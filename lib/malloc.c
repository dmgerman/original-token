multiline_comment|/*&n; * malloc.c --- a general purpose kernel memory allocator for Linux.&n; *&n; * Written by Theodore Ts&squot;o (tytso@mit.edu), 11/29/91&n; *&n; * This routine is written to be as fast as possible, so that it&n; * can be called from the interrupt level.&n; *&n; * Limitations: maximum size of memory we can allocate using this routine&n; *&t;is 4k, the size of a page in Linux.&n; *&n; * The general game plan is that each page (called a bucket) will only hold&n; * objects of a given size.  When all of the object on a page are released,&n; * the page can be returned to the general free pool.  When malloc() is&n; * called, it looks for the smallest bucket size which will fulfill its&n; * request, and allocate a piece of memory from that bucket pool.&n; *&n; * Each bucket has as its control block a bucket descriptor which keeps&n; * track of how many objects are in use on that page, and the free list&n; * for that page.  Like the buckets themselves, bucket descriptors are&n; * stored on pages requested from get_free_page().  However, unlike buckets,&n; * pages devoted to bucket descriptor pages are never released back to the&n; * system.  Fortunately, a system should probably only need 1 or 2 bucket&n; * descriptor pages, since a page can hold 256 bucket descriptors (which&n; * corresponds to 1 megabyte worth of bucket pages.)  If the kernel is using&n; * that much allocated memory, it&squot;s probably doing something wrong.  :-)&n; *&n; * Note: malloc() and free() both call get_free_page() and free_page()&n; *&t;in sections of code where interrupts are turned off, to allow&n; *&t;malloc() and free() to be safely called from an interrupt routine.&n; *&t;(We will probably need this functionality when networking code,&n; *&t;particularily things like NFS, is added to Linux.)  However, this&n; *&t;presumes that get_free_page() and free_page() are interrupt-level&n; *&t;safe, which they may not be once paging is added.  If this is the&n; *&t;case, we will need to modify malloc() to keep a few unused pages&n; *&t;&quot;pre-allocated&quot; so that it can safely draw upon those pages if&n; * &t;it is called from an interrupt routine.&n; *&n; * &t;Another concern is that get_free_page() should not sleep; if it&n; *&t;does, the code is carefully ordered so as to avoid any race&n; *&t;conditions.  The catch is that if malloc() is called re-entrantly,&n; *&t;there is a chance that unecessary pages will be grabbed from the&n; *&t;system.  Except for the pages for the bucket descriptor page, the&n; *&t;extra pages will eventually get released back to the system, though,&n; *&t;so it isn&squot;t all that bad.&n; */
multiline_comment|/* I&squot;m going to modify it to keep some free pages around.  Get free page&n;   can sleep, and tcp/ip needs to call malloc at interrupt time  (Or keep&n;   big buffers around for itself.)  I guess I&squot;ll have return from&n;   syscall fill up the free page descriptors. -RAB */
multiline_comment|/* since the advent of GFP_ATOMIC, I&squot;ve changed the malloc code to&n;   use it and return NULL if it can&squot;t get a page. -RAB */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/system.h&gt;
DECL|struct|bucket_desc
r_struct
id|bucket_desc
(brace
multiline_comment|/* 16 bytes */
DECL|member|page
r_void
op_star
id|page
suffix:semicolon
DECL|member|next
r_struct
id|bucket_desc
op_star
id|next
suffix:semicolon
DECL|member|freeptr
r_void
op_star
id|freeptr
suffix:semicolon
DECL|member|refcnt
r_int
r_int
id|refcnt
suffix:semicolon
DECL|member|bucket_size
r_int
r_int
id|bucket_size
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|_bucket_dir
r_struct
id|_bucket_dir
(brace
multiline_comment|/* 8 bytes */
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|member|chain
r_struct
id|bucket_desc
op_star
id|chain
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * The following is the where we store a pointer to the first bucket&n; * descriptor for a given size.&n; *&n; * If it turns out that the Linux kernel allocates a lot of objects of a&n; * specific size, then we may want to add that specific size to this list,&n; * since that will allow the memory to be allocated more efficiently.&n; * However, since an entire page must be dedicated to each specific size&n; * on this list, some amount of temperance must be exercised here.&n; *&n; * Note that this list *must* be kept in order.&n; */
DECL|variable|bucket_dir
r_struct
id|_bucket_dir
id|bucket_dir
(braket
)braket
op_assign
(brace
(brace
l_int|16
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
comma
(brace
l_int|32
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
comma
(brace
l_int|64
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
comma
(brace
l_int|128
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
comma
(brace
l_int|256
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
comma
(brace
l_int|512
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
comma
(brace
l_int|1024
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
comma
(brace
l_int|2048
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
comma
(brace
l_int|4096
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
comma
(brace
l_int|0
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* End of list marker */
multiline_comment|/*&n; * This contains a linked list of free bucket descriptor blocks&n; */
DECL|variable|free_bucket_desc
r_static
r_struct
id|bucket_desc
op_star
id|free_bucket_desc
op_assign
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
suffix:semicolon
multiline_comment|/*&n; * This routine initializes a bucket description page.&n; */
DECL|function|init_bucket_desc
r_static
r_inline
r_int
id|init_bucket_desc
c_func
(paren
)paren
(brace
r_struct
id|bucket_desc
op_star
id|bdesc
comma
op_star
id|first
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* this turns interrupt on, so we should be carefull. */
id|first
op_assign
id|bdesc
op_assign
(paren
r_struct
id|bucket_desc
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bdesc
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_struct
id|bucket_desc
)paren
suffix:semicolon
id|i
OG
l_int|1
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|bdesc-&gt;next
op_assign
id|bdesc
op_plus
l_int|1
suffix:semicolon
id|bdesc
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This is done last, to avoid race conditions in case&n;&t; * get_free_page() sleeps and this routine gets called again....&n;&t; */
multiline_comment|/* Get free page will not sleep because of the GFP_ATOMIC */
id|bdesc-&gt;next
op_assign
id|free_bucket_desc
suffix:semicolon
id|free_bucket_desc
op_assign
id|first
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|malloc
r_void
op_star
id|malloc
c_func
(paren
r_int
r_int
id|len
)paren
(brace
r_struct
id|_bucket_dir
op_star
id|bdir
suffix:semicolon
r_struct
id|bucket_desc
op_star
id|bdesc
suffix:semicolon
r_void
op_star
id|retval
suffix:semicolon
multiline_comment|/*&n;&t; * First we search the bucket_dir to find the right bucket change&n;&t; * for this request.&n;&t; */
r_for
c_loop
(paren
id|bdir
op_assign
id|bucket_dir
suffix:semicolon
id|bdir-&gt;size
suffix:semicolon
id|bdir
op_increment
)paren
r_if
c_cond
(paren
id|bdir-&gt;size
op_ge
id|len
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bdir-&gt;size
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;malloc called with impossibly large argument (%d)&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now we search for a bucket descriptor which has free space&n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Avoid race conditions */
r_for
c_loop
(paren
id|bdesc
op_assign
id|bdir-&gt;chain
suffix:semicolon
id|bdesc
suffix:semicolon
id|bdesc
op_assign
id|bdesc-&gt;next
)paren
r_if
c_cond
(paren
id|bdesc-&gt;freeptr
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t; * If we didn&squot;t find a bucket with free space, then we&squot;ll&n;&t; * allocate a new one.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|bdesc
)paren
(brace
r_char
op_star
id|cp
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|free_bucket_desc
)paren
r_if
c_cond
(paren
id|init_bucket_desc
c_func
(paren
)paren
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|bdesc
op_assign
id|free_bucket_desc
suffix:semicolon
id|free_bucket_desc
op_assign
id|bdesc-&gt;next
suffix:semicolon
id|bdesc-&gt;refcnt
op_assign
l_int|0
suffix:semicolon
id|bdesc-&gt;bucket_size
op_assign
id|bdir-&gt;size
suffix:semicolon
id|bdesc-&gt;page
op_assign
id|bdesc-&gt;freeptr
op_assign
(paren
r_void
op_star
)paren
id|cp
op_assign
id|get_free_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Set up the chain of free objects */
r_for
c_loop
(paren
id|i
op_assign
id|PAGE_SIZE
op_div
id|bdir-&gt;size
suffix:semicolon
id|i
OG
l_int|1
suffix:semicolon
id|i
op_decrement
)paren
(brace
op_star
(paren
(paren
r_char
op_star
op_star
)paren
id|cp
)paren
op_assign
id|cp
op_plus
id|bdir-&gt;size
suffix:semicolon
id|cp
op_add_assign
id|bdir-&gt;size
suffix:semicolon
)brace
op_star
(paren
(paren
r_char
op_star
op_star
)paren
id|cp
)paren
op_assign
l_int|0
suffix:semicolon
id|bdesc-&gt;next
op_assign
id|bdir-&gt;chain
suffix:semicolon
multiline_comment|/* OK, link it in! */
id|bdir-&gt;chain
op_assign
id|bdesc
suffix:semicolon
)brace
id|retval
op_assign
(paren
r_void
op_star
)paren
id|bdesc-&gt;freeptr
suffix:semicolon
id|bdesc-&gt;freeptr
op_assign
op_star
(paren
(paren
r_void
op_star
op_star
)paren
id|retval
)paren
suffix:semicolon
id|bdesc-&gt;refcnt
op_increment
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* OK, we&squot;re safe again */
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Here is the free routine.  If you know the size of the object that you&n; * are freeing, then free_s() will use that information to speed up the&n; * search for the bucket descriptor.&n; *&n; * We will #define a macro so that &quot;free(x)&quot; is becomes &quot;free_s(x, 0)&quot;&n; */
DECL|function|free_s
r_void
id|free_s
c_func
(paren
r_void
op_star
id|obj
comma
r_int
id|size
)paren
(brace
r_void
op_star
id|page
suffix:semicolon
r_struct
id|_bucket_dir
op_star
id|bdir
suffix:semicolon
r_struct
id|bucket_desc
op_star
id|bdesc
comma
op_star
id|prev
suffix:semicolon
multiline_comment|/* Calculate what page this object lives in */
id|page
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|obj
op_amp
l_int|0xfffff000
)paren
suffix:semicolon
multiline_comment|/* Now search the buckets looking for that page */
r_for
c_loop
(paren
id|bdir
op_assign
id|bucket_dir
suffix:semicolon
id|bdir-&gt;size
suffix:semicolon
id|bdir
op_increment
)paren
(brace
id|prev
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If size is zero then this conditional is always false */
r_if
c_cond
(paren
id|bdir-&gt;size
OL
id|size
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|bdesc
op_assign
id|bdir-&gt;chain
suffix:semicolon
id|bdesc
suffix:semicolon
id|bdesc
op_assign
id|bdesc-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|bdesc-&gt;page
op_eq
id|page
)paren
r_goto
id|found
suffix:semicolon
id|prev
op_assign
id|bdesc
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;Bad address passed to kernel free_s()&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
id|found
suffix:colon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* To avoid race conditions */
op_star
(paren
(paren
r_void
op_star
op_star
)paren
id|obj
)paren
op_assign
id|bdesc-&gt;freeptr
suffix:semicolon
id|bdesc-&gt;freeptr
op_assign
id|obj
suffix:semicolon
id|bdesc-&gt;refcnt
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|bdesc-&gt;refcnt
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * We need to make sure that prev is still accurate.  It&n;&t;&t; * may not be, if someone rudely interrupted us....&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|prev
op_logical_and
(paren
id|prev-&gt;next
op_ne
id|bdesc
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|prev
op_logical_and
(paren
id|bdir-&gt;chain
op_ne
id|bdesc
)paren
)paren
)paren
r_for
c_loop
(paren
id|prev
op_assign
id|bdir-&gt;chain
suffix:semicolon
id|prev
suffix:semicolon
id|prev
op_assign
id|prev-&gt;next
)paren
r_if
c_cond
(paren
id|prev-&gt;next
op_eq
id|bdesc
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;next
op_assign
id|bdesc-&gt;next
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|bdir-&gt;chain
op_ne
id|bdesc
)paren
id|panic
c_func
(paren
l_string|&quot;malloc bucket chains corrupted&quot;
)paren
suffix:semicolon
id|bdir-&gt;chain
op_assign
id|bdesc-&gt;next
suffix:semicolon
)brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|bdesc-&gt;page
)paren
suffix:semicolon
id|bdesc-&gt;next
op_assign
id|free_bucket_desc
suffix:semicolon
id|free_bucket_desc
op_assign
id|bdesc
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
eof
