multiline_comment|/*&n; * malloc.c --- a general purpose kernel memory allocator for Linux.&n; *&n; * Written by Theodore Ts&squot;o (tytso@mit.edu), 11/29/91&n; *&n; * This routine is written to be as fast as possible, so that it&n; * can be called from the interrupt level.&n; *&n; * Limitations: maximum size of memory we can allocate using this routine&n; *&t;is 4k, the size of a page in Linux.&n; *&n; * The general game plan is that each page (called a bucket) will only hold&n; * objects of a given size.  When all of the object on a page are released,&n; * the page can be returned to the general free pool.  When kmalloc() is&n; * called, it looks for the smallest bucket size which will fulfill its&n; * request, and allocate a piece of memory from that bucket pool.&n; *&n; * Each bucket has as its control block a bucket descriptor which keeps&n; * track of how many objects are in use on that page, and the free list&n; * for that page.  Like the buckets themselves, bucket descriptors are&n; * stored on pages requested from get_free_page().  However, unlike buckets,&n; * pages devoted to bucket descriptor pages are never released back to the&n; * system.  Fortunately, a system should probably only need 1 or 2 bucket&n; * descriptor pages, since a page can hold 256 bucket descriptors (which&n; * corresponds to 1 megabyte worth of bucket pages.)  If the kernel is using&n; * that much allocated memory, it&squot;s probably doing something wrong.  :-)&n; *&n; * Note: kmalloc() and kfree() both call get_free_page() and free_page()&n; *&t;in sections of code where interrupts are turned off, to allow&n; *&t;kmalloc() and kfree() to be safely called from an interrupt routine.&n; *&t;(We will probably need this functionality when networking code,&n; *&t;particularily things like NFS, is added to Linux.)  However, this&n; *&t;presumes that get_free_page() and free_page() are interrupt-level&n; *&t;safe, which they may not be once paging is added.  If this is the&n; *&t;case, we will need to modify kmalloc() to keep a few unused pages&n; *&t;&quot;pre-allocated&quot; so that it can safely draw upon those pages if&n; * &t;it is called from an interrupt routine.&n; *&n; * &t;Another concern is that get_free_page() should not sleep; if it&n; *&t;does, the code is carefully ordered so as to avoid any race&n; *&t;conditions.  The catch is that if kmalloc() is called re-entrantly,&n; *&t;there is a chance that unecessary pages will be grabbed from the&n; *&t;system.  Except for the pages for the bucket descriptor page, the&n; *&t;extra pages will eventually get released back to the system, though,&n; *&t;so it isn&squot;t all that bad.&n; */
multiline_comment|/* I&squot;m going to modify it to keep some free pages around.  Get free page&n;   can sleep, and tcp/ip needs to call kmalloc at interrupt time  (Or keep&n;   big buffers around for itself.)  I guess I&squot;ll have return from&n;   syscall fill up the free page descriptors. -RAB */
multiline_comment|/* since the advent of GFP_ATOMIC, I&squot;ve changed the kmalloc code to&n;   use it and return NULL if it can&squot;t get a page. -RAB  */
multiline_comment|/* (mostly just undid the previous changes -RAB) */
multiline_comment|/* I&squot;ve added the priority argument to kmalloc so routines can&n;   sleep on memory if they want. - RAB */
multiline_comment|/* I&squot;ve also got to make sure that kmalloc is reentrant now. */
multiline_comment|/* Debugging support: add file/line info, add beginning+end markers. -M.U- */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/system.h&gt;
DECL|struct|bucket_desc
r_struct
id|bucket_desc
(brace
multiline_comment|/* 16 bytes */
DECL|member|page
r_void
op_star
id|page
suffix:semicolon
DECL|member|next
r_struct
id|bucket_desc
op_star
id|next
suffix:semicolon
DECL|member|freeptr
r_void
op_star
id|freeptr
suffix:semicolon
DECL|member|refcnt
r_int
r_int
id|refcnt
suffix:semicolon
DECL|member|bucket_size
r_int
r_int
id|bucket_size
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|_bucket_dir
r_struct
id|_bucket_dir
(brace
multiline_comment|/* 8 bytes */
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
DECL|member|chain
r_struct
id|bucket_desc
op_star
id|chain
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_MALLOC
DECL|struct|hdr_start
r_struct
id|hdr_start
(brace
DECL|member|file
r_const
r_char
op_star
id|file
suffix:semicolon
DECL|member|ok_file
r_const
r_char
op_star
id|ok_file
suffix:semicolon
DECL|member|line
r_int
r_int
id|line
suffix:semicolon
DECL|member|ok_line
r_int
r_int
id|ok_line
suffix:semicolon
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
DECL|member|magic
r_int
id|magic
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|hdr_end
r_struct
id|hdr_end
(brace
DECL|member|magic
r_int
id|magic
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|DEB_MAGIC_FREE
mdefine_line|#define DEB_MAGIC_FREE  0x13579BDF /* free block */
DECL|macro|DEB_MAGIC_ALLOC
mdefine_line|#define DEB_MAGIC_ALLOC 0x2468ACE0 /* allocated block */
DECL|macro|DEB_MAGIC_USED
mdefine_line|#define DEB_MAGIC_USED  0x147AD036 /* allocated but bad */
DECL|macro|DEB_MAGIC_FREED
mdefine_line|#define DEB_MAGIC_FREED 0x258BE169 /* free but abused */
DECL|macro|DEB_MAGIC_END
mdefine_line|#define DEB_MAGIC_END   0x369CF258 /* end marker */
macro_line|#endif
multiline_comment|/*&n; * The following is the where we store a pointer to the first bucket&n; * descriptor for a given size.&n; *&n; * If it turns out that the Linux kernel allocates a lot of objects of a&n; * specific size, then we may want to add that specific size to this list,&n; * since that will allow the memory to be allocated more efficiently.&n; * However, since an entire page must be dedicated to each specific size&n; * on this list, some amount of temperance must be exercised here.&n; *&n; * Note that this list *must* be kept in order.&n; */
DECL|variable|bucket_dir
r_struct
id|_bucket_dir
id|bucket_dir
(braket
)braket
op_assign
(brace
macro_line|#ifndef CONFIG_DEBUG_MALLOC /* Debug headers have too much overhead */
(brace
l_int|16
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
comma
macro_line|#endif
(brace
l_int|32
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
comma
(brace
l_int|64
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
comma
(brace
l_int|128
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
comma
(brace
l_int|256
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
comma
(brace
l_int|512
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
comma
(brace
l_int|1024
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
comma
(brace
l_int|2048
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
comma
(brace
l_int|4096
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
comma
(brace
l_int|0
comma
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* End of list marker */
multiline_comment|/*&n; * This contains a linked list of free bucket descriptor blocks&n; */
DECL|variable|free_bucket_desc
r_static
r_struct
id|bucket_desc
op_star
id|free_bucket_desc
op_assign
(paren
r_struct
id|bucket_desc
op_star
)paren
l_int|0
suffix:semicolon
multiline_comment|/*&n; * This routine initializes a bucket description page.&n; */
multiline_comment|/* It assumes it is called with interrupts on. and will&n;   return that way.  It also can sleep if priority != GFP_ATOMIC. */
DECL|function|init_bucket_desc
r_static
r_inline
r_void
id|init_bucket_desc
c_func
(paren
r_int
r_int
id|page
)paren
(brace
r_struct
id|bucket_desc
op_star
id|bdesc
suffix:semicolon
r_int
id|i
suffix:semicolon
id|bdesc
op_assign
(paren
r_struct
id|bucket_desc
op_star
)paren
id|page
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_struct
id|bucket_desc
)paren
suffix:semicolon
op_decrement
id|i
OG
l_int|0
suffix:semicolon
id|bdesc
op_increment
)paren
id|bdesc-&gt;next
op_assign
id|bdesc
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * This is done last, to avoid race conditions in case&n;&t; * get_free_page() sleeps and this routine gets called again....&n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|bdesc-&gt;next
op_assign
id|free_bucket_desc
suffix:semicolon
id|free_bucket_desc
op_assign
(paren
r_struct
id|bucket_desc
op_star
)paren
id|page
suffix:semicolon
)brace
multiline_comment|/*&n; * Re-organized some code to give cleaner assembly output for easier&n; * verification.. LBT&n; */
macro_line|#ifdef CONFIG_DEBUG_MALLOC
r_void
op_star
DECL|function|deb_kmalloc
id|deb_kmalloc
c_func
(paren
r_const
r_char
op_star
id|deb_file
comma
r_int
r_int
id|deb_line
comma
r_int
r_int
id|len
comma
r_int
id|priority
)paren
macro_line|#else
r_void
op_star
id|kmalloc
c_func
(paren
r_int
r_int
id|len
comma
r_int
id|priority
)paren
macro_line|#endif
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|page
suffix:semicolon
r_struct
id|_bucket_dir
op_star
id|bdir
suffix:semicolon
r_struct
id|bucket_desc
op_star
id|bdesc
suffix:semicolon
r_void
op_star
id|retval
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_MALLOC
id|len
op_add_assign
r_sizeof
(paren
r_struct
id|hdr_start
)paren
op_plus
r_sizeof
(paren
r_struct
id|hdr_end
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * First we search the bucket_dir to find the right bucket change&n;&t; * for this request.&n;&t; */
multiline_comment|/* The sizes are static so there is no reentry problem here. */
id|bdir
op_assign
id|bucket_dir
suffix:semicolon
r_for
c_loop
(paren
id|bdir
op_assign
id|bucket_dir
suffix:semicolon
id|bdir-&gt;size
OL
id|len
suffix:semicolon
id|bdir
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bdir-&gt;size
)paren
r_goto
id|too_large
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now we search for a bucket descriptor which has free space&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Avoid race conditions */
r_for
c_loop
(paren
id|bdesc
op_assign
id|bdir-&gt;chain
suffix:semicolon
id|bdesc
op_ne
l_int|NULL
suffix:semicolon
id|bdesc
op_assign
id|bdesc-&gt;next
)paren
r_if
c_cond
(paren
id|bdesc-&gt;freeptr
)paren
r_goto
id|found_bdesc
suffix:semicolon
multiline_comment|/*&n;&t; * If we didn&squot;t find a bucket with free space, then we&squot;ll&n;&t; * allocate a new one.&n;&t; */
multiline_comment|/*&n;&t; * Note that init_bucket_descriptor() does its&n;&t; * own cli() before returning, and guarantees that&n;&t; * there is a bucket desc in the page.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|free_bucket_desc
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_assign
id|__get_free_page
c_func
(paren
id|priority
)paren
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|init_bucket_desc
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|bdesc
op_assign
id|free_bucket_desc
suffix:semicolon
id|free_bucket_desc
op_assign
id|bdesc-&gt;next
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_assign
id|__get_free_page
c_func
(paren
id|priority
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t; * Out of memory? Put the bucket descriptor back on the free list&n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|bdesc-&gt;next
op_assign
id|free_bucket_desc
suffix:semicolon
id|free_bucket_desc
op_assign
id|bdesc
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|bdesc-&gt;refcnt
op_assign
l_int|0
suffix:semicolon
id|bdesc-&gt;bucket_size
op_assign
id|bdir-&gt;size
suffix:semicolon
id|bdesc-&gt;page
op_assign
id|bdesc-&gt;freeptr
op_assign
(paren
r_void
op_star
)paren
id|page
suffix:semicolon
multiline_comment|/* Set up the chain of free objects */
r_for
c_loop
(paren
id|i
op_assign
id|PAGE_SIZE
op_div
id|bdir-&gt;size
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_MALLOC
r_struct
id|hdr_start
op_star
id|hd
suffix:semicolon
r_struct
id|hdr_end
op_star
id|he
suffix:semicolon
id|hd
op_assign
(paren
r_struct
id|hdr_start
op_star
)paren
id|page
suffix:semicolon
id|he
op_assign
(paren
r_struct
id|hdr_end
op_star
)paren
(paren
id|page
op_plus
(paren
id|bdir-&gt;size
op_minus
r_sizeof
(paren
r_struct
id|hdr_end
)paren
)paren
)paren
suffix:semicolon
id|hd-&gt;magic
op_assign
id|DEB_MAGIC_FREE
suffix:semicolon
id|hd-&gt;file
op_assign
id|hd-&gt;ok_file
op_assign
l_string|&quot;(expand)&quot;
suffix:semicolon
id|hd-&gt;line
op_assign
id|hd-&gt;ok_line
op_assign
l_int|0
suffix:semicolon
id|hd-&gt;size
op_assign
id|bdir-&gt;size
op_minus
r_sizeof
(paren
r_struct
id|hdr_start
)paren
op_minus
r_sizeof
(paren
r_struct
id|hdr_end
)paren
suffix:semicolon
id|he-&gt;magic
op_assign
id|DEB_MAGIC_END
suffix:semicolon
id|memset
c_func
(paren
id|hd
op_plus
l_int|1
comma
l_int|0xF8
comma
id|hd-&gt;size
)paren
suffix:semicolon
op_star
(paren
(paren
r_void
op_star
op_star
)paren
(paren
id|hd
op_plus
l_int|1
)paren
)paren
op_assign
(paren
id|i
op_eq
l_int|1
)paren
ques
c_cond
l_int|NULL
suffix:colon
(paren
r_void
op_star
)paren
(paren
id|page
op_plus
id|bdir-&gt;size
)paren
suffix:semicolon
macro_line|#else
op_star
(paren
(paren
r_void
op_star
op_star
)paren
id|page
)paren
op_assign
(paren
id|i
op_eq
l_int|1
)paren
ques
c_cond
l_int|NULL
suffix:colon
(paren
r_void
op_star
)paren
(paren
id|page
op_plus
id|bdir-&gt;size
)paren
suffix:semicolon
macro_line|#endif
id|page
op_add_assign
id|bdir-&gt;size
suffix:semicolon
)brace
multiline_comment|/* turn interrupts back off for putting the&n;&t;   thing onto the chain. */
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* remember bdir is not changed. */
id|bdesc-&gt;next
op_assign
id|bdir-&gt;chain
suffix:semicolon
multiline_comment|/* OK, link it in! */
id|bdir-&gt;chain
op_assign
id|bdesc
suffix:semicolon
id|found_bdesc
suffix:colon
id|retval
op_assign
(paren
r_void
op_star
)paren
id|bdesc-&gt;freeptr
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_MALLOC
id|bdesc-&gt;freeptr
op_assign
op_star
(paren
(paren
r_void
op_star
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|retval
)paren
op_plus
r_sizeof
(paren
r_struct
id|hdr_start
)paren
)paren
)paren
suffix:semicolon
macro_line|#else
id|bdesc-&gt;freeptr
op_assign
op_star
(paren
(paren
r_void
op_star
op_star
)paren
id|retval
)paren
suffix:semicolon
macro_line|#endif
id|bdesc-&gt;refcnt
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* OK, we&squot;re safe again */
macro_line|#ifdef CONFIG_DEBUG_MALLOC
(brace
r_struct
id|hdr_start
op_star
id|hd
suffix:semicolon
r_struct
id|hdr_end
op_star
id|he
suffix:semicolon
id|hd
op_assign
(paren
r_struct
id|hdr_start
op_star
)paren
id|retval
suffix:semicolon
id|retval
op_assign
id|hd
op_plus
l_int|1
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
r_struct
id|hdr_start
)paren
op_plus
r_sizeof
(paren
r_struct
id|hdr_end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;magic
op_ne
id|DEB_MAGIC_FREE
op_logical_and
id|hd-&gt;magic
op_ne
id|DEB_MAGIC_FREED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DEB_MALLOC allocating %s block 0x%x (head 0x%x) from %s:%d, magic %x&bslash;n&quot;
comma
(paren
id|hd-&gt;magic
op_eq
id|DEB_MAGIC_ALLOC
)paren
ques
c_cond
l_string|&quot;nonfree&quot;
suffix:colon
l_string|&quot;trashed&quot;
comma
id|retval
comma
id|hd
comma
id|deb_file
comma
id|deb_line
comma
id|hd-&gt;magic
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
id|hd-&gt;size
op_logical_or
id|len
OG
id|bdir-&gt;size
op_minus
r_sizeof
(paren
r_struct
id|hdr_start
)paren
op_minus
r_sizeof
(paren
r_struct
id|hdr_end
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DEB_MALLOC got %x:%x-byte block, wanted %x, from %s:%d, last %s:%d&bslash;n&quot;
comma
id|hd-&gt;size
comma
id|bdir-&gt;size
comma
id|len
comma
id|hd-&gt;file
comma
id|hd-&gt;line
comma
id|deb_file
comma
id|deb_line
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
(brace
r_int
r_char
op_star
id|x
op_assign
(paren
r_int
r_char
op_star
)paren
id|retval
suffix:semicolon
r_int
r_int
id|pos
op_assign
l_int|4
suffix:semicolon
id|x
op_add_assign
id|pos
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
id|hd-&gt;size
)paren
(brace
r_if
c_cond
(paren
op_star
id|x
op_increment
op_ne
l_int|0xF8
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DEB_MALLOC used 0x%x:%x(%x) while free, from %s:%d&bslash;n&quot;
comma
id|retval
comma
id|pos
comma
id|hd-&gt;size
comma
id|hd-&gt;file
comma
id|hd-&gt;line
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|pos
op_increment
suffix:semicolon
)brace
)brace
id|he
op_assign
(paren
r_struct
id|hdr_end
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|retval
)paren
op_plus
id|hd-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|he-&gt;magic
op_ne
id|DEB_MAGIC_END
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DEB_MALLOC overran 0x%x:%d while free, from %s:%d&bslash;n&quot;
comma
id|retval
comma
id|hd-&gt;size
comma
id|hd-&gt;file
comma
id|hd-&gt;line
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|retval
comma
l_int|0xf0
comma
id|len
)paren
suffix:semicolon
id|he
op_assign
(paren
r_struct
id|hdr_end
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|retval
)paren
op_plus
id|len
)paren
suffix:semicolon
id|hd-&gt;file
op_assign
id|hd-&gt;ok_file
op_assign
id|deb_file
suffix:semicolon
id|hd-&gt;line
op_assign
id|hd-&gt;ok_line
op_assign
id|deb_line
suffix:semicolon
id|hd-&gt;size
op_assign
id|len
suffix:semicolon
id|hd-&gt;magic
op_assign
id|DEB_MAGIC_ALLOC
suffix:semicolon
id|he-&gt;magic
op_assign
id|DEB_MAGIC_END
suffix:semicolon
)brace
macro_line|#endif
r_return
id|retval
suffix:semicolon
id|too_large
suffix:colon
multiline_comment|/* This should be changed for sizes &gt; 1 page. */
id|printk
c_func
(paren
l_string|&quot;kmalloc called with impossibly large argument (%d)&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_DEBUG_MALLOC
DECL|function|deb_kcheck_s
r_void
id|deb_kcheck_s
c_func
(paren
r_const
r_char
op_star
id|deb_file
comma
r_int
r_int
id|deb_line
comma
r_void
op_star
id|obj
comma
r_int
id|size
)paren
(brace
r_struct
id|hdr_start
op_star
id|hd
suffix:semicolon
r_struct
id|hdr_end
op_star
id|he
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
r_return
suffix:semicolon
id|hd
op_assign
(paren
r_struct
id|hdr_start
op_star
)paren
id|obj
suffix:semicolon
id|hd
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;magic
op_ne
id|DEB_MAGIC_ALLOC
)paren
(brace
r_if
c_cond
(paren
id|hd-&gt;magic
op_eq
id|DEB_MAGIC_FREE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DEB_MALLOC Using free block of 0x%x at %s:%d, by %s:%d, wasOK %s:%d&bslash;n&quot;
comma
id|obj
comma
id|deb_file
comma
id|deb_line
comma
id|hd-&gt;file
comma
id|hd-&gt;line
comma
id|hd-&gt;ok_file
comma
id|hd-&gt;ok_line
)paren
suffix:semicolon
multiline_comment|/* For any other condition it is either superfluous or dangerous to print something. */
id|hd-&gt;magic
op_assign
id|DEB_MAGIC_FREED
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hd-&gt;size
op_ne
id|size
)paren
(brace
r_if
c_cond
(paren
id|size
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DEB_MALLOC size for 0x%x given as %d, stored %d, at %s:%d, wasOK %s:%d&bslash;n&quot;
comma
id|obj
comma
id|size
comma
id|hd-&gt;size
comma
id|deb_file
comma
id|deb_line
comma
id|hd-&gt;ok_file
comma
id|hd-&gt;ok_line
)paren
suffix:semicolon
)brace
id|size
op_assign
id|hd-&gt;size
suffix:semicolon
)brace
id|he
op_assign
(paren
r_struct
id|hdr_end
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|obj
)paren
op_plus
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|he-&gt;magic
op_ne
id|DEB_MAGIC_END
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DEB_MALLOC overran block 0x%x:%d, at %s:%d, wasOK %s:%d&bslash;n&quot;
comma
id|obj
comma
id|hd-&gt;size
comma
id|deb_file
comma
id|deb_line
comma
id|hd-&gt;ok_file
comma
id|hd-&gt;ok_line
)paren
suffix:semicolon
id|hd-&gt;magic
op_assign
id|DEB_MAGIC_USED
suffix:semicolon
r_return
suffix:semicolon
)brace
id|hd-&gt;ok_file
op_assign
id|deb_file
suffix:semicolon
id|hd-&gt;ok_line
op_assign
id|deb_line
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Here is the kfree routine.  If you know the size of the object that you&n; * are freeing, then kfree_s() will use that information to speed up the&n; * search for the bucket descriptor.&n; *&n; * We will #define a macro so that &quot;kfree(x)&quot; is becomes &quot;kfree_s(x, 0)&quot;&n; */
macro_line|#ifdef CONFIG_DEBUG_MALLOC
DECL|function|deb_kfree_s
r_void
id|deb_kfree_s
c_func
(paren
r_const
r_char
op_star
id|deb_file
comma
r_int
r_int
id|deb_line
comma
r_void
op_star
id|obj
comma
r_int
id|size
)paren
macro_line|#else
r_void
id|kfree_s
c_func
(paren
r_void
op_star
id|obj
comma
r_int
id|size
)paren
macro_line|#endif
(brace
r_int
r_int
id|flags
suffix:semicolon
r_void
op_star
id|page
suffix:semicolon
r_struct
id|_bucket_dir
op_star
id|bdir
suffix:semicolon
r_struct
id|bucket_desc
op_star
id|bdesc
comma
op_star
id|prev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
r_return
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_MALLOC
(brace
r_struct
id|hdr_start
op_star
id|hd
suffix:semicolon
r_struct
id|hdr_end
op_star
id|he
suffix:semicolon
id|hd
op_assign
(paren
r_struct
id|hdr_start
op_star
)paren
id|obj
suffix:semicolon
id|hd
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;magic
op_eq
id|DEB_MAGIC_FREE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DEB_MALLOC dup free of 0x%x at %s:%d by %s:%d, wasOK %s:%d&bslash;n&quot;
comma
id|obj
comma
id|deb_file
comma
id|deb_line
comma
id|hd-&gt;file
comma
id|hd-&gt;line
comma
id|hd-&gt;ok_file
comma
id|hd-&gt;ok_line
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hd-&gt;size
op_ne
id|size
)paren
(brace
r_if
c_cond
(paren
id|size
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|hd-&gt;magic
op_ne
id|DEB_MAGIC_USED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DEB_MALLOC size for 0x%x given as %d, stored %d, at %s:%d, wasOK %s:%d&bslash;n&quot;
comma
id|obj
comma
id|size
comma
id|hd-&gt;size
comma
id|deb_file
comma
id|deb_line
comma
id|hd-&gt;ok_file
comma
id|hd-&gt;ok_line
)paren
suffix:semicolon
)brace
)brace
id|size
op_assign
id|hd-&gt;size
suffix:semicolon
)brace
id|he
op_assign
(paren
r_struct
id|hdr_end
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|obj
)paren
op_plus
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|he-&gt;magic
op_ne
id|DEB_MAGIC_END
)paren
(brace
r_if
c_cond
(paren
id|hd-&gt;magic
op_ne
id|DEB_MAGIC_USED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DEB_MALLOC overran block 0x%x:%d, at %s:%d, from %s:%d, wasOK %s:%d&bslash;n&quot;
comma
id|obj
comma
id|hd-&gt;size
comma
id|deb_file
comma
id|deb_line
comma
id|hd-&gt;file
comma
id|hd-&gt;line
comma
id|hd-&gt;ok_file
comma
id|hd-&gt;ok_line
)paren
suffix:semicolon
)brace
)brace
id|size
op_add_assign
r_sizeof
(paren
r_struct
id|hdr_start
)paren
op_plus
r_sizeof
(paren
r_struct
id|hdr_end
)paren
suffix:semicolon
)brace
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Calculate what page this object lives in */
id|page
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|obj
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
multiline_comment|/* Now search the buckets looking for that page */
r_for
c_loop
(paren
id|bdir
op_assign
id|bucket_dir
suffix:semicolon
id|bdir-&gt;size
suffix:semicolon
id|bdir
op_increment
)paren
(brace
id|prev
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If size is zero then this conditional is always true */
r_if
c_cond
(paren
id|bdir-&gt;size
op_ge
id|size
)paren
(brace
multiline_comment|/* We have to turn off interrupts here because&n;&t;&t;   we are descending the chain.  If something&n;&t;&t;   changes it in the middle we could suddenly&n;&t;&t;   find ourselves descending the free list.&n;&t;&t;   I think this would only cause a memory&n;&t;&t;   leak, but better safe than sorry. */
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* To avoid race conditions */
r_for
c_loop
(paren
id|bdesc
op_assign
id|bdir-&gt;chain
suffix:semicolon
id|bdesc
suffix:semicolon
id|bdesc
op_assign
id|bdesc-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|bdesc-&gt;page
op_eq
id|page
)paren
r_goto
id|found
suffix:semicolon
id|prev
op_assign
id|bdesc
suffix:semicolon
)brace
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Bad address passed to kernel kfree_s(%p, %d)&bslash;n&quot;
comma
id|obj
comma
id|size
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_MALLOC
id|printk
c_func
(paren
l_string|&quot;Offending code: %s:%d&bslash;n&quot;
comma
id|deb_file
comma
id|deb_line
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;Offending eip: %08x&bslash;n&quot;
comma
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|obj
)paren
(braket
op_minus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
id|found
suffix:colon
multiline_comment|/* interrupts are off here. */
macro_line|#ifdef CONFIG_DEBUG_MALLOC
(brace
r_struct
id|hdr_start
op_star
id|hd
suffix:semicolon
r_struct
id|hdr_end
op_star
id|he
suffix:semicolon
id|hd
op_assign
(paren
r_struct
id|hdr_start
op_star
)paren
id|obj
suffix:semicolon
id|hd
op_decrement
suffix:semicolon
id|hd-&gt;file
op_assign
id|deb_file
suffix:semicolon
id|hd-&gt;line
op_assign
id|deb_line
suffix:semicolon
id|hd-&gt;magic
op_assign
id|DEB_MAGIC_FREE
suffix:semicolon
id|hd-&gt;size
op_assign
id|bdir-&gt;size
op_minus
r_sizeof
(paren
r_struct
id|hdr_start
)paren
op_minus
r_sizeof
(paren
r_struct
id|hdr_end
)paren
suffix:semicolon
id|he
op_assign
(paren
r_struct
id|hdr_end
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|obj
)paren
op_plus
id|hd-&gt;size
)paren
suffix:semicolon
id|memset
c_func
(paren
id|obj
comma
l_int|0xf8
comma
id|hd-&gt;size
)paren
suffix:semicolon
id|he-&gt;magic
op_assign
id|DEB_MAGIC_END
suffix:semicolon
op_star
(paren
(paren
r_void
op_star
op_star
)paren
id|obj
)paren
op_assign
id|bdesc-&gt;freeptr
suffix:semicolon
id|obj
op_assign
id|hd
suffix:semicolon
)brace
macro_line|#else
op_star
(paren
(paren
r_void
op_star
op_star
)paren
id|obj
)paren
op_assign
id|bdesc-&gt;freeptr
suffix:semicolon
macro_line|#endif
id|bdesc-&gt;freeptr
op_assign
id|obj
suffix:semicolon
id|bdesc-&gt;refcnt
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|bdesc-&gt;refcnt
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * We need to make sure that prev is still accurate.  It&n;&t;&t; * may not be, if someone rudely interrupted us....&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|prev
op_logical_and
(paren
id|prev-&gt;next
op_ne
id|bdesc
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|prev
op_logical_and
(paren
id|bdir-&gt;chain
op_ne
id|bdesc
)paren
)paren
)paren
r_for
c_loop
(paren
id|prev
op_assign
id|bdir-&gt;chain
suffix:semicolon
id|prev
suffix:semicolon
id|prev
op_assign
id|prev-&gt;next
)paren
r_if
c_cond
(paren
id|prev-&gt;next
op_eq
id|bdesc
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;next
op_assign
id|bdesc-&gt;next
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|bdir-&gt;chain
op_ne
id|bdesc
)paren
id|panic
c_func
(paren
l_string|&quot;kmalloc bucket chains corrupted&quot;
)paren
suffix:semicolon
id|bdir-&gt;chain
op_assign
id|bdesc-&gt;next
suffix:semicolon
)brace
id|bdesc-&gt;next
op_assign
id|free_bucket_desc
suffix:semicolon
id|free_bucket_desc
op_assign
id|bdesc
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|bdesc-&gt;page
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_DEBUG_MALLOC
DECL|function|get_malloc
r_int
id|get_malloc
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_void
op_star
id|page
suffix:semicolon
r_struct
id|_bucket_dir
op_star
id|bdir
suffix:semicolon
r_struct
id|bucket_desc
op_star
id|bdesc
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* To avoid race conditions */
r_for
c_loop
(paren
id|bdir
op_assign
id|bucket_dir
suffix:semicolon
id|bdir-&gt;size
suffix:semicolon
id|bdir
op_increment
)paren
(brace
r_for
c_loop
(paren
id|bdesc
op_assign
id|bdir-&gt;chain
suffix:semicolon
id|bdesc
suffix:semicolon
id|bdesc
op_assign
id|bdesc-&gt;next
)paren
(brace
id|page
op_assign
id|bdesc-&gt;page
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|PAGE_SIZE
op_div
id|bdir-&gt;size
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_struct
id|hdr_start
op_star
id|hd
suffix:semicolon
id|hd
op_assign
(paren
r_struct
id|hdr_start
op_star
)paren
id|page
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;magic
op_eq
id|DEB_MAGIC_ALLOC
)paren
(brace
r_if
c_cond
(paren
id|len
OG
id|PAGE_SIZE
op_minus
l_int|80
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;...&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%08x:%03x %s:%d %s:%d&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|page
op_plus
r_sizeof
(paren
r_struct
id|hdr_start
)paren
)paren
comma
id|hd-&gt;size
comma
id|hd-&gt;file
comma
id|hd-&gt;line
comma
id|hd-&gt;ok_file
comma
id|hd-&gt;ok_line
)paren
suffix:semicolon
)brace
id|page
op_add_assign
id|bdir-&gt;size
suffix:semicolon
)brace
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif
eof
