DECL|macro|DEBG
mdefine_line|#define DEBG(x)
DECL|macro|DEBG1
mdefine_line|#define DEBG1(x)
multiline_comment|/* inflate.c -- Not copyrighted 1992 by Mark Adler&n;   version c10p1, 10 January 1993 */
multiline_comment|/* &n; * Adapted for booting Linux by Hannu Savolainen 1993&n; * based on gzip-1.0.3 &n; *&n; * Nicolas Pitre &lt;nico@cam.org&gt;, 1999/04/14 :&n; *   Little mods for all variable to reside either into rodata or bss segments&n; *   by marking constant variables with &squot;const&squot; and initializing all the others&n; *   at run-time only.  This allows for the kernel uncompressor to run&n; *   directly from Flash or ROM memory on embeded systems.&n; */
multiline_comment|/*&n;   Inflate deflated (PKZIP&squot;s method 8 compressed) data.  The compression&n;   method searches for as much of the current string of bytes (up to a&n;   length of 258) in the previous 32 K bytes.  If it doesn&squot;t find any&n;   matches (of at least length 3), it codes the next byte.  Otherwise, it&n;   codes the length of the matched string and its distance backwards from&n;   the current position.  There is a single Huffman code that codes both&n;   single bytes (called &quot;literals&quot;) and match lengths.  A second Huffman&n;   code codes the distance information, which follows a length code.  Each&n;   length or distance code actually represents a base value and a number&n;   of &quot;extra&quot; (sometimes zero) bits to get to add to the base value.  At&n;   the end of each deflated block is a special end-of-block (EOB) literal/&n;   length code.  The decoding process is basically: get a literal/length&n;   code; if EOB then done; if a literal, emit the decoded byte; if a&n;   length then get the distance and emit the referred-to bytes from the&n;   sliding window of previously emitted data.&n;&n;   There are (currently) three kinds of inflate blocks: stored, fixed, and&n;   dynamic.  The compressor deals with some chunk of data at a time, and&n;   decides which method to use on a chunk-by-chunk basis.  A chunk might&n;   typically be 32 K or 64 K.  If the chunk is incompressible, then the&n;   &quot;stored&quot; method is used.  In this case, the bytes are simply stored as&n;   is, eight bits per byte, with none of the above coding.  The bytes are&n;   preceded by a count, since there is no longer an EOB code.&n;&n;   If the data is compressible, then either the fixed or dynamic methods&n;   are used.  In the dynamic method, the compressed data is preceded by&n;   an encoding of the literal/length and distance Huffman codes that are&n;   to be used to decode this block.  The representation is itself Huffman&n;   coded, and so is preceded by a description of that code.  These code&n;   descriptions take up a little space, and so for small blocks, there is&n;   a predefined set of codes, called the fixed codes.  The fixed method is&n;   used if the block codes up smaller that way (usually for quite small&n;   chunks), otherwise the dynamic method is used.  In the latter case, the&n;   codes are customized to the probabilities in the current block, and so&n;   can code it much better than the pre-determined fixed codes.&n; &n;   The Huffman codes themselves are decoded using a multi-level table&n;   lookup, in order to maximize the speed of decoding plus the speed of&n;   building the decoding tables.  See the comments below that precede the&n;   lbits and dbits tuning parameters.&n; */
multiline_comment|/*&n;   Notes beyond the 1.93a appnote.txt:&n;&n;   1. Distance pointers never point before the beginning of the output&n;      stream.&n;   2. Distance pointers can point back across blocks, up to 32k away.&n;   3. There is an implied maximum of 7 bits for the bit length table and&n;      15 bits for the actual data.&n;   4. If only one code exists, then it is encoded using one bit.  (Zero&n;      would be more efficient, but perhaps a little confusing.)  If two&n;      codes exist, they are coded using one bit each (0 and 1).&n;   5. There is no way of sending zero distance codes--a dummy must be&n;      sent if there are none.  (History: a pre 2.0 version of PKZIP would&n;      store blocks with no distance codes, but this was discovered to be&n;      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow&n;      zero distance codes, which is sent as one code of zero bits in&n;      length.&n;   6. There are up to 286 literal/length codes.  Code 256 represents the&n;      end-of-block.  Note however that the static length tree defines&n;      288 codes just to fill out the Huffman codes.  Codes 286 and 287&n;      cannot be used though, since there is no length base or extra bits&n;      defined for them.  Similarly, there are up to 30 distance codes.&n;      However, static trees define 32 codes (all 5 bits) to fill out the&n;      Huffman codes, but the last two had better not show up in the data.&n;   7. Unzip can check dynamic Huffman blocks for complete code sets.&n;      The exception is that a single code would not be complete (see #4).&n;   8. The five bits following the block type is really the number of&n;      literal codes sent minus 257.&n;   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits&n;      (1+6+6).  Therefore, to output three times the length, you output&n;      three codes (1+1+1), whereas to output four times the same length,&n;      you only need two codes (1+3).  Hmm.&n;  10. In the tree reconstruction algorithm, Code = Code + Increment&n;      only if BitLength(i) is not zero.  (Pretty obvious.)&n;  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)&n;  12. Note: length code 284 can represent 227-258, but length code 285&n;      really is 258.  The last length deserves its own, short code&n;      since it gets used a lot in very redundant files.  The length&n;      258 is special since 258 - 3 (the min match length) is 255.&n;  13. The literal/length and distance code bit lengths are read as a&n;      single stream of lengths.  It is possible (and advantageous) for&n;      a repeat code (16, 17, or 18) to go across the boundary between&n;      the two sets of lengths.&n; */
macro_line|#ifdef RCSID
DECL|variable|rcsid
r_static
r_char
id|rcsid
(braket
)braket
op_assign
l_string|&quot;#Id: inflate.c,v 0.14 1993/06/10 13:27:04 jloup Exp #&quot;
suffix:semicolon
macro_line|#endif
macro_line|#ifndef STATIC
macro_line|#if defined(STDC_HEADERS) || defined(HAVE_STDLIB_H)
macro_line|#  include &lt;sys/types.h&gt;
macro_line|#  include &lt;stdlib.h&gt;
macro_line|#endif
macro_line|#include &quot;gzip.h&quot;
DECL|macro|STATIC
mdefine_line|#define STATIC
macro_line|#endif /* !STATIC */
DECL|macro|slide
mdefine_line|#define slide window
multiline_comment|/* Huffman code lookup table entry--this entry is four bytes for machines&n;   that have 16-bit pointers (e.g. PC&squot;s in the small or medium model).&n;   Valid extra bits are 0..13.  e == 15 is EOB (end of block), e == 16&n;   means that v is a literal, 16 &lt; e &lt; 32 means that v is a pointer to&n;   the next table, which codes e - 16 bits, and lastly e == 99 indicates&n;   an unused code.  If a code with e == 99 is looked up, this implies an&n;   error in the data. */
DECL|struct|huft
r_struct
id|huft
(brace
DECL|member|e
id|uch
id|e
suffix:semicolon
multiline_comment|/* number of extra bits or operation */
DECL|member|b
id|uch
id|b
suffix:semicolon
multiline_comment|/* number of bits in this code or subcode */
r_union
(brace
DECL|member|n
id|ush
id|n
suffix:semicolon
multiline_comment|/* literal, length base, or distance base */
DECL|member|t
r_struct
id|huft
op_star
id|t
suffix:semicolon
multiline_comment|/* pointer to next level of table */
DECL|member|v
)brace
id|v
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Function prototypes */
id|STATIC
r_int
id|huft_build
id|OF
c_func
(paren
(paren
r_int
op_star
comma
r_int
comma
r_int
comma
r_const
id|ush
op_star
comma
r_const
id|ush
op_star
comma
r_struct
id|huft
op_star
op_star
comma
r_int
op_star
)paren
)paren
suffix:semicolon
id|STATIC
r_int
id|huft_free
id|OF
c_func
(paren
(paren
r_struct
id|huft
op_star
)paren
)paren
suffix:semicolon
id|STATIC
r_int
id|inflate_codes
id|OF
c_func
(paren
(paren
r_struct
id|huft
op_star
comma
r_struct
id|huft
op_star
comma
r_int
comma
r_int
)paren
)paren
suffix:semicolon
id|STATIC
r_int
id|inflate_stored
id|OF
c_func
(paren
(paren
r_void
)paren
)paren
suffix:semicolon
id|STATIC
r_int
id|inflate_fixed
id|OF
c_func
(paren
(paren
r_void
)paren
)paren
suffix:semicolon
id|STATIC
r_int
id|inflate_dynamic
id|OF
c_func
(paren
(paren
r_void
)paren
)paren
suffix:semicolon
id|STATIC
r_int
id|inflate_block
id|OF
c_func
(paren
(paren
r_int
op_star
)paren
)paren
suffix:semicolon
id|STATIC
r_int
id|inflate
id|OF
c_func
(paren
(paren
r_void
)paren
)paren
suffix:semicolon
multiline_comment|/* The inflate algorithm uses a sliding 32 K byte window on the uncompressed&n;   stream to find repeated byte strings.  This is implemented here as a&n;   circular buffer.  The index is updated simply by incrementing and then&n;   ANDing with 0x7fff (32K-1). */
multiline_comment|/* It is left to other modules to supply the 32 K area.  It is assumed&n;   to be usable as if it were declared &quot;uch slide[32768];&quot; or as just&n;   &quot;uch *slide;&quot; and then malloc&squot;ed in the latter case.  The definition&n;   must be in unzip.h, included above. */
multiline_comment|/* unsigned wp;             current position in slide */
DECL|macro|wp
mdefine_line|#define wp outcnt
DECL|macro|flush_output
mdefine_line|#define flush_output(w) (wp=(w),flush_window())
multiline_comment|/* Tables for deflate from PKZIP&squot;s appnote.txt. */
DECL|variable|border
r_static
r_const
r_int
id|border
(braket
)braket
op_assign
(brace
multiline_comment|/* Order of the bit length code lengths */
l_int|16
comma
l_int|17
comma
l_int|18
comma
l_int|0
comma
l_int|8
comma
l_int|7
comma
l_int|9
comma
l_int|6
comma
l_int|10
comma
l_int|5
comma
l_int|11
comma
l_int|4
comma
l_int|12
comma
l_int|3
comma
l_int|13
comma
l_int|2
comma
l_int|14
comma
l_int|1
comma
l_int|15
)brace
suffix:semicolon
DECL|variable|cplens
r_static
r_const
id|ush
id|cplens
(braket
)braket
op_assign
(brace
multiline_comment|/* Copy lengths for literal codes 257..285 */
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|6
comma
l_int|7
comma
l_int|8
comma
l_int|9
comma
l_int|10
comma
l_int|11
comma
l_int|13
comma
l_int|15
comma
l_int|17
comma
l_int|19
comma
l_int|23
comma
l_int|27
comma
l_int|31
comma
l_int|35
comma
l_int|43
comma
l_int|51
comma
l_int|59
comma
l_int|67
comma
l_int|83
comma
l_int|99
comma
l_int|115
comma
l_int|131
comma
l_int|163
comma
l_int|195
comma
l_int|227
comma
l_int|258
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* note: see note #13 above about the 258 in this list. */
DECL|variable|cplext
r_static
r_const
id|ush
id|cplext
(braket
)braket
op_assign
(brace
multiline_comment|/* Extra bits for literal codes 257..285 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|0
comma
l_int|99
comma
l_int|99
)brace
suffix:semicolon
multiline_comment|/* 99==invalid */
DECL|variable|cpdist
r_static
r_const
id|ush
id|cpdist
(braket
)braket
op_assign
(brace
multiline_comment|/* Copy offsets for distance codes 0..29 */
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|7
comma
l_int|9
comma
l_int|13
comma
l_int|17
comma
l_int|25
comma
l_int|33
comma
l_int|49
comma
l_int|65
comma
l_int|97
comma
l_int|129
comma
l_int|193
comma
l_int|257
comma
l_int|385
comma
l_int|513
comma
l_int|769
comma
l_int|1025
comma
l_int|1537
comma
l_int|2049
comma
l_int|3073
comma
l_int|4097
comma
l_int|6145
comma
l_int|8193
comma
l_int|12289
comma
l_int|16385
comma
l_int|24577
)brace
suffix:semicolon
DECL|variable|cpdext
r_static
r_const
id|ush
id|cpdext
(braket
)braket
op_assign
(brace
multiline_comment|/* Extra bits for distance codes */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|3
comma
l_int|3
comma
l_int|4
comma
l_int|4
comma
l_int|5
comma
l_int|5
comma
l_int|6
comma
l_int|6
comma
l_int|7
comma
l_int|7
comma
l_int|8
comma
l_int|8
comma
l_int|9
comma
l_int|9
comma
l_int|10
comma
l_int|10
comma
l_int|11
comma
l_int|11
comma
l_int|12
comma
l_int|12
comma
l_int|13
comma
l_int|13
)brace
suffix:semicolon
multiline_comment|/* Macros for inflate() bit peeking and grabbing.&n;   The usage is:&n;   &n;        NEEDBITS(j)&n;        x = b &amp; mask_bits[j];&n;        DUMPBITS(j)&n;&n;   where NEEDBITS makes sure that b has at least j bits in it, and&n;   DUMPBITS removes the bits from b.  The macros use the variable k&n;   for the number of bits in b.  Normally, b and k are register&n;   variables for speed, and are initialized at the beginning of a&n;   routine that uses these macros from a global bit buffer and count.&n;&n;   If we assume that EOB will be the longest code, then we will never&n;   ask for bits with NEEDBITS that are beyond the end of the stream.&n;   So, NEEDBITS should not read any more bytes than are needed to&n;   meet the request.  Then no bytes need to be &quot;returned&quot; to the buffer&n;   at the end of the last block.&n;&n;   However, this assumption is not true for fixed blocks--the EOB code&n;   is 7 bits, but the other literal/length codes can be 8 or 9 bits.&n;   (The EOB code is shorter than other codes because fixed blocks are&n;   generally short.  So, while a block always has an EOB, many other&n;   literal/length codes have a significantly lower probability of&n;   showing up at all.)  However, by making the first table have a&n;   lookup of seven bits, the EOB code will be found in that first&n;   lookup, and so will not require that too many bits be pulled from&n;   the stream.&n; */
DECL|variable|bb
id|STATIC
id|ulg
id|bb
suffix:semicolon
multiline_comment|/* bit buffer */
DECL|variable|bk
id|STATIC
r_int
id|bk
suffix:semicolon
multiline_comment|/* bits in bit buffer */
DECL|variable|mask_bits
id|STATIC
r_const
id|ush
id|mask_bits
(braket
)braket
op_assign
(brace
l_int|0x0000
comma
l_int|0x0001
comma
l_int|0x0003
comma
l_int|0x0007
comma
l_int|0x000f
comma
l_int|0x001f
comma
l_int|0x003f
comma
l_int|0x007f
comma
l_int|0x00ff
comma
l_int|0x01ff
comma
l_int|0x03ff
comma
l_int|0x07ff
comma
l_int|0x0fff
comma
l_int|0x1fff
comma
l_int|0x3fff
comma
l_int|0x7fff
comma
l_int|0xffff
)brace
suffix:semicolon
DECL|macro|NEXTBYTE
mdefine_line|#define NEXTBYTE()  (uch)get_byte()
DECL|macro|NEEDBITS
mdefine_line|#define NEEDBITS(n) {while(k&lt;(n)){b|=((ulg)NEXTBYTE())&lt;&lt;k;k+=8;}}
DECL|macro|DUMPBITS
mdefine_line|#define DUMPBITS(n) {b&gt;&gt;=(n);k-=(n);}
multiline_comment|/*&n;   Huffman code decoding is performed using a multi-level table lookup.&n;   The fastest way to decode is to simply build a lookup table whose&n;   size is determined by the longest code.  However, the time it takes&n;   to build this table can also be a factor if the data being decoded&n;   is not very long.  The most common codes are necessarily the&n;   shortest codes, so those codes dominate the decoding time, and hence&n;   the speed.  The idea is you can have a shorter table that decodes the&n;   shorter, more probable codes, and then point to subsidiary tables for&n;   the longer codes.  The time it costs to decode the longer codes is&n;   then traded against the time it takes to make longer tables.&n;&n;   This results of this trade are in the variables lbits and dbits&n;   below.  lbits is the number of bits the first level table for literal/&n;   length codes can decode in one step, and dbits is the same thing for&n;   the distance codes.  Subsequent tables are also less than or equal to&n;   those sizes.  These values may be adjusted either when all of the&n;   codes are shorter than that, in which case the longest code length in&n;   bits is used, or when the shortest code is *longer* than the requested&n;   table size, in which case the length of the shortest code in bits is&n;   used.&n;&n;   There are two different values for the two tables, since they code a&n;   different number of possibilities each.  The literal/length table&n;   codes 286 possible values, or in a flat code, a little over eight&n;   bits.  The distance table codes 30 possible values, or a little less&n;   than five bits, flat.  The optimum values for speed end up being&n;   about one bit more than those, so lbits is 8+1 and dbits is 5+1.&n;   The optimum values may differ though from machine to machine, and&n;   possibly even between compilers.  Your mileage may vary.&n; */
DECL|variable|lbits
id|STATIC
r_const
r_int
id|lbits
op_assign
l_int|9
suffix:semicolon
multiline_comment|/* bits in base literal/length lookup table */
DECL|variable|dbits
id|STATIC
r_const
r_int
id|dbits
op_assign
l_int|6
suffix:semicolon
multiline_comment|/* bits in base distance lookup table */
multiline_comment|/* If BMAX needs to be larger than 16, then h and x[] should be ulg. */
DECL|macro|BMAX
mdefine_line|#define BMAX 16         /* maximum bit length of any code (16 for explode) */
DECL|macro|N_MAX
mdefine_line|#define N_MAX 288       /* maximum number of codes in any set */
DECL|variable|hufts
id|STATIC
r_int
id|hufts
suffix:semicolon
multiline_comment|/* track memory usage */
DECL|function|huft_build
id|STATIC
r_int
id|huft_build
c_func
(paren
id|b
comma
id|n
comma
id|s
comma
id|d
comma
id|e
comma
id|t
comma
id|m
)paren
r_int
op_star
id|b
suffix:semicolon
multiline_comment|/* code lengths in bits (all assumed &lt;= BMAX) */
r_int
id|n
suffix:semicolon
multiline_comment|/* number of codes (assumed &lt;= N_MAX) */
r_int
id|s
suffix:semicolon
multiline_comment|/* number of simple-valued codes (0..s-1) */
r_const
id|ush
op_star
id|d
suffix:semicolon
multiline_comment|/* list of base values for non-simple codes */
r_const
id|ush
op_star
id|e
suffix:semicolon
multiline_comment|/* list of extra bits for non-simple codes */
r_struct
id|huft
op_star
op_star
id|t
suffix:semicolon
multiline_comment|/* result: starting table */
r_int
op_star
id|m
suffix:semicolon
multiline_comment|/* maximum lookup bits, returns actual */
multiline_comment|/* Given a list of code lengths and a maximum table size, make a set of&n;   tables to decode that set of codes.  Return zero on success, one if&n;   the given code set is incomplete (the tables are still built in this&n;   case), two if the input is invalid (all zero length codes or an&n;   oversubscribed set of lengths), and three if not enough memory. */
(brace
r_int
id|a
suffix:semicolon
multiline_comment|/* counter for codes of length k */
r_int
id|c
(braket
id|BMAX
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* bit length count table */
r_int
id|f
suffix:semicolon
multiline_comment|/* i repeats in table every f entries */
r_int
id|g
suffix:semicolon
multiline_comment|/* maximum code length */
r_int
id|h
suffix:semicolon
multiline_comment|/* table level */
r_register
r_int
id|i
suffix:semicolon
multiline_comment|/* counter, current code */
r_register
r_int
id|j
suffix:semicolon
multiline_comment|/* counter */
r_register
r_int
id|k
suffix:semicolon
multiline_comment|/* number of bits in current code */
r_int
id|l
suffix:semicolon
multiline_comment|/* bits per table (returned in m) */
r_register
r_int
op_star
id|p
suffix:semicolon
multiline_comment|/* pointer into c[], b[], or v[] */
r_register
r_struct
id|huft
op_star
id|q
suffix:semicolon
multiline_comment|/* points to current table */
r_struct
id|huft
id|r
suffix:semicolon
multiline_comment|/* table entry for structure assignment */
r_struct
id|huft
op_star
id|u
(braket
id|BMAX
)braket
suffix:semicolon
multiline_comment|/* table stack */
r_int
id|v
(braket
id|N_MAX
)braket
suffix:semicolon
multiline_comment|/* values in order of bit length */
r_register
r_int
id|w
suffix:semicolon
multiline_comment|/* bits before this table == (l * h) */
r_int
id|x
(braket
id|BMAX
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* bit offsets, then code stack */
r_int
op_star
id|xp
suffix:semicolon
multiline_comment|/* pointer into x */
r_int
id|y
suffix:semicolon
multiline_comment|/* number of dummy codes added */
r_int
id|z
suffix:semicolon
multiline_comment|/* number of entries in current table */
id|DEBG
c_func
(paren
l_string|&quot;huft1 &quot;
)paren
suffix:semicolon
multiline_comment|/* Generate counts for each bit length */
id|memzero
c_func
(paren
id|c
comma
r_sizeof
(paren
id|c
)paren
)paren
suffix:semicolon
id|p
op_assign
id|b
suffix:semicolon
id|i
op_assign
id|n
suffix:semicolon
r_do
(brace
id|Tracecv
c_func
(paren
op_star
id|p
comma
(paren
id|stderr
comma
(paren
id|n
op_minus
id|i
op_ge
l_char|&squot; &squot;
op_logical_and
id|n
op_minus
id|i
op_le
l_char|&squot;~&squot;
ques
c_cond
l_string|&quot;%c %d&bslash;n&quot;
suffix:colon
l_string|&quot;0x%x %d&bslash;n&quot;
)paren
comma
id|n
op_minus
id|i
comma
op_star
id|p
)paren
)paren
suffix:semicolon
id|c
(braket
op_star
id|p
)braket
op_increment
suffix:semicolon
multiline_comment|/* assume all entries &lt;= BMAX */
id|p
op_increment
suffix:semicolon
multiline_comment|/* Can&squot;t combine with above line (Solaris bug) */
)brace
r_while
c_loop
(paren
op_decrement
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
(braket
l_int|0
)braket
op_eq
id|n
)paren
multiline_comment|/* null input--all zero length codes */
(brace
op_star
id|t
op_assign
(paren
r_struct
id|huft
op_star
)paren
l_int|NULL
suffix:semicolon
op_star
id|m
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DEBG
c_func
(paren
l_string|&quot;huft2 &quot;
)paren
suffix:semicolon
multiline_comment|/* Find minimum and maximum length, bound *m by those */
id|l
op_assign
op_star
id|m
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
op_le
id|BMAX
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|c
(braket
id|j
)braket
)paren
r_break
suffix:semicolon
id|k
op_assign
id|j
suffix:semicolon
multiline_comment|/* minimum code length */
r_if
c_cond
(paren
(paren
r_int
)paren
id|l
OL
id|j
)paren
id|l
op_assign
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|BMAX
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
id|c
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
id|g
op_assign
id|i
suffix:semicolon
multiline_comment|/* maximum code length */
r_if
c_cond
(paren
(paren
r_int
)paren
id|l
OG
id|i
)paren
id|l
op_assign
id|i
suffix:semicolon
op_star
id|m
op_assign
id|l
suffix:semicolon
id|DEBG
c_func
(paren
l_string|&quot;huft3 &quot;
)paren
suffix:semicolon
multiline_comment|/* Adjust last length count to fill out codes, if needed */
r_for
c_loop
(paren
id|y
op_assign
l_int|1
op_lshift
id|j
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
comma
id|y
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
(paren
id|y
op_sub_assign
id|c
(braket
id|j
)braket
)paren
OL
l_int|0
)paren
r_return
l_int|2
suffix:semicolon
multiline_comment|/* bad input: more codes than bits */
r_if
c_cond
(paren
(paren
id|y
op_sub_assign
id|c
(braket
id|i
)braket
)paren
OL
l_int|0
)paren
r_return
l_int|2
suffix:semicolon
id|c
(braket
id|i
)braket
op_add_assign
id|y
suffix:semicolon
id|DEBG
c_func
(paren
l_string|&quot;huft4 &quot;
)paren
suffix:semicolon
multiline_comment|/* Generate starting offsets into the value table for each length */
id|x
(braket
l_int|1
)braket
op_assign
id|j
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|c
op_plus
l_int|1
suffix:semicolon
id|xp
op_assign
id|x
op_plus
l_int|2
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|i
)paren
(brace
multiline_comment|/* note that i == g from above */
op_star
id|xp
op_increment
op_assign
(paren
id|j
op_add_assign
op_star
id|p
op_increment
)paren
suffix:semicolon
)brace
id|DEBG
c_func
(paren
l_string|&quot;huft5 &quot;
)paren
suffix:semicolon
multiline_comment|/* Make a table of values in order of bit lengths */
id|p
op_assign
id|b
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|j
op_assign
op_star
id|p
op_increment
)paren
op_ne
l_int|0
)paren
id|v
(braket
id|x
(braket
id|j
)braket
op_increment
)braket
op_assign
id|i
suffix:semicolon
)brace
r_while
c_loop
(paren
op_increment
id|i
OL
id|n
)paren
suffix:semicolon
id|DEBG
c_func
(paren
l_string|&quot;h6 &quot;
)paren
suffix:semicolon
multiline_comment|/* Generate the Huffman codes and for each, make the table entries */
id|x
(braket
l_int|0
)braket
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* first Huffman code is zero */
id|p
op_assign
id|v
suffix:semicolon
multiline_comment|/* grab values in bit order */
id|h
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* no tables yet--level -1 */
id|w
op_assign
op_minus
id|l
suffix:semicolon
multiline_comment|/* bits decoded == (l * h) */
id|u
(braket
l_int|0
)braket
op_assign
(paren
r_struct
id|huft
op_star
)paren
l_int|NULL
suffix:semicolon
multiline_comment|/* just to keep compilers happy */
id|q
op_assign
(paren
r_struct
id|huft
op_star
)paren
l_int|NULL
suffix:semicolon
multiline_comment|/* ditto */
id|z
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ditto */
id|DEBG
c_func
(paren
l_string|&quot;h6a &quot;
)paren
suffix:semicolon
multiline_comment|/* go through the bit lengths (k already is bits in shortest code) */
r_for
c_loop
(paren
suffix:semicolon
id|k
op_le
id|g
suffix:semicolon
id|k
op_increment
)paren
(brace
id|DEBG
c_func
(paren
l_string|&quot;h6b &quot;
)paren
suffix:semicolon
id|a
op_assign
id|c
(braket
id|k
)braket
suffix:semicolon
r_while
c_loop
(paren
id|a
op_decrement
)paren
(brace
id|DEBG
c_func
(paren
l_string|&quot;h6b1 &quot;
)paren
suffix:semicolon
multiline_comment|/* here i is the Huffman code of length k bits for value *p */
multiline_comment|/* make tables up to required level */
r_while
c_loop
(paren
id|k
OG
id|w
op_plus
id|l
)paren
(brace
id|DEBG1
c_func
(paren
l_string|&quot;1 &quot;
)paren
suffix:semicolon
id|h
op_increment
suffix:semicolon
id|w
op_add_assign
id|l
suffix:semicolon
multiline_comment|/* previous table always l bits */
multiline_comment|/* compute minimum size table less than or equal to l bits */
id|z
op_assign
(paren
id|z
op_assign
id|g
op_minus
id|w
)paren
OG
(paren
r_int
)paren
id|l
ques
c_cond
id|l
suffix:colon
id|z
suffix:semicolon
multiline_comment|/* upper limit on table size */
r_if
c_cond
(paren
(paren
id|f
op_assign
l_int|1
op_lshift
(paren
id|j
op_assign
id|k
op_minus
id|w
)paren
)paren
OG
id|a
op_plus
l_int|1
)paren
multiline_comment|/* try a k-w bit table */
(brace
multiline_comment|/* too few codes for k-w bit table */
id|DEBG1
c_func
(paren
l_string|&quot;2 &quot;
)paren
suffix:semicolon
id|f
op_sub_assign
id|a
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* deduct codes from patterns left */
id|xp
op_assign
id|c
op_plus
id|k
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|j
OL
id|z
)paren
multiline_comment|/* try smaller tables up to z bits */
(brace
r_if
c_cond
(paren
(paren
id|f
op_lshift_assign
l_int|1
)paren
op_le
op_star
op_increment
id|xp
)paren
r_break
suffix:semicolon
multiline_comment|/* enough codes to use up j bits */
id|f
op_sub_assign
op_star
id|xp
suffix:semicolon
multiline_comment|/* else deduct codes from patterns */
)brace
)brace
id|DEBG1
c_func
(paren
l_string|&quot;3 &quot;
)paren
suffix:semicolon
id|z
op_assign
l_int|1
op_lshift
id|j
suffix:semicolon
multiline_comment|/* table entries for j-bit table */
multiline_comment|/* allocate and link in new table */
r_if
c_cond
(paren
(paren
id|q
op_assign
(paren
r_struct
id|huft
op_star
)paren
id|malloc
c_func
(paren
(paren
id|z
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|huft
)paren
)paren
)paren
op_eq
(paren
r_struct
id|huft
op_star
)paren
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|h
)paren
id|huft_free
c_func
(paren
id|u
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
l_int|3
suffix:semicolon
multiline_comment|/* not enough memory */
)brace
id|DEBG1
c_func
(paren
l_string|&quot;4 &quot;
)paren
suffix:semicolon
id|hufts
op_add_assign
id|z
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* track memory usage */
op_star
id|t
op_assign
id|q
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* link to list for huft_free() */
op_star
(paren
id|t
op_assign
op_amp
(paren
id|q-&gt;v.t
)paren
)paren
op_assign
(paren
r_struct
id|huft
op_star
)paren
l_int|NULL
suffix:semicolon
id|u
(braket
id|h
)braket
op_assign
op_increment
id|q
suffix:semicolon
multiline_comment|/* table starts after link */
id|DEBG1
c_func
(paren
l_string|&quot;5 &quot;
)paren
suffix:semicolon
multiline_comment|/* connect to last table, if there is one */
r_if
c_cond
(paren
id|h
)paren
(brace
id|x
(braket
id|h
)braket
op_assign
id|i
suffix:semicolon
multiline_comment|/* save pattern for backing up */
id|r.b
op_assign
(paren
id|uch
)paren
id|l
suffix:semicolon
multiline_comment|/* bits to dump before this table */
id|r.e
op_assign
(paren
id|uch
)paren
(paren
l_int|16
op_plus
id|j
)paren
suffix:semicolon
multiline_comment|/* bits in this table */
id|r.v.t
op_assign
id|q
suffix:semicolon
multiline_comment|/* pointer to this table */
id|j
op_assign
id|i
op_rshift
(paren
id|w
op_minus
id|l
)paren
suffix:semicolon
multiline_comment|/* (get around Turbo C bug) */
id|u
(braket
id|h
op_minus
l_int|1
)braket
(braket
id|j
)braket
op_assign
id|r
suffix:semicolon
multiline_comment|/* connect to last table */
)brace
id|DEBG1
c_func
(paren
l_string|&quot;6 &quot;
)paren
suffix:semicolon
)brace
id|DEBG
c_func
(paren
l_string|&quot;h6c &quot;
)paren
suffix:semicolon
multiline_comment|/* set up table entry in r */
id|r.b
op_assign
(paren
id|uch
)paren
(paren
id|k
op_minus
id|w
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ge
id|v
op_plus
id|n
)paren
id|r.e
op_assign
l_int|99
suffix:semicolon
multiline_comment|/* out of values--invalid code */
r_else
r_if
c_cond
(paren
op_star
id|p
OL
id|s
)paren
(brace
id|r.e
op_assign
(paren
id|uch
)paren
(paren
op_star
id|p
OL
l_int|256
ques
c_cond
l_int|16
suffix:colon
l_int|15
)paren
suffix:semicolon
multiline_comment|/* 256 is end-of-block code */
id|r.v.n
op_assign
(paren
id|ush
)paren
(paren
op_star
id|p
)paren
suffix:semicolon
multiline_comment|/* simple code is just the value */
id|p
op_increment
suffix:semicolon
multiline_comment|/* one compiler does not like *p++ */
)brace
r_else
(brace
id|r.e
op_assign
(paren
id|uch
)paren
id|e
(braket
op_star
id|p
op_minus
id|s
)braket
suffix:semicolon
multiline_comment|/* non-simple--look up in lists */
id|r.v.n
op_assign
id|d
(braket
op_star
id|p
op_increment
op_minus
id|s
)braket
suffix:semicolon
)brace
id|DEBG
c_func
(paren
l_string|&quot;h6d &quot;
)paren
suffix:semicolon
multiline_comment|/* fill code-like entries with r */
id|f
op_assign
l_int|1
op_lshift
(paren
id|k
op_minus
id|w
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
op_rshift
id|w
suffix:semicolon
id|j
OL
id|z
suffix:semicolon
id|j
op_add_assign
id|f
)paren
id|q
(braket
id|j
)braket
op_assign
id|r
suffix:semicolon
multiline_comment|/* backwards increment the k-bit code i */
r_for
c_loop
(paren
id|j
op_assign
l_int|1
op_lshift
(paren
id|k
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_amp
id|j
suffix:semicolon
id|j
op_rshift_assign
l_int|1
)paren
id|i
op_xor_assign
id|j
suffix:semicolon
id|i
op_xor_assign
id|j
suffix:semicolon
multiline_comment|/* backup over finished tables */
r_while
c_loop
(paren
(paren
id|i
op_amp
(paren
(paren
l_int|1
op_lshift
id|w
)paren
op_minus
l_int|1
)paren
)paren
op_ne
id|x
(braket
id|h
)braket
)paren
(brace
id|h
op_decrement
suffix:semicolon
multiline_comment|/* don&squot;t need to update q */
id|w
op_sub_assign
id|l
suffix:semicolon
)brace
id|DEBG
c_func
(paren
l_string|&quot;h6e &quot;
)paren
suffix:semicolon
)brace
id|DEBG
c_func
(paren
l_string|&quot;h6f &quot;
)paren
suffix:semicolon
)brace
id|DEBG
c_func
(paren
l_string|&quot;huft7 &quot;
)paren
suffix:semicolon
multiline_comment|/* Return true (1) if we were given an incomplete table */
r_return
id|y
op_ne
l_int|0
op_logical_and
id|g
op_ne
l_int|1
suffix:semicolon
)brace
DECL|function|huft_free
id|STATIC
r_int
id|huft_free
c_func
(paren
id|t
)paren
r_struct
id|huft
op_star
id|t
suffix:semicolon
multiline_comment|/* table to free */
multiline_comment|/* Free the malloc&squot;ed tables built by huft_build(), which makes a linked&n;   list of the tables it made, with the links in a dummy first entry of&n;   each table. */
(brace
r_register
r_struct
id|huft
op_star
id|p
comma
op_star
id|q
suffix:semicolon
multiline_comment|/* Go through linked list, freeing from the malloced (t[-1]) address. */
id|p
op_assign
id|t
suffix:semicolon
r_while
c_loop
(paren
id|p
op_ne
(paren
r_struct
id|huft
op_star
)paren
l_int|NULL
)paren
(brace
id|q
op_assign
(paren
op_decrement
id|p
)paren
op_member_access_from_pointer
id|v.t
suffix:semicolon
id|free
c_func
(paren
(paren
r_char
op_star
)paren
id|p
)paren
suffix:semicolon
id|p
op_assign
id|q
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|inflate_codes
id|STATIC
r_int
id|inflate_codes
c_func
(paren
id|tl
comma
id|td
comma
id|bl
comma
id|bd
)paren
r_struct
id|huft
op_star
id|tl
comma
op_star
id|td
suffix:semicolon
multiline_comment|/* literal/length and distance decoder tables */
r_int
id|bl
comma
id|bd
suffix:semicolon
multiline_comment|/* number of bits decoded by tl[] and td[] */
multiline_comment|/* inflate (decompress) the codes in a deflated (compressed) block.&n;   Return an error code or zero if it all goes ok. */
(brace
r_register
r_int
id|e
suffix:semicolon
multiline_comment|/* table entry flag/number of extra bits */
r_int
id|n
comma
id|d
suffix:semicolon
multiline_comment|/* length and index for copy */
r_int
id|w
suffix:semicolon
multiline_comment|/* current window position */
r_struct
id|huft
op_star
id|t
suffix:semicolon
multiline_comment|/* pointer to table entry */
r_int
id|ml
comma
id|md
suffix:semicolon
multiline_comment|/* masks for bl and bd bits */
r_register
id|ulg
id|b
suffix:semicolon
multiline_comment|/* bit buffer */
r_register
r_int
id|k
suffix:semicolon
multiline_comment|/* number of bits in bit buffer */
multiline_comment|/* make local copies of globals */
id|b
op_assign
id|bb
suffix:semicolon
multiline_comment|/* initialize bit buffer */
id|k
op_assign
id|bk
suffix:semicolon
id|w
op_assign
id|wp
suffix:semicolon
multiline_comment|/* initialize window position */
multiline_comment|/* inflate the coded data */
id|ml
op_assign
id|mask_bits
(braket
id|bl
)braket
suffix:semicolon
multiline_comment|/* precompute masks for speed */
id|md
op_assign
id|mask_bits
(braket
id|bd
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
multiline_comment|/* do until end of block */
(brace
id|NEEDBITS
c_func
(paren
(paren
r_int
)paren
id|bl
)paren
r_if
c_cond
(paren
(paren
id|e
op_assign
(paren
id|t
op_assign
id|tl
op_plus
(paren
(paren
r_int
)paren
id|b
op_amp
id|ml
)paren
)paren
op_member_access_from_pointer
id|e
)paren
OG
l_int|16
)paren
r_do
(brace
r_if
c_cond
(paren
id|e
op_eq
l_int|99
)paren
r_return
l_int|1
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|t-&gt;b
)paren
id|e
op_sub_assign
l_int|16
suffix:semicolon
id|NEEDBITS
c_func
(paren
id|e
)paren
)brace
r_while
c_loop
(paren
(paren
id|e
op_assign
(paren
id|t
op_assign
id|t-&gt;v.t
op_plus
(paren
(paren
r_int
)paren
id|b
op_amp
id|mask_bits
(braket
id|e
)braket
)paren
)paren
op_member_access_from_pointer
id|e
)paren
OG
l_int|16
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|t-&gt;b
)paren
r_if
c_cond
(paren
id|e
op_eq
l_int|16
)paren
multiline_comment|/* then it&squot;s a literal */
(brace
id|slide
(braket
id|w
op_increment
)braket
op_assign
(paren
id|uch
)paren
id|t-&gt;v.n
suffix:semicolon
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;%c&quot;
comma
id|slide
(braket
id|w
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|w
op_eq
id|WSIZE
)paren
(brace
id|flush_output
c_func
(paren
id|w
)paren
suffix:semicolon
id|w
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* it&squot;s an EOB or a length */
(brace
multiline_comment|/* exit if end of block */
r_if
c_cond
(paren
id|e
op_eq
l_int|15
)paren
r_break
suffix:semicolon
multiline_comment|/* get length of block to copy */
id|NEEDBITS
c_func
(paren
id|e
)paren
id|n
op_assign
id|t-&gt;v.n
op_plus
(paren
(paren
r_int
)paren
id|b
op_amp
id|mask_bits
(braket
id|e
)braket
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|e
)paren
suffix:semicolon
multiline_comment|/* decode distance of block to copy */
id|NEEDBITS
c_func
(paren
(paren
r_int
)paren
id|bd
)paren
r_if
c_cond
(paren
(paren
id|e
op_assign
(paren
id|t
op_assign
id|td
op_plus
(paren
(paren
r_int
)paren
id|b
op_amp
id|md
)paren
)paren
op_member_access_from_pointer
id|e
)paren
OG
l_int|16
)paren
r_do
(brace
r_if
c_cond
(paren
id|e
op_eq
l_int|99
)paren
r_return
l_int|1
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|t-&gt;b
)paren
id|e
op_sub_assign
l_int|16
suffix:semicolon
id|NEEDBITS
c_func
(paren
id|e
)paren
)brace
r_while
c_loop
(paren
(paren
id|e
op_assign
(paren
id|t
op_assign
id|t-&gt;v.t
op_plus
(paren
(paren
r_int
)paren
id|b
op_amp
id|mask_bits
(braket
id|e
)braket
)paren
)paren
op_member_access_from_pointer
id|e
)paren
OG
l_int|16
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|t-&gt;b
)paren
id|NEEDBITS
c_func
(paren
id|e
)paren
id|d
op_assign
id|w
op_minus
id|t-&gt;v.n
op_minus
(paren
(paren
r_int
)paren
id|b
op_amp
id|mask_bits
(braket
id|e
)braket
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|e
)paren
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;&bslash;&bslash;[%d,%d]&quot;
comma
id|w
op_minus
id|d
comma
id|n
)paren
)paren
suffix:semicolon
multiline_comment|/* do the copy */
r_do
(brace
id|n
op_sub_assign
(paren
id|e
op_assign
(paren
id|e
op_assign
id|WSIZE
op_minus
(paren
(paren
id|d
op_and_assign
id|WSIZE
op_minus
l_int|1
)paren
OG
id|w
ques
c_cond
id|d
suffix:colon
id|w
)paren
)paren
OG
id|n
ques
c_cond
id|n
suffix:colon
id|e
)paren
suffix:semicolon
macro_line|#if !defined(NOMEMCPY) &amp;&amp; !defined(DEBUG)
r_if
c_cond
(paren
id|w
op_minus
id|d
op_ge
id|e
)paren
multiline_comment|/* (this test assumes unsigned comparison) */
(brace
id|memcpy
c_func
(paren
id|slide
op_plus
id|w
comma
id|slide
op_plus
id|d
comma
id|e
)paren
suffix:semicolon
id|w
op_add_assign
id|e
suffix:semicolon
id|d
op_add_assign
id|e
suffix:semicolon
)brace
r_else
multiline_comment|/* do it slow to avoid memcpy() overlap */
macro_line|#endif /* !NOMEMCPY */
r_do
(brace
id|slide
(braket
id|w
op_increment
)braket
op_assign
id|slide
(braket
id|d
op_increment
)braket
suffix:semicolon
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;%c&quot;
comma
id|slide
(braket
id|w
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|e
)paren
suffix:semicolon
r_if
c_cond
(paren
id|w
op_eq
id|WSIZE
)paren
(brace
id|flush_output
c_func
(paren
id|w
)paren
suffix:semicolon
id|w
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|n
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* restore the globals from the locals */
id|wp
op_assign
id|w
suffix:semicolon
multiline_comment|/* restore global window pointer */
id|bb
op_assign
id|b
suffix:semicolon
multiline_comment|/* restore global bit buffer */
id|bk
op_assign
id|k
suffix:semicolon
multiline_comment|/* done */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|inflate_stored
id|STATIC
r_int
id|inflate_stored
c_func
(paren
)paren
multiline_comment|/* &quot;decompress&quot; an inflated type 0 (stored) block. */
(brace
r_int
id|n
suffix:semicolon
multiline_comment|/* number of bytes in block */
r_int
id|w
suffix:semicolon
multiline_comment|/* current window position */
r_register
id|ulg
id|b
suffix:semicolon
multiline_comment|/* bit buffer */
r_register
r_int
id|k
suffix:semicolon
multiline_comment|/* number of bits in bit buffer */
id|DEBG
c_func
(paren
l_string|&quot;&lt;stor&quot;
)paren
suffix:semicolon
multiline_comment|/* make local copies of globals */
id|b
op_assign
id|bb
suffix:semicolon
multiline_comment|/* initialize bit buffer */
id|k
op_assign
id|bk
suffix:semicolon
id|w
op_assign
id|wp
suffix:semicolon
multiline_comment|/* initialize window position */
multiline_comment|/* go to byte boundary */
id|n
op_assign
id|k
op_amp
l_int|7
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|n
)paren
suffix:semicolon
multiline_comment|/* get the length and its complement */
id|NEEDBITS
c_func
(paren
l_int|16
)paren
id|n
op_assign
(paren
(paren
r_int
)paren
id|b
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
l_int|16
)paren
id|NEEDBITS
c_func
(paren
l_int|16
)paren
r_if
c_cond
(paren
id|n
op_ne
(paren
r_int
)paren
(paren
(paren
op_complement
id|b
)paren
op_amp
l_int|0xffff
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* error in compressed data */
id|DUMPBITS
c_func
(paren
l_int|16
)paren
multiline_comment|/* read and output the compressed data */
r_while
c_loop
(paren
id|n
op_decrement
)paren
(brace
id|NEEDBITS
c_func
(paren
l_int|8
)paren
id|slide
(braket
id|w
op_increment
)braket
op_assign
(paren
id|uch
)paren
id|b
suffix:semicolon
r_if
c_cond
(paren
id|w
op_eq
id|WSIZE
)paren
(brace
id|flush_output
c_func
(paren
id|w
)paren
suffix:semicolon
id|w
op_assign
l_int|0
suffix:semicolon
)brace
id|DUMPBITS
c_func
(paren
l_int|8
)paren
)brace
multiline_comment|/* restore the globals from the locals */
id|wp
op_assign
id|w
suffix:semicolon
multiline_comment|/* restore global window pointer */
id|bb
op_assign
id|b
suffix:semicolon
multiline_comment|/* restore global bit buffer */
id|bk
op_assign
id|k
suffix:semicolon
id|DEBG
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|inflate_fixed
id|STATIC
r_int
id|inflate_fixed
c_func
(paren
)paren
multiline_comment|/* decompress an inflated type 1 (fixed Huffman codes) block.  We should&n;   either replace this with a custom decoder, or at least precompute the&n;   Huffman tables. */
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* temporary variable */
r_struct
id|huft
op_star
id|tl
suffix:semicolon
multiline_comment|/* literal/length code table */
r_struct
id|huft
op_star
id|td
suffix:semicolon
multiline_comment|/* distance code table */
r_int
id|bl
suffix:semicolon
multiline_comment|/* lookup bits for tl */
r_int
id|bd
suffix:semicolon
multiline_comment|/* lookup bits for td */
r_int
id|l
(braket
l_int|288
)braket
suffix:semicolon
multiline_comment|/* length list for huft_build */
id|DEBG
c_func
(paren
l_string|&quot;&lt;fix&quot;
)paren
suffix:semicolon
multiline_comment|/* set up literal table */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|144
suffix:semicolon
id|i
op_increment
)paren
id|l
(braket
id|i
)braket
op_assign
l_int|8
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
id|l
(braket
id|i
)braket
op_assign
l_int|9
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|280
suffix:semicolon
id|i
op_increment
)paren
id|l
(braket
id|i
)braket
op_assign
l_int|7
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|288
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* make a complete, but wrong code set */
id|l
(braket
id|i
)braket
op_assign
l_int|8
suffix:semicolon
id|bl
op_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|huft_build
c_func
(paren
id|l
comma
l_int|288
comma
l_int|257
comma
id|cplens
comma
id|cplext
comma
op_amp
id|tl
comma
op_amp
id|bl
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|i
suffix:semicolon
multiline_comment|/* set up distance table */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|30
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* make an incomplete code set */
id|l
(braket
id|i
)braket
op_assign
l_int|5
suffix:semicolon
id|bd
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|huft_build
c_func
(paren
id|l
comma
l_int|30
comma
l_int|0
comma
id|cpdist
comma
id|cpdext
comma
op_amp
id|td
comma
op_amp
id|bd
)paren
)paren
OG
l_int|1
)paren
(brace
id|huft_free
c_func
(paren
id|tl
)paren
suffix:semicolon
id|DEBG
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* decompress until an end-of-block code */
r_if
c_cond
(paren
id|inflate_codes
c_func
(paren
id|tl
comma
id|td
comma
id|bl
comma
id|bd
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* free the decoding tables, return */
id|huft_free
c_func
(paren
id|tl
)paren
suffix:semicolon
id|huft_free
c_func
(paren
id|td
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|inflate_dynamic
id|STATIC
r_int
id|inflate_dynamic
c_func
(paren
)paren
multiline_comment|/* decompress an inflated type 2 (dynamic Huffman codes) block. */
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* temporary variables */
r_int
id|j
suffix:semicolon
r_int
id|l
suffix:semicolon
multiline_comment|/* last length */
r_int
id|m
suffix:semicolon
multiline_comment|/* mask for bit lengths table */
r_int
id|n
suffix:semicolon
multiline_comment|/* number of lengths to get */
r_struct
id|huft
op_star
id|tl
suffix:semicolon
multiline_comment|/* literal/length code table */
r_struct
id|huft
op_star
id|td
suffix:semicolon
multiline_comment|/* distance code table */
r_int
id|bl
suffix:semicolon
multiline_comment|/* lookup bits for tl */
r_int
id|bd
suffix:semicolon
multiline_comment|/* lookup bits for td */
r_int
id|nb
suffix:semicolon
multiline_comment|/* number of bit length codes */
r_int
id|nl
suffix:semicolon
multiline_comment|/* number of literal/length codes */
r_int
id|nd
suffix:semicolon
multiline_comment|/* number of distance codes */
macro_line|#ifdef PKZIP_BUG_WORKAROUND
r_int
id|ll
(braket
l_int|288
op_plus
l_int|32
)braket
suffix:semicolon
multiline_comment|/* literal/length and distance code lengths */
macro_line|#else
r_int
id|ll
(braket
l_int|286
op_plus
l_int|30
)braket
suffix:semicolon
multiline_comment|/* literal/length and distance code lengths */
macro_line|#endif
r_register
id|ulg
id|b
suffix:semicolon
multiline_comment|/* bit buffer */
r_register
r_int
id|k
suffix:semicolon
multiline_comment|/* number of bits in bit buffer */
id|DEBG
c_func
(paren
l_string|&quot;&lt;dyn&quot;
)paren
suffix:semicolon
multiline_comment|/* make local bit buffer */
id|b
op_assign
id|bb
suffix:semicolon
id|k
op_assign
id|bk
suffix:semicolon
multiline_comment|/* read in table lengths */
id|NEEDBITS
c_func
(paren
l_int|5
)paren
id|nl
op_assign
l_int|257
op_plus
(paren
(paren
r_int
)paren
id|b
op_amp
l_int|0x1f
)paren
suffix:semicolon
multiline_comment|/* number of literal/length codes */
id|DUMPBITS
c_func
(paren
l_int|5
)paren
id|NEEDBITS
c_func
(paren
l_int|5
)paren
id|nd
op_assign
l_int|1
op_plus
(paren
(paren
r_int
)paren
id|b
op_amp
l_int|0x1f
)paren
suffix:semicolon
multiline_comment|/* number of distance codes */
id|DUMPBITS
c_func
(paren
l_int|5
)paren
id|NEEDBITS
c_func
(paren
l_int|4
)paren
id|nb
op_assign
l_int|4
op_plus
(paren
(paren
r_int
)paren
id|b
op_amp
l_int|0xf
)paren
suffix:semicolon
multiline_comment|/* number of bit length codes */
id|DUMPBITS
c_func
(paren
l_int|4
)paren
macro_line|#ifdef PKZIP_BUG_WORKAROUND
r_if
c_cond
(paren
id|nl
OG
l_int|288
op_logical_or
id|nd
OG
l_int|32
)paren
macro_line|#else
r_if
c_cond
(paren
id|nl
OG
l_int|286
op_logical_or
id|nd
OG
l_int|30
)paren
macro_line|#endif
r_return
l_int|1
suffix:semicolon
multiline_comment|/* bad lengths */
id|DEBG
c_func
(paren
l_string|&quot;dyn1 &quot;
)paren
suffix:semicolon
multiline_comment|/* read in bit-length-code lengths */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|nb
suffix:semicolon
id|j
op_increment
)paren
(brace
id|NEEDBITS
c_func
(paren
l_int|3
)paren
id|ll
(braket
id|border
(braket
id|j
)braket
)braket
op_assign
(paren
r_int
)paren
id|b
op_amp
l_int|7
suffix:semicolon
id|DUMPBITS
c_func
(paren
l_int|3
)paren
)brace
r_for
c_loop
(paren
suffix:semicolon
id|j
OL
l_int|19
suffix:semicolon
id|j
op_increment
)paren
id|ll
(braket
id|border
(braket
id|j
)braket
)braket
op_assign
l_int|0
suffix:semicolon
id|DEBG
c_func
(paren
l_string|&quot;dyn2 &quot;
)paren
suffix:semicolon
multiline_comment|/* build decoding table for trees--single level, 7 bit lookup */
id|bl
op_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|huft_build
c_func
(paren
id|ll
comma
l_int|19
comma
l_int|19
comma
l_int|NULL
comma
l_int|NULL
comma
op_amp
id|tl
comma
op_amp
id|bl
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
l_int|1
)paren
id|huft_free
c_func
(paren
id|tl
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
multiline_comment|/* incomplete code set */
)brace
id|DEBG
c_func
(paren
l_string|&quot;dyn3 &quot;
)paren
suffix:semicolon
multiline_comment|/* read in literal and distance code lengths */
id|n
op_assign
id|nl
op_plus
id|nd
suffix:semicolon
id|m
op_assign
id|mask_bits
(braket
id|bl
)braket
suffix:semicolon
id|i
op_assign
id|l
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
r_int
)paren
id|i
OL
id|n
)paren
(brace
id|NEEDBITS
c_func
(paren
(paren
r_int
)paren
id|bl
)paren
id|j
op_assign
(paren
id|td
op_assign
id|tl
op_plus
(paren
(paren
r_int
)paren
id|b
op_amp
id|m
)paren
)paren
op_member_access_from_pointer
id|b
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|j
)paren
id|j
op_assign
id|td-&gt;v.n
suffix:semicolon
r_if
c_cond
(paren
id|j
OL
l_int|16
)paren
multiline_comment|/* length of code in bits (0..15) */
id|ll
(braket
id|i
op_increment
)braket
op_assign
id|l
op_assign
id|j
suffix:semicolon
multiline_comment|/* save last length in l */
r_else
r_if
c_cond
(paren
id|j
op_eq
l_int|16
)paren
multiline_comment|/* repeat last length 3 to 6 times */
(brace
id|NEEDBITS
c_func
(paren
l_int|2
)paren
id|j
op_assign
l_int|3
op_plus
(paren
(paren
r_int
)paren
id|b
op_amp
l_int|3
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
l_int|2
)paren
r_if
c_cond
(paren
(paren
r_int
)paren
id|i
op_plus
id|j
OG
id|n
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|j
op_decrement
)paren
id|ll
(braket
id|i
op_increment
)braket
op_assign
id|l
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|j
op_eq
l_int|17
)paren
multiline_comment|/* 3 to 10 zero length codes */
(brace
id|NEEDBITS
c_func
(paren
l_int|3
)paren
id|j
op_assign
l_int|3
op_plus
(paren
(paren
r_int
)paren
id|b
op_amp
l_int|7
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
l_int|3
)paren
r_if
c_cond
(paren
(paren
r_int
)paren
id|i
op_plus
id|j
OG
id|n
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|j
op_decrement
)paren
id|ll
(braket
id|i
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
id|l
op_assign
l_int|0
suffix:semicolon
)brace
r_else
multiline_comment|/* j == 18: 11 to 138 zero length codes */
(brace
id|NEEDBITS
c_func
(paren
l_int|7
)paren
id|j
op_assign
l_int|11
op_plus
(paren
(paren
r_int
)paren
id|b
op_amp
l_int|0x7f
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
l_int|7
)paren
r_if
c_cond
(paren
(paren
r_int
)paren
id|i
op_plus
id|j
OG
id|n
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|j
op_decrement
)paren
id|ll
(braket
id|i
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
id|l
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|DEBG
c_func
(paren
l_string|&quot;dyn4 &quot;
)paren
suffix:semicolon
multiline_comment|/* free decoding table for trees */
id|huft_free
c_func
(paren
id|tl
)paren
suffix:semicolon
id|DEBG
c_func
(paren
l_string|&quot;dyn5 &quot;
)paren
suffix:semicolon
multiline_comment|/* restore the global bit buffer */
id|bb
op_assign
id|b
suffix:semicolon
id|bk
op_assign
id|k
suffix:semicolon
id|DEBG
c_func
(paren
l_string|&quot;dyn5a &quot;
)paren
suffix:semicolon
multiline_comment|/* build the decoding tables for literal/length and distance codes */
id|bl
op_assign
id|lbits
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|huft_build
c_func
(paren
id|ll
comma
id|nl
comma
l_int|257
comma
id|cplens
comma
id|cplext
comma
op_amp
id|tl
comma
op_amp
id|bl
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|DEBG
c_func
(paren
l_string|&quot;dyn5b &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|1
)paren
(brace
id|error
c_func
(paren
l_string|&quot; incomplete literal tree&bslash;n&quot;
)paren
suffix:semicolon
id|huft_free
c_func
(paren
id|tl
)paren
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
multiline_comment|/* incomplete code set */
)brace
id|DEBG
c_func
(paren
l_string|&quot;dyn5c &quot;
)paren
suffix:semicolon
id|bd
op_assign
id|dbits
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|huft_build
c_func
(paren
id|ll
op_plus
id|nl
comma
id|nd
comma
l_int|0
comma
id|cpdist
comma
id|cpdext
comma
op_amp
id|td
comma
op_amp
id|bd
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|DEBG
c_func
(paren
l_string|&quot;dyn5d &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|1
)paren
(brace
id|error
c_func
(paren
l_string|&quot; incomplete distance tree&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef PKZIP_BUG_WORKAROUND
id|i
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#else
id|huft_free
c_func
(paren
id|td
)paren
suffix:semicolon
)brace
id|huft_free
c_func
(paren
id|tl
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
multiline_comment|/* incomplete code set */
macro_line|#endif
)brace
id|DEBG
c_func
(paren
l_string|&quot;dyn6 &quot;
)paren
suffix:semicolon
multiline_comment|/* decompress until an end-of-block code */
r_if
c_cond
(paren
id|inflate_codes
c_func
(paren
id|tl
comma
id|td
comma
id|bl
comma
id|bd
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|DEBG
c_func
(paren
l_string|&quot;dyn7 &quot;
)paren
suffix:semicolon
multiline_comment|/* free the decoding tables, return */
id|huft_free
c_func
(paren
id|tl
)paren
suffix:semicolon
id|huft_free
c_func
(paren
id|td
)paren
suffix:semicolon
id|DEBG
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|inflate_block
id|STATIC
r_int
id|inflate_block
c_func
(paren
id|e
)paren
r_int
op_star
id|e
suffix:semicolon
multiline_comment|/* last block flag */
multiline_comment|/* decompress an inflated block */
(brace
r_int
id|t
suffix:semicolon
multiline_comment|/* block type */
r_register
id|ulg
id|b
suffix:semicolon
multiline_comment|/* bit buffer */
r_register
r_int
id|k
suffix:semicolon
multiline_comment|/* number of bits in bit buffer */
id|DEBG
c_func
(paren
l_string|&quot;&lt;blk&quot;
)paren
suffix:semicolon
multiline_comment|/* make local bit buffer */
id|b
op_assign
id|bb
suffix:semicolon
id|k
op_assign
id|bk
suffix:semicolon
multiline_comment|/* read in last block bit */
id|NEEDBITS
c_func
(paren
l_int|1
)paren
op_star
id|e
op_assign
(paren
r_int
)paren
id|b
op_amp
l_int|1
suffix:semicolon
id|DUMPBITS
c_func
(paren
l_int|1
)paren
multiline_comment|/* read in block type */
id|NEEDBITS
c_func
(paren
l_int|2
)paren
id|t
op_assign
(paren
r_int
)paren
id|b
op_amp
l_int|3
suffix:semicolon
id|DUMPBITS
c_func
(paren
l_int|2
)paren
multiline_comment|/* restore the global bit buffer */
id|bb
op_assign
id|b
suffix:semicolon
id|bk
op_assign
id|k
suffix:semicolon
multiline_comment|/* inflate that block type */
r_if
c_cond
(paren
id|t
op_eq
l_int|2
)paren
r_return
id|inflate_dynamic
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_eq
l_int|0
)paren
r_return
id|inflate_stored
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_eq
l_int|1
)paren
r_return
id|inflate_fixed
c_func
(paren
)paren
suffix:semicolon
id|DEBG
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
multiline_comment|/* bad block type */
r_return
l_int|2
suffix:semicolon
)brace
DECL|function|inflate
id|STATIC
r_int
id|inflate
c_func
(paren
)paren
multiline_comment|/* decompress an inflated entry */
(brace
r_int
id|e
suffix:semicolon
multiline_comment|/* last block flag */
r_int
id|r
suffix:semicolon
multiline_comment|/* result code */
r_int
id|h
suffix:semicolon
multiline_comment|/* maximum struct huft&squot;s malloc&squot;ed */
r_void
op_star
id|ptr
suffix:semicolon
multiline_comment|/* initialize window, bit buffer */
id|wp
op_assign
l_int|0
suffix:semicolon
id|bk
op_assign
l_int|0
suffix:semicolon
id|bb
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* decompress until the last block */
id|h
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|hufts
op_assign
l_int|0
suffix:semicolon
id|gzip_mark
c_func
(paren
op_amp
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_assign
id|inflate_block
c_func
(paren
op_amp
id|e
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|gzip_release
c_func
(paren
op_amp
id|ptr
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
id|gzip_release
c_func
(paren
op_amp
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hufts
OG
id|h
)paren
id|h
op_assign
id|hufts
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|e
)paren
suffix:semicolon
multiline_comment|/* Undo too much lookahead. The next read will be byte aligned so we&n;   * can discard unused bits in the last meaningful byte.&n;   */
r_while
c_loop
(paren
id|bk
op_ge
l_int|8
)paren
(brace
id|bk
op_sub_assign
l_int|8
suffix:semicolon
id|inptr
op_decrement
suffix:semicolon
)brace
multiline_comment|/* flush out slide */
id|flush_output
c_func
(paren
id|wp
)paren
suffix:semicolon
multiline_comment|/* return success */
macro_line|#ifdef DEBUG
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;&lt;%u&gt; &quot;
comma
id|h
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**********************************************************************&n; *&n; * The following are support routines for inflate.c&n; *&n; **********************************************************************/
DECL|variable|crc_32_tab
r_static
id|ulg
id|crc_32_tab
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|crc
r_static
id|ulg
id|crc
suffix:semicolon
multiline_comment|/* initialized in makecrc() so it&squot;ll reside in bss */
DECL|macro|CRC_VALUE
mdefine_line|#define CRC_VALUE (crc ^ 0xffffffffL)
multiline_comment|/*&n; * Code to compute the CRC-32 table. Borrowed from &n; * gzip-1.0.3/makecrc.c.&n; */
r_static
r_void
DECL|function|makecrc
id|makecrc
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Not copyrighted 1990 Mark Adler&t;*/
r_int
r_int
id|c
suffix:semicolon
multiline_comment|/* crc shift register */
r_int
r_int
id|e
suffix:semicolon
multiline_comment|/* polynomial exclusive-or pattern */
r_int
id|i
suffix:semicolon
multiline_comment|/* counter for all possible eight bit values */
r_int
id|k
suffix:semicolon
multiline_comment|/* byte being shifted into crc apparatus */
multiline_comment|/* terms of polynomial defining this crc (except x^32): */
r_static
r_const
r_int
id|p
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|4
comma
l_int|5
comma
l_int|7
comma
l_int|8
comma
l_int|10
comma
l_int|11
comma
l_int|12
comma
l_int|16
comma
l_int|22
comma
l_int|23
comma
l_int|26
)brace
suffix:semicolon
multiline_comment|/* Make exclusive-or pattern from polynomial */
id|e
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|p
)paren
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|i
op_increment
)paren
id|e
op_or_assign
l_int|1L
op_lshift
(paren
l_int|31
op_minus
id|p
(braket
id|i
)braket
)paren
suffix:semicolon
id|crc_32_tab
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|i
op_or
l_int|256
suffix:semicolon
id|k
op_ne
l_int|1
suffix:semicolon
id|k
op_rshift_assign
l_int|1
)paren
(brace
id|c
op_assign
id|c
op_amp
l_int|1
ques
c_cond
(paren
id|c
op_rshift
l_int|1
)paren
op_xor
id|e
suffix:colon
id|c
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|k
op_amp
l_int|1
)paren
id|c
op_xor_assign
id|e
suffix:semicolon
)brace
id|crc_32_tab
(braket
id|i
)braket
op_assign
id|c
suffix:semicolon
)brace
multiline_comment|/* this is initialized here so this code could reside in ROM */
id|crc
op_assign
(paren
id|ulg
)paren
l_int|0xffffffffL
suffix:semicolon
multiline_comment|/* shift register contents */
)brace
multiline_comment|/* gzip flag byte */
DECL|macro|ASCII_FLAG
mdefine_line|#define ASCII_FLAG   0x01 /* bit 0 set: file probably ASCII text */
DECL|macro|CONTINUATION
mdefine_line|#define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */
DECL|macro|EXTRA_FIELD
mdefine_line|#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
DECL|macro|ORIG_NAME
mdefine_line|#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
DECL|macro|COMMENT
mdefine_line|#define COMMENT      0x10 /* bit 4 set: file comment present */
DECL|macro|ENCRYPTED
mdefine_line|#define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */
DECL|macro|RESERVED
mdefine_line|#define RESERVED     0xC0 /* bit 6,7:   reserved */
multiline_comment|/*&n; * Do the uncompression!&n; */
DECL|function|gunzip
r_static
r_int
id|gunzip
c_func
(paren
r_void
)paren
(brace
id|uch
id|flags
suffix:semicolon
r_int
r_char
id|magic
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* magic header */
r_char
id|method
suffix:semicolon
id|ulg
id|orig_crc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* original crc */
id|ulg
id|orig_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* original uncompressed length */
r_int
id|res
suffix:semicolon
id|magic
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_char
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
id|magic
(braket
l_int|1
)braket
op_assign
(paren
r_int
r_char
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
id|method
op_assign
(paren
r_int
r_char
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|magic
(braket
l_int|0
)braket
op_ne
l_int|037
op_logical_or
(paren
(paren
id|magic
(braket
l_int|1
)braket
op_ne
l_int|0213
)paren
op_logical_and
(paren
id|magic
(braket
l_int|1
)braket
op_ne
l_int|0236
)paren
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;bad gzip magic numbers&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* We only support method #8, DEFLATED */
r_if
c_cond
(paren
id|method
op_ne
l_int|8
)paren
(brace
id|error
c_func
(paren
l_string|&quot;internal error, invalid method&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|flags
op_assign
(paren
id|uch
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|ENCRYPTED
)paren
op_ne
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Input is encrypted&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|CONTINUATION
)paren
op_ne
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Multi part input&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|RESERVED
)paren
op_ne
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Input has invalid flags&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
(paren
id|ulg
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Get timestamp */
(paren
(paren
id|ulg
)paren
id|get_byte
c_func
(paren
)paren
)paren
op_lshift
l_int|8
suffix:semicolon
(paren
(paren
id|ulg
)paren
id|get_byte
c_func
(paren
)paren
)paren
op_lshift
l_int|16
suffix:semicolon
(paren
(paren
id|ulg
)paren
id|get_byte
c_func
(paren
)paren
)paren
op_lshift
l_int|24
suffix:semicolon
(paren
r_void
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Ignore extra flags for the moment */
(paren
r_void
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Ignore OS type for the moment */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|EXTRA_FIELD
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|len
op_assign
(paren
r_int
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
id|len
op_or_assign
(paren
(paren
r_int
)paren
id|get_byte
c_func
(paren
)paren
)paren
op_lshift
l_int|8
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
(paren
r_void
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Get original file name if it was truncated */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|ORIG_NAME
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Discard the old name */
r_while
c_loop
(paren
id|get_byte
c_func
(paren
)paren
op_ne
l_int|0
)paren
multiline_comment|/* null */
suffix:semicolon
)brace
multiline_comment|/* Discard file comment if any */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|COMMENT
)paren
op_ne
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|get_byte
c_func
(paren
)paren
op_ne
l_int|0
)paren
multiline_comment|/* null */
suffix:semicolon
)brace
multiline_comment|/* Decompress */
r_if
c_cond
(paren
(paren
id|res
op_assign
id|inflate
c_func
(paren
)paren
)paren
)paren
(brace
r_switch
c_cond
(paren
id|res
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|error
c_func
(paren
l_string|&quot;invalid compressed format (err=1)&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|error
c_func
(paren
l_string|&quot;invalid compressed format (err=2)&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|error
c_func
(paren
l_string|&quot;out of memory&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
c_func
(paren
l_string|&quot;invalid compressed format (other)&quot;
)paren
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Get the crc and original length */
multiline_comment|/* crc32  (see algorithm.doc)&n;     * uncompressed input size modulo 2^32&n;     */
id|orig_crc
op_assign
(paren
id|ulg
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
id|orig_crc
op_or_assign
(paren
id|ulg
)paren
id|get_byte
c_func
(paren
)paren
op_lshift
l_int|8
suffix:semicolon
id|orig_crc
op_or_assign
(paren
id|ulg
)paren
id|get_byte
c_func
(paren
)paren
op_lshift
l_int|16
suffix:semicolon
id|orig_crc
op_or_assign
(paren
id|ulg
)paren
id|get_byte
c_func
(paren
)paren
op_lshift
l_int|24
suffix:semicolon
id|orig_len
op_assign
(paren
id|ulg
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
id|orig_len
op_or_assign
(paren
id|ulg
)paren
id|get_byte
c_func
(paren
)paren
op_lshift
l_int|8
suffix:semicolon
id|orig_len
op_or_assign
(paren
id|ulg
)paren
id|get_byte
c_func
(paren
)paren
op_lshift
l_int|16
suffix:semicolon
id|orig_len
op_or_assign
(paren
id|ulg
)paren
id|get_byte
c_func
(paren
)paren
op_lshift
l_int|24
suffix:semicolon
multiline_comment|/* Validate decompression */
r_if
c_cond
(paren
id|orig_crc
op_ne
id|CRC_VALUE
)paren
(brace
id|error
c_func
(paren
l_string|&quot;crc error&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|orig_len
op_ne
id|bytes_out
)paren
(brace
id|error
c_func
(paren
l_string|&quot;length error&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
