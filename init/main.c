multiline_comment|/*&n; *  linux/init/main.c&n; *&n; *  (C) 1991  Linus Torvalds&n; */
macro_line|#include &lt;stddef.h&gt;
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;time.h&gt;
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/head.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
multiline_comment|/*&n; * we need this inline - forking from kernel space will result&n; * in NO COPY ON WRITE (!!!), until an execve is executed. This&n; * is no problem, but for the stack. This is handled by not letting&n; * main() use the stack at all after fork(). Thus, no function&n; * calls - which means inline code for fork too, as otherwise we&n; * would use the stack upon exit from &squot;fork()&squot;.&n; *&n; * Actually only pause and fork are needed inline, so that there&n; * won&squot;t be any messing with the stack from main(), but we define&n; * some others too.&n; */
r_static
r_inline
id|_syscall0
c_func
(paren
r_int
comma
id|fork
)paren
r_static
r_inline
id|_syscall0
c_func
(paren
r_int
comma
id|pause
)paren
r_static
r_inline
id|_syscall1
c_func
(paren
r_int
comma
id|setup
comma
r_void
op_star
comma
id|BIOS
)paren
r_static
r_inline
id|_syscall0
c_func
(paren
r_int
comma
id|sync
)paren
r_static
r_inline
id|_syscall0
c_func
(paren
id|pid_t
comma
id|setsid
)paren
r_static
r_inline
id|_syscall3
c_func
(paren
r_int
comma
id|write
comma
r_int
comma
id|fd
comma
r_const
r_char
op_star
comma
id|buf
comma
id|off_t
comma
id|count
)paren
r_static
r_inline
id|_syscall1
c_func
(paren
r_int
comma
id|dup
comma
r_int
comma
id|fd
)paren
r_static
r_inline
id|_syscall3
c_func
(paren
r_int
comma
id|execve
comma
r_const
r_char
op_star
comma
id|file
comma
r_char
op_star
op_star
comma
id|argv
comma
r_char
op_star
op_star
comma
id|envp
)paren
r_static
r_inline
id|_syscall3
c_func
(paren
r_int
comma
id|open
comma
r_const
r_char
op_star
comma
id|file
comma
r_int
comma
id|flag
comma
r_int
comma
id|mode
)paren
r_static
r_inline
id|_syscall1
c_func
(paren
r_int
comma
id|close
comma
r_int
comma
id|fd
)paren
r_static
r_inline
id|_syscall3
c_func
(paren
id|pid_t
comma
id|waitpid
comma
id|pid_t
comma
id|pid
comma
r_int
op_star
comma
id|wait_stat
comma
r_int
comma
id|options
)paren
DECL|function|wait
r_static
r_inline
id|pid_t
id|wait
c_func
(paren
r_int
op_star
id|wait_stat
)paren
(brace
r_return
id|waitpid
c_func
(paren
op_minus
l_int|1
comma
id|wait_stat
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|printbuf
r_static
r_char
id|printbuf
(braket
l_int|1024
)braket
suffix:semicolon
r_extern
r_int
id|vsprintf
c_func
(paren
)paren
suffix:semicolon
r_extern
r_void
id|init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|init_IRQ
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|blk_dev_init
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|chr_dev_init
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|hd_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|floppy_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|sock_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|mem_init
c_func
(paren
r_int
id|start
comma
r_int
id|end
)paren
suffix:semicolon
r_extern
r_int
id|rd_init
c_func
(paren
r_int
id|mem_start
comma
r_int
id|length
)paren
suffix:semicolon
r_extern
r_int
id|kernel_mktime
c_func
(paren
r_struct
id|tm
op_star
id|tm
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SCSI
r_extern
r_void
id|scsi_dev_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
DECL|function|sprintf
r_static
r_int
id|sprintf
c_func
(paren
r_char
op_star
id|str
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_int
id|i
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|i
op_assign
id|vsprintf
c_func
(paren
id|str
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * This is set up by the setup-routine at boot-time&n; */
DECL|macro|EXT_MEM_K
mdefine_line|#define EXT_MEM_K (*(unsigned short *)0x90002)
DECL|macro|CON_ROWS
mdefine_line|#define CON_ROWS ((*(unsigned short *)0x9000e) &amp; 0xff)
DECL|macro|CON_COLS
mdefine_line|#define CON_COLS (((*(unsigned short *)0x9000e) &amp; 0xff00) &gt;&gt; 8)
DECL|macro|DRIVE_INFO
mdefine_line|#define DRIVE_INFO (*(struct drive_info *)0x90080)
DECL|macro|ORIG_ROOT_DEV
mdefine_line|#define ORIG_ROOT_DEV (*(unsigned short *)0x901FC)
multiline_comment|/*&n; * Yeah, yeah, it&squot;s ugly, but I cannot find how to do this correctly&n; * and this seems to work. I anybody has more info on the real-time&n; * clock I&squot;d be interested. Most of this was trial and error, and some&n; * bios-listing reading. Urghh.&n; */
DECL|macro|CMOS_READ
mdefine_line|#define CMOS_READ(addr) ({ &bslash;&n;outb_p(0x80|addr,0x70); &bslash;&n;inb_p(0x71); &bslash;&n;})
DECL|macro|BCD_TO_BIN
mdefine_line|#define BCD_TO_BIN(val) ((val)=((val)&amp;15) + ((val)&gt;&gt;4)*10)
DECL|function|time_init
r_static
r_void
id|time_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|tm
id|time
suffix:semicolon
r_do
(brace
id|time.tm_sec
op_assign
id|CMOS_READ
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|time.tm_min
op_assign
id|CMOS_READ
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|time.tm_hour
op_assign
id|CMOS_READ
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|time.tm_mday
op_assign
id|CMOS_READ
c_func
(paren
l_int|7
)paren
suffix:semicolon
id|time.tm_mon
op_assign
id|CMOS_READ
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|time.tm_year
op_assign
id|CMOS_READ
c_func
(paren
l_int|9
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|time.tm_sec
op_ne
id|CMOS_READ
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|time.tm_sec
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|time.tm_min
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|time.tm_hour
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|time.tm_mday
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|time.tm_mon
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|time.tm_year
)paren
suffix:semicolon
id|time.tm_mon
op_decrement
suffix:semicolon
id|startup_time
op_assign
id|kernel_mktime
c_func
(paren
op_amp
id|time
)paren
suffix:semicolon
)brace
DECL|variable|memory_end
r_static
r_int
id|memory_end
op_assign
l_int|0
suffix:semicolon
DECL|variable|buffer_memory_end
r_static
r_int
id|buffer_memory_end
op_assign
l_int|0
suffix:semicolon
DECL|variable|main_memory_start
r_static
r_int
id|main_memory_start
op_assign
l_int|0
suffix:semicolon
DECL|variable|term
r_static
r_char
id|term
(braket
l_int|32
)braket
suffix:semicolon
DECL|variable|argv_init
r_static
r_char
op_star
id|argv_init
(braket
)braket
op_assign
(brace
l_string|&quot;/bin/init&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|envp_init
r_static
r_char
op_star
id|envp_init
(braket
)braket
op_assign
(brace
l_string|&quot;HOME=/&quot;
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|argv_rc
r_static
r_char
op_star
id|argv_rc
(braket
)braket
op_assign
(brace
l_string|&quot;/bin/sh&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|envp_rc
r_static
r_char
op_star
id|envp_rc
(braket
)braket
op_assign
(brace
l_string|&quot;HOME=/&quot;
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|argv
r_static
r_char
op_star
id|argv
(braket
)braket
op_assign
(brace
l_string|&quot;-/bin/sh&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|envp
r_static
r_char
op_star
id|envp
(braket
)braket
op_assign
(brace
l_string|&quot;HOME=/usr/root&quot;
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|drive_info
DECL|member|dummy
DECL|variable|drive_info
r_struct
id|drive_info
(brace
r_char
id|dummy
(braket
l_int|32
)braket
suffix:semicolon
)brace
id|drive_info
suffix:semicolon
DECL|function|start_kernel
r_void
id|start_kernel
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n; * Interrupts are still disabled. Do necessary setups, then&n; * enable them&n; */
id|ROOT_DEV
op_assign
id|ORIG_ROOT_DEV
suffix:semicolon
id|sprintf
c_func
(paren
id|term
comma
l_string|&quot;TERM=con%dx%d&quot;
comma
id|CON_COLS
comma
id|CON_ROWS
)paren
suffix:semicolon
id|envp
(braket
l_int|1
)braket
op_assign
id|term
suffix:semicolon
id|envp_rc
(braket
l_int|1
)braket
op_assign
id|term
suffix:semicolon
id|envp_init
(braket
l_int|1
)braket
op_assign
id|term
suffix:semicolon
id|drive_info
op_assign
id|DRIVE_INFO
suffix:semicolon
id|memory_end
op_assign
(paren
l_int|1
op_lshift
l_int|20
)paren
op_plus
(paren
id|EXT_MEM_K
op_lshift
l_int|10
)paren
suffix:semicolon
id|memory_end
op_and_assign
l_int|0xfffff000
suffix:semicolon
r_if
c_cond
(paren
id|memory_end
OG
l_int|16
op_star
l_int|1024
op_star
l_int|1024
)paren
id|memory_end
op_assign
l_int|16
op_star
l_int|1024
op_star
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
id|memory_end
op_ge
l_int|12
op_star
l_int|1024
op_star
l_int|1024
)paren
id|buffer_memory_end
op_assign
l_int|4
op_star
l_int|1024
op_star
l_int|1024
suffix:semicolon
r_else
r_if
c_cond
(paren
id|memory_end
op_ge
l_int|6
op_star
l_int|1024
op_star
l_int|1024
)paren
id|buffer_memory_end
op_assign
l_int|2
op_star
l_int|1024
op_star
l_int|1024
suffix:semicolon
r_else
r_if
c_cond
(paren
id|memory_end
op_ge
l_int|4
op_star
l_int|1024
op_star
l_int|1024
)paren
id|buffer_memory_end
op_assign
l_int|3
op_star
l_int|512
op_star
l_int|1024
suffix:semicolon
r_else
id|buffer_memory_end
op_assign
l_int|1
op_star
l_int|1024
op_star
l_int|1024
suffix:semicolon
id|main_memory_start
op_assign
id|buffer_memory_end
suffix:semicolon
id|trap_init
c_func
(paren
)paren
suffix:semicolon
id|init_IRQ
c_func
(paren
)paren
suffix:semicolon
id|sched_init
c_func
(paren
)paren
suffix:semicolon
id|main_memory_start
op_assign
id|chr_dev_init
c_func
(paren
id|main_memory_start
comma
id|memory_end
)paren
suffix:semicolon
id|main_memory_start
op_assign
id|blk_dev_init
c_func
(paren
id|main_memory_start
comma
id|memory_end
)paren
suffix:semicolon
id|mem_init
c_func
(paren
id|main_memory_start
comma
id|memory_end
)paren
suffix:semicolon
id|time_init
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Linux version &quot;
id|UTS_RELEASE
l_string|&quot; &quot;
id|__DATE__
l_string|&quot; &quot;
id|__TIME__
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|buffer_init
c_func
(paren
id|buffer_memory_end
)paren
suffix:semicolon
id|hd_init
c_func
(paren
)paren
suffix:semicolon
id|floppy_init
c_func
(paren
)paren
suffix:semicolon
id|sock_init
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SCSI
id|scsi_dev_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|move_to_user_mode
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fork
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* we count on this going ok */
id|init
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * task[0] is meant to be used as an &quot;idle&quot; task: it may not sleep, but&n; * it might do some general things like count free pages or it could be&n; * used to implement a reasonable LRU algorithm for the paging routines:&n; * anything that can be useful, but shouldn&squot;t take time from the real&n; * processes.&n; *&n; * Right now task[0] just does a infinite loop in user mode.&n; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* nothing */
suffix:semicolon
)brace
)brace
DECL|function|printf
r_static
r_int
id|printf
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_int
id|i
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|write
c_func
(paren
l_int|1
comma
id|printbuf
comma
id|i
op_assign
id|vsprintf
c_func
(paren
id|printbuf
comma
id|fmt
comma
id|args
)paren
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|init
r_void
id|init
c_func
(paren
r_void
)paren
(brace
r_int
id|pid
comma
id|i
suffix:semicolon
id|setup
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|drive_info
)paren
suffix:semicolon
(paren
r_void
)paren
id|open
c_func
(paren
l_string|&quot;/dev/tty1&quot;
comma
id|O_RDWR
comma
l_int|0
)paren
suffix:semicolon
(paren
r_void
)paren
id|dup
c_func
(paren
l_int|0
)paren
suffix:semicolon
(paren
r_void
)paren
id|dup
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%d buffers = %d bytes buffer space&bslash;n&bslash;r&quot;
comma
id|NR_BUFFERS
comma
id|NR_BUFFERS
op_star
id|BLOCK_SIZE
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Free mem: %d bytes&bslash;n&bslash;r&quot;
comma
id|memory_end
op_minus
id|main_memory_start
)paren
suffix:semicolon
id|execve
c_func
(paren
l_string|&quot;/etc/init&quot;
comma
id|argv_init
comma
id|envp_init
)paren
suffix:semicolon
id|execve
c_func
(paren
l_string|&quot;/bin/init&quot;
comma
id|argv_init
comma
id|envp_init
)paren
suffix:semicolon
multiline_comment|/* if this fails, fall through to original stuff */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pid
op_assign
id|fork
c_func
(paren
)paren
)paren
)paren
(brace
id|close
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|open
c_func
(paren
l_string|&quot;/etc/rc&quot;
comma
id|O_RDONLY
comma
l_int|0
)paren
)paren
id|_exit
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|execve
c_func
(paren
l_string|&quot;/bin/sh&quot;
comma
id|argv_rc
comma
id|envp_rc
)paren
suffix:semicolon
id|_exit
c_func
(paren
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pid
OG
l_int|0
)paren
r_while
c_loop
(paren
id|pid
op_ne
id|wait
c_func
(paren
op_amp
id|i
)paren
)paren
multiline_comment|/* nothing */
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|pid
op_assign
id|fork
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Fork failed in init&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pid
)paren
(brace
id|close
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|close
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|close
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|setsid
c_func
(paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|open
c_func
(paren
l_string|&quot;/dev/tty1&quot;
comma
id|O_RDWR
comma
l_int|0
)paren
suffix:semicolon
(paren
r_void
)paren
id|dup
c_func
(paren
l_int|0
)paren
suffix:semicolon
(paren
r_void
)paren
id|dup
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|_exit
c_func
(paren
id|execve
c_func
(paren
l_string|&quot;/bin/sh&quot;
comma
id|argv
comma
id|envp
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
r_if
c_cond
(paren
id|pid
op_eq
id|wait
c_func
(paren
op_amp
id|i
)paren
)paren
r_break
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&bslash;rchild %d died with code %04x&bslash;n&bslash;r&quot;
comma
id|pid
comma
id|i
)paren
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
)brace
id|_exit
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* NOTE! _exit, not exit() */
)brace
eof
