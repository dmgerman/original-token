multiline_comment|/*&n; *&t;DDP:&t;An implementation of the AppleTalk DDP protocol for&n; *&t;&t;Ethernet &squot;ELAP&squot;.&n; *&n; *&t;&t;Alan Cox  &lt;Alan.Cox@linux.org&gt;&n; *&n; *&t;&t;With more than a little assistance from&n; *&n; *&t;&t;Wesley Craig &lt;netatalk@umich.edu&gt;&n; *&n; *&t;Fixes:&n; *&t;&t;Michael Callahan&t;:&t;Made routing work&n; *&t;&t;Wesley Craig&t;&t;:&t;Fix probing to listen to a&n; *&t;&t;&t;&t;&t;&t;passed node id.&n; *&t;&t;Alan Cox&t;&t;:&t;Added send/recvmsg support&n; *&t;&t;Alan Cox&t;&t;:&t;Moved at. to protinfo in&n; *&t;&t;&t;&t;&t;&t;socket.&n; *&t;&t;Alan Cox&t;&t;:&t;Added firewall hooks.&n; *&t;&t;Alan Cox&t;&t;:&t;Supports new ARPHRD_LOOPBACK&n; *&t;&t;Christer Weinigel&t;: &t;Routing and /proc fixes.&n; *&t;&t;Bradford Johnson&t;:&t;LocalTalk.&n; *&t;&t;Tom Dyas&t;&t;:&t;Module support.&n; *&t;&t;Alan Cox&t;&t;:&t;Hooks for PPP (based on the&n; *&t;&t;&t;&t;&t;&t;LocalTalk hook).&n; *&t;&t;Alan Cox&t;&t;:&t;Posix bits&n; *&t;&t;Alan Cox/Mike Freeman&t;:&t;Possible fix to NBP problems&n; *&t;&t;Bradford Johnson&t;:&t;IP-over-DDP (experimental)&n; *&t;&t;Jay Schulist&t;&t;:&t;Moved IP-over-DDP to its own&n; *&t;&t;&t;&t;&t;&t;driver file. (ipddp.c &amp; ipddp.h)&n; *&t;&t;Jay Schulist&t;&t;:&t;Made work as module with &n; *&t;&t;&t;&t;&t;&t;AppleTalk drivers, cleaned it.&n; *&t;&t;Rob Newberry&t;&t;:&t;Added proxy AARP and AARP proc fs, &n; *&t;&t;&t;&t;&t;&t;moved probing to AARP module.&n; *              Adrian Sun/ &n; *              Michael Zuelsdorff      :       fix for net.0 packets. don&squot;t &n; *                                              allow illegal ether/tokentalk&n; *                                              port assignment. we lose a &n; *                                              valid localtalk port as a &n; *                                              result.&n; *              &n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; * &n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#if defined(CONFIG_ATALK) || defined(CONFIG_ATALK_MODULE)
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/inetdevice.h&gt;
macro_line|#include &lt;linux/route.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/termios.h&gt;&t;/* For TIOCOUTQ/INQ */
macro_line|#include &lt;net/datalink.h&gt;
macro_line|#include &lt;net/p8022.h&gt;
macro_line|#include &lt;net/psnap.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;linux/atalk.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#ifdef CONFIG_PROC_FS
r_extern
r_void
id|aarp_register_proc_fs
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|aarp_unregister_proc_fs
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
r_extern
r_void
id|aarp_probe_network
c_func
(paren
r_struct
id|atalk_iface
op_star
id|atif
)paren
suffix:semicolon
r_extern
r_int
id|aarp_proxy_probe_network
c_func
(paren
r_struct
id|atalk_iface
op_star
id|atif
comma
r_struct
id|at_addr
op_star
id|sa
)paren
suffix:semicolon
r_extern
r_void
id|aarp_proxy_remove
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|at_addr
op_star
id|sa
)paren
suffix:semicolon
DECL|macro|APPLETALK_DEBUG
macro_line|#undef APPLETALK_DEBUG
macro_line|#ifdef APPLETALK_DEBUG
DECL|macro|DPRINT
mdefine_line|#define DPRINT(x)&t;&t;print(x)
macro_line|#else
DECL|macro|DPRINT
mdefine_line|#define DPRINT(x)
macro_line|#endif /* APPLETALK_DEBUG */
macro_line|#ifdef CONFIG_SYSCTL
r_extern
r_inline
r_void
id|atalk_register_sysctl
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_inline
r_void
id|atalk_unregister_sysctl
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SYSCTL */
DECL|variable|ddp_dl
DECL|variable|aarp_dl
r_struct
id|datalink_proto
op_star
id|ddp_dl
comma
op_star
id|aarp_dl
suffix:semicolon
DECL|variable|atalk_dgram_ops
r_static
r_struct
id|proto_ops
id|atalk_dgram_ops
suffix:semicolon
DECL|macro|min
mdefine_line|#define min(a,b)&t;(((a)&lt;(b))?(a):(b))
multiline_comment|/**************************************************************************&bslash;&n;*                                                                          *&n;* Handlers for the socket list.                                            *&n;*                                                                          *&n;&bslash;**************************************************************************/
DECL|variable|atalk_sockets
r_static
r_struct
id|sock
op_star
id|atalk_sockets
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|atalk_sockets_lock
r_static
id|spinlock_t
id|atalk_sockets_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|atalk_insert_socket
r_extern
r_inline
r_void
id|atalk_insert_socket
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|atalk_sockets_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sk-&gt;next
op_assign
id|atalk_sockets
)paren
op_ne
l_int|NULL
)paren
id|atalk_sockets-&gt;pprev
op_assign
op_amp
id|sk-&gt;next
suffix:semicolon
id|atalk_sockets
op_assign
id|sk
suffix:semicolon
id|sk-&gt;pprev
op_assign
op_amp
id|atalk_sockets
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|atalk_sockets_lock
)paren
suffix:semicolon
)brace
DECL|function|atalk_remove_socket
r_extern
r_inline
r_void
id|atalk_remove_socket
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|atalk_sockets_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;pprev
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;next
)paren
id|sk-&gt;next-&gt;pprev
op_assign
id|sk-&gt;pprev
suffix:semicolon
op_star
id|sk-&gt;pprev
op_assign
id|sk-&gt;next
suffix:semicolon
id|sk-&gt;pprev
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|atalk_sockets_lock
)paren
suffix:semicolon
)brace
DECL|function|atalk_search_socket
r_static
r_struct
id|sock
op_star
id|atalk_search_socket
c_func
(paren
r_struct
id|sockaddr_at
op_star
id|to
comma
r_struct
id|atalk_iface
op_star
id|atif
)paren
(brace
r_struct
id|sock
op_star
id|s
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|atalk_sockets_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
id|atalk_sockets
suffix:semicolon
id|s
op_ne
l_int|NULL
suffix:semicolon
id|s
op_assign
id|s-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|to-&gt;sat_port
op_ne
id|s-&gt;protinfo.af_at.src_port
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|to-&gt;sat_addr.s_net
op_eq
id|ATADDR_ANYNET
op_logical_and
id|to-&gt;sat_addr.s_node
op_eq
id|ATADDR_BCAST
op_logical_and
id|s-&gt;protinfo.af_at.src_net
op_eq
id|atif-&gt;address.s_net
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|to-&gt;sat_addr.s_net
op_eq
id|s-&gt;protinfo.af_at.src_net
op_logical_and
(paren
id|to-&gt;sat_addr.s_node
op_eq
id|s-&gt;protinfo.af_at.src_node
op_logical_or
id|to-&gt;sat_addr.s_node
op_eq
id|ATADDR_BCAST
op_logical_or
id|to-&gt;sat_addr.s_node
op_eq
id|ATADDR_ANYNODE
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* XXXX.0 -- we got a request for this router. make sure&n;&t;&t; * that the node is appropriately set. */
r_if
c_cond
(paren
id|to-&gt;sat_addr.s_node
op_eq
id|ATADDR_ANYNODE
op_logical_and
id|to-&gt;sat_addr.s_net
op_ne
id|ATADDR_ANYNET
op_logical_and
id|atif-&gt;address.s_node
op_eq
id|s-&gt;protinfo.af_at.src_node
)paren
(brace
id|to-&gt;sat_addr.s_node
op_assign
id|atif-&gt;address.s_node
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|atalk_sockets_lock
)paren
suffix:semicolon
r_return
id|s
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to find a socket matching ADDR in the socket list,&n; * if found then return it.  If not, insert SK into the&n; * socket list.&n; *&n; * This entire operation must execute atomically.&n; */
DECL|function|atalk_find_or_insert_socket
r_static
r_struct
id|sock
op_star
id|atalk_find_or_insert_socket
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr_at
op_star
id|sat
)paren
(brace
r_struct
id|sock
op_star
id|s
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|atalk_sockets_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
id|atalk_sockets
suffix:semicolon
id|s
op_ne
l_int|NULL
suffix:semicolon
id|s
op_assign
id|s-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;protinfo.af_at.src_net
op_eq
id|sat-&gt;sat_addr.s_net
op_logical_and
id|s-&gt;protinfo.af_at.src_node
op_eq
id|sat-&gt;sat_addr.s_node
op_logical_and
id|s-&gt;protinfo.af_at.src_port
op_eq
id|sat-&gt;sat_port
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
(brace
multiline_comment|/* Wheee, it&squot;s free, assign and insert. */
r_if
c_cond
(paren
(paren
id|sk-&gt;next
op_assign
id|atalk_sockets
)paren
op_ne
l_int|NULL
)paren
id|atalk_sockets-&gt;pprev
op_assign
op_amp
id|sk-&gt;next
suffix:semicolon
id|atalk_sockets
op_assign
id|sk
suffix:semicolon
id|sk-&gt;pprev
op_assign
op_amp
id|atalk_sockets
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|atalk_sockets_lock
)paren
suffix:semicolon
r_return
id|s
suffix:semicolon
)brace
DECL|function|atalk_destroy_timer
r_static
r_void
id|atalk_destroy_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
op_eq
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
op_eq
l_int|0
op_logical_and
id|sk-&gt;dead
)paren
(brace
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|SOCK_DESTROY_TIME
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
)brace
)brace
DECL|function|atalk_destroy_socket
r_extern
r_inline
r_void
id|atalk_destroy_socket
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|atalk_remove_socket
c_func
(paren
id|sk
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_ne
l_int|NULL
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
op_eq
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
op_eq
l_int|0
op_logical_and
id|sk-&gt;dead
)paren
(brace
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
r_else
(brace
id|init_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
id|sk-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|SOCK_DESTROY_TIME
suffix:semicolon
id|sk-&gt;timer.function
op_assign
id|atalk_destroy_timer
suffix:semicolon
id|sk-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Called from proc fs&n; */
DECL|function|atalk_get_info
r_static
r_int
id|atalk_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_struct
id|sock
op_star
id|s
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Output the AppleTalk data for the /proc filesystem.&n;&t; */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;Type local_addr  remote_addr tx_queue rx_queue st uid&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|atalk_sockets_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
id|atalk_sockets
suffix:semicolon
id|s
op_ne
l_int|NULL
suffix:semicolon
id|s
op_assign
id|s-&gt;next
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%02X   &quot;
comma
id|s-&gt;type
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%04X:%02X:%02X  &quot;
comma
id|ntohs
c_func
(paren
id|s-&gt;protinfo.af_at.src_net
)paren
comma
id|s-&gt;protinfo.af_at.src_node
comma
id|s-&gt;protinfo.af_at.src_port
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%04X:%02X:%02X  &quot;
comma
id|ntohs
c_func
(paren
id|s-&gt;protinfo.af_at.dest_net
)paren
comma
id|s-&gt;protinfo.af_at.dest_node
comma
id|s-&gt;protinfo.af_at.dest_port
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%08X:%08X &quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|s-&gt;wmem_alloc
)paren
comma
id|atomic_read
c_func
(paren
op_amp
id|s-&gt;rmem_alloc
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%02X %d&bslash;n&quot;
comma
id|s-&gt;state
comma
id|SOCK_INODE
c_func
(paren
id|s-&gt;socket
)paren
op_member_access_from_pointer
id|i_uid
)paren
suffix:semicolon
multiline_comment|/* Are we still dumping unwanted data then discard the record */
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Keep dumping into the buffer start */
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
multiline_comment|/* We have dumped enough */
r_break
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|atalk_sockets_lock
)paren
suffix:semicolon
multiline_comment|/* The data in question runs from begin to begin+len */
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Remove unwanted header data from length */
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
multiline_comment|/* Remove unwanted tail data from length */
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&bslash;&n;*                                                                          *&n;* Routing tables for the AppleTalk socket layer.                           *&n;*                                                                          *&n;&bslash;**************************************************************************/
multiline_comment|/* Anti-deadlock ordering is router_lock --&gt; iface_lock -DaveM */
DECL|variable|atalk_router_list
r_static
r_struct
id|atalk_route
op_star
id|atalk_router_list
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|atalk_router_lock
r_static
id|rwlock_t
id|atalk_router_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|atalk_iface_list
r_static
r_struct
id|atalk_iface
op_star
id|atalk_iface_list
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|atalk_iface_lock
r_static
id|spinlock_t
id|atalk_iface_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|atrtr_default
r_static
r_struct
id|atalk_route
id|atrtr_default
suffix:semicolon
multiline_comment|/* For probing devices or in a routerless network */
multiline_comment|/*&n; * AppleTalk interface control&n; */
multiline_comment|/*&n; * Drop a device. Doesn&squot;t drop any of its routes - that is the caller&squot;s&n; * problem. Called when we down the interface or delete the address.&n; */
DECL|function|atif_drop_device
r_static
r_void
id|atif_drop_device
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|atalk_iface
op_star
op_star
id|iface
op_assign
op_amp
id|atalk_iface_list
suffix:semicolon
r_struct
id|atalk_iface
op_star
id|tmp
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|atalk_iface_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
op_star
id|iface
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;dev
op_eq
id|dev
)paren
(brace
op_star
id|iface
op_assign
id|tmp-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|dev-&gt;atalk_ptr
op_assign
l_int|NULL
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
r_else
id|iface
op_assign
op_amp
id|tmp-&gt;next
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|atalk_iface_lock
)paren
suffix:semicolon
)brace
DECL|function|atif_add_device
r_static
r_struct
id|atalk_iface
op_star
id|atif_add_device
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|at_addr
op_star
id|sa
)paren
(brace
r_struct
id|atalk_iface
op_star
id|iface
op_assign
(paren
r_struct
id|atalk_iface
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|iface
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iface
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|iface-&gt;dev
op_assign
id|dev
suffix:semicolon
id|dev-&gt;atalk_ptr
op_assign
id|iface
suffix:semicolon
id|iface-&gt;address
op_assign
op_star
id|sa
suffix:semicolon
id|iface-&gt;status
op_assign
l_int|0
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|atalk_iface_lock
)paren
suffix:semicolon
id|iface-&gt;next
op_assign
id|atalk_iface_list
suffix:semicolon
id|atalk_iface_list
op_assign
id|iface
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|atalk_iface_lock
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
id|iface
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform phase 2 AARP probing on our tentative address.&n; */
DECL|function|atif_probe_device
r_static
r_int
id|atif_probe_device
c_func
(paren
r_struct
id|atalk_iface
op_star
id|atif
)paren
(brace
r_int
id|netrange
op_assign
id|ntohs
c_func
(paren
id|atif-&gt;nets.nr_lastnet
)paren
op_minus
id|ntohs
c_func
(paren
id|atif-&gt;nets.nr_firstnet
)paren
op_plus
l_int|1
suffix:semicolon
r_int
id|probe_net
op_assign
id|ntohs
c_func
(paren
id|atif-&gt;address.s_net
)paren
suffix:semicolon
r_int
id|probe_node
op_assign
id|atif-&gt;address.s_node
suffix:semicolon
r_int
id|netct
comma
id|nodect
suffix:semicolon
multiline_comment|/*&n;&t; * Offset the network we start probing with.&n;&t; */
r_if
c_cond
(paren
id|probe_net
op_eq
id|ATADDR_ANYNET
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|netrange
)paren
id|probe_net
op_assign
id|ntohs
c_func
(paren
id|atif-&gt;nets.nr_firstnet
)paren
suffix:semicolon
r_else
id|probe_net
op_assign
id|ntohs
c_func
(paren
id|atif-&gt;nets.nr_firstnet
)paren
op_plus
(paren
id|jiffies
op_mod
id|netrange
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|probe_node
op_eq
id|ATADDR_ANYNODE
)paren
id|probe_node
op_assign
id|jiffies
op_amp
l_int|0xFF
suffix:semicolon
multiline_comment|/*&n;&t; * Scan the networks.&n;&t; */
id|atif-&gt;status
op_or_assign
id|ATIF_PROBE
suffix:semicolon
r_for
c_loop
(paren
id|netct
op_assign
l_int|0
suffix:semicolon
id|netct
op_le
id|netrange
suffix:semicolon
id|netct
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Sweep the available nodes from a given start.&n;&t;&t; */
id|atif-&gt;address.s_net
op_assign
id|htons
c_func
(paren
id|probe_net
)paren
suffix:semicolon
r_for
c_loop
(paren
id|nodect
op_assign
l_int|0
suffix:semicolon
id|nodect
OL
l_int|256
suffix:semicolon
id|nodect
op_increment
)paren
(brace
id|atif-&gt;address.s_node
op_assign
(paren
(paren
id|nodect
op_plus
id|probe_node
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atif-&gt;address.s_node
OG
l_int|0
op_logical_and
id|atif-&gt;address.s_node
OL
l_int|254
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Probe a proposed address.&n;&t;&t;&t;&t; */
id|aarp_probe_network
c_func
(paren
id|atif
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|atif-&gt;status
op_amp
id|ATIF_PROBE_FAIL
)paren
)paren
(brace
id|atif-&gt;status
op_and_assign
op_complement
id|ATIF_PROBE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|atif-&gt;status
op_and_assign
op_complement
id|ATIF_PROBE_FAIL
suffix:semicolon
)brace
id|probe_net
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|probe_net
OG
id|ntohs
c_func
(paren
id|atif-&gt;nets.nr_lastnet
)paren
)paren
id|probe_net
op_assign
id|ntohs
c_func
(paren
id|atif-&gt;nets.nr_firstnet
)paren
suffix:semicolon
)brace
id|atif-&gt;status
op_and_assign
op_complement
id|ATIF_PROBE
suffix:semicolon
r_return
op_minus
id|EADDRINUSE
suffix:semicolon
multiline_comment|/* Network is full... */
)brace
multiline_comment|/*&n; * Perform AARP probing for a proxy address&n; */
DECL|function|atif_proxy_probe_device
r_static
r_int
id|atif_proxy_probe_device
c_func
(paren
r_struct
id|atalk_iface
op_star
id|atif
comma
r_struct
id|at_addr
op_star
id|proxy_addr
)paren
(brace
r_int
id|netrange
op_assign
id|ntohs
c_func
(paren
id|atif-&gt;nets.nr_lastnet
)paren
op_minus
id|ntohs
c_func
(paren
id|atif-&gt;nets.nr_firstnet
)paren
op_plus
l_int|1
suffix:semicolon
r_int
id|probe_net
op_assign
id|ntohs
c_func
(paren
id|atif-&gt;address.s_net
)paren
suffix:semicolon
multiline_comment|/* we probe the interface&squot;s network */
r_int
id|probe_node
op_assign
id|ATADDR_ANYNODE
suffix:semicolon
multiline_comment|/* we&squot;ll take anything */
r_int
id|netct
comma
id|nodect
suffix:semicolon
multiline_comment|/*&n;&t; * Offset the network we start probing with.&n;&t; */
r_if
c_cond
(paren
id|probe_net
op_eq
id|ATADDR_ANYNET
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|netrange
)paren
id|probe_net
op_assign
id|ntohs
c_func
(paren
id|atif-&gt;nets.nr_firstnet
)paren
suffix:semicolon
r_else
id|probe_net
op_assign
id|ntohs
c_func
(paren
id|atif-&gt;nets.nr_firstnet
)paren
op_plus
(paren
id|jiffies
op_mod
id|netrange
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|probe_node
op_eq
id|ATADDR_ANYNODE
)paren
id|probe_node
op_assign
id|jiffies
op_amp
l_int|0xFF
suffix:semicolon
multiline_comment|/*&n;&t; * Scan the networks.&n;&t; */
r_for
c_loop
(paren
id|netct
op_assign
l_int|0
suffix:semicolon
id|netct
op_le
id|netrange
suffix:semicolon
id|netct
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Sweep the available nodes from a given start.&n;&t;&t; */
id|proxy_addr-&gt;s_net
op_assign
id|htons
c_func
(paren
id|probe_net
)paren
suffix:semicolon
r_for
c_loop
(paren
id|nodect
op_assign
l_int|0
suffix:semicolon
id|nodect
OL
l_int|256
suffix:semicolon
id|nodect
op_increment
)paren
(brace
id|proxy_addr-&gt;s_node
op_assign
(paren
(paren
id|nodect
op_plus
id|probe_node
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|proxy_addr-&gt;s_node
OG
l_int|0
)paren
op_logical_and
(paren
id|proxy_addr-&gt;s_node
OL
l_int|254
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Tell AARP to probe a proposed address.&n;&t;&t;&t;&t; */
r_int
id|probe_result
op_assign
id|aarp_proxy_probe_network
c_func
(paren
id|atif
comma
id|proxy_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|probe_result
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|probe_result
op_ne
op_minus
id|EADDRINUSE
)paren
r_return
id|probe_result
suffix:semicolon
)brace
)brace
id|probe_net
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|probe_net
OG
id|ntohs
c_func
(paren
id|atif-&gt;nets.nr_lastnet
)paren
)paren
(brace
id|probe_net
op_assign
id|ntohs
c_func
(paren
id|atif-&gt;nets.nr_firstnet
)paren
suffix:semicolon
)brace
)brace
r_return
op_minus
id|EADDRINUSE
suffix:semicolon
multiline_comment|/* Network is full... */
)brace
DECL|function|atalk_find_dev_addr
r_struct
id|at_addr
op_star
id|atalk_find_dev_addr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|atalk_iface
op_star
id|iface
op_assign
id|dev-&gt;atalk_ptr
suffix:semicolon
r_if
c_cond
(paren
id|iface
)paren
(brace
r_return
op_amp
id|iface-&gt;address
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|atalk_find_primary
r_static
r_struct
id|at_addr
op_star
id|atalk_find_primary
c_func
(paren
r_void
)paren
(brace
r_struct
id|at_addr
op_star
id|retval
suffix:semicolon
r_struct
id|atalk_iface
op_star
id|iface
suffix:semicolon
r_struct
id|atalk_iface
op_star
id|fiface
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Return a point-to-point interface only if&n;&t; * there is no non-ptp interface available.&n;&t; */
id|spin_lock_bh
c_func
(paren
op_amp
id|atalk_iface_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|iface
op_assign
id|atalk_iface_list
suffix:semicolon
id|iface
op_ne
l_int|NULL
suffix:semicolon
id|iface
op_assign
id|iface-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fiface
op_logical_and
op_logical_neg
(paren
id|iface-&gt;dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
)paren
id|fiface
op_assign
id|iface
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|iface-&gt;dev-&gt;flags
op_amp
(paren
id|IFF_LOOPBACK
op_or
id|IFF_POINTOPOINT
)paren
)paren
)paren
(brace
id|retval
op_assign
op_amp
id|iface-&gt;address
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|fiface
)paren
(brace
id|retval
op_assign
op_amp
id|fiface-&gt;address
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|atalk_iface_list
op_ne
l_int|NULL
)paren
(brace
id|retval
op_assign
op_amp
id|atalk_iface_list-&gt;address
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
l_int|NULL
suffix:semicolon
)brace
id|out
suffix:colon
id|spin_unlock_bh
c_func
(paren
op_amp
id|atalk_iface_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Find a match for &squot;any network&squot; - ie any of our interfaces with that&n; * node number will do just nicely.&n; */
DECL|function|atalk_find_anynet
r_static
r_struct
id|atalk_iface
op_star
id|atalk_find_anynet
c_func
(paren
r_int
id|node
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|atalk_iface
op_star
id|iface
op_assign
id|dev-&gt;atalk_ptr
suffix:semicolon
r_if
c_cond
(paren
id|iface
op_eq
l_int|NULL
op_logical_or
(paren
id|iface-&gt;status
op_amp
id|ATIF_PROBE
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|node
op_eq
id|ATADDR_BCAST
op_logical_or
id|iface-&gt;address.s_node
op_eq
id|node
op_logical_or
id|node
op_eq
id|ATADDR_ANYNODE
)paren
r_return
id|iface
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Find a match for a specific network:node pair&n; */
DECL|function|atalk_find_interface
r_static
r_struct
id|atalk_iface
op_star
id|atalk_find_interface
c_func
(paren
r_int
id|net
comma
r_int
id|node
)paren
(brace
r_struct
id|atalk_iface
op_star
id|iface
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|atalk_iface_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|iface
op_assign
id|atalk_iface_list
suffix:semicolon
id|iface
op_ne
l_int|NULL
suffix:semicolon
id|iface
op_assign
id|iface-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|node
op_eq
id|ATADDR_BCAST
op_logical_or
id|node
op_eq
id|ATADDR_ANYNODE
op_logical_or
id|iface-&gt;address.s_node
op_eq
id|node
)paren
op_logical_and
id|iface-&gt;address.s_net
op_eq
id|net
op_logical_and
op_logical_neg
(paren
id|iface-&gt;status
op_amp
id|ATIF_PROBE
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* XXXX.0 -- net.0 returns the iface associated with net */
r_if
c_cond
(paren
(paren
id|node
op_eq
id|ATADDR_ANYNODE
)paren
op_logical_and
(paren
id|net
op_ne
id|ATADDR_ANYNET
)paren
op_logical_and
(paren
id|ntohs
c_func
(paren
id|iface-&gt;nets.nr_firstnet
)paren
op_le
id|ntohs
c_func
(paren
id|net
)paren
)paren
op_logical_and
(paren
id|ntohs
c_func
(paren
id|net
)paren
op_le
id|ntohs
c_func
(paren
id|iface-&gt;nets.nr_lastnet
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|atalk_iface_lock
)paren
suffix:semicolon
r_return
id|iface
suffix:semicolon
)brace
multiline_comment|/*&n; * Find a route for an AppleTalk packet. This ought to get cached in&n; * the socket (later on...). We know about host routes and the fact&n; * that a route must be direct to broadcast.&n; */
DECL|function|atrtr_find
r_static
r_struct
id|atalk_route
op_star
id|atrtr_find
c_func
(paren
r_struct
id|at_addr
op_star
id|target
)paren
(brace
multiline_comment|/*&n;&t; * we must search through all routes unless we find a &n;&t; * host route, because some host routes might overlap&n;&t; * network routes&n;&t; */
r_struct
id|atalk_route
op_star
id|r
suffix:semicolon
r_struct
id|atalk_route
op_star
id|net_route
op_assign
l_int|NULL
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|atalk_router_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|r
op_assign
id|atalk_router_list
suffix:semicolon
id|r
op_ne
l_int|NULL
suffix:semicolon
id|r
op_assign
id|r-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|r-&gt;flags
op_amp
id|RTF_UP
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;target.s_net
op_eq
id|target-&gt;s_net
)paren
(brace
r_if
c_cond
(paren
id|r-&gt;flags
op_amp
id|RTF_HOST
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * if this host route is for the target,&n;&t;&t;&t;&t; * the we&squot;re done&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|r-&gt;target.s_node
op_eq
id|target-&gt;s_node
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * this route will work if there isn&squot;t a&n;&t;&t;&t;&t; * direct host route, so cache it&n;&t;&t;&t;&t; */
id|net_route
op_assign
id|r
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* &n;&t; * if we found a network route but not a direct host&n;&t; * route, then return it&n;&t; */
r_if
c_cond
(paren
id|net_route
op_ne
l_int|NULL
)paren
(brace
id|r
op_assign
id|net_route
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|atrtr_default.dev
)paren
(brace
id|r
op_assign
op_amp
id|atrtr_default
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * No route can be found.&n;&t;&t; */
id|r
op_assign
l_int|NULL
suffix:semicolon
)brace
id|out
suffix:colon
id|read_unlock_bh
c_func
(paren
op_amp
id|atalk_router_lock
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/*&n; * Given an AppleTalk network, find the device to use. This can be&n; * a simple lookup.&n; */
DECL|function|atrtr_get_dev
r_struct
id|net_device
op_star
id|atrtr_get_dev
c_func
(paren
r_struct
id|at_addr
op_star
id|sa
)paren
(brace
r_struct
id|atalk_route
op_star
id|atr
op_assign
id|atrtr_find
c_func
(paren
id|sa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atr
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_else
r_return
id|atr-&gt;dev
suffix:semicolon
)brace
multiline_comment|/*&n; * Set up a default router.&n; */
DECL|function|atrtr_set_default
r_static
r_void
id|atrtr_set_default
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|atrtr_default.dev
op_assign
id|dev
suffix:semicolon
id|atrtr_default.flags
op_assign
id|RTF_UP
suffix:semicolon
id|atrtr_default.gateway.s_net
op_assign
id|htons
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|atrtr_default.gateway.s_node
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a router. Basically make sure it looks valid and stuff the&n; * entry in the list. While it uses netranges we always set them to one&n; * entry to work like netatalk.&n; */
DECL|function|atrtr_create
r_static
r_int
id|atrtr_create
c_func
(paren
r_struct
id|rtentry
op_star
id|r
comma
r_struct
id|net_device
op_star
id|devhint
)paren
(brace
r_struct
id|sockaddr_at
op_star
id|ta
op_assign
(paren
r_struct
id|sockaddr_at
op_star
)paren
op_amp
id|r-&gt;rt_dst
suffix:semicolon
r_struct
id|sockaddr_at
op_star
id|ga
op_assign
(paren
r_struct
id|sockaddr_at
op_star
)paren
op_amp
id|r-&gt;rt_gateway
suffix:semicolon
r_struct
id|atalk_route
op_star
id|rt
suffix:semicolon
r_struct
id|atalk_iface
op_star
id|iface
comma
op_star
id|riface
suffix:semicolon
r_int
id|retval
suffix:semicolon
multiline_comment|/*&n;&t; * Fixme: Raise/Lower a routing change semaphore for these&n;&t; * operations.&n;&t; */
multiline_comment|/*&n;&t; * Validate the request&n;&t; */
r_if
c_cond
(paren
id|ta-&gt;sat_family
op_ne
id|AF_APPLETALK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|devhint
op_eq
l_int|NULL
op_logical_and
id|ga-&gt;sat_family
op_ne
id|AF_APPLETALK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * Now walk the routing table and make our decisions.&n;&t; */
id|write_lock_bh
c_func
(paren
op_amp
id|atalk_router_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|rt
op_assign
id|atalk_router_list
suffix:semicolon
id|rt
op_ne
l_int|NULL
suffix:semicolon
id|rt
op_assign
id|rt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|r-&gt;rt_flags
op_ne
id|rt-&gt;flags
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ta-&gt;sat_addr.s_net
op_eq
id|rt-&gt;target.s_net
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|rt-&gt;flags
op_amp
id|RTF_HOST
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ta-&gt;sat_addr.s_node
op_eq
id|rt-&gt;target.s_node
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|devhint
op_eq
l_int|NULL
)paren
(brace
id|riface
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|atalk_iface_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|iface
op_assign
id|atalk_iface_list
suffix:semicolon
id|iface
suffix:semicolon
id|iface
op_assign
id|iface-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|riface
op_eq
l_int|NULL
op_logical_and
id|ntohs
c_func
(paren
id|ga-&gt;sat_addr.s_net
)paren
op_ge
id|ntohs
c_func
(paren
id|iface-&gt;nets.nr_firstnet
)paren
op_logical_and
id|ntohs
c_func
(paren
id|ga-&gt;sat_addr.s_net
)paren
op_le
id|ntohs
c_func
(paren
id|iface-&gt;nets.nr_lastnet
)paren
)paren
id|riface
op_assign
id|iface
suffix:semicolon
r_if
c_cond
(paren
id|ga-&gt;sat_addr.s_net
op_eq
id|iface-&gt;address.s_net
op_logical_and
id|ga-&gt;sat_addr.s_node
op_eq
id|iface-&gt;address.s_node
)paren
id|riface
op_assign
id|iface
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|atalk_iface_lock
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENETUNREACH
suffix:semicolon
r_if
c_cond
(paren
id|riface
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
id|devhint
op_assign
id|riface-&gt;dev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
(brace
id|rt
op_assign
(paren
r_struct
id|atalk_route
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|atalk_route
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
id|rt-&gt;next
op_assign
id|atalk_router_list
suffix:semicolon
id|atalk_router_list
op_assign
id|rt
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fill in the routing entry.&n;&t; */
id|rt-&gt;target
op_assign
id|ta-&gt;sat_addr
suffix:semicolon
id|rt-&gt;dev
op_assign
id|devhint
suffix:semicolon
id|rt-&gt;flags
op_assign
id|r-&gt;rt_flags
suffix:semicolon
id|rt-&gt;gateway
op_assign
id|ga-&gt;sat_addr
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|write_unlock_bh
c_func
(paren
op_amp
id|atalk_router_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Delete a route. Find it and discard it.&n; */
DECL|function|atrtr_delete
r_static
r_int
id|atrtr_delete
c_func
(paren
r_struct
id|at_addr
op_star
id|addr
)paren
(brace
r_struct
id|atalk_route
op_star
op_star
id|r
op_assign
op_amp
id|atalk_router_list
suffix:semicolon
r_struct
id|atalk_route
op_star
id|tmp
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|atalk_router_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
op_star
id|r
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;target.s_net
op_eq
id|addr-&gt;s_net
op_logical_and
(paren
op_logical_neg
(paren
id|tmp-&gt;flags
op_amp
id|RTF_GATEWAY
)paren
op_logical_or
id|tmp-&gt;target.s_node
op_eq
id|addr-&gt;s_node
)paren
)paren
(brace
op_star
id|r
op_assign
id|tmp-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|r
op_assign
op_amp
id|tmp-&gt;next
suffix:semicolon
)brace
id|retval
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|out
suffix:colon
id|write_unlock_bh
c_func
(paren
op_amp
id|atalk_router_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when a device is downed. Just throw away any routes&n; * via it.&n; */
DECL|function|atrtr_device_down
r_void
id|atrtr_device_down
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|atalk_route
op_star
op_star
id|r
op_assign
op_amp
id|atalk_router_list
suffix:semicolon
r_struct
id|atalk_route
op_star
id|tmp
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|atalk_router_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
op_star
id|r
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;dev
op_eq
id|dev
)paren
(brace
op_star
id|r
op_assign
id|tmp-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
r_else
(brace
id|r
op_assign
op_amp
id|tmp-&gt;next
suffix:semicolon
)brace
)brace
id|write_unlock_bh
c_func
(paren
op_amp
id|atalk_router_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atrtr_default.dev
op_eq
id|dev
)paren
id|atrtr_set_default
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Actually down the interface.&n; */
DECL|function|atalk_dev_down
r_static
r_inline
r_void
id|atalk_dev_down
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|atrtr_device_down
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Remove all routes for the device */
id|aarp_device_down
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Remove AARP entries for the device */
id|atif_drop_device
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Remove the device */
)brace
multiline_comment|/*&n; * A device event has occurred. Watch for devices going down and&n; * delete our use of them (iface and route).&n; */
DECL|function|ddp_device_event
r_static
r_int
id|ddp_device_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|event
comma
r_void
op_star
id|ptr
)paren
(brace
r_if
c_cond
(paren
id|event
op_eq
id|NETDEV_DOWN
)paren
(brace
multiline_comment|/* Discard any use of this */
id|atalk_dev_down
c_func
(paren
(paren
r_struct
id|net_device
op_star
)paren
id|ptr
)paren
suffix:semicolon
)brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
multiline_comment|/*&n; * ioctl calls. Shouldn&squot;t even need touching.&n; */
multiline_comment|/*&n; * Device configuration ioctl calls.&n; */
DECL|function|atif_ioctl
r_int
id|atif_ioctl
c_func
(paren
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|ifreq
id|atreq
suffix:semicolon
r_static
r_char
id|aarp_mcast
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x09
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xFF
comma
l_int|0xFF
comma
l_int|0xFF
)brace
suffix:semicolon
r_struct
id|netrange
op_star
id|nr
suffix:semicolon
r_struct
id|sockaddr_at
op_star
id|sa
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|atalk_iface
op_star
id|atif
suffix:semicolon
r_int
id|ct
suffix:semicolon
r_int
id|limit
suffix:semicolon
r_struct
id|rtentry
id|rtdef
suffix:semicolon
r_int
id|add_route
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|atreq
comma
id|arg
comma
r_sizeof
(paren
id|atreq
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|__dev_get_by_name
c_func
(paren
id|atreq.ifr_name
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|sa
op_assign
(paren
r_struct
id|sockaddr_at
op_star
)paren
op_amp
id|atreq.ifr_addr
suffix:semicolon
id|atif
op_assign
id|atalk_find_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCSIFADDR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|sa-&gt;sat_family
op_ne
id|AF_APPLETALK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;type
op_ne
id|ARPHRD_ETHER
op_logical_and
id|dev-&gt;type
op_ne
id|ARPHRD_LOOPBACK
op_logical_and
id|dev-&gt;type
op_ne
id|ARPHRD_LOCALTLK
op_logical_and
id|dev-&gt;type
op_ne
id|ARPHRD_PPP
)paren
r_return
op_minus
id|EPROTONOSUPPORT
suffix:semicolon
id|nr
op_assign
(paren
r_struct
id|netrange
op_star
)paren
op_amp
id|sa-&gt;sat_zero
(braket
l_int|0
)braket
suffix:semicolon
id|add_route
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * if this is a point-to-point iface, and we already have an &n;&t;&t;&t; * iface for this AppleTalk address, then we should not add a route&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_POINTOPOINT
)paren
op_logical_and
id|atalk_find_interface
c_func
(paren
id|sa-&gt;sat_addr.s_net
comma
id|sa-&gt;sat_addr.s_node
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;AppleTalk: point-to-point interface added with existing address&bslash;n&quot;
)paren
suffix:semicolon
id|add_route
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Phase 1 is fine on LocalTalk but we don&squot;t do&n;&t;&t;&t; * EtherTalk phase 1. Anyone wanting to add it go ahead.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|ARPHRD_ETHER
op_logical_and
id|nr-&gt;nr_phase
op_ne
l_int|2
)paren
r_return
op_minus
id|EPROTONOSUPPORT
suffix:semicolon
r_if
c_cond
(paren
id|sa-&gt;sat_addr.s_node
op_eq
id|ATADDR_BCAST
op_logical_or
id|sa-&gt;sat_addr.s_node
op_eq
l_int|254
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|atif
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Already setting address.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|atif-&gt;status
op_amp
id|ATIF_PROBE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|atif-&gt;address.s_net
op_assign
id|sa-&gt;sat_addr.s_net
suffix:semicolon
id|atif-&gt;address.s_node
op_assign
id|sa-&gt;sat_addr.s_node
suffix:semicolon
id|atrtr_device_down
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Flush old routes */
)brace
r_else
(brace
id|atif
op_assign
id|atif_add_device
c_func
(paren
id|dev
comma
op_amp
id|sa-&gt;sat_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atif
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|atif-&gt;nets
op_assign
op_star
id|nr
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Check if the chosen address is used. If so we&n;&t;&t;&t; * error and atalkd will try another.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
op_logical_and
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_POINTOPOINT
)paren
op_logical_and
id|atif_probe_device
c_func
(paren
id|atif
)paren
OL
l_int|0
)paren
(brace
id|atif_drop_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|EADDRINUSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Hey it worked - add the direct routes.&n;&t;&t;&t; */
id|sa
op_assign
(paren
r_struct
id|sockaddr_at
op_star
)paren
op_amp
id|rtdef.rt_gateway
suffix:semicolon
id|sa-&gt;sat_family
op_assign
id|AF_APPLETALK
suffix:semicolon
id|sa-&gt;sat_addr.s_net
op_assign
id|atif-&gt;address.s_net
suffix:semicolon
id|sa-&gt;sat_addr.s_node
op_assign
id|atif-&gt;address.s_node
suffix:semicolon
id|sa
op_assign
(paren
r_struct
id|sockaddr_at
op_star
)paren
op_amp
id|rtdef.rt_dst
suffix:semicolon
id|rtdef.rt_flags
op_assign
id|RTF_UP
suffix:semicolon
id|sa-&gt;sat_family
op_assign
id|AF_APPLETALK
suffix:semicolon
id|sa-&gt;sat_addr.s_node
op_assign
id|ATADDR_ANYNODE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
op_logical_or
(paren
id|dev-&gt;flags
op_amp
id|IFF_POINTOPOINT
)paren
)paren
id|rtdef.rt_flags
op_or_assign
id|RTF_HOST
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Routerless initial state.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|nr-&gt;nr_firstnet
op_eq
id|htons
c_func
(paren
l_int|0
)paren
op_logical_and
id|nr-&gt;nr_lastnet
op_eq
id|htons
c_func
(paren
l_int|0xFFFE
)paren
)paren
(brace
id|sa-&gt;sat_addr.s_net
op_assign
id|atif-&gt;address.s_net
suffix:semicolon
id|atrtr_create
c_func
(paren
op_amp
id|rtdef
comma
id|dev
)paren
suffix:semicolon
id|atrtr_set_default
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|limit
op_assign
id|ntohs
c_func
(paren
id|nr-&gt;nr_lastnet
)paren
suffix:semicolon
r_if
c_cond
(paren
id|limit
op_minus
id|ntohs
c_func
(paren
id|nr-&gt;nr_firstnet
)paren
OG
l_int|4096
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Too many routes/iface.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|add_route
)paren
(brace
r_for
c_loop
(paren
id|ct
op_assign
id|ntohs
c_func
(paren
id|nr-&gt;nr_firstnet
)paren
suffix:semicolon
id|ct
op_le
id|limit
suffix:semicolon
id|ct
op_increment
)paren
(brace
id|sa-&gt;sat_addr.s_net
op_assign
id|htons
c_func
(paren
id|ct
)paren
suffix:semicolon
id|atrtr_create
c_func
(paren
op_amp
id|rtdef
comma
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
id|dev_mc_add
c_func
(paren
id|dev
comma
id|aarp_mcast
comma
l_int|6
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCGIFADDR
suffix:colon
r_if
c_cond
(paren
id|atif
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
(paren
(paren
r_struct
id|sockaddr_at
op_star
)paren
(paren
op_amp
id|atreq.ifr_addr
)paren
)paren
op_member_access_from_pointer
id|sat_family
op_assign
id|AF_APPLETALK
suffix:semicolon
(paren
(paren
r_struct
id|sockaddr_at
op_star
)paren
(paren
op_amp
id|atreq.ifr_addr
)paren
)paren
op_member_access_from_pointer
id|sat_addr
op_assign
id|atif-&gt;address
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFBRDADDR
suffix:colon
r_if
c_cond
(paren
id|atif
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
(paren
(paren
r_struct
id|sockaddr_at
op_star
)paren
(paren
op_amp
id|atreq.ifr_addr
)paren
)paren
op_member_access_from_pointer
id|sat_family
op_assign
id|AF_APPLETALK
suffix:semicolon
(paren
(paren
r_struct
id|sockaddr_at
op_star
)paren
(paren
op_amp
id|atreq.ifr_addr
)paren
)paren
op_member_access_from_pointer
id|sat_addr.s_net
op_assign
id|atif-&gt;address.s_net
suffix:semicolon
(paren
(paren
r_struct
id|sockaddr_at
op_star
)paren
(paren
op_amp
id|atreq.ifr_addr
)paren
)paren
op_member_access_from_pointer
id|sat_addr.s_node
op_assign
id|ATADDR_BCAST
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCATALKDIFADDR
suffix:colon
r_case
id|SIOCDIFADDR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|sa-&gt;sat_family
op_ne
id|AF_APPLETALK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|atalk_dev_down
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSARP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|sa-&gt;sat_family
op_ne
id|AF_APPLETALK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|atif
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
multiline_comment|/*&n;                         * for now, we only support proxy AARP on ELAP;&n;                         * we should be able to do it for LocalTalk, too.&n;                         */
r_if
c_cond
(paren
id|dev-&gt;type
op_ne
id|ARPHRD_ETHER
)paren
r_return
op_minus
id|EPROTONOSUPPORT
suffix:semicolon
multiline_comment|/*&n;                         * atif points to the current interface on this network;&n;                         * we aren&squot;t concerned about its current status (at least for now),&n;                         * but it has all the settings about the network we&squot;re going&n;                         * to probe.  consequently, it must exist.&n;                         */
r_if
c_cond
(paren
op_logical_neg
id|atif
)paren
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
id|nr
op_assign
(paren
r_struct
id|netrange
op_star
)paren
op_amp
(paren
id|atif-&gt;nets
)paren
suffix:semicolon
multiline_comment|/*&n;                         * Phase 1 is fine on Localtalk but we don&squot;t do&n;                         * Ethertalk phase 1. Anyone wanting to add it go ahead.&n;                         */
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|ARPHRD_ETHER
op_logical_and
id|nr-&gt;nr_phase
op_ne
l_int|2
)paren
r_return
op_minus
id|EPROTONOSUPPORT
suffix:semicolon
r_if
c_cond
(paren
id|sa-&gt;sat_addr.s_node
op_eq
id|ATADDR_BCAST
op_logical_or
id|sa-&gt;sat_addr.s_node
op_eq
l_int|254
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;                         * Check if the chosen address is used. If so we&n;                         * error and ATCP will try another.&n;                         */
r_if
c_cond
(paren
id|atif_proxy_probe_device
c_func
(paren
id|atif
comma
op_amp
(paren
id|sa-&gt;sat_addr
)paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EADDRINUSE
suffix:semicolon
multiline_comment|/*&n;                         * We now have an address on the local network, and the AARP&n;                         * code will defend it for us until we take it down.&n;                         * We don&squot;t set up any routes right now, because ATCP will&n;                         * install them manually via SIOCADDRT.&n;                         */
r_break
suffix:semicolon
r_case
id|SIOCDARP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|sa-&gt;sat_family
op_ne
id|AF_APPLETALK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|atif
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
multiline_comment|/*&n;                         * give to aarp module to remove proxy entry&n;                         */
id|aarp_proxy_remove
c_func
(paren
id|atif-&gt;dev
comma
op_amp
(paren
id|sa-&gt;sat_addr
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|atreq
comma
r_sizeof
(paren
id|atreq
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Routing ioctl() calls&n; */
DECL|function|atrtr_ioctl
r_static
r_int
id|atrtr_ioctl
c_func
(paren
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|rtentry
id|rt
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|rt
comma
id|arg
comma
r_sizeof
(paren
id|rt
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCDELRT
suffix:colon
r_if
c_cond
(paren
id|rt.rt_dst.sa_family
op_ne
id|AF_APPLETALK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|atrtr_delete
c_func
(paren
op_amp
(paren
(paren
r_struct
id|sockaddr_at
op_star
)paren
op_amp
id|rt.rt_dst
)paren
op_member_access_from_pointer
id|sat_addr
)paren
suffix:semicolon
r_case
id|SIOCADDRT
suffix:colon
multiline_comment|/* FIX ME: the name of the device is still in user space, isn&squot;t it? */
r_if
c_cond
(paren
id|rt.rt_dev
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|__dev_get_by_name
c_func
(paren
id|rt.rt_dev
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
id|atrtr_create
c_func
(paren
op_amp
id|rt
comma
id|dev
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/* Called from proc fs - just make it print the ifaces neatly */
DECL|function|atalk_if_get_info
r_static
r_int
id|atalk_if_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_struct
id|atalk_iface
op_star
id|iface
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;Interface&t;  Address   Networks   Status&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|atalk_iface_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|iface
op_assign
id|atalk_iface_list
suffix:semicolon
id|iface
op_ne
l_int|NULL
suffix:semicolon
id|iface
op_assign
id|iface-&gt;next
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%-16s %04X:%02X  %04X-%04X  %d&bslash;n&quot;
comma
id|iface-&gt;dev-&gt;name
comma
id|ntohs
c_func
(paren
id|iface-&gt;address.s_net
)paren
comma
id|iface-&gt;address.s_node
comma
id|ntohs
c_func
(paren
id|iface-&gt;nets.nr_firstnet
)paren
comma
id|ntohs
c_func
(paren
id|iface-&gt;nets.nr_lastnet
)paren
comma
id|iface-&gt;status
)paren
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
r_break
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|atalk_iface_lock
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
(paren
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/* Called from proc fs - just make it print the routes neatly */
DECL|function|atalk_rt_get_info
r_static
r_int
id|atalk_rt_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_struct
id|atalk_route
op_star
id|rt
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;Target        Router  Flags Dev&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atrtr_default.dev
)paren
(brace
id|rt
op_assign
op_amp
id|atrtr_default
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Default     %04X:%02X  %-4d  %s&bslash;n&quot;
comma
id|ntohs
c_func
(paren
id|rt-&gt;gateway.s_net
)paren
comma
id|rt-&gt;gateway.s_node
comma
id|rt-&gt;flags
comma
id|rt-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
id|read_lock_bh
c_func
(paren
op_amp
id|atalk_router_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|rt
op_assign
id|atalk_router_list
suffix:semicolon
id|rt
op_ne
l_int|NULL
suffix:semicolon
id|rt
op_assign
id|rt-&gt;next
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%04X:%02X     %04X:%02X  %-4d  %s&bslash;n&quot;
comma
id|ntohs
c_func
(paren
id|rt-&gt;target.s_net
)paren
comma
id|rt-&gt;target.s_node
comma
id|ntohs
c_func
(paren
id|rt-&gt;gateway.s_net
)paren
comma
id|rt-&gt;gateway.s_node
comma
id|rt-&gt;flags
comma
id|rt-&gt;dev-&gt;name
)paren
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
r_break
suffix:semicolon
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|atalk_router_lock
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&bslash;&n;*                                                                          *&n;* Handling for system calls applied via the various interfaces to an       *&n;* AppleTalk socket object.                                                 *&n;*                                                                          *&n;&bslash;**************************************************************************/
multiline_comment|/*&n; * Checksum: This is &squot;optional&squot;. It&squot;s quite likely also a good&n; * candidate for assembler hackery 8)&n; */
DECL|function|atalk_checksum
r_int
r_int
id|atalk_checksum
c_func
(paren
r_struct
id|ddpehdr
op_star
id|ddp
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|sum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Assume unsigned long is &gt;16 bits */
r_int
r_char
op_star
id|data
op_assign
(paren
r_int
r_char
op_star
)paren
id|ddp
suffix:semicolon
id|len
op_sub_assign
l_int|4
suffix:semicolon
multiline_comment|/* skip header 4 bytes */
id|data
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* This ought to be unwrapped neatly. I&squot;ll trust gcc for now */
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
id|sum
op_add_assign
op_star
id|data
suffix:semicolon
id|sum
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sum
op_amp
l_int|0x10000
)paren
(brace
id|sum
op_increment
suffix:semicolon
id|sum
op_and_assign
l_int|0xFFFF
suffix:semicolon
)brace
id|data
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sum
)paren
r_return
id|htons
c_func
(paren
(paren
r_int
r_int
)paren
id|sum
)paren
suffix:semicolon
r_return
l_int|0xFFFF
suffix:semicolon
multiline_comment|/* Use 0xFFFF for 0. 0 itself means none */
)brace
multiline_comment|/*&n; * Create a socket. Initialise the socket, blank the addresses&n; * set the state.&n; */
DECL|function|atalk_create
r_static
r_int
id|atalk_create
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|protocol
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|sk
op_assign
id|sk_alloc
c_func
(paren
id|PF_APPLETALK
comma
id|GFP_KERNEL
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_switch
c_cond
(paren
id|sock-&gt;type
)paren
(brace
multiline_comment|/*&n;&t;&t; * We permit SOCK_DGRAM and RAW is an extension. It is&n;&t;&t; * trivial to do and gives you the full ELAP frame.&n;&t;&t; * Should be handy for CAP 8) &n;&t;&t; */
r_case
id|SOCK_RAW
suffix:colon
r_case
id|SOCK_DGRAM
suffix:colon
id|sock-&gt;ops
op_assign
op_amp
id|atalk_dgram_ops
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOCK_STREAM
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * TO DO: if you want to implement ADSP, here&squot;s the place to start&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t;sock-&gt;ops = &amp;atalk_stream_ops;&n;&t;&t;&t;break;&n;&t;&t;&t;*/
r_default
suffix:colon
id|sk_free
c_func
(paren
(paren
r_void
op_star
)paren
id|sk
)paren
suffix:semicolon
r_return
op_minus
id|ESOCKTNOSUPPORT
suffix:semicolon
)brace
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|sock_init_data
c_func
(paren
id|sock
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;destruct
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Checksums on by default */
id|sk-&gt;zapped
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Free a socket. No work needed&n; */
DECL|function|atalk_release
r_static
r_int
id|atalk_release
c_func
(paren
r_struct
id|socket
op_star
id|sock
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;dead
op_assign
l_int|1
suffix:semicolon
id|sock-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|atalk_destroy_socket
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Pick a source port when one is not given. If we can&n; * find a suitable free one, we insert the socket into&n; * the tables using it.&n; *&n; * This whole operation must be atomic.&n; */
DECL|function|atalk_pick_and_bind_port
r_static
r_int
id|atalk_pick_and_bind_port
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr_at
op_star
id|sat
)paren
(brace
r_struct
id|sock
op_star
id|s
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|atalk_sockets_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sat-&gt;sat_port
op_assign
id|ATPORT_RESERVED
suffix:semicolon
id|sat-&gt;sat_port
OL
id|ATPORT_LAST
suffix:semicolon
id|sat-&gt;sat_port
op_increment
)paren
(brace
r_for
c_loop
(paren
id|s
op_assign
id|atalk_sockets
suffix:semicolon
id|s
op_ne
l_int|NULL
suffix:semicolon
id|s
op_assign
id|s-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;protinfo.af_at.src_net
op_eq
id|sat-&gt;sat_addr.s_net
op_logical_and
id|s-&gt;protinfo.af_at.src_node
op_eq
id|sat-&gt;sat_addr.s_node
op_logical_and
id|s-&gt;protinfo.af_at.src_port
op_eq
id|sat-&gt;sat_port
)paren
r_goto
id|try_next_port
suffix:semicolon
)brace
multiline_comment|/* Wheee, it&squot;s free, assign and insert. */
r_if
c_cond
(paren
(paren
id|sk-&gt;next
op_assign
id|atalk_sockets
)paren
op_ne
l_int|NULL
)paren
id|atalk_sockets-&gt;pprev
op_assign
op_amp
id|sk-&gt;next
suffix:semicolon
id|atalk_sockets
op_assign
id|sk
suffix:semicolon
id|sk-&gt;pprev
op_assign
op_amp
id|atalk_sockets
suffix:semicolon
id|sk-&gt;protinfo.af_at.src_port
op_assign
id|sat-&gt;sat_port
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|try_next_port
suffix:colon
suffix:semicolon
)brace
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_bh
c_func
(paren
op_amp
id|atalk_sockets_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|atalk_autobind
r_static
r_int
id|atalk_autobind
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|at_addr
op_star
id|ap
op_assign
id|atalk_find_primary
c_func
(paren
)paren
suffix:semicolon
r_struct
id|sockaddr_at
id|sat
suffix:semicolon
r_int
id|n
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|NULL
op_logical_or
id|ap-&gt;s_net
op_eq
id|htons
c_func
(paren
id|ATADDR_ANYNET
)paren
)paren
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
id|sk-&gt;protinfo.af_at.src_net
op_assign
id|sat.sat_addr.s_net
op_assign
id|ap-&gt;s_net
suffix:semicolon
id|sk-&gt;protinfo.af_at.src_node
op_assign
id|sat.sat_addr.s_node
op_assign
id|ap-&gt;s_node
suffix:semicolon
r_if
c_cond
(paren
(paren
id|n
op_assign
id|atalk_pick_and_bind_port
c_func
(paren
id|sk
comma
op_amp
id|sat
)paren
)paren
OL
l_int|0
)paren
r_return
id|n
suffix:semicolon
id|sk-&gt;zapped
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the address &squot;our end&squot; of the connection.&n; */
DECL|function|atalk_bind
r_static
r_int
id|atalk_bind
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_struct
id|sockaddr_at
op_star
id|addr
op_assign
(paren
r_struct
id|sockaddr_at
op_star
)paren
id|uaddr
suffix:semicolon
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;zapped
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr_len
op_ne
r_sizeof
(paren
r_struct
id|sockaddr_at
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr-&gt;sat_family
op_ne
id|AF_APPLETALK
)paren
(brace
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr-&gt;sat_addr.s_net
op_eq
id|htons
c_func
(paren
id|ATADDR_ANYNET
)paren
)paren
(brace
r_struct
id|at_addr
op_star
id|ap
op_assign
id|atalk_find_primary
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
)brace
id|sk-&gt;protinfo.af_at.src_net
op_assign
id|addr-&gt;sat_addr.s_net
op_assign
id|ap-&gt;s_net
suffix:semicolon
id|sk-&gt;protinfo.af_at.src_node
op_assign
id|addr-&gt;sat_addr.s_node
op_assign
id|ap-&gt;s_node
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|atalk_find_interface
c_func
(paren
id|addr-&gt;sat_addr.s_net
comma
id|addr-&gt;sat_addr.s_node
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
id|sk-&gt;protinfo.af_at.src_net
op_assign
id|addr-&gt;sat_addr.s_net
suffix:semicolon
id|sk-&gt;protinfo.af_at.src_node
op_assign
id|addr-&gt;sat_addr.s_node
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr-&gt;sat_port
op_eq
id|ATADDR_ANYPORT
)paren
(brace
r_int
id|n
op_assign
id|atalk_pick_and_bind_port
c_func
(paren
id|sk
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
l_int|0
)paren
r_return
id|n
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;protinfo.af_at.src_port
op_assign
id|addr-&gt;sat_port
suffix:semicolon
r_if
c_cond
(paren
id|atalk_find_or_insert_socket
c_func
(paren
id|sk
comma
id|addr
)paren
op_ne
l_int|NULL
)paren
r_return
op_minus
id|EADDRINUSE
suffix:semicolon
)brace
id|sk-&gt;zapped
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the address we talk to.&n; */
DECL|function|atalk_connect
r_static
r_int
id|atalk_connect
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
comma
r_int
id|flags
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|sockaddr_at
op_star
id|addr
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|sock-&gt;state
op_assign
id|SS_UNCONNECTED
suffix:semicolon
r_if
c_cond
(paren
id|addr_len
op_ne
r_sizeof
(paren
op_star
id|addr
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|addr
op_assign
(paren
r_struct
id|sockaddr_at
op_star
)paren
id|uaddr
suffix:semicolon
r_if
c_cond
(paren
id|addr-&gt;sat_family
op_ne
id|AF_APPLETALK
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
r_if
c_cond
(paren
id|addr-&gt;sat_addr.s_node
op_eq
id|ATADDR_BCAST
op_logical_and
op_logical_neg
id|sk-&gt;broadcast
)paren
(brace
macro_line|#if 1&t;
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s is broken and did not set SO_BROADCAST. It will break when 2.2 is released.&bslash;n&quot;
comma
id|current-&gt;comm
)paren
suffix:semicolon
macro_line|#else
r_return
op_minus
id|EACCES
suffix:semicolon
macro_line|#endif&t;&t;&t;
)brace
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_if
c_cond
(paren
id|atalk_autobind
c_func
(paren
id|sk
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atrtr_get_dev
c_func
(paren
op_amp
id|addr-&gt;sat_addr
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
id|sk-&gt;protinfo.af_at.dest_port
op_assign
id|addr-&gt;sat_port
suffix:semicolon
id|sk-&gt;protinfo.af_at.dest_net
op_assign
id|addr-&gt;sat_addr.s_net
suffix:semicolon
id|sk-&gt;protinfo.af_at.dest_node
op_assign
id|addr-&gt;sat_addr.s_node
suffix:semicolon
id|sock-&gt;state
op_assign
id|SS_CONNECTED
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_ESTABLISHED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the name of an AppleTalk socket. Just copy the right&n; * fields into the sockaddr.&n; */
DECL|function|atalk_getname
r_static
r_int
id|atalk_getname
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
op_star
id|uaddr_len
comma
r_int
id|peer
)paren
(brace
r_struct
id|sockaddr_at
id|sat
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_if
c_cond
(paren
id|atalk_autobind
c_func
(paren
id|sk
)paren
OL
l_int|0
)paren
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
op_star
id|uaddr_len
op_assign
r_sizeof
(paren
r_struct
id|sockaddr_at
)paren
suffix:semicolon
r_if
c_cond
(paren
id|peer
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
id|sat.sat_addr.s_net
op_assign
id|sk-&gt;protinfo.af_at.dest_net
suffix:semicolon
id|sat.sat_addr.s_node
op_assign
id|sk-&gt;protinfo.af_at.dest_node
suffix:semicolon
id|sat.sat_port
op_assign
id|sk-&gt;protinfo.af_at.dest_port
suffix:semicolon
)brace
r_else
(brace
id|sat.sat_addr.s_net
op_assign
id|sk-&gt;protinfo.af_at.src_net
suffix:semicolon
id|sat.sat_addr.s_node
op_assign
id|sk-&gt;protinfo.af_at.src_node
suffix:semicolon
id|sat.sat_port
op_assign
id|sk-&gt;protinfo.af_at.src_port
suffix:semicolon
)brace
id|sat.sat_family
op_assign
id|AF_APPLETALK
suffix:semicolon
id|memcpy
c_func
(paren
id|uaddr
comma
op_amp
id|sat
comma
r_sizeof
(paren
id|sat
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Receive a packet (in skb) from device dev. This has come from the SNAP&n; * decoder, and on entry skb-&gt;h.raw is the DDP header, skb-&gt;len is the DDP&n; * header, skb-&gt;len is the DDP length. The physical headers have been&n; * extracted. PPP should probably pass frames marked as for this layer.&n; * [ie ARPHRD_ETHERTALK]&n; */
DECL|function|atalk_rcv
r_static
r_int
id|atalk_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|sock
op_star
id|sock
suffix:semicolon
r_struct
id|ddpehdr
op_star
id|ddp
op_assign
(paren
r_void
op_star
)paren
id|skb-&gt;h.raw
suffix:semicolon
r_struct
id|atalk_iface
op_star
id|atif
suffix:semicolon
r_struct
id|sockaddr_at
id|tosat
suffix:semicolon
r_int
id|origlen
suffix:semicolon
r_struct
id|ddpebits
id|ddphv
suffix:semicolon
multiline_comment|/* Size check */
r_if
c_cond
(paren
id|skb-&gt;len
OL
r_sizeof
(paren
op_star
id|ddp
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Fix up the length field&t;[Ok this is horrible but otherwise&n;&t; *&t;I end up with unions of bit fields and messy bit field order&n;&t; *&t;compiler/endian dependencies..]&n;&t; *&n;&t; *&t;FIXME: This is a write to a shared object. Granted it&n;&t; *&t;happens to be safe BUT.. (Its safe as user space will not&n;&t; *&t;run until we put it back)&n;&t; */
op_star
(paren
(paren
id|__u16
op_star
)paren
op_amp
id|ddphv
)paren
op_assign
id|ntohs
c_func
(paren
op_star
(paren
(paren
id|__u16
op_star
)paren
id|ddp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Trim buffer in case of stray trailing data&n;&t; */
id|origlen
op_assign
id|skb-&gt;len
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
id|min
c_func
(paren
id|skb-&gt;len
comma
id|ddphv.deh_len
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Size check to see if ddp-&gt;deh_len was crap&n;&t; * (Otherwise we&squot;ll detonate most spectacularly&n;&t; * in the middle of recvmsg()).&n;&t; */
r_if
c_cond
(paren
id|skb-&gt;len
OL
r_sizeof
(paren
op_star
id|ddp
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Any checksums. Note we don&squot;t do htons() on this == is assumed to be&n;&t; * valid for net byte orders all over the networking code...&n;&t; */
r_if
c_cond
(paren
id|ddp-&gt;deh_sum
op_logical_and
id|atalk_checksum
c_func
(paren
id|ddp
comma
id|ddphv.deh_len
)paren
op_ne
id|ddp-&gt;deh_sum
)paren
(brace
multiline_comment|/* Not a valid AppleTalk frame - dustbin time */
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Check the packet is aimed at us */
r_if
c_cond
(paren
id|ddp-&gt;deh_dnet
op_eq
l_int|0
)paren
multiline_comment|/* Net 0 is &squot;this network&squot; */
id|atif
op_assign
id|atalk_find_anynet
c_func
(paren
id|ddp-&gt;deh_dnode
comma
id|dev
)paren
suffix:semicolon
r_else
id|atif
op_assign
id|atalk_find_interface
c_func
(paren
id|ddp-&gt;deh_dnet
comma
id|ddp-&gt;deh_dnode
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Not ours, so we route the packet via the correct AppleTalk interface.&n;&t; */
r_if
c_cond
(paren
id|atif
op_eq
l_int|NULL
)paren
(brace
r_struct
id|atalk_route
op_star
id|rt
suffix:semicolon
r_struct
id|at_addr
id|ta
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Don&squot;t route multicast, etc., packets, or packets&n;&t;&t; * sent to &quot;this network&quot; &n;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;pkt_type
op_ne
id|PACKET_HOST
op_logical_or
id|ddp-&gt;deh_dnet
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * FIX ME:&n;&t;&t;&t; * Can it ever happen that a packet is from a PPP iface and needs to be broadcast onto the default network?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|ARPHRD_PPP
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;AppleTalk: didn&squot;t forward broadcast packet received from PPP iface&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ta.s_net
op_assign
id|ddp-&gt;deh_dnet
suffix:semicolon
id|ta.s_node
op_assign
id|ddp-&gt;deh_dnode
suffix:semicolon
multiline_comment|/* Route the packet */
id|rt
op_assign
id|atrtr_find
c_func
(paren
op_amp
id|ta
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
op_logical_or
id|ddphv.deh_hops
op_eq
id|DDP_MAXHOPS
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ddphv.deh_hops
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Route goes through another gateway, so&n;&t;&t; * set the target to the gateway instead.&n;&t;&t; */
r_if
c_cond
(paren
id|rt-&gt;flags
op_amp
id|RTF_GATEWAY
)paren
(brace
id|ta.s_net
op_assign
id|rt-&gt;gateway.s_net
suffix:semicolon
id|ta.s_node
op_assign
id|rt-&gt;gateway.s_node
suffix:semicolon
)brace
multiline_comment|/* Fix up skb-&gt;len field */
id|skb_trim
c_func
(paren
id|skb
comma
id|min
c_func
(paren
id|origlen
comma
id|rt-&gt;dev-&gt;hard_header_len
op_plus
id|ddp_dl-&gt;header_length
op_plus
id|ddphv.deh_len
)paren
)paren
suffix:semicolon
multiline_comment|/* Mend the byte order */
op_star
(paren
(paren
id|__u16
op_star
)paren
id|ddp
)paren
op_assign
id|ntohs
c_func
(paren
op_star
(paren
(paren
id|__u16
op_star
)paren
op_amp
id|ddphv
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Send the buffer onwards&n;&t;&t; *&n;&t;&t; * Now we must always be careful. If it&squot;s come from &n;&t;&t; * LocalTalk to EtherTalk it might not fit&n;&t;&t; *&n;&t;&t; * Order matters here: If a packet has to be copied&n;&t;&t; * to make a new headroom (rare hopefully) then it&n;&t;&t; * won&squot;t need unsharing.&n;&t;&t; *&n;&t;&t; * Note. ddp-&gt; becomes invalid at the realloc.&n;&t;&t; */
r_if
c_cond
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
OL
l_int|22
)paren
(brace
r_struct
id|sk_buff
op_star
id|newskb
suffix:semicolon
multiline_comment|/* 22 bytes - 12 ether, 2 len, 3 802.2 5 snap */
id|newskb
op_assign
id|skb_realloc_headroom
c_func
(paren
id|skb
comma
l_int|32
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newskb
)paren
r_return
l_int|0
suffix:semicolon
id|skb
op_assign
id|newskb
suffix:semicolon
)brace
r_else
id|skb
op_assign
id|skb_unshare
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the buffer didn&squot;t vanish into the lack of&n;&t;&t; * space bitbucket we can send it.&n;&t;&t; */
r_if
c_cond
(paren
id|skb
)paren
(brace
r_if
c_cond
(paren
id|aarp_send_ddp
c_func
(paren
id|rt-&gt;dev
comma
id|skb
comma
op_amp
id|ta
comma
l_int|NULL
)paren
op_eq
op_minus
l_int|1
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_IPDDP) || defined(CONFIG_IPDDP_MODULE)
multiline_comment|/*&n;         *      Check if IP-over-DDP&n;         */
r_if
c_cond
(paren
id|skb-&gt;data
(braket
l_int|12
)braket
op_eq
l_int|22
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* This needs to be able to handle ipddp&quot;N&quot; devices */
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|__dev_get_by_name
c_func
(paren
l_string|&quot;ipddp0&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
l_int|13
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;h.raw
op_assign
id|skb-&gt;data
suffix:semicolon
(paren
(paren
r_struct
id|net_device_stats
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|rx_packets
op_increment
suffix:semicolon
(paren
(paren
r_struct
id|net_device_stats
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|rx_bytes
op_add_assign
id|skb-&gt;len
op_plus
l_int|13
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Send the SKB up to a higher place. */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Which socket - atalk_search_socket() looks for a *full match*&n;&t; * of the &lt;net,node,port&gt; tuple.&n;&t; */
id|tosat.sat_addr.s_net
op_assign
id|ddp-&gt;deh_dnet
suffix:semicolon
id|tosat.sat_addr.s_node
op_assign
id|ddp-&gt;deh_dnode
suffix:semicolon
id|tosat.sat_port
op_assign
id|ddp-&gt;deh_dport
suffix:semicolon
id|sock
op_assign
id|atalk_search_socket
c_func
(paren
op_amp
id|tosat
comma
id|atif
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sock
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* But not one of our sockets */
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Queue packet (standard)&n;&t; */
id|skb-&gt;sk
op_assign
id|sock
suffix:semicolon
r_if
c_cond
(paren
id|sock_queue_rcv_skb
c_func
(paren
id|sock
comma
id|skb
)paren
OL
l_int|0
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Receive a LocalTalk frame. We make some demands on the caller here.&n; * Caller must provide enough headroom on the packet to pull the short&n; * header and append a long one.&n; */
DECL|function|ltalk_rcv
r_static
r_int
id|ltalk_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|ddpehdr
op_star
id|ddp
suffix:semicolon
r_struct
id|at_addr
op_star
id|ap
suffix:semicolon
multiline_comment|/*&n;&t; * Expand any short form frames.&n;&t; */
r_if
c_cond
(paren
id|skb-&gt;mac.raw
(braket
l_int|2
)braket
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Find our address.&n;&t;&t; */
id|ap
op_assign
id|atalk_find_dev_addr
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|NULL
op_logical_or
id|skb-&gt;len
OL
r_sizeof
(paren
r_struct
id|ddpshdr
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The push leaves us with a ddephdr not an shdr, and&n;&t;&t; * handily the port bytes in the right place preset.&n;&t;&t; */
id|skb_push
c_func
(paren
id|skb
comma
r_sizeof
(paren
op_star
id|ddp
)paren
op_minus
l_int|4
)paren
suffix:semicolon
id|ddp
op_assign
(paren
r_struct
id|ddpehdr
op_star
)paren
id|skb-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now fill in the long header.&n;&t;&t; */
multiline_comment|/*&n;&t; &t; * These two first. The mac overlays the new source/dest&n;&t; &t; * network information so we MUST copy these before&n;&t; &t; * we write the network numbers !&n;&t; &t; */
id|ddp-&gt;deh_dnode
op_assign
id|skb-&gt;mac.raw
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* From physical header */
id|ddp-&gt;deh_snode
op_assign
id|skb-&gt;mac.raw
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* From physical header */
id|ddp-&gt;deh_dnet
op_assign
id|ap-&gt;s_net
suffix:semicolon
multiline_comment|/* Network number */
id|ddp-&gt;deh_snet
op_assign
id|ap-&gt;s_net
suffix:semicolon
id|ddp-&gt;deh_sum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No checksum */
multiline_comment|/*&n;&t;&t; * Not sure about this bit...&n;&t;&t; */
id|ddp-&gt;deh_len
op_assign
id|skb-&gt;len
suffix:semicolon
id|ddp-&gt;deh_hops
op_assign
id|DDP_MAXHOPS
suffix:semicolon
multiline_comment|/* Non routable, so force a drop&n;&t;&t;&t;&t;&t;&t;   if we slip up later */
multiline_comment|/* Mend the byte order */
op_star
(paren
(paren
id|__u16
op_star
)paren
id|ddp
)paren
op_assign
id|htons
c_func
(paren
op_star
(paren
(paren
id|__u16
op_star
)paren
id|ddp
)paren
)paren
suffix:semicolon
)brace
id|skb-&gt;h.raw
op_assign
id|skb-&gt;data
suffix:semicolon
r_return
id|atalk_rcv
c_func
(paren
id|skb
comma
id|dev
comma
id|pt
)paren
suffix:semicolon
)brace
DECL|function|atalk_sendmsg
r_static
r_int
id|atalk_sendmsg
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_struct
id|scm_cookie
op_star
id|scm
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|sockaddr_at
op_star
id|usat
op_assign
(paren
r_struct
id|sockaddr_at
op_star
)paren
id|msg-&gt;msg_name
suffix:semicolon
r_struct
id|sockaddr_at
id|local_satalk
comma
id|gsat
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|ddpehdr
op_star
id|ddp
suffix:semicolon
r_int
id|size
suffix:semicolon
r_struct
id|atalk_route
op_star
id|rt
suffix:semicolon
r_int
id|loopback
op_assign
l_int|0
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|flags
op_assign
id|msg-&gt;msg_flags
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
op_complement
id|MSG_DONTWAIT
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|DDP_MAXSZ
)paren
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
r_if
c_cond
(paren
id|usat
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_if
c_cond
(paren
id|atalk_autobind
c_func
(paren
id|sk
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msg-&gt;msg_namelen
OL
r_sizeof
(paren
op_star
id|usat
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|usat-&gt;sat_family
op_ne
id|AF_APPLETALK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* netatalk doesn&squot;t implement this check */
r_if
c_cond
(paren
id|usat-&gt;sat_addr.s_node
op_eq
id|ATADDR_BCAST
op_logical_and
op_logical_neg
id|sk-&gt;broadcast
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SO_BROADCAST: Fix your netatalk as it will break before 2.2&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if 0
r_return
op_minus
id|EPERM
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
id|usat
op_assign
op_amp
id|local_satalk
suffix:semicolon
id|usat-&gt;sat_family
op_assign
id|AF_APPLETALK
suffix:semicolon
id|usat-&gt;sat_port
op_assign
id|sk-&gt;protinfo.af_at.dest_port
suffix:semicolon
id|usat-&gt;sat_addr.s_node
op_assign
id|sk-&gt;protinfo.af_at.dest_node
suffix:semicolon
id|usat-&gt;sat_addr.s_net
op_assign
id|sk-&gt;protinfo.af_at.dest_net
suffix:semicolon
)brace
multiline_comment|/* Build a packet */
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;SK %p: Got address.&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/* For headers */
id|size
op_assign
r_sizeof
(paren
r_struct
id|ddpehdr
)paren
op_plus
id|len
op_plus
id|ddp_dl-&gt;header_length
suffix:semicolon
r_if
c_cond
(paren
id|usat-&gt;sat_addr.s_net
op_ne
l_int|0
op_logical_or
id|usat-&gt;sat_addr.s_node
op_eq
id|ATADDR_ANYNODE
)paren
(brace
id|rt
op_assign
id|atrtr_find
c_func
(paren
op_amp
id|usat-&gt;sat_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
id|dev
op_assign
id|rt-&gt;dev
suffix:semicolon
)brace
r_else
(brace
r_struct
id|at_addr
id|at_hint
suffix:semicolon
id|at_hint.s_node
op_assign
l_int|0
suffix:semicolon
id|at_hint.s_net
op_assign
id|sk-&gt;protinfo.af_at.src_net
suffix:semicolon
id|rt
op_assign
id|atrtr_find
c_func
(paren
op_amp
id|at_hint
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
id|dev
op_assign
id|rt-&gt;dev
suffix:semicolon
)brace
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;SK %p: Size needed %d, device %s&bslash;n&quot;
comma
id|sk
comma
id|size
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|size
op_add_assign
id|dev-&gt;hard_header_len
suffix:semicolon
id|skb
op_assign
id|sock_alloc_send_skb
c_func
(paren
id|sk
comma
id|size
comma
l_int|0
comma
(paren
id|flags
op_amp
id|MSG_DONTWAIT
)paren
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
id|err
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
id|ddp_dl-&gt;header_length
)paren
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;SK %p: Begin build.&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
id|ddp
op_assign
(paren
r_struct
id|ddpehdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|ddpehdr
)paren
)paren
suffix:semicolon
id|ddp-&gt;deh_pad
op_assign
l_int|0
suffix:semicolon
id|ddp-&gt;deh_hops
op_assign
l_int|0
suffix:semicolon
id|ddp-&gt;deh_len
op_assign
id|len
op_plus
r_sizeof
(paren
op_star
id|ddp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fix up the length field [Ok this is horrible but otherwise&n;&t; * I end up with unions of bit fields and messy bit field order&n;&t; * compiler/endian dependencies..&n;&t; */
op_star
(paren
(paren
id|__u16
op_star
)paren
id|ddp
)paren
op_assign
id|ntohs
c_func
(paren
op_star
(paren
(paren
id|__u16
op_star
)paren
id|ddp
)paren
)paren
suffix:semicolon
id|ddp-&gt;deh_dnet
op_assign
id|usat-&gt;sat_addr.s_net
suffix:semicolon
id|ddp-&gt;deh_snet
op_assign
id|sk-&gt;protinfo.af_at.src_net
suffix:semicolon
id|ddp-&gt;deh_dnode
op_assign
id|usat-&gt;sat_addr.s_node
suffix:semicolon
id|ddp-&gt;deh_snode
op_assign
id|sk-&gt;protinfo.af_at.src_node
suffix:semicolon
id|ddp-&gt;deh_dport
op_assign
id|usat-&gt;sat_port
suffix:semicolon
id|ddp-&gt;deh_sport
op_assign
id|sk-&gt;protinfo.af_at.src_port
suffix:semicolon
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;SK %p: Copy user data (%d bytes).&bslash;n&quot;
comma
id|sk
comma
id|len
)paren
suffix:semicolon
id|err
op_assign
id|memcpy_fromiovec
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|len
)paren
comma
id|msg-&gt;msg_iov
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;no_check
op_eq
l_int|1
)paren
id|ddp-&gt;deh_sum
op_assign
l_int|0
suffix:semicolon
r_else
id|ddp-&gt;deh_sum
op_assign
id|atalk_checksum
c_func
(paren
id|ddp
comma
id|len
op_plus
r_sizeof
(paren
op_star
id|ddp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loopback broadcast packets to non gateway targets (ie routes&n;&t; * to group we are in)&n;&t; */
r_if
c_cond
(paren
id|ddp-&gt;deh_dnode
op_eq
id|ATADDR_BCAST
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|rt-&gt;flags
op_amp
id|RTF_GATEWAY
)paren
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
op_assign
id|skb_copy
c_func
(paren
id|skb
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb2
)paren
(brace
id|loopback
op_assign
l_int|1
suffix:semicolon
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;SK %p: send out(copy).&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aarp_send_ddp
c_func
(paren
id|dev
comma
id|skb2
comma
op_amp
id|usat-&gt;sat_addr
comma
l_int|NULL
)paren
op_eq
op_minus
l_int|1
)paren
id|kfree_skb
c_func
(paren
id|skb2
)paren
suffix:semicolon
multiline_comment|/* else queued/sent above in the aarp queue */
)brace
)brace
)brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
op_logical_or
id|loopback
)paren
(brace
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;SK %p: Loop back.&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/* loop back */
id|skb_orphan
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ddp_dl
op_member_access_from_pointer
id|datalink_header
c_func
(paren
id|ddp_dl
comma
id|skb
comma
id|dev-&gt;dev_addr
)paren
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb-&gt;h.raw
op_assign
id|skb-&gt;data
op_plus
id|ddp_dl-&gt;header_length
op_plus
id|dev-&gt;hard_header_len
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|ddp_dl-&gt;header_length
)paren
suffix:semicolon
id|atalk_rcv
c_func
(paren
id|skb
comma
id|dev
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;SK %p: send out.&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt-&gt;flags
op_amp
id|RTF_GATEWAY
)paren
(brace
id|gsat.sat_addr
op_assign
id|rt-&gt;gateway
suffix:semicolon
id|usat
op_assign
op_amp
id|gsat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aarp_send_ddp
c_func
(paren
id|dev
comma
id|skb
comma
op_amp
id|usat-&gt;sat_addr
comma
l_int|NULL
)paren
op_eq
op_minus
l_int|1
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* else queued/sent above in the aarp queue */
)brace
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;SK %p: Done write (%d).&bslash;n&quot;
comma
id|sk
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|atalk_recvmsg
r_static
r_int
id|atalk_recvmsg
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|size
comma
r_int
id|flags
comma
r_struct
id|scm_cookie
op_star
id|scm
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|sockaddr_at
op_star
id|sat
op_assign
(paren
r_struct
id|sockaddr_at
op_star
)paren
id|msg-&gt;msg_name
suffix:semicolon
r_struct
id|ddpehdr
op_star
id|ddp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ddpebits
id|ddphv
suffix:semicolon
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|skb
op_assign
id|skb_recv_datagram
c_func
(paren
id|sk
comma
(paren
id|flags
op_amp
op_complement
id|MSG_DONTWAIT
)paren
comma
(paren
id|flags
op_amp
id|MSG_DONTWAIT
)paren
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
id|err
suffix:semicolon
id|ddp
op_assign
(paren
r_struct
id|ddpehdr
op_star
)paren
(paren
id|skb-&gt;h.raw
)paren
suffix:semicolon
op_star
(paren
(paren
id|__u16
op_star
)paren
op_amp
id|ddphv
)paren
op_assign
id|ntohs
c_func
(paren
op_star
(paren
(paren
id|__u16
op_star
)paren
id|ddp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;type
op_eq
id|SOCK_RAW
)paren
(brace
id|copied
op_assign
id|ddphv.deh_len
suffix:semicolon
r_if
c_cond
(paren
id|copied
OG
id|size
)paren
(brace
id|copied
op_assign
id|size
suffix:semicolon
id|msg-&gt;msg_flags
op_or_assign
id|MSG_TRUNC
suffix:semicolon
)brace
id|err
op_assign
id|skb_copy_datagram_iovec
c_func
(paren
id|skb
comma
l_int|0
comma
id|msg-&gt;msg_iov
comma
id|copied
)paren
suffix:semicolon
)brace
r_else
(brace
id|copied
op_assign
id|ddphv.deh_len
op_minus
r_sizeof
(paren
op_star
id|ddp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
OG
id|size
)paren
(brace
id|copied
op_assign
id|size
suffix:semicolon
id|msg-&gt;msg_flags
op_or_assign
id|MSG_TRUNC
suffix:semicolon
)brace
id|err
op_assign
id|skb_copy_datagram_iovec
c_func
(paren
id|skb
comma
r_sizeof
(paren
op_star
id|ddp
)paren
comma
id|msg-&gt;msg_iov
comma
id|copied
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
r_if
c_cond
(paren
id|sat
)paren
(brace
id|sat-&gt;sat_family
op_assign
id|AF_APPLETALK
suffix:semicolon
id|sat-&gt;sat_port
op_assign
id|ddp-&gt;deh_sport
suffix:semicolon
id|sat-&gt;sat_addr.s_node
op_assign
id|ddp-&gt;deh_snode
suffix:semicolon
id|sat-&gt;sat_addr.s_net
op_assign
id|ddp-&gt;deh_snet
suffix:semicolon
)brace
id|msg-&gt;msg_namelen
op_assign
r_sizeof
(paren
op_star
id|sat
)paren
suffix:semicolon
)brace
id|skb_free_datagram
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* Free the datagram. */
r_return
id|err
ques
c_cond
id|err
suffix:colon
id|copied
suffix:semicolon
)brace
multiline_comment|/*&n; * AppleTalk ioctl calls.&n; */
DECL|function|atalk_ioctl
r_static
r_int
id|atalk_ioctl
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|amount
op_assign
l_int|0
suffix:semicolon
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Protocol layer&n;&t;&t; */
r_case
id|TIOCOUTQ
suffix:colon
id|amount
op_assign
id|sk-&gt;sndbuf
op_minus
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amount
OL
l_int|0
)paren
(brace
id|amount
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCINQ
suffix:colon
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* These two are safe on a single CPU system as only user tasks fiddle here */
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|amount
op_assign
id|skb-&gt;len
op_minus
r_sizeof
(paren
r_struct
id|ddpehdr
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|SIOCGSTAMP
suffix:colon
r_if
c_cond
(paren
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;stamp.tv_sec
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_return
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|sk-&gt;stamp
comma
r_sizeof
(paren
r_struct
id|timeval
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Routing&n;&t;&t; */
r_case
id|SIOCADDRT
suffix:colon
r_case
id|SIOCDELRT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_return
(paren
id|atrtr_ioctl
c_func
(paren
id|cmd
comma
(paren
r_void
op_star
)paren
id|arg
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Interface&n;&t;&t; */
r_case
id|SIOCGIFADDR
suffix:colon
r_case
id|SIOCSIFADDR
suffix:colon
r_case
id|SIOCGIFBRDADDR
suffix:colon
r_case
id|SIOCATALKDIFADDR
suffix:colon
r_case
id|SIOCDIFADDR
suffix:colon
r_case
id|SIOCSARP
suffix:colon
multiline_comment|/* proxy AARP */
r_case
id|SIOCDARP
suffix:colon
multiline_comment|/* proxy AARP */
r_return
(paren
id|atif_ioctl
c_func
(paren
id|cmd
comma
(paren
r_void
op_star
)paren
id|arg
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Physical layer ioctl calls&n;&t;&t; */
r_case
id|SIOCSIFLINK
suffix:colon
r_case
id|SIOCGIFHWADDR
suffix:colon
r_case
id|SIOCSIFHWADDR
suffix:colon
r_case
id|SIOCGIFFLAGS
suffix:colon
r_case
id|SIOCSIFFLAGS
suffix:colon
r_case
id|SIOCGIFMTU
suffix:colon
r_case
id|SIOCGIFCONF
suffix:colon
r_case
id|SIOCADDMULTI
suffix:colon
r_case
id|SIOCDELMULTI
suffix:colon
r_case
id|SIOCGIFCOUNT
suffix:colon
r_case
id|SIOCGIFINDEX
suffix:colon
r_case
id|SIOCGIFNAME
suffix:colon
r_return
(paren
(paren
id|dev_ioctl
c_func
(paren
id|cmd
comma
(paren
r_void
op_star
)paren
id|arg
)paren
)paren
)paren
suffix:semicolon
r_case
id|SIOCSIFMETRIC
suffix:colon
r_case
id|SIOCSIFBRDADDR
suffix:colon
r_case
id|SIOCGIFNETMASK
suffix:colon
r_case
id|SIOCSIFNETMASK
suffix:colon
r_case
id|SIOCGIFMEM
suffix:colon
r_case
id|SIOCSIFMEM
suffix:colon
r_case
id|SIOCGIFDSTADDR
suffix:colon
r_case
id|SIOCSIFDSTADDR
suffix:colon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_default
suffix:colon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
r_return
(paren
id|put_user
c_func
(paren
id|amount
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
suffix:semicolon
)brace
DECL|variable|atalk_family_ops
r_static
r_struct
id|net_proto_family
id|atalk_family_ops
op_assign
(brace
id|PF_APPLETALK
comma
id|atalk_create
)brace
suffix:semicolon
DECL|variable|atalk_dgram_ops
r_static
r_struct
id|proto_ops
id|SOCKOPS_WRAPPED
c_func
(paren
id|atalk_dgram_ops
)paren
op_assign
(brace
id|family
suffix:colon
id|PF_APPLETALK
comma
id|release
suffix:colon
id|atalk_release
comma
id|bind
suffix:colon
id|atalk_bind
comma
id|connect
suffix:colon
id|atalk_connect
comma
id|socketpair
suffix:colon
id|sock_no_socketpair
comma
id|accept
suffix:colon
id|sock_no_accept
comma
id|getname
suffix:colon
id|atalk_getname
comma
id|poll
suffix:colon
id|datagram_poll
comma
id|ioctl
suffix:colon
id|atalk_ioctl
comma
id|listen
suffix:colon
id|sock_no_listen
comma
id|shutdown
suffix:colon
id|sock_no_shutdown
comma
id|setsockopt
suffix:colon
id|sock_no_setsockopt
comma
id|getsockopt
suffix:colon
id|sock_no_getsockopt
comma
id|sendmsg
suffix:colon
id|atalk_sendmsg
comma
id|recvmsg
suffix:colon
id|atalk_recvmsg
comma
id|mmap
suffix:colon
id|sock_no_mmap
comma
)brace
suffix:semicolon
macro_line|#include &lt;linux/smp_lock.h&gt;
id|SOCKOPS_WRAP
c_func
(paren
id|atalk_dgram
comma
id|PF_APPLETALK
)paren
suffix:semicolon
DECL|variable|ddp_notifier
r_static
r_struct
id|notifier_block
id|ddp_notifier
op_assign
(brace
id|ddp_device_event
comma
l_int|NULL
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|ltalk_packet_type
r_struct
id|packet_type
id|ltalk_packet_type
op_assign
(brace
l_int|0
comma
l_int|NULL
comma
id|ltalk_rcv
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|ppptalk_packet_type
r_struct
id|packet_type
id|ppptalk_packet_type
op_assign
(brace
l_int|0
comma
l_int|NULL
comma
id|atalk_rcv
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|ddp_snap_id
r_static
r_char
id|ddp_snap_id
(braket
)braket
op_assign
(brace
l_int|0x08
comma
l_int|0x00
comma
l_int|0x07
comma
l_int|0x80
comma
l_int|0x9B
)brace
suffix:semicolon
multiline_comment|/*&n; * Export symbols for use by drivers when AppleTalk is a module.&n; */
DECL|variable|aarp_send_ddp
id|EXPORT_SYMBOL
c_func
(paren
id|aarp_send_ddp
)paren
suffix:semicolon
DECL|variable|atrtr_get_dev
id|EXPORT_SYMBOL
c_func
(paren
id|atrtr_get_dev
)paren
suffix:semicolon
DECL|variable|atalk_find_dev_addr
id|EXPORT_SYMBOL
c_func
(paren
id|atalk_find_dev_addr
)paren
suffix:semicolon
multiline_comment|/* Called by proto.c on kernel start up */
DECL|function|atalk_init
r_static
r_int
id|__init
id|atalk_init
c_func
(paren
r_void
)paren
(brace
(paren
r_void
)paren
id|sock_register
c_func
(paren
op_amp
id|atalk_family_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ddp_dl
op_assign
id|register_snap_client
c_func
(paren
id|ddp_snap_id
comma
id|atalk_rcv
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Unable to register DDP with SNAP.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ltalk_packet_type.type
op_assign
id|htons
c_func
(paren
id|ETH_P_LOCALTALK
)paren
suffix:semicolon
id|dev_add_pack
c_func
(paren
op_amp
id|ltalk_packet_type
)paren
suffix:semicolon
id|ppptalk_packet_type.type
op_assign
id|htons
c_func
(paren
id|ETH_P_PPPTALK
)paren
suffix:semicolon
id|dev_add_pack
c_func
(paren
op_amp
id|ppptalk_packet_type
)paren
suffix:semicolon
id|register_netdevice_notifier
c_func
(paren
op_amp
id|ddp_notifier
)paren
suffix:semicolon
id|aarp_proto_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|proc_net_create
c_func
(paren
l_string|&quot;appletalk&quot;
comma
l_int|0
comma
id|atalk_get_info
)paren
suffix:semicolon
id|proc_net_create
c_func
(paren
l_string|&quot;atalk_route&quot;
comma
l_int|0
comma
id|atalk_rt_get_info
)paren
suffix:semicolon
id|proc_net_create
c_func
(paren
l_string|&quot;atalk_iface&quot;
comma
l_int|0
comma
id|atalk_if_get_info
)paren
suffix:semicolon
id|aarp_register_proc_fs
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
macro_line|#ifdef CONFIG_SYSCTL
id|atalk_register_sysctl
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SYSCTL */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;NET4: AppleTalk 0.18 for Linux NET4.0&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|atalk_init
id|module_init
c_func
(paren
id|atalk_init
)paren
suffix:semicolon
macro_line|#ifdef MODULE
multiline_comment|/*&n; * Note on MOD_{INC,DEC}_USE_COUNT:&n; *&n; * Use counts are incremented/decremented when&n; * sockets are created/deleted.&n; *&n; * AppleTalk interfaces are not incremented untill atalkd is run&n; * and are only decremented when they are downed.&n; *&n; * Ergo, before the AppleTalk module can be removed, all AppleTalk&n; * sockets be closed from user space.&n; */
DECL|function|atalk_exit
r_static
r_void
id|__exit
id|atalk_exit
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_SYSCTL
id|atalk_unregister_sysctl
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SYSCTL */
macro_line|#ifdef CONFIG_PROC_FS
id|proc_net_remove
c_func
(paren
l_string|&quot;appletalk&quot;
)paren
suffix:semicolon
id|proc_net_remove
c_func
(paren
l_string|&quot;atalk_route&quot;
)paren
suffix:semicolon
id|proc_net_remove
c_func
(paren
l_string|&quot;atalk_iface&quot;
)paren
suffix:semicolon
id|aarp_unregister_proc_fs
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
id|aarp_cleanup_module
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* General aarp clean-up. */
id|unregister_netdevice_notifier
c_func
(paren
op_amp
id|ddp_notifier
)paren
suffix:semicolon
id|dev_remove_pack
c_func
(paren
op_amp
id|ltalk_packet_type
)paren
suffix:semicolon
id|dev_remove_pack
c_func
(paren
op_amp
id|ppptalk_packet_type
)paren
suffix:semicolon
id|unregister_snap_client
c_func
(paren
id|ddp_snap_id
)paren
suffix:semicolon
id|sock_unregister
c_func
(paren
id|PF_APPLETALK
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|variable|atalk_exit
id|module_exit
c_func
(paren
id|atalk_exit
)paren
suffix:semicolon
macro_line|#endif  /* MODULE */
macro_line|#endif  /* CONFIG_ATALK || CONFIG_ATALK_MODULE */
eof
