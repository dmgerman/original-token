multiline_comment|/*&n; *&t;NET3:&t;Implementation of the ICMP protocol layer. &n; *&t;&n; *&t;&t;Alan Cox, &lt;alan@cymru.net&gt;&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License&n; *&t;as published by the Free Software Foundation; either version&n; *&t;2 of the License, or (at your option) any later version.&n; *&n; *&t;Some of the function names and the icmp unreach table for this&n; *&t;module were derived from [icmp.c 1.0.11 06/02/93] by&n; *&t;Ross Biro, Fred N. van Kempen, Mark Evans, Alan Cox, Gerhard Koerting.&n; *&t;Other than that this module is a complete rewrite.&n; *&n; *&t;Fixes:&n; *&t;&t;Mike Shaver&t;:&t;RFC1122 checks.&n; *&t;&t;Alan Cox&t;:&t;Multicast ping reply as self.&n; *&t;&t;Alan Cox&t;:&t;Fix atomicity lockup in ip_build_xmit &n; *&t;&t;&t;&t;&t;call.&n; *&t;&t;Alan Cox&t;:&t;Added 216,128 byte paths to the MTU &n; *&t;&t;&t;&t;&t;code.&n; *&t;&t;Martin Mares&t;:&t;RFC1812 checks.&n; *&t;&t;Martin Mares&t;:&t;Can be configured to follow redirects &n; *&t;&t;&t;&t;&t;if acting as a router _without_ a&n; *&t;&t;&t;&t;&t;routing protocol (RFC 1812).&n; *&t;&t;Martin Mares&t;:&t;Echo requests may be configured to &n; *&t;&t;&t;&t;&t;be ignored (RFC 1812).&n; *&t;&t;Martin Mares&t;:&t;Limitation of ICMP error message &n; *&t;&t;&t;&t;&t;transmit rate (RFC 1812).&n; *&t;&t;Martin Mares&t;:&t;TOS and Precedence set correctly &n; *&t;&t;&t;&t;&t;(RFC 1812).&n; *&t;&t;Martin Mares&t;:&t;Now copying as much data from the &n; *&t;&t;&t;&t;&t;original packet as we can without&n; *&t;&t;&t;&t;&t;exceeding 576 bytes (RFC 1812).&n; *&t;Willy Konynenberg&t;:&t;Transparent proxying support.&n; *&t;&t;Keith Owens&t;:&t;RFC1191 correction for 4.2BSD based &n; *&t;&t;&t;&t;&t;path MTU bug.&n; *&t;&t;Thomas Quinot&t;:&t;ICMP Dest Unreach codes up to 15 are&n; *&t;&t;&t;&t;&t;valid (RFC 1812).&n; *&n; *&n; * RFC1122 (Host Requirements -- Comm. Layer) Status:&n; * (boy, are there a lot of rules for ICMP)&n; *  3.2.2 (Generic ICMP stuff)&n; *   MUST discard messages of unknown type. (OK)&n; *   MUST copy at least the first 8 bytes from the offending packet&n; *     when sending ICMP errors. (OBSOLETE -- see RFC1812)&n; *   MUST pass received ICMP errors up to protocol level. (OK)&n; *   SHOULD send ICMP errors with TOS == 0. (OBSOLETE -- see RFC1812)&n; *   MUST NOT send ICMP errors in reply to:&n; *     ICMP errors (OK)&n; *     Broadcast/multicast datagrams (OK)&n; *     MAC broadcasts (OK)&n; *     Non-initial fragments (OK)&n; *     Datagram with a source address that isn&squot;t a single host. (OK)&n; *  3.2.2.1 (Destination Unreachable)&n; *   All the rules govern the IP layer, and are dealt with in ip.c, not here.&n; *  3.2.2.2 (Redirect)&n; *   Host SHOULD NOT send ICMP_REDIRECTs.  (OK)&n; *   MUST update routing table in response to host or network redirects.&n; *     (host OK, network OBSOLETE)&n; *   SHOULD drop redirects if they&squot;re not from directly connected gateway&n; *     (OK -- we drop it if it&squot;s not from our old gateway, which is close&n; *      enough)&n; * 3.2.2.3 (Source Quench)&n; *   MUST pass incoming SOURCE_QUENCHs to transport layer (OK)&n; *   Other requirements are dealt with at the transport layer.&n; * 3.2.2.4 (Time Exceeded)&n; *   MUST pass TIME_EXCEEDED to transport layer (OK)&n; *   Other requirements dealt with at IP (generating TIME_EXCEEDED).&n; * 3.2.2.5 (Parameter Problem)&n; *   SHOULD generate these (OK)&n; *   MUST pass received PARAMPROBLEM to transport layer (NOT YET)&n; *   &t;[Solaris 2.X seems to assert EPROTO when this occurs] -- AC&n; * 3.2.2.6 (Echo Request/Reply)&n; *   MUST reply to ECHO_REQUEST, and give app to do ECHO stuff (OK, OK)&n; *   MAY discard broadcast ECHO_REQUESTs. (We don&squot;t, but that&squot;s OK.)&n; *   MUST reply using same source address as the request was sent to.&n; *     We&squot;re OK for unicast ECHOs, and it doesn&squot;t say anything about&n; *     how to handle broadcast ones, since it&squot;s optional.&n; *   MUST copy data from REQUEST to REPLY (OK)&n; *     unless it would require illegal fragmentation (OK)&n; *   MUST pass REPLYs to transport/user layer (OK)&n; *   MUST use any provided source route (reversed) for REPLY. (NOT YET)&n; * 3.2.2.7 (Information Request/Reply)&n; *   MUST NOT implement this. (I guess that means silently discard...?) (OK)&n; * 3.2.2.8 (Timestamp Request/Reply)&n; *   MAY implement (OK)&n; *   SHOULD be in-kernel for &quot;minimum variability&quot; (OK)&n; *   MAY discard broadcast REQUESTs.  (OK, but see source for inconsistency)&n; *   MUST reply using same source address as the request was sent to. (OK)&n; *   MUST reverse source route, as per ECHO (NOT YET)&n; *   MUST pass REPLYs to transport/user layer (requires RAW, just like &n; *&t;ECHO) (OK)&n; *   MUST update clock for timestamp at least 15 times/sec (OK)&n; *   MUST be &quot;correct within a few minutes&quot; (OK)&n; * 3.2.2.9 (Address Mask Request/Reply)&n; *   MAY implement (OK)&n; *   MUST send a broadcast REQUEST if using this system to set netmask&n; *     (OK... we don&squot;t use it)&n; *   MUST discard received REPLYs if not using this system (OK)&n; *   MUST NOT send replies unless specifically made agent for this sort&n; *     of thing. (OK)&n; *&n; *&n; * RFC 1812 (IPv4 Router Requirements) Status (even longer):&n; *  4.3.2.1 (Unknown Message Types)&n; *   MUST pass messages of unknown type to ICMP user iface or silently discard&n; *     them (OK)&n; *  4.3.2.2 (ICMP Message TTL)&n; *   MUST initialize TTL when originating an ICMP message (OK)&n; *  4.3.2.3 (Original Message Header)&n; *   SHOULD copy as much data from the offending packet as possible without&n; *     the length of the ICMP datagram exceeding 576 bytes (OK)&n; *   MUST leave original IP header of the offending packet, but we&squot;re not&n; *     required to undo modifications made (OK)&n; *  4.3.2.4 (Original Message Source Address)&n; *   MUST use one of addresses for the interface the orig. packet arrived as&n; *     source address (OK)&n; *  4.3.2.5 (TOS and Precedence)&n; *   SHOULD leave TOS set to the same value unless the packet would be &n; *     discarded for that reason (OK)&n; *   MUST use TOS=0 if not possible to leave original value (OK)&n; *   MUST leave IP Precedence for Source Quench messages (OK -- not sent &n; *&t;at all)&n; *   SHOULD use IP Precedence = 6 (Internetwork Control) or 7 (Network Control)&n; *     for all other error messages (OK, we use 6)&n; *   MAY allow configuration of IP Precedence (OK -- not done)&n; *   MUST leave IP Precedence and TOS for reply messages (OK)&n; *  4.3.2.6 (Source Route)&n; *   SHOULD use reverse source route UNLESS sending Parameter Problem on source&n; *     routing and UNLESS the packet would be immediately discarded (NOT YET)&n; *  4.3.2.7 (When Not to Send ICMP Errors)&n; *   MUST NOT send ICMP errors in reply to:&n; *     ICMP errors (OK)&n; *     Packets failing IP header validation tests unless otherwise noted (OK)&n; *     Broadcast/multicast datagrams (OK)&n; *     MAC broadcasts (OK)&n; *     Non-initial fragments (OK)&n; *     Datagram with a source address that isn&squot;t a single host. (OK)&n; *  4.3.2.8 (Rate Limiting)&n; *   SHOULD be able to limit error message rate (OK)&n; *   SHOULD allow setting of rate limits (OK, in the source)&n; *  4.3.3.1 (Destination Unreachable)&n; *   All the rules govern the IP layer, and are dealt with in ip.c, not here.&n; *  4.3.3.2 (Redirect)&n; *   MAY ignore ICMP Redirects if running a routing protocol or if forwarding&n; *     is enabled on the interface (OK -- ignores)&n; *  4.3.3.3 (Source Quench)&n; *   SHOULD NOT originate SQ messages (OK)&n; *   MUST be able to limit SQ rate if originates them (OK as we don&squot;t &n; *&t;send them)&n; *   MAY ignore SQ messages it receives (OK -- we don&squot;t)&n; *  4.3.3.4 (Time Exceeded)&n; *   Requirements dealt with at IP (generating TIME_EXCEEDED).&n; *  4.3.3.5 (Parameter Problem)&n; *   MUST generate these for all errors not covered by other messages (OK)&n; *   MUST include original value of the value pointed by (OK)&n; *  4.3.3.6 (Echo Request)&n; *   MUST implement echo server function (OK)&n; *   MUST process at ER of at least max(576, MTU) (OK)&n; *   MAY reject broadcast/multicast ER&squot;s (We don&squot;t, but that&squot;s OK)&n; *   SHOULD have a config option for silently ignoring ER&squot;s (OK)&n; *   MUST have a default value for the above switch = NO (OK)&n; *   MUST have application layer interface for Echo Request/Reply (OK)&n; *   MUST reply using same source address as the request was sent to.&n; *     We&squot;re OK for unicast ECHOs, and it doesn&squot;t say anything about&n; *     how to handle broadcast ones, since it&squot;s optional.&n; *   MUST copy data from Request to Reply (OK)&n; *   SHOULD update Record Route / Timestamp options (??)&n; *   MUST use reversed Source Route for Reply if possible (NOT YET)&n; *  4.3.3.7 (Information Request/Reply)&n; *   SHOULD NOT originate or respond to these (OK)&n; *  4.3.3.8 (Timestamp / Timestamp Reply)&n; *   MAY implement (OK)&n; *   MUST reply to every Timestamp message received (OK)&n; *   MAY discard broadcast REQUESTs.  (OK, but see source for inconsistency)&n; *   MUST reply using same source address as the request was sent to. (OK)&n; *   MUST use reversed Source Route if possible (NOT YET)&n; *   SHOULD update Record Route / Timestamp options (??)&n; *   MUST pass REPLYs to transport/user layer (requires RAW, just like &n; *&t;ECHO) (OK)&n; *   MUST update clock for timestamp at least 16 times/sec (OK)&n; *   MUST be &quot;correct within a few minutes&quot; (OK)&n; * 4.3.3.9 (Address Mask Request/Reply)&n; *   MUST have support for receiving AMRq and responding with AMRe (OK, &n; *&t;but only as a compile-time option)&n; *   SHOULD have option for each interface for AMRe&squot;s, MUST default to &n; *&t;NO (NOT YET)&n; *   MUST NOT reply to AMRq before knows the correct AM (OK)&n; *   MUST NOT respond to AMRq with source address 0.0.0.0 on physical&n; *    &t;interfaces having multiple logical i-faces with different masks&n; *&t;(NOT YET)&n; *   SHOULD examine all AMRe&squot;s it receives and check them (NOT YET)&n; *   SHOULD log invalid AMRe&squot;s (AM+sender) (NOT YET)&n; *   MUST NOT use contents of AMRe to determine correct AM (OK)&n; *   MAY broadcast AMRe&squot;s after having configured address masks (OK -- doesn&squot;t)&n; *   MUST NOT do broadcast AMRe&squot;s if not set by extra option (OK, no option)&n; *   MUST use the { &lt;NetPrefix&gt;, -1 } form of broadcast addresses (OK)&n; * 4.3.3.10 (Router Advertisement and Solicitations)&n; *   MUST support router part of Router Discovery Protocol on all networks we&n; *     support broadcast or multicast addressing. (OK -- done by gated)&n; *   MUST have all config parameters with the respective defaults (OK)&n; * 5.2.7.1 (Destination Unreachable)&n; *   MUST generate DU&squot;s (OK)&n; *   SHOULD choose a best-match response code (OK)&n; *   SHOULD NOT generate Host Isolated codes (OK)&n; *   SHOULD use Communication Administratively Prohibited when administratively&n; *     filtering packets (NOT YET -- bug-to-bug compatibility)&n; *   MAY include config option for not generating the above and silently&n; *&t;discard the packets instead (OK)&n; *   MAY include config option for not generating Precedence Violation and&n; *     Precedence Cutoff messages (OK as we don&squot;t generate them at all)&n; *   MUST use Host Unreachable or Dest. Host Unknown codes whenever other hosts&n; *     on the same network might be reachable (OK -- no net unreach&squot;s at all)&n; *   MUST use new form of Fragmentation Needed and DF Set messages (OK)&n; * 5.2.7.2 (Redirect)&n; *   MUST NOT generate network redirects (OK)&n; *   MUST be able to generate host redirects (OK)&n; *   SHOULD be able to generate Host+TOS redirects (NO as we don&squot;t use TOS)&n; *   MUST have an option to use Host redirects instead of Host+TOS ones (OK as&n; *     no Host+TOS Redirects are used)&n; *   MUST NOT generate redirects unless forwarding to the same i-face and the&n; *     dest. address is on the same subnet as the src. address and no source&n; *     routing is in use. (OK)&n; *   MUST NOT follow redirects when using a routing protocol (OK)&n; *   MAY use redirects if not using a routing protocol (OK, compile-time option)&n; *   MUST comply to Host Requirements when not acting as a router (OK)&n; *  5.2.7.3 (Time Exceeded)&n; *   MUST generate Time Exceeded Code 0 when discarding packet due to TTL=0 (OK)&n; *   MAY have a per-interface option to disable origination of TE messages, but&n; *     it MUST default to &quot;originate&quot; (OK -- we don&squot;t support it)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;net/snmp.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;net/snmp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
DECL|macro|min
mdefine_line|#define min(a,b)&t;((a)&lt;(b)?(a):(b))
multiline_comment|/*&n; *&t;Statistics&n; */
DECL|variable|icmp_statistics
r_struct
id|icmp_mib
id|icmp_statistics
suffix:semicolon
multiline_comment|/* An array of errno for error messages from dest unreach. */
multiline_comment|/* RFC 1122: 3.2.2.1 States that NET_UNREACH, HOS_UNREACH and SR_FAIELD MUST be considered &squot;transient errs&squot;. */
DECL|variable|icmp_err_convert
r_struct
id|icmp_err
id|icmp_err_convert
(braket
)braket
op_assign
(brace
(brace
id|ENETUNREACH
comma
l_int|0
)brace
comma
multiline_comment|/*&t;ICMP_NET_UNREACH&t;*/
(brace
id|EHOSTUNREACH
comma
l_int|0
)brace
comma
multiline_comment|/*&t;ICMP_HOST_UNREACH&t;*/
(brace
id|ENOPROTOOPT
comma
l_int|1
)brace
comma
multiline_comment|/*&t;ICMP_PROT_UNREACH&t;*/
(brace
id|ECONNREFUSED
comma
l_int|1
)brace
comma
multiline_comment|/*&t;ICMP_PORT_UNREACH&t;*/
(brace
id|EOPNOTSUPP
comma
l_int|0
)brace
comma
multiline_comment|/*&t;ICMP_FRAG_NEEDED&t;*/
(brace
id|EOPNOTSUPP
comma
l_int|0
)brace
comma
multiline_comment|/*&t;ICMP_SR_FAILED&t;&t;*/
(brace
id|ENETUNREACH
comma
l_int|1
)brace
comma
multiline_comment|/* &t;ICMP_NET_UNKNOWN&t;*/
(brace
id|EHOSTDOWN
comma
l_int|1
)brace
comma
multiline_comment|/*&t;ICMP_HOST_UNKNOWN&t;*/
(brace
id|ENONET
comma
l_int|1
)brace
comma
multiline_comment|/*&t;ICMP_HOST_ISOLATED&t;*/
(brace
id|ENETUNREACH
comma
l_int|1
)brace
comma
multiline_comment|/*&t;ICMP_NET_ANO&t;&t;*/
(brace
id|EHOSTUNREACH
comma
l_int|1
)brace
comma
multiline_comment|/*&t;ICMP_HOST_ANO&t;&t;*/
(brace
id|EOPNOTSUPP
comma
l_int|0
)brace
comma
multiline_comment|/*&t;ICMP_NET_UNR_TOS&t;*/
(brace
id|EOPNOTSUPP
comma
l_int|0
)brace
comma
multiline_comment|/*&t;ICMP_HOST_UNR_TOS&t;*/
(brace
id|EOPNOTSUPP
comma
l_int|1
)brace
comma
multiline_comment|/*&t;ICMP_PKT_FILTERED&t;*/
(brace
id|EOPNOTSUPP
comma
l_int|1
)brace
comma
multiline_comment|/*&t;ICMP_PREC_VIOLATION&t;*/
(brace
id|EOPNOTSUPP
comma
l_int|1
)brace
multiline_comment|/*&t;ICMP_PREC_CUTOFF&t;*/
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;A spare long used to speed up statistics updating&n; */
DECL|variable|dummy
r_int
r_int
id|dummy
suffix:semicolon
multiline_comment|/*&n; *&t;ICMP transmit rate limit control structures. We use a relatively simple&n; *&t;approach to the problem: For each type of ICMP message with rate limit&n; *&t;we count the number of messages sent during some time quantum. If this&n; *&t;count exceeds given maximal value, we ignore all messages not separated&n; *&t;from the last message sent at least by specified time.&n; */
DECL|macro|XRLIM_CACHE_SIZE
mdefine_line|#define XRLIM_CACHE_SIZE 16&t;&t;/* How many destination hosts do we cache */
DECL|struct|icmp_xrl_cache
r_struct
id|icmp_xrl_cache
multiline_comment|/* One entry of the ICMP rate cache */
(brace
DECL|member|daddr
id|__u32
id|daddr
suffix:semicolon
multiline_comment|/* Destination address */
DECL|member|counter
r_int
r_int
id|counter
suffix:semicolon
multiline_comment|/* Message counter */
DECL|member|next_reset
r_int
r_int
id|next_reset
suffix:semicolon
multiline_comment|/* Time of next reset of the counter */
DECL|member|last_access
r_int
r_int
id|last_access
suffix:semicolon
multiline_comment|/* Time of last access to this entry (LRU) */
DECL|member|restricted
r_int
r_int
id|restricted
suffix:semicolon
multiline_comment|/* Set if we&squot;re in restricted mode */
DECL|member|next_packet
r_int
r_int
id|next_packet
suffix:semicolon
multiline_comment|/* When we&squot;ll allow a next packet if restricted */
)brace
suffix:semicolon
DECL|struct|icmp_xrlim
r_struct
id|icmp_xrlim
(brace
DECL|member|timeout
r_int
r_int
id|timeout
suffix:semicolon
multiline_comment|/* Time quantum for rate measuring */
DECL|member|limit
r_int
r_int
id|limit
suffix:semicolon
multiline_comment|/* Maximal number of messages per time quantum allowed */
DECL|member|delay
r_int
r_int
id|delay
suffix:semicolon
multiline_comment|/* How long we wait between packets when restricting */
DECL|member|cache
r_struct
id|icmp_xrl_cache
id|cache
(braket
id|XRLIM_CACHE_SIZE
)braket
suffix:semicolon
multiline_comment|/* Rate cache */
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;ICMP control array. This specifies what to do with each ICMP.&n; */
DECL|struct|icmp_control
r_struct
id|icmp_control
(brace
DECL|member|output
r_int
r_int
op_star
id|output
suffix:semicolon
multiline_comment|/* Address to increment on output */
DECL|member|input
r_int
r_int
op_star
id|input
suffix:semicolon
multiline_comment|/* Address to increment on input */
DECL|member|handler
r_void
(paren
op_star
id|handler
)paren
(paren
r_struct
id|icmphdr
op_star
id|icmph
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
id|__u32
id|saddr
comma
id|__u32
id|daddr
comma
r_int
id|len
)paren
suffix:semicolon
DECL|member|error
r_int
r_int
id|error
suffix:semicolon
multiline_comment|/* This ICMP is classed as an error message */
DECL|member|xrlim
r_struct
id|icmp_xrlim
op_star
id|xrlim
suffix:semicolon
multiline_comment|/* Transmit rate limit control structure or NULL for no limits */
)brace
suffix:semicolon
DECL|variable|icmp_pointers
r_static
r_struct
id|icmp_control
id|icmp_pointers
(braket
l_int|19
)braket
suffix:semicolon
multiline_comment|/*&n; *&t;Build xmit assembly blocks&n; */
DECL|struct|icmp_bxm
r_struct
id|icmp_bxm
(brace
DECL|member|data_ptr
r_void
op_star
id|data_ptr
suffix:semicolon
DECL|member|data_len
r_int
id|data_len
suffix:semicolon
DECL|member|icmph
r_struct
id|icmphdr
id|icmph
suffix:semicolon
DECL|member|csum
r_int
r_int
id|csum
suffix:semicolon
DECL|member|replyopts
r_struct
id|options
id|replyopts
suffix:semicolon
DECL|member|optbuf
r_int
r_char
id|optbuf
(braket
l_int|40
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;The ICMP socket. This is the most convenient way to flow control&n; *&t;our ICMP output as well as maintain a clean interface throughout&n; *&t;all layers. All Socketless IP sends will soon be gone.&n; */
DECL|variable|icmp_socket
r_struct
id|socket
id|icmp_socket
suffix:semicolon
multiline_comment|/*&n; *&t;Send an ICMP frame.&n; */
multiline_comment|/*&n; *&t;Initialize the transmit rate limitation mechanism.&n; */
macro_line|#ifndef CONFIG_NO_ICMP_LIMIT
DECL|function|xrlim_init
r_static
r_void
id|xrlim_init
c_func
(paren
r_void
)paren
(brace
r_int
id|type
comma
id|entry
suffix:semicolon
r_struct
id|icmp_xrlim
op_star
id|xr
suffix:semicolon
r_for
c_loop
(paren
id|type
op_assign
l_int|0
suffix:semicolon
id|type
op_le
l_int|18
suffix:semicolon
id|type
op_increment
)paren
(brace
id|xr
op_assign
id|icmp_pointers
(braket
id|type
)braket
dot
id|xrlim
suffix:semicolon
r_if
c_cond
(paren
id|xr
)paren
(brace
r_for
c_loop
(paren
id|entry
op_assign
l_int|0
suffix:semicolon
id|entry
OL
id|XRLIM_CACHE_SIZE
suffix:semicolon
id|entry
op_increment
)paren
id|xr-&gt;cache
(braket
id|entry
)braket
dot
id|daddr
op_assign
id|INADDR_NONE
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; *&t;Check transmit rate limitation for given message.&n; *&n; *&t;RFC 1812: 4.3.2.8 SHOULD be able to limit error message rate&n; *&t;&t;&t;  SHOULD allow setting of rate limits (we allow &n; *&t;&t;&t;  in the source)&n; */
DECL|function|xrlim_allow
r_static
r_int
id|xrlim_allow
c_func
(paren
r_int
id|type
comma
id|__u32
id|addr
)paren
(brace
r_struct
id|icmp_xrlim
op_star
id|r
suffix:semicolon
r_struct
id|icmp_xrl_cache
op_star
id|c
suffix:semicolon
r_int
r_int
id|now
suffix:semicolon
r_if
c_cond
(paren
id|type
OG
l_int|18
)paren
multiline_comment|/* No time limit present */
r_return
l_int|1
suffix:semicolon
id|r
op_assign
id|icmp_pointers
(braket
id|type
)braket
dot
id|xrlim
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
id|r-&gt;cache
suffix:semicolon
id|c
OL
op_amp
id|r-&gt;cache
(braket
id|XRLIM_CACHE_SIZE
)braket
suffix:semicolon
id|c
op_increment
)paren
multiline_comment|/* Cache lookup */
r_if
c_cond
(paren
id|c-&gt;daddr
op_eq
id|addr
)paren
r_break
suffix:semicolon
id|now
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Cache current time (saves accesses to volatile variable) */
r_if
c_cond
(paren
id|c
op_eq
op_amp
id|r-&gt;cache
(braket
id|XRLIM_CACHE_SIZE
)braket
)paren
(brace
multiline_comment|/* Cache miss */
r_int
r_int
id|oldest
op_assign
id|now
suffix:semicolon
multiline_comment|/* Find the oldest entry to replace */
r_struct
id|icmp_xrl_cache
op_star
id|d
suffix:semicolon
id|c
op_assign
id|r-&gt;cache
suffix:semicolon
r_for
c_loop
(paren
id|d
op_assign
id|r-&gt;cache
suffix:semicolon
id|d
OL
op_amp
id|r-&gt;cache
(braket
id|XRLIM_CACHE_SIZE
)braket
suffix:semicolon
id|d
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|d-&gt;daddr
)paren
(brace
multiline_comment|/* Unused entry */
id|c
op_assign
id|d
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|d-&gt;last_access
OL
id|oldest
)paren
(brace
id|oldest
op_assign
id|d-&gt;last_access
suffix:semicolon
id|c
op_assign
id|d
suffix:semicolon
)brace
id|c-&gt;last_access
op_assign
id|now
suffix:semicolon
multiline_comment|/* Fill the entry with new data */
id|c-&gt;daddr
op_assign
id|addr
suffix:semicolon
id|c-&gt;counter
op_assign
l_int|1
suffix:semicolon
id|c-&gt;next_reset
op_assign
id|now
op_plus
id|r-&gt;timeout
suffix:semicolon
id|c-&gt;restricted
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|c-&gt;last_access
op_assign
id|now
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;next_reset
OG
id|now
)paren
(brace
multiline_comment|/* Let&squot;s increment the counter */
id|c-&gt;counter
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;counter
op_eq
id|r-&gt;limit
)paren
(brace
multiline_comment|/* Limit exceeded, start restrictions */
id|c-&gt;restricted
op_assign
l_int|1
suffix:semicolon
id|c-&gt;next_packet
op_assign
id|now
op_plus
id|r-&gt;delay
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;restricted
)paren
(brace
multiline_comment|/* Any restrictions pending? */
r_if
c_cond
(paren
id|c-&gt;next_packet
OG
id|now
)paren
r_return
l_int|0
suffix:semicolon
id|c-&gt;next_packet
op_assign
id|now
op_plus
id|r-&gt;delay
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Reset the counter */
r_if
c_cond
(paren
id|c-&gt;counter
OL
id|r-&gt;limit
)paren
multiline_comment|/* Switch off all restrictions */
id|c-&gt;restricted
op_assign
l_int|0
suffix:semicolon
id|c-&gt;next_reset
op_assign
id|now
op_plus
id|r-&gt;timeout
suffix:semicolon
id|c-&gt;counter
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Send the packet */
)brace
macro_line|#endif /* CONFIG_NO_ICMP_LIMIT */
multiline_comment|/*&n; *&t;Maintain the counters used in the SNMP statistics for outgoing ICMP&n; */
DECL|function|icmp_out_count
r_static
r_void
id|icmp_out_count
c_func
(paren
r_int
id|type
)paren
(brace
r_if
c_cond
(paren
id|type
OG
l_int|18
)paren
(brace
r_return
suffix:semicolon
)brace
(paren
op_star
id|icmp_pointers
(braket
id|type
)braket
dot
id|output
)paren
op_increment
suffix:semicolon
id|icmp_statistics.IcmpOutMsgs
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Checksum each fragment, and on the first include the headers and final checksum.&n; */
DECL|function|icmp_glue_bits
r_static
r_int
id|icmp_glue_bits
c_func
(paren
r_const
r_void
op_star
id|p
comma
id|__u32
id|saddr
comma
r_char
op_star
id|to
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|fraglen
)paren
(brace
r_struct
id|icmp_bxm
op_star
id|icmp_param
op_assign
(paren
r_struct
id|icmp_bxm
op_star
)paren
id|p
suffix:semicolon
r_struct
id|icmphdr
op_star
id|icmph
suffix:semicolon
r_int
r_int
id|csum
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
(brace
id|icmp_param-&gt;csum
op_assign
id|csum_partial_copy
c_func
(paren
id|icmp_param-&gt;data_ptr
op_plus
id|offset
op_minus
r_sizeof
(paren
r_struct
id|icmphdr
)paren
comma
id|to
comma
id|fraglen
comma
id|icmp_param-&gt;csum
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;First fragment includes header. Note that we&squot;ve done&n;&t; *&t;the other fragments first, so that we get the checksum&n;&t; *&t;for the whole packet here.&n;&t; */
id|csum
op_assign
id|csum_partial_copy
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|icmp_param-&gt;icmph
comma
id|to
comma
r_sizeof
(paren
r_struct
id|icmphdr
)paren
comma
id|icmp_param-&gt;csum
)paren
suffix:semicolon
id|csum
op_assign
id|csum_partial_copy
c_func
(paren
id|icmp_param-&gt;data_ptr
comma
id|to
op_plus
r_sizeof
(paren
r_struct
id|icmphdr
)paren
comma
id|fraglen
op_minus
r_sizeof
(paren
r_struct
id|icmphdr
)paren
comma
id|csum
)paren
suffix:semicolon
id|icmph
op_assign
(paren
r_struct
id|icmphdr
op_star
)paren
id|to
suffix:semicolon
id|icmph-&gt;checksum
op_assign
id|csum_fold
c_func
(paren
id|csum
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Driving logic for building and sending ICMP messages.&n; */
DECL|function|icmp_build_xmit
r_static
r_void
id|icmp_build_xmit
c_func
(paren
r_struct
id|icmp_bxm
op_star
id|icmp_param
comma
id|__u32
id|saddr
comma
id|__u32
id|daddr
comma
id|__u8
id|tos
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|icmp_socket.data
suffix:semicolon
id|icmp_param-&gt;icmph.checksum
op_assign
l_int|0
suffix:semicolon
id|icmp_param-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|icmp_out_count
c_func
(paren
id|icmp_param-&gt;icmph.type
)paren
suffix:semicolon
id|sk-&gt;ip_tos
op_assign
id|tos
suffix:semicolon
id|ip_build_xmit
c_func
(paren
id|sk
comma
id|icmp_glue_bits
comma
id|icmp_param
comma
id|icmp_param-&gt;data_len
op_plus
r_sizeof
(paren
r_struct
id|icmphdr
)paren
comma
id|daddr
comma
id|saddr
comma
op_amp
id|icmp_param-&gt;replyopts
comma
l_int|0
comma
id|IPPROTO_ICMP
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send an ICMP message in response to a situation&n; *&n; *&t;RFC 1122: 3.2.2&t;MUST send at least the IP header and 8 bytes of header. MAY send more (we do).&n; *&t;&t;&t;MUST NOT change this header information.&n; *&t;&t;&t;MUST NOT reply to a multicast/broadcast IP address.&n; *&t;&t;&t;MUST NOT reply to a multicast/broadcast MAC address.&n; *&t;&t;&t;MUST reply to only the first fragment.&n; */
DECL|function|icmp_send
r_void
id|icmp_send
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb_in
comma
r_int
id|type
comma
r_int
id|code
comma
r_int
r_int
id|info
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_struct
id|icmphdr
op_star
id|icmph
suffix:semicolon
r_int
id|atype
comma
id|room
suffix:semicolon
r_struct
id|icmp_bxm
id|icmp_param
suffix:semicolon
id|__u32
id|saddr
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Find the original header&n;&t; */
id|iph
op_assign
id|skb_in-&gt;ip_hdr
suffix:semicolon
multiline_comment|/*&n;&t; *&t;No replies to physical multicast/broadcast&n;&t; */
r_if
c_cond
(paren
id|skb_in-&gt;pkt_type
op_ne
id|PACKET_HOST
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Now check at the protocol level&n;&t; */
id|atype
op_assign
id|ip_chk_addr
c_func
(paren
id|iph-&gt;daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atype
op_eq
id|IS_BROADCAST
op_logical_or
id|atype
op_eq
id|IS_MULTICAST
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Only reply to fragment 0. We byte re-order the constant&n;&t; *&t;mask for efficiency.&n;&t; */
r_if
c_cond
(paren
id|iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_OFFSET
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* &n;&t; *&t;If we send an ICMP error to an ICMP error a mess would result..&n;&t; */
r_if
c_cond
(paren
id|icmp_pointers
(braket
id|type
)braket
dot
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;We are an error, check if we are replying to an ICMP error&n;&t;&t; */
r_if
c_cond
(paren
id|iph-&gt;protocol
op_eq
id|IPPROTO_ICMP
)paren
(brace
id|icmph
op_assign
(paren
r_struct
id|icmphdr
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|iph
op_plus
(paren
id|iph-&gt;ihl
op_lshift
l_int|2
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Assume any unknown ICMP type is an error. This isn&squot;t&n;&t;&t;&t; *&t;specified by the RFC, but think about it..&n;&t;&t;&t; */
r_if
c_cond
(paren
id|icmph-&gt;type
OG
l_int|18
op_logical_or
id|icmp_pointers
(braket
id|icmph-&gt;type
)braket
dot
id|error
)paren
(brace
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; *&t;Check the rate limit&n;&t; */
macro_line|#ifndef CONFIG_NO_ICMP_LIMIT
r_if
c_cond
(paren
op_logical_neg
id|xrlim_allow
c_func
(paren
id|type
comma
id|iph-&gt;saddr
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif&t;
multiline_comment|/*&n;&t; *&t;Construct source address and options.&n;&t; */
id|saddr
op_assign
id|iph-&gt;daddr
suffix:semicolon
r_if
c_cond
(paren
id|saddr
op_ne
id|dev-&gt;pa_addr
op_logical_and
id|ip_chk_addr
c_func
(paren
id|saddr
)paren
op_ne
id|IS_MYADDR
)paren
(brace
id|saddr
op_assign
id|dev-&gt;pa_addr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip_options_echo
c_func
(paren
op_amp
id|icmp_param.replyopts
comma
l_int|NULL
comma
id|saddr
comma
id|iph-&gt;saddr
comma
id|skb_in
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Prepare data for ICMP header.&n;&t; */
id|icmp_param.icmph.type
op_assign
id|type
suffix:semicolon
id|icmp_param.icmph.code
op_assign
id|code
suffix:semicolon
id|icmp_param.icmph.un.gateway
op_assign
id|info
suffix:semicolon
id|icmp_param.data_ptr
op_assign
id|iph
suffix:semicolon
id|room
op_assign
l_int|576
op_minus
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_minus
id|icmp_param.replyopts.optlen
suffix:semicolon
id|icmp_param.data_len
op_assign
(paren
id|iph-&gt;ihl
op_lshift
l_int|2
)paren
op_plus
id|skb_in-&gt;len
suffix:semicolon
multiline_comment|/* RFC says return as much as we can without exceeding 576 bytes */
r_if
c_cond
(paren
id|icmp_param.data_len
OG
id|room
)paren
id|icmp_param.data_len
op_assign
id|room
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Build and send the packet.&n;&t; */
id|icmp_build_xmit
c_func
(paren
op_amp
id|icmp_param
comma
id|saddr
comma
id|iph-&gt;saddr
comma
id|icmp_pointers
(braket
id|type
)braket
dot
id|error
ques
c_cond
(paren
id|iph-&gt;tos
op_amp
l_int|0x1E
)paren
op_or
l_int|0xC0
suffix:colon
id|iph-&gt;tos
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Handle ICMP_DEST_UNREACH, ICMP_TIME_EXCEED, and ICMP_QUENCH. &n; */
DECL|function|icmp_unreach
r_static
r_void
id|icmp_unreach
c_func
(paren
r_struct
id|icmphdr
op_star
id|icmph
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
id|__u32
id|saddr
comma
id|__u32
id|daddr
comma
r_int
id|len
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_int
id|hash
suffix:semicolon
r_struct
id|inet_protocol
op_star
id|ipprot
suffix:semicolon
r_int
r_char
op_star
id|dp
suffix:semicolon
id|__u32
id|info
op_assign
l_int|0
suffix:semicolon
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
(paren
id|icmph
op_plus
l_int|1
)paren
suffix:semicolon
id|dp
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|iph
)paren
op_plus
(paren
id|iph-&gt;ihl
op_lshift
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|icmph-&gt;type
op_eq
id|ICMP_DEST_UNREACH
)paren
(brace
r_switch
c_cond
(paren
id|icmph-&gt;code
op_amp
l_int|15
)paren
(brace
r_case
id|ICMP_NET_UNREACH
suffix:colon
r_break
suffix:semicolon
r_case
id|ICMP_HOST_UNREACH
suffix:colon
r_break
suffix:semicolon
r_case
id|ICMP_PROT_UNREACH
suffix:colon
multiline_comment|/*&t;&t;&t;&t;printk(KERN_INFO &quot;ICMP: %s:%d: protocol unreachable.&bslash;n&quot;,&n;&t;&t;&t;&t;&t;in_ntoa(iph-&gt;daddr), (int)iph-&gt;protocol);*/
r_break
suffix:semicolon
r_case
id|ICMP_PORT_UNREACH
suffix:colon
r_break
suffix:semicolon
r_case
id|ICMP_FRAG_NEEDED
suffix:colon
macro_line|#ifdef CONFIG_NO_PATH_MTU_DISCOVERY
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ICMP: %s: fragmentation needed and DF set.&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|iph-&gt;daddr
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#else
(brace
r_int
r_int
id|old_mtu
op_assign
id|ntohs
c_func
(paren
id|iph-&gt;tot_len
)paren
suffix:semicolon
r_int
r_int
id|new_mtu
op_assign
id|ntohs
c_func
(paren
id|icmph-&gt;un.echo.sequence
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * RFC1191 5.  4.2BSD based router can return incorrect&n;&t;&t;&t;&t; * Total Length.  If current mtu is unknown or old_mtu&n;&t;&t;&t;&t; * is not less than current mtu, reduce old_mtu by 4 times&n;&t;&t;&t;&t; * the header length.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;sk
op_eq
l_int|NULL
multiline_comment|/* can this happen? */
op_logical_or
id|skb-&gt;sk-&gt;ip_route_cache
op_eq
l_int|NULL
op_logical_or
id|skb-&gt;sk-&gt;ip_route_cache-&gt;rt_mtu
op_le
id|old_mtu
)paren
(brace
id|NETDEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;4.2BSD based fragmenting router between here and %s, mtu corrected from %d&quot;
comma
id|in_ntoa
c_func
(paren
id|iph-&gt;daddr
)paren
comma
id|old_mtu
)paren
)paren
suffix:semicolon
id|old_mtu
op_sub_assign
l_int|4
op_star
id|iph-&gt;ihl
suffix:semicolon
id|NETDEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot; to %d&bslash;n&quot;
comma
id|old_mtu
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_mtu
OL
l_int|68
op_logical_or
id|new_mtu
op_ge
id|old_mtu
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * &t;It is either dumb router, which does not&n;&t;&t;&t;&t;&t; *&t;understand Path MTU Disc. protocol&n;&t;&t;&t;&t;&t; *&t;or broken (f.e. Linux&lt;=1.3.37 8) router.&n;&t;&t;&t;&t;&t; *&t;Try to guess...&n;&t;&t;&t;&t;&t; *&t;The table is taken from RFC-1191.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|old_mtu
OG
l_int|32000
)paren
id|new_mtu
op_assign
l_int|32000
suffix:semicolon
r_else
r_if
c_cond
(paren
id|old_mtu
OG
l_int|17914
)paren
id|new_mtu
op_assign
l_int|17914
suffix:semicolon
r_else
r_if
c_cond
(paren
id|old_mtu
OG
l_int|8166
)paren
id|new_mtu
op_assign
l_int|8166
suffix:semicolon
r_else
r_if
c_cond
(paren
id|old_mtu
OG
l_int|4352
)paren
id|new_mtu
op_assign
l_int|4352
suffix:semicolon
r_else
r_if
c_cond
(paren
id|old_mtu
OG
l_int|2002
)paren
id|new_mtu
op_assign
l_int|2002
suffix:semicolon
r_else
r_if
c_cond
(paren
id|old_mtu
OG
l_int|1492
)paren
id|new_mtu
op_assign
l_int|1492
suffix:semicolon
r_else
r_if
c_cond
(paren
id|old_mtu
OG
l_int|576
)paren
id|new_mtu
op_assign
l_int|576
suffix:semicolon
r_else
r_if
c_cond
(paren
id|old_mtu
OG
l_int|296
)paren
id|new_mtu
op_assign
l_int|296
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;These two are not from the RFC but&n;&t;&t;&t;&t;&t; *&t;are needed for AMPRnet AX.25 paths.&n;&t;&t;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|old_mtu
OG
l_int|216
)paren
id|new_mtu
op_assign
l_int|216
suffix:semicolon
r_else
r_if
c_cond
(paren
id|old_mtu
OG
l_int|128
)paren
id|new_mtu
op_assign
l_int|128
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;Despair..&n;&t;&t;&t;&t;&t; */
id|new_mtu
op_assign
l_int|68
suffix:semicolon
)brace
id|info
op_assign
id|new_mtu
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
r_case
id|ICMP_SR_FAILED
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ICMP: %s: Source Route Failed.&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|iph-&gt;daddr
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|icmph-&gt;code
OG
id|NR_ICMP_UNREACH
)paren
(brace
multiline_comment|/* Invalid type */
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Throw it at our lower layers&n;&t; *&n;&t; *&t;RFC 1122: 3.2.2 MUST extract the protocol ID from the passed header.&n;&t; *&t;RFC 1122: 3.2.2.1 MUST pass ICMP unreach messages to the transport layer.&n;&t; *&t;RFC 1122: 3.2.2.2 MUST pass ICMP time expired messages to transport layer.&n;&t; */
multiline_comment|/*&n;&t; *&t;Get the protocol(s). &n;&t; */
id|hash
op_assign
id|iph-&gt;protocol
op_amp
(paren
id|MAX_INET_PROTOS
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This can&squot;t change while we are doing it. &n;&t; *&n;&t; *&t;FIXME: Deliver to appropriate raw sockets too.&n;&t; */
id|ipprot
op_assign
(paren
r_struct
id|inet_protocol
op_star
)paren
id|inet_protos
(braket
id|hash
)braket
suffix:semicolon
r_while
c_loop
(paren
id|ipprot
op_ne
l_int|NULL
)paren
(brace
r_struct
id|inet_protocol
op_star
id|nextip
suffix:semicolon
id|nextip
op_assign
(paren
r_struct
id|inet_protocol
op_star
)paren
id|ipprot-&gt;next
suffix:semicolon
multiline_comment|/* &n;&t;&t; *&t;Pass it off to everyone who wants it. &n;&t;&t; */
multiline_comment|/* RFC1122: OK. Passes appropriate ICMP errors to the */
multiline_comment|/* appropriate protocol layer (MUST), as per 3.2.2. */
r_if
c_cond
(paren
id|iph-&gt;protocol
op_eq
id|ipprot-&gt;protocol
op_logical_and
id|ipprot-&gt;err_handler
)paren
(brace
id|ipprot
op_member_access_from_pointer
id|err_handler
c_func
(paren
id|icmph-&gt;type
comma
id|icmph-&gt;code
comma
id|dp
comma
id|info
comma
id|iph-&gt;daddr
comma
id|iph-&gt;saddr
comma
id|ipprot
)paren
suffix:semicolon
)brace
id|ipprot
op_assign
id|nextip
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Handle ICMP_REDIRECT. &n; */
DECL|function|icmp_redirect
r_static
r_void
id|icmp_redirect
c_func
(paren
r_struct
id|icmphdr
op_star
id|icmph
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
id|__u32
id|source
comma
id|__u32
id|daddr
comma
r_int
id|len
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_int
r_int
id|ip
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Get the copied header of the packet that caused the redirect&n;&t; */
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
(paren
id|icmph
op_plus
l_int|1
)paren
suffix:semicolon
id|ip
op_assign
id|iph-&gt;daddr
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If we are a router and we run a routing protocol, we MUST NOT follow redirects.&n;&t; *&t;When using no routing protocol, we MAY follow redirects. (RFC 1812, 5.2.7.2)&n;&t; */
macro_line|#if defined(CONFIG_IP_FORWARD) &amp;&amp; !defined(CONFIG_IP_DUMB_ROUTER)
id|NETDEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;icmp: ICMP redirect ignored. dest = %lX, &quot;
l_string|&quot;orig gw = %lX, &bslash;&quot;new&bslash;&quot; gw = %lX, device = %s.&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|ip
)paren
comma
id|ntohl
c_func
(paren
id|source
)paren
comma
id|ntohl
c_func
(paren
id|icmph-&gt;un.gateway
)paren
comma
id|dev-&gt;name
)paren
)paren
suffix:semicolon
macro_line|#else&t;
r_switch
c_cond
(paren
id|icmph-&gt;code
op_amp
l_int|7
)paren
(brace
r_case
id|ICMP_REDIR_NET
suffix:colon
multiline_comment|/*&n;&t;&t;&t; *&t;This causes a problem with subnetted networks. What we should do&n;&t;&t;&t; *&t;is use ICMP_ADDRESS to get the subnet mask of the problem route&n;&t;&t;&t; *&t;and set both. But we don&squot;t.. [RFC1812 says routers MUST NOT&n;&t;&t;&t; *&t;generate Network Redirects]&n;&t;&t;&t; */
macro_line|#ifdef not_a_good_idea
id|ip_rt_add
c_func
(paren
(paren
id|RTF_DYNAMIC
op_or
id|RTF_MODIFIED
op_or
id|RTF_GATEWAY
)paren
comma
id|ip
comma
l_int|0
comma
id|icmph-&gt;un.gateway
comma
id|dev
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t; *&t;As per RFC recommendations now handle it as&n;&t;&t;&t; *&t;a host redirect.&n;&t;&t;&t; */
r_case
id|ICMP_REDIR_HOST
suffix:colon
multiline_comment|/*&n;&t;&t;&t; *&t;Add better route to host.&n;&t;&t;&t; *&t;But first check that the redirect&n;&t;&t;&t; *&t;comes from the old gateway..&n;&t;&t;&t; *&t;And make sure it&squot;s an ok host address&n;&t;&t;&t; *&t;(not some confused thing sending our&n;&t;&t;&t; *&t;address)&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ICMP redirect from %s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|source
)paren
)paren
suffix:semicolon
id|ip_rt_redirect
c_func
(paren
id|source
comma
id|ip
comma
id|icmph-&gt;un.gateway
comma
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ICMP_REDIR_NETTOS
suffix:colon
r_case
id|ICMP_REDIR_HOSTTOS
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ICMP: cannot handle TOS redirects yet!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
macro_line|#endif  &t;
multiline_comment|/*&n;  &t; *&t;Discard the original packet&n;  &t; */
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Handle ICMP_ECHO (&quot;ping&quot;) requests. &n; *&n; *&t;RFC 1122: 3.2.2.6 MUST have an echo server that answers ICMP echo requests.&n; *&t;RFC 1122: 3.2.2.6 Data received in the ICMP_ECHO request MUST be included in the reply.&n; *&t;RFC 1812: 4.3.3.6 SHOULD have a config option for silently ignoring echo requests, MUST have default=NOT.&n; *&t;See also WRT handling of options once they are done and working.&n; */
DECL|function|icmp_echo
r_static
r_void
id|icmp_echo
c_func
(paren
r_struct
id|icmphdr
op_star
id|icmph
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
id|__u32
id|saddr
comma
id|__u32
id|daddr
comma
r_int
id|len
)paren
(brace
macro_line|#ifndef CONFIG_IP_IGNORE_ECHO_REQUESTS
r_struct
id|icmp_bxm
id|icmp_param
suffix:semicolon
id|icmp_param.icmph
op_assign
op_star
id|icmph
suffix:semicolon
id|icmp_param.icmph.type
op_assign
id|ICMP_ECHOREPLY
suffix:semicolon
id|icmp_param.data_ptr
op_assign
(paren
id|icmph
op_plus
l_int|1
)paren
suffix:semicolon
id|icmp_param.data_len
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|ip_options_echo
c_func
(paren
op_amp
id|icmp_param.replyopts
comma
l_int|NULL
comma
id|daddr
comma
id|saddr
comma
id|skb
)paren
op_eq
l_int|0
)paren
id|icmp_build_xmit
c_func
(paren
op_amp
id|icmp_param
comma
id|daddr
comma
id|saddr
comma
id|skb-&gt;ip_hdr-&gt;tos
)paren
suffix:semicolon
macro_line|#endif
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Handle ICMP Timestamp requests. &n; *&t;RFC 1122: 3.2.2.8 MAY implement ICMP timestamp requests.&n; *&t;&t;  SHOULD be in the kernel for minimum random latency.&n; *&t;&t;  MUST be accurate to a few minutes.&n; *&t;&t;  MUST be updated at least at 15Hz.&n; */
DECL|function|icmp_timestamp
r_static
r_void
id|icmp_timestamp
c_func
(paren
r_struct
id|icmphdr
op_star
id|icmph
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
id|__u32
id|saddr
comma
id|__u32
id|daddr
comma
r_int
id|len
)paren
(brace
id|__u32
id|times
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* So the new timestamp works on ALPHA&squot;s.. */
r_struct
id|icmp_bxm
id|icmp_param
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Too short.&n;&t; */
r_if
c_cond
(paren
id|len
OL
l_int|12
)paren
(brace
id|icmp_statistics.IcmpInErrors
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Fill in the current time as ms since midnight UT: &n;&t; */
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|times
(braket
l_int|1
)braket
op_assign
id|htonl
c_func
(paren
(paren
id|tv.tv_sec
op_mod
l_int|86400
)paren
op_star
l_int|1000
op_plus
id|tv.tv_usec
op_div
l_int|1000
)paren
suffix:semicolon
)brace
id|times
(braket
l_int|2
)braket
op_assign
id|times
(braket
l_int|1
)braket
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|times
(braket
l_int|0
)braket
comma
id|icmph
op_plus
l_int|1
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Incoming stamp */
id|icmp_param.icmph
op_assign
op_star
id|icmph
suffix:semicolon
id|icmp_param.icmph.type
op_assign
id|ICMP_TIMESTAMPREPLY
suffix:semicolon
id|icmp_param.icmph.code
op_assign
l_int|0
suffix:semicolon
id|icmp_param.data_ptr
op_assign
op_amp
id|times
suffix:semicolon
id|icmp_param.data_len
op_assign
l_int|12
suffix:semicolon
r_if
c_cond
(paren
id|ip_options_echo
c_func
(paren
op_amp
id|icmp_param.replyopts
comma
l_int|NULL
comma
id|daddr
comma
id|saddr
comma
id|skb
)paren
op_eq
l_int|0
)paren
id|icmp_build_xmit
c_func
(paren
op_amp
id|icmp_param
comma
id|daddr
comma
id|saddr
comma
id|skb-&gt;ip_hdr-&gt;tos
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Handle ICMP_ADDRESS_MASK requests.  (RFC950)&n; *&n; * RFC1122 (3.2.2.9).  A host MUST only send replies to &n; * ADDRESS_MASK requests if it&squot;s been configured as an address mask &n; * agent.  Receiving a request doesn&squot;t constitute implicit permission to &n; * act as one. Of course, implementing this correctly requires (SHOULD) &n; * a way to turn the functionality on and off.  Another one for sysctl(), &n; * I guess. -- MS &n; * Botched with a CONFIG option for now - Linus add scts sysctl please.. &n; */
DECL|function|icmp_address
r_static
r_void
id|icmp_address
c_func
(paren
r_struct
id|icmphdr
op_star
id|icmph
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
id|__u32
id|saddr
comma
id|__u32
id|daddr
comma
r_int
id|len
)paren
(brace
macro_line|#ifdef CONFIG_IP_ADDR_AGENT&t;/* Don&squot;t use, broken */
r_struct
id|icmp_bxm
id|icmp_param
suffix:semicolon
id|icmp_param.icmph.type
op_assign
id|ICMP_ADDRESSREPLY
suffix:semicolon
id|icmp_param.icmph.code
op_assign
l_int|0
suffix:semicolon
id|icmp_param.icmph.un.echo.id
op_assign
id|icmph-&gt;un.echo.id
suffix:semicolon
id|icmp_param.icmph.un.echo.sequence
op_assign
id|icmph-&gt;un.echo.sequence
suffix:semicolon
id|icmp_param.data_ptr
op_assign
op_amp
id|dev-&gt;pa_mask
suffix:semicolon
id|icmp_param.data_len
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|ip_options_echo
c_func
(paren
op_amp
id|icmp_param.replyopts
comma
l_int|NULL
comma
id|daddr
comma
id|saddr
comma
id|skb
)paren
op_eq
l_int|0
)paren
id|icmp_build_xmit
c_func
(paren
op_amp
id|icmp_param
comma
id|daddr
comma
id|saddr
comma
id|skb-&gt;iph-&gt;tos
)paren
suffix:semicolon
macro_line|#endif&t;
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
DECL|function|icmp_discard
r_static
r_void
id|icmp_discard
c_func
(paren
r_struct
id|icmphdr
op_star
id|icmph
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
id|__u32
id|saddr
comma
id|__u32
id|daddr
comma
r_int
id|len
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IP_TRANSPARENT_PROXY
multiline_comment|/*&n; *&t;Check incoming icmp packets not addressed locally, to check whether&n; *&t;they relate to a (proxying) socket on our system.&n; *&t;Needed for transparent proxying.&n; *&n; *&t;This code is presently ugly and needs cleanup.&n; *&t;Probably should add a chkaddr entry to ipprot to call a chk routine&n; *&t;in udp.c or tcp.c...&n; */
DECL|function|icmp_chkaddr
r_int
id|icmp_chkaddr
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|icmphdr
op_star
id|icmph
op_assign
(paren
r_struct
id|icmphdr
op_star
)paren
(paren
id|skb-&gt;h.raw
op_plus
id|skb-&gt;h.iph-&gt;ihl
op_star
l_int|4
)paren
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
(paren
id|icmph
op_plus
l_int|1
)paren
suffix:semicolon
r_void
(paren
op_star
id|handler
)paren
(paren
r_struct
id|icmphdr
op_star
id|icmph
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
id|__u32
id|saddr
comma
id|__u32
id|daddr
comma
r_int
id|len
)paren
op_assign
id|icmp_pointers
(braket
id|icmph-&gt;type
)braket
dot
id|handler
suffix:semicolon
r_if
c_cond
(paren
id|handler
op_eq
id|icmp_unreach
op_logical_or
id|handler
op_eq
id|icmp_redirect
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_switch
c_cond
(paren
id|iph-&gt;protocol
)paren
(brace
r_case
id|IPPROTO_TCP
suffix:colon
(brace
r_struct
id|tcphdr
op_star
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|iph
)paren
op_plus
(paren
id|iph-&gt;ihl
op_lshift
l_int|2
)paren
)paren
suffix:semicolon
id|sk
op_assign
id|get_sock
c_func
(paren
op_amp
id|tcp_prot
comma
id|th-&gt;source
comma
id|iph-&gt;daddr
comma
id|th-&gt;dest
comma
id|iph-&gt;saddr
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;saddr
op_ne
id|iph-&gt;saddr
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;daddr
op_ne
id|iph-&gt;daddr
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;dummy_th.dest
op_ne
id|th-&gt;dest
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * This packet came from us.&n;&t;&t;&t; */
r_return
l_int|1
suffix:semicolon
)brace
r_case
id|IPPROTO_UDP
suffix:colon
(brace
r_struct
id|udphdr
op_star
id|uh
op_assign
(paren
r_struct
id|udphdr
op_star
)paren
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|iph
)paren
op_plus
(paren
id|iph-&gt;ihl
op_lshift
l_int|2
)paren
)paren
suffix:semicolon
id|sk
op_assign
id|get_sock
c_func
(paren
op_amp
id|udp_prot
comma
id|uh-&gt;source
comma
id|iph-&gt;daddr
comma
id|uh-&gt;dest
comma
id|iph-&gt;saddr
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;saddr
op_ne
id|iph-&gt;saddr
op_logical_and
id|ip_chk_addr
c_func
(paren
id|iph-&gt;saddr
)paren
op_ne
id|IS_MYADDR
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * This packet may have come from us.&n;&t;&t;&t; * Assume it did.&n;&t;&t;&t; */
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* &n; *&t;Deal with incoming ICMP packets. &n; */
DECL|function|icmp_rcv
r_int
id|icmp_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|options
op_star
id|opt
comma
id|__u32
id|daddr
comma
r_int
r_int
id|len
comma
id|__u32
id|saddr
comma
r_int
id|redo
comma
r_struct
id|inet_protocol
op_star
id|protocol
)paren
(brace
r_struct
id|icmphdr
op_star
id|icmph
op_assign
(paren
r_void
op_star
)paren
id|skb-&gt;h.raw
suffix:semicolon
macro_line|#ifdef CONFIG_IP_TRANSPARENT_PROXY
r_int
id|r
suffix:semicolon
macro_line|#endif
id|icmp_statistics.IcmpInMsgs
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Validate the packet&n;  &t; */
r_if
c_cond
(paren
id|ip_compute_csum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|icmph
comma
id|len
)paren
)paren
(brace
multiline_comment|/* Failed checksum! */
id|icmp_statistics.IcmpInErrors
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ICMP: failed checksum from %s!&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|saddr
)paren
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;18 is the highest &squot;known&squot; ICMP type. Anything else is a mystery&n;&t; *&n;&t; *&t;RFC 1122: 3.2.2  Unknown ICMP messages types MUST be silently discarded.&n;&t; */
r_if
c_cond
(paren
id|icmph-&gt;type
OG
l_int|18
)paren
(brace
id|icmp_statistics.IcmpInErrors
op_increment
suffix:semicolon
multiline_comment|/* Is this right - or do we ignore ? */
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Parse the ICMP message &n;&t; */
macro_line|#ifdef CONFIG_IP_TRANSPARENT_PROXY
multiline_comment|/*&n;&t; *&t;We may get non-local addresses and still want to handle them&n;&t; *&t;locally, due to transparent proxying.&n;&t; *&t;Thus, narrow down the test to what is really meant.&n;&t; */
r_if
c_cond
(paren
id|daddr
op_ne
id|dev-&gt;pa_addr
op_logical_and
(paren
(paren
id|r
op_assign
id|ip_chk_addr
c_func
(paren
id|daddr
)paren
)paren
op_eq
id|IS_BROADCAST
op_logical_or
id|r
op_eq
id|IS_MULTICAST
)paren
)paren
macro_line|#else
r_if
c_cond
(paren
id|daddr
op_ne
id|dev-&gt;pa_addr
op_logical_and
id|ip_chk_addr
c_func
(paren
id|daddr
)paren
op_ne
id|IS_MYADDR
)paren
macro_line|#endif
(brace
multiline_comment|/*&n;&t;&t; *&t;RFC 1122: 3.2.2.6 An ICMP_ECHO to broadcast MAY be silently ignored (we don&squot;t as it is used&n;&t;&t; *&t;by some network mapping tools).&n;&t;&t; *&t;RFC 1122: 3.2.2.8 An ICMP_TIMESTAMP MAY be silently discarded if to broadcast/multicast.&n;&t;&t; */
r_if
c_cond
(paren
id|icmph-&gt;type
op_ne
id|ICMP_ECHO
)paren
(brace
id|icmp_statistics.IcmpInErrors
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;  &t;&t; *&t;Reply the multicast/broadcast using a legal&n;  &t;&t; *&t;interface - in this case the device we got&n;  &t;&t; *&t;it from.&n;  &t;&t; */
id|daddr
op_assign
id|dev-&gt;pa_addr
suffix:semicolon
)brace
id|len
op_sub_assign
r_sizeof
(paren
r_struct
id|icmphdr
)paren
suffix:semicolon
(paren
op_star
id|icmp_pointers
(braket
id|icmph-&gt;type
)braket
dot
id|input
)paren
op_increment
suffix:semicolon
(paren
id|icmp_pointers
(braket
id|icmph-&gt;type
)braket
dot
id|handler
)paren
(paren
id|icmph
comma
id|skb
comma
id|skb-&gt;dev
comma
id|saddr
comma
id|daddr
comma
id|len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This table defined limits of ICMP sending rate for various ICMP messages.&n; */
r_static
r_struct
id|icmp_xrlim
DECL|variable|xrl_unreach
id|xrl_unreach
op_assign
(brace
l_int|4
op_star
id|HZ
comma
l_int|80
comma
id|HZ
op_div
l_int|4
)brace
comma
multiline_comment|/* Host Unreachable */
DECL|variable|xrl_redirect
id|xrl_redirect
op_assign
(brace
l_int|2
op_star
id|HZ
comma
l_int|10
comma
id|HZ
op_div
l_int|2
)brace
comma
multiline_comment|/* Redirect */
DECL|variable|xrl_generic
id|xrl_generic
op_assign
(brace
l_int|3
op_star
id|HZ
comma
l_int|30
comma
id|HZ
op_div
l_int|4
)brace
suffix:semicolon
multiline_comment|/* All other errors */
multiline_comment|/*&n; *&t;This table is the definition of how we handle ICMP.&n; */
DECL|variable|icmp_pointers
r_static
r_struct
id|icmp_control
id|icmp_pointers
(braket
l_int|19
)braket
op_assign
(brace
multiline_comment|/* ECHO REPLY (0) */
(brace
op_amp
id|icmp_statistics.IcmpOutEchoReps
comma
op_amp
id|icmp_statistics.IcmpInEchoReps
comma
id|icmp_discard
comma
l_int|0
comma
l_int|NULL
)brace
comma
(brace
op_amp
id|dummy
comma
op_amp
id|icmp_statistics.IcmpInErrors
comma
id|icmp_discard
comma
l_int|1
comma
l_int|NULL
)brace
comma
(brace
op_amp
id|dummy
comma
op_amp
id|icmp_statistics.IcmpInErrors
comma
id|icmp_discard
comma
l_int|1
comma
l_int|NULL
)brace
comma
multiline_comment|/* DEST UNREACH (3) */
(brace
op_amp
id|icmp_statistics.IcmpOutDestUnreachs
comma
op_amp
id|icmp_statistics.IcmpInDestUnreachs
comma
id|icmp_unreach
comma
l_int|1
comma
op_amp
id|xrl_unreach
)brace
comma
multiline_comment|/* SOURCE QUENCH (4) */
(brace
op_amp
id|icmp_statistics.IcmpOutSrcQuenchs
comma
op_amp
id|icmp_statistics.IcmpInSrcQuenchs
comma
id|icmp_unreach
comma
l_int|1
comma
l_int|NULL
)brace
comma
multiline_comment|/* REDIRECT (5) */
(brace
op_amp
id|icmp_statistics.IcmpOutRedirects
comma
op_amp
id|icmp_statistics.IcmpInRedirects
comma
id|icmp_redirect
comma
l_int|1
comma
op_amp
id|xrl_redirect
)brace
comma
(brace
op_amp
id|dummy
comma
op_amp
id|icmp_statistics.IcmpInErrors
comma
id|icmp_discard
comma
l_int|1
comma
l_int|NULL
)brace
comma
(brace
op_amp
id|dummy
comma
op_amp
id|icmp_statistics.IcmpInErrors
comma
id|icmp_discard
comma
l_int|1
comma
l_int|NULL
)brace
comma
multiline_comment|/* ECHO (8) */
(brace
op_amp
id|icmp_statistics.IcmpOutEchos
comma
op_amp
id|icmp_statistics.IcmpInEchos
comma
id|icmp_echo
comma
l_int|0
comma
l_int|NULL
)brace
comma
(brace
op_amp
id|dummy
comma
op_amp
id|icmp_statistics.IcmpInErrors
comma
id|icmp_discard
comma
l_int|1
comma
l_int|NULL
)brace
comma
(brace
op_amp
id|dummy
comma
op_amp
id|icmp_statistics.IcmpInErrors
comma
id|icmp_discard
comma
l_int|1
comma
l_int|NULL
)brace
comma
multiline_comment|/* TIME EXCEEDED (11) */
(brace
op_amp
id|icmp_statistics.IcmpOutTimeExcds
comma
op_amp
id|icmp_statistics.IcmpInTimeExcds
comma
id|icmp_unreach
comma
l_int|1
comma
op_amp
id|xrl_generic
)brace
comma
multiline_comment|/* PARAMETER PROBLEM (12) */
multiline_comment|/* FIXME: RFC1122 3.2.2.5 - MUST pass PARAM_PROB messages to transport layer */
(brace
op_amp
id|icmp_statistics.IcmpOutParmProbs
comma
op_amp
id|icmp_statistics.IcmpInParmProbs
comma
id|icmp_discard
comma
l_int|1
comma
op_amp
id|xrl_generic
)brace
comma
multiline_comment|/* TIMESTAMP (13) */
(brace
op_amp
id|icmp_statistics.IcmpOutTimestamps
comma
op_amp
id|icmp_statistics.IcmpInTimestamps
comma
id|icmp_timestamp
comma
l_int|0
comma
l_int|NULL
)brace
comma
multiline_comment|/* TIMESTAMP REPLY (14) */
(brace
op_amp
id|icmp_statistics.IcmpOutTimestampReps
comma
op_amp
id|icmp_statistics.IcmpInTimestampReps
comma
id|icmp_discard
comma
l_int|0
comma
l_int|NULL
)brace
comma
multiline_comment|/* INFO (15) */
(brace
op_amp
id|dummy
comma
op_amp
id|dummy
comma
id|icmp_discard
comma
l_int|0
comma
l_int|NULL
)brace
comma
multiline_comment|/* INFO REPLY (16) */
(brace
op_amp
id|dummy
comma
op_amp
id|dummy
comma
id|icmp_discard
comma
l_int|0
comma
l_int|NULL
)brace
comma
multiline_comment|/* ADDR MASK (17) */
(brace
op_amp
id|icmp_statistics.IcmpOutAddrMasks
comma
op_amp
id|icmp_statistics.IcmpInAddrMasks
comma
id|icmp_address
comma
l_int|0
comma
l_int|NULL
)brace
comma
multiline_comment|/* ADDR MASK REPLY (18) */
(brace
op_amp
id|icmp_statistics.IcmpOutAddrMaskReps
comma
op_amp
id|icmp_statistics.IcmpInAddrMaskReps
comma
id|icmp_discard
comma
l_int|0
comma
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|function|icmp_init
r_void
id|icmp_init
c_func
(paren
r_struct
id|proto_ops
op_star
id|ops
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_int
id|err
suffix:semicolon
id|icmp_socket.type
op_assign
id|SOCK_RAW
suffix:semicolon
id|icmp_socket.ops
op_assign
id|ops
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ops
op_member_access_from_pointer
id|create
c_func
(paren
op_amp
id|icmp_socket
comma
id|IPPROTO_ICMP
)paren
)paren
OL
l_int|0
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Failed to create the ICMP control socket.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|sk
op_assign
id|icmp_socket.data
suffix:semicolon
id|sk-&gt;allocation
op_assign
id|GFP_ATOMIC
suffix:semicolon
id|sk-&gt;num
op_assign
l_int|256
suffix:semicolon
multiline_comment|/* Don&squot;t receive any data */
macro_line|#ifndef CONFIG_NO_ICMP_LIMIT
id|xrlim_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
