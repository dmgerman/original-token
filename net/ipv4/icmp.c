multiline_comment|/*&n; *&t;NET3:&t;Implementation of the ICMP protocol layer. &n; *&t;&n; *&t;&t;Alan Cox, &lt;alan@redhat.com&gt;&n; *&n; *&t;Version: $Id: icmp.c,v 1.71 2000/08/02 06:01:48 davem Exp $&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License&n; *&t;as published by the Free Software Foundation; either version&n; *&t;2 of the License, or (at your option) any later version.&n; *&n; *&t;Some of the function names and the icmp unreach table for this&n; *&t;module were derived from [icmp.c 1.0.11 06/02/93] by&n; *&t;Ross Biro, Fred N. van Kempen, Mark Evans, Alan Cox, Gerhard Koerting.&n; *&t;Other than that this module is a complete rewrite.&n; *&n; *&t;Fixes:&n; *&t;&t;Mike Shaver&t;:&t;RFC1122 checks.&n; *&t;&t;Alan Cox&t;:&t;Multicast ping reply as self.&n; *&t;&t;Alan Cox&t;:&t;Fix atomicity lockup in ip_build_xmit &n; *&t;&t;&t;&t;&t;call.&n; *&t;&t;Alan Cox&t;:&t;Added 216,128 byte paths to the MTU &n; *&t;&t;&t;&t;&t;code.&n; *&t;&t;Martin Mares&t;:&t;RFC1812 checks.&n; *&t;&t;Martin Mares&t;:&t;Can be configured to follow redirects &n; *&t;&t;&t;&t;&t;if acting as a router _without_ a&n; *&t;&t;&t;&t;&t;routing protocol (RFC 1812).&n; *&t;&t;Martin Mares&t;:&t;Echo requests may be configured to &n; *&t;&t;&t;&t;&t;be ignored (RFC 1812).&n; *&t;&t;Martin Mares&t;:&t;Limitation of ICMP error message &n; *&t;&t;&t;&t;&t;transmit rate (RFC 1812).&n; *&t;&t;Martin Mares&t;:&t;TOS and Precedence set correctly &n; *&t;&t;&t;&t;&t;(RFC 1812).&n; *&t;&t;Martin Mares&t;:&t;Now copying as much data from the &n; *&t;&t;&t;&t;&t;original packet as we can without&n; *&t;&t;&t;&t;&t;exceeding 576 bytes (RFC 1812).&n; *&t;Willy Konynenberg&t;:&t;Transparent proxying support.&n; *&t;&t;Keith Owens&t;:&t;RFC1191 correction for 4.2BSD based &n; *&t;&t;&t;&t;&t;path MTU bug.&n; *&t;&t;Thomas Quinot&t;:&t;ICMP Dest Unreach codes up to 15 are&n; *&t;&t;&t;&t;&t;valid (RFC 1812).&n; *&t;&t;Andi Kleen&t;:&t;Check all packet lengths properly&n; *&t;&t;&t;&t;&t;and moved all kfree_skb() up to&n; *&t;&t;&t;&t;&t;icmp_rcv.&n; *&t;&t;Andi Kleen&t;:&t;Move the rate limit bookkeeping&n; *&t;&t;&t;&t;&t;into the dest entry and use a token&n; *&t;&t;&t;&t;&t;bucket filter (thanks to ANK). Make&n; *&t;&t;&t;&t;&t;the rates sysctl configurable.&n; *&t;&t;Yu Tianli&t;:&t;Fixed two ugly bugs in icmp_send&n; *&t;&t;&t;&t;&t;- IP option length was accounted wrongly&n; *&t;&t;&t;&t;&t;- ICMP header length was not accounted at all.&n; *              Tristan Greaves :       Added sysctl option to ignore bogus broadcast&n; *                                      responses from broken routers.&n; *&n; * To Fix:&n; *&n; *&t;- Should use skb_pull() instead of all the manual checking.&n; *&t;  This would also greatly simply some upper layer error handlers. --AK&n; *&n; * RFC1122 (Host Requirements -- Comm. Layer) Status:&n; * (boy, are there a lot of rules for ICMP)&n; *  3.2.2 (Generic ICMP stuff)&n; *   MUST discard messages of unknown type. (OK)&n; *   MUST copy at least the first 8 bytes from the offending packet&n; *     when sending ICMP errors. (OBSOLETE -- see RFC1812)&n; *   MUST pass received ICMP errors up to protocol level. (OK)&n; *   SHOULD send ICMP errors with TOS == 0. (OBSOLETE -- see RFC1812)&n; *   MUST NOT send ICMP errors in reply to:&n; *     ICMP errors (OK)&n; *     Broadcast/multicast datagrams (OK)&n; *     MAC broadcasts (OK)&n; *     Non-initial fragments (OK)&n; *     Datagram with a source address that isn&squot;t a single host. (OK)&n; *  3.2.2.1 (Destination Unreachable)&n; *   All the rules govern the IP layer, and are dealt with in ip.c, not here.&n; *  3.2.2.2 (Redirect)&n; *   Host SHOULD NOT send ICMP_REDIRECTs.  (OK)&n; *   MUST update routing table in response to host or network redirects.&n; *     (host OK, network OBSOLETE)&n; *   SHOULD drop redirects if they&squot;re not from directly connected gateway&n; *     (OK -- we drop it if it&squot;s not from our old gateway, which is close&n; *      enough)&n; * 3.2.2.3 (Source Quench)&n; *   MUST pass incoming SOURCE_QUENCHs to transport layer (OK)&n; *   Other requirements are dealt with at the transport layer.&n; * 3.2.2.4 (Time Exceeded)&n; *   MUST pass TIME_EXCEEDED to transport layer (OK)&n; *   Other requirements dealt with at IP (generating TIME_EXCEEDED).&n; * 3.2.2.5 (Parameter Problem)&n; *   SHOULD generate these (OK)&n; *   MUST pass received PARAMPROBLEM to transport layer (NOT YET)&n; *   &t;[Solaris 2.X seems to assert EPROTO when this occurs] -- AC&n; * 3.2.2.6 (Echo Request/Reply)&n; *   MUST reply to ECHO_REQUEST, and give app to do ECHO stuff (OK, OK)&n; *   MAY discard broadcast ECHO_REQUESTs. (Configurable with a sysctl.)&n; *   MUST reply using same source address as the request was sent to.&n; *     We&squot;re OK for unicast ECHOs, and it doesn&squot;t say anything about&n; *     how to handle broadcast ones, since it&squot;s optional.&n; *   MUST copy data from REQUEST to REPLY (OK)&n; *     unless it would require illegal fragmentation (OK)&n; *   MUST pass REPLYs to transport/user layer (OK)&n; *   MUST use any provided source route (reversed) for REPLY. (NOT YET)&n; * 3.2.2.7 (Information Request/Reply)&n; *   MUST NOT implement this. (I guess that means silently discard...?) (OK)&n; * 3.2.2.8 (Timestamp Request/Reply)&n; *   MAY implement (OK)&n; *   SHOULD be in-kernel for &quot;minimum variability&quot; (OK)&n; *   MAY discard broadcast REQUESTs.  (OK, but see source for inconsistency)&n; *   MUST reply using same source address as the request was sent to. (OK)&n; *   MUST reverse source route, as per ECHO (NOT YET)&n; *   MUST pass REPLYs to transport/user layer (requires RAW, just like &n; *&t;ECHO) (OK)&n; *   MUST update clock for timestamp at least 15 times/sec (OK)&n; *   MUST be &quot;correct within a few minutes&quot; (OK)&n; * 3.2.2.9 (Address Mask Request/Reply)&n; *   MAY implement (OK)&n; *   MUST send a broadcast REQUEST if using this system to set netmask&n; *     (OK... we don&squot;t use it)&n; *   MUST discard received REPLYs if not using this system (OK)&n; *   MUST NOT send replies unless specifically made agent for this sort&n; *     of thing. (OK)&n; *&n; *&n; * RFC 1812 (IPv4 Router Requirements) Status (even longer):&n; *  4.3.2.1 (Unknown Message Types)&n; *   MUST pass messages of unknown type to ICMP user iface or silently discard&n; *     them (OK)&n; *  4.3.2.2 (ICMP Message TTL)&n; *   MUST initialize TTL when originating an ICMP message (OK)&n; *  4.3.2.3 (Original Message Header)&n; *   SHOULD copy as much data from the offending packet as possible without&n; *     the length of the ICMP datagram exceeding 576 bytes (OK)&n; *   MUST leave original IP header of the offending packet, but we&squot;re not&n; *     required to undo modifications made (OK)&n; *  4.3.2.4 (Original Message Source Address)&n; *   MUST use one of addresses for the interface the orig. packet arrived as&n; *     source address (OK)&n; *  4.3.2.5 (TOS and Precedence)&n; *   SHOULD leave TOS set to the same value unless the packet would be &n; *     discarded for that reason (OK)&n; *   MUST use TOS=0 if not possible to leave original value (OK)&n; *   MUST leave IP Precedence for Source Quench messages (OK -- not sent &n; *&t;at all)&n; *   SHOULD use IP Precedence = 6 (Internetwork Control) or 7 (Network Control)&n; *     for all other error messages (OK, we use 6)&n; *   MAY allow configuration of IP Precedence (OK -- not done)&n; *   MUST leave IP Precedence and TOS for reply messages (OK)&n; *  4.3.2.6 (Source Route)&n; *   SHOULD use reverse source route UNLESS sending Parameter Problem on source&n; *     routing and UNLESS the packet would be immediately discarded (NOT YET)&n; *  4.3.2.7 (When Not to Send ICMP Errors)&n; *   MUST NOT send ICMP errors in reply to:&n; *     ICMP errors (OK)&n; *     Packets failing IP header validation tests unless otherwise noted (OK)&n; *     Broadcast/multicast datagrams (OK)&n; *     MAC broadcasts (OK)&n; *     Non-initial fragments (OK)&n; *     Datagram with a source address that isn&squot;t a single host. (OK)&n; *  4.3.2.8 (Rate Limiting)&n; *   SHOULD be able to limit error message rate (OK)&n; *   SHOULD allow setting of rate limits (OK, in the source)&n; *  4.3.3.1 (Destination Unreachable)&n; *   All the rules govern the IP layer, and are dealt with in ip.c, not here.&n; *  4.3.3.2 (Redirect)&n; *   MAY ignore ICMP Redirects if running a routing protocol or if forwarding&n; *     is enabled on the interface (OK -- ignores)&n; *  4.3.3.3 (Source Quench)&n; *   SHOULD NOT originate SQ messages (OK)&n; *   MUST be able to limit SQ rate if originates them (OK as we don&squot;t &n; *&t;send them)&n; *   MAY ignore SQ messages it receives (OK -- we don&squot;t)&n; *  4.3.3.4 (Time Exceeded)&n; *   Requirements dealt with at IP (generating TIME_EXCEEDED).&n; *  4.3.3.5 (Parameter Problem)&n; *   MUST generate these for all errors not covered by other messages (OK)&n; *   MUST include original value of the value pointed by (OK)&n; *  4.3.3.6 (Echo Request)&n; *   MUST implement echo server function (OK)&n; *   MUST process at ER of at least max(576, MTU) (OK)&n; *   MAY reject broadcast/multicast ER&squot;s (We don&squot;t, but that&squot;s OK)&n; *   SHOULD have a config option for silently ignoring ER&squot;s (OK)&n; *   MUST have a default value for the above switch = NO (OK)&n; *   MUST have application layer interface for Echo Request/Reply (OK)&n; *   MUST reply using same source address as the request was sent to.&n; *     We&squot;re OK for unicast ECHOs, and it doesn&squot;t say anything about&n; *     how to handle broadcast ones, since it&squot;s optional.&n; *   MUST copy data from Request to Reply (OK)&n; *   SHOULD update Record Route / Timestamp options (??)&n; *   MUST use reversed Source Route for Reply if possible (NOT YET)&n; *  4.3.3.7 (Information Request/Reply)&n; *   SHOULD NOT originate or respond to these (OK)&n; *  4.3.3.8 (Timestamp / Timestamp Reply)&n; *   MAY implement (OK)&n; *   MUST reply to every Timestamp message received (OK)&n; *   MAY discard broadcast REQUESTs.  (OK, but see source for inconsistency)&n; *   MUST reply using same source address as the request was sent to. (OK)&n; *   MUST use reversed Source Route if possible (NOT YET)&n; *   SHOULD update Record Route / Timestamp options (??)&n; *   MUST pass REPLYs to transport/user layer (requires RAW, just like &n; *&t;ECHO) (OK)&n; *   MUST update clock for timestamp at least 16 times/sec (OK)&n; *   MUST be &quot;correct within a few minutes&quot; (OK)&n; * 4.3.3.9 (Address Mask Request/Reply)&n; *   MUST have support for receiving AMRq and responding with AMRe (OK, &n; *&t;but only as a compile-time option)&n; *   SHOULD have option for each interface for AMRe&squot;s, MUST default to &n; *&t;NO (NOT YET)&n; *   MUST NOT reply to AMRq before knows the correct AM (OK)&n; *   MUST NOT respond to AMRq with source address 0.0.0.0 on physical&n; *    &t;interfaces having multiple logical i-faces with different masks&n; *&t;(NOT YET)&n; *   SHOULD examine all AMRe&squot;s it receives and check them (NOT YET)&n; *   SHOULD log invalid AMRe&squot;s (AM+sender) (NOT YET)&n; *   MUST NOT use contents of AMRe to determine correct AM (OK)&n; *   MAY broadcast AMRe&squot;s after having configured address masks (OK -- doesn&squot;t)&n; *   MUST NOT do broadcast AMRe&squot;s if not set by extra option (OK, no option)&n; *   MUST use the { &lt;NetPrefix&gt;, -1 } form of broadcast addresses (OK)&n; * 4.3.3.10 (Router Advertisement and Solicitations)&n; *   MUST support router part of Router Discovery Protocol on all networks we&n; *     support broadcast or multicast addressing. (OK -- done by gated)&n; *   MUST have all config parameters with the respective defaults (OK)&n; * 5.2.7.1 (Destination Unreachable)&n; *   MUST generate DU&squot;s (OK)&n; *   SHOULD choose a best-match response code (OK)&n; *   SHOULD NOT generate Host Isolated codes (OK)&n; *   SHOULD use Communication Administratively Prohibited when administratively&n; *     filtering packets (NOT YET -- bug-to-bug compatibility)&n; *   MAY include config option for not generating the above and silently&n; *&t;discard the packets instead (OK)&n; *   MAY include config option for not generating Precedence Violation and&n; *     Precedence Cutoff messages (OK as we don&squot;t generate them at all)&n; *   MUST use Host Unreachable or Dest. Host Unknown codes whenever other hosts&n; *     on the same network might be reachable (OK -- no net unreach&squot;s at all)&n; *   MUST use new form of Fragmentation Needed and DF Set messages (OK)&n; * 5.2.7.2 (Redirect)&n; *   MUST NOT generate network redirects (OK)&n; *   MUST be able to generate host redirects (OK)&n; *   SHOULD be able to generate Host+TOS redirects (NO as we don&squot;t use TOS)&n; *   MUST have an option to use Host redirects instead of Host+TOS ones (OK as&n; *     no Host+TOS Redirects are used)&n; *   MUST NOT generate redirects unless forwarding to the same i-face and the&n; *     dest. address is on the same subnet as the src. address and no source&n; *     routing is in use. (OK)&n; *   MUST NOT follow redirects when using a routing protocol (OK)&n; *   MAY use redirects if not using a routing protocol (OK, compile-time option)&n; *   MUST comply to Host Requirements when not acting as a router (OK)&n; *  5.2.7.3 (Time Exceeded)&n; *   MUST generate Time Exceeded Code 0 when discarding packet due to TTL=0 (OK)&n; *   MAY have a per-interface option to disable origination of TE messages, but&n; *     it MUST default to &quot;originate&quot; (OK -- we don&squot;t support it)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4.h&gt;
macro_line|#include &lt;net/snmp.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;net/raw.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
DECL|macro|min
mdefine_line|#define min(a,b)&t;((a)&lt;(b)?(a):(b))
multiline_comment|/*&n; *&t;Statistics&n; */
DECL|variable|icmp_statistics
r_struct
id|icmp_mib
id|icmp_statistics
(braket
id|NR_CPUS
op_star
l_int|2
)braket
suffix:semicolon
multiline_comment|/* An array of errno for error messages from dest unreach. */
multiline_comment|/* RFC 1122: 3.2.2.1 States that NET_UNREACH, HOS_UNREACH and SR_FAIELD MUST be considered &squot;transient errs&squot;. */
DECL|variable|icmp_err_convert
r_struct
id|icmp_err
id|icmp_err_convert
(braket
)braket
op_assign
(brace
(brace
id|ENETUNREACH
comma
l_int|0
)brace
comma
multiline_comment|/*&t;ICMP_NET_UNREACH&t;*/
(brace
id|EHOSTUNREACH
comma
l_int|0
)brace
comma
multiline_comment|/*&t;ICMP_HOST_UNREACH&t;*/
(brace
id|ENOPROTOOPT
comma
l_int|1
)brace
comma
multiline_comment|/*&t;ICMP_PROT_UNREACH&t;*/
(brace
id|ECONNREFUSED
comma
l_int|1
)brace
comma
multiline_comment|/*&t;ICMP_PORT_UNREACH&t;*/
(brace
id|EMSGSIZE
comma
l_int|0
)brace
comma
multiline_comment|/*&t;ICMP_FRAG_NEEDED&t;*/
(brace
id|EOPNOTSUPP
comma
l_int|0
)brace
comma
multiline_comment|/*&t;ICMP_SR_FAILED&t;&t;*/
(brace
id|ENETUNREACH
comma
l_int|1
)brace
comma
multiline_comment|/* &t;ICMP_NET_UNKNOWN&t;*/
(brace
id|EHOSTDOWN
comma
l_int|1
)brace
comma
multiline_comment|/*&t;ICMP_HOST_UNKNOWN&t;*/
(brace
id|ENONET
comma
l_int|1
)brace
comma
multiline_comment|/*&t;ICMP_HOST_ISOLATED&t;*/
(brace
id|ENETUNREACH
comma
l_int|1
)brace
comma
multiline_comment|/*&t;ICMP_NET_ANO&t;&t;*/
(brace
id|EHOSTUNREACH
comma
l_int|1
)brace
comma
multiline_comment|/*&t;ICMP_HOST_ANO&t;&t;*/
(brace
id|ENETUNREACH
comma
l_int|0
)brace
comma
multiline_comment|/*&t;ICMP_NET_UNR_TOS&t;*/
(brace
id|EHOSTUNREACH
comma
l_int|0
)brace
comma
multiline_comment|/*&t;ICMP_HOST_UNR_TOS&t;*/
(brace
id|EHOSTUNREACH
comma
l_int|1
)brace
comma
multiline_comment|/*&t;ICMP_PKT_FILTERED&t;*/
(brace
id|EHOSTUNREACH
comma
l_int|1
)brace
comma
multiline_comment|/*&t;ICMP_PREC_VIOLATION&t;*/
(brace
id|EHOSTUNREACH
comma
l_int|1
)brace
multiline_comment|/*&t;ICMP_PREC_CUTOFF&t;*/
)brace
suffix:semicolon
multiline_comment|/* Control parameters for ECHO relies. */
DECL|variable|sysctl_icmp_echo_ignore_all
r_int
id|sysctl_icmp_echo_ignore_all
op_assign
l_int|0
suffix:semicolon
DECL|variable|sysctl_icmp_echo_ignore_broadcasts
r_int
id|sysctl_icmp_echo_ignore_broadcasts
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Control parameter - ignore bogus broadcast responses? */
DECL|variable|sysctl_icmp_ignore_bogus_error_responses
r_int
id|sysctl_icmp_ignore_bogus_error_responses
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; *&t;ICMP control array. This specifies what to do with each ICMP.&n; */
DECL|struct|icmp_control
r_struct
id|icmp_control
(brace
DECL|member|output
r_int
r_int
op_star
id|output
suffix:semicolon
multiline_comment|/* Address to increment on output */
DECL|member|input
r_int
r_int
op_star
id|input
suffix:semicolon
multiline_comment|/* Address to increment on input */
DECL|member|handler
r_void
(paren
op_star
id|handler
)paren
(paren
r_struct
id|icmphdr
op_star
id|icmph
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|len
)paren
suffix:semicolon
DECL|member|error
r_int
id|error
suffix:semicolon
multiline_comment|/* This ICMP is classed as an error message */
DECL|member|timeout
r_int
op_star
id|timeout
suffix:semicolon
multiline_comment|/* Rate limit */
)brace
suffix:semicolon
DECL|variable|icmp_pointers
r_static
r_struct
id|icmp_control
id|icmp_pointers
(braket
id|NR_ICMP_TYPES
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/*&n; *&t;The ICMP socket. This is the most convenient way to flow control&n; *&t;our ICMP output as well as maintain a clean interface throughout&n; *&t;all layers. All Socketless IP sends will soon be gone.&n; */
DECL|variable|icmp_inode
r_struct
id|inode
id|icmp_inode
suffix:semicolon
DECL|variable|icmp_socket
r_struct
id|socket
op_star
id|icmp_socket
op_assign
op_amp
id|icmp_inode.u.socket_i
suffix:semicolon
multiline_comment|/* ICMPv4 socket is only a bit non-reenterable (unlike ICMPv6,&n;   which is strongly non-reenterable). A bit later it will be made&n;   reenterable and the lock may be removed then.&n; */
DECL|variable|icmp_xmit_holder
r_static
r_int
id|icmp_xmit_holder
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|function|icmp_xmit_lock_bh
r_static
r_int
id|icmp_xmit_lock_bh
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|icmp_socket-&gt;sk-&gt;lock.slock
)paren
)paren
(brace
r_if
c_cond
(paren
id|icmp_xmit_holder
op_eq
id|smp_processor_id
c_func
(paren
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|icmp_socket-&gt;sk-&gt;lock.slock
)paren
suffix:semicolon
)brace
id|icmp_xmit_holder
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|icmp_xmit_lock
r_static
id|__inline__
r_int
id|icmp_xmit_lock
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|icmp_xmit_lock_bh
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|icmp_xmit_unlock_bh
r_static
r_void
id|icmp_xmit_unlock_bh
c_func
(paren
r_void
)paren
(brace
id|icmp_xmit_holder
op_assign
op_minus
l_int|1
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|icmp_socket-&gt;sk-&gt;lock.slock
)paren
suffix:semicolon
)brace
DECL|function|icmp_xmit_unlock
r_static
id|__inline__
r_void
id|icmp_xmit_unlock
c_func
(paren
r_void
)paren
(brace
id|icmp_xmit_unlock_bh
c_func
(paren
)paren
suffix:semicolon
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send an ICMP frame.&n; */
multiline_comment|/*&n; *&t;Check transmit rate limitation for given message.&n; *&t;The rate information is held in the destination cache now.&n; *&t;This function is generic and could be used for other purposes&n; *&t;too. It uses a Token bucket filter as suggested by Alexey Kuznetsov.&n; *&n; *&t;Note that the same dst_entry fields are modified by functions in &n; *&t;route.c too, but these work for packet destinations while xrlim_allow&n; *&t;works for icmp destinations. This means the rate limiting information&n; *&t;for one &quot;ip object&quot; is shared.&n; *&n; *&t;Note that the same dst_entry fields are modified by functions in &n; *&t;route.c too, but these work for packet destinations while xrlim_allow&n; *&t;works for icmp destinations. This means the rate limiting information&n; *&t;for one &quot;ip object&quot; is shared - and these ICMPs are twice limited:&n; *&t;by source and by destination.&n; *&n; *&t;RFC 1812: 4.3.2.8 SHOULD be able to limit error message rate&n; *&t;&t;&t;  SHOULD allow setting of rate limits &n; *&n; * &t;Shared between ICMPv4 and ICMPv6.&n; */
DECL|macro|XRLIM_BURST_FACTOR
mdefine_line|#define XRLIM_BURST_FACTOR 6
DECL|function|xrlim_allow
r_int
id|xrlim_allow
c_func
(paren
r_struct
id|dst_entry
op_star
id|dst
comma
r_int
id|timeout
)paren
(brace
r_int
r_int
id|now
suffix:semicolon
id|now
op_assign
id|jiffies
suffix:semicolon
id|dst-&gt;rate_tokens
op_add_assign
id|now
op_minus
id|dst-&gt;rate_last
suffix:semicolon
id|dst-&gt;rate_last
op_assign
id|now
suffix:semicolon
r_if
c_cond
(paren
id|dst-&gt;rate_tokens
OG
id|XRLIM_BURST_FACTOR
op_star
id|timeout
)paren
id|dst-&gt;rate_tokens
op_assign
id|XRLIM_BURST_FACTOR
op_star
id|timeout
suffix:semicolon
r_if
c_cond
(paren
id|dst-&gt;rate_tokens
op_ge
id|timeout
)paren
(brace
id|dst-&gt;rate_tokens
op_sub_assign
id|timeout
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|icmpv4_xrlim_allow
r_static
r_inline
r_int
id|icmpv4_xrlim_allow
c_func
(paren
r_struct
id|rtable
op_star
id|rt
comma
r_int
id|type
comma
r_int
id|code
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
op_assign
op_amp
id|rt-&gt;u.dst
suffix:semicolon
r_if
c_cond
(paren
id|type
OG
id|NR_ICMP_TYPES
op_logical_or
op_logical_neg
id|icmp_pointers
(braket
id|type
)braket
dot
id|timeout
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Don&squot;t limit PMTU discovery. */
r_if
c_cond
(paren
id|type
op_eq
id|ICMP_DEST_UNREACH
op_logical_and
id|code
op_eq
id|ICMP_FRAG_NEEDED
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Redirect has its own rate limit mechanism */
r_if
c_cond
(paren
id|type
op_eq
id|ICMP_REDIRECT
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* No rate limit on loopback */
r_if
c_cond
(paren
id|dst-&gt;dev
op_logical_and
(paren
id|dst-&gt;dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|xrlim_allow
c_func
(paren
id|dst
comma
op_star
(paren
id|icmp_pointers
(braket
id|type
)braket
dot
id|timeout
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Maintain the counters used in the SNMP statistics for outgoing ICMP&n; */
DECL|function|icmp_out_count
r_static
r_void
id|icmp_out_count
c_func
(paren
r_int
id|type
)paren
(brace
r_if
c_cond
(paren
id|type
OG
id|NR_ICMP_TYPES
)paren
r_return
suffix:semicolon
(paren
id|icmp_pointers
(braket
id|type
)braket
dot
id|output
)paren
(braket
(paren
id|smp_processor_id
c_func
(paren
)paren
op_star
l_int|2
op_plus
op_logical_neg
id|in_softirq
c_func
(paren
)paren
)paren
op_star
r_sizeof
(paren
r_struct
id|icmp_mib
)paren
op_div
r_sizeof
(paren
r_int
r_int
)paren
)braket
op_increment
suffix:semicolon
id|ICMP_INC_STATS
c_func
(paren
id|IcmpOutMsgs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Checksum each fragment, and on the first include the headers and final checksum.&n; */
DECL|function|icmp_glue_bits
r_static
r_int
id|icmp_glue_bits
c_func
(paren
r_const
r_void
op_star
id|p
comma
r_char
op_star
id|to
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|fraglen
)paren
(brace
r_struct
id|icmp_bxm
op_star
id|icmp_param
op_assign
(paren
r_struct
id|icmp_bxm
op_star
)paren
id|p
suffix:semicolon
r_struct
id|icmphdr
op_star
id|icmph
suffix:semicolon
r_int
r_int
id|csum
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
(brace
id|icmp_param-&gt;csum
op_assign
id|csum_partial_copy_nocheck
c_func
(paren
id|icmp_param-&gt;data_ptr
op_plus
id|offset
op_minus
r_sizeof
(paren
r_struct
id|icmphdr
)paren
comma
id|to
comma
id|fraglen
comma
id|icmp_param-&gt;csum
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;First fragment includes header. Note that we&squot;ve done&n;&t; *&t;the other fragments first, so that we get the checksum&n;&t; *&t;for the whole packet here.&n;&t; */
id|csum
op_assign
id|csum_partial_copy_nocheck
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|icmp_param-&gt;icmph
comma
id|to
comma
r_sizeof
(paren
r_struct
id|icmphdr
)paren
comma
id|icmp_param-&gt;csum
)paren
suffix:semicolon
id|csum
op_assign
id|csum_partial_copy_nocheck
c_func
(paren
id|icmp_param-&gt;data_ptr
comma
id|to
op_plus
r_sizeof
(paren
r_struct
id|icmphdr
)paren
comma
id|fraglen
op_minus
r_sizeof
(paren
r_struct
id|icmphdr
)paren
comma
id|csum
)paren
suffix:semicolon
id|icmph
op_assign
(paren
r_struct
id|icmphdr
op_star
)paren
id|to
suffix:semicolon
id|icmph-&gt;checksum
op_assign
id|csum_fold
c_func
(paren
id|csum
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Driving logic for building and sending ICMP messages.&n; */
DECL|function|icmp_reply
r_void
id|icmp_reply
c_func
(paren
r_struct
id|icmp_bxm
op_star
id|icmp_param
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|icmp_socket-&gt;sk
suffix:semicolon
r_struct
id|ipcm_cookie
id|ipc
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
id|u32
id|daddr
suffix:semicolon
r_if
c_cond
(paren
id|ip_options_echo
c_func
(paren
op_amp
id|icmp_param-&gt;replyopts
comma
id|skb
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|icmp_xmit_lock_bh
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
id|icmp_param-&gt;icmph.checksum
op_assign
l_int|0
suffix:semicolon
id|icmp_param-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|icmp_out_count
c_func
(paren
id|icmp_param-&gt;icmph.type
)paren
suffix:semicolon
id|sk-&gt;protinfo.af_inet.tos
op_assign
id|skb-&gt;nh.iph-&gt;tos
suffix:semicolon
id|daddr
op_assign
id|ipc.addr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|ipc.opt
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|icmp_param-&gt;replyopts.optlen
)paren
(brace
id|ipc.opt
op_assign
op_amp
id|icmp_param-&gt;replyopts
suffix:semicolon
r_if
c_cond
(paren
id|ipc.opt-&gt;srr
)paren
id|daddr
op_assign
id|icmp_param-&gt;replyopts.faddr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip_route_output
c_func
(paren
op_amp
id|rt
comma
id|daddr
comma
id|rt-&gt;rt_spec_dst
comma
id|RT_TOS
c_func
(paren
id|skb-&gt;nh.iph-&gt;tos
)paren
comma
l_int|0
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|icmpv4_xrlim_allow
c_func
(paren
id|rt
comma
id|icmp_param-&gt;icmph.type
comma
id|icmp_param-&gt;icmph.code
)paren
)paren
(brace
id|ip_build_xmit
c_func
(paren
id|sk
comma
id|icmp_glue_bits
comma
id|icmp_param
comma
id|icmp_param-&gt;data_len
op_plus
r_sizeof
(paren
r_struct
id|icmphdr
)paren
comma
op_amp
id|ipc
comma
id|rt
comma
id|MSG_DONTWAIT
)paren
suffix:semicolon
)brace
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
id|out
suffix:colon
id|icmp_xmit_unlock_bh
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send an ICMP message in response to a situation&n; *&n; *&t;RFC 1122: 3.2.2&t;MUST send at least the IP header and 8 bytes of header. MAY send more (we do).&n; *&t;&t;&t;MUST NOT change this header information.&n; *&t;&t;&t;MUST NOT reply to a multicast/broadcast IP address.&n; *&t;&t;&t;MUST NOT reply to a multicast/broadcast MAC address.&n; *&t;&t;&t;MUST reply to only the first fragment.&n; */
DECL|function|icmp_send
r_void
id|icmp_send
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb_in
comma
r_int
id|type
comma
r_int
id|code
comma
r_int
r_int
id|info
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_struct
id|icmphdr
op_star
id|icmph
suffix:semicolon
r_int
id|room
suffix:semicolon
r_struct
id|icmp_bxm
id|icmp_param
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb_in-&gt;dst
suffix:semicolon
r_struct
id|ipcm_cookie
id|ipc
suffix:semicolon
id|u32
id|saddr
suffix:semicolon
id|u8
id|tos
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rt
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Find the original header&n;&t; */
id|iph
op_assign
id|skb_in-&gt;nh.iph
suffix:semicolon
multiline_comment|/*&n;&t; *&t;No replies to physical multicast/broadcast&n;&t; */
r_if
c_cond
(paren
id|skb_in-&gt;pkt_type
op_ne
id|PACKET_HOST
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now check at the protocol level&n;&t; */
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
(paren
id|RTCF_BROADCAST
op_or
id|RTCF_MULTICAST
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Only reply to fragment 0. We byte re-order the constant&n;&t; *&t;mask for efficiency.&n;&t; */
r_if
c_cond
(paren
id|iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_OFFSET
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* &n;&t; *&t;If we send an ICMP error to an ICMP error a mess would result..&n;&t; */
r_if
c_cond
(paren
id|icmp_pointers
(braket
id|type
)braket
dot
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;We are an error, check if we are replying to an ICMP error&n;&t;&t; */
r_if
c_cond
(paren
id|iph-&gt;protocol
op_eq
id|IPPROTO_ICMP
)paren
(brace
id|icmph
op_assign
(paren
r_struct
id|icmphdr
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|iph
op_plus
(paren
id|iph-&gt;ihl
op_lshift
l_int|2
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Assume any unknown ICMP type is an error. This isn&squot;t&n;&t;&t;&t; *&t;specified by the RFC, but think about it..&n;&t;&t;&t; */
r_if
c_cond
(paren
id|icmph-&gt;type
OG
id|NR_ICMP_TYPES
op_logical_or
id|icmp_pointers
(braket
id|icmph-&gt;type
)braket
dot
id|error
)paren
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|icmp_xmit_lock
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Construct source address and options.&n;&t; */
macro_line|#ifdef CONFIG_IP_ROUTE_NAT&t;
multiline_comment|/*&n;&t; *&t;Restore original addresses if packet has been translated.&n;&t; */
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_NAT
op_logical_and
id|IPCB
c_func
(paren
id|skb_in
)paren
op_member_access_from_pointer
id|flags
op_amp
id|IPSKB_TRANSLATED
)paren
(brace
id|iph-&gt;daddr
op_assign
id|rt-&gt;key.dst
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|rt-&gt;key.src
suffix:semicolon
)brace
macro_line|#endif
id|saddr
op_assign
id|iph-&gt;daddr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_LOCAL
)paren
)paren
id|saddr
op_assign
l_int|0
suffix:semicolon
id|tos
op_assign
id|icmp_pointers
(braket
id|type
)braket
dot
id|error
ques
c_cond
(paren
(paren
id|iph-&gt;tos
op_amp
id|IPTOS_TOS_MASK
)paren
op_or
id|IPTOS_PREC_INTERNETCONTROL
)paren
suffix:colon
id|iph-&gt;tos
suffix:semicolon
multiline_comment|/* XXX: use a more aggressive expire for routes created by &n;&t; * this call (not longer than the rate limit timeout). &n;&t; * It could be also worthwhile to not put them into ipv4&n;&t; * fast routing cache at first. Otherwise an attacker can&n;&t; * grow the routing table.&n;&t; */
r_if
c_cond
(paren
id|ip_route_output
c_func
(paren
op_amp
id|rt
comma
id|iph-&gt;saddr
comma
id|saddr
comma
id|RT_TOS
c_func
(paren
id|tos
)paren
comma
l_int|0
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|ip_options_echo
c_func
(paren
op_amp
id|icmp_param.replyopts
comma
id|skb_in
)paren
)paren
r_goto
id|ende
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Prepare data for ICMP header.&n;&t; */
id|icmp_param.icmph.type
op_assign
id|type
suffix:semicolon
id|icmp_param.icmph.code
op_assign
id|code
suffix:semicolon
id|icmp_param.icmph.un.gateway
op_assign
id|info
suffix:semicolon
id|icmp_param.icmph.checksum
op_assign
l_int|0
suffix:semicolon
id|icmp_param.csum
op_assign
l_int|0
suffix:semicolon
id|icmp_param.data_ptr
op_assign
id|iph
suffix:semicolon
id|icmp_out_count
c_func
(paren
id|icmp_param.icmph.type
)paren
suffix:semicolon
id|icmp_socket-&gt;sk-&gt;protinfo.af_inet.tos
op_assign
id|tos
suffix:semicolon
id|ipc.addr
op_assign
id|iph-&gt;saddr
suffix:semicolon
id|ipc.opt
op_assign
op_amp
id|icmp_param.replyopts
suffix:semicolon
r_if
c_cond
(paren
id|icmp_param.replyopts.srr
)paren
(brace
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip_route_output
c_func
(paren
op_amp
id|rt
comma
id|icmp_param.replyopts.faddr
comma
id|saddr
comma
id|RT_TOS
c_func
(paren
id|tos
)paren
comma
l_int|0
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|icmpv4_xrlim_allow
c_func
(paren
id|rt
comma
id|type
comma
id|code
)paren
)paren
r_goto
id|ende
suffix:semicolon
multiline_comment|/* RFC says return as much as we can without exceeding 576 bytes. */
id|room
op_assign
id|rt-&gt;u.dst.pmtu
suffix:semicolon
r_if
c_cond
(paren
id|room
OG
l_int|576
)paren
id|room
op_assign
l_int|576
suffix:semicolon
id|room
op_sub_assign
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
id|icmp_param.replyopts.optlen
suffix:semicolon
id|room
op_sub_assign
r_sizeof
(paren
r_struct
id|icmphdr
)paren
suffix:semicolon
id|icmp_param.data_len
op_assign
(paren
id|skb_in-&gt;tail
op_minus
(paren
id|u8
op_star
)paren
id|iph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|icmp_param.data_len
OG
id|room
)paren
id|icmp_param.data_len
op_assign
id|room
suffix:semicolon
id|ip_build_xmit
c_func
(paren
id|icmp_socket-&gt;sk
comma
id|icmp_glue_bits
comma
op_amp
id|icmp_param
comma
id|icmp_param.data_len
op_plus
r_sizeof
(paren
r_struct
id|icmphdr
)paren
comma
op_amp
id|ipc
comma
id|rt
comma
id|MSG_DONTWAIT
)paren
suffix:semicolon
id|ende
suffix:colon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
id|out
suffix:colon
id|icmp_xmit_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Handle ICMP_DEST_UNREACH, ICMP_TIME_EXCEED, and ICMP_QUENCH. &n; */
DECL|function|icmp_unreach
r_static
r_void
id|icmp_unreach
c_func
(paren
r_struct
id|icmphdr
op_star
id|icmph
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|len
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_int
id|hash
suffix:semicolon
r_struct
id|inet_protocol
op_star
id|ipprot
suffix:semicolon
r_int
r_char
op_star
id|dp
suffix:semicolon
r_struct
id|sock
op_star
id|raw_sk
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Incomplete header ?&n;&t; * &t;Only checks for the IP header, there should be an&n;&t; *&t;additional check for longer headers in upper levels.&n;&t; */
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
r_struct
id|iphdr
)paren
)paren
(brace
id|ICMP_INC_STATS_BH
c_func
(paren
id|IcmpInErrors
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
(paren
id|icmph
op_plus
l_int|1
)paren
suffix:semicolon
id|dp
op_assign
(paren
r_int
r_char
op_star
)paren
id|iph
suffix:semicolon
r_if
c_cond
(paren
id|icmph-&gt;type
op_eq
id|ICMP_DEST_UNREACH
)paren
(brace
r_switch
c_cond
(paren
id|icmph-&gt;code
op_amp
l_int|15
)paren
(brace
r_case
id|ICMP_NET_UNREACH
suffix:colon
r_break
suffix:semicolon
r_case
id|ICMP_HOST_UNREACH
suffix:colon
r_break
suffix:semicolon
r_case
id|ICMP_PROT_UNREACH
suffix:colon
r_break
suffix:semicolon
r_case
id|ICMP_PORT_UNREACH
suffix:colon
r_break
suffix:semicolon
r_case
id|ICMP_FRAG_NEEDED
suffix:colon
r_if
c_cond
(paren
id|ipv4_config.no_pmtu_disc
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ICMP: %u.%u.%u.%u: fragmentation needed and DF set.&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;daddr
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|new_mtu
suffix:semicolon
id|new_mtu
op_assign
id|ip_rt_frag_needed
c_func
(paren
id|iph
comma
id|ntohs
c_func
(paren
id|icmph-&gt;un.frag.mtu
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_mtu
)paren
r_return
suffix:semicolon
id|icmph-&gt;un.frag.mtu
op_assign
id|htons
c_func
(paren
id|new_mtu
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ICMP_SR_FAILED
suffix:colon
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ICMP: %u.%u.%u.%u: Source Route Failed.&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;daddr
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|icmph-&gt;code
OG
id|NR_ICMP_UNREACH
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Throw it at our lower layers&n;&t; *&n;&t; *&t;RFC 1122: 3.2.2 MUST extract the protocol ID from the passed header.&n;&t; *&t;RFC 1122: 3.2.2.1 MUST pass ICMP unreach messages to the transport layer.&n;&t; *&t;RFC 1122: 3.2.2.2 MUST pass ICMP time expired messages to transport layer.&n;&t; */
multiline_comment|/*&n;&t; *&t;Check the other end isnt violating RFC 1122. Some routers send&n;&t; *&t;bogus responses to broadcast frames. If you see this message&n;&t; *&t;first check your netmask matches at both ends, if it does then&n;&t; *&t;get the other vendor to fix their kit.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sysctl_icmp_ignore_bogus_error_responses
)paren
(brace
r_if
c_cond
(paren
id|inet_addr_type
c_func
(paren
id|iph-&gt;daddr
)paren
op_eq
id|RTN_BROADCAST
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%u.%u.%u.%u sent an invalid ICMP error to a broadcast.&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|skb-&gt;nh.iph-&gt;saddr
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Deliver ICMP message to raw sockets. Pretty useless feature?&n;&t; */
multiline_comment|/* Note: See raw.c and net/raw.h, RAWV4_HTABLE_SIZE==MAX_INET_PROTOS */
id|hash
op_assign
id|iph-&gt;protocol
op_amp
(paren
id|MAX_INET_PROTOS
op_minus
l_int|1
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|raw_v4_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|raw_sk
op_assign
id|raw_v4_htable
(braket
id|hash
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
r_while
c_loop
(paren
(paren
id|raw_sk
op_assign
id|__raw_v4_lookup
c_func
(paren
id|raw_sk
comma
id|iph-&gt;protocol
comma
id|iph-&gt;saddr
comma
id|iph-&gt;daddr
comma
id|skb-&gt;dev-&gt;ifindex
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|raw_err
c_func
(paren
id|raw_sk
comma
id|skb
)paren
suffix:semicolon
id|raw_sk
op_assign
id|raw_sk-&gt;next
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|raw_v4_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This can&squot;t change while we are doing it. &n;&t; *&t;Callers have obtained BR_NETPROTO_LOCK so&n;&t; *&t;we are OK.&n;&t; */
id|ipprot
op_assign
(paren
r_struct
id|inet_protocol
op_star
)paren
id|inet_protos
(braket
id|hash
)braket
suffix:semicolon
r_while
c_loop
(paren
id|ipprot
op_ne
l_int|NULL
)paren
(brace
r_struct
id|inet_protocol
op_star
id|nextip
suffix:semicolon
id|nextip
op_assign
(paren
r_struct
id|inet_protocol
op_star
)paren
id|ipprot-&gt;next
suffix:semicolon
multiline_comment|/* &n;&t;&t; *&t;Pass it off to everyone who wants it. &n;&t;&t; */
multiline_comment|/* RFC1122: OK. Passes appropriate ICMP errors to the */
multiline_comment|/* appropriate protocol layer (MUST), as per 3.2.2. */
r_if
c_cond
(paren
id|iph-&gt;protocol
op_eq
id|ipprot-&gt;protocol
op_logical_and
id|ipprot-&gt;err_handler
)paren
id|ipprot
op_member_access_from_pointer
id|err_handler
c_func
(paren
id|skb
comma
id|dp
comma
id|len
)paren
suffix:semicolon
id|ipprot
op_assign
id|nextip
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Handle ICMP_REDIRECT. &n; */
DECL|function|icmp_redirect
r_static
r_void
id|icmp_redirect
c_func
(paren
r_struct
id|icmphdr
op_star
id|icmph
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|len
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_int
r_int
id|ip
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
r_struct
id|iphdr
)paren
)paren
(brace
id|ICMP_INC_STATS_BH
c_func
(paren
id|IcmpInErrors
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Get the copied header of the packet that caused the redirect&n;&t; */
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
(paren
id|icmph
op_plus
l_int|1
)paren
suffix:semicolon
id|ip
op_assign
id|iph-&gt;daddr
suffix:semicolon
r_switch
c_cond
(paren
id|icmph-&gt;code
op_amp
l_int|7
)paren
(brace
r_case
id|ICMP_REDIR_NET
suffix:colon
r_case
id|ICMP_REDIR_NETTOS
suffix:colon
multiline_comment|/*&n;&t;&t;&t; *&t;As per RFC recommendations now handle it as&n;&t;&t;&t; *&t;a host redirect.&n;&t;&t;&t; */
r_case
id|ICMP_REDIR_HOST
suffix:colon
r_case
id|ICMP_REDIR_HOSTTOS
suffix:colon
id|ip_rt_redirect
c_func
(paren
id|skb-&gt;nh.iph-&gt;saddr
comma
id|ip
comma
id|icmph-&gt;un.gateway
comma
id|iph-&gt;saddr
comma
id|iph-&gt;tos
comma
id|skb-&gt;dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Handle ICMP_ECHO (&quot;ping&quot;) requests. &n; *&n; *&t;RFC 1122: 3.2.2.6 MUST have an echo server that answers ICMP echo requests.&n; *&t;RFC 1122: 3.2.2.6 Data received in the ICMP_ECHO request MUST be included in the reply.&n; *&t;RFC 1812: 4.3.3.6 SHOULD have a config option for silently ignoring echo requests, MUST have default=NOT.&n; *&t;See also WRT handling of options once they are done and working.&n; */
DECL|function|icmp_echo
r_static
r_void
id|icmp_echo
c_func
(paren
r_struct
id|icmphdr
op_star
id|icmph
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sysctl_icmp_echo_ignore_all
)paren
(brace
r_struct
id|icmp_bxm
id|icmp_param
suffix:semicolon
id|icmp_param.icmph
op_assign
op_star
id|icmph
suffix:semicolon
id|icmp_param.icmph.type
op_assign
id|ICMP_ECHOREPLY
suffix:semicolon
id|icmp_param.data_ptr
op_assign
(paren
id|icmph
op_plus
l_int|1
)paren
suffix:semicolon
id|icmp_param.data_len
op_assign
id|len
suffix:semicolon
id|icmp_reply
c_func
(paren
op_amp
id|icmp_param
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Handle ICMP Timestamp requests. &n; *&t;RFC 1122: 3.2.2.8 MAY implement ICMP timestamp requests.&n; *&t;&t;  SHOULD be in the kernel for minimum random latency.&n; *&t;&t;  MUST be accurate to a few minutes.&n; *&t;&t;  MUST be updated at least at 15Hz.&n; */
DECL|function|icmp_timestamp
r_static
r_void
id|icmp_timestamp
c_func
(paren
r_struct
id|icmphdr
op_star
id|icmph
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|len
)paren
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
id|__u32
id|times
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* So the new timestamp works on ALPHA&squot;s.. */
r_struct
id|icmp_bxm
id|icmp_param
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Too short.&n;&t; */
r_if
c_cond
(paren
id|len
OL
l_int|12
)paren
(brace
id|ICMP_INC_STATS_BH
c_func
(paren
id|IcmpInErrors
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Fill in the current time as ms since midnight UT: &n;&t; */
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|times
(braket
l_int|1
)braket
op_assign
id|htonl
c_func
(paren
(paren
id|tv.tv_sec
op_mod
l_int|86400
)paren
op_star
l_int|1000
op_plus
id|tv.tv_usec
op_div
l_int|1000
)paren
suffix:semicolon
id|times
(braket
l_int|2
)braket
op_assign
id|times
(braket
l_int|1
)braket
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|times
(braket
l_int|0
)braket
comma
id|icmph
op_plus
l_int|1
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Incoming stamp */
id|icmp_param.icmph
op_assign
op_star
id|icmph
suffix:semicolon
id|icmp_param.icmph.type
op_assign
id|ICMP_TIMESTAMPREPLY
suffix:semicolon
id|icmp_param.icmph.code
op_assign
l_int|0
suffix:semicolon
id|icmp_param.data_ptr
op_assign
op_amp
id|times
suffix:semicolon
id|icmp_param.data_len
op_assign
l_int|12
suffix:semicolon
id|icmp_reply
c_func
(paren
op_amp
id|icmp_param
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Handle ICMP_ADDRESS_MASK requests.  (RFC950)&n; *&n; * RFC1122 (3.2.2.9).  A host MUST only send replies to &n; * ADDRESS_MASK requests if it&squot;s been configured as an address mask &n; * agent.  Receiving a request doesn&squot;t constitute implicit permission to &n; * act as one. Of course, implementing this correctly requires (SHOULD) &n; * a way to turn the functionality on and off.  Another one for sysctl(), &n; * I guess. -- MS&n; *&n; * RFC1812 (4.3.3.9).&t;A router MUST implement it.&n; *&t;&t;&t;A router SHOULD have switch turning it on/off.&n; *&t;&t;      &t;This switch MUST be ON by default.&n; *&n; * Gratuitous replies, zero-source replies are not implemented,&n; * that complies with RFC. DO NOT implement them!!! All the idea&n; * of broadcast addrmask replies as specified in RFC950 is broken.&n; * The problem is that it is not uncommon to have several prefixes&n; * on one physical interface. Moreover, addrmask agent can even be&n; * not aware of existing another prefixes.&n; * If source is zero, addrmask agent cannot choose correct prefix.&n; * Gratuitous mask announcements suffer from the same problem.&n; * RFC1812 explains it, but still allows to use ADDRMASK,&n; * that is pretty silly. --ANK&n; *&n; * All these rules are so bizarre, that I removed kernel addrmask&n; * support at all. It is wrong, it is obsolete, nobody uses it in&n; * any case. --ANK&n; *&n; * Furthermore you can do it with a usermode address agent program&n; * anyway...&n; */
DECL|function|icmp_address
r_static
r_void
id|icmp_address
c_func
(paren
r_struct
id|icmphdr
op_star
id|icmph
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|len
)paren
(brace
macro_line|#if 0
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;a guy asks for address mask. Who is it?&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif&t;&t;
)brace
multiline_comment|/*&n; * RFC1812 (4.3.3.9).&t;A router SHOULD listen all replies, and complain&n; *&t;&t;&t;loudly if an inconsistency is found.&n; */
DECL|function|icmp_address_reply
r_static
r_void
id|icmp_address_reply
c_func
(paren
r_struct
id|icmphdr
op_star
id|icmph
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|len
)paren
(brace
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
r_struct
id|in_device
op_star
id|in_dev
suffix:semicolon
r_struct
id|in_ifaddr
op_star
id|ifa
suffix:semicolon
id|u32
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|4
op_logical_or
op_logical_neg
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_DIRECTSRC
)paren
)paren
r_return
suffix:semicolon
id|in_dev
op_assign
id|in_dev_get
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_dev
)paren
r_return
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|in_dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_dev-&gt;ifa_list
op_logical_and
id|IN_DEV_LOG_MARTIANS
c_func
(paren
id|in_dev
)paren
op_logical_and
id|IN_DEV_FORWARD
c_func
(paren
id|in_dev
)paren
)paren
(brace
id|mask
op_assign
op_star
(paren
id|u32
op_star
)paren
op_amp
id|icmph
(braket
l_int|1
)braket
suffix:semicolon
r_for
c_loop
(paren
id|ifa
op_assign
id|in_dev-&gt;ifa_list
suffix:semicolon
id|ifa
suffix:semicolon
id|ifa
op_assign
id|ifa-&gt;ifa_next
)paren
(brace
r_if
c_cond
(paren
id|mask
op_eq
id|ifa-&gt;ifa_mask
op_logical_and
id|inet_ifa_match
c_func
(paren
id|rt-&gt;rt_src
comma
id|ifa
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ifa
op_logical_and
id|net_ratelimit
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Wrong address mask %u.%u.%u.%u from %s/%u.%u.%u.%u&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|mask
)paren
comma
id|dev-&gt;name
comma
id|NIPQUAD
c_func
(paren
id|rt-&gt;rt_src
)paren
)paren
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|in_dev-&gt;lock
)paren
suffix:semicolon
id|in_dev_put
c_func
(paren
id|in_dev
)paren
suffix:semicolon
)brace
DECL|function|icmp_discard
r_static
r_void
id|icmp_discard
c_func
(paren
r_struct
id|icmphdr
op_star
id|icmph
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|len
)paren
(brace
)brace
multiline_comment|/* &n; *&t;Deal with incoming ICMP packets.&n; */
DECL|function|icmp_rcv
r_int
id|icmp_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|icmphdr
op_star
id|icmph
op_assign
id|skb-&gt;h.icmph
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
id|ICMP_INC_STATS_BH
c_func
(paren
id|IcmpInMsgs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;18 is the highest &squot;known&squot; ICMP type. Anything else is a mystery&n;&t; *&n;&t; *&t;RFC 1122: 3.2.2  Unknown ICMP messages types MUST be silently discarded.&n;&t; */
r_if
c_cond
(paren
id|len
template_param
id|NR_ICMP_TYPES
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Parse the ICMP message &n;&t; */
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
(paren
id|RTCF_BROADCAST
op_or
id|RTCF_MULTICAST
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;RFC 1122: 3.2.2.6 An ICMP_ECHO to broadcast MAY be&n;&t;&t; *&t;  silently ignored (we let user decide with a sysctl).&n;&t;&t; *&t;RFC 1122: 3.2.2.8 An ICMP_TIMESTAMP MAY be silently&n;&t;&t; *&t;  discarded if to broadcast/multicast.&n;&t;&t; */
r_if
c_cond
(paren
id|icmph-&gt;type
op_eq
id|ICMP_ECHO
op_logical_and
id|sysctl_icmp_echo_ignore_broadcasts
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|icmph-&gt;type
op_ne
id|ICMP_ECHO
op_logical_and
id|icmph-&gt;type
op_ne
id|ICMP_TIMESTAMP
op_logical_and
id|icmph-&gt;type
op_ne
id|ICMP_ADDRESS
op_logical_and
id|icmph-&gt;type
op_ne
id|ICMP_ADDRESSREPLY
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
)brace
id|len
op_sub_assign
r_sizeof
(paren
r_struct
id|icmphdr
)paren
suffix:semicolon
id|icmp_pointers
(braket
id|icmph-&gt;type
)braket
dot
id|input
(braket
id|smp_processor_id
c_func
(paren
)paren
op_star
l_int|2
op_star
r_sizeof
(paren
r_struct
id|icmp_mib
)paren
op_div
r_sizeof
(paren
r_int
r_int
)paren
)braket
op_increment
suffix:semicolon
(paren
id|icmp_pointers
(braket
id|icmph-&gt;type
)braket
dot
id|handler
)paren
(paren
id|icmph
comma
id|skb
comma
id|len
)paren
suffix:semicolon
id|drop
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|ICMP_INC_STATS_BH
c_func
(paren
id|IcmpInErrors
)paren
suffix:semicolon
r_goto
id|drop
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;A spare long used to speed up statistics updating&n; */
DECL|variable|dummy
r_static
r_int
r_int
id|dummy
suffix:semicolon
multiline_comment|/* &n; * &t;Configurable rate limits.&n; *&t;Someone should check if these default values are correct.&n; *&t;Note that these values interact with the routing cache GC timeout.&n; *&t;If you chose them too high they won&squot;t take effect, because the&n; *&t;dst_entry gets expired too early. The same should happen when&n; *&t;the cache grows too big.&n; */
DECL|variable|sysctl_icmp_destunreach_time
r_int
id|sysctl_icmp_destunreach_time
op_assign
l_int|1
op_star
id|HZ
suffix:semicolon
DECL|variable|sysctl_icmp_timeexceed_time
r_int
id|sysctl_icmp_timeexceed_time
op_assign
l_int|1
op_star
id|HZ
suffix:semicolon
DECL|variable|sysctl_icmp_paramprob_time
r_int
id|sysctl_icmp_paramprob_time
op_assign
l_int|1
op_star
id|HZ
suffix:semicolon
DECL|variable|sysctl_icmp_echoreply_time
r_int
id|sysctl_icmp_echoreply_time
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t limit it per default. */
multiline_comment|/*&n; *&t;This table is the definition of how we handle ICMP.&n; */
DECL|variable|icmp_pointers
r_static
r_struct
id|icmp_control
id|icmp_pointers
(braket
id|NR_ICMP_TYPES
op_plus
l_int|1
)braket
op_assign
(brace
multiline_comment|/* ECHO REPLY (0) */
(brace
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpOutEchoReps
comma
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpInEchoReps
comma
id|icmp_discard
comma
l_int|0
comma
op_amp
id|sysctl_icmp_echoreply_time
)brace
comma
(brace
op_amp
id|dummy
comma
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpInErrors
comma
id|icmp_discard
comma
l_int|1
comma
)brace
comma
(brace
op_amp
id|dummy
comma
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpInErrors
comma
id|icmp_discard
comma
l_int|1
comma
)brace
comma
multiline_comment|/* DEST UNREACH (3) */
(brace
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpOutDestUnreachs
comma
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpInDestUnreachs
comma
id|icmp_unreach
comma
l_int|1
comma
op_amp
id|sysctl_icmp_destunreach_time
)brace
comma
multiline_comment|/* SOURCE QUENCH (4) */
(brace
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpOutSrcQuenchs
comma
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpInSrcQuenchs
comma
id|icmp_unreach
comma
l_int|1
comma
)brace
comma
multiline_comment|/* REDIRECT (5) */
(brace
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpOutRedirects
comma
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpInRedirects
comma
id|icmp_redirect
comma
l_int|1
comma
)brace
comma
(brace
op_amp
id|dummy
comma
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpInErrors
comma
id|icmp_discard
comma
l_int|1
comma
)brace
comma
(brace
op_amp
id|dummy
comma
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpInErrors
comma
id|icmp_discard
comma
l_int|1
comma
)brace
comma
multiline_comment|/* ECHO (8) */
(brace
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpOutEchos
comma
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpInEchos
comma
id|icmp_echo
comma
l_int|0
comma
)brace
comma
(brace
op_amp
id|dummy
comma
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpInErrors
comma
id|icmp_discard
comma
l_int|1
comma
)brace
comma
(brace
op_amp
id|dummy
comma
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpInErrors
comma
id|icmp_discard
comma
l_int|1
comma
)brace
comma
multiline_comment|/* TIME EXCEEDED (11) */
(brace
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpOutTimeExcds
comma
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpInTimeExcds
comma
id|icmp_unreach
comma
l_int|1
comma
op_amp
id|sysctl_icmp_timeexceed_time
)brace
comma
multiline_comment|/* PARAMETER PROBLEM (12) */
(brace
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpOutParmProbs
comma
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpInParmProbs
comma
id|icmp_unreach
comma
l_int|1
comma
op_amp
id|sysctl_icmp_paramprob_time
)brace
comma
multiline_comment|/* TIMESTAMP (13) */
(brace
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpOutTimestamps
comma
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpInTimestamps
comma
id|icmp_timestamp
comma
l_int|0
comma
)brace
comma
multiline_comment|/* TIMESTAMP REPLY (14) */
(brace
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpOutTimestampReps
comma
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpInTimestampReps
comma
id|icmp_discard
comma
l_int|0
comma
)brace
comma
multiline_comment|/* INFO (15) */
(brace
op_amp
id|dummy
comma
op_amp
id|dummy
comma
id|icmp_discard
comma
l_int|0
comma
)brace
comma
multiline_comment|/* INFO REPLY (16) */
(brace
op_amp
id|dummy
comma
op_amp
id|dummy
comma
id|icmp_discard
comma
l_int|0
comma
)brace
comma
multiline_comment|/* ADDR MASK (17) */
(brace
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpOutAddrMasks
comma
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpInAddrMasks
comma
id|icmp_address
comma
l_int|0
comma
)brace
comma
multiline_comment|/* ADDR MASK REPLY (18) */
(brace
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpOutAddrMaskReps
comma
op_amp
id|icmp_statistics
(braket
l_int|0
)braket
dot
id|IcmpInAddrMaskReps
comma
id|icmp_address_reply
comma
l_int|0
comma
)brace
)brace
suffix:semicolon
DECL|function|icmp_init
r_void
id|__init
id|icmp_init
c_func
(paren
r_struct
id|net_proto_family
op_star
id|ops
)paren
(brace
r_int
id|err
suffix:semicolon
id|icmp_inode.i_mode
op_assign
id|S_IFSOCK
suffix:semicolon
id|icmp_inode.i_sock
op_assign
l_int|1
suffix:semicolon
id|icmp_inode.i_uid
op_assign
l_int|0
suffix:semicolon
id|icmp_inode.i_gid
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|icmp_inode.i_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|icmp_inode.u.socket_i.wait
)paren
suffix:semicolon
id|icmp_socket-&gt;inode
op_assign
op_amp
id|icmp_inode
suffix:semicolon
id|icmp_socket-&gt;state
op_assign
id|SS_UNCONNECTED
suffix:semicolon
id|icmp_socket-&gt;type
op_assign
id|SOCK_RAW
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ops
op_member_access_from_pointer
id|create
c_func
(paren
id|icmp_socket
comma
id|IPPROTO_ICMP
)paren
)paren
OL
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Failed to create the ICMP control socket.&bslash;n&quot;
)paren
suffix:semicolon
id|icmp_socket-&gt;sk-&gt;allocation
op_assign
id|GFP_ATOMIC
suffix:semicolon
id|icmp_socket-&gt;sk-&gt;sndbuf
op_assign
id|SK_WMEM_MAX
op_star
l_int|2
suffix:semicolon
id|icmp_socket-&gt;sk-&gt;protinfo.af_inet.ttl
op_assign
id|MAXTTL
suffix:semicolon
multiline_comment|/* Unhash it so that IP input processing does not even&n;&t; * see it, we do not wish this socket to see incoming&n;&t; * packets.&n;&t; */
id|icmp_socket-&gt;sk-&gt;prot
op_member_access_from_pointer
id|unhash
c_func
(paren
id|icmp_socket-&gt;sk
)paren
suffix:semicolon
)brace
eof
