multiline_comment|/* NAT for netfilter; shared with compatibility layer. */
multiline_comment|/* (c) 1999 Paul `Rusty&squot; Russell.  Licenced under the GNU General&n;   Public Licence. */
macro_line|#ifdef MODULE
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#endif
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4.h&gt;
macro_line|#include &lt;linux/brlock.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/tcp.h&gt;  /* For tcp_prot in getorigdst */
DECL|macro|ASSERT_READ_LOCK
mdefine_line|#define ASSERT_READ_LOCK(x) MUST_BE_READ_LOCKED(&amp;ip_nat_lock)
DECL|macro|ASSERT_WRITE_LOCK
mdefine_line|#define ASSERT_WRITE_LOCK(x) MUST_BE_WRITE_LOCKED(&amp;ip_nat_lock)
macro_line|#include &lt;linux/netfilter_ipv4/ip_nat.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_nat_protocol.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_nat_core.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_nat_helper.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/listhelp.h&gt;
macro_line|#if 0
mdefine_line|#define DEBUGP printk
macro_line|#else
DECL|macro|DEBUGP
mdefine_line|#define DEBUGP(format, args...)
macro_line|#endif
DECL|variable|ip_nat_lock
id|DECLARE_RWLOCK
c_func
(paren
id|ip_nat_lock
)paren
suffix:semicolon
DECL|macro|IP_NAT_HTABLE_SIZE
mdefine_line|#define IP_NAT_HTABLE_SIZE 64
DECL|variable|bysource
r_static
r_struct
id|list_head
id|bysource
(braket
id|IP_NAT_HTABLE_SIZE
)braket
suffix:semicolon
DECL|variable|byipsproto
r_static
r_struct
id|list_head
id|byipsproto
(braket
id|IP_NAT_HTABLE_SIZE
)braket
suffix:semicolon
DECL|variable|protos
id|LIST_HEAD
c_func
(paren
id|protos
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|helpers
)paren
suffix:semicolon
r_extern
r_struct
id|ip_nat_protocol
id|unknown_nat_protocol
suffix:semicolon
multiline_comment|/* We keep extra hashes for each conntrack, for fast searching. */
r_static
r_inline
r_int
DECL|function|hash_by_ipsproto
id|hash_by_ipsproto
c_func
(paren
id|u_int32_t
id|src
comma
id|u_int32_t
id|dst
comma
id|u_int16_t
id|proto
)paren
(brace
multiline_comment|/* Modified src and dst, to ensure we don&squot;t create two&n;           identical streams. */
r_return
(paren
id|src
op_plus
id|dst
op_plus
id|proto
)paren
op_mod
id|IP_NAT_HTABLE_SIZE
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|hash_by_src
id|hash_by_src
c_func
(paren
r_const
r_struct
id|ip_conntrack_manip
op_star
id|manip
comma
id|u_int16_t
id|proto
)paren
(brace
multiline_comment|/* Original src, to ensure we map it consistently if poss. */
r_return
(paren
id|manip-&gt;ip
op_plus
id|manip-&gt;u.all
op_plus
id|proto
)paren
op_mod
id|IP_NAT_HTABLE_SIZE
suffix:semicolon
)brace
multiline_comment|/* Noone using conntrack by the time this called. */
DECL|function|ip_nat_cleanup_conntrack
r_static
r_void
id|ip_nat_cleanup_conntrack
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|conn
)paren
(brace
r_struct
id|ip_nat_info
op_star
id|info
op_assign
op_amp
id|conn-&gt;nat.info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;initialized
)paren
r_return
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|info-&gt;bysource.conntrack
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|info-&gt;byipsproto.conntrack
)paren
suffix:semicolon
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|bysource
(braket
id|hash_by_src
c_func
(paren
op_amp
id|conn-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.src
comma
id|conn-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.dst.protonum
)paren
)braket
comma
op_amp
id|info-&gt;bysource
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|byipsproto
(braket
id|hash_by_ipsproto
c_func
(paren
id|conn-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple.src.ip
comma
id|conn-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple.dst.ip
comma
id|conn-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple.dst.protonum
)paren
)braket
comma
op_amp
id|info-&gt;byipsproto
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* We do checksum mangling, so if they were wrong before they&squot;re still&n; * wrong.  Also works for incomplete packets (eg. ICMP dest&n; * unreachables.) */
id|u_int16_t
DECL|function|ip_nat_cheat_check
id|ip_nat_cheat_check
c_func
(paren
id|u_int32_t
id|oldvalinv
comma
id|u_int32_t
id|newval
comma
id|u_int16_t
id|oldcheck
)paren
(brace
id|u_int32_t
id|diffs
(braket
)braket
op_assign
(brace
id|oldvalinv
comma
id|newval
)brace
suffix:semicolon
r_return
id|csum_fold
c_func
(paren
id|csum_partial
c_func
(paren
(paren
r_char
op_star
)paren
id|diffs
comma
r_sizeof
(paren
id|diffs
)paren
comma
id|oldcheck
op_xor
l_int|0xFFFF
)paren
)paren
suffix:semicolon
)brace
DECL|function|cmp_proto
r_static
r_inline
r_int
id|cmp_proto
c_func
(paren
r_const
r_struct
id|ip_nat_protocol
op_star
id|i
comma
r_int
id|proto
)paren
(brace
r_return
id|i-&gt;protonum
op_eq
id|proto
suffix:semicolon
)brace
r_struct
id|ip_nat_protocol
op_star
DECL|function|find_nat_proto
id|find_nat_proto
c_func
(paren
id|u_int16_t
id|protonum
)paren
(brace
r_struct
id|ip_nat_protocol
op_star
id|i
suffix:semicolon
id|MUST_BE_READ_LOCKED
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
id|i
op_assign
id|LIST_FIND
c_func
(paren
op_amp
id|protos
comma
id|cmp_proto
comma
r_struct
id|ip_nat_protocol
op_star
comma
id|protonum
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|i
op_assign
op_amp
id|unknown_nat_protocol
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* Is this tuple already taken? (not by us) */
r_int
DECL|function|ip_nat_used_tuple
id|ip_nat_used_tuple
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_conntrack
op_star
id|ignored_conntrack
)paren
(brace
multiline_comment|/* Conntrack tracking doesn&squot;t keep track of outgoing tuples; only&n;&t;   incoming ones.  NAT means they don&squot;t have a fixed mapping,&n;&t;   so we invert the tuple and look for the incoming reply.&n;&n;&t;   We could keep a separate hash if this proves too slow. */
r_struct
id|ip_conntrack_tuple
id|reply
suffix:semicolon
id|invert_tuplepr
c_func
(paren
op_amp
id|reply
comma
id|tuple
)paren
suffix:semicolon
r_return
id|ip_conntrack_tuple_taken
c_func
(paren
op_amp
id|reply
comma
id|ignored_conntrack
)paren
suffix:semicolon
)brace
multiline_comment|/* Does tuple + the source manip come within the range mr */
r_static
r_int
DECL|function|in_range
id|in_range
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_conntrack_manip
op_star
id|manip
comma
r_const
r_struct
id|ip_nat_multi_range
op_star
id|mr
)paren
(brace
r_struct
id|ip_nat_protocol
op_star
id|proto
op_assign
id|find_nat_proto
c_func
(paren
id|tuple-&gt;dst.protonum
)paren
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_struct
id|ip_conntrack_tuple
id|newtuple
op_assign
(brace
op_star
id|manip
comma
id|tuple-&gt;dst
)brace
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mr-&gt;rangesize
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* If we are allowed to map IPs, then we must be in the&n;&t;&t;   range specified, otherwise we must be unchanged. */
r_if
c_cond
(paren
id|mr-&gt;range
(braket
id|i
)braket
dot
id|flags
op_amp
id|IP_NAT_RANGE_MAP_IPS
)paren
(brace
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|newtuple.src.ip
)paren
OL
id|ntohl
c_func
(paren
id|mr-&gt;range
(braket
id|i
)braket
dot
id|min_ip
)paren
op_logical_or
(paren
id|ntohl
c_func
(paren
id|newtuple.src.ip
)paren
OG
id|ntohl
c_func
(paren
id|mr-&gt;range
(braket
id|i
)braket
dot
id|max_ip
)paren
)paren
)paren
r_continue
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|newtuple.src.ip
op_ne
id|tuple-&gt;src.ip
)paren
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mr-&gt;range
(braket
id|i
)braket
dot
id|flags
op_amp
id|IP_NAT_RANGE_PROTO_SPECIFIED
)paren
op_logical_and
id|proto
op_member_access_from_pointer
id|in_range
c_func
(paren
op_amp
id|newtuple
comma
id|IP_NAT_MANIP_SRC
comma
op_amp
id|mr-&gt;range
(braket
id|i
)braket
dot
id|min
comma
op_amp
id|mr-&gt;range
(braket
id|i
)braket
dot
id|max
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|src_cmp
id|src_cmp
c_func
(paren
r_const
r_struct
id|ip_nat_hash
op_star
id|i
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_nat_multi_range
op_star
id|mr
)paren
(brace
r_return
(paren
id|i-&gt;conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.dst.protonum
op_eq
id|tuple-&gt;dst.protonum
op_logical_and
id|i-&gt;conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.src.ip
op_eq
id|tuple-&gt;src.ip
op_logical_and
id|i-&gt;conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.src.u.all
op_eq
id|tuple-&gt;src.u.all
op_logical_and
id|in_range
c_func
(paren
id|tuple
comma
op_amp
id|i-&gt;conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.src
comma
id|mr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Only called for SRC manip */
r_static
r_struct
id|ip_conntrack_manip
op_star
DECL|function|find_appropriate_src
id|find_appropriate_src
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_nat_multi_range
op_star
id|mr
)paren
(brace
r_int
r_int
id|h
op_assign
id|hash_by_src
c_func
(paren
op_amp
id|tuple-&gt;src
comma
id|tuple-&gt;dst.protonum
)paren
suffix:semicolon
r_struct
id|ip_nat_hash
op_star
id|i
suffix:semicolon
id|MUST_BE_READ_LOCKED
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
id|i
op_assign
id|LIST_FIND
c_func
(paren
op_amp
id|bysource
(braket
id|h
)braket
comma
id|src_cmp
comma
r_struct
id|ip_nat_hash
op_star
comma
id|tuple
comma
id|mr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
op_amp
id|i-&gt;conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.src
suffix:semicolon
r_else
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* If it&squot;s really a local destination manip, it may need to do a&n;   source manip too. */
r_static
r_int
DECL|function|do_extra_mangle
id|do_extra_mangle
c_func
(paren
id|u_int32_t
id|var_ip
comma
id|u_int32_t
op_star
id|other_ipp
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
multiline_comment|/* FIXME: IPTOS_TOS(iph-&gt;tos) --RR */
r_if
c_cond
(paren
id|ip_route_output
c_func
(paren
op_amp
id|rt
comma
id|var_ip
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
op_ne
l_int|0
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;do_extra_mangle: Can&squot;t get route to %u.%u.%u.%u&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|var_ip
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|other_ipp
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Simple way to iterate through all. */
DECL|function|fake_cmp
r_static
r_inline
r_int
id|fake_cmp
c_func
(paren
r_const
r_struct
id|ip_nat_hash
op_star
id|i
comma
id|u_int32_t
id|src
comma
id|u_int32_t
id|dst
comma
id|u_int16_t
id|protonum
comma
r_int
r_int
op_star
id|score
comma
r_const
r_struct
id|ip_conntrack
op_star
id|conntrack
)paren
(brace
multiline_comment|/* Compare backwards: we&squot;re dealing with OUTGOING tuples, and&n;           inside the conntrack is the REPLY tuple.  Don&squot;t count this&n;           conntrack. */
r_if
c_cond
(paren
id|i-&gt;conntrack
op_ne
id|conntrack
op_logical_and
id|i-&gt;conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple.src.ip
op_eq
id|dst
op_logical_and
id|i-&gt;conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple.dst.ip
op_eq
id|src
op_logical_and
(paren
id|i-&gt;conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple.dst.protonum
op_eq
id|protonum
)paren
)paren
(paren
op_star
id|score
)paren
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|count_maps
id|count_maps
c_func
(paren
id|u_int32_t
id|src
comma
id|u_int32_t
id|dst
comma
id|u_int16_t
id|protonum
comma
r_const
r_struct
id|ip_conntrack
op_star
id|conntrack
)paren
(brace
r_int
r_int
id|score
op_assign
l_int|0
suffix:semicolon
id|MUST_BE_READ_LOCKED
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
id|LIST_FIND
c_func
(paren
op_amp
id|byipsproto
(braket
id|hash_by_ipsproto
c_func
(paren
id|src
comma
id|dst
comma
id|protonum
)paren
)braket
comma
id|fake_cmp
comma
r_struct
id|ip_nat_hash
op_star
comma
id|src
comma
id|dst
comma
id|protonum
comma
op_amp
id|score
comma
id|conntrack
)paren
suffix:semicolon
r_return
id|score
suffix:semicolon
)brace
multiline_comment|/* For [FUTURE] fragmentation handling, we want the least-used&n;   src-ip/dst-ip/proto triple.  Fairness doesn&squot;t come into it.  Thus&n;   if the range specifies 1.2.3.4 ports 10000-10005 and 1.2.3.5 ports&n;   1-65535, we don&squot;t do pro-rata allocation based on ports; we choose&n;   the ip with the lowest src-ip/dst-ip/proto usage.&n;&n;   If an allocation then fails (eg. all 6 ports used in the 1.2.3.4&n;   range), we eliminate that and try again.  This is not the most&n;   efficient approach, but if you&squot;re worried about that, don&squot;t hand us&n;   ranges you don&squot;t really have.  */
r_static
r_struct
id|ip_nat_range
op_star
DECL|function|find_best_ips_proto
id|find_best_ips_proto
c_func
(paren
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_nat_multi_range
op_star
id|mr
comma
r_const
r_struct
id|ip_conntrack
op_star
id|conntrack
comma
r_int
r_int
id|hooknum
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_struct
(brace
r_const
r_struct
id|ip_nat_range
op_star
id|range
suffix:semicolon
r_int
r_int
id|score
suffix:semicolon
r_struct
id|ip_conntrack_tuple
id|tuple
suffix:semicolon
)brace
id|best
op_assign
(brace
l_int|NULL
comma
l_int|0xFFFFFFFF
)brace
suffix:semicolon
id|u_int32_t
op_star
id|var_ipp
comma
op_star
id|other_ipp
comma
id|saved_ip
comma
id|orig_dstip
suffix:semicolon
r_if
c_cond
(paren
id|HOOK2MANIP
c_func
(paren
id|hooknum
)paren
op_eq
id|IP_NAT_MANIP_SRC
)paren
(brace
id|var_ipp
op_assign
op_amp
id|tuple-&gt;src.ip
suffix:semicolon
id|saved_ip
op_assign
id|tuple-&gt;dst.ip
suffix:semicolon
id|other_ipp
op_assign
op_amp
id|tuple-&gt;dst.ip
suffix:semicolon
)brace
r_else
(brace
id|var_ipp
op_assign
op_amp
id|tuple-&gt;dst.ip
suffix:semicolon
id|saved_ip
op_assign
id|tuple-&gt;src.ip
suffix:semicolon
id|other_ipp
op_assign
op_amp
id|tuple-&gt;src.ip
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t do do_extra_mangle unless neccessary (overrides&n;           explicit socket bindings, for example) */
id|orig_dstip
op_assign
id|tuple-&gt;dst.ip
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|mr-&gt;rangesize
op_ge
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mr-&gt;rangesize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u_int32_t
id|minip
comma
id|maxip
suffix:semicolon
multiline_comment|/* Don&squot;t do ranges which are already eliminated. */
r_if
c_cond
(paren
id|mr-&gt;range
(braket
id|i
)braket
dot
id|flags
op_amp
id|IP_NAT_RANGE_FULL
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mr-&gt;range
(braket
id|i
)braket
dot
id|flags
op_amp
id|IP_NAT_RANGE_MAP_IPS
)paren
(brace
id|minip
op_assign
id|mr-&gt;range
(braket
id|i
)braket
dot
id|min_ip
suffix:semicolon
id|maxip
op_assign
id|mr-&gt;range
(braket
id|i
)braket
dot
id|max_ip
suffix:semicolon
)brace
r_else
id|minip
op_assign
id|maxip
op_assign
op_star
id|var_ipp
suffix:semicolon
r_for
c_loop
(paren
op_star
id|var_ipp
op_assign
id|minip
suffix:semicolon
id|ntohl
c_func
(paren
op_star
id|var_ipp
)paren
op_le
id|ntohl
c_func
(paren
id|maxip
)paren
suffix:semicolon
op_star
id|var_ipp
op_assign
id|htonl
c_func
(paren
id|ntohl
c_func
(paren
op_star
id|var_ipp
)paren
op_plus
l_int|1
)paren
)paren
(brace
r_int
r_int
id|score
suffix:semicolon
multiline_comment|/* Reset the other ip in case it was mangled by&n;&t;&t;&t; * do_extra_mangle last time. */
op_star
id|other_ipp
op_assign
id|saved_ip
suffix:semicolon
r_if
c_cond
(paren
id|hooknum
op_eq
id|NF_IP_LOCAL_OUT
op_logical_and
op_star
id|var_ipp
op_ne
id|orig_dstip
op_logical_and
op_logical_neg
id|do_extra_mangle
c_func
(paren
op_star
id|var_ipp
comma
id|other_ipp
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;Range %u %u.%u.%u.%u rt failed!&bslash;n&quot;
comma
id|i
comma
id|NIPQUAD
c_func
(paren
op_star
id|var_ipp
)paren
)paren
suffix:semicolon
multiline_comment|/* Can&squot;t route?  This whole range part is&n;&t;&t;&t;&t; * probably screwed, but keep trying&n;&t;&t;&t;&t; * anyway. */
r_continue
suffix:semicolon
)brace
multiline_comment|/* Count how many others map onto this. */
id|score
op_assign
id|count_maps
c_func
(paren
id|tuple-&gt;src.ip
comma
id|tuple-&gt;dst.ip
comma
id|tuple-&gt;dst.protonum
comma
id|conntrack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|score
OL
id|best.score
)paren
(brace
multiline_comment|/* Optimization: doesn&squot;t get any better than&n;&t;&t;&t;&t;   this. */
r_if
c_cond
(paren
id|score
op_eq
l_int|0
)paren
r_return
(paren
r_struct
id|ip_nat_range
op_star
)paren
op_amp
id|mr-&gt;range
(braket
id|i
)braket
suffix:semicolon
id|best.score
op_assign
id|score
suffix:semicolon
id|best.tuple
op_assign
op_star
id|tuple
suffix:semicolon
id|best.range
op_assign
op_amp
id|mr-&gt;range
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
)brace
op_star
id|tuple
op_assign
id|best.tuple
suffix:semicolon
multiline_comment|/* Discard const. */
r_return
(paren
r_struct
id|ip_nat_range
op_star
)paren
id|best.range
suffix:semicolon
)brace
multiline_comment|/* Fast version doesn&squot;t iterate through hash chains, but only handles&n;   common case of single IP address (null NAT, masquerade) */
r_static
r_struct
id|ip_nat_range
op_star
DECL|function|find_best_ips_proto_fast
id|find_best_ips_proto_fast
c_func
(paren
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_nat_multi_range
op_star
id|mr
comma
r_const
r_struct
id|ip_conntrack
op_star
id|conntrack
comma
r_int
r_int
id|hooknum
)paren
(brace
r_if
c_cond
(paren
id|mr-&gt;rangesize
op_ne
l_int|1
op_logical_or
(paren
id|mr-&gt;range
(braket
l_int|0
)braket
dot
id|flags
op_amp
id|IP_NAT_RANGE_FULL
)paren
op_logical_or
(paren
(paren
id|mr-&gt;range
(braket
l_int|0
)braket
dot
id|flags
op_amp
id|IP_NAT_RANGE_MAP_IPS
)paren
op_logical_and
id|mr-&gt;range
(braket
l_int|0
)braket
dot
id|min_ip
op_ne
id|mr-&gt;range
(braket
l_int|0
)braket
dot
id|max_ip
)paren
)paren
r_return
id|find_best_ips_proto
c_func
(paren
id|tuple
comma
id|mr
comma
id|conntrack
comma
id|hooknum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mr-&gt;range
(braket
l_int|0
)braket
dot
id|flags
op_amp
id|IP_NAT_RANGE_MAP_IPS
)paren
(brace
r_if
c_cond
(paren
id|HOOK2MANIP
c_func
(paren
id|hooknum
)paren
op_eq
id|IP_NAT_MANIP_SRC
)paren
id|tuple-&gt;src.ip
op_assign
id|mr-&gt;range
(braket
l_int|0
)braket
dot
id|min_ip
suffix:semicolon
r_else
(brace
multiline_comment|/* Only do extra mangle when required (breaks&n;                           socket binding) */
r_if
c_cond
(paren
id|tuple-&gt;dst.ip
op_ne
id|mr-&gt;range
(braket
l_int|0
)braket
dot
id|min_ip
op_logical_and
id|hooknum
op_eq
id|NF_IP_LOCAL_OUT
op_logical_and
op_logical_neg
id|do_extra_mangle
c_func
(paren
id|mr-&gt;range
(braket
l_int|0
)braket
dot
id|min_ip
comma
op_amp
id|tuple-&gt;src.ip
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|tuple-&gt;dst.ip
op_assign
id|mr-&gt;range
(braket
l_int|0
)braket
dot
id|min_ip
suffix:semicolon
)brace
)brace
multiline_comment|/* Discard const. */
r_return
(paren
r_struct
id|ip_nat_range
op_star
)paren
op_amp
id|mr-&gt;range
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_static
r_int
DECL|function|get_unique_tuple
id|get_unique_tuple
c_func
(paren
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|orig_tuple
comma
r_const
r_struct
id|ip_nat_multi_range
op_star
id|mrr
comma
r_struct
id|ip_conntrack
op_star
id|conntrack
comma
r_int
r_int
id|hooknum
)paren
(brace
r_struct
id|ip_nat_protocol
op_star
id|proto
op_assign
id|find_nat_proto
c_func
(paren
id|orig_tuple-&gt;dst.protonum
)paren
suffix:semicolon
r_struct
id|ip_nat_range
op_star
id|rptr
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* We temporarily use flags for marking full parts, but we&n;&t;   always clean up afterwards */
r_struct
id|ip_nat_multi_range
op_star
id|mr
op_assign
(paren
r_void
op_star
)paren
id|mrr
suffix:semicolon
multiline_comment|/* 1) If this srcip/proto/src-proto-part is currently mapped,&n;&t;   and that same mapping gives a unique tuple within the given&n;&t;   range, use that.&n;&n;&t;   This is only required for source (ie. NAT/masq) mappings.&n;&t;   So far, we don&squot;t do local source mappings, so multiple&n;&t;   manips not an issue.  */
r_if
c_cond
(paren
id|hooknum
op_eq
id|NF_IP_POST_ROUTING
)paren
(brace
r_struct
id|ip_conntrack_manip
op_star
id|manip
suffix:semicolon
id|manip
op_assign
id|find_appropriate_src
c_func
(paren
id|orig_tuple
comma
id|mr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|manip
)paren
(brace
multiline_comment|/* Apply same source manipulation. */
op_star
id|tuple
op_assign
(paren
(paren
r_struct
id|ip_conntrack_tuple
)paren
(brace
op_star
id|manip
comma
id|orig_tuple-&gt;dst
)brace
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;get_unique_tuple: Found current src map&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* 2) Select the least-used IP/proto combination in the given&n;&t;   range.&n;&t;*/
op_star
id|tuple
op_assign
op_star
id|orig_tuple
suffix:semicolon
r_while
c_loop
(paren
(paren
id|rptr
op_assign
id|find_best_ips_proto_fast
c_func
(paren
id|tuple
comma
id|mr
comma
id|conntrack
comma
id|hooknum
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;Found best for &quot;
)paren
suffix:semicolon
id|DUMP_TUPLE
c_func
(paren
id|tuple
)paren
suffix:semicolon
multiline_comment|/* 3) The per-protocol part of the manip is made to&n;&t;&t;   map into the range to make a unique tuple. */
multiline_comment|/* Only bother mapping if it&squot;s not already in range&n;&t;&t;   and unique */
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|rptr-&gt;flags
op_amp
id|IP_NAT_RANGE_PROTO_SPECIFIED
)paren
op_logical_or
id|proto
op_member_access_from_pointer
id|in_range
c_func
(paren
id|tuple
comma
id|HOOK2MANIP
c_func
(paren
id|hooknum
)paren
comma
op_amp
id|rptr-&gt;min
comma
op_amp
id|rptr-&gt;max
)paren
)paren
op_logical_and
op_logical_neg
id|ip_nat_used_tuple
c_func
(paren
id|tuple
comma
id|conntrack
)paren
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|clear_fulls
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|proto
op_member_access_from_pointer
id|unique_tuple
c_func
(paren
id|tuple
comma
id|rptr
comma
id|HOOK2MANIP
c_func
(paren
id|hooknum
)paren
comma
id|conntrack
)paren
)paren
(brace
multiline_comment|/* Must be unique. */
id|IP_NF_ASSERT
c_func
(paren
op_logical_neg
id|ip_nat_used_tuple
c_func
(paren
id|tuple
comma
id|conntrack
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|clear_fulls
suffix:semicolon
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;Protocol can&squot;t get unique tuple.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Eliminate that from range, and try again. */
id|rptr-&gt;flags
op_or_assign
id|IP_NAT_RANGE_FULL
suffix:semicolon
op_star
id|tuple
op_assign
op_star
id|orig_tuple
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|clear_fulls
suffix:colon
multiline_comment|/* Clear full flags. */
id|IP_NF_ASSERT
c_func
(paren
id|mr-&gt;rangesize
op_ge
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mr-&gt;rangesize
suffix:semicolon
id|i
op_increment
)paren
id|mr-&gt;range
(braket
id|i
)braket
dot
id|flags
op_and_assign
op_complement
id|IP_NAT_RANGE_FULL
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|helper_cmp
id|helper_cmp
c_func
(paren
r_const
r_struct
id|ip_nat_helper
op_star
id|helper
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
)paren
(brace
r_return
id|ip_ct_tuple_mask_cmp
c_func
(paren
id|tuple
comma
op_amp
id|helper-&gt;tuple
comma
op_amp
id|helper-&gt;mask
)paren
suffix:semicolon
)brace
multiline_comment|/* Where to manip the reply packets (will be reverse manip). */
DECL|variable|opposite_hook
r_static
r_int
r_int
id|opposite_hook
(braket
id|NF_IP_NUMHOOKS
)braket
op_assign
(brace
(braket
id|NF_IP_PRE_ROUTING
)braket
op_assign
id|NF_IP_POST_ROUTING
comma
(braket
id|NF_IP_POST_ROUTING
)braket
op_assign
id|NF_IP_PRE_ROUTING
comma
(braket
id|NF_IP_LOCAL_OUT
)braket
op_assign
id|NF_IP_POST_ROUTING
)brace
suffix:semicolon
r_int
r_int
DECL|function|ip_nat_setup_info
id|ip_nat_setup_info
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|conntrack
comma
r_const
r_struct
id|ip_nat_multi_range
op_star
id|mr
comma
r_int
r_int
id|hooknum
)paren
(brace
r_struct
id|ip_conntrack_tuple
id|new_tuple
comma
id|inv_tuple
comma
id|reply
suffix:semicolon
r_struct
id|ip_conntrack_tuple
id|orig_tp
suffix:semicolon
r_struct
id|ip_nat_info
op_star
id|info
op_assign
op_amp
id|conntrack-&gt;nat.info
suffix:semicolon
id|MUST_BE_WRITE_LOCKED
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|hooknum
op_eq
id|NF_IP_PRE_ROUTING
op_logical_or
id|hooknum
op_eq
id|NF_IP_POST_ROUTING
op_logical_or
id|hooknum
op_eq
id|NF_IP_LOCAL_OUT
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|info-&gt;num_manips
OL
id|IP_NAT_MAX_MANIPS
)paren
suffix:semicolon
multiline_comment|/* What we&squot;ve got will look like inverse of reply. Normally&n;&t;   this is what is in the conntrack, except for prior&n;&t;   manipulations (future optimization: if num_manips == 0,&n;&t;   orig_tp =&n;&t;   conntrack-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple) */
id|invert_tuplepr
c_func
(paren
op_amp
id|orig_tp
comma
op_amp
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple
)paren
suffix:semicolon
macro_line|#if 0
(brace
r_int
r_int
id|i
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;Hook %u (%s), &quot;
comma
id|hooknum
comma
id|HOOK2MANIP
c_func
(paren
id|hooknum
)paren
op_eq
id|IP_NAT_MANIP_SRC
ques
c_cond
l_string|&quot;SRC&quot;
suffix:colon
l_string|&quot;DST&quot;
)paren
suffix:semicolon
id|DUMP_TUPLE
c_func
(paren
op_amp
id|orig_tp
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;Range %p: &quot;
comma
id|mr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mr-&gt;rangesize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;%u:%s%s%s %u.%u.%u.%u - %u.%u.%u.%u %u - %u&bslash;n&quot;
comma
id|i
comma
(paren
id|mr-&gt;range
(braket
id|i
)braket
dot
id|flags
op_amp
id|IP_NAT_RANGE_MAP_IPS
)paren
ques
c_cond
l_string|&quot; MAP_IPS&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|mr-&gt;range
(braket
id|i
)braket
dot
id|flags
op_amp
id|IP_NAT_RANGE_PROTO_SPECIFIED
)paren
ques
c_cond
l_string|&quot; PROTO_SPECIFIED&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|mr-&gt;range
(braket
id|i
)braket
dot
id|flags
op_amp
id|IP_NAT_RANGE_FULL
)paren
ques
c_cond
l_string|&quot; FULL&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|NIPQUAD
c_func
(paren
id|mr-&gt;range
(braket
id|i
)braket
dot
id|min_ip
)paren
comma
id|NIPQUAD
c_func
(paren
id|mr-&gt;range
(braket
id|i
)braket
dot
id|max_ip
)paren
comma
id|mr-&gt;range
(braket
id|i
)braket
dot
id|min.all
comma
id|mr-&gt;range
(braket
id|i
)braket
dot
id|max.all
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|get_unique_tuple
c_func
(paren
op_amp
id|new_tuple
comma
op_amp
id|orig_tp
comma
id|mr
comma
id|conntrack
comma
id|hooknum
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;ip_nat_setup_info: Can&squot;t get unique for %p.&bslash;n&quot;
comma
id|conntrack
)paren
suffix:semicolon
r_return
id|NF_DROP
suffix:semicolon
)brace
macro_line|#if 0
id|DEBUGP
c_func
(paren
l_string|&quot;Hook %u (%s) %p&bslash;n&quot;
comma
id|hooknum
comma
id|HOOK2MANIP
c_func
(paren
id|hooknum
)paren
op_eq
id|IP_NAT_MANIP_SRC
ques
c_cond
l_string|&quot;SRC&quot;
suffix:colon
l_string|&quot;DST&quot;
comma
id|conntrack
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;Original: &quot;
)paren
suffix:semicolon
id|DUMP_TUPLE
c_func
(paren
op_amp
id|orig_tp
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;New: &quot;
)paren
suffix:semicolon
id|DUMP_TUPLE
c_func
(paren
op_amp
id|new_tuple
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* We now have two tuples (SRCIP/SRCPT/DSTIP/DSTPT):&n;&t;&t;   the original (A/B/C/D&squot;) and the mangled one (E/F/G/H&squot;).&n;&n;&t;&t;   We&squot;re only allowed to work with the SRC per-proto&n;&t;&t;   part, so we create inverses of both to start, then&n;&t;&t;   derive the other fields we need.  */
multiline_comment|/* Reply connection: simply invert the new tuple&n;                   (G/H/E/F&squot;) */
id|invert_tuplepr
c_func
(paren
op_amp
id|reply
comma
op_amp
id|new_tuple
)paren
suffix:semicolon
multiline_comment|/* Alter conntrack table so it recognizes replies.&n;                   If fail this race (reply tuple now used), repeat. */
)brace
r_while
c_loop
(paren
op_logical_neg
id|ip_conntrack_alter_reply
c_func
(paren
id|conntrack
comma
op_amp
id|reply
)paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: We can simply used existing conntrack reply tuple&n;           here --RR */
multiline_comment|/* Create inverse of original: C/D/A/B&squot; */
id|invert_tuplepr
c_func
(paren
op_amp
id|inv_tuple
comma
op_amp
id|orig_tp
)paren
suffix:semicolon
multiline_comment|/* Has source changed?. */
r_if
c_cond
(paren
op_logical_neg
id|ip_ct_tuple_src_equal
c_func
(paren
op_amp
id|new_tuple
comma
op_amp
id|orig_tp
)paren
)paren
(brace
multiline_comment|/* In this direction, a source manip. */
id|info-&gt;manips
(braket
id|info-&gt;num_manips
op_increment
)braket
op_assign
(paren
(paren
r_struct
id|ip_nat_info_manip
)paren
(brace
id|IP_CT_DIR_ORIGINAL
comma
id|hooknum
comma
id|IP_NAT_MANIP_SRC
comma
id|new_tuple.src
)brace
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|info-&gt;num_manips
OL
id|IP_NAT_MAX_MANIPS
)paren
suffix:semicolon
multiline_comment|/* In the reverse direction, a destination manip. */
id|info-&gt;manips
(braket
id|info-&gt;num_manips
op_increment
)braket
op_assign
(paren
(paren
r_struct
id|ip_nat_info_manip
)paren
(brace
id|IP_CT_DIR_REPLY
comma
id|opposite_hook
(braket
id|hooknum
)braket
comma
id|IP_NAT_MANIP_DST
comma
id|orig_tp.src
)brace
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|info-&gt;num_manips
op_le
id|IP_NAT_MAX_MANIPS
)paren
suffix:semicolon
)brace
multiline_comment|/* Has destination changed? */
r_if
c_cond
(paren
op_logical_neg
id|ip_ct_tuple_dst_equal
c_func
(paren
op_amp
id|new_tuple
comma
op_amp
id|orig_tp
)paren
)paren
(brace
multiline_comment|/* In this direction, a destination manip */
id|info-&gt;manips
(braket
id|info-&gt;num_manips
op_increment
)braket
op_assign
(paren
(paren
r_struct
id|ip_nat_info_manip
)paren
(brace
id|IP_CT_DIR_ORIGINAL
comma
id|hooknum
comma
id|IP_NAT_MANIP_DST
comma
id|reply.src
)brace
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|info-&gt;num_manips
OL
id|IP_NAT_MAX_MANIPS
)paren
suffix:semicolon
multiline_comment|/* In the reverse direction, a source manip. */
id|info-&gt;manips
(braket
id|info-&gt;num_manips
op_increment
)braket
op_assign
(paren
(paren
r_struct
id|ip_nat_info_manip
)paren
(brace
id|IP_CT_DIR_REPLY
comma
id|opposite_hook
(braket
id|hooknum
)braket
comma
id|IP_NAT_MANIP_SRC
comma
id|inv_tuple.src
)brace
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|info-&gt;num_manips
op_le
id|IP_NAT_MAX_MANIPS
)paren
suffix:semicolon
)brace
multiline_comment|/* If there&squot;s a helper, assign it; based on new tuple. */
id|info-&gt;helper
op_assign
id|LIST_FIND
c_func
(paren
op_amp
id|helpers
comma
id|helper_cmp
comma
r_struct
id|ip_nat_helper
op_star
comma
op_amp
id|reply
)paren
suffix:semicolon
multiline_comment|/* It&squot;s done. */
id|info-&gt;initialized
op_or_assign
(paren
l_int|1
op_lshift
id|HOOK2MANIP
c_func
(paren
id|hooknum
)paren
)paren
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
DECL|function|replace_in_hashes
r_void
id|replace_in_hashes
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|conntrack
comma
r_struct
id|ip_nat_info
op_star
id|info
)paren
(brace
multiline_comment|/* Source has changed, so replace in hashes. */
r_int
r_int
id|srchash
op_assign
id|hash_by_src
c_func
(paren
op_amp
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.src
comma
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.dst.protonum
)paren
suffix:semicolon
multiline_comment|/* We place packet as seen OUTGOUNG in byips_proto hash&n;           (ie. reverse dst and src of reply packet. */
r_int
r_int
id|ipsprotohash
op_assign
id|hash_by_ipsproto
c_func
(paren
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple.dst.ip
comma
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple.src.ip
comma
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple.dst.protonum
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|info-&gt;bysource.conntrack
op_eq
id|conntrack
)paren
suffix:semicolon
id|MUST_BE_WRITE_LOCKED
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|info-&gt;bysource.list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|info-&gt;byipsproto.list
)paren
suffix:semicolon
id|list_prepend
c_func
(paren
op_amp
id|bysource
(braket
id|srchash
)braket
comma
op_amp
id|info-&gt;bysource
)paren
suffix:semicolon
id|list_prepend
c_func
(paren
op_amp
id|byipsproto
(braket
id|ipsprotohash
)braket
comma
op_amp
id|info-&gt;byipsproto
)paren
suffix:semicolon
)brace
DECL|function|place_in_hashes
r_void
id|place_in_hashes
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|conntrack
comma
r_struct
id|ip_nat_info
op_star
id|info
)paren
(brace
r_int
r_int
id|srchash
op_assign
id|hash_by_src
c_func
(paren
op_amp
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.src
comma
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.dst.protonum
)paren
suffix:semicolon
multiline_comment|/* We place packet as seen OUTGOUNG in byips_proto hash&n;           (ie. reverse dst and src of reply packet. */
r_int
r_int
id|ipsprotohash
op_assign
id|hash_by_ipsproto
c_func
(paren
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple.dst.ip
comma
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple.src.ip
comma
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple.dst.protonum
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
op_logical_neg
id|info-&gt;bysource.conntrack
)paren
suffix:semicolon
id|MUST_BE_WRITE_LOCKED
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
id|info-&gt;byipsproto.conntrack
op_assign
id|conntrack
suffix:semicolon
id|info-&gt;bysource.conntrack
op_assign
id|conntrack
suffix:semicolon
id|list_prepend
c_func
(paren
op_amp
id|bysource
(braket
id|srchash
)braket
comma
op_amp
id|info-&gt;bysource
)paren
suffix:semicolon
id|list_prepend
c_func
(paren
op_amp
id|byipsproto
(braket
id|ipsprotohash
)braket
comma
op_amp
id|info-&gt;byipsproto
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|manip_pkt
id|manip_pkt
c_func
(paren
id|u_int16_t
id|proto
comma
r_struct
id|iphdr
op_star
id|iph
comma
r_int
id|len
comma
r_const
r_struct
id|ip_conntrack_manip
op_star
id|manip
comma
r_enum
id|ip_nat_manip_type
id|maniptype
comma
id|__u32
op_star
id|nfcache
)paren
(brace
op_star
id|nfcache
op_or_assign
id|NFC_ALTERED
suffix:semicolon
id|find_nat_proto
c_func
(paren
id|proto
)paren
op_member_access_from_pointer
id|manip_pkt
c_func
(paren
id|iph
comma
id|len
comma
id|manip
comma
id|maniptype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maniptype
op_eq
id|IP_NAT_MANIP_SRC
)paren
(brace
id|iph-&gt;check
op_assign
id|ip_nat_cheat_check
c_func
(paren
op_complement
id|iph-&gt;saddr
comma
id|manip-&gt;ip
comma
id|iph-&gt;check
)paren
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|manip-&gt;ip
suffix:semicolon
)brace
r_else
(brace
id|iph-&gt;check
op_assign
id|ip_nat_cheat_check
c_func
(paren
op_complement
id|iph-&gt;daddr
comma
id|manip-&gt;ip
comma
id|iph-&gt;check
)paren
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|manip-&gt;ip
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|ip_fast_csum
c_func
(paren
(paren
id|u8
op_star
)paren
id|iph
comma
id|iph-&gt;ihl
)paren
op_ne
l_int|0
)paren
id|DEBUGP
c_func
(paren
l_string|&quot;IP: checksum on packet bad.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proto
op_eq
id|IPPROTO_TCP
)paren
(brace
r_void
op_star
id|th
op_assign
(paren
id|u_int32_t
op_star
)paren
id|iph
op_plus
id|iph-&gt;ihl
suffix:semicolon
r_if
c_cond
(paren
id|tcp_v4_check
c_func
(paren
id|th
comma
id|len
op_minus
l_int|4
op_star
id|iph-&gt;ihl
comma
id|iph-&gt;saddr
comma
id|iph-&gt;daddr
comma
id|csum_partial
c_func
(paren
(paren
r_char
op_star
)paren
id|th
comma
id|len
op_minus
l_int|4
op_star
id|iph-&gt;ihl
comma
l_int|0
)paren
)paren
)paren
id|DEBUGP
c_func
(paren
l_string|&quot;TCP: checksum on packet bad&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/* Do packet manipulations according to binding. */
r_int
r_int
DECL|function|do_bindings
id|do_bindings
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|ct
comma
r_enum
id|ip_conntrack_info
id|ctinfo
comma
r_struct
id|ip_nat_info
op_star
id|info
comma
r_int
r_int
id|hooknum
comma
r_struct
id|sk_buff
op_star
op_star
id|pskb
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_struct
id|ip_nat_helper
op_star
id|helper
suffix:semicolon
r_enum
id|ip_conntrack_dir
id|dir
op_assign
id|CTINFO2DIR
c_func
(paren
id|ctinfo
)paren
suffix:semicolon
multiline_comment|/* Need nat lock to protect against modification, but neither&n;&t;   conntrack (referenced) and helper (deleted with&n;&t;   synchronize_bh()) can vanish. */
id|READ_LOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|info-&gt;num_manips
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;manips
(braket
id|i
)braket
dot
id|direction
op_eq
id|dir
op_logical_and
id|info-&gt;manips
(braket
id|i
)braket
dot
id|hooknum
op_eq
id|hooknum
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;Mangling %p: %s to %u.%u.%u.%u %u&bslash;n&quot;
comma
op_star
id|pskb
comma
id|info-&gt;manips
(braket
id|i
)braket
dot
id|maniptype
op_eq
id|IP_NAT_MANIP_SRC
ques
c_cond
l_string|&quot;SRC&quot;
suffix:colon
l_string|&quot;DST&quot;
comma
id|NIPQUAD
c_func
(paren
id|info-&gt;manips
(braket
id|i
)braket
dot
id|manip.ip
)paren
comma
id|htons
c_func
(paren
id|info-&gt;manips
(braket
id|i
)braket
dot
id|manip.u.all
)paren
)paren
suffix:semicolon
id|manip_pkt
c_func
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;protocol
comma
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph
comma
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|len
comma
op_amp
id|info-&gt;manips
(braket
id|i
)braket
dot
id|manip
comma
id|info-&gt;manips
(braket
id|i
)braket
dot
id|maniptype
comma
op_amp
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfcache
)paren
suffix:semicolon
)brace
)brace
id|helper
op_assign
id|info-&gt;helper
suffix:semicolon
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|helper
)paren
(brace
multiline_comment|/* Always defragged for helpers */
id|IP_NF_ASSERT
c_func
(paren
op_logical_neg
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;frag_off
op_amp
id|__constant_htons
c_func
(paren
id|IP_MF
op_or
id|IP_OFFSET
)paren
)paren
)paren
suffix:semicolon
r_return
id|helper
op_member_access_from_pointer
id|help
c_func
(paren
id|ct
comma
id|info
comma
id|ctinfo
comma
id|hooknum
comma
id|pskb
)paren
suffix:semicolon
)brace
r_else
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
r_int
r_int
DECL|function|icmp_reply_translation
id|icmp_reply_translation
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|ip_conntrack
op_star
id|conntrack
comma
r_int
r_int
id|hooknum
comma
r_int
id|dir
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
r_struct
id|icmphdr
op_star
id|hdr
op_assign
(paren
r_struct
id|icmphdr
op_star
)paren
(paren
(paren
id|u_int32_t
op_star
)paren
id|iph
op_plus
id|iph-&gt;ihl
)paren
suffix:semicolon
r_struct
id|iphdr
op_star
id|inner
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
(paren
id|hdr
op_plus
l_int|1
)paren
suffix:semicolon
r_int
id|datalen
op_assign
id|skb-&gt;len
op_minus
(paren
(paren
r_void
op_star
)paren
id|inner
op_minus
(paren
r_void
op_star
)paren
id|iph
)paren
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_struct
id|ip_nat_info
op_star
id|info
op_assign
op_amp
id|conntrack-&gt;nat.info
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|skb-&gt;len
op_ge
id|iph-&gt;ihl
op_star
l_int|4
op_plus
r_sizeof
(paren
r_struct
id|icmphdr
)paren
)paren
suffix:semicolon
multiline_comment|/* Must be RELATED */
id|IP_NF_ASSERT
c_func
(paren
id|skb-&gt;nfct
op_minus
(paren
r_struct
id|ip_conntrack
op_star
)paren
id|skb-&gt;nfct-&gt;master
op_eq
id|IP_CT_RELATED
op_logical_or
id|skb-&gt;nfct
op_minus
(paren
r_struct
id|ip_conntrack
op_star
)paren
id|skb-&gt;nfct-&gt;master
op_eq
id|IP_CT_RELATED
op_plus
id|IP_CT_IS_REPLY
)paren
suffix:semicolon
multiline_comment|/* Redirects on non-null nats must be dropped, else they&squot;ll&n;           start talking to each other without our translation, and be&n;           confused... --RR */
r_if
c_cond
(paren
id|hdr-&gt;type
op_eq
id|ICMP_REDIRECT
)paren
(brace
multiline_comment|/* Don&squot;t care about races here. */
r_if
c_cond
(paren
id|info-&gt;initialized
op_ne
(paren
(paren
l_int|1
op_lshift
id|IP_NAT_MANIP_SRC
)paren
op_or
(paren
l_int|1
op_lshift
id|IP_NAT_MANIP_DST
)paren
)paren
op_logical_or
id|info-&gt;num_manips
op_ne
l_int|0
)paren
r_return
id|NF_DROP
suffix:semicolon
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;icmp_reply_translation: translating error %p hook %u dir %s&bslash;n&quot;
comma
id|skb
comma
id|hooknum
comma
id|dir
op_eq
id|IP_CT_DIR_ORIGINAL
ques
c_cond
l_string|&quot;ORIG&quot;
suffix:colon
l_string|&quot;REPLY&quot;
)paren
suffix:semicolon
multiline_comment|/* Note: May not be from a NAT&squot;d host, but probably safest to&n;&t;   do translation always as if it came from the host itself&n;&t;   (even though a &quot;host unreachable&quot; coming from the host&n;&t;   itself is a bit wierd).&n;&n;&t;   More explanation: some people use NAT for anonymizing.&n;&t;   Also, CERT recommends dropping all packets from private IP&n;&t;   addresses (although ICMP errors from internal links with&n;&t;   such addresses are not too uncommon, as Alan Cox points&n;&t;   out) */
id|READ_LOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|info-&gt;num_manips
suffix:semicolon
id|i
op_increment
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;icmp_reply: manip %u dir %s hook %u&bslash;n&quot;
comma
id|i
comma
id|info-&gt;manips
(braket
id|i
)braket
dot
id|direction
op_eq
id|IP_CT_DIR_ORIGINAL
ques
c_cond
l_string|&quot;ORIG&quot;
suffix:colon
l_string|&quot;REPLY&quot;
comma
id|info-&gt;manips
(braket
id|i
)braket
dot
id|hooknum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;manips
(braket
id|i
)braket
dot
id|direction
op_ne
id|dir
)paren
r_continue
suffix:semicolon
multiline_comment|/* Mapping the inner packet is just like a normal&n;&t;&t;   packet, except it was never src/dst reversed, so&n;&t;&t;   where we would normally apply a dst manip, we apply&n;&t;&t;   a src, and vice versa. */
r_if
c_cond
(paren
id|info-&gt;manips
(braket
id|i
)braket
dot
id|hooknum
op_eq
id|opposite_hook
(braket
id|hooknum
)braket
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;icmp_reply: inner %s -&gt; %u.%u.%u.%u %u&bslash;n&quot;
comma
id|info-&gt;manips
(braket
id|i
)braket
dot
id|maniptype
op_eq
id|IP_NAT_MANIP_SRC
ques
c_cond
l_string|&quot;DST&quot;
suffix:colon
l_string|&quot;SRC&quot;
comma
id|NIPQUAD
c_func
(paren
id|info-&gt;manips
(braket
id|i
)braket
dot
id|manip.ip
)paren
comma
id|ntohs
c_func
(paren
id|info-&gt;manips
(braket
id|i
)braket
dot
id|manip.u.udp.port
)paren
)paren
suffix:semicolon
id|manip_pkt
c_func
(paren
id|inner-&gt;protocol
comma
id|inner
comma
id|skb-&gt;len
op_minus
(paren
(paren
r_void
op_star
)paren
id|inner
op_minus
(paren
r_void
op_star
)paren
id|iph
)paren
comma
op_amp
id|info-&gt;manips
(braket
id|i
)braket
dot
id|manip
comma
op_logical_neg
id|info-&gt;manips
(braket
id|i
)braket
dot
id|maniptype
comma
op_amp
id|skb-&gt;nfcache
)paren
suffix:semicolon
multiline_comment|/* Outer packet needs to have IP header NATed like&n;                   it&squot;s a reply. */
)brace
r_else
r_if
c_cond
(paren
id|info-&gt;manips
(braket
id|i
)braket
dot
id|hooknum
op_eq
id|hooknum
)paren
(brace
multiline_comment|/* Use mapping to map outer packet: 0 give no&n;                           per-proto mapping */
id|DEBUGP
c_func
(paren
l_string|&quot;icmp_reply: outer %s -&gt; %u.%u.%u.%u&bslash;n&quot;
comma
id|info-&gt;manips
(braket
id|i
)braket
dot
id|maniptype
op_eq
id|IP_NAT_MANIP_SRC
ques
c_cond
l_string|&quot;SRC&quot;
suffix:colon
l_string|&quot;DST&quot;
comma
id|NIPQUAD
c_func
(paren
id|info-&gt;manips
(braket
id|i
)braket
dot
id|manip.ip
)paren
)paren
suffix:semicolon
id|manip_pkt
c_func
(paren
l_int|0
comma
id|iph
comma
id|skb-&gt;len
comma
op_amp
id|info-&gt;manips
(braket
id|i
)braket
dot
id|manip
comma
id|info-&gt;manips
(braket
id|i
)braket
dot
id|maniptype
comma
op_amp
id|skb-&gt;nfcache
)paren
suffix:semicolon
)brace
)brace
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
multiline_comment|/* Since we mangled inside ICMP packet, recalculate its&n;&t;   checksum from scratch.  (Hence the handling of incorrect&n;&t;   checksums in conntrack, so we don&squot;t accidentally fix one.)  */
id|hdr-&gt;checksum
op_assign
l_int|0
suffix:semicolon
id|hdr-&gt;checksum
op_assign
id|ip_compute_csum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|hdr
comma
r_sizeof
(paren
op_star
id|hdr
)paren
op_plus
id|datalen
)paren
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
DECL|function|ip_nat_helper_register
r_int
id|ip_nat_helper_register
c_func
(paren
r_struct
id|ip_nat_helper
op_star
id|me
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LIST_FIND
c_func
(paren
op_amp
id|helpers
comma
id|helper_cmp
comma
r_struct
id|ip_nat_helper
op_star
comma
op_amp
id|me-&gt;tuple
)paren
)paren
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_else
(brace
id|list_prepend
c_func
(paren
op_amp
id|helpers
comma
id|me
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
)brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|kill_helper
id|kill_helper
c_func
(paren
r_const
r_struct
id|ip_conntrack
op_star
id|i
comma
r_void
op_star
id|helper
)paren
(brace
r_int
id|ret
suffix:semicolon
id|READ_LOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
id|ret
op_assign
(paren
id|i-&gt;nat.info.helper
op_eq
id|helper
)paren
suffix:semicolon
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|ip_nat_helper_unregister
r_void
id|ip_nat_helper_unregister
c_func
(paren
r_struct
id|ip_nat_helper
op_star
id|me
)paren
(brace
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|helpers
comma
id|me
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
multiline_comment|/* Someone could be still looking at the helper in a bh. */
id|br_write_lock_bh
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
id|br_write_unlock_bh
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
multiline_comment|/* Find anything using it, and umm, kill them.  We can&squot;t turn&n;&t;   them into normal connections: if we&squot;ve adjusted SYNs, then&n;&t;   they&squot;ll ackstorm.  So we just drop it.  We used to just&n;&t;   bump module count when a connection existed, but that&n;&t;   forces admins to gen fake RSTs or bounce box, either of&n;&t;   which is just a long-winded way of making things&n;&t;   worse. --RR */
id|ip_ct_selective_cleanup
c_func
(paren
id|kill_helper
comma
id|me
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|function|ip_nat_init
r_int
id|__init
id|ip_nat_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Sew in builtin protocols. */
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
id|list_append
c_func
(paren
op_amp
id|protos
comma
op_amp
id|ip_nat_protocol_tcp
)paren
suffix:semicolon
id|list_append
c_func
(paren
op_amp
id|protos
comma
op_amp
id|ip_nat_protocol_udp
)paren
suffix:semicolon
id|list_append
c_func
(paren
op_amp
id|protos
comma
op_amp
id|ip_nat_protocol_icmp
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_nat_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IP_NAT_HTABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|bysource
(braket
id|i
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|byipsproto
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* FIXME: Man, this is a hack.  &lt;SIGH&gt; */
id|IP_NF_ASSERT
c_func
(paren
id|ip_conntrack_destroyed
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ip_conntrack_destroyed
op_assign
op_amp
id|ip_nat_cleanup_conntrack
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ip_nat_cleanup
r_void
id|ip_nat_cleanup
c_func
(paren
r_void
)paren
(brace
id|ip_conntrack_destroyed
op_assign
l_int|NULL
suffix:semicolon
)brace
eof
