multiline_comment|/* Connection state tracking for netfilter.  This is separated from,&n;   but required by, the NAT layer; it can also be used by an iptables&n;   extension. */
multiline_comment|/* (c) 1999 Paul `Rusty&squot; Russell.  Licenced under the GNU General&n;   Public Licence. */
macro_line|#ifdef MODULE
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#endif
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/netfilter.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/brlock.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
multiline_comment|/* This rwlock protects the main hash table, protocol/helper/expected&n;   registrations, conntrack timers*/
DECL|macro|ASSERT_READ_LOCK
mdefine_line|#define ASSERT_READ_LOCK(x) MUST_BE_READ_LOCKED(&amp;ip_conntrack_lock)
DECL|macro|ASSERT_WRITE_LOCK
mdefine_line|#define ASSERT_WRITE_LOCK(x) MUST_BE_WRITE_LOCKED(&amp;ip_conntrack_lock)
macro_line|#include &lt;linux/netfilter_ipv4/ip_conntrack.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_conntrack_protocol.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_conntrack_helper.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ip_conntrack_core.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/listhelp.h&gt;
macro_line|#if 0
mdefine_line|#define DEBUGP printk
macro_line|#else
DECL|macro|DEBUGP
mdefine_line|#define DEBUGP(format, args...)
macro_line|#endif
DECL|variable|ip_conntrack_lock
id|DECLARE_RWLOCK
c_func
(paren
id|ip_conntrack_lock
)paren
suffix:semicolon
DECL|variable|ip_conntrack_destroyed
r_void
(paren
op_star
id|ip_conntrack_destroyed
)paren
(paren
r_struct
id|ip_conntrack
op_star
id|conntrack
)paren
op_assign
l_int|NULL
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|expect_list
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|protocol_list
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|helpers
)paren
suffix:semicolon
DECL|variable|ip_conntrack_htable_size
r_int
r_int
id|ip_conntrack_htable_size
op_assign
l_int|0
suffix:semicolon
DECL|variable|ip_conntrack_max
r_static
r_int
id|ip_conntrack_max
op_assign
l_int|0
suffix:semicolon
DECL|variable|ip_conntrack_count
r_static
id|atomic_t
id|ip_conntrack_count
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|ip_conntrack_hash
r_struct
id|list_head
op_star
id|ip_conntrack_hash
suffix:semicolon
r_extern
r_struct
id|ip_conntrack_protocol
id|ip_conntrack_generic_protocol
suffix:semicolon
DECL|function|proto_cmpfn
r_static
r_inline
r_int
id|proto_cmpfn
c_func
(paren
r_const
r_struct
id|ip_conntrack_protocol
op_star
id|curr
comma
id|u_int8_t
id|protocol
)paren
(brace
r_return
id|protocol
op_eq
id|curr-&gt;proto
suffix:semicolon
)brace
DECL|function|__find_proto
r_struct
id|ip_conntrack_protocol
op_star
id|__find_proto
c_func
(paren
id|u_int8_t
id|protocol
)paren
(brace
r_struct
id|ip_conntrack_protocol
op_star
id|p
suffix:semicolon
id|MUST_BE_READ_LOCKED
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|p
op_assign
id|LIST_FIND
c_func
(paren
op_amp
id|protocol_list
comma
id|proto_cmpfn
comma
r_struct
id|ip_conntrack_protocol
op_star
comma
id|protocol
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
id|p
op_assign
op_amp
id|ip_conntrack_generic_protocol
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|find_proto
r_struct
id|ip_conntrack_protocol
op_star
id|find_proto
c_func
(paren
id|u_int8_t
id|protocol
)paren
(brace
r_struct
id|ip_conntrack_protocol
op_star
id|p
suffix:semicolon
id|READ_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|p
op_assign
id|__find_proto
c_func
(paren
id|protocol
)paren
suffix:semicolon
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|ip_conntrack_put
r_static
r_inline
r_void
id|ip_conntrack_put
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|ct
)paren
(brace
id|IP_NF_ASSERT
c_func
(paren
id|ct
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|ct-&gt;infos
(braket
l_int|0
)braket
dot
id|master
)paren
suffix:semicolon
multiline_comment|/* nf_conntrack_put wants to go via an info struct, so feed it&n;           one at random. */
id|nf_conntrack_put
c_func
(paren
op_amp
id|ct-&gt;infos
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_static
r_inline
id|u_int32_t
DECL|function|hash_conntrack
id|hash_conntrack
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
)paren
(brace
macro_line|#if 0
id|dump_tuple
c_func
(paren
id|tuple
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
r_if
c_cond
(paren
id|tuple-&gt;src.pad
)paren
id|DEBUGP
c_func
(paren
l_string|&quot;Tuple %p has non-zero padding.&bslash;n&quot;
comma
id|tuple
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* ntohl because more differences in low bits. */
multiline_comment|/* To ensure that halves of the same connection don&squot;t hash&n;&t;   clash, we add the source per-proto again. */
r_return
(paren
id|ntohl
c_func
(paren
id|tuple-&gt;src.ip
op_plus
id|tuple-&gt;dst.ip
op_plus
id|tuple-&gt;src.u.all
op_plus
id|tuple-&gt;dst.u.all
op_plus
id|tuple-&gt;dst.protonum
)paren
op_plus
id|ntohs
c_func
(paren
id|tuple-&gt;src.u.all
)paren
)paren
op_mod
id|ip_conntrack_htable_size
suffix:semicolon
)brace
r_inline
r_int
DECL|function|get_tuple
id|get_tuple
c_func
(paren
r_const
r_struct
id|iphdr
op_star
id|iph
comma
r_int
id|len
comma
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_struct
id|ip_conntrack_protocol
op_star
id|protocol
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* Can only happen when extracting tuples from inside ICMP&n;           packets */
r_if
c_cond
(paren
id|iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_OFFSET
)paren
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;ip_conntrack_core: Frag of proto %u.&bslash;n&quot;
comma
id|iph-&gt;protocol
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Guarantee 8 protocol bytes: if more wanted, use len param */
r_else
r_if
c_cond
(paren
id|iph-&gt;ihl
op_star
l_int|4
op_plus
l_int|8
OG
id|len
)paren
r_return
l_int|0
suffix:semicolon
id|tuple-&gt;src.ip
op_assign
id|iph-&gt;saddr
suffix:semicolon
id|tuple-&gt;src.pad
op_assign
l_int|0
suffix:semicolon
id|tuple-&gt;dst.ip
op_assign
id|iph-&gt;daddr
suffix:semicolon
id|tuple-&gt;dst.protonum
op_assign
id|iph-&gt;protocol
suffix:semicolon
id|ret
op_assign
id|protocol
op_member_access_from_pointer
id|pkt_to_tuple
c_func
(paren
(paren
id|u_int32_t
op_star
)paren
id|iph
op_plus
id|iph-&gt;ihl
comma
id|len
op_minus
l_int|4
op_star
id|iph-&gt;ihl
comma
id|tuple
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|invert_tuple
id|invert_tuple
c_func
(paren
r_struct
id|ip_conntrack_tuple
op_star
id|inverse
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|orig
comma
r_const
r_struct
id|ip_conntrack_protocol
op_star
id|protocol
)paren
(brace
id|inverse-&gt;src.ip
op_assign
id|orig-&gt;dst.ip
suffix:semicolon
id|inverse-&gt;src.pad
op_assign
l_int|0
suffix:semicolon
id|inverse-&gt;dst.ip
op_assign
id|orig-&gt;src.ip
suffix:semicolon
id|inverse-&gt;dst.protonum
op_assign
id|orig-&gt;dst.protonum
suffix:semicolon
r_return
id|protocol
op_member_access_from_pointer
id|invert_tuple
c_func
(paren
id|inverse
comma
id|orig
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|destroy_conntrack
id|destroy_conntrack
c_func
(paren
r_struct
id|nf_conntrack
op_star
id|nfct
)paren
(brace
r_struct
id|ip_conntrack
op_star
id|ct
op_assign
(paren
r_struct
id|ip_conntrack
op_star
)paren
id|nfct
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|nfct-&gt;use
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
op_logical_neg
id|timer_pending
c_func
(paren
op_amp
id|ct-&gt;timeout
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ct-&gt;master.master
)paren
id|nf_conntrack_put
c_func
(paren
op_amp
id|ct-&gt;master
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip_conntrack_destroyed
)paren
id|ip_conntrack_destroyed
c_func
(paren
id|ct
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ct
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ip_conntrack_count
)paren
suffix:semicolon
)brace
DECL|function|death_by_timeout
r_static
r_void
id|death_by_timeout
c_func
(paren
r_int
r_int
id|ul_conntrack
)paren
(brace
r_struct
id|ip_conntrack
op_star
id|ct
op_assign
(paren
r_void
op_star
)paren
id|ul_conntrack
suffix:semicolon
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
multiline_comment|/* Remove from both hash lists */
id|LIST_DELETE
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|hash_conntrack
c_func
(paren
op_amp
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple
)paren
)braket
comma
op_amp
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|hash_conntrack
c_func
(paren
op_amp
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple
)paren
)braket
comma
op_amp
id|ct-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
)paren
suffix:semicolon
multiline_comment|/* If our expected is in the list, take it out. */
r_if
c_cond
(paren
id|ct-&gt;expected.expectant
)paren
(brace
id|IP_NF_ASSERT
c_func
(paren
id|list_inlist
c_func
(paren
op_amp
id|expect_list
comma
op_amp
id|ct-&gt;expected
)paren
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|ct-&gt;expected.expectant
op_eq
id|ct
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|expect_list
comma
op_amp
id|ct-&gt;expected
)paren
suffix:semicolon
)brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|ip_conntrack_put
c_func
(paren
id|ct
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|conntrack_tuple_cmp
id|conntrack_tuple_cmp
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple_hash
op_star
id|i
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_conntrack
op_star
id|ignored_conntrack
)paren
(brace
id|MUST_BE_READ_LOCKED
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
id|i-&gt;ctrack
op_ne
id|ignored_conntrack
op_logical_and
id|memcmp
c_func
(paren
id|tuple
comma
op_amp
id|i-&gt;tuple
comma
r_sizeof
(paren
op_star
id|tuple
)paren
)paren
op_eq
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|ip_conntrack_tuple_hash
op_star
DECL|function|__ip_conntrack_find
id|__ip_conntrack_find
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_conntrack
op_star
id|ignored_conntrack
)paren
(brace
r_struct
id|ip_conntrack_tuple_hash
op_star
id|h
suffix:semicolon
id|MUST_BE_READ_LOCKED
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|h
op_assign
id|LIST_FIND
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|hash_conntrack
c_func
(paren
id|tuple
)paren
)braket
comma
id|conntrack_tuple_cmp
comma
r_struct
id|ip_conntrack_tuple_hash
op_star
comma
id|tuple
comma
id|ignored_conntrack
)paren
suffix:semicolon
r_return
id|h
suffix:semicolon
)brace
multiline_comment|/* Find a connection corresponding to a tuple. */
r_struct
id|ip_conntrack_tuple_hash
op_star
DECL|function|ip_conntrack_find_get
id|ip_conntrack_find_get
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_conntrack
op_star
id|ignored_conntrack
)paren
(brace
r_struct
id|ip_conntrack_tuple_hash
op_star
id|h
suffix:semicolon
id|READ_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|h
op_assign
id|__ip_conntrack_find
c_func
(paren
id|tuple
comma
id|ignored_conntrack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|h
)paren
id|atomic_inc
c_func
(paren
op_amp
id|h-&gt;ctrack-&gt;ct_general.use
)paren
suffix:semicolon
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
id|h
suffix:semicolon
)brace
multiline_comment|/* Returns true if a connection correspondings to the tuple (required&n;   for NAT). */
r_int
DECL|function|ip_conntrack_tuple_taken
id|ip_conntrack_tuple_taken
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_const
r_struct
id|ip_conntrack
op_star
id|ignored_conntrack
)paren
(brace
r_struct
id|ip_conntrack_tuple_hash
op_star
id|h
suffix:semicolon
id|READ_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|h
op_assign
id|__ip_conntrack_find
c_func
(paren
id|tuple
comma
id|ignored_conntrack
)paren
suffix:semicolon
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
id|h
op_ne
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Returns TRUE if it dealt with ICMP, and filled in skb fields */
DECL|function|icmp_error_track
r_int
id|icmp_error_track
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_const
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
r_struct
id|icmphdr
op_star
id|hdr
op_assign
(paren
r_struct
id|icmphdr
op_star
)paren
(paren
(paren
id|u_int32_t
op_star
)paren
id|iph
op_plus
id|iph-&gt;ihl
)paren
suffix:semicolon
r_struct
id|ip_conntrack_tuple
id|innertuple
comma
id|origtuple
suffix:semicolon
r_struct
id|iphdr
op_star
id|inner
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
(paren
id|hdr
op_plus
l_int|1
)paren
suffix:semicolon
r_int
id|datalen
op_assign
id|skb-&gt;len
op_minus
id|iph-&gt;ihl
op_star
l_int|4
op_minus
r_sizeof
(paren
op_star
id|hdr
)paren
suffix:semicolon
r_struct
id|ip_conntrack_protocol
op_star
id|innerproto
suffix:semicolon
r_struct
id|ip_conntrack_tuple_hash
op_star
id|h
suffix:semicolon
r_enum
id|ip_conntrack_info
id|ctinfo
suffix:semicolon
r_if
c_cond
(paren
id|iph-&gt;protocol
op_ne
id|IPPROTO_ICMP
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OL
id|iph-&gt;ihl
op_star
l_int|4
op_plus
r_sizeof
(paren
r_struct
id|icmphdr
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;icmp_error_track: too short&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hdr-&gt;type
op_ne
id|ICMP_DEST_UNREACH
op_logical_and
id|hdr-&gt;type
op_ne
id|ICMP_SOURCE_QUENCH
op_logical_and
id|hdr-&gt;type
op_ne
id|ICMP_TIME_EXCEEDED
op_logical_and
id|hdr-&gt;type
op_ne
id|ICMP_PARAMETERPROB
op_logical_and
id|hdr-&gt;type
op_ne
id|ICMP_REDIRECT
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Ignore it if the checksum&squot;s bogus. */
r_if
c_cond
(paren
id|ip_compute_csum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|hdr
comma
r_sizeof
(paren
op_star
id|hdr
)paren
op_plus
id|datalen
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;icmp_error_track: bad csum&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|innerproto
op_assign
id|find_proto
c_func
(paren
id|inner-&gt;protocol
)paren
suffix:semicolon
multiline_comment|/* Are they talking about one of our connections? */
r_if
c_cond
(paren
id|inner-&gt;ihl
op_star
l_int|4
op_plus
l_int|8
OG
id|datalen
op_logical_or
op_logical_neg
id|get_tuple
c_func
(paren
id|inner
comma
id|datalen
comma
op_amp
id|origtuple
comma
id|innerproto
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;icmp_error: ! get_tuple p=%u (%u*4+%u dlen=%u)&bslash;n&quot;
comma
id|inner-&gt;protocol
comma
id|inner-&gt;ihl
comma
l_int|8
comma
id|datalen
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Ordinarily, we&squot;d expect the inverted tupleproto, but it&squot;s&n;&t;   been preserved inside the ICMP. */
r_if
c_cond
(paren
op_logical_neg
id|invert_tuple
c_func
(paren
op_amp
id|innertuple
comma
op_amp
id|origtuple
comma
id|innerproto
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;icmp_error_track: Can&squot;t invert tuple&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|h
op_assign
id|ip_conntrack_find_get
c_func
(paren
op_amp
id|innertuple
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;icmp_error_track: no match&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|ctinfo
op_assign
id|IP_CT_RELATED
suffix:semicolon
r_if
c_cond
(paren
id|DIRECTION
c_func
(paren
id|h
)paren
op_eq
id|IP_CT_DIR_REPLY
)paren
id|ctinfo
op_add_assign
id|IP_CT_IS_REPLY
suffix:semicolon
multiline_comment|/* Update skb to refer to this connection */
id|skb-&gt;nfct
op_assign
op_amp
id|h-&gt;ctrack-&gt;infos
(braket
id|ctinfo
)braket
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|helper_cmp
r_static
r_inline
r_int
id|helper_cmp
c_func
(paren
r_const
r_struct
id|ip_conntrack_helper
op_star
id|i
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|rtuple
)paren
(brace
r_return
id|i
op_member_access_from_pointer
id|will_help
c_func
(paren
id|rtuple
)paren
suffix:semicolon
)brace
multiline_comment|/* Compare all but src per-proto part. */
DECL|function|expect_cmp
r_static
r_int
id|expect_cmp
c_func
(paren
r_const
r_struct
id|ip_conntrack_expect
op_star
id|i
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
)paren
(brace
r_return
(paren
id|tuple-&gt;src.ip
op_eq
id|i-&gt;tuple.src.ip
op_logical_and
id|tuple-&gt;dst.ip
op_eq
id|i-&gt;tuple.dst.ip
op_logical_and
id|tuple-&gt;dst.u.all
op_eq
id|i-&gt;tuple.dst.u.all
op_logical_and
id|tuple-&gt;dst.protonum
op_eq
id|i-&gt;tuple.dst.protonum
)paren
suffix:semicolon
)brace
multiline_comment|/* Allocate a new conntrack; we set everything up, then grab write&n;   lock and see if we lost a race.  If we lost it we return 0,&n;   indicating the controlling code should look again. */
r_static
r_int
DECL|function|init_conntrack
id|init_conntrack
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
comma
r_struct
id|ip_conntrack_protocol
op_star
id|protocol
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|ip_conntrack
op_star
id|conntrack
suffix:semicolon
r_struct
id|ip_conntrack_tuple
id|repl_tuple
suffix:semicolon
r_int
id|hash
comma
id|repl_hash
suffix:semicolon
r_struct
id|ip_conntrack_expect
op_star
id|expected
suffix:semicolon
r_enum
id|ip_conntrack_info
id|ctinfo
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|invert_tuple
c_func
(paren
op_amp
id|repl_tuple
comma
id|tuple
comma
id|protocol
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;Can&squot;t invert tuple.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip_conntrack_max
op_logical_and
(paren
id|atomic_read
c_func
(paren
op_amp
id|ip_conntrack_count
)paren
op_ge
id|ip_conntrack_max
)paren
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ip_conntrack: maximum limit of %d entries exceeded&bslash;n&quot;
comma
id|ip_conntrack_max
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|conntrack
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ip_conntrack
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conntrack
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;Can&squot;t allocate conntrack.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|hash
op_assign
id|hash_conntrack
c_func
(paren
id|tuple
)paren
suffix:semicolon
id|repl_hash
op_assign
id|hash_conntrack
c_func
(paren
op_amp
id|repl_tuple
)paren
suffix:semicolon
id|memset
c_func
(paren
id|conntrack
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ip_conntrack
)paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|conntrack-&gt;ct_general.use
comma
l_int|1
)paren
suffix:semicolon
id|conntrack-&gt;ct_general.destroy
op_assign
id|destroy_conntrack
suffix:semicolon
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple
op_assign
op_star
id|tuple
suffix:semicolon
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|ctrack
op_assign
id|conntrack
suffix:semicolon
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple
op_assign
id|repl_tuple
suffix:semicolon
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|ctrack
op_assign
id|conntrack
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IP_CT_NUMBER
suffix:semicolon
id|i
op_increment
)paren
(brace
id|conntrack-&gt;infos
(braket
id|i
)braket
dot
id|master
op_assign
op_amp
id|conntrack-&gt;ct_general
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|protocol
op_member_access_from_pointer
r_new
(paren
id|conntrack
comma
id|skb-&gt;nh.iph
comma
id|skb-&gt;len
)paren
)paren
(brace
id|kfree
c_func
(paren
id|conntrack
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Sew in at head of hash list. */
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
multiline_comment|/* Check noone else beat us in the race... */
r_if
c_cond
(paren
id|__ip_conntrack_find
c_func
(paren
id|tuple
comma
l_int|NULL
)paren
)paren
(brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ip_conntrack: Wow someone raced us!&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|conntrack
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|conntrack-&gt;helper
op_assign
id|LIST_FIND
c_func
(paren
op_amp
id|helpers
comma
id|helper_cmp
comma
r_struct
id|ip_conntrack_helper
op_star
comma
op_amp
id|repl_tuple
)paren
suffix:semicolon
multiline_comment|/* Need finding and deleting of expected ONLY if we win race */
id|expected
op_assign
id|LIST_FIND
c_func
(paren
op_amp
id|expect_list
comma
id|expect_cmp
comma
r_struct
id|ip_conntrack_expect
op_star
comma
id|tuple
)paren
suffix:semicolon
r_if
c_cond
(paren
id|expected
)paren
(brace
multiline_comment|/* Welcome, Mr. Bond.  We&squot;ve been expecting you... */
id|conntrack-&gt;status
op_assign
id|IPS_EXPECTED
suffix:semicolon
id|conntrack-&gt;master.master
op_assign
op_amp
id|expected-&gt;expectant-&gt;ct_general
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|conntrack-&gt;master.master
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|expect_list
comma
id|expected
)paren
suffix:semicolon
id|expected-&gt;expectant
op_assign
l_int|NULL
suffix:semicolon
id|nf_conntrack_get
c_func
(paren
op_amp
id|conntrack-&gt;master
)paren
suffix:semicolon
id|ctinfo
op_assign
id|IP_CT_RELATED
suffix:semicolon
)brace
r_else
(brace
id|ctinfo
op_assign
id|IP_CT_NEW
suffix:semicolon
)brace
id|list_prepend
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|hash
)braket
comma
op_amp
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
)paren
suffix:semicolon
id|list_prepend
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|repl_hash
)braket
comma
op_amp
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
multiline_comment|/* Update skb to refer to this connection */
id|skb-&gt;nfct
op_assign
op_amp
id|conntrack-&gt;infos
(braket
id|ctinfo
)braket
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|ip_conntrack_count
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_void
DECL|function|resolve_normal_ct
id|resolve_normal_ct
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|ip_conntrack_tuple
id|tuple
suffix:semicolon
r_struct
id|ip_conntrack_tuple_hash
op_star
id|h
suffix:semicolon
r_struct
id|ip_conntrack_protocol
op_star
id|proto
suffix:semicolon
r_enum
id|ip_conntrack_info
id|ctinfo
suffix:semicolon
id|proto
op_assign
id|find_proto
c_func
(paren
id|skb-&gt;nh.iph-&gt;protocol
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_tuple
c_func
(paren
id|skb-&gt;nh.iph
comma
id|skb-&gt;len
comma
op_amp
id|tuple
comma
id|proto
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Loop around search/insert race */
r_do
(brace
multiline_comment|/* look for tuple match */
id|h
op_assign
id|ip_conntrack_find_get
c_func
(paren
op_amp
id|tuple
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
op_logical_and
id|init_conntrack
c_func
(paren
op_amp
id|tuple
comma
id|proto
comma
id|skb
)paren
)paren
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|h
)paren
suffix:semicolon
multiline_comment|/* It exists; we have (non-exclusive) reference. */
r_if
c_cond
(paren
id|DIRECTION
c_func
(paren
id|h
)paren
op_eq
id|IP_CT_DIR_REPLY
)paren
(brace
id|ctinfo
op_assign
id|IP_CT_ESTABLISHED
op_plus
id|IP_CT_IS_REPLY
suffix:semicolon
id|h-&gt;ctrack-&gt;status
op_or_assign
id|IPS_SEEN_REPLY
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Once we&squot;ve had two way comms, always ESTABLISHED. */
r_if
c_cond
(paren
id|h-&gt;ctrack-&gt;status
op_amp
id|IPS_SEEN_REPLY
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;ip_conntrack_in: normal packet for %p&bslash;n&quot;
comma
id|h-&gt;ctrack
)paren
suffix:semicolon
id|ctinfo
op_assign
id|IP_CT_ESTABLISHED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|h-&gt;ctrack-&gt;status
op_amp
id|IPS_EXPECTED
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;ip_conntrack_in: related packet for %p&bslash;n&quot;
comma
id|h-&gt;ctrack
)paren
suffix:semicolon
id|ctinfo
op_assign
id|IP_CT_RELATED
suffix:semicolon
)brace
r_else
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;ip_conntrack_in: new packet for %p&bslash;n&quot;
comma
id|h-&gt;ctrack
)paren
suffix:semicolon
id|ctinfo
op_assign
id|IP_CT_NEW
suffix:semicolon
)brace
)brace
id|skb-&gt;nfct
op_assign
op_amp
id|h-&gt;ctrack-&gt;infos
(braket
id|ctinfo
)braket
suffix:semicolon
)brace
multiline_comment|/* Return conntrack and conntrack_info a given skb */
r_struct
id|ip_conntrack
op_star
DECL|function|ip_conntrack_get
id|ip_conntrack_get
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_enum
id|ip_conntrack_info
op_star
id|ctinfo
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;nfct
)paren
(brace
multiline_comment|/* It may be an icmp error... */
r_if
c_cond
(paren
op_logical_neg
id|icmp_error_track
c_func
(paren
id|skb
)paren
)paren
id|resolve_normal_ct
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;nfct
)paren
(brace
r_struct
id|ip_conntrack
op_star
id|ct
op_assign
(paren
r_struct
id|ip_conntrack
op_star
)paren
id|skb-&gt;nfct-&gt;master
suffix:semicolon
multiline_comment|/* ctinfo is the index of the nfct inside the conntrack */
op_star
id|ctinfo
op_assign
id|skb-&gt;nfct
op_minus
id|ct-&gt;infos
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
op_star
id|ctinfo
op_ge
l_int|0
op_logical_and
op_star
id|ctinfo
OL
id|IP_CT_NUMBER
)paren
suffix:semicolon
r_return
id|ct
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Netfilter hook itself. */
DECL|function|ip_conntrack_in
r_int
r_int
id|ip_conntrack_in
c_func
(paren
r_int
r_int
id|hooknum
comma
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_int
(paren
op_star
id|okfn
)paren
(paren
r_struct
id|sk_buff
op_star
)paren
)paren
(brace
r_struct
id|ip_conntrack
op_star
id|ct
suffix:semicolon
r_enum
id|ip_conntrack_info
id|ctinfo
suffix:semicolon
r_struct
id|ip_conntrack_protocol
op_star
id|proto
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* FIXME: Do this right please. --RR */
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfcache
op_or_assign
id|NFC_UNKNOWN
suffix:semicolon
multiline_comment|/* Previously seen (loopback)?  Ignore.  Do this before&n;           fragment check. */
r_if
c_cond
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfct
)paren
r_return
id|NF_ACCEPT
suffix:semicolon
multiline_comment|/* Gather fragments. */
r_if
c_cond
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_MF
op_or
id|IP_OFFSET
)paren
)paren
(brace
op_star
id|pskb
op_assign
id|ip_ct_gather_frags
c_func
(paren
op_star
id|pskb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|pskb
)paren
r_return
id|NF_STOLEN
suffix:semicolon
)brace
id|ct
op_assign
id|ip_conntrack_get
c_func
(paren
op_star
id|pskb
comma
op_amp
id|ctinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ct
)paren
multiline_comment|/* Not valid part of a connection */
r_return
id|NF_ACCEPT
suffix:semicolon
id|proto
op_assign
id|find_proto
c_func
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph-&gt;protocol
)paren
suffix:semicolon
multiline_comment|/* If this is new, this is first time timer will be set */
id|ret
op_assign
id|proto
op_member_access_from_pointer
id|packet
c_func
(paren
id|ct
comma
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph
comma
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|len
comma
id|ctinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Invalid */
id|nf_conntrack_put
c_func
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfct
)paren
suffix:semicolon
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfct
op_assign
l_int|NULL
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_ne
id|NF_DROP
op_logical_and
id|ct-&gt;helper
)paren
(brace
id|ret
op_assign
id|ct-&gt;helper
op_member_access_from_pointer
id|help
c_func
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.iph
comma
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|len
comma
id|ct
comma
id|ctinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Invalid */
id|nf_conntrack_put
c_func
(paren
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfct
)paren
suffix:semicolon
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfct
op_assign
l_int|NULL
suffix:semicolon
r_return
id|NF_ACCEPT
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|invert_tuplepr
r_int
id|invert_tuplepr
c_func
(paren
r_struct
id|ip_conntrack_tuple
op_star
id|inverse
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|orig
)paren
(brace
r_return
id|invert_tuple
c_func
(paren
id|inverse
comma
id|orig
comma
id|find_proto
c_func
(paren
id|orig-&gt;dst.protonum
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Add a related connection. */
DECL|function|ip_conntrack_expect_related
r_int
id|ip_conntrack_expect_related
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|related_to
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|tuple
)paren
(brace
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|related_to-&gt;expected.tuple
op_assign
op_star
id|tuple
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|related_to-&gt;expected.expectant
)paren
(brace
id|list_prepend
c_func
(paren
op_amp
id|expect_list
comma
op_amp
id|related_to-&gt;expected
)paren
suffix:semicolon
id|related_to-&gt;expected.expectant
op_assign
id|related_to
suffix:semicolon
)brace
r_else
(brace
id|IP_NF_ASSERT
c_func
(paren
id|list_inlist
c_func
(paren
op_amp
id|expect_list
comma
op_amp
id|related_to-&gt;expected
)paren
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|related_to-&gt;expected.expectant
op_eq
id|related_to
)paren
suffix:semicolon
)brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Alter reply tuple (maybe alter helper).  If it&squot;s already taken,&n;   return 0 and don&squot;t do alteration. */
DECL|function|ip_conntrack_alter_reply
r_int
id|ip_conntrack_alter_reply
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|conntrack
comma
r_const
r_struct
id|ip_conntrack_tuple
op_star
id|newreply
)paren
(brace
r_int
r_int
id|newindex
op_assign
id|hash_conntrack
c_func
(paren
id|newreply
)paren
suffix:semicolon
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__ip_conntrack_find
c_func
(paren
id|newreply
comma
id|conntrack
)paren
)paren
(brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;Altering reply tuple of %p to &quot;
comma
id|conntrack
)paren
suffix:semicolon
id|DUMP_TUPLE
c_func
(paren
id|newreply
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|hash_conntrack
c_func
(paren
op_amp
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple
)paren
)braket
comma
op_amp
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
)paren
suffix:semicolon
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
dot
id|tuple
op_assign
op_star
id|newreply
suffix:semicolon
id|list_prepend
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|newindex
)braket
comma
op_amp
id|conntrack-&gt;tuplehash
(braket
id|IP_CT_DIR_REPLY
)braket
)paren
suffix:semicolon
id|conntrack-&gt;helper
op_assign
id|LIST_FIND
c_func
(paren
op_amp
id|helpers
comma
id|helper_cmp
comma
r_struct
id|ip_conntrack_helper
op_star
comma
id|newreply
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ip_conntrack_helper_register
r_int
id|ip_conntrack_helper_register
c_func
(paren
r_struct
id|ip_conntrack_helper
op_star
id|me
)paren
(brace
id|MOD_INC_USE_COUNT
suffix:semicolon
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|list_prepend
c_func
(paren
op_amp
id|helpers
comma
id|me
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unhelp
r_static
r_inline
r_int
id|unhelp
c_func
(paren
r_struct
id|ip_conntrack_tuple_hash
op_star
id|i
comma
r_const
r_struct
id|ip_conntrack_helper
op_star
id|me
)paren
(brace
r_if
c_cond
(paren
id|i-&gt;ctrack-&gt;helper
op_eq
id|me
)paren
(brace
id|i-&gt;ctrack-&gt;helper
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Get rid of any expected. */
r_if
c_cond
(paren
id|i-&gt;ctrack-&gt;expected.expectant
)paren
(brace
id|IP_NF_ASSERT
c_func
(paren
id|i-&gt;ctrack-&gt;expected.expectant
op_eq
id|i-&gt;ctrack
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|expect_list
comma
op_amp
id|i-&gt;ctrack-&gt;expected
)paren
suffix:semicolon
id|i-&gt;ctrack-&gt;expected.expectant
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ip_conntrack_helper_unregister
r_void
id|ip_conntrack_helper_unregister
c_func
(paren
r_struct
id|ip_conntrack_helper
op_star
id|me
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
multiline_comment|/* Need write lock here, to delete helper. */
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|helpers
comma
id|me
)paren
suffix:semicolon
multiline_comment|/* Get rid of expecteds, set helpers to NULL. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ip_conntrack_htable_size
suffix:semicolon
id|i
op_increment
)paren
id|LIST_FIND_W
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|i
)braket
comma
id|unhelp
comma
r_struct
id|ip_conntrack_tuple_hash
op_star
comma
id|me
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
multiline_comment|/* Someone could be still looking at the helper in a bh. */
id|br_write_lock_bh
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
id|br_write_unlock_bh
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/* Refresh conntrack for this many jiffies: if noone calls this,&n;   conntrack will vanish with current skb. */
DECL|function|ip_ct_refresh
r_void
id|ip_ct_refresh
c_func
(paren
r_struct
id|ip_conntrack
op_star
id|ct
comma
r_int
r_int
id|extra_jiffies
)paren
(brace
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
multiline_comment|/* If this hasn&squot;t had a timer before, it&squot;s still being set up */
r_if
c_cond
(paren
id|ct-&gt;timeout.data
op_eq
l_int|0
)paren
(brace
id|ct-&gt;timeout.data
op_assign
(paren
r_int
r_int
)paren
id|ct
suffix:semicolon
id|ct-&gt;timeout.function
op_assign
id|death_by_timeout
suffix:semicolon
id|ct-&gt;timeout.expires
op_assign
id|jiffies
op_plus
id|extra_jiffies
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|ct-&gt;ct_general.use
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ct-&gt;timeout
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Need del_timer for race avoidance (may already be dying). */
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
id|ct-&gt;timeout
)paren
)paren
(brace
id|ct-&gt;timeout.expires
op_assign
id|jiffies
op_plus
id|extra_jiffies
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ct-&gt;timeout
)paren
suffix:semicolon
)brace
)brace
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Returns new sk_buff, or NULL */
r_struct
id|sk_buff
op_star
DECL|function|ip_ct_gather_frags
id|ip_ct_gather_frags
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|skb-&gt;sk
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
r_int
r_int
id|olddebug
op_assign
id|skb-&gt;nf_debug
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|sk
)paren
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
id|skb
op_assign
id|ip_defrag
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
r_if
c_cond
(paren
id|sk
)paren
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk
)paren
(brace
id|skb_set_owner_w
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|ip_send_check
c_func
(paren
id|skb-&gt;nh.iph
)paren
suffix:semicolon
id|skb-&gt;nfcache
op_or_assign
id|NFC_ALTERED
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
multiline_comment|/* Packet path as if nothing had happened. */
id|skb-&gt;nf_debug
op_assign
id|olddebug
suffix:semicolon
macro_line|#endif
r_return
id|skb
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|do_kill
id|do_kill
c_func
(paren
r_const
r_struct
id|ip_conntrack_tuple_hash
op_star
id|i
comma
r_int
(paren
op_star
id|kill
)paren
(paren
r_const
r_struct
id|ip_conntrack
op_star
id|i
comma
r_void
op_star
id|data
)paren
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|kill
c_func
(paren
id|i-&gt;ctrack
comma
id|data
)paren
suffix:semicolon
)brace
multiline_comment|/* Bring out ya dead! */
r_static
r_struct
id|ip_conntrack_tuple_hash
op_star
DECL|function|get_next_corpse
id|get_next_corpse
c_func
(paren
r_int
(paren
op_star
id|kill
)paren
(paren
r_const
r_struct
id|ip_conntrack
op_star
id|i
comma
r_void
op_star
id|data
)paren
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|ip_conntrack_tuple_hash
op_star
id|h
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|READ_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|h
op_logical_and
id|i
OL
id|ip_conntrack_htable_size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|h
op_assign
id|LIST_FIND
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|i
)braket
comma
id|do_kill
comma
r_struct
id|ip_conntrack_tuple_hash
op_star
comma
id|kill
comma
id|data
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|h
)paren
id|atomic_inc
c_func
(paren
op_amp
id|h-&gt;ctrack-&gt;ct_general.use
)paren
suffix:semicolon
id|READ_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_return
id|h
suffix:semicolon
)brace
r_void
DECL|function|ip_ct_selective_cleanup
id|ip_ct_selective_cleanup
c_func
(paren
r_int
(paren
op_star
id|kill
)paren
(paren
r_const
r_struct
id|ip_conntrack
op_star
id|i
comma
r_void
op_star
id|data
)paren
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|ip_conntrack_tuple_hash
op_star
id|h
suffix:semicolon
multiline_comment|/* This is order n^2, by the way. */
r_while
c_loop
(paren
(paren
id|h
op_assign
id|get_next_corpse
c_func
(paren
id|kill
comma
id|data
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Time to push up daises... */
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
id|h-&gt;ctrack-&gt;timeout
)paren
)paren
id|death_by_timeout
c_func
(paren
(paren
r_int
r_int
)paren
id|h-&gt;ctrack
)paren
suffix:semicolon
multiline_comment|/* ... else the timer will get him soon. */
id|ip_conntrack_put
c_func
(paren
id|h-&gt;ctrack
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Fast function for those who don&squot;t want to parse /proc (and I don&squot;t&n;   blame them). */
multiline_comment|/* Reversing the socket&squot;s dst/src point of view gives us the reply&n;   mapping. */
r_static
r_int
DECL|function|getorigdst
id|getorigdst
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|optval
comma
r_void
op_star
id|user
comma
r_int
op_star
id|len
)paren
(brace
r_struct
id|ip_conntrack_tuple_hash
op_star
id|h
suffix:semicolon
r_struct
id|ip_conntrack_tuple
id|tuple
op_assign
(brace
(brace
id|sk-&gt;rcv_saddr
comma
(brace
id|sk-&gt;sport
)brace
comma
l_int|0
)brace
comma
(brace
id|sk-&gt;daddr
comma
(brace
id|sk-&gt;dport
)brace
comma
id|IPPROTO_TCP
)brace
)brace
suffix:semicolon
multiline_comment|/* We only do TCP at the moment: is there a better way? */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|sk-&gt;prot-&gt;name
comma
l_string|&quot;TCP&quot;
)paren
op_ne
l_int|0
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;SO_ORIGINAL_DST: Not a TCP socket&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|len
op_ne
r_sizeof
(paren
r_struct
id|sockaddr_in
)paren
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;SO_ORIGINAL_DST: len %u not %u&bslash;n&quot;
comma
op_star
id|len
comma
r_sizeof
(paren
r_struct
id|sockaddr_in
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|h
op_assign
id|ip_conntrack_find_get
c_func
(paren
op_amp
id|tuple
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|h
)paren
(brace
r_struct
id|sockaddr_in
id|sin
suffix:semicolon
id|sin.sin_family
op_assign
id|AF_INET
suffix:semicolon
id|sin.sin_port
op_assign
id|h-&gt;ctrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.dst.u.tcp.port
suffix:semicolon
id|sin.sin_addr.s_addr
op_assign
id|h-&gt;ctrack-&gt;tuplehash
(braket
id|IP_CT_DIR_ORIGINAL
)braket
dot
id|tuple.dst.ip
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;SO_ORIGINAL_DST: %u.%u.%u.%u %u&bslash;n&quot;
comma
id|IP_PARTS
c_func
(paren
id|sin.sin_addr.s_addr
)paren
comma
id|ntohs
c_func
(paren
id|sin.sin_port
)paren
)paren
suffix:semicolon
id|ip_conntrack_put
c_func
(paren
id|h-&gt;ctrack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|user
comma
op_amp
id|sin
comma
r_sizeof
(paren
id|sin
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;SO_ORIGINAL_DST: Can&squot;t find %u.%u.%u.%u/%u-%u.%u.%u.%u/%u.&bslash;n&quot;
comma
id|IP_PARTS
c_func
(paren
id|tuple.src.ip
)paren
comma
id|ntohs
c_func
(paren
id|tuple.src.u.tcp.port
)paren
comma
id|IP_PARTS
c_func
(paren
id|tuple.dst.ip
)paren
comma
id|ntohs
c_func
(paren
id|tuple.dst.u.tcp.port
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
DECL|variable|so_getorigdst
r_static
r_struct
id|nf_sockopt_ops
id|so_getorigdst
op_assign
(brace
(brace
l_int|NULL
comma
l_int|NULL
)brace
comma
id|PF_INET
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
multiline_comment|/* Setsockopts */
id|SO_ORIGINAL_DST
comma
id|SO_ORIGINAL_DST
op_plus
l_int|1
comma
op_amp
id|getorigdst
comma
l_int|0
comma
l_int|NULL
)brace
suffix:semicolon
DECL|macro|NET_IP_CONNTRACK_MAX
mdefine_line|#define NET_IP_CONNTRACK_MAX 2089
DECL|macro|NET_IP_CONNTRACK_MAX_NAME
mdefine_line|#define NET_IP_CONNTRACK_MAX_NAME &quot;ip_conntrack_max&quot;
DECL|variable|ip_conntrack_sysctl_header
r_static
r_struct
id|ctl_table_header
op_star
id|ip_conntrack_sysctl_header
suffix:semicolon
DECL|variable|ip_conntrack_table
r_static
id|ctl_table
id|ip_conntrack_table
(braket
)braket
op_assign
(brace
(brace
id|NET_IP_CONNTRACK_MAX
comma
id|NET_IP_CONNTRACK_MAX_NAME
comma
op_amp
id|ip_conntrack_max
comma
r_sizeof
(paren
id|ip_conntrack_max
)paren
comma
l_int|0644
comma
l_int|NULL
comma
id|proc_dointvec
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|ip_conntrack_dir_table
r_static
id|ctl_table
id|ip_conntrack_dir_table
(braket
)braket
op_assign
(brace
(brace
id|NET_IPV4
comma
l_string|&quot;ipv4&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|ip_conntrack_table
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|ip_conntrack_root_table
r_static
id|ctl_table
id|ip_conntrack_root_table
(braket
)braket
op_assign
(brace
(brace
id|CTL_NET
comma
l_string|&quot;net&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|ip_conntrack_dir_table
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|function|kill_all
r_static
r_int
id|kill_all
c_func
(paren
r_const
r_struct
id|ip_conntrack
op_star
id|i
comma
r_void
op_star
id|data
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Mishearing the voices in his head, our hero wonders how he&squot;s&n;   supposed to kill the mall. */
DECL|function|ip_conntrack_cleanup
r_void
id|ip_conntrack_cleanup
c_func
(paren
r_void
)paren
(brace
id|unregister_sysctl_table
c_func
(paren
id|ip_conntrack_sysctl_header
)paren
suffix:semicolon
id|ip_ct_selective_cleanup
c_func
(paren
id|kill_all
comma
l_int|NULL
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|ip_conntrack_hash
)paren
suffix:semicolon
id|nf_unregister_sockopt
c_func
(paren
op_amp
id|so_getorigdst
)paren
suffix:semicolon
)brace
DECL|function|ip_conntrack_init
r_int
id|__init
id|ip_conntrack_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Idea from tcp.c: use 1/16384 of memory.  On i386: 32MB&n;&t; * machine has 256 buckets.  1GB machine has 8192 buckets. */
id|ip_conntrack_htable_size
op_assign
(paren
(paren
(paren
id|num_physpages
op_lshift
id|PAGE_SHIFT
)paren
op_div
l_int|16384
)paren
op_div
r_sizeof
(paren
r_struct
id|list_head
)paren
)paren
suffix:semicolon
id|ip_conntrack_max
op_assign
l_int|8
op_star
id|ip_conntrack_htable_size
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ip_conntrack (%u buckets, %d max)&bslash;n&quot;
comma
id|ip_conntrack_htable_size
comma
id|ip_conntrack_max
)paren
suffix:semicolon
id|ret
op_assign
id|nf_register_sockopt
c_func
(paren
op_amp
id|so_getorigdst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|ip_conntrack_hash
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|list_head
)paren
op_star
id|ip_conntrack_htable_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ip_conntrack_hash
)paren
(brace
id|nf_unregister_sockopt
c_func
(paren
op_amp
id|so_getorigdst
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t NEED lock here, but good form anyway. */
id|WRITE_LOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
multiline_comment|/* Sew in builtin protocols. */
id|list_append
c_func
(paren
op_amp
id|protocol_list
comma
op_amp
id|ip_conntrack_protocol_tcp
)paren
suffix:semicolon
id|list_append
c_func
(paren
op_amp
id|protocol_list
comma
op_amp
id|ip_conntrack_protocol_udp
)paren
suffix:semicolon
id|list_append
c_func
(paren
op_amp
id|protocol_list
comma
op_amp
id|ip_conntrack_protocol_icmp
)paren
suffix:semicolon
id|WRITE_UNLOCK
c_func
(paren
op_amp
id|ip_conntrack_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ip_conntrack_htable_size
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ip_conntrack_hash
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* This is fucking braindead.  There is NO WAY of doing this without&n;   the CONFIG_SYSCTL unless you don&squot;t want to detect errors.&n;   Grrr... --RR */
macro_line|#ifdef CONFIG_SYSCTL
id|ip_conntrack_sysctl_header
op_assign
id|register_sysctl_table
c_func
(paren
id|ip_conntrack_root_table
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip_conntrack_sysctl_header
op_eq
l_int|NULL
)paren
(brace
id|vfree
c_func
(paren
id|ip_conntrack_hash
)paren
suffix:semicolon
id|nf_unregister_sockopt
c_func
(paren
op_amp
id|so_getorigdst
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
macro_line|#endif /*CONFIG_SYSCTL*/
id|ret
op_assign
id|ip_conntrack_protocol_tcp_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|unregister_sysctl_table
c_func
(paren
id|ip_conntrack_sysctl_header
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|ip_conntrack_hash
)paren
suffix:semicolon
id|nf_unregister_sockopt
c_func
(paren
op_amp
id|so_getorigdst
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
eof
