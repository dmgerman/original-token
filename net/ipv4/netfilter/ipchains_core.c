multiline_comment|/* Minor modifications to fit on compatibility framework:&n;   Rusty.Russell@rustcorp.com.au&n;*/
multiline_comment|/*&n; * This code is heavily based on the code on the old ip_fw.c code; see below for&n; * copyrights and attributions of the old code.  This code is basically GPL.&n; *&n; * 15-Aug-1997: Major changes to allow graphs for firewall rules.&n; *              Paul Russell &lt;Paul.Russell@rustcorp.com.au&gt; and&n; *&t;&t;Michael Neuling &lt;Michael.Neuling@rustcorp.com.au&gt;&n; * 24-Aug-1997: Generalised protocol handling (not just TCP/UDP/ICMP).&n; *              Added explicit RETURN from chains.&n; *              Removed TOS mangling (done in ipchains 1.0.1).&n; *              Fixed read &amp; reset bug by reworking proc handling.&n; *              Paul Russell &lt;Paul.Russell@rustcorp.com.au&gt;&n; * 28-Sep-1997: Added packet marking for net sched code.&n; *              Removed fw_via comparisons: all done on device name now,&n; *              similar to changes in ip_fw.c in DaveM&squot;s CVS970924 tree.&n; *              Paul Russell &lt;Paul.Russell@rustcorp.com.au&gt;&n; * 2-Nov-1997:  Moved types across to __u16, etc.&n; *              Added inverse flags.&n; *              Fixed fragment bug (in args to port_match).&n; *              Changed mark to only one flag (MARKABS).&n; * 21-Nov-1997: Added ability to test ICMP code.&n; * 19-Jan-1998: Added wildcard interfaces.&n; * 6-Feb-1998:  Merged 2.0 and 2.1 versions.&n; *              Initialised ip_masq for 2.0.x version.&n; *              Added explicit NETLINK option for 2.1.x version.&n; *              Added packet and byte counters for policy matches.&n; * 26-Feb-1998: Fixed race conditions, added SMP support.&n; * 18-Mar-1998: Fix SMP, fix race condition fix.&n; * 1-May-1998:  Remove caching of device pointer.&n; * 12-May-1998: Allow tiny fragment case for TCP/UDP.&n; * 15-May-1998: Treat short packets as fragments, don&squot;t just block.&n; * 3-Jan-1999:  Fixed serious procfs security hole -- users should never&n; *              be allowed to view the chains!&n; *              Marc Santoro &lt;ultima@snicker.emoti.com&gt;&n; * 29-Jan-1999: Locally generated bogus IPs dealt with, rather than crash&n; *              during dump_packet. --RR.&n; * 19-May-1999: Star Wars: The Phantom Menace opened.  Rule num&n; *&t;&t;printed in log (modified from Michael Hasenstein&squot;s patch).&n; *&t;&t;Added SYN in log message. --RR&n; * 23-Jul-1999: Fixed small fragment security exposure opened on 15-May-1998.&n; *              John McDonald &lt;jm@dataprotect.com&gt;&n; *              Thomas Lopatic &lt;tl@dataprotect.com&gt;&n; */
multiline_comment|/*&n; *&n; * The origina Linux port was done Alan Cox, with changes/fixes from&n; * Pauline Middlelink, Jos Vos, Thomas Quinot, Wouter Gadeyne, Juan&n; * Jose Ciarlante, Bernd Eckenfels, Keith Owens and others.&n; *&n; * Copyright from the original FreeBSD version follows:&n; *&n; * Copyright (c) 1993 Daniel Boulet&n; * Copyright (c) 1994 Ugen J.S.Antsilevich&n; *&n; * Redistribution and use in source forms, with and without modification,&n; * are permitted provided that this entire comment appears intact.&n; *&n; * Redistribution in binary form may occur without any restrictions.&n; * Obviously, it would be nice if you gave credit where credit is due&n; * but requiring it would be too onerous.&n; *&n; * This software is provided ``AS IS&squot;&squot; without any warranties of any kind.  */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/icmp.h&gt;
macro_line|#include &lt;linux/udp.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;linux/netlink.h&gt;
macro_line|#include &lt;linux/netfilter.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/compat_firewall.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/ipchains_core.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
multiline_comment|/* Understanding locking in this code: (thanks to Alan Cox for using&n; * little words to explain this to me). -- PR&n; *&n; * In UP, there can be two packets traversing the chains:&n; * 1) A packet from the current userspace context&n; * 2) A packet off the bh handlers (timer or net).&n; *&n; * For SMP (kernel v2.1+), multiply this by # CPUs.&n; *&n; * [Note that this in not correct for 2.2 - because the socket code always&n; *  uses lock_kernel() to serialize, and bottom halves (timers and net_bhs)&n; *  only run on one CPU at a time.  This will probably change for 2.3.&n; *  It is still good to use spinlocks because that avoids the global cli()&n; *  for updating the tables, which is rather costly in SMP kernels -AK]&n; *&n; * This means counters and backchains can get corrupted if no precautions&n; * are taken.&n; *&n; * To actually alter a chain on UP, we need only do a cli(), as this will&n; * stop a bh handler firing, as we are in the current userspace context&n; * (coming from a setsockopt()).&n; *&n; * On SMP, we need a write_lock_irqsave(), which is a simple cli() in&n; * UP.&n; *&n; * For backchains and counters, we use an array, indexed by&n; * [cpu_number_map[smp_processor_id()]*2 + !in_interrupt()]; the array is of&n; * size [smp_num_cpus*2].  For v2.0, smp_num_cpus is effectively 1.  So,&n; * confident of uniqueness, we modify counters even though we only&n; * have a read lock (to read the counters, you need a write lock,&n; * though).  */
multiline_comment|/* Why I didn&squot;t use straight locking... -- PR&n; *&n; * The backchains can be separated out of the ip_chains structure, and&n; * allocated as needed inside ip_fw_check().&n; *&n; * The counters, however, can&squot;t.  Trying to lock these means blocking&n; * interrupts every time we want to access them.  This would suck HARD&n; * performance-wise.  Not locking them leads to possible corruption,&n; * made worse on 32-bit machines (counters are 64-bit).  */
multiline_comment|/*#define DEBUG_IP_FIREWALL*/
multiline_comment|/*#define DEBUG_ALLOW_ALL*/
multiline_comment|/* Useful for remote debugging */
multiline_comment|/*#define DEBUG_IP_FIREWALL_USER*/
multiline_comment|/*#define DEBUG_IP_FIREWALL_LOCKING*/
macro_line|#if defined(CONFIG_NETLINK_DEV) || defined(CONFIG_NETLINK_DEV_MODULE)
DECL|variable|ipfwsk
r_static
r_struct
id|sock
op_star
id|ipfwsk
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SMP
DECL|macro|SLOT_NUMBER
mdefine_line|#define SLOT_NUMBER() (cpu_number_map(smp_processor_id())*2 + !in_interrupt())
macro_line|#else /* !SMP */
DECL|macro|SLOT_NUMBER
mdefine_line|#define SLOT_NUMBER() (!in_interrupt())
macro_line|#endif /* CONFIG_SMP */
DECL|macro|NUM_SLOTS
mdefine_line|#define NUM_SLOTS (smp_num_cpus*2)
DECL|macro|SIZEOF_STRUCT_IP_CHAIN
mdefine_line|#define SIZEOF_STRUCT_IP_CHAIN (sizeof(struct ip_chain) &bslash;&n;&t;&t;&t;&t;+ NUM_SLOTS*sizeof(struct ip_reent))
DECL|macro|SIZEOF_STRUCT_IP_FW_KERNEL
mdefine_line|#define SIZEOF_STRUCT_IP_FW_KERNEL (sizeof(struct ip_fwkernel) &bslash;&n;&t;&t;&t;&t;    + NUM_SLOTS*sizeof(struct ip_counters))
macro_line|#ifdef DEBUG_IP_FIREWALL_LOCKING
DECL|variable|fwc_rlocks
DECL|variable|fwc_wlocks
r_static
r_int
r_int
id|fwc_rlocks
comma
id|fwc_wlocks
suffix:semicolon
DECL|macro|FWC_DEBUG_LOCK
mdefine_line|#define FWC_DEBUG_LOCK(d)&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;FWC_DONT_HAVE_LOCK(d);&t;&t;&t;&bslash;&n;&t;d |= (1 &lt;&lt; SLOT_NUMBER());&t;&t;&bslash;&n;} while (0)
DECL|macro|FWC_DEBUG_UNLOCK
mdefine_line|#define FWC_DEBUG_UNLOCK(d)&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;FWC_HAVE_LOCK(d);&t;&t;&t;&bslash;&n;&t;d &amp;= ~(1 &lt;&lt; SLOT_NUMBER());&t;&t;&bslash;&n;} while (0)
DECL|macro|FWC_DONT_HAVE_LOCK
mdefine_line|#define FWC_DONT_HAVE_LOCK(d)&t;&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if ((d) &amp; (1 &lt;&lt; SLOT_NUMBER()))&t;&t;&t;&t;&bslash;&n;&t;&t;printk(&quot;%s:%i: Got lock on %i already!&bslash;n&quot;, &t;&bslash;&n;&t;&t;       __FILE__, __LINE__, SLOT_NUMBER());&t;&bslash;&n;} while(0)
DECL|macro|FWC_HAVE_LOCK
mdefine_line|#define FWC_HAVE_LOCK(d)&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (!((d) &amp; (1 &lt;&lt; SLOT_NUMBER())))&t;&t;&bslash;&n;&t;printk(&quot;%s:%i:No lock on %i!&bslash;n&quot;, &t;&t;&bslash;&n;&t;       __FILE__, __LINE__, SLOT_NUMBER());&t;&bslash;&n;} while (0)
macro_line|#else
DECL|macro|FWC_DEBUG_LOCK
mdefine_line|#define FWC_DEBUG_LOCK(d) do { } while(0)
DECL|macro|FWC_DEBUG_UNLOCK
mdefine_line|#define FWC_DEBUG_UNLOCK(d) do { } while(0)
DECL|macro|FWC_DONT_HAVE_LOCK
mdefine_line|#define FWC_DONT_HAVE_LOCK(d) do { } while(0)
DECL|macro|FWC_HAVE_LOCK
mdefine_line|#define FWC_HAVE_LOCK(d) do { } while(0)
macro_line|#endif /*DEBUG_IP_FIRWALL_LOCKING*/
DECL|macro|FWC_READ_LOCK
mdefine_line|#define FWC_READ_LOCK(l) do { FWC_DEBUG_LOCK(fwc_rlocks); read_lock(l); } while (0)
DECL|macro|FWC_WRITE_LOCK
mdefine_line|#define FWC_WRITE_LOCK(l) do { FWC_DEBUG_LOCK(fwc_wlocks); write_lock(l); } while (0)
DECL|macro|FWC_READ_LOCK_IRQ
mdefine_line|#define FWC_READ_LOCK_IRQ(l,f) do { FWC_DEBUG_LOCK(fwc_rlocks); read_lock_irqsave(l,f); } while (0)
DECL|macro|FWC_WRITE_LOCK_IRQ
mdefine_line|#define FWC_WRITE_LOCK_IRQ(l,f) do { FWC_DEBUG_LOCK(fwc_wlocks); write_lock_irqsave(l,f); } while (0)
DECL|macro|FWC_READ_UNLOCK
mdefine_line|#define FWC_READ_UNLOCK(l) do { FWC_DEBUG_UNLOCK(fwc_rlocks); read_unlock(l); } while (0)
DECL|macro|FWC_WRITE_UNLOCK
mdefine_line|#define FWC_WRITE_UNLOCK(l) do { FWC_DEBUG_UNLOCK(fwc_wlocks); write_unlock(l); } while (0)
DECL|macro|FWC_READ_UNLOCK_IRQ
mdefine_line|#define FWC_READ_UNLOCK_IRQ(l,f) do { FWC_DEBUG_UNLOCK(fwc_rlocks); read_unlock_irqrestore(l,f); } while (0)
DECL|macro|FWC_WRITE_UNLOCK_IRQ
mdefine_line|#define FWC_WRITE_UNLOCK_IRQ(l,f) do { FWC_DEBUG_UNLOCK(fwc_wlocks); write_unlock_irqrestore(l,f); } while (0)
r_struct
id|ip_chain
suffix:semicolon
DECL|struct|ip_counters
r_struct
id|ip_counters
(brace
DECL|member|pcnt
DECL|member|bcnt
id|__u64
id|pcnt
comma
id|bcnt
suffix:semicolon
multiline_comment|/* Packet and byte counters */
)brace
suffix:semicolon
DECL|struct|ip_fwkernel
r_struct
id|ip_fwkernel
(brace
DECL|member|ipfw
r_struct
id|ip_fw
id|ipfw
suffix:semicolon
DECL|member|next
r_struct
id|ip_fwkernel
op_star
id|next
suffix:semicolon
multiline_comment|/* where to go next if current&n;&t;&t;&t;&t;&t; * rule doesn&squot;t match */
DECL|member|branch
r_struct
id|ip_chain
op_star
id|branch
suffix:semicolon
multiline_comment|/* which branch to jump to if&n;&t;&t;&t;&t;&t; * current rule matches */
DECL|member|simplebranch
r_int
id|simplebranch
suffix:semicolon
multiline_comment|/* Use this if branch == NULL */
DECL|member|counters
r_struct
id|ip_counters
id|counters
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Actually several of these */
)brace
suffix:semicolon
DECL|struct|ip_reent
r_struct
id|ip_reent
(brace
DECL|member|prevchain
r_struct
id|ip_chain
op_star
id|prevchain
suffix:semicolon
multiline_comment|/* Pointer to referencing chain */
DECL|member|prevrule
r_struct
id|ip_fwkernel
op_star
id|prevrule
suffix:semicolon
multiline_comment|/* Pointer to referencing rule */
DECL|member|counters
r_struct
id|ip_counters
id|counters
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|ip_chain
r_struct
id|ip_chain
(brace
DECL|member|label
id|ip_chainlabel
id|label
suffix:semicolon
multiline_comment|/* Defines the label for each block */
DECL|member|next
r_struct
id|ip_chain
op_star
id|next
suffix:semicolon
multiline_comment|/* Pointer to next block */
DECL|member|chain
r_struct
id|ip_fwkernel
op_star
id|chain
suffix:semicolon
multiline_comment|/* Pointer to first rule in block */
DECL|member|refcount
id|__u32
id|refcount
suffix:semicolon
multiline_comment|/* Number of refernces to block */
DECL|member|policy
r_int
id|policy
suffix:semicolon
multiline_comment|/* Default rule for chain.  Only *&n;&t;&t;&t;&t;     * used in built in chains */
DECL|member|reent
r_struct
id|ip_reent
id|reent
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Actually several of these */
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Implement IP packet firewall&n; */
macro_line|#ifdef DEBUG_IP_FIREWALL
DECL|macro|dprintf
mdefine_line|#define dprintf(format, args...)  printk(format , ## args)
macro_line|#else
DECL|macro|dprintf
mdefine_line|#define dprintf(format, args...)
macro_line|#endif
macro_line|#ifdef DEBUG_IP_FIREWALL_USER
DECL|macro|duprintf
mdefine_line|#define duprintf(format, args...) printk(format , ## args)
macro_line|#else
DECL|macro|duprintf
mdefine_line|#define duprintf(format, args...)
macro_line|#endif
multiline_comment|/* Lock around ip_fw_chains linked list structure */
DECL|variable|ip_fw_lock
id|rwlock_t
id|ip_fw_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Head of linked list of fw rules */
DECL|variable|ip_fw_chains
r_static
r_struct
id|ip_chain
op_star
id|ip_fw_chains
suffix:semicolon
DECL|macro|IP_FW_INPUT_CHAIN
mdefine_line|#define IP_FW_INPUT_CHAIN ip_fw_chains
DECL|macro|IP_FW_FORWARD_CHAIN
mdefine_line|#define IP_FW_FORWARD_CHAIN (ip_fw_chains-&gt;next)
DECL|macro|IP_FW_OUTPUT_CHAIN
mdefine_line|#define IP_FW_OUTPUT_CHAIN (ip_fw_chains-&gt;next-&gt;next)
multiline_comment|/* Returns 1 if the port is matched by the range, 0 otherwise */
DECL|function|port_match
r_extern
r_inline
r_int
id|port_match
c_func
(paren
id|__u16
id|min
comma
id|__u16
id|max
comma
id|__u16
id|port
comma
r_int
id|frag
comma
r_int
id|invert
)paren
(brace
r_if
c_cond
(paren
id|frag
)paren
multiline_comment|/* Fragments fail ANY port test. */
r_return
(paren
id|min
op_eq
l_int|0
op_logical_and
id|max
op_eq
l_int|0xFFFF
)paren
suffix:semicolon
r_else
r_return
(paren
id|port
op_ge
id|min
op_logical_and
id|port
op_le
id|max
)paren
op_xor
id|invert
suffix:semicolon
)brace
multiline_comment|/* Returns whether matches rule or not. */
DECL|function|ip_rule_match
r_static
r_int
id|ip_rule_match
c_func
(paren
r_struct
id|ip_fwkernel
op_star
id|f
comma
r_const
r_char
op_star
id|ifname
comma
r_struct
id|iphdr
op_star
id|ip
comma
r_char
id|tcpsyn
comma
id|__u16
id|src_port
comma
id|__u16
id|dst_port
comma
r_char
id|isfrag
)paren
(brace
DECL|macro|FWINV
mdefine_line|#define FWINV(bool,invflg) ((bool) ^ !!(f-&gt;ipfw.fw_invflg &amp; invflg))
multiline_comment|/*&n;&t; *&t;This is a bit simpler as we don&squot;t have to walk&n;&t; *&t;an interface chain as you do in BSD - same logic&n;&t; *&t;however.&n;&t; */
r_if
c_cond
(paren
id|FWINV
c_func
(paren
(paren
id|ip-&gt;saddr
op_amp
id|f-&gt;ipfw.fw_smsk.s_addr
)paren
op_ne
id|f-&gt;ipfw.fw_src.s_addr
comma
id|IP_FW_INV_SRCIP
)paren
op_logical_or
id|FWINV
c_func
(paren
(paren
id|ip-&gt;daddr
op_amp
id|f-&gt;ipfw.fw_dmsk.s_addr
)paren
op_ne
id|f-&gt;ipfw.fw_dst.s_addr
comma
id|IP_FW_INV_DSTIP
)paren
)paren
(brace
id|dprintf
c_func
(paren
l_string|&quot;Source or dest mismatch.&bslash;n&quot;
)paren
suffix:semicolon
id|dprintf
c_func
(paren
l_string|&quot;SRC: %u. Mask: %u. Target: %u.%s&bslash;n&quot;
comma
id|ip-&gt;saddr
comma
id|f-&gt;ipfw.fw_smsk.s_addr
comma
id|f-&gt;ipfw.fw_src.s_addr
comma
id|f-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_SRCIP
ques
c_cond
l_string|&quot; (INV)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|dprintf
c_func
(paren
l_string|&quot;DST: %u. Mask: %u. Target: %u.%s&bslash;n&quot;
comma
id|ip-&gt;daddr
comma
id|f-&gt;ipfw.fw_dmsk.s_addr
comma
id|f-&gt;ipfw.fw_dst.s_addr
comma
id|f-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_DSTIP
ques
c_cond
l_string|&quot; (INV)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Look for a VIA device match&n;&t; */
r_if
c_cond
(paren
id|f-&gt;ipfw.fw_flg
op_amp
id|IP_FW_F_WILDIF
)paren
(brace
r_if
c_cond
(paren
id|FWINV
c_func
(paren
id|strncmp
c_func
(paren
id|ifname
comma
id|f-&gt;ipfw.fw_vianame
comma
id|strlen
c_func
(paren
id|f-&gt;ipfw.fw_vianame
)paren
)paren
op_ne
l_int|0
comma
id|IP_FW_INV_VIA
)paren
)paren
(brace
id|dprintf
c_func
(paren
l_string|&quot;Wildcard interface mismatch.%s&bslash;n&quot;
comma
id|f-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_VIA
ques
c_cond
l_string|&quot; (INV)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Mismatch */
)brace
)brace
r_else
r_if
c_cond
(paren
id|FWINV
c_func
(paren
id|strcmp
c_func
(paren
id|ifname
comma
id|f-&gt;ipfw.fw_vianame
)paren
op_ne
l_int|0
comma
id|IP_FW_INV_VIA
)paren
)paren
(brace
id|dprintf
c_func
(paren
l_string|&quot;Interface name does not match.%s&bslash;n&quot;
comma
id|f-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_VIA
ques
c_cond
l_string|&quot; (INV)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Mismatch */
)brace
multiline_comment|/*&n;&t; *&t;Ok the chain addresses match.&n;&t; */
multiline_comment|/* If we have a fragment rule but the packet is not a fragment&n;&t; * the we return zero */
r_if
c_cond
(paren
id|FWINV
c_func
(paren
(paren
id|f-&gt;ipfw.fw_flg
op_amp
id|IP_FW_F_FRAG
)paren
op_logical_and
op_logical_neg
id|isfrag
comma
id|IP_FW_INV_FRAG
)paren
)paren
(brace
id|dprintf
c_func
(paren
l_string|&quot;Fragment rule but not fragment.%s&bslash;n&quot;
comma
id|f-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_FRAG
ques
c_cond
l_string|&quot; (INV)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Fragment NEVER passes a SYN test, even an inverted one. */
r_if
c_cond
(paren
id|FWINV
c_func
(paren
(paren
id|f-&gt;ipfw.fw_flg
op_amp
id|IP_FW_F_TCPSYN
)paren
op_logical_and
op_logical_neg
id|tcpsyn
comma
id|IP_FW_INV_SYN
)paren
op_logical_or
(paren
id|isfrag
op_logical_and
(paren
id|f-&gt;ipfw.fw_flg
op_amp
id|IP_FW_F_TCPSYN
)paren
)paren
)paren
(brace
id|dprintf
c_func
(paren
l_string|&quot;Rule requires SYN and packet has no SYN.%s&bslash;n&quot;
comma
id|f-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_SYN
ques
c_cond
l_string|&quot; (INV)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|f-&gt;ipfw.fw_proto
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Specific firewall - packet&squot;s protocol&n;&t;&t; *&t;must match firewall&squot;s.&n;&t;&t; */
r_if
c_cond
(paren
id|FWINV
c_func
(paren
id|ip-&gt;protocol
op_ne
id|f-&gt;ipfw.fw_proto
comma
id|IP_FW_INV_PROTO
)paren
)paren
(brace
id|dprintf
c_func
(paren
l_string|&quot;Packet protocol %hi does not match %hi.%s&bslash;n&quot;
comma
id|ip-&gt;protocol
comma
id|f-&gt;ipfw.fw_proto
comma
id|f-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_PROTO
ques
c_cond
l_string|&quot; (INV)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* For non TCP/UDP/ICMP, port range is max anyway. */
r_if
c_cond
(paren
op_logical_neg
id|port_match
c_func
(paren
id|f-&gt;ipfw.fw_spts
(braket
l_int|0
)braket
comma
id|f-&gt;ipfw.fw_spts
(braket
l_int|1
)braket
comma
id|src_port
comma
id|isfrag
comma
op_logical_neg
op_logical_neg
(paren
id|f-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_SRCPT
)paren
)paren
op_logical_or
op_logical_neg
id|port_match
c_func
(paren
id|f-&gt;ipfw.fw_dpts
(braket
l_int|0
)braket
comma
id|f-&gt;ipfw.fw_dpts
(braket
l_int|1
)braket
comma
id|dst_port
comma
id|isfrag
comma
op_logical_neg
op_logical_neg
(paren
id|f-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_DSTPT
)paren
)paren
)paren
(brace
id|dprintf
c_func
(paren
l_string|&quot;Port match failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|dprintf
c_func
(paren
l_string|&quot;Match succeeded.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|branchname
r_static
r_const
r_char
op_star
id|branchname
c_func
(paren
r_struct
id|ip_chain
op_star
id|branch
comma
r_int
id|simplebranch
)paren
(brace
r_if
c_cond
(paren
id|branch
)paren
r_return
id|branch-&gt;label
suffix:semicolon
r_switch
c_cond
(paren
id|simplebranch
)paren
(brace
r_case
id|FW_BLOCK
suffix:colon
r_return
id|IP_FW_LABEL_BLOCK
suffix:semicolon
r_case
id|FW_ACCEPT
suffix:colon
r_return
id|IP_FW_LABEL_ACCEPT
suffix:semicolon
r_case
id|FW_REJECT
suffix:colon
r_return
id|IP_FW_LABEL_REJECT
suffix:semicolon
r_case
id|FW_REDIRECT
suffix:colon
r_return
id|IP_FW_LABEL_REDIRECT
suffix:semicolon
r_case
id|FW_MASQUERADE
suffix:colon
r_return
id|IP_FW_LABEL_MASQUERADE
suffix:semicolon
r_case
id|FW_SKIP
suffix:colon
r_return
l_string|&quot;-&quot;
suffix:semicolon
r_case
id|FW_SKIP
op_plus
l_int|1
suffix:colon
r_return
id|IP_FW_LABEL_RETURN
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;UNKNOWN&quot;
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * VERY ugly piece of code which actually&n; * makes kernel printf for matching packets...&n; */
DECL|function|dump_packet
r_static
r_void
id|dump_packet
c_func
(paren
r_const
r_struct
id|iphdr
op_star
id|ip
comma
r_const
r_char
op_star
id|ifname
comma
r_struct
id|ip_fwkernel
op_star
id|f
comma
r_const
id|ip_chainlabel
id|chainlabel
comma
id|__u16
id|src_port
comma
id|__u16
id|dst_port
comma
r_int
r_int
id|count
comma
r_int
id|syn
)paren
(brace
id|__u32
op_star
id|opt
op_assign
(paren
id|__u32
op_star
)paren
(paren
id|ip
op_plus
l_int|1
)paren
suffix:semicolon
r_int
id|opti
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Packet log: %s &quot;
comma
id|chainlabel
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s &quot;
comma
id|branchname
c_func
(paren
id|f-&gt;branch
comma
id|f-&gt;simplebranch
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;simplebranch
op_eq
id|FW_REDIRECT
)paren
id|printk
c_func
(paren
l_string|&quot;%d &quot;
comma
id|f-&gt;ipfw.fw_redirpt
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s PROTO=%d %u.%u.%u.%u:%hu %u.%u.%u.%u:%hu&quot;
l_string|&quot; L=%hu S=0x%2.2hX I=%hu F=0x%4.4hX T=%hu&quot;
comma
id|ifname
comma
id|ip-&gt;protocol
comma
id|NIPQUAD
c_func
(paren
id|ip-&gt;saddr
)paren
comma
id|src_port
comma
id|NIPQUAD
c_func
(paren
id|ip-&gt;daddr
)paren
comma
id|dst_port
comma
id|ntohs
c_func
(paren
id|ip-&gt;tot_len
)paren
comma
id|ip-&gt;tos
comma
id|ntohs
c_func
(paren
id|ip-&gt;id
)paren
comma
id|ntohs
c_func
(paren
id|ip-&gt;frag_off
)paren
comma
id|ip-&gt;ttl
)paren
suffix:semicolon
r_for
c_loop
(paren
id|opti
op_assign
l_int|0
suffix:semicolon
id|opti
OL
(paren
id|ip-&gt;ihl
op_minus
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_div
l_int|4
)paren
suffix:semicolon
id|opti
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; O=0x%8.8X&quot;
comma
op_star
id|opt
op_increment
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %s(#%d)&bslash;n&quot;
comma
id|syn
ques
c_cond
l_string|&quot;SYN &quot;
suffix:colon
multiline_comment|/* &quot;PENANCE&quot; */
l_string|&quot;&quot;
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* function for checking chain labels for user space. */
DECL|function|check_label
r_static
r_int
id|check_label
c_func
(paren
id|ip_chainlabel
id|label
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
multiline_comment|/* strlen must be &lt; IP_FW_MAX_LABEL_LENGTH. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IP_FW_MAX_LABEL_LENGTH
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|label
(braket
id|i
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&t;This function returns a pointer to the first chain with a label&n; *&t;that matches the one given. */
DECL|function|find_label
r_static
r_struct
id|ip_chain
op_star
id|find_label
c_func
(paren
id|ip_chainlabel
id|label
)paren
(brace
r_struct
id|ip_chain
op_star
id|tmp
suffix:semicolon
id|FWC_HAVE_LOCK
c_func
(paren
id|fwc_rlocks
op_or
id|fwc_wlocks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|ip_fw_chains
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|tmp-&gt;label
comma
id|label
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
multiline_comment|/* This function returns a boolean which when true sets answer to one&n;   of the FW_*. */
DECL|function|find_special
r_static
r_int
id|find_special
c_func
(paren
id|ip_chainlabel
id|label
comma
r_int
op_star
id|answer
)paren
(brace
r_if
c_cond
(paren
id|label
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
op_star
id|answer
op_assign
id|FW_SKIP
suffix:semicolon
multiline_comment|/* =&gt; pass-through rule */
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|label
comma
id|IP_FW_LABEL_ACCEPT
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|answer
op_assign
id|FW_ACCEPT
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|label
comma
id|IP_FW_LABEL_BLOCK
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|answer
op_assign
id|FW_BLOCK
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|label
comma
id|IP_FW_LABEL_REJECT
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|answer
op_assign
id|FW_REJECT
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|label
comma
id|IP_FW_LABEL_REDIRECT
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|answer
op_assign
id|FW_REDIRECT
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|label
comma
id|IP_FW_LABEL_MASQUERADE
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|answer
op_assign
id|FW_MASQUERADE
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|label
comma
id|IP_FW_LABEL_RETURN
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|answer
op_assign
id|FW_SKIP
op_plus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* This function cleans up the prevchain and prevrule.  If the verbose&n; * flag is set then he names of the chains will be printed as it&n; * cleans up.  */
DECL|function|cleanup
r_static
r_void
id|cleanup
c_func
(paren
r_struct
id|ip_chain
op_star
id|chain
comma
r_const
r_int
id|verbose
comma
r_int
r_int
id|slot
)paren
(brace
r_struct
id|ip_chain
op_star
id|tmpchain
op_assign
id|chain-&gt;reent
(braket
id|slot
)braket
dot
id|prevchain
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Chain backtrace: &quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tmpchain
)paren
(brace
r_if
c_cond
(paren
id|verbose
)paren
id|printk
c_func
(paren
l_string|&quot;%s&lt;-&quot;
comma
id|chain-&gt;label
)paren
suffix:semicolon
id|chain-&gt;reent
(braket
id|slot
)braket
dot
id|prevchain
op_assign
l_int|NULL
suffix:semicolon
id|chain
op_assign
id|tmpchain
suffix:semicolon
id|tmpchain
op_assign
id|chain-&gt;reent
(braket
id|slot
)braket
dot
id|prevchain
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verbose
)paren
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|chain-&gt;label
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|ip_fw_domatch
id|ip_fw_domatch
c_func
(paren
r_struct
id|ip_fwkernel
op_star
id|f
comma
r_struct
id|iphdr
op_star
id|ip
comma
r_const
r_char
op_star
id|rif
comma
r_const
id|ip_chainlabel
id|label
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|slot
comma
id|__u16
id|src_port
comma
id|__u16
id|dst_port
comma
r_int
r_int
id|count
comma
r_int
id|tcpsyn
)paren
(brace
id|f-&gt;counters
(braket
id|slot
)braket
dot
id|bcnt
op_add_assign
id|ntohs
c_func
(paren
id|ip-&gt;tot_len
)paren
suffix:semicolon
id|f-&gt;counters
(braket
id|slot
)braket
dot
id|pcnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;ipfw.fw_flg
op_amp
id|IP_FW_F_PRN
)paren
(brace
id|dump_packet
c_func
(paren
id|ip
comma
id|rif
comma
id|f
comma
id|label
comma
id|src_port
comma
id|dst_port
comma
id|count
comma
id|tcpsyn
)paren
suffix:semicolon
)brace
id|ip-&gt;tos
op_assign
(paren
id|ip-&gt;tos
op_amp
id|f-&gt;ipfw.fw_tosand
)paren
op_xor
id|f-&gt;ipfw.fw_tosxor
suffix:semicolon
multiline_comment|/* This functionality is useless in stock 2.0.x series, but we don&squot;t&n; * discard the mark thing altogether, to avoid breaking ipchains (and,&n; * more importantly, the ipfwadm wrapper) --PR */
r_if
c_cond
(paren
id|f-&gt;ipfw.fw_flg
op_amp
id|IP_FW_F_MARKABS
)paren
(brace
id|skb-&gt;nfmark
op_assign
id|f-&gt;ipfw.fw_mark
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;nfmark
op_add_assign
id|f-&gt;ipfw.fw_mark
suffix:semicolon
)brace
r_if
c_cond
(paren
id|f-&gt;ipfw.fw_flg
op_amp
id|IP_FW_F_NETLINK
)paren
(brace
macro_line|#if defined(CONFIG_NETLINK_DEV) || defined(CONFIG_NETLINK_DEV_MODULE)
r_int
id|len
op_assign
id|min
c_func
(paren
id|f-&gt;ipfw.fw_outputsize
comma
id|ntohs
c_func
(paren
id|ip-&gt;tot_len
)paren
)paren
op_plus
r_sizeof
(paren
id|__u32
)paren
op_plus
r_sizeof
(paren
id|skb-&gt;nfmark
)paren
op_plus
id|IFNAMSIZ
suffix:semicolon
r_struct
id|sk_buff
op_star
id|outskb
op_assign
id|alloc_skb
c_func
(paren
id|len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|duprintf
c_func
(paren
l_string|&quot;Sending packet out NETLINK (length = %u).&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|outskb
)paren
(brace
multiline_comment|/* Prepend length, mark &amp; interface */
id|skb_put
c_func
(paren
id|outskb
comma
id|len
)paren
suffix:semicolon
op_star
(paren
(paren
id|__u32
op_star
)paren
id|outskb-&gt;data
)paren
op_assign
(paren
id|__u32
)paren
id|len
suffix:semicolon
op_star
(paren
(paren
id|__u32
op_star
)paren
(paren
id|outskb-&gt;data
op_plus
r_sizeof
(paren
id|__u32
)paren
)paren
)paren
op_assign
id|skb-&gt;nfmark
suffix:semicolon
id|strcpy
c_func
(paren
id|outskb-&gt;data
op_plus
r_sizeof
(paren
id|__u32
)paren
op_star
l_int|2
comma
id|rif
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|outskb-&gt;data
op_plus
r_sizeof
(paren
id|__u32
)paren
op_star
l_int|2
op_plus
id|IFNAMSIZ
comma
id|ip
comma
id|len
op_minus
(paren
r_sizeof
(paren
id|__u32
)paren
op_star
l_int|2
op_plus
id|IFNAMSIZ
)paren
)paren
suffix:semicolon
id|netlink_broadcast
c_func
(paren
id|ipfwsk
comma
id|outskb
comma
l_int|0
comma
op_complement
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#endif
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ip_fw: packet drop due to &quot;
l_string|&quot;netlink failure&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#if defined(CONFIG_NETLINK_DEV) || defined(CONFIG_NETLINK_DEV_MODULE)
)brace
macro_line|#endif
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Returns one of the generic firewall policies, like FW_ACCEPT.&n; *&n; *&t;The testing is either false for normal firewall mode or true for&n; *&t;user checking mode (counters are not updated, TOS &amp; mark not done).&n; */
r_static
r_int
DECL|function|ip_fw_check
id|ip_fw_check
c_func
(paren
r_struct
id|iphdr
op_star
id|ip
comma
r_const
r_char
op_star
id|rif
comma
id|__u16
op_star
id|redirport
comma
r_struct
id|ip_chain
op_star
id|chain
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|slot
comma
r_int
id|testing
)paren
(brace
r_struct
id|tcphdr
op_star
id|tcp
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
(paren
(paren
id|__u32
op_star
)paren
id|ip
op_plus
id|ip-&gt;ihl
)paren
suffix:semicolon
r_struct
id|udphdr
op_star
id|udp
op_assign
(paren
r_struct
id|udphdr
op_star
)paren
(paren
(paren
id|__u32
op_star
)paren
id|ip
op_plus
id|ip-&gt;ihl
)paren
suffix:semicolon
r_struct
id|icmphdr
op_star
id|icmp
op_assign
(paren
r_struct
id|icmphdr
op_star
)paren
(paren
(paren
id|__u32
op_star
)paren
id|ip
op_plus
id|ip-&gt;ihl
)paren
suffix:semicolon
id|__u32
id|src
comma
id|dst
suffix:semicolon
id|__u16
id|src_port
op_assign
l_int|0xFFFF
comma
id|dst_port
op_assign
l_int|0xFFFF
suffix:semicolon
r_char
id|tcpsyn
op_assign
l_int|0
suffix:semicolon
id|__u16
id|offset
suffix:semicolon
r_int
r_char
id|oldtos
suffix:semicolon
r_struct
id|ip_fwkernel
op_star
id|f
suffix:semicolon
r_int
id|ret
op_assign
id|FW_SKIP
op_plus
l_int|2
suffix:semicolon
r_int
r_int
id|count
suffix:semicolon
multiline_comment|/* We handle fragments by dealing with the first fragment as&n;&t; * if it was a normal packet.  All other fragments are treated&n;&t; * normally, except that they will NEVER match rules that ask&n;&t; * things we don&squot;t know, ie. tcp syn flag or ports).  If the&n;&t; * rule is also a fragment-specific rule, non-fragments won&squot;t&n;&t; * match it. */
id|offset
op_assign
id|ntohs
c_func
(paren
id|ip-&gt;frag_off
)paren
op_amp
id|IP_OFFSET
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Don&squot;t allow a fragment of TCP 8 bytes in. Nobody&n;&t; *&t;normal causes this. Its a cracker trying to break&n;&t; *&t;in by doing a flag overwrite to pass the direction&n;&t; *&t;checks.&n;&t; */
r_if
c_cond
(paren
id|offset
op_eq
l_int|1
op_logical_and
id|ip-&gt;protocol
op_eq
id|IPPROTO_TCP
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|testing
op_logical_and
id|net_ratelimit
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Suspect TCP fragment.&bslash;n&quot;
)paren
suffix:semicolon
id|dump_packet
c_func
(paren
id|ip
comma
id|rif
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|FW_BLOCK
suffix:semicolon
)brace
multiline_comment|/* If we can&squot;t investigate ports, treat as fragment.  It&squot;s&n;&t; * either a trucated whole packet, or a truncated first&n;&t; * fragment, or a TCP first fragment of length 8-15, in which&n;&t; * case the above rule stops reassembly.&n;&t; */
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
)paren
(brace
r_int
r_int
id|size_req
suffix:semicolon
r_switch
c_cond
(paren
id|ip-&gt;protocol
)paren
(brace
r_case
id|IPPROTO_TCP
suffix:colon
multiline_comment|/* Don&squot;t care about things past flags word */
id|size_req
op_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IPPROTO_UDP
suffix:colon
r_case
id|IPPROTO_ICMP
suffix:colon
id|size_req
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|size_req
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If it is a truncated first fragment then it can be&n;&t;&t; * used to rewrite port information, and thus should&n;&t;&t; * be blocked.&n;&t;&t; */
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|ip-&gt;tot_len
)paren
OL
(paren
id|ip-&gt;ihl
op_lshift
l_int|2
)paren
op_plus
id|size_req
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|testing
op_logical_and
id|net_ratelimit
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Suspect short first fragment.&bslash;n&quot;
)paren
suffix:semicolon
id|dump_packet
c_func
(paren
id|ip
comma
id|rif
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|FW_BLOCK
suffix:semicolon
)brace
)brace
id|src
op_assign
id|ip-&gt;saddr
suffix:semicolon
id|dst
op_assign
id|ip-&gt;daddr
suffix:semicolon
id|oldtos
op_assign
id|ip-&gt;tos
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If we got interface from which packet came&n;&t; *&t;we can use the address directly. Linux 2.1 now uses address&n;&t; *&t;chains per device too, but unlike BSD we first check if the&n;&t; *&t;incoming packet matches a device address and the routing&n;&t; *&t;table before calling the firewall.&n;&t; */
id|dprintf
c_func
(paren
l_string|&quot;Packet &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ip-&gt;protocol
)paren
(brace
r_case
id|IPPROTO_TCP
suffix:colon
id|dprintf
c_func
(paren
l_string|&quot;TCP &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|offset
)paren
(brace
id|src_port
op_assign
id|ntohs
c_func
(paren
id|tcp-&gt;source
)paren
suffix:semicolon
id|dst_port
op_assign
id|ntohs
c_func
(paren
id|tcp-&gt;dest
)paren
suffix:semicolon
multiline_comment|/* Connection initilisation can only&n;&t;&t;&t;&t; * be made when the syn bit is set and&n;&t;&t;&t;&t; * neither of the ack or reset is&n;&t;&t;&t;&t; * set. */
r_if
c_cond
(paren
id|tcp-&gt;syn
op_logical_and
op_logical_neg
(paren
id|tcp-&gt;ack
op_logical_or
id|tcp-&gt;rst
)paren
)paren
(brace
id|tcpsyn
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|IPPROTO_UDP
suffix:colon
id|dprintf
c_func
(paren
l_string|&quot;UDP &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|offset
)paren
(brace
id|src_port
op_assign
id|ntohs
c_func
(paren
id|udp-&gt;source
)paren
suffix:semicolon
id|dst_port
op_assign
id|ntohs
c_func
(paren
id|udp-&gt;dest
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IPPROTO_ICMP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|offset
)paren
(brace
id|src_port
op_assign
(paren
id|__u16
)paren
id|icmp-&gt;type
suffix:semicolon
id|dst_port
op_assign
(paren
id|__u16
)paren
id|icmp-&gt;code
suffix:semicolon
)brace
id|dprintf
c_func
(paren
l_string|&quot;ICMP &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dprintf
c_func
(paren
l_string|&quot;p=%d &quot;
comma
id|ip-&gt;protocol
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_IP_FIREWALL
id|print_ip
c_func
(paren
id|ip-&gt;saddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
id|dprintf
c_func
(paren
l_string|&quot;:fragment (%i) &quot;
comma
(paren
(paren
r_int
)paren
id|offset
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ip-&gt;protocol
op_eq
id|IPPROTO_TCP
op_logical_or
id|ip-&gt;protocol
op_eq
id|IPPROTO_UDP
op_logical_or
id|ip-&gt;protocol
op_eq
id|IPPROTO_ICMP
)paren
id|dprintf
c_func
(paren
l_string|&quot;:%hu:%hu&quot;
comma
id|src_port
comma
id|dst_port
)paren
suffix:semicolon
id|dprintf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|testing
)paren
id|FWC_READ_LOCK
c_func
(paren
op_amp
id|ip_fw_lock
)paren
suffix:semicolon
r_else
id|FWC_HAVE_LOCK
c_func
(paren
id|fwc_rlocks
)paren
suffix:semicolon
id|f
op_assign
id|chain-&gt;chain
suffix:semicolon
r_do
(brace
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|f
suffix:semicolon
id|f
op_assign
id|f-&gt;next
)paren
(brace
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ip_rule_match
c_func
(paren
id|f
comma
id|rif
comma
id|ip
comma
id|tcpsyn
comma
id|src_port
comma
id|dst_port
comma
id|offset
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|testing
op_logical_and
op_logical_neg
id|ip_fw_domatch
c_func
(paren
id|f
comma
id|ip
comma
id|rif
comma
id|chain-&gt;label
comma
id|skb
comma
id|slot
comma
id|src_port
comma
id|dst_port
comma
id|count
comma
id|tcpsyn
)paren
)paren
(brace
id|ret
op_assign
id|FW_BLOCK
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|f
)paren
(brace
r_if
c_cond
(paren
id|f-&gt;branch
)paren
(brace
multiline_comment|/* Do sanity check to see if we have&n;                                 * already set prevchain and if so we&n;                                 * must be in a loop */
r_if
c_cond
(paren
id|f-&gt;branch-&gt;reent
(braket
id|slot
)braket
dot
id|prevchain
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|testing
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;IP firewall: &quot;
l_string|&quot;Loop detected &quot;
l_string|&quot;at `%s&squot;.&bslash;n&quot;
comma
id|f-&gt;branch-&gt;label
)paren
suffix:semicolon
id|cleanup
c_func
(paren
id|chain
comma
l_int|1
comma
id|slot
)paren
suffix:semicolon
id|ret
op_assign
id|FW_BLOCK
suffix:semicolon
)brace
r_else
(brace
id|cleanup
c_func
(paren
id|chain
comma
l_int|0
comma
id|slot
)paren
suffix:semicolon
id|ret
op_assign
id|FW_SKIP
op_plus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|f-&gt;branch-&gt;reent
(braket
id|slot
)braket
dot
id|prevchain
op_assign
id|chain
suffix:semicolon
id|f-&gt;branch-&gt;reent
(braket
id|slot
)braket
dot
id|prevrule
op_assign
id|f-&gt;next
suffix:semicolon
id|chain
op_assign
id|f-&gt;branch
suffix:semicolon
id|f
op_assign
id|chain-&gt;chain
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|f-&gt;simplebranch
op_eq
id|FW_SKIP
)paren
id|f
op_assign
id|f-&gt;next
suffix:semicolon
r_else
r_if
c_cond
(paren
id|f-&gt;simplebranch
op_eq
id|FW_SKIP
op_plus
l_int|1
)paren
(brace
multiline_comment|/* Just like falling off the chain */
r_goto
id|fall_off_chain
suffix:semicolon
)brace
r_else
(brace
id|cleanup
c_func
(paren
id|chain
comma
l_int|0
comma
id|slot
)paren
suffix:semicolon
id|ret
op_assign
id|f-&gt;simplebranch
suffix:semicolon
)brace
)brace
multiline_comment|/* f == NULL */
r_else
(brace
id|fall_off_chain
suffix:colon
r_if
c_cond
(paren
id|chain-&gt;reent
(braket
id|slot
)braket
dot
id|prevchain
)paren
(brace
r_struct
id|ip_chain
op_star
id|tmp
op_assign
id|chain
suffix:semicolon
id|f
op_assign
id|chain-&gt;reent
(braket
id|slot
)braket
dot
id|prevrule
suffix:semicolon
id|chain
op_assign
id|chain-&gt;reent
(braket
id|slot
)braket
dot
id|prevchain
suffix:semicolon
id|tmp-&gt;reent
(braket
id|slot
)braket
dot
id|prevchain
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
id|chain-&gt;policy
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|testing
)paren
(brace
id|chain-&gt;reent
(braket
id|slot
)braket
dot
id|counters.pcnt
op_increment
suffix:semicolon
id|chain-&gt;reent
(braket
id|slot
)braket
dot
id|counters.bcnt
op_add_assign
id|ntohs
c_func
(paren
id|ip-&gt;tot_len
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_while
c_loop
(paren
id|ret
op_eq
id|FW_SKIP
op_plus
l_int|2
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|testing
)paren
id|FWC_READ_UNLOCK
c_func
(paren
op_amp
id|ip_fw_lock
)paren
suffix:semicolon
multiline_comment|/* Recalculate checksum if not going to reject, and TOS changed. */
r_if
c_cond
(paren
id|ip-&gt;tos
op_ne
id|oldtos
op_logical_and
id|ret
op_ne
id|FW_REJECT
op_logical_and
id|ret
op_ne
id|FW_BLOCK
op_logical_and
op_logical_neg
id|testing
)paren
id|ip_send_check
c_func
(paren
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|FW_REDIRECT
op_logical_and
id|redirport
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|redirport
op_assign
id|htons
c_func
(paren
id|f-&gt;ipfw.fw_redirpt
)paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Wildcard redirection.&n;&t;&t;&t; * Note that redirport will become&n;&t;&t;&t; * 0xFFFF for non-TCP/UDP packets.&n;&t;&t;&t; */
op_star
id|redirport
op_assign
id|htons
c_func
(paren
id|dst_port
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG_ALLOW_ALL
r_return
(paren
id|testing
ques
c_cond
id|ret
suffix:colon
id|FW_ACCEPT
)paren
suffix:semicolon
macro_line|#else
r_return
id|ret
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Must have write lock &amp; interrupts off for any of these */
multiline_comment|/* This function sets all the byte counters in a chain to zero.  The&n; * input is a pointer to the chain required for zeroing */
DECL|function|zero_fw_chain
r_static
r_int
id|zero_fw_chain
c_func
(paren
r_struct
id|ip_chain
op_star
id|chainptr
)paren
(brace
r_struct
id|ip_fwkernel
op_star
id|i
suffix:semicolon
id|FWC_HAVE_LOCK
c_func
(paren
id|fwc_wlocks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|chainptr-&gt;chain
suffix:semicolon
id|i
suffix:semicolon
id|i
op_assign
id|i-&gt;next
)paren
id|memset
c_func
(paren
id|i-&gt;counters
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ip_counters
)paren
op_star
id|NUM_SLOTS
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|clear_fw_chain
r_static
r_int
id|clear_fw_chain
c_func
(paren
r_struct
id|ip_chain
op_star
id|chainptr
)paren
(brace
r_struct
id|ip_fwkernel
op_star
id|i
op_assign
id|chainptr-&gt;chain
suffix:semicolon
id|FWC_HAVE_LOCK
c_func
(paren
id|fwc_wlocks
)paren
suffix:semicolon
id|chainptr-&gt;chain
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|i
)paren
(brace
r_struct
id|ip_fwkernel
op_star
id|tmp
op_assign
id|i-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|i-&gt;branch
)paren
id|i-&gt;branch-&gt;refcount
op_decrement
suffix:semicolon
id|kfree
c_func
(paren
id|i
)paren
suffix:semicolon
id|i
op_assign
id|tmp
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|replace_in_chain
r_static
r_int
id|replace_in_chain
c_func
(paren
r_struct
id|ip_chain
op_star
id|chainptr
comma
r_struct
id|ip_fwkernel
op_star
id|frwl
comma
id|__u32
id|position
)paren
(brace
r_struct
id|ip_fwkernel
op_star
id|f
op_assign
id|chainptr-&gt;chain
suffix:semicolon
id|FWC_HAVE_LOCK
c_func
(paren
id|fwc_wlocks
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|position
op_logical_and
id|f
op_ne
l_int|NULL
)paren
id|f
op_assign
id|f-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|f
op_eq
l_int|NULL
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;branch
)paren
id|f-&gt;branch-&gt;refcount
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|frwl-&gt;branch
)paren
id|frwl-&gt;branch-&gt;refcount
op_increment
suffix:semicolon
id|frwl-&gt;next
op_assign
id|f-&gt;next
suffix:semicolon
id|memcpy
c_func
(paren
id|f
comma
id|frwl
comma
r_sizeof
(paren
r_struct
id|ip_fwkernel
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|frwl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|append_to_chain
r_static
r_int
id|append_to_chain
c_func
(paren
r_struct
id|ip_chain
op_star
id|chainptr
comma
r_struct
id|ip_fwkernel
op_star
id|rule
)paren
(brace
r_struct
id|ip_fwkernel
op_star
id|i
suffix:semicolon
id|FWC_HAVE_LOCK
c_func
(paren
id|fwc_wlocks
)paren
suffix:semicolon
multiline_comment|/* Special case if no rules already present */
r_if
c_cond
(paren
id|chainptr-&gt;chain
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* If pointer writes are atomic then turning off&n;&t;&t; * interupts is not necessary. */
id|chainptr-&gt;chain
op_assign
id|rule
suffix:semicolon
r_if
c_cond
(paren
id|rule-&gt;branch
)paren
id|rule-&gt;branch-&gt;refcount
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Find the rule before the end of the chain */
r_for
c_loop
(paren
id|i
op_assign
id|chainptr-&gt;chain
suffix:semicolon
id|i-&gt;next
suffix:semicolon
id|i
op_assign
id|i-&gt;next
)paren
suffix:semicolon
id|i-&gt;next
op_assign
id|rule
suffix:semicolon
r_if
c_cond
(paren
id|rule-&gt;branch
)paren
id|rule-&gt;branch-&gt;refcount
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function inserts a rule at the position of position in the&n; * chain refenced by chainptr.  If position is 1 then this rule will&n; * become the new rule one. */
DECL|function|insert_in_chain
r_static
r_int
id|insert_in_chain
c_func
(paren
r_struct
id|ip_chain
op_star
id|chainptr
comma
r_struct
id|ip_fwkernel
op_star
id|frwl
comma
id|__u32
id|position
)paren
(brace
r_struct
id|ip_fwkernel
op_star
id|f
op_assign
id|chainptr-&gt;chain
suffix:semicolon
id|FWC_HAVE_LOCK
c_func
(paren
id|fwc_wlocks
)paren
suffix:semicolon
multiline_comment|/* special case if the position is number 1 */
r_if
c_cond
(paren
id|position
op_eq
l_int|1
)paren
(brace
id|frwl-&gt;next
op_assign
id|chainptr-&gt;chain
suffix:semicolon
r_if
c_cond
(paren
id|frwl-&gt;branch
)paren
id|frwl-&gt;branch-&gt;refcount
op_increment
suffix:semicolon
id|chainptr-&gt;chain
op_assign
id|frwl
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|position
op_decrement
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|position
op_logical_and
id|f
op_ne
l_int|NULL
)paren
id|f
op_assign
id|f-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|f
op_eq
l_int|NULL
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|frwl-&gt;branch
)paren
id|frwl-&gt;branch-&gt;refcount
op_increment
suffix:semicolon
id|frwl-&gt;next
op_assign
id|f-&gt;next
suffix:semicolon
id|f-&gt;next
op_assign
id|frwl
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function deletes the a rule from a given rulenum and chain.&n; * With rulenum = 1 is the first rule is deleted. */
DECL|function|del_num_from_chain
r_static
r_int
id|del_num_from_chain
c_func
(paren
r_struct
id|ip_chain
op_star
id|chainptr
comma
id|__u32
id|rulenum
)paren
(brace
r_struct
id|ip_fwkernel
op_star
id|i
op_assign
id|chainptr-&gt;chain
comma
op_star
id|tmp
suffix:semicolon
id|FWC_HAVE_LOCK
c_func
(paren
id|fwc_wlocks
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chainptr-&gt;chain
)paren
r_return
id|ENOENT
suffix:semicolon
multiline_comment|/* Need a special case for the first rule */
r_if
c_cond
(paren
id|rulenum
op_eq
l_int|1
)paren
(brace
multiline_comment|/* store temp to allow for freeing up of memory */
id|tmp
op_assign
id|chainptr-&gt;chain
suffix:semicolon
r_if
c_cond
(paren
id|chainptr-&gt;chain-&gt;branch
)paren
id|chainptr-&gt;chain-&gt;branch-&gt;refcount
op_decrement
suffix:semicolon
id|chainptr-&gt;chain
op_assign
id|chainptr-&gt;chain-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|tmp
)paren
suffix:semicolon
multiline_comment|/* free memory that is now unused */
)brace
r_else
(brace
id|rulenum
op_decrement
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|rulenum
op_logical_and
id|i-&gt;next
)paren
id|i
op_assign
id|i-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i-&gt;next
)paren
r_return
id|ENOENT
suffix:semicolon
id|tmp
op_assign
id|i-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|i-&gt;next-&gt;branch
)paren
id|i-&gt;next-&gt;branch-&gt;refcount
op_decrement
suffix:semicolon
id|i-&gt;next
op_assign
id|i-&gt;next-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function deletes the a rule from a given rule and chain.&n; * The rule that is deleted is the first occursance of that rule. */
DECL|function|del_rule_from_chain
r_static
r_int
id|del_rule_from_chain
c_func
(paren
r_struct
id|ip_chain
op_star
id|chainptr
comma
r_struct
id|ip_fwkernel
op_star
id|frwl
)paren
(brace
r_struct
id|ip_fwkernel
op_star
id|ltmp
comma
op_star
id|ftmp
op_assign
id|chainptr-&gt;chain
suffix:semicolon
r_int
id|was_found
suffix:semicolon
id|FWC_HAVE_LOCK
c_func
(paren
id|fwc_wlocks
)paren
suffix:semicolon
multiline_comment|/* Sure, we should compare marks, but since the `ipfwadm&squot;&n;&t; * script uses it for an unholy hack... well, life is easier&n;&t; * this way.  We also mask it out of the flags word. --PR */
r_for
c_loop
(paren
id|ltmp
op_assign
l_int|NULL
comma
id|was_found
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|was_found
op_logical_and
id|ftmp
op_ne
l_int|NULL
suffix:semicolon
id|ltmp
op_assign
id|ftmp
comma
id|ftmp
op_assign
id|ftmp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ftmp-&gt;ipfw.fw_src.s_addr
op_ne
id|frwl-&gt;ipfw.fw_src.s_addr
op_logical_or
id|ftmp-&gt;ipfw.fw_dst.s_addr
op_ne
id|frwl-&gt;ipfw.fw_dst.s_addr
op_logical_or
id|ftmp-&gt;ipfw.fw_smsk.s_addr
op_ne
id|frwl-&gt;ipfw.fw_smsk.s_addr
op_logical_or
id|ftmp-&gt;ipfw.fw_dmsk.s_addr
op_ne
id|frwl-&gt;ipfw.fw_dmsk.s_addr
macro_line|#if 0
op_logical_or
id|ftmp-&gt;ipfw.fw_flg
op_ne
id|frwl-&gt;ipfw.fw_flg
macro_line|#else
op_logical_or
(paren
(paren
id|ftmp-&gt;ipfw.fw_flg
op_amp
op_complement
id|IP_FW_F_MARKABS
)paren
op_ne
(paren
id|frwl-&gt;ipfw.fw_flg
op_amp
op_complement
id|IP_FW_F_MARKABS
)paren
)paren
macro_line|#endif
op_logical_or
id|ftmp-&gt;ipfw.fw_invflg
op_ne
id|frwl-&gt;ipfw.fw_invflg
op_logical_or
id|ftmp-&gt;ipfw.fw_proto
op_ne
id|frwl-&gt;ipfw.fw_proto
macro_line|#if 0
op_logical_or
id|ftmp-&gt;ipfw.fw_mark
op_ne
id|frwl-&gt;ipfw.fw_mark
macro_line|#endif
op_logical_or
id|ftmp-&gt;ipfw.fw_redirpt
op_ne
id|frwl-&gt;ipfw.fw_redirpt
op_logical_or
id|ftmp-&gt;ipfw.fw_spts
(braket
l_int|0
)braket
op_ne
id|frwl-&gt;ipfw.fw_spts
(braket
l_int|0
)braket
op_logical_or
id|ftmp-&gt;ipfw.fw_spts
(braket
l_int|1
)braket
op_ne
id|frwl-&gt;ipfw.fw_spts
(braket
l_int|1
)braket
op_logical_or
id|ftmp-&gt;ipfw.fw_dpts
(braket
l_int|0
)braket
op_ne
id|frwl-&gt;ipfw.fw_dpts
(braket
l_int|0
)braket
op_logical_or
id|ftmp-&gt;ipfw.fw_dpts
(braket
l_int|1
)braket
op_ne
id|frwl-&gt;ipfw.fw_dpts
(braket
l_int|1
)braket
op_logical_or
id|ftmp-&gt;ipfw.fw_outputsize
op_ne
id|frwl-&gt;ipfw.fw_outputsize
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;del_rule_from_chain: mismatch:&quot;
l_string|&quot;src:%u/%u dst:%u/%u smsk:%u/%u dmsk:%u/%u &quot;
l_string|&quot;flg:%hX/%hX invflg:%hX/%hX proto:%u/%u &quot;
l_string|&quot;mark:%u/%u &quot;
l_string|&quot;ports:%hu-%hu/%hu-%hu %hu-%hu/%hu-%hu &quot;
l_string|&quot;outputsize:%hu-%hu&bslash;n&quot;
comma
id|ftmp-&gt;ipfw.fw_src.s_addr
comma
id|frwl-&gt;ipfw.fw_src.s_addr
comma
id|ftmp-&gt;ipfw.fw_dst.s_addr
comma
id|frwl-&gt;ipfw.fw_dst.s_addr
comma
id|ftmp-&gt;ipfw.fw_smsk.s_addr
comma
id|frwl-&gt;ipfw.fw_smsk.s_addr
comma
id|ftmp-&gt;ipfw.fw_dmsk.s_addr
comma
id|frwl-&gt;ipfw.fw_dmsk.s_addr
comma
id|ftmp-&gt;ipfw.fw_flg
comma
id|frwl-&gt;ipfw.fw_flg
comma
id|ftmp-&gt;ipfw.fw_invflg
comma
id|frwl-&gt;ipfw.fw_invflg
comma
id|ftmp-&gt;ipfw.fw_proto
comma
id|frwl-&gt;ipfw.fw_proto
comma
id|ftmp-&gt;ipfw.fw_mark
comma
id|frwl-&gt;ipfw.fw_mark
comma
id|ftmp-&gt;ipfw.fw_spts
(braket
l_int|0
)braket
comma
id|frwl-&gt;ipfw.fw_spts
(braket
l_int|0
)braket
comma
id|ftmp-&gt;ipfw.fw_spts
(braket
l_int|1
)braket
comma
id|frwl-&gt;ipfw.fw_spts
(braket
l_int|1
)braket
comma
id|ftmp-&gt;ipfw.fw_dpts
(braket
l_int|0
)braket
comma
id|frwl-&gt;ipfw.fw_dpts
(braket
l_int|0
)braket
comma
id|ftmp-&gt;ipfw.fw_dpts
(braket
l_int|1
)braket
comma
id|frwl-&gt;ipfw.fw_dpts
(braket
l_int|1
)braket
comma
id|ftmp-&gt;ipfw.fw_outputsize
comma
id|frwl-&gt;ipfw.fw_outputsize
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|ftmp-&gt;ipfw.fw_vianame
comma
id|frwl-&gt;ipfw.fw_vianame
comma
id|IFNAMSIZ
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;del_rule_from_chain: if mismatch: %s/%s&bslash;n&quot;
comma
id|ftmp-&gt;ipfw.fw_vianame
comma
id|frwl-&gt;ipfw.fw_vianame
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ftmp-&gt;branch
op_ne
id|frwl-&gt;branch
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;del_rule_from_chain: branch mismatch: &quot;
l_string|&quot;%s/%s&bslash;n&quot;
comma
id|ftmp-&gt;branch
ques
c_cond
id|ftmp-&gt;branch-&gt;label
suffix:colon
l_string|&quot;(null)&quot;
comma
id|frwl-&gt;branch
ques
c_cond
id|frwl-&gt;branch-&gt;label
suffix:colon
l_string|&quot;(null)&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ftmp-&gt;branch
op_eq
l_int|NULL
op_logical_and
id|ftmp-&gt;simplebranch
op_ne
id|frwl-&gt;simplebranch
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;del_rule_from_chain: simplebranch mismatch: &quot;
l_string|&quot;%i/%i&bslash;n&quot;
comma
id|ftmp-&gt;simplebranch
comma
id|frwl-&gt;simplebranch
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|was_found
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ftmp-&gt;branch
)paren
id|ftmp-&gt;branch-&gt;refcount
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ltmp
)paren
id|ltmp-&gt;next
op_assign
id|ftmp-&gt;next
suffix:semicolon
r_else
id|chainptr-&gt;chain
op_assign
id|ftmp-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|ftmp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|was_found
)paren
r_return
l_int|0
suffix:semicolon
r_else
(brace
id|duprintf
c_func
(paren
l_string|&quot;del_rule_from_chain: no matching rule found&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/* This function takes the label of a chain and deletes the first&n; * chain with that name.  No special cases required for the built in&n; * chains as they have their refcount initilised to 1 so that they are&n; * never deleted.  */
DECL|function|del_chain
r_static
r_int
id|del_chain
c_func
(paren
id|ip_chainlabel
id|label
)paren
(brace
r_struct
id|ip_chain
op_star
id|tmp
comma
op_star
id|tmp2
suffix:semicolon
id|FWC_HAVE_LOCK
c_func
(paren
id|fwc_wlocks
)paren
suffix:semicolon
multiline_comment|/* Corner case: return EBUSY not ENOENT for first elem (&quot;input&quot;) */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|label
comma
id|ip_fw_chains-&gt;label
)paren
op_eq
l_int|0
)paren
r_return
id|EBUSY
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|ip_fw_chains
suffix:semicolon
id|tmp-&gt;next
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|tmp-&gt;next-&gt;label
comma
id|label
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|tmp2
op_assign
id|tmp-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp2
)paren
r_return
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|tmp2-&gt;refcount
)paren
r_return
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|tmp2-&gt;chain
)paren
r_return
id|ENOTEMPTY
suffix:semicolon
id|tmp-&gt;next
op_assign
id|tmp2-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|tmp2
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is a function to initilise a chain.  Built in rules start with&n; * refcount = 1 so that they cannot be deleted.  User defined rules&n; * start with refcount = 0 so they can be deleted. */
DECL|function|ip_init_chain
r_static
r_struct
id|ip_chain
op_star
id|ip_init_chain
c_func
(paren
id|ip_chainlabel
id|name
comma
id|__u32
id|ref
comma
r_int
id|policy
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_struct
id|ip_chain
op_star
id|label
op_assign
id|kmalloc
c_func
(paren
id|SIZEOF_STRUCT_IP_CHAIN
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|label
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;Can&squot;t kmalloc for firewall chains.&bslash;n&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|label-&gt;label
comma
id|name
)paren
suffix:semicolon
id|label-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|label-&gt;chain
op_assign
l_int|NULL
suffix:semicolon
id|label-&gt;refcount
op_assign
id|ref
suffix:semicolon
id|label-&gt;policy
op_assign
id|policy
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
op_star
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|label-&gt;reent
(braket
id|i
)braket
dot
id|counters.pcnt
op_assign
id|label-&gt;reent
(braket
id|i
)braket
dot
id|counters.bcnt
op_assign
l_int|0
suffix:semicolon
id|label-&gt;reent
(braket
id|i
)braket
dot
id|prevchain
op_assign
l_int|NULL
suffix:semicolon
id|label-&gt;reent
(braket
id|i
)braket
dot
id|prevrule
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|label
suffix:semicolon
)brace
multiline_comment|/* This is a function for reating a new chain.  The chains is not&n; * created if a chain of the same name already exists */
DECL|function|create_chain
r_static
r_int
id|create_chain
c_func
(paren
id|ip_chainlabel
id|label
)paren
(brace
r_struct
id|ip_chain
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_label
c_func
(paren
id|label
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
id|FWC_HAVE_LOCK
c_func
(paren
id|fwc_wlocks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|ip_fw_chains
suffix:semicolon
id|tmp-&gt;next
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|tmp-&gt;label
comma
id|label
)paren
op_eq
l_int|0
)paren
r_return
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|tmp-&gt;label
comma
id|label
)paren
op_eq
l_int|0
)paren
r_return
id|EEXIST
suffix:semicolon
id|tmp-&gt;next
op_assign
id|ip_init_chain
c_func
(paren
id|label
comma
l_int|0
comma
id|FW_SKIP
)paren
suffix:semicolon
multiline_comment|/* refcount is&n;&t;&t;&t;&t;&t;      * zero since this is a&n;&t;&t;&t;&t;&t;      * user defined chain *&n;&t;&t;&t;&t;&t;      * and therefore can be&n;&t;&t;&t;&t;&t;      * deleted */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function simply changes the policy on one of the built in&n; * chains.  checking must be done before this is call to ensure that&n; * chainptr is pointing to one of the three possible chains */
DECL|function|change_policy
r_static
r_int
id|change_policy
c_func
(paren
r_struct
id|ip_chain
op_star
id|chainptr
comma
r_int
id|policy
)paren
(brace
id|FWC_HAVE_LOCK
c_func
(paren
id|fwc_wlocks
)paren
suffix:semicolon
id|chainptr-&gt;policy
op_assign
id|policy
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function takes an ip_fwuser and converts it to a ip_fwkernel.  It also&n; * performs some checks in the structure. */
DECL|function|convert_ipfw
r_static
r_struct
id|ip_fwkernel
op_star
id|convert_ipfw
c_func
(paren
r_struct
id|ip_fwuser
op_star
id|fwuser
comma
r_int
op_star
id|errno
)paren
(brace
r_struct
id|ip_fwkernel
op_star
id|fwkern
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fwuser-&gt;ipfw.fw_flg
op_amp
op_complement
id|IP_FW_F_MASK
)paren
op_ne
l_int|0
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;convert_ipfw: undefined flag bits set (flags=%x)&bslash;n&quot;
comma
id|fwuser-&gt;ipfw.fw_flg
)paren
suffix:semicolon
op_star
id|errno
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_IP_FIREWALL_USER
multiline_comment|/* These are sanity checks that don&squot;t really matter.&n;&t; * We can get rid of these once testing is complete.&n;&t; */
r_if
c_cond
(paren
(paren
id|fwuser-&gt;ipfw.fw_flg
op_amp
id|IP_FW_F_TCPSYN
)paren
op_logical_and
(paren
(paren
id|fwuser-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_PROTO
)paren
op_logical_or
id|fwuser-&gt;ipfw.fw_proto
op_ne
id|IPPROTO_TCP
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;convert_ipfw: TCP SYN flag set but proto != TCP!&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|errno
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|fwuser-&gt;label
comma
id|IP_FW_LABEL_REDIRECT
)paren
op_ne
l_int|0
op_logical_and
id|fwuser-&gt;ipfw.fw_redirpt
op_ne
l_int|0
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;convert_ipfw: Target not REDIR but redirpt != 0!&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|errno
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|fwuser-&gt;ipfw.fw_flg
op_amp
id|IP_FW_F_FRAG
)paren
op_logical_and
(paren
id|fwuser-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_FRAG
)paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|fwuser-&gt;ipfw.fw_flg
op_amp
id|IP_FW_F_TCPSYN
)paren
op_logical_and
(paren
id|fwuser-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_SYN
)paren
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;convert_ipfw: Can&squot;t have INV flag if flag unset!&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|errno
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|fwuser-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_SRCPT
)paren
op_logical_and
id|fwuser-&gt;ipfw.fw_spts
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_and
id|fwuser-&gt;ipfw.fw_spts
(braket
l_int|1
)braket
op_eq
l_int|0xFFFF
)paren
op_logical_or
(paren
(paren
id|fwuser-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_DSTPT
)paren
op_logical_and
id|fwuser-&gt;ipfw.fw_dpts
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_and
id|fwuser-&gt;ipfw.fw_dpts
(braket
l_int|1
)braket
op_eq
l_int|0xFFFF
)paren
op_logical_or
(paren
(paren
id|fwuser-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_VIA
)paren
op_logical_and
(paren
id|fwuser-&gt;ipfw.fw_vianame
)paren
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
op_logical_or
(paren
(paren
id|fwuser-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_SRCIP
)paren
op_logical_and
id|fwuser-&gt;ipfw.fw_smsk.s_addr
op_eq
l_int|0
)paren
op_logical_or
(paren
(paren
id|fwuser-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_DSTIP
)paren
op_logical_and
id|fwuser-&gt;ipfw.fw_dmsk.s_addr
op_eq
l_int|0
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;convert_ipfw: INV flag makes rule unmatchable!&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|errno
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|fwuser-&gt;ipfw.fw_flg
op_amp
id|IP_FW_F_FRAG
)paren
op_logical_and
op_logical_neg
(paren
id|fwuser-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_FRAG
)paren
op_logical_and
(paren
id|fwuser-&gt;ipfw.fw_spts
(braket
l_int|0
)braket
op_ne
l_int|0
op_logical_or
id|fwuser-&gt;ipfw.fw_spts
(braket
l_int|1
)braket
op_ne
l_int|0xFFFF
op_logical_or
id|fwuser-&gt;ipfw.fw_dpts
(braket
l_int|0
)braket
op_ne
l_int|0
op_logical_or
id|fwuser-&gt;ipfw.fw_dpts
(braket
l_int|1
)braket
op_ne
l_int|0xFFFF
op_logical_or
(paren
id|fwuser-&gt;ipfw.fw_flg
op_amp
id|IP_FW_F_TCPSYN
)paren
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;convert_ipfw: Can&squot;t test ports or SYN with frag!&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|errno
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|fwuser-&gt;ipfw.fw_spts
(braket
l_int|0
)braket
op_ne
l_int|0
op_logical_or
id|fwuser-&gt;ipfw.fw_spts
(braket
l_int|1
)braket
op_ne
l_int|0xFFFF
op_logical_or
id|fwuser-&gt;ipfw.fw_dpts
(braket
l_int|0
)braket
op_ne
l_int|0
op_logical_or
id|fwuser-&gt;ipfw.fw_dpts
(braket
l_int|1
)braket
op_ne
l_int|0xFFFF
)paren
op_logical_and
(paren
(paren
id|fwuser-&gt;ipfw.fw_invflg
op_amp
id|IP_FW_INV_PROTO
)paren
op_logical_or
(paren
id|fwuser-&gt;ipfw.fw_proto
op_ne
id|IPPROTO_TCP
op_logical_and
id|fwuser-&gt;ipfw.fw_proto
op_ne
id|IPPROTO_UDP
op_logical_and
id|fwuser-&gt;ipfw.fw_proto
op_ne
id|IPPROTO_ICMP
)paren
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;convert_ipfw: Can only test ports for TCP/UDP/ICMP!&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|errno
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|fwkern
op_assign
id|kmalloc
c_func
(paren
id|SIZEOF_STRUCT_IP_FW_KERNEL
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fwkern
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;convert_ipfw: kmalloc failed!&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|errno
op_assign
id|ENOMEM
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|fwkern-&gt;ipfw
comma
op_amp
id|fwuser-&gt;ipfw
comma
r_sizeof
(paren
r_struct
id|ip_fw
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|find_special
c_func
(paren
id|fwuser-&gt;label
comma
op_amp
id|fwkern-&gt;simplebranch
)paren
)paren
(brace
id|fwkern-&gt;branch
op_assign
id|find_label
c_func
(paren
id|fwuser-&gt;label
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fwkern-&gt;branch
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;convert_ipfw: chain doesn&squot;t exist `%s&squot;.&bslash;n&quot;
comma
id|fwuser-&gt;label
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fwkern
)paren
suffix:semicolon
op_star
id|errno
op_assign
id|ENOENT
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|fwkern-&gt;branch
op_eq
id|IP_FW_INPUT_CHAIN
op_logical_or
id|fwkern-&gt;branch
op_eq
id|IP_FW_FORWARD_CHAIN
op_logical_or
id|fwkern-&gt;branch
op_eq
id|IP_FW_OUTPUT_CHAIN
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;convert_ipfw: Can&squot;t branch to builtin chain `%s&squot;.&bslash;n&quot;
comma
id|fwuser-&gt;label
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fwkern
)paren
suffix:semicolon
op_star
id|errno
op_assign
id|ENOENT
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
id|fwkern-&gt;branch
op_assign
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|fwkern-&gt;counters
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ip_counters
)paren
op_star
id|NUM_SLOTS
)paren
suffix:semicolon
multiline_comment|/* Handle empty vianame by making it a wildcard */
r_if
c_cond
(paren
(paren
id|fwkern-&gt;ipfw.fw_vianame
)paren
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
id|fwkern-&gt;ipfw.fw_flg
op_or_assign
id|IP_FW_F_WILDIF
suffix:semicolon
id|fwkern-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|fwkern
suffix:semicolon
)brace
DECL|function|ip_fw_ctl
r_int
id|ip_fw_ctl
c_func
(paren
r_int
id|cmd
comma
r_void
op_star
id|m
comma
r_int
id|len
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|ip_chain
op_star
id|chain
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|FWC_WRITE_LOCK_IRQ
c_func
(paren
op_amp
id|ip_fw_lock
comma
id|flags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|IP_FW_FLUSH
suffix:colon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|ip_chainlabel
)paren
op_logical_or
op_logical_neg
id|check_label
c_func
(paren
id|m
)paren
)paren
id|ret
op_assign
id|EINVAL
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|chain
op_assign
id|find_label
c_func
(paren
id|m
)paren
)paren
op_eq
l_int|NULL
)paren
id|ret
op_assign
id|ENOENT
suffix:semicolon
r_else
id|ret
op_assign
id|clear_fw_chain
c_func
(paren
id|chain
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IP_FW_ZERO
suffix:colon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|ip_chainlabel
)paren
op_logical_or
op_logical_neg
id|check_label
c_func
(paren
id|m
)paren
)paren
id|ret
op_assign
id|EINVAL
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|chain
op_assign
id|find_label
c_func
(paren
id|m
)paren
)paren
op_eq
l_int|NULL
)paren
id|ret
op_assign
id|ENOENT
suffix:semicolon
r_else
id|ret
op_assign
id|zero_fw_chain
c_func
(paren
id|chain
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IP_FW_CHECK
suffix:colon
(brace
r_struct
id|ip_fwtest
op_star
r_new
op_assign
id|m
suffix:semicolon
r_struct
id|iphdr
op_star
id|ip
suffix:semicolon
multiline_comment|/* Don&squot;t need write lock. */
id|FWC_WRITE_UNLOCK_IRQ
c_func
(paren
op_amp
id|ip_fw_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|ip_fwtest
)paren
op_logical_or
op_logical_neg
id|check_label
c_func
(paren
id|m
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
multiline_comment|/* Need readlock to do find_label */
id|FWC_READ_LOCK
c_func
(paren
op_amp
id|ip_fw_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|chain
op_assign
id|find_label
c_func
(paren
r_new
op_member_access_from_pointer
id|fwt_label
)paren
)paren
op_eq
l_int|NULL
)paren
id|ret
op_assign
id|ENOENT
suffix:semicolon
r_else
(brace
id|ip
op_assign
op_amp
(paren
r_new
op_member_access_from_pointer
id|fwt_packet.fwp_iph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;ihl
op_ne
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_div
r_sizeof
(paren
r_int
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;ip_fw_ctl: ip-&gt;ihl=%d, want %d&bslash;n&quot;
comma
id|ip-&gt;ihl
comma
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_div
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
id|ip_fw_check
c_func
(paren
id|ip
comma
r_new
op_member_access_from_pointer
id|fwt_packet.fwp_vianame
comma
l_int|NULL
comma
id|chain
comma
l_int|NULL
comma
id|SLOT_NUMBER
c_func
(paren
)paren
comma
l_int|1
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_case
id|FW_ACCEPT
suffix:colon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FW_REDIRECT
suffix:colon
id|ret
op_assign
id|ECONNABORTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FW_MASQUERADE
suffix:colon
id|ret
op_assign
id|ECONNRESET
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FW_REJECT
suffix:colon
id|ret
op_assign
id|ECONNREFUSED
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Hack to help diag; these only get&n;&t;&t;&t;&t;&t;   returned when testing. */
r_case
id|FW_SKIP
op_plus
l_int|1
suffix:colon
id|ret
op_assign
id|ELOOP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FW_SKIP
suffix:colon
id|ret
op_assign
id|ENFILE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* FW_BLOCK */
id|ret
op_assign
id|ETIMEDOUT
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|FWC_READ_UNLOCK
c_func
(paren
op_amp
id|ip_fw_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_case
id|IP_FW_MASQ_TIMEOUTS
suffix:colon
(brace
id|ret
op_assign
id|ip_fw_masq_timeouts
c_func
(paren
id|m
comma
id|len
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IP_FW_REPLACE
suffix:colon
(brace
r_struct
id|ip_fwkernel
op_star
id|ip_fwkern
suffix:semicolon
r_struct
id|ip_fwnew
op_star
r_new
op_assign
id|m
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|ip_fwnew
)paren
op_logical_or
op_logical_neg
id|check_label
c_func
(paren
r_new
op_member_access_from_pointer
id|fwn_label
)paren
)paren
id|ret
op_assign
id|EINVAL
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|chain
op_assign
id|find_label
c_func
(paren
r_new
op_member_access_from_pointer
id|fwn_label
)paren
)paren
op_eq
l_int|NULL
)paren
id|ret
op_assign
id|ENOENT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|ip_fwkern
op_assign
id|convert_ipfw
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|fwn_rule
comma
op_amp
id|ret
)paren
)paren
op_ne
l_int|NULL
)paren
id|ret
op_assign
id|replace_in_chain
c_func
(paren
id|chain
comma
id|ip_fwkern
comma
r_new
op_member_access_from_pointer
id|fwn_rulenum
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IP_FW_APPEND
suffix:colon
(brace
r_struct
id|ip_fwchange
op_star
r_new
op_assign
id|m
suffix:semicolon
r_struct
id|ip_fwkernel
op_star
id|ip_fwkern
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|ip_fwchange
)paren
op_logical_or
op_logical_neg
id|check_label
c_func
(paren
r_new
op_member_access_from_pointer
id|fwc_label
)paren
)paren
id|ret
op_assign
id|EINVAL
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|chain
op_assign
id|find_label
c_func
(paren
r_new
op_member_access_from_pointer
id|fwc_label
)paren
)paren
op_eq
l_int|NULL
)paren
id|ret
op_assign
id|ENOENT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|ip_fwkern
op_assign
id|convert_ipfw
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|fwc_rule
comma
op_amp
id|ret
)paren
)paren
op_ne
l_int|NULL
)paren
id|ret
op_assign
id|append_to_chain
c_func
(paren
id|chain
comma
id|ip_fwkern
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IP_FW_INSERT
suffix:colon
(brace
r_struct
id|ip_fwkernel
op_star
id|ip_fwkern
suffix:semicolon
r_struct
id|ip_fwnew
op_star
r_new
op_assign
id|m
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|ip_fwnew
)paren
op_logical_or
op_logical_neg
id|check_label
c_func
(paren
r_new
op_member_access_from_pointer
id|fwn_label
)paren
)paren
id|ret
op_assign
id|EINVAL
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|chain
op_assign
id|find_label
c_func
(paren
r_new
op_member_access_from_pointer
id|fwn_label
)paren
)paren
op_eq
l_int|NULL
)paren
id|ret
op_assign
id|ENOENT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|ip_fwkern
op_assign
id|convert_ipfw
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|fwn_rule
comma
op_amp
id|ret
)paren
)paren
op_ne
l_int|NULL
)paren
id|ret
op_assign
id|insert_in_chain
c_func
(paren
id|chain
comma
id|ip_fwkern
comma
r_new
op_member_access_from_pointer
id|fwn_rulenum
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IP_FW_DELETE
suffix:colon
(brace
r_struct
id|ip_fwchange
op_star
r_new
op_assign
id|m
suffix:semicolon
r_struct
id|ip_fwkernel
op_star
id|ip_fwkern
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|ip_fwchange
)paren
op_logical_or
op_logical_neg
id|check_label
c_func
(paren
r_new
op_member_access_from_pointer
id|fwc_label
)paren
)paren
id|ret
op_assign
id|EINVAL
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|chain
op_assign
id|find_label
c_func
(paren
r_new
op_member_access_from_pointer
id|fwc_label
)paren
)paren
op_eq
l_int|NULL
)paren
id|ret
op_assign
id|ENOENT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|ip_fwkern
op_assign
id|convert_ipfw
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|fwc_rule
comma
op_amp
id|ret
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|ret
op_assign
id|del_rule_from_chain
c_func
(paren
id|chain
comma
id|ip_fwkern
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ip_fwkern
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|IP_FW_DELETE_NUM
suffix:colon
(brace
r_struct
id|ip_fwdelnum
op_star
r_new
op_assign
id|m
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|ip_fwdelnum
)paren
op_logical_or
op_logical_neg
id|check_label
c_func
(paren
r_new
op_member_access_from_pointer
id|fwd_label
)paren
)paren
id|ret
op_assign
id|EINVAL
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|chain
op_assign
id|find_label
c_func
(paren
r_new
op_member_access_from_pointer
id|fwd_label
)paren
)paren
op_eq
l_int|NULL
)paren
id|ret
op_assign
id|ENOENT
suffix:semicolon
r_else
id|ret
op_assign
id|del_num_from_chain
c_func
(paren
id|chain
comma
r_new
op_member_access_from_pointer
id|fwd_rulenum
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IP_FW_CREATECHAIN
suffix:colon
(brace
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|ip_chainlabel
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;create_chain: bad size %i&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
id|ret
op_assign
id|EINVAL
suffix:semicolon
)brace
r_else
id|ret
op_assign
id|create_chain
c_func
(paren
id|m
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IP_FW_DELETECHAIN
suffix:colon
(brace
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|ip_chainlabel
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;delete_chain: bad size %i&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
id|ret
op_assign
id|EINVAL
suffix:semicolon
)brace
r_else
id|ret
op_assign
id|del_chain
c_func
(paren
id|m
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IP_FW_POLICY
suffix:colon
(brace
r_struct
id|ip_fwpolicy
op_star
r_new
op_assign
id|m
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_struct
id|ip_fwpolicy
)paren
op_logical_or
op_logical_neg
id|check_label
c_func
(paren
r_new
op_member_access_from_pointer
id|fwp_label
)paren
)paren
id|ret
op_assign
id|EINVAL
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|chain
op_assign
id|find_label
c_func
(paren
r_new
op_member_access_from_pointer
id|fwp_label
)paren
)paren
op_eq
l_int|NULL
)paren
id|ret
op_assign
id|ENOENT
suffix:semicolon
r_else
r_if
c_cond
(paren
id|chain
op_ne
id|IP_FW_INPUT_CHAIN
op_logical_and
id|chain
op_ne
id|IP_FW_FORWARD_CHAIN
op_logical_and
id|chain
op_ne
id|IP_FW_OUTPUT_CHAIN
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;change_policy: can&squot;t change policy on user&quot;
l_string|&quot; defined chain.&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
r_int
id|pol
op_assign
id|FW_SKIP
suffix:semicolon
id|find_special
c_func
(paren
r_new
op_member_access_from_pointer
id|fwp_policy
comma
op_amp
id|pol
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|pol
)paren
(brace
r_case
id|FW_MASQUERADE
suffix:colon
r_if
c_cond
(paren
id|chain
op_ne
id|IP_FW_FORWARD_CHAIN
)paren
(brace
id|ret
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Fall thru... */
r_case
id|FW_BLOCK
suffix:colon
r_case
id|FW_ACCEPT
suffix:colon
r_case
id|FW_REJECT
suffix:colon
id|ret
op_assign
id|change_policy
c_func
(paren
id|chain
comma
id|pol
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|duprintf
c_func
(paren
l_string|&quot;change_policy: bad policy `%s&squot;&bslash;n&quot;
comma
r_new
op_member_access_from_pointer
id|fwp_policy
)paren
suffix:semicolon
id|ret
op_assign
id|EINVAL
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|duprintf
c_func
(paren
l_string|&quot;ip_fw_ctl:  unknown request %d&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|ret
op_assign
id|ENOPROTOOPT
suffix:semicolon
)brace
id|FWC_WRITE_UNLOCK_IRQ
c_func
(paren
op_amp
id|ip_fw_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Returns bytes used - doesn&squot;t NUL terminate */
DECL|function|dump_rule
r_static
r_int
id|dump_rule
c_func
(paren
r_char
op_star
id|buffer
comma
r_const
r_char
op_star
id|chainlabel
comma
r_const
r_struct
id|ip_fwkernel
op_star
id|rule
)paren
(brace
r_int
id|len
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|__u64
id|packets
op_assign
l_int|0
comma
id|bytes
op_assign
l_int|0
suffix:semicolon
id|FWC_HAVE_LOCK
c_func
(paren
id|fwc_wlocks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_SLOTS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|packets
op_add_assign
id|rule-&gt;counters
(braket
id|i
)braket
dot
id|pcnt
suffix:semicolon
id|bytes
op_add_assign
id|rule-&gt;counters
(braket
id|i
)braket
dot
id|bcnt
suffix:semicolon
)brace
id|len
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%9s &quot;
multiline_comment|/* Chain name */
l_string|&quot;%08X/%08X-&gt;%08X/%08X &quot;
multiline_comment|/* Source &amp; Destination IPs */
l_string|&quot;%.16s &quot;
multiline_comment|/* Interface */
l_string|&quot;%X %X &quot;
multiline_comment|/* fw_flg and fw_invflg fields */
l_string|&quot;%u &quot;
multiline_comment|/* Protocol */
l_string|&quot;%-9u %-9u %-9u %-9u &quot;
multiline_comment|/* Packet &amp; byte counters */
l_string|&quot;%u-%u %u-%u &quot;
multiline_comment|/* Source &amp; Dest port ranges */
l_string|&quot;A%02X X%02X &quot;
multiline_comment|/* TOS and and xor masks */
l_string|&quot;%08X &quot;
multiline_comment|/* Redirection port */
l_string|&quot;%u &quot;
multiline_comment|/* fw_mark field */
l_string|&quot;%u &quot;
multiline_comment|/* output size */
l_string|&quot;%9s&bslash;n&quot;
comma
multiline_comment|/* Target */
id|chainlabel
comma
id|ntohl
c_func
(paren
id|rule-&gt;ipfw.fw_src.s_addr
)paren
comma
id|ntohl
c_func
(paren
id|rule-&gt;ipfw.fw_smsk.s_addr
)paren
comma
id|ntohl
c_func
(paren
id|rule-&gt;ipfw.fw_dst.s_addr
)paren
comma
id|ntohl
c_func
(paren
id|rule-&gt;ipfw.fw_dmsk.s_addr
)paren
comma
(paren
id|rule-&gt;ipfw.fw_vianame
)paren
(braket
l_int|0
)braket
ques
c_cond
id|rule-&gt;ipfw.fw_vianame
suffix:colon
l_string|&quot;-&quot;
comma
id|rule-&gt;ipfw.fw_flg
comma
id|rule-&gt;ipfw.fw_invflg
comma
id|rule-&gt;ipfw.fw_proto
comma
(paren
id|__u32
)paren
(paren
id|packets
op_rshift
l_int|32
)paren
comma
(paren
id|__u32
)paren
id|packets
comma
(paren
id|__u32
)paren
(paren
id|bytes
op_rshift
l_int|32
)paren
comma
(paren
id|__u32
)paren
id|bytes
comma
id|rule-&gt;ipfw.fw_spts
(braket
l_int|0
)braket
comma
id|rule-&gt;ipfw.fw_spts
(braket
l_int|1
)braket
comma
id|rule-&gt;ipfw.fw_dpts
(braket
l_int|0
)braket
comma
id|rule-&gt;ipfw.fw_dpts
(braket
l_int|1
)braket
comma
id|rule-&gt;ipfw.fw_tosand
comma
id|rule-&gt;ipfw.fw_tosxor
comma
id|rule-&gt;ipfw.fw_redirpt
comma
id|rule-&gt;ipfw.fw_mark
comma
id|rule-&gt;ipfw.fw_outputsize
comma
id|branchname
c_func
(paren
id|rule-&gt;branch
comma
id|rule-&gt;simplebranch
)paren
)paren
suffix:semicolon
id|duprintf
c_func
(paren
l_string|&quot;dump_rule: %i bytes done.&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* File offset is actually in records, not bytes. */
DECL|function|ip_chain_procinfo
r_static
r_int
id|ip_chain_procinfo
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,29)
comma
r_int
id|reset
macro_line|#endif
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,29)
multiline_comment|/* FIXME: No more `atomic&squot; read and reset.  Wonderful 8-( --RR */
r_int
id|reset
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_struct
id|ip_chain
op_star
id|i
suffix:semicolon
r_struct
id|ip_fwkernel
op_star
id|j
op_assign
id|ip_fw_chains-&gt;chain
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|last_len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|upto
op_assign
l_int|0
suffix:semicolon
id|duprintf
c_func
(paren
l_string|&quot;Offset starts at %lu&bslash;n&quot;
comma
id|offset
)paren
suffix:semicolon
id|duprintf
c_func
(paren
l_string|&quot;ip_fw_chains is 0x%0lX&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ip_fw_chains
)paren
suffix:semicolon
multiline_comment|/* Need a write lock to lock out ``readers&squot;&squot; which update counters. */
id|FWC_WRITE_LOCK_IRQ
c_func
(paren
op_amp
id|ip_fw_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|ip_fw_chains
suffix:semicolon
id|i
suffix:semicolon
id|i
op_assign
id|i-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|i-&gt;chain
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|upto
op_eq
id|offset
)paren
r_break
suffix:semicolon
id|duprintf
c_func
(paren
l_string|&quot;Skipping rule in chain `%s&squot;&bslash;n&quot;
comma
id|i-&gt;label
)paren
suffix:semicolon
id|upto
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|upto
op_eq
id|offset
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t init j first time, or once i = NULL */
r_for
c_loop
(paren
suffix:semicolon
id|i
suffix:semicolon
(paren
r_void
)paren
(paren
(paren
id|i
op_assign
id|i-&gt;next
)paren
op_logical_and
(paren
id|j
op_assign
id|i-&gt;chain
)paren
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Dumping chain `%s&squot;&bslash;n&quot;
comma
id|i-&gt;label
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
comma
id|upto
op_increment
comma
id|last_len
op_assign
id|len
)paren
(brace
id|len
op_add_assign
id|dump_rule
c_func
(paren
id|buffer
op_plus
id|len
comma
id|i-&gt;label
comma
id|j
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Dumped to %i (past %i).  &quot;
l_string|&quot;Moving back to %i.&bslash;n&quot;
comma
id|len
comma
id|length
comma
id|last_len
)paren
suffix:semicolon
id|len
op_assign
id|last_len
suffix:semicolon
r_goto
id|outside
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reset
)paren
id|memset
c_func
(paren
id|j-&gt;counters
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ip_counters
)paren
op_star
id|NUM_SLOTS
)paren
suffix:semicolon
)brace
)brace
id|outside
suffix:colon
id|FWC_WRITE_UNLOCK_IRQ
c_func
(paren
op_amp
id|ip_fw_lock
comma
id|flags
)paren
suffix:semicolon
id|buffer
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|duprintf
c_func
(paren
l_string|&quot;ip_chain_procinfo: Length = %i (of %i).  Offset = %li.&bslash;n&quot;
comma
id|len
comma
id|length
comma
id|upto
)paren
suffix:semicolon
multiline_comment|/* `start&squot; hack - see fs/proc/generic.c line ~165 */
op_star
id|start
op_assign
(paren
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|upto
op_minus
id|offset
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|ip_chain_name_procinfo
r_static
r_int
id|ip_chain_name_procinfo
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_struct
id|ip_chain
op_star
id|i
suffix:semicolon
r_int
id|len
op_assign
l_int|0
comma
id|last_len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
comma
id|begin
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Need a write lock to lock out ``readers&squot;&squot; which update counters. */
id|FWC_WRITE_LOCK_IRQ
c_func
(paren
op_amp
id|ip_fw_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|ip_fw_chains
suffix:semicolon
id|i
suffix:semicolon
id|i
op_assign
id|i-&gt;next
)paren
(brace
r_int
r_int
id|j
suffix:semicolon
id|__u32
id|packetsHi
op_assign
l_int|0
comma
id|packetsLo
op_assign
l_int|0
comma
id|bytesHi
op_assign
l_int|0
comma
id|bytesLo
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NUM_SLOTS
suffix:semicolon
id|j
op_increment
)paren
(brace
id|packetsLo
op_add_assign
id|i-&gt;reent
(braket
id|j
)braket
dot
id|counters.pcnt
op_amp
l_int|0xFFFFFFFF
suffix:semicolon
id|packetsHi
op_add_assign
(paren
(paren
id|i-&gt;reent
(braket
id|j
)braket
dot
id|counters.pcnt
op_rshift
l_int|32
)paren
op_amp
l_int|0xFFFFFFFF
)paren
suffix:semicolon
id|bytesLo
op_add_assign
id|i-&gt;reent
(braket
id|j
)braket
dot
id|counters.bcnt
op_amp
l_int|0xFFFFFFFF
suffix:semicolon
id|bytesHi
op_add_assign
(paren
(paren
id|i-&gt;reent
(braket
id|j
)braket
dot
id|counters.bcnt
op_rshift
l_int|32
)paren
op_amp
l_int|0xFFFFFFFF
)paren
suffix:semicolon
)brace
multiline_comment|/* print the label and the policy */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%s %s %i %u %u %u %u&bslash;n&quot;
comma
id|i-&gt;label
comma
id|branchname
c_func
(paren
l_int|NULL
comma
id|i-&gt;policy
)paren
comma
id|i-&gt;refcount
comma
id|packetsHi
comma
id|packetsLo
comma
id|bytesHi
comma
id|bytesLo
)paren
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
(brace
id|len
op_assign
id|last_len
suffix:semicolon
r_break
suffix:semicolon
)brace
id|last_len
op_assign
id|len
suffix:semicolon
)brace
id|FWC_WRITE_UNLOCK_IRQ
c_func
(paren
op_amp
id|ip_fw_lock
comma
id|flags
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Interface to the generic firewall chains.&n; */
DECL|function|ipfw_input_check
r_int
id|ipfw_input_check
c_func
(paren
r_struct
id|firewall_ops
op_star
id|this
comma
r_int
id|pf
comma
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|phdr
comma
r_void
op_star
id|arg
comma
r_struct
id|sk_buff
op_star
op_star
id|pskb
)paren
(brace
r_return
id|ip_fw_check
c_func
(paren
id|phdr
comma
id|dev-&gt;name
comma
id|arg
comma
id|IP_FW_INPUT_CHAIN
comma
op_star
id|pskb
comma
id|SLOT_NUMBER
c_func
(paren
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|ipfw_output_check
r_int
id|ipfw_output_check
c_func
(paren
r_struct
id|firewall_ops
op_star
id|this
comma
r_int
id|pf
comma
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|phdr
comma
r_void
op_star
id|arg
comma
r_struct
id|sk_buff
op_star
op_star
id|pskb
)paren
(brace
multiline_comment|/* Locally generated bogus packets by root. &lt;SIGH&gt;. */
r_if
c_cond
(paren
(paren
(paren
r_struct
id|iphdr
op_star
)paren
id|phdr
)paren
op_member_access_from_pointer
id|ihl
op_star
l_int|4
OL
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_logical_or
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|len
OL
r_sizeof
(paren
r_struct
id|iphdr
)paren
)paren
r_return
id|FW_ACCEPT
suffix:semicolon
r_return
id|ip_fw_check
c_func
(paren
id|phdr
comma
id|dev-&gt;name
comma
id|arg
comma
id|IP_FW_OUTPUT_CHAIN
comma
op_star
id|pskb
comma
id|SLOT_NUMBER
c_func
(paren
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|ipfw_forward_check
r_int
id|ipfw_forward_check
c_func
(paren
r_struct
id|firewall_ops
op_star
id|this
comma
r_int
id|pf
comma
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|phdr
comma
r_void
op_star
id|arg
comma
r_struct
id|sk_buff
op_star
op_star
id|pskb
)paren
(brace
r_return
id|ip_fw_check
c_func
(paren
id|phdr
comma
id|dev-&gt;name
comma
id|arg
comma
id|IP_FW_FORWARD_CHAIN
comma
op_star
id|pskb
comma
id|SLOT_NUMBER
c_func
(paren
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|ipfw_ops
r_struct
id|firewall_ops
id|ipfw_ops
op_assign
(brace
l_int|NULL
comma
id|ipfw_forward_check
comma
id|ipfw_input_check
comma
id|ipfw_output_check
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|ipfw_init_or_cleanup
r_int
id|ipfw_init_or_cleanup
c_func
(paren
r_int
id|init
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|FWC_WRITE_LOCK_IRQ
c_func
(paren
op_amp
id|ip_fw_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|init
)paren
r_goto
id|cleanup
suffix:semicolon
macro_line|#ifdef DEBUG_IP_FIREWALL_LOCKING
id|fwc_wlocks
op_assign
id|fwc_rlocks
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_NETLINK_DEV) || defined(CONFIG_NETLINK_DEV_MODULE)
id|ipfwsk
op_assign
id|netlink_kernel_create
c_func
(paren
id|NETLINK_FIREWALL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ipfwsk
op_eq
l_int|NULL
)paren
r_goto
id|cleanup_nothing
suffix:semicolon
macro_line|#endif
id|ret
op_assign
id|register_firewall
c_func
(paren
id|PF_INET
comma
op_amp
id|ipfw_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|cleanup_netlink
suffix:semicolon
id|proc_net_create
c_func
(paren
id|IP_FW_PROC_CHAINS
comma
id|S_IFREG
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
id|ip_chain_procinfo
)paren
suffix:semicolon
id|proc_net_create
c_func
(paren
id|IP_FW_PROC_CHAIN_NAMES
comma
id|S_IFREG
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
id|ip_chain_name_procinfo
)paren
suffix:semicolon
id|IP_FW_INPUT_CHAIN
op_assign
id|ip_init_chain
c_func
(paren
id|IP_FW_LABEL_INPUT
comma
l_int|1
comma
id|FW_ACCEPT
)paren
suffix:semicolon
id|IP_FW_FORWARD_CHAIN
op_assign
id|ip_init_chain
c_func
(paren
id|IP_FW_LABEL_FORWARD
comma
l_int|1
comma
id|FW_ACCEPT
)paren
suffix:semicolon
id|IP_FW_OUTPUT_CHAIN
op_assign
id|ip_init_chain
c_func
(paren
id|IP_FW_LABEL_OUTPUT
comma
l_int|1
comma
id|FW_ACCEPT
)paren
suffix:semicolon
id|FWC_WRITE_UNLOCK_IRQ
c_func
(paren
op_amp
id|ip_fw_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
id|cleanup
suffix:colon
r_while
c_loop
(paren
id|ip_fw_chains
)paren
(brace
r_struct
id|ip_chain
op_star
id|next
op_assign
id|ip_fw_chains-&gt;next
suffix:semicolon
id|clear_fw_chain
c_func
(paren
id|ip_fw_chains
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ip_fw_chains
)paren
suffix:semicolon
id|ip_fw_chains
op_assign
id|next
suffix:semicolon
)brace
id|proc_net_remove
c_func
(paren
id|IP_FW_PROC_CHAINS
)paren
suffix:semicolon
id|proc_net_remove
c_func
(paren
id|IP_FW_PROC_CHAIN_NAMES
)paren
suffix:semicolon
id|unregister_firewall
c_func
(paren
id|PF_INET
comma
op_amp
id|ipfw_ops
)paren
suffix:semicolon
id|cleanup_netlink
suffix:colon
macro_line|#if defined(CONFIG_NETLINK_DEV) || defined(CONFIG_NETLINK_DEV_MODULE)
id|sock_release
c_func
(paren
id|ipfwsk-&gt;socket
)paren
suffix:semicolon
id|cleanup_nothing
suffix:colon
macro_line|#endif
id|FWC_WRITE_UNLOCK_IRQ
c_func
(paren
op_amp
id|ip_fw_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
