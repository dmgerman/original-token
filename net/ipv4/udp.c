multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;The User Datagram Protocol (UDP).&n; *&n; * Version:&t;@(#)udp.c&t;1.0.13&t;06/02/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Alan Cox, &lt;Alan.Cox@linux.org&gt;&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;verify_area() calls&n; *&t;&t;Alan Cox&t;: &t;stopped close while in use off icmp&n; *&t;&t;&t;&t;&t;messages. Not a fix but a botch that&n; *&t;&t;&t;&t;&t;for udp at least is &squot;valid&squot;.&n; *&t;&t;Alan Cox&t;:&t;Fixed icmp handling properly&n; *&t;&t;Alan Cox&t;: &t;Correct error for oversized datagrams&n; *&t;&t;Alan Cox&t;:&t;Tidied select() semantics. &n; *&t;&t;Alan Cox&t;:&t;udp_err() fixed properly, also now &n; *&t;&t;&t;&t;&t;select and read wake correctly on errors&n; *&t;&t;Alan Cox&t;:&t;udp_send verify_area moved to avoid mem leak&n; *&t;&t;Alan Cox&t;:&t;UDP can count its memory&n; *&t;&t;Alan Cox&t;:&t;send to an unknown connection causes&n; *&t;&t;&t;&t;&t;an ECONNREFUSED off the icmp, but&n; *&t;&t;&t;&t;&t;does NOT close.&n; *&t;&t;Alan Cox&t;:&t;Switched to new sk_buff handlers. No more backlog!&n; *&t;&t;Alan Cox&t;:&t;Using generic datagram code. Even smaller and the PEEK&n; *&t;&t;&t;&t;&t;bug no longer crashes it.&n; *&t;&t;Fred Van Kempen&t;: &t;Net2e support for sk-&gt;broadcast.&n; *&t;&t;Alan Cox&t;:&t;Uses skb_free_datagram&n; *&t;&t;Alan Cox&t;:&t;Added get/set sockopt support.&n; *&t;&t;Alan Cox&t;:&t;Broadcasting without option set returns EACCES.&n; *&t;&t;Alan Cox&t;:&t;No wakeup calls. Instead we now use the callbacks.&n; *&t;&t;Alan Cox&t;:&t;Use ip_tos and ip_ttl&n; *&t;&t;Alan Cox&t;:&t;SNMP Mibs&n; *&t;&t;Alan Cox&t;:&t;MSG_DONTROUTE, and 0.0.0.0 support.&n; *&t;&t;Matt Dillon&t;:&t;UDP length checks.&n; *&t;&t;Alan Cox&t;:&t;Smarter af_inet used properly.&n; *&t;&t;Alan Cox&t;:&t;Use new kernel side addressing.&n; *&t;&t;Alan Cox&t;:&t;Incorrect return on truncated datagram receive.&n; *&t;Arnt Gulbrandsen &t;:&t;New udp_send and stuff&n; *&t;&t;Alan Cox&t;:&t;Cache last socket&n; *&t;&t;Alan Cox&t;:&t;Route cache&n; *&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/termios.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;net/snmp.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
multiline_comment|/*&n; *&t;SNMP MIB for the UDP layer&n; */
DECL|variable|udp_statistics
r_struct
id|udp_mib
id|udp_statistics
suffix:semicolon
multiline_comment|/*&n; *&t;Cached last hit socket&n; */
DECL|variable|uh_cache_saddr
DECL|variable|uh_cache_daddr
r_volatile
r_int
r_int
id|uh_cache_saddr
comma
id|uh_cache_daddr
suffix:semicolon
DECL|variable|uh_cache_dport
DECL|variable|uh_cache_sport
r_volatile
r_int
r_int
id|uh_cache_dport
comma
id|uh_cache_sport
suffix:semicolon
DECL|variable|uh_cache_sk
r_volatile
r_struct
id|sock
op_star
id|uh_cache_sk
suffix:semicolon
DECL|function|udp_cache_zap
r_void
id|udp_cache_zap
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|uh_cache_saddr
op_assign
l_int|0
suffix:semicolon
id|uh_cache_daddr
op_assign
l_int|0
suffix:semicolon
id|uh_cache_dport
op_assign
l_int|0
suffix:semicolon
id|uh_cache_sport
op_assign
l_int|0
suffix:semicolon
id|uh_cache_sk
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
id|udp_deliver
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|udphdr
op_star
id|uh
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_int
id|saddr
comma
r_int
id|daddr
comma
r_int
id|len
)paren
suffix:semicolon
DECL|macro|min
mdefine_line|#define min(a,b)&t;((a)&lt;(b)?(a):(b))
multiline_comment|/*&n; * This routine is called by the ICMP module when it gets some&n; * sort of error condition.  If err &lt; 0 then the socket should&n; * be closed and the error returned to the user.  If err &gt; 0&n; * it&squot;s just the icmp type &lt;&lt; 8 | icmp code.  &n; * Header points to the ip header of the error packet. We move&n; * on past this. Then (as it used to claim before adjustment)&n; * header points to the first 8 bytes of the udp header.  We need&n; * to find the appropriate port.&n; */
DECL|function|udp_err
r_void
id|udp_err
c_func
(paren
r_int
id|err
comma
r_int
r_char
op_star
id|header
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|saddr
comma
r_struct
id|inet_protocol
op_star
id|protocol
)paren
(brace
r_struct
id|udphdr
op_star
id|th
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_struct
id|iphdr
op_star
id|ip
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|header
suffix:semicolon
id|header
op_add_assign
l_int|4
op_star
id|ip-&gt;ihl
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Find the 8 bytes of post IP header ICMP included for us&n;&t; */
id|th
op_assign
(paren
r_struct
id|udphdr
op_star
)paren
id|header
suffix:semicolon
id|sk
op_assign
id|get_sock
c_func
(paren
op_amp
id|udp_prot
comma
id|th-&gt;source
comma
id|daddr
comma
id|th-&gt;dest
comma
id|saddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* No socket for error */
r_if
c_cond
(paren
(paren
id|err
op_amp
l_int|0xff00
)paren
op_eq
(paren
id|ICMP_SOURCE_QUENCH
op_lshift
l_int|8
)paren
)paren
(brace
multiline_comment|/* Slow down! */
r_if
c_cond
(paren
id|sk-&gt;cong_window
OG
l_int|1
)paren
id|sk-&gt;cong_window
op_assign
id|sk-&gt;cong_window
op_div
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Various people wanted BSD UDP semantics. Well they&squot;ve come &n;&t; *&t;back out because they slow down response to stuff like dead&n;&t; *&t;or unreachable name servers and they screw term users something&n;&t; *&t;chronic. Oh and it violates RFC1122. So basically fix your &n;&t; *&t;client code people.&n;&t; */
r_if
c_cond
(paren
id|icmp_err_convert
(braket
id|err
op_amp
l_int|0xff
)braket
dot
id|fatal
)paren
(brace
id|sk-&gt;err
op_assign
id|icmp_err_convert
(braket
id|err
op_amp
l_int|0xff
)braket
dot
id|errno
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
DECL|function|udp_check
r_static
r_int
r_int
id|udp_check
c_func
(paren
r_struct
id|udphdr
op_star
id|uh
comma
r_int
id|len
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
)paren
(brace
r_return
id|csum_tcpudp_magic
c_func
(paren
id|saddr
comma
id|daddr
comma
id|len
comma
id|IPPROTO_UDP
comma
id|csum_partial
c_func
(paren
(paren
r_char
op_star
)paren
id|uh
comma
id|len
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
DECL|struct|udpfakehdr
r_struct
id|udpfakehdr
(brace
DECL|member|uh
r_struct
id|udphdr
id|uh
suffix:semicolon
DECL|member|daddr
r_int
id|daddr
suffix:semicolon
DECL|member|other
r_int
id|other
suffix:semicolon
DECL|member|from
r_char
op_star
id|from
suffix:semicolon
DECL|member|wcheck
r_int
id|wcheck
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Copy and checksum a UDP packet from user space into a buffer. We still have to do the planning to&n; *&t;get ip_build_xmit to spot direct transfer to network card and provide an additional callback mode&n; *&t;for direct user-&gt;board I/O transfers. That one will be fun.&n; */
DECL|function|udp_getfrag
r_static
r_void
id|udp_getfrag
c_func
(paren
r_void
op_star
id|p
comma
r_int
id|saddr
comma
r_char
op_star
id|to
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|fraglen
)paren
(brace
r_struct
id|udpfakehdr
op_star
id|ufh
op_assign
(paren
r_struct
id|udpfakehdr
op_star
)paren
id|p
suffix:semicolon
r_char
op_star
id|src
comma
op_star
id|dst
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
(brace
id|len
op_assign
id|fraglen
suffix:semicolon
id|src
op_assign
id|ufh-&gt;from
op_plus
(paren
id|offset
op_minus
r_sizeof
(paren
r_struct
id|udphdr
)paren
)paren
suffix:semicolon
id|dst
op_assign
id|to
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
id|fraglen
op_minus
r_sizeof
(paren
r_struct
id|udphdr
)paren
suffix:semicolon
id|src
op_assign
id|ufh-&gt;from
suffix:semicolon
id|dst
op_assign
id|to
op_plus
r_sizeof
(paren
r_struct
id|udphdr
)paren
suffix:semicolon
)brace
id|ufh-&gt;wcheck
op_assign
id|csum_partial_copyffs
c_func
(paren
id|src
comma
id|dst
comma
id|len
comma
id|ufh-&gt;wcheck
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
)paren
(brace
id|ufh-&gt;wcheck
op_assign
id|csum_partial
c_func
(paren
(paren
r_char
op_star
)paren
id|ufh
comma
r_sizeof
(paren
r_struct
id|udphdr
)paren
comma
id|ufh-&gt;wcheck
)paren
suffix:semicolon
id|ufh-&gt;uh.check
op_assign
id|csum_tcpudp_magic
c_func
(paren
id|saddr
comma
id|ufh-&gt;daddr
comma
id|ntohs
c_func
(paren
id|ufh-&gt;uh.len
)paren
comma
id|IPPROTO_UDP
comma
id|ufh-&gt;wcheck
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ufh-&gt;uh.check
op_eq
l_int|0
)paren
id|ufh-&gt;uh.check
op_assign
op_minus
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|to
comma
id|ufh
comma
r_sizeof
(paren
r_struct
id|udphdr
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Uncheckummed UDP is sufficiently criticial to stuff like ATM video conferencing&n; *&t;that we use two routines for this for speed. Probably we ought to have a CONFIG_FAST_NET&n; *&t;set for &gt;10Mb/second boards to activate this sort of coding. Timing needed to verify if&n; *&t;this is a valid decision.&n; */
DECL|function|udp_getfrag_nosum
r_static
r_void
id|udp_getfrag_nosum
c_func
(paren
r_void
op_star
id|p
comma
r_int
id|saddr
comma
r_char
op_star
id|to
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|fraglen
)paren
(brace
r_struct
id|udpfakehdr
op_star
id|ufh
op_assign
(paren
r_struct
id|udpfakehdr
op_star
)paren
id|p
suffix:semicolon
r_char
op_star
id|src
comma
op_star
id|dst
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
(brace
id|len
op_assign
id|fraglen
suffix:semicolon
id|src
op_assign
id|ufh-&gt;from
op_plus
(paren
id|offset
op_minus
r_sizeof
(paren
r_struct
id|udphdr
)paren
)paren
suffix:semicolon
id|dst
op_assign
id|to
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
id|fraglen
op_minus
r_sizeof
(paren
r_struct
id|udphdr
)paren
suffix:semicolon
id|src
op_assign
id|ufh-&gt;from
suffix:semicolon
id|dst
op_assign
id|to
op_plus
r_sizeof
(paren
r_struct
id|udphdr
)paren
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
id|src
comma
id|dst
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
)paren
id|memcpy
c_func
(paren
id|to
comma
id|ufh
comma
r_sizeof
(paren
r_struct
id|udphdr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send UDP frames.&n; */
DECL|function|udp_send
r_static
r_int
id|udp_send
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr_in
op_star
id|sin
comma
r_int
r_char
op_star
id|from
comma
r_int
id|len
comma
r_int
id|rt
)paren
(brace
r_int
id|ulen
op_assign
id|len
op_plus
r_sizeof
(paren
r_struct
id|udphdr
)paren
suffix:semicolon
r_int
id|a
suffix:semicolon
r_struct
id|udpfakehdr
id|ufh
suffix:semicolon
id|ufh.uh.source
op_assign
id|sk-&gt;dummy_th.source
suffix:semicolon
id|ufh.uh.dest
op_assign
id|sin-&gt;sin_port
suffix:semicolon
id|ufh.uh.len
op_assign
id|htons
c_func
(paren
id|ulen
)paren
suffix:semicolon
id|ufh.uh.check
op_assign
l_int|0
suffix:semicolon
id|ufh.daddr
op_assign
id|sin-&gt;sin_addr.s_addr
suffix:semicolon
id|ufh.other
op_assign
(paren
id|htons
c_func
(paren
id|ulen
)paren
op_lshift
l_int|16
)paren
op_plus
id|IPPROTO_UDP
op_star
l_int|256
suffix:semicolon
id|ufh.from
op_assign
id|from
suffix:semicolon
id|ufh.wcheck
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;no_check
)paren
(brace
id|a
op_assign
id|ip_build_xmit
c_func
(paren
id|sk
comma
id|udp_getfrag_nosum
comma
op_amp
id|ufh
comma
id|ulen
comma
id|sin-&gt;sin_addr.s_addr
comma
id|rt
comma
id|IPPROTO_UDP
)paren
suffix:semicolon
)brace
r_else
id|a
op_assign
id|ip_build_xmit
c_func
(paren
id|sk
comma
id|udp_getfrag
comma
op_amp
id|ufh
comma
id|ulen
comma
id|sin-&gt;sin_addr.s_addr
comma
id|rt
comma
id|IPPROTO_UDP
)paren
suffix:semicolon
r_return
id|a
OL
l_int|0
ques
c_cond
id|a
suffix:colon
id|len
suffix:semicolon
)brace
DECL|function|udp_sendto
r_static
r_int
id|udp_sendto
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|from
comma
r_int
id|len
comma
r_int
id|noblock
comma
r_int
id|flags
comma
r_struct
id|sockaddr_in
op_star
id|usin
comma
r_int
id|addr_len
)paren
(brace
r_struct
id|sockaddr_in
id|sin
suffix:semicolon
r_int
id|tmp
suffix:semicolon
multiline_comment|/* &n;&t; *&t;Check the flags. We support no flags for UDP sending&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
op_complement
id|MSG_DONTROUTE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Get and verify the address. &n;&t; */
r_if
c_cond
(paren
id|usin
)paren
(brace
r_if
c_cond
(paren
id|addr_len
OL
r_sizeof
(paren
id|sin
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|sin
comma
id|usin
comma
r_sizeof
(paren
id|sin
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sin.sin_family
op_logical_and
id|sin.sin_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sin.sin_port
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|sin.sin_family
op_assign
id|AF_INET
suffix:semicolon
id|sin.sin_port
op_assign
id|sk-&gt;dummy_th.dest
suffix:semicolon
id|sin.sin_addr.s_addr
op_assign
id|sk-&gt;daddr
suffix:semicolon
)brace
multiline_comment|/*&n;  &t; *&t;BSD socket semantics. You must set SO_BROADCAST to permit&n;  &t; *&t;broadcasting of data.&n;  &t; */
r_if
c_cond
(paren
id|sin.sin_addr.s_addr
op_eq
id|INADDR_ANY
)paren
(brace
id|sin.sin_addr.s_addr
op_assign
id|ip_my_addr
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;broadcast
op_logical_and
id|ip_chk_addr
c_func
(paren
id|sin.sin_addr.s_addr
)paren
op_eq
id|IS_BROADCAST
)paren
(brace
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
multiline_comment|/* Must turn broadcast on first */
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Send the packet. */
id|tmp
op_assign
id|udp_send
c_func
(paren
id|sk
comma
op_amp
id|sin
comma
id|from
comma
id|len
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* The datagram has been sent off.  Release the socket. */
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;In BSD SOCK_DGRAM a write is just like a send.&n; */
DECL|function|udp_write
r_static
r_int
id|udp_write
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|noblock
comma
r_int
id|flags
)paren
(brace
r_return
id|udp_sendto
c_func
(paren
id|sk
comma
id|buff
comma
id|len
comma
id|noblock
comma
id|flags
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;IOCTL requests applicable to the UDP protocol&n; */
DECL|function|udp_ioctl
r_int
id|udp_ioctl
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCOUTQ
suffix:colon
(brace
r_int
r_int
id|amount
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|amount
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wspace
c_func
(paren
id|sk
)paren
multiline_comment|/*/2*/
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_fs_long
c_func
(paren
id|amount
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|TIOCINQ
suffix:colon
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|amount
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|amount
op_assign
l_int|0
suffix:semicolon
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We will only return the amount&n;&t;&t;&t;&t; * of this packet since that is all&n;&t;&t;&t;&t; * that will be read.&n;&t;&t;&t;&t; */
id|amount
op_assign
id|skb-&gt;len
suffix:semicolon
)brace
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_fs_long
c_func
(paren
id|amount
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;This should be easy, if there is something there we&bslash;&n; * &t;return it, otherwise we block.&n; */
DECL|function|udp_recvfrom
r_int
id|udp_recvfrom
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|to
comma
r_int
id|len
comma
r_int
id|noblock
comma
r_int
id|flags
comma
r_struct
id|sockaddr_in
op_star
id|sin
comma
r_int
op_star
id|addr_len
)paren
(brace
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
r_int
id|truesize
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|er
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Check any passed addresses&n;&t; */
r_if
c_cond
(paren
id|addr_len
)paren
op_star
id|addr_len
op_assign
r_sizeof
(paren
op_star
id|sin
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;From here the generic datagram does a lot of the work. Come&n;&t; *&t;the finished NET3, it will do _ALL_ the work!&n;&t; */
id|skb
op_assign
id|skb_recv_datagram
c_func
(paren
id|sk
comma
id|flags
comma
id|noblock
comma
op_amp
id|er
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_return
id|er
suffix:semicolon
)brace
id|truesize
op_assign
id|skb-&gt;len
op_minus
r_sizeof
(paren
r_struct
id|udphdr
)paren
suffix:semicolon
id|copied
op_assign
id|min
c_func
(paren
id|len
comma
id|truesize
)paren
suffix:semicolon
multiline_comment|/*&n;  &t; *&t;FIXME : should use udp header size info value &n;  &t; */
id|skb_copy_datagram
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|udphdr
)paren
comma
id|to
comma
id|copied
)paren
suffix:semicolon
id|sk-&gt;stamp
op_assign
id|skb-&gt;stamp
suffix:semicolon
multiline_comment|/* Copy the address. */
r_if
c_cond
(paren
id|sin
)paren
(brace
id|sin-&gt;sin_family
op_assign
id|AF_INET
suffix:semicolon
id|sin-&gt;sin_port
op_assign
id|skb-&gt;h.uh-&gt;source
suffix:semicolon
id|sin-&gt;sin_addr.s_addr
op_assign
id|skb-&gt;daddr
suffix:semicolon
)brace
id|skb_free_datagram
c_func
(paren
id|skb
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|copied
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Read has the same semantics as recv in SOCK_DGRAM&n; */
DECL|function|udp_read
r_int
id|udp_read
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|noblock
comma
r_int
id|flags
)paren
(brace
r_return
id|udp_recvfrom
c_func
(paren
id|sk
comma
id|buff
comma
id|len
comma
id|noblock
comma
id|flags
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|udp_connect
r_int
id|udp_connect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr_in
op_star
id|usin
comma
r_int
id|addr_len
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_int
r_int
id|sa
suffix:semicolon
r_if
c_cond
(paren
id|addr_len
OL
r_sizeof
(paren
op_star
id|usin
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|usin-&gt;sin_family
op_logical_and
id|usin-&gt;sin_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
r_if
c_cond
(paren
id|usin-&gt;sin_addr.s_addr
op_eq
id|INADDR_ANY
)paren
id|usin-&gt;sin_addr.s_addr
op_assign
id|ip_my_addr
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;broadcast
op_logical_and
id|ip_chk_addr
c_func
(paren
id|usin-&gt;sin_addr.s_addr
)paren
op_eq
id|IS_BROADCAST
)paren
(brace
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
multiline_comment|/* Must turn broadcast on first */
id|rt
op_assign
(paren
id|sk-&gt;localroute
ques
c_cond
id|ip_rt_local
suffix:colon
id|ip_rt_route
)paren
(paren
id|usin-&gt;sin_addr.s_addr
comma
l_int|NULL
comma
op_amp
id|sa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
)brace
id|sk-&gt;saddr
op_assign
id|sa
suffix:semicolon
multiline_comment|/* Update source address */
id|sk-&gt;daddr
op_assign
id|usin-&gt;sin_addr.s_addr
suffix:semicolon
id|sk-&gt;dummy_th.dest
op_assign
id|usin-&gt;sin_port
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_ESTABLISHED
suffix:semicolon
id|udp_cache_zap
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;ip_route_cache
op_assign
id|rt
suffix:semicolon
id|sk-&gt;ip_route_stamp
op_assign
id|rt_stamp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|udp_close
r_static
r_void
id|udp_close
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeout
)paren
(brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
r_if
c_cond
(paren
id|uh_cache_sk
op_eq
id|sk
)paren
(brace
id|udp_cache_zap
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;dead
)paren
id|destroy_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_else
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;All we need to do is get the socket, and then do a checksum. &n; */
DECL|function|udp_rcv
r_int
id|udp_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|options
op_star
id|opt
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|saddr
comma
r_int
id|redo
comma
r_struct
id|inet_protocol
op_star
id|protocol
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_struct
id|udphdr
op_star
id|uh
suffix:semicolon
r_int
r_int
id|ulen
suffix:semicolon
r_int
id|addr_type
op_assign
id|IS_MYADDR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
id|dev-&gt;pa_addr
op_ne
id|daddr
)paren
(brace
id|addr_type
op_assign
id|ip_chk_addr
c_func
(paren
id|daddr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Get the header.&n;&t; */
id|uh
op_assign
(paren
r_struct
id|udphdr
op_star
)paren
id|skb-&gt;h.uh
suffix:semicolon
id|ip_statistics.IpInDelivers
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Validate the packet and the UDP length.&n;&t; */
id|ulen
op_assign
id|ntohs
c_func
(paren
id|uh-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ulen
OG
id|len
op_logical_or
id|len
OL
r_sizeof
(paren
op_star
id|uh
)paren
op_logical_or
id|ulen
OL
r_sizeof
(paren
op_star
id|uh
)paren
)paren
(brace
id|NETDEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;UDP: short packet: %d/%d&bslash;n&quot;
comma
id|ulen
comma
id|len
)paren
)paren
suffix:semicolon
id|udp_statistics.UdpInErrors
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uh-&gt;check
op_logical_and
id|udp_check
c_func
(paren
id|uh
comma
id|len
comma
id|saddr
comma
id|daddr
)paren
)paren
(brace
multiline_comment|/* &lt;mea@utu.fi&gt; wants to know, who sent it, to&n;&t;&t;   go and stomp on the garbage sender... */
id|NETDEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;UDP: bad checksum. From %08lX:%d to %08lX:%d ulen %d&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|saddr
)paren
comma
id|ntohs
c_func
(paren
id|uh-&gt;source
)paren
comma
id|ntohl
c_func
(paren
id|daddr
)paren
comma
id|ntohs
c_func
(paren
id|uh-&gt;dest
)paren
comma
id|ulen
)paren
)paren
suffix:semicolon
id|udp_statistics.UdpInErrors
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|len
op_assign
id|ulen
suffix:semicolon
macro_line|#ifdef CONFIG_IP_MULTICAST
r_if
c_cond
(paren
id|addr_type
op_ne
id|IS_MYADDR
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Multicasts and broadcasts go to each listener.&n;&t;&t; */
r_struct
id|sock
op_star
id|sknext
op_assign
l_int|NULL
suffix:semicolon
id|sk
op_assign
id|get_sock_mcast
c_func
(paren
id|udp_prot.sock_array
(braket
id|ntohs
c_func
(paren
id|uh-&gt;dest
)paren
op_amp
(paren
id|SOCK_ARRAY_SIZE
op_minus
l_int|1
)paren
)braket
comma
id|uh-&gt;dest
comma
id|saddr
comma
id|uh-&gt;source
comma
id|daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
)paren
(brace
r_do
(brace
r_struct
id|sk_buff
op_star
id|skb1
suffix:semicolon
id|sknext
op_assign
id|get_sock_mcast
c_func
(paren
id|sk-&gt;next
comma
id|uh-&gt;dest
comma
id|saddr
comma
id|uh-&gt;source
comma
id|daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sknext
)paren
(brace
id|skb1
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
r_else
id|skb1
op_assign
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|skb1
)paren
(brace
id|udp_deliver
c_func
(paren
id|sk
comma
id|uh
comma
id|skb1
comma
id|dev
comma
id|saddr
comma
id|daddr
comma
id|len
)paren
suffix:semicolon
)brace
id|sk
op_assign
id|sknext
suffix:semicolon
)brace
r_while
c_loop
(paren
id|sknext
op_ne
l_int|NULL
)paren
(brace
suffix:semicolon
)brace
)brace
r_else
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|saddr
op_eq
id|uh_cache_saddr
op_logical_and
id|daddr
op_eq
id|uh_cache_daddr
op_logical_and
id|uh-&gt;dest
op_eq
id|uh_cache_dport
op_logical_and
id|uh-&gt;source
op_eq
id|uh_cache_sport
)paren
(brace
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|uh_cache_sk
suffix:semicolon
)brace
r_else
(brace
id|sk
op_assign
id|get_sock
c_func
(paren
op_amp
id|udp_prot
comma
id|uh-&gt;dest
comma
id|saddr
comma
id|uh-&gt;source
comma
id|daddr
)paren
suffix:semicolon
id|uh_cache_saddr
op_assign
id|saddr
suffix:semicolon
id|uh_cache_daddr
op_assign
id|daddr
suffix:semicolon
id|uh_cache_dport
op_assign
id|uh-&gt;dest
suffix:semicolon
id|uh_cache_sport
op_assign
id|uh-&gt;source
suffix:semicolon
id|uh_cache_sk
op_assign
id|sk
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
id|udp_statistics.UdpNoPorts
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|addr_type
op_eq
id|IS_MYADDR
)paren
(brace
id|icmp_send
c_func
(paren
id|skb
comma
id|ICMP_DEST_UNREACH
comma
id|ICMP_PORT_UNREACH
comma
l_int|0
comma
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Hmm.  We got an UDP broadcast to a port to which we&n;&t;&t; * don&squot;t wanna listen.  Ignore it.&n;&t;&t; */
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|udp_deliver
c_func
(paren
id|sk
comma
id|uh
comma
id|skb
comma
id|dev
comma
id|saddr
comma
id|daddr
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|udp_deliver
r_static
r_int
id|udp_deliver
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|udphdr
op_star
id|uh
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_int
id|saddr
comma
r_int
id|daddr
comma
r_int
id|len
)paren
(brace
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;These are supposed to be switched. &n;&t; */
id|skb-&gt;daddr
op_assign
id|saddr
suffix:semicolon
id|skb-&gt;saddr
op_assign
id|daddr
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Charge it to the socket, dropping if the queue is full.&n;&t; */
r_if
c_cond
(paren
id|sock_queue_rcv_skb
c_func
(paren
id|sk
comma
id|skb
)paren
OL
l_int|0
)paren
(brace
id|udp_statistics.UdpInErrors
op_increment
suffix:semicolon
id|ip_statistics.IpInDiscards
op_increment
suffix:semicolon
id|ip_statistics.IpInDelivers
op_decrement
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|udp_statistics.UdpInDatagrams
op_increment
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|udp_prot
r_struct
id|proto
id|udp_prot
op_assign
(brace
id|sock_wmalloc
comma
id|sock_rmalloc
comma
id|sock_wfree
comma
id|sock_rfree
comma
id|sock_rspace
comma
id|sock_wspace
comma
id|udp_close
comma
id|udp_read
comma
id|udp_write
comma
id|udp_sendto
comma
id|udp_recvfrom
comma
id|ip_build_header
comma
id|udp_connect
comma
l_int|NULL
comma
id|ip_queue_xmit
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
id|udp_rcv
comma
id|datagram_select
comma
id|udp_ioctl
comma
l_int|NULL
comma
l_int|NULL
comma
id|ip_setsockopt
comma
id|ip_getsockopt
comma
l_int|128
comma
l_int|0
comma
l_string|&quot;UDP&quot;
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|NULL
comma
)brace
)brace
suffix:semicolon
eof
