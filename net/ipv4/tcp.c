multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Implementation of the Transmission Control Protocol(TCP).&n; *&n; * Version:&t;@(#)tcp.c&t;1.0.16&t;05/25/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;&n; *&t;&t;Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;Numerous verify_area() calls&n; *&t;&t;Alan Cox&t;:&t;Set the ACK bit on a reset&n; *&t;&t;Alan Cox&t;:&t;Stopped it crashing if it closed while&n; *&t;&t;&t;&t;&t;sk-&gt;inuse=1 and was trying to connect&n; *&t;&t;&t;&t;&t;(tcp_err()).&n; *&t;&t;Alan Cox&t;:&t;All icmp error handling was broken&n; *&t;&t;&t;&t;&t;pointers passed where wrong and the&n; *&t;&t;&t;&t;&t;socket was looked up backwards. Nobody&n; *&t;&t;&t;&t;&t;tested any icmp error code obviously.&n; *&t;&t;Alan Cox&t;:&t;tcp_err() now handled properly. It&n; *&t;&t;&t;&t;&t;wakes people on errors. select&n; *&t;&t;&t;&t;&t;behaves and the icmp error race&n; *&t;&t;&t;&t;&t;has gone by moving it into sock.c&n; *&t;&t;Alan Cox&t;:&t;tcp_send_reset() fixed to work for&n; *&t;&t;&t;&t;&t;everything not just packets for&n; *&t;&t;&t;&t;&t;unknown sockets.&n; *&t;&t;Alan Cox&t;:&t;tcp option processing.&n; *&t;&t;Alan Cox&t;:&t;Reset tweaked (still not 100%) [Had&n; *&t;&t;&t;&t;&t;syn rule wrong]&n; *&t;&t;Herp Rosmanith  :&t;More reset fixes&n; *&t;&t;Alan Cox&t;:&t;No longer acks invalid rst frames.&n; *&t;&t;&t;&t;&t;Acking any kind of RST is right out.&n; *&t;&t;Alan Cox&t;:&t;Sets an ignore me flag on an rst&n; *&t;&t;&t;&t;&t;receive otherwise odd bits of prattle&n; *&t;&t;&t;&t;&t;escape still&n; *&t;&t;Alan Cox&t;:&t;Fixed another acking RST frame bug.&n; *&t;&t;&t;&t;&t;Should stop LAN workplace lockups.&n; *&t;&t;Alan Cox&t;: &t;Some tidyups using the new skb list&n; *&t;&t;&t;&t;&t;facilities&n; *&t;&t;Alan Cox&t;:&t;sk-&gt;keepopen now seems to work&n; *&t;&t;Alan Cox&t;:&t;Pulls options out correctly on accepts&n; *&t;&t;Alan Cox&t;:&t;Fixed assorted sk-&gt;rqueue-&gt;next errors&n; *&t;&t;Alan Cox&t;:&t;PSH doesn&squot;t end a TCP read. Switched a&n; *&t;&t;&t;&t;&t;bit to skb ops.&n; *&t;&t;Alan Cox&t;:&t;Tidied tcp_data to avoid a potential&n; *&t;&t;&t;&t;&t;nasty.&n; *&t;&t;Alan Cox&t;:&t;Added some better commenting, as the&n; *&t;&t;&t;&t;&t;tcp is hard to follow&n; *&t;&t;Alan Cox&t;:&t;Removed incorrect check for 20 * psh&n; *&t;Michael O&squot;Reilly&t;:&t;ack &lt; copied bug fix.&n; *&t;Johannes Stille&t;&t;:&t;Misc tcp fixes (not all in yet).&n; *&t;&t;Alan Cox&t;:&t;FIN with no memory -&gt; CRASH&n; *&t;&t;Alan Cox&t;:&t;Added socket option proto entries.&n; *&t;&t;&t;&t;&t;Also added awareness of them to accept.&n; *&t;&t;Alan Cox&t;:&t;Added TCP options (SOL_TCP)&n; *&t;&t;Alan Cox&t;:&t;Switched wakeup calls to callbacks,&n; *&t;&t;&t;&t;&t;so the kernel can layer network&n; *&t;&t;&t;&t;&t;sockets.&n; *&t;&t;Alan Cox&t;:&t;Use ip_tos/ip_ttl settings.&n; *&t;&t;Alan Cox&t;:&t;Handle FIN (more) properly (we hope).&n; *&t;&t;Alan Cox&t;:&t;RST frames sent on unsynchronised&n; *&t;&t;&t;&t;&t;state ack error.&n; *&t;&t;Alan Cox&t;:&t;Put in missing check for SYN bit.&n; *&t;&t;Alan Cox&t;:&t;Added tcp_select_window() aka NET2E&n; *&t;&t;&t;&t;&t;window non shrink trick.&n; *&t;&t;Alan Cox&t;:&t;Added a couple of small NET2E timer&n; *&t;&t;&t;&t;&t;fixes&n; *&t;&t;Charles Hedrick :&t;TCP fixes&n; *&t;&t;Toomas Tamm&t;:&t;TCP window fixes&n; *&t;&t;Alan Cox&t;:&t;Small URG fix to rlogin ^C ack fight&n; *&t;&t;Charles Hedrick&t;:&t;Rewrote most of it to actually work&n; *&t;&t;Linus&t;&t;:&t;Rewrote tcp_read() and URG handling&n; *&t;&t;&t;&t;&t;completely&n; *&t;&t;Gerhard Koerting:&t;Fixed some missing timer handling&n; *&t;&t;Matthew Dillon  :&t;Reworked TCP machine states as per RFC&n; *&t;&t;Gerhard Koerting:&t;PC/TCP workarounds&n; *&t;&t;Adam Caldwell&t;:&t;Assorted timer/timing errors&n; *&t;&t;Matthew Dillon&t;:&t;Fixed another RST bug&n; *&t;&t;Alan Cox&t;:&t;Move to kernel side addressing changes.&n; *&t;&t;Alan Cox&t;:&t;Beginning work on TCP fastpathing&n; *&t;&t;&t;&t;&t;(not yet usable)&n; *&t;&t;Arnt Gulbrandsen:&t;Turbocharged tcp_check() routine.&n; *&t;&t;Alan Cox&t;:&t;TCP fast path debugging&n; *&t;&t;Alan Cox&t;:&t;Window clamping&n; *&t;&t;Michael Riepe&t;:&t;Bug in tcp_check()&n; *&t;&t;Matt Dillon&t;:&t;More TCP improvements and RST bug fixes&n; *&t;&t;Matt Dillon&t;:&t;Yet more small nasties remove from the&n; *&t;&t;&t;&t;&t;TCP code (Be very nice to this man if&n; *&t;&t;&t;&t;&t;tcp finally works 100%) 8)&n; *&t;&t;Alan Cox&t;:&t;BSD accept semantics.&n; *&t;&t;Alan Cox&t;:&t;Reset on closedown bug.&n; *&t;Peter De Schrijver&t;:&t;ENOTCONN check missing in tcp_sendto().&n; *&t;&t;Michael Pall&t;:&t;Handle select() after URG properly in&n; *&t;&t;&t;&t;&t;all cases.&n; *&t;&t;Michael Pall&t;:&t;Undo the last fix in tcp_read_urg()&n; *&t;&t;&t;&t;&t;(multi URG PUSH broke rlogin).&n; *&t;&t;Michael Pall&t;:&t;Fix the multi URG PUSH problem in&n; *&t;&t;&t;&t;&t;tcp_readable(), select() after URG&n; *&t;&t;&t;&t;&t;works now.&n; *&t;&t;Michael Pall&t;:&t;recv(...,MSG_OOB) never blocks in the&n; *&t;&t;&t;&t;&t;BSD api.&n; *&t;&t;Alan Cox&t;:&t;Changed the semantics of sk-&gt;socket to&n; *&t;&t;&t;&t;&t;fix a race and a signal problem with&n; *&t;&t;&t;&t;&t;accept() and async I/O.&n; *&t;&t;Alan Cox&t;:&t;Relaxed the rules on tcp_sendto().&n; *&t;&t;Yury Shevchuk&t;:&t;Really fixed accept() blocking problem.&n; *&t;&t;Craig I. Hagan  :&t;Allow for BSD compatible TIME_WAIT for&n; *&t;&t;&t;&t;&t;clients/servers which listen in on&n; *&t;&t;&t;&t;&t;fixed ports.&n; *&t;&t;Alan Cox&t;:&t;Cleaned the above up and shrank it to&n; *&t;&t;&t;&t;&t;a sensible code size.&n; *&t;&t;Alan Cox&t;:&t;Self connect lockup fix.&n; *&t;&t;Alan Cox&t;:&t;No connect to multicast.&n; *&t;&t;Ross Biro&t;:&t;Close unaccepted children on master&n; *&t;&t;&t;&t;&t;socket close.&n; *&t;&t;Alan Cox&t;:&t;Reset tracing code.&n; *&t;&t;Alan Cox&t;:&t;Spurious resets on shutdown.&n; *&t;&t;Alan Cox&t;:&t;Giant 15 minute/60 second timer error&n; *&t;&t;Alan Cox&t;:&t;Small whoops in selecting before an&n; *&t;&t;&t;&t;&t;accept.&n; *&t;&t;Alan Cox&t;:&t;Kept the state trace facility since&n; *&t;&t;&t;&t;&t;it&squot;s handy for debugging.&n; *&t;&t;Alan Cox&t;:&t;More reset handler fixes.&n; *&t;&t;Alan Cox&t;:&t;Started rewriting the code based on&n; *&t;&t;&t;&t;&t;the RFC&squot;s for other useful protocol&n; *&t;&t;&t;&t;&t;references see: Comer, KA9Q NOS, and&n; *&t;&t;&t;&t;&t;for a reference on the difference&n; *&t;&t;&t;&t;&t;between specifications and how BSD&n; *&t;&t;&t;&t;&t;works see the 4.4lite source.&n; *&t;&t;A.N.Kuznetsov&t;:&t;Don&squot;t time wait on completion of tidy&n; *&t;&t;&t;&t;&t;close.&n; *&t;&t;Linus Torvalds&t;:&t;Fin/Shutdown &amp; copied_seq changes.&n; *&t;&t;Linus Torvalds&t;:&t;Fixed BSD port reuse to work first syn&n; *&t;&t;Alan Cox&t;:&t;Reimplemented timers as per the RFC&n; *&t;&t;&t;&t;&t;and using multiple timers for sanity.&n; *&t;&t;Alan Cox&t;:&t;Small bug fixes, and a lot of new&n; *&t;&t;&t;&t;&t;comments.&n; *&t;&t;Alan Cox&t;:&t;Fixed dual reader crash by locking&n; *&t;&t;&t;&t;&t;the buffers (much like datagram.c)&n; *&t;&t;Alan Cox&t;:&t;Fixed stuck sockets in probe. A probe&n; *&t;&t;&t;&t;&t;now gets fed up of retrying without&n; *&t;&t;&t;&t;&t;(even a no space) answer.&n; *&t;&t;Alan Cox&t;:&t;Extracted closing code better&n; *&t;&t;Alan Cox&t;:&t;Fixed the closing state machine to&n; *&t;&t;&t;&t;&t;resemble the RFC.&n; *&t;&t;Alan Cox&t;:&t;More &squot;per spec&squot; fixes.&n; *&t;&t;Jorge Cwik&t;:&t;Even faster checksumming.&n; *&t;&t;Alan Cox&t;:&t;tcp_data() doesn&squot;t ack illegal PSH&n; *&t;&t;&t;&t;&t;only frames. At least one pc tcp stack&n; *&t;&t;&t;&t;&t;generates them.&n; *&t;&t;Alan Cox&t;:&t;Cache last socket.&n; *&t;&t;Alan Cox&t;:&t;Per route irtt.&n; *&t;&t;Matt Day&t;:&t;Select() match BSD precisely on error&n; *&t;&t;Alan Cox&t;:&t;New buffers&n; *&t;&t;Marc Tamsky&t;:&t;Various sk-&gt;prot-&gt;retransmits and&n; *&t;&t;&t;&t;&t;sk-&gt;retransmits misupdating fixed.&n; *&t;&t;&t;&t;&t;Fixed tcp_write_timeout: stuck close,&n; *&t;&t;&t;&t;&t;and TCP syn retries gets used now.&n; *&t;&t;Mark Yarvis&t;:&t;In tcp_read_wakeup(), don&squot;t send an&n; *&t;&t;&t;&t;&t;ack if stat is TCP_CLOSED.&n; *&t;&t;Alan Cox&t;:&t;Look up device on a retransmit - routes may&n; *&t;&t;&t;&t;&t;change. Doesn&squot;t yet cope with MSS shrink right&n; *&t;&t;&t;&t;&t;but it&squot;s a start!&n; *&t;&t;Marc Tamsky&t;:&t;Closing in closing fixes.&n; *&t;&t;Mike Shaver&t;:&t;RFC1122 verifications.&n; *&t;&t;Alan Cox&t;:&t;rcv_saddr errors.&n; *&t;&t;Alan Cox&t;:&t;Block double connect().&n; *&t;&t;Alan Cox&t;:&t;Small hooks for enSKIP.&n; *&t;&t;Alexey Kuznetsov:&t;Path MTU discovery.&n; *&t;&t;Alan Cox&t;:&t;Support soft errors.&n; *&t;&t;Alan Cox&t;:&t;Fix MTU discovery pathological case&n; *&t;&t;&t;&t;&t;when the remote claims no mtu!&n; *&t;&t;Marc Tamsky&t;:&t;TCP_CLOSE fix.&n; *&t;&t;Colin (G3TNE)&t;:&t;Send a reset on syn ack replies in&n; *&t;&t;&t;&t;&t;window but wrong (fixes NT lpd problems)&n; *&t;&t;Pedro Roque&t;:&t;Better TCP window handling, delayed ack.&n; *&t;&t;Joerg Reuter&t;:&t;No modification of locked buffers in&n; *&t;&t;&t;&t;&t;tcp_do_retransmit()&n; *&t;&t;Eric Schenk&t;:&t;Changed receiver side silly window&n; *&t;&t;&t;&t;&t;avoidance algorithm to BSD style&n; *&t;&t;&t;&t;&t;algorithm. This doubles throughput&n; *&t;&t;&t;&t;&t;against machines running Solaris,&n; *&t;&t;&t;&t;&t;and seems to result in general&n; *&t;&t;&t;&t;&t;improvement.&n; *&t;&t;Eric Schenk&t;:&t;Changed receiver side silly window&n; *&t;&t;&t;&t;&t;avoidance algorithm to BSD style&n; *&t;&t;&t;&t;&t;algorithm. This doubles throughput&n; *&t;&t;&t;&t;&t;against machines running Solaris,&n; *&t;&t;&t;&t;&t;and seems to result in general&n; *&t;&t;&t;&t;&t;improvement.&n; *&t;Stefan Magdalinski&t;:&t;adjusted tcp_readable() to fix FIONREAD&n; *&t;Willy Konynenberg&t;:&t;Transparent proxying support.&n; *&t;&t;Theodore Ts&squot;o&t;:&t;Do secure TCP sequence numbers.&n; *&t;&t;&t;&t;&t;&n; * To Fix:&n; *&t;&t;Fast path the code. Two things here - fix the window calculation&n; *&t;&t;so it doesn&squot;t iterate over the queue, also spot packets with no funny&n; *&t;&t;options arriving in order and process directly.&n; *&n; *&t;&t;Rewrite output state machine to use a single queue.&n; *&t;&t;Speed up input assembly algorithm.&n; *&t;&t;RFC1323 - PAWS and window scaling. PAWS is required for IPv6 so we&n; *&t;&t;could do with it working on IPv4&n; *&t;&t;User settable/learned rtt/max window/mtu&n; *&n; *&t;&t;Change the fundamental structure to a single send queue maintained&n; *&t;&t;by TCP (removing the bogus ip stuff [thus fixing mtu drops on&n; *&t;&t;active routes too]). Cut the queue off in tcp_retransmit/&n; *&t;&t;tcp_transmit.&n; *&t;&t;Change the receive queue to assemble as it goes. This lets us&n; *&t;&t;dispose of most of tcp_sequence, half of tcp_ack and chunks of&n; *&t;&t;tcp_data/tcp_read as well as the window shrink crud.&n; *&t;&t;Separate out duplicated code - tcp_alloc_skb, tcp_build_ack&n; *&t;&t;tcp_queue_skb seem obvious routines to extract.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or(at your option) any later version.&n; *&n; * Description of States:&n; *&n; *&t;TCP_SYN_SENT&t;&t;sent a connection request, waiting for ack&n; *&n; *&t;TCP_SYN_RECV&t;&t;received a connection request, sent ack,&n; *&t;&t;&t;&t;waiting for final ack in three-way handshake.&n; *&n; *&t;TCP_ESTABLISHED&t;&t;connection established&n; *&n; *&t;TCP_FIN_WAIT1&t;&t;our side has shutdown, waiting to complete&n; *&t;&t;&t;&t;transmission of remaining buffered data&n; *&n; *&t;TCP_FIN_WAIT2&t;&t;all buffered data sent, waiting for remote&n; *&t;&t;&t;&t;to shutdown&n; *&n; *&t;TCP_CLOSING&t;&t;both sides have shutdown but we still have&n; *&t;&t;&t;&t;data we have to finish sending&n; *&n; *&t;TCP_TIME_WAIT&t;&t;timeout to catch resent junk before entering&n; *&t;&t;&t;&t;closed, can only be entered from FIN_WAIT2&n; *&t;&t;&t;&t;or CLOSING.  Required because the other end&n; *&t;&t;&t;&t;may not have gotten our last ACK causing it&n; *&t;&t;&t;&t;to retransmit the data packet (which we ignore)&n; *&n; *&t;TCP_CLOSE_WAIT&t;&t;remote side has shutdown and is waiting for&n; *&t;&t;&t;&t;us to finish writing our data and to shutdown&n; *&t;&t;&t;&t;(we have to close() to move on to LAST_ACK)&n; *&n; *&t;TCP_LAST_ACK&t;&t;out side has shutdown after remote has&n; *&t;&t;&t;&t;shutdown.  There may still be data in our&n; *&t;&t;&t;&t;buffer that we have to finish sending&n; *&n; *&t;TCP_CLOSE&t;&t;socket is finished&n; */
multiline_comment|/*&n; * RFC1122 status:&n; * NOTE: I&squot;m not going to be doing comments in the code for this one except&n; * for violations and the like.  tcp.c is just too big... If I say something&n; * &quot;does?&quot; or &quot;doesn&squot;t?&quot;, it means I&squot;m not sure, and will have to hash it out&n; * with Alan. -- MS 950903&n; *&n; * Use of PSH (4.2.2.2)&n; *   MAY aggregate data sent without the PSH flag. (does)&n; *   MAY queue data received without the PSH flag. (does)&n; *   SHOULD collapse successive PSH flags when it packetizes data. (doesn&squot;t)&n; *   MAY implement PSH on send calls. (doesn&squot;t, thus:)&n; *     MUST NOT buffer data indefinitely (doesn&squot;t [1 second])&n; *     MUST set PSH on last segment (does)&n; *   MAY pass received PSH to application layer (doesn&squot;t)&n; *   SHOULD send maximum-sized segment whenever possible. (almost always does)&n; *&n; * Window Size (4.2.2.3, 4.2.2.16)&n; *   MUST treat window size as an unsigned number (does)&n; *   SHOULD treat window size as a 32-bit number (does not)&n; *   MUST NOT shrink window once it is offered (does not normally)&n; *&n; * Urgent Pointer (4.2.2.4)&n; * **MUST point urgent pointer to last byte of urgent data (not right&n; *     after). (doesn&squot;t, to be like BSD)&n; *   MUST inform application layer asynchronously of incoming urgent&n; *     data. (does)&n; *   MUST provide application with means of determining the amount of&n; *     urgent data pending. (does)&n; * **MUST support urgent data sequence of arbitrary length. (doesn&squot;t, but&n; *   it&squot;s sort of tricky to fix, as urg_ptr is a 16-bit quantity)&n; *&t;[Follows BSD 1 byte of urgent data]&n; *&n; * TCP Options (4.2.2.5)&n; *   MUST be able to receive TCP options in any segment. (does)&n; *   MUST ignore unsupported options (does)&n; *&n; * Maximum Segment Size Option (4.2.2.6)&n; *   MUST implement both sending and receiving MSS. (does)&n; *   SHOULD send an MSS with every SYN where receive MSS != 536 (MAY send&n; *     it always). (does, even when MSS == 536, which is legal)&n; *   MUST assume MSS == 536 if no MSS received at connection setup (does)&n; *   MUST calculate &quot;effective send MSS&quot; correctly:&n; *     min(physical_MTU, remote_MSS+20) - sizeof(tcphdr) - sizeof(ipopts)&n; *     (does - but allows operator override)&n; *&n; * TCP Checksum (4.2.2.7)&n; *   MUST generate and check TCP checksum. (does)&n; *&n; * Initial Sequence Number Selection (4.2.2.8)&n; *   MUST use the RFC 793 clock selection mechanism.  (doesn&squot;t, but it&squot;s&n; *     OK: RFC 793 specifies a 250KHz clock, while we use 1MHz, which is&n; *     necessary for 10Mbps networks - and harder than BSD to spoof!)&n; *&n; * Simultaneous Open Attempts (4.2.2.10)&n; *   MUST support simultaneous open attempts (does)&n; *&n; * Recovery from Old Duplicate SYN (4.2.2.11)&n; *   MUST keep track of active vs. passive open (does)&n; *&n; * RST segment (4.2.2.12)&n; *   SHOULD allow an RST segment to contain data (does, but doesn&squot;t do&n; *     anything with it, which is standard)&n; *&n; * Closing a Connection (4.2.2.13)&n; *   MUST inform application of whether connection was closed by RST or&n; *     normal close. (does)&n; *   MAY allow &quot;half-duplex&quot; close (treat connection as closed for the&n; *     local app, even before handshake is done). (does)&n; *   MUST linger in TIME_WAIT for 2 * MSL (does)&n; *&n; * Retransmission Timeout (4.2.2.15)&n; *   MUST implement Jacobson&squot;s slow start and congestion avoidance&n; *     stuff. (does)&n; *&n; * Probing Zero Windows (4.2.2.17)&n; *   MUST support probing of zero windows. (does)&n; *   MAY keep offered window closed indefinitely. (does)&n; *   MUST allow remote window to stay closed indefinitely. (does)&n; *&n; * Passive Open Calls (4.2.2.18)&n; *   MUST NOT let new passive open affect other connections. (doesn&squot;t)&n; *   MUST support passive opens (LISTENs) concurrently. (does)&n; *&n; * Time to Live (4.2.2.19)&n; *   MUST make TCP TTL configurable. (does - IP_TTL option)&n; *&n; * Event Processing (4.2.2.20)&n; *   SHOULD queue out-of-order segments. (does)&n; *   MUST aggregate ACK segments whenever possible. (does but badly)&n; *&n; * Retransmission Timeout Calculation (4.2.3.1)&n; *   MUST implement Karn&squot;s algorithm and Jacobson&squot;s algorithm for RTO&n; *     calculation. (does, or at least explains them in the comments 8*b)&n; *  SHOULD initialize RTO to 0 and RTT to 3. (does)&n; *&n; * When to Send an ACK Segment (4.2.3.2)&n; *   SHOULD implement delayed ACK. (does)&n; *   MUST keep ACK delay &lt; 0.5 sec. (does)&n; *&n; * When to Send a Window Update (4.2.3.3)&n; *   MUST implement receiver-side SWS. (does)&n; *&n; * When to Send Data (4.2.3.4)&n; *   MUST implement sender-side SWS. (does)&n; *   SHOULD implement Nagle algorithm. (does)&n; *&n; * TCP Connection Failures (4.2.3.5)&n; *  MUST handle excessive retransmissions &quot;properly&quot; (see the RFC). (does)&n; *   SHOULD inform application layer of soft errors. (does)&n; *&n; * TCP Keep-Alives (4.2.3.6)&n; *   MAY provide keep-alives. (does)&n; *   MUST make keep-alives configurable on a per-connection basis. (does)&n; *   MUST default to no keep-alives. (does)&n; * **MUST make keep-alive interval configurable. (doesn&squot;t)&n; * **MUST make default keep-alive interval &gt; 2 hours. (doesn&squot;t)&n; *   MUST NOT interpret failure to ACK keep-alive packet as dead&n; *     connection. (doesn&squot;t)&n; *   SHOULD send keep-alive with no data. (does)&n; *&n; * TCP Multihoming (4.2.3.7)&n; *   MUST get source address from IP layer before sending first&n; *     SYN. (does)&n; *   MUST use same local address for all segments of a connection. (does)&n; *&n; * IP Options (4.2.3.8)&n; *   MUST ignore unsupported IP options. (does)&n; *   MAY support Time Stamp and Record Route. (does)&n; *   MUST allow application to specify a source route. (does)&n; *   MUST allow received Source Route option to set route for all future&n; *     segments on this connection. (does not (security issues))&n; *&n; * ICMP messages (4.2.3.9)&n; *   MUST act on ICMP errors. (does)&n; *   MUST slow transmission upon receipt of a Source Quench. (does)&n; *   MUST NOT abort connection upon receipt of soft Destination&n; *     Unreachables (0, 1, 5), Time Exceededs and Parameter&n; *     Problems. (doesn&squot;t)&n; *   SHOULD report soft Destination Unreachables etc. to the&n; *     application. (does)&n; *   SHOULD abort connection upon receipt of hard Destination Unreachable&n; *     messages (2, 3, 4). (does)&n; *&n; * Remote Address Validation (4.2.3.10)&n; *   MUST reject as an error OPEN for invalid remote IP address. (does)&n; *   MUST ignore SYN with invalid source address. (does)&n; *   MUST silently discard incoming SYN for broadcast/multicast&n; *     address. (does)&n; *&n; * Asynchronous Reports (4.2.4.1)&n; * MUST provide mechanism for reporting soft errors to application&n; *     layer. (does)&n; *&n; * Type of Service (4.2.4.2)&n; *   MUST allow application layer to set Type of Service. (does IP_TOS)&n; *&n; * (Whew. -- MS 950903)&n; **/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
DECL|variable|seq_offset
r_int
r_int
id|seq_offset
suffix:semicolon
DECL|variable|tcp_statistics
r_struct
id|tcp_mib
id|tcp_statistics
suffix:semicolon
r_static
r_void
id|tcp_close
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|timeout
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Find someone to &squot;accept&squot;. Must be called with&n; *&t;the socket locked or with interrupts disabled&n; */
DECL|function|tcp_find_established
r_static
r_struct
id|sk_buff
op_star
id|tcp_find_established
c_func
(paren
r_struct
id|sock
op_star
id|s
)paren
(brace
r_struct
id|sk_buff
op_star
id|p
op_assign
id|skb_peek
c_func
(paren
op_amp
id|s-&gt;receive_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_do
(brace
r_if
c_cond
(paren
id|p-&gt;sk-&gt;state
op_eq
id|TCP_ESTABLISHED
op_logical_or
id|p-&gt;sk-&gt;state
op_ge
id|TCP_FIN_WAIT1
)paren
(brace
r_return
id|p
suffix:semicolon
)brace
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|p
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|s-&gt;receive_queue
)paren
(brace
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine closes sockets which have been at least partially&n; *&t;opened, but not yet accepted. Currently it is only called by&n; *&t;tcp_close, and timeout mirrors the value there.&n; */
DECL|function|tcp_close_pending
r_static
r_void
id|tcp_close_pending
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|tcp_close
c_func
(paren
id|skb-&gt;sk
comma
l_int|0
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Enter the time wait state.&n; */
DECL|function|tcp_time_wait
r_void
id|tcp_time_wait
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_TIME_WAIT
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called by the ICMP module when it gets some&n; * sort of error condition.  If err &lt; 0 then the socket should&n; * be closed and the error returned to the user.  If err &gt; 0&n; * it&squot;s just the icmp type &lt;&lt; 8 | icmp code.  After adjustment&n; * header points to the first 8 bytes of the tcp header.  We need&n; * to find the appropriate port.&n; */
DECL|function|tcp_err
r_void
id|tcp_err
c_func
(paren
r_int
id|type
comma
r_int
id|code
comma
r_int
r_char
op_star
id|header
comma
id|__u32
id|daddr
comma
id|__u32
id|saddr
comma
r_struct
id|inet_protocol
op_star
id|protocol
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|header
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This one is _WRONG_. FIXME urgently.&n;&t; */
macro_line|#ifndef CONFIG_NO_PATH_MTU_DISCOVERY
r_struct
id|iphdr
op_star
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
(paren
id|header
op_minus
r_sizeof
(paren
r_struct
id|iphdr
)paren
)paren
suffix:semicolon
macro_line|#endif
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|header
suffix:semicolon
id|sk
op_assign
id|get_sock
c_func
(paren
op_amp
id|tcp_prot
comma
id|th-&gt;source
comma
id|daddr
comma
id|th-&gt;dest
comma
id|saddr
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|ICMP_SOURCE_QUENCH
)paren
(brace
multiline_comment|/*&n;&t;&t; * FIXME:&n;&t;&t; * Follow BSD for now and just reduce cong_window to 1 again.&n;&t;&t; * It is possible that we just want to reduce the&n;&t;&t; * window by 1/2, or that we want to reduce ssthresh by 1/2&n;&t;&t; * here as well.&n;&t;&t; */
id|sk-&gt;cong_window
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;high_seq
op_assign
id|sk-&gt;sent_seq
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_eq
id|ICMP_PARAMETERPROB
)paren
(brace
id|sk-&gt;err
op_assign
id|EPROTO
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_NO_PATH_MTU_DISCOVERY
r_if
c_cond
(paren
id|type
op_eq
id|ICMP_DEST_UNREACH
op_logical_and
id|code
op_eq
id|ICMP_FRAG_NEEDED
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Ugly trick to pass MTU to protocol layer.&n;&t;&t; * Really we should add argument &quot;info&quot; to error handler.&n;&t;&t; */
r_int
r_int
id|new_mtu
op_assign
id|ntohs
c_func
(paren
id|iph-&gt;id
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rt
op_assign
id|sk-&gt;ip_route_cache
)paren
op_ne
l_int|NULL
)paren
r_if
c_cond
(paren
id|rt-&gt;rt_mtu
OG
id|new_mtu
)paren
id|rt-&gt;rt_mtu
op_assign
id|new_mtu
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;FIXME::&n;&t;&t; *&t;Not the nicest of fixes: Lose a MTU update if the socket is&n;&t;&t; *&t;locked this instant. Not the right answer but will be best&n;&t;&t; *&t;for the production fix. Make 2.1 work right!&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;mtu
OG
id|new_mtu
op_minus
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_logical_and
id|new_mtu
OG
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_logical_and
op_logical_neg
id|sk-&gt;users
)paren
id|sk-&gt;mtu
op_assign
id|new_mtu
op_minus
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * If we&squot;ve already connected we will keep trying&n;&t; * until we time out, or the user gives up.&n;&t; */
r_if
c_cond
(paren
id|code
OL
l_int|13
)paren
(brace
r_if
c_cond
(paren
id|icmp_err_convert
(braket
id|code
)braket
dot
id|fatal
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_SYN_RECV
)paren
(brace
id|sk-&gt;err
op_assign
id|icmp_err_convert
(braket
id|code
)braket
dot
id|errno
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_SYN_RECV
)paren
(brace
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Wake people up to see the error (see connect in sock.c) */
)brace
)brace
r_else
multiline_comment|/* Only an error on timeout */
id|sk-&gt;err_soft
op_assign
id|icmp_err_convert
(braket
id|code
)braket
dot
id|errno
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Walk down the receive queue counting readable data until we hit the end or we find a gap&n; *&t;in the received data queue (ie a frame missing that needs sending to us). Not&n; *&t;sorting using two queues as data arrives makes life so much harder.&n; */
DECL|function|tcp_readable
r_static
r_int
id|tcp_readable
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
r_int
id|counted
suffix:semicolon
r_int
r_int
id|amount
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|sum
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_logical_and
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tcp_readable: %p - &quot;
comma
id|sk
)paren
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
op_logical_or
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_logical_and
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;empty&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|counted
op_assign
id|sk-&gt;copied_seq
suffix:semicolon
multiline_comment|/* Where we are at the moment */
id|amount
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Do until a push or until we are out of data.&n;&t; */
r_do
(brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|counted
comma
id|skb-&gt;seq
)paren
)paren
multiline_comment|/* Found a hole so stops here */
r_break
suffix:semicolon
id|sum
op_assign
id|skb-&gt;len
op_minus
(paren
id|counted
op_minus
id|skb-&gt;seq
)paren
suffix:semicolon
multiline_comment|/* Length - header but start from where we are up to (avoid overlaps) */
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;syn
)paren
id|sum
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sum
OG
l_int|0
)paren
(brace
multiline_comment|/* Add it up, move on */
id|amount
op_add_assign
id|sum
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;syn
)paren
id|amount
op_decrement
suffix:semicolon
id|counted
op_add_assign
id|sum
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Don&squot;t count urg data ... but do it in the right place!&n;&t;&t; * Consider: &quot;old_data (ptr is here) URG PUSH data&quot;&n;&t;&t; * The old code would stop at the first push because&n;&t;&t; * it counted the urg (amount==1) and then does amount--&n;&t;&t; * *after* the loop.  This means tcp_readable() always&n;&t;&t; * returned zero if any URG PUSH was in the queue, even&n;&t;&t; * though there was normal data available. If we subtract&n;&t;&t; * the urg data right here, we even get it to work for more&n;&t;&t; * than one URG PUSH skb without normal data.&n;&t;&t; * This means that select() finally works now with urg data&n;&t;&t; * in the queue.  Note that rlogin was never affected&n;&t;&t; * because it doesn&squot;t use select(); it uses two processes&n;&t;&t; * and a blocking read().  And the queue scan in tcp_read()&n;&t;&t; * was correct.  Mike &lt;pall@rz.uni-karlsruhe.de&gt;&n;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;urg
)paren
id|amount
op_decrement
suffix:semicolon
multiline_comment|/* don&squot;t count urg data */
multiline_comment|/*&t;&t;if (amount &amp;&amp; skb-&gt;h.th-&gt;psh) break;*/
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;receive_queue
)paren
(brace
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;got %lu bytes.&bslash;n&quot;
comma
id|amount
)paren
suffix:semicolon
)brace
r_return
id|amount
suffix:semicolon
)brace
multiline_comment|/*&n; * LISTEN is a special case for select..&n; */
DECL|function|tcp_listen_select
r_static
r_int
id|tcp_listen_select
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
(brace
r_if
c_cond
(paren
id|sel_type
op_eq
id|SEL_IN
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|skb
op_assign
id|tcp_find_established
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
r_return
l_int|1
suffix:semicolon
id|select_wait
c_func
(paren
id|sk-&gt;sleep
comma
id|wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Wait for a TCP event.&n; *&n; *&t;Note that we don&squot;t need to lock the socket, as the upper select layers&n; *&t;take care of normal races (between the test and the event) and we don&squot;t&n; *&t;go look at any of the socket buffers directly.&n; */
DECL|function|tcp_select
r_static
r_int
id|tcp_select
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
id|tcp_listen_select
c_func
(paren
id|sk
comma
id|sel_type
comma
id|wait
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sel_type
)paren
(brace
r_case
id|SEL_IN
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_SYN_RECV
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;acked_seq
op_eq
id|sk-&gt;copied_seq
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;urg_seq
op_ne
id|sk-&gt;copied_seq
op_logical_or
id|sk-&gt;acked_seq
op_ne
id|sk-&gt;copied_seq
op_plus
l_int|1
op_logical_or
id|sk-&gt;urginline
op_logical_or
op_logical_neg
id|sk-&gt;urg_data
)paren
r_return
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SEL_OUT
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_SYN_RECV
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;wmem_alloc
op_star
l_int|2
OG
id|sk-&gt;sndbuf
)paren
r_break
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
id|SEL_EX
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;urg_data
)paren
r_return
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|select_wait
c_func
(paren
id|sk-&gt;sleep
comma
id|wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tcp_ioctl
r_int
id|tcp_ioctl
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCINQ
suffix:colon
macro_line|#ifdef FIXME&t;/* FIXME: */
r_case
id|FIONREAD
suffix:colon
macro_line|#endif
(brace
r_int
r_int
id|amount
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|amount
op_assign
id|tcp_readable
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_user
c_func
(paren
id|amount
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|SIOCATMARK
suffix:colon
(brace
r_int
id|answ
op_assign
id|sk-&gt;urg_data
op_logical_and
id|sk-&gt;urg_seq
op_eq
id|sk-&gt;copied_seq
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|put_user
c_func
(paren
id|answ
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|TIOCOUTQ
suffix:colon
(brace
r_int
r_int
id|amount
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|amount
op_assign
id|sock_wspace
c_func
(paren
id|sk
)paren
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_user
c_func
(paren
id|amount
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;This routine computes a TCP checksum.&n; *&n; *&t;Modified January 1995 from a go-faster DOS routine by&n; *&t;Jorge Cwik &lt;jorge@laser.satlink.net&gt;&n; */
DECL|macro|DEBUG_TCP_CHECK
macro_line|#undef DEBUG_TCP_CHECK
DECL|function|tcp_send_check
r_void
id|tcp_send_check
c_func
(paren
r_struct
id|tcphdr
op_star
id|th
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
comma
r_int
id|len
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
macro_line|#ifdef DEBUG_TCP_CHECK
id|u16
id|check
suffix:semicolon
macro_line|#endif
id|th-&gt;check
op_assign
l_int|0
suffix:semicolon
id|th-&gt;check
op_assign
id|tcp_check
c_func
(paren
id|th
comma
id|len
comma
id|saddr
comma
id|daddr
comma
id|csum_partial
c_func
(paren
(paren
r_char
op_star
)paren
id|th
comma
r_sizeof
(paren
op_star
id|th
)paren
comma
id|skb-&gt;csum
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TCP_CHECK
id|check
op_assign
id|th-&gt;check
suffix:semicolon
id|th-&gt;check
op_assign
l_int|0
suffix:semicolon
id|th-&gt;check
op_assign
id|tcp_check
c_func
(paren
id|th
comma
id|len
comma
id|saddr
comma
id|daddr
comma
id|csum_partial
c_func
(paren
(paren
r_char
op_star
)paren
id|th
comma
id|len
comma
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check
op_ne
id|th-&gt;check
)paren
(brace
r_static
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|count
OL
l_int|10
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Checksum %x (%x) from %p&bslash;n&quot;
comma
id|th-&gt;check
comma
id|check
comma
(paren
op_amp
id|th
)paren
(braket
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TCP=&lt;off:%d a:%d s:%d f:%d&gt;&bslash;n&quot;
comma
id|th-&gt;doff
op_star
l_int|4
comma
id|th-&gt;ack
comma
id|th-&gt;syn
comma
id|th-&gt;fin
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; *&t;This routine builds a generic TCP header.&n; */
DECL|function|tcp_build_header
r_static
r_inline
r_int
id|tcp_build_header
c_func
(paren
r_struct
id|tcphdr
op_star
id|th
comma
r_struct
id|sock
op_star
id|sk
comma
r_int
id|push
)paren
(brace
id|memcpy
c_func
(paren
id|th
comma
(paren
r_void
op_star
)paren
op_amp
(paren
id|sk-&gt;dummy_th
)paren
comma
r_sizeof
(paren
op_star
id|th
)paren
)paren
suffix:semicolon
id|th-&gt;psh
op_assign
(paren
id|push
op_eq
l_int|0
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|th-&gt;seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;write_seq
)paren
suffix:semicolon
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|th-&gt;window
op_assign
id|htons
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
r_return
r_sizeof
(paren
op_star
id|th
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Wait for a socket to get into the connected state&n; */
DECL|function|wait_for_tcp_connect
r_static
r_void
id|wait_for_tcp_connect
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_CLOSE_WAIT
op_logical_and
id|sk-&gt;err
op_eq
l_int|0
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
DECL|function|tcp_memory_free
r_static
r_inline
r_int
id|tcp_memory_free
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|sk-&gt;wmem_alloc
OL
id|sk-&gt;sndbuf
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Wait for more memory for a socket&n; */
DECL|function|wait_for_tcp_memory
r_static
r_void
id|wait_for_tcp_memory
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_memory_free
c_func
(paren
id|sk
)paren
)paren
(brace
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
id|sk-&gt;socket-&gt;flags
op_and_assign
op_complement
id|SO_NOSPACE
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_if
c_cond
(paren
id|tcp_memory_free
c_func
(paren
id|sk
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine copies from a user buffer into a socket,&n; *&t;and starts the transmit system.&n; */
DECL|function|do_tcp_sendmsg
r_static
r_int
id|do_tcp_sendmsg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|iovlen
comma
r_struct
id|iovec
op_star
id|iov
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
)paren
(brace
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Wait for a connection to finish.&n;&t; */
r_while
c_loop
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_CLOSE_WAIT
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;err
)paren
r_return
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_SYN_SENT
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_SYN_RECV
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;keepopen
)paren
id|send_sig
c_func
(paren
id|SIGPIPE
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nonblock
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
id|wait_for_tcp_connect
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Ok commence sending&n;&t; */
r_while
c_loop
(paren
op_decrement
id|iovlen
op_ge
l_int|0
)paren
(brace
r_int
id|seglen
op_assign
id|iov-&gt;iov_len
suffix:semicolon
r_int
r_char
op_star
id|from
op_assign
id|iov-&gt;iov_base
suffix:semicolon
id|iov
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|seglen
OG
l_int|0
)paren
(brace
r_int
id|copy
comma
id|delay
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Stop on errors&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;err
)paren
(brace
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_return
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;Make sure that we are established.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
(brace
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGPIPE
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * The following code can result in copy &lt;= if sk-&gt;mss is ever&n;&t;&t;&t; * decreased.  It shouldn&squot;t be.  sk-&gt;mss is min(sk-&gt;mtu, sk-&gt;max_window).&n;&t;&t;&t; * sk-&gt;mtu is constant once SYN processing is finished.  I.e. we&n;&t;&t;&t; * had better not get here until we&squot;ve seen his SYN and at least one&n;&t;&t;&t; * valid ack.  (The SYN sets sk-&gt;mtu and the ack sets sk-&gt;max_window.)&n;&t;&t;&t; * But ESTABLISHED should guarantee that.  sk-&gt;max_window is by definition&n;&t;&t;&t; * non-decreasing.  Note that any ioctl to set user_mss must be done&n;&t;&t;&t; * before the exchange of SYN&squot;s.  If the initial ack from the other&n;&t;&t;&t; * end has a window of 0, max_window and thus mss will both be 0.&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; *&t;Now we need to check if we have a half built packet.&n;&t;&t;&t; */
macro_line|#ifndef CONFIG_NO_PATH_MTU_DISCOVERY
multiline_comment|/*&n;&t;&t;&t; *&t;Really, we should rebuild all the queues...&n;&t;&t;&t; *&t;It&squot;s difficult. Temporary hack is to send all&n;&t;&t;&t; *&t;queued segments with allowed fragmentation.&n;&t;&t;&t; */
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;new_mss may be zero. That indicates&n;&t;&t;&t;&t; *&t;we don&squot;t have a window estimate for&n;&t;&t;&t;&t; *&t;the remote box yet. &n;&t;&t;&t;&t; *&t;&t;-- AC&n;&t;&t;&t;&t; */
r_int
id|new_mss
op_assign
id|min
c_func
(paren
id|sk-&gt;mtu
comma
id|sk-&gt;max_window
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_mss
op_logical_and
id|new_mss
OL
id|sk-&gt;mss
)paren
(brace
id|tcp_send_partial
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;mss
op_assign
id|new_mss
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t; *&t;If there is a partly filled frame we can fill&n;&t;&t;&t; *&t;out.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|tcp_dequeue_partial
c_func
(paren
id|sk
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|tcp_size
suffix:semicolon
id|tcp_size
op_assign
id|skb-&gt;tail
op_minus
(paren
r_int
r_char
op_star
)paren
(paren
id|skb-&gt;h.th
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Add more stuff to the end of skb-&gt;len */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_OOB
)paren
)paren
(brace
id|copy
op_assign
id|min
c_func
(paren
id|sk-&gt;mss
op_minus
id|tcp_size
comma
id|seglen
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;Now we may find the frame is as big, or too&n;&t;&t;&t;&t;&t; *&t;big for our MSS. Thats all fine. It means the&n;&t;&t;&t;&t;&t; *&t;MSS shrank (from an ICMP) after we allocated &n;&t;&t;&t;&t;&t; *&t;this frame.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|copy
op_le
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; *&t;Send the now forced complete frame out. &n;&t;&t;&t;&t;&t;&t; *&n;&t;&t;&t;&t;&t;&t; *&t;Note for 2.1: The MSS reduce code ought to&n;&t;&t;&t;&t;&t;&t; *&t;flush any frames in partial that are now&n;&t;&t;&t;&t;&t;&t; *&t;full sized. Not serious, potential tiny&n;&t;&t;&t;&t;&t;&t; *&t;performance hit.&n;&t;&t;&t;&t;&t;&t; */
id|tcp_send_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; *&t;Get a new buffer and try again.&n;&t;&t;&t;&t;&t;&t; */
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;Otherwise continue to fill the buffer.&n;&t;&t;&t;&t;&t; */
id|tcp_size
op_add_assign
id|copy
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|copy
)paren
comma
id|from
comma
id|copy
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
id|csum_partial
c_func
(paren
id|skb-&gt;tail
op_minus
id|tcp_size
comma
id|tcp_size
comma
l_int|0
)paren
suffix:semicolon
id|from
op_add_assign
id|copy
suffix:semicolon
id|copied
op_add_assign
id|copy
suffix:semicolon
id|len
op_sub_assign
id|copy
suffix:semicolon
id|sk-&gt;write_seq
op_add_assign
id|copy
suffix:semicolon
id|seglen
op_sub_assign
id|copy
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tcp_size
op_ge
id|sk-&gt;mss
op_logical_or
(paren
id|flags
op_amp
id|MSG_OOB
)paren
op_logical_or
op_logical_neg
id|sk-&gt;packets_out
)paren
id|tcp_send_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_else
id|tcp_enqueue_partial
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We also need to worry about the window.&n;&t; &t; * If window &lt; 1/2 the maximum window we&squot;ve seen from this&n;&t; &t; *   host, don&squot;t use it.  This is sender side&n;&t; &t; *   silly window prevention, as specified in RFC1122.&n;&t; &t; *   (Note that this is different than earlier versions of&n;&t;&t; *   SWS prevention, e.g. RFC813.).  What we actually do is&n;&t;&t; *   use the whole MSS.  Since the results in the right&n;&t;&t; *   edge of the packet being outside the window, it will&n;&t;&t; *   be queued for later rather than sent.&n;&t;&t; */
id|copy
op_assign
id|sk-&gt;window_seq
op_minus
id|sk-&gt;write_seq
suffix:semicolon
r_if
c_cond
(paren
id|copy
op_le
l_int|0
op_logical_or
id|copy
template_param
id|sk-&gt;mss
)paren
id|copy
op_assign
id|sk-&gt;mss
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|seglen
)paren
id|copy
op_assign
id|seglen
suffix:semicolon
r_if
c_cond
(paren
id|copy
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;TCP: **bug**: copy=%d, sk-&gt;mss=%d&bslash;n&quot;
comma
id|copy
comma
id|sk-&gt;mss
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;We should really check the window here also.&n;&t;&t;&t; */
id|delay
op_assign
l_int|0
suffix:semicolon
id|tmp
op_assign
id|copy
op_plus
id|sk-&gt;prot-&gt;max_header
op_plus
l_int|15
suffix:semicolon
r_if
c_cond
(paren
id|copy
OL
id|sk-&gt;mss
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|MSG_OOB
)paren
op_logical_and
id|sk-&gt;packets_out
)paren
(brace
id|tmp
op_assign
id|tmp
op_minus
id|copy
op_plus
id|sk-&gt;mtu
op_plus
l_int|128
suffix:semicolon
id|delay
op_assign
l_int|1
suffix:semicolon
)brace
id|skb
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|tmp
comma
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;If we didn&squot;t get any memory, we need to sleep.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;socket-&gt;flags
op_or_assign
id|SO_NOSPACE
suffix:semicolon
r_if
c_cond
(paren
id|nonblock
)paren
(brace
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|wait_for_tcp_memory
c_func
(paren
id|sk
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;localroute
op_assign
id|sk-&gt;localroute
op_or
(paren
id|flags
op_amp
id|MSG_DONTROUTE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * FIXME: we need to optimize this.&n;&t;&t;&t; * Perhaps some hints here would be good.&n;&t;&t;&t; */
id|tmp
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|skb
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|skb-&gt;truesize
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
comma
op_amp
id|sk-&gt;ip_route_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sock_wfree
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_NO_PATH_MTU_DISCOVERY
id|skb-&gt;ip_hdr-&gt;frag_off
op_or_assign
id|htons
c_func
(paren
id|IP_DF
)paren
suffix:semicolon
macro_line|#endif
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;h.th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|tmp
op_assign
id|tcp_build_header
c_func
(paren
id|skb-&gt;h.th
comma
id|sk
comma
id|seglen
op_minus
id|copy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sock_wfree
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_OOB
)paren
(brace
id|skb-&gt;h.th-&gt;urg
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;h.th-&gt;urg_ptr
op_assign
id|ntohs
c_func
(paren
id|copy
)paren
suffix:semicolon
)brace
id|skb-&gt;csum
op_assign
id|csum_partial_copy_fromuser
c_func
(paren
id|from
comma
id|skb_put
c_func
(paren
id|skb
comma
id|copy
)paren
comma
id|copy
comma
l_int|0
)paren
suffix:semicolon
id|from
op_add_assign
id|copy
suffix:semicolon
id|copied
op_add_assign
id|copy
suffix:semicolon
id|len
op_sub_assign
id|copy
suffix:semicolon
id|seglen
op_sub_assign
id|copy
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;write_seq
op_add_assign
id|copy
suffix:semicolon
r_if
c_cond
(paren
id|delay
)paren
(brace
id|tcp_enqueue_partial
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|tcp_send_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_return
id|copied
suffix:semicolon
)brace
DECL|function|tcp_sendmsg
r_static
r_int
id|tcp_sendmsg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
)paren
(brace
r_int
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Do sanity checking for sendmsg/sendto/send&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
op_complement
(paren
id|MSG_OOB
op_or
id|MSG_DONTROUTE
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;msg_name
)paren
(brace
r_struct
id|sockaddr_in
op_star
id|addr
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
id|msg-&gt;msg_name
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;msg_namelen
OL
r_sizeof
(paren
op_star
id|addr
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|addr-&gt;sin_family
op_logical_and
id|addr-&gt;sin_family
op_ne
id|AF_INET
)paren
r_goto
id|out
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|retval
op_assign
op_minus
id|EISCONN
suffix:semicolon
r_if
c_cond
(paren
id|addr-&gt;sin_port
op_ne
id|sk-&gt;dummy_th.dest
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|addr-&gt;sin_addr.s_addr
op_ne
id|sk-&gt;daddr
)paren
r_goto
id|out
suffix:semicolon
)brace
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|retval
op_assign
id|do_tcp_sendmsg
c_func
(paren
id|sk
comma
id|msg-&gt;msg_iovlen
comma
id|msg-&gt;msg_iov
comma
id|len
comma
id|nonblock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Nagle&squot;s rule. Turn Nagle off with TCP_NODELAY for highly&n; *&t;interactive fast network servers. It&squot;s meant to be on and&n; *&t;it really improves the throughput though not the echo time&n; *&t;on my slow slip link - Alan&n; *&n; *&t;If not nagling we can send on the before case too..&n; */
r_if
c_cond
(paren
id|sk-&gt;partial
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;packets_out
op_logical_or
(paren
id|sk-&gt;nonagle
op_logical_and
id|before
c_func
(paren
id|sk-&gt;write_seq
comma
id|sk-&gt;window_seq
)paren
)paren
)paren
(brace
id|tcp_send_partial
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send an ack if one is backlogged at this point.&n; */
DECL|function|tcp_read_wakeup
r_void
id|tcp_read_wakeup
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;ack_backlog
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re closed, don&squot;t send an ack, or we&squot;ll get a RST&n;&t; * from the closed destination.&n;&t; */
r_if
c_cond
(paren
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
op_logical_or
(paren
id|sk-&gt;state
op_eq
id|TCP_TIME_WAIT
)paren
)paren
r_return
suffix:semicolon
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Handle reading urgent data. BSD has very simple semantics for&n; *&t;this, no blocking and very strange errors 8)&n; */
DECL|function|tcp_recv_urg
r_static
r_int
id|tcp_recv_urg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|nonblock
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_int
id|flags
comma
r_int
op_star
id|addr_len
)paren
(brace
multiline_comment|/*&n;&t; *&t;No URG data to read&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;urginline
op_logical_or
op_logical_neg
id|sk-&gt;urg_data
op_logical_or
id|sk-&gt;urg_data
op_eq
id|URG_READ
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Yes this is right ! */
r_if
c_cond
(paren
id|sk-&gt;err
)paren
r_return
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
op_logical_or
id|sk-&gt;done
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;done
)paren
(brace
id|sk-&gt;done
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENOTCONN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
(brace
id|sk-&gt;done
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;urg_data
op_amp
id|URG_VALID
)paren
(brace
r_char
id|c
op_assign
id|sk-&gt;urg_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
)paren
id|sk-&gt;urg_data
op_assign
id|URG_READ
suffix:semicolon
id|memcpy_toiovec
c_func
(paren
id|msg-&gt;msg_iov
comma
op_amp
id|c
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;msg_name
)paren
(brace
r_struct
id|sockaddr_in
op_star
id|sin
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
id|msg-&gt;msg_name
suffix:semicolon
id|sin-&gt;sin_family
op_assign
id|AF_INET
suffix:semicolon
id|sin-&gt;sin_addr.s_addr
op_assign
id|sk-&gt;daddr
suffix:semicolon
id|sin-&gt;sin_port
op_assign
id|sk-&gt;dummy_th.dest
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr_len
)paren
(brace
op_star
id|addr_len
op_assign
r_sizeof
(paren
r_struct
id|sockaddr_in
)paren
suffix:semicolon
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fixed the recv(..., MSG_OOB) behaviour.  BSD docs and&n;&t; * the available implementations agree in this case:&n;&t; * this call should never block, independent of the&n;&t; * blocking state of the socket.&n;&t; * Mike &lt;pall@rz.uni-karlsruhe.de&gt;&n;&t; */
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Release a skb if it is no longer needed. This routine&n; *&t;must be called with interrupts disabled or with the&n; *&t;socket locked so that the sk_buff queue operation is ok.&n; */
DECL|function|tcp_eat_skb
r_static
r_inline
r_void
id|tcp_eat_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|__skb_unlink
c_func
(paren
id|skb
comma
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;FIXME:&n; *&t;This routine frees used buffers.&n; *&t;It should consider sending an ACK to let the&n; *&t;other end know we now have a bigger window.&n; */
DECL|function|cleanup_rbuf
r_static
r_void
id|cleanup_rbuf
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
multiline_comment|/*&n;&t; * NOTE! The socket must be locked, so that we don&squot;t get&n;&t; * a messed-up receive queue.&n;&t; */
r_while
c_loop
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|sk-&gt;receive_queue.next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;used
op_logical_or
id|skb-&gt;users
)paren
r_break
suffix:semicolon
id|tcp_eat_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Tell the world if we raised the window.&n;&t; */
r_if
c_cond
(paren
id|tcp_raise_window
c_func
(paren
id|sk
)paren
)paren
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine copies from a sock struct into the user buffer.&n; */
DECL|function|tcp_recvmsg
r_static
r_int
id|tcp_recvmsg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
comma
r_int
op_star
id|addr_len
)paren
(brace
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
id|u32
id|peek_seq
suffix:semicolon
r_volatile
id|u32
op_star
id|seq
suffix:semicolon
multiline_comment|/* So gcc doesn&squot;t overoptimise */
r_int
r_int
id|used
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This error should be checked.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Urgent data needs to be handled specially.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_OOB
)paren
r_return
id|tcp_recv_urg
c_func
(paren
id|sk
comma
id|nonblock
comma
id|msg
comma
id|len
comma
id|flags
comma
id|addr_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Copying sequence to update. This is volatile to handle&n;&t; *&t;the multi-reader case neatly (memcpy_to/fromfs might be&n;&t; *&t;inline and thus not flush cached variables otherwise).&n;&t; */
id|peek_seq
op_assign
id|sk-&gt;copied_seq
suffix:semicolon
id|seq
op_assign
op_amp
id|sk-&gt;copied_seq
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
id|seq
op_assign
op_amp
id|peek_seq
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|u32
id|offset
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Are we at urgent data? Stop if we have read anything.&n;&t;&t; */
r_if
c_cond
(paren
id|copied
op_logical_and
id|sk-&gt;urg_data
op_logical_and
id|sk-&gt;urg_seq
op_eq
op_star
id|seq
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We need to check signals first, to get correct SIGURG&n;&t;&t; * handling.&n;&t;&t; */
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
r_if
c_cond
(paren
id|copied
)paren
r_break
suffix:semicolon
id|copied
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Next get a buffer.&n;&t;&t; */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|skb
op_assign
id|sk-&gt;receive_queue.next
suffix:semicolon
r_while
c_loop
(paren
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;receive_queue
)paren
(brace
r_if
c_cond
(paren
id|before
c_func
(paren
op_star
id|seq
comma
id|skb-&gt;seq
)paren
)paren
r_break
suffix:semicolon
id|offset
op_assign
op_star
id|seq
op_minus
id|skb-&gt;seq
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;syn
)paren
id|offset
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
id|skb-&gt;len
)paren
r_goto
id|found_ok_skb
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;fin
)paren
r_goto
id|found_fin_ok
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
)paren
id|skb-&gt;used
op_assign
l_int|1
suffix:semicolon
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copied
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;err
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
)paren
(brace
id|copied
op_assign
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;done
)paren
(brace
id|sk-&gt;done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|copied
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
(brace
id|sk-&gt;done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nonblock
)paren
(brace
id|copied
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cleanup_rbuf
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;socket-&gt;flags
op_or_assign
id|SO_WAITDATA
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;socket-&gt;flags
op_and_assign
op_complement
id|SO_WAITDATA
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_continue
suffix:semicolon
id|found_ok_skb
suffix:colon
multiline_comment|/*&n;&t;&t; *&t;Lock the buffer. We can be fairly relaxed as&n;&t;&t; *&t;an interrupt will never steal a buffer we are&n;&t;&t; *&t;using unless I&squot;ve missed something serious in&n;&t;&t; *&t;tcp_data.&n;&t;&t; */
id|skb-&gt;users
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Ok so how much can we use ?&n;&t;&t; */
id|used
op_assign
id|skb-&gt;len
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|used
)paren
id|used
op_assign
id|len
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Do we have urgent data here?&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;urg_data
)paren
(brace
id|u32
id|urg_offset
op_assign
id|sk-&gt;urg_seq
op_minus
op_star
id|seq
suffix:semicolon
r_if
c_cond
(paren
id|urg_offset
OL
id|used
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|urg_offset
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;urginline
)paren
(brace
op_increment
op_star
id|seq
suffix:semicolon
id|offset
op_increment
suffix:semicolon
id|used
op_decrement
suffix:semicolon
)brace
)brace
r_else
id|used
op_assign
id|urg_offset
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; *&t;Copy it - We _MUST_ update *seq first so that we&n;&t;&t; *&t;don&squot;t ever double read when we have dual readers&n;&t;&t; */
op_star
id|seq
op_add_assign
id|used
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;This memcpy_tofs can sleep. If it sleeps and we&n;&t;&t; *&t;do a second read it relies on the skb-&gt;users to avoid&n;&t;&t; *&t;a crash when cleanup_rbuf() gets called.&n;&t;&t; */
id|memcpy_toiovec
c_func
(paren
id|msg-&gt;msg_iov
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|skb-&gt;h.th
)paren
op_plus
id|skb-&gt;h.th-&gt;doff
op_star
l_int|4
op_plus
id|offset
comma
id|used
)paren
suffix:semicolon
id|copied
op_add_assign
id|used
suffix:semicolon
id|len
op_sub_assign
id|used
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;We now will not sleep again until we are finished&n;&t;&t; *&t;with skb. Sorry if you are doing the SMP port&n;&t;&t; *&t;but you&squot;ll just have to fix it neatly ;)&n;&t;&t; */
id|skb-&gt;users
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|sk-&gt;copied_seq
comma
id|sk-&gt;urg_seq
)paren
)paren
id|sk-&gt;urg_data
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|used
op_plus
id|offset
OL
id|skb-&gt;len
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Process the FIN.&n;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;fin
)paren
r_goto
id|found_fin_ok
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
r_continue
suffix:semicolon
id|skb-&gt;used
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;users
)paren
id|tcp_eat_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_continue
suffix:semicolon
id|found_fin_ok
suffix:colon
op_increment
op_star
id|seq
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;All is done&n;&t;&t; */
id|skb-&gt;used
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;shutdown
op_or_assign
id|RCV_SHUTDOWN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copied
OG
l_int|0
op_logical_and
id|msg-&gt;msg_name
)paren
(brace
r_struct
id|sockaddr_in
op_star
id|sin
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
id|msg-&gt;msg_name
suffix:semicolon
id|sin-&gt;sin_family
op_assign
id|AF_INET
suffix:semicolon
id|sin-&gt;sin_addr.s_addr
op_assign
id|sk-&gt;daddr
suffix:semicolon
id|sin-&gt;sin_port
op_assign
id|sk-&gt;dummy_th.dest
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr_len
)paren
(brace
op_star
id|addr_len
op_assign
r_sizeof
(paren
r_struct
id|sockaddr_in
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
multiline_comment|/* Clean up data we have read: This will do ACK frames */
id|cleanup_rbuf
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|copied
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;State processing on a close. This implements the state shift for&n; *&t;sending our FIN frame. Note that we only send a FIN for some&n; *&t;states. A shutdown() may have already sent the FIN, or we may be&n; *&t;closed.&n; */
DECL|function|tcp_close_state
r_static
r_int
id|tcp_close_state
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|dead
)paren
(brace
r_int
id|ns
op_assign
id|TCP_CLOSE
suffix:semicolon
r_int
id|send_fin
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_SYN_SENT
suffix:colon
multiline_comment|/* No SYN back, no FIN needed */
r_break
suffix:semicolon
r_case
id|TCP_SYN_RECV
suffix:colon
r_case
id|TCP_ESTABLISHED
suffix:colon
multiline_comment|/* Closedown begin */
id|ns
op_assign
id|TCP_FIN_WAIT1
suffix:semicolon
id|send_fin
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_FIN_WAIT1
suffix:colon
multiline_comment|/* Already closing, or FIN sent: no change */
r_case
id|TCP_FIN_WAIT2
suffix:colon
r_case
id|TCP_CLOSING
suffix:colon
id|ns
op_assign
id|sk-&gt;state
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE
suffix:colon
r_case
id|TCP_LISTEN
suffix:colon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE_WAIT
suffix:colon
multiline_comment|/* They have FIN&squot;d us. We send our FIN and&n;&t;&t;&t;&t;&t;   wait only for the ACK */
id|ns
op_assign
id|TCP_LAST_ACK
suffix:semicolon
id|send_fin
op_assign
l_int|1
suffix:semicolon
)brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|ns
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This is a (useful) BSD violating of the RFC. There is a&n;&t; *&t;problem with TCP as specified in that the other end could&n;&t; *&t;keep a socket open forever with no application left this end.&n;&t; *&t;We use a 3 minute timeout (about the same as BSD) then kill&n;&t; *&t;our end. If they send after that then tough - BUT: long enough&n;&t; *&t;that we won&squot;t make the old 4*rto = almost no time - whoops&n;&t; *&t;reset mistake.&n;&t; */
r_if
c_cond
(paren
id|dead
op_logical_and
id|ns
op_eq
id|TCP_FIN_WAIT2
)paren
(brace
r_int
id|timer_active
op_assign
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_active
)paren
(brace
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
)brace
r_else
id|tcp_reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_FIN_TIMEOUT
)paren
suffix:semicolon
)brace
r_return
id|send_fin
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Shutdown the sending side of a connection. Much like close except&n; *&t;that we don&squot;t receive shut down or set sk-&gt;dead.&n; */
DECL|function|tcp_shutdown
r_void
id|tcp_shutdown
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
)paren
(brace
multiline_comment|/*&n;&t; *&t;We need to grab some memory, and put together a FIN,&n;&t; *&t;and then put it into the queue to be sent.&n;&t; *&t;&t;Tim MacKenzie(tym@dibbler.cs.monash.edu.au) 4 Dec &squot;92.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|how
op_amp
id|SEND_SHUTDOWN
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If we&squot;ve already sent a FIN, or it&squot;s a closed state&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT1
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT2
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_CLOSING
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_LAST_ACK
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_TIME_WAIT
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_CLOSE
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
(brace
r_return
suffix:semicolon
)brace
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * flag that the sender has shutdown&n;&t; */
id|sk-&gt;shutdown
op_or_assign
id|SEND_SHUTDOWN
suffix:semicolon
multiline_comment|/*&n;&t; *  Clear out any half completed packets.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;partial
)paren
id|tcp_send_partial
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;FIN if needed&n;&t; */
r_if
c_cond
(paren
id|tcp_close_state
c_func
(paren
id|sk
comma
l_int|0
)paren
)paren
id|tcp_send_fin
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Return 1 if we still have things to send in our buffers.&n; */
DECL|function|closing
r_static
r_inline
r_int
id|closing
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_FIN_WAIT1
suffix:colon
r_case
id|TCP_CLOSING
suffix:colon
r_case
id|TCP_LAST_ACK
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tcp_close
r_static
r_void
id|tcp_close
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|timeout
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/*&n;&t; * We need to grab some memory, and put together a FIN,&n;&t; * and then put it into the queue to be sent.&n;&t; */
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_cache_zap
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
(brace
multiline_comment|/* Special case */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|tcp_close_pending
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;dead
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sk-&gt;keepopen
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  We need to flush the recv. buffs.  We do this only on the&n;&t; *  descriptor close, not protocol-sourced closes, because the&n;&t; *  reader process may not have drained the data yet!&n;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Get rid off any half-completed packets.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;partial
)paren
id|tcp_send_partial
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Timeout is not the same thing - however the code likes&n;&t; *&t;to send both the same way (sigh).&n;&t; */
r_if
c_cond
(paren
id|tcp_close_state
c_func
(paren
id|sk
comma
l_int|1
)paren
op_eq
l_int|1
)paren
(brace
id|tcp_send_fin
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timeout
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|current-&gt;timeout
op_assign
id|timeout
suffix:semicolon
r_while
c_loop
(paren
id|closing
c_func
(paren
id|sk
)paren
op_logical_and
id|current-&gt;timeout
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This will destroy it. The timers will take care of actually&n;&t; * free&squot;ing up the memory.&n;&t; */
id|tcp_cache_zap
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Kill the cache again. */
multiline_comment|/* Now that the socket is dead, if we are in the FIN_WAIT2 state&n;&t; * we may need to set up a timer.&n;         */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT2
)paren
(brace
r_int
id|timer_active
op_assign
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_active
)paren
(brace
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
)brace
r_else
id|tcp_reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_FIN_TIMEOUT
)paren
suffix:semicolon
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;dead
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for a incoming connection, avoid race&n; * conditions. This must be called with the socket&n; * locked.&n; */
DECL|function|wait_for_connect
r_static
r_struct
id|sk_buff
op_star
id|wait_for_connect
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|skb
op_assign
id|tcp_find_established
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
r_break
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This will accept the next outstanding connection.&n; *&n; *&t;Be careful about race conditions here - this is subtle.&n; */
DECL|function|tcp_accept
r_static
r_struct
id|sock
op_star
id|tcp_accept
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|sock
op_star
id|newsk
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;   * We need to make sure that this socket is listening,&n;   * and that it has something pending.&n;   */
id|error
op_assign
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_LISTEN
)paren
r_goto
id|no_listen
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|skb
op_assign
id|tcp_find_established
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
id|got_new_connect
suffix:colon
id|__skb_unlink
c_func
(paren
id|skb
comma
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
id|newsk
op_assign
id|skb-&gt;sk
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|sk-&gt;ack_backlog
op_decrement
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|no_listen
suffix:colon
id|sk-&gt;err
op_assign
id|error
suffix:semicolon
r_return
id|newsk
suffix:semicolon
)brace
id|error
op_assign
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|O_NONBLOCK
)paren
r_goto
id|out
suffix:semicolon
id|skb
op_assign
id|wait_for_connect
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
r_goto
id|got_new_connect
suffix:semicolon
id|error
op_assign
id|ERESTARTSYS
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Check that a TCP address is unique, don&squot;t allow multiple&n; * connects to/from the same address&n; */
DECL|function|tcp_unique_address
r_static
r_int
id|tcp_unique_address
c_func
(paren
id|u32
id|saddr
comma
id|u16
id|snum
comma
id|u32
id|daddr
comma
id|u16
id|dnum
)paren
(brace
r_int
id|retval
op_assign
l_int|1
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
multiline_comment|/* Make sure we are allowed to connect here. */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sk
op_assign
id|tcp_prot.sock_array
(braket
id|snum
op_amp
(paren
id|SOCK_ARRAY_SIZE
op_minus
l_int|1
)paren
)braket
suffix:semicolon
id|sk
op_ne
l_int|NULL
suffix:semicolon
id|sk
op_assign
id|sk-&gt;next
)paren
(brace
multiline_comment|/* hash collision? */
r_if
c_cond
(paren
id|sk-&gt;num
op_ne
id|snum
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;saddr
op_ne
id|saddr
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;daddr
op_ne
id|daddr
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;dummy_th.dest
op_ne
id|dnum
)paren
r_continue
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This will initiate an outgoing connection.&n; */
DECL|function|tcp_connect
r_static
r_int
id|tcp_connect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr_in
op_star
id|usin
comma
r_int
id|addr_len
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_int
id|atype
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_CLOSE
)paren
r_return
op_minus
id|EISCONN
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Don&squot;t allow a double connect.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;daddr
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr_len
OL
l_int|8
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|usin-&gt;sin_family
op_logical_and
id|usin-&gt;sin_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
multiline_comment|/*&n;  &t; *&t;connect() to INADDR_ANY means loopback (BSD&squot;ism).&n;  &t; */
r_if
c_cond
(paren
id|usin-&gt;sin_addr.s_addr
op_eq
id|INADDR_ANY
)paren
id|usin-&gt;sin_addr.s_addr
op_assign
id|ip_my_addr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Don&squot;t want a TCP connection going to a broadcast address&n;&t; */
r_if
c_cond
(paren
(paren
id|atype
op_assign
id|ip_chk_addr
c_func
(paren
id|usin-&gt;sin_addr.s_addr
)paren
)paren
op_eq
id|IS_BROADCAST
op_logical_or
id|atype
op_eq
id|IS_MULTICAST
)paren
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_unique_address
c_func
(paren
id|sk-&gt;saddr
comma
id|sk-&gt;num
comma
id|usin-&gt;sin_addr.s_addr
comma
id|usin-&gt;sin_port
)paren
)paren
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;daddr
op_assign
id|usin-&gt;sin_addr.s_addr
suffix:semicolon
id|sk-&gt;rcv_ack_cnt
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;dummy_th.dest
op_assign
id|usin-&gt;sin_port
suffix:semicolon
id|buff
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|MAX_SYN_SIZE
comma
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|buff-&gt;free
op_assign
l_int|0
suffix:semicolon
id|buff-&gt;localroute
op_assign
id|sk-&gt;localroute
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Put in the IP header and routing stuff.&n;&t; */
id|tmp
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|MAX_SYN_SIZE
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
comma
op_amp
id|sk-&gt;ip_route_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sock_wfree
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rt
op_assign
id|sk-&gt;ip_route_cache
)paren
op_ne
l_int|NULL
op_logical_and
op_logical_neg
id|sk-&gt;saddr
)paren
id|sk-&gt;saddr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|sk-&gt;rcv_saddr
op_assign
id|sk-&gt;saddr
suffix:semicolon
multiline_comment|/*&n;&t; * Set up our outgoing TCP sequence number&n;&t; */
id|sk-&gt;write_seq
op_assign
id|secure_tcp_sequence_number
c_func
(paren
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
id|sk-&gt;dummy_th.source
comma
id|usin-&gt;sin_port
)paren
suffix:semicolon
id|sk-&gt;window_seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|sk-&gt;rcv_ack_seq
op_assign
id|sk-&gt;write_seq
op_minus
l_int|1
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
(paren
r_void
op_star
)paren
op_amp
(paren
id|sk-&gt;dummy_th
)paren
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
id|buff-&gt;seq
op_assign
id|sk-&gt;write_seq
op_increment
suffix:semicolon
id|t1-&gt;seq
op_assign
id|htonl
c_func
(paren
id|buff-&gt;seq
)paren
suffix:semicolon
id|sk-&gt;sent_seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|buff-&gt;end_seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;window
op_assign
l_int|2
suffix:semicolon
id|t1-&gt;syn
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;doff
op_assign
l_int|6
suffix:semicolon
multiline_comment|/* use 512 or whatever user asked for */
r_if
c_cond
(paren
id|rt
op_ne
l_int|NULL
op_logical_and
(paren
id|rt-&gt;rt_flags
op_amp
id|RTF_WINDOW
)paren
)paren
(brace
id|sk-&gt;window_clamp
op_assign
id|rt-&gt;rt_window
suffix:semicolon
)brace
r_else
id|sk-&gt;window_clamp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;user_mss
)paren
id|sk-&gt;mtu
op_assign
id|sk-&gt;user_mss
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rt
)paren
id|sk-&gt;mtu
op_assign
id|rt-&gt;rt_mtu
op_minus
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
r_else
id|sk-&gt;mtu
op_assign
l_int|576
op_minus
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;but not bigger than device MTU&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;mtu
OL
l_int|32
)paren
(brace
id|sk-&gt;mtu
op_assign
l_int|32
suffix:semicolon
)brace
multiline_comment|/* Sanity limit */
id|sk-&gt;mtu
op_assign
id|min
c_func
(paren
id|sk-&gt;mtu
comma
id|dev-&gt;mtu
op_minus
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SKIP
multiline_comment|/*&n;&t; *&t;SKIP devices set their MTU to 65535. This is so they can take packets&n;&t; *&t;unfragmented to security process then fragment. They could lie to the&n;&t; *&t;TCP layer about a suitable MTU, but it&squot;s easier to let skip sort it out&n;&t; *&t;simply because the final package we want unfragmented is going to be&n;&t; *&n;&t; *&t;[IPHDR][IPSP][Security data][Modified TCP data][Security data]&n;&t; */
r_if
c_cond
(paren
id|skip_pick_mtu
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* If SKIP is loaded.. */
id|sk-&gt;mtu
op_assign
id|skip_pick_mtu
c_func
(paren
id|sk-&gt;mtu
comma
id|dev
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Put in the TCP options to say MTU.&n;&t; */
id|ptr
op_assign
id|skb_put
c_func
(paren
id|buff
comma
l_int|4
)paren
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
l_int|2
suffix:semicolon
id|ptr
(braket
l_int|1
)braket
op_assign
l_int|4
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
(paren
id|sk-&gt;mtu
)paren
op_rshift
l_int|8
suffix:semicolon
id|ptr
(braket
l_int|3
)braket
op_assign
(paren
id|sk-&gt;mtu
)paren
op_amp
l_int|0xff
suffix:semicolon
id|buff-&gt;csum
op_assign
id|csum_partial
c_func
(paren
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
l_int|4
comma
id|buff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This must go first otherwise a really quick response will get reset.&n;&t; */
id|tcp_cache_zap
c_func
(paren
)paren
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_SYN_SENT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_logical_and
id|rt-&gt;rt_flags
op_amp
id|RTF_IRTT
)paren
(brace
id|sk-&gt;rto
op_assign
id|rt-&gt;rt_irtt
suffix:semicolon
)brace
r_else
id|sk-&gt;rto
op_assign
id|TCP_TIMEOUT_INIT
suffix:semicolon
id|sk-&gt;delack_timer.function
op_assign
id|tcp_delack_timer
suffix:semicolon
id|sk-&gt;delack_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|sk-&gt;retransmit_timer.function
op_assign
id|tcp_retransmit_timer
suffix:semicolon
id|sk-&gt;retransmit_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|sk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|0
)paren
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
id|tcp_statistics.TcpActiveOpens
op_increment
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Socket option code for TCP.&n; */
DECL|function|tcp_setsockopt
r_int
id|tcp_setsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_int
id|val
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
id|level
op_ne
id|SOL_TCP
)paren
(brace
r_return
id|ip_setsockopt
c_func
(paren
id|sk
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|optval
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|optval
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|val
op_assign
id|get_user
c_func
(paren
(paren
r_int
op_star
)paren
id|optval
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|TCP_MAXSEG
suffix:colon
multiline_comment|/*&n; * values greater than interface MTU won&squot;t take effect.  however at&n; * the point when this call is done we typically don&squot;t yet know&n; * which interface is going to be used&n; */
r_if
c_cond
(paren
id|val
id|MAX_WINDOW
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|sk-&gt;user_mss
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TCP_NODELAY
suffix:colon
id|sk-&gt;nonagle
op_assign
(paren
id|val
op_eq
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
)brace
)brace
DECL|function|tcp_getsockopt
r_int
id|tcp_getsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
r_int
id|val
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
id|level
op_ne
id|SOL_TCP
)paren
(brace
r_return
id|ip_getsockopt
c_func
(paren
id|sk
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|TCP_MAXSEG
suffix:colon
id|val
op_assign
id|sk-&gt;user_mss
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_NODELAY
suffix:colon
id|val
op_assign
id|sk-&gt;nonagle
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
)brace
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|optlen
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_user
c_func
(paren
r_sizeof
(paren
r_int
)paren
comma
(paren
r_int
op_star
)paren
id|optlen
)paren
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|optval
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|optval
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|tcp_prot
r_struct
id|proto
id|tcp_prot
op_assign
(brace
id|tcp_close
comma
id|ip_build_header
comma
id|tcp_connect
comma
id|tcp_accept
comma
id|ip_queue_xmit
comma
id|tcp_retransmit
comma
id|tcp_write_wakeup
comma
id|tcp_read_wakeup
comma
id|tcp_rcv
comma
id|tcp_select
comma
id|tcp_ioctl
comma
l_int|NULL
comma
id|tcp_shutdown
comma
id|tcp_setsockopt
comma
id|tcp_getsockopt
comma
id|tcp_sendmsg
comma
id|tcp_recvmsg
comma
l_int|NULL
comma
multiline_comment|/* No special bind() */
l_int|128
comma
l_int|0
comma
l_string|&quot;TCP&quot;
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|NULL
comma
)brace
)brace
suffix:semicolon
eof
