multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Implementation of the Transmission Control Protocol(TCP).&n; *&n; * Version:&t;$Id: tcp.c,v 1.180 2000/11/28 17:04:09 davem Exp $&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;&n; *&t;&t;Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;Numerous verify_area() calls&n; *&t;&t;Alan Cox&t;:&t;Set the ACK bit on a reset&n; *&t;&t;Alan Cox&t;:&t;Stopped it crashing if it closed while&n; *&t;&t;&t;&t;&t;sk-&gt;inuse=1 and was trying to connect&n; *&t;&t;&t;&t;&t;(tcp_err()).&n; *&t;&t;Alan Cox&t;:&t;All icmp error handling was broken&n; *&t;&t;&t;&t;&t;pointers passed where wrong and the&n; *&t;&t;&t;&t;&t;socket was looked up backwards. Nobody&n; *&t;&t;&t;&t;&t;tested any icmp error code obviously.&n; *&t;&t;Alan Cox&t;:&t;tcp_err() now handled properly. It&n; *&t;&t;&t;&t;&t;wakes people on errors. poll&n; *&t;&t;&t;&t;&t;behaves and the icmp error race&n; *&t;&t;&t;&t;&t;has gone by moving it into sock.c&n; *&t;&t;Alan Cox&t;:&t;tcp_send_reset() fixed to work for&n; *&t;&t;&t;&t;&t;everything not just packets for&n; *&t;&t;&t;&t;&t;unknown sockets.&n; *&t;&t;Alan Cox&t;:&t;tcp option processing.&n; *&t;&t;Alan Cox&t;:&t;Reset tweaked (still not 100%) [Had&n; *&t;&t;&t;&t;&t;syn rule wrong]&n; *&t;&t;Herp Rosmanith  :&t;More reset fixes&n; *&t;&t;Alan Cox&t;:&t;No longer acks invalid rst frames.&n; *&t;&t;&t;&t;&t;Acking any kind of RST is right out.&n; *&t;&t;Alan Cox&t;:&t;Sets an ignore me flag on an rst&n; *&t;&t;&t;&t;&t;receive otherwise odd bits of prattle&n; *&t;&t;&t;&t;&t;escape still&n; *&t;&t;Alan Cox&t;:&t;Fixed another acking RST frame bug.&n; *&t;&t;&t;&t;&t;Should stop LAN workplace lockups.&n; *&t;&t;Alan Cox&t;: &t;Some tidyups using the new skb list&n; *&t;&t;&t;&t;&t;facilities&n; *&t;&t;Alan Cox&t;:&t;sk-&gt;keepopen now seems to work&n; *&t;&t;Alan Cox&t;:&t;Pulls options out correctly on accepts&n; *&t;&t;Alan Cox&t;:&t;Fixed assorted sk-&gt;rqueue-&gt;next errors&n; *&t;&t;Alan Cox&t;:&t;PSH doesn&squot;t end a TCP read. Switched a&n; *&t;&t;&t;&t;&t;bit to skb ops.&n; *&t;&t;Alan Cox&t;:&t;Tidied tcp_data to avoid a potential&n; *&t;&t;&t;&t;&t;nasty.&n; *&t;&t;Alan Cox&t;:&t;Added some better commenting, as the&n; *&t;&t;&t;&t;&t;tcp is hard to follow&n; *&t;&t;Alan Cox&t;:&t;Removed incorrect check for 20 * psh&n; *&t;Michael O&squot;Reilly&t;:&t;ack &lt; copied bug fix.&n; *&t;Johannes Stille&t;&t;:&t;Misc tcp fixes (not all in yet).&n; *&t;&t;Alan Cox&t;:&t;FIN with no memory -&gt; CRASH&n; *&t;&t;Alan Cox&t;:&t;Added socket option proto entries.&n; *&t;&t;&t;&t;&t;Also added awareness of them to accept.&n; *&t;&t;Alan Cox&t;:&t;Added TCP options (SOL_TCP)&n; *&t;&t;Alan Cox&t;:&t;Switched wakeup calls to callbacks,&n; *&t;&t;&t;&t;&t;so the kernel can layer network&n; *&t;&t;&t;&t;&t;sockets.&n; *&t;&t;Alan Cox&t;:&t;Use ip_tos/ip_ttl settings.&n; *&t;&t;Alan Cox&t;:&t;Handle FIN (more) properly (we hope).&n; *&t;&t;Alan Cox&t;:&t;RST frames sent on unsynchronised&n; *&t;&t;&t;&t;&t;state ack error.&n; *&t;&t;Alan Cox&t;:&t;Put in missing check for SYN bit.&n; *&t;&t;Alan Cox&t;:&t;Added tcp_select_window() aka NET2E&n; *&t;&t;&t;&t;&t;window non shrink trick.&n; *&t;&t;Alan Cox&t;:&t;Added a couple of small NET2E timer&n; *&t;&t;&t;&t;&t;fixes&n; *&t;&t;Charles Hedrick :&t;TCP fixes&n; *&t;&t;Toomas Tamm&t;:&t;TCP window fixes&n; *&t;&t;Alan Cox&t;:&t;Small URG fix to rlogin ^C ack fight&n; *&t;&t;Charles Hedrick&t;:&t;Rewrote most of it to actually work&n; *&t;&t;Linus&t;&t;:&t;Rewrote tcp_read() and URG handling&n; *&t;&t;&t;&t;&t;completely&n; *&t;&t;Gerhard Koerting:&t;Fixed some missing timer handling&n; *&t;&t;Matthew Dillon  :&t;Reworked TCP machine states as per RFC&n; *&t;&t;Gerhard Koerting:&t;PC/TCP workarounds&n; *&t;&t;Adam Caldwell&t;:&t;Assorted timer/timing errors&n; *&t;&t;Matthew Dillon&t;:&t;Fixed another RST bug&n; *&t;&t;Alan Cox&t;:&t;Move to kernel side addressing changes.&n; *&t;&t;Alan Cox&t;:&t;Beginning work on TCP fastpathing&n; *&t;&t;&t;&t;&t;(not yet usable)&n; *&t;&t;Arnt Gulbrandsen:&t;Turbocharged tcp_check() routine.&n; *&t;&t;Alan Cox&t;:&t;TCP fast path debugging&n; *&t;&t;Alan Cox&t;:&t;Window clamping&n; *&t;&t;Michael Riepe&t;:&t;Bug in tcp_check()&n; *&t;&t;Matt Dillon&t;:&t;More TCP improvements and RST bug fixes&n; *&t;&t;Matt Dillon&t;:&t;Yet more small nasties remove from the&n; *&t;&t;&t;&t;&t;TCP code (Be very nice to this man if&n; *&t;&t;&t;&t;&t;tcp finally works 100%) 8)&n; *&t;&t;Alan Cox&t;:&t;BSD accept semantics.&n; *&t;&t;Alan Cox&t;:&t;Reset on closedown bug.&n; *&t;Peter De Schrijver&t;:&t;ENOTCONN check missing in tcp_sendto().&n; *&t;&t;Michael Pall&t;:&t;Handle poll() after URG properly in&n; *&t;&t;&t;&t;&t;all cases.&n; *&t;&t;Michael Pall&t;:&t;Undo the last fix in tcp_read_urg()&n; *&t;&t;&t;&t;&t;(multi URG PUSH broke rlogin).&n; *&t;&t;Michael Pall&t;:&t;Fix the multi URG PUSH problem in&n; *&t;&t;&t;&t;&t;tcp_readable(), poll() after URG&n; *&t;&t;&t;&t;&t;works now.&n; *&t;&t;Michael Pall&t;:&t;recv(...,MSG_OOB) never blocks in the&n; *&t;&t;&t;&t;&t;BSD api.&n; *&t;&t;Alan Cox&t;:&t;Changed the semantics of sk-&gt;socket to&n; *&t;&t;&t;&t;&t;fix a race and a signal problem with&n; *&t;&t;&t;&t;&t;accept() and async I/O.&n; *&t;&t;Alan Cox&t;:&t;Relaxed the rules on tcp_sendto().&n; *&t;&t;Yury Shevchuk&t;:&t;Really fixed accept() blocking problem.&n; *&t;&t;Craig I. Hagan  :&t;Allow for BSD compatible TIME_WAIT for&n; *&t;&t;&t;&t;&t;clients/servers which listen in on&n; *&t;&t;&t;&t;&t;fixed ports.&n; *&t;&t;Alan Cox&t;:&t;Cleaned the above up and shrank it to&n; *&t;&t;&t;&t;&t;a sensible code size.&n; *&t;&t;Alan Cox&t;:&t;Self connect lockup fix.&n; *&t;&t;Alan Cox&t;:&t;No connect to multicast.&n; *&t;&t;Ross Biro&t;:&t;Close unaccepted children on master&n; *&t;&t;&t;&t;&t;socket close.&n; *&t;&t;Alan Cox&t;:&t;Reset tracing code.&n; *&t;&t;Alan Cox&t;:&t;Spurious resets on shutdown.&n; *&t;&t;Alan Cox&t;:&t;Giant 15 minute/60 second timer error&n; *&t;&t;Alan Cox&t;:&t;Small whoops in polling before an&n; *&t;&t;&t;&t;&t;accept.&n; *&t;&t;Alan Cox&t;:&t;Kept the state trace facility since&n; *&t;&t;&t;&t;&t;it&squot;s handy for debugging.&n; *&t;&t;Alan Cox&t;:&t;More reset handler fixes.&n; *&t;&t;Alan Cox&t;:&t;Started rewriting the code based on&n; *&t;&t;&t;&t;&t;the RFC&squot;s for other useful protocol&n; *&t;&t;&t;&t;&t;references see: Comer, KA9Q NOS, and&n; *&t;&t;&t;&t;&t;for a reference on the difference&n; *&t;&t;&t;&t;&t;between specifications and how BSD&n; *&t;&t;&t;&t;&t;works see the 4.4lite source.&n; *&t;&t;A.N.Kuznetsov&t;:&t;Don&squot;t time wait on completion of tidy&n; *&t;&t;&t;&t;&t;close.&n; *&t;&t;Linus Torvalds&t;:&t;Fin/Shutdown &amp; copied_seq changes.&n; *&t;&t;Linus Torvalds&t;:&t;Fixed BSD port reuse to work first syn&n; *&t;&t;Alan Cox&t;:&t;Reimplemented timers as per the RFC&n; *&t;&t;&t;&t;&t;and using multiple timers for sanity.&n; *&t;&t;Alan Cox&t;:&t;Small bug fixes, and a lot of new&n; *&t;&t;&t;&t;&t;comments.&n; *&t;&t;Alan Cox&t;:&t;Fixed dual reader crash by locking&n; *&t;&t;&t;&t;&t;the buffers (much like datagram.c)&n; *&t;&t;Alan Cox&t;:&t;Fixed stuck sockets in probe. A probe&n; *&t;&t;&t;&t;&t;now gets fed up of retrying without&n; *&t;&t;&t;&t;&t;(even a no space) answer.&n; *&t;&t;Alan Cox&t;:&t;Extracted closing code better&n; *&t;&t;Alan Cox&t;:&t;Fixed the closing state machine to&n; *&t;&t;&t;&t;&t;resemble the RFC.&n; *&t;&t;Alan Cox&t;:&t;More &squot;per spec&squot; fixes.&n; *&t;&t;Jorge Cwik&t;:&t;Even faster checksumming.&n; *&t;&t;Alan Cox&t;:&t;tcp_data() doesn&squot;t ack illegal PSH&n; *&t;&t;&t;&t;&t;only frames. At least one pc tcp stack&n; *&t;&t;&t;&t;&t;generates them.&n; *&t;&t;Alan Cox&t;:&t;Cache last socket.&n; *&t;&t;Alan Cox&t;:&t;Per route irtt.&n; *&t;&t;Matt Day&t;:&t;poll()-&gt;select() match BSD precisely on error&n; *&t;&t;Alan Cox&t;:&t;New buffers&n; *&t;&t;Marc Tamsky&t;:&t;Various sk-&gt;prot-&gt;retransmits and&n; *&t;&t;&t;&t;&t;sk-&gt;retransmits misupdating fixed.&n; *&t;&t;&t;&t;&t;Fixed tcp_write_timeout: stuck close,&n; *&t;&t;&t;&t;&t;and TCP syn retries gets used now.&n; *&t;&t;Mark Yarvis&t;:&t;In tcp_read_wakeup(), don&squot;t send an&n; *&t;&t;&t;&t;&t;ack if state is TCP_CLOSED.&n; *&t;&t;Alan Cox&t;:&t;Look up device on a retransmit - routes may&n; *&t;&t;&t;&t;&t;change. Doesn&squot;t yet cope with MSS shrink right&n; *&t;&t;&t;&t;&t;but its a start!&n; *&t;&t;Marc Tamsky&t;:&t;Closing in closing fixes.&n; *&t;&t;Mike Shaver&t;:&t;RFC1122 verifications.&n; *&t;&t;Alan Cox&t;:&t;rcv_saddr errors.&n; *&t;&t;Alan Cox&t;:&t;Block double connect().&n; *&t;&t;Alan Cox&t;:&t;Small hooks for enSKIP.&n; *&t;&t;Alexey Kuznetsov:&t;Path MTU discovery.&n; *&t;&t;Alan Cox&t;:&t;Support soft errors.&n; *&t;&t;Alan Cox&t;:&t;Fix MTU discovery pathological case&n; *&t;&t;&t;&t;&t;when the remote claims no mtu!&n; *&t;&t;Marc Tamsky&t;:&t;TCP_CLOSE fix.&n; *&t;&t;Colin (G3TNE)&t;:&t;Send a reset on syn ack replies in&n; *&t;&t;&t;&t;&t;window but wrong (fixes NT lpd problems)&n; *&t;&t;Pedro Roque&t;:&t;Better TCP window handling, delayed ack.&n; *&t;&t;Joerg Reuter&t;:&t;No modification of locked buffers in&n; *&t;&t;&t;&t;&t;tcp_do_retransmit()&n; *&t;&t;Eric Schenk&t;:&t;Changed receiver side silly window&n; *&t;&t;&t;&t;&t;avoidance algorithm to BSD style&n; *&t;&t;&t;&t;&t;algorithm. This doubles throughput&n; *&t;&t;&t;&t;&t;against machines running Solaris,&n; *&t;&t;&t;&t;&t;and seems to result in general&n; *&t;&t;&t;&t;&t;improvement.&n; *&t;Stefan Magdalinski&t;:&t;adjusted tcp_readable() to fix FIONREAD&n; *&t;Willy Konynenberg&t;:&t;Transparent proxying support.&n; *&t;Mike McLagan&t;&t;:&t;Routing by source&n; *&t;&t;Keith Owens&t;:&t;Do proper merging with partial SKB&squot;s in&n; *&t;&t;&t;&t;&t;tcp_do_sendmsg to avoid burstiness.&n; *&t;&t;Eric Schenk&t;:&t;Fix fast close down bug with&n; *&t;&t;&t;&t;&t;shutdown() followed by close().&n; *&t;&t;Andi Kleen &t;:&t;Make poll agree with SIGIO&n; *&t;Salvatore Sanfilippo&t;:&t;Support SO_LINGER with linger == 1 and&n; *&t;&t;&t;&t;&t;lingertime == 0 (RFC 793 ABORT Call)&n; *&t;&t;&t;&t;&t;&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or(at your option) any later version.&n; *&n; * Description of States:&n; *&n; *&t;TCP_SYN_SENT&t;&t;sent a connection request, waiting for ack&n; *&n; *&t;TCP_SYN_RECV&t;&t;received a connection request, sent ack,&n; *&t;&t;&t;&t;waiting for final ack in three-way handshake.&n; *&n; *&t;TCP_ESTABLISHED&t;&t;connection established&n; *&n; *&t;TCP_FIN_WAIT1&t;&t;our side has shutdown, waiting to complete&n; *&t;&t;&t;&t;transmission of remaining buffered data&n; *&n; *&t;TCP_FIN_WAIT2&t;&t;all buffered data sent, waiting for remote&n; *&t;&t;&t;&t;to shutdown&n; *&n; *&t;TCP_CLOSING&t;&t;both sides have shutdown but we still have&n; *&t;&t;&t;&t;data we have to finish sending&n; *&n; *&t;TCP_TIME_WAIT&t;&t;timeout to catch resent junk before entering&n; *&t;&t;&t;&t;closed, can only be entered from FIN_WAIT2&n; *&t;&t;&t;&t;or CLOSING.  Required because the other end&n; *&t;&t;&t;&t;may not have gotten our last ACK causing it&n; *&t;&t;&t;&t;to retransmit the data packet (which we ignore)&n; *&n; *&t;TCP_CLOSE_WAIT&t;&t;remote side has shutdown and is waiting for&n; *&t;&t;&t;&t;us to finish writing our data and to shutdown&n; *&t;&t;&t;&t;(we have to close() to move on to LAST_ACK)&n; *&n; *&t;TCP_LAST_ACK&t;&t;out side has shutdown after remote has&n; *&t;&t;&t;&t;shutdown.  There may still be data in our&n; *&t;&t;&t;&t;buffer that we have to finish sending&n; *&n; *&t;TCP_CLOSE&t;&t;socket is finished&n; */
multiline_comment|/*&n; * RFC1122 status:&n; * NOTE: I&squot;m not going to be doing comments in the code for this one except&n; * for violations and the like.  tcp.c is just too big... If I say something&n; * &quot;does?&quot; or &quot;doesn&squot;t?&quot;, it means I&squot;m not sure, and will have to hash it out&n; * with Alan. -- MS 950903&n; * [Note: Most of the TCP code has been rewriten/redesigned since this &n; *  RFC1122 check. It is probably not correct anymore. It should be redone &n; *  before 2.2. -AK]&n; *&n; * Use of PSH (4.2.2.2)&n; *   MAY aggregate data sent without the PSH flag. (does)&n; *   MAY queue data received without the PSH flag. (does)&n; *   SHOULD collapse successive PSH flags when it packetizes data. (doesn&squot;t)&n; *   MAY implement PSH on send calls. (doesn&squot;t, thus:)&n; *     MUST NOT buffer data indefinitely (doesn&squot;t [1 second])&n; *     MUST set PSH on last segment (does)&n; *   MAY pass received PSH to application layer (doesn&squot;t)&n; *   SHOULD send maximum-sized segment whenever possible. (almost always does)&n; *&n; * Window Size (4.2.2.3, 4.2.2.16)&n; *   MUST treat window size as an unsigned number (does)&n; *   SHOULD treat window size as a 32-bit number (does not)&n; *   MUST NOT shrink window once it is offered (does not normally)&n; *&n; * Urgent Pointer (4.2.2.4)&n; * **MUST point urgent pointer to last byte of urgent data (not right&n; *     after). (doesn&squot;t, to be like BSD. That&squot;s configurable, but defaults&n; *&t;to off)&n; *   MUST inform application layer asynchronously of incoming urgent&n; *     data. (does)&n; *   MUST provide application with means of determining the amount of&n; *     urgent data pending. (does)&n; * **MUST support urgent data sequence of arbitrary length. (doesn&squot;t, but&n; *   it&squot;s sort of tricky to fix, as urg_ptr is a 16-bit quantity)&n; *&t;[Follows BSD 1 byte of urgent data]&n; *&n; * TCP Options (4.2.2.5)&n; *   MUST be able to receive TCP options in any segment. (does)&n; *   MUST ignore unsupported options (does)&n; *&n; * Maximum Segment Size Option (4.2.2.6)&n; *   MUST implement both sending and receiving MSS. (does, but currently&n; *&t;only uses the smaller of both of them)&n; *   SHOULD send an MSS with every SYN where receive MSS != 536 (MAY send&n; *     it always). (does, even when MSS == 536, which is legal)&n; *   MUST assume MSS == 536 if no MSS received at connection setup (does)&n; *   MUST calculate &quot;effective send MSS&quot; correctly:&n; *     min(physical_MTU, remote_MSS+20) - sizeof(tcphdr) - sizeof(ipopts)&n; *     (does - but allows operator override)&n; *&n; * TCP Checksum (4.2.2.7)&n; *   MUST generate and check TCP checksum. (does)&n; *&n; * Initial Sequence Number Selection (4.2.2.8)&n; *   MUST use the RFC 793 clock selection mechanism.  (doesn&squot;t, but it&squot;s&n; *     OK: RFC 793 specifies a 250KHz clock, while we use 1MHz, which is&n; *     necessary for 10Mbps networks - and harder than BSD to spoof!&n; *     With syncookies we don&squot;t)&n; *&n; * Simultaneous Open Attempts (4.2.2.10)&n; *   MUST support simultaneous open attempts (does)&n; *&n; * Recovery from Old Duplicate SYN (4.2.2.11)&n; *   MUST keep track of active vs. passive open (does)&n; *&n; * RST segment (4.2.2.12)&n; *   SHOULD allow an RST segment to contain data (does, but doesn&squot;t do&n; *     anything with it, which is standard)&n; *&n; * Closing a Connection (4.2.2.13)&n; *   MUST inform application of whether connection was closed by RST or&n; *     normal close. (does)&n; *   MAY allow &quot;half-duplex&quot; close (treat connection as closed for the&n; *     local app, even before handshake is done). (does)&n; *   MUST linger in TIME_WAIT for 2 * MSL (does)&n; *&n; * Retransmission Timeout (4.2.2.15)&n; *   MUST implement Jacobson&squot;s slow start and congestion avoidance&n; *     stuff. (does)&n; *&n; * Probing Zero Windows (4.2.2.17)&n; *   MUST support probing of zero windows. (does)&n; *   MAY keep offered window closed indefinitely. (does)&n; *   MUST allow remote window to stay closed indefinitely. (does)&n; *&n; * Passive Open Calls (4.2.2.18)&n; *   MUST NOT let new passive open affect other connections. (doesn&squot;t)&n; *   MUST support passive opens (LISTENs) concurrently. (does)&n; *&n; * Time to Live (4.2.2.19)&n; *   MUST make TCP TTL configurable. (does - IP_TTL option)&n; *&n; * Event Processing (4.2.2.20)&n; *   SHOULD queue out-of-order segments. (does)&n; *   MUST aggregate ACK segments whenever possible. (does but badly)&n; *&n; * Retransmission Timeout Calculation (4.2.3.1)&n; *   MUST implement Karn&squot;s algorithm and Jacobson&squot;s algorithm for RTO&n; *     calculation. (does, or at least explains them in the comments 8*b)&n; *  SHOULD initialize RTO to 0 and RTT to 3. (does)&n; *&n; * When to Send an ACK Segment (4.2.3.2)&n; *   SHOULD implement delayed ACK. (does)&n; *   MUST keep ACK delay &lt; 0.5 sec. (does)&n; *&n; * When to Send a Window Update (4.2.3.3)&n; *   MUST implement receiver-side SWS. (does)&n; *&n; * When to Send Data (4.2.3.4)&n; *   MUST implement sender-side SWS. (does)&n; *   SHOULD implement Nagle algorithm. (does)&n; *&n; * TCP Connection Failures (4.2.3.5)&n; *  MUST handle excessive retransmissions &quot;properly&quot; (see the RFC). (does)&n; *   SHOULD inform application layer of soft errors. (does)&n; *&n; * TCP Keep-Alives (4.2.3.6)&n; *   MAY provide keep-alives. (does)&n; *   MUST make keep-alives configurable on a per-connection basis. (does)&n; *   MUST default to no keep-alives. (does)&n; *   MUST make keep-alive interval configurable. (does)&n; *   MUST make default keep-alive interval &gt; 2 hours. (does)&n; *   MUST NOT interpret failure to ACK keep-alive packet as dead&n; *     connection. (doesn&squot;t)&n; *   SHOULD send keep-alive with no data. (does)&n; *&n; * TCP Multihoming (4.2.3.7)&n; *   MUST get source address from IP layer before sending first&n; *     SYN. (does)&n; *   MUST use same local address for all segments of a connection. (does)&n; *&n; * IP Options (4.2.3.8)&n; *   MUST ignore unsupported IP options. (does)&n; *   MAY support Time Stamp and Record Route. (does)&n; *   MUST allow application to specify a source route. (does)&n; *   MUST allow received Source Route option to set route for all future&n; *     segments on this connection. (does not (security issues))&n; *&n; * ICMP messages (4.2.3.9)&n; *   MUST act on ICMP errors. (does)&n; *   MUST slow transmission upon receipt of a Source Quench. (doesn&squot;t anymore &n; *   because that is deprecated now by the IETF, can be turned on)&n; *   MUST NOT abort connection upon receipt of soft Destination&n; *     Unreachables (0, 1, 5), Time Exceededs and Parameter&n; *     Problems. (doesn&squot;t)&n; *   SHOULD report soft Destination Unreachables etc. to the&n; *     application. (does, except during SYN_RECV and may drop messages&n; *     in some rare cases before accept() - ICMP is unreliable)&t;&n; *   SHOULD abort connection upon receipt of hard Destination Unreachable&n; *     messages (2, 3, 4). (does, but see above)&n; *&n; * Remote Address Validation (4.2.3.10)&n; *   MUST reject as an error OPEN for invalid remote IP address. (does)&n; *   MUST ignore SYN with invalid source address. (does)&n; *   MUST silently discard incoming SYN for broadcast/multicast&n; *     address. (does)&n; *&n; * Asynchronous Reports (4.2.4.1)&n; * MUST provide mechanism for reporting soft errors to application&n; *     layer. (does)&n; *&n; * Type of Service (4.2.4.2)&n; *   MUST allow application layer to set Type of Service. (does IP_TOS)&n; *&n; * (Whew. -- MS 950903)&n; * (Updated by AK, but not complete yet.)&n; **/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|variable|sysctl_tcp_fin_timeout
r_int
id|sysctl_tcp_fin_timeout
op_assign
id|TCP_FIN_TIMEOUT
suffix:semicolon
DECL|variable|tcp_statistics
r_struct
id|tcp_mib
id|tcp_statistics
(braket
id|NR_CPUS
op_star
l_int|2
)braket
suffix:semicolon
DECL|variable|tcp_openreq_cachep
id|kmem_cache_t
op_star
id|tcp_openreq_cachep
suffix:semicolon
DECL|variable|tcp_bucket_cachep
id|kmem_cache_t
op_star
id|tcp_bucket_cachep
suffix:semicolon
DECL|variable|tcp_timewait_cachep
id|kmem_cache_t
op_star
id|tcp_timewait_cachep
suffix:semicolon
DECL|variable|tcp_orphan_count
id|atomic_t
id|tcp_orphan_count
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|sysctl_tcp_mem
r_int
id|sysctl_tcp_mem
(braket
l_int|3
)braket
suffix:semicolon
DECL|variable|sysctl_tcp_wmem
r_int
id|sysctl_tcp_wmem
(braket
l_int|3
)braket
op_assign
(brace
l_int|4
op_star
l_int|1024
comma
l_int|16
op_star
l_int|1024
comma
l_int|128
op_star
l_int|1024
)brace
suffix:semicolon
DECL|variable|sysctl_tcp_rmem
r_int
id|sysctl_tcp_rmem
(braket
l_int|3
)braket
op_assign
(brace
l_int|4
op_star
l_int|1024
comma
l_int|87380
comma
l_int|87380
op_star
l_int|2
)brace
suffix:semicolon
DECL|variable|tcp_memory_allocated
id|atomic_t
id|tcp_memory_allocated
suffix:semicolon
multiline_comment|/* Current allocated memory. */
DECL|variable|tcp_sockets_allocated
id|atomic_t
id|tcp_sockets_allocated
suffix:semicolon
multiline_comment|/* Current number of TCP sockets. */
multiline_comment|/* Pressure flag: try to collapse.&n; * Technical note: it is used by multiple contexts non atomically.&n; * All the tcp_mem_schedule() is of this nature: accounting&n; * is strict, actions are advisory and have some latency. */
DECL|variable|tcp_memory_pressure
r_int
id|tcp_memory_pressure
suffix:semicolon
DECL|macro|TCP_PAGES
mdefine_line|#define TCP_PAGES(amt) (((amt)+TCP_MEM_QUANTUM-1)/TCP_MEM_QUANTUM)
DECL|function|tcp_mem_schedule
r_int
id|tcp_mem_schedule
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|size
comma
r_int
id|kind
)paren
(brace
r_int
id|amt
op_assign
id|TCP_PAGES
c_func
(paren
id|size
)paren
suffix:semicolon
id|sk-&gt;forward_alloc
op_add_assign
id|amt
op_star
id|TCP_MEM_QUANTUM
suffix:semicolon
id|atomic_add
c_func
(paren
id|amt
comma
op_amp
id|tcp_memory_allocated
)paren
suffix:semicolon
multiline_comment|/* Under limit. */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|tcp_memory_allocated
)paren
OL
id|sysctl_tcp_mem
(braket
l_int|0
)braket
)paren
(brace
r_if
c_cond
(paren
id|tcp_memory_pressure
)paren
id|tcp_memory_pressure
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Over hard limit. */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|tcp_memory_allocated
)paren
OG
id|sysctl_tcp_mem
(braket
l_int|2
)braket
)paren
(brace
id|tcp_enter_memory_pressure
c_func
(paren
)paren
suffix:semicolon
r_goto
id|suppress_allocation
suffix:semicolon
)brace
multiline_comment|/* Under pressure. */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|tcp_memory_allocated
)paren
OG
id|sysctl_tcp_mem
(braket
l_int|1
)braket
)paren
id|tcp_enter_memory_pressure
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kind
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
OL
id|sysctl_tcp_rmem
(braket
l_int|0
)braket
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk-&gt;wmem_queued
OL
id|sysctl_tcp_wmem
(braket
l_int|0
)braket
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tcp_memory_pressure
op_logical_or
id|sysctl_tcp_mem
(braket
l_int|2
)braket
OG
id|atomic_read
c_func
(paren
op_amp
id|tcp_sockets_allocated
)paren
op_star
id|TCP_PAGES
c_func
(paren
id|sk-&gt;wmem_queued
op_plus
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
op_plus
id|sk-&gt;forward_alloc
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|suppress_allocation
suffix:colon
r_if
c_cond
(paren
id|kind
op_eq
l_int|0
)paren
(brace
id|tcp_moderate_sndbuf
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Fail only if socket is _under_ its sndbuf.&n;&t;&t; * In this case we cannot block, so that we have to fail.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;wmem_queued
op_plus
id|size
op_ge
id|sk-&gt;sndbuf
)paren
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Alas. Undo changes. */
id|sk-&gt;forward_alloc
op_sub_assign
id|amt
op_star
id|TCP_MEM_QUANTUM
suffix:semicolon
id|atomic_sub
c_func
(paren
id|amt
comma
op_amp
id|tcp_memory_allocated
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__tcp_mem_reclaim
r_void
id|__tcp_mem_reclaim
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;forward_alloc
op_ge
id|TCP_MEM_QUANTUM
)paren
(brace
id|atomic_sub
c_func
(paren
id|sk-&gt;forward_alloc
op_div
id|TCP_MEM_QUANTUM
comma
op_amp
id|tcp_memory_allocated
)paren
suffix:semicolon
id|sk-&gt;forward_alloc
op_and_assign
(paren
id|TCP_MEM_QUANTUM
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_memory_pressure
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|tcp_memory_allocated
)paren
OL
id|sysctl_tcp_mem
(braket
l_int|0
)braket
)paren
id|tcp_memory_pressure
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|tcp_rfree
r_void
id|tcp_rfree
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|skb-&gt;sk
suffix:semicolon
id|atomic_sub
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;rmem_alloc
)paren
suffix:semicolon
id|sk-&gt;forward_alloc
op_add_assign
id|skb-&gt;truesize
suffix:semicolon
)brace
multiline_comment|/*&n; * LISTEN is a special case for poll..&n; */
DECL|function|tcp_listen_poll
r_static
id|__inline__
r_int
r_int
id|tcp_listen_poll
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_return
id|sk-&gt;tp_pinfo.af_tcp.accept_queue
ques
c_cond
(paren
id|POLLIN
op_or
id|POLLRDNORM
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Wait for a TCP event.&n; *&n; *&t;Note that we don&squot;t need to lock the socket, as the upper poll layers&n; *&t;take care of normal races (between the test and the event) and we don&squot;t&n; *&t;go look at any of the socket buffers directly.&n; */
DECL|function|tcp_poll
r_int
r_int
id|tcp_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|socket
op_star
id|sock
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
id|sk-&gt;sleep
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
id|tcp_listen_poll
c_func
(paren
id|sk
comma
id|wait
)paren
suffix:semicolon
multiline_comment|/* Socket is not locked. We are protected from async events&n;&t;   by poll logic and correct handling of state changes&n;&t;   made by another threads is impossible in any case.&n;&t; */
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
id|mask
op_assign
id|POLLERR
suffix:semicolon
multiline_comment|/*&n;&t; * POLLHUP is certainly not done right. But poll() doesn&squot;t&n;&t; * have a notion of HUP in just one direction, and for a&n;&t; * socket the read side is more interesting.&n;&t; *&n;&t; * Some poll() documentation says that POLLHUP is incompatible&n;&t; * with the POLLOUT/POLLWR flags, so somebody should check this&n;&t; * all. But careful, it tends to be safer to return too many&n;&t; * bits than too few, and you can easily break real applications&n;&t; * if you don&squot;t tell them that something has hung up!&n;&t; *&n;&t; * Check-me.&n;&t; *&n;&t; * Check number 1. POLLHUP is _UNMASKABLE_ event (see UNIX98 and&n;&t; * our fs/select.c). It means that after we received EOF,&n;&t; * poll always returns immediately, making impossible poll() on write()&n;&t; * in state CLOSE_WAIT. One solution is evident --- to set POLLHUP&n;&t; * if and only if shutdown has been made in both directions.&n;&t; * Actually, it is interesting to look how Solaris and DUX&n;&t; * solve this dilemma. I would prefer, if PULLHUP were maskable,&n;&t; * then we could set it on SND_SHUTDOWN. BTW examples given&n;&t; * in Stevens&squot; books assume exactly this behaviour, it explains&n;&t; * why PULLHUP is incompatible with POLLOUT.&t;--ANK&n;&t; *&n;&t; * NOTE. Check for TCP_CLOSE is added. The goal is to prevent&n;&t; * blocking on fresh not-connected or disconnected socket. --ANK&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_eq
id|SHUTDOWN_MASK
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
multiline_comment|/* Connected? */
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|sk-&gt;state
)paren
op_amp
op_complement
(paren
id|TCPF_SYN_SENT
op_or
id|TCPF_SYN_RECV
)paren
)paren
(brace
multiline_comment|/* Potential race condition. If read of tp below will&n;&t;&t; * escape above sk-&gt;state, we can be illegally awaken&n;&t;&t; * in SYN_* states. */
r_if
c_cond
(paren
(paren
id|tp-&gt;rcv_nxt
op_ne
id|tp-&gt;copied_seq
)paren
op_logical_and
(paren
id|tp-&gt;urg_seq
op_ne
id|tp-&gt;copied_seq
op_logical_or
id|tp-&gt;rcv_nxt
op_ne
id|tp-&gt;copied_seq
op_plus
l_int|1
op_logical_or
id|sk-&gt;urginline
op_logical_or
op_logical_neg
id|tp-&gt;urg_data
)paren
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
)paren
(brace
r_if
c_cond
(paren
id|tcp_wspace
c_func
(paren
id|sk
)paren
op_ge
id|tcp_min_write_space
c_func
(paren
id|sk
)paren
)paren
(brace
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* send SIGIO later */
id|set_bit
c_func
(paren
id|SOCK_ASYNC_NOSPACE
comma
op_amp
id|sk-&gt;socket-&gt;flags
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|SOCK_NOSPACE
comma
op_amp
id|sk-&gt;socket-&gt;flags
)paren
suffix:semicolon
multiline_comment|/* Race breaker. If space is freed after&n;&t;&t;&t;&t; * wspace test but before the flags are set,&n;&t;&t;&t;&t; * IO signal will be lost.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|tcp_wspace
c_func
(paren
id|sk
)paren
op_ge
id|tcp_min_write_space
c_func
(paren
id|sk
)paren
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tp-&gt;urg_data
op_amp
id|TCP_URG_VALID
)paren
id|mask
op_or_assign
id|POLLPRI
suffix:semicolon
)brace
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;TCP socket write_space callback. Not used.&n; */
DECL|function|tcp_write_space
r_void
id|tcp_write_space
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
)brace
DECL|function|tcp_ioctl
r_int
id|tcp_ioctl
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|answ
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCINQ
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|sk-&gt;state
)paren
op_amp
(paren
id|TCPF_SYN_SENT
op_or
id|TCPF_SYN_RECV
)paren
)paren
id|answ
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sk-&gt;urginline
op_logical_or
op_logical_neg
id|tp-&gt;urg_data
op_logical_or
id|before
c_func
(paren
id|tp-&gt;urg_seq
comma
id|tp-&gt;copied_seq
)paren
op_logical_or
op_logical_neg
id|before
c_func
(paren
id|tp-&gt;urg_seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
id|answ
op_assign
id|tp-&gt;rcv_nxt
op_minus
id|tp-&gt;copied_seq
suffix:semicolon
multiline_comment|/* Subtract 1, if FIN is in queue. */
r_if
c_cond
(paren
id|answ
op_logical_and
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
id|answ
op_sub_assign
(paren
(paren
r_struct
id|sk_buff
op_star
)paren
id|sk-&gt;receive_queue.prev
)paren
op_member_access_from_pointer
id|h.th-&gt;fin
suffix:semicolon
)brace
r_else
id|answ
op_assign
id|tp-&gt;urg_seq
op_minus
id|tp-&gt;copied_seq
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCATMARK
suffix:colon
(brace
id|answ
op_assign
id|tp-&gt;urg_data
op_logical_and
id|tp-&gt;urg_seq
op_eq
id|tp-&gt;copied_seq
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|SIOCOUTQ
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|sk-&gt;state
)paren
op_amp
(paren
id|TCPF_SYN_SENT
op_or
id|TCPF_SYN_RECV
)paren
)paren
id|answ
op_assign
l_int|0
suffix:semicolon
r_else
id|answ
op_assign
id|tp-&gt;write_seq
op_minus
id|tp-&gt;snd_una
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|answ
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
DECL|function|tcp_listen_start
r_int
id|tcp_listen_start
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|tcp_listen_opt
op_star
id|lopt
suffix:semicolon
id|sk-&gt;max_ack_backlog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;accept_queue
op_assign
id|tp-&gt;accept_queue_tail
op_assign
l_int|NULL
suffix:semicolon
id|tp-&gt;syn_wait_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
id|lopt
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|tcp_listen_opt
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lopt
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|lopt
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tcp_listen_opt
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|lopt-&gt;max_qlen_log
op_assign
l_int|6
suffix:semicolon
suffix:semicolon
id|lopt-&gt;max_qlen_log
op_increment
)paren
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|lopt-&gt;max_qlen_log
)paren
op_ge
id|sysctl_max_syn_backlog
)paren
r_break
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|tp-&gt;syn_wait_lock
)paren
suffix:semicolon
id|tp-&gt;listen_opt
op_assign
id|lopt
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|tp-&gt;syn_wait_lock
)paren
suffix:semicolon
multiline_comment|/* There is race window here: we announce ourselves listening,&n;&t; * but this transition is still not validated by get_port().&n;&t; * It is OK, because this socket enters to hash table only&n;&t; * after validation is complete.&n;&t; */
id|sk-&gt;state
op_assign
id|TCP_LISTEN
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;prot
op_member_access_from_pointer
id|get_port
c_func
(paren
id|sk
comma
id|sk-&gt;num
)paren
op_eq
l_int|0
)paren
(brace
id|sk-&gt;sport
op_assign
id|htons
c_func
(paren
id|sk-&gt;num
)paren
suffix:semicolon
id|sk_dst_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|hash
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|tp-&gt;syn_wait_lock
)paren
suffix:semicolon
id|tp-&gt;listen_opt
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|tp-&gt;syn_wait_lock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lopt
)paren
suffix:semicolon
r_return
op_minus
id|EADDRINUSE
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine closes sockets which have been at least partially&n; *&t;opened, but not yet accepted.&n; */
DECL|function|tcp_listen_stop
r_static
r_void
id|tcp_listen_stop
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|tcp_listen_opt
op_star
id|lopt
op_assign
id|tp-&gt;listen_opt
suffix:semicolon
r_struct
id|open_request
op_star
id|acc_req
op_assign
id|tp-&gt;accept_queue
suffix:semicolon
r_struct
id|open_request
op_star
id|req
suffix:semicolon
r_int
id|i
suffix:semicolon
id|tcp_delete_keepalive_timer
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* make all the listen_opt local to us */
id|write_lock_bh
c_func
(paren
op_amp
id|tp-&gt;syn_wait_lock
)paren
suffix:semicolon
id|tp-&gt;listen_opt
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|tp-&gt;syn_wait_lock
)paren
suffix:semicolon
id|tp-&gt;accept_queue
op_assign
id|tp-&gt;accept_queue_tail
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|lopt-&gt;qlen
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TCP_SYNQ_HSIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_while
c_loop
(paren
(paren
id|req
op_assign
id|lopt-&gt;syn_table
(braket
id|i
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|lopt-&gt;syn_table
(braket
id|i
)braket
op_assign
id|req-&gt;dl_next
suffix:semicolon
id|lopt-&gt;qlen
op_decrement
suffix:semicolon
id|tcp_openreq_free
c_func
(paren
id|req
)paren
suffix:semicolon
multiline_comment|/* Following specs, it would be better either to send FIN&n;&t;&t; * (and enter FIN-WAIT-1, it is normal close)&n;&t;&t; * or to send active reset (abort). &n;&t;&t; * Certainly, it is pretty dangerous while synflood, but it is&n;&t;&t; * bad justification for our negligence 8)&n;&t;&t; * To be honest, we are not able to make either&n;&t;&t; * of the variants now.&t;&t;&t;--ANK&n;&t;&t; */
)brace
)brace
)brace
id|BUG_TRAP
c_func
(paren
id|lopt-&gt;qlen
op_eq
l_int|0
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lopt
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|req
op_assign
id|acc_req
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|sock
op_star
id|child
op_assign
id|req-&gt;sk
suffix:semicolon
id|acc_req
op_assign
id|req-&gt;dl_next
suffix:semicolon
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
id|bh_lock_sock
c_func
(paren
id|child
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|child-&gt;lock.users
op_eq
l_int|0
)paren
suffix:semicolon
id|sock_hold
c_func
(paren
id|child
)paren
suffix:semicolon
id|tcp_disconnect
c_func
(paren
id|child
comma
id|O_NONBLOCK
)paren
suffix:semicolon
id|sock_orphan
c_func
(paren
id|child
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|tcp_orphan_count
)paren
suffix:semicolon
id|tcp_destroy_sock
c_func
(paren
id|child
)paren
suffix:semicolon
id|bh_unlock_sock
c_func
(paren
id|child
)paren
suffix:semicolon
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|child
)paren
suffix:semicolon
id|tcp_acceptq_removed
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_openreq_fastfree
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
id|BUG_TRAP
c_func
(paren
id|sk-&gt;ack_backlog
op_eq
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Wait for a socket to get into the connected state&n; *&n; *&t;Note: Must be called with the socket locked.&n; */
DECL|function|wait_for_tcp_connect
r_static
r_int
id|wait_for_tcp_connect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
comma
r_int
op_star
id|timeo_p
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
l_int|1
op_lshift
id|sk-&gt;state
)paren
op_amp
op_complement
(paren
id|TCPF_ESTABLISHED
op_or
id|TCPF_CLOSE_WAIT
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;err
)paren
(brace
r_return
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|sk-&gt;state
)paren
op_amp
op_complement
(paren
id|TCPF_SYN_SENT
op_or
id|TCPF_SYN_RECV
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;keepopen
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|MSG_NOSIGNAL
)paren
)paren
(brace
id|send_sig
c_func
(paren
id|SIGPIPE
comma
id|tsk
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|timeo_p
)paren
(brace
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|tsk
)paren
)paren
(brace
r_return
id|sock_intr_errno
c_func
(paren
op_star
id|timeo_p
)paren
suffix:semicolon
)brace
id|__set_task_state
c_func
(paren
id|tsk
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
id|sk-&gt;tp_pinfo.af_tcp.write_pending
op_increment
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
op_star
id|timeo_p
op_assign
id|schedule_timeout
c_func
(paren
op_star
id|timeo_p
)paren
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|__set_task_state
c_func
(paren
id|tsk
comma
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
id|sk-&gt;tp_pinfo.af_tcp.write_pending
op_decrement
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tcp_memory_free
r_static
r_inline
r_int
id|tcp_memory_free
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|sk-&gt;wmem_queued
OL
id|sk-&gt;sndbuf
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Wait for more memory for a socket&n; */
DECL|function|wait_for_tcp_memory
r_static
r_int
id|wait_for_tcp_memory
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeo
)paren
(brace
r_int
id|vm_wait
op_assign
l_int|0
suffix:semicolon
r_int
id|current_timeo
op_assign
id|timeo
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_memory_free
c_func
(paren
id|sk
)paren
)paren
id|current_timeo
op_assign
id|vm_wait
op_assign
(paren
id|net_random
c_func
(paren
)paren
op_mod
(paren
id|HZ
op_div
l_int|5
)paren
)paren
op_plus
l_int|2
suffix:semicolon
id|clear_bit
c_func
(paren
id|SOCK_ASYNC_NOSPACE
comma
op_amp
id|sk-&gt;socket-&gt;flags
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|set_bit
c_func
(paren
id|SOCK_NOSPACE
comma
op_amp
id|sk-&gt;socket-&gt;flags
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|tcp_memory_free
c_func
(paren
id|sk
)paren
op_logical_and
op_logical_neg
id|vm_wait
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
r_break
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_memory_free
c_func
(paren
id|sk
)paren
op_logical_or
id|vm_wait
)paren
id|current_timeo
op_assign
id|schedule_timeout
c_func
(paren
id|current_timeo
)paren
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vm_wait
)paren
(brace
r_if
c_cond
(paren
id|timeo
op_ne
id|MAX_SCHEDULE_TIMEOUT
op_logical_and
(paren
id|timeo
op_sub_assign
id|vm_wait
op_minus
id|current_timeo
)paren
OL
l_int|0
)paren
id|timeo
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|timeo
op_assign
id|current_timeo
suffix:semicolon
)brace
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|timeo
suffix:semicolon
)brace
multiline_comment|/* When all user supplied data has been queued set the PSH bit */
DECL|macro|PSH_NEEDED
mdefine_line|#define PSH_NEEDED (seglen == 0 &amp;&amp; iovlen == 0)
multiline_comment|/*&n; *&t;This routine copies from a user buffer into a socket,&n; *&t;and starts the transmit system.&n; */
DECL|function|tcp_sendmsg
r_int
id|tcp_sendmsg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|size
)paren
(brace
r_struct
id|iovec
op_star
id|iov
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|iovlen
comma
id|flags
suffix:semicolon
r_int
id|mss_now
suffix:semicolon
r_int
id|err
comma
id|copied
suffix:semicolon
r_int
id|timeo
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|TCP_CHECK_TIMER
c_func
(paren
id|sk
)paren
suffix:semicolon
id|flags
op_assign
id|msg-&gt;msg_flags
suffix:semicolon
id|timeo
op_assign
id|sock_sndtimeo
c_func
(paren
id|sk
comma
id|flags
op_amp
id|MSG_DONTWAIT
)paren
suffix:semicolon
multiline_comment|/* Wait for a connection to finish. */
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|sk-&gt;state
)paren
op_amp
op_complement
(paren
id|TCPF_ESTABLISHED
op_or
id|TCPF_CLOSE_WAIT
)paren
)paren
r_if
c_cond
(paren
(paren
id|err
op_assign
id|wait_for_tcp_connect
c_func
(paren
id|sk
comma
id|flags
comma
op_amp
id|timeo
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* This should be in poll */
id|clear_bit
c_func
(paren
id|SOCK_ASYNC_NOSPACE
comma
op_amp
id|sk-&gt;socket-&gt;flags
)paren
suffix:semicolon
id|mss_now
op_assign
id|tcp_current_mss
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Ok commence sending. */
id|iovlen
op_assign
id|msg-&gt;msg_iovlen
suffix:semicolon
id|iov
op_assign
id|msg-&gt;msg_iov
suffix:semicolon
id|copied
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|iovlen
op_ge
l_int|0
)paren
(brace
r_int
id|seglen
op_assign
id|iov-&gt;iov_len
suffix:semicolon
r_int
r_char
op_star
id|from
op_assign
id|iov-&gt;iov_base
suffix:semicolon
id|iov
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|seglen
OG
l_int|0
)paren
(brace
r_int
id|copy
comma
id|tmp
comma
id|queue_it
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|do_fault2
suffix:semicolon
multiline_comment|/* Stop on errors. */
r_if
c_cond
(paren
id|sk-&gt;err
)paren
r_goto
id|do_sock_err
suffix:semicolon
multiline_comment|/* Make sure that we are established. */
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
r_goto
id|do_shutdown
suffix:semicolon
multiline_comment|/* Now we need to check if we have a half&n;&t;&t;&t; * built packet we can tack some data onto.&n;&t;&t;&t; */
id|skb
op_assign
id|sk-&gt;write_queue.prev
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;send_head
op_logical_and
(paren
id|mss_now
op_minus
id|skb-&gt;len
)paren
OG
l_int|0
)paren
(brace
id|copy
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|skb_tailroom
c_func
(paren
id|skb
)paren
OG
l_int|0
)paren
(brace
r_int
id|last_byte_was_odd
op_assign
(paren
id|copy
op_mod
l_int|4
)paren
suffix:semicolon
id|copy
op_assign
id|mss_now
op_minus
id|copy
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|skb_tailroom
c_func
(paren
id|skb
)paren
)paren
(brace
id|copy
op_assign
id|skb_tailroom
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy
OG
id|seglen
)paren
(brace
id|copy
op_assign
id|seglen
suffix:semicolon
)brace
r_if
c_cond
(paren
id|last_byte_was_odd
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|copy
)paren
comma
id|from
comma
id|copy
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
id|skb-&gt;csum
op_assign
id|csum_partial
c_func
(paren
id|skb-&gt;data
comma
id|skb-&gt;len
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;csum
op_assign
id|csum_and_copy_from_user
c_func
(paren
id|from
comma
id|skb_put
c_func
(paren
id|skb
comma
id|copy
)paren
comma
id|copy
comma
id|skb-&gt;csum
comma
op_amp
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * FIXME: the *_user functions should&n;&t;&t;&t;&t;&t; *&t;  return how much data was&n;&t;&t;&t;&t;&t; *&t;  copied before the fault&n;&t;&t;&t;&t;&t; *&t;  occurred and then a partial&n;&t;&t;&t;&t;&t; *&t;  packet with this data should&n;&t;&t;&t;&t;&t; *&t;  be sent.  Unfortunately&n;&t;&t;&t;&t;&t; *&t;  csum_and_copy_from_user doesn&squot;t&n;&t;&t;&t;&t;&t; *&t;  return this information.&n;&t;&t;&t;&t;&t; *&t;  ATM it might send partly zeroed&n;&t;&t;&t;&t;&t; *&t;  data in this case.&n;&t;&t;&t;&t;&t; */
id|tp-&gt;write_seq
op_add_assign
id|copy
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_add_assign
id|copy
suffix:semicolon
id|from
op_add_assign
id|copy
suffix:semicolon
id|copied
op_add_assign
id|copy
suffix:semicolon
id|seglen
op_sub_assign
id|copy
suffix:semicolon
r_if
c_cond
(paren
id|PSH_NEEDED
op_logical_or
id|after
c_func
(paren
id|tp-&gt;write_seq
comma
id|tp-&gt;pushed_seq
op_plus
(paren
id|tp-&gt;max_window
op_rshift
l_int|1
)paren
)paren
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_or_assign
id|TCPCB_FLAG_PSH
suffix:semicolon
id|tp-&gt;pushed_seq
op_assign
id|tp-&gt;write_seq
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_OOB
)paren
(brace
id|tp-&gt;urg_mode
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;snd_up
op_assign
id|tp-&gt;write_seq
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_or_assign
id|TCPCB_URG
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_else
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_or_assign
id|TCPCB_FLAG_PSH
suffix:semicolon
id|tp-&gt;pushed_seq
op_assign
id|tp-&gt;write_seq
suffix:semicolon
)brace
)brace
id|copy
op_assign
id|min
c_func
(paren
id|seglen
comma
id|mss_now
)paren
suffix:semicolon
multiline_comment|/* Determine how large of a buffer to allocate.  */
id|tmp
op_assign
id|MAX_TCP_HEADER
op_plus
l_int|15
op_plus
id|tp-&gt;mss_cache
suffix:semicolon
r_if
c_cond
(paren
id|copy
OL
id|mss_now
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|MSG_OOB
)paren
)paren
(brace
multiline_comment|/* What is happening here is that we want to&n;&t;&t;&t;&t; * tack on later members of the users iovec&n;&t;&t;&t;&t; * if possible into a single frame.  When we&n;&t;&t;&t;&t; * leave this loop our we check to see if&n;&t;&t;&t;&t; * we can send queued frames onto the wire.&n;&t;&t;&t;&t; */
id|queue_it
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|queue_it
op_assign
l_int|0
suffix:semicolon
)brace
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tcp_memory_free
c_func
(paren
id|sk
)paren
)paren
id|skb
op_assign
id|tcp_alloc_skb
c_func
(paren
id|sk
comma
id|tmp
comma
id|sk-&gt;allocation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* If we didn&squot;t get any memory, we need to sleep. */
id|set_bit
c_func
(paren
id|SOCK_ASYNC_NOSPACE
comma
op_amp
id|sk-&gt;socket-&gt;flags
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|SOCK_NOSPACE
comma
op_amp
id|sk-&gt;socket-&gt;flags
)paren
suffix:semicolon
id|__tcp_push_pending_frames
c_func
(paren
id|sk
comma
id|tp
comma
id|mss_now
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timeo
)paren
(brace
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|do_interrupted
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|err
op_assign
id|sock_intr_errno
c_func
(paren
id|timeo
)paren
suffix:semicolon
r_goto
id|do_interrupted
suffix:semicolon
)brace
id|timeo
op_assign
id|wait_for_tcp_memory
c_func
(paren
id|sk
comma
id|timeo
)paren
suffix:semicolon
multiline_comment|/* If SACK&squot;s were formed or PMTU events happened,&n;&t;&t;&t;&t; * we must find out about it.&n;&t;&t;&t;&t; */
id|mss_now
op_assign
id|tcp_current_mss
c_func
(paren
id|sk
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|seglen
op_sub_assign
id|copy
suffix:semicolon
multiline_comment|/* Prepare control bits for TCP header creation engine. */
r_if
c_cond
(paren
id|PSH_NEEDED
op_logical_or
id|after
c_func
(paren
id|tp-&gt;write_seq
op_plus
id|copy
comma
id|tp-&gt;pushed_seq
op_plus
(paren
id|tp-&gt;max_window
op_rshift
l_int|1
)paren
)paren
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_assign
id|TCPCB_FLAG_ACK
op_or
id|TCPCB_FLAG_PSH
suffix:semicolon
id|tp-&gt;pushed_seq
op_assign
id|tp-&gt;write_seq
op_plus
id|copy
suffix:semicolon
)brace
r_else
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_assign
id|TCPCB_FLAG_ACK
suffix:semicolon
)brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_OOB
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_or_assign
id|TCPCB_URG
suffix:semicolon
id|tp-&gt;urg_mode
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;snd_up
op_assign
id|tp-&gt;write_seq
op_plus
id|copy
suffix:semicolon
)brace
multiline_comment|/* TCP data bytes are SKB_PUT() on top, later&n;&t;&t;&t; * TCP+IP+DEV headers are SKB_PUSH()&squot;d beneath.&n;&t;&t;&t; * Reserve header space and checksum the data.&n;&t;&t;&t; */
id|skb_reserve
c_func
(paren
id|skb
comma
id|MAX_TCP_HEADER
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
id|csum_and_copy_from_user
c_func
(paren
id|from
comma
id|skb_put
c_func
(paren
id|skb
comma
id|copy
)paren
comma
id|copy
comma
l_int|0
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|do_fault
suffix:semicolon
id|from
op_add_assign
id|copy
suffix:semicolon
id|copied
op_add_assign
id|copy
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_assign
id|tp-&gt;write_seq
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_plus
id|copy
suffix:semicolon
multiline_comment|/* This advances tp-&gt;write_seq for us. */
id|tcp_send_skb
c_func
(paren
id|sk
comma
id|skb
comma
id|queue_it
comma
id|mss_now
)paren
suffix:semicolon
)brace
)brace
id|err
op_assign
id|copied
suffix:semicolon
id|out
suffix:colon
id|__tcp_push_pending_frames
c_func
(paren
id|sk
comma
id|tp
comma
id|mss_now
comma
id|tp-&gt;nonagle
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|TCP_CHECK_TIMER
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|do_sock_err
suffix:colon
r_if
c_cond
(paren
id|copied
)paren
id|err
op_assign
id|copied
suffix:semicolon
r_else
id|err
op_assign
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|do_shutdown
suffix:colon
r_if
c_cond
(paren
id|copied
)paren
id|err
op_assign
id|copied
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_NOSIGNAL
)paren
)paren
id|send_sig
c_func
(paren
id|SIGPIPE
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EPIPE
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
id|do_interrupted
suffix:colon
r_if
c_cond
(paren
id|copied
)paren
id|err
op_assign
id|copied
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
id|do_fault
suffix:colon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|do_fault2
suffix:colon
r_if
c_cond
(paren
id|copied
)paren
id|err
op_assign
id|copied
suffix:semicolon
r_else
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|macro|PSH_NEEDED
macro_line|#undef PSH_NEEDED
multiline_comment|/*&n; *&t;Handle reading urgent data. BSD has very simple semantics for&n; *&t;this, no blocking and very strange errors 8)&n; */
DECL|function|tcp_recv_urg
r_static
r_int
id|tcp_recv_urg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeo
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_int
id|flags
comma
r_int
op_star
id|addr_len
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/* No URG data to read. */
r_if
c_cond
(paren
id|sk-&gt;urginline
op_logical_or
op_logical_neg
id|tp-&gt;urg_data
op_logical_or
id|tp-&gt;urg_data
op_eq
id|TCP_URG_READ
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Yes this is right ! */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
op_logical_and
op_logical_neg
id|sk-&gt;done
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;urg_data
op_amp
id|TCP_URG_VALID
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_char
id|c
op_assign
id|tp-&gt;urg_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
)paren
id|tp-&gt;urg_data
op_assign
id|TCP_URG_READ
suffix:semicolon
multiline_comment|/* Read urgent data. */
id|msg-&gt;msg_flags
op_or_assign
id|MSG_OOB
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
)paren
id|err
op_assign
id|memcpy_toiovec
c_func
(paren
id|msg-&gt;msg_iov
comma
op_amp
id|c
comma
l_int|1
)paren
suffix:semicolon
id|len
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|msg-&gt;msg_flags
op_or_assign
id|MSG_TRUNC
suffix:semicolon
r_return
id|err
ques
c_cond
op_minus
id|EFAULT
suffix:colon
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
op_logical_or
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Fixed the recv(..., MSG_OOB) behaviour.  BSD docs and&n;&t; * the available implementations agree in this case:&n;&t; * this call should never block, independent of the&n;&t; * blocking state of the socket.&n;&t; * Mike &lt;pall@rz.uni-karlsruhe.de&gt;&n;&t; */
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Release a skb if it is no longer needed. This routine&n; *&t;must be called with interrupts disabled or with the&n; *&t;socket locked so that the sk_buff queue operation is ok.&n; */
DECL|function|tcp_eat_skb
r_static
r_inline
r_void
id|tcp_eat_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|__skb_unlink
c_func
(paren
id|skb
comma
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* Clean up the receive buffer for full frames taken by the user,&n; * then send an ACK if necessary.  COPIED is the number of bytes&n; * tcp_recvmsg has given to the user so far, it speeds up the&n; * calculation of whether or not we must ACK for the sake of&n; * a window update.&n; */
DECL|function|cleanup_rbuf
r_static
r_void
id|cleanup_rbuf
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|copied
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|time_to_ack
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* NOTE! The socket must be locked, so that we don&squot;t get&n;&t; * a messed-up receive queue.&n;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;used
)paren
r_break
suffix:semicolon
id|tcp_eat_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tcp_ack_scheduled
c_func
(paren
id|tp
)paren
)paren
(brace
multiline_comment|/* Delayed ACKs frequently hit locked sockets during bulk receive. */
r_if
c_cond
(paren
id|tp-&gt;ack.blocked
multiline_comment|/* Once-per-two-segments ACK was not sent by tcp_input.c */
op_logical_or
id|tp-&gt;rcv_nxt
op_minus
id|tp-&gt;rcv_wup
OG
id|tp-&gt;ack.rcv_mss
multiline_comment|/*&n;&t;&t;     * If this read emptied read buffer, we send ACK, if&n;&t;&t;     * connection is not bidirectional, user drained&n;&t;&t;     * receive buffer and there was a small segment&n;&t;&t;     * in queue.&n;&t;&t;     */
op_logical_or
(paren
id|copied
OG
l_int|0
op_logical_and
(paren
id|tp-&gt;ack.pending
op_amp
id|TCP_ACK_PUSHED
)paren
op_logical_and
op_logical_neg
id|tp-&gt;ack.pingpong
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|time_to_ack
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* We send an ACK if we can now advertise a non-zero window&n;&t; * which has been raised &quot;significantly&quot;.&n;&t; *&n;&t; * Even if window raised up to infinity, do not send window open ACK&n;&t; * in states, where we will not receive more. It is useless.&n;  &t; */
r_if
c_cond
(paren
id|copied
OG
l_int|0
op_logical_and
op_logical_neg
id|time_to_ack
op_logical_and
op_logical_neg
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
)paren
(brace
id|__u32
id|rcv_window_now
op_assign
id|tcp_receive_window
c_func
(paren
id|tp
)paren
suffix:semicolon
multiline_comment|/* Optimize, __tcp_select_window() is not cheap. */
r_if
c_cond
(paren
l_int|2
op_star
id|rcv_window_now
op_le
id|tp-&gt;window_clamp
)paren
(brace
id|__u32
id|new_window
op_assign
id|__tcp_select_window
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Send ACK now, if this read freed lots of space&n;&t;&t;&t; * in our buffer. Certainly, new_window is new window.&n;&t;&t;&t; * We can advertise it now, if it is not less than current one.&n;&t;&t;&t; * &quot;Lots&quot; means &quot;at least twice&quot; here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|new_window
op_logical_and
id|new_window
op_ge
l_int|2
op_star
id|rcv_window_now
)paren
(brace
id|time_to_ack
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|time_to_ack
)paren
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* Now socket state including sk-&gt;err is changed only under lock,&n; * hence we may omit checks after joining wait queue.&n; * We check receive queue before schedule() only as optimization;&n; * it is very likely that release_sock() added new data.&n; */
DECL|function|tcp_data_wait
r_static
r_int
id|tcp_data_wait
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeo
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|SOCK_ASYNC_WAITDATA
comma
op_amp
id|sk-&gt;socket-&gt;flags
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
id|timeo
op_assign
id|schedule_timeout
c_func
(paren
id|timeo
)paren
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|SOCK_ASYNC_WAITDATA
comma
op_amp
id|sk-&gt;socket-&gt;flags
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_return
id|timeo
suffix:semicolon
)brace
DECL|function|tcp_prequeue_process
r_static
r_void
id|tcp_prequeue_process
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|net_statistics
(braket
id|smp_processor_id
c_func
(paren
)paren
op_star
l_int|2
op_plus
l_int|1
)braket
dot
id|TCPPrequeued
op_add_assign
id|skb_queue_len
c_func
(paren
op_amp
id|tp-&gt;ucopy.prequeue
)paren
suffix:semicolon
multiline_comment|/* RX process wants to run with disabled BHs, though it is not necessary */
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
op_amp
id|tp-&gt;ucopy.prequeue
)paren
)paren
op_ne
l_int|NULL
)paren
id|sk
op_member_access_from_pointer
id|backlog_rcv
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Clear memory counter. */
id|tp-&gt;ucopy.memory
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine copies from a sock struct into the user buffer. &n; *&n; *&t;Technical note: in 2.3 we work on _locked_ socket, so that&n; *&t;tricks with *seq access order and skb-&gt;users are not required.&n; *&t;Probably, code can be easily improved even more.&n; */
DECL|function|tcp_recvmsg
r_int
id|tcp_recvmsg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
comma
r_int
op_star
id|addr_len
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
id|u32
id|peek_seq
suffix:semicolon
id|u32
op_star
id|seq
suffix:semicolon
r_int
r_int
id|used
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|target
suffix:semicolon
multiline_comment|/* Read at least this many bytes */
r_int
id|timeo
suffix:semicolon
r_struct
id|task_struct
op_star
id|user_recv
op_assign
l_int|NULL
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|TCP_CHECK_TIMER
c_func
(paren
id|sk
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_goto
id|out
suffix:semicolon
id|timeo
op_assign
id|sock_rcvtimeo
c_func
(paren
id|sk
comma
id|nonblock
)paren
suffix:semicolon
multiline_comment|/* Urgent data needs to be handled specially. */
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_OOB
)paren
r_goto
id|recv_urg
suffix:semicolon
id|seq
op_assign
op_amp
id|tp-&gt;copied_seq
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
(brace
id|peek_seq
op_assign
id|tp-&gt;copied_seq
suffix:semicolon
id|seq
op_assign
op_amp
id|peek_seq
suffix:semicolon
)brace
id|target
op_assign
id|sock_rcvlowat
c_func
(paren
id|sk
comma
id|flags
op_amp
id|MSG_WAITALL
comma
id|len
)paren
suffix:semicolon
r_do
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|u32
id|offset
suffix:semicolon
multiline_comment|/* Are we at urgent data? Stop if we have read anything. */
r_if
c_cond
(paren
id|copied
op_logical_and
id|tp-&gt;urg_data
op_logical_and
id|tp-&gt;urg_seq
op_eq
op_star
id|seq
)paren
r_break
suffix:semicolon
multiline_comment|/* We need to check signals first, to get correct SIGURG&n;&t;&t; * handling. FIXME: Need to check this doesnt impact 1003.1g&n;&t;&t; * and move it down to the bottom of the loop&n;&t;&t; */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
id|copied
)paren
r_break
suffix:semicolon
id|copied
op_assign
id|timeo
ques
c_cond
id|sock_intr_errno
c_func
(paren
id|timeo
)paren
suffix:colon
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Next get a buffer. */
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_break
suffix:semicolon
multiline_comment|/* Now that we have two receive queues this &n;&t;&t;&t; * shouldn&squot;t happen.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|before
c_func
(paren
op_star
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;recvmsg bug: copied %X seq %X&bslash;n&quot;
comma
op_star
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|offset
op_assign
op_star
id|seq
op_minus
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;syn
)paren
id|offset
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
id|skb-&gt;len
)paren
r_goto
id|found_ok_skb
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;fin
)paren
r_goto
id|found_fin_ok
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
)paren
id|skb-&gt;used
op_assign
l_int|1
suffix:semicolon
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
multiline_comment|/* Well, if we have backlog, try to process it now yet. */
r_if
c_cond
(paren
id|copied
op_ge
id|target
op_logical_and
id|sk-&gt;backlog.tail
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;err
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_CLOSE
op_logical_or
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
op_logical_or
op_logical_neg
id|timeo
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk-&gt;done
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
(brace
id|copied
op_assign
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;done
)paren
(brace
multiline_comment|/* This occurs when user tries to read&n;&t;&t;&t;&t;&t; * from never connected socket.&n;&t;&t;&t;&t;&t; */
id|copied
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|timeo
)paren
(brace
id|copied
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|cleanup_rbuf
c_func
(paren
id|sk
comma
id|copied
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ucopy.task
op_eq
id|user_recv
)paren
(brace
multiline_comment|/* Install new reader */
r_if
c_cond
(paren
id|user_recv
op_eq
l_int|NULL
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
(paren
id|MSG_TRUNC
op_or
id|MSG_PEEK
)paren
)paren
)paren
(brace
id|user_recv
op_assign
id|current
suffix:semicolon
id|tp-&gt;ucopy.task
op_assign
id|user_recv
suffix:semicolon
id|tp-&gt;ucopy.iov
op_assign
id|msg-&gt;msg_iov
suffix:semicolon
)brace
id|tp-&gt;ucopy.len
op_assign
id|len
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|tp-&gt;copied_seq
op_eq
id|tp-&gt;rcv_nxt
op_logical_or
(paren
id|flags
op_amp
(paren
id|MSG_PEEK
op_or
id|MSG_TRUNC
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Ugly... If prequeue is not empty, we have to&n;&t;&t;&t; * process it before releasing socket, otherwise&n;&t;&t;&t; * order will be broken at second iteration.&n;&t;&t;&t; * More elegant solution is required!!!&n;&t;&t;&t; *&n;&t;&t;&t; * Look: we have the following (pseudo)queues:&n;&t;&t;&t; *&n;&t;&t;&t; * 1. packets in flight&n;&t;&t;&t; * 2. backlog&n;&t;&t;&t; * 3. prequeue&n;&t;&t;&t; * 4. receive_queue&n;&t;&t;&t; *&n;&t;&t;&t; * Each queue can be processed only if the next ones&n;&t;&t;&t; * are empty. At this point we have empty receive_queue.&n;&t;&t;&t; * But prequeue _can_ be not empty after second iteration,&n;&t;&t;&t; * when we jumped to start of loop because backlog&n;&t;&t;&t; * processing added something to receive_queue.&n;&t;&t;&t; * We cannot release_sock(), because backlog contains&n;&t;&t;&t; * packets arrived _after_ prequeued ones.&n;&t;&t;&t; *&n;&t;&t;&t; * Shortly, algorithm is clear --- to process all&n;&t;&t;&t; * the queues in order. We could make it more directly,&n;&t;&t;&t; * requeueing packets from backlog to prequeue, if&n;&t;&t;&t; * is not empty. It is more elegant, but eats cycles,&n;&t;&t;&t; * unfortunately.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|tp-&gt;ucopy.prequeue
)paren
)paren
r_goto
id|do_prequeue
suffix:semicolon
multiline_comment|/* __ Set realtime policy in scheduler __ */
)brace
r_if
c_cond
(paren
id|copied
op_ge
id|target
)paren
(brace
multiline_comment|/* Do not sleep, just process backlog. */
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
id|timeo
op_assign
id|tcp_data_wait
c_func
(paren
id|sk
comma
id|timeo
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|user_recv
)paren
(brace
r_int
id|chunk
suffix:semicolon
multiline_comment|/* __ Restore normal policy in scheduler __ */
r_if
c_cond
(paren
(paren
id|chunk
op_assign
id|len
op_minus
id|tp-&gt;ucopy.len
)paren
op_ne
l_int|0
)paren
(brace
id|net_statistics
(braket
id|smp_processor_id
c_func
(paren
)paren
op_star
l_int|2
op_plus
l_int|1
)braket
dot
id|TCPDirectCopyFromBacklog
op_add_assign
id|chunk
suffix:semicolon
id|len
op_sub_assign
id|chunk
suffix:semicolon
id|copied
op_add_assign
id|chunk
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;rcv_nxt
op_eq
id|tp-&gt;copied_seq
op_logical_and
id|skb_queue_len
c_func
(paren
op_amp
id|tp-&gt;ucopy.prequeue
)paren
)paren
(brace
id|do_prequeue
suffix:colon
id|tcp_prequeue_process
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|chunk
op_assign
id|len
op_minus
id|tp-&gt;ucopy.len
)paren
op_ne
l_int|0
)paren
(brace
id|net_statistics
(braket
id|smp_processor_id
c_func
(paren
)paren
op_star
l_int|2
op_plus
l_int|1
)braket
dot
id|TCPDirectCopyFromPrequeue
op_add_assign
id|chunk
suffix:semicolon
id|len
op_sub_assign
id|chunk
suffix:semicolon
id|copied
op_add_assign
id|chunk
suffix:semicolon
)brace
)brace
)brace
r_continue
suffix:semicolon
id|found_ok_skb
suffix:colon
multiline_comment|/* Ok so how much can we use? */
id|used
op_assign
id|skb-&gt;len
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|used
)paren
id|used
op_assign
id|len
suffix:semicolon
multiline_comment|/* Do we have urgent data here? */
r_if
c_cond
(paren
id|tp-&gt;urg_data
)paren
(brace
id|u32
id|urg_offset
op_assign
id|tp-&gt;urg_seq
op_minus
op_star
id|seq
suffix:semicolon
r_if
c_cond
(paren
id|urg_offset
OL
id|used
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|urg_offset
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;urginline
)paren
(brace
op_increment
op_star
id|seq
suffix:semicolon
id|offset
op_increment
suffix:semicolon
id|used
op_decrement
suffix:semicolon
)brace
)brace
r_else
id|used
op_assign
id|urg_offset
suffix:semicolon
)brace
)brace
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_TRUNC
)paren
)paren
(brace
id|err
op_assign
id|memcpy_toiovec
c_func
(paren
id|msg-&gt;msg_iov
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|skb-&gt;h.th
)paren
op_plus
id|skb-&gt;h.th-&gt;doff
op_star
l_int|4
op_plus
id|offset
comma
id|used
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
multiline_comment|/* Exception. Bailout! */
r_if
c_cond
(paren
op_logical_neg
id|copied
)paren
id|copied
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
op_star
id|seq
op_add_assign
id|used
suffix:semicolon
id|copied
op_add_assign
id|used
suffix:semicolon
id|len
op_sub_assign
id|used
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|tp-&gt;copied_seq
comma
id|tp-&gt;urg_seq
)paren
)paren
(brace
id|tp-&gt;urg_data
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
op_eq
l_int|0
macro_line|#ifdef TCP_FORMAL_WINDOW
op_logical_and
id|tcp_receive_window
c_func
(paren
id|tp
)paren
macro_line|#endif
)paren
(brace
id|tcp_fast_path_on
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|used
op_plus
id|offset
OL
id|skb-&gt;len
)paren
r_continue
suffix:semicolon
multiline_comment|/*&t;Process the FIN. We may also need to handle PSH&n;&t;&t; *&t;here and make it break out of MSG_WAITALL.&n;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;fin
)paren
r_goto
id|found_fin_ok
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
r_continue
suffix:semicolon
id|skb-&gt;used
op_assign
l_int|1
suffix:semicolon
id|tcp_eat_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_continue
suffix:semicolon
id|found_fin_ok
suffix:colon
op_increment
op_star
id|seq
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
r_break
suffix:semicolon
multiline_comment|/* All is done. */
id|skb-&gt;used
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user_recv
)paren
(brace
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|tp-&gt;ucopy.prequeue
)paren
)paren
(brace
r_int
id|chunk
suffix:semicolon
id|tp-&gt;ucopy.len
op_assign
id|copied
OG
l_int|0
ques
c_cond
id|len
suffix:colon
l_int|0
suffix:semicolon
id|tcp_prequeue_process
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
OG
l_int|0
op_logical_and
(paren
id|chunk
op_assign
id|len
op_minus
id|tp-&gt;ucopy.len
)paren
op_ne
l_int|0
)paren
(brace
id|net_statistics
(braket
id|smp_processor_id
c_func
(paren
)paren
op_star
l_int|2
op_plus
l_int|1
)braket
dot
id|TCPDirectCopyFromPrequeue
op_add_assign
id|chunk
suffix:semicolon
id|len
op_sub_assign
id|chunk
suffix:semicolon
id|copied
op_add_assign
id|chunk
suffix:semicolon
)brace
)brace
id|tp-&gt;ucopy.task
op_assign
l_int|NULL
suffix:semicolon
id|tp-&gt;ucopy.len
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* According to UNIX98, msg_name/msg_namelen are ignored&n;&t; * on connected socket. I was just happy when found this 8) --ANK&n;&t; */
multiline_comment|/* Clean up data we have read: This will do ACK frames. */
id|cleanup_rbuf
c_func
(paren
id|sk
comma
id|copied
)paren
suffix:semicolon
id|TCP_CHECK_TIMER
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|copied
suffix:semicolon
id|out
suffix:colon
id|TCP_CHECK_TIMER
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|recv_urg
suffix:colon
id|err
op_assign
id|tcp_recv_urg
c_func
(paren
id|sk
comma
id|timeo
comma
id|msg
comma
id|len
comma
id|flags
comma
id|addr_len
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;State processing on a close. This implements the state shift for&n; *&t;sending our FIN frame. Note that we only send a FIN for some&n; *&t;states. A shutdown() may have already sent the FIN, or we may be&n; *&t;closed.&n; */
DECL|variable|new_state
r_static
r_int
r_char
id|new_state
(braket
l_int|16
)braket
op_assign
(brace
multiline_comment|/* current state:        new state:      action:&t;*/
multiline_comment|/* (Invalid)&t;&t;*/
id|TCP_CLOSE
comma
multiline_comment|/* TCP_ESTABLISHED&t;*/
id|TCP_FIN_WAIT1
op_or
id|TCP_ACTION_FIN
comma
multiline_comment|/* TCP_SYN_SENT&t;*/
id|TCP_CLOSE
comma
multiline_comment|/* TCP_SYN_RECV&t;*/
id|TCP_FIN_WAIT1
op_or
id|TCP_ACTION_FIN
comma
multiline_comment|/* TCP_FIN_WAIT1&t;*/
id|TCP_FIN_WAIT1
comma
multiline_comment|/* TCP_FIN_WAIT2&t;*/
id|TCP_FIN_WAIT2
comma
multiline_comment|/* TCP_TIME_WAIT&t;*/
id|TCP_CLOSE
comma
multiline_comment|/* TCP_CLOSE&t;&t;*/
id|TCP_CLOSE
comma
multiline_comment|/* TCP_CLOSE_WAIT&t;*/
id|TCP_LAST_ACK
op_or
id|TCP_ACTION_FIN
comma
multiline_comment|/* TCP_LAST_ACK&t;*/
id|TCP_LAST_ACK
comma
multiline_comment|/* TCP_LISTEN&t;&t;*/
id|TCP_CLOSE
comma
multiline_comment|/* TCP_CLOSING&t;*/
id|TCP_CLOSING
comma
)brace
suffix:semicolon
DECL|function|tcp_close_state
r_static
r_int
id|tcp_close_state
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|next
op_assign
(paren
r_int
)paren
id|new_state
(braket
id|sk-&gt;state
)braket
suffix:semicolon
r_int
id|ns
op_assign
(paren
id|next
op_amp
id|TCP_STATE_MASK
)paren
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|ns
)paren
suffix:semicolon
r_return
(paren
id|next
op_amp
id|TCP_ACTION_FIN
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Shutdown the sending side of a connection. Much like close except&n; *&t;that we don&squot;t receive shut down or set sk-&gt;dead.&n; */
DECL|function|tcp_shutdown
r_void
id|tcp_shutdown
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
)paren
(brace
multiline_comment|/*&t;We need to grab some memory, and put together a FIN,&n;&t; *&t;and then put it into the queue to be sent.&n;&t; *&t;&t;Tim MacKenzie(tym@dibbler.cs.monash.edu.au) 4 Dec &squot;92.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|how
op_amp
id|SEND_SHUTDOWN
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* If we&squot;ve already sent a FIN, or it&squot;s a closed state, skip this. */
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|sk-&gt;state
)paren
op_amp
(paren
id|TCPF_ESTABLISHED
op_or
id|TCPF_SYN_SENT
op_or
id|TCPF_SYN_RECV
op_or
id|TCPF_CLOSE_WAIT
)paren
)paren
(brace
multiline_comment|/* Clear out any half completed packets.  FIN if needed. */
r_if
c_cond
(paren
id|tcp_close_state
c_func
(paren
id|sk
)paren
)paren
id|tcp_send_fin
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Return 1 if we still have things to send in our buffers.&n; */
DECL|function|closing
r_static
r_inline
r_int
id|closing
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
(paren
(paren
l_int|1
op_lshift
id|sk-&gt;state
)paren
op_amp
(paren
id|TCPF_FIN_WAIT1
op_or
id|TCPF_CLOSING
op_or
id|TCPF_LAST_ACK
)paren
)paren
suffix:semicolon
)brace
DECL|function|tcp_kill_sk_queues
r_static
id|__inline__
r_void
id|tcp_kill_sk_queues
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
multiline_comment|/* First the read buffer. */
id|__skb_queue_purge
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
multiline_comment|/* Next, the error queue. */
id|__skb_queue_purge
c_func
(paren
op_amp
id|sk-&gt;error_queue
)paren
suffix:semicolon
multiline_comment|/* Next, the write queue. */
id|BUG_TRAP
c_func
(paren
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
suffix:semicolon
multiline_comment|/* Account for returned memory. */
id|tcp_mem_reclaim
c_func
(paren
id|sk
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|sk-&gt;wmem_queued
op_eq
l_int|0
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|sk-&gt;forward_alloc
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* It is _impossible_ for the backlog to contain anything&n;&t; * when we get here.  All user references to this socket&n;&t; * have gone away, only the net layer knows can touch it.&n;&t; */
)brace
multiline_comment|/*&n; * At this point, there should be no process reference to this&n; * socket, and thus no user references at all.  Therefore we&n; * can assume the socket waitqueue is inactive and nobody will&n; * try to jump onto it.&n; */
DECL|function|tcp_destroy_sock
r_void
id|tcp_destroy_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|BUG_TRAP
c_func
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|sk-&gt;dead
)paren
suffix:semicolon
multiline_comment|/* It cannot be in hash table! */
id|BUG_TRAP
c_func
(paren
id|sk-&gt;pprev
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* It it has not 0 sk-&gt;num, it must be bound */
id|BUG_TRAP
c_func
(paren
op_logical_neg
id|sk-&gt;num
op_logical_or
id|sk-&gt;prev
op_ne
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef TCP_DEBUG
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TCP: double destroy sk=%p&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|sk-&gt;zapped
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|sk-&gt;prot
op_member_access_from_pointer
id|destroy
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_kill_sk_queues
c_func
(paren
id|sk
)paren
suffix:semicolon
macro_line|#ifdef INET_REFCNT_DEBUG
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Destruction TCP %p delayed, c=%d&bslash;n&quot;
comma
id|sk
comma
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|atomic_dec
c_func
(paren
op_amp
id|tcp_orphan_count
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
DECL|function|tcp_close
r_void
id|tcp_close
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeout
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|data_was_unread
op_assign
l_int|0
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
(brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
multiline_comment|/* Special case. */
id|tcp_listen_stop
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|adjudge_to_death
suffix:semicolon
)brace
multiline_comment|/*  We need to flush the recv. buffs.  We do this only on the&n;&t; *  descriptor close, not protocol-sourced closes, because the&n;&t; *  reader process may not have drained the data yet!&n;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|u32
id|len
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_minus
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_minus
id|skb-&gt;h.th-&gt;fin
suffix:semicolon
id|data_was_unread
op_add_assign
id|len
suffix:semicolon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|tcp_mem_reclaim
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* As outlined in draft-ietf-tcpimpl-prob-03.txt, section&n;&t; * 3.10, we send a RST here because data was lost.  To&n;&t; * witness the awful effects of the old behavior of always&n;&t; * doing a FIN, run an older 2.1.x kernel or 2.0.x, start&n;&t; * a bulk GET in an FTP client, suspend the process, wait&n;&t; * for the client to advertise a zero window, then kill -9&n;&t; * the FTP client, wheee...  Note: timeout is always zero&n;&t; * in such a case.&n;&t; */
r_if
c_cond
(paren
id|data_was_unread
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Unread data was tossed, zap the connection. */
id|NET_INC_STATS_USER
c_func
(paren
id|TCPAbortOnClose
)paren
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|tcp_send_active_reset
c_func
(paren
id|sk
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sk-&gt;linger
op_logical_and
id|sk-&gt;lingertime
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Check zero linger _after_ checking for unread data. */
id|sk-&gt;prot
op_member_access_from_pointer
id|disconnect
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
id|NET_INC_STATS_USER
c_func
(paren
id|TCPAbortOnData
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tcp_close_state
c_func
(paren
id|sk
)paren
)paren
(brace
multiline_comment|/* We FIN if the application ate all the data before&n;&t;&t; * zapping the connection.&n;&t;&t; */
multiline_comment|/* RED-PEN. Formally speaking, we have broken TCP state&n;&t;&t; * machine. State transitions:&n;&t;&t; *&n;&t;&t; * TCP_ESTABLISHED -&gt; TCP_FIN_WAIT1&n;&t;&t; * TCP_SYN_RECV&t;-&gt; TCP_FIN_WAIT1 (forget it, it&squot;s impossible)&n;&t;&t; * TCP_CLOSE_WAIT -&gt; TCP_LAST_ACK&n;&t;&t; *&n;&t;&t; * are legal only when FIN has been sent (i.e. in window),&n;&t;&t; * rather than queued out of window. Purists blame.&n;&t;&t; *&n;&t;&t; * F.e. &quot;RFC state&quot; is ESTABLISHED,&n;&t;&t; * if Linux state is FIN-WAIT-1, but FIN is still not sent.&n;&t;&t; *&n;&t;&t; * The visible declinations are that sometimes&n;&t;&t; * we enter time-wait state, when it is not required really&n;&t;&t; * (harmless), do not send active resets, when they are&n;&t;&t; * required by specs (TCP_ESTABLISHED, TCP_CLOSE_WAIT, when&n;&t;&t; * they look as CLOSING or LAST_ACK for Linux)&n;&t;&t; * Probably, I missed some more holelets.&n;&t;&t; * &t;&t;&t;&t;&t;&t;--ANK&n;&t;&t; */
id|tcp_send_fin
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timeout
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
r_do
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|closing
c_func
(paren
id|sk
)paren
)paren
r_break
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|timeout
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|signal_pending
c_func
(paren
id|tsk
)paren
op_logical_and
id|timeout
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
id|adjudge_to_death
suffix:colon
multiline_comment|/* It is the last release_sock in its life. It will remove backlog. */
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Now socket is owned by kernel and we acquire BH lock&n;&t;   to finish close. No need to check for user refs.&n;&t; */
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
id|bh_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|sk-&gt;lock.users
op_eq
l_int|0
)paren
suffix:semicolon
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sock_orphan
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*&t;This is a (useful) BSD violating of the RFC. There is a&n;&t; *&t;problem with TCP as specified in that the other end could&n;&t; *&t;keep a socket open forever with no application left this end.&n;&t; *&t;We use a 3 minute timeout (about the same as BSD) then kill&n;&t; *&t;our end. If they send after that then tough - BUT: long enough&n;&t; *&t;that we won&squot;t make the old 4*rto = almost no time - whoops&n;&t; *&t;reset mistake.&n;&t; *&n;&t; *&t;Nope, it was not mistake. It is really desired behaviour&n;&t; *&t;f.e. on http servers, when such sockets are useless, but&n;&t; *&t;consume significant resources. Let&squot;s do it with special&n;&t; *&t;linger2&t;option.&t;&t;&t;&t;&t;--ANK&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT2
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;linger2
OL
l_int|0
)paren
(brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|tcp_send_active_reset
c_func
(paren
id|sk
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|TCPAbortOnLinger
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|tmo
op_assign
id|tcp_fin_time
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmo
OG
id|TCP_TIMEWAIT_LEN
)paren
(brace
id|tcp_reset_keepalive_timer
c_func
(paren
id|sk
comma
id|tcp_fin_time
c_func
(paren
id|tp
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|atomic_inc
c_func
(paren
op_amp
id|tcp_orphan_count
)paren
suffix:semicolon
id|tcp_time_wait
c_func
(paren
id|sk
comma
id|TCP_FIN_WAIT2
comma
id|tmo
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_CLOSE
)paren
(brace
id|tcp_mem_reclaim
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|tcp_orphan_count
)paren
OG
id|sysctl_tcp_max_orphans
op_logical_or
(paren
id|sk-&gt;wmem_queued
OG
id|SOCK_MIN_SNDBUF
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|tcp_memory_allocated
)paren
OG
id|sysctl_tcp_mem
(braket
l_int|2
)braket
)paren
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;TCP: too many of orphaned sockets&bslash;n&quot;
)paren
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|tcp_send_active_reset
c_func
(paren
id|sk
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|TCPAbortOnMemory
)paren
suffix:semicolon
)brace
)brace
id|atomic_inc
c_func
(paren
op_amp
id|tcp_orphan_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
id|tcp_destroy_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Otherwise, socket is reprieved until protocol close. */
id|out
suffix:colon
id|bh_unlock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* These states need RST on ABORT according to RFC793 */
DECL|function|tcp_need_reset
r_extern
id|__inline__
r_int
id|tcp_need_reset
c_func
(paren
r_int
id|state
)paren
(brace
r_return
(paren
(paren
l_int|1
op_lshift
id|state
)paren
op_amp
(paren
id|TCPF_ESTABLISHED
op_or
id|TCPF_CLOSE_WAIT
op_or
id|TCPF_FIN_WAIT1
op_or
id|TCPF_FIN_WAIT2
op_or
id|TCPF_SYN_RECV
)paren
)paren
suffix:semicolon
)brace
DECL|function|tcp_disconnect
r_int
id|tcp_disconnect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_int
id|old_state
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|old_state
op_assign
id|sk-&gt;state
suffix:semicolon
r_if
c_cond
(paren
id|old_state
op_ne
id|TCP_CLOSE
)paren
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
multiline_comment|/* ABORT function of RFC793 */
r_if
c_cond
(paren
id|old_state
op_eq
id|TCP_LISTEN
)paren
(brace
id|tcp_listen_stop
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tcp_need_reset
c_func
(paren
id|old_state
)paren
op_logical_or
(paren
id|tp-&gt;snd_nxt
op_ne
id|tp-&gt;write_seq
op_logical_and
(paren
l_int|1
op_lshift
id|old_state
)paren
op_amp
(paren
id|TCPF_CLOSING
op_or
id|TCPF_LAST_ACK
)paren
)paren
)paren
(brace
multiline_comment|/* The last check adjusts for discrepance of Linux wrt. RFC&n;&t;&t; * states&n;&t;&t; */
id|tcp_send_active_reset
c_func
(paren
id|sk
comma
id|gfp_any
c_func
(paren
)paren
)paren
suffix:semicolon
id|sk-&gt;err
op_assign
id|ECONNRESET
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|old_state
op_eq
id|TCP_SYN_SENT
)paren
id|sk-&gt;err
op_assign
id|ECONNRESET
suffix:semicolon
id|tcp_clear_xmit_timers
c_func
(paren
id|sk
)paren
suffix:semicolon
id|__skb_queue_purge
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
id|tcp_writequeue_purge
c_func
(paren
id|sk
)paren
suffix:semicolon
id|__skb_queue_purge
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
suffix:semicolon
id|sk-&gt;dport
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sk-&gt;userlocks
op_amp
id|SOCK_BINDADDR_LOCK
)paren
)paren
(brace
id|sk-&gt;rcv_saddr
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;saddr
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
id|memset
c_func
(paren
op_amp
id|sk-&gt;net_pinfo.af_inet6.saddr
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|sk-&gt;net_pinfo.af_inet6.rcv_saddr
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
macro_line|#endif
)brace
id|sk-&gt;shutdown
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;done
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;srtt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;write_seq
op_add_assign
id|tp-&gt;max_window
op_plus
l_int|2
)paren
op_eq
l_int|0
)paren
id|tp-&gt;write_seq
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;backoff
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;snd_cwnd
op_assign
l_int|2
suffix:semicolon
id|tp-&gt;probes_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;packets_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;snd_ssthresh
op_assign
l_int|0x7fffffff
suffix:semicolon
id|tp-&gt;snd_cwnd_cnt
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;ca_state
op_assign
id|TCP_CA_Open
suffix:semicolon
id|tcp_clear_retrans
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tcp_delack_init
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;send_head
op_assign
l_int|NULL
suffix:semicolon
id|tp-&gt;saw_tstamp
op_assign
l_int|0
suffix:semicolon
id|tcp_sack_reset
c_func
(paren
id|tp
)paren
suffix:semicolon
id|__sk_dst_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
op_logical_neg
id|sk-&gt;num
op_logical_or
id|sk-&gt;prev
)paren
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Wait for an incoming connection, avoid race&n; *&t;conditions. This must be called with the socket locked.&n; */
DECL|function|wait_for_connect
r_static
r_int
id|wait_for_connect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeo
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/*&n;&t; * True wake-one mechanism for incoming connections: only&n;&t; * one process gets woken up, not the &squot;whole herd&squot;.&n;&t; * Since we do not &squot;race &amp; poll&squot; for established sockets&n;&t; * anymore, the common case will execute the loop only once.&n;&t; *&n;&t; * Subtle issue: &quot;add_wait_queue_exclusive()&quot; will be added&n;&t; * after any current non-exclusive waiters, and we know that&n;&t; * it will always _stay_ after any new non-exclusive waiters&n;&t; * because all non-exclusive waiters are added at the&n;&t; * beginning of the wait-queue. As such, it&squot;s ok to &quot;drop&quot;&n;&t; * our exclusiveness temporarily when we get woken up without&n;&t; * having to remove and re-insert us on the wait queue.&n;&t; */
id|add_wait_queue_exclusive
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;tp_pinfo.af_tcp.accept_queue
op_eq
l_int|NULL
)paren
id|timeo
op_assign
id|schedule_timeout
c_func
(paren
id|timeo
)paren
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;tp_pinfo.af_tcp.accept_queue
)paren
r_break
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_LISTEN
)paren
r_break
suffix:semicolon
id|err
op_assign
id|sock_intr_errno
c_func
(paren
id|timeo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timeo
)paren
r_break
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This will accept the next outstanding connection.&n; */
DECL|function|tcp_accept
r_struct
id|sock
op_star
id|tcp_accept
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
comma
r_int
op_star
id|err
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_struct
id|open_request
op_star
id|req
suffix:semicolon
r_struct
id|sock
op_star
id|newsk
suffix:semicolon
r_int
id|error
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* We need to make sure that this socket is listening,&n;&t; * and that it has something pending.&n;&t; */
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_LISTEN
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Find already established connection */
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;accept_queue
)paren
(brace
r_int
id|timeo
op_assign
id|sock_rcvtimeo
c_func
(paren
id|sk
comma
id|flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
multiline_comment|/* If this is a non blocking socket don&squot;t sleep */
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timeo
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|wait_for_connect
c_func
(paren
id|sk
comma
id|timeo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
)brace
id|req
op_assign
id|tp-&gt;accept_queue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;accept_queue
op_assign
id|req-&gt;dl_next
)paren
op_eq
l_int|NULL
)paren
id|tp-&gt;accept_queue_tail
op_assign
l_int|NULL
suffix:semicolon
id|newsk
op_assign
id|req-&gt;sk
suffix:semicolon
id|tcp_acceptq_removed
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_openreq_fastfree
c_func
(paren
id|req
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|newsk-&gt;state
op_ne
id|TCP_SYN_RECV
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|newsk
suffix:semicolon
id|out
suffix:colon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
op_star
id|err
op_assign
id|error
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Socket option code for TCP. &n; */
DECL|function|tcp_setsockopt
r_int
id|tcp_setsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|val
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|level
op_ne
id|SOL_TCP
)paren
r_return
id|tp-&gt;af_specific
op_member_access_from_pointer
id|setsockopt
c_func
(paren
id|sk
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|optlen
OL
r_sizeof
(paren
r_int
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|optval
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|TCP_MAXSEG
suffix:colon
multiline_comment|/* values greater than interface MTU won&squot;t take effect.  however at&n;&t;&t; * the point when this call is done we typically don&squot;t yet know&n;&t;&t; * which interface is going to be used&n;&t;&t; */
r_if
c_cond
(paren
id|val
template_param
id|MAX_TCP_WINDOW
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tp-&gt;user_mss
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_NODELAY
suffix:colon
multiline_comment|/* You cannot try to use this and TCP_CORK in&n;&t;&t; * tandem, so let the user know.&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;nonagle
op_eq
l_int|2
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tp-&gt;nonagle
op_assign
(paren
id|val
op_eq
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
id|tcp_push_pending_frames
c_func
(paren
id|sk
comma
id|tp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CORK
suffix:colon
multiline_comment|/* When set indicates to always queue non-full frames.&n;&t;&t; * Later the user clears this option and we transmit&n;&t;&t; * any pending partial frames in the queue.  This is&n;&t;&t; * meant to be used alongside sendfile() to get properly&n;&t;&t; * filled frames when the user (for example) must write&n;&t;&t; * out headers with a write() call first and then use&n;&t;&t; * sendfile to send out the data parts.&n;&t;&t; *&n;&t;&t; * You cannot try to use TCP_NODELAY and this mechanism&n;&t;&t; * at the same time, so let the user know.&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;nonagle
op_eq
l_int|1
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|val
op_ne
l_int|0
)paren
(brace
id|tp-&gt;nonagle
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|tp-&gt;nonagle
op_assign
l_int|0
suffix:semicolon
id|tcp_push_pending_frames
c_func
(paren
id|sk
comma
id|tp
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TCP_KEEPIDLE
suffix:colon
r_if
c_cond
(paren
id|val
template_param
id|MAX_TCP_KEEPIDLE
)paren
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
(brace
id|tp-&gt;keepalive_time
op_assign
id|val
op_star
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;keepopen
op_logical_and
op_logical_neg
(paren
(paren
l_int|1
op_lshift
id|sk-&gt;state
)paren
op_amp
(paren
id|TCPF_CLOSE
op_or
id|TCPF_LISTEN
)paren
)paren
)paren
(brace
id|__u32
id|elapsed
op_assign
id|tcp_time_stamp
op_minus
id|tp-&gt;rcv_tstamp
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;keepalive_time
OG
id|elapsed
)paren
id|elapsed
op_assign
id|tp-&gt;keepalive_time
op_minus
id|elapsed
suffix:semicolon
r_else
id|elapsed
op_assign
l_int|0
suffix:semicolon
id|tcp_reset_keepalive_timer
c_func
(paren
id|sk
comma
id|elapsed
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|TCP_KEEPINTVL
suffix:colon
r_if
c_cond
(paren
id|val
template_param
id|MAX_TCP_KEEPINTVL
)paren
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
id|tp-&gt;keepalive_intvl
op_assign
id|val
op_star
id|HZ
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_KEEPCNT
suffix:colon
r_if
c_cond
(paren
id|val
template_param
id|MAX_TCP_KEEPCNT
)paren
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
id|tp-&gt;keepalive_probes
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_SYNCNT
suffix:colon
r_if
c_cond
(paren
id|val
template_param
id|MAX_TCP_SYNCNT
)paren
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
id|tp-&gt;syn_retries
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_LINGER2
suffix:colon
r_if
c_cond
(paren
id|val
OL
l_int|0
)paren
id|tp-&gt;linger2
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|val
OG
id|sysctl_tcp_fin_timeout
op_div
id|HZ
)paren
id|tp-&gt;linger2
op_assign
l_int|0
suffix:semicolon
r_else
id|tp-&gt;linger2
op_assign
id|val
op_star
id|HZ
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_DEFER_ACCEPT
suffix:colon
id|tp-&gt;defer_accept
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
OG
l_int|0
)paren
(brace
multiline_comment|/* Translate value in seconds to number of retransmits */
r_while
c_loop
(paren
id|val
OG
(paren
(paren
id|TCP_TIMEOUT_INIT
op_div
id|HZ
)paren
op_lshift
id|tp-&gt;defer_accept
)paren
)paren
id|tp-&gt;defer_accept
op_increment
suffix:semicolon
id|tp-&gt;defer_accept
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TCP_WINDOW_CLAMP
suffix:colon
r_if
c_cond
(paren
id|val
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_CLOSE
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tp-&gt;window_clamp
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|tp-&gt;window_clamp
op_assign
id|val
OL
id|SOCK_MIN_RCVBUF
op_div
l_int|2
ques
c_cond
id|SOCK_MIN_RCVBUF
op_div
l_int|2
suffix:colon
id|val
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|ENOPROTOOPT
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|tcp_getsockopt
r_int
id|tcp_getsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|val
comma
id|len
suffix:semicolon
r_if
c_cond
(paren
id|level
op_ne
id|SOL_TCP
)paren
(brace
r_return
id|tp-&gt;af_specific
op_member_access_from_pointer
id|getsockopt
c_func
(paren
id|sk
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|len
op_assign
id|min
c_func
(paren
id|len
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|TCP_MAXSEG
suffix:colon
id|val
op_assign
id|tp-&gt;mss_cache
suffix:semicolon
r_if
c_cond
(paren
id|val
op_eq
l_int|0
op_logical_and
(paren
(paren
l_int|1
op_lshift
id|sk-&gt;state
)paren
op_amp
(paren
id|TCPF_CLOSE
op_or
id|TCPF_LISTEN
)paren
)paren
)paren
id|val
op_assign
id|tp-&gt;user_mss
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_NODELAY
suffix:colon
id|val
op_assign
(paren
id|tp-&gt;nonagle
op_eq
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CORK
suffix:colon
id|val
op_assign
(paren
id|tp-&gt;nonagle
op_eq
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_KEEPIDLE
suffix:colon
id|val
op_assign
(paren
id|tp-&gt;keepalive_time
ques
c_cond
suffix:colon
id|sysctl_tcp_keepalive_time
)paren
op_div
id|HZ
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_KEEPINTVL
suffix:colon
id|val
op_assign
(paren
id|tp-&gt;keepalive_intvl
ques
c_cond
suffix:colon
id|sysctl_tcp_keepalive_intvl
)paren
op_div
id|HZ
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_KEEPCNT
suffix:colon
id|val
op_assign
id|tp-&gt;keepalive_probes
ques
c_cond
suffix:colon
id|sysctl_tcp_keepalive_probes
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_SYNCNT
suffix:colon
id|val
op_assign
id|tp-&gt;syn_retries
ques
c_cond
suffix:colon
id|sysctl_tcp_syn_retries
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_LINGER2
suffix:colon
id|val
op_assign
id|tp-&gt;linger2
suffix:semicolon
r_if
c_cond
(paren
id|val
OG
l_int|0
)paren
id|val
op_assign
(paren
id|val
ques
c_cond
suffix:colon
id|sysctl_tcp_fin_timeout
)paren
op_div
id|HZ
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_DEFER_ACCEPT
suffix:colon
id|val
op_assign
id|tp-&gt;defer_accept
op_eq
l_int|0
ques
c_cond
l_int|0
suffix:colon
(paren
id|TCP_TIMEOUT_INIT
op_lshift
(paren
id|tp-&gt;defer_accept
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_WINDOW_CLAMP
suffix:colon
id|val
op_assign
id|tp-&gt;window_clamp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_INFO
suffix:colon
(brace
r_struct
id|tcp_info
id|info
suffix:semicolon
id|u32
id|now
op_assign
id|tcp_time_stamp
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|info.tcpi_state
op_assign
id|sk-&gt;state
suffix:semicolon
id|info.tcpi_ca_state
op_assign
id|tp-&gt;ca_state
suffix:semicolon
id|info.tcpi_retransmits
op_assign
id|tp-&gt;retransmits
suffix:semicolon
id|info.tcpi_probes
op_assign
id|tp-&gt;probes_out
suffix:semicolon
id|info.tcpi_backoff
op_assign
id|tp-&gt;backoff
suffix:semicolon
id|info.tcpi_options
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;tstamp_ok
)paren
id|info.tcpi_options
op_or_assign
id|TCPI_OPT_TIMESTAMPS
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;sack_ok
)paren
id|info.tcpi_options
op_or_assign
id|TCPI_OPT_SACK
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;wscale_ok
)paren
(brace
id|info.tcpi_options
op_or_assign
id|TCPI_OPT_WSCALE
suffix:semicolon
id|info.tcpi_snd_wscale
op_assign
id|tp-&gt;snd_wscale
suffix:semicolon
id|info.tcpi_rcv_wscale
op_assign
id|tp-&gt;rcv_wscale
suffix:semicolon
)brace
r_else
(brace
id|info.tcpi_snd_wscale
op_assign
l_int|0
suffix:semicolon
id|info.tcpi_rcv_wscale
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_INET_ECN
r_if
c_cond
(paren
id|tp-&gt;ecn_flags
op_amp
id|TCP_ECN_OK
)paren
id|info.tcpi_options
op_or_assign
id|TCPI_OPT_ECN
suffix:semicolon
macro_line|#endif
id|info.tcpi_rto
op_assign
(paren
l_int|1000000
op_star
id|tp-&gt;rto
)paren
op_div
id|HZ
suffix:semicolon
id|info.tcpi_ato
op_assign
(paren
l_int|1000000
op_star
id|tp-&gt;ack.ato
)paren
op_div
id|HZ
suffix:semicolon
id|info.tcpi_snd_mss
op_assign
id|tp-&gt;mss_cache
suffix:semicolon
id|info.tcpi_rcv_mss
op_assign
id|tp-&gt;ack.rcv_mss
suffix:semicolon
id|info.tcpi_unacked
op_assign
id|tp-&gt;packets_out
suffix:semicolon
id|info.tcpi_sacked
op_assign
id|tp-&gt;sacked_out
suffix:semicolon
id|info.tcpi_lost
op_assign
id|tp-&gt;lost_out
suffix:semicolon
id|info.tcpi_retrans
op_assign
id|tp-&gt;retrans_out
suffix:semicolon
id|info.tcpi_fackets
op_assign
id|tp-&gt;fackets_out
suffix:semicolon
id|info.tcpi_last_data_sent
op_assign
(paren
(paren
id|now
op_minus
id|tp-&gt;lsndtime
)paren
op_star
l_int|1000
)paren
op_div
id|HZ
suffix:semicolon
id|info.tcpi_last_ack_sent
op_assign
l_int|0
suffix:semicolon
id|info.tcpi_last_data_recv
op_assign
(paren
(paren
id|now
op_minus
id|tp-&gt;ack.lrcvtime
)paren
op_star
l_int|1000
)paren
op_div
id|HZ
suffix:semicolon
id|info.tcpi_last_ack_recv
op_assign
(paren
(paren
id|now
op_minus
id|tp-&gt;rcv_tstamp
)paren
op_star
l_int|1000
)paren
op_div
id|HZ
suffix:semicolon
id|info.tcpi_pmtu
op_assign
id|tp-&gt;pmtu_cookie
suffix:semicolon
id|info.tcpi_rcv_ssthresh
op_assign
id|tp-&gt;rcv_ssthresh
suffix:semicolon
id|info.tcpi_rtt
op_assign
(paren
(paren
l_int|1000000
op_star
id|tp-&gt;srtt
)paren
op_div
id|HZ
)paren
op_rshift
l_int|3
suffix:semicolon
id|info.tcpi_rttvar
op_assign
(paren
(paren
l_int|1000000
op_star
id|tp-&gt;mdev
)paren
op_div
id|HZ
)paren
op_rshift
l_int|2
suffix:semicolon
id|info.tcpi_snd_ssthresh
op_assign
id|tp-&gt;snd_ssthresh
suffix:semicolon
id|info.tcpi_snd_cwnd
op_assign
id|tp-&gt;snd_cwnd
suffix:semicolon
id|info.tcpi_advmss
op_assign
id|tp-&gt;advmss
suffix:semicolon
id|info.tcpi_reordering
op_assign
id|tp-&gt;reordering
suffix:semicolon
id|len
op_assign
id|min
c_func
(paren
id|len
comma
r_sizeof
(paren
id|info
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|info
comma
id|len
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|val
comma
id|len
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_extern
r_void
id|__skb_cb_too_small_for_tcp
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
DECL|function|tcp_init
r_void
id|__init
id|tcp_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|goal
suffix:semicolon
r_int
id|order
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|tcp_skb_cb
)paren
OG
r_sizeof
(paren
id|skb-&gt;cb
)paren
)paren
(brace
id|__skb_cb_too_small_for_tcp
c_func
(paren
r_sizeof
(paren
r_struct
id|tcp_skb_cb
)paren
comma
r_sizeof
(paren
id|skb-&gt;cb
)paren
)paren
suffix:semicolon
)brace
id|tcp_openreq_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;tcp_open_request&quot;
comma
r_sizeof
(paren
r_struct
id|open_request
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_openreq_cachep
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;tcp_init: Cannot alloc open_request cache.&quot;
)paren
suffix:semicolon
)brace
id|tcp_bucket_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;tcp_bind_bucket&quot;
comma
r_sizeof
(paren
r_struct
id|tcp_bind_bucket
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_bucket_cachep
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;tcp_init: Cannot alloc tcp_bind_bucket cache.&quot;
)paren
suffix:semicolon
)brace
id|tcp_timewait_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;tcp_tw_bucket&quot;
comma
r_sizeof
(paren
r_struct
id|tcp_tw_bucket
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_timewait_cachep
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;tcp_init: Cannot alloc tcp_tw_bucket cache.&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Size and allocate the main established and bind bucket&n;&t; * hash tables.&n;&t; *&n;&t; * The methodology is similar to that of the buffer cache.&n;&t; */
id|goal
op_assign
id|num_physpages
op_rshift
(paren
l_int|23
op_minus
id|PAGE_SHIFT
)paren
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
suffix:semicolon
(paren
l_int|1UL
op_lshift
id|order
)paren
OL
id|goal
suffix:semicolon
id|order
op_increment
)paren
(brace
suffix:semicolon
)brace
r_do
(brace
id|tcp_ehash_size
op_assign
(paren
l_int|1UL
op_lshift
id|order
)paren
op_star
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_struct
id|tcp_ehash_bucket
)paren
suffix:semicolon
id|tcp_ehash_size
op_rshift_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|tcp_ehash_size
op_amp
(paren
id|tcp_ehash_size
op_minus
l_int|1
)paren
)paren
id|tcp_ehash_size
op_decrement
suffix:semicolon
id|tcp_ehash
op_assign
(paren
r_struct
id|tcp_ehash_bucket
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|order
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tcp_ehash
op_eq
l_int|NULL
op_logical_and
op_decrement
id|order
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_ehash
)paren
id|panic
c_func
(paren
l_string|&quot;Failed to allocate TCP established hash table&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|tcp_ehash_size
op_lshift
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tcp_ehash
(braket
id|i
)braket
dot
id|lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
id|tcp_ehash
(braket
id|i
)braket
dot
id|chain
op_assign
l_int|NULL
suffix:semicolon
)brace
r_do
(brace
id|tcp_bhash_size
op_assign
(paren
l_int|1UL
op_lshift
id|order
)paren
op_star
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_struct
id|tcp_bind_hashbucket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tcp_bhash_size
OG
(paren
l_int|64
op_star
l_int|1024
)paren
)paren
op_logical_and
id|order
OG
l_int|0
)paren
r_continue
suffix:semicolon
id|tcp_bhash
op_assign
(paren
r_struct
id|tcp_bind_hashbucket
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|order
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tcp_bhash
op_eq
l_int|NULL
op_logical_and
op_decrement
id|order
op_ge
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_bhash
)paren
id|panic
c_func
(paren
l_string|&quot;Failed to allocate TCP bind hash table&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|tcp_bhash_size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tcp_bhash
(braket
id|i
)braket
dot
id|lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|tcp_bhash
(braket
id|i
)braket
dot
id|chain
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Try to be a bit smarter and adjust defaults depending&n;&t; * on available memory.&n;&t; */
r_if
c_cond
(paren
id|order
OG
l_int|4
)paren
(brace
id|sysctl_local_port_range
(braket
l_int|0
)braket
op_assign
l_int|32768
suffix:semicolon
id|sysctl_local_port_range
(braket
l_int|1
)braket
op_assign
l_int|61000
suffix:semicolon
id|sysctl_tcp_max_tw_buckets
op_assign
l_int|180000
suffix:semicolon
id|sysctl_tcp_max_orphans
op_assign
l_int|4096
op_lshift
(paren
id|order
op_minus
l_int|4
)paren
suffix:semicolon
id|sysctl_max_syn_backlog
op_assign
l_int|1024
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|order
OL
l_int|3
)paren
(brace
id|sysctl_local_port_range
(braket
l_int|0
)braket
op_assign
l_int|1024
op_star
(paren
l_int|3
op_minus
id|order
)paren
suffix:semicolon
id|sysctl_tcp_max_tw_buckets
op_rshift_assign
(paren
l_int|3
op_minus
id|order
)paren
suffix:semicolon
id|sysctl_tcp_max_orphans
op_rshift_assign
(paren
l_int|3
op_minus
id|order
)paren
suffix:semicolon
id|sysctl_max_syn_backlog
op_assign
l_int|128
suffix:semicolon
)brace
id|tcp_port_rover
op_assign
id|sysctl_local_port_range
(braket
l_int|0
)braket
op_minus
l_int|1
suffix:semicolon
id|sysctl_tcp_mem
(braket
l_int|0
)braket
op_assign
l_int|64
op_lshift
id|order
suffix:semicolon
id|sysctl_tcp_mem
(braket
l_int|1
)braket
op_assign
l_int|200
op_lshift
id|order
suffix:semicolon
id|sysctl_tcp_mem
(braket
l_int|2
)braket
op_assign
l_int|256
op_lshift
id|order
suffix:semicolon
r_if
c_cond
(paren
id|sysctl_tcp_mem
(braket
l_int|2
)braket
op_minus
id|sysctl_tcp_mem
(braket
l_int|1
)braket
OG
l_int|512
)paren
id|sysctl_tcp_mem
(braket
l_int|1
)braket
op_assign
id|sysctl_tcp_mem
(braket
l_int|2
)braket
op_minus
l_int|512
suffix:semicolon
r_if
c_cond
(paren
id|sysctl_tcp_mem
(braket
l_int|1
)braket
op_minus
id|sysctl_tcp_mem
(braket
l_int|0
)braket
OG
l_int|512
)paren
id|sysctl_tcp_mem
(braket
l_int|0
)braket
op_assign
id|sysctl_tcp_mem
(braket
l_int|1
)braket
op_minus
l_int|512
suffix:semicolon
r_if
c_cond
(paren
id|order
OL
l_int|3
)paren
(brace
id|sysctl_tcp_wmem
(braket
l_int|2
)braket
op_assign
l_int|64
op_star
l_int|1024
suffix:semicolon
id|sysctl_tcp_rmem
(braket
l_int|0
)braket
op_assign
id|PAGE_SIZE
suffix:semicolon
id|sysctl_tcp_rmem
(braket
l_int|1
)braket
op_assign
l_int|43689
suffix:semicolon
id|sysctl_tcp_rmem
(braket
l_int|2
)braket
op_assign
l_int|2
op_star
l_int|43689
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;TCP: Hash tables configured (established %d bind %d)&bslash;n&quot;
comma
id|tcp_ehash_size
op_lshift
l_int|1
comma
id|tcp_bhash_size
)paren
suffix:semicolon
)brace
eof
