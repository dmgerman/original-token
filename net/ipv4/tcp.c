multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Implementation of the Transmission Control Protocol(TCP).&n; *&n; * Version:&t;@(#)tcp.c&t;1.0.16&t;05/25/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;&n; *&t;&t;Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; *&n; * Fixes:&t;&n; *&t;&t;Alan Cox&t;:&t;Numerous verify_area() calls&n; *&t;&t;Alan Cox&t;:&t;Set the ACK bit on a reset&n; *&t;&t;Alan Cox&t;:&t;Stopped it crashing if it closed while&n; *&t;&t;&t;&t;&t;sk-&gt;inuse=1 and was trying to connect &n; *&t;&t;&t;&t;&t;(tcp_err()).&n; *&t;&t;Alan Cox&t;:&t;All icmp error handling was broken&n; *&t;&t;&t;&t;&t;pointers passed where wrong and the&n; *&t;&t;&t;&t;&t;socket was looked up backwards. Nobody&n; *&t;&t;&t;&t;&t;tested any icmp error code obviously.&n; *&t;&t;Alan Cox&t;:&t;tcp_err() now handled properly. It &n; *&t;&t;&t;&t;&t;wakes people on errors. select &n; *&t;&t;&t;&t;&t;behaves and the icmp error race&n; *&t;&t;&t;&t;&t;has gone by moving it into sock.c&n; *&t;&t;Alan Cox&t;:&t;tcp_reset() fixed to work for &n; *&t;&t;&t;&t;&t;everything not just packets for &n; *&t;&t;&t;&t;&t;unknown sockets.&n; *&t;&t;Alan Cox&t;:&t;tcp option processing.&n; *&t;&t;Alan Cox&t;:&t;Reset tweaked (still not 100%) [Had &n; *&t;&t;&t;&t;&t;syn rule wrong]&n; *&t;&t;Herp Rosmanith  :&t;More reset fixes&n; *&t;&t;Alan Cox&t;:&t;No longer acks invalid rst frames. &n; *&t;&t;&t;&t;&t;Acking any kind of RST is right out.&n; *&t;&t;Alan Cox&t;:&t;Sets an ignore me flag on an rst &n; *&t;&t;&t;&t;&t;receive otherwise odd bits of prattle &n; *&t;&t;&t;&t;&t;escape still&n; *&t;&t;Alan Cox&t;:&t;Fixed another acking RST frame bug. &n; *&t;&t;&t;&t;&t;Should stop LAN workplace lockups.&n; *&t;&t;Alan Cox&t;: &t;Some tidyups using the new skb list &n; *&t;&t;&t;&t;&t;facilities&n; *&t;&t;Alan Cox&t;:&t;sk-&gt;keepopen now seems to work&n; *&t;&t;Alan Cox&t;:&t;Pulls options out correctly on accepts&n; *&t;&t;Alan Cox&t;:&t;Fixed assorted sk-&gt;rqueue-&gt;next errors&n; *&t;&t;Alan Cox&t;:&t;PSH doesn&squot;t end a TCP read. Switched a&n; *&t;&t;&t;&t;&t;bit to skb ops.&n; *&t;&t;Alan Cox&t;:&t;Tidied tcp_data to avoid a potential &n; *&t;&t;&t;&t;&t;nasty.&n; *&t;&t;Alan Cox&t;:&t;Added some better commenting, as the &n; *&t;&t;&t;&t;&t;tcp is hard to follow&n; *&t;&t;Alan Cox&t;:&t;Removed incorrect check for 20 * psh&n; *&t;Michael O&squot;Reilly&t;:&t;ack &lt; copied bug fix.&n; *&t;Johannes Stille&t;&t;:&t;Misc tcp fixes (not all in yet).&n; *&t;&t;Alan Cox&t;:&t;FIN with no memory -&gt; CRASH&n; *&t;&t;Alan Cox&t;:&t;Added socket option proto entries. &n; *&t;&t;&t;&t;&t;Also added awareness of them to accept.&n; *&t;&t;Alan Cox&t;:&t;Added TCP options (SOL_TCP)&n; *&t;&t;Alan Cox&t;:&t;Switched wakeup calls to callbacks, &n; *&t;&t;&t;&t;&t;so the kernel can layer network &n; *&t;&t;&t;&t;&t;sockets.&n; *&t;&t;Alan Cox&t;:&t;Use ip_tos/ip_ttl settings.&n; *&t;&t;Alan Cox&t;:&t;Handle FIN (more) properly (we hope).&n; *&t;&t;Alan Cox&t;:&t;RST frames sent on unsynchronised &n; *&t;&t;&t;&t;&t;state ack error.&n; *&t;&t;Alan Cox&t;:&t;Put in missing check for SYN bit.&n; *&t;&t;Alan Cox&t;:&t;Added tcp_select_window() aka NET2E &n; *&t;&t;&t;&t;&t;window non shrink trick.&n; *&t;&t;Alan Cox&t;:&t;Added a couple of small NET2E timer &n; *&t;&t;&t;&t;&t;fixes&n; *&t;&t;Charles Hedrick :&t;TCP fixes&n; *&t;&t;Toomas Tamm&t;:&t;TCP window fixes&n; *&t;&t;Alan Cox&t;:&t;Small URG fix to rlogin ^C ack fight&n; *&t;&t;Charles Hedrick&t;:&t;Rewrote most of it to actually work&n; *&t;&t;Linus&t;&t;:&t;Rewrote tcp_read() and URG handling&n; *&t;&t;&t;&t;&t;completely&n; *&t;&t;Gerhard Koerting:&t;Fixed some missing timer handling&n; *&t;&t;Matthew Dillon  :&t;Reworked TCP machine states as per RFC&n; *&t;&t;Gerhard Koerting:&t;PC/TCP workarounds&n; *&t;&t;Adam Caldwell&t;:&t;Assorted timer/timing errors&n; *&t;&t;Matthew Dillon&t;:&t;Fixed another RST bug&n; *&t;&t;Alan Cox&t;:&t;Move to kernel side addressing changes.&n; *&t;&t;Alan Cox&t;:&t;Beginning work on TCP fastpathing &n; *&t;&t;&t;&t;&t;(not yet usable)&n; *&t;&t;Arnt Gulbrandsen:&t;Turbocharged tcp_check() routine.&n; *&t;&t;Alan Cox&t;:&t;TCP fast path debugging&n; *&t;&t;Alan Cox&t;:&t;Window clamping&n; *&t;&t;Michael Riepe&t;:&t;Bug in tcp_check()&n; *&t;&t;Matt Dillon&t;:&t;More TCP improvements and RST bug fixes&n; *&t;&t;Matt Dillon&t;:&t;Yet more small nasties remove from the&n; *&t;&t;&t;&t;&t;TCP code (Be very nice to this man if &n; *&t;&t;&t;&t;&t;tcp finally works 100%) 8)&n; *&t;&t;Alan Cox&t;:&t;BSD accept semantics. &n; *&t;&t;Alan Cox&t;:&t;Reset on closedown bug.&n; *&t;Peter De Schrijver&t;:&t;ENOTCONN check missing in tcp_sendto().&n; *&t;&t;Michael Pall&t;:&t;Handle select() after URG properly in &n; *&t;&t;&t;&t;&t;all cases.&n; *&t;&t;Michael Pall&t;:&t;Undo the last fix in tcp_read_urg() &n; *&t;&t;&t;&t;&t;(multi URG PUSH broke rlogin).&n; *&t;&t;Michael Pall&t;:&t;Fix the multi URG PUSH problem in &n; *&t;&t;&t;&t;&t;tcp_readable(), select() after URG &n; *&t;&t;&t;&t;&t;works now.&n; *&t;&t;Michael Pall&t;:&t;recv(...,MSG_OOB) never blocks in the &n; *&t;&t;&t;&t;&t;BSD api.&n; *&t;&t;Alan Cox&t;:&t;Changed the semantics of sk-&gt;socket to &n; *&t;&t;&t;&t;&t;fix a race and a signal problem with&n; *&t;&t;&t;&t;&t;accept() and async I/O.&n; *&t;&t;Alan Cox&t;:&t;Relaxed the rules on tcp_sendto().&n; *&t;&t;Yury Shevchuk&t;:&t;Really fixed accept() blocking problem.&n; *&t;&t;Craig I. Hagan  :&t;Allow for BSD compatible TIME_WAIT for&n; *&t;&t;&t;&t;&t;clients/servers which listen in on&n; *&t;&t;&t;&t;&t;fixed ports.&n; *&t;&t;Alan Cox&t;:&t;Cleaned the above up and shrank it to&n; *&t;&t;&t;&t;&t;a sensible code size.&n; *&t;&t;Alan Cox&t;:&t;Self connect lockup fix.&n; *&t;&t;Alan Cox&t;:&t;No connect to multicast.&n; *&t;&t;Ross Biro&t;:&t;Close unaccepted children on master&n; *&t;&t;&t;&t;&t;socket close.&n; *&t;&t;Alan Cox&t;:&t;Reset tracing code.&n; *&t;&t;Alan Cox&t;:&t;Spurious resets on shutdown.&n; *&t;&t;Alan Cox&t;:&t;Giant 15 minute/60 second timer error&n; *&t;&t;Alan Cox&t;:&t;Small whoops in selecting before an &n; *&t;&t;&t;&t;&t;accept.&n; *&t;&t;Alan Cox&t;:&t;Kept the state trace facility since &n; *&t;&t;&t;&t;&t;it&squot;s handy for debugging.&n; *&t;&t;Alan Cox&t;:&t;More reset handler fixes.&n; *&t;&t;Alan Cox&t;:&t;Started rewriting the code based on &n; *&t;&t;&t;&t;&t;the RFC&squot;s for other useful protocol &n; *&t;&t;&t;&t;&t;references see: Comer, KA9Q NOS, and &n; *&t;&t;&t;&t;&t;for a reference on the difference &n; *&t;&t;&t;&t;&t;between specifications and how BSD&n; *&t;&t;&t;&t;&t;works see the 4.4lite source.&n; *&t;&t;A.N.Kuznetsov&t;:&t;Don&squot;t time wait on completion of tidy &n; *&t;&t;&t;&t;&t;close.&n; *&t;&t;Linus Torvalds&t;:&t;Fin/Shutdown &amp; copied_seq changes.&n; *&t;&t;Linus Torvalds&t;:&t;Fixed BSD port reuse to work first syn&n; *&t;&t;Alan Cox&t;:&t;Reimplemented timers as per the RFC &n; *&t;&t;&t;&t;&t;and using multiple timers for sanity. &n; *&t;&t;Alan Cox&t;:&t;Small bug fixes, and a lot of new&n; *&t;&t;&t;&t;&t;comments.&n; *&t;&t;Alan Cox&t;:&t;Fixed dual reader crash by locking&n; *&t;&t;&t;&t;&t;the buffers (much like datagram.c)&n; *&t;&t;Alan Cox&t;:&t;Fixed stuck sockets in probe. A probe&n; *&t;&t;&t;&t;&t;now gets fed up of retrying without&n; *&t;&t;&t;&t;&t;(even a no space) answer.&n; *&t;&t;Alan Cox&t;:&t;Extracted closing code better&n; *&t;&t;Alan Cox&t;:&t;Fixed the closing state machine to&n; *&t;&t;&t;&t;&t;resemble the RFC.&n; *&t;&t;Alan Cox&t;:&t;More &squot;per spec&squot; fixes.&n; *&t;&t;Jorge Cwik&t;:&t;Even faster checksumming.&n; *&t;&t;Alan Cox&t;:&t;tcp_data() doesn&squot;t ack illegal PSH&n; *&t;&t;&t;&t;&t;only frames. At least one pc tcp stack&n; *&t;&t;&t;&t;&t;generates them.&n; *&t;&t;Alan Cox&t;:&t;Cache last socket.&n; *&t;&t;Alan Cox&t;:&t;Per route irtt.&n; *&t;&t;Matt Day&t;:&t;Select() match BSD precisely on error&n; *&t;&t;Alan Cox&t;:&t;New buffers&n; *&t;&t;Marc Tamsky&t;:&t;Various sk-&gt;prot-&gt;retransmits and &n; *&t;&t;&t;&t;&t;sk-&gt;retransmits misupdating fixed.&n; *&t;&t;&t;&t;&t;Fixed tcp_write_timeout: stuck close,&n; *&t;&t;&t;&t;&t;and TCP syn retries gets used now.&n; *&t;&t;Mark Yarvis&t;:&t;In tcp_read_wakeup(), don&squot;t send an&n; *&t;&t;&t;&t;&t;ack if stat is TCP_CLOSED.&n; *&t;&t;Alan Cox&t;:&t;Look up device on a retransmit - routes may&n; *&t;&t;&t;&t;&t;change. Doesn&squot;t yet cope with MSS shrink right&n; *&t;&t;&t;&t;&t;but its a start!&n; *&t;&t;Marc Tamsky&t;:&t;Closing in closing fixes.&n; *&t;&t;Mike Shaver&t;:&t;RFC1122 verifications&n; *&n; *&n; * To Fix:&n; *&t;&t;Fast path the code. Two things here - fix the window calculation&n; *&t;&t;so it doesn&squot;t iterate over the queue, also spot packets with no funny&n; *&t;&t;options arriving in order and process directly.&n; *&n; *&t;&t;Implement RFC 1191 [Path MTU discovery]&n; *&t;&t;Look at the effect of implementing RFC 1337 suggestions and their impact.&n; *&t;&t;Rewrite output state machine to use a single queue and do low window&n; *&t;&t;situations as per the spec (RFC 1122)&n; *&t;&t;Speed up input assembly algorithm.&n; *&t;&t;RFC1323 - PAWS and window scaling. PAWS is required for IPv6 so we&n; *&t;&t;could do with it working on IPv4&n; *&t;&t;User settable/learned rtt/max window/mtu&n; *&t;&t;Cope with MTU/device switches when retransmitting in tcp.&n; *&t;&t;Fix the window handling to use PR&squot;s new code.&n; *&n; *&t;&t;Change the fundamental structure to a single send queue maintained&n; *&t;&t;by TCP (removing the bogus ip stuff [thus fixing mtu drops on&n; *&t;&t;active routes too]). Cut the queue off in tcp_retransmit/&n; *&t;&t;tcp_transmit.&n; *&t;&t;Change the receive queue to assemble as it goes. This lets us&n; *&t;&t;dispose of most of tcp_sequence, half of tcp_ack and chunks of&n; *&t;&t;tcp_data/tcp_read as well as the window shrink crud.&n; *&t;&t;Separate out duplicated code - tcp_alloc_skb, tcp_build_ack&n; *&t;&t;tcp_queue_skb seem obvious routines to extract.&n; *&t;&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or(at your option) any later version.&n; *&n; * Description of States:&n; *&n; *&t;TCP_SYN_SENT&t;&t;sent a connection request, waiting for ack&n; *&n; *&t;TCP_SYN_RECV&t;&t;received a connection request, sent ack,&n; *&t;&t;&t;&t;waiting for final ack in three-way handshake.&n; *&n; *&t;TCP_ESTABLISHED&t;&t;connection established&n; *&n; *&t;TCP_FIN_WAIT1&t;&t;our side has shutdown, waiting to complete&n; *&t;&t;&t;&t;transmission of remaining buffered data&n; *&n; *&t;TCP_FIN_WAIT2&t;&t;all buffered data sent, waiting for remote&n; *&t;&t;&t;&t;to shutdown&n; *&n; *&t;TCP_CLOSING&t;&t;both sides have shutdown but we still have&n; *&t;&t;&t;&t;data we have to finish sending&n; *&n; *&t;TCP_TIME_WAIT&t;&t;timeout to catch resent junk before entering&n; *&t;&t;&t;&t;closed, can only be entered from FIN_WAIT2&n; *&t;&t;&t;&t;or CLOSING.  Required because the other end&n; *&t;&t;&t;&t;may not have gotten our last ACK causing it&n; *&t;&t;&t;&t;to retransmit the data packet (which we ignore)&n; *&n; *&t;TCP_CLOSE_WAIT&t;&t;remote side has shutdown and is waiting for&n; *&t;&t;&t;&t;us to finish writing our data and to shutdown&n; *&t;&t;&t;&t;(we have to close() to move on to LAST_ACK)&n; *&n; *&t;TCP_LAST_ACK&t;&t;out side has shutdown after remote has&n; *&t;&t;&t;&t;shutdown.  There may still be data in our&n; *&t;&t;&t;&t;buffer that we have to finish sending&n; *&t;&t;&n; *&t;TCP_CLOSE&t;&t;socket is finished&n; */
multiline_comment|/*&n; * RFC1122 status:&n; * NOTE: I&squot;m not going to be doing comments in the code for this one except&n; * for violations and the like.  tcp.c is just too big... If I say something&n; * &quot;does?&quot; or &quot;doesn&squot;t?&quot;, it means I&squot;m not sure, and will have to hash it out&n; * with Alan. -- MS 950903&n; * &n; * Use of PSH (4.2.2.2)&n; *   MAY aggregate data sent without the PSH flag. (does)&n; *   MAY queue data recieved without the PSH flag. (does)&n; *   SHOULD collapse successive PSH flags when it packetizes data. (doesn&squot;t)&n; *   MAY implement PSH on send calls. (doesn&squot;t, thus:)&n; *     MUST NOT buffer data indefinitely (doesn&squot;t [1 second])&n; *     MUST set PSH on last segment (does)&n; *   MAY pass received PSH to application layer (doesn&squot;t)&n; *   SHOULD send maximum-sized segment whenever possible. (almost always does)&n; * &n; * Window Size (4.2.2.3, 4.2.2.16)&n; *   MUST treat window size as an unsigned number (does)&n; *   SHOULD treat window size as a 32-bit number (does not)&n; *   MUST NOT shrink window once it is offered (does not normally)&n; *   &n; * Urgent Pointer (4.2.2.4)&n; * **MUST point urgent pointer to last byte of urgent data (not right&n; *     after). (doesn&squot;t, to be like BSD)&n; *   MUST inform application layer asynchronously of incoming urgent&n; *     data. (does)&n; *   MUST provide application with means of determining the amount of&n; *     urgent data pending. (does)&n; * **MUST support urgent data sequence of arbitrary length. (doesn&squot;t, but&n; *   it&squot;s sort of tricky to fix, as urg_ptr is a 16-bit quantity)&n; *&t;[Follows BSD 1 byte of urgent data]&n; * &n; * TCP Options (4.2.2.5)&n; *   MUST be able to recieve TCP options in any segment. (does)&n; *   MUST ignore unsupported options (does)&n; *   &n; * Maximum Segment Size Option (4.2.2.6)&n; *   MUST implement both sending and receiving MSS. (does)&n; *   SHOULD send an MSS with every SYN where recieve MSS != 536 (MAY send&n; *     it always). (does, even when MSS == 536, which is legal)&n; *   MUST assume MSS == 536 if no MSS received at connection setup (does)&n; *   MUST calculate &quot;effective send MSS&quot; correctly:&n; *     min(physical_MTU, remote_MSS+20) - sizeof(tcphdr) - sizeof(ipopts)&n; *     (does - but allows operator override)&n; *  &n; * TCP Checksum (4.2.2.7)&n; *   MUST generate and check TCP checksum. (does)&n; * &n; * Initial Sequence Number Selection (4.2.2.8)&n; *   MUST use the RFC 793 clock selection mechanism.  (doesn&squot;t, but it&squot;s&n; *     OK: RFC 793 specifies a 250KHz clock, while we use 1MHz, which is&n; *     necessary for 10Mbps networks - and harder than BSD to spoof!)&n; * &n; * Simultaneous Open Attempts (4.2.2.10)&n; *   MUST support simultaneous open attempts (does)&n; * &n; * Recovery from Old Duplicate SYN (4.2.2.11)&n; *   MUST keep track of active vs. passive open (does)&n; * &n; * RST segment (4.2.2.12)&n; *   SHOULD allow an RST segment to contain data (does, but doesn&squot;t do&n; *     anything with it, which is standard)&n; * &n; * Closing a Connection (4.2.2.13)&n; *   MUST inform application of whether connectin was closed by RST or&n; *     normal close. (does)&n; *   MAY allow &quot;half-duplex&quot; close (treat connection as closed for the&n; *     local app, even before handshake is done). (does)&n; *   MUST linger in TIME_WAIT for 2 * MSL (does)&n; * &n; * Retransmission Timeout (4.2.2.15)&n; *   MUST implement Jacobson&squot;s slow start and congestion avoidance&n; *     stuff. (does) &n; * &n; * Probing Zero Windows (4.2.2.17)&n; *   MUST support probing of zero windows. (does)&n; *   MAY keep offered window closed indefinitely. (does)&n; *   MUST allow remote window to stay closed indefinitely. (does)&n; * &n; * Passive Open Calls (4.2.2.18)&n; *   MUST NOT let new passive open affect other connections. (doesn&squot;t)&n; *   MUST support passive opens (LISTENs) concurrently. (does)&n; *   &n; * Time to Live (4.2.2.19)&n; *   MUST make TCP TTL configurable. (does - IP_TTL option)&n; * &n; * Event Processing (4.2.2.20)&n; *   SHOULD queue out-of-order segments. (does)&n; *   MUST aggregate ACK segments whenever possible. (does but badly)&n; *   &n; * Retransmission Timeout Calculation (4.2.3.1)&n; *   MUST implement Karn&squot;s algorithm and Jacobson&squot;s algorithm for RTO&n; *     calculation. (does, or at least explains them in the comments 8*b)&n; *  SHOULD initialize RTO to 0 and RTT to 3. (does)&n; * &n; * When to Send an ACK Segment (4.2.3.2)&n; *   SHOULD implement delayed ACK. (does not)&n; *   MUST keep ACK delay &lt; 0.5 sec. (N/A)&n; * &n; * When to Send a Window Update (4.2.3.3)&n; *   MUST implement receiver-side SWS. (does)&n; *   &n; * When to Send Data (4.2.3.4)&n; *   MUST implement sender-side SWS. (does - imperfectly)&n; *   SHOULD implement Nagle algorithm. (does)&n; * &n; * TCP Connection Failures (4.2.3.5)&n; *  MUST handle excessive retransmissions &quot;properly&quot; (see the RFC). (does)&n; *   SHOULD inform application layer of soft errors. (doesn&squot;t)&n; *   &n; * TCP Keep-Alives (4.2.3.6)&n; *   MAY provide keep-alives. (does)&n; *   MUST make keep-alives configurable on a per-connection basis. (does)&n; *   MUST default to no keep-alives. (does)&n; * **MUST make keep-alive interval configurable. (doesn&squot;t)&n; * **MUST make default keep-alive interval &gt; 2 hours. (doesn&squot;t)&n; *   MUST NOT interpret failure to ACK keep-alive packet as dead&n; *     connection. (doesn&squot;t)&n; *   SHOULD send keep-alive with no data. (does)&n; * &n; * TCP Multihoming (4.2.3.7)&n; *   MUST get source address from IP layer before sending first&n; *     SYN. (does)&n; *   MUST use same local address for all segments of a connection. (does)&n; * &n; * IP Options (4.2.3.8)&n; *   (I don&squot;t think the IP layer sees the IP options, yet.)&n; *   MUST ignore unsupported IP options. (does, I guess 8*b)&n; *   MAY support Time Stamp and Record Route. (doesn&squot;t)&n; * **MUST allow application to specify a source route. (doesn&squot;t?)&n; * **MUST allow receieved Source Route option to set route for all future&n; *     segments on this connection. (doesn&squot;t, not that I think it&squot;s a&n; *     huge problem)&n; * &n; * ICMP messages (4.2.3.9)&n; *   MUST act on ICMP errors. (does)&n; *   MUST slow transmission upon receipt of a Source Quench. (does)&n; *   MUST NOT abort connection upon receipt of soft Destination&n; *     Unreachables (0, 1, 5), Time Exceededs and Parameter&n; *     Problems. (doesn&squot;t)&n; *   SHOULD report soft Destination Unreachables etc. to the&n; *     application. (doesn&squot;t)&n; *   SHOULD abort connection upon receipt of hard Destination Unreachable&n; *     messages (2, 3, 4). (does)&n; * &n; * Remote Address Validation (4.2.3.10)&n; *   MUST reject as an error OPEN for invalid remote IP address. (does)&n; *   MUST ignore SYN with invalid source address. (does)&n; *   MUST silently discard incoming SYN for broadcast/multicast&n; *     address. (does) &n; * &n; * Asynchronous Reports (4.2.4.1)&n; * **MUST provide mechanism for reporting soft errors to application&n; *     layer. (doesn&squot;t)&n; * &n; * Type of Service (4.2.4.2)&n; *   MUST allow application layer to set Type of Service. (does IP_TOS)&n; * &n; * (Whew. -- MS 950903)&n; **/
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/termios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;net/snmp.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
multiline_comment|/*&n; *&t;The MSL timer is the &squot;normal&squot; timer.&n; */
DECL|macro|reset_msl_timer
mdefine_line|#define reset_msl_timer(x,y,z)&t;reset_timer(x,y,z)
DECL|macro|SEQ_TICK
mdefine_line|#define SEQ_TICK 3
DECL|variable|seq_offset
r_int
r_int
id|seq_offset
suffix:semicolon
DECL|variable|tcp_statistics
r_struct
id|tcp_mib
id|tcp_statistics
suffix:semicolon
multiline_comment|/*&n; *&t;Cached last hit socket&n; */
DECL|variable|th_cache_saddr
DECL|variable|th_cache_daddr
r_volatile
r_int
r_int
id|th_cache_saddr
comma
id|th_cache_daddr
suffix:semicolon
DECL|variable|th_cache_dport
DECL|variable|th_cache_sport
r_volatile
r_int
r_int
id|th_cache_dport
comma
id|th_cache_sport
suffix:semicolon
DECL|variable|th_cache_sk
r_volatile
r_struct
id|sock
op_star
id|th_cache_sk
suffix:semicolon
DECL|function|tcp_cache_zap
r_void
id|tcp_cache_zap
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|th_cache_saddr
op_assign
l_int|0
suffix:semicolon
id|th_cache_daddr
op_assign
l_int|0
suffix:semicolon
id|th_cache_dport
op_assign
l_int|0
suffix:semicolon
id|th_cache_sport
op_assign
l_int|0
suffix:semicolon
id|th_cache_sk
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
id|tcp_close
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeout
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;The less said about this the better, but it works and will do for 1.2 &n; */
DECL|variable|master_select_wakeup
r_static
r_struct
id|wait_queue
op_star
id|master_select_wakeup
suffix:semicolon
DECL|function|min
r_static
id|__inline__
r_int
id|min
c_func
(paren
r_int
r_int
id|a
comma
r_int
r_int
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
OL
id|b
)paren
r_return
id|a
suffix:semicolon
r_return
id|b
suffix:semicolon
)brace
DECL|macro|STATE_TRACE
macro_line|#undef STATE_TRACE
macro_line|#ifdef STATE_TRACE
DECL|variable|statename
r_static
r_char
op_star
id|statename
(braket
)braket
op_assign
initialization_block
suffix:semicolon
macro_line|#endif
DECL|function|tcp_set_state
r_static
id|__inline__
r_void
id|tcp_set_state
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|state
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
)paren
(brace
id|tcp_statistics.TcpCurrEstab
op_decrement
suffix:semicolon
)brace
macro_line|#ifdef STATE_TRACE
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TCP sk=%p, State %s -&gt; %s&bslash;n&quot;
comma
id|sk
comma
id|statename
(braket
id|sk-&gt;state
)braket
comma
id|statename
(braket
id|state
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif&t;
multiline_comment|/* This is a hack but it doesn&squot;t occur often and it&squot;s going to&n;&t;   be a real        to fix nicely */
r_if
c_cond
(paren
id|state
op_eq
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;state
op_eq
id|TCP_SYN_RECV
)paren
(brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|master_select_wakeup
)paren
suffix:semicolon
)brace
id|sk-&gt;state
op_assign
id|state
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|TCP_ESTABLISHED
)paren
(brace
id|tcp_statistics.TcpCurrEstab
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;This routine picks a TCP windows for a socket based on&n; *&t;the following constraints&n; *  &n; *&t;1. The window can never be shrunk once it is offered (RFC 793)&n; *&t;2. We limit memory per socket&n; *   &n; *&t;For now we use NET2E3&squot;s heuristic of offering half the memory&n; *&t;we have handy. All is not as bad as this seems however because&n; *&t;of two things. Firstly we will bin packets even within the window&n; *&t;in order to get the data we are waiting for into the memory limit.&n; *&t;Secondly we bin common duplicate forms at receive time&n; *&t;Better heuristics welcome&n; */
DECL|function|tcp_select_window
r_int
id|tcp_select_window
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|new_window
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;window_clamp
)paren
(brace
id|new_window
op_assign
id|min
c_func
(paren
id|sk-&gt;window_clamp
comma
id|new_window
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * &t;Two things are going on here.  First, we don&squot;t ever offer a&n;&t; * &t;window less than min(sk-&gt;mss, MAX_WINDOW/2).  This is the&n;&t; * &t;receiver side of SWS as specified in RFC1122.&n;&t; * &t;Second, we always give them at least the window they&n;&t; * &t;had before, in order to avoid retracting window.  This&n;&t; * &t;is technically allowed, but RFC1122 advises against it and&n;&t; * &t;in practice it causes trouble.&n;&t; *&n;&t; * &t;Fixme: This doesn&squot;t correctly handle the case where&n;&t; *&t;new_window &gt; sk-&gt;window but not by enough to allow for the&n;&t; *&t;shift in sequence space. &n;&t; */
r_if
c_cond
(paren
id|new_window
OL
id|min
c_func
(paren
id|sk-&gt;mss
comma
id|MAX_WINDOW
op_div
l_int|2
)paren
op_logical_or
id|new_window
OL
id|sk-&gt;window
)paren
r_return
id|sk-&gt;window
suffix:semicolon
r_return
id|new_window
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Find someone to &squot;accept&squot;. Must be called with&n; *&t;sk-&gt;inuse=1 or cli()&n; */
DECL|function|tcp_find_established
r_static
r_struct
id|sk_buff
op_star
id|tcp_find_established
c_func
(paren
r_struct
id|sock
op_star
id|s
)paren
(brace
r_struct
id|sk_buff
op_star
id|p
op_assign
id|skb_peek
c_func
(paren
op_amp
id|s-&gt;receive_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_do
(brace
r_if
c_cond
(paren
id|p-&gt;sk-&gt;state
op_eq
id|TCP_ESTABLISHED
op_logical_or
id|p-&gt;sk-&gt;state
op_ge
id|TCP_FIN_WAIT1
)paren
(brace
r_return
id|p
suffix:semicolon
)brace
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|p
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|s-&gt;receive_queue
)paren
(brace
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Remove a completed connection and return it. This is used by&n; *&t;tcp_accept() to get connections from the queue.&n; */
DECL|function|tcp_dequeue_established
r_static
r_struct
id|sk_buff
op_star
id|tcp_dequeue_established
c_func
(paren
r_struct
id|sock
op_star
id|s
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb
op_assign
id|tcp_find_established
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* Take it off the queue */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;This routine closes sockets which have been at least partially&n; *&t;opened, but not yet accepted. Currently it is only called by&n; *&t;tcp_close, and timeout mirrors the value there. &n; */
DECL|function|tcp_close_pending
r_static
r_void
id|tcp_close_pending
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|skb-&gt;sk-&gt;dead
op_assign
l_int|1
suffix:semicolon
id|tcp_close
c_func
(paren
id|skb-&gt;sk
comma
l_int|0
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Enter the time wait state. &n; */
DECL|function|tcp_time_wait
r_static
r_void
id|tcp_time_wait
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_TIME_WAIT
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;A socket has timed out on its send queue and wants to do a&n; *&t;little retransmitting. Currently this means TCP.&n; */
DECL|function|tcp_do_retransmit
r_void
id|tcp_do_retransmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|all
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|proto
op_star
id|prot
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
id|prot
op_assign
id|sk-&gt;prot
suffix:semicolon
id|skb
op_assign
id|sk-&gt;send_head
suffix:semicolon
r_while
c_loop
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_int
id|size
suffix:semicolon
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Discard the surplus MAC header&n;&t;&t; */
id|skb_pull
c_func
(paren
id|skb
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|skb-&gt;ip_hdr
)paren
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In general it&squot;s OK just to use the old packet.  However we&n;&t;&t; * need to use the current ack and window fields.  Urg and&n;&t;&t; * urg_ptr could possibly stand to be updated as well, but we&n;&t;&t; * don&squot;t keep the necessary data.  That shouldn&squot;t be a problem,&n;&t;&t; * if the other end is doing the right thing.  Since we&squot;re&n;&t;&t; * changing the packet, we have to issue a new IP identifier.&n;&t;&t; */
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb-&gt;data
suffix:semicolon
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|iph
)paren
op_plus
(paren
id|iph-&gt;ihl
op_lshift
l_int|2
)paren
)paren
suffix:semicolon
id|size
op_assign
id|ntohs
c_func
(paren
id|iph-&gt;tot_len
)paren
op_minus
(paren
id|iph-&gt;ihl
op_lshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Note: We ought to check for window limits here but&n;&t;&t; *&t;currently this is done (less efficiently) elsewhere.&n;&t;&t; */
id|iph-&gt;id
op_assign
id|htons
c_func
(paren
id|ip_id_count
op_increment
)paren
suffix:semicolon
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Put a MAC header back on (may cause ARPing)&n;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;localroute
)paren
(brace
id|rt
op_assign
id|ip_rt_local
c_func
(paren
id|iph-&gt;daddr
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
id|rt
op_assign
id|ip_rt_route
c_func
(paren
id|iph-&gt;daddr
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
multiline_comment|/* Deep poo */
(brace
r_if
c_cond
(paren
id|skb-&gt;sk
)paren
(brace
id|skb-&gt;sk-&gt;err
op_assign
id|ENETUNREACH
suffix:semicolon
id|skb-&gt;sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|skb-&gt;sk
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|dev
op_assign
id|rt-&gt;rt_dev
suffix:semicolon
id|skb-&gt;raddr
op_assign
id|rt-&gt;rt_gateway
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;raddr
op_eq
l_int|0
)paren
(brace
id|skb-&gt;raddr
op_assign
id|iph-&gt;daddr
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;hard_header
)paren
(brace
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|skb
comma
id|dev
comma
id|ETH_P_IP
comma
l_int|NULL
comma
l_int|NULL
comma
id|skb-&gt;len
)paren
OL
l_int|0
)paren
(brace
id|skb-&gt;arp
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;This is not the right way to handle this. We have to&n;&t;&t;&t; *&t;issue an up to date window and ack report with this &n;&t;&t;&t; *&t;retransmit to keep the odd buggy tcp that relies on &n;&t;&t;&t; *&t;the fact BSD does this happy. &n;&t;&t;&t; *&t;We don&squot;t however need to recalculate the entire &n;&t;&t;&t; *&t;checksum, so someone wanting a small problem to play&n;&t;&t;&t; *&t;with might like to implement RFC1141/RFC1624 and speed&n;&t;&t;&t; *&t;this up by avoiding a full checksum.&n;&t;&t;&t; */
id|th-&gt;ack_seq
op_assign
id|ntohl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|th-&gt;window
op_assign
id|ntohs
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|th
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
id|size
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;If the interface is (still) up and running, kick it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;If the packet is still being sent by the device/protocol&n;&t;&t;&t;&t; *&t;below then don&squot;t retransmit. This is both needed, and good -&n;&t;&t;&t;&t; *&t;especially with connected mode AX.25 where it stops resends&n;&t;&t;&t;&t; *&t;occurring of an as yet unsent anyway frame!&n;&t;&t;&t;&t; *&t;We still add up the counts as the round trip time wants&n;&t;&t;&t;&t; *&t;adjusting.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|sk
op_logical_and
op_logical_neg
id|skb_device_locked
c_func
(paren
id|skb
)paren
)paren
(brace
multiline_comment|/* Remove it from any existing driver queue first! */
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Now queue it */
id|ip_statistics.IpOutRequests
op_increment
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
id|sk-&gt;priority
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; *&t;Count retransmissions&n;&t;&t; */
id|ct
op_increment
suffix:semicolon
id|sk-&gt;prot-&gt;retransmits
op_increment
suffix:semicolon
id|tcp_statistics.TcpRetransSegs
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Only one retransmit requested.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|all
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;This should cut it off before we send too many packets.&n;&t;&t; */
r_if
c_cond
(paren
id|ct
op_ge
id|sk-&gt;cong_window
)paren
r_break
suffix:semicolon
id|skb
op_assign
id|skb-&gt;link3
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Reset the retransmission timer&n; */
DECL|function|reset_xmit_timer
r_static
r_void
id|reset_xmit_timer
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|why
comma
r_int
r_int
id|when
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;retransmit_timer
)paren
suffix:semicolon
id|sk-&gt;ip_xmit_timeout
op_assign
id|why
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|when
OL
l_int|0
)paren
(brace
id|when
op_assign
l_int|3
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Error: Negative timer in xmit_timer&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|sk-&gt;retransmit_timer.expires
op_assign
id|jiffies
op_plus
id|when
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;retransmit_timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;This is the normal code called for timeouts.  It does the retransmission&n; * &t;and then does backoff.  tcp_do_retransmit is separated out because&n; * &t;tcp_ack needs to send stuff from the retransmit queue without&n; * &t;initiating a backoff.&n; */
DECL|function|tcp_retransmit_time
r_void
id|tcp_retransmit_time
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|all
)paren
(brace
id|tcp_do_retransmit
c_func
(paren
id|sk
comma
id|all
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Increase the timeout each time we retransmit.  Note that&n;&t; * we do not increase the rtt estimate.  rto is initialized&n;&t; * from rtt, but increases here.  Jacobson (SIGCOMM 88) suggests&n;&t; * that doubling rto each time is the least we can get away with.&n;&t; * In KA9Q, Karn uses this for the first few times, and then&n;&t; * goes to quadratic.  netBSD doubles, but only goes up to *64,&n;&t; * and clamps at 1 to 64 sec afterwards.  Note that 120 sec is&n;&t; * defined in the protocol as the maximum possible RTT.  I guess&n;&t; * we&squot;ll have to use something other than TCP to talk to the&n;&t; * University of Mars.&n;&t; *&n;&t; * PAWS allows us longer timeouts and large windows, so once&n;&t; * implemented ftp to mars will work nicely. We will have to fix&n;&t; * the 120 second clamps though!&n;&t; */
id|sk-&gt;retransmits
op_increment
suffix:semicolon
id|sk-&gt;prot-&gt;retransmits
op_increment
suffix:semicolon
id|sk-&gt;backoff
op_increment
suffix:semicolon
id|sk-&gt;rto
op_assign
id|min
c_func
(paren
id|sk-&gt;rto
op_lshift
l_int|1
comma
l_int|120
op_star
id|HZ
)paren
suffix:semicolon
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;A timer event has trigger a tcp retransmit timeout. The&n; *&t;socket xmit queue is ready and set up to send. Because&n; *&t;the ack receive code keeps the queue straight we do&n; *&t;nothing clever here.&n; */
DECL|function|tcp_retransmit
r_static
r_void
id|tcp_retransmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|all
)paren
(brace
r_if
c_cond
(paren
id|all
)paren
(brace
id|tcp_retransmit_time
c_func
(paren
id|sk
comma
id|all
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sk-&gt;ssthresh
op_assign
id|sk-&gt;cong_window
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/* remember window where we lost */
multiline_comment|/* sk-&gt;ssthresh in theory can be zero.  I guess that&squot;s OK */
id|sk-&gt;cong_count
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;cong_window
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Do the actual retransmit. */
id|tcp_retransmit_time
c_func
(paren
id|sk
comma
id|all
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;A write timeout has occurred. Process the after effects.&n; */
DECL|function|tcp_write_timeout
r_static
r_int
id|tcp_write_timeout
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
multiline_comment|/*&n;&t; *&t;Look for a &squot;soft&squot; timeout.&n;&t; */
r_if
c_cond
(paren
(paren
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;retransmits
op_logical_and
op_logical_neg
(paren
id|sk-&gt;retransmits
op_amp
l_int|7
)paren
)paren
op_logical_or
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;retransmits
OG
id|TCP_RETR1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Attempt to recover if arp has changed (unlikely!) or&n;&t;&t; *&t;a route has shifted (not supported prior to 1.3).&n;&t;&t; */
id|arp_destroy
(paren
id|sk-&gt;daddr
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*ip_route_check (sk-&gt;daddr);*/
)brace
multiline_comment|/*&n;&t; *&t;Have we tried to SYN too many times (repent repent 8))&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;retransmits
OG
id|TCP_SYN_RETRIES
op_logical_and
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
)paren
(brace
id|sk-&gt;err
op_assign
id|ETIMEDOUT
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;retransmit_timer
)paren
suffix:semicolon
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
multiline_comment|/* Is this right ??? - FIXME - */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t FIN, we got nothing back */
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Has it gone just too far ?&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;retransmits
OG
id|TCP_RETR2
)paren
(brace
id|sk-&gt;err
op_assign
id|ETIMEDOUT
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;retransmit_timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Time wait the socket &n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT1
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT2
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_CLOSING
)paren
(brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_TIME_WAIT
)paren
suffix:semicolon
id|reset_msl_timer
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Clean up time.&n;&t;&t;&t; */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The TCP retransmit timer. This lacks a few small details.&n; *&n; *&t;1. &t;An initial rtt timeout on the probe0 should cause what we can&n; *&t;&t;of the first write queue buffer to be split and sent.&n; *&t;2.&t;On a &squot;major timeout&squot; as defined by RFC1122 we shouldn&squot;t report&n; *&t;&t;ETIMEDOUT if we know an additional &squot;soft&squot; error caused this.&n; *&t;&t;tcp_err should save a &squot;soft error&squot; for us.&n; */
DECL|function|retransmit_timer
r_static
r_void
id|retransmit_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
r_int
id|why
op_assign
id|sk-&gt;ip_xmit_timeout
suffix:semicolon
multiline_comment|/* &n;&t; * only process if socket is not in use&n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;inuse
op_logical_or
id|in_bh
)paren
(brace
multiline_comment|/* Try again in 1 second */
id|sk-&gt;retransmit_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;retransmit_timer
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Always see if we need to send an ack. */
r_if
c_cond
(paren
id|sk-&gt;ack_backlog
op_logical_and
op_logical_neg
id|sk-&gt;zapped
)paren
(brace
id|sk-&gt;prot-&gt;read_wakeup
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Now we need to figure out why the socket was on the timer. */
r_switch
c_cond
(paren
id|why
)paren
(brace
multiline_comment|/* Window probing */
r_case
id|TIME_PROBE0
suffix:colon
id|tcp_send_probe0
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_write_timeout
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Retransmitting */
r_case
id|TIME_WRITE
suffix:colon
multiline_comment|/* It could be we got here because we needed to send an ack.&n;&t;&t;&t; * So we need to check for that.&n;&t;&t;&t; */
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb
op_assign
id|sk-&gt;send_head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Kicked by a delayed ack. Reset timer&n;&t;&t;&t;&t; *&t;correctly now&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|jiffies
OL
id|skb-&gt;when
op_plus
id|sk-&gt;rto
)paren
(brace
id|reset_xmit_timer
(paren
id|sk
comma
id|TIME_WRITE
comma
id|skb-&gt;when
op_plus
id|sk-&gt;rto
op_minus
id|jiffies
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Retransmission&n;&t;&t;&t;&t; */
id|sk-&gt;retransmits
op_increment
suffix:semicolon
id|sk-&gt;prot-&gt;retransmits
op_increment
suffix:semicolon
id|sk-&gt;prot-&gt;retransmit
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
id|tcp_write_timeout
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Sending Keepalives */
r_case
id|TIME_KEEPOPEN
suffix:colon
multiline_comment|/* &n;&t;&t;&t; * this reset_timer() call is a hack, this is not&n;&t;&t;&t; * how KEEPOPEN is supposed to work.&n;&t;&t;&t; */
id|reset_xmit_timer
(paren
id|sk
comma
id|TIME_KEEPOPEN
comma
id|TCP_TIMEOUT_LEN
)paren
suffix:semicolon
multiline_comment|/* Send something to keep the connection open. */
r_if
c_cond
(paren
id|sk-&gt;prot-&gt;write_wakeup
)paren
id|sk-&gt;prot-&gt;write_wakeup
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;retransmits
op_increment
suffix:semicolon
id|sk-&gt;prot-&gt;retransmits
op_increment
suffix:semicolon
id|tcp_write_timeout
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;rexmit_timer: timer expired - reason unknown&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called by the ICMP module when it gets some&n; * sort of error condition.  If err &lt; 0 then the socket should&n; * be closed and the error returned to the user.  If err &gt; 0&n; * it&squot;s just the icmp type &lt;&lt; 8 | icmp code.  After adjustment&n; * header points to the first 8 bytes of the tcp header.  We need&n; * to find the appropriate port.&n; */
DECL|function|tcp_err
r_void
id|tcp_err
c_func
(paren
r_int
id|err
comma
r_int
r_char
op_star
id|header
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|saddr
comma
r_struct
id|inet_protocol
op_star
id|protocol
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|header
suffix:semicolon
id|header
op_add_assign
l_int|4
op_star
id|iph-&gt;ihl
suffix:semicolon
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|header
suffix:semicolon
id|sk
op_assign
id|get_sock
c_func
(paren
op_amp
id|tcp_prot
comma
id|th-&gt;source
comma
id|daddr
comma
id|th-&gt;dest
comma
id|saddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|sk-&gt;err
op_assign
op_minus
id|err
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_amp
l_int|0xff00
)paren
op_eq
(paren
id|ICMP_SOURCE_QUENCH
op_lshift
l_int|8
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * FIXME:&n;&t;&t; * For now we will just trigger a linear backoff.&n;&t;&t; * The slow start code should cause a real backoff here.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;cong_window
OG
l_int|4
)paren
id|sk-&gt;cong_window
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we&squot;ve already connected we will keep trying&n;&t; * until we time out, or the user gives up.&n;&t; */
id|err
op_and_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|13
op_logical_and
(paren
id|icmp_err_convert
(braket
id|err
)braket
dot
id|fatal
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
)paren
)paren
(brace
id|sk-&gt;err
op_assign
id|icmp_err_convert
(braket
id|err
)braket
dot
id|errno
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
)paren
(brace
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Wake people up to see the error (see connect in sock.c) */
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Walk down the receive queue counting readable data until we hit the end or we find a gap&n; *&t;in the received data queue (ie a frame missing that needs sending to us). Not&n; *&t;sorting using two queues as data arrives makes life so much harder.&n; */
DECL|function|tcp_readable
r_static
r_int
id|tcp_readable
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
r_int
id|counted
suffix:semicolon
r_int
r_int
id|amount
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|sum
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_logical_and
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tcp_readable: %p - &quot;
comma
id|sk
)paren
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
op_logical_or
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_logical_and
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;empty&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|counted
op_assign
id|sk-&gt;copied_seq
suffix:semicolon
multiline_comment|/* Where we are at the moment */
id|amount
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t; *&t;Do until a push or until we are out of data. &n;&t; */
r_do
(brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|counted
comma
id|skb-&gt;h.th-&gt;seq
)paren
)paren
multiline_comment|/* Found a hole so stops here */
r_break
suffix:semicolon
id|sum
op_assign
id|skb-&gt;len
op_minus
(paren
id|counted
op_minus
id|skb-&gt;h.th-&gt;seq
)paren
suffix:semicolon
multiline_comment|/* Length - header but start from where we are up to (avoid overlaps) */
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;syn
)paren
id|sum
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sum
OG
l_int|0
)paren
(brace
multiline_comment|/* Add it up, move on */
id|amount
op_add_assign
id|sum
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;syn
)paren
id|amount
op_decrement
suffix:semicolon
id|counted
op_add_assign
id|sum
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Don&squot;t count urg data ... but do it in the right place!&n;&t;&t; * Consider: &quot;old_data (ptr is here) URG PUSH data&quot;&n;&t;&t; * The old code would stop at the first push because&n;&t;&t; * it counted the urg (amount==1) and then does amount--&n;&t;&t; * *after* the loop.  This means tcp_readable() always&n;&t;&t; * returned zero if any URG PUSH was in the queue, even&n;&t;&t; * though there was normal data available. If we subtract&n;&t;&t; * the urg data right here, we even get it to work for more&n;&t;&t; * than one URG PUSH skb without normal data.&n;&t;&t; * This means that select() finally works now with urg data&n;&t;&t; * in the queue.  Note that rlogin was never affected&n;&t;&t; * because it doesn&squot;t use select(); it uses two processes&n;&t;&t; * and a blocking read().  And the queue scan in tcp_read()&n;&t;&t; * was correct.  Mike &lt;pall@rz.uni-karlsruhe.de&gt;&n;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;urg
)paren
id|amount
op_decrement
suffix:semicolon
multiline_comment|/* don&squot;t count urg data */
r_if
c_cond
(paren
id|amount
op_logical_and
id|skb-&gt;h.th-&gt;psh
)paren
r_break
suffix:semicolon
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;receive_queue
)paren
(brace
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;got %lu bytes.&bslash;n&quot;
comma
id|amount
)paren
suffix:semicolon
)brace
r_return
id|amount
suffix:semicolon
)brace
multiline_comment|/*&n; * LISTEN is a special case for select..&n; */
DECL|function|tcp_listen_select
r_static
r_int
id|tcp_listen_select
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
(brace
r_if
c_cond
(paren
id|sel_type
op_eq
id|SEL_IN
)paren
(brace
r_int
id|retval
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|retval
op_assign
(paren
id|tcp_find_established
c_func
(paren
id|sk
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|select_wait
c_func
(paren
op_amp
id|master_select_wakeup
comma
id|wait
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Wait for a TCP event.&n; *&n; *&t;Note that we don&squot;t need to set &quot;sk-&gt;inuse&quot;, as the upper select layers&n; *&t;take care of normal races (between the test and the event) and we don&squot;t&n; *&t;go look at any of the socket buffers directly.&n; */
DECL|function|tcp_select
r_static
r_int
id|tcp_select
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
id|tcp_listen_select
c_func
(paren
id|sk
comma
id|sel_type
comma
id|wait
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sel_type
)paren
(brace
r_case
id|SEL_IN
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_SYN_RECV
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;acked_seq
op_eq
id|sk-&gt;copied_seq
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;urg_seq
op_ne
id|sk-&gt;copied_seq
op_logical_or
id|sk-&gt;acked_seq
op_ne
id|sk-&gt;copied_seq
op_plus
l_int|1
op_logical_or
id|sk-&gt;urginline
op_logical_or
op_logical_neg
id|sk-&gt;urg_data
)paren
r_return
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SEL_OUT
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_SYN_RECV
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This is now right thanks to a small fix&n;&t;&t; * by Matt Dillon.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;prot
op_member_access_from_pointer
id|wspace
c_func
(paren
id|sk
)paren
OL
id|sk-&gt;mtu
op_plus
l_int|128
op_plus
id|sk-&gt;prot-&gt;max_header
)paren
r_break
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
id|SEL_EX
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;urg_data
)paren
r_return
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|select_wait
c_func
(paren
id|sk-&gt;sleep
comma
id|wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tcp_ioctl
r_int
id|tcp_ioctl
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCINQ
suffix:colon
macro_line|#ifdef FIXME&t;/* FIXME: */
r_case
id|FIONREAD
suffix:colon
macro_line|#endif
(brace
r_int
r_int
id|amount
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|amount
op_assign
id|tcp_readable
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_user
c_func
(paren
id|amount
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|SIOCATMARK
suffix:colon
(brace
r_int
id|answ
op_assign
id|sk-&gt;urg_data
op_logical_and
id|sk-&gt;urg_seq
op_eq
id|sk-&gt;copied_seq
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|put_user
c_func
(paren
id|answ
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|TIOCOUTQ
suffix:colon
(brace
r_int
r_int
id|amount
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|amount
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wspace
c_func
(paren
id|sk
)paren
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_user
c_func
(paren
id|amount
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;This routine computes a TCP checksum. &n; *&n; *&t;Modified January 1995 from a go-faster DOS routine by&n; *&t;Jorge Cwik &lt;jorge@laser.satlink.net&gt;&n; */
DECL|function|tcp_check
r_int
r_int
id|tcp_check
c_func
(paren
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|base
)paren
(brace
r_return
id|csum_tcpudp_magic
c_func
(paren
id|saddr
comma
id|daddr
comma
id|len
comma
id|IPPROTO_TCP
comma
id|base
)paren
suffix:semicolon
)brace
DECL|function|tcp_send_check
r_void
id|tcp_send_check
c_func
(paren
r_struct
id|tcphdr
op_star
id|th
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
comma
r_int
id|len
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|th-&gt;check
op_assign
l_int|0
suffix:semicolon
id|th-&gt;check
op_assign
id|tcp_check
c_func
(paren
id|th
comma
id|len
comma
id|saddr
comma
id|daddr
comma
id|csum_partial
c_func
(paren
(paren
r_char
op_star
)paren
id|th
comma
id|len
comma
l_int|0
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is the main buffer sending routine. We queue the buffer&n; *&t;having checked it is sane seeming.&n; */
DECL|function|tcp_send_skb
r_static
r_void
id|tcp_send_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|size
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
multiline_comment|/*&n;&t; *&t;length of packet (not counting length of pre-tcp headers) &n;&t; */
id|size
op_assign
id|skb-&gt;len
op_minus
(paren
(paren
r_int
r_char
op_star
)paren
id|th
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Sanity check it.. &n;&t; */
r_if
c_cond
(paren
id|size
template_param
id|skb-&gt;len
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tcp_send_skb: bad skb (skb = %p, data = %p, th = %p, len = %lu)&bslash;n&quot;
comma
id|skb
comma
id|skb-&gt;data
comma
id|th
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If we have queued a header size packet.. (these crash a few&n;&t; *&t;tcp stacks if ack is not set)&n;&t; */
r_if
c_cond
(paren
id|size
op_eq
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
(brace
multiline_comment|/* If it&squot;s got a syn or fin it&squot;s notionally included in the size..*/
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;syn
op_logical_and
op_logical_neg
id|th-&gt;fin
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tcp_send_skb: attempt to queue a bogon.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Actual processing.&n;&t; */
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
id|skb-&gt;h.seq
op_assign
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
op_plus
id|size
op_minus
l_int|4
op_star
id|th-&gt;doff
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We must queue if&n;&t; *&n;&t; *&t;a) The right edge of this frame exceeds the window&n;&t; *&t;b) We are retransmitting (Nagle&squot;s rule)&n;&t; *&t;c) We have too many packets &squot;in flight&squot;&n;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|skb-&gt;h.seq
comma
id|sk-&gt;window_seq
)paren
op_logical_or
(paren
id|sk-&gt;retransmits
op_logical_and
id|sk-&gt;ip_xmit_timeout
op_eq
id|TIME_WRITE
)paren
op_logical_or
id|sk-&gt;packets_out
op_ge
id|sk-&gt;cong_window
)paren
(brace
multiline_comment|/* checksum will be supplied by tcp_write_xmit.  So&n;&t;&t; * we shouldn&squot;t need to set it at all.  I&squot;m being paranoid */
id|th-&gt;check
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tcp_send_partial: next != NULL&bslash;n&quot;
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;If we don&squot;t fit we have to start the zero window&n;&t;&t; *&t;probes. This is broken - we really need to do a partial&n;&t;&t; *&t;send _first_ (This is what causes the Cisco and PC/TCP&n;&t;&t; *&t;grief).&n;&t;&t; */
r_if
c_cond
(paren
id|before
c_func
(paren
id|sk-&gt;window_seq
comma
id|sk-&gt;write_queue.next-&gt;h.seq
)paren
op_logical_and
id|sk-&gt;send_head
op_eq
l_int|NULL
op_logical_and
id|sk-&gt;ack_backlog
op_eq
l_int|0
)paren
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; *&t;This is going straight out&n;&t;&t; */
id|th-&gt;ack_seq
op_assign
id|ntohl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|th-&gt;window
op_assign
id|ntohs
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|th
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
id|size
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;sent_seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;This is mad. The tcp retransmit queue is put together&n;&t;&t; *&t;by the ip layer. This causes half the problems with&n;&t;&t; *&t;unroutable FIN&squot;s and other things.&n;&t;&t; */
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|skb-&gt;dev
comma
id|skb
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Set for next retransmit based on expected ACK time.&n;&t;&t; *&t;FIXME: We set this every time which means our &n;&t;&t; *&t;retransmits are really about a window behind.&n;&t;&t; */
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Locking problems lead us to a messy situation where we can have&n; *&t;multiple partially complete buffers queued up. This is really bad&n; *&t;as we don&squot;t want to be sending partial buffers. Fix this with&n; *&t;a semaphore or similar to lock tcp_write per socket.&n; *&n; *&t;These routines are pretty self descriptive.&n; */
DECL|function|tcp_dequeue_partial
r_struct
id|sk_buff
op_star
id|tcp_dequeue_partial
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb
op_assign
id|sk-&gt;partial
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
id|sk-&gt;partial
op_assign
l_int|NULL
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;partial_timer
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Empty the partial queue&n; */
DECL|function|tcp_send_partial
r_static
r_void
id|tcp_send_partial
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|tcp_dequeue_partial
c_func
(paren
id|sk
)paren
)paren
op_ne
l_int|NULL
)paren
id|tcp_send_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Queue a partial frame&n; */
DECL|function|tcp_enqueue_partial
r_void
id|tcp_enqueue_partial
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|tmp
op_assign
id|sk-&gt;partial
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;partial_timer
)paren
suffix:semicolon
id|sk-&gt;partial
op_assign
id|skb
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|sk-&gt;partial_timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Wait up to 1 second for the buffer to fill.&n;&t; */
id|sk-&gt;partial_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|sk-&gt;partial_timer.function
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|tcp_send_partial
suffix:semicolon
id|sk-&gt;partial_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;partial_timer
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
id|tcp_send_skb
c_func
(paren
id|sk
comma
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine sends an ack and also updates the window. &n; */
DECL|function|tcp_send_ack
r_static
r_void
id|tcp_send_ack
c_func
(paren
id|u32
id|sequence
comma
id|u32
id|ack
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
r_int
id|daddr
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* We have been reset, we may not send again */
multiline_comment|/*&n;&t; * We need to grab some memory, and put together an ack,&n;&t; * and then put it into the queue to be sent.&n;&t; */
id|buff
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|MAX_ACK_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* &n;&t;&t; *&t;Force it to send an ack. We don&squot;t have to do this&n;&t;&t; *&t;(ACK is unreliable) but it&squot;s much better use of &n;&t;&t; *&t;bandwidth on slow links to send a spare ack than&n;&t;&t; *&t;resend packets. &n;&t;&t; */
id|sk-&gt;ack_backlog
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;ip_xmit_timeout
op_ne
id|TIME_WRITE
op_logical_and
id|tcp_connected
c_func
(paren
id|sk-&gt;state
)paren
)paren
(brace
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|HZ
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Assemble a suitable TCP frame&n;&t; */
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|buff-&gt;localroute
op_assign
id|sk-&gt;localroute
suffix:semicolon
multiline_comment|/* &n;&t; *&t;Put in the IP header and routing stuff. &n;&t; */
id|tmp
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|MAX_ACK_SIZE
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
id|th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Swap the send and the receive. &n;&t; */
id|t1-&gt;dest
op_assign
id|th-&gt;source
suffix:semicolon
id|t1-&gt;source
op_assign
id|th-&gt;dest
suffix:semicolon
id|t1-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|sequence
)paren
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;window
op_assign
id|tcp_select_window
c_func
(paren
id|sk
)paren
suffix:semicolon
id|t1-&gt;window
op_assign
id|ntohs
c_func
(paren
id|sk-&gt;window
)paren
suffix:semicolon
id|t1-&gt;res1
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;res2
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;syn
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;fin
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If we have nothing queued for transmit and the transmit timer&n;&t; *&t;is on we are just doing an ACK timeout and need to switch&n;&t; *&t;to a keepalive.&n;&t; */
r_if
c_cond
(paren
id|ack
op_eq
id|sk-&gt;acked_seq
)paren
(brace
id|sk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;bytes_rcv
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ack_timed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;send_head
op_eq
l_int|NULL
op_logical_and
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_eq
l_int|NULL
op_logical_and
id|sk-&gt;ip_xmit_timeout
op_eq
id|TIME_WRITE
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;keepopen
)paren
(brace
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_KEEPOPEN
comma
id|TCP_TIMEOUT_LEN
)paren
suffix:semicolon
)brace
r_else
(brace
id|delete_timer
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;  &t; *&t;Fill in the packet and send it&n;  &t; */
id|t1-&gt;ack_seq
op_assign
id|ntohl
c_func
(paren
id|ack
)paren
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;rtcp_ack: seq %x ack %x&bslash;n&quot;
comma
id|sequence
comma
id|ack
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;This routine builds a generic TCP header. &n; */
DECL|function|tcp_build_header
r_extern
id|__inline
r_int
id|tcp_build_header
c_func
(paren
r_struct
id|tcphdr
op_star
id|th
comma
r_struct
id|sock
op_star
id|sk
comma
r_int
id|push
)paren
(brace
id|memcpy
c_func
(paren
id|th
comma
(paren
r_void
op_star
)paren
op_amp
(paren
id|sk-&gt;dummy_th
)paren
comma
r_sizeof
(paren
op_star
id|th
)paren
)paren
suffix:semicolon
id|th-&gt;seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;write_seq
)paren
suffix:semicolon
id|th-&gt;psh
op_assign
(paren
id|push
op_eq
l_int|0
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|th-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|th
)paren
op_div
l_int|4
suffix:semicolon
id|th-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|th-&gt;fin
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;bytes_rcv
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ack_timed
op_assign
l_int|0
suffix:semicolon
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|sk-&gt;window
op_assign
id|tcp_select_window
c_func
(paren
id|sk
)paren
suffix:semicolon
id|th-&gt;window
op_assign
id|htons
c_func
(paren
id|sk-&gt;window
)paren
suffix:semicolon
r_return
r_sizeof
(paren
op_star
id|th
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine copies from a user buffer into a socket,&n; *&t;and starts the transmit system.&n; */
DECL|function|tcp_write
r_static
r_int
id|tcp_write
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_const
r_int
r_char
op_star
id|from
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
)paren
(brace
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
r_int
id|copy
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|sk_buff
op_star
id|send_tmp
suffix:semicolon
r_struct
id|proto
op_star
id|prot
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|prot
op_assign
id|sk-&gt;prot
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;err
)paren
(brace
multiline_comment|/* Stop on an error */
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
id|tmp
op_assign
op_minus
id|sk-&gt;err
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;First thing we do is make sure that we are established. &n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;err
op_assign
id|EPIPE
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; *&t;Wait for a connection to finish.&n;&t;&t; */
r_while
c_loop
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_CLOSE_WAIT
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;err
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
id|tmp
op_assign
op_minus
id|sk-&gt;err
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_SYN_SENT
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_SYN_RECV
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
(brace
id|tmp
op_assign
op_minus
id|sk-&gt;err
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;keepopen
)paren
(brace
id|send_sig
c_func
(paren
id|SIGPIPE
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nonblock
op_logical_or
id|copied
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_CLOSE_WAIT
op_logical_and
id|sk-&gt;err
op_eq
l_int|0
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The following code can result in copy &lt;= if sk-&gt;mss is ever&n;&t; * decreased.  It shouldn&squot;t be.  sk-&gt;mss is min(sk-&gt;mtu, sk-&gt;max_window).&n;&t; * sk-&gt;mtu is constant once SYN processing is finished.  I.e. we&n;&t; * had better not get here until we&squot;ve seen his SYN and at least one&n;&t; * valid ack.  (The SYN sets sk-&gt;mtu and the ack sets sk-&gt;max_window.)&n;&t; * But ESTABLISHED should guarantee that.  sk-&gt;max_window is by definition&n;&t; * non-decreasing.  Note that any ioctl to set user_mss must be done&n;&t; * before the exchange of SYN&squot;s.  If the initial ack from the other&n;&t; * end has a window of 0, max_window and thus mss will both be 0.&n;&t; */
multiline_comment|/* &n;&t; *&t;Now we need to check if we have a half built packet. &n;&t; */
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|tcp_dequeue_partial
c_func
(paren
id|sk
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|hdrlen
suffix:semicolon
multiline_comment|/* IP header + TCP header */
id|hdrlen
op_assign
(paren
(paren
r_int
r_int
)paren
id|skb-&gt;h.th
op_minus
(paren
r_int
r_int
)paren
id|skb-&gt;data
)paren
op_plus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
multiline_comment|/* Add more stuff to the end of skb-&gt;len */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_OOB
)paren
)paren
(brace
id|copy
op_assign
id|min
c_func
(paren
id|sk-&gt;mss
op_minus
(paren
id|skb-&gt;len
op_minus
id|hdrlen
)paren
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* FIXME: this is really a bug. */
r_if
c_cond
(paren
id|copy
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TCP: **bug**: &bslash;&quot;copy&bslash;&quot; &lt;= 0!!&bslash;n&quot;
)paren
suffix:semicolon
id|copy
op_assign
l_int|0
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|copy
)paren
comma
id|from
comma
id|copy
)paren
suffix:semicolon
id|from
op_add_assign
id|copy
suffix:semicolon
id|copied
op_add_assign
id|copy
suffix:semicolon
id|len
op_sub_assign
id|copy
suffix:semicolon
id|sk-&gt;write_seq
op_add_assign
id|copy
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|skb-&gt;len
op_minus
id|hdrlen
)paren
op_ge
id|sk-&gt;mss
op_logical_or
(paren
id|flags
op_amp
id|MSG_OOB
)paren
op_logical_or
op_logical_neg
id|sk-&gt;packets_out
)paren
id|tcp_send_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_else
id|tcp_enqueue_partial
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We also need to worry about the window.&n; &t; * If window &lt; 1/2 the maximum window we&squot;ve seen from this&n; &t; *   host, don&squot;t use it.  This is sender side&n; &t; *   silly window prevention, as specified in RFC1122.&n; &t; *   (Note that this is different than earlier versions of&n; &t; *   SWS prevention, e.g. RFC813.).  What we actually do is &n;&t; *   use the whole MSS.  Since the results in the right&n;&t; *   edge of the packet being outside the window, it will&n;&t; *   be queued for later rather than sent.&n;&t; */
id|copy
op_assign
id|sk-&gt;window_seq
op_minus
id|sk-&gt;write_seq
suffix:semicolon
r_if
c_cond
(paren
id|copy
op_le
l_int|0
op_logical_or
id|copy
template_param
id|sk-&gt;mss
)paren
id|copy
op_assign
id|sk-&gt;mss
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We should really check the window here also. &n;&t; */
id|send_tmp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|copy
OL
id|sk-&gt;mss
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|MSG_OOB
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;We will release the socket in case we sleep here. &n;&t;&t;&t; */
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;NB: following must be mtu, because mss can be increased.&n;&t;&t;&t; *&t;mss is always &lt;= mtu &n;&t;&t;&t; */
id|skb
op_assign
id|prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|sk-&gt;mtu
op_plus
l_int|128
op_plus
id|prot-&gt;max_header
op_plus
l_int|15
comma
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|send_tmp
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;We will release the socket in case we sleep here. &n;&t;&t;&t; */
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|skb
op_assign
id|prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|copy
op_plus
id|prot-&gt;max_header
op_plus
l_int|15
comma
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;If we didn&squot;t get any memory, we need to sleep. &n;&t;&t; */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;socket-&gt;flags
op_or_assign
id|SO_NOSPACE
suffix:semicolon
r_if
c_cond
(paren
id|nonblock
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;FIXME: here is another race condition. &n;&t;&t;&t; */
id|tmp
op_assign
id|sk-&gt;wmem_alloc
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Again we will try to avoid it. &n;&t;&t;&t; */
r_if
c_cond
(paren
id|tmp
op_le
id|sk-&gt;wmem_alloc
op_logical_and
(paren
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_CLOSE_WAIT
)paren
op_logical_and
id|sk-&gt;err
op_eq
l_int|0
)paren
(brace
id|sk-&gt;socket-&gt;flags
op_and_assign
op_complement
id|SO_NOSPACE
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;localroute
op_assign
id|sk-&gt;localroute
op_or
(paren
id|flags
op_amp
id|MSG_DONTROUTE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * FIXME: we need to optimize this.&n;&t;&t; * Perhaps some hints here would be good.&n;&t;&t; */
id|tmp
op_assign
id|prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|skb
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|skb-&gt;truesize
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;h.th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|tmp
op_assign
id|tcp_build_header
c_func
(paren
id|skb-&gt;h.th
comma
id|sk
comma
id|len
op_minus
id|copy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_OOB
)paren
(brace
id|skb-&gt;h.th-&gt;urg
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;h.th-&gt;urg_ptr
op_assign
id|ntohs
c_func
(paren
id|copy
)paren
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|copy
)paren
comma
id|from
comma
id|copy
)paren
suffix:semicolon
id|from
op_add_assign
id|copy
suffix:semicolon
id|copied
op_add_assign
id|copy
suffix:semicolon
id|len
op_sub_assign
id|copy
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;write_seq
op_add_assign
id|copy
suffix:semicolon
r_if
c_cond
(paren
id|send_tmp
op_ne
l_int|NULL
op_logical_and
id|sk-&gt;packets_out
)paren
(brace
id|tcp_enqueue_partial
c_func
(paren
id|send_tmp
comma
id|sk
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|tcp_send_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; *&t;Nagle&squot;s rule. Turn Nagle off with TCP_NODELAY for highly&n; *&t;interactive fast network servers. It&squot;s meant to be on and&n; *&t;it really improves the throughput though not the echo time&n; *&t;on my slow slip link - Alan&n; */
multiline_comment|/*&n; *&t;Avoid possible race on send_tmp - c/o Johannes Stille &n; */
r_if
c_cond
(paren
id|sk-&gt;partial
op_logical_and
(paren
(paren
op_logical_neg
id|sk-&gt;packets_out
)paren
multiline_comment|/* If not nagling we can send on the before case too.. */
op_logical_or
(paren
id|sk-&gt;nonagle
op_logical_and
id|before
c_func
(paren
id|sk-&gt;write_seq
comma
id|sk-&gt;window_seq
)paren
)paren
)paren
)paren
(brace
id|tcp_send_partial
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|copied
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is just a wrapper. &n; */
DECL|function|tcp_sendto
r_static
r_int
id|tcp_sendto
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_const
r_int
r_char
op_star
id|from
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
comma
r_struct
id|sockaddr_in
op_star
id|addr
comma
r_int
id|addr_len
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
op_complement
(paren
id|MSG_OOB
op_or
id|MSG_DONTROUTE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
r_if
c_cond
(paren
id|addr_len
OL
r_sizeof
(paren
op_star
id|addr
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|addr-&gt;sin_family
op_logical_and
id|addr-&gt;sin_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|addr-&gt;sin_port
op_ne
id|sk-&gt;dummy_th.dest
)paren
r_return
op_minus
id|EISCONN
suffix:semicolon
r_if
c_cond
(paren
id|addr-&gt;sin_addr.s_addr
op_ne
id|sk-&gt;daddr
)paren
r_return
op_minus
id|EISCONN
suffix:semicolon
r_return
id|tcp_write
c_func
(paren
id|sk
comma
id|from
comma
id|len
comma
id|nonblock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send an ack if one is backlogged at this point. Ought to merge&n; *&t;this with tcp_send_ack().&n; */
DECL|function|tcp_read_wakeup
r_static
r_void
id|tcp_read_wakeup
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|tmp
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;ack_backlog
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re closed, don&squot;t send an ack, or we&squot;ll get a RST&n;&t; * from the closed destination.&n;&t; */
r_if
c_cond
(paren
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
op_logical_or
(paren
id|sk-&gt;state
op_eq
id|TCP_TIME_WAIT
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: we need to put code here to prevent this routine from&n;&t; * being called.  Being called once in a while is ok, so only check&n;&t; * if this is the second time in a row.&n; &t; */
multiline_comment|/*&n;&t; * We need to grab some memory, and put together an ack,&n;&t; * and then put it into the queue to be sent.&n;&t; */
id|buff
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|MAX_ACK_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Try again real soon. */
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|HZ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|buff-&gt;localroute
op_assign
id|sk-&gt;localroute
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Put in the IP header and routing stuff. &n;&t; */
id|tmp
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|MAX_ACK_SIZE
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
(paren
r_void
op_star
)paren
op_amp
id|sk-&gt;dummy_th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
id|t1-&gt;seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;sent_seq
)paren
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;res1
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;res2
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;syn
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;bytes_rcv
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;window
op_assign
id|tcp_select_window
c_func
(paren
id|sk
)paren
suffix:semicolon
id|t1-&gt;window
op_assign
id|ntohs
c_func
(paren
id|sk-&gt;window
)paren
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|ntohl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|1
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;FIXME:&n; * &t;This routine frees used buffers.&n; * &t;It should consider sending an ACK to let the&n; * &t;other end know we now have a bigger window.&n; */
DECL|function|cleanup_rbuf
r_static
r_void
id|cleanup_rbuf
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|left
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|rspace
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cleaning rbuf for sk=%p&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|left
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We have to loop through all the buffer headers,&n;&t; *&t;and try to free up all the space we can.&n;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;used
op_logical_or
id|skb-&gt;users
)paren
r_break
suffix:semicolon
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;FIXME:&n;&t; *&t;At this point we should send an ack if the difference&n;&t; *&t;in the window, and the amount of space is bigger than&n;&t; *&t;TCP_WINDOW_DIFF.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sk-&gt;rspace = %lu, was %lu&bslash;n&quot;
comma
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
comma
id|left
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rspace
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
)paren
op_ne
id|left
)paren
(brace
multiline_comment|/*&n;&t;&t; * This area has caused the most trouble.  The current strategy&n;&t;&t; * is to simply do nothing if the other end has room to send at&n;&t;&t; * least 3 full packets, because the ack from those will auto-&n;&t;&t; * matically update the window.  If the other end doesn&squot;t think&n;&t;&t; * we have much space left, but we have room for at least 1 more&n;&t;&t; * complete packet than it thinks we do, we will send an ack&n;&t;&t; * immediately.  Otherwise we will wait up to .5 seconds in case&n;&t;&t; * the user reads some more.&n;&t;&t; */
id|sk-&gt;ack_backlog
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * It&squot;s unclear whether to use sk-&gt;mtu or sk-&gt;mss here.  They differ only&n;&t; * if the other end is offering a window smaller than the agreed on MSS&n;&t; * (called sk-&gt;mtu here).  In theory there&squot;s no connection between send&n;&t; * and receive, and so no reason to think that they&squot;re going to send&n;&t; * small packets.  For the moment I&squot;m using the hack of reducing the mss&n;&t; * only on the send side, so I&squot;m putting mtu here.&n;&t; */
r_if
c_cond
(paren
id|rspace
OG
(paren
id|sk-&gt;window
op_minus
id|sk-&gt;bytes_rcv
op_plus
id|sk-&gt;mtu
)paren
)paren
(brace
multiline_comment|/* Send an ack right now. */
id|tcp_read_wakeup
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Force it to send an ack soon. */
r_int
id|was_active
op_assign
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;retransmit_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|was_active
op_logical_or
id|jiffies
op_plus
id|TCP_ACK_TIME
OL
id|sk-&gt;timer.expires
)paren
(brace
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|TCP_ACK_TIME
)paren
suffix:semicolon
)brace
r_else
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;retransmit_timer
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; *&t;Handle reading urgent data. BSD has very simple semantics for&n; *&t;this, no blocking and very strange errors 8)&n; */
DECL|function|tcp_read_urg
r_static
r_int
id|tcp_read_urg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|nonblock
comma
r_int
r_char
op_star
id|to
comma
r_int
id|len
comma
r_int
id|flags
)paren
(brace
multiline_comment|/*&n;&t; *&t;No URG data to read&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;urginline
op_logical_or
op_logical_neg
id|sk-&gt;urg_data
op_logical_or
id|sk-&gt;urg_data
op_eq
id|URG_READ
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Yes this is right ! */
r_if
c_cond
(paren
id|sk-&gt;err
)paren
(brace
r_int
id|tmp
op_assign
op_minus
id|sk-&gt;err
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
op_logical_or
id|sk-&gt;done
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;done
)paren
(brace
id|sk-&gt;done
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENOTCONN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
(brace
id|sk-&gt;done
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;urg_data
op_amp
id|URG_VALID
)paren
(brace
r_char
id|c
op_assign
id|sk-&gt;urg_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
)paren
id|sk-&gt;urg_data
op_assign
id|URG_READ
suffix:semicolon
id|put_fs_byte
c_func
(paren
id|c
comma
id|to
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fixed the recv(..., MSG_OOB) behaviour.  BSD docs and&n;&t; * the available implementations agree in this case:&n;&t; * this call should never block, independent of the&n;&t; * blocking state of the socket.&n;&t; * Mike &lt;pall@rz.uni-karlsruhe.de&gt;&n;&t; */
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine copies from a sock struct into the user buffer. &n; */
DECL|function|tcp_read
r_static
r_int
id|tcp_read
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|to
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
)paren
(brace
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
id|u32
id|peek_seq
suffix:semicolon
r_volatile
id|u32
op_star
id|seq
suffix:semicolon
multiline_comment|/* So gcc doesn&squot;t overoptimise */
r_int
r_int
id|used
suffix:semicolon
multiline_comment|/* &n;&t; *&t;This error should be checked. &n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Urgent data needs to be handled specially. &n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_OOB
)paren
r_return
id|tcp_read_urg
c_func
(paren
id|sk
comma
id|nonblock
comma
id|to
comma
id|len
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Copying sequence to update. This is volatile to handle&n;&t; *&t;the multi-reader case neatly (memcpy_to/fromfs might be &n;&t; *&t;inline and thus not flush cached variables otherwise).&n;&t; */
id|peek_seq
op_assign
id|sk-&gt;copied_seq
suffix:semicolon
id|seq
op_assign
op_amp
id|sk-&gt;copied_seq
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
id|seq
op_assign
op_amp
id|peek_seq
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|u32
id|offset
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Are we at urgent data? Stop if we have read anything.&n;&t;&t; */
r_if
c_cond
(paren
id|copied
op_logical_and
id|sk-&gt;urg_data
op_logical_and
id|sk-&gt;urg_seq
op_eq
op_star
id|seq
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Next get a buffer.&n;&t;&t; */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|before
c_func
(paren
op_star
id|seq
comma
id|skb-&gt;h.th-&gt;seq
)paren
)paren
r_break
suffix:semicolon
id|offset
op_assign
op_star
id|seq
op_minus
id|skb-&gt;h.th-&gt;seq
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;syn
)paren
id|offset
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
id|skb-&gt;len
)paren
r_goto
id|found_ok_skb
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;fin
)paren
r_goto
id|found_fin_ok
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
)paren
id|skb-&gt;used
op_assign
l_int|1
suffix:semicolon
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
(brace
id|copied
op_assign
op_minus
id|sk-&gt;err
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;done
)paren
(brace
id|sk-&gt;done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|copied
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
(brace
id|sk-&gt;done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nonblock
)paren
(brace
id|copied
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cleanup_rbuf
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;socket-&gt;flags
op_or_assign
id|SO_WAITDATA
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;socket-&gt;flags
op_and_assign
op_complement
id|SO_WAITDATA
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|copied
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_continue
suffix:semicolon
id|found_ok_skb
suffix:colon
multiline_comment|/*&n;&t;&t; *&t;Lock the buffer. We can be fairly relaxed as&n;&t;&t; *&t;an interrupt will never steal a buffer we are &n;&t;&t; *&t;using unless I&squot;ve missed something serious in&n;&t;&t; *&t;tcp_data.&n;&t;&t; */
id|skb-&gt;users
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Ok so how much can we use ? &n;&t;&t; */
id|used
op_assign
id|skb-&gt;len
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|used
)paren
id|used
op_assign
id|len
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Do we have urgent data here? &n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;urg_data
)paren
(brace
id|u32
id|urg_offset
op_assign
id|sk-&gt;urg_seq
op_minus
op_star
id|seq
suffix:semicolon
r_if
c_cond
(paren
id|urg_offset
OL
id|used
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|urg_offset
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;urginline
)paren
(brace
op_increment
op_star
id|seq
suffix:semicolon
id|offset
op_increment
suffix:semicolon
id|used
op_decrement
suffix:semicolon
)brace
)brace
r_else
id|used
op_assign
id|urg_offset
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; *&t;Copy it - We _MUST_ update *seq first so that we&n;&t;&t; *&t;don&squot;t ever double read when we have dual readers&n;&t;&t; */
op_star
id|seq
op_add_assign
id|used
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;This memcpy_tofs can sleep. If it sleeps and we&n;&t;&t; *&t;do a second read it relies on the skb-&gt;users to avoid&n;&t;&t; *&t;a crash when cleanup_rbuf() gets called.&n;&t;&t; */
id|memcpy_tofs
c_func
(paren
id|to
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|skb-&gt;h.th
)paren
op_plus
id|skb-&gt;h.th-&gt;doff
op_star
l_int|4
op_plus
id|offset
comma
id|used
)paren
suffix:semicolon
id|copied
op_add_assign
id|used
suffix:semicolon
id|len
op_sub_assign
id|used
suffix:semicolon
id|to
op_add_assign
id|used
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;We now will not sleep again until we are finished&n;&t;&t; *&t;with skb. Sorry if you are doing the SMP port&n;&t;&t; *&t;but you&squot;ll just have to fix it neatly ;)&n;&t;&t; */
id|skb-&gt;users
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|sk-&gt;copied_seq
comma
id|sk-&gt;urg_seq
)paren
)paren
id|sk-&gt;urg_data
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|used
op_plus
id|offset
OL
id|skb-&gt;len
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Process the FIN.&n;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;fin
)paren
r_goto
id|found_fin_ok
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
r_continue
suffix:semicolon
id|skb-&gt;used
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
id|found_fin_ok
suffix:colon
op_increment
op_star
id|seq
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;All is done&n;&t;&t; */
id|skb-&gt;used
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;shutdown
op_or_assign
id|RCV_SHUTDOWN
suffix:semicolon
r_break
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
multiline_comment|/* Clean up data we have read: This will do ACK frames */
id|cleanup_rbuf
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|copied
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;State processing on a close. This implements the state shift for&n; *&t;sending our FIN frame. Note that we only send a FIN for some &n; *&t;states. A shutdown() may have already sent the FIN, or we may be&n; *&t;closed.&n; */
DECL|function|tcp_close_state
r_static
r_int
id|tcp_close_state
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|dead
)paren
(brace
r_int
id|ns
op_assign
id|TCP_CLOSE
suffix:semicolon
r_int
id|send_fin
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_SYN_SENT
suffix:colon
multiline_comment|/* No SYN back, no FIN needed */
r_break
suffix:semicolon
r_case
id|TCP_SYN_RECV
suffix:colon
r_case
id|TCP_ESTABLISHED
suffix:colon
multiline_comment|/* Closedown begin */
id|ns
op_assign
id|TCP_FIN_WAIT1
suffix:semicolon
id|send_fin
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_FIN_WAIT1
suffix:colon
multiline_comment|/* Already closing, or FIN sent: no change */
r_case
id|TCP_FIN_WAIT2
suffix:colon
r_case
id|TCP_CLOSING
suffix:colon
id|ns
op_assign
id|sk-&gt;state
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE
suffix:colon
r_case
id|TCP_LISTEN
suffix:colon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE_WAIT
suffix:colon
multiline_comment|/* They have FIN&squot;d us. We send our FIN and&n;&t;&t;&t;&t;&t;   wait only for the ACK */
id|ns
op_assign
id|TCP_LAST_ACK
suffix:semicolon
id|send_fin
op_assign
l_int|1
suffix:semicolon
)brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|ns
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This is a (useful) BSD violating of the RFC. There is a&n;&t; *&t;problem with TCP as specified in that the other end could&n;&t; *&t;keep a socket open forever with no application left this end.&n;&t; *&t;We use a 3 minute timeout (about the same as BSD) then kill&n;&t; *&t;our end. If they send after that then tough - BUT: long enough&n;&t; *&t;that we won&squot;t make the old 4*rto = almost no time - whoops&n;&t; *&t;reset mistake.&n;&t; */
r_if
c_cond
(paren
id|dead
op_logical_and
id|ns
op_eq
id|TCP_FIN_WAIT2
)paren
(brace
r_int
id|timer_active
op_assign
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_active
)paren
(brace
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
)brace
r_else
id|reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_FIN_TIMEOUT
)paren
suffix:semicolon
)brace
r_return
id|send_fin
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send a fin.&n; */
DECL|function|tcp_send_fin
r_static
r_void
id|tcp_send_fin
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|proto
op_star
id|prot
op_assign
(paren
r_struct
id|proto
op_star
)paren
id|sk-&gt;prot
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
op_amp
id|sk-&gt;dummy_th
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* in case the malloc sleeps. */
id|buff
op_assign
id|prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|MAX_RESET_SIZE
comma
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* This is a disaster if it occurs */
id|printk
c_func
(paren
l_string|&quot;tcp_send_fin: Impossible malloc failure&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Administrivia&n;&t; */
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|buff-&gt;localroute
op_assign
id|sk-&gt;localroute
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Put in the IP header and routing stuff. &n;&t; */
id|tmp
op_assign
id|prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
r_int
id|t
suffix:semicolon
multiline_comment|/*&n;  &t;&t; *&t;Finish anyway, treat this as a send that got lost. &n;  &t;&t; *&t;(Not good).&n;  &t;&t; */
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
id|sk-&gt;write_seq
op_increment
suffix:semicolon
id|t
op_assign
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
)brace
r_else
id|reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;We ought to check if the end of the queue is a buffer and&n;&t; *&t;if so simply add the fin to that buffer, not send it ahead.&n;&t; */
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|buff-&gt;dev
op_assign
id|dev
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
id|th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
id|t1-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|sk-&gt;write_seq
)paren
suffix:semicolon
id|sk-&gt;write_seq
op_increment
suffix:semicolon
id|buff-&gt;h.seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|ntohl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|t1-&gt;window
op_assign
id|ntohs
c_func
(paren
id|sk-&gt;window
op_assign
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|t1-&gt;fin
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If there is data in the write queue, the fin must be appended to&n;&t; * the write queue.&n; &t; */
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_ne
l_int|NULL
)paren
(brace
id|buff-&gt;free
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buff-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tcp_send_fin: next != NULL&bslash;n&quot;
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|buff
)paren
suffix:semicolon
)brace
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|buff
)paren
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;sent_seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|0
)paren
suffix:semicolon
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Shutdown the sending side of a connection. Much like close except&n; *&t;that we don&squot;t receive shut down or set sk-&gt;dead=1.&n; */
DECL|function|tcp_shutdown
r_void
id|tcp_shutdown
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
)paren
(brace
multiline_comment|/*&n;&t; *&t;We need to grab some memory, and put together a FIN,&n;&t; *&t;and then put it into the queue to be sent.&n;&t; *&t;&t;Tim MacKenzie(tym@dibbler.cs.monash.edu.au) 4 Dec &squot;92.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|how
op_amp
id|SEND_SHUTDOWN
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If we&squot;ve already sent a FIN, or it&squot;s a closed state&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT1
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT2
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_CLOSING
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_LAST_ACK
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_TIME_WAIT
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_CLOSE
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
(brace
r_return
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * flag that the sender has shutdown&n;&t; */
id|sk-&gt;shutdown
op_or_assign
id|SEND_SHUTDOWN
suffix:semicolon
multiline_comment|/*&n;&t; *  Clear out any half completed packets. &n;&t; */
r_if
c_cond
(paren
id|sk-&gt;partial
)paren
id|tcp_send_partial
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;FIN if needed&n;&t; */
r_if
c_cond
(paren
id|tcp_close_state
c_func
(paren
id|sk
comma
l_int|0
)paren
)paren
(brace
id|tcp_send_fin
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|tcp_recvfrom
id|tcp_recvfrom
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|to
comma
r_int
id|to_len
comma
r_int
id|nonblock
comma
r_int
id|flags
comma
r_struct
id|sockaddr_in
op_star
id|addr
comma
r_int
op_star
id|addr_len
)paren
(brace
r_int
id|result
suffix:semicolon
multiline_comment|/* &n;&t; *&t;Have to check these first unlike the old code. If &n;&t; *&t;we check them after we lose data on an error&n;&t; *&t;which is wrong &n;&t; */
r_if
c_cond
(paren
id|addr_len
)paren
(brace
op_star
id|addr_len
op_assign
r_sizeof
(paren
op_star
id|addr
)paren
suffix:semicolon
)brace
id|result
op_assign
id|tcp_read
c_func
(paren
id|sk
comma
id|to
comma
id|to_len
comma
id|nonblock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
id|addr
)paren
(brace
id|addr-&gt;sin_family
op_assign
id|AF_INET
suffix:semicolon
id|addr-&gt;sin_port
op_assign
id|sk-&gt;dummy_th.dest
suffix:semicolon
id|addr-&gt;sin_addr.s_addr
op_assign
id|sk-&gt;daddr
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine will send an RST to the other tcp. &n; */
DECL|function|tcp_reset
r_static
r_void
id|tcp_reset
c_func
(paren
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_struct
id|proto
op_star
id|prot
comma
r_struct
id|options
op_star
id|opt
comma
r_struct
id|device
op_star
id|dev
comma
r_int
id|tos
comma
r_int
id|ttl
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_struct
id|device
op_star
id|ndev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Cannot reset a reset (Think about it).&n;&t; */
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We need to grab some memory, and put together an RST,&n;&t; * and then put it into the queue to be sent.&n;&t; */
id|buff
op_assign
id|prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
l_int|NULL
comma
id|MAX_RESET_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|buff-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|buff-&gt;dev
op_assign
id|dev
suffix:semicolon
id|buff-&gt;localroute
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Put in the IP header and routing stuff. &n;&t; */
id|tmp
op_assign
id|prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|saddr
comma
id|daddr
comma
op_amp
id|ndev
comma
id|IPPROTO_TCP
comma
id|opt
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
comma
id|tos
comma
id|ttl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|prot
op_member_access_from_pointer
id|wfree
c_func
(paren
l_int|NULL
comma
id|buff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
id|th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Swap the send and the receive. &n;&t; */
id|t1-&gt;dest
op_assign
id|th-&gt;source
suffix:semicolon
id|t1-&gt;source
op_assign
id|th-&gt;dest
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;window
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
id|t1-&gt;ack
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;seq
op_assign
id|th-&gt;ack_seq
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;syn
)paren
(brace
id|t1-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|th-&gt;seq
)paren
suffix:semicolon
)brace
r_else
id|t1-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|th-&gt;seq
op_plus
l_int|1
)paren
suffix:semicolon
id|t1-&gt;seq
op_assign
l_int|0
suffix:semicolon
)brace
id|t1-&gt;syn
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;fin
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|saddr
comma
id|daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
l_int|NULL
)paren
suffix:semicolon
id|prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
l_int|NULL
comma
id|ndev
comma
id|buff
comma
l_int|1
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Look for tcp options. Parses everything but only knows about MSS.&n; *&t;This routine is always called with the packet containing the SYN.&n; *&t;However it may also be called with the ack to the SYN.  So you&n; *&t;can&squot;t assume this is always the SYN.  It&squot;s always called after&n; *&t;we have set up sk-&gt;mtu to our own MTU.&n; *&n; *&t;We need at minimum to add PAWS support here. Possibly large windows&n; *&t;as Linux gets deployed on 100Mb/sec networks.&n; */
DECL|function|tcp_options
r_static
r_void
id|tcp_options
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|length
op_assign
(paren
id|th-&gt;doff
op_star
l_int|4
)paren
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
r_int
id|mss_seen
op_assign
l_int|0
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|length
OG
l_int|0
)paren
(brace
r_int
id|opcode
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_int
id|opsize
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|TCPOPT_EOL
suffix:colon
r_return
suffix:semicolon
r_case
id|TCPOPT_NOP
suffix:colon
multiline_comment|/* Ref: RFC 793 section 3.1 */
id|length
op_decrement
suffix:semicolon
id|ptr
op_decrement
suffix:semicolon
multiline_comment|/* the opsize=*ptr++ above was a mistake */
r_continue
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|opsize
op_le
l_int|2
)paren
(brace
multiline_comment|/* Avoid silly options looping forever */
r_return
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|TCPOPT_MSS
suffix:colon
r_if
c_cond
(paren
id|opsize
op_eq
l_int|4
op_logical_and
id|th-&gt;syn
)paren
(brace
id|sk-&gt;mtu
op_assign
id|min
c_func
(paren
id|sk-&gt;mtu
comma
id|ntohs
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|ptr
)paren
)paren
suffix:semicolon
id|mss_seen
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* Add other options here as people feel the urge to implement stuff like large windows */
)brace
id|ptr
op_add_assign
id|opsize
op_minus
l_int|2
suffix:semicolon
id|length
op_sub_assign
id|opsize
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|th-&gt;syn
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mss_seen
)paren
id|sk-&gt;mtu
op_assign
id|min
c_func
(paren
id|sk-&gt;mtu
comma
l_int|536
)paren
suffix:semicolon
multiline_comment|/* default MSS if none sent */
)brace
macro_line|#ifdef CONFIG_INET_PCTCP
id|sk-&gt;mss
op_assign
id|min
c_func
(paren
id|sk-&gt;max_window
op_rshift
l_int|1
comma
id|sk-&gt;mtu
)paren
suffix:semicolon
macro_line|#else    
id|sk-&gt;mss
op_assign
id|min
c_func
(paren
id|sk-&gt;max_window
comma
id|sk-&gt;mtu
)paren
suffix:semicolon
macro_line|#endif  
)brace
DECL|function|default_mask
r_static
r_inline
r_int
r_int
id|default_mask
c_func
(paren
r_int
r_int
id|dst
)paren
(brace
id|dst
op_assign
id|ntohl
c_func
(paren
id|dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSA
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSA_NET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSB
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSB_NET
)paren
suffix:semicolon
r_return
id|htonl
c_func
(paren
id|IN_CLASSC_NET
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Default sequence number picking algorithm.&n; *&t;As close as possible to RFC 793, which&n; *&t;suggests using a 250kHz clock.&n; *&t;Further reading shows this assumes 2MB/s networks.&n; *&t;For 10MB/s ethernet, a 1MHz clock is appropriate.&n; *&t;That&squot;s funny, Linux has one built in!  Use it!&n; */
DECL|function|tcp_init_seq
r_extern
r_inline
id|u32
id|tcp_init_seq
c_func
(paren
r_void
)paren
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
r_return
id|tv.tv_usec
op_plus
id|tv.tv_sec
op_star
l_int|1000000
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine handles a connection request.&n; *&t;It should make sure we haven&squot;t already responded.&n; *&t;Because of the way BSD works, we have to send a syn/ack now.&n; *&t;This also means it will be harder to close a socket which is&n; *&t;listening.&n; */
DECL|function|tcp_conn_request
r_static
r_void
id|tcp_conn_request
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|saddr
comma
r_struct
id|options
op_star
id|opt
comma
r_struct
id|device
op_star
id|dev
comma
id|u32
id|seq
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_struct
id|sock
op_star
id|newsk
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|device
op_star
id|ndev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
multiline_comment|/* If the socket is dead, don&squot;t accept the connection. */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Reset on %p: Connect on dead socket.&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
)brace
id|tcp_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Make sure we can accept more.  This will prevent a&n;&t; * flurry of syns from eating up all our memory.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;ack_backlog
op_ge
id|sk-&gt;max_ack_backlog
)paren
(brace
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We need to build a new sock struct.&n;&t; * It is sort of bad to have a socket without an inode attached&n;&t; * to it, but the wake_up&squot;s will just wake up the listening socket,&n;&t; * and if the listening socket is destroyed before this is taken&n;&t; * off of the queue, this will take care of it.&n;&t; */
id|newsk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sock
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newsk
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* just ignore the syn.  It will get retransmitted. */
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|newsk
comma
id|sk
comma
r_sizeof
(paren
op_star
id|newsk
)paren
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|newsk-&gt;write_queue
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|newsk-&gt;receive_queue
)paren
suffix:semicolon
id|newsk-&gt;send_head
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;send_tail
op_assign
l_int|NULL
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|newsk-&gt;back_log
)paren
suffix:semicolon
id|newsk-&gt;rtt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*TCP_CONNECT_TIME&lt;&lt;3*/
id|newsk-&gt;rto
op_assign
id|TCP_TIMEOUT_INIT
suffix:semicolon
id|newsk-&gt;mdev
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;max_window
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;cong_window
op_assign
l_int|1
suffix:semicolon
id|newsk-&gt;cong_count
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;ssthresh
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;backoff
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;blog
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;intr
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;proc
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;done
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;partial
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;pair
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;wmem_alloc
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;rmem_alloc
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;localroute
op_assign
id|sk-&gt;localroute
suffix:semicolon
id|newsk-&gt;max_unacked
op_assign
id|MAX_WINDOW
op_minus
id|TCP_WINDOW_DIFF
suffix:semicolon
id|newsk-&gt;err
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;shutdown
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;acked_seq
op_assign
id|skb-&gt;h.th-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|newsk-&gt;copied_seq
op_assign
id|skb-&gt;h.th-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|newsk-&gt;fin_seq
op_assign
id|skb-&gt;h.th-&gt;seq
suffix:semicolon
id|newsk-&gt;state
op_assign
id|TCP_SYN_RECV
suffix:semicolon
id|newsk-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;ip_xmit_timeout
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;write_seq
op_assign
id|seq
suffix:semicolon
id|newsk-&gt;window_seq
op_assign
id|newsk-&gt;write_seq
suffix:semicolon
id|newsk-&gt;rcv_ack_seq
op_assign
id|newsk-&gt;write_seq
suffix:semicolon
id|newsk-&gt;urg_data
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;linger
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;destroy
op_assign
l_int|0
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|newsk-&gt;timer
)paren
suffix:semicolon
id|newsk-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|newsk
suffix:semicolon
id|newsk-&gt;timer.function
op_assign
op_amp
id|net_timer
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|newsk-&gt;retransmit_timer
)paren
suffix:semicolon
id|newsk-&gt;retransmit_timer.data
op_assign
(paren
r_int
r_int
)paren
id|newsk
suffix:semicolon
id|newsk-&gt;retransmit_timer.function
op_assign
op_amp
id|retransmit_timer
suffix:semicolon
id|newsk-&gt;dummy_th.source
op_assign
id|skb-&gt;h.th-&gt;dest
suffix:semicolon
id|newsk-&gt;dummy_th.dest
op_assign
id|skb-&gt;h.th-&gt;source
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Swap these two, they are from our point of view. &n;&t; */
id|newsk-&gt;daddr
op_assign
id|saddr
suffix:semicolon
id|newsk-&gt;saddr
op_assign
id|daddr
suffix:semicolon
id|put_sock
c_func
(paren
id|newsk-&gt;num
comma
id|newsk
)paren
suffix:semicolon
id|newsk-&gt;dummy_th.res1
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.doff
op_assign
l_int|6
suffix:semicolon
id|newsk-&gt;dummy_th.fin
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.syn
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.rst
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.psh
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.ack
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.urg
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.res2
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;acked_seq
op_assign
id|skb-&gt;h.th-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|newsk-&gt;copied_seq
op_assign
id|skb-&gt;h.th-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|newsk-&gt;socket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Grab the ttl and tos values and use them &n;&t; */
id|newsk-&gt;ip_ttl
op_assign
id|sk-&gt;ip_ttl
suffix:semicolon
id|newsk-&gt;ip_tos
op_assign
id|skb-&gt;ip_hdr-&gt;tos
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Use 512 or whatever user asked for &n;&t; */
multiline_comment|/*&n;&t; * &t;Note use of sk-&gt;user_mss, since user has no direct access to newsk &n;&t; */
id|rt
op_assign
id|ip_rt_route
c_func
(paren
id|saddr
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_ne
l_int|NULL
op_logical_and
(paren
id|rt-&gt;rt_flags
op_amp
id|RTF_WINDOW
)paren
)paren
(brace
id|newsk-&gt;window_clamp
op_assign
id|rt-&gt;rt_window
suffix:semicolon
)brace
r_else
id|newsk-&gt;window_clamp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;user_mss
)paren
id|newsk-&gt;mtu
op_assign
id|sk-&gt;user_mss
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rt
op_ne
l_int|NULL
op_logical_and
(paren
id|rt-&gt;rt_flags
op_amp
id|RTF_MSS
)paren
)paren
(brace
id|newsk-&gt;mtu
op_assign
id|rt-&gt;rt_mss
op_minus
id|HEADER_SIZE
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_INET_SNARL&t;/* Sub Nets Are Local */
r_if
c_cond
(paren
(paren
id|saddr
op_xor
id|daddr
)paren
op_amp
id|default_mask
c_func
(paren
id|saddr
)paren
)paren
macro_line|#else
r_if
c_cond
(paren
(paren
id|saddr
op_xor
id|daddr
)paren
op_amp
id|dev-&gt;pa_mask
)paren
macro_line|#endif
id|newsk-&gt;mtu
op_assign
l_int|576
op_minus
id|HEADER_SIZE
suffix:semicolon
r_else
id|newsk-&gt;mtu
op_assign
id|MAX_WINDOW
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;But not bigger than device MTU &n;&t; */
id|newsk-&gt;mtu
op_assign
id|min
c_func
(paren
id|newsk-&gt;mtu
comma
id|dev-&gt;mtu
op_minus
id|HEADER_SIZE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This will min with what arrived in the packet &n;&t; */
id|tcp_options
c_func
(paren
id|newsk
comma
id|skb-&gt;h.th
)paren
suffix:semicolon
id|tcp_cache_zap
c_func
(paren
)paren
suffix:semicolon
id|buff
op_assign
id|newsk-&gt;prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|newsk
comma
id|MAX_SYN_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;err
op_assign
id|ENOMEM
suffix:semicolon
id|newsk-&gt;dead
op_assign
l_int|1
suffix:semicolon
id|newsk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
multiline_comment|/* And this will destroy it */
id|release_sock
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buff-&gt;sk
op_assign
id|newsk
suffix:semicolon
id|buff-&gt;localroute
op_assign
id|newsk-&gt;localroute
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Put in the IP header and routing stuff. &n;&t; */
id|tmp
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|newsk-&gt;saddr
comma
id|newsk-&gt;daddr
comma
op_amp
id|ndev
comma
id|IPPROTO_TCP
comma
l_int|NULL
comma
id|MAX_SYN_SIZE
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Something went wrong. &n;&t; */
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sk-&gt;err
op_assign
id|tmp
suffix:semicolon
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|kfree_skb
c_func
(paren
id|buff
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|newsk-&gt;dead
op_assign
l_int|1
suffix:semicolon
id|newsk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|release_sock
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
id|skb-&gt;h.th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
id|buff-&gt;h.seq
op_assign
id|newsk-&gt;write_seq
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Swap the send and the receive. &n;&t; */
id|t1-&gt;dest
op_assign
id|skb-&gt;h.th-&gt;source
suffix:semicolon
id|t1-&gt;source
op_assign
id|newsk-&gt;dummy_th.source
suffix:semicolon
id|t1-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|newsk-&gt;write_seq
op_increment
)paren
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|newsk-&gt;window
op_assign
id|tcp_select_window
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|newsk-&gt;sent_seq
op_assign
id|newsk-&gt;write_seq
suffix:semicolon
id|t1-&gt;window
op_assign
id|ntohs
c_func
(paren
id|newsk-&gt;window
)paren
suffix:semicolon
id|t1-&gt;res1
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;res2
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;syn
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|ntohl
c_func
(paren
id|skb-&gt;h.th-&gt;seq
op_plus
l_int|1
)paren
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
op_plus
l_int|1
suffix:semicolon
id|ptr
op_assign
id|skb_put
c_func
(paren
id|buff
comma
l_int|4
)paren
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
l_int|2
suffix:semicolon
id|ptr
(braket
l_int|1
)braket
op_assign
l_int|4
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
(paren
(paren
id|newsk-&gt;mtu
)paren
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|ptr
(braket
l_int|3
)braket
op_assign
(paren
id|newsk-&gt;mtu
)paren
op_amp
l_int|0xff
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|daddr
comma
id|saddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
op_plus
l_int|4
comma
id|newsk
)paren
suffix:semicolon
id|newsk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|newsk
comma
id|ndev
comma
id|buff
comma
l_int|0
)paren
suffix:semicolon
id|reset_xmit_timer
c_func
(paren
id|newsk
comma
id|TIME_WRITE
comma
id|TCP_TIMEOUT_INIT
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
id|newsk
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Charge the sock_buff to newsk. &n;&t; */
id|sk-&gt;rmem_alloc
op_sub_assign
id|skb-&gt;truesize
suffix:semicolon
id|newsk-&gt;rmem_alloc
op_add_assign
id|skb-&gt;truesize
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
id|sk-&gt;ack_backlog
op_increment
suffix:semicolon
id|release_sock
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
)brace
DECL|function|tcp_close
r_static
r_void
id|tcp_close
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeout
)paren
(brace
multiline_comment|/*&n;&t; * We need to grab some memory, and put together a FIN,&t;&n;&t; * and then put it into the queue to be sent.&n;&t; */
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|th_cache_sk
op_eq
id|sk
)paren
(brace
id|tcp_cache_zap
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
(brace
multiline_comment|/* Special case */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|tcp_close_pending
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sk-&gt;keepopen
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
op_eq
l_int|0
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  We need to flush the recv. buffs.  We do this only on the&n;&t;&t; *  descriptor close, not protocol-sourced closes, because the&n;&t;&t; *  reader process may not have drained the data yet!&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Get rid off any half-completed packets. &n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;partial
)paren
id|tcp_send_partial
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Timeout is not the same thing - however the code likes&n;&t; *&t;to send both the same way (sigh).&n;&t; */
r_if
c_cond
(paren
id|timeout
)paren
(brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
multiline_comment|/* Dead */
)brace
r_else
(brace
r_if
c_cond
(paren
id|tcp_close_state
c_func
(paren
id|sk
comma
l_int|1
)paren
op_eq
l_int|1
)paren
(brace
id|tcp_send_fin
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;This routine takes stuff off of the write queue,&n; *&t;and puts it in the xmit queue. This happens as incoming acks&n; *&t;open up the remote window for us.&n; */
DECL|function|tcp_write_xmit
r_static
r_void
id|tcp_write_xmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/*&n;&t; *&t;The bytes will have to remain here. In time closedown will&n;&t; *&t;empty the write queue and all will be happy &n;&t; */
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Anything on the transmit queue that fits the window can&n;&t; *&t;be added providing we are not&n;&t; *&n;&t; *&t;a) retransmitting (Nagle&squot;s rule)&n;&t; *&t;b) exceeding our congestion window.&n;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
op_ne
l_int|NULL
op_logical_and
id|before
c_func
(paren
id|skb-&gt;h.seq
comma
id|sk-&gt;window_seq
op_plus
l_int|1
)paren
op_logical_and
(paren
id|sk-&gt;retransmits
op_eq
l_int|0
op_logical_or
id|sk-&gt;ip_xmit_timeout
op_ne
id|TIME_WRITE
op_logical_or
id|before
c_func
(paren
id|skb-&gt;h.seq
comma
id|sk-&gt;rcv_ack_seq
op_plus
l_int|1
)paren
)paren
op_logical_and
id|sk-&gt;packets_out
OL
id|sk-&gt;cong_window
)paren
(brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;See if we really need to send the packet. &n;&t;&t; */
r_if
c_cond
(paren
id|before
c_func
(paren
id|skb-&gt;h.seq
comma
id|sk-&gt;rcv_ack_seq
op_plus
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;This is acked data. We can discard it. This &n;&t;&t;&t; *&t;cannot currently occur.&n;&t;&t;&t; */
id|sk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/*&n; * put in the ack seq and window at this point rather than earlier,&n; * in order to keep them monotonic.  We really want to avoid taking&n; * back window allocations.  That&squot;s legal, but RFC1122 says it&squot;s frowned on.&n; * Ack and window will in general have changed since this packet was put&n; * on the write queue.&n; */
id|iph
op_assign
id|skb-&gt;ip_hdr
suffix:semicolon
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|iph
)paren
op_plus
(paren
id|iph-&gt;ihl
op_lshift
l_int|2
)paren
)paren
suffix:semicolon
id|size
op_assign
id|skb-&gt;len
op_minus
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|th
)paren
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
id|th-&gt;ack_seq
op_assign
id|ntohl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|th-&gt;window
op_assign
id|ntohs
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|th
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
id|size
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;sent_seq
op_assign
id|skb-&gt;h.seq
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;IP manages our queue for some crazy reason&n;&t;&t;&t; */
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|skb-&gt;dev
comma
id|skb
comma
id|skb-&gt;free
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Again we slide the timer wrongly&n;&t;&t;&t; */
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; *&t;This routine deals with incoming acks, but not outgoing ones.&n; */
DECL|function|tcp_ack
r_extern
id|__inline__
r_int
id|tcp_ack
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
r_int
id|saddr
comma
r_int
id|len
)paren
(brace
id|u32
id|ack
suffix:semicolon
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t; * 1 - there was data in packet as well as ack or new data is sent or &n;&t; *     in shutdown state&n;&t; * 2 - data from retransmit queue was acked and removed&n;&t; * 4 - window shrunk or data from retransmit queue was acked and removed&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Dead, cant ack any more so why bother */
multiline_comment|/*&n;&t; *&t;Have we discovered a larger window&n;&t; */
id|ack
op_assign
id|ntohl
c_func
(paren
id|th-&gt;ack_seq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
OG
id|sk-&gt;max_window
)paren
(brace
id|sk-&gt;max_window
op_assign
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_INET_PCTCP
multiline_comment|/* Hack because we don&squot;t send partial packets to non SWS&n;&t;&t;   handling hosts */
id|sk-&gt;mss
op_assign
id|min
c_func
(paren
id|sk-&gt;max_window
op_rshift
l_int|1
comma
id|sk-&gt;mtu
)paren
suffix:semicolon
macro_line|#else
id|sk-&gt;mss
op_assign
id|min
c_func
(paren
id|sk-&gt;max_window
comma
id|sk-&gt;mtu
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
multiline_comment|/*&n;&t; *&t;We have dropped back to keepalive timeouts. Thus we have&n;&t; *&t;no retransmits pending.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;retransmits
op_logical_and
id|sk-&gt;ip_xmit_timeout
op_eq
id|TIME_KEEPOPEN
)paren
id|sk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If the ack is newer than sent or older than previous acks&n;&t; *&t;then we can probably ignore it.&n;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|ack
comma
id|sk-&gt;sent_seq
)paren
op_logical_or
id|before
c_func
(paren
id|ack
comma
id|sk-&gt;rcv_ack_seq
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Ack ignored %u %u&bslash;n&quot;
comma
id|ack
comma
id|sk-&gt;sent_seq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Keepalive processing.&n;&t;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|ack
comma
id|sk-&gt;sent_seq
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Restart the keepalive timer.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;keepopen
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;ip_xmit_timeout
op_eq
id|TIME_KEEPOPEN
)paren
(brace
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_KEEPOPEN
comma
id|TCP_TIMEOUT_LEN
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If there is data set flag 1&n;&t; */
r_if
c_cond
(paren
id|len
op_ne
id|th-&gt;doff
op_star
l_int|4
)paren
id|flag
op_or_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *&t;See if our window has been shrunk. &n;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|sk-&gt;window_seq
comma
id|ack
op_plus
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * We may need to move packets from the send queue&n;&t;&t; * to the write queue, if the window has been shrunk on us.&n;&t;&t; * The RFC says you are not allowed to shrink your window&n;&t;&t; * like this, but if the other end does, you must be able&n;&t;&t; * to deal with it.&n;&t;&t; */
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_struct
id|sk_buff
op_star
id|wskb
op_assign
l_int|NULL
suffix:semicolon
id|skb2
op_assign
id|sk-&gt;send_head
suffix:semicolon
id|sk-&gt;send_head
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;send_tail
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;This is an artifact of a flawed concept. We want one&n;&t;&t; *&t;queue and a smarter send routine when we send all.&n;&t;&t; */
id|flag
op_or_assign
l_int|4
suffix:semicolon
multiline_comment|/* Window changed */
id|sk-&gt;window_seq
op_assign
id|ack
op_plus
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|skb2
op_ne
l_int|NULL
)paren
(brace
id|skb
op_assign
id|skb2
suffix:semicolon
id|skb2
op_assign
id|skb-&gt;link3
suffix:semicolon
id|skb-&gt;link3
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|skb-&gt;h.seq
comma
id|sk-&gt;window_seq
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;packets_out
OG
l_int|0
)paren
id|sk-&gt;packets_out
op_decrement
suffix:semicolon
multiline_comment|/* We may need to remove this from the dev send list. */
r_if
c_cond
(paren
id|skb-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* Now add it to the write_queue. */
r_if
c_cond
(paren
id|wskb
op_eq
l_int|NULL
)paren
id|skb_queue_head
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
r_else
id|skb_append
c_func
(paren
id|wskb
comma
id|skb
)paren
suffix:semicolon
id|wskb
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk-&gt;send_head
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;send_head
op_assign
id|skb
suffix:semicolon
id|sk-&gt;send_tail
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;send_tail-&gt;link3
op_assign
id|skb
suffix:semicolon
id|sk-&gt;send_tail
op_assign
id|skb
suffix:semicolon
)brace
id|skb-&gt;link3
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Pipe has emptied&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;send_tail
op_eq
l_int|NULL
op_logical_or
id|sk-&gt;send_head
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;send_head
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;send_tail
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;packets_out
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Update the right hand window edge of the host&n;&t; */
id|sk-&gt;window_seq
op_assign
id|ack
op_plus
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We don&squot;t want too many packets out there. &n;&t; */
r_if
c_cond
(paren
id|sk-&gt;ip_xmit_timeout
op_eq
id|TIME_WRITE
op_logical_and
id|sk-&gt;cong_window
OL
l_int|2048
op_logical_and
id|after
c_func
(paren
id|ack
comma
id|sk-&gt;rcv_ack_seq
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t; * This is Jacobson&squot;s slow start and congestion avoidance. &n;&t;&t; * SIGCOMM &squot;88, p. 328.  Because we keep cong_window in integral&n;&t;&t; * mss&squot;s, we can&squot;t do cwnd += 1 / cwnd.  Instead, maintain a &n;&t;&t; * counter and increment it once every cwnd times.  It&squot;s possible&n;&t;&t; * that this should be done only if sk-&gt;retransmits == 0.  I&squot;m&n;&t;&t; * interpreting &quot;new data is acked&quot; as including data that has&n;&t;&t; * been retransmitted but is just now being acked.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;cong_window
OL
id|sk-&gt;ssthresh
)paren
multiline_comment|/* &n;&t;&t;&t; *&t;In &quot;safe&quot; area, increase&n;&t;&t;&t; */
id|sk-&gt;cong_window
op_increment
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;In dangerous area, increase slowly.  In theory this is&n;&t;&t;&t; *  &t;sk-&gt;cong_window += 1 / sk-&gt;cong_window&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;cong_count
op_ge
id|sk-&gt;cong_window
)paren
(brace
id|sk-&gt;cong_window
op_increment
suffix:semicolon
id|sk-&gt;cong_count
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|sk-&gt;cong_count
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Remember the highest ack received.&n;&t; */
id|sk-&gt;rcv_ack_seq
op_assign
id|ack
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If this ack opens up a zero window, clear backoff.  It was&n;&t; *&t;being used to time the probes, and is probably far higher than&n;&t; *&t;it needs to be for normal retransmission.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;ip_xmit_timeout
op_eq
id|TIME_PROBE0
)paren
(brace
id|sk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Our probe was answered */
multiline_comment|/*&n;&t;&t; *&t;Was it a usable window open ?&n;&t;&t; */
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_ne
l_int|NULL
op_logical_and
multiline_comment|/* should always be non-null */
op_logical_neg
id|before
(paren
id|sk-&gt;window_seq
comma
id|sk-&gt;write_queue.next-&gt;h.seq
)paren
)paren
(brace
id|sk-&gt;backoff
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Recompute rto from rtt.  this eliminates any backoff.&n;&t;&t;&t; */
id|sk-&gt;rto
op_assign
(paren
(paren
id|sk-&gt;rtt
op_rshift
l_int|2
)paren
op_plus
id|sk-&gt;mdev
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rto
OG
l_int|120
op_star
id|HZ
)paren
id|sk-&gt;rto
op_assign
l_int|120
op_star
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rto
OL
l_int|20
)paren
multiline_comment|/* Was 1*HZ, then 1 - turns out we must allow about&n;&t;&t;&t;&t;&t;&t;   .2 of a second because of BSD delayed acks - on a 100Mb/sec link&n;&t;&t;&t;&t;&t;&t;   .2 of a second is going to need huge windows (SIGH) */
id|sk-&gt;rto
op_assign
l_int|20
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;&t; *&t;See if we can take anything off of the retransmit queue.&n;&t; */
r_while
c_loop
(paren
id|sk-&gt;send_head
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Check for a bug. */
r_if
c_cond
(paren
id|sk-&gt;send_head-&gt;link3
op_logical_and
id|after
c_func
(paren
id|sk-&gt;send_head-&gt;h.seq
comma
id|sk-&gt;send_head-&gt;link3-&gt;h.seq
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;INET: tcp.c: *** bug send_list out of order.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;If our packet is before the ack sequence we can&n;&t;&t; *&t;discard it as it&squot;s confirmed to have arrived the other end.&n;&t;&t; */
r_if
c_cond
(paren
id|before
c_func
(paren
id|sk-&gt;send_head-&gt;h.seq
comma
id|ack
op_plus
l_int|1
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|oskb
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;retransmits
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;We were retransmitting.  don&squot;t count this in RTT est &n;&t;&t;&t;&t; */
id|flag
op_or_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * even though we&squot;ve gotten an ack, we&squot;re still&n;&t;&t;&t;&t; * retransmitting as long as we&squot;re sending from&n;&t;&t;&t;&t; * the retransmit queue.  Keeping retransmits non-zero&n;&t;&t;&t;&t; * prevents us from getting new data interspersed with&n;&t;&t;&t;&t; * retransmissions.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;send_head-&gt;link3
)paren
multiline_comment|/* Any more queued retransmits? */
id|sk-&gt;retransmits
op_assign
l_int|1
suffix:semicolon
r_else
id|sk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Note that we only reset backoff and rto in the&n;&t;&t;&t; * rtt recomputation code.  And that doesn&squot;t happen&n;&t;&t;&t; * if there were retransmissions in effect.  So the&n;&t;&t;&t; * first new packet after the retransmissions is&n;&t;&t;&t; * sent with the backoff still in effect.  Not until&n;&t;&t;&t; * we get an ack from a non-retransmitted packet do&n;&t;&t;&t; * we reset the backoff and rto.  This allows us to deal&n;&t;&t;&t; * with a situation where the network delay has increased&n;&t;&t;&t; * suddenly.  I.e. Karn&squot;s algorithm. (SIGCOMM &squot;87, p5.)&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; *&t;We have one less packet out there. &n;&t;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;packets_out
OG
l_int|0
)paren
id|sk-&gt;packets_out
op_decrement
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; *&t;Wake up the process, it can probably write more. &n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
id|oskb
op_assign
id|sk-&gt;send_head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flag
op_amp
l_int|2
)paren
)paren
multiline_comment|/* Not retransmitting */
(brace
r_int
id|m
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;The following amusing code comes from Jacobson&squot;s&n;&t;&t;&t;&t; *&t;article in SIGCOMM &squot;88.  Note that rtt and mdev&n;&t;&t;&t;&t; *&t;are scaled versions of rtt and mean deviation.&n;&t;&t;&t;&t; *&t;This is designed to be as fast as possible &n;&t;&t;&t;&t; *&t;m stands for &quot;measurement&quot;.&n;&t;&t;&t;&t; */
id|m
op_assign
id|jiffies
op_minus
id|oskb-&gt;when
suffix:semicolon
multiline_comment|/* RTT */
r_if
c_cond
(paren
id|m
op_le
l_int|0
)paren
(brace
id|m
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* IS THIS RIGHT FOR &lt;0 ??? */
id|m
op_sub_assign
(paren
id|sk-&gt;rtt
op_rshift
l_int|3
)paren
suffix:semicolon
multiline_comment|/* m is now error in rtt est */
id|sk-&gt;rtt
op_add_assign
id|m
suffix:semicolon
multiline_comment|/* rtt = 7/8 rtt + 1/8 new */
r_if
c_cond
(paren
id|m
OL
l_int|0
)paren
id|m
op_assign
op_minus
id|m
suffix:semicolon
multiline_comment|/* m is now abs(error) */
id|m
op_sub_assign
(paren
id|sk-&gt;mdev
op_rshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* similar update on mdev */
id|sk-&gt;mdev
op_add_assign
id|m
suffix:semicolon
multiline_comment|/* mdev = 3/4 mdev + 1/4 new */
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Now update timeout.  Note that this removes any backoff.&n;&t;&t;&t;&t; */
id|sk-&gt;rto
op_assign
(paren
(paren
id|sk-&gt;rtt
op_rshift
l_int|2
)paren
op_plus
id|sk-&gt;mdev
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rto
OG
l_int|120
op_star
id|HZ
)paren
id|sk-&gt;rto
op_assign
l_int|120
op_star
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rto
OL
l_int|20
)paren
multiline_comment|/* Was 1*HZ - keep .2 as minimum cos of the BSD delayed acks */
id|sk-&gt;rto
op_assign
l_int|20
suffix:semicolon
id|sk-&gt;backoff
op_assign
l_int|0
suffix:semicolon
)brace
id|flag
op_or_assign
(paren
l_int|2
op_or
l_int|4
)paren
suffix:semicolon
multiline_comment|/* 2 is really more like &squot;don&squot;t adjust the rtt &n;&t;&t;&t;&t;&t;   In this case as we just set it up */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|oskb
op_assign
id|sk-&gt;send_head
suffix:semicolon
id|IS_SKB
c_func
(paren
id|oskb
)paren
suffix:semicolon
id|sk-&gt;send_head
op_assign
id|oskb-&gt;link3
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;send_head
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;send_tail
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;We may need to remove this from the dev send list. &n;&t;&t; */
r_if
c_cond
(paren
id|oskb-&gt;next
)paren
id|skb_unlink
c_func
(paren
id|oskb
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|oskb
comma
id|FREE_WRITE
)paren
suffix:semicolon
multiline_comment|/* write. */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * XXX someone ought to look at this too.. at the moment, if skb_peek()&n;&t; * returns non-NULL, we complete ignore the timer stuff in the else&n;&t; * clause.  We ought to organize the code so that else clause can&n;&t; * (should) be executed regardless, possibly moving the PROBE timer&n;&t; * reset over.  The skb_peek() thing should only move stuff to the&n;&t; * write queue, NOT also manage the timer functions.&n;&t; */
multiline_comment|/*&n;&t; * Maybe we can take some stuff off of the write queue,&n;&t; * and put it onto the xmit queue.&n;&t; */
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|after
(paren
id|sk-&gt;window_seq
op_plus
l_int|1
comma
id|sk-&gt;write_queue.next-&gt;h.seq
)paren
op_logical_and
(paren
id|sk-&gt;retransmits
op_eq
l_int|0
op_logical_or
id|sk-&gt;ip_xmit_timeout
op_ne
id|TIME_WRITE
op_logical_or
id|before
c_func
(paren
id|sk-&gt;write_queue.next-&gt;h.seq
comma
id|sk-&gt;rcv_ack_seq
op_plus
l_int|1
)paren
)paren
op_logical_and
id|sk-&gt;packets_out
OL
id|sk-&gt;cong_window
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Add more data to the send queue.&n;&t;&t;&t; */
id|flag
op_or_assign
l_int|1
suffix:semicolon
id|tcp_write_xmit
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|before
c_func
(paren
id|sk-&gt;window_seq
comma
id|sk-&gt;write_queue.next-&gt;h.seq
)paren
op_logical_and
id|sk-&gt;send_head
op_eq
l_int|NULL
op_logical_and
id|sk-&gt;ack_backlog
op_eq
l_int|0
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_TIME_WAIT
)paren
(brace
multiline_comment|/*&n; &t;&t;&t; *&t;Data to queue but no room.&n; &t;&t;&t; */
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * from TIME_WAIT we stay in TIME_WAIT as long as we rx packets&n;&t;&t; * from TCP_CLOSE we don&squot;t do anything&n;&t;&t; *&n;&t;&t; * from anything else, if there is write data (or fin) pending,&n;&t;&t; * we use a TIME_WRITE timeout, else if keepalive we reset to&n;&t;&t; * a KEEPALIVE timeout, else we delete the timer.&n;&t;&t; *&n;&t;&t; * We do not set flag for nominal write data, otherwise we may&n;&t;&t; * force a state where we start to write itsy bitsy tidbits&n;&t;&t; * of data.&n;&t;&t; */
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_TIME_WAIT
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * keep us in TIME_WAIT until we stop getting packets,&n;&t;&t;&t; * reset the timeout.&n;&t;&t;&t; */
id|reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * don&squot;t touch the timer.&n;&t;&t;&t; */
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/*&n;&t;&t;&t; * &t;Must check send_head, write_queue, and ack_backlog&n;&t;&t;&t; * &t;to determine which timeout to use.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;send_head
op_logical_or
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_ne
l_int|NULL
op_logical_or
id|sk-&gt;ack_backlog
)paren
(brace
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sk-&gt;keepopen
)paren
(brace
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_KEEPOPEN
comma
id|TCP_TIMEOUT_LEN
)paren
suffix:semicolon
)brace
r_else
(brace
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;retransmit_timer
)paren
suffix:semicolon
id|sk-&gt;ip_xmit_timeout
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;We have nothing queued but space to send. Send any partial&n;&t; *&t;packets immediately (end of Nagle rule application).&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;packets_out
op_eq
l_int|0
op_logical_and
id|sk-&gt;partial
op_ne
l_int|NULL
op_logical_and
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_eq
l_int|NULL
op_logical_and
id|sk-&gt;send_head
op_eq
l_int|NULL
)paren
(brace
id|flag
op_or_assign
l_int|1
suffix:semicolon
id|tcp_send_partial
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * In the LAST_ACK case, the other end FIN&squot;d us.  We then FIN&squot;d them, and&n;&t; * we are now waiting for an acknowledge to our FIN.  The other end is&n;&t; * already in TIME_WAIT.&n;&t; *&n;&t; * Move to TCP_CLOSE on success.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LAST_ACK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rcv_ack_seq: %X==%X, acked_seq: %X==%X&bslash;n&quot;
comma
id|sk-&gt;rcv_ack_seq
comma
id|sk-&gt;write_seq
comma
id|sk-&gt;acked_seq
comma
id|sk-&gt;fin_seq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;rcv_ack_seq
op_eq
id|sk-&gt;write_seq
multiline_comment|/*&amp;&amp; sk-&gt;acked_seq == sk-&gt;fin_seq*/
)paren
(brace
id|flag
op_or_assign
l_int|1
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Incoming ACK to a FIN we sent in the case of our initiating the close.&n;&t; *&n;&t; *&t;Move to FIN_WAIT2 to await a FIN from the other end. Set&n;&t; *&t;SEND_SHUTDOWN but not RCV_SHUTDOWN as data can still be coming in.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rcv_ack_seq
op_eq
id|sk-&gt;write_seq
)paren
(brace
id|flag
op_or_assign
l_int|1
suffix:semicolon
id|sk-&gt;shutdown
op_or_assign
id|SEND_SHUTDOWN
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_FIN_WAIT2
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Incoming ACK to a FIN we sent in the case of a simultaneous close.&n;&t; *&n;&t; *&t;Move to TIME_WAIT&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSING
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rcv_ack_seq
op_eq
id|sk-&gt;write_seq
)paren
(brace
id|flag
op_or_assign
l_int|1
suffix:semicolon
id|tcp_time_wait
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Final ack of a three way shake &n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_RECV
)paren
(brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_ESTABLISHED
)paren
suffix:semicolon
id|tcp_options
c_func
(paren
id|sk
comma
id|th
)paren
suffix:semicolon
id|sk-&gt;dummy_th.dest
op_assign
id|th-&gt;source
suffix:semicolon
id|sk-&gt;copied_seq
op_assign
id|sk-&gt;acked_seq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;max_window
op_eq
l_int|0
)paren
(brace
id|sk-&gt;max_window
op_assign
l_int|32
suffix:semicolon
multiline_comment|/* Sanity check */
id|sk-&gt;mss
op_assign
id|min
c_func
(paren
id|sk-&gt;max_window
comma
id|sk-&gt;mtu
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * I make no guarantees about the first clause in the following&n;&t; * test, i.e. &quot;(!flag) || (flag&amp;4)&quot;.  I&squot;m not entirely sure under&n;&t; * what conditions &quot;!flag&quot; would be true.  However I think the rest&n;&t; * of the conditions would prevent that from causing any&n;&t; * unnecessary retransmission. &n;&t; *   Clearly if the first packet has expired it should be &n;&t; * retransmitted.  The other alternative, &quot;flag&amp;2 &amp;&amp; retransmits&quot;, is&n;&t; * harder to explain:  You have to look carefully at how and when the&n;&t; * timer is set and with what timeout.  The most recent transmission always&n;&t; * sets the timer.  So in general if the most recent thing has timed&n;&t; * out, everything before it has as well.  So we want to go ahead and&n;&t; * retransmit some more.  If we didn&squot;t explicitly test for this&n;&t; * condition with &quot;flag&amp;2 &amp;&amp; retransmits&quot;, chances are &quot;when + rto &lt; jiffies&quot;&n;&t; * would not be true.  If you look at the pattern of timing, you can&n;&t; * show that rto is increased fast enough that the next packet would&n;&t; * almost never be retransmitted immediately.  Then you&squot;d end up&n;&t; * waiting for a timeout to send each packet on the retransmission&n;&t; * queue.  With my implementation of the Karn sampling algorithm,&n;&t; * the timeout would double each time.  The net result is that it would&n;&t; * take a hideous amount of time to recover from a single dropped packet.&n;&t; * It&squot;s possible that there should also be a test for TIME_WRITE, but&n;&t; * I think as long as &quot;send_head != NULL&quot; and &quot;retransmit&quot; is on, we&squot;ve&n;&t; * got to be in real retransmission mode.&n;&t; *   Note that tcp_do_retransmit is called with all==1.  Setting cong_window&n;&t; * back to 1 at the timeout will cause us to send 1, then 2, etc. packets.&n;&t; * As long as no further losses occur, this seems reasonable.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
op_logical_neg
id|flag
)paren
op_logical_or
(paren
id|flag
op_amp
l_int|4
)paren
)paren
op_logical_and
id|sk-&gt;send_head
op_ne
l_int|NULL
op_logical_and
(paren
(paren
(paren
id|flag
op_amp
l_int|2
)paren
op_logical_and
id|sk-&gt;retransmits
)paren
op_logical_or
(paren
id|sk-&gt;send_head-&gt;when
op_plus
id|sk-&gt;rto
OL
id|jiffies
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;send_head-&gt;when
op_plus
id|sk-&gt;rto
OL
id|jiffies
)paren
(brace
id|tcp_retransmit
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|tcp_do_retransmit
c_func
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Process the FIN bit. This now behaves as it is supposed to work&n; *&t;and the FIN takes effect when it is validly part of sequence&n; *&t;space. Not before when we get holes.&n; *&n; *&t;If we are ESTABLISHED, a received fin moves us to CLOSE-WAIT&n; *&t;(and thence onto LAST-ACK and finally, CLOSE, we never enter&n; *&t;TIME-WAIT)&n; *&n; *&t;If we are in FINWAIT-1, a received FIN indicates simultaneous&n; *&t;close and we go into CLOSING (and later onto TIME-WAIT)&n; *&n; *&t;If we are in FINWAIT-2, a received FIN moves us to TIME-WAIT.&n; *&n; */
DECL|function|tcp_fin
r_static
r_int
id|tcp_fin
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
id|sk-&gt;fin_seq
op_assign
id|th-&gt;seq
op_plus
id|skb-&gt;len
op_plus
id|th-&gt;syn
op_plus
id|th-&gt;fin
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sock_wake_async
c_func
(paren
id|sk-&gt;socket
comma
l_int|1
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_SYN_RECV
suffix:colon
r_case
id|TCP_SYN_SENT
suffix:colon
r_case
id|TCP_ESTABLISHED
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * move to CLOSE_WAIT, tcp_data() already handled&n;&t;&t;&t; * sending the ack.&n;&t;&t;&t; */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE_WAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;rst
)paren
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE_WAIT
suffix:colon
r_case
id|TCP_CLOSING
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * received a retransmission of the FIN, do&n;&t;&t;&t; * nothing.&n;&t;&t;&t; */
r_break
suffix:semicolon
r_case
id|TCP_TIME_WAIT
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * received a retransmission of the FIN,&n;&t;&t;&t; * restart the TIME_WAIT timer.&n;&t;&t;&t; */
id|reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TCP_FIN_WAIT1
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * This case occurs when a simultaneous close&n;&t;&t;&t; * happens, we must ack the received FIN and&n;&t;&t;&t; * enter the CLOSING state.&n;&t;&t;&t; *&n;&t;&t;&t; * This causes a WRITE timeout, which will either&n;&t;&t;&t; * move on to TIME_WAIT when we timeout, or resend&n;&t;&t;&t; * the FIN properly (maybe we get rid of that annoying&n;&t;&t;&t; * FIN lost hang). The TIME_WRITE code is already correct&n;&t;&t;&t; * for handling this timeout.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;ip_xmit_timeout
op_ne
id|TIME_WRITE
)paren
(brace
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSING
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_FIN_WAIT2
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * received a FIN -- send ACK and enter TIME_WAIT&n;&t;&t;&t; */
id|reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_or_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_TIME_WAIT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * already in CLOSE&n;&t;&t;&t; */
r_break
suffix:semicolon
r_default
suffix:colon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_LAST_ACK
)paren
suffix:semicolon
multiline_comment|/* Start the timers. */
id|reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine handles the data.  If there is room in the buffer,&n; *&t;it will be have already been moved into it.  If there is no&n; *&t;room, then we will just have to discard the packet.&n; */
DECL|function|tcp_data
r_extern
id|__inline__
r_int
id|tcp_data
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb1
comma
op_star
id|skb2
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_int
id|dup_dumped
op_assign
l_int|0
suffix:semicolon
id|u32
id|new_seq
comma
id|shut_seq
suffix:semicolon
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|th-&gt;doff
op_star
l_int|4
)paren
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
id|len
op_minus
(paren
id|th-&gt;doff
op_star
l_int|4
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;The bytes in the receive read/assembly queue has increased. Needed for the&n;&t; *&t;low memory discard algorithm &n;&t; */
id|sk-&gt;bytes_rcv
op_add_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
op_eq
l_int|0
op_logical_and
op_logical_neg
id|th-&gt;fin
)paren
(brace
multiline_comment|/* &n;&t;&t; *&t;Don&squot;t want to keep passing ack&squot;s back and forth. &n;&t;&t; *&t;(someone sent us dataless, boring frame)&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;ack
)paren
id|tcp_send_ack
c_func
(paren
id|sk-&gt;sent_seq
comma
id|sk-&gt;acked_seq
comma
id|sk
comma
id|th
comma
id|saddr
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;We no longer have anyone receiving data on this connection.&n;&t; */
macro_line|#ifndef TCP_DONT_RST_SHUTDOWN&t;&t; 
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;FIXME: BSD has some magic to avoid sending resets to&n;&t;&t; *&t;broken 4.2 BSD keepalives. Much to my surprise a few non&n;&t;&t; *&t;BSD stacks still have broken keepalives so we want to&n;&t;&t; *&t;cope with it.&n;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;len
)paren
multiline_comment|/* We don&squot;t care if it&squot;s just an ack or&n;&t;&t;&t;&t;   a keepalive/window probe */
(brace
id|new_seq
op_assign
id|th-&gt;seq
op_plus
id|skb-&gt;len
op_plus
id|th-&gt;syn
suffix:semicolon
multiline_comment|/* Right edge of _data_ part of frame */
multiline_comment|/* Do this the way 4.4BSD treats it. Not what I&squot;d&n;&t;&t;&t;   regard as the meaning of the spec but it&squot;s what BSD&n;&t;&t;&t;   does and clearly they know everything 8) */
multiline_comment|/*&n;&t;&t;&t; *&t;This is valid because of two things&n;&t;&t;&t; *&n;&t;&t;&t; *&t;a) The way tcp_data behaves at the bottom.&n;&t;&t;&t; *&t;b) A fin takes effect when read not when received.&n;&t;&t;&t; */
id|shut_seq
op_assign
id|sk-&gt;acked_seq
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Last byte */
r_if
c_cond
(paren
id|after
c_func
(paren
id|new_seq
comma
id|shut_seq
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Data arrived on %p after close [Data right edge %X, Socket shut on %X] %d&bslash;n&quot;
comma
id|sk
comma
id|new_seq
comma
id|shut_seq
comma
id|sk-&gt;blog
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;dead
)paren
(brace
id|sk-&gt;acked_seq
op_assign
id|new_seq
op_plus
id|th-&gt;fin
suffix:semicolon
id|tcp_reset
c_func
(paren
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
id|skb-&gt;h.th
comma
id|sk-&gt;prot
comma
l_int|NULL
comma
id|skb-&gt;dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
id|tcp_statistics.TcpEstabResets
op_increment
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|sk-&gt;err
op_assign
id|EPIPE
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * &t;Now we have to walk the chain, and figure out where this one&n;&t; * &t;goes into it.  This is set up so that the last packet we received&n;&t; * &t;will be the first one we look at, that way if everything comes&n;&t; * &t;in order, there will be no performance loss, and if they come&n;&t; * &t;out of order we will be able to fit things in nicely.&n;&t; *&n;&t; *&t;[AC: This is wrong. We should assume in order first and then walk&n;&t; *&t; forwards from the first hole based upon real traffic patterns.]&n;&t; *&t;&n;&t; */
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
op_eq
l_int|NULL
)paren
multiline_comment|/* Empty queue is easy case */
(brace
id|skb_queue_head
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
id|skb1
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|skb1
op_assign
id|sk-&gt;receive_queue.prev
suffix:semicolon
suffix:semicolon
id|skb1
op_assign
id|skb1-&gt;prev
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;skb1=%p :&quot;
comma
id|skb1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;skb1-&gt;h.th-&gt;seq = %d: &quot;
comma
id|skb1-&gt;h.th-&gt;seq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;skb-&gt;h.th-&gt;seq = %d&bslash;n&quot;
comma
id|skb-&gt;h.th-&gt;seq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;copied_seq = %d acked_seq = %d&bslash;n&quot;
comma
id|sk-&gt;copied_seq
comma
id|sk-&gt;acked_seq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;Optimisation: Duplicate frame or extension of previous frame from&n;&t;&t;&t; *&t;same sequence point (lost ack case).&n;&t;&t;&t; *&t;The frame contains duplicate data or replaces a previous frame&n;&t;&t;&t; *&t;discard the previous frame (safe as sk-&gt;inuse is set) and put&n;&t;&t;&t; *&t;the new one in its place.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|th-&gt;seq
op_eq
id|skb1-&gt;h.th-&gt;seq
op_logical_and
id|skb-&gt;len
op_ge
id|skb1-&gt;len
)paren
(brace
id|skb_append
c_func
(paren
id|skb1
comma
id|skb
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|skb1
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb1
comma
id|FREE_READ
)paren
suffix:semicolon
id|dup_dumped
op_assign
l_int|1
suffix:semicolon
id|skb1
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;Found where it fits&n;&t;&t;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|th-&gt;seq
op_plus
l_int|1
comma
id|skb1-&gt;h.th-&gt;seq
)paren
)paren
(brace
id|skb_append
c_func
(paren
id|skb1
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;See if we&squot;ve hit the start. If so insert.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb1
op_eq
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
(brace
id|skb_queue_head
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; *&t;Figure out what the ack value for this frame is&n;&t; */
id|th-&gt;ack_seq
op_assign
id|th-&gt;seq
op_plus
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;syn
)paren
id|th-&gt;ack_seq
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;fin
)paren
id|th-&gt;ack_seq
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|before
c_func
(paren
id|sk-&gt;acked_seq
comma
id|sk-&gt;copied_seq
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;*** tcp.c:tcp_data bug acked &lt; copied&bslash;n&quot;
)paren
suffix:semicolon
id|sk-&gt;acked_seq
op_assign
id|sk-&gt;copied_seq
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Now figure out if we can ack anything. This is very messy because we really want two&n;&t; *&t;receive queues, a completed and an assembly queue. We also want only one transmit&n;&t; *&t;queue.&n;&t; */
r_if
c_cond
(paren
(paren
op_logical_neg
id|dup_dumped
op_logical_and
(paren
id|skb1
op_eq
l_int|NULL
op_logical_or
id|skb1-&gt;acked
)paren
)paren
op_logical_or
id|before
c_func
(paren
id|th-&gt;seq
comma
id|sk-&gt;acked_seq
op_plus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|th-&gt;seq
comma
id|sk-&gt;acked_seq
op_plus
l_int|1
)paren
)paren
(brace
r_int
id|newwindow
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|th-&gt;ack_seq
comma
id|sk-&gt;acked_seq
)paren
)paren
(brace
id|newwindow
op_assign
id|sk-&gt;window
op_minus
(paren
id|th-&gt;ack_seq
op_minus
id|sk-&gt;acked_seq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newwindow
OL
l_int|0
)paren
id|newwindow
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;window
op_assign
id|newwindow
suffix:semicolon
id|sk-&gt;acked_seq
op_assign
id|th-&gt;ack_seq
suffix:semicolon
)brace
id|skb-&gt;acked
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;When we ack the fin, we do the FIN &n;&t;&t;&t; *&t;processing.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;fin
)paren
(brace
id|tcp_fin
c_func
(paren
id|skb
comma
id|sk
comma
id|skb-&gt;h.th
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|skb2
op_assign
id|skb-&gt;next
suffix:semicolon
id|skb2
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;receive_queue
suffix:semicolon
id|skb2
op_assign
id|skb2-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|skb2-&gt;h.th-&gt;seq
comma
id|sk-&gt;acked_seq
op_plus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|after
c_func
(paren
id|skb2-&gt;h.th-&gt;ack_seq
comma
id|sk-&gt;acked_seq
)paren
)paren
(brace
id|newwindow
op_assign
id|sk-&gt;window
op_minus
(paren
id|skb2-&gt;h.th-&gt;ack_seq
op_minus
id|sk-&gt;acked_seq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newwindow
OL
l_int|0
)paren
id|newwindow
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;window
op_assign
id|newwindow
suffix:semicolon
id|sk-&gt;acked_seq
op_assign
id|skb2-&gt;h.th-&gt;ack_seq
suffix:semicolon
)brace
id|skb2-&gt;acked
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * &t;When we ack the fin, we do&n;&t;&t;&t;&t;&t; * &t;the fin handling.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|skb2-&gt;h.th-&gt;fin
)paren
(brace
id|tcp_fin
c_func
(paren
id|skb
comma
id|sk
comma
id|skb-&gt;h.th
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;Force an immediate ack.&n;&t;&t;&t;&t;&t; */
id|sk-&gt;ack_backlog
op_assign
id|sk-&gt;max_ack_backlog
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;This also takes care of updating the window.&n;&t;&t;&t; *&t;This if statement needs to be simplified.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;delay_acks
op_logical_or
id|sk-&gt;ack_backlog
op_ge
id|sk-&gt;max_ack_backlog
op_logical_or
id|sk-&gt;bytes_rcv
OG
id|sk-&gt;max_unacked
op_logical_or
id|th-&gt;fin
)paren
(brace
multiline_comment|/*&t;&t;&t;tcp_send_ack(sk-&gt;sent_seq, sk-&gt;acked_seq,sk,th, saddr); */
)brace
r_else
(brace
id|sk-&gt;ack_backlog
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Ack queued.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|TCP_ACK_TIME
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; *&t;If we&squot;ve missed a packet, send an ack.&n;&t; *&t;Also start a timer to send another.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;acked
)paren
(brace
multiline_comment|/*&n;&t; *&t;This is important.  If we don&squot;t have much room left,&n;&t; *&t;we need to throw out a few packets so we have a good&n;&t; *&t;window.  Note that mtu is used, not mss, because mss is really&n;&t; *&t;for the send side.  He could be sending us stuff as large as mtu.&n;&t; */
r_while
c_loop
(paren
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
OL
id|sk-&gt;mtu
)paren
(brace
id|skb1
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb1
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;INET: tcp.c:tcp_data memory leak detected.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;Don&squot;t throw out something that has been acked. &n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb1-&gt;acked
)paren
(brace
r_break
suffix:semicolon
)brace
id|skb_unlink
c_func
(paren
id|skb1
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb1
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
id|tcp_send_ack
c_func
(paren
id|sk-&gt;sent_seq
comma
id|sk-&gt;acked_seq
comma
id|sk
comma
id|th
comma
id|saddr
)paren
suffix:semicolon
id|sk-&gt;ack_backlog
op_increment
suffix:semicolon
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|TCP_ACK_TIME
)paren
suffix:semicolon
)brace
r_else
(brace
id|tcp_send_ack
c_func
(paren
id|sk-&gt;sent_seq
comma
id|sk-&gt;acked_seq
comma
id|sk
comma
id|th
comma
id|saddr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Now tell the user we may have some data. &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Data wakeup.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine is only called when we have urgent data&n; *&t;signalled. Its the &squot;slow&squot; part of tcp_urg. It could be&n; *&t;moved inline now as tcp_urg is only called from one&n; *&t;place. We handle URGent data wrong. We have to - as&n; *&t;BSD still doesn&squot;t use the correction from RFC961.&n; */
DECL|function|tcp_check_urg
r_static
r_void
id|tcp_check_urg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
id|u32
id|ptr
op_assign
id|ntohs
c_func
(paren
id|th-&gt;urg_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
id|ptr
op_decrement
suffix:semicolon
id|ptr
op_add_assign
id|th-&gt;seq
suffix:semicolon
multiline_comment|/* ignore urgent data that we&squot;ve already seen and read */
r_if
c_cond
(paren
id|after
c_func
(paren
id|sk-&gt;copied_seq
comma
id|ptr
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* do we already have a newer (or duplicate) urgent pointer? */
r_if
c_cond
(paren
id|sk-&gt;urg_data
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|ptr
comma
id|sk-&gt;urg_seq
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* tell the world about our new urgent pointer */
r_if
c_cond
(paren
id|sk-&gt;proc
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;proc
OG
l_int|0
)paren
(brace
id|kill_proc
c_func
(paren
id|sk-&gt;proc
comma
id|SIGURG
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|kill_pg
c_func
(paren
op_minus
id|sk-&gt;proc
comma
id|SIGURG
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|sk-&gt;urg_data
op_assign
id|URG_NOTYET
suffix:semicolon
id|sk-&gt;urg_seq
op_assign
id|ptr
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is the &squot;fast&squot; part of urgent handling.&n; */
DECL|function|tcp_urg
r_extern
id|__inline__
r_int
id|tcp_urg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|len
)paren
(brace
id|u32
id|ptr
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Check if we get a new urgent pointer - normally not &n;&t; */
r_if
c_cond
(paren
id|th-&gt;urg
)paren
id|tcp_check_urg
c_func
(paren
id|sk
comma
id|th
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Do we wait for any urgent data? - normally not&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;urg_data
op_ne
id|URG_NOTYET
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Is the urgent pointer pointing into this packet? &n;&t; */
id|ptr
op_assign
id|sk-&gt;urg_seq
op_minus
id|th-&gt;seq
op_plus
id|th-&gt;doff
op_star
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_ge
id|len
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Ok, got the correct packet, update info &n;&t; */
id|sk-&gt;urg_data
op_assign
id|URG_VALID
op_or
op_star
(paren
id|ptr
op_plus
(paren
r_int
r_char
op_star
)paren
id|th
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This will accept the next outstanding connection. &n; */
DECL|function|tcp_accept
r_static
r_struct
id|sock
op_star
id|tcp_accept
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
)paren
(brace
r_struct
id|sock
op_star
id|newsk
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/*&n;   * We need to make sure that this socket is listening,&n;   * and that it has something pending.&n;   */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_LISTEN
)paren
(brace
id|sk-&gt;err
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Avoid the race. */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|tcp_dequeue_established
c_func
(paren
id|sk
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;err
op_assign
id|EAGAIN
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;err
op_assign
id|ERESTARTSYS
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now all we need to do is return skb-&gt;sk. &n;&t; */
id|newsk
op_assign
id|skb-&gt;sk
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|sk-&gt;ack_backlog
op_decrement
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|newsk
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This will initiate an outgoing connection. &n; */
DECL|function|tcp_connect
r_static
r_int
id|tcp_connect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr_in
op_star
id|usin
comma
r_int
id|addr_len
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_int
id|atype
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_CLOSE
)paren
(brace
r_return
op_minus
id|EISCONN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr_len
OL
l_int|8
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|usin-&gt;sin_family
op_logical_and
id|usin-&gt;sin_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
multiline_comment|/*&n;  &t; *&t;connect() to INADDR_ANY means loopback (BSD&squot;ism).&n;  &t; */
r_if
c_cond
(paren
id|usin-&gt;sin_addr.s_addr
op_eq
id|INADDR_ANY
)paren
(brace
id|usin-&gt;sin_addr.s_addr
op_assign
id|ip_my_addr
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Don&squot;t want a TCP connection going to a broadcast address &n;&t; */
r_if
c_cond
(paren
(paren
id|atype
op_assign
id|ip_chk_addr
c_func
(paren
id|usin-&gt;sin_addr.s_addr
)paren
)paren
op_eq
id|IS_BROADCAST
op_logical_or
id|atype
op_eq
id|IS_MULTICAST
)paren
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;daddr
op_assign
id|usin-&gt;sin_addr.s_addr
suffix:semicolon
id|sk-&gt;write_seq
op_assign
id|tcp_init_seq
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;window_seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|sk-&gt;rcv_ack_seq
op_assign
id|sk-&gt;write_seq
op_minus
l_int|1
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;dummy_th.dest
op_assign
id|usin-&gt;sin_port
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|buff
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|MAX_SYN_SIZE
comma
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|buff-&gt;free
op_assign
l_int|0
suffix:semicolon
id|buff-&gt;localroute
op_assign
id|sk-&gt;localroute
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Put in the IP header and routing stuff. &n;&t; */
id|rt
op_assign
id|ip_rt_route
c_func
(paren
id|sk-&gt;daddr
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We need to build the routing stuff from the things saved in skb. &n;&t; */
id|tmp
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
l_int|NULL
comma
id|MAX_SYN_SIZE
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sk-&gt;prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
)brace
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
(paren
r_void
op_star
)paren
op_amp
(paren
id|sk-&gt;dummy_th
)paren
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
id|t1-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|sk-&gt;write_seq
op_increment
)paren
suffix:semicolon
id|sk-&gt;sent_seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|buff-&gt;h.seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;window
op_assign
l_int|2
suffix:semicolon
id|t1-&gt;res1
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;res2
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;syn
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;urg_ptr
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;doff
op_assign
l_int|6
suffix:semicolon
multiline_comment|/* use 512 or whatever user asked for */
r_if
c_cond
(paren
id|rt
op_ne
l_int|NULL
op_logical_and
(paren
id|rt-&gt;rt_flags
op_amp
id|RTF_WINDOW
)paren
)paren
(brace
id|sk-&gt;window_clamp
op_assign
id|rt-&gt;rt_window
suffix:semicolon
)brace
r_else
id|sk-&gt;window_clamp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;user_mss
)paren
id|sk-&gt;mtu
op_assign
id|sk-&gt;user_mss
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rt
op_ne
l_int|NULL
op_logical_and
(paren
id|rt-&gt;rt_flags
op_amp
id|RTF_MTU
)paren
)paren
(brace
id|sk-&gt;mtu
op_assign
id|rt-&gt;rt_mss
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_INET_SNARL
r_if
c_cond
(paren
(paren
id|sk-&gt;saddr
op_xor
id|sk-&gt;daddr
)paren
op_amp
id|default_mask
c_func
(paren
id|sk-&gt;saddr
)paren
)paren
macro_line|#else
r_if
c_cond
(paren
(paren
id|sk-&gt;saddr
op_xor
id|sk-&gt;daddr
)paren
op_amp
id|dev-&gt;pa_mask
)paren
macro_line|#endif
id|sk-&gt;mtu
op_assign
l_int|576
op_minus
id|HEADER_SIZE
suffix:semicolon
r_else
id|sk-&gt;mtu
op_assign
id|MAX_WINDOW
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;but not bigger than device MTU &n;&t; */
r_if
c_cond
(paren
id|sk-&gt;mtu
OL
l_int|32
)paren
(brace
id|sk-&gt;mtu
op_assign
l_int|32
suffix:semicolon
)brace
multiline_comment|/* Sanity limit */
id|sk-&gt;mtu
op_assign
id|min
c_func
(paren
id|sk-&gt;mtu
comma
id|dev-&gt;mtu
op_minus
id|HEADER_SIZE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Put in the TCP options to say MTU. &n;&t; */
id|ptr
op_assign
id|skb_put
c_func
(paren
id|buff
comma
l_int|4
)paren
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
l_int|2
suffix:semicolon
id|ptr
(braket
l_int|1
)braket
op_assign
l_int|4
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
(paren
id|sk-&gt;mtu
)paren
op_rshift
l_int|8
suffix:semicolon
id|ptr
(braket
l_int|3
)braket
op_assign
(paren
id|sk-&gt;mtu
)paren
op_amp
l_int|0xff
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
l_int|4
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This must go first otherwise a really quick response will get reset. &n;&t; */
id|tcp_cache_zap
c_func
(paren
)paren
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_SYN_SENT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_logical_and
id|rt-&gt;rt_flags
op_amp
id|RTF_IRTT
)paren
(brace
id|sk-&gt;rto
op_assign
id|rt-&gt;rt_irtt
suffix:semicolon
)brace
r_else
id|sk-&gt;rto
op_assign
id|TCP_TIMEOUT_INIT
suffix:semicolon
id|sk-&gt;retransmit_timer.function
op_assign
op_amp
id|retransmit_timer
suffix:semicolon
id|sk-&gt;retransmit_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
multiline_comment|/* Timer for repeating the SYN until an answer */
id|sk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Now works the right way instead of a hacked initial setting */
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|0
)paren
suffix:semicolon
id|reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
id|tcp_statistics.TcpActiveOpens
op_increment
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This functions checks to see if the tcp header is actually acceptable. */
DECL|function|tcp_sequence
r_extern
id|__inline__
r_int
id|tcp_sequence
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
comma
r_struct
id|options
op_star
id|opt
comma
r_int
r_int
id|saddr
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
id|u32
id|next_seq
suffix:semicolon
id|next_seq
op_assign
id|len
op_minus
l_int|4
op_star
id|th-&gt;doff
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;fin
)paren
id|next_seq
op_increment
suffix:semicolon
multiline_comment|/* if we have a zero window, we can&squot;t have any data in the packet.. */
r_if
c_cond
(paren
id|next_seq
op_logical_and
op_logical_neg
id|sk-&gt;window
)paren
r_goto
id|ignore_it
suffix:semicolon
id|next_seq
op_add_assign
id|th-&gt;seq
suffix:semicolon
multiline_comment|/*&n;&t; * This isn&squot;t quite right.  sk-&gt;acked_seq could be more recent&n;&t; * than sk-&gt;window.  This is however close enough.  We will accept&n;&t; * slightly more packets than we should, but it should not cause&n;&t; * problems unless someone is trying to forge packets.&n;&t; */
multiline_comment|/* have we already seen all of this packet? */
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|next_seq
op_plus
l_int|1
comma
id|sk-&gt;acked_seq
)paren
)paren
r_goto
id|ignore_it
suffix:semicolon
multiline_comment|/* or does it start beyond the window? */
r_if
c_cond
(paren
op_logical_neg
id|before
c_func
(paren
id|th-&gt;seq
comma
id|sk-&gt;acked_seq
op_plus
id|sk-&gt;window
op_plus
l_int|1
)paren
)paren
r_goto
id|ignore_it
suffix:semicolon
multiline_comment|/* ok, at least part of this packet would seem interesting.. */
r_return
l_int|1
suffix:semicolon
id|ignore_it
suffix:colon
r_if
c_cond
(paren
id|th-&gt;rst
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Send a reset if we get something not ours and we are&n;&t; *&t;unsynchronized. Note: We don&squot;t do anything to our end. We&n;&t; *&t;are just killing the bogus remote connection then we will&n;&t; *&t;connect again and it will work (with luck).&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_SYN_RECV
)paren
(brace
id|tcp_reset
c_func
(paren
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
id|th
comma
id|sk-&gt;prot
comma
l_int|NULL
comma
id|dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Try to resync things. */
id|tcp_send_ack
c_func
(paren
id|sk-&gt;sent_seq
comma
id|sk-&gt;acked_seq
comma
id|sk
comma
id|th
comma
id|saddr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;When we get a reset we do this.&n; */
DECL|function|tcp_std_reset
r_static
r_int
id|tcp_std_reset
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|sk-&gt;zapped
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;err
op_assign
id|ECONNRESET
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
)paren
id|sk-&gt;err
op_assign
id|ECONNREFUSED
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE_WAIT
)paren
id|sk-&gt;err
op_assign
id|EPIPE
suffix:semicolon
macro_line|#ifdef TCP_DO_RFC1337&t;&t;
multiline_comment|/*&n;&t; *&t;Time wait assassination protection [RFC1337]&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_TIME_WAIT
)paren
(brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
)brace
macro_line|#else&t;
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
macro_line|#endif&t;
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;A TCP packet has arrived.&n; *&t;&t;skb-&gt;h.raw is the TCP header.&n; */
DECL|function|tcp_rcv
r_int
id|tcp_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|options
op_star
id|opt
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|saddr
comma
r_int
id|redo
comma
r_struct
id|inet_protocol
op_star
id|protocol
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_int
id|syn_ok
op_assign
l_int|0
suffix:semicolon
id|tcp_statistics.TcpInSegs
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;pkt_type
op_ne
id|PACKET_HOST
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Find the socket, using the last hit cache if applicable.&n;&t; */
r_if
c_cond
(paren
id|saddr
op_eq
id|th_cache_saddr
op_logical_and
id|daddr
op_eq
id|th_cache_daddr
op_logical_and
id|th-&gt;dest
op_eq
id|th_cache_dport
op_logical_and
id|th-&gt;source
op_eq
id|th_cache_sport
)paren
(brace
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|th_cache_sk
suffix:semicolon
)brace
r_else
(brace
id|sk
op_assign
id|get_sock
c_func
(paren
op_amp
id|tcp_prot
comma
id|th-&gt;dest
comma
id|saddr
comma
id|th-&gt;source
comma
id|daddr
)paren
suffix:semicolon
id|th_cache_saddr
op_assign
id|saddr
suffix:semicolon
id|th_cache_daddr
op_assign
id|daddr
suffix:semicolon
id|th_cache_dport
op_assign
id|th-&gt;dest
suffix:semicolon
id|th_cache_sport
op_assign
id|th-&gt;source
suffix:semicolon
id|th_cache_sk
op_assign
id|sk
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If this socket has got a reset it&squot;s to all intents and purposes &n;  &t; *&t;really dead. Count closed sockets as dead.&n;  &t; *&n;  &t; *&t;Note: BSD appears to have a bug here. A &squot;closed&squot; TCP in BSD&n;  &t; *&t;simply drops data. This seems incorrect as a &squot;closed&squot; TCP doesn&squot;t&n;  &t; *&t;exist so should cause resets as if the port was unreachable.&n;  &t; */
r_if
c_cond
(paren
id|sk
op_ne
l_int|NULL
op_logical_and
(paren
id|sk-&gt;zapped
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
)paren
id|sk
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|redo
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Pull up the IP header.&n;&t;&t; */
id|skb_pull
c_func
(paren
id|skb
comma
id|skb-&gt;h.raw
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Try to use the device checksum if provided.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|skb-&gt;ip_summed
op_logical_and
id|tcp_check
c_func
(paren
id|th
comma
id|len
comma
id|saddr
comma
id|daddr
comma
id|skb-&gt;csum
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|skb-&gt;ip_summed
op_logical_and
id|tcp_check
c_func
(paren
id|th
comma
id|len
comma
id|saddr
comma
id|daddr
comma
id|csum_partial
c_func
(paren
(paren
r_char
op_star
)paren
id|th
comma
id|len
comma
l_int|0
)paren
)paren
)paren
)paren
(brace
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;We don&squot;t release the socket because it was&n;&t;&t;&t; *&t;never marked in use.&n;&t;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
id|th-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
suffix:semicolon
multiline_comment|/* See if we know about the socket. */
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;No such TCB. If th-&gt;rst is 0 send a reset (checked in tcp_reset)&n;&t;&t;&t; */
id|tcp_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
op_amp
id|tcp_prot
comma
id|opt
comma
id|dev
comma
id|skb-&gt;ip_hdr-&gt;tos
comma
l_int|255
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Discard frame&n;&t;&t;&t; */
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&t;&t;skb-&gt;len = len;*/
id|skb-&gt;acked
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;used
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;saddr
op_assign
id|daddr
suffix:semicolon
id|skb-&gt;daddr
op_assign
id|saddr
suffix:semicolon
multiline_comment|/* We may need to add it to the backlog here. */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;inuse
)paren
(brace
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;back_log
comma
id|skb
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
id|tcp_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
op_amp
id|tcp_prot
comma
id|opt
comma
id|dev
comma
id|skb-&gt;ip_hdr-&gt;tos
comma
l_int|255
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;prot
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IMPOSSIBLE 3&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Charge the memory to the socket. &n;&t; */
r_if
c_cond
(paren
id|sk-&gt;rmem_alloc
op_plus
id|skb-&gt;truesize
op_ge
id|sk-&gt;rcvbuf
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|sk-&gt;rmem_alloc
op_add_assign
id|skb-&gt;truesize
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This basically follows the flow suggested by RFC793, with the corrections in RFC1122. We&n;&t; *&t;don&squot;t implement precedence and we process URG incorrectly (deliberately so) for BSD bug&n;&t; *&t;compatibility. We also set up variables more thoroughly [Karn notes in the&n;&t; *&t;KA9Q code the RFC793 incoming segment rules don&squot;t initialise the variables for all paths].&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
)paren
multiline_comment|/* Skip this lot for normal flow */
(brace
multiline_comment|/*&n;&t;&t; *&t;Now deal with unusual cases.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
(brace
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
multiline_comment|/* These use the socket TOS.. might want to be the received TOS */
id|tcp_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;We don&squot;t care for RST, and non SYN are absorbed (old segments)&n;&t;&t;&t; *&t;Broadcast/multicast SYN isn&squot;t allowed. Note - bug if you change the&n;&t;&t;&t; *&t;netmask on a running connection it can go broadcast. Even Sun&squot;s have&n;&t;&t;&t; *&t;this problem so I&squot;m ignoring it &n;&t;&t;&t; */
r_if
c_cond
(paren
id|th-&gt;rst
op_logical_or
op_logical_neg
id|th-&gt;syn
op_logical_or
id|th-&gt;ack
op_logical_or
id|ip_chk_addr
c_func
(paren
id|daddr
)paren
op_ne
id|IS_MYADDR
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&t;&n;&t;&t;&t; *&t;Guess we need to make a new socket up &n;&t;&t;&t; */
id|tcp_conn_request
c_func
(paren
id|sk
comma
id|skb
comma
id|daddr
comma
id|saddr
comma
id|opt
comma
id|dev
comma
id|tcp_init_seq
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Now we have several options: In theory there is nothing else&n;&t;&t;&t; *&t;in the frame. KA9Q has an option to send data with the syn,&n;&t;&t;&t; *&t;BSD accepts data with the syn up to the [to be] advertised window&n;&t;&t;&t; *&t;and Solaris 2.1 gives you a protocol error. For now we just ignore&n;&t;&t;&t; *&t;it, that fits the spec precisely and avoids incompatibilities. It&n;&t;&t;&t; *&t;would be nice in future to drop through and process the data.&n;&t;&t;&t; */
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* retransmitted SYN? */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_RECV
op_logical_and
id|th-&gt;syn
op_logical_and
id|th-&gt;seq
op_plus
l_int|1
op_eq
id|sk-&gt;acked_seq
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;SYN sent means we have to look for a suitable ack and either reset&n;&t;&t; *&t;for bad matches or go to connected &n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
)paren
(brace
multiline_comment|/* Crossed SYN or previous junk segment */
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
multiline_comment|/* We got an ack, but it&squot;s not a good ack */
r_if
c_cond
(paren
op_logical_neg
id|tcp_ack
c_func
(paren
id|sk
comma
id|th
comma
id|saddr
comma
id|len
)paren
)paren
(brace
multiline_comment|/* Reset the ack - its an ack from a &n;&t;&t;&t;&t;&t;   different connection  [ th-&gt;rst is checked in tcp_reset()] */
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|tcp_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
r_return
id|tcp_std_reset
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;syn
)paren
(brace
multiline_comment|/* A valid ack from a different connection&n;&t;&t;&t;&t;&t;   start. Shouldn&squot;t happen but cover it */
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Ok.. it&squot;s good. Set up sequence numbers and&n;&t;&t;&t;&t; *&t;move to established.&n;&t;&t;&t;&t; */
id|syn_ok
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Don&squot;t reset this connection for the syn */
id|sk-&gt;acked_seq
op_assign
id|th-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|sk-&gt;fin_seq
op_assign
id|th-&gt;seq
suffix:semicolon
id|tcp_send_ack
c_func
(paren
id|sk-&gt;sent_seq
comma
id|sk-&gt;acked_seq
comma
id|sk
comma
id|th
comma
id|sk-&gt;daddr
)paren
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_ESTABLISHED
)paren
suffix:semicolon
id|tcp_options
c_func
(paren
id|sk
comma
id|th
)paren
suffix:semicolon
id|sk-&gt;dummy_th.dest
op_assign
id|th-&gt;source
suffix:semicolon
id|sk-&gt;copied_seq
op_assign
id|sk-&gt;acked_seq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sock_wake_async
c_func
(paren
id|sk-&gt;socket
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;max_window
op_eq
l_int|0
)paren
(brace
id|sk-&gt;max_window
op_assign
l_int|32
suffix:semicolon
id|sk-&gt;mss
op_assign
id|min
c_func
(paren
id|sk-&gt;max_window
comma
id|sk-&gt;mtu
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* See if SYN&squot;s cross. Drop if boring */
r_if
c_cond
(paren
id|th-&gt;syn
op_logical_and
op_logical_neg
id|th-&gt;rst
)paren
(brace
multiline_comment|/* Crossed SYN&squot;s are fine - but talking to&n;&t;&t;&t;&t;&t;   yourself is right out... */
r_if
c_cond
(paren
id|sk-&gt;saddr
op_eq
id|saddr
op_logical_and
id|sk-&gt;daddr
op_eq
id|daddr
op_logical_and
id|sk-&gt;dummy_th.source
op_eq
id|th-&gt;source
op_logical_and
id|sk-&gt;dummy_th.dest
op_eq
id|th-&gt;dest
)paren
(brace
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
r_return
id|tcp_std_reset
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_SYN_RECV
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;FIXME:&n;&t;&t;&t;&t;&t; *&t;Must send SYN|ACK here&n;&t;&t;&t;&t;&t; */
)brace
multiline_comment|/* Discard junk segment */
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;SYN_RECV with data maybe.. drop through&n;&t;&t;&t; */
r_goto
id|rfc_step6
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;BSD has a funny hack with TIME_WAIT and fast reuse of a port. There is&n;&t; *&t;a more complex suggestion for fixing these reuse issues in RFC1644&n;&t; *&t;but not yet ready for general use. Also see RFC1379.&n;&t; */
DECL|macro|BSD_TIME_WAIT
mdefine_line|#define BSD_TIME_WAIT
macro_line|#ifdef BSD_TIME_WAIT
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_TIME_WAIT
op_logical_and
id|th-&gt;syn
op_logical_and
id|sk-&gt;dead
op_logical_and
id|after
c_func
(paren
id|th-&gt;seq
comma
id|sk-&gt;acked_seq
)paren
op_logical_and
op_logical_neg
id|th-&gt;rst
)paren
(brace
id|u32
id|seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Doing a BSD time wait&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|tcp_statistics.TcpEstabResets
op_increment
suffix:semicolon
id|sk-&gt;rmem_alloc
op_sub_assign
id|skb-&gt;truesize
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;err
op_assign
id|ECONNRESET
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk
op_assign
id|get_sock
c_func
(paren
op_amp
id|tcp_prot
comma
id|th-&gt;dest
comma
id|saddr
comma
id|th-&gt;source
comma
id|daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_logical_and
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
(brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|sk-&gt;rmem_alloc
op_add_assign
id|skb-&gt;truesize
suffix:semicolon
id|tcp_conn_request
c_func
(paren
id|sk
comma
id|skb
comma
id|daddr
comma
id|saddr
comma
id|opt
comma
id|dev
comma
id|seq
op_plus
l_int|128000
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;
)brace
multiline_comment|/*&n;&t; *&t;We are now in normal data flow (see the step list in the RFC)&n;&t; *&t;Note most of these are inline now. I&squot;ll inline the lot when&n;&t; *&t;I have time to test it hard and look at what gcc outputs &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tcp_sequence
c_func
(paren
id|sk
comma
id|th
comma
id|len
comma
id|opt
comma
id|saddr
comma
id|dev
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
r_return
id|tcp_std_reset
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;!syn_ok is effectively the state test in RFC793.&n;&t; */
r_if
c_cond
(paren
id|th-&gt;syn
op_logical_and
op_logical_neg
id|syn_ok
)paren
(brace
id|tcp_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
op_amp
id|tcp_prot
comma
id|opt
comma
id|dev
comma
id|skb-&gt;ip_hdr-&gt;tos
comma
l_int|255
)paren
suffix:semicolon
r_return
id|tcp_std_reset
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Process the ACK&n;&t; */
r_if
c_cond
(paren
id|th-&gt;ack
op_logical_and
op_logical_neg
id|tcp_ack
c_func
(paren
id|sk
comma
id|th
comma
id|saddr
comma
id|len
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Our three way handshake failed.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_RECV
)paren
(brace
id|tcp_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|rfc_step6
suffix:colon
multiline_comment|/* I&squot;ll clean this up later */
multiline_comment|/*&n;&t; *&t;Process urgent data&n;&t; */
r_if
c_cond
(paren
id|tcp_urg
c_func
(paren
id|sk
comma
id|th
comma
id|saddr
comma
id|len
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Process the encapsulated data&n;&t; */
r_if
c_cond
(paren
id|tcp_data
c_func
(paren
id|skb
comma
id|sk
comma
id|saddr
comma
id|len
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;And done&n;&t; */
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine sends a packet with an out of date sequence&n; *&t;number. It assumes the other end will try to ack it.&n; */
DECL|function|tcp_write_wakeup
r_static
r_void
id|tcp_write_wakeup
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
comma
op_star
id|skb
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
r_return
suffix:semicolon
multiline_comment|/* After a valid reset we can send no more */
multiline_comment|/*&n;&t; *&t;Write data can still be transmitted/retransmitted in the&n;&t; *&t;following states.  If any other state is encountered, return.&n;&t; *&t;[listen/close will never occur here anyway]&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_CLOSE_WAIT
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_FIN_WAIT1
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_LAST_ACK
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_CLOSING
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|sk-&gt;sent_seq
comma
id|sk-&gt;window_seq
)paren
op_logical_and
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;    &t; * We are probing the opening of a window&n;&t;    &t; * but the window size is != 0&n;&t;    &t; * must have been a result SWS advoidance ( sender )&n;&t;    &t; */
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|tcphdr
op_star
id|nth
suffix:semicolon
r_int
r_int
id|win_size
comma
id|ow_size
suffix:semicolon
r_void
op_star
id|tcp_data_start
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;How many bytes can we send ?&n;&t;&t; */
id|win_size
op_assign
id|sk-&gt;window_seq
op_minus
id|sk-&gt;sent_seq
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Recover the buffer pointers&n;&t;&t; */
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb-&gt;ip_hdr
suffix:semicolon
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|iph
)paren
op_plus
(paren
id|iph-&gt;ihl
op_lshift
l_int|2
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Grab the data for a temporary frame&n;&t;&t; */
id|buff
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|win_size
op_plus
id|th-&gt;doff
op_star
l_int|4
op_plus
(paren
id|iph-&gt;ihl
op_lshift
l_int|2
)paren
op_plus
id|sk-&gt;prot-&gt;max_header
op_plus
l_int|15
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* &n;&t; &t; *&t;If we strip the packet on the write queue we must&n;&t; &t; *&t;be ready to retransmit this one &n;&t; &t; */
id|buff-&gt;free
op_assign
multiline_comment|/*0*/
l_int|1
suffix:semicolon
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|buff-&gt;localroute
op_assign
id|sk-&gt;localroute
suffix:semicolon
multiline_comment|/*&n;&t;    &t; *&t;Put headers on the new packet&n;&t;    &t; */
id|tmp
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|buff-&gt;truesize
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sk-&gt;prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Move the TCP header over&n;&t;&t; */
id|buff-&gt;dev
op_assign
id|dev
suffix:semicolon
id|nth
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
id|th-&gt;doff
op_star
l_int|4
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|nth
comma
id|th
comma
id|th-&gt;doff
op_star
l_int|4
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Correct the new header&n;&t;&t; */
id|nth-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|nth-&gt;ack_seq
op_assign
id|ntohl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|nth-&gt;window
op_assign
id|ntohs
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|nth-&gt;check
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Find the first data byte.&n;&t;&t; */
id|tcp_data_start
op_assign
id|skb-&gt;data
op_plus
id|skb-&gt;dev-&gt;hard_header_len
op_plus
(paren
id|iph-&gt;ihl
op_lshift
l_int|2
)paren
op_plus
id|th-&gt;doff
op_star
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Add it to our new buffer&n;&t;&t; */
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|buff
comma
id|win_size
)paren
comma
id|tcp_data_start
comma
id|win_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Remember our right edge sequence number.&n;&t;&t; */
id|buff-&gt;h.seq
op_assign
id|sk-&gt;sent_seq
op_plus
id|win_size
suffix:semicolon
id|sk-&gt;sent_seq
op_assign
id|buff-&gt;h.seq
suffix:semicolon
multiline_comment|/* Hack */
macro_line|#if 0
multiline_comment|/*&n;&t;    &t; *&t;now: shrink the queue head segment &n;&t;    &t; */
id|th-&gt;check
op_assign
l_int|0
suffix:semicolon
id|ow_size
op_assign
id|skb-&gt;len
op_minus
id|win_size
op_minus
(paren
(paren
r_int
r_int
)paren
(paren
id|tcp_data_start
op_minus
(paren
r_void
op_star
)paren
id|skb-&gt;data
)paren
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|tcp_data_start
comma
id|tcp_data_start
op_plus
id|win_size
comma
id|ow_size
)paren
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
id|skb-&gt;len
op_minus
id|win_size
)paren
suffix:semicolon
id|sk-&gt;sent_seq
op_add_assign
id|win_size
suffix:semicolon
id|th-&gt;seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;sent_seq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;urg
)paren
(brace
r_int
r_int
id|urg_ptr
suffix:semicolon
id|urg_ptr
op_assign
id|ntohs
c_func
(paren
id|th-&gt;urg_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urg_ptr
op_le
id|win_size
)paren
id|th-&gt;urg
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|urg_ptr
op_sub_assign
id|win_size
suffix:semicolon
id|th-&gt;urg_ptr
op_assign
id|htons
c_func
(paren
id|urg_ptr
)paren
suffix:semicolon
id|nth-&gt;urg_ptr
op_assign
id|htons
c_func
(paren
id|win_size
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
r_if
c_cond
(paren
id|th-&gt;urg
op_logical_and
id|ntohs
c_func
(paren
id|th-&gt;urg_ptr
)paren
OL
id|win_size
)paren
(brace
id|nth-&gt;urg
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;      &t;
multiline_comment|/*&n;&t;&t; *&t;Checksum the split buffer&n;&t;&t; */
id|tcp_send_check
c_func
(paren
id|nth
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
id|nth-&gt;doff
op_star
l_int|4
op_plus
id|win_size
comma
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
id|buff
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|MAX_ACK_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|buff-&gt;localroute
op_assign
id|sk-&gt;localroute
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Put in the IP header and routing stuff. &n;&t;&t; */
id|tmp
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|MAX_ACK_SIZE
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sk-&gt;prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
(paren
r_void
op_star
)paren
op_amp
id|sk-&gt;dummy_th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Use a previous sequence.&n;&t;&t; *&t;This should cause the other end to send an ack.&n;&t;&t; */
id|t1-&gt;seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;sent_seq
op_minus
l_int|1
)paren
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;res1
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;res2
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;fin
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We are sending a &squot;previous&squot; sequence, and 0 bytes of data - thus no FIN bit */
id|t1-&gt;syn
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|ntohl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|t1-&gt;window
op_assign
id|ntohs
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Send it.&n;&t; */
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|1
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;A window probe timeout has occurred.&n; */
DECL|function|tcp_send_probe0
r_void
id|tcp_send_probe0
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
r_return
suffix:semicolon
multiline_comment|/* After a valid reset we can send no more */
id|tcp_write_wakeup
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;backoff
op_increment
suffix:semicolon
id|sk-&gt;rto
op_assign
id|min
c_func
(paren
id|sk-&gt;rto
op_lshift
l_int|1
comma
l_int|120
op_star
id|HZ
)paren
suffix:semicolon
id|reset_xmit_timer
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|sk-&gt;rto
)paren
suffix:semicolon
id|sk-&gt;retransmits
op_increment
suffix:semicolon
id|sk-&gt;prot-&gt;retransmits
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Socket option code for TCP. &n; */
DECL|function|tcp_setsockopt
r_int
id|tcp_setsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_int
id|val
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
id|level
op_ne
id|SOL_TCP
)paren
(brace
r_return
id|ip_setsockopt
c_func
(paren
id|sk
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|optval
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|optval
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|val
op_assign
id|get_user
c_func
(paren
(paren
r_int
op_star
)paren
id|optval
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|TCP_MAXSEG
suffix:colon
multiline_comment|/*&n; * values greater than interface MTU won&squot;t take effect.  however at&n; * the point when this call is done we typically don&squot;t yet know&n; * which interface is going to be used&n; */
r_if
c_cond
(paren
id|val
id|MAX_WINDOW
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|sk-&gt;user_mss
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TCP_NODELAY
suffix:colon
id|sk-&gt;nonagle
op_assign
(paren
id|val
op_eq
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
)brace
)brace
DECL|function|tcp_getsockopt
r_int
id|tcp_getsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
r_int
id|val
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
id|level
op_ne
id|SOL_TCP
)paren
(brace
r_return
id|ip_getsockopt
c_func
(paren
id|sk
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|TCP_MAXSEG
suffix:colon
id|val
op_assign
id|sk-&gt;user_mss
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_NODELAY
suffix:colon
id|val
op_assign
id|sk-&gt;nonagle
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
)brace
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|optlen
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_user
c_func
(paren
r_sizeof
(paren
r_int
)paren
comma
(paren
r_int
op_star
)paren
id|optlen
)paren
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|optval
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|optval
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|tcp_prot
r_struct
id|proto
id|tcp_prot
op_assign
(brace
id|sock_wmalloc
comma
id|sock_rmalloc
comma
id|sock_wfree
comma
id|sock_rfree
comma
id|sock_rspace
comma
id|sock_wspace
comma
id|tcp_close
comma
id|tcp_read
comma
id|tcp_write
comma
id|tcp_sendto
comma
id|tcp_recvfrom
comma
id|ip_build_header
comma
id|tcp_connect
comma
id|tcp_accept
comma
id|ip_queue_xmit
comma
id|tcp_retransmit
comma
id|tcp_write_wakeup
comma
id|tcp_read_wakeup
comma
id|tcp_rcv
comma
id|tcp_select
comma
id|tcp_ioctl
comma
l_int|NULL
comma
id|tcp_shutdown
comma
id|tcp_setsockopt
comma
id|tcp_getsockopt
comma
l_int|128
comma
l_int|0
comma
l_string|&quot;TCP&quot;
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|NULL
comma
)brace
)brace
suffix:semicolon
eof
