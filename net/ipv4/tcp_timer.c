multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Implementation of the Transmission Control Protocol(TCP).&n; *&n; * Version:&t;@(#)tcp.c&t;1.0.16&t;05/25/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;&n; *&t;&t;Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; */
macro_line|#include &lt;net/tcp.h&gt;
multiline_comment|/*&n; *&t;Reset the retransmission timer&n; */
DECL|function|tcp_reset_xmit_timer
r_void
id|tcp_reset_xmit_timer
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|why
comma
r_int
r_int
id|when
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;retransmit_timer
)paren
suffix:semicolon
id|sk-&gt;ip_xmit_timeout
op_assign
id|why
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|when
OL
l_int|0
)paren
(brace
id|when
op_assign
l_int|3
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Error: Negative timer in xmit_timer&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|sk-&gt;retransmit_timer.expires
op_assign
id|jiffies
op_plus
id|when
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;retransmit_timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;POLICY:&n; *&n; * &t;This is the normal code called for timeouts.  It does the retransmission&n; * &t;and then does backoff.  tcp_do_retransmit is separated out because&n; * &t;tcp_ack needs to send stuff from the retransmit queue without&n; * &t;initiating a backoff.&n; */
DECL|function|tcp_retransmit_time
r_static
r_void
id|tcp_retransmit_time
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|all
)paren
(brace
id|tcp_do_retransmit
c_func
(paren
id|sk
comma
id|all
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Increase the timeout each time we retransmit.  Note that&n;&t; * we do not increase the rtt estimate.  rto is initialized&n;&t; * from rtt, but increases here.  Jacobson (SIGCOMM 88) suggests&n;&t; * that doubling rto each time is the least we can get away with.&n;&t; * In KA9Q, Karn uses this for the first few times, and then&n;&t; * goes to quadratic.  netBSD doubles, but only goes up to *64,&n;&t; * and clamps at 1 to 64 sec afterwards.  Note that 120 sec is&n;&t; * defined in the protocol as the maximum possible RTT.  I guess&n;&t; * we&squot;ll have to use something other than TCP to talk to the&n;&t; * University of Mars.&n;&t; *&n;&t; * PAWS allows us longer timeouts and large windows, so once&n;&t; * implemented ftp to mars will work nicely. We will have to fix&n;&t; * the 120 second clamps though!&n;&t; */
id|sk-&gt;retransmits
op_increment
suffix:semicolon
id|sk-&gt;prot-&gt;retransmits
op_increment
suffix:semicolon
id|sk-&gt;backoff
op_increment
suffix:semicolon
id|sk-&gt;rto
op_assign
id|min
c_func
(paren
id|sk-&gt;rto
op_lshift
l_int|1
comma
l_int|120
op_star
id|HZ
)paren
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;POLICY:&n; *&t;&t;Congestion control.&n; *&n; *&t;A timer event has trigger a tcp retransmit timeout. The&n; *&t;socket xmit queue is ready and set up to send. Because&n; *&t;the ack receive code keeps the queue straight we do&n; *&t;nothing clever here.&n; */
DECL|function|tcp_retransmit
r_void
id|tcp_retransmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|all
)paren
(brace
r_if
c_cond
(paren
id|all
)paren
(brace
id|tcp_retransmit_time
c_func
(paren
id|sk
comma
id|all
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sk-&gt;ssthresh
op_assign
id|sk-&gt;cong_window
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/* remember window where we lost */
multiline_comment|/* sk-&gt;ssthresh in theory can be zero.  I guess that&squot;s OK */
id|sk-&gt;cong_count
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;cong_window
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Do the actual retransmit. */
id|tcp_retransmit_time
c_func
(paren
id|sk
comma
id|all
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;A write timeout has occurred. Process the after effects. BROKEN (badly)&n; */
DECL|function|tcp_write_timeout
r_static
r_int
id|tcp_write_timeout
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
multiline_comment|/*&n;&t; *&t;Look for a &squot;soft&squot; timeout.&n;&t; */
r_if
c_cond
(paren
(paren
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;retransmits
op_logical_and
op_logical_neg
(paren
id|sk-&gt;retransmits
op_amp
l_int|7
)paren
)paren
op_logical_or
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;retransmits
OG
id|TCP_RETR1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Attempt to recover if arp has changed (unlikely!) or&n;&t;&t; *&t;a route has shifted (not supported prior to 1.3).&n;&t;&t; */
id|ip_rt_advice
c_func
(paren
op_amp
id|sk-&gt;ip_route_cache
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Have we tried to SYN too many times (repent repent 8))&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;retransmits
OG
id|TCP_SYN_RETRIES
op_logical_and
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;err_soft
)paren
(brace
id|sk-&gt;err
op_assign
id|sk-&gt;err_soft
suffix:semicolon
)brace
r_else
id|sk-&gt;err
op_assign
id|ETIMEDOUT
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;retransmit_timer
)paren
suffix:semicolon
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
multiline_comment|/* Is this right ??? - FIXME - */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t FIN, we got nothing back */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Has it gone just too far ?&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;retransmits
OG
id|TCP_RETR2
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;err_soft
)paren
(brace
id|sk-&gt;err
op_assign
id|sk-&gt;err_soft
suffix:semicolon
)brace
r_else
id|sk-&gt;err
op_assign
id|ETIMEDOUT
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;retransmit_timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Time wait the socket &n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT1
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT2
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_CLOSING
)paren
(brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_TIME_WAIT
)paren
suffix:semicolon
id|tcp_reset_msl_timer
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Clean up time.&n;&t;&t;&t; */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;It could be we got here because we needed to send an ack,&n; *&t;so we need to check for that and not just normal retransmit.&n; */
DECL|function|tcp_time_write_timeout
r_static
r_void
id|tcp_time_write_timeout
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb
op_assign
id|sk-&gt;send_head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;ack_backlog
)paren
id|tcp_read_wakeup
c_func
(paren
id|sk
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Kicked by a delayed ack. Reset timer&n;&t; *&t;correctly now&n;&t; */
r_if
c_cond
(paren
id|jiffies
OL
id|skb-&gt;when
op_plus
id|sk-&gt;rto
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;ack_backlog
)paren
id|tcp_read_wakeup
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_reset_xmit_timer
(paren
id|sk
comma
id|TIME_WRITE
comma
id|skb-&gt;when
op_plus
id|sk-&gt;rto
op_minus
id|jiffies
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Retransmission&n;&t; */
id|sk-&gt;retransmits
op_increment
suffix:semicolon
id|sk-&gt;prot-&gt;retransmits
op_increment
suffix:semicolon
id|sk-&gt;prot-&gt;retransmit
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
id|tcp_write_timeout
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The TCP retransmit timer. This lacks a few small details.&n; *&n; *&t;1. &t;An initial rtt timeout on the probe0 should cause what we can&n; *&t;&t;of the first write queue buffer to be split and sent.&n; *&t;2.&t;On a &squot;major timeout&squot; as defined by RFC1122 we shouldn&squot;t report&n; *&t;&t;ETIMEDOUT if we know an additional &squot;soft&squot; error caused this.&n; *&t;&t;tcp_err should save a &squot;soft error&squot; for us.&n; */
DECL|function|tcp_retransmit_timer
r_void
id|tcp_retransmit_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
r_int
id|why
op_assign
id|sk-&gt;ip_xmit_timeout
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We are reset. We will send no more retransmits.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* &n;&t; *&t;Only process if socket is not in use&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;users
)paren
(brace
multiline_comment|/* Try again in 1 second */
id|sk-&gt;retransmit_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;retransmit_timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;ack_backlog
op_logical_and
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Now we need to figure out why the socket was on the timer. */
r_switch
c_cond
(paren
id|why
)paren
(brace
multiline_comment|/* Window probing */
r_case
id|TIME_PROBE0
suffix:colon
id|tcp_send_probe0
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_write_timeout
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Retransmitting */
r_case
id|TIME_WRITE
suffix:colon
id|tcp_time_write_timeout
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Sending Keepalives */
r_case
id|TIME_KEEPOPEN
suffix:colon
multiline_comment|/* &n;&t;&t; * this reset_timer() call is a hack, this is not&n;&t;&t; * how KEEPOPEN is supposed to work.&n;&t;&t; */
id|tcp_reset_xmit_timer
(paren
id|sk
comma
id|TIME_KEEPOPEN
comma
id|TCP_TIMEOUT_LEN
)paren
suffix:semicolon
multiline_comment|/* Send something to keep the connection open. */
r_if
c_cond
(paren
id|sk-&gt;prot-&gt;write_wakeup
)paren
id|sk-&gt;prot-&gt;write_wakeup
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;retransmits
op_increment
suffix:semicolon
id|sk-&gt;prot-&gt;retransmits
op_increment
suffix:semicolon
id|tcp_write_timeout
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;rexmit_timer: timer expired - reason unknown&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
eof
