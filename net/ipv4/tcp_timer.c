multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Implementation of the Transmission Control Protocol(TCP).&n; *&n; * Version:&t;$Id: tcp_timer.c,v 1.77 2000/06/30 10:18:38 davem Exp $&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;&n; *&t;&t;Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; */
macro_line|#include &lt;net/tcp.h&gt;
DECL|variable|sysctl_tcp_syn_retries
r_int
id|sysctl_tcp_syn_retries
op_assign
id|TCP_SYN_RETRIES
suffix:semicolon
DECL|variable|sysctl_tcp_synack_retries
r_int
id|sysctl_tcp_synack_retries
op_assign
id|TCP_SYNACK_RETRIES
suffix:semicolon
DECL|variable|sysctl_tcp_keepalive_time
r_int
id|sysctl_tcp_keepalive_time
op_assign
id|TCP_KEEPALIVE_TIME
suffix:semicolon
DECL|variable|sysctl_tcp_keepalive_probes
r_int
id|sysctl_tcp_keepalive_probes
op_assign
id|TCP_KEEPALIVE_PROBES
suffix:semicolon
DECL|variable|sysctl_tcp_keepalive_intvl
r_int
id|sysctl_tcp_keepalive_intvl
op_assign
id|TCP_KEEPALIVE_INTVL
suffix:semicolon
DECL|variable|sysctl_tcp_retries1
r_int
id|sysctl_tcp_retries1
op_assign
id|TCP_RETR1
suffix:semicolon
DECL|variable|sysctl_tcp_retries2
r_int
id|sysctl_tcp_retries2
op_assign
id|TCP_RETR2
suffix:semicolon
DECL|variable|sysctl_tcp_orphan_retries
r_int
id|sysctl_tcp_orphan_retries
op_assign
id|TCP_ORPHAN_RETRIES
suffix:semicolon
r_static
r_void
id|tcp_retransmit_timer
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|tcp_delack_timer
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|tcp_probe_timer
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|tcp_keepalive_timer
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_void
id|tcp_twkill
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|variable|timer_bug_msg
r_const
r_char
id|timer_bug_msg
(braket
)braket
op_assign
id|KERN_DEBUG
l_string|&quot;tcpbug: unknown timer value&bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n; * Using different timers for retransmit, delayed acks and probes&n; * We may wish use just one timer maintaining a list of expire jiffies &n; * to optimize.&n; */
DECL|function|tcp_init_xmit_timers
r_void
id|tcp_init_xmit_timers
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|tp-&gt;retransmit_timer
)paren
suffix:semicolon
id|tp-&gt;retransmit_timer.function
op_assign
op_amp
id|tcp_retransmit_timer
suffix:semicolon
id|tp-&gt;retransmit_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|tp-&gt;delack_timer
)paren
suffix:semicolon
id|tp-&gt;delack_timer.function
op_assign
op_amp
id|tcp_delack_timer
suffix:semicolon
id|tp-&gt;delack_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|tp-&gt;probe_timer
)paren
suffix:semicolon
id|tp-&gt;probe_timer.function
op_assign
op_amp
id|tcp_probe_timer
suffix:semicolon
id|tp-&gt;probe_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
id|sk-&gt;timer.function
op_assign
op_amp
id|tcp_keepalive_timer
suffix:semicolon
id|sk-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Reset the retransmission timer&n; */
DECL|function|tcp_reset_xmit_timer
r_void
id|tcp_reset_xmit_timer
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|what
comma
r_int
r_int
id|when
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_switch
c_cond
(paren
id|what
)paren
(brace
r_case
id|TCP_TIME_RETRANS
suffix:colon
multiline_comment|/* When seting the transmit timer the probe timer &n;&t;&t; * should not be set.&n;&t;&t; * The delayed ack timer can be set if we are changing the&n;&t;&t; * retransmit timer when removing acked frames.&n;&t;&t; */
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|tp-&gt;probe_timer
)paren
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;probe_timer
)paren
)paren
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|when
OG
id|TCP_RTO_MAX
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;reset_xmit_timer sk=%p when=0x%lx, caller=%p&bslash;n&quot;
comma
id|sk
comma
id|when
comma
id|NET_CALLER
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|when
op_assign
id|TCP_RTO_MAX
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|tp-&gt;retransmit_timer
comma
id|jiffies
op_plus
id|when
)paren
)paren
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_TIME_DACK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|tp-&gt;delack_timer
comma
id|jiffies
op_plus
id|when
)paren
)paren
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_TIME_PROBE0
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|tp-&gt;probe_timer
comma
id|jiffies
op_plus
id|when
)paren
)paren
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;bug: unknown timer value&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
DECL|function|tcp_clear_xmit_timers
r_void
id|tcp_clear_xmit_timers
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|tp-&gt;retransmit_timer
)paren
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;retransmit_timer
)paren
)paren
(brace
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|tp-&gt;delack_timer
)paren
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;delack_timer
)paren
)paren
(brace
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|tp-&gt;ack.blocked
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|tp-&gt;probe_timer
)paren
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;probe_timer
)paren
)paren
(brace
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
)paren
(brace
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
DECL|function|tcp_write_err
r_static
r_void
id|tcp_write_err
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sk-&gt;err
op_assign
id|sk-&gt;err_soft
ques
c_cond
suffix:colon
id|ETIMEDOUT
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_done
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* Do not allow orphaned sockets to eat all our resources.&n; * This is direct violation of TCP specs, but it is required&n; * to prevent DoS attacks. It is called when a retransmission timeout&n; * or zero probe timeout occurs on orphaned socket.&n; *&n; * Criterium is still not confirmed experimentally and may change.&n; * We kill the socket, if:&n; * 1. If number of orphaned sockets exceeds an administratively configured&n; *    limit.&n; * 2. Under pessimistic assumption that all the orphans eat memory not&n; *    less than this one, total consumed memory exceeds all&n; *    the available memory.&n; */
DECL|function|tcp_out_of_resources
r_static
r_int
id|tcp_out_of_resources
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|do_reset
)paren
(brace
r_int
id|orphans
op_assign
id|atomic_read
c_func
(paren
op_amp
id|tcp_orphan_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|orphans
op_ge
id|sysctl_tcp_max_orphans
op_logical_or
(paren
(paren
id|orphans
op_star
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_ge
id|num_physpages
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Out of socket memory&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_reset
)paren
id|tcp_send_active_reset
c_func
(paren
id|sk
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|tcp_done
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* A write timeout has occurred. Process the after effects. */
DECL|function|tcp_write_timeout
r_static
r_int
id|tcp_write_timeout
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|retry_until
suffix:semicolon
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|sk-&gt;state
)paren
op_amp
(paren
id|TCPF_SYN_SENT
op_or
id|TCPF_SYN_RECV
)paren
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;retransmits
)paren
id|dst_negative_advice
c_func
(paren
op_amp
id|sk-&gt;dst_cache
)paren
suffix:semicolon
id|retry_until
op_assign
id|tp-&gt;syn_retries
ques
c_cond
suffix:colon
id|sysctl_tcp_syn_retries
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|tp-&gt;retransmits
op_ge
id|sysctl_tcp_retries1
)paren
(brace
multiline_comment|/* NOTE. draft-ietf-tcpimpl-pmtud-01.txt requires pmtu black&n;&t;&t;&t;   hole detection. :-(&n;&n;&t;&t;&t;   It is place to make it. It is not made. I do not want&n;&t;&t;&t;   to make it. It is disguisting. It does not work in any&n;&t;&t;&t;   case. Let me to cite the same draft, which requires for&n;&t;&t;&t;   us to implement this:&n;&n;   &quot;The one security concern raised by this memo is that ICMP black holes&n;   are often caused by over-zealous security administrators who block&n;   all ICMP messages.  It is vitally important that those who design and&n;   deploy security systems understand the impact of strict filtering on&n;   upper-layer protocols.  The safest web site in the world is worthless&n;   if most TCP implementations cannot transfer data from it.  It would&n;   be far nicer to have all of the black holes fixed rather than fixing&n;   all of the TCP implementations.&quot;&n;&n;                           Golden words :-).&n;&t;&t;   */
id|dst_negative_advice
c_func
(paren
op_amp
id|sk-&gt;dst_cache
)paren
suffix:semicolon
)brace
id|retry_until
op_assign
id|sysctl_tcp_retries2
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;dead
)paren
(brace
r_if
c_cond
(paren
id|tcp_out_of_resources
c_func
(paren
id|sk
comma
id|tp-&gt;retransmits
OL
id|retry_until
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|retry_until
op_assign
id|sysctl_tcp_orphan_retries
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tp-&gt;retransmits
op_ge
id|retry_until
)paren
(brace
multiline_comment|/* Has it gone just too far? */
id|tcp_write_err
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tcp_delack_timer
r_static
r_void
id|tcp_delack_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|bh_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;lock.users
)paren
(brace
multiline_comment|/* Try again later. */
id|tp-&gt;ack.blocked
op_assign
l_int|1
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|DelayedACKLocked
)paren
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_DACK
comma
id|TCP_DELACK_MIN
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;ack.pending
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;ack.pingpong
)paren
(brace
multiline_comment|/* Delayed ACK missed: inflate ATO. */
id|tp-&gt;ack.ato
op_assign
id|min
c_func
(paren
id|tp-&gt;ack.ato
op_lshift
l_int|1
comma
id|TCP_ATO_MAX
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Delayed ACK missed: leave pingpong mode and&n;&t;&t;&t; * deflate ATO.&n;&t;&t;&t; */
id|tp-&gt;ack.pingpong
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;ack.ato
op_assign
id|TCP_ATO_MIN
suffix:semicolon
)brace
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|DelayedACKs
)paren
suffix:semicolon
)brace
id|TCP_CHECK_TIMER
c_func
(paren
id|sk
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|bh_unlock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
DECL|function|tcp_probe_timer
r_static
r_void
id|tcp_probe_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_int
id|max_probes
suffix:semicolon
id|bh_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;lock.users
)paren
(brace
multiline_comment|/* Try again later. */
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_PROBE0
comma
id|HZ
op_div
l_int|5
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
r_goto
id|out_unlock
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;packets_out
op_logical_or
op_logical_neg
id|tp-&gt;send_head
)paren
(brace
id|tp-&gt;probes_out
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* *WARNING* RFC 1122 forbids this&n;&t; *&n;&t; * It doesn&squot;t AFAIK, because we kill the retransmit timer -AK&n;&t; *&n;&t; * FIXME: We ought not to do it, Solaris 2.5 actually has fixing&n;&t; * this behaviour in Solaris down as a bug fix. [AC]&n;&t; *&n;&t; * Let me to explain. probes_out is zeroed by incoming ACKs&n;&t; * even if they advertise zero window. Hence, connection is killed only&n;&t; * if we received no ACKs for normal connection timeout. It is not killed&n;&t; * only because window stays zero for some time, window may be zero&n;&t; * until armageddon and even later. We are in full accordance&n;&t; * with RFCs, only probe timer combines both retransmission timeout&n;&t; * and probe timeout in one bottle.&t;&t;&t;&t;--ANK&n;&t; */
id|max_probes
op_assign
id|sysctl_tcp_retries2
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;dead
)paren
(brace
r_if
c_cond
(paren
id|tcp_out_of_resources
c_func
(paren
id|sk
comma
id|tp-&gt;probes_out
op_le
id|max_probes
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|max_probes
op_assign
id|sysctl_tcp_orphan_retries
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;probes_out
OG
id|max_probes
)paren
(brace
id|tcp_write_err
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Only send another probe if we didn&squot;t close things up. */
id|tcp_send_probe0
c_func
(paren
id|sk
)paren
suffix:semicolon
id|TCP_CHECK_TIMER
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|bh_unlock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* Kill off TIME_WAIT sockets once their lifetime has expired. */
DECL|variable|tcp_tw_death_row_slot
r_static
r_int
id|tcp_tw_death_row_slot
op_assign
l_int|0
suffix:semicolon
DECL|variable|tcp_tw_count
r_int
id|tcp_tw_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|tcp_tw_death_row
r_static
r_struct
id|tcp_tw_bucket
op_star
id|tcp_tw_death_row
(braket
id|TCP_TWKILL_SLOTS
)braket
suffix:semicolon
DECL|variable|tw_death_lock
r_static
id|spinlock_t
id|tw_death_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|tcp_tw_timer
r_static
r_struct
id|timer_list
id|tcp_tw_timer
op_assign
(brace
id|function
suffix:colon
id|tcp_twkill
)brace
suffix:semicolon
DECL|function|tcp_twkill
r_static
r_void
id|SMP_TIMER_NAME
c_func
(paren
id|tcp_twkill
)paren
(paren
r_int
r_int
id|dummy
)paren
(brace
r_struct
id|tcp_tw_bucket
op_star
id|tw
suffix:semicolon
r_int
id|killed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* NOTE: compare this to previous version where lock&n;&t; * was released after detaching chain. It was racy,&n;&t; * because tw buckets are scheduled in not serialized context&n;&t; * in 2.3 (with netfilter), and with softnet it is common, because&n;&t; * soft irqs are not sequenced.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_tw_count
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tw
op_assign
id|tcp_tw_death_row
(braket
id|tcp_tw_death_row_slot
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|tcp_tw_death_row
(braket
id|tcp_tw_death_row_slot
)braket
op_assign
id|tw-&gt;next_death
suffix:semicolon
id|tw-&gt;pprev_death
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
id|tcp_timewait_kill
c_func
(paren
id|tw
)paren
suffix:semicolon
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
id|killed
op_increment
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
)brace
id|tcp_tw_death_row_slot
op_assign
(paren
(paren
id|tcp_tw_death_row_slot
op_plus
l_int|1
)paren
op_amp
(paren
id|TCP_TWKILL_SLOTS
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tcp_tw_count
op_sub_assign
id|killed
)paren
op_ne
l_int|0
)paren
id|mod_timer
c_func
(paren
op_amp
id|tcp_tw_timer
comma
id|jiffies
op_plus
id|TCP_TWKILL_PERIOD
)paren
suffix:semicolon
id|net_statistics
(braket
id|smp_processor_id
c_func
(paren
)paren
op_star
l_int|2
)braket
dot
id|TimeWaited
op_add_assign
id|killed
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
)brace
id|SMP_TIMER_DEFINE
c_func
(paren
id|tcp_twkill
comma
id|tcp_twkill_task
)paren
suffix:semicolon
multiline_comment|/* These are always called from BH context.  See callers in&n; * tcp_input.c to verify this.&n; */
multiline_comment|/* This is for handling early-kills of TIME_WAIT sockets. */
DECL|function|tcp_tw_deschedule
r_void
id|tcp_tw_deschedule
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tw-&gt;pprev_death
)paren
(brace
r_if
c_cond
(paren
id|tw-&gt;next_death
)paren
(brace
id|tw-&gt;next_death-&gt;pprev_death
op_assign
id|tw-&gt;pprev_death
suffix:semicolon
)brace
op_star
id|tw-&gt;pprev_death
op_assign
id|tw-&gt;next_death
suffix:semicolon
id|tw-&gt;pprev_death
op_assign
l_int|NULL
suffix:semicolon
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|tcp_tw_count
op_eq
l_int|0
)paren
id|del_timer
c_func
(paren
op_amp
id|tcp_tw_timer
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Short-time timewait calendar */
DECL|variable|tcp_twcal_hand
r_static
r_int
id|tcp_twcal_hand
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|tcp_twcal_jiffie
r_static
r_int
id|tcp_twcal_jiffie
suffix:semicolon
r_static
r_void
id|tcp_twcal_tick
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|variable|tcp_twcal_timer
r_static
r_struct
id|timer_list
id|tcp_twcal_timer
op_assign
(brace
id|function
suffix:colon
id|tcp_twcal_tick
)brace
suffix:semicolon
DECL|variable|tcp_twcal_row
r_static
r_struct
id|tcp_tw_bucket
op_star
id|tcp_twcal_row
(braket
id|TCP_TW_RECYCLE_SLOTS
)braket
suffix:semicolon
DECL|function|tcp_tw_schedule
r_void
id|tcp_tw_schedule
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
comma
r_int
id|timeo
)paren
(brace
r_struct
id|tcp_tw_bucket
op_star
op_star
id|tpp
suffix:semicolon
r_int
id|slot
suffix:semicolon
multiline_comment|/* timeout := RTO * 3.5&n;&t; *&n;&t; * 3.5 = 1+2+0.5 to wait for two retransmits.&n;&t; *&n;&t; * RATIONALE: if FIN arrived and we entered TIME-WAIT state,&n;&t; * our ACK acking that FIN can be lost. If N subsequent retransmitted&n;&t; * FINs (or previous seqments) are lost (probability of such event&n;&t; * is p^(N+1), where p is probability to lose single packet and&n;&t; * time to detect the loss is about RTO*(2^N - 1) with exponential&n;&t; * backoff). Normal timewait length is calculated so, that we&n;&t; * waited at least for one retransmitted FIN (maximal RTO is 120sec).&n;&t; * [ BTW Linux. following BSD, violates this requirement waiting&n;&t; *   only for 60sec, we should wait at least for 240 secs.&n;&t; *   Well, 240 consumes too much of resources 8)&n;&t; * ]&n;&t; * This interval is not reduced to catch old duplicate and&n;&t; * responces to our wandering segments living for two MSLs.&n;&t; * However, if we use PAWS to detect&n;&t; * old duplicates, we can reduce the interval to bounds required&n;&t; * by RTO, rather than MSL. So, if peer understands PAWS, we&n;&t; * kill tw bucket after 3.5*RTO (it is important that this number&n;&t; * is greater than TS tick!) and detect old duplicates with help&n;&t; * of PAWS.&n;&t; */
id|slot
op_assign
(paren
id|timeo
op_plus
(paren
l_int|1
op_lshift
id|TCP_TW_RECYCLE_TICK
)paren
op_minus
l_int|1
)paren
op_rshift
id|TCP_TW_RECYCLE_TICK
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
multiline_comment|/* Unlink it, if it was scheduled */
r_if
c_cond
(paren
id|tw-&gt;pprev_death
)paren
(brace
r_if
c_cond
(paren
id|tw-&gt;next_death
)paren
(brace
id|tw-&gt;next_death-&gt;pprev_death
op_assign
id|tw-&gt;pprev_death
suffix:semicolon
)brace
op_star
id|tw-&gt;pprev_death
op_assign
id|tw-&gt;next_death
suffix:semicolon
id|tw-&gt;pprev_death
op_assign
l_int|NULL
suffix:semicolon
id|tcp_tw_count
op_decrement
suffix:semicolon
)brace
r_else
id|atomic_inc
c_func
(paren
op_amp
id|tw-&gt;refcnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_ge
id|TCP_TW_RECYCLE_SLOTS
)paren
(brace
multiline_comment|/* Schedule to slow timer */
r_if
c_cond
(paren
id|timeo
op_ge
id|TCP_TIMEWAIT_LEN
)paren
(brace
id|slot
op_assign
id|TCP_TWKILL_SLOTS
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|slot
op_assign
(paren
id|timeo
op_plus
id|TCP_TWKILL_PERIOD
op_minus
l_int|1
)paren
op_div
id|TCP_TWKILL_PERIOD
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_ge
id|TCP_TWKILL_SLOTS
)paren
id|slot
op_assign
id|TCP_TWKILL_SLOTS
op_minus
l_int|1
suffix:semicolon
)brace
id|tw-&gt;ttd
op_assign
id|jiffies
op_plus
id|timeo
suffix:semicolon
id|slot
op_assign
(paren
id|tcp_tw_death_row_slot
op_plus
id|slot
)paren
op_amp
(paren
id|TCP_TWKILL_SLOTS
op_minus
l_int|1
)paren
suffix:semicolon
id|tpp
op_assign
op_amp
id|tcp_tw_death_row
(braket
id|slot
)braket
suffix:semicolon
)brace
r_else
(brace
id|tw-&gt;ttd
op_assign
id|jiffies
op_plus
(paren
id|slot
op_lshift
id|TCP_TW_RECYCLE_TICK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_twcal_hand
OL
l_int|0
)paren
(brace
id|tcp_twcal_hand
op_assign
l_int|0
suffix:semicolon
id|tcp_twcal_jiffie
op_assign
id|jiffies
suffix:semicolon
id|tcp_twcal_timer.expires
op_assign
id|tcp_twcal_jiffie
op_plus
(paren
id|slot
op_lshift
id|TCP_TW_RECYCLE_TICK
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|tcp_twcal_timer
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|tcp_twcal_timer.expires
op_minus
id|jiffies
)paren
OG
(paren
id|slot
op_lshift
id|TCP_TW_RECYCLE_TICK
)paren
)paren
id|mod_timer
c_func
(paren
op_amp
id|tcp_twcal_timer
comma
id|jiffies
op_plus
(paren
id|slot
op_lshift
id|TCP_TW_RECYCLE_TICK
)paren
)paren
suffix:semicolon
id|slot
op_assign
(paren
id|tcp_twcal_hand
op_plus
id|slot
)paren
op_amp
(paren
id|TCP_TW_RECYCLE_SLOTS
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|tpp
op_assign
op_amp
id|tcp_twcal_row
(braket
id|slot
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|tw-&gt;next_death
op_assign
op_star
id|tpp
)paren
op_ne
l_int|NULL
)paren
(brace
(paren
op_star
id|tpp
)paren
op_member_access_from_pointer
id|pprev_death
op_assign
op_amp
id|tw-&gt;next_death
suffix:semicolon
)brace
op_star
id|tpp
op_assign
id|tw
suffix:semicolon
id|tw-&gt;pprev_death
op_assign
id|tpp
suffix:semicolon
r_if
c_cond
(paren
id|tcp_tw_count
op_increment
op_eq
l_int|0
)paren
id|mod_timer
c_func
(paren
op_amp
id|tcp_tw_timer
comma
id|jiffies
op_plus
id|TCP_TWKILL_PERIOD
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
)brace
DECL|function|tcp_twcal_tick
r_void
id|SMP_TIMER_NAME
c_func
(paren
id|tcp_twcal_tick
)paren
(paren
r_int
r_int
id|dummy
)paren
(brace
r_int
id|n
comma
id|slot
suffix:semicolon
r_int
r_int
id|j
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_int
id|killed
op_assign
l_int|0
suffix:semicolon
r_int
id|adv
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_twcal_hand
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|slot
op_assign
id|tcp_twcal_hand
suffix:semicolon
id|j
op_assign
id|tcp_twcal_jiffie
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|TCP_TW_RECYCLE_SLOTS
suffix:semicolon
id|n
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|j
op_minus
id|now
)paren
op_le
l_int|0
)paren
(brace
r_struct
id|tcp_tw_bucket
op_star
id|tw
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tw
op_assign
id|tcp_twcal_row
(braket
id|slot
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|tcp_twcal_row
(braket
id|slot
)braket
op_assign
id|tw-&gt;next_death
suffix:semicolon
id|tw-&gt;pprev_death
op_assign
l_int|NULL
suffix:semicolon
id|tcp_timewait_kill
c_func
(paren
id|tw
)paren
suffix:semicolon
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
id|killed
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|adv
)paren
(brace
id|adv
op_assign
l_int|1
suffix:semicolon
id|tcp_twcal_jiffie
op_assign
id|j
suffix:semicolon
id|tcp_twcal_hand
op_assign
id|slot
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tcp_twcal_row
(braket
id|slot
)braket
op_ne
l_int|NULL
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|tcp_twcal_timer
comma
id|j
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|j
op_add_assign
(paren
l_int|1
op_lshift
id|TCP_TW_RECYCLE_TICK
)paren
suffix:semicolon
id|slot
op_assign
(paren
id|slot
op_plus
l_int|1
)paren
op_amp
(paren
id|TCP_TW_RECYCLE_SLOTS
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|tcp_twcal_hand
op_assign
op_minus
l_int|1
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
(paren
id|tcp_tw_count
op_sub_assign
id|killed
)paren
op_eq
l_int|0
)paren
id|del_timer
c_func
(paren
op_amp
id|tcp_tw_timer
)paren
suffix:semicolon
id|net_statistics
(braket
id|smp_processor_id
c_func
(paren
)paren
op_star
l_int|2
)braket
dot
id|TimeWaitKilled
op_add_assign
id|killed
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
)brace
id|SMP_TIMER_DEFINE
c_func
(paren
id|tcp_twcal_tick
comma
id|tcp_twcal_tasklet
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;The TCP retransmit timer.&n; */
DECL|function|tcp_retransmit_timer
r_static
r_void
id|tcp_retransmit_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
id|bh_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;lock.users
)paren
(brace
multiline_comment|/* Try again later */
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
comma
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
op_logical_or
id|tp-&gt;packets_out
op_eq
l_int|0
)paren
r_goto
id|out_unlock
suffix:semicolon
id|BUG_TRAP
c_func
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_write_timeout
c_func
(paren
id|sk
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/* RFC 2018, clear all &squot;sacked&squot; flags in retransmission queue,&n;&t; * the sender may have dropped out of order frames and we must&n;&t; * send them out should this timer fire on us.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;sack_ok
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|skb
op_ne
id|tp-&gt;send_head
)paren
op_logical_and
(paren
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_and_assign
op_complement
(paren
id|TCPCB_SACKED_ACKED
op_or
id|TCPCB_SACKED_RETRANS
)paren
suffix:semicolon
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/* Retransmission. */
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
id|tp-&gt;rexmt_done
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;fackets_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;retrans_out
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;retransmits
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Remember window where we lost:&n;&t;&t; * &quot;one half of the current window but at least 2 segments&quot;&n;&t;&t; *&n;&t;&t; * Here &quot;current window&quot; means the effective one, which&n;&t;&t; * means it must be an accurate representation of our current&n;&t;&t; * sending rate _and_ the snd_wnd.&n;&t;&t; */
id|tp-&gt;snd_ssthresh
op_assign
id|tcp_recalc_ssthresh
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;snd_cwnd_cnt
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;snd_cwnd
op_assign
l_int|1
suffix:semicolon
)brace
id|tp-&gt;dup_acks
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;high_seq
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
r_if
c_cond
(paren
id|tcp_retransmit_skb
c_func
(paren
id|sk
comma
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
OG
l_int|0
)paren
(brace
multiline_comment|/* Retransmission failed because of local congestion,&n;&t;&t; * do not backoff.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;retransmits
)paren
id|tp-&gt;retransmits
op_assign
l_int|1
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
comma
id|min
c_func
(paren
id|tp-&gt;rto
comma
id|TCP_RESOURCE_PROBE_INTERVAL
)paren
)paren
suffix:semicolon
id|TCP_CHECK_TIMER
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Increase the timeout each time we retransmit.  Note that&n;&t; * we do not increase the rtt estimate.  rto is initialized&n;&t; * from rtt, but increases here.  Jacobson (SIGCOMM 88) suggests&n;&t; * that doubling rto each time is the least we can get away with.&n;&t; * In KA9Q, Karn uses this for the first few times, and then&n;&t; * goes to quadratic.  netBSD doubles, but only goes up to *64,&n;&t; * and clamps at 1 to 64 sec afterwards.  Note that 120 sec is&n;&t; * defined in the protocol as the maximum possible RTT.  I guess&n;&t; * we&squot;ll have to use something other than TCP to talk to the&n;&t; * University of Mars.&n;&t; *&n;&t; * PAWS allows us longer timeouts and large windows, so once&n;&t; * implemented ftp to mars will work nicely. We will have to fix&n;&t; * the 120 second clamps though!&n;&t; */
id|tp-&gt;backoff
op_increment
suffix:semicolon
id|tp-&gt;retransmits
op_increment
suffix:semicolon
id|tp-&gt;rto
op_assign
id|min
c_func
(paren
id|tp-&gt;rto
op_lshift
l_int|1
comma
id|TCP_RTO_MAX
)paren
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;retransmits
OG
id|sysctl_tcp_retries1
)paren
id|__sk_dst_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
id|TCP_CHECK_TIMER
c_func
(paren
id|sk
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|bh_unlock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Timer for listening sockets&n; */
DECL|function|tcp_synack_timer
r_static
r_void
id|tcp_synack_timer
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|tcp_listen_opt
op_star
id|lopt
op_assign
id|tp-&gt;listen_opt
suffix:semicolon
r_int
id|max_retries
op_assign
id|tp-&gt;syn_retries
ques
c_cond
suffix:colon
id|sysctl_tcp_synack_retries
suffix:semicolon
r_int
id|thresh
op_assign
id|max_retries
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_struct
id|open_request
op_star
op_star
id|reqp
comma
op_star
id|req
suffix:semicolon
r_int
id|i
comma
id|budget
suffix:semicolon
r_if
c_cond
(paren
id|lopt
op_eq
l_int|NULL
op_logical_or
id|lopt-&gt;qlen
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* Normally all the openreqs are young and become mature&n;&t; * (i.e. converted to established socket) for first timeout.&n;&t; * If synack was not acknowledged for 3 seconds, it means&n;&t; * one of the following things: synack was lost, ack was lost,&n;&t; * rtt is high or nobody planned to ack (i.e. synflood).&n;&t; * When server is a bit loaded, queue is populated with old&n;&t; * open requests, reducing effective size of queue.&n;&t; * When server is well loaded, queue size reduces to zero&n;&t; * after several minutes of work. It is not synflood,&n;&t; * it is normal operation. The solution is pruning&n;&t; * too old entries overriding normal timeout, when&n;&t; * situation becomes dangerous.&n;&t; *&n;&t; * Essentially, we reserve half of room for young&n;&t; * embrions; and abort old ones without pity, if old&n;&t; * ones are about to clog our table.&n;&t; */
r_if
c_cond
(paren
id|lopt-&gt;qlen
op_rshift
(paren
id|lopt-&gt;max_qlen_log
op_minus
l_int|1
)paren
)paren
(brace
r_int
id|young
op_assign
(paren
id|lopt-&gt;qlen_young
op_lshift
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|thresh
OG
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|lopt-&gt;qlen
OL
id|young
)paren
r_break
suffix:semicolon
id|thresh
op_decrement
suffix:semicolon
id|young
op_lshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tp-&gt;defer_accept
)paren
id|max_retries
op_assign
id|tp-&gt;defer_accept
suffix:semicolon
id|budget
op_assign
l_int|2
op_star
(paren
id|TCP_SYNQ_HSIZE
op_div
(paren
id|TCP_TIMEOUT_INIT
op_div
id|TCP_SYNQ_INTERVAL
)paren
)paren
suffix:semicolon
id|i
op_assign
id|lopt-&gt;clock_hand
suffix:semicolon
r_do
(brace
id|reqp
op_assign
op_amp
id|lopt-&gt;syn_table
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|req
op_assign
op_star
id|reqp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|now
op_minus
id|req-&gt;expires
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|req-&gt;retrans
OL
id|thresh
op_logical_or
(paren
id|req-&gt;acked
op_logical_and
id|req-&gt;retrans
OL
id|max_retries
)paren
)paren
op_logical_and
op_logical_neg
id|req
op_member_access_from_pointer
r_class
op_member_access_from_pointer
id|rtx_syn_ack
c_func
(paren
id|sk
comma
id|req
comma
l_int|NULL
)paren
)paren
(brace
r_int
r_int
id|timeo
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;retrans
op_increment
op_eq
l_int|0
)paren
id|lopt-&gt;qlen_young
op_decrement
suffix:semicolon
id|timeo
op_assign
id|min
c_func
(paren
(paren
id|TCP_TIMEOUT_INIT
op_lshift
id|req-&gt;retrans
)paren
comma
id|TCP_RTO_MAX
)paren
suffix:semicolon
id|req-&gt;expires
op_assign
id|now
op_plus
id|timeo
suffix:semicolon
id|reqp
op_assign
op_amp
id|req-&gt;dl_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Drop this request */
id|write_lock
c_func
(paren
op_amp
id|tp-&gt;syn_wait_lock
)paren
suffix:semicolon
op_star
id|reqp
op_assign
id|req-&gt;dl_next
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|tp-&gt;syn_wait_lock
)paren
suffix:semicolon
id|lopt-&gt;qlen
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;retrans
op_eq
l_int|0
)paren
id|lopt-&gt;qlen_young
op_decrement
suffix:semicolon
id|tcp_openreq_free
c_func
(paren
id|req
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|reqp
op_assign
op_amp
id|req-&gt;dl_next
suffix:semicolon
)brace
id|i
op_assign
(paren
id|i
op_plus
l_int|1
)paren
op_amp
(paren
id|TCP_SYNQ_HSIZE
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|budget
OG
l_int|0
)paren
suffix:semicolon
id|lopt-&gt;clock_hand
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|lopt-&gt;qlen
)paren
id|tcp_reset_keepalive_timer
c_func
(paren
id|sk
comma
id|TCP_SYNQ_INTERVAL
)paren
suffix:semicolon
)brace
DECL|function|tcp_delete_keepalive_timer
r_void
id|tcp_delete_keepalive_timer
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
op_logical_and
id|del_timer
(paren
op_amp
id|sk-&gt;timer
)paren
)paren
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
DECL|function|tcp_reset_keepalive_timer
r_void
id|tcp_reset_keepalive_timer
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|sk-&gt;timer
comma
id|jiffies
op_plus
id|len
)paren
)paren
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
DECL|function|tcp_set_keepalive
r_void
id|tcp_set_keepalive
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|val
)paren
(brace
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|sk-&gt;state
)paren
op_amp
(paren
id|TCPF_CLOSE
op_or
id|TCPF_LISTEN
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|val
op_logical_and
op_logical_neg
id|sk-&gt;keepopen
)paren
id|tcp_reset_keepalive_timer
c_func
(paren
id|sk
comma
id|keepalive_time_when
c_func
(paren
op_amp
id|sk-&gt;tp_pinfo.af_tcp
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|val
)paren
id|tcp_delete_keepalive_timer
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
DECL|function|tcp_keepalive_timer
r_static
r_void
id|tcp_keepalive_timer
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
id|__u32
id|elapsed
suffix:semicolon
multiline_comment|/* Only process if socket is not in use. */
id|bh_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;lock.users
)paren
(brace
multiline_comment|/* Try again later. */
id|tcp_reset_keepalive_timer
(paren
id|sk
comma
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
(brace
id|tcp_synack_timer
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT2
op_logical_and
id|sk-&gt;dead
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;linger2
op_ge
l_int|0
)paren
(brace
r_int
id|tmo
op_assign
id|tcp_fin_time
c_func
(paren
id|tp
)paren
op_minus
id|TCP_TIMEWAIT_LEN
suffix:semicolon
r_if
c_cond
(paren
id|tmo
OG
l_int|0
)paren
(brace
id|tcp_time_wait
c_func
(paren
id|sk
comma
id|TCP_FIN_WAIT2
comma
id|tmo
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|tcp_send_active_reset
c_func
(paren
id|sk
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_goto
id|death
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;keepopen
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
r_goto
id|out
suffix:semicolon
id|elapsed
op_assign
id|keepalive_time_when
c_func
(paren
id|tp
)paren
suffix:semicolon
multiline_comment|/* It is alive without keepalive 8) */
r_if
c_cond
(paren
id|tp-&gt;packets_out
op_logical_or
id|tp-&gt;send_head
)paren
r_goto
id|resched
suffix:semicolon
id|elapsed
op_assign
id|tcp_time_stamp
op_minus
id|tp-&gt;rcv_tstamp
suffix:semicolon
r_if
c_cond
(paren
id|elapsed
op_ge
id|keepalive_time_when
c_func
(paren
id|tp
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|tp-&gt;keepalive_probes
op_logical_and
id|tp-&gt;probes_out
op_ge
id|sysctl_tcp_keepalive_probes
)paren
op_logical_or
(paren
id|tp-&gt;keepalive_probes
op_logical_and
id|tp-&gt;probes_out
op_ge
id|tp-&gt;keepalive_probes
)paren
)paren
(brace
id|tcp_send_active_reset
c_func
(paren
id|sk
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|tcp_write_err
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tcp_write_wakeup
c_func
(paren
id|sk
)paren
op_le
l_int|0
)paren
(brace
id|tp-&gt;probes_out
op_increment
suffix:semicolon
id|elapsed
op_assign
id|keepalive_intvl_when
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If keepalive was lost due to local congestion,&n;&t;&t;&t; * try harder.&n;&t;&t;&t; */
id|elapsed
op_assign
id|TCP_RESOURCE_PROBE_INTERVAL
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* It is tp-&gt;rcv_tstamp + keepalive_time_when(tp) */
id|elapsed
op_assign
id|keepalive_time_when
c_func
(paren
id|tp
)paren
op_minus
id|elapsed
suffix:semicolon
)brace
id|TCP_CHECK_TIMER
c_func
(paren
id|sk
)paren
suffix:semicolon
id|resched
suffix:colon
id|tcp_reset_keepalive_timer
(paren
id|sk
comma
id|elapsed
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|death
suffix:colon
id|tcp_done
c_func
(paren
id|sk
)paren
suffix:semicolon
id|out
suffix:colon
id|bh_unlock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
eof
