multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Implementation of the Transmission Control Protocol(TCP).&n; *&n; * Version:&t;$Id: tcp_timer.c,v 1.59 1999/03/23 21:21:09 davem Exp $&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;&n; *&t;&t;Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; */
macro_line|#include &lt;net/tcp.h&gt;
DECL|variable|sysctl_tcp_syn_retries
r_int
id|sysctl_tcp_syn_retries
op_assign
id|TCP_SYN_RETRIES
suffix:semicolon
DECL|variable|sysctl_tcp_keepalive_time
r_int
id|sysctl_tcp_keepalive_time
op_assign
id|TCP_KEEPALIVE_TIME
suffix:semicolon
DECL|variable|sysctl_tcp_keepalive_probes
r_int
id|sysctl_tcp_keepalive_probes
op_assign
id|TCP_KEEPALIVE_PROBES
suffix:semicolon
DECL|variable|sysctl_tcp_retries1
r_int
id|sysctl_tcp_retries1
op_assign
id|TCP_RETR1
suffix:semicolon
DECL|variable|sysctl_tcp_retries2
r_int
id|sysctl_tcp_retries2
op_assign
id|TCP_RETR2
suffix:semicolon
r_static
r_void
id|tcp_sltimer_handler
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|tcp_syn_recv_timer
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|tcp_keepalive
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_void
id|tcp_bucketgc
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|tcp_twkill
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|variable|tcp_slow_timer
r_struct
id|timer_list
id|tcp_slow_timer
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|tcp_sltimer_handler
comma
)brace
suffix:semicolon
DECL|variable|tcp_slt_array
r_struct
id|tcp_sl_timer
id|tcp_slt_array
(braket
id|TCP_SLT_MAX
)braket
op_assign
(brace
(brace
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
comma
id|TCP_SYNACK_PERIOD
comma
l_int|0
comma
id|tcp_syn_recv_timer
)brace
comma
multiline_comment|/* SYNACK&t;*/
(brace
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
comma
id|TCP_KEEPALIVE_PERIOD
comma
l_int|0
comma
id|tcp_keepalive
)brace
comma
multiline_comment|/* KEEPALIVE&t;*/
(brace
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
comma
id|TCP_TWKILL_PERIOD
comma
l_int|0
comma
id|tcp_twkill
)brace
comma
multiline_comment|/* TWKILL&t;*/
(brace
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
comma
id|TCP_BUCKETGC_PERIOD
comma
l_int|0
comma
id|tcp_bucketgc
)brace
multiline_comment|/* BUCKETGC&t;*/
)brace
suffix:semicolon
DECL|variable|timer_bug_msg
r_const
r_char
id|timer_bug_msg
(braket
)braket
op_assign
id|KERN_DEBUG
l_string|&quot;tcpbug: unknown timer value&bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n; * Using different timers for retransmit, delayed acks and probes&n; * We may wish use just one timer maintaining a list of expire jiffies &n; * to optimize.&n; */
DECL|function|tcp_init_xmit_timers
r_void
id|tcp_init_xmit_timers
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|init_timer
c_func
(paren
op_amp
id|sk-&gt;tp_pinfo.af_tcp.retransmit_timer
)paren
suffix:semicolon
id|sk-&gt;tp_pinfo.af_tcp.retransmit_timer.function
op_assign
op_amp
id|tcp_retransmit_timer
suffix:semicolon
id|sk-&gt;tp_pinfo.af_tcp.retransmit_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|sk-&gt;tp_pinfo.af_tcp.delack_timer
)paren
suffix:semicolon
id|sk-&gt;tp_pinfo.af_tcp.delack_timer.function
op_assign
op_amp
id|tcp_delack_timer
suffix:semicolon
id|sk-&gt;tp_pinfo.af_tcp.delack_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|sk-&gt;tp_pinfo.af_tcp.probe_timer
)paren
suffix:semicolon
id|sk-&gt;tp_pinfo.af_tcp.probe_timer.function
op_assign
op_amp
id|tcp_probe_timer
suffix:semicolon
id|sk-&gt;tp_pinfo.af_tcp.probe_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Reset the retransmission timer&n; */
DECL|function|tcp_reset_xmit_timer
r_void
id|tcp_reset_xmit_timer
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|what
comma
r_int
r_int
id|when
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_switch
c_cond
(paren
id|what
)paren
(brace
r_case
id|TIME_RETRANS
suffix:colon
multiline_comment|/* When seting the transmit timer the probe timer &n;&t;&t; * should not be set.&n;&t;&t; * The delayed ack timer can be set if we are changing the&n;&t;&t; * retransmit timer when removing acked frames.&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;probe_timer.prev
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;probe_timer
)paren
suffix:semicolon
)brace
id|mod_timer
c_func
(paren
op_amp
id|tp-&gt;retransmit_timer
comma
id|jiffies
op_plus
id|when
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_DACK
suffix:colon
id|mod_timer
c_func
(paren
op_amp
id|tp-&gt;delack_timer
comma
id|jiffies
op_plus
id|when
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_PROBE0
suffix:colon
id|mod_timer
c_func
(paren
op_amp
id|tp-&gt;probe_timer
comma
id|jiffies
op_plus
id|when
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_WRITE
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;bug: tcp_reset_xmit_timer TIME_WRITE&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;bug: unknown timer value&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
DECL|function|tcp_clear_xmit_timers
r_void
id|tcp_clear_xmit_timers
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;retransmit_timer.prev
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;retransmit_timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;delack_timer.prev
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;delack_timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;probe_timer.prev
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;probe_timer
)paren
suffix:semicolon
)brace
)brace
DECL|function|tcp_write_err
r_static
r_int
id|tcp_write_err
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|force
)paren
(brace
id|sk-&gt;err
op_assign
id|sk-&gt;err_soft
ques
c_cond
id|sk-&gt;err_soft
suffix:colon
id|ETIMEDOUT
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_clear_xmit_timers
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Time wait the socket. */
r_if
c_cond
(paren
op_logical_neg
id|force
op_logical_and
(paren
(paren
l_int|1
op_lshift
id|sk-&gt;state
)paren
op_amp
(paren
id|TCPF_FIN_WAIT1
op_or
id|TCPF_FIN_WAIT2
op_or
id|TCPF_CLOSING
)paren
)paren
)paren
(brace
id|tcp_time_wait
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Clean up time. */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* A write timeout has occurred. Process the after effects. */
DECL|function|tcp_write_timeout
r_static
r_int
id|tcp_write_timeout
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/* Look for a &squot;soft&squot; timeout. */
r_if
c_cond
(paren
(paren
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
op_logical_and
id|tp-&gt;retransmits
op_logical_and
(paren
id|tp-&gt;retransmits
op_mod
id|TCP_QUICK_TRIES
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|tp-&gt;retransmits
OG
id|sysctl_tcp_retries1
)paren
)paren
(brace
id|dst_negative_advice
c_func
(paren
op_amp
id|sk-&gt;dst_cache
)paren
suffix:semicolon
)brace
multiline_comment|/* Have we tried to SYN too many times (repent repent 8)) */
r_if
c_cond
(paren
id|tp-&gt;retransmits
OG
id|sysctl_tcp_syn_retries
op_logical_and
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
)paren
(brace
id|tcp_write_err
c_func
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t FIN, we got nothing back */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Has it gone just too far? */
r_if
c_cond
(paren
id|tp-&gt;retransmits
OG
id|sysctl_tcp_retries2
)paren
r_return
id|tcp_write_err
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|tcp_delack_timer
r_void
id|tcp_delack_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;zapped
op_logical_and
id|sk-&gt;tp_pinfo.af_tcp.delayed_acks
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_CLOSE
)paren
(brace
multiline_comment|/* If socket is currently locked, defer the ACK. */
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sock_readers
)paren
)paren
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
r_else
id|tcp_send_delayed_ack
c_func
(paren
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
comma
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
)brace
)brace
DECL|function|tcp_probe_timer
r_void
id|tcp_probe_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sock_readers
)paren
)paren
(brace
multiline_comment|/* Try again later. */
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|HZ
op_div
l_int|5
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* *WARNING* RFC 1122 forbids this &n;&t; * It doesn&squot;t AFAIK, because we kill the retransmit timer -AK&n;&t; * FIXME: We ought not to do it, Solaris 2.5 actually has fixing&n;&t; * this behaviour in Solaris down as a bug fix. [AC]&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;probes_out
OG
id|sysctl_tcp_retries2
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;err_soft
)paren
(brace
id|sk-&gt;err
op_assign
id|sk-&gt;err_soft
suffix:semicolon
)brace
r_else
id|sk-&gt;err
op_assign
id|ETIMEDOUT
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|sk-&gt;state
)paren
op_amp
(paren
id|TCPF_FIN_WAIT1
op_or
id|TCPF_FIN_WAIT2
op_or
id|TCPF_CLOSING
)paren
)paren
(brace
multiline_comment|/* Time wait the socket. */
id|tcp_time_wait
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Clean up time. */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Only send another probe if we didn&squot;t close things up. */
id|tcp_send_probe0
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
DECL|function|tcp_keepopen_proc
r_static
id|__inline__
r_int
id|tcp_keepopen_proc
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|sk-&gt;state
)paren
op_amp
(paren
id|TCPF_ESTABLISHED
op_or
id|TCPF_CLOSE_WAIT
op_or
id|TCPF_FIN_WAIT2
)paren
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
id|__u32
id|elapsed
op_assign
id|jiffies
op_minus
id|tp-&gt;rcv_tstamp
suffix:semicolon
r_if
c_cond
(paren
id|elapsed
op_ge
id|sysctl_tcp_keepalive_time
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;probes_out
OG
id|sysctl_tcp_keepalive_probes
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;err_soft
)paren
(brace
id|sk-&gt;err
op_assign
id|sk-&gt;err_soft
suffix:semicolon
)brace
r_else
id|sk-&gt;err
op_assign
id|ETIMEDOUT
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
id|tp-&gt;probes_out
op_increment
suffix:semicolon
id|tp-&gt;pending
op_assign
id|TIME_KEEPOPEN
suffix:semicolon
id|tcp_write_wakeup
c_func
(paren
id|sk
)paren
suffix:semicolon
id|res
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* Garbage collect TCP bind buckets. */
DECL|function|tcp_bucketgc
r_static
r_void
id|tcp_bucketgc
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
id|i
comma
id|reaped
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TCP_BHTABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|tcp_bind_bucket
op_star
id|tb
op_assign
id|tcp_bound_hash
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
id|tb
)paren
(brace
r_struct
id|tcp_bind_bucket
op_star
id|next
op_assign
id|tb-&gt;next
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tb-&gt;owners
op_eq
l_int|NULL
)paren
op_logical_and
op_logical_neg
(paren
id|tb-&gt;flags
op_amp
id|TCPB_FLAG_LOCKED
)paren
)paren
(brace
id|reaped
op_increment
suffix:semicolon
multiline_comment|/* Unlink bucket. */
r_if
c_cond
(paren
id|tb-&gt;next
)paren
(brace
id|tb-&gt;next-&gt;pprev
op_assign
id|tb-&gt;pprev
suffix:semicolon
)brace
op_star
id|tb-&gt;pprev
op_assign
id|tb-&gt;next
suffix:semicolon
multiline_comment|/* Finally, free it up. */
id|kmem_cache_free
c_func
(paren
id|tcp_bucket_cachep
comma
id|tb
)paren
suffix:semicolon
)brace
id|tb
op_assign
id|next
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|reaped
op_ne
l_int|0
)paren
(brace
r_struct
id|tcp_sl_timer
op_star
id|slt
op_assign
(paren
r_struct
id|tcp_sl_timer
op_star
)paren
id|data
suffix:semicolon
multiline_comment|/* Eat timer references. */
id|atomic_sub
c_func
(paren
id|reaped
comma
op_amp
id|slt-&gt;count
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Kill off TIME_WAIT sockets once their lifetime has expired. */
DECL|variable|tcp_tw_death_row_slot
r_int
id|tcp_tw_death_row_slot
op_assign
l_int|0
suffix:semicolon
DECL|variable|tcp_tw_death_row
r_static
r_struct
id|tcp_tw_bucket
op_star
id|tcp_tw_death_row
(braket
id|TCP_TWKILL_SLOTS
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
r_extern
r_void
id|tcp_timewait_kill
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
)paren
suffix:semicolon
DECL|function|tcp_twkill
r_static
r_void
id|tcp_twkill
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|tcp_tw_bucket
op_star
id|tw
suffix:semicolon
r_int
id|killed
op_assign
l_int|0
suffix:semicolon
id|tw
op_assign
id|tcp_tw_death_row
(braket
id|tcp_tw_death_row_slot
)braket
suffix:semicolon
id|tcp_tw_death_row
(braket
id|tcp_tw_death_row_slot
)braket
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|tw
op_ne
l_int|NULL
)paren
(brace
r_struct
id|tcp_tw_bucket
op_star
id|next
op_assign
id|tw-&gt;next_death
suffix:semicolon
id|tcp_timewait_kill
c_func
(paren
id|tw
)paren
suffix:semicolon
id|killed
op_increment
suffix:semicolon
id|tw
op_assign
id|next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|killed
op_ne
l_int|0
)paren
(brace
r_struct
id|tcp_sl_timer
op_star
id|slt
op_assign
(paren
r_struct
id|tcp_sl_timer
op_star
)paren
id|data
suffix:semicolon
id|atomic_sub
c_func
(paren
id|killed
comma
op_amp
id|slt-&gt;count
)paren
suffix:semicolon
)brace
id|tcp_tw_death_row_slot
op_assign
(paren
(paren
id|tcp_tw_death_row_slot
op_plus
l_int|1
)paren
op_amp
(paren
id|TCP_TWKILL_SLOTS
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* These are always called from BH context.  See callers in&n; * tcp_input.c to verify this.&n; */
DECL|function|tcp_tw_schedule
r_void
id|tcp_tw_schedule
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
)paren
(brace
r_int
id|slot
op_assign
(paren
id|tcp_tw_death_row_slot
op_minus
l_int|1
)paren
op_amp
(paren
id|TCP_TWKILL_SLOTS
op_minus
l_int|1
)paren
suffix:semicolon
id|tw-&gt;death_slot
op_assign
id|slot
suffix:semicolon
id|tw-&gt;next_death
op_assign
id|tcp_tw_death_row
(braket
id|slot
)braket
suffix:semicolon
id|tcp_tw_death_row
(braket
id|slot
)braket
op_assign
id|tw
suffix:semicolon
id|tcp_inc_slow_timer
c_func
(paren
id|TCP_SLT_TWKILL
)paren
suffix:semicolon
)brace
multiline_comment|/* Happens rarely if at all, no care about scalability here. */
DECL|function|tcp_tw_reschedule
r_void
id|tcp_tw_reschedule
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
)paren
(brace
r_struct
id|tcp_tw_bucket
op_star
id|walk
suffix:semicolon
r_int
id|slot
op_assign
id|tw-&gt;death_slot
suffix:semicolon
id|walk
op_assign
id|tcp_tw_death_row
(braket
id|slot
)braket
suffix:semicolon
r_if
c_cond
(paren
id|walk
op_eq
id|tw
)paren
(brace
id|tcp_tw_death_row
(braket
id|slot
)braket
op_assign
id|tw-&gt;next_death
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
id|walk-&gt;next_death
op_ne
id|tw
)paren
(brace
id|walk
op_assign
id|walk-&gt;next_death
suffix:semicolon
)brace
id|walk-&gt;next_death
op_assign
id|tw-&gt;next_death
suffix:semicolon
)brace
id|slot
op_assign
(paren
id|tcp_tw_death_row_slot
op_minus
l_int|1
)paren
op_amp
(paren
id|TCP_TWKILL_SLOTS
op_minus
l_int|1
)paren
suffix:semicolon
id|tw-&gt;death_slot
op_assign
id|slot
suffix:semicolon
id|tw-&gt;next_death
op_assign
id|tcp_tw_death_row
(braket
id|slot
)braket
suffix:semicolon
id|tcp_tw_death_row
(braket
id|slot
)braket
op_assign
id|tw
suffix:semicolon
multiline_comment|/* Timer was incremented when we first entered the table. */
)brace
multiline_comment|/* This is for handling early-kills of TIME_WAIT sockets. */
DECL|function|tcp_tw_deschedule
r_void
id|tcp_tw_deschedule
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
)paren
(brace
r_struct
id|tcp_tw_bucket
op_star
id|walk
suffix:semicolon
r_int
id|slot
op_assign
id|tw-&gt;death_slot
suffix:semicolon
id|walk
op_assign
id|tcp_tw_death_row
(braket
id|slot
)braket
suffix:semicolon
r_if
c_cond
(paren
id|walk
op_eq
id|tw
)paren
(brace
id|tcp_tw_death_row
(braket
id|slot
)braket
op_assign
id|tw-&gt;next_death
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
id|walk-&gt;next_death
op_ne
id|tw
)paren
(brace
id|walk
op_assign
id|walk-&gt;next_death
suffix:semicolon
)brace
id|walk-&gt;next_death
op_assign
id|tw-&gt;next_death
suffix:semicolon
)brace
id|tcp_dec_slow_timer
c_func
(paren
id|TCP_SLT_TWKILL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Check all sockets for keepalive timer&n; *&t;Called every 75 seconds&n; *&t;This timer is started by af_inet init routine and is constantly&n; *&t;running.&n; *&n; *&t;It might be better to maintain a count of sockets that need it using&n; *&t;setsockopt/tcp_destroy_sk and only set the timer when needed.&n; */
multiline_comment|/*&n; *&t;don&squot;t send over 5 keepopens at a time to avoid burstiness &n; *&t;on big servers [AC]&n; */
DECL|macro|MAX_KA_PROBES
mdefine_line|#define MAX_KA_PROBES&t;5
DECL|variable|sysctl_tcp_max_ka_probes
r_int
id|sysctl_tcp_max_ka_probes
op_assign
id|MAX_KA_PROBES
suffix:semicolon
multiline_comment|/* Keepopen&squot;s are only valid for &quot;established&quot; TCP&squot;s, nicely our listener&n; * hash gets rid of most of the useless testing, so we run through a couple&n; * of the established hash chains each clock tick.  -DaveM&n; *&n; * And now, even more magic... TIME_WAIT TCP&squot;s cannot have keepalive probes&n; * going off for them, so we only need check the first half of the established&n; * hash table, even less testing under heavy load.&n; *&n; * I _really_ would rather do this by adding a new timer_struct to struct sock,&n; * and this way only those who set the keepalive option will get the overhead.&n; * The idea is you set it for 2 hours when the sock is first connected, when it&n; * does fire off (if at all, most sockets die earlier) you check for the keepalive&n; * option and also if the sock has been idle long enough to start probing.&n; */
DECL|function|tcp_keepalive
r_static
r_void
id|tcp_keepalive
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_static
r_int
id|chain_start
op_assign
l_int|0
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|chain_start
suffix:semicolon
id|i
OL
(paren
id|chain_start
op_plus
(paren
(paren
id|TCP_HTABLE_SIZE
op_div
l_int|2
)paren
op_rshift
l_int|2
)paren
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|tcp_established_hash
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
id|sk
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sock_readers
)paren
op_logical_and
id|sk-&gt;keepopen
)paren
(brace
id|count
op_add_assign
id|tcp_keepopen_proc
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
id|sysctl_tcp_max_ka_probes
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
)brace
id|sk
op_assign
id|sk-&gt;next
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|chain_start
op_assign
(paren
(paren
id|chain_start
op_plus
(paren
(paren
id|TCP_HTABLE_SIZE
op_div
l_int|2
)paren
op_rshift
l_int|2
)paren
)paren
op_amp
(paren
(paren
id|TCP_HTABLE_SIZE
op_div
l_int|2
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The TCP retransmit timer. This lacks a few small details.&n; *&n; *&t;1. &t;An initial rtt timeout on the probe0 should cause what we can&n; *&t;&t;of the first write queue buffer to be split and sent.&n; *&t;2.&t;On a &squot;major timeout&squot; as defined by RFC1122 we shouldn&squot;t report&n; *&t;&t;ETIMEDOUT if we know an additional &squot;soft&squot; error caused this.&n; *&t;&t;tcp_err should save a &squot;soft error&squot; for us.&n; *&t;[Unless someone has broken it then it does, except for one 2.0 &n; *&t;broken case of a send when the route/device is directly unreachable,&n; *&t;and we error but should retry! - FIXME] [AC]&n; */
DECL|function|tcp_retransmit_timer
r_void
id|tcp_retransmit_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
multiline_comment|/* We are reset. We will send no more retransmits. */
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
id|tcp_clear_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sock_readers
)paren
)paren
(brace
multiline_comment|/* Try again later */
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Clear delay ack timer. */
id|tcp_clear_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_DACK
)paren
suffix:semicolon
multiline_comment|/* RFC 2018, clear all &squot;sacked&squot; flags in retransmission queue,&n;&t; * the sender may have dropped out of order frames and we must&n;&t; * send them out should this timer fire on us.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;sack_ok
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|skb
op_ne
id|tp-&gt;send_head
)paren
op_logical_and
(paren
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_and_assign
op_complement
(paren
id|TCPCB_SACKED_ACKED
op_or
id|TCPCB_SACKED_RETRANS
)paren
suffix:semicolon
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/* Retransmission. */
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
id|tp-&gt;rexmt_done
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;fackets_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;retrans_out
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;retransmits
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Remember window where we lost:&n;&t;&t; * &quot;one half of the current window but at least 2 segments&quot;&n;&t;&t; *&n;&t;&t; * Here &quot;current window&quot; means the effective one, which&n;&t;&t; * means it must be an accurate representation of our current&n;&t;&t; * sending rate _and_ the snd_wnd.&n;&t;&t; */
id|tp-&gt;snd_ssthresh
op_assign
id|max
c_func
(paren
id|min
c_func
(paren
id|tp-&gt;snd_wnd
comma
id|tp-&gt;snd_cwnd
)paren
op_rshift
l_int|1
comma
l_int|2
)paren
suffix:semicolon
id|tp-&gt;snd_cwnd_cnt
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;snd_cwnd
op_assign
l_int|1
suffix:semicolon
)brace
id|tp-&gt;retransmits
op_increment
suffix:semicolon
id|tp-&gt;dup_acks
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;high_seq
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
id|tcp_retransmit_skb
c_func
(paren
id|sk
comma
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
suffix:semicolon
multiline_comment|/* Increase the timeout each time we retransmit.  Note that&n;&t; * we do not increase the rtt estimate.  rto is initialized&n;&t; * from rtt, but increases here.  Jacobson (SIGCOMM 88) suggests&n;&t; * that doubling rto each time is the least we can get away with.&n;&t; * In KA9Q, Karn uses this for the first few times, and then&n;&t; * goes to quadratic.  netBSD doubles, but only goes up to *64,&n;&t; * and clamps at 1 to 64 sec afterwards.  Note that 120 sec is&n;&t; * defined in the protocol as the maximum possible RTT.  I guess&n;&t; * we&squot;ll have to use something other than TCP to talk to the&n;&t; * University of Mars.&n;&t; *&n;&t; * PAWS allows us longer timeouts and large windows, so once&n;&t; * implemented ftp to mars will work nicely. We will have to fix&n;&t; * the 120 second clamps though!&n;&t; */
id|tp-&gt;backoff
op_increment
suffix:semicolon
id|tp-&gt;rto
op_assign
id|min
c_func
(paren
id|tp-&gt;rto
op_lshift
l_int|1
comma
l_int|120
op_star
id|HZ
)paren
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
id|tcp_write_timeout
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Slow timer for SYN-RECV sockets&n; */
multiline_comment|/* This now scales very nicely. -DaveM */
DECL|function|tcp_syn_recv_timer
r_static
r_void
id|tcp_syn_recv_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TCP_LHTABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sk
op_assign
id|tcp_listening_hash
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
multiline_comment|/* TCP_LISTEN is implied. */
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sock_readers
)paren
op_logical_and
id|tp-&gt;syn_wait_queue
)paren
(brace
r_struct
id|open_request
op_star
id|prev
op_assign
(paren
r_struct
id|open_request
op_star
)paren
(paren
op_amp
id|tp-&gt;syn_wait_queue
)paren
suffix:semicolon
r_struct
id|open_request
op_star
id|req
op_assign
id|tp-&gt;syn_wait_queue
suffix:semicolon
r_do
(brace
r_struct
id|open_request
op_star
id|conn
suffix:semicolon
id|conn
op_assign
id|req
suffix:semicolon
id|req
op_assign
id|req-&gt;dl_next
suffix:semicolon
r_if
c_cond
(paren
id|conn-&gt;sk
)paren
(brace
id|prev
op_assign
id|conn
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|now
op_minus
id|conn-&gt;expires
)paren
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|tcp_synq_unlink
c_func
(paren
id|tp
comma
id|conn
comma
id|prev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conn-&gt;retrans
op_ge
id|sysctl_tcp_retries1
)paren
(brace
macro_line|#ifdef TCP_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;syn_recv: &quot;
l_string|&quot;too many retransmits&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
(paren
op_star
id|conn
op_member_access_from_pointer
r_class
op_member_access_from_pointer
id|destructor
)paren
(paren
id|conn
)paren
suffix:semicolon
id|tcp_dec_slow_timer
c_func
(paren
id|TCP_SLT_SYNACK
)paren
suffix:semicolon
id|tp-&gt;syn_backlog
op_decrement
suffix:semicolon
id|tcp_openreq_free
c_func
(paren
id|conn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;syn_wait_queue
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
id|__u32
id|timeo
suffix:semicolon
r_struct
id|open_request
op_star
id|op
suffix:semicolon
(paren
op_star
id|conn
op_member_access_from_pointer
r_class
op_member_access_from_pointer
id|rtx_syn_ack
)paren
(paren
id|sk
comma
id|conn
)paren
suffix:semicolon
id|conn-&gt;retrans
op_increment
suffix:semicolon
macro_line|#ifdef TCP_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;syn_ack rtx %d&bslash;n&quot;
comma
id|conn-&gt;retrans
)paren
suffix:semicolon
macro_line|#endif
id|timeo
op_assign
id|min
c_func
(paren
(paren
id|TCP_TIMEOUT_INIT
op_lshift
id|conn-&gt;retrans
)paren
comma
l_int|120
op_star
id|HZ
)paren
suffix:semicolon
id|conn-&gt;expires
op_assign
id|now
op_plus
id|timeo
suffix:semicolon
id|op
op_assign
id|prev-&gt;dl_next
suffix:semicolon
id|tcp_synq_queue
c_func
(paren
id|tp
comma
id|conn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|op
op_ne
id|prev-&gt;dl_next
)paren
id|prev
op_assign
id|prev-&gt;dl_next
suffix:semicolon
)brace
multiline_comment|/* old prev still valid here */
)brace
r_while
c_loop
(paren
id|req
)paren
suffix:semicolon
)brace
id|sk
op_assign
id|sk-&gt;next
suffix:semicolon
)brace
)brace
)brace
DECL|function|tcp_sltimer_handler
r_void
id|tcp_sltimer_handler
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|tcp_sl_timer
op_star
id|slt
op_assign
id|tcp_slt_array
suffix:semicolon
r_int
r_int
id|next
op_assign
op_complement
l_int|0UL
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TCP_SLT_MAX
suffix:semicolon
id|i
op_increment
comma
id|slt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|slt-&gt;count
)paren
)paren
(brace
r_int
id|trigger
suffix:semicolon
id|trigger
op_assign
id|slt-&gt;period
op_minus
(paren
(paren
r_int
)paren
(paren
id|now
op_minus
id|slt-&gt;last
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|trigger
op_le
l_int|0
)paren
(brace
(paren
op_star
id|slt-&gt;handler
)paren
(paren
(paren
r_int
r_int
)paren
id|slt
)paren
suffix:semicolon
id|slt-&gt;last
op_assign
id|now
suffix:semicolon
id|trigger
op_assign
id|slt-&gt;period
suffix:semicolon
)brace
multiline_comment|/* Only reschedule if some events remain. */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|slt-&gt;count
)paren
)paren
id|next
op_assign
id|min
c_func
(paren
id|next
comma
id|trigger
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|next
op_ne
op_complement
l_int|0UL
)paren
id|mod_timer
c_func
(paren
op_amp
id|tcp_slow_timer
comma
(paren
id|now
op_plus
id|next
)paren
)paren
suffix:semicolon
)brace
DECL|function|__tcp_inc_slow_timer
r_void
id|__tcp_inc_slow_timer
c_func
(paren
r_struct
id|tcp_sl_timer
op_star
id|slt
)paren
(brace
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_int
r_int
id|when
suffix:semicolon
id|slt-&gt;last
op_assign
id|now
suffix:semicolon
id|when
op_assign
id|now
op_plus
id|slt-&gt;period
suffix:semicolon
r_if
c_cond
(paren
id|tcp_slow_timer.prev
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|tcp_slow_timer.expires
op_minus
id|when
)paren
op_ge
l_int|0
)paren
id|mod_timer
c_func
(paren
op_amp
id|tcp_slow_timer
comma
id|when
)paren
suffix:semicolon
)brace
r_else
(brace
id|tcp_slow_timer.expires
op_assign
id|when
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|tcp_slow_timer
)paren
suffix:semicolon
)brace
)brace
eof
