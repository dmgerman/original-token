multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Implementation of the Transmission Control Protocol(TCP).&n; *&n; * Version:&t;$Id: tcp_timer.c,v 1.66 1999/08/20 11:06:10 davem Exp $&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;&n; *&t;&t;Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; */
macro_line|#include &lt;net/tcp.h&gt;
DECL|variable|sysctl_tcp_syn_retries
r_int
id|sysctl_tcp_syn_retries
op_assign
id|TCP_SYN_RETRIES
suffix:semicolon
DECL|variable|sysctl_tcp_keepalive_time
r_int
id|sysctl_tcp_keepalive_time
op_assign
id|TCP_KEEPALIVE_TIME
suffix:semicolon
DECL|variable|sysctl_tcp_keepalive_probes
r_int
id|sysctl_tcp_keepalive_probes
op_assign
id|TCP_KEEPALIVE_PROBES
suffix:semicolon
DECL|variable|sysctl_tcp_retries1
r_int
id|sysctl_tcp_retries1
op_assign
id|TCP_RETR1
suffix:semicolon
DECL|variable|sysctl_tcp_retries2
r_int
id|sysctl_tcp_retries2
op_assign
id|TCP_RETR2
suffix:semicolon
r_static
r_void
id|tcp_sltimer_handler
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|tcp_syn_recv_timer
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|tcp_twkill
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|variable|tcp_slow_timer
r_struct
id|timer_list
id|tcp_slow_timer
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|tcp_sltimer_handler
comma
)brace
suffix:semicolon
DECL|variable|tcp_slt_array
r_struct
id|tcp_sl_timer
id|tcp_slt_array
(braket
id|TCP_SLT_MAX
)braket
op_assign
(brace
(brace
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
comma
id|TCP_SYNACK_PERIOD
comma
l_int|0
comma
id|tcp_syn_recv_timer
)brace
comma
multiline_comment|/* SYNACK&t;*/
(brace
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
comma
id|TCP_TWKILL_PERIOD
comma
l_int|0
comma
id|tcp_twkill
)brace
multiline_comment|/* TWKILL&t;*/
)brace
suffix:semicolon
DECL|variable|timer_bug_msg
r_const
r_char
id|timer_bug_msg
(braket
)braket
op_assign
id|KERN_DEBUG
l_string|&quot;tcpbug: unknown timer value&bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n; * Using different timers for retransmit, delayed acks and probes&n; * We may wish use just one timer maintaining a list of expire jiffies &n; * to optimize.&n; */
DECL|function|tcp_init_xmit_timers
r_void
id|tcp_init_xmit_timers
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|init_timer
c_func
(paren
op_amp
id|sk-&gt;tp_pinfo.af_tcp.retransmit_timer
)paren
suffix:semicolon
id|sk-&gt;tp_pinfo.af_tcp.retransmit_timer.function
op_assign
op_amp
id|tcp_retransmit_timer
suffix:semicolon
id|sk-&gt;tp_pinfo.af_tcp.retransmit_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|sk-&gt;tp_pinfo.af_tcp.delack_timer
)paren
suffix:semicolon
id|sk-&gt;tp_pinfo.af_tcp.delack_timer.function
op_assign
op_amp
id|tcp_delack_timer
suffix:semicolon
id|sk-&gt;tp_pinfo.af_tcp.delack_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|sk-&gt;tp_pinfo.af_tcp.probe_timer
)paren
suffix:semicolon
id|sk-&gt;tp_pinfo.af_tcp.probe_timer.function
op_assign
op_amp
id|tcp_probe_timer
suffix:semicolon
id|sk-&gt;tp_pinfo.af_tcp.probe_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Reset the retransmission timer&n; */
DECL|function|tcp_reset_xmit_timer
r_void
id|tcp_reset_xmit_timer
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|what
comma
r_int
r_int
id|when
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|sk-&gt;timer_lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|what
)paren
(brace
r_case
id|TIME_RETRANS
suffix:colon
multiline_comment|/* When seting the transmit timer the probe timer &n;&t;&t; * should not be set.&n;&t;&t; * The delayed ack timer can be set if we are changing the&n;&t;&t; * retransmit timer when removing acked frames.&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;probe_timer.prev
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;probe_timer
)paren
)paren
(brace
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;retransmit_timer.prev
op_logical_or
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;retransmit_timer
)paren
)paren
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|when
OG
l_int|120
op_star
id|HZ
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;reset_xmit_timer sk=%p when=0x%lx, caller=%p&bslash;n&quot;
comma
id|sk
comma
id|when
comma
id|NET_CALLER
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|when
op_assign
l_int|120
op_star
id|HZ
suffix:semicolon
)brace
id|mod_timer
c_func
(paren
op_amp
id|tp-&gt;retransmit_timer
comma
id|jiffies
op_plus
id|when
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_DACK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;delack_timer.prev
op_logical_or
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;delack_timer
)paren
)paren
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|tp-&gt;delack_timer
comma
id|jiffies
op_plus
id|when
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_PROBE0
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;probe_timer.prev
op_logical_or
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;probe_timer
)paren
)paren
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|tp-&gt;probe_timer
comma
id|jiffies
op_plus
id|when
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_WRITE
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;bug: tcp_reset_xmit_timer TIME_WRITE&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;bug: unknown timer value&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;timer_lock
)paren
suffix:semicolon
)brace
DECL|function|tcp_clear_xmit_timers
r_void
id|tcp_clear_xmit_timers
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|sk-&gt;timer_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;retransmit_timer.prev
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;retransmit_timer
)paren
)paren
(brace
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;delack_timer.prev
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;delack_timer
)paren
)paren
(brace
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;probe_timer.prev
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;probe_timer
)paren
)paren
(brace
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;timer.prev
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
)paren
(brace
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;timer_lock
)paren
suffix:semicolon
)brace
DECL|function|tcp_write_err
r_static
r_void
id|tcp_write_err
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|force
)paren
(brace
id|sk-&gt;err
op_assign
id|sk-&gt;err_soft
ques
c_cond
id|sk-&gt;err_soft
suffix:colon
id|ETIMEDOUT
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_clear_xmit_timers
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Do not time wait the socket. It is timed out and, hence,&n;&t; * idle for 120*HZ. &quot;force&quot; argument is ignored, delete&n;&t; * it eventually.&n;&t; */
multiline_comment|/* Clean up time. */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|tcp_done
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* A write timeout has occurred. Process the after effects. */
DECL|function|tcp_write_timeout
r_static
r_void
id|tcp_write_timeout
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/* Look for a &squot;soft&squot; timeout. */
r_if
c_cond
(paren
(paren
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
op_logical_and
id|tp-&gt;retransmits
op_logical_and
(paren
id|tp-&gt;retransmits
op_mod
id|TCP_QUICK_TRIES
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|tp-&gt;retransmits
OG
id|sysctl_tcp_retries1
)paren
)paren
(brace
multiline_comment|/* NOTE. draft-ietf-tcpimpl-pmtud-01.txt requires pmtu black&n;&t;&t;   hole detection. :-(&n;&n;&t;&t;   It is place to make it. It is not made. I do not want&n;&t;&t;   to make it. It is disguisting. It does not work in any&n;&t;&t;   case. Let me to cite the same draft, which requires for&n;&t;&t;   us to implement this:&n;&n;   &quot;The one security concern raised by this memo is that ICMP black holes&n;   are often caused by over-zealous security administrators who block&n;   all ICMP messages.  It is vitally important that those who design and&n;   deploy security systems understand the impact of strict filtering on&n;   upper-layer protocols.  The safest web site in the world is worthless&n;   if most TCP implementations cannot transfer data from it.  It would&n;   be far nicer to have all of the black holes fixed rather than fixing&n;   all of the TCP implementations.&quot;&n;&n;                   Golden words :-).&n;&t;&t; */
id|dst_negative_advice
c_func
(paren
op_amp
id|sk-&gt;dst_cache
)paren
suffix:semicolon
)brace
multiline_comment|/* Have we tried to SYN too many times (repent repent 8)) */
r_if
c_cond
(paren
id|tp-&gt;retransmits
OG
id|sysctl_tcp_syn_retries
op_logical_and
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
)paren
(brace
id|tcp_write_err
c_func
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t FIN, we got nothing back */
)brace
r_else
r_if
c_cond
(paren
id|tp-&gt;retransmits
OG
id|sysctl_tcp_retries2
)paren
(brace
multiline_comment|/* Has it gone just too far? */
id|tcp_write_err
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
DECL|function|tcp_delack_timer
r_void
id|tcp_delack_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
id|bh_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;lock.users
)paren
(brace
multiline_comment|/* Try again later. */
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_DACK
comma
id|HZ
op_div
l_int|5
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;zapped
op_logical_and
id|sk-&gt;tp_pinfo.af_tcp.delayed_acks
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_CLOSE
)paren
(brace
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|bh_unlock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
DECL|function|tcp_probe_timer
r_void
id|tcp_probe_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|bh_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;lock.users
)paren
(brace
multiline_comment|/* Try again later. */
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|HZ
op_div
l_int|5
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* *WARNING* RFC 1122 forbids this&n;&t; *&n;&t; * It doesn&squot;t AFAIK, because we kill the retransmit timer -AK&n;&t; *&n;&t; * FIXME: We ought not to do it, Solaris 2.5 actually has fixing&n;&t; * this behaviour in Solaris down as a bug fix. [AC]&n;&t; *&n;&t; * Let me to explain. probes_out is zeroed by incoming ACKs&n;&t; * even if they advertise zero window. Hence, connection is killed only&n;&t; * if we received no ACKs for normal connection timeout. It is not killed&n;&t; * only because window stays zero for some time, window may be zero&n;&t; * until armageddon and even later. We are in full accordance&n;&t; * with RFCs, only probe timer combines both retransmission timeout&n;&t; * and probe timeout in one bottle.&t;&t;&t;&t;--ANK&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;probes_out
OG
id|sysctl_tcp_retries2
)paren
(brace
id|tcp_write_err
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Only send another probe if we didn&squot;t close things up. */
id|tcp_send_probe0
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|bh_unlock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|out
suffix:colon
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* Kill off TIME_WAIT sockets once their lifetime has expired. */
DECL|variable|tcp_tw_death_row_slot
r_int
id|tcp_tw_death_row_slot
op_assign
l_int|0
suffix:semicolon
DECL|variable|tcp_tw_death_row
r_static
r_struct
id|tcp_tw_bucket
op_star
id|tcp_tw_death_row
(braket
id|TCP_TWKILL_SLOTS
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|tw_death_lock
r_static
id|spinlock_t
id|tw_death_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|tcp_twkill
r_static
r_void
id|tcp_twkill
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|tcp_tw_bucket
op_star
id|tw
suffix:semicolon
r_int
id|killed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The death-row tw chains are only ever touched&n;&t; * in BH context so no BH disabling (for now) is needed.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
id|tw
op_assign
id|tcp_tw_death_row
(braket
id|tcp_tw_death_row_slot
)braket
suffix:semicolon
id|tcp_tw_death_row
(braket
id|tcp_tw_death_row_slot
)braket
op_assign
l_int|NULL
suffix:semicolon
id|tcp_tw_death_row_slot
op_assign
(paren
(paren
id|tcp_tw_death_row_slot
op_plus
l_int|1
)paren
op_amp
(paren
id|TCP_TWKILL_SLOTS
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tw
op_ne
l_int|NULL
)paren
(brace
r_struct
id|tcp_tw_bucket
op_star
id|next
op_assign
id|tw-&gt;next_death
suffix:semicolon
id|tcp_timewait_kill
c_func
(paren
id|tw
)paren
suffix:semicolon
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
id|killed
op_increment
suffix:semicolon
id|tw
op_assign
id|next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|killed
op_ne
l_int|0
)paren
(brace
r_struct
id|tcp_sl_timer
op_star
id|slt
op_assign
(paren
r_struct
id|tcp_sl_timer
op_star
)paren
id|data
suffix:semicolon
id|atomic_sub
c_func
(paren
id|killed
comma
op_amp
id|slt-&gt;count
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* These are always called from BH context.  See callers in&n; * tcp_input.c to verify this.&n; */
DECL|function|tcp_tw_schedule
r_void
id|tcp_tw_schedule
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
)paren
(brace
r_struct
id|tcp_tw_bucket
op_star
op_star
id|tpp
suffix:semicolon
r_int
id|slot
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
id|slot
op_assign
(paren
id|tcp_tw_death_row_slot
op_minus
l_int|1
)paren
op_amp
(paren
id|TCP_TWKILL_SLOTS
op_minus
l_int|1
)paren
suffix:semicolon
id|tpp
op_assign
op_amp
id|tcp_tw_death_row
(braket
id|slot
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tw-&gt;next_death
op_assign
op_star
id|tpp
)paren
op_ne
l_int|NULL
)paren
(brace
(paren
op_star
id|tpp
)paren
op_member_access_from_pointer
id|pprev_death
op_assign
op_amp
id|tw-&gt;next_death
suffix:semicolon
)brace
op_star
id|tpp
op_assign
id|tw
suffix:semicolon
id|tw-&gt;pprev_death
op_assign
id|tpp
suffix:semicolon
id|tw-&gt;death_slot
op_assign
id|slot
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|tw-&gt;refcnt
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
id|tcp_inc_slow_timer
c_func
(paren
id|TCP_SLT_TWKILL
)paren
suffix:semicolon
)brace
multiline_comment|/* Happens rarely if at all, no care about scalability here. */
DECL|function|tcp_tw_reschedule
r_void
id|tcp_tw_reschedule
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
)paren
(brace
r_struct
id|tcp_tw_bucket
op_star
op_star
id|tpp
suffix:semicolon
r_int
id|slot
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tw-&gt;pprev_death
)paren
(brace
r_if
c_cond
(paren
id|tw-&gt;next_death
)paren
(brace
id|tw-&gt;next_death-&gt;pprev_death
op_assign
id|tw-&gt;pprev_death
suffix:semicolon
)brace
op_star
id|tw-&gt;pprev_death
op_assign
id|tw-&gt;next_death
suffix:semicolon
id|tw-&gt;pprev_death
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
id|atomic_inc
c_func
(paren
op_amp
id|tw-&gt;refcnt
)paren
suffix:semicolon
id|slot
op_assign
(paren
id|tcp_tw_death_row_slot
op_minus
l_int|1
)paren
op_amp
(paren
id|TCP_TWKILL_SLOTS
op_minus
l_int|1
)paren
suffix:semicolon
id|tpp
op_assign
op_amp
id|tcp_tw_death_row
(braket
id|slot
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tw-&gt;next_death
op_assign
op_star
id|tpp
)paren
op_ne
l_int|NULL
)paren
(brace
(paren
op_star
id|tpp
)paren
op_member_access_from_pointer
id|pprev_death
op_assign
op_amp
id|tw-&gt;next_death
suffix:semicolon
)brace
op_star
id|tpp
op_assign
id|tw
suffix:semicolon
id|tw-&gt;pprev_death
op_assign
id|tpp
suffix:semicolon
id|tw-&gt;death_slot
op_assign
id|slot
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
multiline_comment|/* Timer was incremented when we first entered the table. */
)brace
multiline_comment|/* This is for handling early-kills of TIME_WAIT sockets. */
DECL|function|tcp_tw_deschedule
r_void
id|tcp_tw_deschedule
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tw-&gt;pprev_death
)paren
(brace
r_if
c_cond
(paren
id|tw-&gt;next_death
)paren
(brace
id|tw-&gt;next_death-&gt;pprev_death
op_assign
id|tw-&gt;pprev_death
suffix:semicolon
)brace
op_star
id|tw-&gt;pprev_death
op_assign
id|tw-&gt;next_death
suffix:semicolon
id|tw-&gt;pprev_death
op_assign
l_int|NULL
suffix:semicolon
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
id|tcp_dec_slow_timer
c_func
(paren
id|TCP_SLT_TWKILL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The TCP retransmit timer.&n; *&n; *&t;1. &t;An initial rtt timeout on the probe0 should cause what we can&n; *&t;&t;of the first write queue buffer to be split and sent.&n; *&t;2.&t;On a &squot;major timeout&squot; as defined by RFC1122 we do not report&n; *&t;&t;ETIMEDOUT if we know an additional &squot;soft&squot; error caused this.&n; *&t;&t;tcp_err saves a &squot;soft error&squot; for us.&n; */
DECL|function|tcp_retransmit_timer
r_void
id|tcp_retransmit_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
multiline_comment|/* We are reset. We will send no more retransmits. */
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|bh_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;lock.users
)paren
(brace
multiline_comment|/* Try again later */
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Clear delay ack timer. */
id|tcp_clear_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_DACK
)paren
suffix:semicolon
multiline_comment|/* RFC 2018, clear all &squot;sacked&squot; flags in retransmission queue,&n;&t; * the sender may have dropped out of order frames and we must&n;&t; * send them out should this timer fire on us.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;sack_ok
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|skb
op_ne
id|tp-&gt;send_head
)paren
op_logical_and
(paren
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_and_assign
op_complement
(paren
id|TCPCB_SACKED_ACKED
op_or
id|TCPCB_SACKED_RETRANS
)paren
suffix:semicolon
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/* Retransmission. */
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
id|tp-&gt;rexmt_done
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;fackets_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;retrans_out
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;retransmits
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Remember window where we lost:&n;&t;&t; * &quot;one half of the current window but at least 2 segments&quot;&n;&t;&t; *&n;&t;&t; * Here &quot;current window&quot; means the effective one, which&n;&t;&t; * means it must be an accurate representation of our current&n;&t;&t; * sending rate _and_ the snd_wnd.&n;&t;&t; */
id|tp-&gt;snd_ssthresh
op_assign
id|tcp_recalc_ssthresh
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;snd_cwnd_cnt
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;snd_cwnd
op_assign
l_int|1
suffix:semicolon
)brace
id|tp-&gt;retransmits
op_increment
suffix:semicolon
id|tp-&gt;dup_acks
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;high_seq
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
id|tcp_retransmit_skb
c_func
(paren
id|sk
comma
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
suffix:semicolon
multiline_comment|/* Increase the timeout each time we retransmit.  Note that&n;&t; * we do not increase the rtt estimate.  rto is initialized&n;&t; * from rtt, but increases here.  Jacobson (SIGCOMM 88) suggests&n;&t; * that doubling rto each time is the least we can get away with.&n;&t; * In KA9Q, Karn uses this for the first few times, and then&n;&t; * goes to quadratic.  netBSD doubles, but only goes up to *64,&n;&t; * and clamps at 1 to 64 sec afterwards.  Note that 120 sec is&n;&t; * defined in the protocol as the maximum possible RTT.  I guess&n;&t; * we&squot;ll have to use something other than TCP to talk to the&n;&t; * University of Mars.&n;&t; *&n;&t; * PAWS allows us longer timeouts and large windows, so once&n;&t; * implemented ftp to mars will work nicely. We will have to fix&n;&t; * the 120 second clamps though!&n;&t; */
id|tp-&gt;backoff
op_increment
suffix:semicolon
id|tp-&gt;rto
op_assign
id|min
c_func
(paren
id|tp-&gt;rto
op_lshift
l_int|1
comma
l_int|120
op_star
id|HZ
)paren
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
id|tcp_write_timeout
c_func
(paren
id|sk
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|bh_unlock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|out
suffix:colon
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Slow timer for SYN-RECV sockets&n; */
DECL|function|tcp_do_syn_queue
r_static
r_void
id|tcp_do_syn_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_opt
op_star
id|tp
comma
r_int
r_int
id|now
)paren
(brace
r_struct
id|open_request
op_star
id|prev
comma
op_star
id|req
suffix:semicolon
id|prev
op_assign
(paren
r_struct
id|open_request
op_star
)paren
op_amp
id|tp-&gt;syn_wait_queue
suffix:semicolon
r_for
c_loop
(paren
id|req
op_assign
id|tp-&gt;syn_wait_queue
suffix:semicolon
id|req
suffix:semicolon
)paren
(brace
r_struct
id|open_request
op_star
id|next
op_assign
id|req-&gt;dl_next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;sk
op_logical_and
(paren
r_int
)paren
(paren
id|now
op_minus
id|req-&gt;expires
)paren
op_ge
l_int|0
)paren
(brace
id|tcp_synq_unlink
c_func
(paren
id|tp
comma
id|req
comma
id|prev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;retrans
op_ge
id|sysctl_tcp_retries1
)paren
(brace
(paren
op_star
id|req
op_member_access_from_pointer
r_class
op_member_access_from_pointer
id|destructor
)paren
(paren
id|req
)paren
suffix:semicolon
id|tcp_dec_slow_timer
c_func
(paren
id|TCP_SLT_SYNACK
)paren
suffix:semicolon
id|tp-&gt;syn_backlog
op_decrement
suffix:semicolon
id|tcp_openreq_free
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;syn_wait_queue
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|timeo
suffix:semicolon
r_struct
id|open_request
op_star
id|rp
suffix:semicolon
(paren
op_star
id|req
op_member_access_from_pointer
r_class
op_member_access_from_pointer
id|rtx_syn_ack
)paren
(paren
id|sk
comma
id|req
)paren
suffix:semicolon
id|req-&gt;retrans
op_increment
suffix:semicolon
id|timeo
op_assign
id|min
c_func
(paren
(paren
id|TCP_TIMEOUT_INIT
op_lshift
id|req-&gt;retrans
)paren
comma
(paren
l_int|120
op_star
id|HZ
)paren
)paren
suffix:semicolon
id|req-&gt;expires
op_assign
id|now
op_plus
id|timeo
suffix:semicolon
id|rp
op_assign
id|prev-&gt;dl_next
suffix:semicolon
id|tcp_synq_queue
c_func
(paren
id|tp
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_ne
id|prev-&gt;dl_next
)paren
(brace
id|prev
op_assign
id|prev-&gt;dl_next
suffix:semicolon
)brace
)brace
)brace
r_else
id|prev
op_assign
id|req
suffix:semicolon
id|req
op_assign
id|next
suffix:semicolon
)brace
)brace
multiline_comment|/* This now scales very nicely. -DaveM */
DECL|function|tcp_syn_recv_timer
r_static
r_void
id|tcp_syn_recv_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_int
id|i
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tcp_lhash_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TCP_LHTABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sk
op_assign
id|tcp_listening_hash
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
multiline_comment|/* TCP_LISTEN is implied. */
id|bh_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;lock.users
op_logical_and
id|tp-&gt;syn_wait_queue
)paren
id|tcp_do_syn_queue
c_func
(paren
id|sk
comma
id|tp
comma
id|now
)paren
suffix:semicolon
id|bh_unlock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk
op_assign
id|sk-&gt;next
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|tcp_lhash_lock
)paren
suffix:semicolon
)brace
DECL|function|tcp_sltimer_handler
r_void
id|tcp_sltimer_handler
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|tcp_sl_timer
op_star
id|slt
op_assign
id|tcp_slt_array
suffix:semicolon
r_int
r_int
id|next
op_assign
op_complement
l_int|0UL
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TCP_SLT_MAX
suffix:semicolon
id|i
op_increment
comma
id|slt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|slt-&gt;count
)paren
)paren
(brace
r_int
id|trigger
suffix:semicolon
id|trigger
op_assign
id|slt-&gt;period
op_minus
(paren
(paren
r_int
)paren
(paren
id|now
op_minus
id|slt-&gt;last
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|trigger
op_le
l_int|0
)paren
(brace
(paren
op_star
id|slt-&gt;handler
)paren
(paren
(paren
r_int
r_int
)paren
id|slt
)paren
suffix:semicolon
id|slt-&gt;last
op_assign
id|now
suffix:semicolon
id|trigger
op_assign
id|slt-&gt;period
suffix:semicolon
)brace
multiline_comment|/* Only reschedule if some events remain. */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|slt-&gt;count
)paren
)paren
id|next
op_assign
id|min
c_func
(paren
id|next
comma
id|trigger
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|next
op_ne
op_complement
l_int|0UL
)paren
id|mod_timer
c_func
(paren
op_amp
id|tcp_slow_timer
comma
(paren
id|now
op_plus
id|next
)paren
)paren
suffix:semicolon
)brace
DECL|function|__tcp_inc_slow_timer
r_void
id|__tcp_inc_slow_timer
c_func
(paren
r_struct
id|tcp_sl_timer
op_star
id|slt
)paren
(brace
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_int
r_int
id|when
suffix:semicolon
id|slt-&gt;last
op_assign
id|now
suffix:semicolon
id|when
op_assign
id|now
op_plus
id|slt-&gt;period
suffix:semicolon
r_if
c_cond
(paren
id|tcp_slow_timer.prev
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|tcp_slow_timer.expires
op_minus
id|when
)paren
op_ge
l_int|0
)paren
id|mod_timer
c_func
(paren
op_amp
id|tcp_slow_timer
comma
id|when
)paren
suffix:semicolon
)brace
r_else
(brace
id|tcp_slow_timer.expires
op_assign
id|when
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|tcp_slow_timer
)paren
suffix:semicolon
)brace
)brace
DECL|function|tcp_delete_keepalive_timer
r_void
id|tcp_delete_keepalive_timer
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|sk-&gt;timer_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;timer.prev
op_logical_and
id|del_timer
(paren
op_amp
id|sk-&gt;timer
)paren
)paren
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;timer_lock
)paren
suffix:semicolon
)brace
DECL|function|tcp_reset_keepalive_timer
r_void
id|tcp_reset_keepalive_timer
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|len
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|sk-&gt;timer_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;timer.prev
op_logical_or
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
)paren
(brace
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|mod_timer
c_func
(paren
op_amp
id|sk-&gt;timer
comma
id|jiffies
op_plus
id|len
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;timer_lock
)paren
suffix:semicolon
)brace
DECL|function|tcp_set_keepalive
r_void
id|tcp_set_keepalive
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|val
)paren
(brace
r_if
c_cond
(paren
id|val
op_logical_and
op_logical_neg
id|sk-&gt;keepopen
)paren
id|tcp_reset_keepalive_timer
c_func
(paren
id|sk
comma
id|sysctl_tcp_keepalive_time
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|val
)paren
id|tcp_delete_keepalive_timer
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
DECL|function|tcp_keepalive_timer
r_void
id|tcp_keepalive_timer
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
id|__u32
id|elapsed
suffix:semicolon
multiline_comment|/* Only process if socket is not in use. */
id|bh_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;lock.users
)paren
(brace
multiline_comment|/* Try again later. */
id|tcp_reset_keepalive_timer
(paren
id|sk
comma
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT2
op_logical_and
id|sk-&gt;dead
)paren
r_goto
id|death
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;keepopen
)paren
r_goto
id|out
suffix:semicolon
id|elapsed
op_assign
id|sysctl_tcp_keepalive_time
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
l_int|1
op_lshift
id|sk-&gt;state
)paren
op_amp
(paren
id|TCPF_ESTABLISHED
op_or
id|TCPF_CLOSE_WAIT
op_or
id|TCPF_FIN_WAIT2
)paren
)paren
)paren
r_goto
id|resched
suffix:semicolon
id|elapsed
op_assign
id|tcp_time_stamp
op_minus
id|tp-&gt;rcv_tstamp
suffix:semicolon
r_if
c_cond
(paren
id|elapsed
op_ge
id|sysctl_tcp_keepalive_time
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;probes_out
OG
id|sysctl_tcp_keepalive_probes
)paren
(brace
id|tcp_write_err
c_func
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|tp-&gt;probes_out
op_increment
suffix:semicolon
id|tp-&gt;pending
op_assign
id|TIME_KEEPOPEN
suffix:semicolon
id|tcp_write_wakeup
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Randomize to avoid synchronization */
id|elapsed
op_assign
(paren
id|TCP_KEEPALIVE_PERIOD
op_rshift
l_int|1
)paren
op_plus
(paren
id|net_random
c_func
(paren
)paren
op_mod
id|TCP_KEEPALIVE_PERIOD
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It is tp-&gt;rcv_tstamp + sysctl_tcp_keepalive_time */
id|elapsed
op_assign
id|sysctl_tcp_keepalive_time
op_minus
id|elapsed
suffix:semicolon
)brace
id|resched
suffix:colon
id|tcp_reset_keepalive_timer
(paren
id|sk
comma
id|elapsed
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|death
suffix:colon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|tcp_clear_xmit_timers
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_done
c_func
(paren
id|sk
)paren
suffix:semicolon
id|out
suffix:colon
id|bh_unlock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
eof
