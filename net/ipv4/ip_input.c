multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;The Internet Protocol (IP) module.&n; *&n; * Version:&t;@(#)ip.c&t;1.0.16b&t;9/1/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Donald Becker, &lt;becker@super.org&gt;&n; *&t;&t;Alan Cox, &lt;Alan.Cox@linux.org&gt;&n; *&t;&t;Richard Underwood&n; *&t;&t;Stefan Becker, &lt;stefanb@yello.ping.de&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;Commented a couple of minor bits of surplus code&n; *&t;&t;Alan Cox&t;:&t;Undefining IP_FORWARD doesn&squot;t include the code&n; *&t;&t;&t;&t;&t;(just stops a compiler warning).&n; *&t;&t;Alan Cox&t;:&t;Frames with &gt;=MAX_ROUTE record routes, strict routes or loose routes&n; *&t;&t;&t;&t;&t;are junked rather than corrupting things.&n; *&t;&t;Alan Cox&t;:&t;Frames to bad broadcast subnets are dumped&n; *&t;&t;&t;&t;&t;We used to process them non broadcast and&n; *&t;&t;&t;&t;&t;boy could that cause havoc.&n; *&t;&t;Alan Cox&t;:&t;ip_forward sets the free flag on the&n; *&t;&t;&t;&t;&t;new frame it queues. Still crap because&n; *&t;&t;&t;&t;&t;it copies the frame but at least it&n; *&t;&t;&t;&t;&t;doesn&squot;t eat memory too.&n; *&t;&t;Alan Cox&t;:&t;Generic queue code and memory fixes.&n; *&t;&t;Fred Van Kempen :&t;IP fragment support (borrowed from NET2E)&n; *&t;&t;Gerhard Koerting:&t;Forward fragmented frames correctly.&n; *&t;&t;Gerhard Koerting: &t;Fixes to my fix of the above 8-).&n; *&t;&t;Gerhard Koerting:&t;IP interface addressing fix.&n; *&t;&t;Linus Torvalds&t;:&t;More robustness checks&n; *&t;&t;Alan Cox&t;:&t;Even more checks: Still not as robust as it ought to be&n; *&t;&t;Alan Cox&t;:&t;Save IP header pointer for later&n; *&t;&t;Alan Cox&t;:&t;ip option setting&n; *&t;&t;Alan Cox&t;:&t;Use ip_tos/ip_ttl settings&n; *&t;&t;Alan Cox&t;:&t;Fragmentation bogosity removed&n; *&t;&t;&t;&t;&t;(Thanks to Mark.Bush@prg.ox.ac.uk)&n; *&t;&t;Dmitry Gorodchanin :&t;Send of a raw packet crash fix.&n; *&t;&t;Alan Cox&t;:&t;Silly ip bug when an overlength&n; *&t;&t;&t;&t;&t;fragment turns up. Now frees the&n; *&t;&t;&t;&t;&t;queue.&n; *&t;&t;Linus Torvalds/ :&t;Memory leakage on fragmentation&n; *&t;&t;Alan Cox&t;:&t;handling.&n; *&t;&t;Gerhard Koerting:&t;Forwarding uses IP priority hints&n; *&t;&t;Teemu Rantanen&t;:&t;Fragment problems.&n; *&t;&t;Alan Cox&t;:&t;General cleanup, comments and reformat&n; *&t;&t;Alan Cox&t;:&t;SNMP statistics&n; *&t;&t;Alan Cox&t;:&t;BSD address rule semantics. Also see&n; *&t;&t;&t;&t;&t;UDP as there is a nasty checksum issue&n; *&t;&t;&t;&t;&t;if you do things the wrong way.&n; *&t;&t;Alan Cox&t;:&t;Always defrag, moved IP_FORWARD to the config.in file&n; *&t;&t;Alan Cox&t;: &t;IP options adjust sk-&gt;priority.&n; *&t;&t;Pedro Roque&t;:&t;Fix mtu/length error in ip_forward.&n; *&t;&t;Alan Cox&t;:&t;Avoid ip_chk_addr when possible.&n; *&t;Richard Underwood&t;:&t;IP multicasting.&n; *&t;&t;Alan Cox&t;:&t;Cleaned up multicast handlers.&n; *&t;&t;Alan Cox&t;:&t;RAW sockets demultiplex in the BSD style.&n; *&t;&t;Gunther Mayer&t;:&t;Fix the SNMP reporting typo&n; *&t;&t;Alan Cox&t;:&t;Always in group 224.0.0.1&n; *&t;Pauline Middelink&t;:&t;Fast ip_checksum update when forwarding&n; *&t;&t;&t;&t;&t;Masquerading support.&n; *&t;&t;Alan Cox&t;:&t;Multicast loopback error for 224.0.0.1&n; *&t;&t;Alan Cox&t;:&t;IP_MULTICAST_LOOP option.&n; *&t;&t;Alan Cox&t;:&t;Use notifiers.&n; *&t;&t;Bjorn Ekwall&t;:&t;Removed ip_csum (from slhc.c too)&n; *&t;&t;Bjorn Ekwall&t;:&t;Moved ip_fast_csum to ip.h (inline!)&n; *&t;&t;Stefan Becker   :       Send out ICMP HOST REDIRECT&n; *&t;Arnt Gulbrandsen&t;:&t;ip_build_xmit&n; *&t;&t;Alan Cox&t;:&t;Per socket routing cache&n; *&t;&t;Alan Cox&t;:&t;Fixed routing cache, added header cache.&n; *&t;&t;Alan Cox&t;:&t;Loopback didnt work right in original ip_build_xmit - fixed it.&n; *&t;&t;Alan Cox&t;:&t;Only send ICMP_REDIRECT if src/dest are the same net.&n; *&t;&t;Alan Cox&t;:&t;Incoming IP option handling.&n; *&t;&t;Alan Cox&t;:&t;Set saddr on raw output frames as per BSD.&n; *&t;&t;Alan Cox&t;:&t;Stopped broadcast source route explosions.&n; *&t;&t;Alan Cox&t;:&t;Can disable source routing&n; *&t;&t;Takeshi Sone    :&t;Masquerading didn&squot;t work.&n; *&t;Dave Bonn,Alan Cox&t;:&t;Faster IP forwarding whenever possible.&n; *&t;&t;Alan Cox&t;:&t;Memory leaks, tramples, misc debugging.&n; *&t;&t;Alan Cox&t;:&t;Fixed multicast (by popular demand 8))&n; *&t;&t;Alan Cox&t;:&t;Fixed forwarding (by even more popular demand 8))&n; *&t;&t;Alan Cox&t;:&t;Fixed SNMP statistics [I think]&n; *&t;Gerhard Koerting&t;:&t;IP fragmentation forwarding fix&n; *&t;&t;Alan Cox&t;:&t;Device lock against page fault.&n; *&t;&t;Alan Cox&t;:&t;IP_HDRINCL facility.&n; *&t;Werner Almesberger&t;:&t;Zero fragment bug&n; *&t;&t;Alan Cox&t;:&t;RAW IP frame length bug&n; *&t;&t;Alan Cox&t;:&t;Outgoing firewall on build_xmit&n; *&t;&t;A.N.Kuznetsov&t;:&t;IP_OPTIONS support throughout the kernel&n; *&t;&t;Alan Cox&t;:&t;Multicast routing hooks&n; *&n; *  &n; *&n; * To Fix:&n; *&t;&t;IP fragmentation wants rewriting cleanly. The RFC815 algorithm is much more efficient&n; *&t;&t;and could be made very efficient with the addition of some virtual memory hacks to permit&n; *&t;&t;the allocation of a buffer that can then be &squot;grown&squot; by twiddling page tables.&n; *&t;&t;Output fragmentation wants updating along with the buffer management to use a single &n; *&t;&t;interleaved copy algorithm so that fragmenting has a one copy overhead. Actual packet&n; *&t;&t;output should probably do its own fragmentation at the UDP/RAW layer. TCP shouldn&squot;t cause&n; *&t;&t;fragmentation anyway.&n; *&n; *&t;&t;FIXME: copy frag 0 iph to qp-&gt;iph&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;net/snmp.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/raw.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;linux/igmp.h&gt;
macro_line|#include &lt;linux/ip_fw.h&gt;
macro_line|#include &lt;linux/firewall.h&gt;
macro_line|#include &lt;linux/mroute.h&gt;
macro_line|#include &lt;net/netlink.h&gt;
macro_line|#ifdef CONFIG_NET_ALIAS
macro_line|#include &lt;linux/net_alias.h&gt;
macro_line|#endif
r_extern
r_int
id|last_retran
suffix:semicolon
r_extern
r_void
id|sort_send
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|macro|min
mdefine_line|#define min(a,b)&t;((a)&lt;(b)?(a):(b))
multiline_comment|/*&n; *&t;SNMP management statistics&n; */
macro_line|#ifdef CONFIG_IP_FORWARD
DECL|variable|ip_statistics
r_struct
id|ip_mib
id|ip_statistics
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Forwarding=Yes, Default TTL=64 */
macro_line|#else
DECL|variable|ip_statistics
r_struct
id|ip_mib
id|ip_statistics
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Forwarding=No, Default TTL=64 */
macro_line|#endif
multiline_comment|/*&n; *&t;Handle the issuing of an ioctl() request&n; *&t;for the ip device. This is scheduled to&n; *&t;disappear&n; */
DECL|function|ip_ioctl
r_int
id|ip_ioctl
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;This function receives all incoming IP datagrams.&n; *&n; *&t;On entry skb-&gt;data points to the start of the IP header and&n; *&t;the MAC header has been removed.&n; */
DECL|function|ip_rcv
r_int
id|ip_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;h.iph
suffix:semicolon
r_struct
id|sock
op_star
id|raw_sk
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
id|hash
suffix:semicolon
r_int
r_char
id|flag
op_assign
l_int|0
suffix:semicolon
r_struct
id|inet_protocol
op_star
id|ipprot
suffix:semicolon
r_int
id|brd
op_assign
id|IS_MYADDR
suffix:semicolon
r_struct
id|options
op_star
id|opt
op_assign
l_int|NULL
suffix:semicolon
r_int
id|is_frag
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_FIREWALL
r_int
id|err
suffix:semicolon
macro_line|#endif&t;
macro_line|#ifdef CONFIG_IP_MROUTE
r_int
id|mroute_pkt
op_assign
l_int|0
suffix:semicolon
macro_line|#endif&t;
macro_line|#ifdef CONFIG_NET_IPV6
multiline_comment|/* &n;&t; *&t;Intercept IPv6 frames. We dump ST-II and invalid types just below..&n;&t; */
r_if
c_cond
(paren
id|iph-&gt;version
op_eq
l_int|6
)paren
(brace
r_return
id|ipv6_rcv
c_func
(paren
id|skb
comma
id|dev
comma
id|pt
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;
id|ip_statistics.IpInReceives
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Tag the ip header of this packet so we can find it&n;&t; */
id|skb-&gt;ip_hdr
op_assign
id|iph
suffix:semicolon
multiline_comment|/*&n;&t; *&t;RFC1122: 3.1.2.2 MUST silently discard any IP frame that fails the checksum.&n;&t; *&t;RFC1122: 3.1.2.3 MUST discard a frame with invalid source address [NEEDS FIXING].&n;&t; *&n;&t; *&t;Is the datagram acceptable?&n;&t; *&n;&t; *&t;1.&t;Length at least the size of an ip header&n;&t; *&t;2.&t;Version of 4&n;&t; *&t;3.&t;Checksums correctly. [Speed optimisation for later, skip loopback checksums]&n;&t; *&t;4.&t;Doesn&squot;t have a bogus length&n;&t; *&t;(5.&t;We ought to check for IP multicast addresses and undefined types.. does this matter ?)&n;&t; */
r_if
c_cond
(paren
id|skb-&gt;len
OL
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_logical_or
id|iph-&gt;ihl
OL
l_int|5
op_logical_or
id|iph-&gt;version
op_ne
l_int|4
op_logical_or
id|ip_fast_csum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|iph
comma
id|iph-&gt;ihl
)paren
op_ne
l_int|0
op_logical_or
id|skb-&gt;len
OL
id|ntohs
c_func
(paren
id|iph-&gt;tot_len
)paren
)paren
(brace
id|ip_statistics.IpInHdrErrors
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Our transport medium may have padded the buffer out. Now we know it&n;&t; *&t;is IP we can trim to the true length of the frame.&n;&t; *&t;Note this now means skb-&gt;len holds ntohs(iph-&gt;tot_len).&n;&t; */
id|skb_trim
c_func
(paren
id|skb
comma
id|ntohs
c_func
(paren
id|iph-&gt;tot_len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iph-&gt;ihl
OG
l_int|5
)paren
(brace
id|skb-&gt;ip_summed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ip_options_compile
c_func
(paren
l_int|NULL
comma
id|skb
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|opt
op_assign
(paren
r_struct
id|options
op_star
)paren
id|skb-&gt;proto_priv
suffix:semicolon
macro_line|#ifdef CONFIG_IP_NOSR
r_if
c_cond
(paren
id|opt-&gt;srr
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;&t;
)brace
multiline_comment|/*&n;&t; *&t;See if the firewall wants to dispose of the packet. &n;&t; */
macro_line|#ifdef&t;CONFIG_FIREWALL
r_if
c_cond
(paren
(paren
id|err
op_assign
id|call_in_firewall
c_func
(paren
id|PF_INET
comma
id|skb
comma
id|iph
)paren
)paren
OL
id|FW_ACCEPT
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
id|FW_REJECT
)paren
(brace
id|icmp_send
c_func
(paren
id|skb
comma
id|ICMP_DEST_UNREACH
comma
id|ICMP_PORT_UNREACH
comma
l_int|0
comma
id|dev
)paren
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Remember if the frame is fragmented.&n;&t; */
r_if
c_cond
(paren
id|iph-&gt;frag_off
)paren
(brace
r_if
c_cond
(paren
id|iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_MF
)paren
)paren
id|is_frag
op_or_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Last fragment ?&n;&t;&t; */
r_if
c_cond
(paren
id|iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_OFFSET
)paren
)paren
id|is_frag
op_or_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Do any IP forwarding required.  chk_addr() is expensive -- avoid it someday.&n;&t; *&n;&t; *&t;This is inefficient. While finding out if it is for us we could also compute&n;&t; *&t;the routing table entry. This is where the great unified cache theory comes&n;&t; *&t;in as and when someone implements it&n;&t; *&n;&t; *&t;For most hosts over 99% of packets match the first conditional&n;&t; *&t;and don&squot;t go via ip_chk_addr. Note: brd is set to IS_MYADDR at&n;&t; *&t;function entry.&n;&t; */
multiline_comment|/*&n;&t; *&t;also check device aliases address : will avoid&n;&t; *&t;a full lookup over device chain&n;&t; */
macro_line|#ifdef CONFIG_NET_ALIAS
r_if
c_cond
(paren
id|iph-&gt;daddr
op_eq
id|skb-&gt;dev-&gt;pa_addr
op_logical_or
(paren
id|net_alias_has
c_func
(paren
id|skb-&gt;dev
)paren
op_logical_and
id|net_alias_addr_chk32
c_func
(paren
id|skb-&gt;dev
comma
id|AF_INET
comma
id|iph-&gt;daddr
)paren
)paren
op_logical_or
(paren
id|brd
op_assign
id|ip_chk_addr
c_func
(paren
id|iph-&gt;daddr
)paren
)paren
op_ne
l_int|0
)paren
macro_line|#else
r_if
c_cond
(paren
id|iph-&gt;daddr
op_eq
id|skb-&gt;dev-&gt;pa_addr
op_logical_or
(paren
id|brd
op_assign
id|ip_chk_addr
c_func
(paren
id|iph-&gt;daddr
)paren
)paren
op_ne
l_int|0
)paren
macro_line|#endif
(brace
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;srr
)paren
(brace
r_int
id|srrspace
comma
id|srrptr
suffix:semicolon
id|__u32
id|nexthop
suffix:semicolon
r_int
r_char
op_star
id|optptr
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|iph
)paren
op_plus
id|opt-&gt;srr
suffix:semicolon
r_if
c_cond
(paren
id|brd
op_ne
id|IS_MYADDR
op_logical_or
id|skb-&gt;pkt_type
op_ne
id|PACKET_HOST
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|srrptr
op_assign
id|optptr
(braket
l_int|2
)braket
comma
id|srrspace
op_assign
id|optptr
(braket
l_int|1
)braket
suffix:semicolon
id|srrptr
op_le
id|srrspace
suffix:semicolon
id|srrptr
op_add_assign
l_int|4
)paren
(brace
r_int
id|brd2
suffix:semicolon
r_if
c_cond
(paren
id|srrptr
op_plus
l_int|3
OG
id|srrspace
)paren
(brace
id|icmp_send
c_func
(paren
id|skb
comma
id|ICMP_PARAMETERPROB
comma
l_int|0
comma
id|opt-&gt;srr
op_plus
l_int|2
comma
id|skb-&gt;dev
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|nexthop
comma
op_amp
id|optptr
(braket
id|srrptr
op_minus
l_int|1
)braket
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|brd2
op_assign
id|ip_chk_addr
c_func
(paren
id|nexthop
)paren
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|brd2
op_ne
id|IS_MYADDR
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;ANK: should we implement weak tunneling of multicasts?&n;&t;&t;&t;&t;&t; *&t;Are they obsolete? DVMRP specs (RFC-1075) is old enough...&n;&t;&t;&t;&t;&t; *&t;[They are obsolete]&n;&t;&t;&t;&t;&t; */
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|srrptr
op_le
id|srrspace
)paren
(brace
id|opt-&gt;srr_is_hit
op_assign
l_int|1
suffix:semicolon
id|opt-&gt;is_changed
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_IP_FORWARD
r_if
c_cond
(paren
id|ip_forward
c_func
(paren
id|skb
comma
id|dev
comma
id|is_frag
comma
id|nexthop
)paren
)paren
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
macro_line|#else
id|ip_statistics.IpInAddrErrors
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_IP_MULTICAST&t;
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_and
id|brd
op_eq
id|IS_MULTICAST
op_logical_and
id|iph-&gt;daddr
op_ne
id|IGMP_ALL_HOSTS
op_logical_and
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Check it is for one of our groups&n;&t;&t;&t; */
r_struct
id|ip_mc_list
op_star
id|ip_mc
op_assign
id|dev-&gt;ip_mc_list
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|ip_mc
op_eq
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip_mc-&gt;multiaddr
op_eq
id|iph-&gt;daddr
)paren
(brace
r_break
suffix:semicolon
)brace
id|ip_mc
op_assign
id|ip_mc-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_IP_MASQUERADE
multiline_comment|/*&n;&t;&t; * Do we need to de-masquerade this fragment?&n;&t;&t; */
r_if
c_cond
(paren
id|ip_fw_demasquerade
c_func
(paren
id|skb
)paren
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;h.iph
suffix:semicolon
r_if
c_cond
(paren
id|ip_forward
c_func
(paren
id|skb
comma
id|dev
comma
id|is_frag
op_or
l_int|4
comma
id|iph-&gt;daddr
)paren
)paren
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; *&t;Account for the packet&n;&t;&t; */
macro_line|#ifdef CONFIG_IP_ACCT
id|ip_fw_chk
c_func
(paren
id|iph
comma
id|dev
comma
id|ip_acct_chain
comma
id|IP_FW_F_ACCEPT
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif&t;
multiline_comment|/*&n;&t;&t; *&t;Reassemble IP fragments.&n;&t;&t; */
r_if
c_cond
(paren
id|is_frag
)paren
(brace
multiline_comment|/* Defragment. Obtain the complete packet if there is one */
id|skb
op_assign
id|ip_defrag
c_func
(paren
id|iph
comma
id|skb
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|iph
op_assign
id|skb-&gt;h.iph
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Point into the IP datagram, just past the header.&n;&t;&t; */
id|skb-&gt;ip_hdr
op_assign
id|iph
suffix:semicolon
id|skb-&gt;h.raw
op_add_assign
id|iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
macro_line|#ifdef CONFIG_IP_MROUTE&t;&t;
multiline_comment|/*&n;&t;&t; *&t;Check the state on multicast routing (multicast and not 224.0.0.z)&n;&t;&t; */
r_if
c_cond
(paren
id|brd
op_eq
id|IS_MULTICAST
op_logical_and
(paren
id|iph-&gt;daddr
op_amp
id|htonl
c_func
(paren
l_int|0xFFFFFF00
)paren
)paren
op_ne
id|htonl
c_func
(paren
l_int|0xE0000000
)paren
)paren
(brace
id|mroute_pkt
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; *&t;Deliver to raw sockets. This is fun as to avoid copies we want to make no surplus copies.&n;&t;&t; *&n;&t;&t; *&t;RFC 1122: SHOULD pass TOS value up to the transport layer.&n;&t;&t; */
id|hash
op_assign
id|iph-&gt;protocol
op_amp
(paren
id|SOCK_ARRAY_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; *&t;If there maybe a raw socket we must check - if not we don&squot;t care less &n;&t;&t; */
r_if
c_cond
(paren
(paren
id|raw_sk
op_assign
id|raw_prot.sock_array
(braket
id|hash
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|sock
op_star
id|sknext
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb1
suffix:semicolon
id|raw_sk
op_assign
id|get_sock_raw
c_func
(paren
id|raw_sk
comma
id|iph-&gt;protocol
comma
id|iph-&gt;saddr
comma
id|iph-&gt;daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raw_sk
)paren
multiline_comment|/* Any raw sockets */
(brace
r_do
(brace
multiline_comment|/* Find the next */
id|sknext
op_assign
id|get_sock_raw
c_func
(paren
id|raw_sk-&gt;next
comma
id|iph-&gt;protocol
comma
id|iph-&gt;saddr
comma
id|iph-&gt;daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sknext
)paren
(brace
id|skb1
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
multiline_comment|/* One pending raw socket left */
r_if
c_cond
(paren
id|skb1
)paren
(brace
id|raw_rcv
c_func
(paren
id|raw_sk
comma
id|skb1
comma
id|dev
comma
id|iph-&gt;saddr
comma
id|iph-&gt;daddr
)paren
suffix:semicolon
)brace
id|raw_sk
op_assign
id|sknext
suffix:semicolon
)brace
r_while
c_loop
(paren
id|raw_sk
op_ne
l_int|NULL
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Here either raw_sk is the last raw socket, or NULL if none &n;&t;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t;&t; *&t;We deliver to the last raw socket AFTER the protocol checks as it avoids a surplus copy &n;&t;&t;&t;&t; */
)brace
)brace
multiline_comment|/*&n;&t;&t; *&t;skb-&gt;h.raw now points at the protocol beyond the IP header.&n;&t;&t; */
id|hash
op_assign
id|iph-&gt;protocol
op_amp
(paren
id|MAX_INET_PROTOS
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ipprot
op_assign
(paren
r_struct
id|inet_protocol
op_star
)paren
id|inet_protos
(braket
id|hash
)braket
suffix:semicolon
id|ipprot
op_ne
l_int|NULL
suffix:semicolon
id|ipprot
op_assign
(paren
r_struct
id|inet_protocol
op_star
)paren
id|ipprot-&gt;next
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_if
c_cond
(paren
id|ipprot-&gt;protocol
op_ne
id|iph-&gt;protocol
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;* &t;See if we need to make a copy of it.  This will&n;&t;&t;&t;* &t;only be set if more than one protocol wants it.&n;&t;&t;&t;* &t;and then not for the last one. If there is a pending&n;&t;&t;&t;*&t;raw delivery wait for that&n;&t;&t;&t;*/
macro_line|#ifdef CONFIG_IP_MROUTE
r_if
c_cond
(paren
id|ipprot-&gt;copy
op_logical_or
id|raw_sk
op_logical_or
id|mroute_pkt
)paren
macro_line|#else&t;
r_if
c_cond
(paren
id|ipprot-&gt;copy
op_logical_or
id|raw_sk
)paren
macro_line|#endif&t;&t;&t;
(brace
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb2
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
)brace
r_else
(brace
id|skb2
op_assign
id|skb
suffix:semicolon
)brace
id|flag
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;*&t;Pass on the datagram to each protocol that wants it,&n;&t;&t;&t;*&t;based on the datagram protocol.  We should really&n;&t;&t;&t;*&t;check the protocol handler&squot;s return values here...&n;&t;&t;&t;*/
id|ipprot
op_member_access_from_pointer
id|handler
c_func
(paren
id|skb2
comma
id|dev
comma
id|opt
comma
id|iph-&gt;daddr
comma
(paren
id|ntohs
c_func
(paren
id|iph-&gt;tot_len
)paren
op_minus
(paren
id|iph-&gt;ihl
op_star
l_int|4
)paren
)paren
comma
id|iph-&gt;saddr
comma
l_int|0
comma
id|ipprot
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;All protocols checked.&n;&t;&t; *&t;If this packet was a broadcast, we may *not* reply to it, since that&n;&t;&t; *&t;causes (proven, grin) ARP storms and a leakage of memory (i.e. all&n;&t;&t; *&t;ICMP reply messages get queued up for transmission...)&n;&t;&t; */
macro_line|#ifdef CONFIG_IP_MROUTE&t;&t; 
multiline_comment|/*&n;&t;&t; *&t;Forward the last copy to the multicast router. If&n;&t;&t; *&t;there is a pending raw deliery however make a copy&n;&t;&t; *&t;and forward that.&n;&t;&t; */
r_if
c_cond
(paren
id|mroute_pkt
)paren
(brace
id|flag
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|raw_sk
op_eq
l_int|NULL
)paren
(brace
id|ipmr_forward
c_func
(paren
id|skb
comma
id|is_frag
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|sk_buff
op_star
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb2
)paren
(brace
id|skb2-&gt;free
op_assign
l_int|1
suffix:semicolon
id|ipmr_forward
c_func
(paren
id|skb2
comma
id|is_frag
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif&t;&t;
r_if
c_cond
(paren
id|raw_sk
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Shift to last raw user */
id|raw_rcv
c_func
(paren
id|raw_sk
comma
id|skb
comma
id|dev
comma
id|iph-&gt;saddr
comma
id|iph-&gt;daddr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
multiline_comment|/* Free and report errors */
(brace
r_if
c_cond
(paren
id|brd
op_ne
id|IS_BROADCAST
op_logical_and
id|brd
op_ne
id|IS_MULTICAST
)paren
id|icmp_send
c_func
(paren
id|skb
comma
id|ICMP_DEST_UNREACH
comma
id|ICMP_PROT_UNREACH
comma
l_int|0
comma
id|dev
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Do any unicast IP forwarding required.&n;&t; */
multiline_comment|/*&n;&t; *&t;Don&squot;t forward multicast or broadcast frames.&n;&t; */
r_if
c_cond
(paren
id|skb-&gt;pkt_type
op_ne
id|PACKET_HOST
op_logical_or
id|brd
op_eq
id|IS_BROADCAST
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;The packet is for another target. Forward the frame&n;&t; */
macro_line|#ifdef CONFIG_IP_FORWARD
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;is_strictroute
)paren
(brace
id|icmp_send
c_func
(paren
id|skb
comma
id|ICMP_PARAMETERPROB
comma
l_int|0
comma
l_int|16
comma
id|skb-&gt;dev
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip_forward
c_func
(paren
id|skb
comma
id|dev
comma
id|is_frag
comma
id|iph-&gt;daddr
)paren
)paren
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/*&t;printk(&quot;Machine %lx tried to use us as a forwarder to %lx but we have forwarding disabled!&bslash;n&quot;,&n;&t;&t;&t;iph-&gt;saddr,iph-&gt;daddr);*/
id|ip_statistics.IpInAddrErrors
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
eof
