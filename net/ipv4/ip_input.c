multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;The Internet Protocol (IP) module.&n; *&n; * Version:&t;$Id: ip_input.c,v 1.37 1999/04/22 10:38:36 davem Exp $&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Donald Becker, &lt;becker@super.org&gt;&n; *&t;&t;Alan Cox, &lt;Alan.Cox@linux.org&gt;&n; *&t;&t;Richard Underwood&n; *&t;&t;Stefan Becker, &lt;stefanb@yello.ping.de&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;Commented a couple of minor bits of surplus code&n; *&t;&t;Alan Cox&t;:&t;Undefining IP_FORWARD doesn&squot;t include the code&n; *&t;&t;&t;&t;&t;(just stops a compiler warning).&n; *&t;&t;Alan Cox&t;:&t;Frames with &gt;=MAX_ROUTE record routes, strict routes or loose routes&n; *&t;&t;&t;&t;&t;are junked rather than corrupting things.&n; *&t;&t;Alan Cox&t;:&t;Frames to bad broadcast subnets are dumped&n; *&t;&t;&t;&t;&t;We used to process them non broadcast and&n; *&t;&t;&t;&t;&t;boy could that cause havoc.&n; *&t;&t;Alan Cox&t;:&t;ip_forward sets the free flag on the&n; *&t;&t;&t;&t;&t;new frame it queues. Still crap because&n; *&t;&t;&t;&t;&t;it copies the frame but at least it&n; *&t;&t;&t;&t;&t;doesn&squot;t eat memory too.&n; *&t;&t;Alan Cox&t;:&t;Generic queue code and memory fixes.&n; *&t;&t;Fred Van Kempen :&t;IP fragment support (borrowed from NET2E)&n; *&t;&t;Gerhard Koerting:&t;Forward fragmented frames correctly.&n; *&t;&t;Gerhard Koerting: &t;Fixes to my fix of the above 8-).&n; *&t;&t;Gerhard Koerting:&t;IP interface addressing fix.&n; *&t;&t;Linus Torvalds&t;:&t;More robustness checks&n; *&t;&t;Alan Cox&t;:&t;Even more checks: Still not as robust as it ought to be&n; *&t;&t;Alan Cox&t;:&t;Save IP header pointer for later&n; *&t;&t;Alan Cox&t;:&t;ip option setting&n; *&t;&t;Alan Cox&t;:&t;Use ip_tos/ip_ttl settings&n; *&t;&t;Alan Cox&t;:&t;Fragmentation bogosity removed&n; *&t;&t;&t;&t;&t;(Thanks to Mark.Bush@prg.ox.ac.uk)&n; *&t;&t;Dmitry Gorodchanin :&t;Send of a raw packet crash fix.&n; *&t;&t;Alan Cox&t;:&t;Silly ip bug when an overlength&n; *&t;&t;&t;&t;&t;fragment turns up. Now frees the&n; *&t;&t;&t;&t;&t;queue.&n; *&t;&t;Linus Torvalds/ :&t;Memory leakage on fragmentation&n; *&t;&t;Alan Cox&t;:&t;handling.&n; *&t;&t;Gerhard Koerting:&t;Forwarding uses IP priority hints&n; *&t;&t;Teemu Rantanen&t;:&t;Fragment problems.&n; *&t;&t;Alan Cox&t;:&t;General cleanup, comments and reformat&n; *&t;&t;Alan Cox&t;:&t;SNMP statistics&n; *&t;&t;Alan Cox&t;:&t;BSD address rule semantics. Also see&n; *&t;&t;&t;&t;&t;UDP as there is a nasty checksum issue&n; *&t;&t;&t;&t;&t;if you do things the wrong way.&n; *&t;&t;Alan Cox&t;:&t;Always defrag, moved IP_FORWARD to the config.in file&n; *&t;&t;Alan Cox&t;: &t;IP options adjust sk-&gt;priority.&n; *&t;&t;Pedro Roque&t;:&t;Fix mtu/length error in ip_forward.&n; *&t;&t;Alan Cox&t;:&t;Avoid ip_chk_addr when possible.&n; *&t;Richard Underwood&t;:&t;IP multicasting.&n; *&t;&t;Alan Cox&t;:&t;Cleaned up multicast handlers.&n; *&t;&t;Alan Cox&t;:&t;RAW sockets demultiplex in the BSD style.&n; *&t;&t;Gunther Mayer&t;:&t;Fix the SNMP reporting typo&n; *&t;&t;Alan Cox&t;:&t;Always in group 224.0.0.1&n; *&t;Pauline Middelink&t;:&t;Fast ip_checksum update when forwarding&n; *&t;&t;&t;&t;&t;Masquerading support.&n; *&t;&t;Alan Cox&t;:&t;Multicast loopback error for 224.0.0.1&n; *&t;&t;Alan Cox&t;:&t;IP_MULTICAST_LOOP option.&n; *&t;&t;Alan Cox&t;:&t;Use notifiers.&n; *&t;&t;Bjorn Ekwall&t;:&t;Removed ip_csum (from slhc.c too)&n; *&t;&t;Bjorn Ekwall&t;:&t;Moved ip_fast_csum to ip.h (inline!)&n; *&t;&t;Stefan Becker   :       Send out ICMP HOST REDIRECT&n; *&t;Arnt Gulbrandsen&t;:&t;ip_build_xmit&n; *&t;&t;Alan Cox&t;:&t;Per socket routing cache&n; *&t;&t;Alan Cox&t;:&t;Fixed routing cache, added header cache.&n; *&t;&t;Alan Cox&t;:&t;Loopback didn&squot;t work right in original ip_build_xmit - fixed it.&n; *&t;&t;Alan Cox&t;:&t;Only send ICMP_REDIRECT if src/dest are the same net.&n; *&t;&t;Alan Cox&t;:&t;Incoming IP option handling.&n; *&t;&t;Alan Cox&t;:&t;Set saddr on raw output frames as per BSD.&n; *&t;&t;Alan Cox&t;:&t;Stopped broadcast source route explosions.&n; *&t;&t;Alan Cox&t;:&t;Can disable source routing&n; *&t;&t;Takeshi Sone    :&t;Masquerading didn&squot;t work.&n; *&t;Dave Bonn,Alan Cox&t;:&t;Faster IP forwarding whenever possible.&n; *&t;&t;Alan Cox&t;:&t;Memory leaks, tramples, misc debugging.&n; *&t;&t;Alan Cox&t;:&t;Fixed multicast (by popular demand 8))&n; *&t;&t;Alan Cox&t;:&t;Fixed forwarding (by even more popular demand 8))&n; *&t;&t;Alan Cox&t;:&t;Fixed SNMP statistics [I think]&n; *&t;Gerhard Koerting&t;:&t;IP fragmentation forwarding fix&n; *&t;&t;Alan Cox&t;:&t;Device lock against page fault.&n; *&t;&t;Alan Cox&t;:&t;IP_HDRINCL facility.&n; *&t;Werner Almesberger&t;:&t;Zero fragment bug&n; *&t;&t;Alan Cox&t;:&t;RAW IP frame length bug&n; *&t;&t;Alan Cox&t;:&t;Outgoing firewall on build_xmit&n; *&t;&t;A.N.Kuznetsov&t;:&t;IP_OPTIONS support throughout the kernel&n; *&t;&t;Alan Cox&t;:&t;Multicast routing hooks&n; *&t;&t;Jos Vos&t;&t;:&t;Do accounting *before* call_in_firewall&n; *&t;Willy Konynenberg&t;:&t;Transparent proxying support&n; *&n; *  &n; *&n; * To Fix:&n; *&t;&t;IP fragmentation wants rewriting cleanly. The RFC815 algorithm is much more efficient&n; *&t;&t;and could be made very efficient with the addition of some virtual memory hacks to permit&n; *&t;&t;the allocation of a buffer that can then be &squot;grown&squot; by twiddling page tables.&n; *&t;&t;Output fragmentation wants updating along with the buffer management to use a single &n; *&t;&t;interleaved copy algorithm so that fragmenting has a one copy overhead. Actual packet&n; *&t;&t;output should probably do its own fragmentation at the UDP/RAW layer. TCP shouldn&squot;t cause&n; *&t;&t;fragmentation anyway.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;net/snmp.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/raw.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;linux/ip_fw.h&gt;
macro_line|#ifdef CONFIG_IP_MASQUERADE
macro_line|#include &lt;net/ip_masq.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/firewall.h&gt;
macro_line|#include &lt;linux/mroute.h&gt;
macro_line|#include &lt;linux/netlink.h&gt;
multiline_comment|/*&n; *&t;SNMP management statistics&n; */
DECL|variable|ip_statistics
r_struct
id|ip_mib
id|ip_statistics
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Forwarding=No, Default TTL=64 */
multiline_comment|/*&n; *&t;Handle the issuing of an ioctl() request&n; *&t;for the ip device. This is scheduled to&n; *&t;disappear&n; */
DECL|function|ip_ioctl
r_int
id|ip_ioctl
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
macro_line|#if defined(CONFIG_IP_TRANSPARENT_PROXY) &amp;&amp; !defined(CONFIG_IP_ALWAYS_DEFRAG)
DECL|macro|CONFIG_IP_ALWAYS_DEFRAG
mdefine_line|#define CONFIG_IP_ALWAYS_DEFRAG 1
macro_line|#endif
multiline_comment|/*&n; *&t;0 - deliver&n; *&t;1 - block&n; */
DECL|function|icmp_filter
r_static
id|__inline__
r_int
id|icmp_filter
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|type
suffix:semicolon
id|type
op_assign
id|skb-&gt;h.icmph-&gt;type
suffix:semicolon
r_if
c_cond
(paren
id|type
OL
l_int|32
)paren
r_return
id|test_bit
c_func
(paren
id|type
comma
op_amp
id|sk-&gt;tp_pinfo.tp_raw4.filter
)paren
suffix:semicolon
multiline_comment|/* Do not block unknown ICMP types */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Process Router Attention IP option&n; */
DECL|function|ip_call_ra_chain
r_int
id|ip_call_ra_chain
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|ip_ra_chain
op_star
id|ra
suffix:semicolon
id|u8
id|protocol
op_assign
id|skb-&gt;nh.iph-&gt;protocol
suffix:semicolon
r_struct
id|sock
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|ra
op_assign
id|ip_ra_chain
suffix:semicolon
id|ra
suffix:semicolon
id|ra
op_assign
id|ra-&gt;next
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|ra-&gt;sk
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_logical_and
id|sk-&gt;num
op_eq
id|protocol
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;nh.iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_MF
op_or
id|IP_OFFSET
)paren
)paren
(brace
id|skb
op_assign
id|ip_defrag
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|last
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb2
)paren
id|raw_rcv
c_func
(paren
id|last
comma
id|skb2
)paren
suffix:semicolon
)brace
id|last
op_assign
id|sk
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|last
)paren
(brace
id|raw_rcv
c_func
(paren
id|last
comma
id|skb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Deliver IP Packets to the higher protocol layers.&n; */
DECL|function|ip_local_deliver
r_int
id|ip_local_deliver
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
r_struct
id|inet_protocol
op_star
id|ipprot
suffix:semicolon
r_struct
id|sock
op_star
id|raw_sk
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
id|hash
suffix:semicolon
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
macro_line|#ifndef CONFIG_IP_ALWAYS_DEFRAG
multiline_comment|/*&n;&t; *&t;Reassemble IP fragments.&n;&t; */
r_if
c_cond
(paren
id|iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_MF
op_or
id|IP_OFFSET
)paren
)paren
(brace
id|skb
op_assign
id|ip_defrag
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
l_int|0
suffix:semicolon
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_IP_MASQUERADE
multiline_comment|/*&n;&t; * Do we need to de-masquerade this packet?&n;&t; */
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Some masq modules can re-inject packets if&n;&t;&t; *&t;bad configured.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|IPCB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_amp
id|IPSKB_MASQUERADED
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ip_input(): demasq recursion detected. Check masq modules configuration&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ret
op_assign
id|ip_fw_demasquerade
c_func
(paren
op_amp
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
)paren
(brace
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
id|IPCB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_or_assign
id|IPSKB_MASQUERADED
suffix:semicolon
id|dst_release
c_func
(paren
id|skb-&gt;dst
)paren
suffix:semicolon
id|skb-&gt;dst
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ip_route_input
c_func
(paren
id|skb
comma
id|iph-&gt;daddr
comma
id|iph-&gt;saddr
comma
id|iph-&gt;tos
comma
id|skb-&gt;dev
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|skb-&gt;dst
op_member_access_from_pointer
id|input
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Point into the IP datagram, just past the header.&n;&t; */
id|skb-&gt;h.raw
op_assign
id|skb-&gt;nh.raw
op_plus
id|iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Deliver to raw sockets. This is fun as to avoid copies we want to make no &n;&t; *&t;surplus copies.&n;&t; *&n;&t; *&t;RFC 1122: SHOULD pass TOS value up to the transport layer.&n;&t; *&t;-&gt; It does. And not only TOS, but all IP header.&n;&t; */
multiline_comment|/* Note: See raw.c and net/raw.h, RAWV4_HTABLE_SIZE==MAX_INET_PROTOS */
id|hash
op_assign
id|iph-&gt;protocol
op_amp
(paren
id|MAX_INET_PROTOS
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* &n;&t; *&t;If there maybe a raw socket we must check - if not we don&squot;t care less &n;&t; */
r_if
c_cond
(paren
(paren
id|raw_sk
op_assign
id|raw_v4_htable
(braket
id|hash
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|sock
op_star
id|sknext
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb1
suffix:semicolon
id|raw_sk
op_assign
id|raw_v4_lookup
c_func
(paren
id|raw_sk
comma
id|iph-&gt;protocol
comma
id|iph-&gt;saddr
comma
id|iph-&gt;daddr
comma
id|skb-&gt;dev-&gt;ifindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raw_sk
)paren
(brace
multiline_comment|/* Any raw sockets */
r_do
(brace
multiline_comment|/* Find the next */
id|sknext
op_assign
id|raw_v4_lookup
c_func
(paren
id|raw_sk-&gt;next
comma
id|iph-&gt;protocol
comma
id|iph-&gt;saddr
comma
id|iph-&gt;daddr
comma
id|skb-&gt;dev-&gt;ifindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iph-&gt;protocol
op_ne
id|IPPROTO_ICMP
op_logical_or
op_logical_neg
id|icmp_filter
c_func
(paren
id|raw_sk
comma
id|skb
)paren
)paren
(brace
r_if
c_cond
(paren
id|sknext
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|skb1
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb1
)paren
(brace
id|raw_rcv
c_func
(paren
id|raw_sk
comma
id|skb1
)paren
suffix:semicolon
)brace
)brace
id|raw_sk
op_assign
id|sknext
suffix:semicolon
)brace
r_while
c_loop
(paren
id|raw_sk
op_ne
l_int|NULL
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/*&t;Here either raw_sk is the last raw socket, or NULL if&n;&t;&t;&t; *&t;none.  We deliver to the last raw socket AFTER the&n;&t;&t;&t; *&t;protocol checks as it avoids a surplus copy.&n;&t;&t;&t; */
)brace
)brace
multiline_comment|/*&n;&t; *&t;skb-&gt;h.raw now points at the protocol beyond the IP header.&n;&t; */
r_for
c_loop
(paren
id|ipprot
op_assign
(paren
r_struct
id|inet_protocol
op_star
)paren
id|inet_protos
(braket
id|hash
)braket
suffix:semicolon
id|ipprot
op_ne
l_int|NULL
suffix:semicolon
id|ipprot
op_assign
(paren
r_struct
id|inet_protocol
op_star
)paren
id|ipprot-&gt;next
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_if
c_cond
(paren
id|ipprot-&gt;protocol
op_ne
id|iph-&gt;protocol
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * &t;See if we need to make a copy of it.  This will&n;&t;&t; * &t;only be set if more than one protocol wants it.&n;&t;&t; * &t;and then not for the last one. If there is a pending&n;&t;&t; *&t;raw delivery wait for that&n;&t;&t; */
r_if
c_cond
(paren
id|ipprot-&gt;copy
op_logical_or
id|raw_sk
)paren
(brace
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb2
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
)brace
r_else
(brace
id|skb2
op_assign
id|skb
suffix:semicolon
)brace
id|flag
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Pass on the datagram to each protocol that wants it,&n;&t;&t; *&t;based on the datagram protocol.  We should really&n;&t;&t; *&t;check the protocol handler&squot;s return values here...&n;&t;&t; */
id|ipprot
op_member_access_from_pointer
id|handler
c_func
(paren
id|skb2
comma
id|ntohs
c_func
(paren
id|iph-&gt;tot_len
)paren
op_minus
(paren
id|iph-&gt;ihl
op_star
l_int|4
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;All protocols checked.&n;&t; *&t;If this packet was a broadcast, we may *not* reply to it, since that&n;&t; *&t;causes (proven, grin) ARP storms and a leakage of memory (i.e. all&n;&t; *&t;ICMP reply messages get queued up for transmission...)&n;&t; */
r_if
c_cond
(paren
id|raw_sk
op_ne
l_int|NULL
)paren
multiline_comment|/* Shift to last raw user */
(brace
id|raw_rcv
c_func
(paren
id|raw_sk
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
multiline_comment|/* Free and report errors */
(brace
id|icmp_send
c_func
(paren
id|skb
comma
id|ICMP_DEST_UNREACH
comma
id|ICMP_PROT_UNREACH
comma
l_int|0
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Main IP Receive routine.&n; */
DECL|function|ip_rcv
r_int
id|ip_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
macro_line|#ifdef&t;CONFIG_FIREWALL
r_int
id|fwres
suffix:semicolon
id|u16
id|rport
suffix:semicolon
macro_line|#endif /* CONFIG_FIREWALL */
multiline_comment|/*&n;&t; * &t;When the interface is in promisc. mode, drop all the crap&n;&t; * &t;that it receives, do not try to analyse it.&n;&t; */
r_if
c_cond
(paren
id|skb-&gt;pkt_type
op_eq
id|PACKET_OTHERHOST
)paren
r_goto
id|drop
suffix:semicolon
id|ip_statistics.IpInReceives
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; *&t;RFC1122: 3.1.2.2 MUST silently discard any IP frame that fails the checksum.&n;&t; *&n;&t; *&t;Is the datagram acceptable?&n;&t; *&n;&t; *&t;1.&t;Length at least the size of an ip header&n;&t; *&t;2.&t;Version of 4&n;&t; *&t;3.&t;Checksums correctly. [Speed optimisation for later, skip loopback checksums]&n;&t; *&t;4.&t;Doesn&squot;t have a bogus length&n;&t; */
r_if
c_cond
(paren
id|skb-&gt;len
OL
r_sizeof
(paren
r_struct
id|iphdr
)paren
)paren
r_goto
id|inhdr_error
suffix:semicolon
r_if
c_cond
(paren
id|iph-&gt;ihl
OL
l_int|5
op_logical_or
id|iph-&gt;version
op_ne
l_int|4
op_logical_or
id|ip_fast_csum
c_func
(paren
(paren
id|u8
op_star
)paren
id|iph
comma
id|iph-&gt;ihl
)paren
op_ne
l_int|0
)paren
r_goto
id|inhdr_error
suffix:semicolon
(brace
id|__u32
id|len
op_assign
id|ntohs
c_func
(paren
id|iph-&gt;tot_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OL
id|len
)paren
r_goto
id|inhdr_error
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Our transport medium may have padded the buffer out. Now we know it&n;&t; *&t;is IP we can trim to the true length of the frame.&n;&t; *&t;Note this now means skb-&gt;len holds ntohs(iph-&gt;tot_len).&n;&t; */
id|__skb_trim
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IP_ALWAYS_DEFRAG
multiline_comment|/* Won&squot;t send ICMP reply, since skb-&gt;dst == NULL. --RR */
r_if
c_cond
(paren
id|iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_MF
op_or
id|IP_OFFSET
)paren
)paren
(brace
id|skb
op_assign
id|ip_defrag
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
l_int|0
suffix:semicolon
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_FIREWALL
multiline_comment|/*&n;&t; *&t;See if the firewall wants to dispose of the packet. &n;&t; *&n;&t; * We can&squot;t do ICMP reply or local delivery before routing,&n;&t; * so we delay those decisions until after route. --RR&n;&t; */
id|fwres
op_assign
id|call_in_firewall
c_func
(paren
id|PF_INET
comma
id|dev
comma
id|iph
comma
op_amp
id|rport
comma
op_amp
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fwres
OL
id|FW_ACCEPT
op_logical_and
id|fwres
op_ne
id|FW_REJECT
)paren
r_goto
id|drop
suffix:semicolon
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
macro_line|#endif /* CONFIG_FIREWALL */
multiline_comment|/*&n;&t; *&t;Initialise the virtual path cache for the packet. It describes&n;&t; *&t;how the packet travels inside Linux networking.&n;&t; */
r_if
c_cond
(paren
id|skb-&gt;dst
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ip_route_input
c_func
(paren
id|skb
comma
id|iph-&gt;daddr
comma
id|iph-&gt;saddr
comma
id|iph-&gt;tos
comma
id|dev
)paren
)paren
r_goto
id|drop
suffix:semicolon
macro_line|#ifdef CONFIG_CPU_IS_SLOW
r_if
c_cond
(paren
id|net_cpu_congestion
OG
l_int|10
op_logical_and
op_logical_neg
(paren
id|iph-&gt;tos
op_amp
id|IPTOS_RELIABILITY
)paren
op_logical_and
id|IPTOS_PREC
c_func
(paren
id|iph-&gt;tos
)paren
OL
id|IPTOS_PREC_INTERNETCONTROL
)paren
(brace
r_goto
id|drop
suffix:semicolon
)brace
macro_line|#endif
)brace
macro_line|#ifdef CONFIG_NET_CLS_ROUTE
r_if
c_cond
(paren
id|skb-&gt;dst-&gt;tclassid
)paren
(brace
id|u32
id|idx
op_assign
id|skb-&gt;dst-&gt;tclassid
suffix:semicolon
id|ip_rt_acct
(braket
id|idx
op_amp
l_int|0xFF
)braket
dot
id|o_packets
op_increment
suffix:semicolon
id|ip_rt_acct
(braket
id|idx
op_amp
l_int|0xFF
)braket
dot
id|o_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|ip_rt_acct
(braket
(paren
id|idx
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
)braket
dot
id|i_packets
op_increment
suffix:semicolon
id|ip_rt_acct
(braket
(paren
id|idx
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
)braket
dot
id|i_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|iph-&gt;ihl
OG
l_int|5
)paren
(brace
r_struct
id|ip_options
op_star
id|opt
suffix:semicolon
multiline_comment|/* It looks as overkill, because not all&n;&t;&t;   IP options require packet mangling.&n;&t;&t;   But it is the easiest for now, especially taking&n;&t;&t;   into account that combination of IP options&n;&t;&t;   and running sniffer is extremely rare condition.&n;&t;&t;                                      --ANK (980813)&n;&t;&t;*/
id|skb
op_assign
id|skb_cow
c_func
(paren
id|skb
comma
id|skb_headroom
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
id|skb-&gt;ip_summed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ip_options_compile
c_func
(paren
l_int|NULL
comma
id|skb
)paren
)paren
r_goto
id|inhdr_error
suffix:semicolon
id|opt
op_assign
op_amp
(paren
id|IPCB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|opt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;srr
)paren
(brace
r_struct
id|in_device
op_star
id|in_dev
op_assign
id|dev-&gt;ip_ptr
suffix:semicolon
r_if
c_cond
(paren
id|in_dev
op_logical_and
op_logical_neg
id|IN_DEV_SOURCE_ROUTE
c_func
(paren
id|in_dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|IN_DEV_LOG_MARTIANS
c_func
(paren
id|in_dev
)paren
op_logical_and
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;source route option %d.%d.%d.%d -&gt; %d.%d.%d.%d&bslash;n&quot;
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;saddr
)paren
comma
id|NIPQUAD
c_func
(paren
id|iph-&gt;daddr
)paren
)paren
suffix:semicolon
r_goto
id|drop
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip_options_rcv_srr
c_func
(paren
id|skb
)paren
)paren
r_goto
id|drop
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_FIREWALL
macro_line|#ifdef&t;CONFIG_IP_TRANSPARENT_PROXY
r_if
c_cond
(paren
id|fwres
op_eq
id|FW_REDIRECT
op_logical_and
(paren
id|IPCB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|redirport
op_assign
id|rport
)paren
op_ne
l_int|0
)paren
r_return
id|ip_local_deliver
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IP_TRANSPARENT_PROXY */
r_if
c_cond
(paren
id|fwres
op_eq
id|FW_REJECT
)paren
(brace
id|icmp_send
c_func
(paren
id|skb
comma
id|ICMP_DEST_UNREACH
comma
id|ICMP_PORT_UNREACH
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|drop
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_FIREWALL */
r_return
id|skb-&gt;dst
op_member_access_from_pointer
id|input
c_func
(paren
id|skb
)paren
suffix:semicolon
id|inhdr_error
suffix:colon
id|ip_statistics.IpInHdrErrors
op_increment
suffix:semicolon
id|drop
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
