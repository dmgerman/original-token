multiline_comment|/*&n; *&t;&t;IP_MASQ_MARKFW masquerading module&n; *&n; *&t;Does (reverse-masq) forwarding based on skb-&gt;fwmark value&n; *&n; *&t;$Id: ip_masq_mfw.c,v 1.3 1999/01/26 05:33:47 davem Exp $&n; *&n; * Author:&t;Juan Jose Ciarlante   &lt;jjciarla@raiz.uncu.edu.ar&gt;&n; *&t;&t;  based on Steven Clarke&squot;s portfw&n; *&n; * Fixes:&t;&n; *&t;JuanJo Ciarlante:&t;added u-space sched support&n; *&t;JuanJo Ciarlante:&t;if rport==0, use packet dest port *grin*&n; *&t;JuanJo Ciarlante:&t;fixed tcp syn&amp;&amp;!ack creation&n; *&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;linux/ip_fw.h&gt;
macro_line|#include &lt;linux/ip_masq.h&gt;
macro_line|#include &lt;net/ip_masq.h&gt;
macro_line|#include &lt;net/ip_masq_mod.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/softirq.h&gt;
macro_line|#include &lt;asm/spinlock.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
DECL|variable|mmod_self
r_static
r_struct
id|ip_masq_mod
op_star
id|mmod_self
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef CONFIG_IP_MASQ_DEBUG
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *  Lists structure:&n; *&t;There is a &quot;main&quot; linked list with entries hashed&n; *&t;by fwmark value (struct ip_masq_mfw, the &quot;m-entries&quot;).&n; *&n; *&t;Each of this m-entry holds a double linked list&n; *&t;of &quot;forward-to&quot; hosts (struct ip_masq_mfw_host, the &quot;m.host&quot;),&n; *&t;the round-robin scheduling takes place by rotating m.host entries&n; *&t;&quot;inside&quot; its m-entry.&n; */
multiline_comment|/*&n; *&t;Each forwarded host (addr:port) is stored here&n; */
DECL|struct|ip_masq_mfw_host
r_struct
id|ip_masq_mfw_host
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|addr
id|__u32
id|addr
suffix:semicolon
DECL|member|port
id|__u16
id|port
suffix:semicolon
DECL|member|pad0
id|__u16
id|pad0
suffix:semicolon
DECL|member|fwmark
id|__u32
id|fwmark
suffix:semicolon
DECL|member|pref
r_int
id|pref
suffix:semicolon
DECL|member|pref_cnt
id|atomic_t
id|pref_cnt
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|IP_MASQ_MFW_HSIZE
mdefine_line|#define IP_MASQ_MFW_HSIZE&t;16
multiline_comment|/*&n; *&t;This entries are indexed by fwmark, &n; *&t;they hold a list of forwarded addr:port&n; */
DECL|struct|ip_masq_mfw
r_struct
id|ip_masq_mfw
(brace
DECL|member|next
r_struct
id|ip_masq_mfw
op_star
id|next
suffix:semicolon
multiline_comment|/* linked list */
DECL|member|fwmark
id|__u32
id|fwmark
suffix:semicolon
multiline_comment|/* key: firewall mark */
DECL|member|hosts
r_struct
id|list_head
id|hosts
suffix:semicolon
multiline_comment|/* list of forward-to hosts */
DECL|member|nhosts
id|atomic_t
id|nhosts
suffix:semicolon
multiline_comment|/* number of &quot;&quot; */
macro_line|#ifdef __SMP__
DECL|member|lock
id|rwlock_t
id|lock
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|mfw_sema
)paren
suffix:semicolon
macro_line|#ifdef __SMP__
DECL|variable|mfw_lock
r_static
id|rwlock_t
id|mfw_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
macro_line|#endif
DECL|variable|ip_masq_mfw_table
r_static
r_struct
id|ip_masq_mfw
op_star
id|ip_masq_mfw_table
(braket
id|IP_MASQ_MFW_HSIZE
)braket
suffix:semicolon
DECL|function|mfw_hash_val
r_static
id|__inline__
r_int
id|mfw_hash_val
c_func
(paren
r_int
id|fwmark
)paren
(brace
r_return
id|fwmark
op_amp
l_int|0x0f
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get m-entry by &quot;fwmark&quot;&n; *&t;Caller must lock tables.&n; */
DECL|function|__mfw_get
r_static
r_struct
id|ip_masq_mfw
op_star
id|__mfw_get
c_func
(paren
r_int
id|fwmark
)paren
(brace
r_struct
id|ip_masq_mfw
op_star
id|mfw
suffix:semicolon
r_int
id|hash
op_assign
id|mfw_hash_val
c_func
(paren
id|fwmark
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mfw
op_assign
id|ip_masq_mfw_table
(braket
id|hash
)braket
suffix:semicolon
id|mfw
suffix:semicolon
id|mfw
op_assign
id|mfw-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|mfw-&gt;fwmark
op_eq
id|fwmark
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
id|mfw
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Links m-entry.&n; *&t;Caller should have checked if already present for same fwmark&n; *&n; *&t;Caller must lock tables.&n; */
DECL|function|__mfw_add
r_static
r_int
id|__mfw_add
c_func
(paren
r_struct
id|ip_masq_mfw
op_star
id|mfw
)paren
(brace
r_int
id|fwmark
op_assign
id|mfw-&gt;fwmark
suffix:semicolon
r_int
id|hash
op_assign
id|mfw_hash_val
c_func
(paren
id|fwmark
)paren
suffix:semicolon
id|mfw-&gt;next
op_assign
id|ip_masq_mfw_table
(braket
id|hash
)braket
suffix:semicolon
id|ip_masq_mfw_table
(braket
id|hash
)braket
op_assign
id|mfw
suffix:semicolon
id|ip_masq_mod_inc_nent
c_func
(paren
id|mmod_self
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Creates a m-entry (doesn&squot;t link it)&n; */
DECL|function|mfw_new
r_static
r_struct
id|ip_masq_mfw
op_star
id|mfw_new
c_func
(paren
r_int
id|fwmark
)paren
(brace
r_struct
id|ip_masq_mfw
op_star
id|mfw
suffix:semicolon
id|mfw
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|mfw
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfw
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|memset
c_func
(paren
id|mfw
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|mfw
)paren
)paren
suffix:semicolon
id|mfw-&gt;fwmark
op_assign
id|fwmark
suffix:semicolon
macro_line|#ifdef __SMP__
id|mfw-&gt;lock
op_assign
(paren
id|rwlock_t
)paren
id|RW_LOCK_UNLOCKED
suffix:semicolon
macro_line|#endif
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|mfw-&gt;hosts
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|mfw
suffix:semicolon
)brace
DECL|function|mfw_host_to_user
r_static
r_void
id|mfw_host_to_user
c_func
(paren
r_struct
id|ip_masq_mfw_host
op_star
id|h
comma
r_struct
id|ip_mfw_user
op_star
id|mu
)paren
(brace
id|mu-&gt;raddr
op_assign
id|h-&gt;addr
suffix:semicolon
id|mu-&gt;rport
op_assign
id|h-&gt;port
suffix:semicolon
id|mu-&gt;fwmark
op_assign
id|h-&gt;fwmark
suffix:semicolon
id|mu-&gt;pref
op_assign
id|h-&gt;pref
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Creates a m.host (doesn&squot;t link it in a m-entry)&n; */
DECL|function|mfw_host_new
r_static
r_struct
id|ip_masq_mfw_host
op_star
id|mfw_host_new
c_func
(paren
r_struct
id|ip_mfw_user
op_star
id|mu
)paren
(brace
r_struct
id|ip_masq_mfw_host
op_star
id|mfw_host
suffix:semicolon
id|mfw_host
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|mfw_host
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mfw_host
)paren
r_return
l_int|NULL
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|memset
c_func
(paren
id|mfw_host
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|mfw_host
)paren
)paren
suffix:semicolon
id|mfw_host-&gt;addr
op_assign
id|mu-&gt;raddr
suffix:semicolon
id|mfw_host-&gt;port
op_assign
id|mu-&gt;rport
suffix:semicolon
id|mfw_host-&gt;fwmark
op_assign
id|mu-&gt;fwmark
suffix:semicolon
id|mfw_host-&gt;pref
op_assign
id|mu-&gt;pref
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|mfw_host-&gt;pref_cnt
comma
id|mu-&gt;pref
)paren
suffix:semicolon
r_return
id|mfw_host
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Create AND link m.host to m-entry.&n; *&t;It locks m.lock.&n; */
DECL|function|mfw_addhost
r_static
r_int
id|mfw_addhost
c_func
(paren
r_struct
id|ip_masq_mfw
op_star
id|mfw
comma
r_struct
id|ip_mfw_user
op_star
id|mu
comma
r_int
id|attail
)paren
(brace
r_struct
id|ip_masq_mfw_host
op_star
id|mfw_host
suffix:semicolon
id|mfw_host
op_assign
id|mfw_host_new
c_func
(paren
id|mu
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mfw_host
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|mfw-&gt;lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|mfw_host-&gt;list
comma
id|attail
ques
c_cond
id|mfw-&gt;hosts.prev
suffix:colon
op_amp
id|mfw-&gt;hosts
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|mfw-&gt;nhosts
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|mfw-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Unlink AND destroy m.host(s) from m-entry.&n; *&t;Wildcard (nul host or addr) ok.&n; *&t;It uses m.lock.&n; */
DECL|function|mfw_delhost
r_static
r_int
id|mfw_delhost
c_func
(paren
r_struct
id|ip_masq_mfw
op_star
id|mfw
comma
r_struct
id|ip_mfw_user
op_star
id|mu
)paren
(brace
r_struct
id|list_head
op_star
id|l
comma
op_star
id|e
suffix:semicolon
r_struct
id|ip_masq_mfw_host
op_star
id|h
suffix:semicolon
r_int
id|n_del
op_assign
l_int|0
suffix:semicolon
id|l
op_assign
op_amp
id|mfw-&gt;hosts
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|mfw-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|l-&gt;next
suffix:semicolon
id|e
op_ne
id|l
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
(brace
id|h
op_assign
id|list_entry
c_func
(paren
id|e
comma
r_struct
id|ip_masq_mfw_host
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|mu-&gt;raddr
op_logical_or
id|h-&gt;addr
op_eq
id|mu-&gt;raddr
)paren
op_logical_and
(paren
op_logical_neg
id|mu-&gt;rport
op_logical_or
id|h-&gt;port
op_eq
id|mu-&gt;rport
)paren
)paren
(brace
multiline_comment|/* HIT */
id|atomic_dec
c_func
(paren
op_amp
id|mfw-&gt;nhosts
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|h-&gt;list
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|h
comma
r_sizeof
(paren
op_star
id|h
)paren
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|n_del
op_increment
suffix:semicolon
)brace
)brace
id|write_unlock_bh
c_func
(paren
op_amp
id|mfw-&gt;lock
)paren
suffix:semicolon
r_return
id|n_del
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ESRCH
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Changes m.host parameters&n; *&t;Wildcards ok&n; *&n; *&t;Caller must lock tables.&n; */
DECL|function|__mfw_edithost
r_static
r_int
id|__mfw_edithost
c_func
(paren
r_struct
id|ip_masq_mfw
op_star
id|mfw
comma
r_struct
id|ip_mfw_user
op_star
id|mu
)paren
(brace
r_struct
id|list_head
op_star
id|l
comma
op_star
id|e
suffix:semicolon
r_struct
id|ip_masq_mfw_host
op_star
id|h
suffix:semicolon
r_int
id|n_edit
op_assign
l_int|0
suffix:semicolon
id|l
op_assign
op_amp
id|mfw-&gt;hosts
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|l-&gt;next
suffix:semicolon
id|e
op_ne
id|l
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
(brace
id|h
op_assign
id|list_entry
c_func
(paren
id|e
comma
r_struct
id|ip_masq_mfw_host
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|mu-&gt;raddr
op_logical_or
id|h-&gt;addr
op_eq
id|mu-&gt;raddr
)paren
op_logical_and
(paren
op_logical_neg
id|mu-&gt;rport
op_logical_or
id|h-&gt;port
op_eq
id|mu-&gt;rport
)paren
)paren
(brace
multiline_comment|/* HIT */
id|h-&gt;pref
op_assign
id|mu-&gt;pref
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|h-&gt;pref_cnt
comma
id|mu-&gt;pref
)paren
suffix:semicolon
id|n_edit
op_increment
suffix:semicolon
)brace
)brace
r_return
id|n_edit
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ESRCH
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Destroys m-entry.&n; *&t;Caller must have checked that it doesn&squot;t hold any m.host(s)&n; */
DECL|function|mfw_destroy
r_static
r_void
id|mfw_destroy
c_func
(paren
r_struct
id|ip_masq_mfw
op_star
id|mfw
)paren
(brace
id|kfree_s
c_func
(paren
id|mfw
comma
r_sizeof
(paren
op_star
id|mfw
)paren
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Unlink m-entry.&n; *&n; *&t;Caller must lock tables.&n; */
DECL|function|__mfw_del
r_static
r_int
id|__mfw_del
c_func
(paren
r_struct
id|ip_masq_mfw
op_star
id|mfw
)paren
(brace
r_struct
id|ip_masq_mfw
op_star
op_star
id|mfw_p
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|mfw_p
op_assign
op_amp
id|ip_masq_mfw_table
(braket
id|mfw_hash_val
c_func
(paren
id|mfw-&gt;fwmark
)paren
)braket
suffix:semicolon
op_star
id|mfw_p
suffix:semicolon
id|mfw_p
op_assign
op_amp
(paren
(paren
op_star
id|mfw_p
)paren
op_member_access_from_pointer
id|next
)paren
)paren
(brace
r_if
c_cond
(paren
id|mfw
op_eq
(paren
op_star
id|mfw_p
)paren
)paren
(brace
op_star
id|mfw_p
op_assign
id|mfw-&gt;next
suffix:semicolon
id|ip_masq_mod_dec_nent
c_func
(paren
id|mmod_self
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Crude m.host scheduler&n; *&t;This interface could be exported to allow playing with &n; *&t;other sched policies.&n; *&n; *&t;Caller must lock m-entry.&n; */
DECL|function|__mfw_sched
r_static
r_struct
id|ip_masq_mfw_host
op_star
id|__mfw_sched
c_func
(paren
r_struct
id|ip_masq_mfw
op_star
id|mfw
comma
r_int
id|force
)paren
(brace
r_struct
id|ip_masq_mfw_host
op_star
id|h
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mfw-&gt;nhosts
)paren
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Here resides actual sched policy: &n;&t; *&t;When pref_cnt touches 0, entry gets shifted to tail and&n;&t; *&t;its pref_cnt reloaded from h-&gt;pref (actual value&n;&t; *&t;passed from u-space).&n;&t; *&n;&t; *&t;Exception is pref==0: avoid scheduling.&n;&t; */
id|h
op_assign
id|list_entry
c_func
(paren
id|mfw-&gt;hosts.next
comma
r_struct
id|ip_masq_mfw_host
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mfw-&gt;nhosts
)paren
op_le
l_int|1
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|h-&gt;pref
op_logical_and
id|atomic_dec_and_test
c_func
(paren
op_amp
id|h-&gt;pref_cnt
)paren
)paren
op_logical_or
id|force
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|h-&gt;pref_cnt
comma
id|h-&gt;pref
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|h-&gt;list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|h-&gt;list
comma
id|mfw-&gt;hosts.prev
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|h
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Main lookup routine.&n; *&t;HITs fwmark and schedules m.host entries if required&n; */
DECL|function|mfw_lookup
r_static
r_struct
id|ip_masq_mfw_host
op_star
id|mfw_lookup
c_func
(paren
r_int
id|fwmark
)paren
(brace
r_struct
id|ip_masq_mfw
op_star
id|mfw
suffix:semicolon
r_struct
id|ip_masq_mfw_host
op_star
id|h
op_assign
l_int|NULL
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
id|mfw
op_assign
id|__mfw_get
c_func
(paren
id|fwmark
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfw
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|mfw-&gt;lock
)paren
suffix:semicolon
id|h
op_assign
id|__mfw_sched
c_func
(paren
id|mfw
comma
l_int|0
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|mfw-&gt;lock
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
r_return
id|h
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|mfw_procinfo
r_static
r_int
id|mfw_procinfo
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|dummy
)paren
(brace
r_struct
id|ip_masq_mfw
op_star
id|mfw
suffix:semicolon
r_struct
id|ip_masq_mfw_host
op_star
id|h
suffix:semicolon
r_struct
id|list_head
op_star
id|l
comma
op_star
id|e
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
comma
id|begin
suffix:semicolon
r_char
id|temp
(braket
l_int|129
)braket
suffix:semicolon
r_int
id|idx
op_assign
l_int|0
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|IP_MASQ_DEBUG
c_func
(paren
l_int|1
op_minus
id|debug
comma
l_string|&quot;Entered mfw_info&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
l_int|64
)paren
(brace
id|sprintf
c_func
(paren
id|temp
comma
l_string|&quot;FwMark &gt; RAddr    RPort PrCnt  Pref&quot;
)paren
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%-63s&bslash;n&quot;
comma
id|temp
)paren
suffix:semicolon
)brace
id|pos
op_assign
l_int|64
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|IP_MASQ_MFW_HSIZE
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mfw
op_assign
id|ip_masq_mfw_table
(braket
id|idx
)braket
suffix:semicolon
id|mfw
suffix:semicolon
id|mfw
op_assign
id|mfw-&gt;next
)paren
(brace
id|read_lock_bh
c_func
(paren
op_amp
id|mfw-&gt;lock
)paren
suffix:semicolon
id|l
op_assign
op_amp
id|mfw-&gt;hosts
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|l-&gt;next
suffix:semicolon
id|l
op_ne
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
(brace
id|h
op_assign
id|list_entry
c_func
(paren
id|e
comma
r_struct
id|ip_masq_mfw_host
comma
id|list
)paren
suffix:semicolon
id|pos
op_add_assign
l_int|64
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_le
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|temp
comma
l_string|&quot;0x%x &gt; %08lX %5u %5d %5d&quot;
comma
id|h-&gt;fwmark
comma
id|ntohl
c_func
(paren
id|h-&gt;addr
)paren
comma
id|ntohs
c_func
(paren
id|h-&gt;port
)paren
comma
id|atomic_read
c_func
(paren
op_amp
id|h-&gt;pref_cnt
)paren
comma
id|h-&gt;pref
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%-63s&bslash;n&quot;
comma
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|length
)paren
(brace
id|read_unlock_bh
c_func
(paren
op_amp
id|mfw-&gt;lock
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|mfw-&gt;lock
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
)brace
id|done
suffix:colon
r_if
c_cond
(paren
id|len
)paren
(brace
id|begin
op_assign
id|len
op_minus
(paren
id|pos
op_minus
id|offset
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|begin
suffix:semicolon
id|len
op_sub_assign
id|begin
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|variable|mfw_proc_entry
r_static
r_struct
id|proc_dir_entry
id|mfw_proc_entry
op_assign
(brace
multiline_comment|/* &t;&t;0, 0, NULL&quot;, */
l_int|0
comma
l_int|3
comma
l_string|&quot;mfw&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_amp
id|proc_net_inode_operations
comma
id|mfw_procinfo
)brace
suffix:semicolon
DECL|macro|proc_ent
mdefine_line|#define proc_ent &amp;mfw_proc_entry
macro_line|#else /* !CONFIG_PROC_FS */
DECL|macro|proc_ent
mdefine_line|#define proc_ent NULL
macro_line|#endif
DECL|function|mfw_flush
r_static
r_void
id|mfw_flush
c_func
(paren
r_void
)paren
(brace
r_struct
id|ip_masq_mfw
op_star
id|mfw
comma
op_star
id|local_table
(braket
id|IP_MASQ_MFW_HSIZE
)braket
suffix:semicolon
r_struct
id|ip_masq_mfw_host
op_star
id|h
suffix:semicolon
r_struct
id|ip_masq_mfw
op_star
id|mfw_next
suffix:semicolon
r_int
id|idx
suffix:semicolon
r_struct
id|list_head
op_star
id|l
comma
op_star
id|e
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|local_table
comma
id|ip_masq_mfw_table
comma
r_sizeof
id|ip_masq_mfw_table
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ip_masq_mfw_table
comma
l_int|0
comma
r_sizeof
id|ip_masq_mfw_table
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;For every hash table row ...&n;&t; */
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|IP_MASQ_MFW_HSIZE
suffix:semicolon
id|idx
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;For every m-entry in row ...&n;&t;&t; */
r_for
c_loop
(paren
id|mfw
op_assign
id|local_table
(braket
id|idx
)braket
suffix:semicolon
id|mfw
suffix:semicolon
id|mfw
op_assign
id|mfw_next
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;For every m.host in m-entry ...&n;&t;&t;&t; */
id|l
op_assign
op_amp
id|mfw-&gt;hosts
suffix:semicolon
r_while
c_loop
(paren
(paren
id|e
op_assign
id|l-&gt;next
)paren
op_ne
id|l
)paren
(brace
id|h
op_assign
id|list_entry
c_func
(paren
id|e
comma
r_struct
id|ip_masq_mfw_host
comma
id|list
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|mfw-&gt;nhosts
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|h-&gt;list
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|h
comma
r_sizeof
(paren
op_star
id|h
)paren
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mfw-&gt;nhosts
)paren
)paren
(brace
id|IP_MASQ_ERR
c_func
(paren
l_string|&quot;mfw_flush(): after flushing row nhosts=%d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|mfw-&gt;nhosts
)paren
)paren
suffix:semicolon
)brace
id|mfw_next
op_assign
id|mfw-&gt;next
suffix:semicolon
id|kfree_s
c_func
(paren
id|mfw
comma
r_sizeof
(paren
op_star
id|mfw
)paren
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|ip_masq_mod_dec_nent
c_func
(paren
id|mmod_self
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; *&t;User space control entry point&n; */
DECL|function|mfw_ctl
r_static
r_int
id|mfw_ctl
c_func
(paren
r_int
id|optname
comma
r_struct
id|ip_masq_ctl
op_star
id|mctl
comma
r_int
id|optlen
)paren
(brace
r_struct
id|ip_mfw_user
op_star
id|mu
op_assign
op_amp
id|mctl-&gt;u.mfw_user
suffix:semicolon
r_struct
id|ip_masq_mfw
op_star
id|mfw
suffix:semicolon
r_int
id|ret
op_assign
id|EINVAL
suffix:semicolon
r_int
id|arglen
op_assign
id|optlen
op_minus
id|IP_MASQ_CTL_BSIZE
suffix:semicolon
r_int
id|cmd
suffix:semicolon
id|IP_MASQ_DEBUG
c_func
(paren
l_int|1
op_minus
id|debug
comma
l_string|&quot;ip_masq_user_ctl(len=%d/%d|%d/%d)&bslash;n&quot;
comma
id|arglen
comma
r_sizeof
(paren
op_star
id|mu
)paren
comma
id|optlen
comma
r_sizeof
(paren
op_star
id|mctl
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;checks ...&n;&t; */
r_if
c_cond
(paren
id|arglen
op_ne
r_sizeof
(paren
op_star
id|mu
)paren
op_logical_and
id|optlen
op_ne
r_sizeof
(paren
op_star
id|mctl
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* &n;&t; *&t;Don&squot;t trust the lusers - plenty of error checking! &n;&t; */
id|cmd
op_assign
id|mctl-&gt;m_cmd
suffix:semicolon
id|IP_MASQ_DEBUG
c_func
(paren
l_int|1
op_minus
id|debug
comma
l_string|&quot;ip_masq_mfw_ctl(cmd=%d, fwmark=%d)&bslash;n&quot;
comma
id|cmd
comma
id|mu-&gt;fwmark
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|IP_MASQ_CMD_NONE
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|IP_MASQ_CMD_FLUSH
suffix:colon
r_break
suffix:semicolon
r_case
id|IP_MASQ_CMD_ADD
suffix:colon
r_case
id|IP_MASQ_CMD_INSERT
suffix:colon
r_case
id|IP_MASQ_CMD_SET
suffix:colon
r_if
c_cond
(paren
id|mu-&gt;fwmark
op_eq
l_int|0
)paren
(brace
id|IP_MASQ_DEBUG
c_func
(paren
l_int|1
op_minus
id|debug
comma
l_string|&quot;invalid fwmark==0&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mu-&gt;pref
OL
l_int|0
)paren
(brace
id|IP_MASQ_DEBUG
c_func
(paren
l_int|1
op_minus
id|debug
comma
l_string|&quot;invalid pref==%d&bslash;n&quot;
comma
id|mu-&gt;pref
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|IP_MASQ_CMD_ADD
suffix:colon
r_case
id|IP_MASQ_CMD_INSERT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|mu-&gt;raddr
)paren
(brace
id|IP_MASQ_DEBUG
c_func
(paren
l_int|0
op_minus
id|debug
comma
l_string|&quot;ip_masq_mfw_ctl(ADD): invalid redirect 0x%x:%d&bslash;n&quot;
comma
id|mu-&gt;raddr
comma
id|mu-&gt;rport
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Cannot just use mfw_lock because below&n;&t;&t; *&t;are allocations that can sleep; so&n;&t;&t; *&t;to assure &quot;new entry&quot; atomic creation&n;&t;&t; *&t;I use a semaphore.&n;&t;&t; *&n;&t;&t; */
id|down
c_func
(paren
op_amp
id|mfw_sema
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
id|mfw
op_assign
id|__mfw_get
c_func
(paren
id|mu-&gt;fwmark
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;If first host, create m-entry&n;&t;&t; */
r_if
c_cond
(paren
id|mfw
op_eq
l_int|NULL
)paren
(brace
id|mfw
op_assign
id|mfw_new
c_func
(paren
id|mu-&gt;fwmark
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfw
op_eq
l_int|NULL
)paren
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mfw
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Put m.host in m-entry.&n;&t;&t;&t; */
id|ret
op_assign
id|mfw_addhost
c_func
(paren
id|mfw
comma
id|mu
comma
id|cmd
op_eq
id|IP_MASQ_CMD_ADD
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;If first host, link m-entry to hash table.&n;&t;&t;&t; *&t;Already protected by global lock.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|mfw-&gt;nhosts
)paren
op_eq
l_int|1
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
id|__mfw_add
c_func
(paren
id|mfw
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mfw-&gt;nhosts
)paren
op_eq
l_int|0
)paren
(brace
id|mfw_destroy
c_func
(paren
id|mfw
)paren
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|mfw_sema
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IP_MASQ_CMD_DEL
suffix:colon
id|down
c_func
(paren
op_amp
id|mfw_sema
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
id|mfw
op_assign
id|__mfw_get
c_func
(paren
id|mu-&gt;fwmark
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfw
)paren
(brace
id|ret
op_assign
id|mfw_delhost
c_func
(paren
id|mfw
comma
id|mu
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Last lease will free&n;&t;&t;&t; *&t;XXX check logic XXX&n;&t;&t;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mfw-&gt;nhosts
)paren
op_eq
l_int|0
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
id|__mfw_del
c_func
(paren
id|mfw
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
id|mfw_destroy
c_func
(paren
id|mfw
)paren
suffix:semicolon
)brace
)brace
r_else
id|ret
op_assign
op_minus
id|ESRCH
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mfw_sema
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IP_MASQ_CMD_FLUSH
suffix:colon
id|down
c_func
(paren
op_amp
id|mfw_sema
)paren
suffix:semicolon
id|mfw_flush
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mfw_sema
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IP_MASQ_CMD_SET
suffix:colon
multiline_comment|/*&n;&t;&t; *&t;No need to semaphorize here, main list is not &n;&t;&t; *&t;modified.&n;&t;&t; */
id|read_lock
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
id|mfw
op_assign
id|__mfw_get
c_func
(paren
id|mu-&gt;fwmark
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfw
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|mfw-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mu-&gt;flags
op_amp
id|IP_MASQ_MFW_SCHED
)paren
(brace
r_struct
id|ip_masq_mfw_host
op_star
id|h
suffix:semicolon
r_if
c_cond
(paren
(paren
id|h
op_assign
id|__mfw_sched
c_func
(paren
id|mfw
comma
l_int|1
)paren
)paren
)paren
(brace
id|mfw_host_to_user
c_func
(paren
id|h
comma
id|mu
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|ret
op_assign
id|__mfw_edithost
c_func
(paren
id|mfw
comma
id|mu
)paren
suffix:semicolon
)brace
id|write_unlock_bh
c_func
(paren
op_amp
id|mfw-&gt;lock
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Module stubs called from ip_masq core module&n; */
multiline_comment|/*&n; *&t;Input rule stub, called very early for each incoming packet, &n; *&t;to see if this module has &quot;interest&quot; in packet.&n; */
DECL|function|mfw_in_rule
r_static
r_int
id|mfw_in_rule
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_const
r_struct
id|iphdr
op_star
id|iph
)paren
(brace
r_int
id|val
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
id|val
op_assign
(paren
id|__mfw_get
c_func
(paren
id|skb-&gt;fwmark
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|mfw_lock
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Input-create stub, called to allow &quot;custom&quot; masq creation&n; */
DECL|function|mfw_in_create
r_static
r_struct
id|ip_masq
op_star
id|mfw_in_create
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_const
r_struct
id|iphdr
op_star
id|iph
comma
id|__u32
id|maddr
)paren
(brace
r_union
id|ip_masq_tphdr
id|tph
suffix:semicolon
r_struct
id|ip_masq
op_star
id|ms
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ip_masq_mfw_host
op_star
id|h
op_assign
l_int|NULL
suffix:semicolon
id|tph.raw
op_assign
(paren
r_char
op_star
)paren
id|iph
op_plus
id|iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
r_switch
c_cond
(paren
id|iph-&gt;protocol
)paren
(brace
r_case
id|IPPROTO_TCP
suffix:colon
multiline_comment|/* &t;&n;&t;&t;&t; *&t;Only open TCP tunnel if SYN+!ACK packet&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tph.th-&gt;syn
op_logical_and
id|tph.th-&gt;ack
)paren
r_return
l_int|NULL
suffix:semicolon
r_case
id|IPPROTO_UDP
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* &n;&t; *&t;If no entry exists in the masquerading table&n; &t; * &t;and the port is involved&n;&t; *  &t;in port forwarding, create a new masq entry &n;&t; */
r_if
c_cond
(paren
(paren
id|h
op_assign
id|mfw_lookup
c_func
(paren
id|skb-&gt;fwmark
)paren
)paren
)paren
(brace
id|ms
op_assign
id|ip_masq_new
c_func
(paren
id|iph-&gt;protocol
comma
id|iph-&gt;daddr
comma
id|tph.portp
(braket
l_int|1
)braket
comma
multiline_comment|/* if no redir-port, use packet dest port */
id|h-&gt;addr
comma
id|h-&gt;port
ques
c_cond
id|h-&gt;port
suffix:colon
id|tph.portp
(braket
l_int|1
)braket
comma
id|iph-&gt;saddr
comma
id|tph.portp
(braket
l_int|0
)braket
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ms
op_ne
l_int|NULL
)paren
id|ip_masq_listen
c_func
(paren
id|ms
)paren
suffix:semicolon
)brace
r_return
id|ms
suffix:semicolon
)brace
DECL|macro|mfw_in_update
mdefine_line|#define mfw_in_update&t;NULL
DECL|macro|mfw_out_rule
mdefine_line|#define mfw_out_rule&t;NULL
DECL|macro|mfw_out_create
mdefine_line|#define mfw_out_create&t;NULL
DECL|macro|mfw_out_update
mdefine_line|#define mfw_out_update&t;NULL
DECL|variable|mfw_mod
r_static
r_struct
id|ip_masq_mod
id|mfw_mod
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* next */
l_int|NULL
comma
multiline_comment|/* next_reg */
l_string|&quot;mfw&quot;
comma
multiline_comment|/* name */
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
comma
multiline_comment|/* nent */
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
comma
multiline_comment|/* refcnt */
id|proc_ent
comma
id|mfw_ctl
comma
l_int|NULL
comma
multiline_comment|/* masq_mod_init */
l_int|NULL
comma
multiline_comment|/* masq_mod_done */
id|mfw_in_rule
comma
id|mfw_in_update
comma
id|mfw_in_create
comma
id|mfw_out_rule
comma
id|mfw_out_update
comma
id|mfw_out_create
comma
)brace
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
id|ip_mfw_init
c_func
(paren
r_void
)paren
)paren
(brace
r_return
id|register_ip_masq_mod
(paren
(paren
id|mmod_self
op_assign
op_amp
id|mfw_mod
)paren
)paren
suffix:semicolon
)brace
DECL|function|ip_mfw_done
r_int
id|ip_mfw_done
c_func
(paren
r_void
)paren
(brace
r_return
id|unregister_ip_masq_mod
c_func
(paren
op_amp
id|mfw_mod
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|EXPORT_NO_SYMBOLS
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|ip_mfw_init
c_func
(paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|ip_mfw_done
c_func
(paren
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;can&squot;t remove module&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
