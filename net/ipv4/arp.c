multiline_comment|/* linux/net/inet/arp.c&n; *&n; * Copyright (C) 1994 by Florian  La Roche&n; *&n; * This module implements the Address Resolution Protocol ARP (RFC 826),&n; * which is used to convert IP addresses (or in the future maybe other&n; * high-level addresses into a low-level hardware address (like an Ethernet&n; * address).&n; *&n; * FIXME:&n; *&t;Experiment with better retransmit timers&n; *&t;Clean up the timer deletions&n; *&t;If you create a proxy entry set your interface address to the address&n; *&t;and then delete it, proxies may get out of sync with reality - check this&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; *&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;Removed the ethernet assumptions in Florian&squot;s code&n; *&t;&t;Alan Cox&t;:&t;Fixed some small errors in the ARP logic&n; *&t;&t;Alan Cox&t;:&t;Allow &gt;4K in /proc&n; *&t;&t;Alan Cox&t;:&t;Make ARP add its own protocol entry&n; *&n; *&t;&t;Ross Martin     :       Rewrote arp_rcv() and arp_get_info()&n; *&t;&t;Stephen Henson&t;:&t;Add AX25 support to arp_get_info()&n; *&t;&t;Alan Cox&t;:&t;Drop data when a device is downed.&n; *&t;&t;Alan Cox&t;:&t;Use init_timer().&n; *&t;&t;Alan Cox&t;:&t;Double lock fixes.&n; *&t;&t;Martin Seine&t;:&t;Move the arphdr structure&n; *&t;&t;&t;&t;&t;to if_arp.h for compatibility.&n; *&t;&t;&t;&t;&t;with BSD based programs.&n; *&t;&t;Andrew Tridgell :       Added ARP netmask code and&n; *&t;&t;&t;&t;&t;re-arranged proxy handling.&n; *&t;&t;Alan Cox&t;:&t;Changed to use notifiers.&n; *&t;&t;Niibe Yutaka&t;:&t;Reply for this device or proxies only.&n; *&t;&t;Alan Cox&t;:&t;Don&squot;t proxy across hardware types!&n; *&t;&t;Jonathan Naylor :&t;Added support for NET/ROM.&n; *&t;&t;Mike Shaver     :       RFC1122 checks.&n; */
multiline_comment|/* RFC1122 Status:&n;   2.3.2.1 (ARP Cache Validation):&n;     MUST provide mechanism to flush stale cache entries (OK)&n;     SHOULD be able to configure cache timeout (NOT YET)&n;     MUST throttle ARP retransmits (OK)&n;   2.3.2.2 (ARP Packet Queue):&n;     SHOULD save at least one packet from each &quot;conversation&quot; with an&n;       unresolved IP address.  (OK)&n;   950727 -- MS&n;*/
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/trdevice.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#ifdef CONFIG_AX25
macro_line|#include &lt;net/ax25.h&gt;
macro_line|#ifdef CONFIG_NETROM
macro_line|#include &lt;net/netrom.h&gt;
macro_line|#endif
macro_line|#endif
macro_line|#include &lt;linux/proc_fs.h&gt;
multiline_comment|/*&n; *&t;This structure defines the ARP mapping cache. As long as we make changes&n; *&t;in this structure, we keep interrupts of. But normally we can copy the&n; *&t;hardware address and the device pointer in a local variable and then make&n; *&t;any &quot;long calls&quot; to send a packet out.&n; */
DECL|struct|arp_table
r_struct
id|arp_table
(brace
DECL|member|next
r_struct
id|arp_table
op_star
id|next
suffix:semicolon
multiline_comment|/* Linked entry list &t;&t;*/
DECL|member|last_used
r_int
r_int
id|last_used
suffix:semicolon
multiline_comment|/* For expiry &t;&t;&t;*/
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Control status &t;&t;*/
DECL|member|ip
id|u32
id|ip
suffix:semicolon
multiline_comment|/* ip address of entry &t;&t;*/
DECL|member|mask
id|u32
id|mask
suffix:semicolon
multiline_comment|/* netmask - used for generalised proxy arps (tridge) &t;&t;*/
DECL|member|ha
r_int
r_char
id|ha
(braket
id|MAX_ADDR_LEN
)braket
suffix:semicolon
multiline_comment|/* Hardware address&t;&t;*/
DECL|member|hlen
r_int
r_char
id|hlen
suffix:semicolon
multiline_comment|/* Length of hardware address &t;*/
DECL|member|htype
r_int
r_int
id|htype
suffix:semicolon
multiline_comment|/* Type of hardware in use&t;*/
DECL|member|dev
r_struct
id|device
op_star
id|dev
suffix:semicolon
multiline_comment|/* Device the entry is tied to &t;*/
multiline_comment|/*&n;&t; *&t;The following entries are only used for unresolved hw addresses.&n;&t; */
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* expire timer &t;&t;*/
DECL|member|retries
r_int
id|retries
suffix:semicolon
multiline_comment|/* remaining retries&t; &t;*/
DECL|member|skb
r_struct
id|sk_buff_head
id|skb
suffix:semicolon
multiline_comment|/* list of queued packets &t;*/
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Configurable Parameters (don&squot;t touch unless you know what you are doing&n; */
multiline_comment|/*&n; *&t;If an arp request is send, ARP_RES_TIME is the timeout value until the&n; *&t;next request is send.&n; */
multiline_comment|/* RFC1122: OK.  Throttles ARPing, as per 2.3.2.1. (MUST) */
multiline_comment|/* The recommended minimum timeout is 1 second per destination. */
multiline_comment|/* Is this a per-destination timeout? -- MS [YES AC]*/
DECL|macro|ARP_RES_TIME
mdefine_line|#define ARP_RES_TIME&t;&t;(250*(HZ/10))
multiline_comment|/*&n; *&t;The number of times an arp request is send, until the host is&n; *&t;considered unreachable.&n; */
DECL|macro|ARP_MAX_TRIES
mdefine_line|#define ARP_MAX_TRIES&t;&t;3
multiline_comment|/*&n; *&t;After that time, an unused entry is deleted from the arp table.&n; */
DECL|macro|ARP_TIMEOUT
mdefine_line|#define ARP_TIMEOUT&t;&t;(600*HZ)
multiline_comment|/*&n; *&t;How often is the function &squot;arp_check_retries&squot; called.&n; *&t;An entry is invalidated in the time between ARP_TIMEOUT and&n; *&t;(ARP_TIMEOUT+ARP_CHECK_INTERVAL).&n; */
DECL|macro|ARP_CHECK_INTERVAL
mdefine_line|#define ARP_CHECK_INTERVAL&t;(60 * HZ)
DECL|enum|proxy
r_enum
id|proxy
(brace
DECL|enumerator|PROXY_EXACT
id|PROXY_EXACT
op_assign
l_int|0
comma
DECL|enumerator|PROXY_ANY
id|PROXY_ANY
comma
DECL|enumerator|PROXY_NONE
id|PROXY_NONE
comma
)brace
suffix:semicolon
multiline_comment|/* Forward declarations. */
r_static
r_void
id|arp_check_expire
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_struct
id|arp_table
op_star
id|arp_lookup
c_func
(paren
id|u32
id|paddr
comma
r_enum
id|proxy
id|proxy
)paren
suffix:semicolon
DECL|variable|arp_timer
r_static
r_struct
id|timer_list
id|arp_timer
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
id|ARP_CHECK_INTERVAL
comma
l_int|0L
comma
op_amp
id|arp_check_expire
)brace
suffix:semicolon
multiline_comment|/*&n; * The default arp netmask is just 255.255.255.255 which means it&squot;s&n; * a single machine entry. Only proxy entries can have other netmasks&n; *&n;*/
DECL|macro|DEF_ARP_NETMASK
mdefine_line|#define DEF_ARP_NETMASK (~0)
multiline_comment|/*&n; * &t;The size of the hash table. Must be a power of two.&n; * &t;Maybe we should remove hashing in the future for arp and concentrate&n; * &t;on Patrick Schaaf&squot;s Host-Cache-Lookup...&n; */
DECL|macro|ARP_TABLE_SIZE
mdefine_line|#define ARP_TABLE_SIZE  16
multiline_comment|/* The ugly +1 here is to cater for proxy entries. They are put in their &n;   own list for efficiency of lookup. If you don&squot;t want to find a proxy&n;   entry then don&squot;t look in the last entry, otherwise do &n;*/
DECL|macro|FULL_ARP_TABLE_SIZE
mdefine_line|#define FULL_ARP_TABLE_SIZE (ARP_TABLE_SIZE+1)
DECL|variable|arp_tables
r_struct
id|arp_table
op_star
id|arp_tables
(braket
id|FULL_ARP_TABLE_SIZE
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|arp_cache_stamp
r_int
r_int
id|arp_cache_stamp
suffix:semicolon
multiline_comment|/*&n; *&t;The last bits in the IP address are used for the cache lookup.&n; *&t;A special entry is used for proxy arp entries&n; */
DECL|macro|HASH
mdefine_line|#define HASH(paddr) &t;&t;(htonl(paddr) &amp; (ARP_TABLE_SIZE - 1))
DECL|macro|PROXY_HASH
mdefine_line|#define PROXY_HASH ARP_TABLE_SIZE
multiline_comment|/*&n; *&t;Check if there are too old entries and remove them. If the ATF_PERM&n; *&t;flag is set, they are always left in the arp cache (permanent entry).&n; *&t;Note: Only fully resolved entries, which don&squot;t have any packets in&n; *&t;the queue, can be deleted, since ARP_TIMEOUT is much greater than&n; *&t;ARP_MAX_TRIES*ARP_RES_TIME.&n; */
multiline_comment|/* RFC1122: Looks good.  Prevents stale ARP entries, as per 2.3.2.1. (MUST) */
DECL|function|arp_check_expire
r_static
r_void
id|arp_check_expire
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FULL_ARP_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|arp_table
op_star
op_star
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
op_star
id|pentry
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|now
op_minus
id|entry-&gt;last_used
)paren
OG
id|ARP_TIMEOUT
op_logical_and
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_PERM
)paren
)paren
(brace
op_star
id|pentry
op_assign
id|entry-&gt;next
suffix:semicolon
multiline_comment|/* remove from list */
id|arp_cache_stamp
op_increment
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
multiline_comment|/* Paranoia */
id|kfree_s
c_func
(paren
id|entry
comma
r_sizeof
(paren
r_struct
id|arp_table
)paren
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t have to remove packets in entry-&gt;skb. */
multiline_comment|/* See comments above. */
)brace
r_else
id|pentry
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
multiline_comment|/* go to next entry */
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Set the timer again.&n;&t; */
id|del_timer
c_func
(paren
op_amp
id|arp_timer
)paren
suffix:semicolon
id|arp_timer.expires
op_assign
id|jiffies
op_plus
id|ARP_CHECK_INTERVAL
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|arp_timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Release all linked skb&squot;s and the memory for this entry.&n; */
DECL|function|arp_release_entry
r_static
r_void
id|arp_release_entry
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Release the list of `skb&squot; pointers. */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|skb_device_lock
c_func
(paren
id|skb
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|entry
comma
r_sizeof
(paren
r_struct
id|arp_table
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Purge a device from the ARP queue&n; */
DECL|function|arp_device_event
r_int
id|arp_device_event
c_func
(paren
r_int
r_int
id|event
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|ptr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|event
op_ne
id|NETDEV_DOWN
)paren
(brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;This is a bit OTT - maybe we need some arp semaphores instead.&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FULL_ARP_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|arp_table
op_star
op_star
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
op_star
id|pentry
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;dev
op_eq
id|dev
)paren
(brace
op_star
id|pentry
op_assign
id|entry-&gt;next
suffix:semicolon
multiline_comment|/* remove from list */
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
multiline_comment|/* Paranoia */
id|kfree_s
c_func
(paren
id|entry
comma
r_sizeof
(paren
r_struct
id|arp_table
)paren
)paren
suffix:semicolon
)brace
r_else
id|pentry
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
multiline_comment|/* go to next entry */
)brace
)brace
id|arp_cache_stamp
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Create and send an arp packet. If (dest_hw == NULL), we create a broadcast&n; *&t;message.&n; */
DECL|function|arp_send
r_void
id|arp_send
c_func
(paren
r_int
id|type
comma
r_int
id|ptype
comma
id|u32
id|dest_ip
comma
r_struct
id|device
op_star
id|dev
comma
id|u32
id|src_ip
comma
r_int
r_char
op_star
id|dest_hw
comma
r_int
r_char
op_star
id|src_hw
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|arphdr
op_star
id|arp
suffix:semicolon
r_int
r_char
op_star
id|arp_ptr
suffix:semicolon
multiline_comment|/*&n;&t; *&t;No arp on this interface.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_NOARP
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Allocate a buffer&n;&t; */
id|skb
op_assign
id|alloc_skb
c_func
(paren
r_sizeof
(paren
r_struct
id|arphdr
)paren
op_plus
l_int|2
op_star
(paren
id|dev-&gt;addr_len
op_plus
l_int|4
)paren
op_plus
id|dev-&gt;hard_header_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ARP: no memory to send an arp packet&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
id|arp
op_assign
(paren
r_struct
id|arphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|arphdr
)paren
op_plus
l_int|2
op_star
(paren
id|dev-&gt;addr_len
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fill the device header for the ARP frame&n;&t; */
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|skb
comma
id|dev
comma
id|ptype
comma
id|dest_hw
ques
c_cond
id|dest_hw
suffix:colon
id|dev-&gt;broadcast
comma
id|src_hw
ques
c_cond
id|src_hw
suffix:colon
l_int|NULL
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Fill out the arp protocol part. */
id|arp-&gt;ar_hrd
op_assign
id|htons
c_func
(paren
id|dev-&gt;type
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_AX25
macro_line|#ifdef CONFIG_NETROM
id|arp-&gt;ar_pro
op_assign
(paren
id|dev-&gt;type
op_eq
id|ARPHRD_AX25
op_logical_or
id|dev-&gt;type
op_eq
id|ARPHRD_NETROM
)paren
ques
c_cond
id|htons
c_func
(paren
id|AX25_P_IP
)paren
suffix:colon
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
macro_line|#else
id|arp-&gt;ar_pro
op_assign
(paren
id|dev-&gt;type
op_ne
id|ARPHRD_AX25
)paren
ques
c_cond
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:colon
id|htons
c_func
(paren
id|AX25_P_IP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#else
id|arp-&gt;ar_pro
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
macro_line|#endif
id|arp-&gt;ar_hln
op_assign
id|dev-&gt;addr_len
suffix:semicolon
id|arp-&gt;ar_pln
op_assign
l_int|4
suffix:semicolon
id|arp-&gt;ar_op
op_assign
id|htons
c_func
(paren
id|type
)paren
suffix:semicolon
id|arp_ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|arp
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|arp_ptr
comma
id|src_hw
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
id|arp_ptr
comma
op_amp
id|src_ip
comma
l_int|4
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|dest_hw
op_ne
l_int|NULL
)paren
id|memcpy
c_func
(paren
id|arp_ptr
comma
id|dest_hw
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_else
id|memset
c_func
(paren
id|arp_ptr
comma
l_int|0
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
id|arp_ptr
comma
op_amp
id|dest_ip
comma
l_int|4
)paren
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This function is called, if an entry is not resolved in ARP_RES_TIME.&n; *&t;Either resend a request, or give it up and free the entry.&n; */
DECL|function|arp_expire_request
r_static
r_void
id|arp_expire_request
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
op_assign
(paren
r_struct
id|arp_table
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|arp_table
op_star
op_star
id|pentry
suffix:semicolon
r_int
r_int
id|hash
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Since all timeouts are handled with interrupts enabled, there is a&n;&t; *&t;small chance, that this entry has just been resolved by an incoming&n;&t; *&t;packet. This is the only race condition, but it is handled...&n;&t; */
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|entry-&gt;retries
OG
l_int|0
)paren
(brace
id|u32
id|ip
op_assign
id|entry-&gt;ip
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
id|entry-&gt;dev
suffix:semicolon
multiline_comment|/* Set new timer. */
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|ARP_RES_TIME
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|ip
comma
id|dev
comma
id|dev-&gt;pa_addr
comma
l_int|NULL
comma
id|dev-&gt;dev_addr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Arp request timed out. Delete entry and all waiting packets.&n;&t; *&t;If we give each entry a pointer to itself, we don&squot;t have to&n;&t; *&t;loop through everything again. Maybe hash is good enough, but&n;&t; *&t;I will look at it later.&n;&t; */
id|hash
op_assign
id|HASH
c_func
(paren
id|entry-&gt;ip
)paren
suffix:semicolon
multiline_comment|/* proxy entries shouldn&squot;t really time out so this is really&n;&t;   only here for completeness&n;&t;*/
multiline_comment|/* RFC1122: They *can* be timed out, according to 2.3.2.1. */
multiline_comment|/* They recommend a minute. -- MS */
multiline_comment|/* The world doesn&squot;t work this way -- AC */
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|ATF_PUBL
)paren
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|PROXY_HASH
)braket
suffix:semicolon
r_else
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pentry
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_star
id|pentry
op_eq
id|entry
)paren
(brace
op_star
id|pentry
op_assign
id|entry-&gt;next
suffix:semicolon
multiline_comment|/* delete from linked list */
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|arp_release_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|arp_cache_stamp
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pentry
op_assign
op_amp
(paren
op_star
id|pentry
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Possible ARP queue corruption.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We should never arrive here.&n;&t; */
multiline_comment|/* Should we perhaps flush the ARP table (except the ones we&squot;re */
multiline_comment|/* publishing, if we can trust the queue that much) at this */
multiline_comment|/* point? -- MS */
)brace
multiline_comment|/*&n; *&t;This will try to retransmit everything on the queue.&n; */
DECL|function|arp_send_q
r_static
r_void
id|arp_send_q
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
comma
r_int
r_char
op_star
id|hw_dest
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Empty the entire queue, building its data up ready to send&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arp_send_q: incomplete entry for %s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|entry-&gt;ip
)paren
)paren
suffix:semicolon
multiline_comment|/* Can&squot;t flush the skb, because RFC1122 says to hang on to */
multiline_comment|/* at least one from any unresolved entry.  --MS */
multiline_comment|/* Whats happened is that someone has &squot;unresolved&squot; the entry&n;&t;&t;   as we got to use it - this &squot;can&squot;t happen&squot; -- AC */
r_return
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb_device_lock
c_func
(paren
id|skb
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;dev
op_member_access_from_pointer
id|rebuild_header
c_func
(paren
id|skb-&gt;data
comma
id|skb-&gt;dev
comma
id|skb-&gt;raddr
comma
id|skb
)paren
)paren
(brace
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;sk
op_eq
l_int|NULL
)paren
(brace
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
id|skb-&gt;sk-&gt;priority
)paren
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Delete an ARP mapping entry in the cache.&n; */
DECL|function|arp_destroy
r_void
id|arp_destroy
c_func
(paren
id|u32
id|ip_addr
comma
r_int
id|force
)paren
(brace
r_int
id|checked_proxies
op_assign
l_int|0
suffix:semicolon
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|arp_table
op_star
op_star
id|pentry
suffix:semicolon
r_int
r_int
id|hash
op_assign
id|HASH
c_func
(paren
id|ip_addr
)paren
suffix:semicolon
id|ugly
suffix:colon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|pentry
)paren
multiline_comment|/* also check proxy entries */
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|PROXY_HASH
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
op_star
id|pentry
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|ip_addr
)paren
(brace
r_if
c_cond
(paren
(paren
id|entry-&gt;flags
op_amp
id|ATF_PERM
)paren
op_logical_and
op_logical_neg
id|force
)paren
r_return
suffix:semicolon
op_star
id|pentry
op_assign
id|entry-&gt;next
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|arp_release_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
multiline_comment|/* this would have to be cleaned up */
r_goto
id|ugly
suffix:semicolon
multiline_comment|/* perhaps like this ?&n;&t;&t;&t;cli();&n;&t;&t;&t;entry = *pentry;&n;&t;&t;&t;*/
)brace
id|pentry
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|checked_proxies
op_logical_and
op_logical_neg
op_star
id|pentry
)paren
(brace
multiline_comment|/* ugly. we have to make sure we check proxy&n;&t;&t;       entries as well */
id|checked_proxies
op_assign
l_int|1
suffix:semicolon
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|PROXY_HASH
)braket
suffix:semicolon
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Receive an arp request by the device layer. Maybe I rewrite it, to&n; *&t;use the incoming packet for the reply. The time for the current&n; *&t;&quot;overhead&quot; isn&squot;t that high...&n; */
DECL|function|arp_rcv
r_int
id|arp_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
multiline_comment|/*&n; *&t;We shouldn&squot;t use this type conversion. Check later.&n; */
r_struct
id|arphdr
op_star
id|arp
op_assign
(paren
r_struct
id|arphdr
op_star
)paren
id|skb-&gt;h.raw
suffix:semicolon
r_int
r_char
op_star
id|arp_ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|arp
op_plus
l_int|1
)paren
suffix:semicolon
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|arp_table
op_star
id|proxy_entry
suffix:semicolon
r_int
id|addr_hint
comma
id|hlen
comma
id|htype
suffix:semicolon
r_int
r_int
id|hash
suffix:semicolon
r_int
r_char
id|ha
(braket
id|MAX_ADDR_LEN
)braket
suffix:semicolon
multiline_comment|/* So we can enable ints again. */
r_int
r_char
op_star
id|sha
comma
op_star
id|tha
suffix:semicolon
id|u32
id|sip
comma
id|tip
suffix:semicolon
multiline_comment|/*&n; *&t;The hardware length of the packet should match the hardware length&n; *&t;of the device.  Similarly, the hardware types should match.  The&n; *&t;device should be ARP-able.  Also, if pln is not 4, then the lookup&n; *&t;is not from an IP number.  We can&squot;t currently handle this, so toss&n; *&t;it. &n; */
r_if
c_cond
(paren
id|arp-&gt;ar_hln
op_ne
id|dev-&gt;addr_len
op_logical_or
id|dev-&gt;type
op_ne
id|ntohs
c_func
(paren
id|arp-&gt;ar_hrd
)paren
op_logical_or
id|dev-&gt;flags
op_amp
id|IFF_NOARP
op_logical_or
id|arp-&gt;ar_pln
op_ne
l_int|4
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Should this be an error/printk?  Seems like something */
multiline_comment|/* you&squot;d want to know about. Unless it&squot;s just !IFF_NOARP. -- MS */
)brace
multiline_comment|/*&n; *&t;Another test.&n; *&t;The logic here is that the protocol being looked up by arp should &n; *&t;match the protocol the device speaks.  If it doesn&squot;t, there is a&n; *&t;problem, so toss the packet.&n; */
multiline_comment|/* Again, should this be an error/printk? -- MS */
r_switch
c_cond
(paren
id|dev-&gt;type
)paren
(brace
macro_line|#ifdef CONFIG_AX25
r_case
id|ARPHRD_AX25
suffix:colon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|AX25_P_IP
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NETROM
r_case
id|ARPHRD_NETROM
suffix:colon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|AX25_P_IP
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#endif
r_case
id|ARPHRD_ETHER
suffix:colon
r_case
id|ARPHRD_ARCNET
suffix:colon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ARPHRD_IEEE802
suffix:colon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ARP: dev-&gt;type mangled!&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Extract fields&n; */
id|hlen
op_assign
id|dev-&gt;addr_len
suffix:semicolon
id|htype
op_assign
id|dev-&gt;type
suffix:semicolon
id|sha
op_assign
id|arp_ptr
suffix:semicolon
id|arp_ptr
op_add_assign
id|hlen
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|sip
comma
id|arp_ptr
comma
l_int|4
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
l_int|4
suffix:semicolon
id|tha
op_assign
id|arp_ptr
suffix:semicolon
id|arp_ptr
op_add_assign
id|hlen
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|tip
comma
id|arp_ptr
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* &n; *&t;Check for bad requests for 127.0.0.1.  If this is one such, delete it.&n; */
r_if
c_cond
(paren
id|tip
op_eq
id|INADDR_LOOPBACK
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Process entry.  The idea here is we want to send a reply if it is a&n; *  request for us or if it is a request for someone else that we hold&n; *  a proxy for.  We want to add an entry to our cache if it is a reply&n; *  to us or if it is a request for our address.  &n; *  (The assumption for this last is that if someone is requesting our &n; *  address, they are probably intending to talk to us, so it saves time &n; *  if we cache their address.  Their address is also probably not in &n; *  our cache, since ours is not in their cache.)&n; * &n; *  Putting this another way, we only care about replies if they are to&n; *  us, in which case we add them to the cache.  For requests, we care&n; *  about those for us and those for our proxies.  We reply to both,&n; *  and in the case of requests for us we add the requester to the arp &n; *  cache.&n; */
id|addr_hint
op_assign
id|ip_chk_addr
c_func
(paren
id|tip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arp-&gt;ar_op
op_eq
id|htons
c_func
(paren
id|ARPOP_REPLY
)paren
)paren
(brace
r_if
c_cond
(paren
id|addr_hint
op_ne
id|IS_MYADDR
)paren
(brace
multiline_comment|/* &n; *&t;Replies to other machines get tossed. &n; */
multiline_comment|/* Should we reset the expiry timers for an entry that isn&squot;t for us, if we */
multiline_comment|/* have it in the cache? RFC1122 suggests it. -- MS */
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Fall through to code below that adds sender to cache. &n; */
)brace
r_else
(brace
multiline_comment|/* &n; * &t;It is now an arp request &n; */
multiline_comment|/*&n; * Only reply for the real device address or when it&squot;s in our proxy tables&n; */
r_if
c_cond
(paren
id|tip
op_ne
id|dev-&gt;pa_addr
)paren
(brace
multiline_comment|/*&n; * &t;To get in here, it is a request for someone else.  We need to&n; * &t;check if that someone else is one of our proxies.  If it isn&squot;t,&n; * &t;we can toss it.&n; */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|proxy_entry
op_assign
id|arp_tables
(braket
id|PROXY_HASH
)braket
suffix:semicolon
id|proxy_entry
suffix:semicolon
id|proxy_entry
op_assign
id|proxy_entry-&gt;next
)paren
(brace
multiline_comment|/* we will respond to a proxy arp request&n;&t;&t;&t;     if the masked arp table ip matches the masked&n;&t;&t;&t;     tip. This allows a single proxy arp table&n;&t;&t;&t;     entry to be used on a gateway machine to handle&n;&t;&t;&t;     all requests for a whole network, rather than&n;&t;&t;&t;     having to use a huge number of proxy arp entries&n;&t;&t;&t;     and having to keep them uptodate.&n;&t;&t;&t;     */
r_if
c_cond
(paren
id|proxy_entry-&gt;dev
op_ne
id|dev
op_logical_and
id|proxy_entry-&gt;htype
op_eq
id|htype
op_logical_and
op_logical_neg
(paren
(paren
id|proxy_entry-&gt;ip
op_xor
id|tip
)paren
op_amp
id|proxy_entry-&gt;mask
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|proxy_entry
)paren
(brace
id|memcpy
c_func
(paren
id|ha
comma
id|proxy_entry-&gt;ha
comma
id|hlen
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|arp_send
c_func
(paren
id|ARPOP_REPLY
comma
id|ETH_P_ARP
comma
id|sip
comma
id|dev
comma
id|tip
comma
id|sha
comma
id|ha
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n; * &t;To get here, it must be an arp request for us.  We need to reply.&n; */
id|arp_send
c_func
(paren
id|ARPOP_REPLY
comma
id|ETH_P_ARP
comma
id|sip
comma
id|dev
comma
id|tip
comma
id|sha
comma
id|dev-&gt;dev_addr
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Now all replies are handled.  Next, anything that falls through to here&n; * needs to be added to the arp cache, or have its entry updated if it is &n; * there.&n; */
id|hash
op_assign
id|HASH
c_func
(paren
id|sip
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|entry
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|sip
op_logical_and
id|entry-&gt;htype
op_eq
id|htype
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry
)paren
(brace
multiline_comment|/*&n; *&t;Entry found; update it.&n; */
id|memcpy
c_func
(paren
id|entry-&gt;ha
comma
id|sha
comma
id|hlen
)paren
suffix:semicolon
id|entry-&gt;hlen
op_assign
id|hlen
suffix:semicolon
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
)paren
(brace
multiline_comment|/*&n; *&t;This entry was incomplete.  Delete the retransmit timer&n; *&t;and switch to complete status.&n; */
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;flags
op_or_assign
id|ATF_COM
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* &n; *&t;Send out waiting packets. We might have problems, if someone is &n; *&t;manually removing entries right now -- entry might become invalid &n; *&t;underneath us.&n; */
id|arp_send_q
c_func
(paren
id|entry
comma
id|sha
)paren
suffix:semicolon
)brace
r_else
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n; * &t;No entry found.  Need to add a new entry to the arp table.&n; */
id|entry
op_assign
(paren
r_struct
id|arp_table
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arp_table
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ARP: no memory for new arp entry&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|entry-&gt;mask
op_assign
id|DEF_ARP_NETMASK
suffix:semicolon
id|entry-&gt;ip
op_assign
id|sip
suffix:semicolon
id|entry-&gt;hlen
op_assign
id|hlen
suffix:semicolon
id|entry-&gt;htype
op_assign
id|htype
suffix:semicolon
id|entry-&gt;flags
op_assign
id|ATF_COM
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|entry-&gt;ha
comma
id|sha
comma
id|hlen
)paren
suffix:semicolon
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|entry-&gt;dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
suffix:semicolon
id|entry-&gt;next
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|arp_tables
(braket
id|hash
)braket
op_assign
id|entry
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Replies have been sent, and entries have been added.  All done.&n; */
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Find an arp mapping in the cache. If not found, return false.&n; */
DECL|function|arp_query
r_int
id|arp_query
c_func
(paren
r_int
r_char
op_star
id|haddr
comma
id|u32
id|paddr
comma
r_int
r_int
id|type
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_int
r_int
id|hash
op_assign
id|HASH
c_func
(paren
id|paddr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Find an entry&n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|paddr
op_logical_and
id|entry-&gt;htype
op_eq
id|type
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Update the record&n;&t;&t; */
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|memcpy
c_func
(paren
id|haddr
comma
id|entry-&gt;ha
comma
id|entry-&gt;hlen
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Find an arp mapping in the cache. If not found, post a request.&n; */
DECL|function|arp_find
r_int
id|arp_find
c_func
(paren
r_int
r_char
op_star
id|haddr
comma
id|u32
id|paddr
comma
r_struct
id|device
op_star
id|dev
comma
id|u32
id|saddr
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_int
r_int
id|hash
suffix:semicolon
macro_line|#ifdef CONFIG_IP_MULTICAST
id|u32
id|taddr
suffix:semicolon
macro_line|#endif&t;
r_switch
c_cond
(paren
id|ip_chk_addr
c_func
(paren
id|paddr
)paren
)paren
(brace
r_case
id|IS_MYADDR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ARP: arp called for own IP address&bslash;n&quot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|haddr
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_IP_MULTICAST
r_case
id|IS_MULTICAST
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|ARPHRD_ETHER
op_logical_or
id|dev-&gt;type
op_eq
id|ARPHRD_IEEE802
)paren
(brace
multiline_comment|/* What exactly does this do? -- MS */
id|haddr
(braket
l_int|0
)braket
op_assign
l_int|0x01
suffix:semicolon
id|haddr
(braket
l_int|1
)braket
op_assign
l_int|0x00
suffix:semicolon
id|haddr
(braket
l_int|2
)braket
op_assign
l_int|0x5e
suffix:semicolon
id|taddr
op_assign
id|ntohl
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|haddr
(braket
l_int|5
)braket
op_assign
id|taddr
op_amp
l_int|0xff
suffix:semicolon
id|taddr
op_assign
id|taddr
op_rshift
l_int|8
suffix:semicolon
id|haddr
(braket
l_int|4
)braket
op_assign
id|taddr
op_amp
l_int|0xff
suffix:semicolon
id|taddr
op_assign
id|taddr
op_rshift
l_int|8
suffix:semicolon
id|haddr
(braket
l_int|3
)braket
op_assign
id|taddr
op_amp
l_int|0x7f
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;If a device does not support multicast broadcast the stuff (eg AX.25 for now)&n;&t;&t; */
macro_line|#endif
r_case
id|IS_BROADCAST
suffix:colon
id|memcpy
c_func
(paren
id|haddr
comma
id|dev-&gt;broadcast
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|hash
op_assign
id|HASH
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Find an entry&n;&t; */
id|entry
op_assign
id|arp_lookup
c_func
(paren
id|paddr
comma
id|PROXY_NONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_ne
l_int|NULL
)paren
multiline_comment|/* It exists */
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;A request was already send, but no reply yet. Thus&n;&t;&t;&t; *&t;queue the packet with the previous attempt&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|skb_queue_tail
c_func
(paren
op_amp
id|entry-&gt;skb
comma
id|skb
)paren
suffix:semicolon
id|skb_device_unlock
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Update the record&n;&t;&t; */
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|memcpy
c_func
(paren
id|haddr
comma
id|entry-&gt;ha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Create a new unresolved entry.&n;&t; */
id|entry
op_assign
(paren
r_struct
id|arp_table
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arp_table
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_ne
l_int|NULL
)paren
(brace
id|entry-&gt;next
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|entry-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|entry-&gt;ip
op_assign
id|paddr
suffix:semicolon
id|entry-&gt;mask
op_assign
id|DEF_ARP_NETMASK
suffix:semicolon
id|memset
c_func
(paren
id|entry-&gt;ha
comma
l_int|0
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|entry-&gt;hlen
op_assign
id|dev-&gt;addr_len
suffix:semicolon
id|entry-&gt;htype
op_assign
id|dev-&gt;type
suffix:semicolon
id|entry-&gt;dev
op_assign
id|dev
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;timer.function
op_assign
id|arp_expire_request
suffix:semicolon
id|entry-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|entry
suffix:semicolon
id|entry-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|ARP_RES_TIME
suffix:semicolon
id|arp_tables
(braket
id|hash
)braket
op_assign
id|entry
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;retries
op_assign
id|ARP_MAX_TRIES
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|skb_queue_tail
c_func
(paren
op_amp
id|entry-&gt;skb
comma
id|skb
)paren
suffix:semicolon
id|skb_device_unlock
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
op_logical_and
id|skb-&gt;free
)paren
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If we didn&squot;t find an entry, we will try to send an ARP packet.&n;&t; */
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|paddr
comma
id|dev
comma
id|saddr
comma
l_int|NULL
comma
id|dev-&gt;dev_addr
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Write the contents of the ARP cache to a PROCfs file.&n; */
DECL|macro|HBUFFERLEN
mdefine_line|#define HBUFFERLEN 30
DECL|function|arp_get_info
r_int
id|arp_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|dummy
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|size
suffix:semicolon
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_char
id|hbuffer
(braket
id|HBUFFERLEN
)braket
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_const
r_char
id|hexbuf
(braket
)braket
op_assign
l_string|&quot;0123456789ABCDEF&quot;
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;IP address       HW type     Flags       HW address            Mask&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FULL_ARP_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|entry
op_assign
id|arp_tables
(braket
id|i
)braket
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
(brace
multiline_comment|/*&n; *&t;Convert hardware address to XX:XX:XX:XX ... form.&n; */
macro_line|#ifdef CONFIG_AX25
macro_line|#ifdef CONFIG_NETROM
r_if
c_cond
(paren
id|entry-&gt;htype
op_eq
id|ARPHRD_AX25
op_logical_or
id|entry-&gt;htype
op_eq
id|ARPHRD_NETROM
)paren
id|strcpy
c_func
(paren
id|hbuffer
comma
id|ax2asc
c_func
(paren
(paren
id|ax25_address
op_star
)paren
id|entry-&gt;ha
)paren
)paren
suffix:semicolon
r_else
(brace
macro_line|#else
r_if
c_cond
(paren
id|entry-&gt;htype
op_eq
id|ARPHRD_AX25
)paren
(brace
id|strcpy
c_func
(paren
id|hbuffer
comma
id|ax2asc
c_func
(paren
(paren
id|ax25_address
op_star
)paren
id|entry-&gt;ha
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#endif
macro_line|#endif
r_for
c_loop
(paren
id|k
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|HBUFFERLEN
op_minus
l_int|3
op_logical_and
id|j
OL
id|entry-&gt;hlen
suffix:semicolon
id|j
op_increment
)paren
(brace
id|hbuffer
(braket
id|k
op_increment
)braket
op_assign
id|hexbuf
(braket
(paren
id|entry-&gt;ha
(braket
id|j
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|15
)braket
suffix:semicolon
id|hbuffer
(braket
id|k
op_increment
)braket
op_assign
id|hexbuf
(braket
id|entry-&gt;ha
(braket
id|j
)braket
op_amp
l_int|15
)braket
suffix:semicolon
id|hbuffer
(braket
id|k
op_increment
)braket
op_assign
l_char|&squot;:&squot;
suffix:semicolon
)brace
id|hbuffer
(braket
op_decrement
id|k
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_AX25
)brace
macro_line|#endif
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%-17s0x%-10x0x%-10x%s&quot;
comma
id|in_ntoa
c_func
(paren
id|entry-&gt;ip
)paren
comma
(paren
r_int
r_int
)paren
id|entry-&gt;htype
comma
id|entry-&gt;flags
comma
id|hbuffer
)paren
suffix:semicolon
id|size
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
op_plus
id|size
comma
l_string|&quot;     %-17s&bslash;n&quot;
comma
id|entry-&gt;mask
op_eq
id|DEF_ARP_NETMASK
ques
c_cond
l_string|&quot;*&quot;
suffix:colon
id|in_ntoa
c_func
(paren
id|entry-&gt;mask
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start slop */
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
multiline_comment|/* Ending slop */
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This will find an entry in the ARP table by looking at the IP address.&n; *&t;If proxy is PROXY_EXACT then only exact IP matches will be allowed&n; *&t;for proxy entries, otherwise the netmask will be used&n; */
DECL|function|arp_lookup
r_static
r_struct
id|arp_table
op_star
id|arp_lookup
c_func
(paren
id|u32
id|paddr
comma
r_enum
id|proxy
id|proxy
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_int
r_int
id|hash
op_assign
id|HASH
c_func
(paren
id|paddr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|paddr
)paren
r_break
suffix:semicolon
multiline_comment|/* it&squot;s possibly a proxy entry (with a netmask) */
r_if
c_cond
(paren
op_logical_neg
id|entry
op_logical_and
id|proxy
op_ne
id|PROXY_NONE
)paren
r_for
c_loop
(paren
id|entry
op_assign
id|arp_tables
(braket
id|PROXY_HASH
)braket
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
r_if
c_cond
(paren
(paren
id|proxy
op_eq
id|PROXY_EXACT
)paren
ques
c_cond
(paren
id|entry-&gt;ip
op_eq
id|paddr
)paren
suffix:colon
op_logical_neg
(paren
(paren
id|entry-&gt;ip
op_xor
id|paddr
)paren
op_amp
id|entry-&gt;mask
)paren
)paren
r_break
suffix:semicolon
r_return
id|entry
suffix:semicolon
)brace
DECL|function|arp_find_cache
r_int
id|arp_find_cache
c_func
(paren
r_int
r_char
op_star
id|dp
comma
id|u32
id|daddr
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
multiline_comment|/* &n;&t; *&t;We need the broadcast/multicast awareness here and the find routine split up.&n;&t; */
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
macro_line|#ifdef CONFIG_IP_MULTICAST
id|u32
id|taddr
suffix:semicolon
macro_line|#endif&t;
r_switch
c_cond
(paren
id|ip_chk_addr
c_func
(paren
id|daddr
)paren
)paren
(brace
r_case
id|IS_MYADDR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ARP: arp called for own IP address&bslash;n&quot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dp
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_IP_MULTICAST
r_case
id|IS_MULTICAST
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|ARPHRD_ETHER
op_logical_or
id|dev-&gt;type
op_eq
id|ARPHRD_IEEE802
)paren
(brace
id|dp
(braket
l_int|0
)braket
op_assign
l_int|0x01
suffix:semicolon
id|dp
(braket
l_int|1
)braket
op_assign
l_int|0x00
suffix:semicolon
id|dp
(braket
l_int|2
)braket
op_assign
l_int|0x5e
suffix:semicolon
id|taddr
op_assign
id|ntohl
c_func
(paren
id|daddr
)paren
suffix:semicolon
id|dp
(braket
l_int|5
)braket
op_assign
id|taddr
op_amp
l_int|0xff
suffix:semicolon
id|taddr
op_assign
id|taddr
op_rshift
l_int|8
suffix:semicolon
id|dp
(braket
l_int|4
)braket
op_assign
id|taddr
op_amp
l_int|0xff
suffix:semicolon
id|taddr
op_assign
id|taddr
op_rshift
l_int|8
suffix:semicolon
id|dp
(braket
l_int|3
)braket
op_assign
id|taddr
op_amp
l_int|0x7f
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;If a device does not support multicast broadcast the stuff (eg AX.25 for now)&n;&t;&t; */
macro_line|#endif
r_case
id|IS_BROADCAST
suffix:colon
id|memcpy
c_func
(paren
id|dp
comma
id|dev-&gt;broadcast
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_default
suffix:colon
id|entry
op_assign
id|arp_lookup
c_func
(paren
id|daddr
comma
id|PROXY_NONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
(brace
id|memcpy
c_func
(paren
id|dp
comma
id|entry-&gt;ha
comma
id|ETH_ALEN
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Set (create) an ARP cache entry.&n; */
DECL|function|arp_req_set
r_static
r_int
id|arp_req_set
c_func
(paren
r_struct
id|arpreq
op_star
id|req
)paren
(brace
r_struct
id|arpreq
id|r
suffix:semicolon
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|si
suffix:semicolon
r_int
id|htype
comma
id|hlen
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
id|u32
id|ip
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|r
comma
id|req
comma
r_sizeof
(paren
id|r
)paren
)paren
suffix:semicolon
multiline_comment|/* We only understand about IP addresses... */
r_if
c_cond
(paren
id|r.arp_pa.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EPFNOSUPPORT
suffix:semicolon
multiline_comment|/*&n;&t; * Find out about the hardware type.&n;&t; * We have to be compatible with BSD UNIX, so we have to&n;&t; * assume that a &quot;not set&quot; value (i.e. 0) means Ethernet.&n;&t; */
r_switch
c_cond
(paren
id|r.arp_ha.sa_family
)paren
(brace
r_case
id|ARPHRD_ETHER
suffix:colon
id|htype
op_assign
id|ARPHRD_ETHER
suffix:semicolon
id|hlen
op_assign
id|ETH_ALEN
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ARPHRD_ARCNET
suffix:colon
id|htype
op_assign
id|ARPHRD_ARCNET
suffix:semicolon
id|hlen
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* length of arcnet addresses */
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_AX25
r_case
id|ARPHRD_AX25
suffix:colon
id|htype
op_assign
id|ARPHRD_AX25
suffix:semicolon
id|hlen
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NETROM
r_case
id|ARPHRD_NETROM
suffix:colon
id|htype
op_assign
id|ARPHRD_NETROM
suffix:semicolon
id|hlen
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|ARPHRD_IEEE802
suffix:colon
id|htype
op_assign
id|ARPHRD_IEEE802
suffix:semicolon
id|hlen
op_assign
id|TR_ALEN
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EPFNOSUPPORT
suffix:semicolon
)brace
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r.arp_pa
suffix:semicolon
id|ip
op_assign
id|si-&gt;sin_addr.s_addr
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ARP: SETARP: requested PA is 0.0.0.0 !&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Is it reachable directly ?&n;&t; */
id|rt
op_assign
id|ip_rt_route
c_func
(paren
id|ip
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Is there an existing entry for this address?&n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Find the entry&n;&t; */
id|entry
op_assign
id|arp_lookup
c_func
(paren
id|ip
comma
id|PROXY_EXACT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_logical_and
(paren
id|entry-&gt;flags
op_amp
id|ATF_PUBL
)paren
op_ne
(paren
id|r.arp_flags
op_amp
id|ATF_PUBL
)paren
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|arp_destroy
c_func
(paren
id|ip
comma
l_int|1
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|entry
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Do we need to create a new entry&n;&t; */
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
(brace
r_int
r_int
id|hash
op_assign
id|HASH
c_func
(paren
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r.arp_flags
op_amp
id|ATF_PUBL
)paren
id|hash
op_assign
id|PROXY_HASH
suffix:semicolon
id|entry
op_assign
(paren
r_struct
id|arp_table
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arp_table
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|entry-&gt;ip
op_assign
id|ip
suffix:semicolon
id|entry-&gt;hlen
op_assign
id|hlen
suffix:semicolon
id|entry-&gt;htype
op_assign
id|htype
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;next
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|arp_tables
(braket
id|hash
)braket
op_assign
id|entry
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;We now have a pointer to an ARP entry.  Update it!&n;&t; */
id|memcpy
c_func
(paren
op_amp
id|entry-&gt;ha
comma
op_amp
id|r.arp_ha.sa_data
comma
id|hlen
)paren
suffix:semicolon
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|entry-&gt;flags
op_assign
id|r.arp_flags
op_or
id|ATF_COM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|entry-&gt;flags
op_amp
id|ATF_PUBL
)paren
op_logical_and
(paren
id|entry-&gt;flags
op_amp
id|ATF_NETMASK
)paren
)paren
(brace
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r.arp_netmask
suffix:semicolon
id|entry-&gt;mask
op_assign
id|si-&gt;sin_addr.s_addr
suffix:semicolon
)brace
r_else
id|entry-&gt;mask
op_assign
id|DEF_ARP_NETMASK
suffix:semicolon
id|entry-&gt;dev
op_assign
id|rt-&gt;rt_dev
suffix:semicolon
id|arp_cache_stamp
op_increment
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get an ARP cache entry.&n; */
DECL|function|arp_req_get
r_static
r_int
id|arp_req_get
c_func
(paren
r_struct
id|arpreq
op_star
id|req
)paren
(brace
r_struct
id|arpreq
id|r
suffix:semicolon
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|si
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We only understand about IP addresses...&n;&t; */
id|memcpy_fromfs
c_func
(paren
op_amp
id|r
comma
id|req
comma
r_sizeof
(paren
id|r
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r.arp_pa.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EPFNOSUPPORT
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Is there an existing entry for this address?&n;&t; */
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r.arp_pa
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|entry
op_assign
id|arp_lookup
c_func
(paren
id|si-&gt;sin_addr.s_addr
comma
id|PROXY_ANY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;We found it; copy into structure.&n;&t; */
id|memcpy
c_func
(paren
id|r.arp_ha.sa_data
comma
op_amp
id|entry-&gt;ha
comma
id|entry-&gt;hlen
)paren
suffix:semicolon
id|r.arp_ha.sa_family
op_assign
id|entry-&gt;htype
suffix:semicolon
id|r.arp_flags
op_assign
id|entry-&gt;flags
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Copy the information back&n;&t; */
id|memcpy_tofs
c_func
(paren
id|req
comma
op_amp
id|r
comma
r_sizeof
(paren
id|r
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Handle an ARP layer I/O control request.&n; */
DECL|function|arp_ioctl
r_int
id|arp_ioctl
c_func
(paren
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|arpreq
id|r
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|si
suffix:semicolon
r_int
id|err
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCDARP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|r
comma
id|arg
comma
r_sizeof
(paren
id|r
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r.arp_pa.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EPFNOSUPPORT
suffix:semicolon
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r.arp_pa
suffix:semicolon
id|arp_destroy
c_func
(paren
id|si-&gt;sin_addr.s_addr
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCGARP
suffix:colon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
r_return
id|arp_req_get
c_func
(paren
(paren
r_struct
id|arpreq
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SIOCSARP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
r_return
id|arp_req_set
c_func
(paren
(paren
r_struct
id|arpreq
op_star
)paren
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*NOTREACHED*/
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Called once on startup.&n; */
DECL|variable|arp_packet_type
r_static
r_struct
id|packet_type
id|arp_packet_type
op_assign
(brace
l_int|0
comma
multiline_comment|/* Should be: __constant_htons(ETH_P_ARP) - but this _doesn&squot;t_ come out constant! */
l_int|NULL
comma
multiline_comment|/* All devices */
id|arp_rcv
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|arp_dev_notifier
r_static
r_struct
id|notifier_block
id|arp_dev_notifier
op_assign
initialization_block
suffix:semicolon
DECL|function|arp_init
r_void
id|arp_init
(paren
r_void
)paren
(brace
multiline_comment|/* Register the packet type */
id|arp_packet_type.type
op_assign
id|htons
c_func
(paren
id|ETH_P_ARP
)paren
suffix:semicolon
id|dev_add_pack
c_func
(paren
op_amp
id|arp_packet_type
)paren
suffix:semicolon
multiline_comment|/* Start with the regular checks for expired arp entries. */
id|add_timer
c_func
(paren
op_amp
id|arp_timer
)paren
suffix:semicolon
multiline_comment|/* Register for device down reports */
id|register_netdevice_notifier
c_func
(paren
op_amp
id|arp_dev_notifier
)paren
suffix:semicolon
id|proc_net_register
c_func
(paren
op_amp
(paren
r_struct
id|proc_dir_entry
)paren
(brace
id|PROC_NET_ARP
comma
id|arp_get_info
comma
l_int|3
comma
l_string|&quot;arp&quot;
)brace
)paren
suffix:semicolon
)brace
eof
