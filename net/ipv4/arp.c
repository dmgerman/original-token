multiline_comment|/* linux/net/inet/arp.c&n; *&n; * Copyright (C) 1994 by Florian  La Roche&n; *&n; * This module implements the Address Resolution Protocol ARP (RFC 826),&n; * which is used to convert IP addresses (or in the future maybe other&n; * high-level addresses) into a low-level hardware address (like an Ethernet&n; * address).&n; *&n; * FIXME:&n; *&t;Experiment with better retransmit timers&n; *&t;Clean up the timer deletions&n; *&t;If you create a proxy entry, set your interface address to the address&n; *&t;and then delete it, proxies may get out of sync with reality - &n; *&t;check this.&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;Removed the ethernet assumptions in &n; *&t;&t;&t;&t;&t;Florian&squot;s code&n; *&t;&t;Alan Cox&t;:&t;Fixed some small errors in the ARP &n; *&t;&t;&t;&t;&t;logic&n; *&t;&t;Alan Cox&t;:&t;Allow &gt;4K in /proc&n; *&t;&t;Alan Cox&t;:&t;Make ARP add its own protocol entry&n; *&t;&t;Ross Martin     :       Rewrote arp_rcv() and arp_get_info()&n; *&t;&t;Stephen Henson&t;:&t;Add AX25 support to arp_get_info()&n; *&t;&t;Alan Cox&t;:&t;Drop data when a device is downed.&n; *&t;&t;Alan Cox&t;:&t;Use init_timer().&n; *&t;&t;Alan Cox&t;:&t;Double lock fixes.&n; *&t;&t;Martin Seine&t;:&t;Move the arphdr structure&n; *&t;&t;&t;&t;&t;to if_arp.h for compatibility.&n; *&t;&t;&t;&t;&t;with BSD based programs.&n; *&t;&t;Andrew Tridgell :       Added ARP netmask code and&n; *&t;&t;&t;&t;&t;re-arranged proxy handling.&n; *&t;&t;Alan Cox&t;:&t;Changed to use notifiers.&n; *&t;&t;Niibe Yutaka&t;:&t;Reply for this device or proxies only.&n; *&t;&t;Alan Cox&t;:&t;Don&squot;t proxy across hardware types!&n; *&t;&t;Jonathan Naylor :&t;Added support for NET/ROM.&n; *&t;&t;Mike Shaver     :       RFC1122 checks.&n; *&t;&t;Jonathan Naylor :&t;Only lookup the hardware address for&n; *&t;&t;&t;&t;&t;the correct hardware type.&n; *&t;&t;Germano Caronni&t;:&t;Assorted subtle races.&n; *&t;&t;Craig Schlenter :&t;Don&squot;t modify permanent entry &n; *&t;&t;&t;&t;&t;during arp_rcv.&n; *&t;&t;Russ Nelson&t;:&t;Tidied up a few bits.&n; *&t;&t;Alexey Kuznetsov:&t;Major changes to caching and behaviour,&n; *&t;&t;&t;&t;&t;eg intelligent arp probing and &n; *&t;&t;&t;&t;&t;generation&n; *&t;&t;&t;&t;&t;of host down events.&n; *&t;&t;Alan Cox&t;:&t;Missing unlock in device events.&n; *&t;&t;Eckes&t;&t;:&t;ARP ioctl control errors.&n; *&t;&t;Alexey Kuznetsov:&t;Arp free fix.&n; *&t;&t;Manuel Rodriguez:&t;Gratuitous ARP.&n; *              Jonathan Layes  :       Added arpd support through kerneld &n; *                                      message queue (960314)&n; *&t;&t;Mike Shaver&t;:&t;/proc/sys/net/ipv4/arp_* support&n; *&t;&t;Stuart Cheshire&t;:&t;Metricom and grat arp fixes&n; *&t;&t;&t;&t;&t;*** FOR 2.1 clean this up ***&n; */
multiline_comment|/* RFC1122 Status:&n;   2.3.2.1 (ARP Cache Validation):&n;     MUST provide mechanism to flush stale cache entries (OK)&n;     SHOULD be able to configure cache timeout (OK)&n;     MUST throttle ARP retransmits (OK)&n;   2.3.2.2 (ARP Packet Queue):&n;     SHOULD save at least one packet from each &quot;conversation&quot; with an&n;       unresolved IP address.  (OK)&n;   950727 -- MS&n;*/
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/trdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#ifdef CONFIG_AX25
macro_line|#include &lt;net/ax25.h&gt;
macro_line|#ifdef CONFIG_NETROM
macro_line|#include &lt;net/netrom.h&gt;
macro_line|#endif
macro_line|#endif
macro_line|#ifdef CONFIG_NET_ALIAS
macro_line|#include &lt;linux/net_alias.h&gt;
macro_line|#endif
macro_line|#ifdef CONFIG_ARPD
macro_line|#include &lt;net/netlink.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;stdarg.h&gt;
multiline_comment|/*&n; *&t;Configurable Parameters&n; */
multiline_comment|/*&n; *&t;After that time, an unused entry is deleted from the arp table.&n; *&t;RFC1122 recommends set it to 60*HZ, if your site uses proxy arp&n; *&t;and dynamic routing.&n; */
DECL|macro|ARP_TIMEOUT
mdefine_line|#define ARP_TIMEOUT&t;&t;(60*HZ)
DECL|variable|sysctl_arp_timeout
r_int
id|sysctl_arp_timeout
op_assign
id|ARP_TIMEOUT
suffix:semicolon
multiline_comment|/*&n; *&t;How often is ARP cache checked for expire.&n; *&t;It is useless to set ARP_CHECK_INTERVAL &gt; ARP_TIMEOUT&n; */
DECL|macro|ARP_CHECK_INTERVAL
mdefine_line|#define ARP_CHECK_INTERVAL&t;(60*HZ)
DECL|variable|sysctl_arp_check_interval
r_int
id|sysctl_arp_check_interval
op_assign
id|ARP_CHECK_INTERVAL
suffix:semicolon
multiline_comment|/*&n; *&t;Soft limit on ARP cache size.&n; *&t;Note that this number should be greater than&n; *&t;number of simultaneously opened sockets, or else&n; *&t;hardware header cache will not be efficient.&n; */
macro_line|#if RT_CACHE_DEBUG &gt;= 2
DECL|macro|ARP_MAXSIZE
mdefine_line|#define ARP_MAXSIZE&t;4
macro_line|#else
macro_line|#ifdef CONFIG_ARPD
DECL|macro|ARP_MAXSIZE
mdefine_line|#define ARP_MAXSIZE&t;64
macro_line|#else
DECL|macro|ARP_MAXSIZE
mdefine_line|#define ARP_MAXSIZE&t;256
macro_line|#endif /* CONFIG_ARPD */
macro_line|#endif
multiline_comment|/*&n; *&t;If an arp request is send, ARP_RES_TIME is the timeout value until the&n; *&t;next request is send.&n; * &t;RFC1122: OK.  Throttles ARPing, as per 2.3.2.1. (MUST)&n; *&t;The recommended minimum timeout is 1 second per destination.&n; *&n; */
DECL|macro|ARP_RES_TIME
mdefine_line|#define ARP_RES_TIME&t;&t;(5*HZ)
DECL|variable|sysctl_arp_res_time
r_int
id|sysctl_arp_res_time
op_assign
id|ARP_RES_TIME
suffix:semicolon
multiline_comment|/*&n; *&t;The number of times an broadcast arp request is send, until&n; *&t;the host is considered temporarily unreachable.&n; */
DECL|macro|ARP_MAX_TRIES
mdefine_line|#define ARP_MAX_TRIES&t;&t;3
DECL|variable|sysctl_arp_max_tries
r_int
id|sysctl_arp_max_tries
op_assign
id|ARP_MAX_TRIES
suffix:semicolon
multiline_comment|/*&n; *&t;The entry is reconfirmed by sending point-to-point ARP&n; *&t;request after ARP_CONFIRM_INTERVAL.&n; *&t;RFC1122 recommends 60*HZ.&n; *&n; *&t;Warning: there exist nodes, that answer only broadcast&n; *&t;ARP requests (Cisco-4000 in hot standby mode?)&n; *&t;Now arp code should work with such nodes, but&n; *&t;it still will generate redundant broadcast requests, so that&n; *&t;this interval should be enough long.&n; */
DECL|macro|ARP_CONFIRM_INTERVAL
mdefine_line|#define ARP_CONFIRM_INTERVAL&t;(300*HZ)
DECL|variable|sysctl_arp_confirm_interval
r_int
id|sysctl_arp_confirm_interval
op_assign
id|ARP_CONFIRM_INTERVAL
suffix:semicolon
multiline_comment|/*&n; *&t;We wait for answer to unicast request for ARP_CONFIRM_TIMEOUT.&n; */
DECL|macro|ARP_CONFIRM_TIMEOUT
mdefine_line|#define ARP_CONFIRM_TIMEOUT&t;ARP_RES_TIME
DECL|variable|sysctl_arp_confirm_timeout
r_int
id|sysctl_arp_confirm_timeout
op_assign
id|ARP_CONFIRM_TIMEOUT
suffix:semicolon
multiline_comment|/*&n; *&t;The number of times an unicast arp request is retried, until&n; *&t;the cache entry is considered suspicious.&n; *&t;Value 0 means that no unicast pings will be sent.&n; *&t;RFC1122 recommends 2.&n; */
DECL|macro|ARP_MAX_PINGS
mdefine_line|#define ARP_MAX_PINGS&t;&t;1
DECL|variable|sysctl_arp_max_pings
r_int
id|sysctl_arp_max_pings
op_assign
id|ARP_MAX_PINGS
suffix:semicolon
multiline_comment|/*&n; *&t;When a host is dead, but someone tries to connect it,&n; *&t;we do not remove corresponding cache entry (it would&n; *&t;be useless, it will be created again immediately)&n; *&t;Instead we prolongate interval between broadcasts&n; *&t;to ARP_DEAD_RES_TIME.&n; *&t;This interval should be not very long.&n; *&t;(When the host will be up again, we will notice it only&n; *&t;when ARP_DEAD_RES_TIME expires, or when the host will arp us.&n; */
DECL|macro|ARP_DEAD_RES_TIME
mdefine_line|#define ARP_DEAD_RES_TIME&t;(60*HZ)
DECL|variable|sysctl_arp_dead_res_time
r_int
id|sysctl_arp_dead_res_time
op_assign
id|ARP_DEAD_RES_TIME
suffix:semicolon
multiline_comment|/*&n; *&t;This structure defines the ARP mapping cache.&n; */
DECL|struct|arp_table
r_struct
id|arp_table
(brace
DECL|member|next
r_struct
id|arp_table
op_star
id|next
suffix:semicolon
multiline_comment|/* Linked entry list &t;&t;*/
DECL|member|last_used
r_int
r_int
id|last_used
suffix:semicolon
multiline_comment|/* For expiry &t;&t;&t;*/
DECL|member|last_updated
r_int
r_int
id|last_updated
suffix:semicolon
multiline_comment|/* For expiry &t;&t;&t;*/
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Control status &t;&t;*/
DECL|member|ip
id|u32
id|ip
suffix:semicolon
multiline_comment|/* ip address of entry &t;&t;*/
DECL|member|mask
id|u32
id|mask
suffix:semicolon
multiline_comment|/* netmask - used for generalised proxy arps (tridge) &t;&t;*/
DECL|member|ha
r_int
r_char
id|ha
(braket
id|MAX_ADDR_LEN
)braket
suffix:semicolon
multiline_comment|/* Hardware address&t;&t;*/
DECL|member|dev
r_struct
id|device
op_star
id|dev
suffix:semicolon
multiline_comment|/* Device the entry is tied to &t;*/
DECL|member|hh
r_struct
id|hh_cache
op_star
id|hh
suffix:semicolon
multiline_comment|/* Hardware headers chain&t;*/
multiline_comment|/*&n;&t; *&t;The following entries are only used for unresolved hw addresses.&n;&t; */
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* expire timer &t;&t;*/
DECL|member|retries
r_int
id|retries
suffix:semicolon
multiline_comment|/* remaining retries&t; &t;*/
DECL|member|skb
r_struct
id|sk_buff_head
id|skb
suffix:semicolon
multiline_comment|/* list of queued packets &t;*/
)brace
suffix:semicolon
DECL|variable|arp_size
r_static
id|atomic_t
id|arp_size
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_ARPD
DECL|variable|arpd_not_running
r_static
r_int
id|arpd_not_running
suffix:semicolon
DECL|variable|arpd_stamp
r_static
r_int
id|arpd_stamp
suffix:semicolon
macro_line|#endif
DECL|variable|arp_bh_mask
r_static
r_int
r_int
id|arp_bh_mask
suffix:semicolon
DECL|macro|ARP_BH_BACKLOG
mdefine_line|#define ARP_BH_BACKLOG&t;1
multiline_comment|/*&n; *&t;Backlog for ARP updates.&n; */
DECL|variable|arp_backlog
r_static
r_struct
id|arp_table
op_star
id|arp_backlog
suffix:semicolon
multiline_comment|/*&n; *&t;Backlog for incomplete entries.&n; */
DECL|variable|arp_req_backlog
r_static
r_struct
id|arp_table
op_star
id|arp_req_backlog
suffix:semicolon
r_static
r_void
id|arp_run_bh
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|arp_check_expire
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
id|arp_update
(paren
id|u32
id|sip
comma
r_char
op_star
id|sha
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|updated
comma
r_struct
id|arp_table
op_star
id|ientry
comma
r_int
id|grat
)paren
suffix:semicolon
DECL|variable|arp_timer
r_static
r_struct
id|timer_list
id|arp_timer
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
id|ARP_CHECK_INTERVAL
comma
l_int|0L
comma
op_amp
id|arp_check_expire
)brace
suffix:semicolon
multiline_comment|/*&n; * The default arp netmask is just 255.255.255.255 which means it&squot;s&n; * a single machine entry. Only proxy entries can have other netmasks&n; */
DECL|macro|DEF_ARP_NETMASK
mdefine_line|#define DEF_ARP_NETMASK (~0)
multiline_comment|/*&n; * &t;The size of the hash table. Must be a power of two.&n; */
DECL|macro|ARP_TABLE_SIZE
mdefine_line|#define ARP_TABLE_SIZE&t;&t;16
DECL|macro|FULL_ARP_TABLE_SIZE
mdefine_line|#define FULL_ARP_TABLE_SIZE&t;(ARP_TABLE_SIZE+1)
DECL|variable|arp_tables
r_struct
id|arp_table
op_star
id|arp_tables
(braket
id|FULL_ARP_TABLE_SIZE
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|macro|arp_proxy_list
mdefine_line|#define arp_proxy_list arp_tables[ARP_TABLE_SIZE]
multiline_comment|/*&n; *&t;The last bits in the IP address are used for the cache lookup.&n; *&t;A special entry is used for proxy arp entries&n; */
DECL|macro|HASH
mdefine_line|#define HASH(paddr) &t;&t;(htonl(paddr) &amp; (ARP_TABLE_SIZE - 1))
multiline_comment|/*&n; *&t;ARP cache semaphore.&n; *&n; *&t;Every time when someone wants to traverse arp table,&n; *&t;he MUST call arp_fast_lock.&n; *&t;It will guarantee that arp cache list will not change&n; *&t;by interrupts and the entry that you found will not&n; *&t;disappear unexpectedly.&n; *&t;&n; *&t;If you want to modify arp cache lists, you MUST&n; *&t;call arp_fast_lock, and check that you are the only&n; *&t;owner of semaphore (arp_lock == 1). If it is not the case&n; *&t;you can defer your operation or forgot it,&n; *&t;but DO NOT TOUCH lists.&n; *&n; *&t;However, you are allowed to change arp entry contents.&n; *&n; *&t;Assumptions:&n; *&t;     -- interrupt code MUST have lock/unlock balanced,&n; *&t;&t;you cannot lock cache on interrupt and defer unlocking&n; *&t;&t;to callback.&n; *&t;&t;In particular, it means that lock/unlock are allowed&n; *&t;&t;to be non-atomic. They are made atomic, but it was not&n; *&t;&t;necessary.&n; *&t;     -- nobody is allowed to sleep while&n; *&t;&t;it keeps arp locked. (route cache has similar locking&n; *&t;&t;scheme, but allows sleeping)&n; *&t;&t;&n; */
DECL|variable|arp_lock
r_static
id|atomic_t
id|arp_lock
suffix:semicolon
DECL|macro|ARP_LOCKED
mdefine_line|#define ARP_LOCKED() (arp_lock != 1)
DECL|function|arp_fast_lock
r_static
id|__inline__
r_void
id|arp_fast_lock
c_func
(paren
r_void
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|arp_lock
)paren
suffix:semicolon
)brace
DECL|function|arp_unlock
r_static
id|__inline__
r_void
id|arp_unlock
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|arp_lock
)paren
op_logical_and
id|arp_bh_mask
)paren
id|arp_run_bh
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Enqueue to FIFO list.&n; */
DECL|function|arp_enqueue
r_static
r_void
id|arp_enqueue
c_func
(paren
r_struct
id|arp_table
op_star
op_star
id|q
comma
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|arp_table
op_star
id|tail
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|tail
op_assign
op_star
id|q
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tail
)paren
id|entry-&gt;next
op_assign
id|entry
suffix:semicolon
r_else
(brace
id|entry-&gt;next
op_assign
id|tail-&gt;next
suffix:semicolon
id|tail-&gt;next
op_assign
id|entry
suffix:semicolon
)brace
op_star
id|q
op_assign
id|entry
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Dequeue from FIFO list,&n; * caller should mask interrupts.&n; */
DECL|function|arp_dequeue
r_static
r_struct
id|arp_table
op_star
id|arp_dequeue
c_func
(paren
r_struct
id|arp_table
op_star
op_star
id|q
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
op_star
id|q
)paren
(brace
id|entry
op_assign
(paren
op_star
id|q
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
(paren
op_star
id|q
)paren
op_member_access_from_pointer
id|next
op_assign
id|entry-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;next
op_eq
id|entry
)paren
op_star
id|q
op_assign
l_int|NULL
suffix:semicolon
id|entry-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|entry
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Purge all linked skb&squot;s of the entry.&n; */
DECL|function|arp_purge_send_q
r_static
r_void
id|arp_purge_send_q
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Release the list of `skb&squot; pointers. */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|skb_device_lock
c_func
(paren
id|skb
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Release the entry and all resources linked to it: skb&squot;s, hh&squot;s, timer&n; * &t;and certainly memory.&n; *&t;The entry should be already removed from lists.&n; */
DECL|function|arp_free_entry
r_static
r_void
id|arp_free_entry
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|hh_cache
op_star
id|hh
comma
op_star
id|next
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|arp_purge_send_q
c_func
(paren
id|entry
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|hh
op_assign
id|entry-&gt;hh
suffix:semicolon
id|entry-&gt;hh
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|hh
suffix:semicolon
id|hh
op_assign
id|next
)paren
(brace
id|next
op_assign
id|hh-&gt;hh_next
suffix:semicolon
id|hh-&gt;hh_uptodate
op_assign
l_int|0
suffix:semicolon
id|hh-&gt;hh_next
op_assign
l_int|NULL
suffix:semicolon
id|hh-&gt;hh_arp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|hh-&gt;hh_refcnt
)paren
)paren
id|kfree_s
c_func
(paren
id|hh
comma
r_sizeof
(paren
r_struct
(paren
r_struct
id|hh_cache
)paren
)paren
)paren
suffix:semicolon
)brace
id|kfree_s
c_func
(paren
id|entry
comma
r_sizeof
(paren
r_struct
id|arp_table
)paren
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|arp_size
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Hardware header cache.&n; *&n; *&t;BEWARE! Hardware header cache has no locking, so that&n; *&t;it requires especially careful handling.&n; *&t;It is the only part of arp+route, where a list&n; *&t;should be traversed with masked interrupts.&n; *&t;Luckily, this list contains one element 8), as rule.&n; */
multiline_comment|/*&n; *&t;How many users has this entry?&n; *&t;The answer is reliable only when interrupts are masked.&n; */
DECL|function|arp_count_hhs
r_static
id|__inline__
r_int
id|arp_count_hhs
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_struct
id|hh_cache
op_star
id|hh
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|hh
op_assign
id|entry-&gt;hh
suffix:semicolon
id|hh
suffix:semicolon
id|hh
op_assign
id|hh-&gt;hh_next
)paren
id|count
op_add_assign
id|hh-&gt;hh_refcnt
op_minus
l_int|1
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * Signal to device layer, that hardware address may be changed.&n; */
DECL|function|arp_update_hhs
r_static
id|__inline__
r_void
id|arp_update_hhs
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_struct
id|hh_cache
op_star
id|hh
suffix:semicolon
r_for
c_loop
(paren
id|hh
op_assign
id|entry-&gt;hh
suffix:semicolon
id|hh
suffix:semicolon
id|hh
op_assign
id|hh-&gt;hh_next
)paren
id|entry-&gt;dev
op_member_access_from_pointer
id|header_cache_update
c_func
(paren
id|hh
comma
id|entry-&gt;dev
comma
id|entry-&gt;ha
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Invalidate all hh&squot;s, so that higher level will not try to use it.&n; */
DECL|function|arp_invalidate_hhs
r_static
id|__inline__
r_void
id|arp_invalidate_hhs
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_struct
id|hh_cache
op_star
id|hh
suffix:semicolon
r_for
c_loop
(paren
id|hh
op_assign
id|entry-&gt;hh
suffix:semicolon
id|hh
suffix:semicolon
id|hh
op_assign
id|hh-&gt;hh_next
)paren
id|hh-&gt;hh_uptodate
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Atomic attaching new hh entry.&n; *&t;Return 1, if entry has been freed, rather than attached.&n; */
DECL|function|arp_set_hh
r_static
r_int
id|arp_set_hh
c_func
(paren
r_struct
id|hh_cache
op_star
op_star
id|hhp
comma
r_struct
id|hh_cache
op_star
id|hh
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|hh_cache
op_star
id|hh1
suffix:semicolon
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|hh-&gt;hh_refcnt
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hh1
op_assign
op_star
id|hhp
)paren
op_eq
l_int|NULL
)paren
(brace
op_star
id|hhp
op_assign
id|hh
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|entry
op_assign
(paren
r_struct
id|arp_table
op_star
)paren
id|hh-&gt;hh_arp
suffix:semicolon
multiline_comment|/*&n;&t; *&t;An hh1 entry is already attached to this point.&n;&t; *&t;Is it not linked to arp entry? Link it!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|hh1-&gt;hh_arp
op_logical_and
id|entry
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|hh1-&gt;hh_refcnt
)paren
suffix:semicolon
id|hh1-&gt;hh_next
op_assign
id|entry-&gt;hh
suffix:semicolon
id|entry-&gt;hh
op_assign
id|hh1
suffix:semicolon
id|hh1-&gt;hh_arp
op_assign
(paren
r_void
op_star
)paren
id|entry
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
id|entry-&gt;dev
op_member_access_from_pointer
id|header_cache_update
c_func
(paren
id|hh1
comma
id|entry-&gt;dev
comma
id|entry-&gt;ha
)paren
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 1
id|printk
c_func
(paren
l_string|&quot;arp_set_hh: %08x is reattached. Good!&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if RT_CACHE_DEBUG &gt;= 1
r_else
r_if
c_cond
(paren
id|entry
)paren
id|printk
c_func
(paren
l_string|&quot;arp_set_hh: %08x rr1 ok!&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|hh-&gt;hh_refcnt
)paren
)paren
id|kfree_s
c_func
(paren
id|hh
comma
r_sizeof
(paren
r_struct
id|hh_cache
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|arp_alloc_hh
r_static
id|__inline__
r_struct
id|hh_cache
op_star
id|arp_alloc_hh
c_func
(paren
r_int
id|htype
)paren
(brace
r_struct
id|hh_cache
op_star
id|hh
suffix:semicolon
id|hh
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|hh_cache
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hh
)paren
(brace
id|memset
c_func
(paren
id|hh
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|hh_cache
)paren
)paren
suffix:semicolon
id|hh-&gt;hh_type
op_assign
id|htype
suffix:semicolon
)brace
r_return
id|hh
suffix:semicolon
)brace
multiline_comment|/*&n; * Test if a hardware address is all zero&n; */
DECL|function|empty
r_static
id|__inline__
r_int
id|empty
c_func
(paren
r_int
r_char
op_star
id|addr
comma
r_int
id|len
)paren
(brace
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_star
id|addr
)paren
r_return
l_int|0
suffix:semicolon
id|len
op_decrement
suffix:semicolon
id|addr
op_increment
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_ARPD
multiline_comment|/*&n; *&t;Send ARPD message.&n; */
DECL|function|arpd_send
r_static
r_void
id|arpd_send
c_func
(paren
r_int
id|req
comma
id|u32
id|addr
comma
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|ha
comma
r_int
r_int
id|updated
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|arpd_request
op_star
id|arpreq
suffix:semicolon
r_if
c_cond
(paren
id|arpd_not_running
)paren
r_return
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
r_sizeof
(paren
r_struct
id|arpd_request
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
id|arpreq
op_assign
(paren
r_struct
id|arpd_request
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|arpd_request
)paren
)paren
suffix:semicolon
id|arpreq-&gt;req
op_assign
id|req
suffix:semicolon
id|arpreq-&gt;ip
op_assign
id|addr
suffix:semicolon
id|arpreq-&gt;dev
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
id|arpreq-&gt;stamp
op_assign
id|arpd_stamp
suffix:semicolon
id|arpreq-&gt;updated
op_assign
id|updated
suffix:semicolon
r_if
c_cond
(paren
id|ha
)paren
id|memcpy
c_func
(paren
id|arpreq-&gt;ha
comma
id|ha
comma
r_sizeof
(paren
id|arpreq-&gt;ha
)paren
)paren
suffix:semicolon
id|retval
op_assign
id|netlink_post
c_func
(paren
id|NETLINK_ARPD
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
op_minus
id|EUNATCH
)paren
id|arpd_not_running
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Send ARPD update message.&n; */
DECL|function|arpd_update
r_static
id|__inline__
r_void
id|arpd_update
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_if
c_cond
(paren
id|arpd_not_running
)paren
r_return
suffix:semicolon
id|arpd_send
c_func
(paren
id|ARPD_UPDATE
comma
id|entry-&gt;ip
comma
id|entry-&gt;dev
comma
id|entry-&gt;ha
comma
id|entry-&gt;last_updated
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send ARPD lookup request.&n; */
DECL|function|arpd_lookup
r_static
id|__inline__
r_void
id|arpd_lookup
c_func
(paren
id|u32
id|addr
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|arpd_not_running
)paren
r_return
suffix:semicolon
id|arpd_send
c_func
(paren
id|ARPD_LOOKUP
comma
id|addr
comma
id|dev
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send ARPD flush message.&n; */
DECL|function|arpd_flush
r_static
id|__inline__
r_void
id|arpd_flush
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|arpd_not_running
)paren
r_return
suffix:semicolon
id|arpd_send
c_func
(paren
id|ARPD_FLUSH
comma
l_int|0
comma
id|dev
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|arpd_callback
r_static
r_int
id|arpd_callback
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_struct
id|arpd_request
op_star
id|retreq
suffix:semicolon
id|arpd_not_running
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
op_ne
r_sizeof
(paren
r_struct
id|arpd_request
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|retreq
op_assign
(paren
r_struct
id|arpd_request
op_star
)paren
id|skb-&gt;data
suffix:semicolon
id|dev
op_assign
(paren
r_struct
id|device
op_star
)paren
id|retreq-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|retreq-&gt;stamp
op_ne
id|arpd_stamp
op_logical_or
op_logical_neg
id|dev
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|retreq-&gt;updated
op_logical_or
id|empty
c_func
(paren
id|retreq-&gt;ha
comma
r_sizeof
(paren
id|retreq-&gt;ha
)paren
)paren
)paren
(brace
multiline_comment|/*&n; *&t;Invalid mapping: drop it and send ARP broadcast.&n; */
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|retreq-&gt;ip
comma
id|dev
comma
id|dev-&gt;pa_addr
comma
l_int|NULL
comma
id|dev-&gt;dev_addr
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
id|arp_update
c_func
(paren
id|retreq-&gt;ip
comma
id|retreq-&gt;ha
comma
id|dev
comma
id|retreq-&gt;updated
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
r_sizeof
(paren
r_struct
id|arpd_request
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|arpd_update
r_static
id|__inline__
r_void
id|arpd_update
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ARPD */
multiline_comment|/*&n; *&t;ARP expiration routines.&n; */
multiline_comment|/*&n; *&t;Force the expiry of an entry in the internal cache so the memory&n; *&t;can be used for a new request.&n; */
DECL|function|arp_force_expire
r_static
r_int
id|arp_force_expire
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|arp_table
op_star
id|entry
comma
op_star
op_star
id|pentry
suffix:semicolon
r_struct
id|arp_table
op_star
op_star
id|oldest_entry
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|oldest_used
op_assign
op_complement
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_static
id|last_index
suffix:semicolon
r_if
c_cond
(paren
id|ARP_LOCKED
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_index
op_ge
id|ARP_TABLE_SIZE
)paren
id|last_index
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARP_TABLE_SIZE
suffix:semicolon
id|i
op_increment
comma
id|last_index
op_increment
)paren
(brace
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|last_index
op_amp
(paren
id|ARP_TABLE_SIZE
op_minus
l_int|1
)paren
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
op_star
id|pentry
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_PERM
)paren
)paren
(brace
r_int
id|users
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|users
op_assign
id|arp_count_hhs
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|users
op_logical_and
id|now
op_minus
id|entry-&gt;last_used
OG
id|sysctl_arp_timeout
)paren
(brace
op_star
id|pentry
op_assign
id|entry-&gt;next
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;arp_force_expire: %08x expired&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
id|arp_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|result
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|arp_size
OL
id|ARP_MAXSIZE
)paren
r_goto
id|done
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|users
op_logical_and
id|entry-&gt;last_used
OL
id|oldest_used
)paren
(brace
id|oldest_entry
op_assign
id|pentry
suffix:semicolon
id|oldest_used
op_assign
id|entry-&gt;last_used
suffix:semicolon
)brace
)brace
id|pentry
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
)brace
)brace
id|done
suffix:colon
r_if
c_cond
(paren
id|result
op_logical_or
op_logical_neg
id|oldest_entry
)paren
r_return
id|result
suffix:semicolon
id|entry
op_assign
op_star
id|oldest_entry
suffix:semicolon
op_star
id|oldest_entry
op_assign
id|entry-&gt;next
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;arp_force_expire: expiring %08x&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
id|arp_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Check if there are entries that are too old and remove them. If the&n; *&t;ATF_PERM flag is set, they are always left in the arp cache (permanent&n; *      entries). If an entry was not confirmed for ARP_CONFIRM_INTERVAL,&n; *&t;send point-to-point ARP request.&n; *&t;If it will not be confirmed for ARP_CONFIRM_TIMEOUT,&n; *&t;give it to shred by arp_expire_entry.&n; */
DECL|function|arp_check_expire
r_static
r_void
id|arp_check_expire
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|arp_timer
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ARPD
id|arpd_not_running
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|ip_rt_check_expire
c_func
(paren
)paren
suffix:semicolon
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ARP_LOCKED
c_func
(paren
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARP_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
comma
op_star
op_star
id|pentry
suffix:semicolon
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
op_star
id|pentry
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|ATF_PERM
)paren
(brace
id|pentry
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|now
op_minus
id|entry-&gt;last_used
OG
id|sysctl_arp_timeout
op_logical_and
op_logical_neg
id|arp_count_hhs
c_func
(paren
id|entry
)paren
)paren
(brace
op_star
id|pentry
op_assign
id|entry-&gt;next
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;arp_expire: %08x expired&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
id|arp_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;last_updated
op_logical_and
id|now
op_minus
id|entry-&gt;last_updated
OG
id|sysctl_arp_confirm_interval
op_logical_and
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_PERM
)paren
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|entry-&gt;dev
suffix:semicolon
id|entry-&gt;retries
op_assign
id|sysctl_arp_max_tries
op_plus
id|sysctl_arp_max_pings
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|ARP_CONFIRM_TIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|entry-&gt;ip
comma
id|dev
comma
id|dev-&gt;pa_addr
comma
id|entry-&gt;ha
comma
id|dev-&gt;dev_addr
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;arp_expire: %08x requires confirmation&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
)brace
id|pentry
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
multiline_comment|/* go to next entry */
)brace
)brace
)brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Set the timer again.&n;&t; */
id|arp_timer.expires
op_assign
id|jiffies
op_plus
id|sysctl_arp_check_interval
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|arp_timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This function is called, if an entry is not resolved in ARP_RES_TIME.&n; *&t;When more than MAX_ARP_TRIES retries was done, release queued skb&squot;s,&n; *&t;but not discard entry itself if  it is in use.&n; */
DECL|function|arp_expire_request
r_static
r_void
id|arp_expire_request
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
op_assign
(paren
r_struct
id|arp_table
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|arp_table
op_star
op_star
id|pentry
suffix:semicolon
r_int
r_int
id|hash
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If arp table is locked, defer expire processing.&n;&t; */
r_if
c_cond
(paren
id|ARP_LOCKED
c_func
(paren
)paren
)paren
(brace
macro_line|#if RT_CACHE_DEBUG &gt;= 1
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;arp_expire_request: %08x deferred&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
id|entry-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|10
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Since all timeouts are handled with interrupts enabled, there is a&n;&t; *&t;small chance, that this entry has just been resolved by an incoming&n;&t; *&t;packet. This is the only race condition, but it is handled...&n;&t; *&n;&t; *&t;One exception: if entry is COMPLETE but old,&n;&t; *&t;it means that point-to-point ARP ping has been failed&n;&t; *&t;(It really occurs with Cisco 4000 routers)&n;&t; *&t;We should reconfirm it.&n;&t; */
r_if
c_cond
(paren
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
op_logical_and
id|entry-&gt;last_updated
op_logical_and
id|jiffies
op_minus
id|entry-&gt;last_updated
op_le
id|sysctl_arp_confirm_interval
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;last_updated
op_logical_and
op_decrement
id|entry-&gt;retries
OG
l_int|0
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|entry-&gt;dev
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;arp_expire_request: %08x timed out&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Set new timer. */
id|entry-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|sysctl_arp_res_time
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|entry-&gt;ip
comma
id|dev
comma
id|dev-&gt;pa_addr
comma
id|entry-&gt;retries
OG
id|sysctl_arp_max_tries
ques
c_cond
id|entry-&gt;ha
suffix:colon
l_int|NULL
comma
id|dev-&gt;dev_addr
comma
l_int|NULL
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;The host is really dead.&n;&t; */
id|arp_purge_send_q
c_func
(paren
id|entry
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arp_count_hhs
c_func
(paren
id|entry
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;The host is dead, but someone refers to it.&n;&t;&t; *&t;It is useless to drop this entry just now,&n;&t;&t; *&t;it will be born again, so that&n;&t;&t; *&t;we keep it, but slow down retransmitting&n;&t;&t; *&t;to ARP_DEAD_RES_TIME.&n;&t;&t; */
r_struct
id|device
op_star
id|dev
op_assign
id|entry-&gt;dev
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;arp_expire_request: %08x is dead&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
id|entry-&gt;retries
op_assign
id|sysctl_arp_max_tries
suffix:semicolon
id|entry-&gt;flags
op_and_assign
op_complement
id|ATF_COM
suffix:semicolon
id|arp_invalidate_hhs
c_func
(paren
id|entry
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Declare the entry dead.&n;&t;&t; */
id|entry-&gt;last_updated
op_assign
l_int|0
suffix:semicolon
id|arpd_update
c_func
(paren
id|entry
)paren
suffix:semicolon
id|entry-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|sysctl_arp_dead_res_time
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|entry-&gt;ip
comma
id|dev
comma
id|dev-&gt;pa_addr
comma
l_int|NULL
comma
id|dev-&gt;dev_addr
comma
l_int|NULL
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|entry-&gt;last_updated
op_assign
l_int|0
suffix:semicolon
id|arpd_update
c_func
(paren
id|entry
)paren
suffix:semicolon
id|hash
op_assign
id|HASH
c_func
(paren
id|entry-&gt;ip
)paren
suffix:semicolon
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pentry
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_star
id|pentry
op_ne
id|entry
)paren
(brace
id|pentry
op_assign
op_amp
(paren
op_star
id|pentry
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_continue
suffix:semicolon
)brace
op_star
id|pentry
op_assign
id|entry-&gt;next
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;arp_expire_request: %08x is killed&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
id|arp_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Allocate memory for a new entry.  If we are at the maximum limit&n; * of the internal ARP cache, arp_force_expire() an entry.  NOTE:  &n; * arp_force_expire() needs the cache to be locked, so therefore&n; * arp_alloc_entry() should only be called with the cache locked too!&n; */
DECL|function|arp_alloc_entry
r_static
r_struct
id|arp_table
op_star
id|arp_alloc_entry
c_func
(paren
r_void
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|arp_size
op_ge
id|ARP_MAXSIZE
)paren
id|arp_force_expire
c_func
(paren
)paren
suffix:semicolon
id|entry
op_assign
(paren
r_struct
id|arp_table
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arp_table
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_ne
l_int|NULL
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|arp_size
)paren
suffix:semicolon
id|memset
c_func
(paren
id|entry
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|arp_table
)paren
)paren
suffix:semicolon
id|entry-&gt;mask
op_assign
id|DEF_ARP_NETMASK
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;timer.function
op_assign
id|arp_expire_request
suffix:semicolon
id|entry-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|entry
suffix:semicolon
id|entry-&gt;last_updated
op_assign
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
suffix:semicolon
)brace
r_return
id|entry
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Purge a device from the ARP queue&n; */
DECL|function|arp_device_event
r_int
id|arp_device_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|event
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|ptr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|event
op_ne
id|NETDEV_DOWN
)paren
r_return
id|NOTIFY_DONE
suffix:semicolon
macro_line|#ifdef  CONFIG_ARPD
id|arpd_flush
c_func
(paren
id|dev
)paren
suffix:semicolon
id|arpd_stamp
op_increment
suffix:semicolon
macro_line|#endif
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 1&t; 
r_if
c_cond
(paren
id|ARP_LOCKED
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;arp_device_event: impossible&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FULL_ARP_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|arp_table
op_star
op_star
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
op_star
id|pentry
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;dev
op_eq
id|dev
)paren
(brace
op_star
id|pentry
op_assign
id|entry-&gt;next
suffix:semicolon
multiline_comment|/* remove from list */
id|arp_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
r_else
id|pentry
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
multiline_comment|/* go to next entry */
)brace
)brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This will try to retransmit everything on the queue.&n; */
DECL|function|arp_send_q
r_static
r_void
id|arp_send_q
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Empty the entire queue, building its data up ready to send&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;arp_send_q: incomplete entry for %s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|entry-&gt;ip
)paren
)paren
suffix:semicolon
multiline_comment|/* Can&squot;t flush the skb, because RFC1122 says to hang on to */
multiline_comment|/* at least one from any unresolved entry.  --MS */
multiline_comment|/* What&squot;s happened is that someone has &squot;unresolved&squot; the entry&n;&t;&t;   as we got to use it - this &squot;can&squot;t happen&squot; -- AC */
r_return
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb_device_lock
c_func
(paren
id|skb
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;dev
op_member_access_from_pointer
id|rebuild_header
c_func
(paren
id|skb-&gt;data
comma
id|skb-&gt;dev
comma
id|skb-&gt;raddr
comma
id|skb
)paren
)paren
(brace
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;sk
op_eq
l_int|NULL
)paren
(brace
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
id|skb-&gt;sk-&gt;priority
)paren
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|arp_update
id|arp_update
(paren
id|u32
id|sip
comma
r_char
op_star
id|sha
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|updated
comma
r_struct
id|arp_table
op_star
id|ientry
comma
r_int
id|grat
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_int
r_int
id|hash
suffix:semicolon
r_int
id|do_arpd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|updated
op_eq
l_int|0
)paren
(brace
id|updated
op_assign
id|jiffies
suffix:semicolon
id|do_arpd
op_assign
l_int|1
suffix:semicolon
)brace
id|hash
op_assign
id|HASH
c_func
(paren
id|sip
)paren
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|entry
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|sip
op_logical_and
id|entry-&gt;dev
op_eq
id|dev
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
(brace
multiline_comment|/*&n; *&t;Entry found; update it only if it is not a permanent entry.&n; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_PERM
)paren
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;last_updated
op_assign
id|updated
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|entry-&gt;ha
comma
id|sha
comma
id|dev-&gt;addr_len
)paren
op_ne
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|entry-&gt;ha
comma
id|sha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
id|arp_update_hhs
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_arpd
)paren
id|arpd_update
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
)paren
(brace
multiline_comment|/*&n; *&t;This entry was incomplete.  Delete the retransmit timer&n; *&t;and switch to complete status.&n; */
id|entry-&gt;flags
op_or_assign
id|ATF_COM
suffix:semicolon
id|arp_update_hhs
c_func
(paren
id|entry
)paren
suffix:semicolon
multiline_comment|/* &n; *&t;Send out waiting packets. We might have problems, if someone is &n; *&t;manually removing entries right now -- entry might become invalid &n; *&t;underneath us.&n; */
id|arp_send_q
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;No entry found.  Need to add a new entry to the arp table.&n; */
id|entry
op_assign
id|ientry
suffix:semicolon
r_if
c_cond
(paren
id|grat
op_logical_and
op_logical_neg
id|entry
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
(brace
id|entry
op_assign
id|arp_alloc_entry
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_return
l_int|0
suffix:semicolon
id|entry-&gt;ip
op_assign
id|sip
suffix:semicolon
id|entry-&gt;flags
op_assign
id|ATF_COM
suffix:semicolon
id|memcpy
c_func
(paren
id|entry-&gt;ha
comma
id|sha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|entry-&gt;dev
op_assign
id|dev
suffix:semicolon
)brace
id|entry-&gt;last_updated
op_assign
id|updated
suffix:semicolon
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|do_arpd
)paren
id|arpd_update
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ARP_LOCKED
c_func
(paren
)paren
)paren
(brace
id|entry-&gt;next
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|arp_tables
(braket
id|hash
)braket
op_assign
id|entry
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;arp_update: %08x backlogged&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
id|arp_enqueue
c_func
(paren
op_amp
id|arp_backlog
comma
id|entry
)paren
suffix:semicolon
id|arp_bh_mask
op_or_assign
id|ARP_BH_BACKLOG
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|arp_lookup
r_static
id|__inline__
r_struct
id|arp_table
op_star
id|arp_lookup
c_func
(paren
id|u32
id|paddr
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|arp_tables
(braket
id|HASH
c_func
(paren
id|paddr
)paren
)braket
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|paddr
op_logical_and
(paren
op_logical_neg
id|dev
op_logical_or
id|entry-&gt;dev
op_eq
id|dev
)paren
)paren
r_return
id|entry
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Find an arp mapping in the cache. If not found, return false.&n; */
DECL|function|arp_query
r_int
id|arp_query
c_func
(paren
r_int
r_char
op_star
id|haddr
comma
id|u32
id|paddr
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
id|entry
op_assign
id|arp_lookup
c_func
(paren
id|paddr
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_ne
l_int|NULL
)paren
(brace
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
(brace
id|memcpy
c_func
(paren
id|haddr
comma
id|entry-&gt;ha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|arp_set_predefined
r_static
r_int
id|arp_set_predefined
c_func
(paren
r_int
id|addr_hint
comma
r_int
r_char
op_star
id|haddr
comma
id|u32
id|paddr
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_switch
c_cond
(paren
id|addr_hint
)paren
(brace
r_case
id|IS_MYADDR
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ARP: arp called for own IP address&bslash;n&quot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|haddr
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_IP_MULTICAST
r_case
id|IS_MULTICAST
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|ARPHRD_ETHER
op_logical_or
id|dev-&gt;type
op_eq
id|ARPHRD_IEEE802
)paren
(brace
id|u32
id|taddr
suffix:semicolon
id|haddr
(braket
l_int|0
)braket
op_assign
l_int|0x01
suffix:semicolon
id|haddr
(braket
l_int|1
)braket
op_assign
l_int|0x00
suffix:semicolon
id|haddr
(braket
l_int|2
)braket
op_assign
l_int|0x5e
suffix:semicolon
id|taddr
op_assign
id|ntohl
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|haddr
(braket
l_int|5
)braket
op_assign
id|taddr
op_amp
l_int|0xff
suffix:semicolon
id|taddr
op_assign
id|taddr
op_rshift
l_int|8
suffix:semicolon
id|haddr
(braket
l_int|4
)braket
op_assign
id|taddr
op_amp
l_int|0xff
suffix:semicolon
id|taddr
op_assign
id|taddr
op_rshift
l_int|8
suffix:semicolon
id|haddr
(braket
l_int|3
)braket
op_assign
id|taddr
op_amp
l_int|0x7f
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;If a device does not support multicast broadcast the stuff (eg AX.25 for now)&n;&t;&t; */
macro_line|#endif
r_case
id|IS_BROADCAST
suffix:colon
id|memcpy
c_func
(paren
id|haddr
comma
id|dev-&gt;broadcast
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Create a new unresolved entry.&n; */
DECL|function|arp_new_entry
r_struct
id|arp_table
op_star
id|arp_new_entry
c_func
(paren
id|u32
id|paddr
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|hh_cache
op_star
id|hh
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
id|entry
op_assign
id|arp_alloc_entry
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_ne
l_int|NULL
)paren
(brace
id|entry-&gt;ip
op_assign
id|paddr
suffix:semicolon
id|entry-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|hh
)paren
(brace
id|entry-&gt;hh
op_assign
id|hh
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|hh-&gt;hh_refcnt
)paren
suffix:semicolon
id|hh-&gt;hh_arp
op_assign
(paren
r_void
op_star
)paren
id|entry
suffix:semicolon
)brace
id|entry-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|sysctl_arp_res_time
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|skb_queue_tail
c_func
(paren
op_amp
id|entry-&gt;skb
comma
id|skb
)paren
suffix:semicolon
id|skb_device_unlock
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ARP_LOCKED
c_func
(paren
)paren
)paren
(brace
r_int
r_int
id|hash
op_assign
id|HASH
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|entry-&gt;next
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|arp_tables
(braket
id|hash
)braket
op_assign
id|entry
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;retries
op_assign
id|sysctl_arp_max_tries
suffix:semicolon
macro_line|#ifdef CONFIG_ARPD
r_if
c_cond
(paren
op_logical_neg
id|arpd_not_running
)paren
id|arpd_lookup
c_func
(paren
id|paddr
comma
id|dev
)paren
suffix:semicolon
r_else
macro_line|#endif
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|paddr
comma
id|dev
comma
id|dev-&gt;pa_addr
comma
l_int|NULL
comma
id|dev-&gt;dev_addr
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;arp_new_entry: %08x backlogged&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
id|arp_enqueue
c_func
(paren
op_amp
id|arp_req_backlog
comma
id|entry
)paren
suffix:semicolon
id|arp_bh_mask
op_or_assign
id|ARP_BH_BACKLOG
suffix:semicolon
)brace
)brace
r_return
id|entry
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Find an arp mapping in the cache. If not found, post a request.&n; */
DECL|function|arp_find
r_int
id|arp_find
c_func
(paren
r_int
r_char
op_star
id|haddr
comma
id|u32
id|paddr
comma
r_struct
id|device
op_star
id|dev
comma
id|u32
id|saddr
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_int
r_int
id|hash
suffix:semicolon
r_if
c_cond
(paren
id|arp_set_predefined
c_func
(paren
id|ip_chk_addr
c_func
(paren
id|paddr
)paren
comma
id|haddr
comma
id|paddr
comma
id|dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|skb
)paren
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|hash
op_assign
id|HASH
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Find an entry&n;&t; */
id|entry
op_assign
id|arp_lookup
c_func
(paren
id|paddr
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_ne
l_int|NULL
)paren
multiline_comment|/* It exists */
(brace
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
(brace
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|memcpy
c_func
(paren
id|haddr
comma
id|entry-&gt;ha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;A request was already sent, but no reply yet. Thus&n;&t;&t; *&t;queue the packet with the previous attempt&n;&t;&t; */
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;last_updated
)paren
(brace
id|skb_queue_tail
c_func
(paren
op_amp
id|entry-&gt;skb
comma
id|skb
)paren
suffix:semicolon
id|skb_device_unlock
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If last_updated==0 host is dead, so&n;&t;&t;&t; * drop skb&squot;s and set socket error.&n;&t;&t;&t; */
r_else
(brace
id|icmp_send
c_func
(paren
id|skb
comma
id|ICMP_DEST_UNREACH
comma
id|ICMP_HOST_UNREACH
comma
l_int|0
comma
id|dev
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
)brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|entry
op_assign
id|arp_new_entry
c_func
(paren
id|paddr
comma
id|dev
comma
l_int|NULL
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
op_logical_and
op_logical_neg
id|entry
)paren
id|dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Binding hardware header cache entry.&n; *&t;It is the only really complicated part of arp code.&n; *&t;We have no locking for hh records, so that&n; *&t;all possible race conditions should be resolved by&n; *&t;cli()/sti() pairs.&n; *&n; *&t;Important note: hhs never disappear from lists, if ARP_LOCKED,&n; *&t;this fact allows to scan hh lists with enabled interrupts,&n; *&t;but results in generating duplicate hh entries.&n; *&t;It is harmless. (and I&squot;ve never seen such event)&n; *&n; *&t;Returns 0, if hh has been just created, so that&n; *&t;caller should fill it.&n; */
DECL|function|arp_bind_cache
r_int
id|arp_bind_cache
c_func
(paren
r_struct
id|hh_cache
op_star
op_star
id|hhp
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|htype
comma
id|u32
id|paddr
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|hh_cache
op_star
id|hh
suffix:semicolon
r_int
id|addr_hint
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr_hint
op_assign
id|ip_chk_addr
c_func
(paren
id|paddr
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_int
r_char
id|haddr
(braket
id|MAX_ADDR_LEN
)braket
suffix:semicolon
r_if
c_cond
(paren
op_star
id|hhp
)paren
r_return
l_int|1
suffix:semicolon
id|hh
op_assign
id|arp_alloc_hh
c_func
(paren
id|htype
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hh
)paren
r_return
l_int|1
suffix:semicolon
id|arp_set_predefined
c_func
(paren
id|addr_hint
comma
id|haddr
comma
id|paddr
comma
id|dev
)paren
suffix:semicolon
id|dev
op_member_access_from_pointer
id|header_cache_update
c_func
(paren
id|hh
comma
id|dev
comma
id|haddr
)paren
suffix:semicolon
r_return
id|arp_set_hh
c_func
(paren
id|hhp
comma
id|hh
)paren
suffix:semicolon
)brace
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
id|entry
op_assign
id|arp_lookup
c_func
(paren
id|paddr
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
(brace
r_for
c_loop
(paren
id|hh
op_assign
id|entry-&gt;hh
suffix:semicolon
id|hh
suffix:semicolon
id|hh
op_assign
id|hh-&gt;hh_next
)paren
r_if
c_cond
(paren
id|hh-&gt;hh_type
op_eq
id|htype
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|hh
)paren
(brace
id|arp_set_hh
c_func
(paren
id|hhp
comma
id|hh
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|hh
op_assign
id|arp_alloc_hh
c_func
(paren
id|htype
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hh
)paren
(brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|hh-&gt;hh_arp
op_assign
(paren
r_void
op_star
)paren
id|entry
suffix:semicolon
id|hh-&gt;hh_next
op_assign
id|entry-&gt;hh
suffix:semicolon
id|entry-&gt;hh
op_assign
id|hh
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|hh-&gt;hh_refcnt
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
id|dev
op_member_access_from_pointer
id|header_cache_update
c_func
(paren
id|hh
comma
id|dev
comma
id|entry-&gt;ha
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arp_set_hh
c_func
(paren
id|hhp
comma
id|hh
)paren
)paren
(brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|entry
op_assign
id|arp_new_entry
c_func
(paren
id|paddr
comma
id|dev
comma
id|hh
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
(brace
id|kfree_s
c_func
(paren
id|hh
comma
r_sizeof
(paren
r_struct
id|hh_cache
)paren
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|arp_set_hh
c_func
(paren
id|hhp
comma
id|hh
)paren
)paren
(brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|arp_run_bh
r_static
r_void
id|arp_run_bh
c_func
(paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|arp_table
op_star
id|entry
comma
op_star
id|entry1
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_int
r_int
id|hash
suffix:semicolon
r_struct
id|hh_cache
op_star
id|hh
suffix:semicolon
id|u32
id|sip
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|arp_bh_mask
)paren
(brace
id|arp_bh_mask
op_and_assign
op_complement
id|ARP_BH_BACKLOG
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
id|arp_dequeue
c_func
(paren
op_amp
id|arp_backlog
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arp_update
c_func
(paren
id|entry-&gt;ip
comma
id|entry-&gt;ha
comma
id|entry-&gt;dev
comma
l_int|0
comma
id|entry
comma
l_int|0
)paren
)paren
id|arp_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
id|arp_dequeue
c_func
(paren
op_amp
id|arp_req_backlog
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|dev
op_assign
id|entry-&gt;dev
suffix:semicolon
id|sip
op_assign
id|entry-&gt;ip
suffix:semicolon
id|hash
op_assign
id|HASH
c_func
(paren
id|sip
)paren
suffix:semicolon
r_for
c_loop
(paren
id|entry1
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|entry1
suffix:semicolon
id|entry1
op_assign
id|entry1-&gt;next
)paren
r_if
c_cond
(paren
id|entry1-&gt;ip
op_eq
id|sip
op_logical_and
id|entry1-&gt;dev
op_eq
id|dev
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry1
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|entry-&gt;next
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|arp_tables
(braket
id|hash
)braket
op_assign
id|entry
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|entry-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|sysctl_arp_res_time
suffix:semicolon
id|entry-&gt;retries
op_assign
id|sysctl_arp_max_tries
suffix:semicolon
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
)paren
(brace
id|add_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ARPD
r_if
c_cond
(paren
op_logical_neg
id|arpd_not_running
)paren
id|arpd_lookup
c_func
(paren
id|sip
comma
id|dev
)paren
suffix:semicolon
r_else
macro_line|#endif
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|sip
comma
id|dev
comma
id|dev-&gt;pa_addr
comma
l_int|NULL
comma
id|dev-&gt;dev_addr
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#if RT_CACHE_DEBUG &gt;= 1
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;arp_run_bh: %08x reinstalled&bslash;n&quot;
comma
id|sip
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|hh_cache
op_star
id|next
suffix:semicolon
multiline_comment|/* Discard entry, but preserve its hh&squot;s and&n;&t;&t;&t;&t; * skb&squot;s.&n;&t;&t;&t;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|hh
op_assign
id|entry-&gt;hh
suffix:semicolon
id|hh
suffix:semicolon
id|hh
op_assign
id|next
)paren
(brace
id|next
op_assign
id|hh-&gt;hh_next
suffix:semicolon
id|hh-&gt;hh_next
op_assign
id|entry1-&gt;hh
suffix:semicolon
id|entry1-&gt;hh
op_assign
id|hh
suffix:semicolon
id|hh-&gt;hh_arp
op_assign
(paren
r_void
op_star
)paren
id|entry1
suffix:semicolon
)brace
id|entry-&gt;hh
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Prune skb list from entry&n;&t;&t;&t;&t; * and graft it to entry1.&n;&t;&t;&t;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|skb_device_lock
c_func
(paren
id|skb
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|entry1-&gt;skb
comma
id|skb
)paren
suffix:semicolon
id|skb_device_unlock
c_func
(paren
id|skb
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|arp_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry1-&gt;flags
op_amp
id|ATF_COM
)paren
(brace
id|arp_update_hhs
c_func
(paren
id|entry1
)paren
suffix:semicolon
id|arp_send_q
c_func
(paren
id|entry1
)paren
suffix:semicolon
)brace
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Interface to link layer: send routine and receive handler.&n; */
multiline_comment|/*&n; *&t;Create and send an arp packet. If (dest_hw == NULL), we create a broadcast&n; *&t;message.&n; */
DECL|function|arp_send
r_void
id|arp_send
c_func
(paren
r_int
id|type
comma
r_int
id|ptype
comma
id|u32
id|dest_ip
comma
r_struct
id|device
op_star
id|dev
comma
id|u32
id|src_ip
comma
r_int
r_char
op_star
id|dest_hw
comma
r_int
r_char
op_star
id|src_hw
comma
r_int
r_char
op_star
id|target_hw
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|arphdr
op_star
id|arp
suffix:semicolon
r_int
r_char
op_star
id|arp_ptr
suffix:semicolon
multiline_comment|/*&n;&t; *&t;No arp on this interface.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_NOARP
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate a buffer&n;&t; */
id|skb
op_assign
id|alloc_skb
c_func
(paren
r_sizeof
(paren
r_struct
id|arphdr
)paren
op_plus
l_int|2
op_star
(paren
id|dev-&gt;addr_len
op_plus
l_int|4
)paren
op_plus
id|dev-&gt;hard_header_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ARP: no memory to send an arp packet&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
id|arp
op_assign
(paren
r_struct
id|arphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|arphdr
)paren
op_plus
l_int|2
op_star
(paren
id|dev-&gt;addr_len
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
(paren
id|ETH_P_IP
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fill the device header for the ARP frame&n;&t; */
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|skb
comma
id|dev
comma
id|ptype
comma
id|dest_hw
ques
c_cond
id|dest_hw
suffix:colon
id|dev-&gt;broadcast
comma
id|src_hw
ques
c_cond
id|src_hw
suffix:colon
l_int|NULL
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Fill out the arp protocol part. */
id|arp-&gt;ar_hrd
op_assign
id|htons
c_func
(paren
id|dev-&gt;type
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_AX25
macro_line|#ifdef CONFIG_NETROM
id|arp-&gt;ar_pro
op_assign
(paren
id|dev-&gt;type
op_eq
id|ARPHRD_AX25
op_logical_or
id|dev-&gt;type
op_eq
id|ARPHRD_NETROM
)paren
ques
c_cond
id|htons
c_func
(paren
id|AX25_P_IP
)paren
suffix:colon
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
macro_line|#else
id|arp-&gt;ar_pro
op_assign
(paren
id|dev-&gt;type
op_ne
id|ARPHRD_AX25
)paren
ques
c_cond
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:colon
id|htons
c_func
(paren
id|AX25_P_IP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#else
id|arp-&gt;ar_pro
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
macro_line|#endif
id|arp-&gt;ar_hln
op_assign
id|dev-&gt;addr_len
suffix:semicolon
id|arp-&gt;ar_pln
op_assign
l_int|4
suffix:semicolon
id|arp-&gt;ar_op
op_assign
id|htons
c_func
(paren
id|type
)paren
suffix:semicolon
id|arp_ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|arp
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|arp_ptr
comma
id|src_hw
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
id|arp_ptr
comma
op_amp
id|src_ip
comma
l_int|4
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|target_hw
op_ne
l_int|NULL
)paren
id|memcpy
c_func
(paren
id|arp_ptr
comma
id|target_hw
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_else
id|memset
c_func
(paren
id|arp_ptr
comma
l_int|0
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
id|arp_ptr
comma
op_amp
id|dest_ip
comma
l_int|4
)paren
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Receive an arp request by the device layer.&n; */
DECL|function|arp_rcv
r_int
id|arp_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
multiline_comment|/*&n; *&t;We shouldn&squot;t use this type conversion. Check later.&n; */
r_struct
id|arphdr
op_star
id|arp
op_assign
(paren
r_struct
id|arphdr
op_star
)paren
id|skb-&gt;h.raw
suffix:semicolon
r_int
r_char
op_star
id|arp_ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|arp
op_plus
l_int|1
)paren
suffix:semicolon
r_int
r_char
op_star
id|sha
comma
op_star
id|tha
suffix:semicolon
id|u32
id|sip
comma
id|tip
suffix:semicolon
multiline_comment|/*&n; *&t;The hardware length of the packet should match the hardware length&n; *&t;of the device.  Similarly, the hardware types should match.  The&n; *&t;device should be ARP-able.  Also, if pln is not 4, then the lookup&n; *&t;is not from an IP number.  We can&squot;t currently handle this, so toss&n; *&t;it. &n; */
r_if
c_cond
(paren
id|arp-&gt;ar_hln
op_ne
id|dev-&gt;addr_len
op_logical_or
id|dev-&gt;type
op_ne
id|ntohs
c_func
(paren
id|arp-&gt;ar_hrd
)paren
op_logical_or
id|dev-&gt;flags
op_amp
id|IFF_NOARP
op_logical_or
id|arp-&gt;ar_pln
op_ne
l_int|4
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Should this be an error/printk?  Seems like something */
multiline_comment|/* you&squot;d want to know about. Unless it&squot;s just !IFF_NOARP. -- MS */
)brace
multiline_comment|/*&n; *&t;Another test.&n; *&t;The logic here is that the protocol being looked up by arp should &n; *&t;match the protocol the device speaks.  If it doesn&squot;t, there is a&n; *&t;problem, so toss the packet.&n; */
multiline_comment|/* Again, should this be an error/printk? -- MS */
r_switch
c_cond
(paren
id|dev-&gt;type
)paren
(brace
macro_line|#ifdef CONFIG_AX25
r_case
id|ARPHRD_AX25
suffix:colon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|AX25_P_IP
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NETROM
r_case
id|ARPHRD_NETROM
suffix:colon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|AX25_P_IP
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#endif
r_case
id|ARPHRD_ETHER
suffix:colon
r_case
id|ARPHRD_ARCNET
suffix:colon
r_case
id|ARPHRD_METRICOM
suffix:colon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ARPHRD_IEEE802
suffix:colon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ARP: dev-&gt;type mangled!&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Extract fields&n; */
id|sha
op_assign
id|arp_ptr
suffix:semicolon
id|arp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|sip
comma
id|arp_ptr
comma
l_int|4
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
l_int|4
suffix:semicolon
id|tha
op_assign
id|arp_ptr
suffix:semicolon
id|arp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|tip
comma
id|arp_ptr
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* &n; *&t;Check for bad requests for 127.x.x.x and requests for multicast&n; *&t;addresses.  If this is one such, delete it.&n; */
r_if
c_cond
(paren
id|LOOPBACK
c_func
(paren
id|tip
)paren
op_logical_or
id|MULTICAST
c_func
(paren
id|tip
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Process entry.  The idea here is we want to send a reply if it is a&n; *  request for us or if it is a request for someone else that we hold&n; *  a proxy for.  We want to add an entry to our cache if it is a reply&n; *  to us or if it is a request for our address.  &n; *  (The assumption for this last is that if someone is requesting our &n; *  address, they are probably intending to talk to us, so it saves time &n; *  if we cache their address.  Their address is also probably not in &n; *  our cache, since ours is not in their cache.)&n; * &n; *  Putting this another way, we only care about replies if they are to&n; *  us, in which case we add them to the cache.  For requests, we care&n; *  about those for us and those for our proxies.  We reply to both,&n; *  and in the case of requests for us we add the requester to the arp &n; *  cache.&n; */
multiline_comment|/*&n; *&t;try to switch to alias device whose addr is tip or closest to sip.&n; */
macro_line|#ifdef CONFIG_NET_ALIAS
r_if
c_cond
(paren
id|tip
op_ne
id|dev-&gt;pa_addr
op_logical_and
id|net_alias_has
c_func
(paren
id|skb-&gt;dev
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;net_alias_dev_rcv_sel32 returns main dev if it fails to found other.&n;&t;&t; */
id|dev
op_assign
id|net_alias_dev_rcv_sel32
c_func
(paren
id|dev
comma
id|AF_INET
comma
id|sip
comma
id|tip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;type
op_ne
id|ntohs
c_func
(paren
id|arp-&gt;ar_hrd
)paren
op_logical_or
id|dev-&gt;flags
op_amp
id|IFF_NOARP
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|arp-&gt;ar_op
op_eq
id|htons
c_func
(paren
id|ARPOP_REQUEST
)paren
)paren
(brace
multiline_comment|/*&n; * Only reply for the real device address or when it&squot;s in our proxy tables&n; */
r_if
c_cond
(paren
id|tip
op_ne
id|dev-&gt;pa_addr
)paren
(brace
r_struct
id|arp_table
op_star
id|proxy_entry
suffix:semicolon
multiline_comment|/*&n; * &t;To get in here, it is a request for someone else.  We need to&n; * &t;check if that someone else is one of our proxies.  If it isn&squot;t,&n; * &t;we can toss it.&n; *&n; *&t;Make &quot;longest match&quot; lookup, a la routing.&n; */
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|proxy_entry
op_assign
id|arp_proxy_list
suffix:semicolon
id|proxy_entry
suffix:semicolon
id|proxy_entry
op_assign
id|proxy_entry-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|proxy_entry-&gt;dev
op_eq
id|dev
op_logical_and
op_logical_neg
(paren
(paren
id|proxy_entry-&gt;ip
op_xor
id|tip
)paren
op_amp
id|proxy_entry-&gt;mask
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|proxy_entry
op_logical_and
(paren
id|proxy_entry-&gt;mask
op_logical_or
(paren
(paren
id|dev-&gt;pa_addr
op_xor
id|tip
)paren
op_amp
id|dev-&gt;pa_mask
)paren
)paren
)paren
(brace
r_char
id|ha
(braket
id|MAX_ADDR_LEN
)braket
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
multiline_comment|/* Unlock arp tables to make life for&n;&t;&t;&t;&t; * ip_rt_route easy. Note, that we are obliged&n;&t;&t;&t;&t; * to make local copy of hardware address.&n;&t;&t;&t;&t; */
id|memcpy
c_func
(paren
id|ha
comma
id|proxy_entry-&gt;ha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
id|rt
op_assign
id|ip_rt_route
c_func
(paren
id|tip
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_logical_and
id|rt-&gt;rt_dev
op_ne
id|dev
)paren
id|arp_send
c_func
(paren
id|ARPOP_REPLY
comma
id|ETH_P_ARP
comma
id|sip
comma
id|dev
comma
id|tip
comma
id|sha
comma
id|ha
comma
id|sha
)paren
suffix:semicolon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
)brace
r_else
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|arp_send
c_func
(paren
id|ARPOP_REPLY
comma
id|ETH_P_ARP
comma
id|sip
comma
id|dev
comma
id|tip
comma
id|sha
comma
id|dev-&gt;dev_addr
comma
id|sha
)paren
suffix:semicolon
)brace
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
id|arp_update
c_func
(paren
id|sip
comma
id|sha
comma
id|dev
comma
l_int|0
comma
l_int|NULL
comma
id|ip_chk_addr
c_func
(paren
id|tip
)paren
op_ne
id|IS_MYADDR
op_logical_and
id|dev-&gt;type
op_ne
id|ARPHRD_METRICOM
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;User level interface (ioctl, /proc)&n; */
multiline_comment|/*&n; *&t;Set (create) an ARP cache entry.&n; */
DECL|function|arp_req_set
r_static
r_int
id|arp_req_set
c_func
(paren
r_struct
id|arpreq
op_star
id|r
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
comma
op_star
op_star
id|entryp
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|si
suffix:semicolon
r_int
r_char
op_star
id|ha
suffix:semicolon
id|u32
id|ip
suffix:semicolon
id|u32
id|mask
op_assign
id|DEF_ARP_NETMASK
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Extract netmask (if supplied).&n;&t; */
r_if
c_cond
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_NETMASK
)paren
(brace
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;arp_netmask
suffix:semicolon
id|mask
op_assign
id|si-&gt;sin_addr.s_addr
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Extract destination.&n;&t; */
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;arp_pa
suffix:semicolon
id|ip
op_assign
id|si-&gt;sin_addr.s_addr
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_PUBL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mask
op_logical_and
id|ip
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|dev
op_assign
id|dev_getbytype
c_func
(paren
id|r-&gt;arp_ha.sa_family
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
id|rt
op_assign
id|ip_rt_route
c_func
(paren
id|ip
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rt
)paren
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
id|dev
op_assign
id|rt-&gt;rt_dev
suffix:semicolon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;type
op_ne
id|ARPHRD_METRICOM
op_logical_and
id|ip_chk_addr
c_func
(paren
id|ip
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
(paren
id|IFF_LOOPBACK
op_or
id|IFF_NOARP
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;arp_ha.sa_family
op_ne
id|dev-&gt;type
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 1
r_if
c_cond
(paren
id|ARP_LOCKED
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;arp_req_set: bug&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_PUBL
)paren
)paren
id|entryp
op_assign
op_amp
id|arp_tables
(braket
id|HASH
c_func
(paren
id|ip
)paren
)braket
suffix:semicolon
r_else
id|entryp
op_assign
op_amp
id|arp_proxy_list
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
op_star
id|entryp
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* User supplied arp entries are definitive - RHP 960603 */
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|ip
op_logical_and
id|entry-&gt;mask
op_eq
id|mask
op_logical_and
id|entry-&gt;dev
op_eq
id|dev
)paren
(brace
op_star
id|entryp
op_assign
id|entry-&gt;next
suffix:semicolon
id|arp_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|entry-&gt;mask
op_amp
id|mask
)paren
op_ne
id|mask
)paren
r_break
suffix:semicolon
id|entryp
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
)brace
id|entry
op_assign
id|arp_alloc_entry
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
(brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|entry-&gt;ip
op_assign
id|ip
suffix:semicolon
id|entry-&gt;dev
op_assign
id|dev
suffix:semicolon
id|entry-&gt;mask
op_assign
id|mask
suffix:semicolon
id|entry-&gt;flags
op_assign
id|r-&gt;arp_flags
suffix:semicolon
id|entry-&gt;next
op_assign
op_star
id|entryp
suffix:semicolon
op_star
id|entryp
op_assign
id|entry
suffix:semicolon
id|ha
op_assign
id|r-&gt;arp_ha.sa_data
suffix:semicolon
r_if
c_cond
(paren
id|empty
c_func
(paren
id|ha
comma
id|dev-&gt;addr_len
)paren
)paren
id|ha
op_assign
id|dev-&gt;dev_addr
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|entry-&gt;ha
comma
id|ha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|entry-&gt;last_updated
op_assign
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|entry-&gt;flags
op_or_assign
id|ATF_COM
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|arpd_update
c_func
(paren
id|entry
)paren
suffix:semicolon
id|arp_update_hhs
c_func
(paren
id|entry
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get an ARP cache entry.&n; */
DECL|function|arp_req_get
r_static
r_int
id|arp_req_get
c_func
(paren
r_struct
id|arpreq
op_star
id|r
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|si
suffix:semicolon
id|u32
id|mask
op_assign
id|DEF_ARP_NETMASK
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_NETMASK
)paren
(brace
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;arp_netmask
suffix:semicolon
id|mask
op_assign
id|si-&gt;sin_addr.s_addr
suffix:semicolon
)brace
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;arp_pa
suffix:semicolon
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 1
r_if
c_cond
(paren
id|ARP_LOCKED
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;arp_req_set: impossible&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_PUBL
)paren
)paren
id|entry
op_assign
id|arp_tables
(braket
id|HASH
c_func
(paren
id|si-&gt;sin_addr.s_addr
)paren
)braket
suffix:semicolon
r_else
id|entry
op_assign
id|arp_proxy_list
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|entry
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|si-&gt;sin_addr.s_addr
op_logical_and
(paren
op_logical_neg
id|dev
op_logical_or
id|entry-&gt;dev
op_eq
id|dev
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_NETMASK
)paren
op_logical_or
id|entry-&gt;mask
op_eq
id|mask
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|r-&gt;arp_ha.sa_data
comma
id|entry-&gt;ha
comma
id|entry-&gt;dev-&gt;addr_len
)paren
suffix:semicolon
id|r-&gt;arp_ha.sa_family
op_assign
id|entry-&gt;dev-&gt;type
suffix:semicolon
id|r-&gt;arp_flags
op_assign
id|entry-&gt;flags
suffix:semicolon
id|strncpy
c_func
(paren
id|r-&gt;arp_dev
comma
id|entry-&gt;dev-&gt;name
comma
r_sizeof
(paren
id|r-&gt;arp_dev
)paren
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
DECL|function|arp_req_delete
r_static
r_int
id|arp_req_delete
c_func
(paren
r_struct
id|arpreq
op_star
id|r
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|sockaddr_in
op_star
id|si
suffix:semicolon
r_struct
id|arp_table
op_star
id|entry
comma
op_star
op_star
id|entryp
suffix:semicolon
r_int
id|retval
op_assign
op_minus
id|ENXIO
suffix:semicolon
id|u32
id|mask
op_assign
id|DEF_ARP_NETMASK
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_NETMASK
)paren
(brace
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;arp_netmask
suffix:semicolon
id|mask
op_assign
id|si-&gt;sin_addr.s_addr
suffix:semicolon
)brace
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;arp_pa
suffix:semicolon
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 1
r_if
c_cond
(paren
id|ARP_LOCKED
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;arp_req_delete: impossible&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_PUBL
)paren
)paren
id|entryp
op_assign
op_amp
id|arp_tables
(braket
id|HASH
c_func
(paren
id|si-&gt;sin_addr.s_addr
)paren
)braket
suffix:semicolon
r_else
id|entryp
op_assign
op_amp
id|arp_proxy_list
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
op_star
id|entryp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|si-&gt;sin_addr.s_addr
op_logical_and
(paren
op_logical_neg
id|dev
op_logical_or
id|entry-&gt;dev
op_eq
id|dev
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_NETMASK
)paren
op_logical_or
id|entry-&gt;mask
op_eq
id|mask
)paren
)paren
(brace
op_star
id|entryp
op_assign
id|entry-&gt;next
suffix:semicolon
id|arp_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|entryp
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
)brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Handle an ARP layer I/O control request.&n; */
DECL|function|arp_ioctl
r_int
id|arp_ioctl
c_func
(paren
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|arpreq
id|r
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCDARP
suffix:colon
r_case
id|SIOCSARP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_case
id|SIOCGARP
suffix:colon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|r
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OLD_SIOCDARP
suffix:colon
r_case
id|OLD_SIOCSARP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_case
id|OLD_SIOCGARP
suffix:colon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq_old
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|r
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq_old
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|r.arp_dev
comma
l_int|0
comma
r_sizeof
(paren
id|r.arp_dev
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r.arp_pa.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EPFNOSUPPORT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r.arp_flags
op_amp
id|ATF_PUBL
)paren
)paren
id|r.arp_flags
op_and_assign
op_complement
id|ATF_NETMASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r.arp_flags
op_amp
id|ATF_NETMASK
)paren
)paren
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r.arp_netmask
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
op_assign
id|DEF_ARP_NETMASK
suffix:semicolon
r_if
c_cond
(paren
id|r.arp_dev
(braket
l_int|0
)braket
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|dev_get
c_func
(paren
id|r.arp_dev
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r.arp_ha.sa_family
)paren
id|r.arp_ha.sa_family
op_assign
id|dev-&gt;type
suffix:semicolon
r_else
r_if
c_cond
(paren
id|r.arp_ha.sa_family
op_ne
id|dev-&gt;type
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCDARP
suffix:colon
r_return
id|arp_req_delete
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
r_case
id|SIOCSARP
suffix:colon
r_return
id|arp_req_set
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
r_case
id|OLD_SIOCDARP
suffix:colon
multiline_comment|/* old  SIOCDARP destroys both&n;&t;&t;&t; * normal and proxy mappings&n;&t;&t;&t; */
id|r.arp_flags
op_and_assign
op_complement
id|ATF_PUBL
suffix:semicolon
id|err
op_assign
id|arp_req_delete
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
id|r.arp_flags
op_or_assign
id|ATF_PUBL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|arp_req_delete
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
r_else
id|err
op_assign
id|arp_req_delete
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
r_case
id|OLD_SIOCSARP
suffix:colon
id|err
op_assign
id|arp_req_set
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* old SIOCSARP works so funny,&n;&t;&t;&t; * that its behaviour can be emulated&n;&t;&t;&t; * only approximately 8).&n;&t;&t;&t; * It should work. --ANK&n;&t;&t;&t; */
r_if
c_cond
(paren
id|r.arp_flags
op_amp
id|ATF_PUBL
)paren
(brace
id|r.arp_flags
op_and_assign
op_complement
id|ATF_PUBL
suffix:semicolon
id|arp_req_delete
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
r_case
id|SIOCGARP
suffix:colon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|err
op_assign
id|arp_req_get
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|r
comma
r_sizeof
(paren
id|r
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
r_case
id|OLD_SIOCGARP
suffix:colon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq_old
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|r.arp_flags
op_and_assign
op_complement
id|ATF_PUBL
suffix:semicolon
id|err
op_assign
id|arp_req_get
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|r.arp_flags
op_or_assign
id|ATF_PUBL
suffix:semicolon
id|err
op_assign
id|arp_req_get
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|r
comma
r_sizeof
(paren
r_struct
id|arpreq_old
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*NOTREACHED*/
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Write the contents of the ARP cache to a PROCfs file.&n; */
DECL|macro|HBUFFERLEN
mdefine_line|#define HBUFFERLEN 30
DECL|function|arp_get_info
r_int
id|arp_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|dummy
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|size
suffix:semicolon
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_char
id|hbuffer
(braket
id|HBUFFERLEN
)braket
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_const
r_char
id|hexbuf
(braket
)braket
op_assign
l_string|&quot;0123456789ABCDEF&quot;
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;IP address       HW type     Flags       HW address            Mask     Device&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FULL_ARP_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|entry
op_assign
id|arp_tables
(braket
id|i
)braket
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
(brace
multiline_comment|/*&n; *&t;Convert hardware address to XX:XX:XX:XX ... form.&n; */
macro_line|#ifdef CONFIG_AX25
macro_line|#ifdef CONFIG_NETROM
r_if
c_cond
(paren
id|entry-&gt;dev-&gt;type
op_eq
id|ARPHRD_AX25
op_logical_or
id|entry-&gt;dev-&gt;type
op_eq
id|ARPHRD_NETROM
)paren
id|strcpy
c_func
(paren
id|hbuffer
comma
id|ax2asc
c_func
(paren
(paren
id|ax25_address
op_star
)paren
id|entry-&gt;ha
)paren
)paren
suffix:semicolon
r_else
(brace
macro_line|#else
r_if
c_cond
(paren
id|entry-&gt;dev-&gt;type
op_eq
id|ARPHRD_AX25
)paren
(brace
id|strcpy
c_func
(paren
id|hbuffer
comma
id|ax2asc
c_func
(paren
(paren
id|ax25_address
op_star
)paren
id|entry-&gt;ha
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#endif
macro_line|#endif
r_for
c_loop
(paren
id|k
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|HBUFFERLEN
op_minus
l_int|3
op_logical_and
id|j
OL
id|entry-&gt;dev-&gt;addr_len
suffix:semicolon
id|j
op_increment
)paren
(brace
id|hbuffer
(braket
id|k
op_increment
)braket
op_assign
id|hexbuf
(braket
(paren
id|entry-&gt;ha
(braket
id|j
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|15
)braket
suffix:semicolon
id|hbuffer
(braket
id|k
op_increment
)braket
op_assign
id|hexbuf
(braket
id|entry-&gt;ha
(braket
id|j
)braket
op_amp
l_int|15
)braket
suffix:semicolon
id|hbuffer
(braket
id|k
op_increment
)braket
op_assign
l_char|&squot;:&squot;
suffix:semicolon
)brace
id|hbuffer
(braket
op_decrement
id|k
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_AX25
)brace
macro_line|#endif
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%-17s0x%-10x0x%-10x%s&quot;
comma
id|in_ntoa
c_func
(paren
id|entry-&gt;ip
)paren
comma
(paren
r_int
r_int
)paren
id|entry-&gt;dev-&gt;type
comma
id|entry-&gt;flags
comma
id|hbuffer
)paren
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &lt; 2
id|size
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
op_plus
id|size
comma
l_string|&quot;     %-17s %s&bslash;n&quot;
comma
id|entry-&gt;mask
op_eq
id|DEF_ARP_NETMASK
ques
c_cond
l_string|&quot;*&quot;
suffix:colon
id|in_ntoa
c_func
(paren
id|entry-&gt;mask
)paren
comma
id|entry-&gt;dev-&gt;name
)paren
suffix:semicolon
macro_line|#else
id|size
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
op_plus
id|size
comma
l_string|&quot;     %-17s %s&bslash;t%d&bslash;t%1d&bslash;n&quot;
comma
id|entry-&gt;mask
op_eq
id|DEF_ARP_NETMASK
ques
c_cond
l_string|&quot;*&quot;
suffix:colon
id|in_ntoa
c_func
(paren
id|entry-&gt;mask
)paren
comma
id|entry-&gt;dev-&gt;name
comma
id|entry-&gt;hh
ques
c_cond
id|entry-&gt;hh-&gt;hh_refcnt
suffix:colon
op_minus
l_int|1
comma
id|entry-&gt;hh
ques
c_cond
id|entry-&gt;hh-&gt;hh_uptodate
suffix:colon
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_le
id|offset
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|offset
op_plus
id|length
)paren
r_goto
id|done
suffix:semicolon
)brace
)brace
id|done
suffix:colon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|len
op_minus
(paren
id|pos
op_minus
id|offset
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_assign
id|pos
op_minus
id|offset
suffix:semicolon
multiline_comment|/* Start slop */
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
multiline_comment|/* Ending slop */
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Called once on startup.&n; */
DECL|variable|arp_packet_type
r_static
r_struct
id|packet_type
id|arp_packet_type
op_assign
(brace
l_int|0
comma
multiline_comment|/* Should be: __constant_htons(ETH_P_ARP) - but this _doesn&squot;t_ come out constant! */
l_int|NULL
comma
multiline_comment|/* All devices */
id|arp_rcv
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|arp_dev_notifier
r_static
r_struct
id|notifier_block
id|arp_dev_notifier
op_assign
initialization_block
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
DECL|variable|proc_net_arp
r_static
r_struct
id|proc_dir_entry
id|proc_net_arp
op_assign
(brace
id|PROC_NET_ARP
comma
l_int|3
comma
l_string|&quot;arp&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_amp
id|proc_net_inode_operations
comma
id|arp_get_info
)brace
suffix:semicolon
macro_line|#endif
DECL|function|arp_init
r_void
id|arp_init
(paren
r_void
)paren
(brace
multiline_comment|/* Register the packet type */
id|arp_packet_type.type
op_assign
id|htons
c_func
(paren
id|ETH_P_ARP
)paren
suffix:semicolon
id|dev_add_pack
c_func
(paren
op_amp
id|arp_packet_type
)paren
suffix:semicolon
multiline_comment|/* Start with the regular checks for expired arp entries. */
id|add_timer
c_func
(paren
op_amp
id|arp_timer
)paren
suffix:semicolon
multiline_comment|/* Register for device down reports */
id|register_netdevice_notifier
c_func
(paren
op_amp
id|arp_dev_notifier
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|proc_net_register
c_func
(paren
op_amp
id|proc_net_arp
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ARPD
id|netlink_attach
c_func
(paren
id|NETLINK_ARPD
comma
id|arpd_callback
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
