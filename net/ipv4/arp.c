multiline_comment|/* linux/net/inet/arp.c&n; *&n; * Version:&t;$Id: arp.c,v 1.90 2000/10/04 09:20:56 anton Exp $&n; *&n; * Copyright (C) 1994 by Florian  La Roche&n; *&n; * This module implements the Address Resolution Protocol ARP (RFC 826),&n; * which is used to convert IP addresses (or in the future maybe other&n; * high-level addresses) into a low-level hardware address (like an Ethernet&n; * address).&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;Removed the Ethernet assumptions in &n; *&t;&t;&t;&t;&t;Florian&squot;s code&n; *&t;&t;Alan Cox&t;:&t;Fixed some small errors in the ARP &n; *&t;&t;&t;&t;&t;logic&n; *&t;&t;Alan Cox&t;:&t;Allow &gt;4K in /proc&n; *&t;&t;Alan Cox&t;:&t;Make ARP add its own protocol entry&n; *&t;&t;Ross Martin     :       Rewrote arp_rcv() and arp_get_info()&n; *&t;&t;Stephen Henson&t;:&t;Add AX25 support to arp_get_info()&n; *&t;&t;Alan Cox&t;:&t;Drop data when a device is downed.&n; *&t;&t;Alan Cox&t;:&t;Use init_timer().&n; *&t;&t;Alan Cox&t;:&t;Double lock fixes.&n; *&t;&t;Martin Seine&t;:&t;Move the arphdr structure&n; *&t;&t;&t;&t;&t;to if_arp.h for compatibility.&n; *&t;&t;&t;&t;&t;with BSD based programs.&n; *&t;&t;Andrew Tridgell :       Added ARP netmask code and&n; *&t;&t;&t;&t;&t;re-arranged proxy handling.&n; *&t;&t;Alan Cox&t;:&t;Changed to use notifiers.&n; *&t;&t;Niibe Yutaka&t;:&t;Reply for this device or proxies only.&n; *&t;&t;Alan Cox&t;:&t;Don&squot;t proxy across hardware types!&n; *&t;&t;Jonathan Naylor :&t;Added support for NET/ROM.&n; *&t;&t;Mike Shaver     :       RFC1122 checks.&n; *&t;&t;Jonathan Naylor :&t;Only lookup the hardware address for&n; *&t;&t;&t;&t;&t;the correct hardware type.&n; *&t;&t;Germano Caronni&t;:&t;Assorted subtle races.&n; *&t;&t;Craig Schlenter :&t;Don&squot;t modify permanent entry &n; *&t;&t;&t;&t;&t;during arp_rcv.&n; *&t;&t;Russ Nelson&t;:&t;Tidied up a few bits.&n; *&t;&t;Alexey Kuznetsov:&t;Major changes to caching and behaviour,&n; *&t;&t;&t;&t;&t;eg intelligent arp probing and &n; *&t;&t;&t;&t;&t;generation&n; *&t;&t;&t;&t;&t;of host down events.&n; *&t;&t;Alan Cox&t;:&t;Missing unlock in device events.&n; *&t;&t;Eckes&t;&t;:&t;ARP ioctl control errors.&n; *&t;&t;Alexey Kuznetsov:&t;Arp free fix.&n; *&t;&t;Manuel Rodriguez:&t;Gratuitous ARP.&n; *              Jonathan Layes  :       Added arpd support through kerneld &n; *                                      message queue (960314)&n; *&t;&t;Mike Shaver&t;:&t;/proc/sys/net/ipv4/arp_* support&n; *&t;&t;Mike McLagan    :&t;Routing by source&n; *&t;&t;Stuart Cheshire&t;:&t;Metricom and grat arp fixes&n; *&t;&t;&t;&t;&t;*** FOR 2.1 clean this up ***&n; *&t;&t;Lawrence V. Stefani: (08/12/96) Added FDDI support.&n; *&t;&t;Alan Cox &t;:&t;Took the AP1000 nasty FDDI hack and&n; *&t;&t;&t;&t;&t;folded into the mainstream FDDI code.&n; *&t;&t;&t;&t;&t;Ack spit, Linus how did you allow that&n; *&t;&t;&t;&t;&t;one in...&n; *&t;&t;Jes Sorensen&t;:&t;Make FDDI work again in 2.1.x and&n; *&t;&t;&t;&t;&t;clean up the APFDDI &amp; gen. FDDI bits.&n; *&t;&t;Alexey Kuznetsov:&t;new arp state machine;&n; *&t;&t;&t;&t;&t;now it is in net/core/neighbour.c.&n; */
multiline_comment|/* RFC1122 Status:&n;   2.3.2.1 (ARP Cache Validation):&n;     MUST provide mechanism to flush stale cache entries (OK)&n;     SHOULD be able to configure cache timeout (OK)&n;     MUST throttle ARP retransmits (OK)&n;   2.3.2.2 (ARP Packet Queue):&n;     SHOULD save at least one packet from each &quot;conversation&quot; with an&n;       unresolved IP address.  (OK)&n;   950727 -- MS&n;*/
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/fddidevice.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/trdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#ifdef CONFIG_SYSCTL
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#endif
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
macro_line|#include &lt;net/ax25.h&gt;
macro_line|#if defined(CONFIG_NETROM) || defined(CONFIG_NETROM_MODULE)
macro_line|#include &lt;net/netrom.h&gt;
macro_line|#endif
macro_line|#endif
macro_line|#ifdef CONFIG_ATM_CLIP
macro_line|#include &lt;net/atmclip.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/*&n; *&t;Interface to generic neighbour cache.&n; */
r_static
id|u32
id|arp_hash
c_func
(paren
r_const
r_void
op_star
id|pkey
comma
r_const
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|arp_constructor
c_func
(paren
r_struct
id|neighbour
op_star
id|neigh
)paren
suffix:semicolon
r_static
r_void
id|arp_solicit
c_func
(paren
r_struct
id|neighbour
op_star
id|neigh
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_void
id|arp_error_report
c_func
(paren
r_struct
id|neighbour
op_star
id|neigh
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_void
id|parp_redo
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
DECL|variable|arp_generic_ops
r_static
r_struct
id|neigh_ops
id|arp_generic_ops
op_assign
(brace
id|AF_INET
comma
l_int|NULL
comma
id|arp_solicit
comma
id|arp_error_report
comma
id|neigh_resolve_output
comma
id|neigh_connected_output
comma
id|dev_queue_xmit
comma
id|dev_queue_xmit
)brace
suffix:semicolon
DECL|variable|arp_hh_ops
r_static
r_struct
id|neigh_ops
id|arp_hh_ops
op_assign
(brace
id|AF_INET
comma
l_int|NULL
comma
id|arp_solicit
comma
id|arp_error_report
comma
id|neigh_resolve_output
comma
id|neigh_resolve_output
comma
id|dev_queue_xmit
comma
id|dev_queue_xmit
)brace
suffix:semicolon
DECL|variable|arp_direct_ops
r_static
r_struct
id|neigh_ops
id|arp_direct_ops
op_assign
(brace
id|AF_INET
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
id|dev_queue_xmit
comma
id|dev_queue_xmit
comma
id|dev_queue_xmit
comma
id|dev_queue_xmit
)brace
suffix:semicolon
DECL|variable|arp_broken_ops
r_struct
id|neigh_ops
id|arp_broken_ops
op_assign
(brace
id|AF_INET
comma
l_int|NULL
comma
id|arp_solicit
comma
id|arp_error_report
comma
id|neigh_compat_output
comma
id|neigh_compat_output
comma
id|dev_queue_xmit
comma
id|dev_queue_xmit
comma
)brace
suffix:semicolon
DECL|variable|arp_tbl
r_struct
id|neigh_table
id|arp_tbl
op_assign
(brace
l_int|NULL
comma
id|AF_INET
comma
r_sizeof
(paren
r_struct
id|neighbour
)paren
op_plus
l_int|4
comma
l_int|4
comma
id|arp_hash
comma
id|arp_constructor
comma
l_int|NULL
comma
l_int|NULL
comma
id|parp_redo
comma
l_string|&quot;arp_cache&quot;
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
op_amp
id|arp_tbl
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|30
op_star
id|HZ
comma
l_int|1
op_star
id|HZ
comma
l_int|60
op_star
id|HZ
comma
l_int|30
op_star
id|HZ
comma
l_int|5
op_star
id|HZ
comma
l_int|3
comma
l_int|3
comma
l_int|0
comma
l_int|3
comma
l_int|1
op_star
id|HZ
comma
(paren
l_int|8
op_star
id|HZ
)paren
op_div
l_int|10
comma
l_int|64
comma
l_int|1
op_star
id|HZ
)brace
comma
l_int|30
op_star
id|HZ
comma
l_int|128
comma
l_int|512
comma
l_int|1024
comma
)brace
suffix:semicolon
DECL|function|arp_mc_map
r_int
id|arp_mc_map
c_func
(paren
id|u32
id|addr
comma
id|u8
op_star
id|haddr
comma
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|dir
)paren
(brace
r_switch
c_cond
(paren
id|dev-&gt;type
)paren
(brace
r_case
id|ARPHRD_ETHER
suffix:colon
r_case
id|ARPHRD_FDDI
suffix:colon
r_case
id|ARPHRD_IEEE802
suffix:colon
id|ip_eth_mc_map
c_func
(paren
id|addr
comma
id|haddr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|ARPHRD_IEEE802_TR
suffix:colon
id|ip_tr_mc_map
c_func
(paren
id|addr
comma
id|haddr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|dir
)paren
(brace
id|memcpy
c_func
(paren
id|haddr
comma
id|dev-&gt;broadcast
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|arp_hash
r_static
id|u32
id|arp_hash
c_func
(paren
r_const
r_void
op_star
id|pkey
comma
r_const
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|u32
id|hash_val
suffix:semicolon
id|hash_val
op_assign
op_star
(paren
id|u32
op_star
)paren
id|pkey
suffix:semicolon
id|hash_val
op_xor_assign
(paren
id|hash_val
op_rshift
l_int|16
)paren
suffix:semicolon
id|hash_val
op_xor_assign
id|hash_val
op_rshift
l_int|8
suffix:semicolon
id|hash_val
op_xor_assign
id|hash_val
op_rshift
l_int|3
suffix:semicolon
id|hash_val
op_assign
(paren
id|hash_val
op_xor
id|dev-&gt;ifindex
)paren
op_amp
id|NEIGH_HASHMASK
suffix:semicolon
r_return
id|hash_val
suffix:semicolon
)brace
DECL|function|arp_constructor
r_static
r_int
id|arp_constructor
c_func
(paren
r_struct
id|neighbour
op_star
id|neigh
)paren
(brace
id|u32
id|addr
op_assign
op_star
(paren
id|u32
op_star
)paren
id|neigh-&gt;primary_key
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|neigh-&gt;dev
suffix:semicolon
r_struct
id|in_device
op_star
id|in_dev
op_assign
id|in_dev_get
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_dev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|neigh-&gt;type
op_assign
id|inet_addr_type
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_dev-&gt;arp_parms
)paren
id|neigh-&gt;parms
op_assign
id|in_dev-&gt;arp_parms
suffix:semicolon
id|in_dev_put
c_func
(paren
id|in_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;hard_header
op_eq
l_int|NULL
)paren
(brace
id|neigh-&gt;nud_state
op_assign
id|NUD_NOARP
suffix:semicolon
id|neigh-&gt;ops
op_assign
op_amp
id|arp_direct_ops
suffix:semicolon
id|neigh-&gt;output
op_assign
id|neigh-&gt;ops-&gt;queue_xmit
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Good devices (checked by reading texts, but only Ethernet is&n;&t;&t;   tested)&n;&n;&t;&t;   ARPHRD_ETHER: (ethernet, apfddi)&n;&t;&t;   ARPHRD_FDDI: (fddi)&n;&t;&t;   ARPHRD_IEEE802: (tr)&n;&t;&t;   ARPHRD_METRICOM: (strip)&n;&t;&t;   ARPHRD_ARCNET:&n;&t;&t;   etc. etc. etc.&n;&n;&t;&t;   ARPHRD_IPDDP will also work, if author repairs it.&n;&t;&t;   I did not it, because this driver does not work even&n;&t;&t;   in old paradigm.&n;&t;&t; */
macro_line|#if 1
multiline_comment|/* So... these &quot;amateur&quot; devices are hopeless.&n;&t;&t;   The only thing, that I can say now:&n;&t;&t;   It is very sad that we need to keep ugly obsolete&n;&t;&t;   code to make them happy.&n;&n;&t;&t;   They should be moved to more reasonable state, now&n;&t;&t;   they use rebuild_header INSTEAD OF hard_start_xmit!!!&n;&t;&t;   Besides that, they are sort of out of date&n;&t;&t;   (a lot of redundant clones/copies, useless in 2.1),&n;&t;&t;   I wonder why people believe that they work.&n;&t;&t; */
r_switch
c_cond
(paren
id|dev-&gt;type
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|ARPHRD_ROSE
suffix:colon
macro_line|#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
r_case
id|ARPHRD_AX25
suffix:colon
macro_line|#if defined(CONFIG_NETROM) || defined(CONFIG_NETROM_MODULE)
r_case
id|ARPHRD_NETROM
suffix:colon
macro_line|#endif
id|neigh-&gt;ops
op_assign
op_amp
id|arp_broken_ops
suffix:semicolon
id|neigh-&gt;output
op_assign
id|neigh-&gt;ops-&gt;output
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|neigh-&gt;type
op_eq
id|RTN_MULTICAST
)paren
(brace
id|neigh-&gt;nud_state
op_assign
id|NUD_NOARP
suffix:semicolon
id|arp_mc_map
c_func
(paren
id|addr
comma
id|neigh-&gt;ha
comma
id|dev
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
(paren
id|IFF_NOARP
op_or
id|IFF_LOOPBACK
)paren
)paren
(brace
id|neigh-&gt;nud_state
op_assign
id|NUD_NOARP
suffix:semicolon
id|memcpy
c_func
(paren
id|neigh-&gt;ha
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|neigh-&gt;type
op_eq
id|RTN_BROADCAST
op_logical_or
id|dev-&gt;flags
op_amp
id|IFF_POINTOPOINT
)paren
(brace
id|neigh-&gt;nud_state
op_assign
id|NUD_NOARP
suffix:semicolon
id|memcpy
c_func
(paren
id|neigh-&gt;ha
comma
id|dev-&gt;broadcast
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;hard_header_cache
)paren
id|neigh-&gt;ops
op_assign
op_amp
id|arp_hh_ops
suffix:semicolon
r_else
id|neigh-&gt;ops
op_assign
op_amp
id|arp_generic_ops
suffix:semicolon
r_if
c_cond
(paren
id|neigh-&gt;nud_state
op_amp
id|NUD_VALID
)paren
id|neigh-&gt;output
op_assign
id|neigh-&gt;ops-&gt;connected_output
suffix:semicolon
r_else
id|neigh-&gt;output
op_assign
id|neigh-&gt;ops-&gt;output
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|arp_error_report
r_static
r_void
id|arp_error_report
c_func
(paren
r_struct
id|neighbour
op_star
id|neigh
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|dst_link_failure
c_func
(paren
id|skb
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
DECL|function|arp_solicit
r_static
r_void
id|arp_solicit
c_func
(paren
r_struct
id|neighbour
op_star
id|neigh
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|u32
id|saddr
suffix:semicolon
id|u8
op_star
id|dst_ha
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|neigh-&gt;dev
suffix:semicolon
id|u32
id|target
op_assign
op_star
(paren
id|u32
op_star
)paren
id|neigh-&gt;primary_key
suffix:semicolon
r_int
id|probes
op_assign
id|atomic_read
c_func
(paren
op_amp
id|neigh-&gt;probes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_logical_and
id|inet_addr_type
c_func
(paren
id|skb-&gt;nh.iph-&gt;saddr
)paren
op_eq
id|RTN_LOCAL
)paren
id|saddr
op_assign
id|skb-&gt;nh.iph-&gt;saddr
suffix:semicolon
r_else
id|saddr
op_assign
id|inet_select_addr
c_func
(paren
id|dev
comma
id|target
comma
id|RT_SCOPE_LINK
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|probes
op_sub_assign
id|neigh-&gt;parms-&gt;ucast_probes
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|neigh-&gt;nud_state
op_amp
id|NUD_VALID
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;trying to ucast probe in NUD_INVALID&bslash;n&quot;
)paren
suffix:semicolon
id|dst_ha
op_assign
id|neigh-&gt;ha
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|probes
op_sub_assign
id|neigh-&gt;parms-&gt;app_probes
)paren
OL
l_int|0
)paren
(brace
macro_line|#ifdef CONFIG_ARPD
id|neigh_app_ns
c_func
(paren
id|neigh
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|target
comma
id|dev
comma
id|saddr
comma
id|dst_ha
comma
id|dev-&gt;dev_addr
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst_ha
)paren
id|read_unlock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* OBSOLETE FUNCTIONS */
multiline_comment|/*&n; *&t;Find an arp mapping in the cache. If not found, post a request.&n; *&n; *&t;It is very UGLY routine: it DOES NOT use skb-&gt;dst-&gt;neighbour,&n; *&t;even if it exists. It is supposed that skb-&gt;dev was mangled&n; *&t;by a virtual device (eql, shaper). Nobody but broken devices&n; *&t;is allowed to use this function, it is scheduled to be removed. --ANK&n; */
DECL|function|arp_set_predefined
r_static
r_int
id|arp_set_predefined
c_func
(paren
r_int
id|addr_hint
comma
r_int
r_char
op_star
id|haddr
comma
id|u32
id|paddr
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_switch
c_cond
(paren
id|addr_hint
)paren
(brace
r_case
id|RTN_LOCAL
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ARP: arp called for own IP address&bslash;n&quot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|haddr
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
id|RTN_MULTICAST
suffix:colon
id|arp_mc_map
c_func
(paren
id|paddr
comma
id|haddr
comma
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
id|RTN_BROADCAST
suffix:colon
id|memcpy
c_func
(paren
id|haddr
comma
id|dev-&gt;broadcast
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|arp_find
r_int
id|arp_find
c_func
(paren
r_int
r_char
op_star
id|haddr
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|u32
id|paddr
suffix:semicolon
r_struct
id|neighbour
op_star
id|n
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;dst
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;arp_find is called with dst==NULL&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|paddr
op_assign
(paren
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
)paren
op_member_access_from_pointer
id|rt_gateway
suffix:semicolon
r_if
c_cond
(paren
id|arp_set_predefined
c_func
(paren
id|inet_addr_type
c_func
(paren
id|paddr
)paren
comma
id|haddr
comma
id|paddr
comma
id|dev
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|n
op_assign
id|__neigh_lookup
c_func
(paren
op_amp
id|arp_tbl
comma
op_amp
id|paddr
comma
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
)paren
(brace
id|n-&gt;used
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|n-&gt;nud_state
op_amp
id|NUD_VALID
op_logical_or
id|neigh_event_send
c_func
(paren
id|n
comma
id|skb
)paren
op_eq
l_int|0
)paren
(brace
id|read_lock_bh
c_func
(paren
op_amp
id|n-&gt;lock
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|haddr
comma
id|n-&gt;ha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|read_unlock_bh
c_func
(paren
op_amp
id|n-&gt;lock
)paren
suffix:semicolon
id|neigh_release
c_func
(paren
id|n
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|neigh_release
c_func
(paren
id|n
)paren
suffix:semicolon
)brace
r_else
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* END OF OBSOLETE FUNCTIONS */
DECL|function|arp_bind_neighbour
r_int
id|arp_bind_neighbour
c_func
(paren
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dst-&gt;dev
suffix:semicolon
r_struct
id|neighbour
op_star
id|n
op_assign
id|dst-&gt;neighbour
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|NULL
)paren
(brace
id|u32
id|nexthop
op_assign
(paren
(paren
r_struct
id|rtable
op_star
)paren
id|dst
)paren
op_member_access_from_pointer
id|rt_gateway
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
(paren
id|IFF_LOOPBACK
op_or
id|IFF_POINTOPOINT
)paren
)paren
id|nexthop
op_assign
l_int|0
suffix:semicolon
id|n
op_assign
id|__neigh_lookup_errno
c_func
(paren
macro_line|#ifdef CONFIG_ATM_CLIP
id|dev-&gt;type
op_eq
id|ARPHRD_ATM
ques
c_cond
op_amp
id|clip_tbl
suffix:colon
macro_line|#endif
op_amp
id|arp_tbl
comma
op_amp
id|nexthop
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|n
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|n
)paren
suffix:semicolon
id|dst-&gt;neighbour
op_assign
id|n
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Interface to link layer: send routine and receive handler.&n; */
multiline_comment|/*&n; *&t;Create and send an arp packet. If (dest_hw == NULL), we create a broadcast&n; *&t;message.&n; */
DECL|function|arp_send
r_void
id|arp_send
c_func
(paren
r_int
id|type
comma
r_int
id|ptype
comma
id|u32
id|dest_ip
comma
r_struct
id|net_device
op_star
id|dev
comma
id|u32
id|src_ip
comma
r_int
r_char
op_star
id|dest_hw
comma
r_int
r_char
op_star
id|src_hw
comma
r_int
r_char
op_star
id|target_hw
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|arphdr
op_star
id|arp
suffix:semicolon
r_int
r_char
op_star
id|arp_ptr
suffix:semicolon
multiline_comment|/*&n;&t; *&t;No arp on this interface.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_NOARP
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate a buffer&n;&t; */
id|skb
op_assign
id|alloc_skb
c_func
(paren
r_sizeof
(paren
r_struct
id|arphdr
)paren
op_plus
l_int|2
op_star
(paren
id|dev-&gt;addr_len
op_plus
l_int|4
)paren
op_plus
id|dev-&gt;hard_header_len
op_plus
l_int|15
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
(paren
id|dev-&gt;hard_header_len
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
)paren
suffix:semicolon
id|skb-&gt;nh.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|arp
op_assign
(paren
r_struct
id|arphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|arphdr
)paren
op_plus
l_int|2
op_star
(paren
id|dev-&gt;addr_len
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|__constant_htons
(paren
id|ETH_P_ARP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|src_hw
op_eq
l_int|NULL
)paren
id|src_hw
op_assign
id|dev-&gt;dev_addr
suffix:semicolon
r_if
c_cond
(paren
id|dest_hw
op_eq
l_int|NULL
)paren
id|dest_hw
op_assign
id|dev-&gt;broadcast
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fill the device header for the ARP frame&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;hard_header
op_logical_and
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|skb
comma
id|dev
comma
id|ptype
comma
id|dest_hw
comma
id|src_hw
comma
id|skb-&gt;len
)paren
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Fill out the arp protocol part.&n;&t; *&n;&t; * The arp hardware type should match the device type, except for FDDI,&n;&t; * which (according to RFC 1390) should always equal 1 (Ethernet).&n;&t; */
multiline_comment|/*&n;&t; *&t;Exceptions everywhere. AX.25 uses the AX.25 PID value not the&n;&t; *&t;DIX code for the protocol. Make these device structure fields.&n;&t; */
r_switch
c_cond
(paren
id|dev-&gt;type
)paren
(brace
r_default
suffix:colon
id|arp-&gt;ar_hrd
op_assign
id|htons
c_func
(paren
id|dev-&gt;type
)paren
suffix:semicolon
id|arp-&gt;ar_pro
op_assign
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
r_case
id|ARPHRD_AX25
suffix:colon
id|arp-&gt;ar_hrd
op_assign
id|__constant_htons
c_func
(paren
id|ARPHRD_AX25
)paren
suffix:semicolon
id|arp-&gt;ar_pro
op_assign
id|__constant_htons
c_func
(paren
id|AX25_P_IP
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if defined(CONFIG_NETROM) || defined(CONFIG_NETROM_MODULE)
r_case
id|ARPHRD_NETROM
suffix:colon
id|arp-&gt;ar_hrd
op_assign
id|__constant_htons
c_func
(paren
id|ARPHRD_NETROM
)paren
suffix:semicolon
id|arp-&gt;ar_pro
op_assign
id|__constant_htons
c_func
(paren
id|AX25_P_IP
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#endif
macro_line|#ifdef CONFIG_FDDI
r_case
id|ARPHRD_FDDI
suffix:colon
id|arp-&gt;ar_hrd
op_assign
id|__constant_htons
c_func
(paren
id|ARPHRD_ETHER
)paren
suffix:semicolon
id|arp-&gt;ar_pro
op_assign
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_TR
r_case
id|ARPHRD_IEEE802_TR
suffix:colon
id|arp-&gt;ar_hrd
op_assign
id|__constant_htons
c_func
(paren
id|ARPHRD_IEEE802
)paren
suffix:semicolon
id|arp-&gt;ar_pro
op_assign
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
)brace
id|arp-&gt;ar_hln
op_assign
id|dev-&gt;addr_len
suffix:semicolon
id|arp-&gt;ar_pln
op_assign
l_int|4
suffix:semicolon
id|arp-&gt;ar_op
op_assign
id|htons
c_func
(paren
id|type
)paren
suffix:semicolon
id|arp_ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|arp
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|arp_ptr
comma
id|src_hw
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
id|arp_ptr
comma
op_amp
id|src_ip
comma
l_int|4
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|target_hw
op_ne
l_int|NULL
)paren
id|memcpy
c_func
(paren
id|arp_ptr
comma
id|target_hw
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_else
id|memset
c_func
(paren
id|arp_ptr
comma
l_int|0
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
id|arp_ptr
comma
op_amp
id|dest_ip
comma
l_int|4
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
id|out
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
DECL|function|parp_redo
r_static
r_void
id|parp_redo
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|arp_rcv
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Receive an arp request by the device layer.&n; */
DECL|function|arp_rcv
r_int
id|arp_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|arphdr
op_star
id|arp
op_assign
id|skb-&gt;nh.arph
suffix:semicolon
r_int
r_char
op_star
id|arp_ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|arp
op_plus
l_int|1
)paren
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_int
r_char
op_star
id|sha
comma
op_star
id|tha
suffix:semicolon
id|u32
id|sip
comma
id|tip
suffix:semicolon
id|u16
id|dev_type
op_assign
id|dev-&gt;type
suffix:semicolon
r_int
id|addr_type
suffix:semicolon
r_struct
id|in_device
op_star
id|in_dev
op_assign
id|in_dev_get
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|neighbour
op_star
id|n
suffix:semicolon
multiline_comment|/*&n; *&t;The hardware length of the packet should match the hardware length&n; *&t;of the device.  Similarly, the hardware types should match.  The&n; *&t;device should be ARP-able.  Also, if pln is not 4, then the lookup&n; *&t;is not from an IP number.  We can&squot;t currently handle this, so toss&n; *&t;it. &n; */
r_if
c_cond
(paren
id|in_dev
op_eq
l_int|NULL
op_logical_or
id|arp-&gt;ar_hln
op_ne
id|dev-&gt;addr_len
op_logical_or
id|dev-&gt;flags
op_amp
id|IFF_NOARP
op_logical_or
id|skb-&gt;pkt_type
op_eq
id|PACKET_OTHERHOST
op_logical_or
id|skb-&gt;pkt_type
op_eq
id|PACKET_LOOPBACK
op_logical_or
id|arp-&gt;ar_pln
op_ne
l_int|4
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|skb_share_check
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|out_of_mem
suffix:semicolon
r_switch
c_cond
(paren
id|dev_type
)paren
(brace
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|htons
c_func
(paren
id|dev_type
)paren
op_ne
id|arp-&gt;ar_hrd
)paren
r_goto
id|out
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_NET_ETHERNET
r_case
id|ARPHRD_ETHER
suffix:colon
multiline_comment|/*&n;&t;&t; * ETHERNET devices will accept ARP hardware types of either&n;&t;&t; * 1 (Ethernet) or 6 (IEEE 802.2).&n;&t;&t; */
r_if
c_cond
(paren
id|arp-&gt;ar_hrd
op_ne
id|__constant_htons
c_func
(paren
id|ARPHRD_ETHER
)paren
op_logical_and
id|arp-&gt;ar_hrd
op_ne
id|__constant_htons
c_func
(paren
id|ARPHRD_IEEE802
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
r_goto
id|out
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_TR
r_case
id|ARPHRD_IEEE802_TR
suffix:colon
multiline_comment|/*&n;&t;&t; * Token ring devices will accept ARP hardware types of either&n;&t;&t; * 1 (Ethernet) or 6 (IEEE 802.2).&n;&t;&t; */
r_if
c_cond
(paren
id|arp-&gt;ar_hrd
op_ne
id|__constant_htons
c_func
(paren
id|ARPHRD_ETHER
)paren
op_logical_and
id|arp-&gt;ar_hrd
op_ne
id|__constant_htons
c_func
(paren
id|ARPHRD_IEEE802
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
r_goto
id|out
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_FDDI
r_case
id|ARPHRD_FDDI
suffix:colon
multiline_comment|/*&n;&t;&t; * According to RFC 1390, FDDI devices should accept ARP hardware types&n;&t;&t; * of 1 (Ethernet).  However, to be more robust, we&squot;ll accept hardware&n;&t;&t; * types of either 1 (Ethernet) or 6 (IEEE 802.2).&n;&t;&t; */
r_if
c_cond
(paren
id|arp-&gt;ar_hrd
op_ne
id|__constant_htons
c_func
(paren
id|ARPHRD_ETHER
)paren
op_logical_and
id|arp-&gt;ar_hrd
op_ne
id|__constant_htons
c_func
(paren
id|ARPHRD_IEEE802
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
r_goto
id|out
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
r_case
id|ARPHRD_AX25
suffix:colon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|__constant_htons
c_func
(paren
id|AX25_P_IP
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|arp-&gt;ar_hrd
op_ne
id|__constant_htons
c_func
(paren
id|ARPHRD_AX25
)paren
)paren
r_goto
id|out
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if defined(CONFIG_NETROM) || defined(CONFIG_NETROM_MODULE)
r_case
id|ARPHRD_NETROM
suffix:colon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|__constant_htons
c_func
(paren
id|AX25_P_IP
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|arp-&gt;ar_hrd
op_ne
id|__constant_htons
c_func
(paren
id|ARPHRD_NETROM
)paren
)paren
r_goto
id|out
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#endif
)brace
multiline_comment|/* Understand only these message types */
r_if
c_cond
(paren
id|arp-&gt;ar_op
op_ne
id|__constant_htons
c_func
(paren
id|ARPOP_REPLY
)paren
op_logical_and
id|arp-&gt;ar_op
op_ne
id|__constant_htons
c_func
(paren
id|ARPOP_REQUEST
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n; *&t;Extract fields&n; */
id|sha
op_assign
id|arp_ptr
suffix:semicolon
id|arp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|sip
comma
id|arp_ptr
comma
l_int|4
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
l_int|4
suffix:semicolon
id|tha
op_assign
id|arp_ptr
suffix:semicolon
id|arp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|tip
comma
id|arp_ptr
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* &n; *&t;Check for bad requests for 127.x.x.x and requests for multicast&n; *&t;addresses.  If this is one such, delete it.&n; */
r_if
c_cond
(paren
id|LOOPBACK
c_func
(paren
id|tip
)paren
op_logical_or
id|MULTICAST
c_func
(paren
id|tip
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n; *  Process entry.  The idea here is we want to send a reply if it is a&n; *  request for us or if it is a request for someone else that we hold&n; *  a proxy for.  We want to add an entry to our cache if it is a reply&n; *  to us or if it is a request for our address.  &n; *  (The assumption for this last is that if someone is requesting our &n; *  address, they are probably intending to talk to us, so it saves time &n; *  if we cache their address.  Their address is also probably not in &n; *  our cache, since ours is not in their cache.)&n; * &n; *  Putting this another way, we only care about replies if they are to&n; *  us, in which case we add them to the cache.  For requests, we care&n; *  about those for us and those for our proxies.  We reply to both,&n; *  and in the case of requests for us we add the requester to the arp &n; *  cache.&n; */
multiline_comment|/* Special case: IPv4 duplicate address detection packet (RFC2131) */
r_if
c_cond
(paren
id|sip
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|arp-&gt;ar_op
op_eq
id|__constant_htons
c_func
(paren
id|ARPOP_REQUEST
)paren
op_logical_and
id|inet_addr_type
c_func
(paren
id|tip
)paren
op_eq
id|RTN_LOCAL
)paren
id|arp_send
c_func
(paren
id|ARPOP_REPLY
comma
id|ETH_P_ARP
comma
id|tip
comma
id|dev
comma
id|tip
comma
id|sha
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;dev_addr
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arp-&gt;ar_op
op_eq
id|__constant_htons
c_func
(paren
id|ARPOP_REQUEST
)paren
op_logical_and
id|ip_route_input
c_func
(paren
id|skb
comma
id|tip
comma
id|sip
comma
l_int|0
comma
id|dev
)paren
op_eq
l_int|0
)paren
(brace
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
id|addr_type
op_assign
id|rt-&gt;rt_type
suffix:semicolon
r_if
c_cond
(paren
id|addr_type
op_eq
id|RTN_LOCAL
)paren
(brace
id|n
op_assign
id|neigh_event_ns
c_func
(paren
op_amp
id|arp_tbl
comma
id|sha
comma
op_amp
id|sip
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
)paren
(brace
id|arp_send
c_func
(paren
id|ARPOP_REPLY
comma
id|ETH_P_ARP
comma
id|sip
comma
id|dev
comma
id|tip
comma
id|sha
comma
id|dev-&gt;dev_addr
comma
id|sha
)paren
suffix:semicolon
id|neigh_release
c_func
(paren
id|n
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|IN_DEV_FORWARD
c_func
(paren
id|in_dev
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_DNAT
)paren
op_logical_or
(paren
id|addr_type
op_eq
id|RTN_UNICAST
op_logical_and
id|rt-&gt;u.dst.dev
op_ne
id|dev
op_logical_and
(paren
id|IN_DEV_PROXY_ARP
c_func
(paren
id|in_dev
)paren
op_logical_or
id|pneigh_lookup
c_func
(paren
op_amp
id|arp_tbl
comma
op_amp
id|tip
comma
id|dev
comma
l_int|0
)paren
)paren
)paren
)paren
(brace
id|n
op_assign
id|neigh_event_ns
c_func
(paren
op_amp
id|arp_tbl
comma
id|sha
comma
op_amp
id|sip
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
)paren
id|neigh_release
c_func
(paren
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;stamp.tv_sec
op_eq
l_int|0
op_logical_or
id|skb-&gt;pkt_type
op_eq
id|PACKET_HOST
op_logical_or
id|in_dev-&gt;arp_parms-&gt;proxy_delay
op_eq
l_int|0
)paren
(brace
id|arp_send
c_func
(paren
id|ARPOP_REPLY
comma
id|ETH_P_ARP
comma
id|sip
comma
id|dev
comma
id|tip
comma
id|sha
comma
id|dev-&gt;dev_addr
comma
id|sha
)paren
suffix:semicolon
)brace
r_else
(brace
id|pneigh_enqueue
c_func
(paren
op_amp
id|arp_tbl
comma
id|in_dev-&gt;arp_parms
comma
id|skb
)paren
suffix:semicolon
id|in_dev_put
c_func
(paren
id|in_dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Update our ARP tables */
id|n
op_assign
id|__neigh_lookup
c_func
(paren
op_amp
id|arp_tbl
comma
op_amp
id|sip
comma
id|dev
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IP_ACCEPT_UNSOLICITED_ARP
multiline_comment|/* Unsolicited ARP is not accepted by default.&n;&t;   It is possible, that this option should be enabled for some&n;&t;   devices (strip is candidate)&n;&t; */
r_if
c_cond
(paren
id|n
op_eq
l_int|NULL
op_logical_and
id|arp-&gt;ar_op
op_eq
id|__constant_htons
c_func
(paren
id|ARPOP_REPLY
)paren
op_logical_and
id|inet_addr_type
c_func
(paren
id|sip
)paren
op_eq
id|RTN_UNICAST
)paren
id|n
op_assign
id|__neigh_lookup
c_func
(paren
op_amp
id|arp_tbl
comma
op_amp
id|sip
comma
id|dev
comma
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|n
)paren
(brace
r_int
id|state
op_assign
id|NUD_REACHABLE
suffix:semicolon
r_int
id|override
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If several different ARP replies follows back-to-back,&n;&t;&t;   use the FIRST one. It is possible, if several proxy&n;&t;&t;   agents are active. Taking the first reply prevents&n;&t;&t;   arp trashing and chooses the fastest router.&n;&t;&t; */
r_if
c_cond
(paren
id|jiffies
op_minus
id|n-&gt;updated
op_ge
id|n-&gt;parms-&gt;locktime
)paren
id|override
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Broadcast replies and request packets&n;&t;&t;   do not assert neighbour reachability.&n;&t;&t; */
r_if
c_cond
(paren
id|arp-&gt;ar_op
op_ne
id|__constant_htons
c_func
(paren
id|ARPOP_REPLY
)paren
op_logical_or
id|skb-&gt;pkt_type
op_ne
id|PACKET_HOST
)paren
id|state
op_assign
id|NUD_STALE
suffix:semicolon
id|neigh_update
c_func
(paren
id|n
comma
id|sha
comma
id|state
comma
id|override
comma
l_int|1
)paren
suffix:semicolon
id|neigh_release
c_func
(paren
id|n
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_dev
)paren
id|in_dev_put
c_func
(paren
id|in_dev
)paren
suffix:semicolon
id|out_of_mem
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;User level interface (ioctl, /proc)&n; */
multiline_comment|/*&n; *&t;Set (create) an ARP cache entry.&n; */
DECL|function|arp_req_set
r_int
id|arp_req_set
c_func
(paren
r_struct
id|arpreq
op_star
id|r
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|u32
id|ip
op_assign
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;arp_pa
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
suffix:semicolon
r_struct
id|neighbour
op_star
id|neigh
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_PUBL
)paren
(brace
id|u32
id|mask
op_assign
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;arp_netmask
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_logical_and
id|mask
op_ne
l_int|0xFFFFFFFF
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_and
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_COM
)paren
)paren
(brace
id|dev
op_assign
id|dev_getbyhwaddr
c_func
(paren
id|r-&gt;arp_ha.sa_family
comma
id|r-&gt;arp_ha.sa_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mask
)paren
(brace
r_if
c_cond
(paren
id|pneigh_lookup
c_func
(paren
op_amp
id|arp_tbl
comma
op_amp
id|ip
comma
id|dev
comma
l_int|1
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOBUFS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|ipv4_devconf.proxy_arp
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|__in_dev_get
c_func
(paren
id|dev
)paren
)paren
(brace
id|__in_dev_get
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|cnf.proxy_arp
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_PERM
)paren
id|r-&gt;arp_flags
op_or_assign
id|ATF_COM
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ip_route_output
c_func
(paren
op_amp
id|rt
comma
id|ip
comma
l_int|0
comma
id|RTO_ONLINK
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|dev
op_assign
id|rt-&gt;u.dst.dev
suffix:semicolon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r-&gt;arp_ha.sa_family
op_ne
id|dev-&gt;type
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|neigh
op_assign
id|__neigh_lookup_errno
c_func
(paren
op_amp
id|arp_tbl
comma
op_amp
id|ip
comma
id|dev
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|neigh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|neigh
)paren
)paren
(brace
r_int
id|state
op_assign
id|NUD_STALE
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_PERM
)paren
id|state
op_assign
id|NUD_PERMANENT
suffix:semicolon
id|err
op_assign
id|neigh_update
c_func
(paren
id|neigh
comma
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_COM
)paren
ques
c_cond
id|r-&gt;arp_ha.sa_data
suffix:colon
l_int|NULL
comma
id|state
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|neigh_release
c_func
(paren
id|neigh
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|arp_state_to_flags
r_static
r_int
id|arp_state_to_flags
c_func
(paren
r_struct
id|neighbour
op_star
id|neigh
)paren
(brace
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|neigh-&gt;nud_state
op_amp
id|NUD_PERMANENT
)paren
id|flags
op_assign
id|ATF_PERM
op_or
id|ATF_COM
suffix:semicolon
r_else
r_if
c_cond
(paren
id|neigh-&gt;nud_state
op_amp
id|NUD_VALID
)paren
id|flags
op_assign
id|ATF_COM
suffix:semicolon
r_return
id|flags
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get an ARP cache entry.&n; */
DECL|function|arp_req_get
r_static
r_int
id|arp_req_get
c_func
(paren
r_struct
id|arpreq
op_star
id|r
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|u32
id|ip
op_assign
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;arp_pa
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
suffix:semicolon
r_struct
id|neighbour
op_star
id|neigh
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
id|neigh
op_assign
id|neigh_lookup
c_func
(paren
op_amp
id|arp_tbl
comma
op_amp
id|ip
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|neigh
)paren
(brace
id|read_lock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|r-&gt;arp_ha.sa_data
comma
id|neigh-&gt;ha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|r-&gt;arp_flags
op_assign
id|arp_state_to_flags
c_func
(paren
id|neigh
)paren
suffix:semicolon
id|read_unlock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
id|r-&gt;arp_ha.sa_family
op_assign
id|dev-&gt;type
suffix:semicolon
id|strncpy
c_func
(paren
id|r-&gt;arp_dev
comma
id|dev-&gt;name
comma
r_sizeof
(paren
id|r-&gt;arp_dev
)paren
)paren
suffix:semicolon
id|neigh_release
c_func
(paren
id|neigh
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|arp_req_delete
r_int
id|arp_req_delete
c_func
(paren
r_struct
id|arpreq
op_star
id|r
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|err
suffix:semicolon
id|u32
id|ip
op_assign
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;arp_pa
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
suffix:semicolon
r_struct
id|neighbour
op_star
id|neigh
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_PUBL
)paren
(brace
id|u32
id|mask
op_assign
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;arp_netmask
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_eq
l_int|0xFFFFFFFF
)paren
r_return
id|pneigh_delete
c_func
(paren
op_amp
id|arp_tbl
comma
op_amp
id|ip
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|ipv4_devconf.proxy_arp
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|__in_dev_get
c_func
(paren
id|dev
)paren
)paren
(brace
id|__in_dev_get
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|cnf.proxy_arp
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|ip_route_output
c_func
(paren
op_amp
id|rt
comma
id|ip
comma
l_int|0
comma
id|RTO_ONLINK
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|dev
op_assign
id|rt-&gt;u.dst.dev
suffix:semicolon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
id|neigh
op_assign
id|neigh_lookup
c_func
(paren
op_amp
id|arp_tbl
comma
op_amp
id|ip
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|neigh
)paren
(brace
r_if
c_cond
(paren
id|neigh-&gt;nud_state
op_amp
op_complement
id|NUD_NOARP
)paren
id|err
op_assign
id|neigh_update
c_func
(paren
id|neigh
comma
l_int|NULL
comma
id|NUD_FAILED
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|neigh_release
c_func
(paren
id|neigh
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Handle an ARP layer I/O control request.&n; */
DECL|function|arp_ioctl
r_int
id|arp_ioctl
c_func
(paren
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|arpreq
id|r
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCDARP
suffix:colon
r_case
id|SIOCSARP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_case
id|SIOCGARP
suffix:colon
id|err
op_assign
id|copy_from_user
c_func
(paren
op_amp
id|r
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r.arp_pa.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EPFNOSUPPORT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r.arp_flags
op_amp
id|ATF_PUBL
)paren
op_logical_and
(paren
id|r.arp_flags
op_amp
(paren
id|ATF_NETMASK
op_or
id|ATF_DONTPUB
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r.arp_flags
op_amp
id|ATF_NETMASK
)paren
)paren
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r.arp_netmask
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
op_assign
id|__constant_htonl
c_func
(paren
l_int|0xFFFFFFFFUL
)paren
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r.arp_dev
(braket
l_int|0
)braket
)paren
(brace
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|__dev_get_by_name
c_func
(paren
id|r.arp_dev
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Mmmm... It is wrong... ARPHRD_NETROM==0 */
r_if
c_cond
(paren
op_logical_neg
id|r.arp_ha.sa_family
)paren
id|r.arp_ha.sa_family
op_assign
id|dev-&gt;type
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r.arp_flags
op_amp
id|ATF_COM
)paren
op_logical_and
id|r.arp_ha.sa_family
op_ne
id|dev-&gt;type
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd
op_eq
id|SIOCGARP
)paren
(brace
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCDARP
suffix:colon
id|err
op_assign
id|arp_req_delete
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSARP
suffix:colon
id|err
op_assign
id|arp_req_set
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGARP
suffix:colon
id|err
op_assign
id|arp_req_get
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|r
comma
r_sizeof
(paren
id|r
)paren
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out
suffix:colon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Write the contents of the ARP cache to a PROCfs file.&n; */
macro_line|#ifndef CONFIG_PROC_FS
DECL|function|arp_get_info
r_static
r_int
id|arp_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else
macro_line|#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
r_static
r_char
op_star
id|ax2asc2
c_func
(paren
id|ax25_address
op_star
id|a
comma
r_char
op_star
id|buf
)paren
suffix:semicolon
macro_line|#endif
DECL|macro|HBUFFERLEN
mdefine_line|#define HBUFFERLEN 30
DECL|function|arp_get_info
r_static
r_int
id|arp_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|size
suffix:semicolon
r_char
id|hbuffer
(braket
id|HBUFFERLEN
)braket
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_const
r_char
id|hexbuf
(braket
)braket
op_assign
l_string|&quot;0123456789ABCDEF&quot;
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;IP address       HW type     Flags       HW address            Mask     Device&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|NEIGH_HASHMASK
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|neighbour
op_star
id|n
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|arp_tbl.lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|arp_tbl.hash_buckets
(braket
id|i
)braket
suffix:semicolon
id|n
suffix:semicolon
id|n
op_assign
id|n-&gt;next
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|n-&gt;dev
suffix:semicolon
r_int
id|hatype
op_assign
id|dev-&gt;type
suffix:semicolon
multiline_comment|/* Do not confuse users &quot;arp -a&quot; with magic entries */
r_if
c_cond
(paren
op_logical_neg
(paren
id|n-&gt;nud_state
op_amp
op_complement
id|NUD_NOARP
)paren
)paren
r_continue
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|n-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Convert hardware address to XX:XX:XX:XX ... form.&n; */
macro_line|#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
r_if
c_cond
(paren
id|hatype
op_eq
id|ARPHRD_AX25
op_logical_or
id|hatype
op_eq
id|ARPHRD_NETROM
)paren
id|ax2asc2
c_func
(paren
(paren
id|ax25_address
op_star
)paren
id|n-&gt;ha
comma
id|hbuffer
)paren
suffix:semicolon
r_else
(brace
macro_line|#endif
r_for
c_loop
(paren
id|k
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|HBUFFERLEN
op_minus
l_int|3
op_logical_and
id|j
OL
id|dev-&gt;addr_len
suffix:semicolon
id|j
op_increment
)paren
(brace
id|hbuffer
(braket
id|k
op_increment
)braket
op_assign
id|hexbuf
(braket
(paren
id|n-&gt;ha
(braket
id|j
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|15
)braket
suffix:semicolon
id|hbuffer
(braket
id|k
op_increment
)braket
op_assign
id|hexbuf
(braket
id|n-&gt;ha
(braket
id|j
)braket
op_amp
l_int|15
)braket
suffix:semicolon
id|hbuffer
(braket
id|k
op_increment
)braket
op_assign
l_char|&squot;:&squot;
suffix:semicolon
)brace
id|hbuffer
(braket
op_decrement
id|k
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
)brace
macro_line|#endif
(brace
r_char
id|tbuf
(braket
l_int|16
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot;%u.%u.%u.%u&quot;
comma
id|NIPQUAD
c_func
(paren
op_star
(paren
id|u32
op_star
)paren
id|n-&gt;primary_key
)paren
)paren
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%-16s 0x%-10x0x%-10x%s&quot;
l_string|&quot;     *        %s&bslash;n&quot;
comma
id|tbuf
comma
id|hatype
comma
id|arp_state_to_flags
c_func
(paren
id|n
)paren
comma
id|hbuffer
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|n-&gt;lock
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_le
id|offset
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|offset
op_plus
id|length
)paren
(brace
id|read_unlock_bh
c_func
(paren
op_amp
id|arp_tbl.lock
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|arp_tbl.lock
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|PNEIGH_HASHMASK
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|pneigh_entry
op_star
id|n
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|arp_tbl.phash_buckets
(braket
id|i
)braket
suffix:semicolon
id|n
suffix:semicolon
id|n
op_assign
id|n-&gt;next
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|n-&gt;dev
suffix:semicolon
r_int
id|hatype
op_assign
id|dev
ques
c_cond
id|dev-&gt;type
suffix:colon
l_int|0
suffix:semicolon
(brace
r_char
id|tbuf
(braket
l_int|16
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot;%u.%u.%u.%u&quot;
comma
id|NIPQUAD
c_func
(paren
op_star
(paren
id|u32
op_star
)paren
id|n-&gt;key
)paren
)paren
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%-16s 0x%-10x0x%-10x%s&quot;
l_string|&quot;     *        %s&bslash;n&quot;
comma
id|tbuf
comma
id|hatype
comma
id|ATF_PUBL
op_or
id|ATF_PERM
comma
l_string|&quot;00:00:00:00:00:00&quot;
comma
id|dev
ques
c_cond
id|dev-&gt;name
suffix:colon
l_string|&quot;*&quot;
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_le
id|offset
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|offset
op_plus
id|length
)paren
r_goto
id|done
suffix:semicolon
)brace
)brace
id|done
suffix:colon
op_star
id|start
op_assign
id|buffer
op_plus
id|len
op_minus
(paren
id|pos
op_minus
id|offset
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_assign
id|pos
op_minus
id|offset
suffix:semicolon
multiline_comment|/* Start slop */
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
multiline_comment|/* Ending slop */
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Note, that it is not on notifier chain.&n;   It is necessary, that this routine was called after route cache will be&n;   flushed.&n; */
DECL|function|arp_ifdown
r_void
id|arp_ifdown
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|neigh_ifdown
c_func
(paren
op_amp
id|arp_tbl
comma
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Called once on startup.&n; */
DECL|variable|arp_packet_type
r_static
r_struct
id|packet_type
id|arp_packet_type
op_assign
(brace
id|__constant_htons
c_func
(paren
id|ETH_P_ARP
)paren
comma
l_int|NULL
comma
multiline_comment|/* All devices */
id|arp_rcv
comma
(paren
r_void
op_star
)paren
l_int|1
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|arp_init
r_void
id|__init
id|arp_init
(paren
r_void
)paren
(brace
id|neigh_table_init
c_func
(paren
op_amp
id|arp_tbl
)paren
suffix:semicolon
id|dev_add_pack
c_func
(paren
op_amp
id|arp_packet_type
)paren
suffix:semicolon
id|proc_net_create
(paren
l_string|&quot;arp&quot;
comma
l_int|0
comma
id|arp_get_info
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SYSCTL
id|neigh_sysctl_register
c_func
(paren
l_int|NULL
comma
op_amp
id|arp_tbl.parms
comma
id|NET_IPV4
comma
id|NET_IPV4_NEIGH
comma
l_string|&quot;ipv4&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef CONFIG_PROC_FS
macro_line|#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
multiline_comment|/*&n; *&t;ax25 -&gt; ASCII conversion&n; */
DECL|function|ax2asc2
r_char
op_star
id|ax2asc2
c_func
(paren
id|ax25_address
op_star
id|a
comma
r_char
op_star
id|buf
)paren
(brace
r_char
id|c
comma
op_star
id|s
suffix:semicolon
r_int
id|n
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
comma
id|s
op_assign
id|buf
suffix:semicolon
id|n
OL
l_int|6
suffix:semicolon
id|n
op_increment
)paren
(brace
id|c
op_assign
(paren
id|a-&gt;ax25_call
(braket
id|n
)braket
op_rshift
l_int|1
)paren
op_amp
l_int|0x7F
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot; &squot;
)paren
op_star
id|s
op_increment
op_assign
id|c
suffix:semicolon
)brace
op_star
id|s
op_increment
op_assign
l_char|&squot;-&squot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|n
op_assign
(paren
(paren
id|a-&gt;ax25_call
(braket
l_int|6
)braket
op_rshift
l_int|1
)paren
op_amp
l_int|0x0F
)paren
)paren
OG
l_int|9
)paren
(brace
op_star
id|s
op_increment
op_assign
l_char|&squot;1&squot;
suffix:semicolon
id|n
op_sub_assign
l_int|10
suffix:semicolon
)brace
op_star
id|s
op_increment
op_assign
id|n
op_plus
l_char|&squot;0&squot;
suffix:semicolon
op_star
id|s
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_star
id|buf
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
op_star
id|buf
op_eq
l_char|&squot;-&squot;
)paren
r_return
l_string|&quot;*&quot;
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif
eof
