multiline_comment|/* linux/net/inet/arp.c&n; *&n; * Copyright (C) 1994 by Florian  La Roche&n; *&n; * This module implements the Address Resolution Protocol ARP (RFC 826),&n; * which is used to convert IP addresses (or in the future maybe other&n; * high-level addresses into a low-level hardware address (like an Ethernet&n; * address).&n; *&n; * FIXME:&n; *&t;Experiment with better retransmit timers&n; *&t;Clean up the timer deletions&n; *&t;If you create a proxy entry set your interface address to the address&n; *&t;and then delete it, proxies may get out of sync with reality - check this&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; *&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;Removed the ethernet assumptions in Florian&squot;s code&n; *&t;&t;Alan Cox&t;:&t;Fixed some small errors in the ARP logic&n; *&t;&t;Alan Cox&t;:&t;Allow &gt;4K in /proc&n; *&t;&t;Alan Cox&t;:&t;Make ARP add its own protocol entry&n; *&n; *&t;&t;Ross Martin     :       Rewrote arp_rcv() and arp_get_info()&n; *&t;&t;Stephen Henson&t;:&t;Add AX25 support to arp_get_info()&n; *&t;&t;Alan Cox&t;:&t;Drop data when a device is downed.&n; *&t;&t;Alan Cox&t;:&t;Use init_timer().&n; *&t;&t;Alan Cox&t;:&t;Double lock fixes.&n; *&t;&t;Martin Seine&t;:&t;Move the arphdr structure&n; *&t;&t;&t;&t;&t;to if_arp.h for compatibility.&n; *&t;&t;&t;&t;&t;with BSD based programs.&n; *&t;&t;Andrew Tridgell :       Added ARP netmask code and&n; *&t;&t;&t;&t;&t;re-arranged proxy handling.&n; *&t;&t;Alan Cox&t;:&t;Changed to use notifiers.&n; *&t;&t;Niibe Yutaka&t;:&t;Reply for this device or proxies only.&n; *&t;&t;Alan Cox&t;:&t;Don&squot;t proxy across hardware types!&n; *&t;&t;Jonathan Naylor :&t;Added support for NET/ROM.&n; *&t;&t;Mike Shaver     :       RFC1122 checks.&n; *&t;&t;Jonathan Naylor :&t;Only lookup the hardware address for&n; *&t;&t;&t;&t;&t;the correct hardware type.&n; *&t;&t;Germano Caronni&t;:&t;Assorted subtle races.&n; *&t;&t;Craig Schlenter :&t;Don&squot;t modify permanent entry &n; *&t;&t;&t;&t;&t;during arp_rcv.&n; *&t;&t;Russ Nelson&t;:&t;Tidied up a few bits.&n; *&t;&t;Alexey Kuznetsov:&t;Major changes to caching and behaviour,&n; *&t;&t;&t;&t;&t;eg intelligent arp probing and generation&n; *&t;&t;&t;&t;&t;of host down events.&n; *&t;&t;Alan Cox&t;:&t;Missing unlock in device events.&n; *&t;&t;Eckes&t;&t;:&t;ARP ioctl control errors.&n; */
multiline_comment|/* RFC1122 Status:&n;   2.3.2.1 (ARP Cache Validation):&n;     MUST provide mechanism to flush stale cache entries (OK)&n;     SHOULD be able to configure cache timeout (NOT YET)&n;     MUST throttle ARP retransmits (OK)&n;   2.3.2.2 (ARP Packet Queue):&n;     SHOULD save at least one packet from each &quot;conversation&quot; with an&n;       unresolved IP address.  (OK)&n;   950727 -- MS&n;*/
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/trdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#ifdef CONFIG_AX25
macro_line|#include &lt;net/ax25.h&gt;
macro_line|#ifdef CONFIG_NETROM
macro_line|#include &lt;net/netrom.h&gt;
macro_line|#endif
macro_line|#endif
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;stdarg.h&gt;
multiline_comment|/*&n; *&t;This structure defines the ARP mapping cache. As long as we make changes&n; *&t;in this structure, we keep interrupts off. But normally we can copy the&n; *&t;hardware address and the device pointer in a local variable and then &n; *&t;make any &quot;long calls&quot; to send a packet out.&n; */
DECL|struct|arp_table
r_struct
id|arp_table
(brace
DECL|member|next
r_struct
id|arp_table
op_star
id|next
suffix:semicolon
multiline_comment|/* Linked entry list &t;&t;*/
DECL|member|last_used
r_int
r_int
id|last_used
suffix:semicolon
multiline_comment|/* For expiry &t;&t;&t;*/
DECL|member|last_updated
r_int
r_int
id|last_updated
suffix:semicolon
multiline_comment|/* For expiry &t;&t;&t;*/
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Control status &t;&t;*/
DECL|member|ip
id|u32
id|ip
suffix:semicolon
multiline_comment|/* ip address of entry &t;&t;*/
DECL|member|mask
id|u32
id|mask
suffix:semicolon
multiline_comment|/* netmask - used for generalised proxy arps (tridge) &t;&t;*/
DECL|member|ha
r_int
r_char
id|ha
(braket
id|MAX_ADDR_LEN
)braket
suffix:semicolon
multiline_comment|/* Hardware address&t;&t;*/
DECL|member|dev
r_struct
id|device
op_star
id|dev
suffix:semicolon
multiline_comment|/* Device the entry is tied to &t;*/
multiline_comment|/*&n;&t; *&t;The following entries are only used for unresolved hw addresses.&n;&t; */
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* expire timer &t;&t;*/
DECL|member|retries
r_int
id|retries
suffix:semicolon
multiline_comment|/* remaining retries&t; &t;*/
DECL|member|skb
r_struct
id|sk_buff_head
id|skb
suffix:semicolon
multiline_comment|/* list of queued packets &t;*/
DECL|member|hh
r_struct
id|hh_cache
op_star
id|hh
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Configurable Parameters (don&squot;t touch unless you know what you are doing&n; */
multiline_comment|/*&n; *&t;If an arp request is send, ARP_RES_TIME is the timeout value until the&n; *&t;next request is send.&n; * &t;RFC1122: OK.  Throttles ARPing, as per 2.3.2.1. (MUST)&n; *&t;The recommended minimum timeout is 1 second per destination.&n; *&t;This timeout is prolongated to ARP_DEAD_RES_TIME, if&n; *&t;destination does not respond.&n; */
DECL|macro|ARP_RES_TIME
mdefine_line|#define ARP_RES_TIME&t;&t;(5*HZ)
DECL|macro|ARP_DEAD_RES_TIME
mdefine_line|#define ARP_DEAD_RES_TIME&t;(60*HZ)
multiline_comment|/*&n; *&t;The number of times an arp request is send, until the host is&n; *&t;considered temporarily unreachable.&n; */
DECL|macro|ARP_MAX_TRIES
mdefine_line|#define ARP_MAX_TRIES&t;&t;3
multiline_comment|/*&n; *&t;After that time, an unused entry is deleted from the arp table.&n; */
DECL|macro|ARP_TIMEOUT
mdefine_line|#define ARP_TIMEOUT&t;&t;(600*HZ)
multiline_comment|/*&n; *&t;How often is the function &squot;arp_check_retries&squot; called.&n; *&t;An unused entry is invalidated in the time between ARP_TIMEOUT and&n; *&t;(ARP_TIMEOUT+ARP_CHECK_INTERVAL).&n; */
DECL|macro|ARP_CHECK_INTERVAL
mdefine_line|#define ARP_CHECK_INTERVAL&t;(60*HZ)
multiline_comment|/*&n; *&t;The entry is reconfirmed by sending point-to-point ARP&n; *&t;request after ARP_CONFIRM_INTERVAL. If destinations does not respond&n; *&t;for ARP_CONFIRM_TIMEOUT, normal broadcast resolution scheme is started.&n; */
DECL|macro|ARP_CONFIRM_INTERVAL
mdefine_line|#define ARP_CONFIRM_INTERVAL&t;(300*HZ)
DECL|macro|ARP_CONFIRM_TIMEOUT
mdefine_line|#define ARP_CONFIRM_TIMEOUT&t;ARP_RES_TIME
DECL|variable|arp_lock
r_static
r_int
r_int
id|arp_lock
suffix:semicolon
DECL|variable|arp_bh_mask
r_static
r_int
r_int
id|arp_bh_mask
suffix:semicolon
DECL|macro|ARP_BH_BACKLOG
mdefine_line|#define ARP_BH_BACKLOG&t;1
DECL|variable|arp_backlog
r_static
r_struct
id|arp_table
op_star
id|arp_backlog
suffix:semicolon
r_static
r_void
id|arp_run_bh
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|arp_check_expire
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|variable|arp_timer
r_static
r_struct
id|timer_list
id|arp_timer
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
id|ARP_CHECK_INTERVAL
comma
l_int|0L
comma
op_amp
id|arp_check_expire
)brace
suffix:semicolon
multiline_comment|/*&n; * The default arp netmask is just 255.255.255.255 which means it&squot;s&n; * a single machine entry. Only proxy entries can have other netmasks&n; */
DECL|macro|DEF_ARP_NETMASK
mdefine_line|#define DEF_ARP_NETMASK (~0)
multiline_comment|/*&n; * &t;The size of the hash table. Must be a power of two.&n; * &t;Maybe we should remove hashing in the future for arp and concentrate&n; * &t;on Patrick Schaaf&squot;s Host-Cache-Lookup...&n; */
DECL|macro|ARP_TABLE_SIZE
mdefine_line|#define ARP_TABLE_SIZE  16
DECL|macro|FULL_ARP_TABLE_SIZE
mdefine_line|#define FULL_ARP_TABLE_SIZE (ARP_TABLE_SIZE+1)
DECL|variable|arp_tables
r_struct
id|arp_table
op_star
id|arp_tables
(braket
id|FULL_ARP_TABLE_SIZE
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|macro|arp_proxy_list
mdefine_line|#define arp_proxy_list arp_tables[ARP_TABLE_SIZE]
multiline_comment|/*&n; *&t;The last bits in the IP address are used for the cache lookup.&n; *&t;A special entry is used for proxy arp entries&n; */
DECL|macro|HASH
mdefine_line|#define HASH(paddr) &t;&t;(htonl(paddr) &amp; (ARP_TABLE_SIZE - 1))
multiline_comment|/*&n; * Lock/unlock arp_table chains.&n; */
DECL|function|arp_fast_lock
r_static
id|__inline__
r_void
id|arp_fast_lock
c_func
(paren
r_void
)paren
(brace
id|ATOMIC_INCR
c_func
(paren
op_amp
id|arp_lock
)paren
suffix:semicolon
)brace
DECL|function|arp_fast_unlock
r_static
id|__inline__
r_void
id|arp_fast_unlock
c_func
(paren
r_void
)paren
(brace
id|ATOMIC_DECR
c_func
(paren
op_amp
id|arp_lock
)paren
suffix:semicolon
)brace
DECL|function|arp_unlock
r_static
id|__inline__
r_void
id|arp_unlock
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ATOMIC_DECR_AND_CHECK
c_func
(paren
op_amp
id|arp_lock
)paren
op_logical_and
id|arp_bh_mask
)paren
id|arp_run_bh
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Enqueue to FIFO list.&n; */
DECL|function|arp_enqueue
r_static
r_void
id|arp_enqueue
c_func
(paren
r_struct
id|arp_table
op_star
op_star
id|q
comma
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|arp_table
op_star
id|tail
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|tail
op_assign
op_star
id|q
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tail
)paren
id|entry-&gt;next
op_assign
id|entry
suffix:semicolon
r_else
(brace
id|entry-&gt;next
op_assign
id|tail-&gt;next
suffix:semicolon
id|tail-&gt;next
op_assign
id|entry
suffix:semicolon
)brace
op_star
id|q
op_assign
id|entry
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Dequeue from FIFO list,&n; * caller should mask interrupts.&n; */
DECL|function|arp_dequeue
r_static
r_struct
id|arp_table
op_star
id|arp_dequeue
c_func
(paren
r_struct
id|arp_table
op_star
op_star
id|q
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
op_star
id|q
)paren
(brace
id|entry
op_assign
(paren
op_star
id|q
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
(paren
op_star
id|q
)paren
op_member_access_from_pointer
id|next
op_assign
id|entry-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;next
op_eq
id|entry
)paren
op_star
id|q
op_assign
l_int|NULL
suffix:semicolon
id|entry-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|entry
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Purge all linked skb&squot;s of the entry.&n; */
DECL|function|arp_release_entry
r_static
r_void
id|arp_release_entry
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Release the list of `skb&squot; pointers. */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|skb_device_lock
c_func
(paren
id|skb
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Release the entry and all resources linked to it: skb&squot;s, hh&squot;s, timer&n; * &t;and certainly memory.&n; */
DECL|function|arp_free_entry
r_static
r_void
id|arp_free_entry
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|hh_cache
op_star
id|hh
comma
op_star
id|next
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|arp_release_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_for
c_loop
(paren
id|hh
op_assign
id|entry-&gt;hh
suffix:semicolon
id|hh
suffix:semicolon
id|hh
op_assign
id|next
)paren
(brace
id|next
op_assign
id|hh-&gt;hh_next
suffix:semicolon
id|hh-&gt;hh_arp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|hh-&gt;hh_refcnt
)paren
id|kfree_s
c_func
(paren
id|hh
comma
r_sizeof
(paren
r_struct
(paren
r_struct
id|hh_cache
)paren
)paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|entry
comma
r_sizeof
(paren
r_struct
id|arp_table
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * How many users has this entry?&n; */
DECL|function|arp_count_hhs
r_static
id|__inline__
r_int
id|arp_count_hhs
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_struct
id|hh_cache
op_star
id|hh
comma
op_star
op_star
id|hhp
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|hhp
op_assign
op_amp
id|entry-&gt;hh
suffix:semicolon
r_while
c_loop
(paren
(paren
id|hh
op_assign
op_star
id|hhp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|hh-&gt;hh_refcnt
op_eq
l_int|1
)paren
(brace
op_star
id|hhp
op_assign
id|hh-&gt;hh_next
suffix:semicolon
id|kfree_s
c_func
(paren
id|hh
comma
r_sizeof
(paren
r_struct
id|hh_cache
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|count
op_add_assign
id|hh-&gt;hh_refcnt
op_minus
l_int|1
suffix:semicolon
id|hhp
op_assign
op_amp
id|hh-&gt;hh_next
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * Invalidate all hh&squot;s, so that higher level will not try to use it.&n; */
DECL|function|arp_invalidate_hhs
r_static
id|__inline__
r_void
id|arp_invalidate_hhs
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_struct
id|hh_cache
op_star
id|hh
suffix:semicolon
r_for
c_loop
(paren
id|hh
op_assign
id|entry-&gt;hh
suffix:semicolon
id|hh
suffix:semicolon
id|hh
op_assign
id|hh-&gt;hh_next
)paren
id|hh-&gt;hh_uptodate
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Signal to device layer, that hardware address may be changed.&n; */
DECL|function|arp_update_hhs
r_static
id|__inline__
r_void
id|arp_update_hhs
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_struct
id|hh_cache
op_star
id|hh
suffix:semicolon
r_for
c_loop
(paren
id|hh
op_assign
id|entry-&gt;hh
suffix:semicolon
id|hh
suffix:semicolon
id|hh
op_assign
id|hh-&gt;hh_next
)paren
id|entry-&gt;dev
op_member_access_from_pointer
id|header_cache_update
c_func
(paren
id|hh
comma
id|entry-&gt;dev
comma
id|entry-&gt;ha
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Check if there are too old entries and remove them. If the ATF_PERM&n; *&t;flag is set, they are always left in the arp cache (permanent entry).&n; *      If an entry was not be confirmed  for ARP_CONFIRM_INTERVAL,&n; *&t;declare it invalid and send point-to-point ARP request.&n; *&t;If it will not be confirmed for ARP_CONFIRM_TIMEOUT,&n; *&t;give it to shred by arp_expire_entry.&n; */
DECL|function|arp_check_expire
r_static
r_void
id|arp_check_expire
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|arp_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arp_lock
)paren
(brace
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARP_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|arp_table
op_star
op_star
id|pentry
suffix:semicolon
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
op_star
id|pentry
)paren
op_ne
l_int|NULL
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|now
op_minus
id|entry-&gt;last_used
OG
id|ARP_TIMEOUT
op_logical_and
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_PERM
)paren
op_logical_and
op_logical_neg
id|arp_count_hhs
c_func
(paren
id|entry
)paren
)paren
(brace
op_star
id|pentry
op_assign
id|entry-&gt;next
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;arp_expire: %08x expired&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
id|arp_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;last_updated
op_logical_and
id|now
op_minus
id|entry-&gt;last_updated
OG
id|ARP_CONFIRM_INTERVAL
op_logical_and
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_PERM
)paren
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|entry-&gt;dev
suffix:semicolon
id|pentry
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
id|entry-&gt;flags
op_and_assign
op_complement
id|ATF_COM
suffix:semicolon
id|arp_invalidate_hhs
c_func
(paren
id|entry
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|entry-&gt;retries
op_assign
id|ARP_MAX_TRIES
op_plus
l_int|1
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|ARP_CONFIRM_TIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|entry-&gt;ip
comma
id|dev
comma
id|dev-&gt;pa_addr
comma
id|entry-&gt;ha
comma
id|dev-&gt;dev_addr
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;arp_expire: %08x requires confirmation&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
id|pentry
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
multiline_comment|/* go to next entry */
)brace
)brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
id|ip_rt_check_expire
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Set the timer again.&n;&t; */
id|arp_timer.expires
op_assign
id|jiffies
op_plus
id|ARP_CHECK_INTERVAL
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|arp_timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This function is called, if an entry is not resolved in ARP_RES_TIME.&n; *&t;When more than MAX_ARP_TRIES retries was done, release queued skb&squot;s,&n; *&t;but not discard entry itself if  it is in use.&n; */
DECL|function|arp_expire_request
r_static
r_void
id|arp_expire_request
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
op_assign
(paren
r_struct
id|arp_table
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|arp_table
op_star
op_star
id|pentry
suffix:semicolon
r_int
r_int
id|hash
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Since all timeouts are handled with interrupts enabled, there is a&n;&t; *&t;small chance, that this entry has just been resolved by an incoming&n;&t; *&t;packet. This is the only race condition, but it is handled...&n;&t; */
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arp_lock
)paren
(brace
macro_line|#if RT_CACHE_DEBUG &gt;= 1
id|printk
c_func
(paren
l_string|&quot;arp_expire_request: %08x postponed&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|10
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;last_updated
op_logical_and
op_decrement
id|entry-&gt;retries
OG
l_int|0
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|entry-&gt;dev
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;arp_expire_request: %08x timed out&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Set new timer. */
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|ARP_RES_TIME
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|entry-&gt;ip
comma
id|dev
comma
id|dev-&gt;pa_addr
comma
l_int|NULL
comma
id|dev-&gt;dev_addr
comma
l_int|NULL
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|arp_release_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arp_count_hhs
c_func
(paren
id|entry
)paren
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|entry-&gt;dev
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;arp_expire_request: %08x is dead&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
id|arp_release_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|entry-&gt;retries
op_assign
id|ARP_MAX_TRIES
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|entry-&gt;last_updated
op_assign
l_int|0
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|ARP_DEAD_RES_TIME
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|entry-&gt;ip
comma
id|dev
comma
id|dev-&gt;pa_addr
comma
l_int|NULL
comma
id|dev-&gt;dev_addr
comma
l_int|NULL
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|hash
op_assign
id|HASH
c_func
(paren
id|entry-&gt;ip
)paren
suffix:semicolon
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pentry
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_star
id|pentry
op_eq
id|entry
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|pentry
op_assign
id|entry-&gt;next
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;arp_expire_request: %08x is killed&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
id|arp_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pentry
op_assign
op_amp
(paren
op_star
id|pentry
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;arp_expire_request: bug: ARP entry is lost!&bslash;n&quot;
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Purge a device from the ARP queue&n; */
DECL|function|arp_device_event
r_int
id|arp_device_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|event
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|ptr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|event
op_ne
id|NETDEV_DOWN
)paren
r_return
id|NOTIFY_DONE
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This is a bit OTT - maybe we need some arp semaphores instead.&n;&t; */
macro_line|#if RT_CACHE_DEBUG &gt;= 1&t; 
r_if
c_cond
(paren
id|arp_lock
)paren
id|printk
c_func
(paren
l_string|&quot;arp_device_event: bug&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FULL_ARP_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|arp_table
op_star
op_star
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
op_star
id|pentry
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;dev
op_eq
id|dev
)paren
(brace
op_star
id|pentry
op_assign
id|entry-&gt;next
suffix:semicolon
multiline_comment|/* remove from list */
id|arp_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
r_else
id|pentry
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
multiline_comment|/* go to next entry */
)brace
)brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Create and send an arp packet. If (dest_hw == NULL), we create a broadcast&n; *&t;message.&n; */
DECL|function|arp_send
r_void
id|arp_send
c_func
(paren
r_int
id|type
comma
r_int
id|ptype
comma
id|u32
id|dest_ip
comma
r_struct
id|device
op_star
id|dev
comma
id|u32
id|src_ip
comma
r_int
r_char
op_star
id|dest_hw
comma
r_int
r_char
op_star
id|src_hw
comma
r_int
r_char
op_star
id|target_hw
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|arphdr
op_star
id|arp
suffix:semicolon
r_int
r_char
op_star
id|arp_ptr
suffix:semicolon
multiline_comment|/*&n;&t; *&t;No arp on this interface.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_NOARP
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate a buffer&n;&t; */
id|skb
op_assign
id|alloc_skb
c_func
(paren
r_sizeof
(paren
r_struct
id|arphdr
)paren
op_plus
l_int|2
op_star
(paren
id|dev-&gt;addr_len
op_plus
l_int|4
)paren
op_plus
id|dev-&gt;hard_header_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ARP: no memory to send an arp packet&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
id|arp
op_assign
(paren
r_struct
id|arphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|arphdr
)paren
op_plus
l_int|2
op_star
(paren
id|dev-&gt;addr_len
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
(paren
id|ETH_P_IP
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fill the device header for the ARP frame&n;&t; */
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|skb
comma
id|dev
comma
id|ptype
comma
id|dest_hw
ques
c_cond
id|dest_hw
suffix:colon
id|dev-&gt;broadcast
comma
id|src_hw
ques
c_cond
id|src_hw
suffix:colon
l_int|NULL
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Fill out the arp protocol part. */
id|arp-&gt;ar_hrd
op_assign
id|htons
c_func
(paren
id|dev-&gt;type
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_AX25
macro_line|#ifdef CONFIG_NETROM
id|arp-&gt;ar_pro
op_assign
(paren
id|dev-&gt;type
op_eq
id|ARPHRD_AX25
op_logical_or
id|dev-&gt;type
op_eq
id|ARPHRD_NETROM
)paren
ques
c_cond
id|htons
c_func
(paren
id|AX25_P_IP
)paren
suffix:colon
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
macro_line|#else
id|arp-&gt;ar_pro
op_assign
(paren
id|dev-&gt;type
op_ne
id|ARPHRD_AX25
)paren
ques
c_cond
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:colon
id|htons
c_func
(paren
id|AX25_P_IP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#else
id|arp-&gt;ar_pro
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
macro_line|#endif
id|arp-&gt;ar_hln
op_assign
id|dev-&gt;addr_len
suffix:semicolon
id|arp-&gt;ar_pln
op_assign
l_int|4
suffix:semicolon
id|arp-&gt;ar_op
op_assign
id|htons
c_func
(paren
id|type
)paren
suffix:semicolon
id|arp_ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|arp
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|arp_ptr
comma
id|src_hw
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
id|arp_ptr
comma
op_amp
id|src_ip
comma
l_int|4
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|target_hw
op_ne
l_int|NULL
)paren
id|memcpy
c_func
(paren
id|arp_ptr
comma
id|target_hw
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_else
id|memset
c_func
(paren
id|arp_ptr
comma
l_int|0
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
id|arp_ptr
comma
op_amp
id|dest_ip
comma
l_int|4
)paren
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This will try to retransmit everything on the queue.&n; */
DECL|function|arp_send_q
r_static
r_void
id|arp_send_q
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Empty the entire queue, building its data up ready to send&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arp_send_q: incomplete entry for %s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|entry-&gt;ip
)paren
)paren
suffix:semicolon
multiline_comment|/* Can&squot;t flush the skb, because RFC1122 says to hang on to */
multiline_comment|/* at least one from any unresolved entry.  --MS */
multiline_comment|/* Whats happened is that someone has &squot;unresolved&squot; the entry&n;&t;&t;   as we got to use it - this &squot;can&squot;t happen&squot; -- AC */
r_return
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb_device_lock
c_func
(paren
id|skb
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;dev
op_member_access_from_pointer
id|rebuild_header
c_func
(paren
id|skb-&gt;data
comma
id|skb-&gt;dev
comma
id|skb-&gt;raddr
comma
id|skb
)paren
)paren
(brace
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;sk
op_eq
l_int|NULL
)paren
(brace
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
id|skb-&gt;sk-&gt;priority
)paren
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Delete an ARP mapping entry in the cache.&n; */
DECL|function|arp_destroy
r_static
r_void
id|arp_destroy
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_struct
id|arp_table
op_star
id|entry1
suffix:semicolon
r_struct
id|arp_table
op_star
op_star
id|pentry
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|ATF_PUBL
)paren
id|pentry
op_assign
op_amp
id|arp_proxy_list
suffix:semicolon
r_else
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|HASH
c_func
(paren
id|entry-&gt;ip
)paren
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry1
op_assign
op_star
id|pentry
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|entry1
op_eq
id|entry
)paren
(brace
op_star
id|pentry
op_assign
id|entry1-&gt;next
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|arp_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pentry
op_assign
op_amp
id|entry1-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Receive an arp request by the device layer. Maybe I rewrite it, to&n; *&t;use the incoming packet for the reply. The time for the current&n; *&t;&quot;overhead&quot; isn&squot;t that high...&n; */
DECL|function|arp_rcv
r_int
id|arp_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
multiline_comment|/*&n; *&t;We shouldn&squot;t use this type conversion. Check later.&n; */
r_struct
id|arphdr
op_star
id|arp
op_assign
(paren
r_struct
id|arphdr
op_star
)paren
id|skb-&gt;h.raw
suffix:semicolon
r_int
r_char
op_star
id|arp_ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|arp
op_plus
l_int|1
)paren
suffix:semicolon
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|arp_table
op_star
id|proxy_entry
suffix:semicolon
r_int
r_int
id|hash
suffix:semicolon
r_int
r_char
id|ha
(braket
id|MAX_ADDR_LEN
)braket
suffix:semicolon
multiline_comment|/* So we can enable ints again. */
r_int
r_char
op_star
id|sha
comma
op_star
id|tha
suffix:semicolon
id|u32
id|sip
comma
id|tip
suffix:semicolon
multiline_comment|/*&n; *&t;The hardware length of the packet should match the hardware length&n; *&t;of the device.  Similarly, the hardware types should match.  The&n; *&t;device should be ARP-able.  Also, if pln is not 4, then the lookup&n; *&t;is not from an IP number.  We can&squot;t currently handle this, so toss&n; *&t;it. &n; */
r_if
c_cond
(paren
id|arp-&gt;ar_hln
op_ne
id|dev-&gt;addr_len
op_logical_or
id|dev-&gt;type
op_ne
id|ntohs
c_func
(paren
id|arp-&gt;ar_hrd
)paren
op_logical_or
id|dev-&gt;flags
op_amp
id|IFF_NOARP
op_logical_or
id|arp-&gt;ar_pln
op_ne
l_int|4
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Should this be an error/printk?  Seems like something */
multiline_comment|/* you&squot;d want to know about. Unless it&squot;s just !IFF_NOARP. -- MS */
)brace
multiline_comment|/*&n; *&t;Another test.&n; *&t;The logic here is that the protocol being looked up by arp should &n; *&t;match the protocol the device speaks.  If it doesn&squot;t, there is a&n; *&t;problem, so toss the packet.&n; */
multiline_comment|/* Again, should this be an error/printk? -- MS */
r_switch
c_cond
(paren
id|dev-&gt;type
)paren
(brace
macro_line|#ifdef CONFIG_AX25
r_case
id|ARPHRD_AX25
suffix:colon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|AX25_P_IP
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NETROM
r_case
id|ARPHRD_NETROM
suffix:colon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|AX25_P_IP
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#endif
r_case
id|ARPHRD_ETHER
suffix:colon
r_case
id|ARPHRD_ARCNET
suffix:colon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ARPHRD_IEEE802
suffix:colon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ARP: dev-&gt;type mangled!&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Extract fields&n; */
id|sha
op_assign
id|arp_ptr
suffix:semicolon
id|arp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|sip
comma
id|arp_ptr
comma
l_int|4
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
l_int|4
suffix:semicolon
id|tha
op_assign
id|arp_ptr
suffix:semicolon
id|arp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|tip
comma
id|arp_ptr
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* &n; *&t;Check for bad requests for 127.x.x.x and requests for multicast&n; *&t;addresses.  If this is one such, delete it.&n; */
r_if
c_cond
(paren
id|LOOPBACK
c_func
(paren
id|tip
)paren
op_logical_or
id|MULTICAST
c_func
(paren
id|tip
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Process entry.  The idea here is we want to send a reply if it is a&n; *  request for us or if it is a request for someone else that we hold&n; *  a proxy for.  We want to add an entry to our cache if it is a reply&n; *  to us or if it is a request for our address.  &n; *  (The assumption for this last is that if someone is requesting our &n; *  address, they are probably intending to talk to us, so it saves time &n; *  if we cache their address.  Their address is also probably not in &n; *  our cache, since ours is not in their cache.)&n; * &n; *  Putting this another way, we only care about replies if they are to&n; *  us, in which case we add them to the cache.  For requests, we care&n; *  about those for us and those for our proxies.  We reply to both,&n; *  and in the case of requests for us we add the requester to the arp &n; *  cache.&n; */
r_if
c_cond
(paren
id|arp-&gt;ar_op
op_eq
id|htons
c_func
(paren
id|ARPOP_REQUEST
)paren
)paren
(brace
multiline_comment|/*&n; * Only reply for the real device address or when it&squot;s in our proxy tables&n; */
r_if
c_cond
(paren
id|tip
op_ne
id|dev-&gt;pa_addr
)paren
(brace
multiline_comment|/*&n; * &t;To get in here, it is a request for someone else.  We need to&n; * &t;check if that someone else is one of our proxies.  If it isn&squot;t,&n; * &t;we can toss it.&n; */
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|proxy_entry
op_assign
id|arp_proxy_list
suffix:semicolon
id|proxy_entry
suffix:semicolon
id|proxy_entry
op_assign
id|proxy_entry-&gt;next
)paren
(brace
multiline_comment|/* we will respond to a proxy arp request&n;&t;&t;&t;&t;   if the masked arp table ip matches the masked&n;&t;&t;&t;&t;   tip. This allows a single proxy arp table&n;&t;&t;&t;&t;   entry to be used on a gateway machine to handle&n;&t;&t;&t;&t;   all requests for a whole network, rather than&n;&t;&t;&t;&t;   having to use a huge number of proxy arp entries&n;&t;&t;&t;&t;   and having to keep them uptodate.&n;&t;&t;&t;&t;   */
r_if
c_cond
(paren
id|proxy_entry-&gt;dev
op_eq
id|dev
op_logical_and
op_logical_neg
(paren
(paren
id|proxy_entry-&gt;ip
op_xor
id|tip
)paren
op_amp
id|proxy_entry-&gt;mask
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|proxy_entry
)paren
(brace
id|memcpy
c_func
(paren
id|ha
comma
id|proxy_entry-&gt;ha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
id|arp_send
c_func
(paren
id|ARPOP_REPLY
comma
id|ETH_P_ARP
comma
id|sip
comma
id|dev
comma
id|tip
comma
id|sha
comma
id|ha
comma
id|sha
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n; * &t;To get here, it must be an arp request for us.  We need to reply.&n; */
id|arp_send
c_func
(paren
id|ARPOP_REPLY
comma
id|ETH_P_ARP
comma
id|sip
comma
id|dev
comma
id|tip
comma
id|sha
comma
id|dev-&gt;dev_addr
comma
id|sha
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;It is now an arp reply.&n; */
r_if
c_cond
(paren
id|ip_chk_addr
c_func
(paren
id|tip
)paren
op_ne
id|IS_MYADDR
)paren
(brace
multiline_comment|/*&n; *&t;Replies to other machines get tossed.&n; */
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Now all replies are handled.  Next, anything that falls through to here&n; * needs to be added to the arp cache, or have its entry updated if it is &n; * there.&n; */
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
id|hash
op_assign
id|HASH
c_func
(paren
id|sip
)paren
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|entry
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|sip
op_logical_and
id|entry-&gt;dev
op_eq
id|dev
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
(brace
multiline_comment|/*&n; *&t;Entry found; update it only if it is not a permanent entry.&n; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_PERM
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|entry-&gt;ha
comma
id|sha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|entry-&gt;last_updated
op_assign
id|jiffies
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
)paren
(brace
multiline_comment|/*&n; *&t;This entry was incomplete.  Delete the retransmit timer&n; *&t;and switch to complete status.&n; */
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;flags
op_or_assign
id|ATF_COM
suffix:semicolon
id|arp_update_hhs
c_func
(paren
id|entry
)paren
suffix:semicolon
multiline_comment|/* &n; *&t;Send out waiting packets. We might have problems, if someone is &n; *&t;manually removing entries right now -- entry might become invalid &n; *&t;underneath us.&n; */
id|arp_send_q
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n; * &t;No entry found.  Need to add a new entry to the arp table.&n; */
id|entry
op_assign
(paren
r_struct
id|arp_table
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arp_table
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
(brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ARP: no memory for new arp entry&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|entry-&gt;mask
op_assign
id|DEF_ARP_NETMASK
suffix:semicolon
id|entry-&gt;ip
op_assign
id|sip
suffix:semicolon
id|entry-&gt;flags
op_assign
id|ATF_COM
suffix:semicolon
id|entry-&gt;hh
op_assign
l_int|NULL
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;timer.function
op_assign
id|arp_expire_request
suffix:semicolon
id|entry-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|entry
suffix:semicolon
id|memcpy
c_func
(paren
id|entry-&gt;ha
comma
id|sha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|entry-&gt;last_updated
op_assign
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|entry-&gt;dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arp_lock
op_eq
l_int|1
)paren
(brace
id|entry-&gt;next
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|arp_tables
(braket
id|hash
)braket
op_assign
id|entry
suffix:semicolon
)brace
r_else
(brace
macro_line|#if RT_CACHE_DEBUG &gt;= 1
id|printk
c_func
(paren
l_string|&quot;arp_rcv: %08x backlogged&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
id|arp_enqueue
c_func
(paren
op_amp
id|arp_backlog
comma
id|entry
)paren
suffix:semicolon
id|arp_bh_mask
op_or_assign
id|ARP_BH_BACKLOG
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Replies have been sent, and entries have been added.  All done.&n; */
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Lookup ARP entry by (addr, dev) pair.&n; * Flags: ATF_PUBL - search for proxy entries&n; *&t;  ATF_NETMASK - search for proxy network entry.&n; * NOTE:  should be called with locked ARP tables.&n; */
DECL|function|arp_lookup
r_static
r_struct
id|arp_table
op_star
id|arp_lookup
c_func
(paren
id|u32
id|paddr
comma
r_int
r_int
id|flags
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|ATF_PUBL
)paren
)paren
(brace
r_for
c_loop
(paren
id|entry
op_assign
id|arp_tables
(braket
id|HASH
c_func
(paren
id|paddr
)paren
)braket
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|paddr
op_logical_and
(paren
op_logical_neg
id|dev
op_logical_or
id|entry-&gt;dev
op_eq
id|dev
)paren
)paren
r_break
suffix:semicolon
r_return
id|entry
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|ATF_NETMASK
)paren
)paren
(brace
r_for
c_loop
(paren
id|entry
op_assign
id|arp_proxy_list
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|paddr
op_logical_and
(paren
op_logical_neg
id|dev
op_logical_or
id|entry-&gt;dev
op_eq
id|dev
)paren
)paren
r_break
suffix:semicolon
r_return
id|entry
suffix:semicolon
)brace
r_for
c_loop
(paren
id|entry
op_assign
id|arp_proxy_list
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|entry-&gt;ip
op_xor
id|paddr
)paren
op_amp
id|entry-&gt;mask
)paren
op_logical_and
(paren
op_logical_neg
id|dev
op_logical_or
id|entry-&gt;dev
op_eq
id|dev
)paren
)paren
r_break
suffix:semicolon
r_return
id|entry
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Find an arp mapping in the cache. If not found, return false.&n; */
DECL|function|arp_query
r_int
id|arp_query
c_func
(paren
r_int
r_char
op_star
id|haddr
comma
id|u32
id|paddr
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
id|entry
op_assign
id|arp_lookup
c_func
(paren
id|paddr
comma
l_int|0
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_ne
l_int|NULL
)paren
(brace
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
(brace
id|memcpy
c_func
(paren
id|haddr
comma
id|entry-&gt;ha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|arp_set_predefined
r_static
r_int
id|arp_set_predefined
c_func
(paren
r_int
id|addr_hint
comma
r_int
r_char
op_star
id|haddr
comma
id|__u32
id|paddr
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_switch
c_cond
(paren
id|addr_hint
)paren
(brace
r_case
id|IS_MYADDR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ARP: arp called for own IP address&bslash;n&quot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|haddr
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_IP_MULTICAST
r_case
id|IS_MULTICAST
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|ARPHRD_ETHER
op_logical_or
id|dev-&gt;type
op_eq
id|ARPHRD_IEEE802
)paren
(brace
id|u32
id|taddr
suffix:semicolon
id|haddr
(braket
l_int|0
)braket
op_assign
l_int|0x01
suffix:semicolon
id|haddr
(braket
l_int|1
)braket
op_assign
l_int|0x00
suffix:semicolon
id|haddr
(braket
l_int|2
)braket
op_assign
l_int|0x5e
suffix:semicolon
id|taddr
op_assign
id|ntohl
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|haddr
(braket
l_int|5
)braket
op_assign
id|taddr
op_amp
l_int|0xff
suffix:semicolon
id|taddr
op_assign
id|taddr
op_rshift
l_int|8
suffix:semicolon
id|haddr
(braket
l_int|4
)braket
op_assign
id|taddr
op_amp
l_int|0xff
suffix:semicolon
id|taddr
op_assign
id|taddr
op_rshift
l_int|8
suffix:semicolon
id|haddr
(braket
l_int|3
)braket
op_assign
id|taddr
op_amp
l_int|0x7f
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;If a device does not support multicast broadcast the stuff (eg AX.25 for now)&n;&t;&t; */
macro_line|#endif
r_case
id|IS_BROADCAST
suffix:colon
id|memcpy
c_func
(paren
id|haddr
comma
id|dev-&gt;broadcast
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Find an arp mapping in the cache. If not found, post a request.&n; */
DECL|function|arp_find
r_int
id|arp_find
c_func
(paren
r_int
r_char
op_star
id|haddr
comma
id|u32
id|paddr
comma
r_struct
id|device
op_star
id|dev
comma
id|u32
id|saddr
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_int
r_int
id|hash
suffix:semicolon
r_if
c_cond
(paren
id|arp_set_predefined
c_func
(paren
id|ip_chk_addr
c_func
(paren
id|paddr
)paren
comma
id|haddr
comma
id|paddr
comma
id|dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|skb
)paren
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|hash
op_assign
id|HASH
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Find an entry&n;&t; */
id|entry
op_assign
id|arp_lookup
c_func
(paren
id|paddr
comma
l_int|0
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_ne
l_int|NULL
)paren
multiline_comment|/* It exists */
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;A request was already send, but no reply yet. Thus&n;&t;&t;&t; *&t;queue the packet with the previous attempt&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;last_updated
)paren
(brace
id|skb_queue_tail
c_func
(paren
op_amp
id|entry-&gt;skb
comma
id|skb
)paren
suffix:semicolon
id|skb_device_unlock
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * If last_updated==0 host is dead, so&n;&t;&t;&t;&t; * drop skb&squot;s and set socket error.&n;&t;&t;&t;&t; */
r_else
(brace
macro_line|#if 0&t;&t;&t;&t;
multiline_comment|/*&n;&t;&t;&t;&t;&t; * FIXME: ICMP HOST UNREACHABLE should be&n;&t;&t;&t;&t;&t; *&t;  sent in this situation. --ANK&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;sk
)paren
(brace
id|skb-&gt;sk-&gt;err
op_assign
id|EHOSTDOWN
suffix:semicolon
id|skb-&gt;sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|skb-&gt;sk
)paren
suffix:semicolon
)brace
macro_line|#else
id|icmp_send
c_func
(paren
id|skb
comma
id|ICMP_DEST_UNREACH
comma
id|ICMP_HOST_UNREACH
comma
l_int|0
comma
id|dev
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;
id|dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
)brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Update the record&n;&t;&t; */
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|memcpy
c_func
(paren
id|haddr
comma
id|entry-&gt;ha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Create a new unresolved entry.&n;&t; */
id|entry
op_assign
(paren
r_struct
id|arp_table
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arp_table
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_ne
l_int|NULL
)paren
(brace
id|entry-&gt;last_updated
op_assign
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|entry-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|entry-&gt;ip
op_assign
id|paddr
suffix:semicolon
id|entry-&gt;mask
op_assign
id|DEF_ARP_NETMASK
suffix:semicolon
id|memset
c_func
(paren
id|entry-&gt;ha
comma
l_int|0
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|entry-&gt;dev
op_assign
id|dev
suffix:semicolon
id|entry-&gt;hh
op_assign
l_int|NULL
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;timer.function
op_assign
id|arp_expire_request
suffix:semicolon
id|entry-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|entry
suffix:semicolon
id|entry-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|ARP_RES_TIME
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|skb_queue_tail
c_func
(paren
op_amp
id|entry-&gt;skb
comma
id|skb
)paren
suffix:semicolon
id|skb_device_unlock
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arp_lock
op_eq
l_int|1
)paren
(brace
id|entry-&gt;next
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|arp_tables
(braket
id|hash
)braket
op_assign
id|entry
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;retries
op_assign
id|ARP_MAX_TRIES
suffix:semicolon
)brace
r_else
(brace
macro_line|#if RT_CACHE_DEBUG &gt;= 1
id|printk
c_func
(paren
l_string|&quot;arp_find: %08x backlogged&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
id|arp_enqueue
c_func
(paren
op_amp
id|arp_backlog
comma
id|entry
)paren
suffix:semicolon
id|arp_bh_mask
op_or_assign
id|ARP_BH_BACKLOG
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
id|dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If we didn&squot;t find an entry, we will try to send an ARP packet.&n;&t; */
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|paddr
comma
id|dev
comma
id|saddr
comma
l_int|NULL
comma
id|dev-&gt;dev_addr
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Write the contents of the ARP cache to a PROCfs file.&n; */
DECL|macro|HBUFFERLEN
mdefine_line|#define HBUFFERLEN 30
DECL|function|arp_get_info
r_int
id|arp_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|dummy
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|size
suffix:semicolon
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_char
id|hbuffer
(braket
id|HBUFFERLEN
)braket
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_const
r_char
id|hexbuf
(braket
)braket
op_assign
l_string|&quot;0123456789ABCDEF&quot;
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;IP address       HW type     Flags       HW address            Mask     Device&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FULL_ARP_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|entry
op_assign
id|arp_tables
(braket
id|i
)braket
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
(brace
multiline_comment|/*&n; *&t;Convert hardware address to XX:XX:XX:XX ... form.&n; */
macro_line|#ifdef CONFIG_AX25
macro_line|#ifdef CONFIG_NETROM
r_if
c_cond
(paren
id|entry-&gt;dev-&gt;type
op_eq
id|ARPHRD_AX25
op_logical_or
id|entry-&gt;dev-&gt;type
op_eq
id|ARPHRD_NETROM
)paren
id|strcpy
c_func
(paren
id|hbuffer
comma
id|ax2asc
c_func
(paren
(paren
id|ax25_address
op_star
)paren
id|entry-&gt;ha
)paren
)paren
suffix:semicolon
r_else
(brace
macro_line|#else
r_if
c_cond
(paren
id|entry-&gt;dev-&gt;type
op_eq
id|ARPHRD_AX25
)paren
(brace
id|strcpy
c_func
(paren
id|hbuffer
comma
id|ax2asc
c_func
(paren
(paren
id|ax25_address
op_star
)paren
id|entry-&gt;ha
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#endif
macro_line|#endif
r_for
c_loop
(paren
id|k
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|HBUFFERLEN
op_minus
l_int|3
op_logical_and
id|j
OL
id|entry-&gt;dev-&gt;addr_len
suffix:semicolon
id|j
op_increment
)paren
(brace
id|hbuffer
(braket
id|k
op_increment
)braket
op_assign
id|hexbuf
(braket
(paren
id|entry-&gt;ha
(braket
id|j
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|15
)braket
suffix:semicolon
id|hbuffer
(braket
id|k
op_increment
)braket
op_assign
id|hexbuf
(braket
id|entry-&gt;ha
(braket
id|j
)braket
op_amp
l_int|15
)braket
suffix:semicolon
id|hbuffer
(braket
id|k
op_increment
)braket
op_assign
l_char|&squot;:&squot;
suffix:semicolon
)brace
id|hbuffer
(braket
op_decrement
id|k
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_AX25
)brace
macro_line|#endif
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%-17s0x%-10x0x%-10x%s&quot;
comma
id|in_ntoa
c_func
(paren
id|entry-&gt;ip
)paren
comma
(paren
r_int
r_int
)paren
id|entry-&gt;dev-&gt;type
comma
id|entry-&gt;flags
comma
id|hbuffer
)paren
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &lt; 2
id|size
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
op_plus
id|size
comma
l_string|&quot;     %-17s %s&bslash;n&quot;
comma
id|entry-&gt;mask
op_eq
id|DEF_ARP_NETMASK
ques
c_cond
l_string|&quot;*&quot;
suffix:colon
id|in_ntoa
c_func
(paren
id|entry-&gt;mask
)paren
comma
id|entry-&gt;dev-&gt;name
)paren
suffix:semicolon
macro_line|#else
id|size
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
op_plus
id|size
comma
l_string|&quot;     %-17s %s&bslash;t%ld&bslash;t%1d&bslash;n&quot;
comma
id|entry-&gt;mask
op_eq
id|DEF_ARP_NETMASK
ques
c_cond
l_string|&quot;*&quot;
suffix:colon
id|in_ntoa
c_func
(paren
id|entry-&gt;mask
)paren
comma
id|entry-&gt;dev-&gt;name
comma
id|entry-&gt;hh
ques
c_cond
id|entry-&gt;hh-&gt;hh_refcnt
suffix:colon
op_minus
l_int|1
comma
id|entry-&gt;hh
ques
c_cond
id|entry-&gt;hh-&gt;hh_uptodate
suffix:colon
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_le
id|offset
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|offset
op_plus
id|length
)paren
r_break
suffix:semicolon
)brace
)brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|len
op_minus
(paren
id|pos
op_minus
id|offset
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_assign
id|pos
op_minus
id|offset
suffix:semicolon
multiline_comment|/* Start slop */
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
multiline_comment|/* Ending slop */
r_return
id|len
suffix:semicolon
)brace
DECL|function|arp_bind_cache
r_int
id|arp_bind_cache
c_func
(paren
r_struct
id|hh_cache
op_star
op_star
id|hhp
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|htype
comma
id|u32
id|paddr
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|hh_cache
op_star
id|hh
op_assign
op_star
id|hhp
suffix:semicolon
r_int
id|addr_hint
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|hh
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr_hint
op_assign
id|ip_chk_addr
c_func
(paren
id|paddr
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_int
r_char
id|haddr
(braket
id|MAX_ADDR_LEN
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hh
)paren
r_return
l_int|1
suffix:semicolon
id|hh
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|hh_cache
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hh
)paren
r_return
l_int|1
suffix:semicolon
id|arp_set_predefined
c_func
(paren
id|addr_hint
comma
id|haddr
comma
id|paddr
comma
id|dev
)paren
suffix:semicolon
id|hh-&gt;hh_uptodate
op_assign
l_int|0
suffix:semicolon
id|hh-&gt;hh_refcnt
op_assign
l_int|1
suffix:semicolon
id|hh-&gt;hh_arp
op_assign
l_int|NULL
suffix:semicolon
id|hh-&gt;hh_next
op_assign
l_int|NULL
suffix:semicolon
id|hh-&gt;hh_type
op_assign
id|htype
suffix:semicolon
op_star
id|hhp
op_assign
id|hh
suffix:semicolon
id|dev
op_member_access_from_pointer
id|header_cache_update
c_func
(paren
id|hh
comma
id|dev
comma
id|haddr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
id|entry
op_assign
id|arp_lookup
c_func
(paren
id|paddr
comma
l_int|0
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|hh
op_assign
id|entry-&gt;hh
suffix:semicolon
id|hh
suffix:semicolon
id|hh
op_assign
id|hh-&gt;hh_next
)paren
r_if
c_cond
(paren
id|hh-&gt;hh_type
op_eq
id|htype
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|hh
)paren
(brace
id|hh-&gt;hh_refcnt
op_increment
suffix:semicolon
op_star
id|hhp
op_assign
id|hh
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|hh
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|hh_cache
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hh
)paren
(brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|hh-&gt;hh_uptodate
op_assign
l_int|0
suffix:semicolon
id|hh-&gt;hh_refcnt
op_assign
l_int|1
suffix:semicolon
id|hh-&gt;hh_arp
op_assign
l_int|NULL
suffix:semicolon
id|hh-&gt;hh_next
op_assign
l_int|NULL
suffix:semicolon
id|hh-&gt;hh_type
op_assign
id|htype
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
(brace
id|dev
op_member_access_from_pointer
id|header_cache_update
c_func
(paren
id|hh
comma
id|dev
comma
id|entry-&gt;ha
)paren
suffix:semicolon
op_star
id|hhp
op_assign
id|hh
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|hh-&gt;hh_arp
op_assign
(paren
r_void
op_star
)paren
id|entry
suffix:semicolon
id|entry-&gt;hh
op_assign
id|hh
suffix:semicolon
id|hh-&gt;hh_refcnt
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Create a new unresolved entry.&n;&t; */
id|entry
op_assign
(paren
r_struct
id|arp_table
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arp_table
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
(brace
id|kfree_s
c_func
(paren
id|hh
comma
r_sizeof
(paren
r_struct
id|hh_cache
)paren
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|entry-&gt;last_updated
op_assign
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|entry-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|entry-&gt;ip
op_assign
id|paddr
suffix:semicolon
id|entry-&gt;mask
op_assign
id|DEF_ARP_NETMASK
suffix:semicolon
id|memset
c_func
(paren
id|entry-&gt;ha
comma
l_int|0
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|entry-&gt;dev
op_assign
id|dev
suffix:semicolon
id|entry-&gt;hh
op_assign
id|hh
suffix:semicolon
id|ATOMIC_INCR
c_func
(paren
op_amp
id|hh-&gt;hh_refcnt
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;timer.function
op_assign
id|arp_expire_request
suffix:semicolon
id|entry-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|entry
suffix:semicolon
id|entry-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|ARP_RES_TIME
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arp_lock
op_eq
l_int|1
)paren
(brace
r_int
r_int
id|hash
op_assign
id|HASH
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|entry-&gt;next
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|arp_tables
(braket
id|hash
)braket
op_assign
id|entry
suffix:semicolon
id|hh-&gt;hh_arp
op_assign
(paren
r_void
op_star
)paren
id|entry
suffix:semicolon
id|entry-&gt;retries
op_assign
id|ARP_MAX_TRIES
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|paddr
comma
id|dev
comma
id|dev-&gt;pa_addr
comma
l_int|NULL
comma
id|dev-&gt;dev_addr
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if RT_CACHE_DEBUG &gt;= 1
id|printk
c_func
(paren
l_string|&quot;arp_cache_bind: %08x backlogged&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
id|arp_enqueue
c_func
(paren
op_amp
id|arp_backlog
comma
id|entry
)paren
suffix:semicolon
id|arp_bh_mask
op_or_assign
id|ARP_BH_BACKLOG
suffix:semicolon
)brace
op_star
id|hhp
op_assign
id|hh
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|arp_run_bh
r_static
r_void
id|arp_run_bh
c_func
(paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|arp_table
op_star
id|entry
comma
op_star
id|entry1
suffix:semicolon
r_struct
id|hh_cache
op_star
id|hh
suffix:semicolon
id|__u32
id|sip
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arp_lock
)paren
(brace
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
id|arp_dequeue
c_func
(paren
op_amp
id|arp_backlog
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
r_int
id|hash
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|sip
op_assign
id|entry-&gt;ip
suffix:semicolon
id|hash
op_assign
id|HASH
c_func
(paren
id|sip
)paren
suffix:semicolon
multiline_comment|/* It&squot;s possible, that an entry with the same pair &n;&t;&t;&t; * (addr,type) was already created. Our entry is older,&n;&t;&t;&t; * so it should be discarded.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|entry1
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|entry1
suffix:semicolon
id|entry1
op_assign
id|entry1-&gt;next
)paren
r_if
c_cond
(paren
id|entry1-&gt;ip
op_eq
id|sip
op_logical_and
id|entry1-&gt;dev
op_eq
id|entry-&gt;dev
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry1
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|entry-&gt;dev
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|entry-&gt;next
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|arp_tables
(braket
id|hash
)braket
op_assign
id|entry
suffix:semicolon
r_for
c_loop
(paren
id|hh
op_assign
id|entry-&gt;hh
suffix:semicolon
id|hh
suffix:semicolon
id|hh
op_assign
id|hh-&gt;hh_next
)paren
id|hh-&gt;hh_arp
op_assign
(paren
r_void
op_star
)paren
id|entry
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|ARP_RES_TIME
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;retries
op_assign
id|ARP_MAX_TRIES
suffix:semicolon
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|entry-&gt;ip
comma
id|dev
comma
id|dev-&gt;pa_addr
comma
l_int|NULL
comma
id|dev-&gt;dev_addr
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 1
id|printk
c_func
(paren
l_string|&quot;arp_run_bh: %08x reinstalled&bslash;n&quot;
comma
id|sip
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|hh_cache
op_star
id|next
suffix:semicolon
multiline_comment|/* Discard entry, but preserve its hh&squot;s and&n;&t;&t;&t;&t; * skb&squot;s.&n;&t;&t;&t;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|hh
op_assign
id|entry-&gt;hh
suffix:semicolon
id|hh
suffix:semicolon
id|hh
op_assign
id|next
)paren
(brace
id|next
op_assign
id|hh-&gt;hh_next
suffix:semicolon
id|hh-&gt;hh_next
op_assign
id|entry1-&gt;hh
suffix:semicolon
id|entry1-&gt;hh
op_assign
id|hh
suffix:semicolon
id|hh-&gt;hh_arp
op_assign
(paren
r_void
op_star
)paren
id|entry1
suffix:semicolon
)brace
id|entry-&gt;hh
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Prune skb list from entry&n;&t;&t;&t;&t; * and graft it to entry1.&n;&t;&t;&t;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|skb_device_lock
c_func
(paren
id|skb
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|entry1-&gt;skb
comma
id|skb
)paren
suffix:semicolon
id|skb_device_unlock
c_func
(paren
id|skb
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 1
id|printk
c_func
(paren
l_string|&quot;arp_run_bh: entry %08x was born dead&bslash;n&quot;
comma
id|entry-&gt;ip
)paren
suffix:semicolon
macro_line|#endif
id|arp_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry1-&gt;flags
op_amp
id|ATF_COM
)paren
(brace
id|arp_update_hhs
c_func
(paren
id|entry1
)paren
suffix:semicolon
id|arp_send_q
c_func
(paren
id|entry1
)paren
suffix:semicolon
)brace
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|arp_bh_mask
op_and_assign
op_complement
id|ARP_BH_BACKLOG
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Test if a hardware address is all zero&n; */
DECL|function|empty
r_static
r_inline
r_int
id|empty
c_func
(paren
r_int
r_char
op_star
id|addr
comma
r_int
id|len
)paren
(brace
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_star
id|addr
)paren
r_return
l_int|0
suffix:semicolon
id|len
op_decrement
suffix:semicolon
id|addr
op_increment
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Set (create) an ARP cache entry.&n; */
DECL|function|arp_req_set
r_static
r_int
id|arp_req_set
c_func
(paren
r_struct
id|arpreq
op_star
id|r
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|si
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_struct
id|device
op_star
id|dev1
suffix:semicolon
r_int
r_char
op_star
id|ha
suffix:semicolon
id|u32
id|ip
suffix:semicolon
multiline_comment|/*&n;&t; * Find out about the hardware type.&n;&t; * We have to be compatible with BSD UNIX, so we have to&n;&t; * assume that a &quot;not set&quot; value (i.e. 0) means Ethernet.&n;&t; *&n;&t; * ANK: Hey, who wrote it? Do you really mean that BSD considers &n;&t; *&t;ARPHRD_NETROM as ARPHRD_ETHER, or somthing another?&n;&t; */
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;arp_pa
suffix:semicolon
id|ip
op_assign
id|si-&gt;sin_addr.s_addr
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Is it reachable ?&n;&t; */
r_if
c_cond
(paren
id|ip_chk_addr
c_func
(paren
id|ip
)paren
op_eq
id|IS_MYADDR
)paren
id|dev1
op_assign
id|dev_get
c_func
(paren
l_string|&quot;lo&quot;
)paren
suffix:semicolon
r_else
(brace
id|rt
op_assign
id|ip_rt_route
c_func
(paren
id|ip
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rt
)paren
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
id|dev1
op_assign
id|rt-&gt;rt_dev
suffix:semicolon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
multiline_comment|/* this is can only be NULL if ATF_PUBL is not set */
id|dev
op_assign
id|dev1
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_PUBL
)paren
op_logical_and
id|dev
op_eq
id|dev1
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_PUBL
)paren
op_logical_and
id|dev
op_ne
id|dev1
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 1
r_if
c_cond
(paren
id|arp_lock
)paren
id|printk
c_func
(paren
l_string|&quot;arp_req_set: bug&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Is there an existing entry for this address?&n;&t; */
multiline_comment|/*&n;&t; *&t;Find the entry&n;&t; */
id|entry
op_assign
id|arp_lookup
c_func
(paren
id|ip
comma
id|r-&gt;arp_flags
op_amp
op_complement
id|ATF_NETMASK
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
(brace
id|arp_destroy
c_func
(paren
id|entry
)paren
suffix:semicolon
id|entry
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Do we need to create a new entry&n;&t; */
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
(brace
id|entry
op_assign
(paren
r_struct
id|arp_table
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arp_table
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
(brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|entry-&gt;ip
op_assign
id|ip
suffix:semicolon
id|entry-&gt;hh
op_assign
l_int|NULL
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;timer.function
op_assign
id|arp_expire_request
suffix:semicolon
id|entry-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_PUBL
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|entry-&gt;next
op_assign
id|arp_proxy_list
suffix:semicolon
id|arp_proxy_list
op_assign
id|entry
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|hash
op_assign
id|HASH
c_func
(paren
id|ip
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|entry-&gt;next
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|arp_tables
(braket
id|hash
)braket
op_assign
id|entry
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
id|skb_queue_head_init
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;We now have a pointer to an ARP entry.  Update it!&n;&t; */
id|ha
op_assign
id|r-&gt;arp_ha.sa_data
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_COM
)paren
op_logical_and
id|empty
c_func
(paren
id|ha
comma
id|dev-&gt;addr_len
)paren
)paren
id|ha
op_assign
id|dev-&gt;dev_addr
suffix:semicolon
id|memcpy
c_func
(paren
id|entry-&gt;ha
comma
id|ha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|entry-&gt;last_updated
op_assign
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|entry-&gt;flags
op_assign
id|r-&gt;arp_flags
op_or
id|ATF_COM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|entry-&gt;flags
op_amp
id|ATF_PUBL
)paren
op_logical_and
(paren
id|entry-&gt;flags
op_amp
id|ATF_NETMASK
)paren
)paren
(brace
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;arp_netmask
suffix:semicolon
id|entry-&gt;mask
op_assign
id|si-&gt;sin_addr.s_addr
suffix:semicolon
)brace
r_else
id|entry-&gt;mask
op_assign
id|DEF_ARP_NETMASK
suffix:semicolon
id|entry-&gt;dev
op_assign
id|dev
suffix:semicolon
id|arp_update_hhs
c_func
(paren
id|entry
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get an ARP cache entry.&n; */
DECL|function|arp_req_get
r_static
r_int
id|arp_req_get
c_func
(paren
r_struct
id|arpreq
op_star
id|r
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|si
suffix:semicolon
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;arp_pa
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 1
r_if
c_cond
(paren
id|arp_lock
)paren
id|printk
c_func
(paren
l_string|&quot;arp_req_set: bug&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
id|entry
op_assign
id|arp_lookup
c_func
(paren
id|si-&gt;sin_addr.s_addr
comma
id|r-&gt;arp_flags
op_or
id|ATF_NETMASK
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
(brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;We found it; copy into structure.&n;&t; */
id|memcpy
c_func
(paren
id|r-&gt;arp_ha.sa_data
comma
op_amp
id|entry-&gt;ha
comma
id|entry-&gt;dev-&gt;addr_len
)paren
suffix:semicolon
id|r-&gt;arp_ha.sa_family
op_assign
id|entry-&gt;dev-&gt;type
suffix:semicolon
id|r-&gt;arp_flags
op_assign
id|entry-&gt;flags
suffix:semicolon
id|strncpy
c_func
(paren
id|r-&gt;arp_dev
comma
id|entry-&gt;dev-&gt;name
comma
l_int|16
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|arp_req_delete
r_static
r_int
id|arp_req_delete
c_func
(paren
r_struct
id|arpreq
op_star
id|r
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|si
suffix:semicolon
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;arp_pa
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 1
r_if
c_cond
(paren
id|arp_lock
)paren
id|printk
c_func
(paren
l_string|&quot;arp_req_delete: bug&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|arp_fast_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r-&gt;arp_flags
op_amp
id|ATF_PUBL
)paren
)paren
(brace
r_for
c_loop
(paren
id|entry
op_assign
id|arp_tables
(braket
id|HASH
c_func
(paren
id|si-&gt;sin_addr.s_addr
)paren
)braket
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|si-&gt;sin_addr.s_addr
op_logical_and
(paren
op_logical_neg
id|dev
op_logical_or
id|entry-&gt;dev
op_eq
id|dev
)paren
)paren
(brace
id|arp_destroy
c_func
(paren
id|entry
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|entry
op_assign
id|arp_proxy_list
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|si-&gt;sin_addr.s_addr
op_logical_and
(paren
op_logical_neg
id|dev
op_logical_or
id|entry-&gt;dev
op_eq
id|dev
)paren
)paren
(brace
id|arp_destroy
c_func
(paren
id|entry
)paren
suffix:semicolon
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|arp_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Handle an ARP layer I/O control request.&n; */
DECL|function|arp_ioctl
r_int
id|arp_ioctl
c_func
(paren
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|arpreq
id|r
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCDARP
suffix:colon
r_case
id|SIOCSARP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_case
id|SIOCGARP
suffix:colon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|r
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OLD_SIOCDARP
suffix:colon
r_case
id|OLD_SIOCSARP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_case
id|OLD_SIOCGARP
suffix:colon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq_old
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|r
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq_old
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|r.arp_dev
comma
l_int|0
comma
r_sizeof
(paren
id|r.arp_dev
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r.arp_pa.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EPFNOSUPPORT
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r.arp_pa
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|r.arp_dev
(braket
l_int|0
)braket
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|dev_get
c_func
(paren
id|r.arp_dev
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r.arp_ha.sa_family
)paren
id|r.arp_ha.sa_family
op_assign
id|dev-&gt;type
suffix:semicolon
r_else
r_if
c_cond
(paren
id|r.arp_ha.sa_family
op_ne
id|dev-&gt;type
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|r.arp_flags
op_amp
id|ATF_PUBL
)paren
op_logical_and
(paren
(paren
id|cmd
op_eq
id|SIOCSARP
)paren
op_logical_or
(paren
id|cmd
op_eq
id|OLD_SIOCSARP
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|dev_getbytype
c_func
(paren
id|r.arp_ha.sa_family
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCDARP
suffix:colon
r_return
id|arp_req_delete
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
r_case
id|SIOCSARP
suffix:colon
r_return
id|arp_req_set
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
r_case
id|OLD_SIOCDARP
suffix:colon
multiline_comment|/* old  SIOCDARP destoyes both&n;&t;&t;&t; * normal and proxy mappings&n;&t;&t;&t; */
id|r.arp_flags
op_and_assign
op_complement
id|ATF_PUBL
suffix:semicolon
id|err
op_assign
id|arp_req_delete
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
id|r.arp_flags
op_or_assign
id|ATF_PUBL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|arp_req_delete
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
r_else
id|err
op_assign
id|arp_req_delete
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
r_case
id|OLD_SIOCSARP
suffix:colon
id|err
op_assign
id|arp_req_set
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* old SIOCSARP works so funny,&n;&t;&t;&t; * that its behaviour can be emulated&n;&t;&t;&t; * only approximately 8).&n;&t;&t;&t; * It should work. --ANK&n;&t;&t;&t; */
r_if
c_cond
(paren
id|r.arp_flags
op_amp
id|ATF_PUBL
)paren
(brace
id|r.arp_flags
op_and_assign
op_complement
id|ATF_PUBL
suffix:semicolon
id|arp_req_delete
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
r_case
id|SIOCGARP
suffix:colon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|err
op_assign
id|arp_req_get
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|r
comma
r_sizeof
(paren
id|r
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
r_case
id|OLD_SIOCGARP
suffix:colon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq_old
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|r.arp_flags
op_and_assign
op_complement
id|ATF_PUBL
suffix:semicolon
id|err
op_assign
id|arp_req_get
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|r.arp_flags
op_or_assign
id|ATF_PUBL
suffix:semicolon
id|err
op_assign
id|arp_req_get
c_func
(paren
op_amp
id|r
comma
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|r
comma
r_sizeof
(paren
r_struct
id|arpreq_old
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*NOTREACHED*/
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Called once on startup.&n; */
DECL|variable|arp_packet_type
r_static
r_struct
id|packet_type
id|arp_packet_type
op_assign
(brace
l_int|0
comma
multiline_comment|/* Should be: __constant_htons(ETH_P_ARP) - but this _doesn&squot;t_ come out constant! */
l_int|NULL
comma
multiline_comment|/* All devices */
id|arp_rcv
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|arp_dev_notifier
r_static
r_struct
id|notifier_block
id|arp_dev_notifier
op_assign
initialization_block
suffix:semicolon
DECL|function|arp_init
r_void
id|arp_init
(paren
r_void
)paren
(brace
multiline_comment|/* Register the packet type */
id|arp_packet_type.type
op_assign
id|htons
c_func
(paren
id|ETH_P_ARP
)paren
suffix:semicolon
id|dev_add_pack
c_func
(paren
op_amp
id|arp_packet_type
)paren
suffix:semicolon
multiline_comment|/* Start with the regular checks for expired arp entries. */
id|add_timer
c_func
(paren
op_amp
id|arp_timer
)paren
suffix:semicolon
multiline_comment|/* Register for device down reports */
id|register_netdevice_notifier
c_func
(paren
op_amp
id|arp_dev_notifier
)paren
suffix:semicolon
id|proc_net_register
c_func
(paren
op_amp
(paren
r_struct
id|proc_dir_entry
)paren
(brace
id|PROC_NET_ARP
comma
l_int|3
comma
l_string|&quot;arp&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_amp
id|proc_net_inode_operations
comma
id|arp_get_info
)brace
)paren
suffix:semicolon
)brace
eof
