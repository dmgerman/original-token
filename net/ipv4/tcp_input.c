multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Implementation of the Transmission Control Protocol(TCP).&n; *&n; * Version:&t;$Id: tcp_input.c,v 1.188 2000/02/08 21:27:14 davem Exp $&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;&n; *&t;&t;Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; */
multiline_comment|/*&n; * Changes:&n; *&t;&t;Pedro Roque&t;:&t;Fast Retransmit/Recovery.&n; *&t;&t;&t;&t;&t;Two receive queues.&n; *&t;&t;&t;&t;&t;Retransmit queue handled by TCP.&n; *&t;&t;&t;&t;&t;Better retransmit timer handling.&n; *&t;&t;&t;&t;&t;New congestion avoidance.&n; *&t;&t;&t;&t;&t;Header prediction.&n; *&t;&t;&t;&t;&t;Variable renaming.&n; *&n; *&t;&t;Eric&t;&t;:&t;Fast Retransmit.&n; *&t;&t;Randy Scott&t;:&t;MSS option defines.&n; *&t;&t;Eric Schenk&t;:&t;Fixes to slow start algorithm.&n; *&t;&t;Eric Schenk&t;:&t;Yet another double ACK bug.&n; *&t;&t;Eric Schenk&t;:&t;Delayed ACK bug fixes.&n; *&t;&t;Eric Schenk&t;:&t;Floyd style fast retrans war avoidance.&n; *&t;&t;David S. Miller&t;:&t;Don&squot;t allow zero congestion window.&n; *&t;&t;Eric Schenk&t;:&t;Fix retransmitter so that it sends&n; *&t;&t;&t;&t;&t;next packet on ack of previous packet.&n; *&t;&t;Andi Kleen&t;:&t;Moved open_request checking here&n; *&t;&t;&t;&t;&t;and process RSTs for open_requests.&n; *&t;&t;Andi Kleen&t;:&t;Better prune_queue, and other fixes.&n; *&t;&t;Andrey Savochkin:&t;Fix RTT measurements in the presnce of&n; *&t;&t;&t;&t;&t;timestamps.&n; *&t;&t;Andrey Savochkin:&t;Check sequence numbers correctly when&n; *&t;&t;&t;&t;&t;removing SACKs due to in sequence incoming&n; *&t;&t;&t;&t;&t;data segments.&n; *&t;&t;Andi Kleen:&t;&t;Make sure we never ack data there is not&n; *&t;&t;&t;&t;&t;enough room for. Also make this condition&n; *&t;&t;&t;&t;&t;a fatal error if it might still happen.&n; *&t;&t;Andi Kleen:&t;&t;Add tcp_measure_rcv_mss to make &n; *&t;&t;&t;&t;&t;connections with MSS&lt;min(MTU,ann. MSS)&n; *&t;&t;&t;&t;&t;work without delayed acks. &n; *&t;&t;Andi Kleen:&t;&t;Process packets with PSH set in the&n; *&t;&t;&t;&t;&t;fast path.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/inet_common.h&gt;
macro_line|#include &lt;linux/ipsec.h&gt;
macro_line|#ifdef CONFIG_SYSCTL
DECL|macro|SYNC_INIT
mdefine_line|#define SYNC_INIT 0 /* let the user enable it */
macro_line|#else
DECL|macro|SYNC_INIT
mdefine_line|#define SYNC_INIT 1
macro_line|#endif
multiline_comment|/* These are on by default so the code paths get tested.&n; * For the final 2.2 this may be undone at our discretion. -DaveM&n; */
DECL|variable|sysctl_tcp_timestamps
r_int
id|sysctl_tcp_timestamps
op_assign
l_int|1
suffix:semicolon
DECL|variable|sysctl_tcp_window_scaling
r_int
id|sysctl_tcp_window_scaling
op_assign
l_int|1
suffix:semicolon
DECL|variable|sysctl_tcp_sack
r_int
id|sysctl_tcp_sack
op_assign
l_int|1
suffix:semicolon
DECL|variable|sysctl_tcp_syncookies
r_int
id|sysctl_tcp_syncookies
op_assign
id|SYNC_INIT
suffix:semicolon
DECL|variable|sysctl_tcp_stdurg
r_int
id|sysctl_tcp_stdurg
suffix:semicolon
DECL|variable|sysctl_tcp_rfc1337
r_int
id|sysctl_tcp_rfc1337
suffix:semicolon
DECL|variable|sysctl_tcp_tw_recycle
r_int
id|sysctl_tcp_tw_recycle
op_assign
l_int|1
suffix:semicolon
DECL|variable|sysctl_tcp_abort_on_overflow
r_int
id|sysctl_tcp_abort_on_overflow
op_assign
l_int|0
suffix:semicolon
DECL|variable|sysctl_tcp_max_orphans
r_int
id|sysctl_tcp_max_orphans
op_assign
id|NR_FILE
suffix:semicolon
DECL|variable|sysctl_tcp_max_tw_buckets
r_int
id|sysctl_tcp_max_tw_buckets
op_assign
id|NR_FILE
op_star
l_int|2
suffix:semicolon
r_static
r_int
id|prune_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
multiline_comment|/* &n; * Adapt the MSS value used to make delayed ack decision to the &n; * real world.&n; *&n; * The constant 536 hasn&squot;t any good meaning.  In IPv4 world&n; * MTU may be smaller, though it contradicts to RFC1122, which&n; * states that MSS must be at least 536.&n; * We use the constant to do not ACK each second&n; * packet in a stream of tiny size packets.&n; * It means that super-low mtu links will be aggressively delacked.&n; * Seems, it is even good. If they have so low mtu, they are weirdly&n; * slow.&n; *&n; * AK: BTW it may be useful to add an option to lock the rcv_mss.&n; *     this way the beowulf people wouldn&squot;t need ugly patches to get the&n; *     ack frequencies they want and it would be an elegant way to tune delack.&n; */
DECL|function|tcp_measure_rcv_mss
r_static
id|__inline__
r_void
id|tcp_measure_rcv_mss
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
r_int
id|len
comma
id|lss
suffix:semicolon
id|lss
op_assign
id|tp-&gt;ack.last_seg_size
suffix:semicolon
id|tp-&gt;ack.last_seg_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* skb-&gt;len may jitter because of SACKs, even if peer&n;&t; * sends good full-sized frames.&n;&t; */
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|tp-&gt;ack.rcv_mss
)paren
(brace
id|tp-&gt;ack.rcv_mss
op_assign
id|len
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Otherwise, we make more careful check taking into account,&n;&t;&t; * that SACKs block is variable.&n;&t;&t; *&n;&t;&t; * &quot;len&quot; is invariant segment length, including TCP header.&n;&t;&t; */
id|len
op_assign
id|skb-&gt;tail
op_minus
id|skb-&gt;h.raw
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|TCP_MIN_RCVMSS
op_plus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
(brace
multiline_comment|/* Subtract also invariant (if peer is RFC compliant),&n;&t;&t;&t; * tcp header plus fixed timestamp option length.&n;&t;&t;&t; * Resulting &quot;len&quot; is MSS free of SACK jitter.&n;&t;&t;&t; */
id|len
op_sub_assign
id|tp-&gt;tcp_header_len
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
id|lss
)paren
id|tp-&gt;ack.rcv_mss
op_assign
id|len
suffix:semicolon
id|tp-&gt;ack.last_seg_size
op_assign
id|len
suffix:semicolon
)brace
)brace
)brace
DECL|function|tcp_enter_quickack_mode
r_static
id|__inline__
r_void
id|tcp_enter_quickack_mode
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_int
id|quickacks
op_assign
id|tcp_receive_window
c_func
(paren
id|tp
)paren
op_div
(paren
l_int|2
op_star
id|tp-&gt;ack.rcv_mss
)paren
suffix:semicolon
id|tp-&gt;ack.quick
op_assign
id|max
c_func
(paren
id|min
c_func
(paren
id|quickacks
comma
l_int|127
)paren
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;tstamp_ok
op_logical_and
id|tp-&gt;ack.quick
OG
l_int|2
)paren
(brace
multiline_comment|/* Quick ACKs are _dangerous_, if RTTM is not used.&n;&t;&t; * See comment in tcp_init_metrics(). We still help&n;&t;&t; * them to overcome the most difficult, initial&n;&t;&t; * phase of slow start.&n;&t;&t; */
id|tp-&gt;ack.quick
op_assign
l_int|2
suffix:semicolon
)brace
)brace
multiline_comment|/* Send ACKs quickly, if &quot;quick&quot; count is not ehausted&n; * and the session is not interactive.&n; */
DECL|function|tcp_in_quickack_mode
r_static
id|__inline__
r_int
id|tcp_in_quickack_mode
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_return
(paren
id|tp-&gt;ack.quick
op_logical_and
op_logical_neg
id|tp-&gt;ack.pingpong
)paren
suffix:semicolon
)brace
multiline_comment|/* There is something which you must keep in mind when you analyze the&n; * behavior of the tp-&gt;ato delayed ack timeout interval.  When a&n; * connection starts up, we want to ack as quickly as possible.  The&n; * problem is that &quot;good&quot; TCP&squot;s do slow start at the beginning of data&n; * transmission.  The means that until we send the first few ACK&squot;s the&n; * sender will sit on his end and only queue most of his data, because&n; * he can only send snd_cwnd unacked packets at any given time.  For&n; * each ACK we send, he increments snd_cwnd and transmits more of his&n; * queue.  -DaveM&n; */
DECL|function|tcp_event_data_recv
r_static
r_void
id|tcp_event_data_recv
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|u32
id|now
suffix:semicolon
id|tcp_measure_rcv_mss
c_func
(paren
id|tp
comma
id|skb
)paren
suffix:semicolon
id|tp-&gt;ack.pending
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;ack.rcv_segs
op_increment
suffix:semicolon
id|now
op_assign
id|tcp_time_stamp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;ack.ato
)paren
(brace
multiline_comment|/* The _first_ data packet received, initialize&n;&t;&t; * delayed ACK engine.&n;&t;&t; */
multiline_comment|/* Help sender leave slow start quickly. */
id|tcp_enter_quickack_mode
c_func
(paren
id|tp
)paren
suffix:semicolon
multiline_comment|/* Pingpong is off, session is not interactive by default */
id|tp-&gt;ack.pingpong
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ATO is minimal */
id|tp-&gt;ack.ato
op_assign
id|TCP_ATO_MIN
suffix:semicolon
)brace
r_else
(brace
r_int
id|m
op_assign
id|now
op_minus
id|tp-&gt;ack.lrcvtime
suffix:semicolon
r_if
c_cond
(paren
id|m
OG
id|TCP_ATO_MAX
op_div
l_int|2
)paren
(brace
multiline_comment|/* Do not touch ATO, if interval is out of bounds.&n;&t;&t;&t; * It will be deflated by delack timer, if our peer&n;&t;&t;&t; * really sends too rarely.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|m
OG
id|tp-&gt;rto
)paren
(brace
multiline_comment|/* Too long gap. Apparently sender falled to&n;&t;&t;&t;&t; * restart window, so that we send ACKs quickly.&n;&t;&t;&t;&t; */
id|tcp_enter_quickack_mode
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|m
op_le
l_int|0
)paren
id|m
op_assign
id|TCP_ATO_MIN
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|m
op_le
id|tp-&gt;ack.ato
)paren
id|tp-&gt;ack.ato
op_assign
(paren
id|tp-&gt;ack.ato
op_rshift
l_int|1
)paren
op_plus
id|m
suffix:semicolon
)brace
)brace
id|tp-&gt;ack.lrcvtime
op_assign
id|now
suffix:semicolon
)brace
multiline_comment|/* Called to compute a smoothed rtt estimate. The data fed to this&n; * routine either comes from timestamps, or from segments that were&n; * known _not_ to have been retransmitted [see Karn/Partridge&n; * Proceedings SIGCOMM 87]. The algorithm is from the SIGCOMM 88&n; * piece by Van Jacobson.&n; * NOTE: the next three routines used to be one big routine.&n; * To save cycles in the RFC 1323 implementation it was better to break&n; * it up into three procedures. -- erics&n; */
DECL|function|tcp_rtt_estimator
r_static
id|__inline__
r_void
id|tcp_rtt_estimator
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
id|__u32
id|mrtt
)paren
(brace
r_int
id|m
op_assign
id|mrtt
suffix:semicolon
multiline_comment|/* RTT */
multiline_comment|/*&t;The following amusing code comes from Jacobson&squot;s&n;&t; *&t;article in SIGCOMM &squot;88.  Note that rtt and mdev&n;&t; *&t;are scaled versions of rtt and mean deviation.&n;&t; *&t;This is designed to be as fast as possible &n;&t; *&t;m stands for &quot;measurement&quot;.&n;&t; *&n;&t; *&t;On a 1990 paper the rto value is changed to:&n;&t; *&t;RTO = rtt + 4 * mdev&n;&t; */
r_if
c_cond
(paren
id|m
op_eq
l_int|0
)paren
(brace
id|m
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;srtt
op_ne
l_int|0
)paren
(brace
id|m
op_sub_assign
(paren
id|tp-&gt;srtt
op_rshift
l_int|3
)paren
suffix:semicolon
multiline_comment|/* m is now error in rtt est */
id|tp-&gt;srtt
op_add_assign
id|m
suffix:semicolon
multiline_comment|/* rtt = 7/8 rtt + 1/8 new */
r_if
c_cond
(paren
id|m
OL
l_int|0
)paren
id|m
op_assign
op_minus
id|m
suffix:semicolon
multiline_comment|/* m is now abs(error) */
id|m
op_sub_assign
(paren
id|tp-&gt;mdev
op_rshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* similar update on mdev */
id|tp-&gt;mdev
op_add_assign
id|m
suffix:semicolon
multiline_comment|/* mdev = 3/4 mdev + 1/4 new */
)brace
r_else
(brace
multiline_comment|/* no previous measure. */
id|tp-&gt;srtt
op_assign
id|m
op_lshift
l_int|3
suffix:semicolon
multiline_comment|/* take the measured time to be rtt */
id|tp-&gt;mdev
op_assign
id|m
op_lshift
l_int|2
suffix:semicolon
multiline_comment|/* make sure rto = 3*rtt */
)brace
)brace
multiline_comment|/* Calculate rto without backoff.  This is the second half of Van Jacobson&squot;s&n; * routine referred to above.&n; */
DECL|function|tcp_set_rto
r_static
id|__inline__
r_void
id|tcp_set_rto
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
id|tp-&gt;rto
op_assign
(paren
id|tp-&gt;srtt
op_rshift
l_int|3
)paren
op_plus
id|tp-&gt;mdev
suffix:semicolon
multiline_comment|/* I am not enough educated to understand this magic.&n;&t; * However, it smells bad. snd_cwnd&gt;31 is common case.&n;&t; */
id|tp-&gt;rto
op_add_assign
(paren
id|tp-&gt;rto
op_rshift
l_int|2
)paren
op_plus
(paren
id|tp-&gt;rto
op_rshift
(paren
id|tp-&gt;snd_cwnd
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Keep the rto between HZ/5 and 120*HZ. 120*HZ is the upper bound&n; * on packet lifetime in the internet. We need the HZ/5 lower&n; * bound to behave correctly against BSD stacks with a fixed&n; * delayed ack.&n; * FIXME: It&squot;s not entirely clear this lower bound is the best&n; * way to avoid the problem. Is it possible to drop the lower&n; * bound and still avoid trouble with BSD stacks? Perhaps&n; * some modification to the RTO calculation that takes delayed&n; * ack bias into account? This needs serious thought. -- erics&n; */
DECL|function|tcp_bound_rto
r_static
id|__inline__
r_void
id|tcp_bound_rto
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;rto
OL
id|TCP_RTO_MIN
)paren
id|tp-&gt;rto
op_assign
id|TCP_RTO_MIN
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;rto
OG
id|TCP_RTO_MAX
)paren
id|tp-&gt;rto
op_assign
id|TCP_RTO_MAX
suffix:semicolon
)brace
multiline_comment|/* Save metrics learned by this TCP session.&n;   This function is called only, when TCP finishes sucessfully&n;   i.e. when it enters TIME-WAIT or goes from LAST-ACK to CLOSE.&n; */
DECL|function|tcp_update_metrics
r_static
r_void
id|tcp_update_metrics
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|__sk_dst_get
c_func
(paren
id|sk
)paren
suffix:semicolon
id|dst_confirm
c_func
(paren
id|dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst
op_logical_and
(paren
id|dst-&gt;flags
op_amp
id|DST_HOST
)paren
)paren
(brace
r_int
id|m
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;backoff
op_logical_or
op_logical_neg
id|tp-&gt;srtt
)paren
(brace
multiline_comment|/* This session failed to estimate rtt. Why?&n;&t;&t;&t; * Probably, no packets returned in time.&n;&t;&t;&t; * Reset our results.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dst-&gt;mxlock
op_amp
(paren
l_int|1
op_lshift
id|RTAX_RTT
)paren
)paren
)paren
id|dst-&gt;rtt
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|m
op_assign
id|dst-&gt;rtt
op_minus
id|tp-&gt;srtt
suffix:semicolon
multiline_comment|/* If newly calculated rtt larger than stored one,&n;&t;&t; * store new one. Otherwise, use EWMA. Remember,&n;&t;&t; * rtt overestimation is always better than underestimation.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dst-&gt;mxlock
op_amp
(paren
l_int|1
op_lshift
id|RTAX_RTT
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|m
op_le
l_int|0
)paren
id|dst-&gt;rtt
op_assign
id|tp-&gt;srtt
suffix:semicolon
r_else
id|dst-&gt;rtt
op_sub_assign
(paren
id|m
op_rshift
l_int|3
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dst-&gt;mxlock
op_amp
(paren
l_int|1
op_lshift
id|RTAX_RTTVAR
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|m
OL
l_int|0
)paren
id|m
op_assign
op_minus
id|m
suffix:semicolon
multiline_comment|/* Scale deviation to rttvar fixed point */
id|m
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|m
OL
id|tp-&gt;mdev
)paren
id|m
op_assign
id|tp-&gt;mdev
suffix:semicolon
r_if
c_cond
(paren
id|m
op_ge
id|dst-&gt;rttvar
)paren
id|dst-&gt;rttvar
op_assign
id|m
suffix:semicolon
r_else
id|dst-&gt;rttvar
op_sub_assign
(paren
id|dst-&gt;rttvar
op_minus
id|m
)paren
op_rshift
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;snd_ssthresh
op_eq
l_int|0x7FFFFFFF
)paren
(brace
multiline_comment|/* Slow start still did not finish. */
r_if
c_cond
(paren
id|dst-&gt;ssthresh
op_logical_and
op_logical_neg
(paren
id|dst-&gt;mxlock
op_amp
(paren
l_int|1
op_lshift
id|RTAX_SSTHRESH
)paren
)paren
op_logical_and
id|tp-&gt;snd_cwnd
OG
id|dst-&gt;ssthresh
)paren
id|dst-&gt;ssthresh
op_assign
id|tp-&gt;snd_cwnd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dst-&gt;mxlock
op_amp
(paren
l_int|1
op_lshift
id|RTAX_CWND
)paren
)paren
op_logical_and
id|tp-&gt;snd_cwnd
OG
id|dst-&gt;cwnd
)paren
id|dst-&gt;cwnd
op_assign
id|tp-&gt;snd_cwnd
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd
op_ge
id|tp-&gt;snd_ssthresh
op_logical_and
op_logical_neg
id|tp-&gt;high_seq
)paren
(brace
multiline_comment|/* Cong. avoidance phase, cwnd is reliable. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dst-&gt;mxlock
op_amp
(paren
l_int|1
op_lshift
id|RTAX_SSTHRESH
)paren
)paren
)paren
id|dst-&gt;ssthresh
op_assign
id|tp-&gt;snd_cwnd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dst-&gt;mxlock
op_amp
(paren
l_int|1
op_lshift
id|RTAX_CWND
)paren
)paren
)paren
id|dst-&gt;cwnd
op_assign
(paren
id|dst-&gt;cwnd
op_plus
id|tp-&gt;snd_cwnd
)paren
op_rshift
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Else slow start did not finish, cwnd is non-sense,&n;&t;&t;&t;   ssthresh may be also invalid.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dst-&gt;mxlock
op_amp
(paren
l_int|1
op_lshift
id|RTAX_CWND
)paren
)paren
)paren
id|dst-&gt;cwnd
op_assign
(paren
id|dst-&gt;cwnd
op_plus
id|tp-&gt;snd_ssthresh
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dst-&gt;ssthresh
op_logical_and
op_logical_neg
(paren
id|dst-&gt;mxlock
op_amp
(paren
l_int|1
op_lshift
id|RTAX_SSTHRESH
)paren
)paren
op_logical_and
id|tp-&gt;snd_ssthresh
OG
id|dst-&gt;ssthresh
)paren
id|dst-&gt;ssthresh
op_assign
id|tp-&gt;snd_ssthresh
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Initialize metrics on socket. */
DECL|function|tcp_init_metrics
r_static
r_void
id|tcp_init_metrics
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|__sk_dst_get
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst
op_eq
l_int|NULL
)paren
r_goto
id|reset
suffix:semicolon
id|dst_confirm
c_func
(paren
id|dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst-&gt;mxlock
op_amp
(paren
l_int|1
op_lshift
id|RTAX_CWND
)paren
)paren
id|tp-&gt;snd_cwnd_clamp
op_assign
id|dst-&gt;cwnd
suffix:semicolon
r_if
c_cond
(paren
id|dst-&gt;ssthresh
)paren
(brace
id|tp-&gt;snd_ssthresh
op_assign
id|dst-&gt;ssthresh
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;snd_ssthresh
OG
id|tp-&gt;snd_cwnd_clamp
)paren
id|tp-&gt;snd_ssthresh
op_assign
id|tp-&gt;snd_cwnd_clamp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dst-&gt;rtt
op_eq
l_int|0
)paren
r_goto
id|reset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;srtt
op_logical_and
id|dst-&gt;rtt
OL
(paren
id|TCP_TIMEOUT_INIT
op_lshift
l_int|3
)paren
)paren
r_goto
id|reset
suffix:semicolon
multiline_comment|/* Initial rtt is determined from SYN,SYN-ACK.&n;&t; * The segment is small and rtt may appear much&n;&t; * less than real one. Use per-dst memory&n;&t; * to make it more realistic.&n;&t; *&n;&t; * A bit of theory. RTT is time passed after &quot;normal&quot; sized packet&n;&t; * is sent until it is ACKed. In normal curcumstances sending small&n;&t; * packets force peer to delay ACKs and calculation is correct too.&n;&t; * The algorithm is adaptive and, provided we follow specs, it&n;&t; * NEVER underestimate RTT. BUT! If peer tries to make some clever&n;&t; * tricks sort of &quot;quick acks&quot; for time long enough to decrease RTT&n;&t; * to low value, and then abruptly stops to do it and starts to delay&n;&t; * ACKs, wait for troubles.&n;&t; */
r_if
c_cond
(paren
id|dst-&gt;rtt
OG
id|tp-&gt;srtt
)paren
id|tp-&gt;srtt
op_assign
id|dst-&gt;rtt
suffix:semicolon
r_if
c_cond
(paren
id|dst-&gt;rttvar
OG
id|tp-&gt;mdev
)paren
id|tp-&gt;mdev
op_assign
id|dst-&gt;rttvar
suffix:semicolon
id|tcp_set_rto
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tcp_bound_rto
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;rto
OL
id|TCP_TIMEOUT_INIT
op_logical_and
op_logical_neg
id|tp-&gt;saw_tstamp
)paren
r_goto
id|reset
suffix:semicolon
id|tp-&gt;snd_cwnd
op_assign
id|tcp_init_cwnd
c_func
(paren
id|tp
)paren
suffix:semicolon
r_return
suffix:semicolon
id|reset
suffix:colon
multiline_comment|/* Play conservative. If timestamps are not&n;&t; * supported, TCP will fail to recalculate correct&n;&t; * rtt, if initial rto is too small. FORGET ALL AND RESET!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;saw_tstamp
op_logical_and
id|tp-&gt;srtt
)paren
(brace
id|tp-&gt;srtt
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;mdev
op_assign
id|TCP_TIMEOUT_INIT
suffix:semicolon
id|tp-&gt;rto
op_assign
id|TCP_TIMEOUT_INIT
suffix:semicolon
)brace
)brace
multiline_comment|/* WARNING: this must not be called if tp-&gt;saw_tstamp was false. */
r_extern
id|__inline__
r_void
DECL|function|tcp_replace_ts_recent
id|tcp_replace_ts_recent
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_opt
op_star
id|tp
comma
id|u32
id|seq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|seq
comma
id|tp-&gt;rcv_wup
)paren
)paren
(brace
multiline_comment|/* PAWS bug workaround wrt. ACK frames, the PAWS discard&n;&t;&t; * extra check below makes sure this can only happen&n;&t;&t; * for pure ACK frames.  -DaveM&n;&t;&t; *&n;&t;&t; * Not only, also it occurs for expired timestamps&n;&t;&t; * and RSTs with bad timestamp option. --ANK&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|s32
)paren
(paren
id|tp-&gt;rcv_tsval
op_minus
id|tp-&gt;ts_recent
)paren
op_ge
l_int|0
op_logical_or
id|xtime.tv_sec
op_ge
id|tp-&gt;ts_recent_stamp
op_plus
id|TCP_PAWS_24DAYS
)paren
(brace
id|tp-&gt;ts_recent
op_assign
id|tp-&gt;rcv_tsval
suffix:semicolon
id|tp-&gt;ts_recent_stamp
op_assign
id|xtime.tv_sec
suffix:semicolon
)brace
)brace
)brace
DECL|function|tcp_paws_discard
r_extern
id|__inline__
r_int
id|tcp_paws_discard
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
(paren
(paren
id|s32
)paren
(paren
id|tp-&gt;rcv_tsval
op_minus
id|tp-&gt;ts_recent
)paren
OL
l_int|0
op_logical_and
id|xtime.tv_sec
OL
id|tp-&gt;ts_recent_stamp
op_plus
id|TCP_PAWS_24DAYS
multiline_comment|/* Sorry, PAWS as specified is broken wrt. pure-ACKs -DaveM&n;&n;&t;&t;    I cannot see quitely as all the idea behind PAWS&n;&t;&t;    is destroyed 8)&n;&n;&t;&t;    The problem is only in reordering duplicate ACKs.&n;&t;&t;    Hence, we can check this rare case more carefully.&n;&n;&t;&t;    1. Check that it is really duplicate ACK (ack==snd_una)&n;&t;&t;    2. Give it some small &quot;replay&quot; window (~RTO)&n;&n;&t;&t;    We do not know units of foreign ts values, but make conservative&n;&t;&t;    assumption that they are &gt;=1ms. It solves problem&n;&t;&t;    noted in Dave&squot;s mail to tcpimpl and does not harm PAWS. --ANK&n;&t;&t;  */
op_logical_and
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_ne
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_logical_or
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
op_ne
id|tp-&gt;snd_una
op_logical_or
op_logical_neg
id|skb-&gt;h.th-&gt;ack
op_logical_or
(paren
id|s32
)paren
(paren
id|tp-&gt;ts_recent
op_minus
id|tp-&gt;rcv_tsval
)paren
OG
(paren
id|tp-&gt;rto
op_star
l_int|1024
)paren
op_div
id|HZ
)paren
)paren
suffix:semicolon
)brace
DECL|function|__tcp_sequence
r_static
r_int
id|__tcp_sequence
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
id|u32
id|seq
comma
id|u32
id|end_seq
)paren
(brace
id|u32
id|end_window
op_assign
id|tp-&gt;rcv_wup
op_plus
id|tp-&gt;rcv_wnd
suffix:semicolon
macro_line|#ifdef TCP_FORMAL_WINDOW
id|u32
id|rcv_wnd
op_assign
id|tcp_receive_window
c_func
(paren
id|tp
)paren
suffix:semicolon
macro_line|#else
id|u32
id|rcv_wnd
op_assign
id|tp-&gt;rcv_wnd
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|rcv_wnd
op_logical_and
id|after
c_func
(paren
id|end_seq
comma
id|tp-&gt;rcv_nxt
)paren
op_logical_and
id|before
c_func
(paren
id|seq
comma
id|end_window
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|seq
op_ne
id|end_window
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
id|seq
op_eq
id|end_seq
)paren
suffix:semicolon
)brace
multiline_comment|/* This functions checks to see if the tcp header is actually acceptable. */
DECL|function|tcp_sequence
r_extern
id|__inline__
r_int
id|tcp_sequence
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
id|u32
id|seq
comma
id|u32
id|end_seq
)paren
(brace
macro_line|#ifdef TCP_FORMAL_WINDOW
id|u32
id|rcv_wnd
op_assign
id|tcp_receive_window
c_func
(paren
id|tp
)paren
suffix:semicolon
macro_line|#else
id|u32
id|rcv_wnd
op_assign
id|tp-&gt;rcv_wnd
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|seq
op_eq
id|tp-&gt;rcv_nxt
)paren
r_return
(paren
id|rcv_wnd
op_logical_or
(paren
id|end_seq
op_eq
id|seq
)paren
)paren
suffix:semicolon
r_return
id|__tcp_sequence
c_func
(paren
id|tp
comma
id|seq
comma
id|end_seq
)paren
suffix:semicolon
)brace
multiline_comment|/* When we get a reset we do this. */
DECL|function|tcp_reset
r_static
r_void
id|tcp_reset
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
multiline_comment|/* We want the right error as BSD sees it (and indeed as we do). */
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_SYN_SENT
suffix:colon
id|sk-&gt;err
op_assign
id|ECONNREFUSED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE_WAIT
suffix:colon
id|sk-&gt;err
op_assign
id|EPIPE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE
suffix:colon
r_return
suffix:semicolon
r_default
suffix:colon
id|sk-&gt;err
op_assign
id|ECONNRESET
suffix:semicolon
)brace
id|tcp_done
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* This tags the retransmission queue when SACKs arrive. */
DECL|function|tcp_sacktag_write_queue
r_static
r_void
id|tcp_sacktag_write_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_sack_block
op_star
id|sp
comma
r_int
id|nsacks
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|i
op_assign
id|nsacks
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
id|__u32
id|start_seq
op_assign
id|ntohl
c_func
(paren
id|sp-&gt;start_seq
)paren
suffix:semicolon
id|__u32
id|end_seq
op_assign
id|ntohl
c_func
(paren
id|sp-&gt;end_seq
)paren
suffix:semicolon
r_int
id|fack_count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|skb
op_ne
id|tp-&gt;send_head
)paren
op_logical_and
(paren
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
(brace
multiline_comment|/* The retransmission queue is always in order, so&n;&t;&t;&t; * we can short-circuit the walk early.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|end_seq
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* We play conservative, we don&squot;t allow SACKS to partially&n;&t;&t;&t; * tag a sequence space.&n;&t;&t;&t; */
id|fack_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|start_seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
op_logical_and
op_logical_neg
id|before
c_func
(paren
id|end_seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
)paren
(brace
multiline_comment|/* If this was a retransmitted frame, account for it. */
r_if
c_cond
(paren
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_amp
id|TCPCB_SACKED_RETRANS
)paren
op_logical_and
id|tp-&gt;retrans_out
)paren
(brace
id|tp-&gt;retrans_out
op_decrement
suffix:semicolon
)brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_or_assign
id|TCPCB_SACKED_ACKED
suffix:semicolon
multiline_comment|/* RULE: All new SACKs will either decrease retrans_out&n;&t;&t;&t;&t; *       or advance fackets_out.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|fack_count
OG
id|tp-&gt;fackets_out
)paren
(brace
id|tp-&gt;fackets_out
op_assign
id|fack_count
suffix:semicolon
)brace
)brace
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
id|sp
op_increment
suffix:semicolon
multiline_comment|/* Move on to the next SACK block. */
)brace
)brace
multiline_comment|/* Look for tcp options. Normally only called on SYN and SYNACK packets.&n; * But, this can also be called on packets in the established flow when&n; * the fast version below fails.&n; */
DECL|function|tcp_parse_options
r_void
id|tcp_parse_options
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_struct
id|tcp_opt
op_star
id|tp
comma
r_int
id|no_fancy
)paren
(brace
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|length
op_assign
(paren
id|th-&gt;doff
op_star
l_int|4
)paren
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
suffix:semicolon
id|tp-&gt;saw_tstamp
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|length
OG
l_int|0
)paren
(brace
r_int
id|opcode
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_int
id|opsize
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|TCPOPT_EOL
suffix:colon
r_return
suffix:semicolon
r_case
id|TCPOPT_NOP
suffix:colon
multiline_comment|/* Ref: RFC 793 section 3.1 */
id|length
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
r_default
suffix:colon
id|opsize
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|opsize
OL
l_int|2
)paren
multiline_comment|/* &quot;silly options&quot; */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|opsize
OG
id|length
)paren
r_break
suffix:semicolon
multiline_comment|/* don&squot;t parse partial options */
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|TCPOPT_MSS
suffix:colon
r_if
c_cond
(paren
id|opsize
op_eq
id|TCPOLEN_MSS
op_logical_and
id|th-&gt;syn
)paren
(brace
id|u16
id|in_mss
op_assign
id|ntohs
c_func
(paren
op_star
(paren
id|__u16
op_star
)paren
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_mss
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;user_mss
op_logical_and
id|tp-&gt;user_mss
OL
id|in_mss
)paren
id|in_mss
op_assign
id|tp-&gt;user_mss
suffix:semicolon
id|tp-&gt;mss_clamp
op_assign
id|in_mss
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|TCPOPT_WINDOW
suffix:colon
r_if
c_cond
(paren
id|opsize
op_eq
id|TCPOLEN_WINDOW
op_logical_and
id|th-&gt;syn
)paren
r_if
c_cond
(paren
op_logical_neg
id|no_fancy
op_logical_and
id|sysctl_tcp_window_scaling
)paren
(brace
id|tp-&gt;wscale_ok
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;snd_wscale
op_assign
op_star
(paren
id|__u8
op_star
)paren
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;snd_wscale
OG
l_int|14
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tcp_parse_options: Illegal window &quot;
l_string|&quot;scaling value %d &gt;14 received.&quot;
comma
id|tp-&gt;snd_wscale
)paren
suffix:semicolon
)brace
id|tp-&gt;snd_wscale
op_assign
l_int|14
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|TCPOPT_TIMESTAMP
suffix:colon
r_if
c_cond
(paren
id|opsize
op_eq
id|TCPOLEN_TIMESTAMP
)paren
(brace
r_if
c_cond
(paren
id|sysctl_tcp_timestamps
op_logical_and
op_logical_neg
id|no_fancy
)paren
(brace
id|tp-&gt;tstamp_ok
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;saw_tstamp
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;rcv_tsval
op_assign
id|ntohl
c_func
(paren
op_star
(paren
id|__u32
op_star
)paren
id|ptr
)paren
suffix:semicolon
id|tp-&gt;rcv_tsecr
op_assign
id|ntohl
c_func
(paren
op_star
(paren
id|__u32
op_star
)paren
(paren
id|ptr
op_plus
l_int|4
)paren
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|TCPOPT_SACK_PERM
suffix:colon
r_if
c_cond
(paren
id|opsize
op_eq
id|TCPOLEN_SACK_PERM
op_logical_and
id|th-&gt;syn
)paren
(brace
r_if
c_cond
(paren
id|sysctl_tcp_sack
op_logical_and
op_logical_neg
id|no_fancy
)paren
(brace
id|tp-&gt;sack_ok
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;num_sacks
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|TCPOPT_SACK
suffix:colon
r_if
c_cond
(paren
(paren
id|opsize
op_ge
(paren
id|TCPOLEN_SACK_BASE
op_plus
id|TCPOLEN_SACK_PERBLOCK
)paren
)paren
op_logical_and
id|sysctl_tcp_sack
op_logical_and
(paren
id|sk
op_ne
l_int|NULL
)paren
op_logical_and
op_logical_neg
id|th-&gt;syn
)paren
(brace
r_int
id|sack_bytes
op_assign
id|opsize
op_minus
id|TCPOLEN_SACK_BASE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sack_bytes
op_mod
id|TCPOLEN_SACK_PERBLOCK
)paren
)paren
(brace
r_int
id|num_sacks
op_assign
id|sack_bytes
op_rshift
l_int|3
suffix:semicolon
r_struct
id|tcp_sack_block
op_star
id|sackp
suffix:semicolon
id|sackp
op_assign
(paren
r_struct
id|tcp_sack_block
op_star
)paren
id|ptr
suffix:semicolon
id|tcp_sacktag_write_queue
c_func
(paren
id|sk
comma
id|sackp
comma
id|num_sacks
)paren
suffix:semicolon
)brace
)brace
)brace
suffix:semicolon
id|ptr
op_add_assign
id|opsize
op_minus
l_int|2
suffix:semicolon
id|length
op_sub_assign
id|opsize
suffix:semicolon
)brace
suffix:semicolon
)brace
)brace
multiline_comment|/* Fast parse options. This hopes to only see timestamps.&n; * If it is wrong it falls back on tcp_parse_options().&n; */
DECL|function|tcp_fast_parse_options
r_static
id|__inline__
r_int
id|tcp_fast_parse_options
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
multiline_comment|/* If we didn&squot;t send out any options ignore them all. */
r_if
c_cond
(paren
id|tp-&gt;tcp_header_len
op_eq
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;doff
op_eq
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_rshift
l_int|2
)paren
(brace
id|tp-&gt;saw_tstamp
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|th-&gt;doff
op_eq
(paren
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_rshift
l_int|2
)paren
op_plus
(paren
id|TCPOLEN_TSTAMP_ALIGNED
op_rshift
l_int|2
)paren
)paren
(brace
id|__u32
op_star
id|ptr
op_assign
(paren
id|__u32
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ptr
op_eq
id|__constant_ntohl
c_func
(paren
(paren
id|TCPOPT_NOP
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOPT_NOP
op_lshift
l_int|16
)paren
op_or
(paren
id|TCPOPT_TIMESTAMP
op_lshift
l_int|8
)paren
op_or
id|TCPOLEN_TIMESTAMP
)paren
)paren
(brace
id|tp-&gt;saw_tstamp
op_assign
l_int|1
suffix:semicolon
op_increment
id|ptr
suffix:semicolon
id|tp-&gt;rcv_tsval
op_assign
id|ntohl
c_func
(paren
op_star
id|ptr
)paren
suffix:semicolon
op_increment
id|ptr
suffix:semicolon
id|tp-&gt;rcv_tsecr
op_assign
id|ntohl
c_func
(paren
op_star
id|ptr
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|tcp_parse_options
c_func
(paren
id|sk
comma
id|th
comma
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|macro|FLAG_DATA
mdefine_line|#define FLAG_DATA&t;&t;0x01 /* Incoming frame contained data.&t;&t;*/
DECL|macro|FLAG_WIN_UPDATE
mdefine_line|#define FLAG_WIN_UPDATE&t;&t;0x02 /* Incoming ACK was a window update.&t;*/
DECL|macro|FLAG_DATA_ACKED
mdefine_line|#define FLAG_DATA_ACKED&t;&t;0x04 /* This ACK acknowledged new data.&t;&t;*/
DECL|macro|FLAG_RETRANS_DATA_ACKED
mdefine_line|#define FLAG_RETRANS_DATA_ACKED&t;0x08 /* &quot;&quot; &quot;&quot; some of which was retransmitted.&t;*/
DECL|macro|FLAG_SYN_ACKED
mdefine_line|#define FLAG_SYN_ACKED&t;&t;0x10 /* This ACK acknowledged new data.&t;&t;*/
DECL|function|clear_fast_retransmit
r_static
id|__inline__
r_void
id|clear_fast_retransmit
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;dup_acks
OG
l_int|3
)paren
id|tp-&gt;snd_cwnd
op_assign
(paren
id|tp-&gt;snd_ssthresh
)paren
suffix:semicolon
id|tp-&gt;dup_acks
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* NOTE: This code assumes that tp-&gt;dup_acks gets cleared when a&n; * retransmit timer fires.&n; */
DECL|function|tcp_fast_retrans
r_static
r_void
id|tcp_fast_retrans
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|ack
comma
r_int
id|not_dup
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/* Note: If not_dup is set this implies we got a&n;&t; * data carrying packet or a window update.&n;&t; * This carries no new information about possible&n;&t; * lost packets, so we have to ignore it for the purposes&n;&t; * of counting duplicate acks. Ideally this does not imply we&n;&t; * should stop our fast retransmit phase, more acks may come&n;&t; * later without data to help us. Unfortunately this would make&n;&t; * the code below much more complex. For now if I see such&n;&t; * a packet I clear the fast retransmit phase.&n;&t; */
r_if
c_cond
(paren
id|ack
op_eq
id|tp-&gt;snd_una
op_logical_and
id|tp-&gt;packets_out
op_logical_and
(paren
id|not_dup
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* This is the standard reno style fast retransmit branch. */
multiline_comment|/* 1. When the third duplicate ack is received, set ssthresh &n;                 * to one half the current congestion window, but no less &n;                 * than two segments. Retransmit the missing segment.&n;                 */
r_if
c_cond
(paren
id|tp-&gt;high_seq
op_eq
l_int|0
op_logical_or
id|after
c_func
(paren
id|ack
comma
id|tp-&gt;high_seq
)paren
)paren
(brace
id|tp-&gt;dup_acks
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;fackets_out
OG
l_int|3
)paren
op_logical_or
(paren
id|tp-&gt;dup_acks
op_eq
l_int|3
)paren
)paren
(brace
id|__tcp_enter_cong_avoid
c_func
(paren
id|tp
)paren
suffix:semicolon
multiline_comment|/* ... and account for 3 ACKs, which are&n;&t;&t;&t;&t; * already received to this time.&n;&t;&t;&t;&t; */
id|tp-&gt;snd_cwnd
op_add_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;fackets_out
)paren
(brace
id|tcp_retransmit_skb
c_func
(paren
id|sk
comma
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
suffix:semicolon
)brace
r_else
id|tcp_fack_retransmit
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_increment
id|tp-&gt;dup_acks
OG
l_int|3
)paren
(brace
multiline_comment|/* 2. Each time another duplicate ACK arrives, increment &n;&t;&t;&t; * cwnd by the segment size. [...] Transmit a packet...&n;&t;&t;&t; *&n;&t;&t;&t; * Packet transmission will be done on normal flow processing&n;&t;&t;&t; * since we&squot;re not in &quot;retransmit mode&quot;.  We do not use&n;&t;&t;&t; * duplicate ACKs to artificially inflate the congestion&n;&t;&t;&t; * window when doing FACK.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;fackets_out
)paren
(brace
id|tp-&gt;snd_cwnd
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Fill any further holes which may have&n;&t;&t;&t;&t; * appeared.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * We may want to change this to run every&n;&t;&t;&t;&t; * further multiple-of-3 dup ack increments,&n;&t;&t;&t;&t; * to be more robust against out-of-order&n;&t;&t;&t;&t; * packet delivery.  -DaveM&n;&t;&t;&t;&t; */
id|tcp_fack_retransmit
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|tp-&gt;high_seq
op_ne
l_int|0
)paren
(brace
multiline_comment|/* In this branch we deal with clearing the Floyd style&n;&t;&t; * block on duplicate fast retransmits, and if requested&n;&t;&t; * we do Hoe style secondary fast retransmits.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|before
c_func
(paren
id|ack
comma
id|tp-&gt;high_seq
)paren
op_logical_or
(paren
id|not_dup
op_amp
id|FLAG_DATA
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Once we have acked all the packets up to high_seq&n;&t;&t;&t; * we are done this fast retransmit phase.&n;&t;&t;&t; * Alternatively data arrived. In this case we&n;&t;&t;&t; * Have to abort the fast retransmit attempt.&n;&t;&t;&t; * Note that we do want to accept a window&n;&t;&t;&t; * update since this is expected with Hoe&squot;s algorithm.&n;&t;&t;&t; */
id|clear_fast_retransmit
c_func
(paren
id|tp
)paren
suffix:semicolon
multiline_comment|/* After we have cleared up to high_seq we can&n;&t;&t;&t; * clear the Floyd style block.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|before
c_func
(paren
id|ack
comma
id|tp-&gt;high_seq
)paren
)paren
(brace
id|tp-&gt;high_seq
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;fackets_out
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|tp-&gt;dup_acks
op_ge
l_int|3
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;fackets_out
)paren
(brace
multiline_comment|/* Hoe Style. We didn&squot;t ack the whole&n;&t;&t;&t;&t; * window. Take this as a cue that&n;&t;&t;&t;&t; * another packet was lost and retransmit it.&n;&t;&t;&t;&t; * Don&squot;t muck with the congestion window here.&n;&t;&t;&t;&t; * Note that we have to be careful not to&n;&t;&t;&t;&t; * act if this was a window update and it&n;&t;&t;&t;&t; * didn&squot;t ack new data, since this does&n;&t;&t;&t;&t; * not indicate a packet left the system.&n;&t;&t;&t;&t; * We can test this by just checking&n;&t;&t;&t;&t; * if ack changed from snd_una, since&n;&t;&t;&t;&t; * the only way to get here without advancing&n;&t;&t;&t;&t; * from snd_una is if this was a window update.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ack
op_ne
id|tp-&gt;snd_una
op_logical_and
id|before
c_func
(paren
id|ack
comma
id|tp-&gt;high_seq
)paren
)paren
(brace
id|tcp_retransmit_skb
c_func
(paren
id|sk
comma
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* FACK style, fill any remaining holes in&n;&t;&t;&t;&t; * receiver&squot;s queue.&n;&t;&t;&t;&t; */
id|tcp_fack_retransmit
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* This is Jacobson&squot;s slow start and congestion avoidance. &n; * SIGCOMM &squot;88, p. 328.&n; */
DECL|function|tcp_cong_avoid
r_static
id|__inline__
r_void
id|tcp_cong_avoid
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd
op_le
id|tp-&gt;snd_ssthresh
)paren
(brace
multiline_comment|/* In &quot;safe&quot; area, increase. */
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd
OL
id|tp-&gt;snd_cwnd_clamp
)paren
id|tp-&gt;snd_cwnd
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* In dangerous area, increase slowly.&n;&t;&t; * In theory this is tp-&gt;snd_cwnd += 1 / tp-&gt;snd_cwnd&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd_cnt
op_ge
id|tp-&gt;snd_cwnd
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd
OL
id|tp-&gt;snd_cwnd_clamp
)paren
id|tp-&gt;snd_cwnd
op_increment
suffix:semicolon
id|tp-&gt;snd_cwnd_cnt
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|tp-&gt;snd_cwnd_cnt
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Remove acknowledged frames from the retransmission queue. */
DECL|function|tcp_clean_rtx_queue
r_static
r_int
id|tcp_clean_rtx_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|__u32
id|ack
comma
id|__u32
op_star
id|seq
comma
id|__u32
op_star
id|seq_rtt
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|__u32
id|now
op_assign
id|tcp_time_stamp
suffix:semicolon
r_int
id|acked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If we are retransmitting, and this ACK clears up to&n;&t; * the retransmit head, or further, then clear our state.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;retrans_head
op_ne
l_int|NULL
op_logical_and
op_logical_neg
id|before
c_func
(paren
id|ack
comma
id|TCP_SKB_CB
c_func
(paren
id|tp-&gt;retrans_head
)paren
op_member_access_from_pointer
id|end_seq
)paren
)paren
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
op_logical_and
(paren
id|skb
op_ne
id|tp-&gt;send_head
)paren
)paren
(brace
r_struct
id|tcp_skb_cb
op_star
id|scb
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|__u8
id|sacked
op_assign
id|scb-&gt;sacked
suffix:semicolon
multiline_comment|/* If our packet is before the ack sequence we can&n;&t;&t; * discard it as it&squot;s confirmed to have arrived at&n;&t;&t; * the other end.&n;&t;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|scb-&gt;end_seq
comma
id|ack
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Initial outgoing SYN&squot;s get put onto the write_queue&n;&t;&t; * just like anything else we transmit.  It is not&n;&t;&t; * true data, and if we misinform our callers that&n;&t;&t; * this ACK acks real data, we will erroneously exit&n;&t;&t; * connection startup slow start one packet too&n;&t;&t; * quickly.  This is severely frowned upon behavior.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|sacked
op_amp
id|TCPCB_SACKED_RETRANS
)paren
op_logical_and
id|tp-&gt;retrans_out
)paren
(brace
id|tp-&gt;retrans_out
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;flags
op_amp
id|TCPCB_FLAG_SYN
)paren
)paren
(brace
id|acked
op_or_assign
id|FLAG_DATA_ACKED
suffix:semicolon
r_if
c_cond
(paren
id|sacked
op_amp
id|TCPCB_SACKED_RETRANS
)paren
(brace
id|acked
op_or_assign
id|FLAG_RETRANS_DATA_ACKED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;fackets_out
)paren
(brace
id|tp-&gt;fackets_out
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
id|acked
op_or_assign
id|FLAG_SYN_ACKED
suffix:semicolon
multiline_comment|/* This is pure paranoia. */
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
)brace
id|tp-&gt;packets_out
op_decrement
suffix:semicolon
op_star
id|seq
op_assign
id|scb-&gt;seq
suffix:semicolon
op_star
id|seq_rtt
op_assign
id|now
op_minus
id|scb-&gt;when
suffix:semicolon
id|__skb_unlink
c_func
(paren
id|skb
comma
id|skb-&gt;list
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_return
id|acked
suffix:semicolon
)brace
DECL|function|tcp_ack_probe
r_static
r_void
id|tcp_ack_probe
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|__u32
id|ack
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/* Was it a usable window open? */
r_if
c_cond
(paren
id|tp-&gt;send_head
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|tp-&gt;send_head
)paren
op_member_access_from_pointer
id|end_seq
comma
id|ack
op_plus
id|tp-&gt;snd_wnd
)paren
)paren
(brace
id|tp-&gt;backoff
op_assign
l_int|0
suffix:semicolon
id|tcp_clear_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_PROBE0
)paren
suffix:semicolon
multiline_comment|/* If packets_out==0, socket must be waked up by&n;&t;&t;&t; * subsequent tcp_data_snd_check(). This function is&n;&t;&t;&t; * not for random using!&n;&t;&t;&t; */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;packets_out
)paren
(brace
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_PROBE0
comma
id|min
c_func
(paren
id|tp-&gt;rto
op_lshift
id|tp-&gt;backoff
comma
id|TCP_RTO_MAX
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Should we open up the congestion window? */
DECL|function|should_advance_cwnd
r_static
id|__inline__
r_int
id|should_advance_cwnd
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_int
id|flag
)paren
(brace
multiline_comment|/* Data must have been acked. */
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|FLAG_DATA_ACKED
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Some of the data acked was retransmitted somehow? */
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|FLAG_RETRANS_DATA_ACKED
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* We advance in all cases except during&n;&t;&t; * non-FACK fast retransmit/recovery.&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;fackets_out
op_ne
l_int|0
op_logical_or
id|tp-&gt;retransmits
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Non-FACK fast retransmit does it&squot;s own&n;&t;&t; * congestion window management, don&squot;t get&n;&t;&t; * in the way.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* New non-retransmitted data acked, always advance.  */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Read draft-ietf-tcplw-high-performance before mucking&n; * with this code. (Superceeds RFC1323)&n; */
DECL|function|tcp_ack_saw_tstamp
r_static
r_void
id|tcp_ack_saw_tstamp
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_opt
op_star
id|tp
comma
id|u32
id|seq
comma
id|u32
id|ack
comma
r_int
id|flag
)paren
(brace
id|__u32
id|seq_rtt
suffix:semicolon
multiline_comment|/* RTTM Rule: A TSecr value received in a segment is used to&n;&t; * update the averaged RTT measurement only if the segment&n;&t; * acknowledges some new data, i.e., only if it advances the&n;&t; * left edge of the send window.&n;&t; *&n;&t; * See draft-ietf-tcplw-high-performance-00, section 3.3.&n;&t; * 1998/04/10 Andrey V. Savochkin &lt;saw@msu.ru&gt;&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flag
op_amp
(paren
id|FLAG_DATA_ACKED
op_or
id|FLAG_SYN_ACKED
)paren
)paren
)paren
r_return
suffix:semicolon
id|seq_rtt
op_assign
id|tcp_time_stamp
op_minus
id|tp-&gt;rcv_tsecr
suffix:semicolon
id|tcp_rtt_estimator
c_func
(paren
id|tp
comma
id|seq_rtt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;retransmits
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;packets_out
op_eq
l_int|0
)paren
(brace
id|tp-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;fackets_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;retrans_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;backoff
op_assign
l_int|0
suffix:semicolon
id|tcp_set_rto
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Still retransmitting, use backoff */
id|tcp_set_rto
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;rto
op_assign
id|tp-&gt;rto
op_lshift
id|tp-&gt;backoff
suffix:semicolon
)brace
)brace
r_else
(brace
id|tcp_set_rto
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
id|tcp_bound_rto
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
DECL|function|tcp_ack_packets_out
r_static
id|__inline__
r_void
id|tcp_ack_packets_out
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
macro_line|#ifdef TCP_DEBUG
multiline_comment|/* It occured in 2.3, because of racy timers. Namely,&n;&t; * retransmit timer did not check packets_out and retransmitted&n;&t; * send_head sometimes and, hence, messed all the write_queue.&n;&t; * Now it is impossible, I bet. --ANK&n;&t; */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sucks! packets_out=%d, sk=%p, %d&bslash;n&quot;
comma
id|tp-&gt;packets_out
comma
id|sk
comma
id|sk-&gt;state
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Some data was ACK&squot;d, if still retransmitting (due to a&n;&t; * timeout), resend more of the retransmit queue.  The&n;&t; * congestion window is handled properly by that code.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;retransmits
)paren
(brace
id|tcp_xmit_retransmit_queue
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
r_else
(brace
id|__u32
id|when
op_assign
id|tp-&gt;rto
op_minus
(paren
id|tcp_time_stamp
op_minus
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|__s32
)paren
id|when
OL
l_int|0
)paren
id|when
op_assign
l_int|1
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
comma
id|when
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This routine deals with incoming acks, but not outgoing ones. */
DECL|function|tcp_ack
r_static
r_int
id|tcp_ack
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
id|u32
id|ack_seq
comma
id|u32
id|ack
comma
r_int
id|len
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
id|u32
id|seq
op_assign
l_int|0
suffix:semicolon
id|u32
id|seq_rtt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Dead, can&squot;t ack any more so why bother */
multiline_comment|/* If the ack is newer than sent or older than previous acks&n;&t; * then we can probably ignore it.&n;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|ack
comma
id|tp-&gt;snd_nxt
)paren
op_logical_or
id|before
c_func
(paren
id|ack
comma
id|tp-&gt;snd_una
)paren
)paren
r_goto
id|uninteresting_ack
suffix:semicolon
multiline_comment|/* If there is data set flag 1 */
r_if
c_cond
(paren
id|len
op_ne
id|th-&gt;doff
op_star
l_int|4
)paren
id|flag
op_or_assign
id|FLAG_DATA
suffix:semicolon
multiline_comment|/* Update our send window. */
multiline_comment|/* This is the window update code as per RFC 793&n;&t; * snd_wl{1,2} are used to prevent unordered&n;&t; * segments from shrinking the window &n;&t; */
r_if
c_cond
(paren
id|before
c_func
(paren
id|tp-&gt;snd_wl1
comma
id|ack_seq
)paren
op_logical_or
(paren
id|tp-&gt;snd_wl1
op_eq
id|ack_seq
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|tp-&gt;snd_wl2
comma
id|ack
)paren
)paren
)paren
(brace
id|u32
id|nwin
op_assign
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
op_lshift
id|tp-&gt;snd_wscale
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;snd_wl2
op_ne
id|ack
)paren
op_logical_or
(paren
id|nwin
OG
id|tp-&gt;snd_wnd
)paren
)paren
(brace
id|flag
op_or_assign
id|FLAG_WIN_UPDATE
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;snd_wnd
op_ne
id|nwin
)paren
(brace
id|tp-&gt;snd_wnd
op_assign
id|nwin
suffix:semicolon
multiline_comment|/* Note, it is the only place, where&n;&t;&t;&t;&t; * fast path is recovered for sending TCP.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
op_eq
l_int|0
op_logical_and
macro_line|#ifdef TCP_FORMAL_WINDOW
id|tcp_receive_window
c_func
(paren
id|tp
)paren
op_logical_and
macro_line|#endif
op_logical_neg
id|tp-&gt;urg_data
)paren
id|tcp_fast_path_on
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nwin
OG
id|tp-&gt;max_window
)paren
(brace
id|tp-&gt;max_window
op_assign
id|nwin
suffix:semicolon
id|tcp_sync_mss
c_func
(paren
id|sk
comma
id|tp-&gt;pmtu_cookie
)paren
suffix:semicolon
)brace
)brace
id|tp-&gt;snd_wl1
op_assign
id|ack_seq
suffix:semicolon
id|tp-&gt;snd_wl2
op_assign
id|ack
suffix:semicolon
)brace
)brace
multiline_comment|/* BEWARE! From this place and until return from this function&n;&t; * snd_nxt and snd_wnd are out of sync. All the routines, called&n;&t; * from here must get &quot;ack&quot; as argument or they should not depend&n;&t; * on right edge of window. It is _UGLY_. It cries to be fixed. --ANK&n;&t; */
multiline_comment|/* We passed data and got it acked, remove any soft error&n;&t; * log. Something worked...&n;&t; */
id|sk-&gt;err_soft
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;probes_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;rcv_tstamp
op_assign
id|tcp_time_stamp
suffix:semicolon
multiline_comment|/* See if we can take anything off of the retransmit queue. */
id|flag
op_or_assign
id|tcp_clean_rtx_queue
c_func
(paren
id|sk
comma
id|ack
comma
op_amp
id|seq
comma
op_amp
id|seq_rtt
)paren
suffix:semicolon
multiline_comment|/* If this ack opens up a zero window, clear backoff.  It was&n;&t; * being used to time the probes, and is probably far higher than&n;&t; * it needs to be for normal retransmission.&n;&t; */
r_if
c_cond
(paren
id|tcp_timer_is_set
c_func
(paren
id|sk
comma
id|TCP_TIME_PROBE0
)paren
)paren
id|tcp_ack_probe
c_func
(paren
id|sk
comma
id|ack
)paren
suffix:semicolon
multiline_comment|/* We must do this here, before code below clears out important&n;&t; * state contained in tp-&gt;fackets_out and tp-&gt;retransmits.  -DaveM&n;&t; */
r_if
c_cond
(paren
id|should_advance_cwnd
c_func
(paren
id|tp
comma
id|flag
)paren
)paren
id|tcp_cong_avoid
c_func
(paren
id|tp
)paren
suffix:semicolon
multiline_comment|/* If we have a timestamp, we always do rtt estimates. */
r_if
c_cond
(paren
id|tp-&gt;saw_tstamp
)paren
(brace
id|tcp_ack_saw_tstamp
c_func
(paren
id|sk
comma
id|tp
comma
id|seq
comma
id|ack
comma
id|flag
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If we were retransmiting don&squot;t count rtt estimate. */
r_if
c_cond
(paren
id|tp-&gt;retransmits
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;packets_out
op_eq
l_int|0
)paren
(brace
id|tp-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;fackets_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;retrans_out
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* We don&squot;t have a timestamp. Can only use&n;&t;&t;&t; * packets that are not retransmitted to determine&n;&t;&t;&t; * rtt estimates. Also, we must not reset the&n;&t;&t;&t; * backoff for rto until we get a non-retransmitted&n;&t;&t;&t; * packet. This allows us to deal with a situation&n;&t;&t;&t; * where the network delay has increased suddenly.&n;&t;&t;&t; * I.e. Karn&squot;s algorithm. (SIGCOMM &squot;87, p5.)&n;&t;&t;&t; */
r_if
c_cond
(paren
id|flag
op_amp
(paren
id|FLAG_DATA_ACKED
op_or
id|FLAG_SYN_ACKED
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flag
op_amp
id|FLAG_RETRANS_DATA_ACKED
)paren
)paren
(brace
id|tp-&gt;backoff
op_assign
l_int|0
suffix:semicolon
id|tcp_rtt_estimator
c_func
(paren
id|tp
comma
id|seq_rtt
)paren
suffix:semicolon
id|tcp_set_rto
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tcp_bound_rto
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|tp-&gt;packets_out
)paren
(brace
r_if
c_cond
(paren
id|flag
op_amp
id|FLAG_DATA_ACKED
)paren
id|tcp_ack_packets_out
c_func
(paren
id|sk
comma
id|tp
)paren
suffix:semicolon
)brace
r_else
(brace
id|tcp_clear_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
)paren
suffix:semicolon
)brace
id|flag
op_and_assign
(paren
id|FLAG_DATA
op_or
id|FLAG_WIN_UPDATE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ack
op_eq
id|tp-&gt;snd_una
op_logical_and
id|tp-&gt;packets_out
op_logical_and
id|flag
op_eq
l_int|0
)paren
op_logical_or
(paren
id|tp-&gt;high_seq
op_ne
l_int|0
)paren
)paren
(brace
id|tcp_fast_retrans
c_func
(paren
id|sk
comma
id|ack
comma
id|flag
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Clear any aborted fast retransmit starts. */
id|tp-&gt;dup_acks
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* It is not a brain fart, I thought a bit now. 8)&n;&t; *&n;&t; * Forward progress is indicated, if:&n;&t; *   1. the ack acknowledges new data.&n;&t; *   2. or the ack is duplicate, but it is caused by new segment&n;&t; *      arrival. This case is filtered by:&n;&t; *      - it contains no data, syn or fin.&n;&t; *      - it does not update window.&n;&t; *   3. or new SACK. It is difficult to check, so that we ignore it.&n;&t; *&n;&t; * Forward progress is also indicated by arrival new data,&n;&t; * which was caused by window open from our side. This case is more&n;&t; * difficult and it is made (alas, incorrectly) in tcp_data_queue().&n;&t; *                                              --ANK (990513)&n;&t; */
r_if
c_cond
(paren
id|ack
op_ne
id|tp-&gt;snd_una
op_logical_or
(paren
id|flag
op_eq
l_int|0
op_logical_and
op_logical_neg
id|th-&gt;fin
)paren
)paren
id|dst_confirm
c_func
(paren
id|sk-&gt;dst_cache
)paren
suffix:semicolon
multiline_comment|/* Remember the highest ack received. */
id|tp-&gt;snd_una
op_assign
id|ack
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|uninteresting_ack
suffix:colon
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;Ack ignored %u %u&bslash;n&quot;
comma
id|ack
comma
id|tp-&gt;snd_nxt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tcp_paws_check
r_int
id|tcp_paws_check
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_int
id|rst
)paren
(brace
r_if
c_cond
(paren
(paren
id|s32
)paren
(paren
id|tp-&gt;rcv_tsval
op_minus
id|tp-&gt;ts_recent
)paren
op_ge
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|xtime.tv_sec
op_ge
id|tp-&gt;ts_recent_stamp
op_plus
id|TCP_PAWS_24DAYS
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* RST segments are not recommended to carry timestamp,&n;&t;   and, if they do, it is recommended to ignore PAWS because&n;&t;   &quot;their cleanup function should take precedence over timestamps.&quot;&n;&t;   Certainly, it is mistake. It is necessary to understand the reasons&n;&t;   of this constraint to relax it: if peer reboots, clock may go&n;&t;   out-of-sync and half-open connections will not be reset.&n;&t;   Actually, the problem would be not existing if all&n;&t;   the implementations followed draft about maintaining clock&n;&t;   via reboots. Linux-2.2 DOES NOT!&n;&n;&t;   However, we can relax time bounds for RST segments to MSL.&n;&t; */
r_if
c_cond
(paren
id|rst
op_logical_and
id|xtime.tv_sec
op_ge
id|tp-&gt;ts_recent_stamp
op_plus
id|TCP_PAWS_MSL
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|tcp_in_window
r_static
id|__inline__
r_int
id|tcp_in_window
c_func
(paren
id|u32
id|seq
comma
id|u32
id|end_seq
comma
id|u32
id|s_win
comma
id|u32
id|e_win
)paren
(brace
r_if
c_cond
(paren
id|seq
op_eq
id|s_win
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|end_seq
comma
id|s_win
)paren
op_logical_and
id|before
c_func
(paren
id|seq
comma
id|e_win
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
(paren
id|seq
op_eq
id|e_win
op_logical_and
id|seq
op_eq
id|end_seq
)paren
suffix:semicolon
)brace
multiline_comment|/* New-style handling of TIME_WAIT sockets. */
multiline_comment|/* Must be called with locally disabled BHs. */
DECL|function|tcp_timewait_kill
r_void
id|tcp_timewait_kill
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
)paren
(brace
r_struct
id|tcp_ehash_bucket
op_star
id|ehead
suffix:semicolon
r_struct
id|tcp_bind_hashbucket
op_star
id|bhead
suffix:semicolon
r_struct
id|tcp_bind_bucket
op_star
id|tb
suffix:semicolon
multiline_comment|/* Unlink from established hashes. */
id|ehead
op_assign
op_amp
id|tcp_ehash
(braket
id|tw-&gt;hashent
)braket
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|ehead-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tw-&gt;pprev
)paren
(brace
id|write_unlock
c_func
(paren
op_amp
id|ehead-&gt;lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tw-&gt;next
)paren
(brace
id|tw-&gt;next-&gt;pprev
op_assign
id|tw-&gt;pprev
suffix:semicolon
)brace
op_star
(paren
id|tw-&gt;pprev
)paren
op_assign
id|tw-&gt;next
suffix:semicolon
id|tw-&gt;pprev
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|ehead-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Disassociate with bind bucket. */
id|bhead
op_assign
op_amp
id|tcp_bhash
(braket
id|tcp_bhashfn
c_func
(paren
id|tw-&gt;num
)paren
)braket
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|bhead-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tb
op_assign
id|tw-&gt;tb
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|tw-&gt;bind_next
)paren
(brace
id|tw-&gt;bind_next-&gt;bind_pprev
op_assign
id|tw-&gt;bind_pprev
suffix:semicolon
)brace
op_star
(paren
id|tw-&gt;bind_pprev
)paren
op_assign
id|tw-&gt;bind_next
suffix:semicolon
id|tw-&gt;tb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;owners
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|tb-&gt;next
)paren
id|tb-&gt;next-&gt;pprev
op_assign
id|tb-&gt;pprev
suffix:semicolon
op_star
(paren
id|tb-&gt;pprev
)paren
op_assign
id|tb-&gt;next
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|tcp_bucket_cachep
comma
id|tb
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|bhead-&gt;lock
)paren
suffix:semicolon
macro_line|#ifdef INET_REFCNT_DEBUG
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|tw-&gt;refcnt
)paren
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tw_bucket %p refcnt=%d&bslash;n&quot;
comma
id|tw
comma
id|atomic_read
c_func
(paren
op_amp
id|tw-&gt;refcnt
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * * Main purpose of TIME-WAIT state is to close connection gracefully,&n; *   when one of ends sits in LAST-ACK or CLOSING retransmitting FIN&n; *   (and, probably, tail of data) and one or more our ACKs are lost.&n; * * What is TIME-WAIT timeout? It is associated with maximal packet&n; *   lifetime in the internet, which results in wrong conclusion, that&n; *   it is set to catch &quot;old duplicate segments&quot; wandering out of their path.&n; *   It is not quite correct. This timeout is calculated so that it exceeds&n; *   maximal retransmision timeout enough to allow to lose one (or more)&n; *   segments sent by peer and our ACKs. This time may be calculated from RTO.&n; * * When TIME-WAIT socket receives RST, it means that another end&n; *   finally closed and we are allowed to kill TIME-WAIT too.&n; * * Second purpose of TIME-WAIT is catching old duplicate segments.&n; *   Well, certainly it is pure paranoia, but if we load TIME-WAIT&n; *   with this semantics, we MUST NOT kill TIME-WAIT state with RSTs.&n; * * If we invented some more clever way to catch duplicates&n; *   (f.e. based on PAWS), we could truncate TIME-WAIT to several RTOs.&n; *&n; * The algorithm below is based on FORMAL INTERPRETATION of RFCs.&n; * When you compare it to RFCs, please, read section SEGMENT ARRIVES&n; * from the very beginning.&n; *&n; * NOTE. With recycling (and later with fin-wait-2) TW bucket&n; * is _not_ stateless. It means, that strictly speaking we must&n; * spinlock it. I do not want! Well, probability of misbehaviour&n; * is ridiculously low and, seems, we could use some mb() tricks&n; * to avoid misread sequence numbers, states etc.  --ANK&n; */
r_enum
id|tcp_tw_status
DECL|function|tcp_timewait_state_process
id|tcp_timewait_state_process
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
)paren
(brace
r_struct
id|tcp_opt
id|tp
suffix:semicolon
r_int
id|paws_reject
op_assign
l_int|0
suffix:semicolon
id|tp.saw_tstamp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;doff
OG
(paren
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_rshift
l_int|2
)paren
op_logical_and
id|tw-&gt;ts_recent_stamp
)paren
(brace
id|tcp_parse_options
c_func
(paren
l_int|NULL
comma
id|th
comma
op_amp
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp.saw_tstamp
)paren
(brace
id|tp.ts_recent
op_assign
id|tw-&gt;ts_recent
suffix:semicolon
id|tp.ts_recent_stamp
op_assign
id|tw-&gt;ts_recent_stamp
suffix:semicolon
id|paws_reject
op_assign
id|tcp_paws_check
c_func
(paren
op_amp
id|tp
comma
id|th-&gt;rst
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tw-&gt;substate
op_eq
id|TCP_FIN_WAIT2
)paren
(brace
multiline_comment|/* Just repeat all the checks of tcp_rcv_state_process() */
multiline_comment|/* Out of window, send ACK */
r_if
c_cond
(paren
id|paws_reject
op_logical_or
op_logical_neg
id|tcp_in_window
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tw-&gt;rcv_nxt
comma
id|tw-&gt;rcv_nxt
op_plus
id|tw-&gt;rcv_wnd
)paren
)paren
r_return
id|TCP_TW_ACK
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;rst
)paren
r_goto
id|kill
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;syn
op_logical_and
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_ne
id|tw-&gt;syn_seq
)paren
r_goto
id|kill_with_rst
suffix:semicolon
multiline_comment|/* Dup ACK? */
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tw-&gt;rcv_nxt
)paren
op_logical_or
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_eq
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
(brace
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
r_return
id|TCP_TW_SUCCESS
suffix:semicolon
)brace
multiline_comment|/* New data or FIN. If new data arrive after half-duplex close,&n;&t;&t; * reset.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;fin
op_logical_or
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_ne
id|tw-&gt;rcv_nxt
op_plus
l_int|1
)paren
(brace
id|kill_with_rst
suffix:colon
id|tcp_tw_deschedule
c_func
(paren
id|tw
)paren
suffix:semicolon
id|tcp_timewait_kill
c_func
(paren
id|tw
)paren
suffix:semicolon
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
r_return
id|TCP_TW_RST
suffix:semicolon
)brace
multiline_comment|/* FIN arrived, enter true time-wait state. */
id|tw-&gt;substate
op_assign
id|TCP_TIME_WAIT
suffix:semicolon
id|tw-&gt;rcv_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
r_if
c_cond
(paren
id|tp.saw_tstamp
)paren
(brace
id|tw-&gt;ts_recent_stamp
op_assign
id|xtime.tv_sec
suffix:semicolon
id|tw-&gt;ts_recent
op_assign
id|tp.rcv_tsval
suffix:semicolon
)brace
multiline_comment|/* I am shamed, but failed to make it more elegant.&n;&t;&t; * Yes, it is direct reference to IP, which is impossible&n;&t;&t; * to generalize to IPv6. Taking into account that IPv6&n;&t;&t; * do not undertsnad recycling in any case, it not&n;&t;&t; * a big problem in practice. --ANK */
r_if
c_cond
(paren
id|tw-&gt;family
op_eq
id|AF_INET
op_logical_and
id|sysctl_tcp_tw_recycle
op_logical_and
id|tw-&gt;ts_recent_stamp
op_logical_and
id|tcp_v4_tw_remember_stamp
c_func
(paren
id|tw
)paren
)paren
id|tcp_tw_schedule
c_func
(paren
id|tw
comma
id|tw-&gt;timeout
)paren
suffix:semicolon
r_else
id|tcp_tw_schedule
c_func
(paren
id|tw
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
r_return
id|TCP_TW_ACK
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Now real TIME-WAIT state.&n;&t; *&n;&t; *&t;RFC 1122:&n;&t; *&t;&quot;When a connection is [...] on TIME-WAIT state [...]&n;&t; *&t;[a TCP] MAY accept a new SYN from the remote TCP to&n;&t; *&t;reopen the connection directly, if it:&n;&t; *&t;&n;&t; *&t;(1)  assigns its initial sequence number for the new&n;&t; *&t;connection to be larger than the largest sequence&n;&t; *&t;number it used on the previous connection incarnation,&n;&t; *&t;and&n;&t; *&n;&t; *&t;(2)  returns to TIME-WAIT state if the SYN turns out &n;&t; *&t;to be an old duplicate&quot;.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|paws_reject
op_logical_and
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_eq
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_logical_and
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_eq
id|tw-&gt;rcv_nxt
)paren
)paren
(brace
multiline_comment|/* In window segment, it may be only reset or bare ack. */
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
multiline_comment|/* This is TIME_WAIT assasination, in two flavors.&n;&t;&t;&t; * Oh well... nobody has a sufficient solution to this&n;&t;&t;&t; * protocol bug yet.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sysctl_tcp_rfc1337
op_eq
l_int|0
)paren
(brace
id|kill
suffix:colon
id|tcp_tw_deschedule
c_func
(paren
id|tw
)paren
suffix:semicolon
id|tcp_timewait_kill
c_func
(paren
id|tw
)paren
suffix:semicolon
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
r_return
id|TCP_TW_SUCCESS
suffix:semicolon
)brace
)brace
id|tcp_tw_schedule
c_func
(paren
id|tw
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp.saw_tstamp
)paren
(brace
id|tw-&gt;ts_recent
op_assign
id|tp.rcv_tsval
suffix:semicolon
id|tw-&gt;ts_recent_stamp
op_assign
id|xtime.tv_sec
suffix:semicolon
)brace
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
r_return
id|TCP_TW_SUCCESS
suffix:semicolon
)brace
multiline_comment|/* Out of window segment.&n;&n;&t;   All the segments are ACKed immediately.&n;&n;&t;   The only exception is new SYN. We accept it, if it is&n;&t;   not old duplicate and we are not in danger to be killed&n;&t;   by delayed old duplicates. RFC check is that it has&n;&t;   newer sequence number works at rates &lt;40Mbit/sec.&n;&t;   However, if paws works, it is reliable AND even more,&n;&t;   we even may relax silly seq space cutoff.&n;&n;&t;   RED-PEN: we violate main RFC requirement, if this SYN will appear&n;&t;   old duplicate (i.e. we receive RST in reply to SYN-ACK),&n;&t;   we must return socket to time-wait state. It is not good,&n;&t;   but not fatal yet.&n;&t; */
r_if
c_cond
(paren
id|th-&gt;syn
op_logical_and
op_logical_neg
id|th-&gt;rst
op_logical_and
op_logical_neg
id|th-&gt;ack
op_logical_and
op_logical_neg
id|paws_reject
op_logical_and
(paren
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|tw-&gt;rcv_nxt
)paren
op_logical_or
(paren
id|tp.saw_tstamp
op_logical_and
(paren
id|s32
)paren
(paren
id|tw-&gt;ts_recent
op_minus
id|tp.rcv_tsval
)paren
OL
l_int|0
)paren
)paren
)paren
(brace
id|u32
id|isn
op_assign
id|tw-&gt;snd_nxt
op_plus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|isn
op_eq
l_int|0
)paren
id|isn
op_increment
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|isn
suffix:semicolon
r_return
id|TCP_TW_SYN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|paws_reject
)paren
id|NET_INC_STATS_BH
c_func
(paren
id|PAWSEstabRejected
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;rst
)paren
(brace
multiline_comment|/* In this case we must reset the TIMEWAIT timer.&n;&t;&t; *&n;&t;&t; * If it is ACKless SYN it may be both old duplicate&n;&t;&t; * and new good SYN with random sequence number &lt;rcv_nxt.&n;&t;&t; * Do not reschedule in the last case.&n;&t;&t; */
r_if
c_cond
(paren
id|paws_reject
op_logical_or
id|th-&gt;ack
)paren
id|tcp_tw_schedule
c_func
(paren
id|tw
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
multiline_comment|/* Send ACK. Note, we do not put the bucket,&n;&t;&t; * it will be released by caller.&n;&t;&t; */
r_return
id|TCP_TW_ACK
suffix:semicolon
)brace
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
r_return
id|TCP_TW_SUCCESS
suffix:semicolon
)brace
multiline_comment|/* Enter the time wait state.  This is called with locally disabled BH.&n; * Essentially we whip up a timewait bucket, copy the&n; * relevant info into it from the SK, and mess with hash chains&n; * and list linkage.&n; */
DECL|function|__tcp_tw_hashdance
r_static
r_void
id|__tcp_tw_hashdance
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_tw_bucket
op_star
id|tw
)paren
(brace
r_struct
id|tcp_ehash_bucket
op_star
id|ehead
op_assign
op_amp
id|tcp_ehash
(braket
id|sk-&gt;hashent
)braket
suffix:semicolon
r_struct
id|tcp_bind_hashbucket
op_star
id|bhead
suffix:semicolon
r_struct
id|sock
op_star
op_star
id|head
comma
op_star
id|sktw
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|ehead-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Step 1: Remove SK from established hash. */
r_if
c_cond
(paren
id|sk-&gt;pprev
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;next
)paren
(brace
id|sk-&gt;next-&gt;pprev
op_assign
id|sk-&gt;pprev
suffix:semicolon
)brace
op_star
id|sk-&gt;pprev
op_assign
id|sk-&gt;next
suffix:semicolon
id|sk-&gt;pprev
op_assign
l_int|NULL
suffix:semicolon
id|sock_prot_dec_use
c_func
(paren
id|sk-&gt;prot
)paren
suffix:semicolon
)brace
multiline_comment|/* Step 2: Hash TW into TIMEWAIT half of established hash table. */
id|head
op_assign
op_amp
(paren
id|ehead
op_plus
id|tcp_ehash_size
)paren
op_member_access_from_pointer
id|chain
suffix:semicolon
id|sktw
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|tw
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sktw-&gt;next
op_assign
op_star
id|head
)paren
op_ne
l_int|NULL
)paren
(brace
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|pprev
op_assign
op_amp
id|sktw-&gt;next
suffix:semicolon
)brace
op_star
id|head
op_assign
id|sktw
suffix:semicolon
id|sktw-&gt;pprev
op_assign
id|head
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|tw-&gt;refcnt
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|ehead-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Step 3: Put TW into bind hash. Original socket stays there too.&n;&t;   Note, that any socket with sk-&gt;num!=0 MUST be bound in binding&n;&t;   cache, even if it is closed.&n;&t; */
id|bhead
op_assign
op_amp
id|tcp_bhash
(braket
id|tcp_bhashfn
c_func
(paren
id|sk-&gt;num
)paren
)braket
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|bhead-&gt;lock
)paren
suffix:semicolon
id|tw-&gt;tb
op_assign
(paren
r_struct
id|tcp_bind_bucket
op_star
)paren
id|sk-&gt;prev
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|sk-&gt;prev
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tw-&gt;bind_next
op_assign
id|tw-&gt;tb-&gt;owners
)paren
op_ne
l_int|NULL
)paren
id|tw-&gt;tb-&gt;owners-&gt;bind_pprev
op_assign
op_amp
id|tw-&gt;bind_next
suffix:semicolon
id|tw-&gt;tb-&gt;owners
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|tw
suffix:semicolon
id|tw-&gt;bind_pprev
op_assign
op_amp
id|tw-&gt;tb-&gt;owners
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|bhead-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Move a socket to time-wait or dead fin-wait-2 state.&n; */
DECL|function|tcp_time_wait
r_void
id|tcp_time_wait
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|state
comma
r_int
id|timeo
)paren
(brace
r_struct
id|tcp_tw_bucket
op_star
id|tw
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|recycle_ok
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sysctl_tcp_tw_recycle
op_logical_and
id|tp-&gt;ts_recent_stamp
)paren
id|recycle_ok
op_assign
id|tp-&gt;af_specific
op_member_access_from_pointer
id|remember_stamp
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_tw_count
OL
id|sysctl_tcp_max_tw_buckets
)paren
id|tw
op_assign
id|kmem_cache_alloc
c_func
(paren
id|tcp_timewait_cachep
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tw
op_ne
l_int|NULL
)paren
(brace
r_int
id|rto
op_assign
(paren
id|tp-&gt;rto
op_lshift
l_int|2
)paren
op_minus
(paren
id|tp-&gt;rto
op_rshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Give us an identity. */
id|tw-&gt;daddr
op_assign
id|sk-&gt;daddr
suffix:semicolon
id|tw-&gt;rcv_saddr
op_assign
id|sk-&gt;rcv_saddr
suffix:semicolon
id|tw-&gt;bound_dev_if
op_assign
id|sk-&gt;bound_dev_if
suffix:semicolon
id|tw-&gt;num
op_assign
id|sk-&gt;num
suffix:semicolon
id|tw-&gt;state
op_assign
id|TCP_TIME_WAIT
suffix:semicolon
id|tw-&gt;substate
op_assign
id|state
suffix:semicolon
id|tw-&gt;sport
op_assign
id|sk-&gt;sport
suffix:semicolon
id|tw-&gt;dport
op_assign
id|sk-&gt;dport
suffix:semicolon
id|tw-&gt;family
op_assign
id|sk-&gt;family
suffix:semicolon
id|tw-&gt;reuse
op_assign
id|sk-&gt;reuse
suffix:semicolon
id|tw-&gt;rcv_wscale
op_assign
id|tp-&gt;rcv_wscale
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|tw-&gt;refcnt
comma
l_int|0
)paren
suffix:semicolon
id|tw-&gt;hashent
op_assign
id|sk-&gt;hashent
suffix:semicolon
id|tw-&gt;rcv_nxt
op_assign
id|tp-&gt;rcv_nxt
suffix:semicolon
id|tw-&gt;snd_nxt
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
id|tw-&gt;rcv_wnd
op_assign
id|tcp_receive_window
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tw-&gt;syn_seq
op_assign
id|tp-&gt;syn_seq
suffix:semicolon
id|tw-&gt;ts_recent
op_assign
id|tp-&gt;ts_recent
suffix:semicolon
id|tw-&gt;ts_recent_stamp
op_assign
id|tp-&gt;ts_recent_stamp
suffix:semicolon
id|tw-&gt;pprev_death
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
r_if
c_cond
(paren
id|tw-&gt;family
op_eq
id|PF_INET6
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|tw-&gt;v6_daddr
comma
op_amp
id|sk-&gt;net_pinfo.af_inet6.daddr
comma
r_sizeof
(paren
r_struct
id|in6_addr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|tw-&gt;v6_rcv_saddr
comma
op_amp
id|sk-&gt;net_pinfo.af_inet6.rcv_saddr
comma
r_sizeof
(paren
r_struct
id|in6_addr
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Linkage updates. */
id|__tcp_tw_hashdance
c_func
(paren
id|sk
comma
id|tw
)paren
suffix:semicolon
multiline_comment|/* Get the TIME_WAIT timeout firing. */
r_if
c_cond
(paren
id|timeo
OL
id|rto
)paren
id|timeo
op_assign
id|rto
suffix:semicolon
r_if
c_cond
(paren
id|recycle_ok
)paren
(brace
id|tw-&gt;timeout
op_assign
id|rto
suffix:semicolon
)brace
r_else
(brace
id|tw-&gt;timeout
op_assign
id|TCP_TIMEWAIT_LEN
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|TCP_TIME_WAIT
)paren
id|timeo
op_assign
id|TCP_TIMEWAIT_LEN
suffix:semicolon
)brace
id|tcp_tw_schedule
c_func
(paren
id|tw
comma
id|timeo
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Sorry, if we&squot;re out of memory, just CLOSE this&n;&t;&t; * socket up.  We&squot;ve got bigger problems than&n;&t;&t; * non-graceful socket closings.&n;&t;&t; */
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;TCP: time wait bucket table overflow&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|tcp_update_metrics
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_done
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Process the FIN bit. This now behaves as it is supposed to work&n; *&t;and the FIN takes effect when it is validly part of sequence&n; *&t;space. Not before when we get holes.&n; *&n; *&t;If we are ESTABLISHED, a received fin moves us to CLOSE-WAIT&n; *&t;(and thence onto LAST-ACK and finally, CLOSE, we never enter&n; *&t;TIME-WAIT)&n; *&n; *&t;If we are in FINWAIT-1, a received FIN indicates simultaneous&n; *&t;close and we go into CLOSING (and later onto TIME-WAIT)&n; *&n; *&t;If we are in FINWAIT-2, a received FIN moves us to TIME-WAIT.&n; */
DECL|function|tcp_fin
r_static
r_void
id|tcp_fin
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|tp-&gt;fin_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_or_assign
id|RCV_SHUTDOWN
suffix:semicolon
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_SYN_RECV
suffix:colon
r_case
id|TCP_ESTABLISHED
suffix:colon
multiline_comment|/* Move to CLOSE_WAIT */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE_WAIT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE_WAIT
suffix:colon
r_case
id|TCP_CLOSING
suffix:colon
multiline_comment|/* Received a retransmission of the FIN, do&n;&t;&t;&t; * nothing.&n;&t;&t;&t; */
r_break
suffix:semicolon
r_case
id|TCP_LAST_ACK
suffix:colon
multiline_comment|/* RFC793: Remain in the LAST-ACK state. */
r_break
suffix:semicolon
r_case
id|TCP_FIN_WAIT1
suffix:colon
multiline_comment|/* This case occurs when a simultaneous close&n;&t;&t;&t; * happens, we must ack the received FIN and&n;&t;&t;&t; * enter the CLOSING state.&n;&t;&t;&t; */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSING
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_FIN_WAIT2
suffix:colon
multiline_comment|/* Received a FIN -- send ACK and enter TIME_WAIT. */
id|tcp_time_wait
c_func
(paren
id|sk
comma
id|TCP_TIME_WAIT
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Only TCP_LISTEN and TCP_CLOSE are left, in these&n;&t;&t;&t; * cases we should never reach this piece of code.&n;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;tcp_fin: Impossible, sk-&gt;state=%d&bslash;n&quot;
comma
id|sk-&gt;state
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* It _is_ possible, that we have something out-of-order _after_ FIN.&n;&t; * Probably, we should reset in this case. For now drop them.&n;&t; */
id|__skb_queue_purge
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;sack_ok
)paren
id|tp-&gt;num_sacks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sock_wake_async
c_func
(paren
id|sk-&gt;socket
comma
l_int|1
comma
id|POLL_HUP
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* These routines update the SACK block as out-of-order packets arrive or&n; * in-order packets close up the sequence space.&n; */
DECL|function|tcp_sack_maybe_coalesce
r_static
r_void
id|tcp_sack_maybe_coalesce
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_struct
id|tcp_sack_block
op_star
id|sp
)paren
(brace
r_int
id|this_sack
comma
id|num_sacks
op_assign
id|tp-&gt;num_sacks
suffix:semicolon
r_struct
id|tcp_sack_block
op_star
id|swalk
op_assign
op_amp
id|tp-&gt;selective_acks
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* If more than one SACK block, see if the recent change to SP eats into&n;&t; * or hits the sequence space of other SACK blocks, if so coalesce.&n;&t; */
r_if
c_cond
(paren
id|num_sacks
op_ne
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|this_sack
op_assign
l_int|0
suffix:semicolon
id|this_sack
OL
id|num_sacks
suffix:semicolon
id|this_sack
op_increment
comma
id|swalk
op_increment
)paren
(brace
r_if
c_cond
(paren
id|swalk
op_eq
id|sp
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* First case, bottom of SP moves into top of the&n;&t;&t;&t; * sequence space of SWALK.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|between
c_func
(paren
id|sp-&gt;start_seq
comma
id|swalk-&gt;start_seq
comma
id|swalk-&gt;end_seq
)paren
)paren
(brace
id|sp-&gt;start_seq
op_assign
id|swalk-&gt;start_seq
suffix:semicolon
r_goto
id|coalesce
suffix:semicolon
)brace
multiline_comment|/* Second case, top of SP moves into bottom of the&n;&t;&t;&t; * sequence space of SWALK.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|between
c_func
(paren
id|sp-&gt;end_seq
comma
id|swalk-&gt;start_seq
comma
id|swalk-&gt;end_seq
)paren
)paren
(brace
id|sp-&gt;end_seq
op_assign
id|swalk-&gt;end_seq
suffix:semicolon
r_goto
id|coalesce
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* SP is the only SACK, or no coalescing cases found. */
r_return
suffix:semicolon
id|coalesce
suffix:colon
multiline_comment|/* Zap SWALK, by moving every further SACK up by one slot.&n;&t; * Decrease num_sacks.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|this_sack
OL
id|num_sacks
op_minus
l_int|1
suffix:semicolon
id|this_sack
op_increment
comma
id|swalk
op_increment
)paren
(brace
r_struct
id|tcp_sack_block
op_star
id|next
op_assign
(paren
id|swalk
op_plus
l_int|1
)paren
suffix:semicolon
id|swalk-&gt;start_seq
op_assign
id|next-&gt;start_seq
suffix:semicolon
id|swalk-&gt;end_seq
op_assign
id|next-&gt;end_seq
suffix:semicolon
)brace
id|tp-&gt;num_sacks
op_decrement
suffix:semicolon
)brace
DECL|function|tcp_sack_swap
r_static
id|__inline__
r_void
id|tcp_sack_swap
c_func
(paren
r_struct
id|tcp_sack_block
op_star
id|sack1
comma
r_struct
id|tcp_sack_block
op_star
id|sack2
)paren
(brace
id|__u32
id|tmp
suffix:semicolon
id|tmp
op_assign
id|sack1-&gt;start_seq
suffix:semicolon
id|sack1-&gt;start_seq
op_assign
id|sack2-&gt;start_seq
suffix:semicolon
id|sack2-&gt;start_seq
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
id|sack1-&gt;end_seq
suffix:semicolon
id|sack1-&gt;end_seq
op_assign
id|sack2-&gt;end_seq
suffix:semicolon
id|sack2-&gt;end_seq
op_assign
id|tmp
suffix:semicolon
)brace
DECL|function|tcp_sack_new_ofo_skb
r_static
r_void
id|tcp_sack_new_ofo_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|tcp_sack_block
op_star
id|sp
op_assign
op_amp
id|tp-&gt;selective_acks
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|cur_sacks
op_assign
id|tp-&gt;num_sacks
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cur_sacks
)paren
r_goto
id|new_sack
suffix:semicolon
multiline_comment|/* Optimize for the common case, new ofo frames arrive&n;&t; * &quot;in order&quot;. ;-)  This also satisfies the requirements&n;&t; * of RFC2018 about ordering of SACKs.&n;&t; */
r_if
c_cond
(paren
id|sp-&gt;end_seq
op_eq
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
(brace
id|sp-&gt;end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
id|tcp_sack_maybe_coalesce
c_func
(paren
id|tp
comma
id|sp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sp-&gt;start_seq
op_eq
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
(brace
multiline_comment|/* Re-ordered arrival, in this case, can be optimized&n;&t;&t; * as well.&n;&t;&t; */
id|sp-&gt;start_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|tcp_sack_maybe_coalesce
c_func
(paren
id|tp
comma
id|sp
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|tcp_sack_block
op_star
id|swap
op_assign
id|sp
op_plus
l_int|1
suffix:semicolon
r_int
id|this_sack
comma
id|max_sacks
op_assign
(paren
id|tp-&gt;tstamp_ok
ques
c_cond
l_int|3
suffix:colon
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Oh well, we have to move things around.&n;&t;&t; * Try to find a SACK we can tack this onto.&n;&t;&t; */
r_for
c_loop
(paren
id|this_sack
op_assign
l_int|1
suffix:semicolon
id|this_sack
OL
id|cur_sacks
suffix:semicolon
id|this_sack
op_increment
comma
id|swap
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|swap-&gt;end_seq
op_eq
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
op_logical_or
(paren
id|swap-&gt;start_seq
op_eq
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
)paren
(brace
r_if
c_cond
(paren
id|swap-&gt;end_seq
op_eq
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
(brace
id|swap-&gt;end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
)brace
r_else
id|swap-&gt;start_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|tcp_sack_swap
c_func
(paren
id|sp
comma
id|swap
)paren
suffix:semicolon
id|tcp_sack_maybe_coalesce
c_func
(paren
id|tp
comma
id|sp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Could not find an adjacent existing SACK, build a new one,&n;&t;&t; * put it at the front, and shift everyone else down.  We&n;&t;&t; * always know there is at least one SACK present already here.&n;&t;&t; *&n;&t;&t; * If the sack array is full, forget about the last one.&n;&t;&t; */
r_if
c_cond
(paren
id|cur_sacks
op_ge
id|max_sacks
)paren
(brace
id|cur_sacks
op_decrement
suffix:semicolon
id|tp-&gt;num_sacks
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cur_sacks
op_ge
l_int|1
)paren
(brace
r_struct
id|tcp_sack_block
op_star
id|this
op_assign
op_amp
id|tp-&gt;selective_acks
(braket
id|cur_sacks
)braket
suffix:semicolon
r_struct
id|tcp_sack_block
op_star
id|prev
op_assign
(paren
id|this
op_minus
l_int|1
)paren
suffix:semicolon
id|this-&gt;start_seq
op_assign
id|prev-&gt;start_seq
suffix:semicolon
id|this-&gt;end_seq
op_assign
id|prev-&gt;end_seq
suffix:semicolon
id|cur_sacks
op_decrement
suffix:semicolon
)brace
id|new_sack
suffix:colon
multiline_comment|/* Build the new head SACK, and we&squot;re done. */
id|sp-&gt;start_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|sp-&gt;end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
id|tp-&gt;num_sacks
op_increment
suffix:semicolon
)brace
)brace
DECL|function|tcp_sack_remove_skb
r_static
r_void
id|tcp_sack_remove_skb
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcp_sack_block
op_star
id|sp
op_assign
op_amp
id|tp-&gt;selective_acks
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|num_sacks
op_assign
id|tp-&gt;num_sacks
suffix:semicolon
r_int
id|this_sack
suffix:semicolon
multiline_comment|/* This is an in order data segment _or_ an out-of-order SKB being&n;&t; * moved to the receive queue, so we know this removed SKB will eat&n;&t; * from the front of a SACK.&n;&t; */
r_for
c_loop
(paren
id|this_sack
op_assign
l_int|0
suffix:semicolon
id|this_sack
OL
id|num_sacks
suffix:semicolon
id|this_sack
op_increment
comma
id|sp
op_increment
)paren
(brace
multiline_comment|/* Check if the start of the sack is covered by skb. */
r_if
c_cond
(paren
op_logical_neg
id|before
c_func
(paren
id|sp-&gt;start_seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
op_logical_and
id|before
c_func
(paren
id|sp-&gt;start_seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* This should only happen if so many SACKs get built that some get&n;&t; * pushed out before we get here, or we eat some in sequence packets&n;&t; * which are before the first SACK block.&n;&t; */
r_if
c_cond
(paren
id|this_sack
op_ge
id|num_sacks
)paren
(brace
r_return
suffix:semicolon
)brace
id|sp-&gt;start_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|before
c_func
(paren
id|sp-&gt;start_seq
comma
id|sp-&gt;end_seq
)paren
)paren
(brace
multiline_comment|/* Zap this SACK, by moving forward any other SACKS. */
r_for
c_loop
(paren
id|this_sack
op_add_assign
l_int|1
suffix:semicolon
id|this_sack
OL
id|num_sacks
suffix:semicolon
id|this_sack
op_increment
comma
id|sp
op_increment
)paren
(brace
r_struct
id|tcp_sack_block
op_star
id|next
op_assign
(paren
id|sp
op_plus
l_int|1
)paren
suffix:semicolon
id|sp-&gt;start_seq
op_assign
id|next-&gt;start_seq
suffix:semicolon
id|sp-&gt;end_seq
op_assign
id|next-&gt;end_seq
suffix:semicolon
)brace
id|tp-&gt;num_sacks
op_decrement
suffix:semicolon
)brace
)brace
DECL|function|tcp_sack_extend
r_static
r_void
id|tcp_sack_extend
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_struct
id|sk_buff
op_star
id|old_skb
comma
r_struct
id|sk_buff
op_star
id|new_skb
)paren
(brace
r_struct
id|tcp_sack_block
op_star
id|sp
op_assign
op_amp
id|tp-&gt;selective_acks
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|num_sacks
op_assign
id|tp-&gt;num_sacks
suffix:semicolon
r_int
id|this_sack
suffix:semicolon
r_for
c_loop
(paren
id|this_sack
op_assign
l_int|0
suffix:semicolon
id|this_sack
OL
id|num_sacks
suffix:semicolon
id|this_sack
op_increment
comma
id|sp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sp-&gt;end_seq
op_eq
id|TCP_SKB_CB
c_func
(paren
id|old_skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|this_sack
op_ge
id|num_sacks
)paren
(brace
r_return
suffix:semicolon
)brace
id|sp-&gt;end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|new_skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
)brace
multiline_comment|/* This one checks to see if we can put data from the&n; * out_of_order queue into the receive_queue.&n; */
DECL|function|tcp_ofo_queue
r_static
r_void
id|tcp_ofo_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;ofo packet was already received &bslash;n&quot;
)paren
suffix:semicolon
id|__skb_unlink
c_func
(paren
id|skb
comma
id|skb-&gt;list
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;ofo requeuing : rcv_next %X seq %X - %X&bslash;n&quot;
comma
id|tp-&gt;rcv_nxt
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;sack_ok
)paren
(brace
id|tcp_sack_remove_skb
c_func
(paren
id|tp
comma
id|skb
)paren
suffix:semicolon
)brace
id|__skb_unlink
c_func
(paren
id|skb
comma
id|skb-&gt;list
)paren
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
id|tp-&gt;rcv_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;fin
)paren
(brace
id|tcp_fin
c_func
(paren
id|skb
comma
id|sk
comma
id|skb-&gt;h.th
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|tcp_data_queue
r_static
r_void
id|tcp_data_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb1
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|eaten
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*  Queue data for delivery to the user.&n;&t; *  Packets in sequence go to the receive queue.&n;&t; *  Out of sequence packets to the out_of_order_queue.&n;&t; */
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_eq
id|tp-&gt;rcv_nxt
)paren
(brace
multiline_comment|/* Ok. In sequence. */
r_if
c_cond
(paren
id|tp-&gt;ucopy.task
op_eq
id|current
op_logical_and
id|tp-&gt;copied_seq
op_eq
id|tp-&gt;rcv_nxt
op_logical_and
id|tp-&gt;ucopy.len
op_logical_and
id|sk-&gt;lock.users
op_logical_and
op_logical_neg
id|tp-&gt;urg_data
)paren
(brace
r_int
id|chunk
op_assign
id|min
c_func
(paren
id|skb-&gt;len
comma
id|tp-&gt;ucopy.len
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcpy_toiovec
c_func
(paren
id|tp-&gt;ucopy.iov
comma
id|skb-&gt;data
comma
id|chunk
)paren
)paren
(brace
id|sk-&gt;err
op_assign
id|EFAULT
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
id|tp-&gt;ucopy.len
op_sub_assign
id|chunk
suffix:semicolon
id|tp-&gt;copied_seq
op_add_assign
id|chunk
suffix:semicolon
id|eaten
op_assign
(paren
id|chunk
op_eq
id|skb-&gt;len
op_logical_and
op_logical_neg
id|skb-&gt;h.th-&gt;fin
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|eaten
)paren
(brace
id|queue_and_out
suffix:colon
id|skb_set_owner_r
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
)brace
id|dst_confirm
c_func
(paren
id|sk-&gt;dst_cache
)paren
suffix:semicolon
id|tp-&gt;rcv_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
)paren
(brace
id|tcp_event_data_recv
c_func
(paren
id|tp
comma
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;fin
)paren
(brace
id|tcp_fin
c_func
(paren
id|skb
comma
id|sk
comma
id|skb-&gt;h.th
)paren
suffix:semicolon
)brace
multiline_comment|/* This may have eaten into a SACK block. */
r_if
c_cond
(paren
id|tp-&gt;sack_ok
op_logical_and
id|tp-&gt;num_sacks
)paren
(brace
id|tcp_sack_remove_skb
c_func
(paren
id|tp
comma
id|skb
)paren
suffix:semicolon
)brace
id|tcp_ofo_queue
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Turn on fast path. */
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
op_eq
l_int|0
op_logical_and
macro_line|#ifdef TCP_FORMAL_WINDOW
id|tcp_receive_window
c_func
(paren
id|tp
)paren
op_logical_and
macro_line|#endif
op_logical_neg
id|tp-&gt;urg_data
)paren
id|tcp_fast_path_on
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eaten
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|wake_up_interruptible
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
id|sock_wake_async
c_func
(paren
id|sk-&gt;socket
comma
l_int|1
comma
id|POLL_IN
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* An old packet, either a retransmit or some packet got lost. */
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
multiline_comment|/* A retransmit, 2nd most common case.  Force an imediate ack.&n;&t;&t; * &n;&t;&t; * It is impossible, seq is checked by top level.&n;&t;&t; */
id|NETDEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;retransmit in tcp_data_queue: seq %X&bslash;n&quot;
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
)paren
suffix:semicolon
id|tcp_enter_quickack_mode
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;ack.pending
op_assign
l_int|1
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
multiline_comment|/* Partial packet, seq &lt; rcv_next &lt; end_seq */
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;partial packet: rcv_next %X seq %X - %X&bslash;n&quot;
comma
id|tp-&gt;rcv_nxt
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
suffix:semicolon
r_goto
id|queue_and_out
suffix:semicolon
)brace
multiline_comment|/* Ok. This is an out_of_order segment, force an ack. */
id|tp-&gt;ack.pending
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Disable header prediction. */
id|tp-&gt;pred_flags
op_assign
l_int|0
suffix:semicolon
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;out of order segment: rcv_next %X seq %X - %X&bslash;n&quot;
comma
id|tp-&gt;rcv_nxt
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
suffix:semicolon
id|skb_set_owner_r
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Initial out of order segment, build 1 SACK. */
r_if
c_cond
(paren
id|tp-&gt;sack_ok
)paren
(brace
id|tp-&gt;num_sacks
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;selective_acks
(braket
l_int|0
)braket
dot
id|start_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|tp-&gt;selective_acks
(braket
l_int|0
)braket
dot
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
)brace
id|__skb_queue_head
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|skb1
op_assign
id|tp-&gt;out_of_order_queue.prev
suffix:semicolon
suffix:semicolon
id|skb1
op_assign
id|skb1-&gt;prev
)paren
(brace
multiline_comment|/* Already there. */
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_eq
id|TCP_SKB_CB
c_func
(paren
id|skb1
)paren
op_member_access_from_pointer
id|seq
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;len
op_ge
id|skb1-&gt;len
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;sack_ok
)paren
(brace
id|tcp_sack_extend
c_func
(paren
id|tp
comma
id|skb1
comma
id|skb
)paren
suffix:semicolon
)brace
id|__skb_append
c_func
(paren
id|skb1
comma
id|skb
)paren
suffix:semicolon
id|__skb_unlink
c_func
(paren
id|skb1
comma
id|skb1-&gt;list
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* A duplicate, smaller than what is in the&n;&t;&t;&t;&t;&t; * out-of-order queue right now, toss it.&n;&t;&t;&t;&t;&t; */
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb1
)paren
op_member_access_from_pointer
id|seq
)paren
)paren
(brace
id|__skb_append
c_func
(paren
id|skb1
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;sack_ok
)paren
(brace
id|tcp_sack_new_ofo_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* See if we&squot;ve hit the start. If so insert. */
r_if
c_cond
(paren
id|skb1
op_eq
id|skb_peek
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
)paren
(brace
id|__skb_queue_head
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;sack_ok
)paren
(brace
id|tcp_sack_new_ofo_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine handles the data.  If there is room in the buffer,&n; *&t;it will be have already been moved into it.  If there is no&n; *&t;room, then we will just have to discard the packet.&n; */
DECL|function|tcp_data
r_static
r_void
id|tcp_data
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|th-&gt;doff
op_star
l_int|4
)paren
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
id|len
op_minus
(paren
id|th-&gt;doff
op_star
l_int|4
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
op_eq
l_int|0
op_logical_and
op_logical_neg
id|th-&gt;fin
)paren
r_goto
id|drop
suffix:semicolon
multiline_comment|/* &n;&t; *&t;If our receive queue has grown past its limits shrink it.&n;&t; *&t;Make sure to do this before moving rcv_nxt, otherwise&n;&t; *&t;data might be acked for that we don&squot;t have enough room.&n;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
OG
id|sk-&gt;rcvbuf
)paren
(brace
r_if
c_cond
(paren
id|prune_queue
c_func
(paren
id|sk
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* Still not enough room. That can happen when&n;&t;&t;&t; * skb-&gt;true_size differs significantly from skb-&gt;len.&n;&t;&t;&t; */
r_goto
id|drop
suffix:semicolon
)brace
)brace
id|tcp_data_queue
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|before
c_func
(paren
id|tp-&gt;rcv_nxt
comma
id|tp-&gt;copied_seq
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;*** tcp.c:tcp_data bug acked &lt; copied&bslash;n&quot;
)paren
suffix:semicolon
id|tp-&gt;rcv_nxt
op_assign
id|tp-&gt;copied_seq
suffix:semicolon
)brace
r_return
suffix:semicolon
id|drop
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
DECL|function|__tcp_data_snd_check
r_static
r_void
id|__tcp_data_snd_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tp-&gt;snd_una
op_plus
id|tp-&gt;snd_wnd
)paren
op_logical_or
id|tcp_packets_in_flight
c_func
(paren
id|tp
)paren
op_ge
id|tp-&gt;snd_cwnd
op_logical_or
id|tcp_write_xmit
c_func
(paren
id|sk
)paren
)paren
id|tcp_check_probe_timer
c_func
(paren
id|sk
comma
id|tp
)paren
suffix:semicolon
)brace
DECL|function|tcp_data_snd_check
r_static
id|__inline__
r_void
id|tcp_data_snd_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|sk-&gt;tp_pinfo.af_tcp.send_head
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
id|__tcp_data_snd_check
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check if sending an ack is needed.&n; */
DECL|function|__tcp_ack_snd_check
r_static
id|__inline__
r_void
id|__tcp_ack_snd_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|ofo_possible
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/* This also takes care of updating the window.&n;&t; * This if statement needs to be simplified.&n;&t; *&n;&t; * Rules for delaying an ack:&n;&t; *      - delay time &lt;= 0.5 HZ&n;&t; *      - we don&squot;t have a window update to send&n;&t; *      - must send at least every 2 full sized packets&n;&t; *&t;- must send an ACK if we have any out of order data&n;&t; *&n;&t; * With an extra heuristic to handle loss of packet&n;&t; * situations and also helping the sender leave slow&n;&t; * start in an expediant manner.&n;&t; */
multiline_comment|/* More than one full frame received or... */
r_if
c_cond
(paren
(paren
(paren
id|tp-&gt;rcv_nxt
op_minus
id|tp-&gt;rcv_wup
)paren
OG
id|tp-&gt;ack.rcv_mss
)paren
op_logical_or
multiline_comment|/* We ACK each frame or... */
id|tcp_in_quickack_mode
c_func
(paren
id|tp
)paren
op_logical_or
multiline_comment|/* We have out of order data or */
(paren
id|ofo_possible
op_logical_and
id|skb_peek
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* Then ack it now */
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Else, send delayed ack. */
id|tcp_send_delayed_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
DECL|function|tcp_ack_snd_check
r_static
id|__inline__
r_void
id|tcp_ack_snd_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ack.pending
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We sent a data segment already. */
r_return
suffix:semicolon
)brace
id|__tcp_ack_snd_check
c_func
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine is only called when we have urgent data&n; *&t;signalled. Its the &squot;slow&squot; part of tcp_urg. It could be&n; *&t;moved inline now as tcp_urg is only called from one&n; *&t;place. We handle URGent data wrong. We have to - as&n; *&t;BSD still doesn&squot;t use the correction from RFC961.&n; *&t;For 1003.1g we should support a new option TCP_STDURG to permit&n; *&t;either form (or just set the sysctl tcp_stdurg).&n; */
DECL|function|tcp_check_urg
r_static
r_void
id|tcp_check_urg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|u32
id|ptr
op_assign
id|ntohs
c_func
(paren
id|th-&gt;urg_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_logical_and
op_logical_neg
id|sysctl_tcp_stdurg
)paren
id|ptr
op_decrement
suffix:semicolon
id|ptr
op_add_assign
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
suffix:semicolon
multiline_comment|/* Ignore urgent data that we&squot;ve already seen and read. */
r_if
c_cond
(paren
id|after
c_func
(paren
id|tp-&gt;copied_seq
comma
id|ptr
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Do we already have a newer (or duplicate) urgent pointer? */
r_if
c_cond
(paren
id|tp-&gt;urg_data
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|ptr
comma
id|tp-&gt;urg_seq
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Tell the world about our new urgent pointer. */
r_if
c_cond
(paren
id|sk-&gt;proc
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;proc
OG
l_int|0
)paren
id|kill_proc
c_func
(paren
id|sk-&gt;proc
comma
id|SIGURG
comma
l_int|1
)paren
suffix:semicolon
r_else
id|kill_pg
c_func
(paren
op_minus
id|sk-&gt;proc
comma
id|SIGURG
comma
l_int|1
)paren
suffix:semicolon
id|sock_wake_async
c_func
(paren
id|sk-&gt;socket
comma
l_int|3
comma
id|POLL_PRI
)paren
suffix:semicolon
)brace
multiline_comment|/* We may be adding urgent data when the last byte read was&n;&t; * urgent. To do this requires some care. We cannot just ignore&n;&t; * tp-&gt;copied_seq since we would read the last urgent byte again&n;&t; * as data, nor can we alter copied_seq until this data arrives&n;&t; * or we break the sematics of SIOCATMARK (and thus sockatmark())&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;urg_seq
op_eq
id|tp-&gt;copied_seq
)paren
id|tp-&gt;copied_seq
op_increment
suffix:semicolon
multiline_comment|/* Move the copied sequence on correctly */
id|tp-&gt;urg_data
op_assign
id|TCP_URG_NOTYET
suffix:semicolon
id|tp-&gt;urg_seq
op_assign
id|ptr
suffix:semicolon
multiline_comment|/* Disable header prediction. */
id|tp-&gt;pred_flags
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is the &squot;fast&squot; part of urgent handling. */
DECL|function|tcp_urg
r_static
r_inline
r_void
id|tcp_urg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/* Check if we get a new urgent pointer - normally not. */
r_if
c_cond
(paren
id|th-&gt;urg
)paren
id|tcp_check_urg
c_func
(paren
id|sk
comma
id|th
)paren
suffix:semicolon
multiline_comment|/* Do we wait for any urgent data? - normally not... */
r_if
c_cond
(paren
id|tp-&gt;urg_data
op_eq
id|TCP_URG_NOTYET
)paren
(brace
id|u32
id|ptr
op_assign
id|tp-&gt;urg_seq
op_minus
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
op_plus
(paren
id|th-&gt;doff
op_star
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Is the urgent pointer pointing into this packet? */
r_if
c_cond
(paren
id|ptr
OL
id|len
)paren
(brace
id|tp-&gt;urg_data
op_assign
id|TCP_URG_VALID
op_or
op_star
(paren
id|ptr
op_plus
(paren
r_int
r_char
op_star
)paren
id|th
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Clean the out_of_order queue if we can, trying to get&n; * the socket within its memory limits again.&n; *&n; * Return less than zero if we should start dropping frames&n; * until the socket owning process reads some of the data&n; * to stabilize the situation.&n; */
DECL|function|prune_queue
r_static
r_int
id|prune_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|pruned
op_assign
l_int|0
suffix:semicolon
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;prune_queue: c=%x&bslash;n&quot;
comma
id|tp-&gt;copied_seq
)paren
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|PruneCalled
)paren
suffix:semicolon
multiline_comment|/* First, purge the out_of_order queue. */
id|skb
op_assign
id|__skb_dequeue_tail
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Free it all. */
r_do
(brace
id|pruned
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|net_statistics
(braket
id|smp_processor_id
c_func
(paren
)paren
op_star
l_int|2
)braket
dot
id|OfoPruned
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb
op_assign
id|__skb_dequeue_tail
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Reset SACK state.  A conforming SACK implementation will&n;&t;&t; * do the same at a timeout based retransmit.  When a connection&n;&t;&t; * is in a sad state like this, we care only about integrity&n;&t;&t; * of the connection not performance.&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;sack_ok
)paren
(brace
id|tp-&gt;num_sacks
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* If we are really being abused, tell the caller to silently&n;&t; * drop receive data on the floor.  It will get retransmitted&n;&t; * and hopefully then we&squot;ll have sufficient space.&n;&t; *&n;&t; * We used to try to purge the in-order packets too, but that&n;&t; * turns out to be deadly and fraught with races.  Consider:&n;&t; *&n;&t; * 1) If we acked the data, we absolutely cannot drop the&n;&t; *    packet.  This data would then never be retransmitted.&n;&t; * 2) It is possible, with a proper sequence of events involving&n;&t; *    delayed acks and backlog queue handling, to have the user&n;&t; *    read the data before it gets acked.  The previous code&n;&t; *    here got this wrong, and it lead to data corruption.&n;&t; * 3) Too much state changes happen when the FIN arrives, so once&n;&t; *    we&squot;ve seen that we can&squot;t remove any in-order data safely.&n;&t; *&n;&t; * The net result is that removing in-order receive data is too&n;&t; * complex for anyones sanity.  So we don&squot;t do it anymore.  But&n;&t; * if we are really having our buffer space abused we stop accepting&n;&t; * new receive data.&n;&t; *&n;&t; * 8) The arguments are interesting, but I even cannot imagine&n;&t; * what kind of arguments could force us to drop NICE, ALREADY&n;&t; * RECEIVED DATA only to get one more packet? --ANK&n;&t; *&n;&t; * FIXME: it should recompute SACK state and only remove enough&n;&t; *        buffers to get into bounds again. The current scheme loses&n;&t; *        badly sometimes on links with large RTT, especially when &n;&t; *        the driver has high overhead per skb.&n;&t; *        (increasing the rcvbuf is not enough because it inflates the&n;&t; *         the window too, disabling flow control effectively) -AK&n;&t; *&n;&t; *&t;  Mmm... Why not to scale it seprately then? Just replace&n;&t; *&t;  / WINDOW_ADVERTISE_DIVISOR with &gt;&gt; sk-&gt;window_advertise_scale&n;&t; *&t;  and adjust it dynamically, when TCP window flow control&n;&t; *&t;  fails?&t;&t;&t;&t;&t;&t;-ANK&n;&t; */
id|tp-&gt;ack.quick
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
OL
(paren
id|sk-&gt;rcvbuf
op_lshift
l_int|1
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|NET_INC_STATS_BH
c_func
(paren
id|RcvPruned
)paren
suffix:semicolon
multiline_comment|/* Massive buffer overcommit. */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|tcp_copy_to_iovec
r_static
r_int
id|tcp_copy_to_iovec
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|hlen
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|chunk
op_assign
id|skb-&gt;len
op_minus
id|hlen
suffix:semicolon
r_int
id|err
suffix:semicolon
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;ip_summed
op_eq
id|CHECKSUM_UNNECESSARY
)paren
id|err
op_assign
id|memcpy_toiovec
c_func
(paren
id|tp-&gt;ucopy.iov
comma
id|skb-&gt;h.raw
op_plus
id|hlen
comma
id|chunk
)paren
suffix:semicolon
r_else
id|err
op_assign
id|copy_and_csum_toiovec
c_func
(paren
id|tp-&gt;ucopy.iov
comma
id|skb
comma
id|hlen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|update
suffix:colon
id|tp-&gt;ucopy.len
op_sub_assign
id|chunk
suffix:semicolon
id|tp-&gt;copied_seq
op_add_assign
id|chunk
suffix:semicolon
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EFAULT
)paren
(brace
id|sk-&gt;err
op_assign
id|EFAULT
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|update
suffix:semicolon
)brace
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|__tcp_checksum_complete_user
r_static
r_int
id|__tcp_checksum_complete_user
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;lock.users
)paren
(brace
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
id|result
op_assign
id|__tcp_checksum_complete
c_func
(paren
id|skb
)paren
suffix:semicolon
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
id|__tcp_checksum_complete
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
r_static
id|__inline__
r_int
DECL|function|tcp_checksum_complete_user
id|tcp_checksum_complete_user
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
id|skb-&gt;ip_summed
op_ne
id|CHECKSUM_UNNECESSARY
op_logical_and
id|__tcp_checksum_complete_user
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;TCP receive function for the ESTABLISHED state. &n; *&n; *&t;It is split into a fast path and a slow path. The fast path is &n; * &t;disabled when:&n; *&t;- A zero window was announced from us - zero window probing&n; *        is only handled properly in the slow path. &n; *&t;  [ NOTE: actually, it was made incorrectly and nobody ever noticed&n; *&t;    this! Reason is clear: 1. Correct senders do not send&n; *&t;    to zero window. 2. Even if a sender sends to zero window,&n; *&t;    nothing terrible occurs.&n; *&n; *&t;    For now I cleaned this and fast path is really always disabled,&n; *&t;    when window is zero, but I would be more happy to remove these&n; *&t;    checks. Code will be only cleaner and _faster_.    --ANK&n; *&t;&n; *&t;    Later note. I&squot;ve just found that slow path also accepts&n; *&t;    out of window segments, look at tcp_sequence(). So...&n; *&t;    it is the last argument: I repair all and comment out&n; *&t;    repaired code by TCP_FORMAL_WINDOW.&n; *&t;    [ I remember one rhyme from a chidren&squot;s book. (I apologize,&n; *&t;      the trasnlation is not rhymed 8)): people in one (jewish) village&n; *&t;      decided to build sauna, but divided to two parties.&n; *&t;      The first one insisted that battens should not be dubbed,&n; *&t;      another objected that foots will suffer of splinters,&n; *&t;      the first fended that dubbed wet battens are too slippy&n; *&t;      and people will fall and it is much more serious!&n; *&t;      Certaiinly, all they went to rabbi.&n; *&t;      After some thinking, he judged: &quot;Do not be lazy!&n; *&t;      Certainly, dub the battens! But put them by dubbed surface down.&quot;&n; *          ]&n; *        ]&n; *&n; *&t;- Out of order segments arrived.&n; *&t;- Urgent data is expected.&n; *&t;- There is no buffer space left&n; *&t;- Unexpected TCP flags/window values/header lengths are received&n; *&t;  (detected by checking the TCP header against pred_flags) &n; *&t;- Data is sent in both directions. Fast path only supports pure senders&n; *&t;  or pure receivers (this means either the sequence number or the ack&n; *&t;  value must stay constant)&n; *&t;- Unexpected TCP option.&n; *&n; *&t;When these conditions are not satisfied it drops into a standard &n; *&t;receive procedure patterned after RFC793 to handle all cases.&n; *&t;The first three cases are guaranteed by proper pred_flags setting,&n; *&t;the rest is checked inline. Fast processing is turned on in &n; *&t;tcp_data_queue when everything is OK.&n; */
DECL|function|tcp_rcv_established
r_int
id|tcp_rcv_established
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Header prediction.&n;&t; *&t;The code losely follows the one in the famous &n;&t; *&t;&quot;30 instruction TCP receive&quot; Van Jacobson mail.&n;&t; *&t;&n;&t; *&t;Van&squot;s trick is to deposit buffers into socket queue &n;&t; *&t;on a device interrupt, to call tcp_recv function&n;&t; *&t;on the receive process context and checksum and copy&n;&t; *&t;the buffer to user space. smart...&n;&t; *&n;&t; *&t;Our current scheme is not silly either but we take the &n;&t; *&t;extra cost of the net_bh soft interrupt processing...&n;&t; *&t;We do checksum and copy also but from device to kernel.&n;&t; */
multiline_comment|/* RED-PEN. Using static variables to pass function arguments&n;&t; * cannot be good idea...&n;&t; */
id|tp-&gt;saw_tstamp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&t;pred_flags is 0xS?10 &lt;&lt; 16 + snd_wnd&n;&t; *&t;if header_predition is to be made&n;&t; *&t;&squot;S&squot; will always be tp-&gt;tcp_header_len &gt;&gt; 2&n;&t; *&t;&squot;?&squot; will be 0 for the fast path, otherwise pred_flags is 0 to&n;&t; *  turn it off&t;(when there are holes in the receive &n;&t; *&t; space for instance)&n;&t; *&t;PSH flag is ignored.&n;&t; */
r_if
c_cond
(paren
(paren
id|tcp_flag_word
c_func
(paren
id|th
)paren
op_amp
op_complement
(paren
id|TCP_RESERVED_BITS
op_or
id|TCP_FLAG_PSH
)paren
)paren
op_eq
id|tp-&gt;pred_flags
op_logical_and
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_eq
id|tp-&gt;rcv_nxt
)paren
(brace
r_int
id|tcp_header_len
op_assign
id|tp-&gt;tcp_header_len
suffix:semicolon
multiline_comment|/* Timestamp header prediction: tcp_header_len&n;&t;&t; * is automatically equal to th-&gt;doff*4 due to pred_flags&n;&t;&t; * match.&n;&t;&t; */
multiline_comment|/* Check timestamp */
r_if
c_cond
(paren
id|tcp_header_len
op_eq
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
id|TCPOLEN_TSTAMP_ALIGNED
)paren
(brace
id|__u32
op_star
id|ptr
op_assign
(paren
id|__u32
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* No? Slow path! */
r_if
c_cond
(paren
op_star
id|ptr
op_ne
id|__constant_ntohl
c_func
(paren
(paren
id|TCPOPT_NOP
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOPT_NOP
op_lshift
l_int|16
)paren
op_or
(paren
id|TCPOPT_TIMESTAMP
op_lshift
l_int|8
)paren
op_or
id|TCPOLEN_TIMESTAMP
)paren
)paren
r_goto
id|slow_path
suffix:semicolon
id|tp-&gt;saw_tstamp
op_assign
l_int|1
suffix:semicolon
op_increment
id|ptr
suffix:semicolon
id|tp-&gt;rcv_tsval
op_assign
id|ntohl
c_func
(paren
op_star
id|ptr
)paren
suffix:semicolon
op_increment
id|ptr
suffix:semicolon
id|tp-&gt;rcv_tsecr
op_assign
id|ntohl
c_func
(paren
op_star
id|ptr
)paren
suffix:semicolon
multiline_comment|/* If PAWS failed, check it more carefully in slow path */
r_if
c_cond
(paren
(paren
id|s32
)paren
(paren
id|tp-&gt;rcv_tsval
op_minus
id|tp-&gt;ts_recent
)paren
OL
l_int|0
)paren
r_goto
id|slow_path
suffix:semicolon
multiline_comment|/* Predicted packet is in window by definition.&n;&t;&t;&t; * seq == rcv_nxt and rcv_wup &lt;= rcv_nxt.&n;&t;&t;&t; * Hence, check seq&lt;=rcv_wup reduces to:&n;&t;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;rcv_nxt
op_eq
id|tp-&gt;rcv_wup
)paren
(brace
id|tp-&gt;ts_recent
op_assign
id|tp-&gt;rcv_tsval
suffix:semicolon
id|tp-&gt;ts_recent_stamp
op_assign
id|xtime.tv_sec
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|len
op_le
id|tcp_header_len
)paren
(brace
multiline_comment|/* Bulk data transfer: sender */
r_if
c_cond
(paren
id|len
op_eq
id|tcp_header_len
)paren
(brace
multiline_comment|/* We know that such packets are checksummed&n;&t;&t;&t;&t; * on entry.&n;&t;&t;&t;&t; */
id|tcp_ack
c_func
(paren
id|sk
comma
id|th
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
comma
id|len
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|tcp_data_snd_check
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Header too small */
id|TCP_INC_STATS_BH
c_func
(paren
id|TcpInErrs
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
op_eq
id|tp-&gt;snd_una
)paren
(brace
r_int
id|eaten
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ucopy.task
op_eq
id|current
op_logical_and
id|tp-&gt;copied_seq
op_eq
id|tp-&gt;rcv_nxt
op_logical_and
id|len
op_minus
id|tcp_header_len
op_le
id|tp-&gt;ucopy.len
op_logical_and
id|sk-&gt;lock.users
)paren
(brace
id|eaten
op_assign
l_int|1
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|TCPHPHitsToUser
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_copy_to_iovec
c_func
(paren
id|sk
comma
id|skb
comma
id|tcp_header_len
)paren
)paren
r_goto
id|csum_error
suffix:semicolon
id|__skb_pull
c_func
(paren
id|skb
comma
id|tcp_header_len
)paren
suffix:semicolon
id|tp-&gt;rcv_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|tcp_checksum_complete_user
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
r_goto
id|csum_error
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
OG
id|sk-&gt;rcvbuf
)paren
r_goto
id|step5
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|TCPHPHits
)paren
suffix:semicolon
multiline_comment|/* Bulk data transfer: receiver */
id|__skb_pull
c_func
(paren
id|skb
comma
id|tcp_header_len
)paren
suffix:semicolon
multiline_comment|/* DO NOT notify forward progress here.&n;&t;&t;&t;&t; * It saves dozen of CPU instructions in fast path. --ANK&n;&t;&t;&t;&t; * And where is it signaled then ? -AK&n;&t;&t;&t;&t; * Nowhere. 8) --ANK&n;&t;&t;&t;&t; */
id|__skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
id|skb_set_owner_r
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
id|tp-&gt;rcv_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
multiline_comment|/* FIN bit check is not done since if FIN is set in&n;&t;&t;&t;&t; * this frame, the pred_flags won&squot;t match up. -DaveM&n;&t;&t;&t;&t; */
id|wake_up_interruptible
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
id|sock_wake_async
c_func
(paren
id|sk-&gt;socket
comma
l_int|1
comma
id|POLL_IN
)paren
suffix:semicolon
)brace
id|tcp_event_data_recv
c_func
(paren
id|tp
comma
id|skb
)paren
suffix:semicolon
macro_line|#ifdef TCP_MORE_COARSE_ACKS
r_if
c_cond
(paren
id|eaten
)paren
(brace
r_if
c_cond
(paren
id|tcp_in_quickack_mode
c_func
(paren
id|tp
)paren
)paren
(brace
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
id|tcp_send_delayed_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
r_else
macro_line|#endif
id|__tcp_ack_snd_check
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eaten
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Packet is in sequence, flags are trivial;&n;&t;&t; * only ACK is strange. Jump to step 5.&n;&t;&t; */
r_if
c_cond
(paren
id|tcp_checksum_complete_user
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
r_goto
id|csum_error
suffix:semicolon
r_goto
id|step5
suffix:semicolon
)brace
id|slow_path
suffix:colon
r_if
c_cond
(paren
id|tcp_checksum_complete_user
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
r_goto
id|csum_error
suffix:semicolon
multiline_comment|/*&n;&t; * RFC1323: H1. Apply PAWS check first.&n;&t; */
r_if
c_cond
(paren
id|tcp_fast_parse_options
c_func
(paren
id|sk
comma
id|th
comma
id|tp
)paren
op_logical_and
id|tp-&gt;saw_tstamp
op_logical_and
id|tcp_paws_discard
c_func
(paren
id|tp
comma
id|skb
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;rst
)paren
(brace
id|NET_INC_STATS_BH
c_func
(paren
id|PAWSEstabRejected
)paren
suffix:semicolon
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
multiline_comment|/* Resets are accepted even if PAWS failed.&n;&n;&t;&t;   ts_recent update must be made after we are sure&n;&t;&t;   that the packet is in window.&n;&t;&t; */
)brace
multiline_comment|/*&n;&t; *&t;Standard slow path.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tcp_sequence
c_func
(paren
id|tp
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
)paren
(brace
multiline_comment|/* RFC793, page 37: &quot;In all states except SYN-SENT, all reset&n;&t;&t; * (RST) segments are validated by checking their SEQ-fields.&quot;&n;&t;&t; * And page 69: &quot;If an incoming segment is not acceptable,&n;&t;&t; * an acknowledgment should be sent in reply (unless the RST bit&n;&t;&t; * is set, if so drop the segment and return)&quot;.&n;&t;&t; */
r_if
c_cond
(paren
id|th-&gt;rst
)paren
r_goto
id|discard
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;seq:%d end:%d wup:%d wnd:%d&bslash;n&quot;
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tp-&gt;rcv_wup
comma
id|tp-&gt;rcv_wnd
)paren
suffix:semicolon
)brace
id|tcp_enter_quickack_mode
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|DelayedACKLost
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
id|tcp_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;saw_tstamp
)paren
(brace
id|tcp_replace_ts_recent
c_func
(paren
id|sk
comma
id|tp
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;syn
op_logical_and
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_ne
id|tp-&gt;syn_seq
)paren
(brace
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;syn in established state&bslash;n&quot;
)paren
suffix:semicolon
id|TCP_INC_STATS_BH
c_func
(paren
id|TcpInErrs
)paren
suffix:semicolon
id|tcp_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|step5
suffix:colon
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
id|tcp_ack
c_func
(paren
id|sk
comma
id|th
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/* Process urgent data. */
id|tcp_urg
c_func
(paren
id|sk
comma
id|th
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* step 7: process the segment text */
id|tcp_data
c_func
(paren
id|skb
comma
id|sk
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Be careful, tcp_data() may have put this into TIME_WAIT. */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_CLOSE
)paren
(brace
id|tcp_data_snd_check
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_ack_snd_check
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|csum_error
suffix:colon
id|TCP_INC_STATS_BH
c_func
(paren
id|TcpInErrs
)paren
suffix:semicolon
id|discard
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is not only more efficient than what we used to do, it eliminates&n; * a lot of code duplication between IPv4/IPv6 SYN recv processing. -DaveM&n; *&n; * Actually, we could lots of memory writes here. tp of listening&n; * socket contains all necessary default parameters.&n; */
DECL|function|tcp_create_openreq_child
r_struct
id|sock
op_star
id|tcp_create_openreq_child
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|open_request
op_star
id|req
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sock
op_star
id|newsk
op_assign
id|sk_alloc
c_func
(paren
id|PF_INET
comma
id|GFP_ATOMIC
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newsk
op_ne
l_int|NULL
)paren
(brace
r_struct
id|tcp_opt
op_star
id|newtp
suffix:semicolon
macro_line|#ifdef CONFIG_FILTER
r_struct
id|sk_filter
op_star
id|filter
suffix:semicolon
macro_line|#endif
id|memcpy
c_func
(paren
id|newsk
comma
id|sk
comma
r_sizeof
(paren
op_star
id|newsk
)paren
)paren
suffix:semicolon
id|newsk-&gt;state
op_assign
id|TCP_SYN_RECV
suffix:semicolon
multiline_comment|/* SANITY */
id|newsk-&gt;pprev
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Clone the TCP header template */
id|newsk-&gt;dport
op_assign
id|req-&gt;rmt_port
suffix:semicolon
id|sock_lock_init
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|bh_lock_sock
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|newsk-&gt;rmem_alloc
comma
l_int|0
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|newsk-&gt;receive_queue
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|newsk-&gt;wmem_alloc
comma
l_int|0
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|newsk-&gt;write_queue
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|newsk-&gt;omem_alloc
comma
l_int|0
)paren
suffix:semicolon
id|newsk-&gt;done
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;proc
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;backlog.head
op_assign
id|newsk-&gt;backlog.tail
op_assign
l_int|NULL
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|newsk-&gt;error_queue
)paren
suffix:semicolon
id|newsk-&gt;write_space
op_assign
id|tcp_write_space
suffix:semicolon
macro_line|#ifdef CONFIG_FILTER
r_if
c_cond
(paren
(paren
id|filter
op_assign
id|newsk-&gt;filter
)paren
op_ne
l_int|NULL
)paren
id|sk_filter_charge
c_func
(paren
id|newsk
comma
id|filter
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Now setup tcp_opt */
id|newtp
op_assign
op_amp
(paren
id|newsk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|newtp-&gt;pred_flags
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;rcv_nxt
op_assign
id|req-&gt;rcv_isn
op_plus
l_int|1
suffix:semicolon
id|newtp-&gt;snd_nxt
op_assign
id|req-&gt;snt_isn
op_plus
l_int|1
suffix:semicolon
id|newtp-&gt;snd_una
op_assign
id|req-&gt;snt_isn
op_plus
l_int|1
suffix:semicolon
id|newtp-&gt;snd_sml
op_assign
id|req-&gt;snt_isn
op_plus
l_int|1
suffix:semicolon
id|tcp_delack_init
c_func
(paren
id|newtp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
op_ge
l_int|536
)paren
id|newtp-&gt;ack.last_seg_size
op_assign
id|skb-&gt;len
suffix:semicolon
id|tcp_prequeue_init
c_func
(paren
id|newtp
)paren
suffix:semicolon
id|newtp-&gt;snd_wl1
op_assign
id|req-&gt;rcv_isn
suffix:semicolon
id|newtp-&gt;snd_wl2
op_assign
id|req-&gt;snt_isn
suffix:semicolon
id|newtp-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;backoff
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;srtt
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;mdev
op_assign
id|TCP_TIMEOUT_INIT
suffix:semicolon
id|newtp-&gt;rto
op_assign
id|TCP_TIMEOUT_INIT
suffix:semicolon
id|newtp-&gt;packets_out
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;fackets_out
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;retrans_out
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;snd_ssthresh
op_assign
l_int|0x7fffffff
suffix:semicolon
multiline_comment|/* So many TCP implementations out there (incorrectly) count the&n;&t;&t; * initial SYN frame in their delayed-ACK and congestion control&n;&t;&t; * algorithms that we must have the following bandaid to talk&n;&t;&t; * efficiently to them.  -DaveM&n;&t;&t; */
id|newtp-&gt;snd_cwnd
op_assign
l_int|2
suffix:semicolon
id|newtp-&gt;snd_cwnd_cnt
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;high_seq
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;dup_acks
op_assign
l_int|0
suffix:semicolon
id|tcp_init_xmit_timers
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|newtp-&gt;out_of_order_queue
)paren
suffix:semicolon
id|newtp-&gt;send_head
op_assign
id|newtp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
id|newtp-&gt;rcv_wup
op_assign
id|req-&gt;rcv_isn
op_plus
l_int|1
suffix:semicolon
id|newtp-&gt;write_seq
op_assign
id|req-&gt;snt_isn
op_plus
l_int|1
suffix:semicolon
id|newtp-&gt;copied_seq
op_assign
id|req-&gt;rcv_isn
op_plus
l_int|1
suffix:semicolon
id|newtp-&gt;saw_tstamp
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;probes_out
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;syn_seq
op_assign
id|req-&gt;rcv_isn
suffix:semicolon
id|newtp-&gt;fin_seq
op_assign
id|req-&gt;rcv_isn
suffix:semicolon
id|newtp-&gt;urg_data
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;listen_opt
op_assign
l_int|NULL
suffix:semicolon
id|newtp-&gt;accept_queue
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Deinitialize syn_wait_lock to trap illegal accesses. */
id|memset
c_func
(paren
op_amp
id|newtp-&gt;syn_wait_lock
comma
l_int|0
comma
r_sizeof
(paren
id|newtp-&gt;syn_wait_lock
)paren
)paren
suffix:semicolon
multiline_comment|/* Back to base struct sock members. */
id|newsk-&gt;err
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;priority
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|newsk-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef INET_REFCNT_DEBUG
id|atomic_inc
c_func
(paren
op_amp
id|inet_sock_nr
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|newsk-&gt;keepopen
)paren
id|tcp_reset_keepalive_timer
c_func
(paren
id|newsk
comma
id|keepalive_time_when
c_func
(paren
id|newtp
)paren
)paren
suffix:semicolon
id|newsk-&gt;socket
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;sleep
op_assign
l_int|NULL
suffix:semicolon
id|newtp-&gt;tstamp_ok
op_assign
id|req-&gt;tstamp_ok
suffix:semicolon
r_if
c_cond
(paren
(paren
id|newtp-&gt;sack_ok
op_assign
id|req-&gt;sack_ok
)paren
op_ne
l_int|0
)paren
(brace
id|newtp-&gt;num_sacks
op_assign
l_int|0
suffix:semicolon
)brace
id|newtp-&gt;window_clamp
op_assign
id|req-&gt;window_clamp
suffix:semicolon
id|newtp-&gt;rcv_wnd
op_assign
id|req-&gt;rcv_wnd
suffix:semicolon
id|newtp-&gt;wscale_ok
op_assign
id|req-&gt;wscale_ok
suffix:semicolon
r_if
c_cond
(paren
id|newtp-&gt;wscale_ok
)paren
(brace
id|newtp-&gt;snd_wscale
op_assign
id|req-&gt;snd_wscale
suffix:semicolon
id|newtp-&gt;rcv_wscale
op_assign
id|req-&gt;rcv_wscale
suffix:semicolon
)brace
r_else
(brace
id|newtp-&gt;snd_wscale
op_assign
id|newtp-&gt;rcv_wscale
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;window_clamp
op_assign
id|min
c_func
(paren
id|newtp-&gt;window_clamp
comma
l_int|65535
)paren
suffix:semicolon
)brace
id|newtp-&gt;snd_wnd
op_assign
id|ntohs
c_func
(paren
id|skb-&gt;h.th-&gt;window
)paren
op_lshift
id|newtp-&gt;snd_wscale
suffix:semicolon
id|newtp-&gt;max_window
op_assign
id|newtp-&gt;snd_wnd
suffix:semicolon
r_if
c_cond
(paren
id|newtp-&gt;tstamp_ok
)paren
(brace
id|newtp-&gt;ts_recent
op_assign
id|req-&gt;ts_recent
suffix:semicolon
id|newtp-&gt;ts_recent_stamp
op_assign
id|xtime.tv_sec
suffix:semicolon
id|newtp-&gt;tcp_header_len
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
id|TCPOLEN_TSTAMP_ALIGNED
suffix:semicolon
)brace
r_else
(brace
id|newtp-&gt;ts_recent_stamp
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;tcp_header_len
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
)brace
id|newtp-&gt;mss_clamp
op_assign
id|req-&gt;mss
suffix:semicolon
)brace
r_return
id|newsk
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Process an incoming packet for SYN_RECV sockets represented&n; *&t;as an open_request.&n; */
DECL|function|tcp_check_req
r_struct
id|sock
op_star
id|tcp_check_req
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|open_request
op_star
id|req
comma
r_struct
id|open_request
op_star
op_star
id|prev
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|u32
id|flg
op_assign
id|tcp_flag_word
c_func
(paren
id|th
)paren
op_amp
(paren
id|TCP_FLAG_RST
op_or
id|TCP_FLAG_SYN
op_or
id|TCP_FLAG_ACK
)paren
suffix:semicolon
r_int
id|paws_reject
op_assign
l_int|0
suffix:semicolon
r_struct
id|tcp_opt
id|ttp
suffix:semicolon
r_struct
id|sock
op_star
id|child
suffix:semicolon
id|ttp.saw_tstamp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;doff
OG
(paren
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_rshift
l_int|2
)paren
)paren
(brace
id|tcp_parse_options
c_func
(paren
l_int|NULL
comma
id|th
comma
op_amp
id|ttp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ttp.saw_tstamp
)paren
(brace
id|ttp.ts_recent
op_assign
id|req-&gt;ts_recent
suffix:semicolon
multiline_comment|/* We do not store true stamp, but it is not required,&n;&t;&t;&t; * it can be estimated (approximately)&n;&t;&t;&t; * from another data.&n;&t;&t;&t; */
id|ttp.ts_recent_stamp
op_assign
id|xtime.tv_sec
op_minus
(paren
(paren
id|TCP_TIMEOUT_INIT
op_div
id|HZ
)paren
op_lshift
id|req-&gt;retrans
)paren
suffix:semicolon
id|paws_reject
op_assign
id|tcp_paws_check
c_func
(paren
op_amp
id|ttp
comma
id|th-&gt;rst
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Check for pure retransmited SYN. */
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_eq
id|req-&gt;rcv_isn
op_logical_and
id|flg
op_eq
id|TCP_FLAG_SYN
op_logical_and
op_logical_neg
id|paws_reject
)paren
(brace
multiline_comment|/*&n;&t;&t; * RFC793 draws (Incorrectly! It was fixed in RFC1122)&n;&t;&t; * this case on figure 6 and figure 8, but formal&n;&t;&t; * protocol description says NOTHING.&n;&t;&t; * To be more exact, it says that we should send ACK,&n;&t;&t; * because this segment (at least, if it has no data)&n;&t;&t; * is out of window.&n;&t;&t; *&n;&t;&t; *  CONCLUSION: RFC793 (even with RFC1122) DOES NOT&n;&t;&t; *  describe SYN-RECV state. All the description&n;&t;&t; *  is wrong, we cannot believe to it and should&n;&t;&t; *  rely only on common sense and implementation&n;&t;&t; *  experience.&n;&t;&t; *&n;&t;&t; * Enforce &quot;SYN-ACK&quot; according to figure 8, figure 6&n;&t;&t; * of RFC793, fixed by RFC1122.&n;&t;&t; */
id|req
op_member_access_from_pointer
r_class
op_member_access_from_pointer
id|rtx_syn_ack
c_func
(paren
id|sk
comma
id|req
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Further reproduces section &quot;SEGMENT ARRIVES&quot;&n;&t;   for state SYN-RECEIVED of RFC793.&n;&t;   It is broken, however, it does not work only&n;&t;   when SYNs are crossed, which is impossible in our&n;&t;   case.&n;&n;&t;   But generally, we should (RFC lies!) to accept ACK&n;&t;   from SYNACK both here and in tcp_rcv_state_process().&n;&t;   tcp_rcv_state_process() does not, hence, we do not too.&n;&n;&t;   Note that the case is absolutely generic:&n;&t;   we cannot optimize anything here without&n;&t;   violating protocol. All the checks must be made&n;&t;   before attempt to create socket.&n;&t; */
multiline_comment|/* RFC793: &quot;first check sequence number&quot;. */
r_if
c_cond
(paren
id|paws_reject
op_logical_or
op_logical_neg
id|tcp_in_window
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|req-&gt;rcv_isn
op_plus
l_int|1
comma
id|req-&gt;rcv_isn
op_plus
l_int|1
op_plus
id|req-&gt;rcv_wnd
)paren
)paren
(brace
multiline_comment|/* Out of window: send ACK and drop. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flg
op_amp
id|TCP_FLAG_RST
)paren
)paren
id|req
op_member_access_from_pointer
r_class
op_member_access_from_pointer
id|send_ack
c_func
(paren
id|skb
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|paws_reject
)paren
id|NET_INC_STATS_BH
c_func
(paren
id|PAWSEstabRejected
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* In sequence, PAWS is OK. */
r_if
c_cond
(paren
id|ttp.saw_tstamp
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|req-&gt;rcv_isn
op_plus
l_int|1
)paren
)paren
id|req-&gt;ts_recent
op_assign
id|ttp.rcv_tsval
suffix:semicolon
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_eq
id|req-&gt;rcv_isn
)paren
(brace
multiline_comment|/* Truncate SYN, it is out of window starting&n;&t;&t;   at req-&gt;rcv_isn+1. */
id|flg
op_and_assign
op_complement
id|TCP_FLAG_SYN
suffix:semicolon
)brace
multiline_comment|/* RFC793: &quot;second check the RST bit&quot; and&n;&t; *&t;   &quot;fourth, check the SYN bit&quot;&n;&t; */
r_if
c_cond
(paren
id|flg
op_amp
(paren
id|TCP_FLAG_RST
op_or
id|TCP_FLAG_SYN
)paren
)paren
r_goto
id|embryonic_reset
suffix:semicolon
multiline_comment|/* RFC793: &quot;fifth check the ACK field&quot; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flg
op_amp
id|TCP_FLAG_ACK
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Invalid ACK: reset will be sent by listening socket */
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
op_ne
id|req-&gt;snt_isn
op_plus
l_int|1
)paren
r_return
id|sk
suffix:semicolon
multiline_comment|/* Also, it would be not so bad idea to check rcv_tsecr, which&n;&t; * is essentially ACK extension and too early or too late values&n;&t; * should cause reset in unsynchronized states.&n;&t; */
multiline_comment|/* If TCP_DEFER_ACCEPT is set, drop bare ACK. */
r_if
c_cond
(paren
id|tp-&gt;defer_accept
op_logical_and
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_eq
id|req-&gt;rcv_isn
op_plus
l_int|1
)paren
(brace
id|req-&gt;acked
op_assign
l_int|1
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* OK, ACK is valid, create big socket and&n;&t; * feed this segment to it. It will repeat all&n;&t; * the tests. THIS SEGMENT MUST MOVE SOCKET TO&n;&t; * ESTABLISHED STATE. If it will be dropped after&n;&t; * socket is created, wait for troubles.&n;&t; */
id|child
op_assign
id|tp-&gt;af_specific
op_member_access_from_pointer
id|syn_recv_sock
c_func
(paren
id|sk
comma
id|skb
comma
id|req
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|child
op_eq
l_int|NULL
)paren
r_goto
id|listen_overflow
suffix:semicolon
id|tcp_synq_unlink
c_func
(paren
id|tp
comma
id|req
comma
id|prev
)paren
suffix:semicolon
id|tcp_synq_removed
c_func
(paren
id|sk
comma
id|req
)paren
suffix:semicolon
id|tcp_acceptq_queue
c_func
(paren
id|sk
comma
id|req
comma
id|child
)paren
suffix:semicolon
r_return
id|child
suffix:semicolon
id|listen_overflow
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|sysctl_tcp_abort_on_overflow
)paren
(brace
id|req-&gt;acked
op_assign
l_int|1
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|embryonic_reset
suffix:colon
id|NET_INC_STATS_BH
c_func
(paren
id|EmbryonicRsts
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flg
op_amp
id|TCP_FLAG_RST
)paren
)paren
id|req
op_member_access_from_pointer
r_class
op_member_access_from_pointer
id|send_reset
c_func
(paren
id|skb
)paren
suffix:semicolon
id|tcp_synq_drop
c_func
(paren
id|sk
comma
id|req
comma
id|prev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Queue segment on the new socket if the new socket is active,&n; * otherwise we just shortcircuit this and continue with&n; * the new socket.&n; */
DECL|function|tcp_child_process
r_int
id|tcp_child_process
c_func
(paren
r_struct
id|sock
op_star
id|parent
comma
r_struct
id|sock
op_star
id|child
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|state
op_assign
id|child-&gt;state
suffix:semicolon
r_if
c_cond
(paren
id|child-&gt;lock.users
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|tcp_rcv_state_process
c_func
(paren
id|child
comma
id|skb
comma
id|skb-&gt;h.th
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Wakeup parent, send SIGIO */
r_if
c_cond
(paren
id|state
op_eq
id|TCP_SYN_RECV
op_logical_and
id|child-&gt;state
op_ne
id|state
)paren
id|parent
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|parent
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Alas, it is possible again, because we do lookup&n;&t;&t; * in main socket hash table and lock on listening&n;&t;&t; * socket does not protect us more.&n;&t;&t; */
id|sk_add_backlog
c_func
(paren
id|child
comma
id|skb
)paren
suffix:semicolon
)brace
id|bh_unlock_sock
c_func
(paren
id|child
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|tcp_rcv_synsent_state_process
r_static
r_int
id|tcp_rcv_synsent_state_process
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|tcp_parse_options
c_func
(paren
id|sk
comma
id|th
comma
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
multiline_comment|/* rfc793:&n;&t;&t; * &quot;If the state is SYN-SENT then&n;&t;&t; *    first check the ACK bit&n;&t;&t; *      If the ACK bit is set&n;&t;&t; *&t;  If SEG.ACK =&lt; ISS, or SEG.ACK &gt; SND.NXT, send&n;&t;&t; *        a reset (unless the RST bit is set, if so drop&n;&t;&t; *        the segment and return)&quot;&n;&t;&t; *&n;&t;&t; *  I cite this place to emphasize one essential&n;&t;&t; *  detail, this check is different of one&n;&t;&t; *  in established state: SND.UNA &lt;= SEG.ACK &lt;= SND.NXT.&n;&t;&t; *  SEG_ACK == SND.UNA == ISS is invalid in SYN-SENT,&n;&t;&t; *  because we have no previous data sent before SYN.&n;&t;&t; *                                        --ANK(990513)&n;&t;&t; *&n;&t;&t; *  We do not send data with SYN, so that RFC-correct&n;&t;&t; *  test reduces to:&n;&t;&t; */
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
op_ne
id|tp-&gt;snd_nxt
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Check not from any RFC, but it is evident consequence&n;&t;&t; * of combining PAWS and usual SYN-SENT logic: ACK _is_&n;&t;&t; * checked in SYN-SENT unlike another states, hence&n;&t;&t; * echoed tstamp must be checked too.&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;saw_tstamp
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;rcv_tsecr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Workaround for bug in linux-2.1 and early&n;&t;&t;&t;&t; * 2.2 kernels. Let&squot;s pretend that we did not&n;&t;&t;&t;&t; * see such timestamp to avoid bogus rtt value,&n;&t;&t;&t;&t; * calculated by tcp_ack().&n;&t;&t;&t;&t; */
id|tp-&gt;saw_tstamp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* But do not forget to store peer&squot;s timestamp! */
r_if
c_cond
(paren
id|th-&gt;syn
)paren
(brace
id|tp-&gt;ts_recent
op_assign
id|tp-&gt;rcv_tsval
suffix:semicolon
id|tp-&gt;ts_recent_stamp
op_assign
id|xtime.tv_sec
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|__s32
)paren
(paren
id|tp-&gt;rcv_tsecr
op_minus
id|tcp_time_stamp
)paren
OG
l_int|0
op_logical_or
(paren
id|__s32
)paren
(paren
id|tp-&gt;rcv_tsecr
op_minus
id|tp-&gt;syn_stamp
)paren
OL
l_int|0
)paren
(brace
id|NETDEBUG
c_func
(paren
r_if
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;TCP: synsent reject.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|NET_INC_STATS_BH
c_func
(paren
id|PAWSActiveRejected
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Now ACK is acceptable.&n;&t;&t; *&n;&t;&t; * &quot;If the RST bit is set&n;&t;&t; *    If the ACK was acceptable then signal the user &quot;error:&n;&t;&t; *    connection reset&quot;, drop the segment, enter CLOSED state,&n;&t;&t; *    delete TCB, and return.&quot;&n;&t;&t; */
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
id|tcp_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
multiline_comment|/* rfc793:&n;&t;&t; *   &quot;fifth, if neither of the SYN or RST bits is set then&n;&t;&t; *    drop the segment and return.&quot;&n;&t;&t; *&n;&t;&t; *    See note below!&n;&t;&t; *                                        --ANK(990513)&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;syn
)paren
r_goto
id|discard
suffix:semicolon
multiline_comment|/* rfc793:&n;&t;&t; *   &quot;If the SYN bit is on ...&n;&t;&t; *    are acceptable then ...&n;&t;&t; *    (our SYN has been ACKed), change the connection&n;&t;&t; *    state to ESTABLISHED...&quot;&n;&t;&t; *&n;&t;&t; * Do you see? SYN-less ACKs in SYN-SENT state are&n;&t;&t; * completely ignored.&n;&t;&t; *&n;&t;&t; * The bug causing stalled SYN-SENT sockets&n;&t;&t; * was here: tcp_ack advanced snd_una and canceled&n;&t;&t; * retransmit timer, so that bare ACK received&n;&t;&t; * in SYN-SENT state (even with invalid ack==ISS,&n;&t;&t; * because tcp_ack check is too weak for SYN-SENT)&n;&t;&t; * causes moving socket to invalid semi-SYN-SENT,&n;&t;&t; * semi-ESTABLISHED state and connection hangs.&n;&t;&t; *                                     --ANK (990514)&n;&t;&t; *&n;&t;&t; * Bare ACK is valid, however.&n;&t;&t; * Actually, RFC793 requires to send such ACK&n;&t;&t; * in reply to any out of window packet.&n;&t;&t; * It is wrong, but Linux also send such&n;&t;&t; * useless ACKs sometimes.&n;&t;&t; *                                     --ANK (990724)&n;&t;&t; */
id|tp-&gt;snd_wl1
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|tcp_ack
c_func
(paren
id|sk
comma
id|th
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Ok.. it&squot;s good. Set up sequence numbers and&n;&t;&t; * move to established.&n;&t;&t; */
id|tp-&gt;rcv_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_plus
l_int|1
suffix:semicolon
id|tp-&gt;rcv_wup
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* RFC1323: The window in SYN &amp; SYN/ACK segments is&n;&t;&t; * never scaled.&n;&t;&t; */
id|tp-&gt;snd_wnd
op_assign
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
suffix:semicolon
id|tp-&gt;snd_wl1
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|tp-&gt;snd_wl2
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
suffix:semicolon
id|tp-&gt;fin_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_ESTABLISHED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;wscale_ok
op_eq
l_int|0
)paren
(brace
id|tp-&gt;snd_wscale
op_assign
id|tp-&gt;rcv_wscale
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;window_clamp
op_assign
id|min
c_func
(paren
id|tp-&gt;window_clamp
comma
l_int|65535
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;tstamp_ok
)paren
(brace
id|tp-&gt;tcp_header_len
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
id|TCPOLEN_TSTAMP_ALIGNED
suffix:semicolon
)brace
r_else
id|tp-&gt;tcp_header_len
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;saw_tstamp
)paren
(brace
id|tp-&gt;ts_recent
op_assign
id|tp-&gt;rcv_tsval
suffix:semicolon
id|tp-&gt;ts_recent_stamp
op_assign
id|xtime.tv_sec
suffix:semicolon
)brace
id|tcp_sync_mss
c_func
(paren
id|sk
comma
id|tp-&gt;pmtu_cookie
)paren
suffix:semicolon
id|tcp_initialize_rcv_mss
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_init_metrics
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;keepopen
)paren
id|tcp_reset_keepalive_timer
c_func
(paren
id|sk
comma
id|keepalive_time_when
c_func
(paren
id|tp
)paren
)paren
suffix:semicolon
id|tp-&gt;copied_seq
op_assign
id|tp-&gt;rcv_nxt
suffix:semicolon
id|__tcp_fast_path_on
c_func
(paren
id|tp
comma
id|tp-&gt;snd_wnd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sock_wake_async
c_func
(paren
id|sk-&gt;socket
comma
l_int|0
comma
id|POLL_OUT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;write_pending
)paren
(brace
multiline_comment|/* Save one ACK. Data will be ready after&n;&t;&t;&t; * several ticks, if write_pending is set.&n;&t;&t;&t; *&n;&t;&t;&t; * It may be deleted, but with this feature tcpdumps&n;&t;&t;&t; * look so _wonderfully_ clever, that I was not able&n;&t;&t;&t; * to stand against the temptation 8)     --ANK&n;&t;&t;&t; */
id|tp-&gt;ack.pending
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;ack.lrcvtime
op_assign
id|tcp_time_stamp
suffix:semicolon
id|tcp_enter_quickack_mode
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;ack.ato
op_assign
id|TCP_ATO_MIN
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_DACK
comma
id|TCP_DELACK_MIN
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
r_else
(brace
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* No ACK in the segment */
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
multiline_comment|/* rfc793:&n;&t;&t; * &quot;If the RST bit is set&n;&t;&t; *&n;&t;&t; *      Otherwise (no ACK) drop the segment and return.&quot;&n;&t;&t; */
r_goto
id|discard
suffix:semicolon
)brace
multiline_comment|/* PAWS check. */
r_if
c_cond
(paren
id|tp-&gt;ts_recent_stamp
op_logical_and
id|tp-&gt;saw_tstamp
op_logical_and
id|tcp_paws_check
c_func
(paren
id|tp
comma
l_int|0
)paren
)paren
r_goto
id|discard
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;syn
)paren
(brace
multiline_comment|/* We see SYN without ACK. It is attempt of&n;&t;&t; *  simultaneous connect with crossed SYNs.&n;&t;&t; *&n;&t;&t; * The previous version of the code&n;&t;&t; * checked for &quot;connecting to self&quot;&n;&t;&t; * here. that check is done now in&n;&t;&t; * tcp_connect.&n;&t;&t; *&n;&t;&t; * RED-PEN: BTW, it does not. 8)&n;&t;&t; */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_SYN_RECV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;saw_tstamp
)paren
(brace
id|tp-&gt;ts_recent
op_assign
id|tp-&gt;rcv_tsval
suffix:semicolon
id|tp-&gt;ts_recent_stamp
op_assign
id|xtime.tv_sec
suffix:semicolon
)brace
id|tp-&gt;rcv_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_plus
l_int|1
suffix:semicolon
id|tp-&gt;rcv_wup
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* RFC1323: The window in SYN &amp; SYN/ACK segments is&n;&t;&t; * never scaled.&n;&t;&t; */
id|tp-&gt;snd_wnd
op_assign
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
suffix:semicolon
id|tp-&gt;snd_wl1
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|tp-&gt;max_window
op_assign
id|tp-&gt;snd_wnd
suffix:semicolon
id|tcp_sync_mss
c_func
(paren
id|sk
comma
id|tp-&gt;pmtu_cookie
)paren
suffix:semicolon
id|tcp_initialize_rcv_mss
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_send_synack
c_func
(paren
id|sk
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Note, we could accept data and URG from this segment.&n;&t;&t; * There are no obstacles to make this.&n;&t;&t; *&n;&t;&t; * However, if we ignore data in ACKless segments sometimes,&n;&t;&t; * we have no reasons to accept it sometimes.&n;&t;&t; * Also, seems the code doing it in step6 of tcp_rcv_state_process&n;&t;&t; * is not flawless. So, discard packet for sanity.&n;&t;&t; * Uncomment this return to process the data.&n;&t;&t; */
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* &quot;fifth, if neither of the SYN or RST bits is set then&n;&t; * drop the segment and return.&quot;&n;&t; */
id|discard
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This function implements the receiving procedure of RFC 793 for&n; *&t;all states except ESTABLISHED and TIME_WAIT. &n; *&t;It&squot;s called from both tcp_v4_rcv and tcp_v6_rcv and should be&n; *&t;address independent.&n; */
DECL|function|tcp_rcv_state_process
r_int
id|tcp_rcv_state_process
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|queued
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;saw_tstamp
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_CLOSE
suffix:colon
multiline_comment|/* When state == CLOSED, hash lookup always fails.&n;&t;&t; *&n;&t;&t; * But, there is a back door, the backlog queue.&n;&t;&t; * If we have a sequence of packets in the backlog&n;&t;&t; * during __release_sock() which have a sequence such&n;&t;&t; * that:&n;&t;&t; *&t;packet X&t;causes entry to TCP_CLOSE state&n;&t;&t; *&t;...&n;&t;&t; *&t;packet X + N&t;has FIN bit set&n;&t;&t; *&n;&t;&t; * We report a (luckily) harmless error in this case.&n;&t;&t; * The issue is that backlog queue processing bypasses&n;&t;&t; * any hash lookups (we know which socket packets are for).&n;&t;&t; * The correct behavior here is what 2.0.x did, since&n;&t;&t; * a TCP_CLOSE socket does not exist.  Drop the frame&n;&t;&t; * and send a RST back to the other end.&n;&t;&t; */
multiline_comment|/* 1. The socket may be moved to TIME-WAIT state.&n;&t;&t;   2. While this socket was locked, another socket&n;&t;&t;      with the same identity could be created.&n;&t;&t;   3. To continue?&n;&n;&t;&t;   CONCLUSION: discard and only discard!&n;&n;&t;&t;   Alternative would be relookup and recurse into tcp_v?_rcv&n;&t;&t;   (not *_do_rcv) to work with timewait and listen states&n;&t;&t;   correctly.&n;&t;&t; */
r_goto
id|discard
suffix:semicolon
r_case
id|TCP_LISTEN
suffix:colon
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;syn
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;af_specific
op_member_access_from_pointer
id|conn_request
c_func
(paren
id|sk
comma
id|skb
)paren
OL
l_int|0
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now we have several options: In theory there is &n;&t;&t;&t; * nothing else in the frame. KA9Q has an option to &n;&t;&t;&t; * send data with the syn, BSD accepts data with the&n;&t;&t;&t; * syn up to the [to be] advertised window and &n;&t;&t;&t; * Solaris 2.1 gives you a protocol error. For now &n;&t;&t;&t; * we just ignore it, that fits the spec precisely &n;&t;&t;&t; * and avoids incompatibilities. It would be nice in&n;&t;&t;&t; * future to drop through and process the data.&n;&t;&t;&t; *&n;&t;&t;&t; * Now that TTCP is starting to be used we ought to &n;&t;&t;&t; * queue this data.&n;&t;&t;&t; * But, this leaves one open to an easy denial of&n;&t;&t; &t; * service attack, and SYN cookies can&squot;t defend&n;&t;&t;&t; * against this problem. So, we drop the data&n;&t;&t;&t; * in the interest of security over speed.&n;&t;&t;&t; */
r_goto
id|discard
suffix:semicolon
)brace
r_goto
id|discard
suffix:semicolon
r_case
id|TCP_SYN_SENT
suffix:colon
id|queued
op_assign
id|tcp_rcv_synsent_state_process
c_func
(paren
id|sk
comma
id|skb
comma
id|th
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|queued
op_ge
l_int|0
)paren
r_return
id|queued
suffix:semicolon
id|queued
op_assign
l_int|0
suffix:semicolon
r_goto
id|step6
suffix:semicolon
)brace
multiline_comment|/*   Parse the tcp_options present on this header.&n;&t; *   By this point we really only expect timestamps.&n;&t; *   Note that this really has to be here and not later for PAWS&n;&t; *   (RFC1323) to work.&n;&t; */
r_if
c_cond
(paren
id|tcp_fast_parse_options
c_func
(paren
id|sk
comma
id|th
comma
id|tp
)paren
op_logical_and
id|tp-&gt;saw_tstamp
op_logical_and
id|tcp_paws_discard
c_func
(paren
id|tp
comma
id|skb
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;rst
)paren
(brace
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
multiline_comment|/* Reset is accepted even if it did not pass PAWS. */
)brace
multiline_comment|/* The silly FIN test here is necessary to see an advancing ACK in&n;&t; * retransmitted FIN frames properly.  Consider the following sequence:&n;&t; *&n;&t; *&t;host1 --&gt; host2&t;&t;FIN XSEQ:XSEQ(0) ack YSEQ&n;&t; *&t;host2 --&gt; host1&t;&t;FIN YSEQ:YSEQ(0) ack XSEQ&n;&t; *&t;host1 --&gt; host2&t;&t;XSEQ:XSEQ(0) ack YSEQ+1&n;&t; *&t;host2 --&gt; host1&t;&t;FIN YSEQ:YSEQ(0) ack XSEQ+1&t;(fails tcp_sequence test)&n;&t; *&n;&t; * At this point the connection will deadlock with host1 believing&n;&t; * that his FIN is never ACK&squot;d, and thus it will retransmit it&squot;s FIN&n;&t; * forever.  The following fix is from Taral (taral@taral.net).&n;&t; *&n;&t; * RED-PEN. Seems, the above is not true.&n;&t; * If at least one end is RFC compliant, it will send ACK to&n;&t; * out of window FIN and, hence, move peer to TIME-WAIT.&n;&t; * I comment out this line. --ANK&n;&t; *&n;&t; * RED-PEN. DANGER! tcp_sequence check rejects also SYN-ACKs&n;&t; * received in SYN-RECV. The problem is that description of&n;&t; * segment processing in SYN-RECV state in RFC792 is WRONG.&n;&t; * Correct check would accept ACK from this SYN-ACK, see&n;&t; * figures 6 and 8 (fixed by RFC1122). Compare this&n;&t; * to problem with FIN, they smell similarly. --ANK&n;&t; */
multiline_comment|/* step 1: check sequence number */
r_if
c_cond
(paren
op_logical_neg
id|tcp_sequence
c_func
(paren
id|tp
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
)paren
macro_line|#if 0
op_logical_and
op_logical_neg
(paren
id|th-&gt;fin
op_logical_and
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_eq
id|tp-&gt;rcv_nxt
)paren
macro_line|#endif
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;rst
)paren
(brace
id|NET_INC_STATS_BH
c_func
(paren
id|DelayedACKLost
)paren
suffix:semicolon
id|tcp_enter_quickack_mode
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_goto
id|discard
suffix:semicolon
)brace
multiline_comment|/* step 2: check RST bit */
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
id|tcp_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;saw_tstamp
)paren
(brace
id|tcp_replace_ts_recent
c_func
(paren
id|sk
comma
id|tp
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
suffix:semicolon
)brace
multiline_comment|/* step 3: check security and precedence [ignored] */
multiline_comment|/*&t;step 4:&n;&t; *&n;&t; *&t;Check for a SYN, and ensure it matches the SYN we were&n;&t; *&t;first sent. We have to handle the rather unusual (but valid)&n;&t; *&t;sequence that KA9Q derived products may generate of&n;&t; *&n;&t; *&t;SYN&n;&t; *&t;&t;&t;&t;SYN|ACK Data&n;&t; *&t;ACK&t;(lost)&n;&t; *&t;&t;&t;&t;SYN|ACK Data + More Data&n;&t; *&t;.. we must ACK not RST...&n;&t; *&n;&t; *&t;We keep syn_seq as the sequence space occupied by the &n;&t; *&t;original syn. &n;&t; */
r_if
c_cond
(paren
id|th-&gt;syn
op_logical_and
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_ne
id|tp-&gt;syn_seq
)paren
(brace
id|tcp_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* step 5: check the ACK field */
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
r_int
id|acceptable
op_assign
id|tcp_ack
c_func
(paren
id|sk
comma
id|th
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
comma
id|len
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_SYN_RECV
suffix:colon
r_if
c_cond
(paren
id|acceptable
)paren
(brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_ESTABLISHED
)paren
suffix:semicolon
id|tp-&gt;copied_seq
op_assign
id|tp-&gt;rcv_nxt
suffix:semicolon
multiline_comment|/* Note, that this wakeup is only for marginal&n;&t;&t;&t;&t; * crossed SYN case. Passively open sockets&n;&t;&t;&t;&t; * are not waked up, because sk-&gt;sleep == NULL&n;&t;&t;&t;&t; * and sk-&gt;socket == NULL.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sock_wake_async
c_func
(paren
id|sk-&gt;socket
comma
l_int|0
comma
id|POLL_OUT
)paren
suffix:semicolon
)brace
id|tp-&gt;snd_una
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
suffix:semicolon
id|tp-&gt;snd_wnd
op_assign
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
op_lshift
id|tp-&gt;snd_wscale
suffix:semicolon
id|tp-&gt;snd_wl1
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|tp-&gt;snd_wl2
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
suffix:semicolon
multiline_comment|/* tcp_ack considers this ACK as duplicate&n;&t;&t;&t;&t; * and does not calculate rtt.&n;&t;&t;&t;&t; * Fix it at least with timestamps.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;saw_tstamp
op_logical_and
op_logical_neg
id|tp-&gt;srtt
)paren
id|tcp_ack_saw_tstamp
c_func
(paren
id|sk
comma
id|tp
comma
l_int|0
comma
l_int|0
comma
id|FLAG_SYN_ACKED
)paren
suffix:semicolon
id|tcp_init_metrics
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_fast_path_on
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
r_else
(brace
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;bad ack&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TCP_FIN_WAIT1
suffix:colon
r_if
c_cond
(paren
id|tp-&gt;snd_una
op_eq
id|tp-&gt;write_seq
)paren
(brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_FIN_WAIT2
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_or_assign
id|SEND_SHUTDOWN
suffix:semicolon
id|dst_confirm
c_func
(paren
id|sk-&gt;dst_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
multiline_comment|/* Wake up lingering close() */
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|tmo
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;linger2
OL
l_int|0
op_logical_or
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_ne
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_logical_and
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_minus
id|th-&gt;fin
comma
id|tp-&gt;rcv_nxt
)paren
)paren
)paren
(brace
id|tcp_done
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|tmo
op_assign
id|tcp_fin_time
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmo
OG
id|TCP_TIMEWAIT_LEN
)paren
(brace
id|tcp_reset_keepalive_timer
c_func
(paren
id|sk
comma
id|tmo
op_minus
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|th-&gt;fin
op_logical_or
id|sk-&gt;lock.users
)paren
(brace
multiline_comment|/* Bad case. We could lose such FIN otherwise.&n;&t;&t;&t;&t;&t;&t; * It is not a big problem, but it looks confusing&n;&t;&t;&t;&t;&t;&t; * and not so rare event. We still can lose it now,&n;&t;&t;&t;&t;&t;&t; * if it spins in bh_lock_sock(), but it is really&n;&t;&t;&t;&t;&t;&t; * marginal case.&n;&t;&t;&t;&t;&t;&t; */
id|tcp_reset_keepalive_timer
c_func
(paren
id|sk
comma
id|tmo
)paren
suffix:semicolon
)brace
r_else
(brace
id|tcp_time_wait
c_func
(paren
id|sk
comma
id|TCP_FIN_WAIT2
comma
id|tmo
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
r_case
id|TCP_CLOSING
suffix:colon
r_if
c_cond
(paren
id|tp-&gt;snd_una
op_eq
id|tp-&gt;write_seq
)paren
(brace
id|tcp_time_wait
c_func
(paren
id|sk
comma
id|TCP_TIME_WAIT
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TCP_LAST_ACK
suffix:colon
r_if
c_cond
(paren
id|tp-&gt;snd_una
op_eq
id|tp-&gt;write_seq
)paren
(brace
id|tcp_update_metrics
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_done
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_else
r_goto
id|discard
suffix:semicolon
id|step6
suffix:colon
multiline_comment|/* step 6: check the URG bit */
id|tcp_urg
c_func
(paren
id|sk
comma
id|th
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* step 7: process the segment text */
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_CLOSE_WAIT
suffix:colon
r_case
id|TCP_CLOSING
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|before
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|tp-&gt;fin_seq
)paren
)paren
r_break
suffix:semicolon
r_case
id|TCP_FIN_WAIT1
suffix:colon
r_case
id|TCP_FIN_WAIT2
suffix:colon
multiline_comment|/* RFC 793 says to queue data in these states,&n;&t;&t; * RFC 1122 says we MUST send a reset. &n;&t;&t; * BSD 4.4 also does reset.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
(brace
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_ne
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_logical_and
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_minus
id|th-&gt;fin
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
id|tcp_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Fall through */
r_case
id|TCP_ESTABLISHED
suffix:colon
id|tcp_data
c_func
(paren
id|skb
comma
id|sk
comma
id|len
)paren
suffix:semicolon
id|queued
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* tcp_data could move socket to TIME-WAIT */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_CLOSE
)paren
(brace
id|tcp_data_snd_check
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_ack_snd_check
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|queued
)paren
(brace
id|discard
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
