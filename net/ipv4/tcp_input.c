multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Implementation of the Transmission Control Protocol(TCP).&n; *&n; * Version:&t;$Id: tcp_input.c,v 1.43 1997/04/16 09:18:47 davem Exp $&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;&n; *&t;&t;Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; */
multiline_comment|/*&n; * Changes:&n; *&t;&t;Pedro Roque&t;:&t;Fast Retransmit/Recovery.&n; *&t;&t;&t;&t;&t;Two receive queues.&n; *&t;&t;&t;&t;&t;Retransmit queue handled by TCP.&n; *&t;&t;&t;&t;&t;Better retransmit timer handling.&n; *&t;&t;&t;&t;&t;New congestion avoidance.&n; *&t;&t;&t;&t;&t;Header prediction.&n; *&t;&t;&t;&t;&t;Variable renaming.&n; *&n; *&t;&t;Eric&t;&t;:&t;Fast Retransmit.&n; *&t;&t;Randy Scott&t;:&t;MSS option defines.&n; *&t;&t;Eric Schenk&t;:&t;Fixes to slow start algorithm.&n; *&t;&t;Eric Schenk&t;:&t;Yet another double ACK bug.&n; *&t;&t;Eric Schenk&t;:&t;Delayed ACK bug fixes.&n; *&t;&t;Eric Schenk&t;:&t;Floyd style fast retrans war avoidance.&n; *&t;&t;David S. Miller&t;:&t;Don&squot;t allow zero congestion window.&n; *&t;&t;Eric Schenk&t;:&t;Fix retransmitter so that it sends&n; *&t;&t;&t;&t;&t;next packet on ack of previous packet.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;linux/ipsec.h&gt;
DECL|typedef|tcp_sys_cong_ctl_t
r_typedef
r_void
(paren
op_star
id|tcp_sys_cong_ctl_t
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|seq
comma
id|u32
id|ack
comma
id|u32
id|seq_rtt
)paren
suffix:semicolon
r_static
r_void
id|tcp_cong_avoid_vanj
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|seq
comma
id|u32
id|ack
comma
id|u32
id|seq_rtt
)paren
suffix:semicolon
r_static
r_void
id|tcp_cong_avoid_vegas
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|seq
comma
id|u32
id|ack
comma
id|u32
id|seq_rtt
)paren
suffix:semicolon
DECL|variable|sysctl_tcp_cong_avoidance
r_int
id|sysctl_tcp_cong_avoidance
op_assign
l_int|0
suffix:semicolon
DECL|variable|tcp_sys_cong_ctl_f
r_static
id|tcp_sys_cong_ctl_t
id|tcp_sys_cong_ctl_f
op_assign
op_amp
id|tcp_cong_avoid_vanj
suffix:semicolon
multiline_comment|/*&n; *&t;Called each time to estimate the delayed ack timeout. This is&n; *&t;how it should be done so a fast link isnt impacted by ack delay.&n; *&n; *&t;I think we need a medium deviation here also...&n; *&t;The estimated value is changing to fast&n; */
DECL|function|tcp_delack_estimator
r_static
r_void
id|tcp_delack_estimator
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_int
id|m
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Delayed ACK time estimator.&n;&t; */
id|m
op_assign
id|jiffies
op_minus
id|tp-&gt;lrcvtime
suffix:semicolon
id|tp-&gt;lrcvtime
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|m
OL
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * if the mesured value is bigger than&n;&t; * twice the round trip time ignore it.&n;&t; */
r_if
c_cond
(paren
(paren
id|m
op_lshift
l_int|2
)paren
op_le
id|tp-&gt;srtt
)paren
(brace
id|m
op_sub_assign
(paren
id|tp-&gt;iat
op_rshift
l_int|3
)paren
suffix:semicolon
id|tp-&gt;iat
op_add_assign
id|m
suffix:semicolon
r_if
c_cond
(paren
id|m
OL
l_int|0
)paren
id|m
op_assign
op_minus
id|m
suffix:semicolon
id|m
op_sub_assign
(paren
id|tp-&gt;iat_mdev
op_rshift
l_int|2
)paren
suffix:semicolon
id|tp-&gt;iat_mdev
op_add_assign
id|m
suffix:semicolon
id|tp-&gt;ato
op_assign
(paren
id|tp-&gt;iat
op_rshift
l_int|3
)paren
op_plus
(paren
id|tp-&gt;iat_mdev
op_rshift
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ato
OL
id|HZ
op_div
l_int|50
)paren
id|tp-&gt;ato
op_assign
id|HZ
op_div
l_int|50
suffix:semicolon
)brace
r_else
id|tp-&gt;ato
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Called on frames that were known _not_ to have been&n; *&t;retransmitted [see Karn/Partridge Proceedings SIGCOMM 87]. &n; *&t;The algorithm is from the SIGCOMM 88 piece by Van Jacobson.&n; */
DECL|function|tcp_rtt_estimator
r_extern
id|__inline__
r_void
id|tcp_rtt_estimator
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
id|__u32
id|mrtt
)paren
(brace
r_int
id|m
suffix:semicolon
multiline_comment|/*&n;&t; *&t;The following amusing code comes from Jacobson&squot;s&n;&t; *&t;article in SIGCOMM &squot;88.  Note that rtt and mdev&n;&t; *&t;are scaled versions of rtt and mean deviation.&n;&t; *&t;This is designed to be as fast as possible &n;&t; *&t;m stands for &quot;measurement&quot;.&n;&t; */
multiline_comment|/*&n;&t; *&t;On a 1990 paper the rto value is changed to:&n;&t; *&t;RTO = rtt + 4 * mdev&n;&t; */
id|m
op_assign
id|mrtt
suffix:semicolon
multiline_comment|/* RTT */
r_if
c_cond
(paren
id|tp-&gt;srtt
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|m
op_le
l_int|0
)paren
(brace
id|m
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* IS THIS RIGHT FOR &lt;0 ??? */
id|m
op_sub_assign
(paren
id|tp-&gt;srtt
op_rshift
l_int|3
)paren
suffix:semicolon
multiline_comment|/* m is now error in rtt est */
id|tp-&gt;srtt
op_add_assign
id|m
suffix:semicolon
multiline_comment|/* rtt = 7/8 rtt + 1/8 new */
r_if
c_cond
(paren
id|m
OL
l_int|0
)paren
id|m
op_assign
op_minus
id|m
suffix:semicolon
multiline_comment|/* m is now abs(error) */
id|m
op_sub_assign
(paren
id|tp-&gt;mdev
op_rshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* similar update on mdev */
id|tp-&gt;mdev
op_add_assign
id|m
suffix:semicolon
multiline_comment|/* mdev = 3/4 mdev + 1/4 new */
)brace
r_else
(brace
multiline_comment|/* no previous measure. */
id|tp-&gt;srtt
op_assign
id|m
op_lshift
l_int|3
suffix:semicolon
multiline_comment|/* take the measured time to be rtt */
id|tp-&gt;mdev
op_assign
id|m
op_lshift
l_int|2
suffix:semicolon
multiline_comment|/* make sure rto = 3*rtt */
)brace
multiline_comment|/*&n;&t; *&t;Now update timeout.  Note that this removes any backoff.&n;&t; */
id|tp-&gt;rto
op_assign
(paren
id|tp-&gt;srtt
op_rshift
l_int|3
)paren
op_plus
id|tp-&gt;mdev
suffix:semicolon
id|tp-&gt;rto
op_add_assign
(paren
id|tp-&gt;rto
op_rshift
l_int|2
)paren
op_plus
(paren
id|tp-&gt;rto
op_rshift
(paren
id|tp-&gt;snd_cwnd
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;rto
OG
l_int|120
op_star
id|HZ
)paren
id|tp-&gt;rto
op_assign
l_int|120
op_star
id|HZ
suffix:semicolon
multiline_comment|/* Was 1*HZ - keep .2 as minimum cos of the BSD delayed acks &n;&t; * FIXME: It&squot;s not entirely clear this lower bound is the best&n;&t; * way to avoid the problem. Is it possible to drop the lower&n;&t; * bound and still avoid trouble with BSD stacks? Perhaps&n;&t; * some modification to the RTO calculation that takes delayed&n;&t; * ack bais into account? This needs serious thought. -- erics&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;rto
OL
id|HZ
op_div
l_int|5
)paren
id|tp-&gt;rto
op_assign
id|HZ
op_div
l_int|5
suffix:semicolon
id|tp-&gt;backoff
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|__tcp_sequence
r_static
r_int
id|__tcp_sequence
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
id|u32
id|seq
comma
id|u32
id|end_seq
)paren
(brace
id|u32
id|end_window
suffix:semicolon
id|end_window
op_assign
id|tp-&gt;rcv_wup
op_plus
id|tp-&gt;rcv_wnd
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;rcv_wnd
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|before
c_func
(paren
id|seq
comma
id|tp-&gt;rcv_nxt
)paren
op_logical_and
id|before
c_func
(paren
id|seq
comma
id|end_window
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|end_seq
op_minus
id|seq
)paren
op_logical_and
id|after
c_func
(paren
id|end_seq
comma
id|tp-&gt;rcv_nxt
)paren
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|end_seq
comma
id|end_window
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This functions checks to see if the tcp header is actually acceptable. &n; */
DECL|function|tcp_sequence
r_extern
id|__inline__
r_int
id|tcp_sequence
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
id|u32
id|seq
comma
id|u32
id|end_seq
)paren
(brace
r_if
c_cond
(paren
id|seq
op_eq
id|tp-&gt;rcv_nxt
)paren
(brace
r_return
(paren
id|tp-&gt;rcv_wnd
op_logical_or
(paren
id|end_seq
op_eq
id|seq
)paren
)paren
suffix:semicolon
)brace
r_return
id|__tcp_sequence
c_func
(paren
id|tp
comma
id|seq
comma
id|end_seq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;When we get a reset we do this. This probably is a tcp_output routine&n; *&t;really.&n; */
DECL|function|tcp_reset
r_static
r_int
id|tcp_reset
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|sk-&gt;zapped
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We want the right error as BSD sees it (and indeed as we do).&n;&t; */
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_TIME_WAIT
suffix:colon
r_break
suffix:semicolon
r_case
id|TCP_SYN_SENT
suffix:colon
id|sk-&gt;err
op_assign
id|ECONNREFUSED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE_WAIT
suffix:colon
id|sk-&gt;err
op_assign
id|EPIPE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|sk-&gt;err
op_assign
id|ECONNRESET
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_TCP_RFC1337
multiline_comment|/*&n;&t; *&t;Time wait assassination protection [RFC1337]&n;&t; *&n;&t; *&t;This is a good idea, but causes more sockets to take time to close.&n;&t; *&n;&t; *&t;Ian Heavens has since shown this is an inadequate fix for the protocol&n;&t; *&t;bug in question.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_TIME_WAIT
)paren
(brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
)brace
macro_line|#else&t;
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
macro_line|#endif&t;
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Look for tcp options. Parses everything but only knows about MSS.&n; *&t;This routine is always called with the packet containing the SYN.&n; *&t;However it may also be called with the ack to the SYN.  So you&n; *&t;can&squot;t assume this is always the SYN.  It&squot;s always called after&n; *&t;we have set up sk-&gt;mtu to our own MTU.&n; *&n; *&t;We need at minimum to add PAWS support here. Possibly large windows&n; *&t;as Linux gets deployed on 100Mb/sec networks.&n; */
DECL|function|tcp_parse_options
r_int
id|tcp_parse_options
c_func
(paren
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|length
op_assign
(paren
id|th-&gt;doff
op_star
l_int|4
)paren
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
r_int
id|mss
op_assign
l_int|0
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|length
OG
l_int|0
)paren
(brace
r_int
id|opcode
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_int
id|opsize
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|TCPOPT_EOL
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|TCPOPT_NOP
suffix:colon
multiline_comment|/* Ref: RFC 793 section 3.1 */
id|length
op_decrement
suffix:semicolon
id|ptr
op_decrement
suffix:semicolon
multiline_comment|/* the opsize=*ptr++ above was a mistake */
r_continue
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|opsize
op_le
l_int|2
)paren
(brace
multiline_comment|/* Avoid silly options looping forever */
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|TCPOPT_MSS
suffix:colon
r_if
c_cond
(paren
id|opsize
op_eq
id|TCPOLEN_MSS
op_logical_and
id|th-&gt;syn
)paren
(brace
id|mss
op_assign
id|ntohs
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|ptr
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* Add other options here as people feel the urge to implement stuff like large windows */
)brace
id|ptr
op_add_assign
id|opsize
op_minus
l_int|2
suffix:semicolon
id|length
op_sub_assign
id|opsize
suffix:semicolon
)brace
)brace
r_return
id|mss
suffix:semicolon
)brace
multiline_comment|/* &n; *  See draft-stevens-tcpca-spec-01 for documentation.&n; */
DECL|function|tcp_fast_retrans
r_static
r_void
id|tcp_fast_retrans
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|ack
comma
r_int
id|not_dup
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/* FIXME: if we are already retransmitting should this code&n;&t; * be skipped? [Floyd high_seq check sort of does this]&n;&t; * The case I&squot;m worried about is falling into a fast&n;&t; * retransmit on a link with a congestion window of 1 or 2.&n;&t; * There was some evidence in 2.0.x that this was problem&n;&t; * on really slow links (1200 or 2400 baud). I need to&n;&t; * try this situation again and see what happens.&n;&t; */
multiline_comment|/*&n;&t; * An ACK is a duplicate if:&n;&t; * (1) it has the same sequence number as the largest number we&squot;ve &n;&t; *     seen,&n;&t; * (2) it has the same window as the last ACK,&n;&t; * (3) we have outstanding data that has not been ACKed&n;&t; * (4) The packet was not carrying any data.&n;&t; * (5) [From Floyds paper on fast retransmit wars]&n;&t; *     The packet acked data after high_seq;&n;&t; */
r_if
c_cond
(paren
id|ack
op_eq
id|tp-&gt;snd_una
op_logical_and
id|sk-&gt;packets_out
op_logical_and
(paren
id|not_dup
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * 1. When the third duplicate ack is received, set ssthresh &n;&t;&t; * to one half the current congestion window, but no less &n;&t;&t; * than two segments. Retransmit the missing segment.&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;high_seq
op_eq
l_int|0
op_logical_or
id|after
c_func
(paren
id|ack
comma
id|tp-&gt;high_seq
)paren
)paren
(brace
id|sk-&gt;dup_acks
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;dup_acks
op_eq
l_int|3
)paren
(brace
id|sk-&gt;ssthresh
op_assign
id|max
c_func
(paren
id|tp-&gt;snd_cwnd
op_rshift
l_int|1
comma
l_int|2
)paren
suffix:semicolon
id|tp-&gt;snd_cwnd
op_assign
id|sk-&gt;ssthresh
op_plus
l_int|3
suffix:semicolon
id|tcp_do_retransmit
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* careful not to timeout just after fast&n;&t;&t;&t;&t; * retransmit!&n;&t;&t;&t;&t; */
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * 2. Each time another duplicate ACK arrives, increment &n;&t;&t; * cwnd by the segment size. [...] Transmit a packet...&n;&t;&t; *&n;&t;&t; * Packet transmission will be done on normal flow processing&n;&t;&t; * since we&squot;re not in &quot;retransmit mode&quot;&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;dup_acks
op_ge
l_int|3
)paren
(brace
id|sk-&gt;dup_acks
op_increment
suffix:semicolon
id|tp-&gt;snd_cwnd
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * 3. When the next ACK arrives that acknowledges new data,&n;&t;&t; *    set cwnd to ssthresh&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;dup_acks
op_ge
l_int|3
)paren
(brace
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
id|tp-&gt;snd_cwnd
op_assign
id|max
c_func
(paren
id|sk-&gt;ssthresh
comma
l_int|1
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|sk-&gt;retransmits
comma
l_int|0
)paren
suffix:semicolon
)brace
id|sk-&gt;dup_acks
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;high_seq
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *      TCP slow start and congestion avoidance in two flavors:&n; *      RFC 1122 and TCP Vegas.&n; *&n; *      This is a /proc/sys configurable option. &n; */
DECL|macro|SHIFT_FACTOR
mdefine_line|#define SHIFT_FACTOR 16
DECL|function|tcp_cong_avoid_vegas
r_static
r_void
id|tcp_cong_avoid_vegas
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|seq
comma
id|u32
id|ack
comma
id|u32
id|seq_rtt
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
suffix:semicolon
r_int
r_int
id|actual
comma
id|expected
suffix:semicolon
r_int
r_int
id|inv_rtt
comma
id|inv_basertt
comma
id|inv_basebd
suffix:semicolon
id|u32
id|snt_bytes
suffix:semicolon
multiline_comment|/*&n;&t; *&t;From:&n;&t; *      TCP Vegas: New Techniques for Congestion &n;&t; *&t;Detection and Avoidance.&n;&t; *&n;&t; *&n;&t; *&t;Warning: This code is a scratch implementation taken&n;&t; *&t;from the paper only. The code they distribute seams&n;&t; *&t;to have improved several things over the initial spec.&n;&t; */
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|seq_rtt
)paren
id|seq_rtt
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;basertt
)paren
id|tp-&gt;basertt
op_assign
id|min
c_func
(paren
id|seq_rtt
comma
id|tp-&gt;basertt
)paren
suffix:semicolon
r_else
id|tp-&gt;basertt
op_assign
id|seq_rtt
suffix:semicolon
multiline_comment|/*&n;&t; * &n;&t; *&t;actual&t; = throughput for this segment.&n;&t; *&t;expected = number_of_bytes in transit / BaseRTT&n;&t; * &n;&t; */
id|snt_bytes
op_assign
id|ack
op_minus
id|seq
suffix:semicolon
id|inv_rtt
op_assign
(paren
l_int|1
op_lshift
id|SHIFT_FACTOR
)paren
op_div
id|seq_rtt
suffix:semicolon
id|inv_basertt
op_assign
(paren
l_int|1
op_lshift
id|SHIFT_FACTOR
)paren
op_div
id|tp-&gt;basertt
suffix:semicolon
id|actual
op_assign
id|snt_bytes
op_star
id|inv_rtt
suffix:semicolon
id|expected
op_assign
(paren
id|tp-&gt;snd_nxt
op_minus
id|tp-&gt;snd_una
)paren
op_star
id|inv_basertt
suffix:semicolon
id|inv_basebd
op_assign
id|sk-&gt;mss
op_star
id|inv_basertt
suffix:semicolon
multiline_comment|/*&n;&t; *      Slow Start&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd
OL
id|sk-&gt;ssthresh
op_logical_and
(paren
id|seq
op_eq
id|tp-&gt;snd_nxt
op_logical_or
(paren
id|expected
op_minus
id|actual
op_le
id|TCP_VEGAS_GAMMA
op_star
id|inv_basebd
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * &quot;Vegas allows exponential growth only every other&n;&t;&t; *  RTT&quot;&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;cong_count
op_increment
)paren
(brace
id|tp-&gt;snd_cwnd
op_increment
suffix:semicolon
id|sk-&gt;cong_count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; *      Congestion Avoidance&n;&t;&t; */
r_if
c_cond
(paren
id|expected
op_minus
id|actual
op_le
id|TCP_VEGAS_ALPHA
op_star
id|inv_basebd
)paren
(brace
multiline_comment|/* Increase Linearly */
r_if
c_cond
(paren
id|sk-&gt;cong_count
op_increment
op_ge
id|tp-&gt;snd_cwnd
)paren
(brace
id|tp-&gt;snd_cwnd
op_increment
suffix:semicolon
id|sk-&gt;cong_count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|expected
op_minus
id|actual
op_ge
id|TCP_VEGAS_BETA
op_star
id|inv_basebd
)paren
(brace
multiline_comment|/* Decrease Linearly */
r_if
c_cond
(paren
id|sk-&gt;cong_count
op_increment
op_ge
id|tp-&gt;snd_cwnd
)paren
(brace
id|tp-&gt;snd_cwnd
op_decrement
suffix:semicolon
id|sk-&gt;cong_count
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Never less than 2 segments */
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd
OL
l_int|2
)paren
id|tp-&gt;snd_cwnd
op_assign
l_int|2
suffix:semicolon
)brace
)brace
)brace
DECL|function|tcp_cong_avoid_vanj
r_static
r_void
id|tcp_cong_avoid_vanj
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|seq
comma
id|u32
id|ack
comma
id|u32
id|seq_rtt
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/* &n;         * This is Jacobson&squot;s slow start and congestion avoidance. &n;         * SIGCOMM &squot;88, p. 328.  Because we keep cong_window in &n;         * integral mss&squot;s, we can&squot;t do cwnd += 1 / cwnd.  &n;         * Instead, maintain a counter and increment it once every &n;         * cwnd times.  &n;&t; * FIXME: Check to be sure the mathematics works out right&n;&t; * on this trick when we have to reduce the congestion window.&n;&t; * The cong_count has to be reset properly when reduction events&n;&t; * happen.&n;&t; * FIXME: What happens when the congestion window gets larger&n;&t; * than the maximum receiver window by some large factor&n;&t; * Suppose the pipeline never looses packets for a long&n;&t; * period of time, then traffic increases causing packet loss.&n;&t; * The congestion window should be reduced, but what it should&n;&t; * be reduced to is not clear, since 1/2 the old window may&n;&t; * still be larger than the maximum sending rate we ever achieved.&n;         */
r_if
c_cond
(paren
id|tp-&gt;snd_cwnd
op_le
id|sk-&gt;ssthresh
)paren
(brace
multiline_comment|/* &n;                 *&t;In &quot;safe&quot; area, increase&n;                 */
id|tp-&gt;snd_cwnd
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;                 *&t;In dangerous area, increase slowly.  &n;                 *      In theory this is&n;                 *  &t;tp-&gt;snd_cwnd += 1 / tp-&gt;snd_cwnd&n;                 */
r_if
c_cond
(paren
id|sk-&gt;cong_count
op_ge
id|tp-&gt;snd_cwnd
)paren
(brace
id|tp-&gt;snd_cwnd
op_increment
suffix:semicolon
id|sk-&gt;cong_count
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|sk-&gt;cong_count
op_increment
suffix:semicolon
)brace
)brace
DECL|macro|FLAG_DATA
mdefine_line|#define FLAG_DATA&t;&t;0x01
DECL|macro|FLAG_WIN_UPDATE
mdefine_line|#define FLAG_WIN_UPDATE&t;&t;0x02
DECL|macro|FLAG_DATA_ACKED
mdefine_line|#define FLAG_DATA_ACKED&t;&t;0x04
DECL|function|tcp_clean_rtx_queue
r_static
r_int
id|tcp_clean_rtx_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|__u32
id|ack
comma
id|__u32
op_star
id|seq
comma
id|__u32
op_star
id|seq_rtt
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_int
id|acked
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
op_logical_and
(paren
id|skb
op_ne
id|tp-&gt;send_head
)paren
)paren
(brace
macro_line|#ifdef TCP_DEBUG
multiline_comment|/* Check for a bug. */
r_if
c_cond
(paren
id|skb-&gt;next
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
op_logical_and
id|after
c_func
(paren
id|skb-&gt;end_seq
comma
id|skb-&gt;next-&gt;seq
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;INET: tcp_input.c: *** &quot;
l_string|&quot;bug send_list out of order.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;&t;&t;&t;&t;
multiline_comment|/*&n;&t;&t; *&t;If our packet is before the ack sequence we can&n;&t;&t; *&t;discard it as it&squot;s confirmed to have arrived the &n;&t;&t; *&t;other end.&n;&t;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|skb-&gt;end_seq
comma
id|ack
)paren
)paren
r_break
suffix:semicolon
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;removing seg %x-%x from retransmit queue&bslash;n&quot;
comma
id|skb-&gt;seq
comma
id|skb-&gt;end_seq
)paren
suffix:semicolon
id|acked
op_assign
id|FLAG_DATA_ACKED
suffix:semicolon
multiline_comment|/* FIXME: packet counting may break if we have to&n;&t;&t; * do packet &quot;repackaging&quot; for stacks that don&squot;t&n;&t;&t; * like overlapping packets.&n;&t;&t; */
id|sk-&gt;packets_out
op_decrement
suffix:semicolon
op_star
id|seq
op_assign
id|skb-&gt;seq
suffix:semicolon
op_star
id|seq_rtt
op_assign
id|now
op_minus
id|skb-&gt;when
suffix:semicolon
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|acked
)paren
(brace
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_return
id|acked
suffix:semicolon
)brace
DECL|function|tcp_ack_probe
r_static
r_void
id|tcp_ack_probe
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|__u32
id|ack
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Our probe was answered&n;&t; */
id|tp-&gt;probes_out
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Was it a usable window open ?&n;&t; */
multiline_comment|/* should always be non-null */
r_if
c_cond
(paren
id|tp-&gt;send_head
op_ne
l_int|NULL
op_logical_and
op_logical_neg
id|before
(paren
id|ack
op_plus
id|tp-&gt;snd_wnd
comma
id|tp-&gt;send_head-&gt;end_seq
)paren
)paren
(brace
id|tp-&gt;backoff
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;pending
op_assign
l_int|0
suffix:semicolon
id|tcp_clear_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_PROBE0
)paren
suffix:semicolon
)brace
r_else
(brace
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|min
c_func
(paren
id|tp-&gt;rto
op_lshift
id|tp-&gt;backoff
comma
l_int|120
op_star
id|HZ
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;This routine deals with incoming acks, but not outgoing ones.&n; */
DECL|function|tcp_ack
r_static
r_int
id|tcp_ack
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
id|u32
id|ack_seq
comma
id|u32
id|ack
comma
r_int
id|len
)paren
(brace
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
id|u32
id|seq
op_assign
l_int|0
suffix:semicolon
id|u32
id|seq_rtt
op_assign
l_int|0
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Dead, can&squot;t ack any more so why bother */
r_if
c_cond
(paren
id|tp-&gt;pending
op_eq
id|TIME_KEEPOPEN
)paren
(brace
id|tp-&gt;probes_out
op_assign
l_int|0
suffix:semicolon
)brace
id|tp-&gt;rcv_tstamp
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If the ack is newer than sent or older than previous acks&n;&t; *&t;then we can probably ignore it.&n;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|ack
comma
id|tp-&gt;snd_nxt
)paren
op_logical_or
id|before
c_func
(paren
id|ack
comma
id|tp-&gt;snd_una
)paren
)paren
r_goto
id|uninteresting_ack
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If there is data set flag 1&n;&t; */
r_if
c_cond
(paren
id|len
op_ne
id|th-&gt;doff
op_star
l_int|4
)paren
(brace
id|flag
op_or_assign
id|FLAG_DATA
suffix:semicolon
id|tcp_delack_estimator
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Update our send window&n;&t; */
multiline_comment|/*&n;&t; *&t;This is the window update code as per RFC 793&n;&t; *&t;snd_wl{1,2} are used to prevent unordered&n;&t; *&t;segments from shrinking the window &n;&t; */
r_if
c_cond
(paren
id|before
c_func
(paren
id|tp-&gt;snd_wl1
comma
id|ack_seq
)paren
op_logical_or
(paren
id|tp-&gt;snd_wl1
op_eq
id|ack_seq
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|tp-&gt;snd_wl2
comma
id|ack
)paren
)paren
)paren
(brace
r_int
r_int
id|nwin
suffix:semicolon
id|nwin
op_assign
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;snd_wl2
op_ne
id|ack
)paren
op_logical_or
(paren
id|nwin
OG
id|tp-&gt;snd_wnd
)paren
)paren
(brace
id|flag
op_or_assign
id|FLAG_WIN_UPDATE
suffix:semicolon
id|tp-&gt;snd_wnd
op_assign
id|nwin
suffix:semicolon
id|tp-&gt;snd_wl1
op_assign
id|ack_seq
suffix:semicolon
id|tp-&gt;snd_wl2
op_assign
id|ack
suffix:semicolon
r_if
c_cond
(paren
id|nwin
OG
id|sk-&gt;max_window
)paren
id|sk-&gt;max_window
op_assign
id|nwin
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;We passed data and got it acked, remove any soft error&n;&t; *&t;log. Something worked...&n;&t; */
id|sk-&gt;err_soft
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If this ack opens up a zero window, clear backoff.  It was&n;&t; *&t;being used to time the probes, and is probably far higher than&n;&t; *&t;it needs to be for normal retransmission.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;pending
op_eq
id|TIME_PROBE0
)paren
(brace
id|tcp_ack_probe
c_func
(paren
id|sk
comma
id|ack
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t; *&t;See if we can take anything off of the retransmit queue.&n;&t; */
r_if
c_cond
(paren
id|tcp_clean_rtx_queue
c_func
(paren
id|sk
comma
id|ack
comma
op_amp
id|seq
comma
op_amp
id|seq_rtt
)paren
)paren
id|flag
op_or_assign
id|FLAG_DATA_ACKED
suffix:semicolon
multiline_comment|/*&n;&t; *&t;if we where retransmiting don&squot;t count rtt estimate&n;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;retransmits
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;packets_out
op_eq
l_int|0
)paren
id|atomic_set
c_func
(paren
op_amp
id|sk-&gt;retransmits
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Note that we only reset backoff and rto in the&n;&t;&t; * rtt recomputation code.  And that doesn&squot;t happen&n;&t;&t; * if there were retransmissions in effect.  So the&n;&t;&t; * first new packet after the retransmissions is&n;&t;&t; * sent with the backoff still in effect.  Not until&n;&t;&t; * we get an ack from a non-retransmitted packet do&n;&t;&t; * we reset the backoff and rto.  This allows us to deal&n;&t;&t; * with a situation where the network delay has increased&n;&t;&t; * suddenly.  I.e. Karn&squot;s algorithm. (SIGCOMM &squot;87, p5.)&n;&t;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|FLAG_DATA_ACKED
)paren
(brace
id|tcp_rtt_estimator
c_func
(paren
id|tp
comma
id|seq_rtt
)paren
suffix:semicolon
(paren
op_star
id|tcp_sys_cong_ctl_f
)paren
(paren
id|sk
comma
id|seq
comma
id|ack
comma
id|seq_rtt
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sk-&gt;packets_out
)paren
(brace
r_if
c_cond
(paren
id|flag
op_amp
id|FLAG_DATA_ACKED
)paren
(brace
r_int
id|when
suffix:semicolon
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
id|when
op_assign
id|tp-&gt;rto
op_minus
(paren
id|jiffies
op_minus
id|skb-&gt;when
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * FIXME: This assumes that when we are retransmitting&n;&t;&t;&t; * we should only ever respond with one packet.&n;&t;&t;&t; * This means congestion windows should not grow&n;&t;&t;&t; * during recovery. In 2.0.X we allow the congestion&n;&t;&t;&t; * window to grow. It is not clear to me which&n;&t;&t;&t; * decision is correct. The RFCs should be double&n;&t;&t;&t; * checked as should the behavior of other stacks.&n;&t;&t;&t; * Also note that if we do want to allow the&n;&t;&t;&t; * congestion window to grow during retransmits&n;&t;&t;&t; * we have to fix the call to congestion window&n;&t;&t;&t; * updates so that it works during retransmission.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;retransmits
)paren
)paren
(brace
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * This is tricky. We are retransmiting a &n;&t;&t;&t;&t; * segment of a window when congestion occured.&n;&t;&t;&t;&t; */
id|tcp_do_retransmit
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
r_else
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|when
)paren
suffix:semicolon
)brace
)brace
r_else
id|tcp_clear_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
)paren
suffix:semicolon
multiline_comment|/* FIXME: danger, if we just did a timeout and got the third&n;&t; * ack on this packet, then this is going to send it again!&n;&t; * [No. Floyd retransmit war check keeps this from happening. -- erics]&n;&t; */
id|tcp_fast_retrans
c_func
(paren
id|sk
comma
id|ack
comma
(paren
id|flag
op_amp
(paren
id|FLAG_DATA
op_or
id|FLAG_WIN_UPDATE
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Remember the highest ack received.&n;&t; */
id|tp-&gt;snd_una
op_assign
id|ack
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|uninteresting_ack
suffix:colon
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;Ack ignored %u %u&bslash;n&quot;
comma
id|ack
comma
id|tp-&gt;snd_nxt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Process the FIN bit. This now behaves as it is supposed to work&n; *&t;and the FIN takes effect when it is validly part of sequence&n; *&t;space. Not before when we get holes.&n; *&n; *&t;If we are ESTABLISHED, a received fin moves us to CLOSE-WAIT&n; *&t;(and thence onto LAST-ACK and finally, CLOSE, we never enter&n; *&t;TIME-WAIT)&n; *&n; *&t;If we are in FINWAIT-1, a received FIN indicates simultaneous&n; *&t;close and we go into CLOSING (and later onto TIME-WAIT)&n; *&n; *&t;If we are in FINWAIT-2, a received FIN moves us to TIME-WAIT.&n; *&n; */
DECL|function|tcp_fin
r_static
r_int
id|tcp_fin
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
id|sk-&gt;fin_seq
op_assign
id|skb-&gt;end_seq
suffix:semicolon
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sock_wake_async
c_func
(paren
id|sk-&gt;socket
comma
l_int|1
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_SYN_RECV
suffix:colon
r_case
id|TCP_SYN_SENT
suffix:colon
r_case
id|TCP_ESTABLISHED
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * move to CLOSE_WAIT&n;&t;&t;&t; */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE_WAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;rst
)paren
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE_WAIT
suffix:colon
r_case
id|TCP_CLOSING
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * received a retransmission of the FIN, do&n;&t;&t;&t; * nothing.&n;&t;&t;&t; */
r_break
suffix:semicolon
r_case
id|TCP_TIME_WAIT
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * received a retransmission of the FIN,&n;&t;&t;&t; * restart the TIME_WAIT timer.&n;&t;&t;&t; */
id|tcp_reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TCP_FIN_WAIT1
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * This case occurs when a simultaneous close&n;&t;&t;&t; * happens, we must ack the received FIN and&n;&t;&t;&t; * enter the CLOSING state.&n;&t;&t;&t; *&n;&t;&t;&t; * This causes a WRITE timeout, which will either&n;&t;&t;&t; * move on to TIME_WAIT when we timeout, or resend&n;&t;&t;&t; * the FIN properly (maybe we get rid of that annoying&n;&t;&t;&t; * FIN lost hang). The TIME_WRITE code is already &n;&t;&t;&t; * correct for handling this timeout.&n;&t;&t;&t; */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSING
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_FIN_WAIT2
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * received a FIN -- send ACK and enter TIME_WAIT&n;&t;&t;&t; */
id|tcp_reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_or_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_TIME_WAIT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * already in CLOSE&n;&t;&t;&t; */
r_break
suffix:semicolon
r_default
suffix:colon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_LAST_ACK
)paren
suffix:semicolon
multiline_comment|/* Start the timers. */
id|tcp_reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This one checks to see if we can put data from the&n;&t; * out_of_order queue into the receive_queue&n;&t; */
DECL|function|tcp_ofo_queue
r_static
r_void
id|tcp_ofo_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;out_of_order_queue
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|after
c_func
(paren
id|skb-&gt;seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|skb-&gt;end_seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;ofo packet was allready received &bslash;n&quot;
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;ofo requeuing : rcv_next %X seq %X - %X&bslash;n&quot;
comma
id|tp-&gt;rcv_nxt
comma
id|skb-&gt;seq
comma
id|skb-&gt;end_seq
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
id|tp-&gt;rcv_nxt
op_assign
id|skb-&gt;end_seq
suffix:semicolon
)brace
)brace
DECL|function|tcp_data_queue
r_static
r_void
id|tcp_data_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb1
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Queue data for delivery to the user&n;&t; *  Packets in sequence go to the receive queue&n;&t; *  Out of sequence packets to out_of_order_queue&n;&t; */
r_if
c_cond
(paren
id|skb-&gt;seq
op_eq
id|tp-&gt;rcv_nxt
)paren
(brace
multiline_comment|/*&n;&t;&t; * Ok. In sequence.&n;&t;&t; */
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
id|tp-&gt;rcv_nxt
op_assign
id|skb-&gt;end_seq
suffix:semicolon
id|tcp_ofo_queue
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|sk-&gt;out_of_order_queue
)paren
op_eq
l_int|0
)paren
id|tp-&gt;pred_flags
op_assign
id|htonl
c_func
(paren
(paren
l_int|0x5010
op_lshift
l_int|16
)paren
op_or
id|tp-&gt;snd_wnd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Not in sequence&n;&t; *  either a retransmit or some packet got lost&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|skb-&gt;end_seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t; * A retransmit.&n;&t;&t; * 2nd most common case.&n;&t;&t; * force an imediate ack&n;&t;&t; */
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;retransmit received: seq %X&bslash;n&quot;
comma
id|skb-&gt;seq
)paren
suffix:semicolon
id|sk-&gt;delayed_acks
op_assign
id|MAX_DELAY_ACK
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|skb-&gt;seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Partial packet&n;&t;&t; * seq &lt; rcv_next &lt; end_seq&n;&t;&t; */
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;partial packet: rcv_next %X seq %X - %X&bslash;n&quot;
comma
id|tp-&gt;rcv_nxt
comma
id|skb-&gt;seq
comma
id|skb-&gt;end_seq
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
id|tp-&gt;rcv_nxt
op_assign
id|skb-&gt;end_seq
suffix:semicolon
id|tcp_ofo_queue
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|sk-&gt;out_of_order_queue
)paren
op_eq
l_int|0
)paren
id|tp-&gt;pred_flags
op_assign
id|htonl
c_func
(paren
(paren
l_int|0x5010
op_lshift
l_int|16
)paren
op_or
id|tp-&gt;snd_wnd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Ok. This is an out_of_order segment&n;&t; */
multiline_comment|/* Force an ack */
id|sk-&gt;delayed_acks
op_assign
id|MAX_DELAY_ACK
suffix:semicolon
multiline_comment|/*&n;&t; *&t;disable header predition&n;&t; */
id|tp-&gt;pred_flags
op_assign
l_int|0
suffix:semicolon
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;out of order segment: rcv_next %X seq %X - %X&bslash;n&quot;
comma
id|tp-&gt;rcv_nxt
comma
id|skb-&gt;seq
comma
id|skb-&gt;end_seq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;out_of_order_queue
)paren
op_eq
l_int|NULL
)paren
(brace
id|skb_queue_head
c_func
(paren
op_amp
id|sk-&gt;out_of_order_queue
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
r_for
c_loop
(paren
id|skb1
op_assign
id|sk-&gt;out_of_order_queue.prev
suffix:semicolon
suffix:semicolon
id|skb1
op_assign
id|skb1-&gt;prev
)paren
(brace
multiline_comment|/* allready there */
r_if
c_cond
(paren
id|skb-&gt;seq
op_eq
id|skb1-&gt;seq
op_logical_and
id|skb-&gt;len
op_ge
id|skb1-&gt;len
)paren
(brace
id|skb_append
c_func
(paren
id|skb1
comma
id|skb
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|skb1
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb1
comma
id|FREE_READ
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|after
c_func
(paren
id|skb-&gt;seq
comma
id|skb1-&gt;seq
)paren
)paren
(brace
id|skb_append
c_func
(paren
id|skb1
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;See if we&squot;ve hit the start. If so insert.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb1
op_eq
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;out_of_order_queue
)paren
)paren
(brace
id|skb_queue_head
c_func
(paren
op_amp
id|sk-&gt;out_of_order_queue
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; *&t;This routine handles the data.  If there is room in the buffer,&n; *&t;it will be have already been moved into it.  If there is no&n; *&t;room, then we will just have to discard the packet.&n; */
DECL|function|tcp_data
r_static
r_int
id|tcp_data
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|th-&gt;doff
op_star
l_int|4
)paren
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
id|len
op_minus
(paren
id|th-&gt;doff
op_star
l_int|4
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
op_eq
l_int|0
op_logical_and
op_logical_neg
id|th-&gt;fin
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;FIXME: don&squot;t accept data after the receved fin&n;&t; */
multiline_comment|/*&n;&t; *&t;The bytes in the receive read/assembly queue has increased. &n;&t; *&t;Needed for the low memory discard algorithm &n;&t; */
id|sk-&gt;bytes_rcv
op_add_assign
id|skb-&gt;len
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We no longer have anyone receiving data on this connection.&n;&t; */
id|tcp_data_queue
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|before
c_func
(paren
id|tp-&gt;rcv_nxt
comma
id|sk-&gt;copied_seq
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;*** tcp.c:tcp_data bug acked &lt; copied&bslash;n&quot;
)paren
suffix:semicolon
id|tp-&gt;rcv_nxt
op_assign
id|sk-&gt;copied_seq
suffix:semicolon
)brace
id|sk-&gt;delayed_acks
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now tell the user we may have some data. &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;Data wakeup.&bslash;n&quot;
)paren
suffix:semicolon
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|tcp_data_snd_check
r_static
r_void
id|tcp_data_snd_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|tp-&gt;send_head
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|skb-&gt;end_seq
comma
id|tp-&gt;snd_una
op_plus
id|tp-&gt;snd_wnd
)paren
op_logical_and
id|sk-&gt;packets_out
OL
id|tp-&gt;snd_cwnd
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Add more data to the send queue.&n;&t;&t;&t; */
multiline_comment|/* FIXME: the congestion window is checked&n;&t;&t;&t; * again in tcp_write_xmit anyway?!&n;&t;&t;&t; */
id|tcp_write_xmit
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|sk-&gt;packets_out
op_eq
l_int|0
op_logical_and
op_logical_neg
id|tp-&gt;pending
)paren
(brace
multiline_comment|/*&n; &t;&t;&t; *&t;Data to queue but no room.&n; &t;&t;&t; */
multiline_comment|/* FIXME: Is it right to do a zero window probe into&n;&t;&t;&t; * a congestion window limited window???&n;&t;&t;&t; */
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|tcp_ack_snd_check
r_static
id|__inline__
r_void
id|tcp_ack_snd_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
multiline_comment|/*&n;&t; *&t;This also takes care of updating the window.&n;&t; *&t;This if statement needs to be simplified.&n;&t; *&n;&t; *      rules for delaying an ack:&n;&t; *      - delay time &lt;= 0.5 HZ&n;&t; *      - we don&squot;t have a window update to send&n;&t; *      - must send at least every 2 full sized packets&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;delayed_acks
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;We sent a data segment already&n;&t;&t; */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;delayed_acks
op_ge
id|MAX_DELAY_ACK
op_logical_or
id|tcp_raise_window
c_func
(paren
id|sk
)paren
)paren
(brace
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
id|tcp_send_delayed_ack
c_func
(paren
id|sk
comma
id|HZ
op_div
l_int|2
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;This routine is only called when we have urgent data&n; *&t;signalled. Its the &squot;slow&squot; part of tcp_urg. It could be&n; *&t;moved inline now as tcp_urg is only called from one&n; *&t;place. We handle URGent data wrong. We have to - as&n; *&t;BSD still doesn&squot;t use the correction from RFC961.&n; *&t;For 1003.1g we should support a new option TCP_STDURG to permit&n; *&t;either form.&n; */
DECL|function|tcp_check_urg
r_static
r_void
id|tcp_check_urg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|u32
id|ptr
op_assign
id|ntohs
c_func
(paren
id|th-&gt;urg_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
id|ptr
op_decrement
suffix:semicolon
id|ptr
op_add_assign
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
suffix:semicolon
multiline_comment|/* ignore urgent data that we&squot;ve already seen and read */
r_if
c_cond
(paren
id|after
c_func
(paren
id|sk-&gt;copied_seq
comma
id|ptr
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* do we already have a newer (or duplicate) urgent pointer? */
r_if
c_cond
(paren
id|sk-&gt;urg_data
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|ptr
comma
id|sk-&gt;urg_seq
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* tell the world about our new urgent pointer */
r_if
c_cond
(paren
id|sk-&gt;proc
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;proc
OG
l_int|0
)paren
(brace
id|kill_proc
c_func
(paren
id|sk-&gt;proc
comma
id|SIGURG
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|kill_pg
c_func
(paren
op_minus
id|sk-&gt;proc
comma
id|SIGURG
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;We may be adding urgent data when the last byte read was&n;&t; *&t;urgent. To do this requires some care. We cannot just ignore&n;&t; *&t;sk-&gt;copied_seq since we would read the last urgent byte again&n;&t; *&t;as data, nor can we alter copied_seq until this data arrives&n;&t; *&t;or we break the sematics of SIOCATMARK (and thus sockatmark())&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;urg_seq
op_eq
id|sk-&gt;copied_seq
)paren
id|sk-&gt;copied_seq
op_increment
suffix:semicolon
multiline_comment|/* Move the copied sequence on correctly */
id|sk-&gt;urg_data
op_assign
id|URG_NOTYET
suffix:semicolon
id|sk-&gt;urg_seq
op_assign
id|ptr
suffix:semicolon
multiline_comment|/* disable header prediction */
id|tp-&gt;pred_flags
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is the &squot;fast&squot; part of urgent handling.&n; */
DECL|function|tcp_urg
r_static
r_inline
r_void
id|tcp_urg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
r_int
id|len
)paren
(brace
multiline_comment|/*&n;&t; *&t;Check if we get a new urgent pointer - normally not &n;&t; */
r_if
c_cond
(paren
id|th-&gt;urg
)paren
id|tcp_check_urg
c_func
(paren
id|sk
comma
id|th
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Do we wait for any urgent data? - normally not&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;urg_data
op_eq
id|URG_NOTYET
)paren
(brace
id|u32
id|ptr
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Is the urgent pointer pointing into this packet? &n;&t;&t; */
id|ptr
op_assign
id|sk-&gt;urg_seq
op_minus
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
op_plus
id|th-&gt;doff
op_star
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|ptr
OL
id|len
)paren
(brace
id|sk-&gt;urg_data
op_assign
id|URG_VALID
op_or
op_star
(paren
id|ptr
op_plus
(paren
r_int
r_char
op_star
)paren
id|th
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|prune_queue
r_static
r_void
id|prune_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/*&n;&t; *&t;clean the out_of_order queue&n;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;out_of_order_queue
)paren
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
)brace
DECL|function|tcp_rcv_established
r_int
id|tcp_rcv_established
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
comma
id|__u16
id|len
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
suffix:semicolon
r_int
id|queued
op_assign
l_int|0
suffix:semicolon
id|u32
id|flg
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Header prediction.&n;&t; *&t;The code follows the one in the famous &n;&t; *&t;&quot;30 instruction TCP receive&quot; Van Jacobson mail.&n;&t; *&t;&n;&t; *&t;Van&squot;s trick is to deposit buffers into socket queue &n;&t; *&t;on a device interrupt, to call tcp_recv function&n;&t; *&t;on the receive process context and checksum and copy&n;&t; *&t;the buffer to user space. smart...&n;&t; *&n;&t; *&t;Our current scheme is not silly either but we take the &n;&t; *&t;extra cost of the net_bh soft interrupt processing...&n;&t; *&t;We do checksum and copy also but from device to kernel.&n;&t; */
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|flg
op_assign
op_star
(paren
(paren
(paren
id|u32
op_star
)paren
id|th
)paren
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;pred_flags is 0x5?10 &lt;&lt; 16 + snd_wnd&n;&t; *&t;if header_predition is to be made&n;&t; *&t;? will be 0 else it will be !0&n;&t; *&t;(when there are holes in the receive &n;&t; *&t; space for instance)&n;&t; */
r_if
c_cond
(paren
id|flg
op_eq
id|tp-&gt;pred_flags
op_logical_and
id|skb-&gt;seq
op_eq
id|tp-&gt;rcv_nxt
)paren
(brace
r_if
c_cond
(paren
id|len
op_le
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
(brace
r_if
c_cond
(paren
id|len
op_eq
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
(brace
id|tcp_ack
c_func
(paren
id|sk
comma
id|th
comma
id|skb-&gt;seq
comma
id|skb-&gt;ack_seq
comma
id|len
)paren
suffix:semicolon
id|tcp_data_snd_check
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|skb-&gt;ack_seq
op_eq
id|tp-&gt;snd_una
)paren
(brace
multiline_comment|/* &n;&t;&t;&t; * Bulk data transfer: receiver &n;&t;&t;&t; */
id|skb_pull
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
id|tp-&gt;rcv_nxt
op_assign
id|skb-&gt;end_seq
suffix:semicolon
id|sk-&gt;bytes_rcv
op_add_assign
id|len
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
id|tcp_delack_estimator
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;delayed_acks
op_increment
op_eq
l_int|0
)paren
(brace
id|tcp_send_delayed_ack
c_func
(paren
id|sk
comma
id|HZ
op_div
l_int|2
)paren
suffix:semicolon
)brace
r_else
(brace
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|tcp_sequence
c_func
(paren
id|tp
comma
id|skb-&gt;seq
comma
id|skb-&gt;end_seq
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;rst
)paren
(brace
r_if
c_cond
(paren
id|after
c_func
(paren
id|skb-&gt;seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;seq:%d end:%d wup:%d wnd:%d&bslash;n&quot;
comma
id|skb-&gt;seq
comma
id|skb-&gt;end_seq
comma
id|tp-&gt;rcv_wup
comma
id|tp-&gt;rcv_wnd
)paren
suffix:semicolon
)brace
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|th-&gt;syn
op_logical_and
id|skb-&gt;seq
op_ne
id|sk-&gt;syn_seq
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;syn in established state&bslash;n&quot;
)paren
suffix:semicolon
id|tcp_reset
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
id|tcp_reset
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
id|tcp_ack
c_func
(paren
id|sk
comma
id|th
comma
id|skb-&gt;seq
comma
id|skb-&gt;ack_seq
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Process urgent data&n;&t; */
id|tcp_urg
c_func
(paren
id|sk
comma
id|th
comma
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;step 7: process the segment text&n;&t; */
id|queued
op_assign
id|tcp_data
c_func
(paren
id|skb
comma
id|sk
comma
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;step 8: check the FIN bit&n;&t; */
r_if
c_cond
(paren
id|th-&gt;fin
)paren
(brace
id|tcp_fin
c_func
(paren
id|skb
comma
id|sk
comma
id|th
)paren
suffix:semicolon
)brace
id|tcp_data_snd_check
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_ack_snd_check
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If our receive queue has grown past its limits,&n;&t; *&t;try to prune away duplicates etc..&n;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
OG
id|sk-&gt;rcvbuf
)paren
id|prune_queue
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;And done&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|queued
)paren
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This function implements the receiving procedure of RFC 793.&n; *&t;It&squot;s called from both tcp_v4_rcv and tcp_v6_rcv and should be&n; *&t;address independent.&n; */
DECL|function|tcp_rcv_state_process
r_int
id|tcp_rcv_state_process
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_void
op_star
id|opt
comma
id|__u16
id|len
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|queued
op_assign
l_int|0
suffix:semicolon
r_int
id|rcv_mss
suffix:semicolon
multiline_comment|/*&n;&t; *&t;state == CLOSED&n;&t; *&t;Hash lookup always fails, so no worries. -DaveM &n;&t; */
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_LISTEN
suffix:colon
r_if
c_cond
(paren
id|th-&gt;rst
)paren
r_goto
id|discard
suffix:semicolon
multiline_comment|/* &n;&t;&t; * These use the socket TOS.. &n;&t;&t; * might want to be the received TOS &n;&t;&t; */
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  send reset&n;&t;&t;&t; */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;syn
)paren
(brace
r_int
id|err
suffix:semicolon
id|__u32
id|isn
suffix:semicolon
id|isn
op_assign
id|tp-&gt;af_specific
op_member_access_from_pointer
id|init_sequence
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
id|err
op_assign
id|tp-&gt;af_specific
op_member_access_from_pointer
id|conn_request
c_func
(paren
id|sk
comma
id|skb
comma
id|opt
comma
id|isn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Now we have several options: In theory there is &n;&t;&t;&t; *  nothing else in the frame. KA9Q has an option to &n;&t;&t;&t; *  send data with the syn, BSD accepts data with the&n;&t;&t;&t; *  syn up to the [to be] advertised window and &n;&t;&t;&t; *  Solaris 2.1 gives you a protocol error. For now &n;&t;&t;&t; *  we just ignore it, that fits the spec precisely &n;&t;&t;&t; *  and avoids incompatibilities. It would be nice in&n;&t;&t;&t; *  future to drop through and process the data.&n;&t;&t;&t; *&n;&t;&t;&t; *  Now that TTCP is starting to be used we ought to &n;&t;&t;&t; *  queue this data.&n;&t;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
r_goto
id|discard
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_SYN_SENT
suffix:colon
multiline_comment|/*&n;&t;&t; *&t;SYN sent means we have to look for a suitable ack and &n;&t;&t; *&t;either reset for bad matches or go to connected. &n;&t;&t; *&t;The SYN_SENT case is unusual and should&n;&t;&t; *&t;not be in line code. [AC]&n;&t;&t; */
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
id|tp-&gt;snd_wl1
op_assign
id|skb-&gt;seq
suffix:semicolon
multiline_comment|/* We got an ack, but it&squot;s not a good ack */
r_if
c_cond
(paren
op_logical_neg
id|tcp_ack
c_func
(paren
id|sk
comma
id|th
comma
id|skb-&gt;seq
comma
id|skb-&gt;ack_seq
comma
id|len
)paren
)paren
(brace
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
id|tcp_reset
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;syn
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t; *  A valid ack from a different connection&n;&t;&t;&t;&t; *  start. Shouldn&squot;t happen but cover it &n;&t;&t;&t;&t; */
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;Ok.. it&squot;s good. Set up sequence &n;&t;&t;&t; *&t;numbers and&n;&t;&t;&t; *&t;move to established.&n;&t;&t;&t; */
id|tp-&gt;rcv_nxt
op_assign
id|skb-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|tp-&gt;rcv_wnd
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;rcv_wup
op_assign
id|skb-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|tp-&gt;snd_wnd
op_assign
id|htons
c_func
(paren
id|th-&gt;window
)paren
suffix:semicolon
id|tp-&gt;snd_wl1
op_assign
id|skb-&gt;seq
suffix:semicolon
id|tp-&gt;snd_wl2
op_assign
id|skb-&gt;ack_seq
suffix:semicolon
id|sk-&gt;fin_seq
op_assign
id|skb-&gt;seq
suffix:semicolon
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_ESTABLISHED
)paren
suffix:semicolon
id|rcv_mss
op_assign
id|tcp_parse_options
c_func
(paren
id|th
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rcv_mss
)paren
id|sk-&gt;mss
op_assign
id|min
c_func
(paren
id|sk-&gt;mss
comma
id|rcv_mss
)paren
suffix:semicolon
id|sk-&gt;dummy_th.dest
op_assign
id|th-&gt;source
suffix:semicolon
id|sk-&gt;copied_seq
op_assign
id|tp-&gt;rcv_nxt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sock_wake_async
c_func
(paren
id|sk-&gt;socket
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Drop through step 6 */
r_goto
id|step6
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|th-&gt;syn
op_logical_and
op_logical_neg
id|th-&gt;rst
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t; * the previous version of the code&n;&t;&t;&t;&t; * checked for &quot;connecting to self&quot;&n;&t;&t;&t;&t; * here. that check is done now in&n;&t;&t;&t;&t; * tcp_connect&n;&t;&t;&t;&t; */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_SYN_RECV
)paren
suffix:semicolon
id|tp-&gt;rcv_nxt
op_assign
id|skb-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|tp-&gt;rcv_wup
op_assign
id|skb-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|tp-&gt;snd_wnd
op_assign
id|htons
c_func
(paren
id|th-&gt;window
)paren
suffix:semicolon
id|tp-&gt;snd_wl1
op_assign
id|skb-&gt;seq
suffix:semicolon
id|tcp_send_synack
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|TCP_TIME_WAIT
suffix:colon
multiline_comment|/*&n;&t;&t; *&t;RFC 1122:&n;&t;&t; *&t;&quot;When a connection is [...] on TIME-WAIT state [...]&n;&t;&t; *&t;[a TCP] MAY accept a new SYN from the remote TCP to&n;&t;&t; *&t;reopen the connection directly, if it:&n;&t;&t; *&t;&n;&t;&t; *&t;(1)  assigns its initial sequence number for the new&n;                 *&t;connection to be larger than the largest sequence&n;                 *&t;number it used on the previous connection incarnation,&n;                 *&t;and&n;&t;&t; *&n;&t;&t; *&t;(2)  returns to TIME-WAIT state if the SYN turns out &n;&t;&t; *&t;to be an old duplicate&quot;.&n;&t;&t; */
r_if
c_cond
(paren
id|th-&gt;syn
op_logical_and
op_logical_neg
id|th-&gt;rst
op_logical_and
id|after
c_func
(paren
id|skb-&gt;seq
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
id|__u32
id|isn
suffix:semicolon
r_int
id|err
suffix:semicolon
id|skb_orphan
c_func
(paren
id|skb
)paren
suffix:semicolon
id|sk-&gt;err
op_assign
id|ECONNRESET
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|isn
op_assign
id|tp-&gt;rcv_nxt
op_plus
l_int|128000
suffix:semicolon
id|sk
op_assign
id|tp-&gt;af_specific
op_member_access_from_pointer
id|get_sock
c_func
(paren
id|skb
comma
id|th
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
op_logical_or
op_logical_neg
id|ipsec_sk_policy
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
r_goto
id|discard
suffix:semicolon
id|skb_set_owner_r
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
id|err
op_assign
id|tp-&gt;af_specific
op_member_access_from_pointer
id|conn_request
c_func
(paren
id|sk
comma
id|skb
comma
id|opt
comma
id|isn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;step 1: check sequence number&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tcp_sequence
c_func
(paren
id|tp
comma
id|skb-&gt;seq
comma
id|skb-&gt;end_seq
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;rst
)paren
(brace
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;step 2: check RST bit&n;&t; */
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
id|tcp_reset
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;step 3: check security and precedence &n;&t; *&t;[ignored]&n;&t; */
multiline_comment|/*&n;&t; *&t;step 4:&n;&t; *&n;&t; *&t;Check for a SYN, and ensure it matches the SYN we were&n;&t; *&t;first sent. We have to handle the rather unusual (but valid)&n;&t; *&t;sequence that KA9Q derived products may generate of&n;&t; *&n;&t; *&t;SYN&n;&t; *&t;&t;&t;&t;SYN|ACK Data&n;&t; *&t;ACK&t;(lost)&n;&t; *&t;&t;&t;&t;SYN|ACK Data + More Data&n;&t; *&t;.. we must ACK not RST...&n;&t; *&n;&t; *&t;We keep syn_seq as the sequence space occupied by the &n;&t; *&t;original syn. &n;&t; */
r_if
c_cond
(paren
id|th-&gt;syn
op_logical_and
id|skb-&gt;seq
op_ne
id|sk-&gt;syn_seq
)paren
(brace
id|tcp_reset
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;step 5: check the ACK field&n;&t; */
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
r_int
id|acceptable
op_assign
id|tcp_ack
c_func
(paren
id|sk
comma
id|th
comma
id|skb-&gt;seq
comma
id|skb-&gt;ack_seq
comma
id|len
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_SYN_RECV
suffix:colon
r_if
c_cond
(paren
id|acceptable
)paren
(brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_ESTABLISHED
)paren
suffix:semicolon
id|sk-&gt;dummy_th.dest
op_assign
id|th-&gt;source
suffix:semicolon
id|sk-&gt;copied_seq
op_assign
id|tp-&gt;rcv_nxt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|tp-&gt;snd_una
op_assign
id|skb-&gt;ack_seq
suffix:semicolon
id|tp-&gt;snd_wnd
op_assign
id|htons
c_func
(paren
id|th-&gt;window
)paren
suffix:semicolon
id|tp-&gt;snd_wl1
op_assign
id|skb-&gt;seq
suffix:semicolon
id|tp-&gt;snd_wl2
op_assign
id|skb-&gt;ack_seq
suffix:semicolon
)brace
r_else
r_return
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_FIN_WAIT1
suffix:colon
r_if
c_cond
(paren
id|tp-&gt;snd_una
op_eq
id|sk-&gt;write_seq
)paren
(brace
id|sk-&gt;shutdown
op_or_assign
id|SEND_SHUTDOWN
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_FIN_WAIT2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TCP_CLOSING
suffix:colon
r_if
c_cond
(paren
id|tp-&gt;snd_una
op_eq
id|sk-&gt;write_seq
)paren
(brace
id|tcp_time_wait
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TCP_LAST_ACK
suffix:colon
r_if
c_cond
(paren
id|tp-&gt;snd_una
op_eq
id|sk-&gt;write_seq
)paren
(brace
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
r_goto
id|discard
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TCP_TIME_WAIT
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * keep us in TIME_WAIT until we stop getting &n;&t;&t;&t; * packets, reset the timeout.&n;&t;&t;&t; */
id|tcp_reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_goto
id|discard
suffix:semicolon
id|step6
suffix:colon
multiline_comment|/*&n;&t; *&t;step 6: check the URG bit&n;&t; */
id|tcp_urg
c_func
(paren
id|sk
comma
id|th
comma
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;step 7: process the segment text&n;&t; */
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_CLOSE_WAIT
suffix:colon
r_case
id|TCP_CLOSING
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|before
c_func
(paren
id|skb-&gt;seq
comma
id|sk-&gt;fin_seq
)paren
)paren
r_break
suffix:semicolon
r_case
id|TCP_FIN_WAIT1
suffix:colon
r_case
id|TCP_FIN_WAIT2
suffix:colon
multiline_comment|/*&n;&t;&t; *&t;RFC 793 says to queue data in this states,&n;&t;&t; *&t;RFC 1122 says we MUST send a reset. &n;&t;&t; *&t;BSD 4.4 also does reset.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
op_logical_and
id|sk-&gt;dead
)paren
(brace
r_if
c_cond
(paren
id|after
c_func
(paren
id|skb-&gt;end_seq
op_minus
id|th-&gt;fin
comma
id|tp-&gt;rcv_nxt
)paren
)paren
(brace
id|tcp_reset
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_case
id|TCP_ESTABLISHED
suffix:colon
id|queued
op_assign
id|tcp_data
c_func
(paren
id|skb
comma
id|sk
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;step 8: check the FIN bit&n;&t; */
r_if
c_cond
(paren
id|th-&gt;fin
)paren
(brace
id|tcp_fin
c_func
(paren
id|skb
comma
id|sk
comma
id|th
)paren
suffix:semicolon
)brace
id|tcp_data_snd_check
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_ack_snd_check
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|queued
)paren
r_return
l_int|0
suffix:semicolon
id|discard
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tcp_sysctl_congavoid
r_int
id|tcp_sysctl_congavoid
c_func
(paren
id|ctl_table
op_star
id|ctl
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|lenp
)paren
(brace
r_int
id|val
op_assign
id|sysctl_tcp_cong_avoidance
suffix:semicolon
r_int
id|retv
suffix:semicolon
id|retv
op_assign
id|proc_dointvec
c_func
(paren
id|ctl
comma
id|write
comma
id|filp
comma
id|buffer
comma
id|lenp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write
)paren
(brace
r_switch
c_cond
(paren
id|sysctl_tcp_cong_avoidance
)paren
(brace
r_case
l_int|0
suffix:colon
id|tcp_sys_cong_ctl_f
op_assign
op_amp
id|tcp_cong_avoid_vanj
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|tcp_sys_cong_ctl_f
op_assign
op_amp
id|tcp_cong_avoid_vegas
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|retv
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|sysctl_tcp_cong_avoidance
op_assign
id|val
suffix:semicolon
)brace
)brace
r_return
id|retv
suffix:semicolon
)brace
eof
