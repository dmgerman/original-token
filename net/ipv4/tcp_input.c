multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Implementation of the Transmission Control Protocol(TCP).&n; *&n; * Version:&t;@(#)tcp_input.c&t;1.0.16&t;05/25/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;&n; *&t;&t;Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; *&n; * FIXES&n; *&t;&t;Pedro Roque&t;:&t;Double ACK bug&n; *&t;&t;Eric Schenk&t;:&t;Fixes to slow start algorithm.&n; *&t;&t;Eric Schenk&t;:&t;Yet another double ACK bug.&n; *&t;&t;Eric Schenk&t;:&t;Delayed ACK bug fixes.&n; *&t;&t;Eric Schenk&t;:&t;Floyd style fast retrans war avoidance.&n; *&t;&t;Eric Schenk&t;: &t;Skip fast retransmit on small windows.&n; *&t;&t;Eric schenk&t;:&t;Fixes to retransmission code to&n; *&t;&t;&t;&t;:&t;avoid extra retransmission.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
multiline_comment|/*&n; *&t;Policy code extracted so it&squot;s now separate&n; */
multiline_comment|/*&n; *&t;Called each time to estimate the delayed ack timeout. This is&n; *&t;how it should be done so a fast link isn&squot;t impacted by ack delay.&n; */
DECL|function|tcp_delack_estimator
r_extern
id|__inline__
r_void
id|tcp_delack_estimator
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
multiline_comment|/*&n;&t; *&t;Delayed ACK time estimator.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;lrcvtime
op_eq
l_int|0
)paren
(brace
id|sk-&gt;lrcvtime
op_assign
id|jiffies
suffix:semicolon
id|sk-&gt;ato
op_assign
id|HZ
op_div
l_int|3
suffix:semicolon
)brace
r_else
(brace
r_int
id|m
suffix:semicolon
id|m
op_assign
id|jiffies
op_minus
id|sk-&gt;lrcvtime
suffix:semicolon
id|sk-&gt;lrcvtime
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|m
op_le
l_int|0
)paren
id|m
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|m
OG
(paren
id|sk-&gt;rtt
op_rshift
l_int|3
)paren
)paren
(brace
id|sk-&gt;ato
op_assign
id|sk-&gt;rtt
op_rshift
l_int|3
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * printk(KERN_DEBUG &quot;ato: rtt %lu&bslash;n&quot;, sk-&gt;ato);&n;&t;&t;&t; */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; &t; * Very fast acting estimator.&n;&t;&t; &t; * May fluctuate too much. Probably we should be&n;&t;&t;&t; * doing something like the rtt estimator here.&n;&t;&t;&t; */
id|sk-&gt;ato
op_assign
(paren
id|sk-&gt;ato
op_rshift
l_int|1
)paren
op_plus
id|m
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * printk(KERN_DEBUG &quot;ato: m %lu&bslash;n&quot;, sk-&gt;ato);&n;&t;&t;&t; */
)brace
)brace
)brace
multiline_comment|/*&n; *&t;Called on frames that were known _not_ to have been&n; *&t;retransmitted [see Karn/Partridge Proceedings SIGCOMM 87]. &n; *&t;The algorithm is from the SIGCOMM 88 piece by Van Jacobson.&n; */
DECL|function|tcp_rtt_estimator
r_extern
id|__inline__
r_void
id|tcp_rtt_estimator
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|oskb
)paren
(brace
r_int
id|m
suffix:semicolon
multiline_comment|/*&n;&t; *&t;The following amusing code comes from Jacobson&squot;s&n;&t; *&t;article in SIGCOMM &squot;88.  Note that rtt and mdev&n;&t; *&t;are scaled versions of rtt and mean deviation.&n;&t; *&t;This is designed to be as fast as possible &n;&t; *&t;m stands for &quot;measurement&quot;.&n;&t; */
id|m
op_assign
id|jiffies
op_minus
id|oskb-&gt;when
suffix:semicolon
multiline_comment|/* RTT */
r_if
c_cond
(paren
id|sk-&gt;rtt
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|m
op_le
l_int|0
)paren
(brace
id|m
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* IS THIS RIGHT FOR &lt;0 ??? */
id|m
op_sub_assign
(paren
id|sk-&gt;rtt
op_rshift
l_int|3
)paren
suffix:semicolon
multiline_comment|/* m is now error in rtt est */
id|sk-&gt;rtt
op_add_assign
id|m
suffix:semicolon
multiline_comment|/* rtt = 7/8 rtt + 1/8 new */
r_if
c_cond
(paren
id|m
OL
l_int|0
)paren
id|m
op_assign
op_minus
id|m
suffix:semicolon
multiline_comment|/* m is now abs(error) */
id|m
op_sub_assign
(paren
id|sk-&gt;mdev
op_rshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* similar update on mdev */
id|sk-&gt;mdev
op_add_assign
id|m
suffix:semicolon
multiline_comment|/* mdev = 3/4 mdev + 1/4 new */
)brace
r_else
(brace
multiline_comment|/* no previous measure. */
id|sk-&gt;rtt
op_assign
id|m
op_lshift
l_int|3
suffix:semicolon
multiline_comment|/* take the measured time to be rtt */
id|sk-&gt;mdev
op_assign
id|m
op_lshift
l_int|1
suffix:semicolon
multiline_comment|/* make sure rto = 3*rtt */
)brace
multiline_comment|/*&n;&t; *&t;Now update timeout.  Note that this removes any backoff.&n;&t; */
id|sk-&gt;rto
op_assign
(paren
id|sk-&gt;rtt
op_rshift
l_int|3
)paren
op_plus
id|sk-&gt;mdev
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rto
OG
l_int|120
op_star
id|HZ
)paren
id|sk-&gt;rto
op_assign
l_int|120
op_star
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rto
OL
id|HZ
op_div
l_int|5
)paren
multiline_comment|/* Was 1*HZ - keep .2 as minimum cos of the BSD delayed acks */
id|sk-&gt;rto
op_assign
id|HZ
op_div
l_int|5
suffix:semicolon
id|sk-&gt;backoff
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Cached last hit socket&n; */
DECL|variable|th_cache_saddr
DECL|variable|th_cache_daddr
r_static
r_volatile
r_int
r_int
id|th_cache_saddr
comma
id|th_cache_daddr
suffix:semicolon
DECL|variable|th_cache_dport
DECL|variable|th_cache_sport
r_static
r_volatile
r_int
r_int
id|th_cache_dport
comma
id|th_cache_sport
suffix:semicolon
DECL|variable|th_cache_sk
r_static
r_volatile
r_struct
id|sock
op_star
id|th_cache_sk
suffix:semicolon
DECL|function|tcp_cache_zap
r_void
id|tcp_cache_zap
c_func
(paren
r_void
)paren
(brace
id|th_cache_sk
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Find the socket, using the last hit cache if applicable. The cache is not quite&n; *&t;right...&n; */
DECL|function|get_tcp_sock
r_static
r_inline
r_struct
id|sock
op_star
id|get_tcp_sock
c_func
(paren
id|u32
id|saddr
comma
id|u16
id|sport
comma
id|u32
id|daddr
comma
id|u16
id|dport
comma
id|u32
id|paddr
comma
id|u16
id|pport
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|th_cache_sk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk
op_logical_or
id|saddr
op_ne
id|th_cache_saddr
op_logical_or
id|daddr
op_ne
id|th_cache_daddr
op_logical_or
id|sport
op_ne
id|th_cache_sport
op_logical_or
id|dport
op_ne
id|th_cache_dport
)paren
(brace
id|sk
op_assign
id|get_sock
c_func
(paren
op_amp
id|tcp_prot
comma
id|dport
comma
id|saddr
comma
id|sport
comma
id|daddr
comma
id|paddr
comma
id|pport
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
)paren
(brace
id|th_cache_saddr
op_assign
id|saddr
suffix:semicolon
id|th_cache_daddr
op_assign
id|daddr
suffix:semicolon
id|th_cache_dport
op_assign
id|dport
suffix:semicolon
id|th_cache_sport
op_assign
id|sport
suffix:semicolon
id|th_cache_sk
op_assign
id|sk
suffix:semicolon
)brace
)brace
r_return
id|sk
suffix:semicolon
)brace
multiline_comment|/*&n; * React to a out-of-window TCP sequence number in an incoming packet&n; */
DECL|function|bad_tcp_sequence
r_static
r_void
id|bad_tcp_sequence
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
id|u32
id|end_seq
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|th-&gt;rst
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Send a reset if we get something not ours and we are&n;&t; *&t;unsynchronized. Note: We don&squot;t do anything to our end. We&n;&t; *&t;are just killing the bogus remote connection then we will&n;&t; *&t;connect again and it will work (with luck).&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_SYN_RECV
)paren
(brace
id|tcp_send_reset
c_func
(paren
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
id|th
comma
id|sk-&gt;prot
comma
l_int|NULL
comma
id|dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * &t;This packet is old news. Usually this is just a resend&n;&t; * &t;from the far end, but sometimes it means the far end lost&n;&t; *&t;an ACK we send, so we better send an ACK.&n;&t; */
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This functions checks to see if the tcp header is actually acceptable. &n; */
DECL|function|tcp_sequence
r_extern
id|__inline__
r_int
id|tcp_sequence
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|seq
comma
id|u32
id|end_seq
)paren
(brace
id|u32
id|end_window
op_assign
id|sk-&gt;lastwin_seq
op_plus
id|sk-&gt;window
suffix:semicolon
r_return
multiline_comment|/* if start is at end of window, end must be too (zero window) */
(paren
id|seq
op_eq
id|end_window
op_logical_and
id|seq
op_eq
id|end_seq
)paren
op_logical_or
multiline_comment|/* if start is before end of window, check for interest */
(paren
id|before
c_func
(paren
id|seq
comma
id|end_window
)paren
op_logical_and
op_logical_neg
id|before
c_func
(paren
id|end_seq
comma
id|sk-&gt;acked_seq
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;When we get a reset we do this. This probably is a tcp_output routine&n; *&t;really.&n; */
DECL|function|tcp_reset
r_static
r_int
id|tcp_reset
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|sk-&gt;zapped
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We want the right error as BSD sees it (and indeed as we do).&n;&t; */
id|sk-&gt;err
op_assign
id|ECONNRESET
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
)paren
id|sk-&gt;err
op_assign
id|ECONNREFUSED
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE_WAIT
)paren
id|sk-&gt;err
op_assign
id|EPIPE
suffix:semicolon
macro_line|#ifdef CONFIG_TCP_RFC1337
multiline_comment|/*&n;&t; *&t;Time wait assassination protection [RFC1337]&n;&t; *&n;&t; *&t;This is a good idea, but causes more sockets to take time to close.&n;&t; *&n;&t; *&t;Ian Heavens has since shown this is an inadequate fix for the protocol&n;&t; *&t;bug in question.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_TIME_WAIT
)paren
(brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
)brace
macro_line|#else&t;
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
macro_line|#endif&t;
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Look for tcp options. Parses everything but only knows about MSS.&n; *&t;This routine is always called with the packet containing the SYN.&n; *&t;However it may also be called with the ack to the SYN.  So you&n; *&t;can&squot;t assume this is always the SYN.  It&squot;s always called after&n; *&t;we have set up sk-&gt;mtu to our own MTU.&n; *&n; *&t;We need at minimum to add PAWS support here. Possibly large windows&n; *&t;as Linux gets deployed on 100Mb/sec networks.&n; */
DECL|function|tcp_options
r_static
r_void
id|tcp_options
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|length
op_assign
(paren
id|th-&gt;doff
op_star
l_int|4
)paren
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
r_int
id|mss_seen
op_assign
l_int|0
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|length
OG
l_int|0
)paren
(brace
r_int
id|opcode
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_int
id|opsize
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|TCPOPT_EOL
suffix:colon
r_return
suffix:semicolon
r_case
id|TCPOPT_NOP
suffix:colon
multiline_comment|/* Ref: RFC 793 section 3.1 */
id|length
op_decrement
suffix:semicolon
id|ptr
op_decrement
suffix:semicolon
multiline_comment|/* the opsize=*ptr++ above was a mistake */
r_continue
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|opsize
op_le
l_int|2
)paren
(brace
multiline_comment|/* Avoid silly options looping forever */
r_return
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|TCPOPT_MSS
suffix:colon
r_if
c_cond
(paren
id|opsize
op_eq
l_int|4
op_logical_and
id|th-&gt;syn
)paren
(brace
id|sk-&gt;mtu
op_assign
id|min
c_func
(paren
id|sk-&gt;mtu
comma
id|ntohs
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|ptr
)paren
)paren
suffix:semicolon
id|mss_seen
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* Add other options here as people feel the urge to implement stuff like large windows */
)brace
id|ptr
op_add_assign
id|opsize
op_minus
l_int|2
suffix:semicolon
id|length
op_sub_assign
id|opsize
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|th-&gt;syn
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mss_seen
)paren
id|sk-&gt;mtu
op_assign
id|min
c_func
(paren
id|sk-&gt;mtu
comma
l_int|536
)paren
suffix:semicolon
multiline_comment|/* default MSS if none sent */
)brace
macro_line|#ifdef CONFIG_INET_PCTCP
id|sk-&gt;mss
op_assign
id|min
c_func
(paren
id|sk-&gt;max_window
op_rshift
l_int|1
comma
id|sk-&gt;mtu
)paren
suffix:semicolon
macro_line|#else    
id|sk-&gt;mss
op_assign
id|min
c_func
(paren
id|sk-&gt;max_window
comma
id|sk-&gt;mtu
)paren
suffix:semicolon
id|sk-&gt;max_unacked
op_assign
l_int|2
op_star
id|sk-&gt;mss
suffix:semicolon
macro_line|#endif  
)brace
multiline_comment|/*&n; *&t;This routine handles a connection request.&n; *&t;It should make sure we haven&squot;t already responded.&n; *&t;Because of the way BSD works, we have to send a syn/ack now.&n; *&t;This also means it will be harder to close a socket which is&n; *&t;listening.&n; */
DECL|function|tcp_conn_request
r_static
r_void
id|tcp_conn_request
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
id|u32
id|daddr
comma
id|u32
id|saddr
comma
r_struct
id|options
op_star
id|opt
comma
r_struct
id|device
op_star
id|dev
comma
id|u32
id|seq
)paren
(brace
r_struct
id|sock
op_star
id|newsk
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
multiline_comment|/* If the socket is dead, don&squot;t accept the connection. */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Reset on %p: Connect on dead socket.&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
)brace
id|tcp_send_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Make sure we can accept more.  This will prevent a&n;&t; *&t;flurry of syns from eating up all our memory.&n;&t; *&n;&t; *&t;BSD does some funnies here and allows 3/2 times the&n;&t; *&t;set backlog as a fudge factor. That&squot;s just too gross.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;ack_backlog
op_ge
id|sk-&gt;max_ack_backlog
)paren
(brace
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We need to build a new sock struct.&n;&t; * It is sort of bad to have a socket without an inode attached&n;&t; * to it, but the wake_up&squot;s will just wake up the listening socket,&n;&t; * and if the listening socket is destroyed before this is taken&n;&t; * off of the queue, this will take care of it.&n;&t; */
id|newsk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sock
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newsk
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* just ignore the syn.  It will get retransmitted. */
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|newsk
comma
id|sk
comma
r_sizeof
(paren
op_star
id|newsk
)paren
)paren
suffix:semicolon
id|newsk-&gt;opt
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;ip_route_cache
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;optlen
)paren
(brace
id|sk-&gt;opt
op_assign
(paren
r_struct
id|options
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|options
)paren
op_plus
id|opt-&gt;optlen
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;opt
)paren
(brace
id|kfree_s
c_func
(paren
id|newsk
comma
r_sizeof
(paren
r_struct
id|sock
)paren
)paren
suffix:semicolon
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip_options_echo
c_func
(paren
id|sk-&gt;opt
comma
id|opt
comma
id|daddr
comma
id|saddr
comma
id|skb
)paren
)paren
(brace
id|kfree_s
c_func
(paren
id|sk-&gt;opt
comma
r_sizeof
(paren
r_struct
id|options
)paren
op_plus
id|opt-&gt;optlen
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|newsk
comma
r_sizeof
(paren
r_struct
id|sock
)paren
)paren
suffix:semicolon
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|skb_queue_head_init
c_func
(paren
op_amp
id|newsk-&gt;write_queue
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|newsk-&gt;receive_queue
)paren
suffix:semicolon
id|newsk-&gt;send_head
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;send_tail
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;send_next
op_assign
l_int|NULL
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|newsk-&gt;back_log
)paren
suffix:semicolon
id|newsk-&gt;rtt
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;rto
op_assign
id|TCP_TIMEOUT_INIT
suffix:semicolon
id|newsk-&gt;mdev
op_assign
id|TCP_TIMEOUT_INIT
suffix:semicolon
id|newsk-&gt;max_window
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * See draft-stevens-tcpca-spec-01 for discussion of the&n;&t; * initialization of these values.&n;&t; */
id|newsk-&gt;cong_window
op_assign
l_int|1
suffix:semicolon
id|newsk-&gt;cong_count
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;ssthresh
op_assign
l_int|0x7fffffff
suffix:semicolon
id|newsk-&gt;lrcvtime
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;idletime
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;high_seq
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;backoff
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;blog
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;intr
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;proc
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;done
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;partial
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;pair
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;wmem_alloc
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;rmem_alloc
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;localroute
op_assign
id|sk-&gt;localroute
suffix:semicolon
id|newsk-&gt;max_unacked
op_assign
id|MAX_WINDOW
op_minus
id|TCP_WINDOW_DIFF
suffix:semicolon
id|newsk-&gt;err
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;shutdown
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;acked_seq
op_assign
id|skb-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|newsk-&gt;lastwin_seq
op_assign
id|skb-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|newsk-&gt;delay_acks
op_assign
l_int|1
suffix:semicolon
id|newsk-&gt;copied_seq
op_assign
id|skb-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|newsk-&gt;fin_seq
op_assign
id|skb-&gt;seq
suffix:semicolon
id|newsk-&gt;state
op_assign
id|TCP_SYN_RECV
suffix:semicolon
id|newsk-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;ip_xmit_timeout
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;write_seq
op_assign
id|seq
suffix:semicolon
id|newsk-&gt;window_seq
op_assign
id|newsk-&gt;write_seq
suffix:semicolon
id|newsk-&gt;rcv_ack_seq
op_assign
id|newsk-&gt;write_seq
suffix:semicolon
id|newsk-&gt;urg_data
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;linger
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;destroy
op_assign
l_int|0
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|newsk-&gt;timer
)paren
suffix:semicolon
id|newsk-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|newsk
suffix:semicolon
id|newsk-&gt;timer.function
op_assign
op_amp
id|net_timer
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|newsk-&gt;delack_timer
)paren
suffix:semicolon
id|newsk-&gt;delack_timer.data
op_assign
(paren
r_int
r_int
)paren
id|newsk
suffix:semicolon
id|newsk-&gt;delack_timer.function
op_assign
id|tcp_delack_timer
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|newsk-&gt;retransmit_timer
)paren
suffix:semicolon
id|newsk-&gt;retransmit_timer.data
op_assign
(paren
r_int
r_int
)paren
id|newsk
suffix:semicolon
id|newsk-&gt;retransmit_timer.function
op_assign
id|tcp_retransmit_timer
suffix:semicolon
id|newsk-&gt;dummy_th.source
op_assign
id|skb-&gt;h.th-&gt;dest
suffix:semicolon
id|newsk-&gt;dummy_th.dest
op_assign
id|skb-&gt;h.th-&gt;source
suffix:semicolon
macro_line|#ifdef CONFIG_IP_TRANSPARENT_PROXY
multiline_comment|/* &n;&t; *&t;Deal with possibly redirected traffic by setting num to&n;&t; *&t;the intended destination port of the received packet.&n;&t; */
id|newsk-&gt;num
op_assign
id|ntohs
c_func
(paren
id|skb-&gt;h.th-&gt;dest
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Swap these two, they are from our point of view. &n;&t; */
id|newsk-&gt;daddr
op_assign
id|saddr
suffix:semicolon
id|newsk-&gt;saddr
op_assign
id|daddr
suffix:semicolon
id|newsk-&gt;rcv_saddr
op_assign
id|daddr
suffix:semicolon
id|put_sock
c_func
(paren
id|newsk-&gt;num
comma
id|newsk
)paren
suffix:semicolon
id|newsk-&gt;acked_seq
op_assign
id|skb-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|newsk-&gt;copied_seq
op_assign
id|skb-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|newsk-&gt;socket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Grab the ttl and tos values and use them &n;&t; */
id|newsk-&gt;ip_ttl
op_assign
id|sk-&gt;ip_ttl
suffix:semicolon
id|newsk-&gt;ip_tos
op_assign
id|skb-&gt;ip_hdr-&gt;tos
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Use 512 or whatever user asked for &n;&t; */
multiline_comment|/*&n;&t; * &t;Note use of sk-&gt;user_mss, since user has no direct access to newsk &n;&t; */
id|rt
op_assign
id|ip_rt_route
c_func
(paren
id|newsk-&gt;opt
op_logical_and
id|newsk-&gt;opt-&gt;srr
ques
c_cond
id|newsk-&gt;opt-&gt;faddr
suffix:colon
id|saddr
comma
l_int|0
)paren
suffix:semicolon
id|newsk-&gt;ip_route_cache
op_assign
id|rt
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_ne
l_int|NULL
op_logical_and
(paren
id|rt-&gt;rt_flags
op_amp
id|RTF_WINDOW
)paren
)paren
(brace
id|newsk-&gt;window_clamp
op_assign
id|rt-&gt;rt_window
suffix:semicolon
)brace
r_else
id|newsk-&gt;window_clamp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;user_mss
)paren
id|newsk-&gt;mtu
op_assign
id|sk-&gt;user_mss
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rt
)paren
id|newsk-&gt;mtu
op_assign
id|rt-&gt;rt_mtu
op_minus
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
r_else
id|newsk-&gt;mtu
op_assign
l_int|576
op_minus
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;But not bigger than device MTU &n;&t; */
id|newsk-&gt;mtu
op_assign
id|min
c_func
(paren
id|newsk-&gt;mtu
comma
id|dev-&gt;mtu
op_minus
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SKIP
multiline_comment|/*&n;&t; *&t;SKIP devices set their MTU to 65535. This is so they can take packets&n;&t; *&t;unfragmented to security process then fragment. They could lie to the&n;&t; *&t;TCP layer about a suitable MTU, but it&squot;s easier to let skip sort it out&n;&t; *&t;simply because the final package we want unfragmented is going to be&n;&t; *&n;&t; *&t;[IPHDR][IPSP][Security data][Modified TCP data][Security data]&n;&t; */
r_if
c_cond
(paren
id|skip_pick_mtu
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* If SKIP is loaded.. */
id|sk-&gt;mtu
op_assign
id|skip_pick_mtu
c_func
(paren
id|sk-&gt;mtu
comma
id|dev
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *&t;This will min with what arrived in the packet &n;&t; */
id|tcp_options
c_func
(paren
id|newsk
comma
id|skb-&gt;h.th
)paren
suffix:semicolon
id|tcp_cache_zap
c_func
(paren
)paren
suffix:semicolon
id|tcp_send_synack
c_func
(paren
id|newsk
comma
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle a TCP window that shrunk on us. It shouldn&squot;t happen,&n; * but..&n; *&n; * We may need to move packets from the send queue&n; * to the write queue, if the window has been shrunk on us.&n; * The RFC says you are not allowed to shrink your window&n; * like this, but if the other end does, you must be able&n; * to deal with it.&n; */
DECL|function|tcp_window_shrunk
r_void
id|tcp_window_shrunk
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|window_seq
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_struct
id|sk_buff
op_star
id|wskb
op_assign
l_int|NULL
suffix:semicolon
id|skb2
op_assign
id|sk-&gt;send_head
suffix:semicolon
id|sk-&gt;send_head
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;send_tail
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;send_next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This is an artifact of a flawed concept. We want one&n;&t; *&t;queue and a smarter send routine when we send all.&n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|skb2
op_ne
l_int|NULL
)paren
(brace
id|skb
op_assign
id|skb2
suffix:semicolon
id|skb2
op_assign
id|skb-&gt;link3
suffix:semicolon
id|skb-&gt;link3
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|skb-&gt;end_seq
comma
id|window_seq
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;packets_out
OG
l_int|0
)paren
id|sk-&gt;packets_out
op_decrement
suffix:semicolon
multiline_comment|/* We may need to remove this from the dev send list. */
r_if
c_cond
(paren
id|skb-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* Now add it to the write_queue. */
r_if
c_cond
(paren
id|wskb
op_eq
l_int|NULL
)paren
id|skb_queue_head
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
r_else
id|skb_append
c_func
(paren
id|wskb
comma
id|skb
)paren
suffix:semicolon
id|wskb
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk-&gt;send_head
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;send_head
op_assign
id|skb
suffix:semicolon
id|sk-&gt;send_tail
op_assign
id|skb
suffix:semicolon
id|sk-&gt;send_next
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;send_tail-&gt;link3
op_assign
id|skb
suffix:semicolon
id|sk-&gt;send_tail
op_assign
id|skb
suffix:semicolon
)brace
id|skb-&gt;link3
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine deals with incoming acks, but not outgoing ones.&n; *&n; *&t;This routine is totally _WRONG_. The list structuring is wrong,&n; *&t;the algorithm is wrong, the code is wrong.&n; */
DECL|function|tcp_ack
r_static
r_int
id|tcp_ack
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
id|u32
id|ack
comma
r_int
id|len
)paren
(brace
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
id|u32
id|window_seq
suffix:semicolon
multiline_comment|/* &n;&t; * 1 - there was data in packet as well as ack or new data is sent or &n;&t; *     in shutdown state&n;&t; * 2 - data from retransmit queue was acked and removed&n;&t; * 4 - window shrunk or data from retransmit queue was acked and removed&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Dead, can&squot;t ack any more so why bother */
multiline_comment|/*&n;&t; *&t;We have dropped back to keepalive timeouts. Thus we have&n;&t; *&t;no retransmits pending.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;ip_xmit_timeout
op_eq
id|TIME_KEEPOPEN
)paren
id|sk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If the ack is newer than sent or older than previous acks&n;&t; *&t;then we can probably ignore it.&n;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|ack
comma
id|sk-&gt;sent_seq
)paren
op_logical_or
id|before
c_func
(paren
id|ack
comma
id|sk-&gt;rcv_ack_seq
)paren
)paren
r_goto
id|uninteresting_ack
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Have we discovered a larger window&n;&t; */
id|window_seq
op_assign
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
suffix:semicolon
r_if
c_cond
(paren
id|window_seq
OG
id|sk-&gt;max_window
)paren
(brace
id|sk-&gt;max_window
op_assign
id|window_seq
suffix:semicolon
macro_line|#ifdef CONFIG_INET_PCTCP
multiline_comment|/* Hack because we don&squot;t send partial packets to non SWS&n;&t;&t;   handling hosts */
id|sk-&gt;mss
op_assign
id|min
c_func
(paren
id|window_seq
op_rshift
l_int|1
comma
id|sk-&gt;mtu
)paren
suffix:semicolon
macro_line|#else
id|sk-&gt;mss
op_assign
id|min
c_func
(paren
id|window_seq
comma
id|sk-&gt;mtu
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
id|window_seq
op_add_assign
id|ack
suffix:semicolon
multiline_comment|/*&n;&t; *&t;See if our window has been shrunk. &n;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|sk-&gt;window_seq
comma
id|window_seq
)paren
)paren
id|tcp_window_shrunk
c_func
(paren
id|sk
comma
id|window_seq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Pipe has emptied&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;send_tail
op_eq
l_int|NULL
op_logical_or
id|sk-&gt;send_head
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;send_head
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;send_tail
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;send_next
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;packets_out
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;We don&squot;t want too many packets out there. &n;&t; */
r_if
c_cond
(paren
id|sk-&gt;ip_xmit_timeout
op_eq
id|TIME_WRITE
op_logical_and
id|sk-&gt;cong_window
OL
l_int|2048
op_logical_and
id|after
c_func
(paren
id|ack
comma
id|sk-&gt;rcv_ack_seq
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t; * This is Jacobson&squot;s slow start and congestion avoidance. &n;&t;&t; * SIGCOMM &squot;88, p. 328.  Because we keep cong_window in integral&n;&t;&t; * mss&squot;s, we can&squot;t do cwnd += 1 / cwnd.  Instead, maintain a &n;&t;&t; * counter and increment it once every cwnd times.  It&squot;s possible&n;&t;&t; * that this should be done only if sk-&gt;retransmits == 0.  I&squot;m&n;&t;&t; * interpreting &quot;new data is acked&quot; as including data that has&n;&t;&t; * been retransmitted but is just now being acked.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;cong_window
op_le
id|sk-&gt;ssthresh
)paren
multiline_comment|/* &n;&t;&t;&t; *&t;In &quot;safe&quot; area, increase&n;&t;&t;&t; */
id|sk-&gt;cong_window
op_increment
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;In dangerous area, increase slowly.  In theory this is&n;&t;&t;&t; *  &t;sk-&gt;cong_window += 1 / sk-&gt;cong_window&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;cong_count
op_ge
id|sk-&gt;cong_window
)paren
(brace
id|sk-&gt;cong_window
op_increment
suffix:semicolon
id|sk-&gt;cong_count
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|sk-&gt;cong_count
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Remember the highest ack received and update the&n;&t; *&t;right hand window edge of the host.&n;&t; *&t;We do a bit of work here to track number of times we&squot;ve&n;&t; *&t;seen this ack without a change in the right edge of the&n;&t; *&t;window and no data in the packet.&n;&t; *&t;This will allow us to do fast retransmits.&n;&t; */
multiline_comment|/* We are looking for duplicate ACKs here.&n;&t; * An ACK is a duplicate if:&n;&t; * (1) it has the same sequence number as the largest number we&squot;ve seen,&n;&t; * (2) it has the same window as the last ACK,&n;&t; * (3) we have outstanding data that has not been ACKed&n;&t; * (4) The packet was not carrying any data.&n;&t; * (5) [From Floyd&squot;s paper on fast retransmit wars]&n;&t; *     The packet acked data after high_seq;&n;&t; * I&squot;ve tried to order these in occurrence of most likely to fail&n;&t; * to least likely to fail.&n;&t; * [These are an extension of the rules BSD stacks use to&n;&t; *  determine if an ACK is a duplicate.]&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;rcv_ack_seq
op_eq
id|ack
op_logical_and
id|sk-&gt;window_seq
op_eq
id|window_seq
op_logical_and
id|len
op_ne
id|th-&gt;doff
op_star
l_int|4
op_logical_and
id|before
c_func
(paren
id|ack
comma
id|sk-&gt;sent_seq
)paren
op_logical_and
id|after
c_func
(paren
id|ack
comma
id|sk-&gt;high_seq
)paren
)paren
(brace
multiline_comment|/* Prevent counting of duplicate ACKs if the congestion&n;&t;&t; * window is smaller than 3. Note that since we reduce&n;&t;&t; * the congestion window when we do a fast retransmit,&n;&t;&t; * we must be careful to keep counting if we were already&n;&t;&t; * counting. The idea behind this is to avoid doing&n;&t;&t; * fast retransmits if the congestion window is so small&n;&t;&t; * that we cannot get 3 ACKs due to the loss of a packet&n;&t;&t; * unless we are getting ACKs for retransmitted packets.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;cong_window
op_ge
l_int|3
op_logical_or
id|sk-&gt;rcv_ack_cnt
OG
id|MAX_DUP_ACKS
op_plus
l_int|1
)paren
id|sk-&gt;rcv_ack_cnt
op_increment
suffix:semicolon
multiline_comment|/* See draft-stevens-tcpca-spec-01 for explanation&n;&t;&t; * of what we are doing here.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;rcv_ack_cnt
op_eq
id|MAX_DUP_ACKS
op_plus
l_int|1
)paren
(brace
r_int
id|tmp
suffix:semicolon
multiline_comment|/* We need to be a bit careful to preserve the&n;&t;&t;&t; * count of packets that are out in the system here.&n;&t;&t;&t; */
id|sk-&gt;ssthresh
op_assign
id|max
c_func
(paren
id|sk-&gt;cong_window
op_rshift
l_int|1
comma
l_int|2
)paren
suffix:semicolon
id|sk-&gt;cong_window
op_assign
id|sk-&gt;ssthresh
op_plus
id|MAX_DUP_ACKS
op_plus
l_int|1
suffix:semicolon
id|tmp
op_assign
id|sk-&gt;packets_out
suffix:semicolon
id|tcp_do_retransmit
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
id|sk-&gt;packets_out
op_assign
id|tmp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sk-&gt;rcv_ack_cnt
OG
id|MAX_DUP_ACKS
op_plus
l_int|1
)paren
(brace
id|sk-&gt;cong_window
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;* At this point we are suppose to transmit a NEW&n;&t;&t;&t;* packet (not retransmit the missing packet,&n;&t;&t;&t;* this would only get us into a retransmit war.)&n;&t;&t;&t;* I think that having just adjusted cong_window&n;&t;&t;&t;* we will transmit the new packet below.&n;&t;&t;&t;*/
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk-&gt;rcv_ack_cnt
OG
id|MAX_DUP_ACKS
)paren
(brace
id|sk-&gt;cong_window
op_assign
id|sk-&gt;ssthresh
suffix:semicolon
)brace
id|sk-&gt;window_seq
op_assign
id|window_seq
suffix:semicolon
id|sk-&gt;rcv_ack_seq
op_assign
id|ack
suffix:semicolon
id|sk-&gt;rcv_ack_cnt
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;We passed data and got it acked, remove any soft error&n;&t; *&t;log. Something worked...&n;&t; */
id|sk-&gt;err_soft
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If this ack opens up a zero window, clear backoff.  It was&n;&t; *&t;being used to time the probes, and is probably far higher than&n;&t; *&t;it needs to be for normal retransmission.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;ip_xmit_timeout
op_eq
id|TIME_PROBE0
)paren
(brace
id|sk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Our probe was answered */
multiline_comment|/*&n;&t;&t; *&t;Was it a usable window open ?&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_logical_and
multiline_comment|/* should always be true */
op_logical_neg
id|before
(paren
id|sk-&gt;window_seq
comma
id|sk-&gt;write_queue.next-&gt;end_seq
)paren
)paren
(brace
id|sk-&gt;backoff
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Recompute rto from rtt.  this eliminates any backoff.&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * Appendix C of Van Jacobson&squot;s final version of&n;&t;&t;&t; * the SIGCOMM 88 paper states that although&n;&t;&t;&t; * the original paper suggested that&n;&t;&t;&t; *  RTO = R*2V&n;&t;&t;&t; * was the correct calculation experience showed&n;&t;&t;&t; * better results using&n;&t;&t;&t; *  RTO = R*4V&n;&t;&t;&t; * In particular this gives better performance over&n;&t;&t;&t; * slow links, and should not effect fast links.&n;&t;&t;&t; */
id|sk-&gt;rto
op_assign
(paren
id|sk-&gt;rtt
op_rshift
l_int|3
)paren
op_plus
id|sk-&gt;mdev
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rto
OG
l_int|120
op_star
id|HZ
)paren
id|sk-&gt;rto
op_assign
l_int|120
op_star
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rto
OL
id|HZ
op_div
l_int|5
)paren
multiline_comment|/* Was 1*HZ, then 1 - turns out we must allow about&n;&t;&t;&t;&t;&t;&t;   .2 of a second because of BSD delayed acks - on a 100Mb/sec link&n;&t;&t;&t;&t;&t;&t;   .2 of a second is going to need huge windows (SIGH) */
id|sk-&gt;rto
op_assign
id|HZ
op_div
l_int|5
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;&t; *&t;See if we can take anything off of the retransmit queue.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|sk-&gt;send_head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_break
suffix:semicolon
multiline_comment|/* Check for a bug. */
r_if
c_cond
(paren
id|skb-&gt;link3
op_logical_and
id|after
c_func
(paren
id|skb-&gt;end_seq
comma
id|skb-&gt;link3-&gt;end_seq
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;INET: tcp.c: *** bug send_list out of order.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;If our packet is before the ack sequence we can&n;&t;&t; *&t;discard it as it&squot;s confirmed to have arrived the other end.&n;&t;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|skb-&gt;end_seq
comma
id|ack
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;retransmits
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;We were retransmitting.  don&squot;t count this in RTT est &n;&t;&t;&t; */
id|flag
op_or_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sk-&gt;send_head
op_assign
id|skb-&gt;link3
)paren
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;send_tail
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;send_next
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * advance the send_next pointer if needed.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;send_next
op_eq
id|skb
)paren
id|sk-&gt;send_next
op_assign
id|sk-&gt;send_head
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Note that we only reset backoff and rto in the&n;&t;&t; * rtt recomputation code.  And that doesn&squot;t happen&n;&t;&t; * if there were retransmissions in effect.  So the&n;&t;&t; * first new packet after the retransmissions is&n;&t;&t; * sent with the backoff still in effect.  Not until&n;&t;&t; * we get an ack from a non-retransmitted packet do&n;&t;&t; * we reset the backoff and rto.  This allows us to deal&n;&t;&t; * with a situation where the network delay has increased&n;&t;&t; * suddenly.  I.e. Karn&squot;s algorithm. (SIGCOMM &squot;87, p5.)&n;&t;&t; */
multiline_comment|/*&n;&t;&t; *&t;We have one less packet out there. &n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;packets_out
OG
l_int|0
)paren
id|sk-&gt;packets_out
op_decrement
suffix:semicolon
multiline_comment|/* This is really only supposed to be called when we&n;&t;&t; * are actually ACKing new data, which should exclude&n;&t;&t; * the ACK handshake on an initial SYN packet as well.&n;&t;&t; * Rather than introducing a new test here for this&n;&t;&t; * special case, we just reset the initial values for&n;&t;&t; * rtt immediatly after we move to the established state.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flag
op_amp
l_int|2
)paren
)paren
multiline_comment|/* Not retransmitting */
id|tcp_rtt_estimator
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;We may need to remove this from the dev send list. &n;&t;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;next
)paren
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
multiline_comment|/* write. */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Maybe we can take some stuff off of the write queue,&n;&t; * and put it onto the xmit queue.&n;&t; * FIXME: (?) There is bizarre case being tested here, to check if&n;&t; * the data at the head of the queue ends before the start of&n;&t; * the sequence we already ACKed. This does not appear to be&n;&t; * a case that can actually occur. Why are we testing it?&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_logical_and
op_logical_neg
id|before
c_func
(paren
id|sk-&gt;window_seq
comma
id|sk-&gt;write_queue.next-&gt;end_seq
)paren
op_logical_and
(paren
id|sk-&gt;retransmits
op_eq
l_int|0
op_logical_or
id|sk-&gt;ip_xmit_timeout
op_ne
id|TIME_WRITE
op_logical_or
op_logical_neg
id|after
c_func
(paren
id|sk-&gt;write_queue.next-&gt;end_seq
comma
id|sk-&gt;rcv_ack_seq
)paren
)paren
op_logical_and
id|sk-&gt;packets_out
OL
id|sk-&gt;cong_window
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Add more data to the send queue.&n;&t;&t; */
id|tcp_write_xmit
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Reset timers to reflect the new state.&n;&t; *&n;&t; * from TIME_WAIT we stay in TIME_WAIT as long as we rx packets&n;&t; * from TCP_CLOSE we don&squot;t do anything&n;&t; *&n;&t; * from anything else, if there is queued data (or fin) pending,&n;&t; * we use a TIME_WRITE timeout, if there is data to write but&n;&t; * no room in the window we use TIME_PROBE0, else if keepalive&n;&t; * we reset to a KEEPALIVE timeout, else we delete the timer.&n;&t; *&n;&t; * We do not set flag for nominal write data, otherwise we may&n;&t; * force a state where we start to write itsy bitsy tidbits&n;&t; * of data.&n;&t; */
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_TIME_WAIT
suffix:colon
multiline_comment|/*&n;&t;&t; * keep us in TIME_WAIT until we stop getting packets,&n;&t;&t; * reset the timeout.&n;&t;&t; */
id|tcp_reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE
suffix:colon
multiline_comment|/*&n;&t;&t; * don&squot;t touch the timer.&n;&t;&t; */
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/*&n;&t;&t; * &t;Must check send_head and write_queue&n;&t;&t; * &t;to determine which timeout to use.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;send_head
)paren
(brace
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_logical_and
id|sk-&gt;ack_backlog
op_eq
l_int|0
)paren
(brace
multiline_comment|/* &n;&t;&t;&t; * if the write queue is not empty when we get here&n;&t;&t;&t; * then we failed to move any data to the retransmit&n;&t;&t;&t; * queue above. (If we had send_head would be non-NULL).&n;&t;&t;&t; * Furthermore, since the send_head is NULL here&n;&t;&t;&t; * we must not be in retransmit mode at this point.&n;&t;&t;&t; * This implies we have no packets in flight,&n;&t;&t;&t; * hence sk-&gt;packets_out &lt; sk-&gt;cong_window.&n;&t;&t;&t; * Examining the conditions for the test to move&n;&t;&t;&t; * data to the retransmission queue we find that&n;&t;&t;&t; * we must therefore have a zero window.&n;&t;&t;&t; * Hence, if the ack_backlog is 0 we should initiate&n;&t;&t;&t; * a zero probe.&n;&t;&t;&t; * We don&squot;t do a zero probe if we have a delayed&n;&t;&t;&t; * ACK in hand since the other side may have a&n;&t;&t;&t; * window opening, but they are waiting to hear&n;&t;&t;&t; * from us before they tell us about it.&n;&t;&t;&t; * (They are applying Nagle&squot;s rule).&n;&t;&t;&t; * So, we don&squot;t set up the zero window probe&n;&t;&t;&t; * just yet. We do have to clear the timer&n;&t;&t;&t; * though in this case...&n;&t;&t;&t; */
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sk-&gt;keepopen
)paren
(brace
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_KEEPOPEN
comma
id|TCP_TIMEOUT_LEN
)paren
suffix:semicolon
)brace
r_else
(brace
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;retransmit_timer
)paren
suffix:semicolon
id|sk-&gt;ip_xmit_timeout
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;We have nothing queued but space to send. Send any partial&n;&t; *&t;packets immediately (end of Nagle rule application).&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;packets_out
op_eq
l_int|0
op_logical_and
id|sk-&gt;partial
op_ne
l_int|NULL
op_logical_and
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_logical_and
id|sk-&gt;send_head
op_eq
l_int|NULL
)paren
(brace
id|tcp_send_partial
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * In the LAST_ACK case, the other end FIN&squot;d us.  We then FIN&squot;d them, and&n;&t; * we are now waiting for an acknowledge to our FIN.  The other end is&n;&t; * already in TIME_WAIT.&n;&t; *&n;&t; * Move to TCP_CLOSE on success.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LAST_ACK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rcv_ack_seq: %X==%X, acked_seq: %X==%X&bslash;n&quot;
comma
id|sk-&gt;rcv_ack_seq
comma
id|sk-&gt;write_seq
comma
id|sk-&gt;acked_seq
comma
id|sk-&gt;fin_seq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;rcv_ack_seq
op_eq
id|sk-&gt;write_seq
multiline_comment|/*&amp;&amp; sk-&gt;acked_seq == sk-&gt;fin_seq*/
)paren
(brace
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Incoming ACK to a FIN we sent in the case of our initiating the close.&n;&t; *&n;&t; *&t;Move to FIN_WAIT2 to await a FIN from the other end. Set&n;&t; *&t;SEND_SHUTDOWN but not RCV_SHUTDOWN as data can still be coming in.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rcv_ack_seq
op_eq
id|sk-&gt;write_seq
)paren
(brace
id|sk-&gt;shutdown
op_or_assign
id|SEND_SHUTDOWN
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_FIN_WAIT2
)paren
suffix:semicolon
multiline_comment|/* If the socket is dead, then there is no&n;&t;&t;&t; * user process hanging around using it.&n;&t;&t;&t; * We want to set up a FIN_WAIT2 timeout ala BSD.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;dead
)paren
id|tcp_reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_FIN_TIMEOUT
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Incoming ACK to a FIN we sent in the case of a simultaneous close.&n;&t; *&n;&t; *&t;Move to TIME_WAIT&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSING
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rcv_ack_seq
op_eq
id|sk-&gt;write_seq
)paren
(brace
id|tcp_time_wait
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Final ack of a three way shake &n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_RECV
)paren
(brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_ESTABLISHED
)paren
suffix:semicolon
id|tcp_options
c_func
(paren
id|sk
comma
id|th
)paren
suffix:semicolon
id|sk-&gt;dummy_th.dest
op_assign
id|th-&gt;source
suffix:semicolon
id|sk-&gt;copied_seq
op_assign
id|sk-&gt;acked_seq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;max_window
op_eq
l_int|0
)paren
(brace
id|sk-&gt;max_window
op_assign
l_int|32
suffix:semicolon
multiline_comment|/* Sanity check */
id|sk-&gt;mss
op_assign
id|min
c_func
(paren
id|sk-&gt;max_window
comma
id|sk-&gt;mtu
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset the RTT estimator to the initial&n;&t;&t; * state rather than testing to avoid&n;&t;&t; * updating it on the ACK to the SYN packet.&n;&t;&t; */
id|sk-&gt;rtt
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;rto
op_assign
id|TCP_TIMEOUT_INIT
suffix:semicolon
id|sk-&gt;mdev
op_assign
id|TCP_TIMEOUT_INIT
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The following code has been greatly simplified from the&n;&t; * old hacked up stuff. The wonders of properly setting the&n;&t; * retransmission timeouts.&n;&t; *&n;&t; * If we are retransmitting, and we acked a packet on the retransmit&n;&t; * queue, and there is still something in the retransmit queue,&n;&t; * then we can output some retransmission packets.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;send_head
op_ne
l_int|NULL
op_logical_and
(paren
id|flag
op_amp
l_int|2
)paren
op_logical_and
id|sk-&gt;retransmits
)paren
(brace
id|tcp_do_retransmit
c_func
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
id|uninteresting_ack
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Ack ignored %u %u&bslash;n&quot;
comma
id|ack
comma
id|sk-&gt;sent_seq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Keepalive processing.&n;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|ack
comma
id|sk-&gt;sent_seq
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Restart the keepalive timer.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;keepopen
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;ip_xmit_timeout
op_eq
id|TIME_KEEPOPEN
)paren
(brace
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_KEEPOPEN
comma
id|TCP_TIMEOUT_LEN
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Process the FIN bit. This now behaves as it is supposed to work&n; *&t;and the FIN takes effect when it is validly part of sequence&n; *&t;space. Not before when we get holes.&n; *&n; *&t;If we are ESTABLISHED, a received fin moves us to CLOSE-WAIT&n; *&t;(and thence onto LAST-ACK and finally, CLOSE, we never enter&n; *&t;TIME-WAIT)&n; *&n; *&t;If we are in FINWAIT-1, a received FIN indicates simultaneous&n; *&t;close and we go into CLOSING (and later onto TIME-WAIT)&n; *&n; *&t;If we are in FINWAIT-2, a received FIN moves us to TIME-WAIT.&n; *&n; */
DECL|function|tcp_fin
r_static
r_int
id|tcp_fin
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
id|sk-&gt;fin_seq
op_assign
id|skb-&gt;end_seq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sock_wake_async
c_func
(paren
id|sk-&gt;socket
comma
l_int|1
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_SYN_RECV
suffix:colon
r_case
id|TCP_SYN_SENT
suffix:colon
r_case
id|TCP_ESTABLISHED
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * move to CLOSE_WAIT, tcp_data() already handled&n;&t;&t;&t; * sending the ack.&n;&t;&t;&t; */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE_WAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;rst
)paren
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE_WAIT
suffix:colon
r_case
id|TCP_CLOSING
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * received a retransmission of the FIN, do&n;&t;&t;&t; * nothing.&n;&t;&t;&t; */
r_break
suffix:semicolon
r_case
id|TCP_TIME_WAIT
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * received a retransmission of the FIN,&n;&t;&t;&t; * restart the TIME_WAIT timer.&n;&t;&t;&t; */
id|tcp_reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TCP_FIN_WAIT1
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * This case occurs when a simultaneous close&n;&t;&t;&t; * happens, we must ack the received FIN and&n;&t;&t;&t; * enter the CLOSING state.&n;&t;&t;&t; *&n;&t;&t;&t; * This causes a WRITE timeout, which will either&n;&t;&t;&t; * move on to TIME_WAIT when we timeout, or resend&n;&t;&t;&t; * the FIN properly (maybe we get rid of that annoying&n;&t;&t;&t; * FIN lost hang). The TIME_WRITE code is already correct&n;&t;&t;&t; * for handling this timeout.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;ip_xmit_timeout
op_ne
id|TIME_WRITE
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;send_head
)paren
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;send_head NULL in FIN_WAIT1&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSING
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_FIN_WAIT2
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * received a FIN -- send ACK and enter TIME_WAIT&n;&t;&t;&t; */
id|tcp_reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_or_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_TIME_WAIT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * already in CLOSE&n;&t;&t;&t; */
r_break
suffix:semicolon
r_default
suffix:colon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_LAST_ACK
)paren
suffix:semicolon
multiline_comment|/* Start the timers. */
id|tcp_reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a sk_buff to the TCP receive queue, calculating&n; * the ACK sequence as we go..&n; */
DECL|function|tcp_insert_skb
r_static
r_inline
r_void
id|tcp_insert_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_struct
id|sk_buff
op_star
id|prev
comma
op_star
id|next
suffix:semicolon
id|u32
id|seq
suffix:semicolon
multiline_comment|/*&n;&t; * Find where the new skb goes.. (This goes backwards,&n;&t; * on the assumption that we get the packets in order)&n;&t; */
id|seq
op_assign
id|skb-&gt;seq
suffix:semicolon
id|prev
op_assign
id|list-&gt;prev
suffix:semicolon
id|next
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|prev
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
op_logical_or
op_logical_neg
id|after
c_func
(paren
id|prev-&gt;seq
comma
id|seq
)paren
)paren
r_break
suffix:semicolon
id|next
op_assign
id|prev
suffix:semicolon
id|prev
op_assign
id|prev-&gt;prev
suffix:semicolon
)brace
id|__skb_insert
c_func
(paren
id|skb
comma
id|prev
comma
id|next
comma
id|list
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called for each packet when we find a new ACK endpoint sequence in it&n; */
DECL|function|tcp_queue_ack
r_static
r_inline
id|u32
id|tcp_queue_ack
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
multiline_comment|/*&n;&t; *&t;When we ack the fin, we do the FIN &n;&t; *&t;processing.&n;&t; */
id|skb-&gt;acked
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;fin
)paren
id|tcp_fin
c_func
(paren
id|skb
comma
id|sk
comma
id|skb-&gt;h.th
)paren
suffix:semicolon
r_return
id|skb-&gt;end_seq
suffix:semicolon
)brace
DECL|function|tcp_queue
r_static
r_void
id|tcp_queue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
id|u32
id|ack_seq
suffix:semicolon
id|tcp_insert_skb
c_func
(paren
id|skb
comma
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Did we get anything new to ack?&n;&t; */
id|ack_seq
op_assign
id|sk-&gt;acked_seq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|skb-&gt;seq
comma
id|ack_seq
)paren
)paren
(brace
r_if
c_cond
(paren
id|after
c_func
(paren
id|skb-&gt;end_seq
comma
id|ack_seq
)paren
)paren
(brace
multiline_comment|/* the packet straddles our window end */
r_struct
id|sk_buff_head
op_star
id|list
op_assign
op_amp
id|sk-&gt;receive_queue
suffix:semicolon
r_struct
id|sk_buff
op_star
id|next
suffix:semicolon
id|ack_seq
op_assign
id|tcp_queue_ack
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Do we have any old packets to ack that the above&n;&t;&t;&t; * made visible? (Go forward from skb)&n;&t;&t;&t; */
id|next
op_assign
id|skb-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|next
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
)paren
(brace
r_if
c_cond
(paren
id|after
c_func
(paren
id|next-&gt;seq
comma
id|ack_seq
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|next-&gt;end_seq
comma
id|ack_seq
)paren
)paren
id|ack_seq
op_assign
id|tcp_queue_ack
c_func
(paren
id|next
comma
id|sk
)paren
suffix:semicolon
id|next
op_assign
id|next-&gt;next
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Ok, we found new data, update acked_seq as&n;&t;&t;&t; * necessary (and possibly send the actual&n;&t;&t;&t; * ACK packet).&n;&t;&t;&t; */
id|sk-&gt;acked_seq
op_assign
id|ack_seq
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
id|printk
c_func
(paren
l_string|&quot;Ack duplicate packet.&bslash;n&quot;
)paren
suffix:semicolon
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Delay the ack if possible.  Send ack&squot;s to&n;&t;&t; * fin frames immediately as there shouldn&squot;t be&n;&t;&t; * anything more to come.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;delay_acks
op_logical_or
id|th-&gt;fin
)paren
(brace
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * If psh is set we assume it&squot;s an&n;&t;&t;&t; * interactive session that wants quick&n;&t;&t;&t; * acks to avoid nagling too much. &n;&t;&t;&t; */
r_int
id|delay
op_assign
id|HZ
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;psh
)paren
id|delay
op_assign
id|HZ
op_div
l_int|50
suffix:semicolon
id|tcp_send_delayed_ack
c_func
(paren
id|sk
comma
id|delay
comma
id|sk-&gt;ato
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Tell the user we have some more data.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;     *&t;If we&squot;ve missed a packet, send an ack.&n;&t;     *&t;Also start a timer to send another.&n;&t;     *&n;&t;     *&t;4.3reno machines look for these kind of acks so&n;&t;     *&t;they can do fast recovery. Three identical &squot;old&squot;&n;&t;     *&t;acks lets it know that one frame has been lost&n;&t;     *      and should be resent. Because this is before the&n;&t;     *&t;whole window of data has timed out it can take&n;&t;     *&t;one lost frame per window without stalling.&n;&t;     *&t;[See Jacobson RFC1323, Stevens TCP/IP illus vol2]&n;&t;     *&n;&t;     *&t;We also should be spotting triple bad sequences.&n;&t;     *&t;[We now do this.]&n;&t;     *&n;&t;     */
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;acked
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Ack past end of seq packet.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;     * We need to be very careful here. We must&n;&t;&t;     * not violate Jacobsons packet conservation condition.&n;&t;&t;     * This means we should only send an ACK when a packet&n;&t;&t;     * leaves the network. We can say a packet left the&n;&t;&t;     * network when we see a packet leave the network, or&n;&t;&t;     * when an rto measure expires.&n;&t;&t;     */
id|tcp_send_delayed_ack
c_func
(paren
id|sk
comma
id|sk-&gt;rto
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; *&t;This routine handles the data.  If there is room in the buffer,&n; *&t;it will be have already been moved into it.  If there is no&n; *&t;room, then we will just have to discard the packet.&n; */
DECL|function|tcp_data
r_static
r_int
id|tcp_data
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
id|u32
id|new_seq
comma
id|shut_seq
suffix:semicolon
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|th-&gt;doff
op_star
l_int|4
)paren
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
id|len
op_minus
(paren
id|th-&gt;doff
op_star
l_int|4
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;The bytes in the receive read/assembly queue has increased. Needed for the&n;&t; *&t;low memory discard algorithm &n;&t; */
id|sk-&gt;bytes_rcv
op_add_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
op_eq
l_int|0
op_logical_and
op_logical_neg
id|th-&gt;fin
)paren
(brace
multiline_comment|/* &n;&t;&t; *&t;Don&squot;t want to keep passing ack&squot;s back and forth. &n;&t;&t; *&t;(someone sent us dataless, boring frame)&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;ack
)paren
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;We no longer have anyone receiving data on this connection.&n;&t; */
macro_line|#ifndef TCP_DONT_RST_SHUTDOWN&t;&t; 
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;FIXME: BSD has some magic to avoid sending resets to&n;&t;&t; *&t;broken 4.2 BSD keepalives. Much to my surprise a few non&n;&t;&t; *&t;BSD stacks still have broken keepalives so we want to&n;&t;&t; *&t;cope with it.&n;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;len
)paren
multiline_comment|/* We don&squot;t care if it&squot;s just an ack or&n;&t;&t;&t;&t;   a keepalive/window probe */
(brace
id|new_seq
op_assign
id|skb-&gt;seq
op_plus
id|skb-&gt;len
op_plus
id|th-&gt;syn
suffix:semicolon
multiline_comment|/* Right edge of _data_ part of frame */
multiline_comment|/* Do this the way 4.4BSD treats it. Not what I&squot;d&n;&t;&t;&t;   regard as the meaning of the spec but it&squot;s what BSD&n;&t;&t;&t;   does and clearly they know everything 8) */
multiline_comment|/*&n;&t;&t;&t; *&t;This is valid because of two things&n;&t;&t;&t; *&n;&t;&t;&t; *&t;a) The way tcp_data behaves at the bottom.&n;&t;&t;&t; *&t;b) A fin takes effect when read not when received.&n;&t;&t;&t; */
id|shut_seq
op_assign
id|sk-&gt;acked_seq
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Last byte */
r_if
c_cond
(paren
id|after
c_func
(paren
id|new_seq
comma
id|shut_seq
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Data arrived on %p after close [Data right edge %X, Socket shut on %X] %d&bslash;n&quot;
comma
id|sk
comma
id|new_seq
comma
id|shut_seq
comma
id|sk-&gt;blog
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;dead
)paren
(brace
id|sk-&gt;acked_seq
op_assign
id|new_seq
op_plus
id|th-&gt;fin
suffix:semicolon
id|tcp_send_reset
c_func
(paren
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
id|skb-&gt;h.th
comma
id|sk-&gt;prot
comma
l_int|NULL
comma
id|skb-&gt;dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
id|tcp_statistics.TcpEstabResets
op_increment
suffix:semicolon
id|sk-&gt;err
op_assign
id|EPIPE
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;  &t; * We should only call this if there is data in the frame.&n; &t; */
id|tcp_delack_estimator
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_queue
c_func
(paren
id|skb
comma
id|sk
comma
id|th
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine is only called when we have urgent data&n; *&t;signalled. Its the &squot;slow&squot; part of tcp_urg. It could be&n; *&t;moved inline now as tcp_urg is only called from one&n; *&t;place. We handle URGent data wrong. We have to - as&n; *&t;BSD still doesn&squot;t use the correction from RFC961.&n; */
DECL|function|tcp_check_urg
r_static
r_void
id|tcp_check_urg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
id|u32
id|ptr
op_assign
id|ntohs
c_func
(paren
id|th-&gt;urg_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
id|ptr
op_decrement
suffix:semicolon
id|ptr
op_add_assign
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
suffix:semicolon
multiline_comment|/* ignore urgent data that we&squot;ve already seen and read */
r_if
c_cond
(paren
id|after
c_func
(paren
id|sk-&gt;copied_seq
comma
id|ptr
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* do we already have a newer (or duplicate) urgent pointer? */
r_if
c_cond
(paren
id|sk-&gt;urg_data
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|ptr
comma
id|sk-&gt;urg_seq
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* tell the world about our new urgent pointer */
r_if
c_cond
(paren
id|sk-&gt;proc
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;proc
OG
l_int|0
)paren
(brace
id|kill_proc
c_func
(paren
id|sk-&gt;proc
comma
id|SIGURG
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|kill_pg
c_func
(paren
op_minus
id|sk-&gt;proc
comma
id|SIGURG
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|sk-&gt;urg_data
op_assign
id|URG_NOTYET
suffix:semicolon
id|sk-&gt;urg_seq
op_assign
id|ptr
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is the &squot;fast&squot; part of urgent handling.&n; */
DECL|function|tcp_urg
r_static
r_inline
r_void
id|tcp_urg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
r_int
id|len
)paren
(brace
multiline_comment|/*&n;&t; *&t;Check if we get a new urgent pointer - normally not &n;&t; */
r_if
c_cond
(paren
id|th-&gt;urg
)paren
id|tcp_check_urg
c_func
(paren
id|sk
comma
id|th
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Do we wait for any urgent data? - normally not&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;urg_data
op_eq
id|URG_NOTYET
)paren
(brace
id|u32
id|ptr
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Is the urgent pointer pointing into this packet? &n;&t;&t; */
id|ptr
op_assign
id|sk-&gt;urg_seq
op_minus
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
op_plus
id|th-&gt;doff
op_star
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|ptr
OL
id|len
)paren
(brace
id|sk-&gt;urg_data
op_assign
id|URG_VALID
op_or
op_star
(paren
id|ptr
op_plus
(paren
r_int
r_char
op_star
)paren
id|th
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * This should be a bit smarter and remove partially&n; * overlapping stuff too, but this should be good&n; * enough for any even remotely normal case (and the&n; * worst that can happen is that we have a few&n; * unnecessary packets in the receive queue).&n; *&n; * This function is never called with an empty list..&n; */
DECL|function|tcp_remove_dups
r_static
r_inline
r_void
id|tcp_remove_dups
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_struct
id|sk_buff
op_star
id|next
op_assign
id|list-&gt;next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|next
suffix:semicolon
id|next
op_assign
id|next-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|next
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|before
c_func
(paren
id|next-&gt;end_seq
comma
id|skb-&gt;end_seq
)paren
)paren
(brace
id|__skb_unlink
c_func
(paren
id|next
comma
id|list
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|next
comma
id|FREE_READ
)paren
suffix:semicolon
id|next
op_assign
id|skb
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|next-&gt;seq
op_ne
id|skb-&gt;seq
)paren
r_continue
suffix:semicolon
id|__skb_unlink
c_func
(paren
id|skb
comma
id|list
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Throw out all unnecessary packets: we&squot;ve gone over the&n; * receive queue limit. This shouldn&squot;t happen in a normal&n; * TCP connection, but we might have gotten duplicates etc.&n; */
DECL|function|prune_queue
r_static
r_void
id|prune_queue
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|list-&gt;prev
suffix:semicolon
multiline_comment|/* gone through it all? */
r_if
c_cond
(paren
id|skb
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;acked
)paren
(brace
id|__skb_unlink
c_func
(paren
id|skb
comma
id|list
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|tcp_remove_dups
c_func
(paren
id|list
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_IP_TRANSPARENT_PROXY
multiline_comment|/*&n; *&t;Check whether a received TCP packet might be for one of our&n; *&t;connections.&n; */
DECL|function|tcp_chkaddr
r_int
id|tcp_chkaddr
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;h.iph
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
(paren
id|skb-&gt;h.raw
op_plus
id|iph-&gt;ihl
op_star
l_int|4
)paren
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|sk
op_assign
id|get_sock
c_func
(paren
op_amp
id|tcp_prot
comma
id|th-&gt;dest
comma
id|iph-&gt;saddr
comma
id|th-&gt;source
comma
id|iph-&gt;daddr
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* 0 means accept all LOCAL addresses here, not all the world... */
r_if
c_cond
(paren
id|sk-&gt;rcv_saddr
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; *&t;A TCP packet has arrived.&n; *&t;&t;skb-&gt;h.raw is the TCP header.&n; */
DECL|function|tcp_rcv
r_int
id|tcp_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|options
op_star
id|opt
comma
id|__u32
id|daddr
comma
r_int
r_int
id|len
comma
id|__u32
id|saddr
comma
r_int
id|redo
comma
r_struct
id|inet_protocol
op_star
id|protocol
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_int
id|syn_ok
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_IP_TRANSPARENT_PROXY
r_int
id|r
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * &quot;redo&quot; is 1 if we have already seen this skb but couldn&squot;t&n;&t; * use it at that time (the socket was locked).  In that case&n;&t; * we have already done a lot of the work (looked up the socket&n;&t; * etc).&n;&t; */
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
id|sk
op_assign
id|skb-&gt;sk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|redo
)paren
(brace
id|tcp_statistics.TcpInSegs
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;pkt_type
op_ne
id|PACKET_HOST
)paren
r_goto
id|discard_it
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Pull up the IP header.&n;&t;&t; */
id|skb_pull
c_func
(paren
id|skb
comma
id|skb-&gt;h.raw
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Try to use the device checksum if provided.&n;&t;&t; */
r_switch
c_cond
(paren
id|skb-&gt;ip_summed
)paren
(brace
r_case
id|CHECKSUM_NONE
suffix:colon
id|skb-&gt;csum
op_assign
id|csum_partial
c_func
(paren
(paren
r_char
op_star
)paren
id|th
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
r_case
id|CHECKSUM_HW
suffix:colon
r_if
c_cond
(paren
id|tcp_check
c_func
(paren
id|th
comma
id|len
comma
id|saddr
comma
id|daddr
comma
id|skb-&gt;csum
)paren
)paren
r_goto
id|discard_it
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* CHECKSUM_UNNECESSARY */
)brace
id|sk
op_assign
id|get_tcp_sock
c_func
(paren
id|saddr
comma
id|th-&gt;source
comma
id|daddr
comma
id|th-&gt;dest
comma
id|dev-&gt;pa_addr
comma
id|skb-&gt;redirport
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk
)paren
r_goto
id|no_tcp_socket
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
suffix:semicolon
id|skb-&gt;end_seq
op_assign
id|skb-&gt;seq
op_plus
id|th-&gt;syn
op_plus
id|th-&gt;fin
op_plus
id|len
op_minus
id|th-&gt;doff
op_star
l_int|4
suffix:semicolon
id|skb-&gt;ack_seq
op_assign
id|ntohl
c_func
(paren
id|th-&gt;ack_seq
)paren
suffix:semicolon
id|skb-&gt;acked
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;used
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;saddr
op_assign
id|daddr
suffix:semicolon
id|skb-&gt;daddr
op_assign
id|saddr
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We may need to add it to the backlog here. &n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;users
)paren
(brace
id|__skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;back_log
comma
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;If this socket has got a reset it&squot;s to all intents and purposes &n;&t; *&t;really dead. Count closed sockets as dead.&n;&t; *&n;&t; *&t;Note: BSD appears to have a bug here. A &squot;closed&squot; TCP in BSD&n;&t; *&t;simply drops data. This seems incorrect as a &squot;closed&squot; TCP doesn&squot;t&n;&t; *&t;exist so should cause resets as if the port was unreachable.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;zapped
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
r_goto
id|no_tcp_socket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;prot
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;IMPOSSIBLE 3&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Charge the memory to the socket. &n;&t; */
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|atomic_add
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;rmem_alloc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the time of the last received packet.&n;&t; */
id|sk-&gt;idletime
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We should now do header prediction.&n;&t; */
multiline_comment|/*&n;&t; *&t;This basically follows the flow suggested by RFC793, with the corrections in RFC1122. We&n;&t; *&t;don&squot;t implement precedence and we process URG incorrectly (deliberately so) for BSD bug&n;&t; *&t;compatibility. We also set up variables more thoroughly [Karn notes in the&n;&t; *&t;KA9Q code the RFC793 incoming segment rules don&squot;t initialise the variables for all paths].&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
)paren
multiline_comment|/* Skip this lot for normal flow */
(brace
multiline_comment|/*&n;&t;&t; *&t;Now deal with unusual cases.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
(brace
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
multiline_comment|/* These use the socket TOS.. might want to be the received TOS */
id|tcp_send_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;We don&squot;t care for RST, and non SYN are absorbed (old segments)&n;&t;&t;&t; *&t;Broadcast/multicast SYN isn&squot;t allowed. Note - bug if you change the&n;&t;&t;&t; *&t;netmask on a running connection it can go broadcast. Even Sun&squot;s have&n;&t;&t;&t; *&t;this problem so I&squot;m ignoring it &n;&t;&t;&t; */
macro_line|#ifdef CONFIG_IP_TRANSPARENT_PROXY
multiline_comment|/*&n;&t;&t;&t; * We may get non-local addresses and still want to&n;&t;&t;&t; * handle them locally, due to transparent proxying.&n;&t;&t;&t; * Thus, narrow down the test to what is really meant.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|th-&gt;rst
op_logical_or
op_logical_neg
id|th-&gt;syn
op_logical_or
id|th-&gt;ack
op_logical_or
(paren
id|r
op_assign
id|ip_chk_addr
c_func
(paren
id|daddr
)paren
op_eq
id|IS_BROADCAST
op_logical_or
id|r
op_eq
id|IS_MULTICAST
)paren
)paren
macro_line|#else
r_if
c_cond
(paren
id|th-&gt;rst
op_logical_or
op_logical_neg
id|th-&gt;syn
op_logical_or
id|th-&gt;ack
op_logical_or
id|ip_chk_addr
c_func
(paren
id|daddr
)paren
op_ne
id|IS_MYADDR
)paren
macro_line|#endif
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&t;&n;&t;&t;&t; *&t;Guess we need to make a new socket up &n;&t;&t;&t; */
id|tcp_conn_request
c_func
(paren
id|sk
comma
id|skb
comma
id|daddr
comma
id|saddr
comma
id|opt
comma
id|dev
comma
id|tcp_init_seq
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Now we have several options: In theory there is nothing else&n;&t;&t;&t; *&t;in the frame. KA9Q has an option to send data with the syn,&n;&t;&t;&t; *&t;BSD accepts data with the syn up to the [to be] advertised window&n;&t;&t;&t; *&t;and Solaris 2.1 gives you a protocol error. For now we just ignore&n;&t;&t;&t; *&t;it, that fits the spec precisely and avoids incompatibilities. It&n;&t;&t;&t; *&t;would be nice in future to drop through and process the data.&n;&t;&t;&t; *&n;&t;&t;&t; *&t;Now TTCP is starting to use we ought to queue this data.&n;&t;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; *&t;Retransmitted SYN for our socket. This is uninteresting. If sk-&gt;state==TCP_LISTEN&n;&t;&t; *&t;then it&squot;s a new connection&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_RECV
op_logical_and
id|th-&gt;syn
op_logical_and
id|skb-&gt;seq
op_plus
l_int|1
op_eq
id|sk-&gt;acked_seq
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;SYN sent means we have to look for a suitable ack and either reset&n;&t;&t; *&t;for bad matches or go to connected. The SYN_SENT case is unusual and should&n;&t;&t; *&t;not be in line code. [AC]&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
)paren
(brace
multiline_comment|/* Crossed SYN or previous junk segment */
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
multiline_comment|/* We got an ack, but it&squot;s not a good ack */
r_if
c_cond
(paren
op_logical_neg
id|tcp_ack
c_func
(paren
id|sk
comma
id|th
comma
id|skb-&gt;ack_seq
comma
id|len
)paren
)paren
(brace
multiline_comment|/* Reset the ack - it&squot;s an ack from a &n;&t;&t;&t;&t;&t;   different connection  [ th-&gt;rst is checked in tcp_send_reset()] */
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|tcp_send_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
r_return
id|tcp_reset
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;syn
)paren
(brace
multiline_comment|/* A valid ack from a different connection&n;&t;&t;&t;&t;&t;   start. Shouldn&squot;t happen but cover it */
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|tcp_send_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Ok.. it&squot;s good. Set up sequence numbers and&n;&t;&t;&t;&t; *&t;move to established.&n;&t;&t;&t;&t; */
id|syn_ok
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Don&squot;t reset this connection for the syn */
id|sk-&gt;acked_seq
op_assign
id|skb-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|sk-&gt;lastwin_seq
op_assign
id|skb-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|sk-&gt;fin_seq
op_assign
id|skb-&gt;seq
suffix:semicolon
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_ESTABLISHED
)paren
suffix:semicolon
id|tcp_options
c_func
(paren
id|sk
comma
id|th
)paren
suffix:semicolon
id|sk-&gt;dummy_th.dest
op_assign
id|th-&gt;source
suffix:semicolon
id|sk-&gt;copied_seq
op_assign
id|sk-&gt;acked_seq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sock_wake_async
c_func
(paren
id|sk-&gt;socket
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;max_window
op_eq
l_int|0
)paren
(brace
id|sk-&gt;max_window
op_assign
l_int|32
suffix:semicolon
id|sk-&gt;mss
op_assign
id|min
c_func
(paren
id|sk-&gt;max_window
comma
id|sk-&gt;mtu
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset the RTT estimator to the initial&n;&t;&t;&t;&t; * state rather than testing to avoid&n;&t;&t;&t;&t; * updating it on the ACK to the SYN packet.&n;&t;&t;&t;&t; */
id|sk-&gt;rtt
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;rto
op_assign
id|TCP_TIMEOUT_INIT
suffix:semicolon
id|sk-&gt;mdev
op_assign
id|TCP_TIMEOUT_INIT
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* See if SYN&squot;s cross. Drop if boring */
r_if
c_cond
(paren
id|th-&gt;syn
op_logical_and
op_logical_neg
id|th-&gt;rst
)paren
(brace
multiline_comment|/* Crossed SYN&squot;s are fine - but talking to&n;&t;&t;&t;&t;&t;   yourself is right out... */
r_if
c_cond
(paren
id|sk-&gt;saddr
op_eq
id|saddr
op_logical_and
id|sk-&gt;daddr
op_eq
id|daddr
op_logical_and
id|sk-&gt;dummy_th.source
op_eq
id|th-&gt;source
op_logical_and
id|sk-&gt;dummy_th.dest
op_eq
id|th-&gt;dest
)paren
(brace
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
r_return
id|tcp_reset
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_SYN_RECV
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;FIXME:&n;&t;&t;&t;&t;&t; *&t;Must send SYN|ACK here&n;&t;&t;&t;&t;&t; */
)brace
multiline_comment|/* Discard junk segment */
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;SYN_RECV with data maybe.. drop through&n;&t;&t;&t; */
r_goto
id|rfc_step6
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;BSD has a funny hack with TIME_WAIT and fast reuse of a port. There is&n;&t; *&t;a more complex suggestion for fixing these reuse issues in RFC1644&n;&t; *&t;but not yet ready for general use. Also see RFC1379.&n;&t; *&n;&t; *&t;Note the funny way we go back to the top of this function for&n;&t; *&t;this case (&quot;goto try_next_socket&quot;).  That also takes care of&n;&t; *&t;checking &quot;sk-&gt;users&quot; for the new socket as well as doing all&n;&t; *&t;the normal tests on the packet.&n;&t; */
DECL|macro|BSD_TIME_WAIT
mdefine_line|#define BSD_TIME_WAIT
macro_line|#ifdef BSD_TIME_WAIT
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_TIME_WAIT
op_logical_and
id|th-&gt;syn
op_logical_and
id|sk-&gt;dead
op_logical_and
id|after
c_func
(paren
id|skb-&gt;seq
comma
id|sk-&gt;acked_seq
)paren
op_logical_and
op_logical_neg
id|th-&gt;rst
)paren
(brace
id|u32
id|seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Doing a BSD time wait&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|tcp_statistics.TcpEstabResets
op_increment
suffix:semicolon
id|atomic_sub
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;rmem_alloc
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;err
op_assign
id|ECONNRESET
suffix:semicolon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|sk
op_assign
id|get_sock
c_func
(paren
op_amp
id|tcp_prot
comma
id|th-&gt;dest
comma
id|saddr
comma
id|th-&gt;source
comma
id|daddr
comma
id|dev-&gt;pa_addr
comma
id|skb-&gt;redirport
)paren
suffix:semicolon
multiline_comment|/* this is not really correct: we should check sk-&gt;users */
r_if
c_cond
(paren
id|sk
op_logical_and
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
(brace
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|atomic_add
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;rmem_alloc
)paren
suffix:semicolon
id|tcp_conn_request
c_func
(paren
id|sk
comma
id|skb
comma
id|daddr
comma
id|saddr
comma
id|opt
comma
id|dev
comma
id|seq
op_plus
l_int|128000
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;
)brace
multiline_comment|/*&n;&t; *&t;We are now in normal data flow (see the step list in the RFC)&n;&t; *&t;Note most of these are inline now. I&squot;ll inline the lot when&n;&t; *&t;I have time to test it hard and look at what gcc outputs &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tcp_sequence
c_func
(paren
id|sk
comma
id|skb-&gt;seq
comma
id|skb-&gt;end_seq
op_minus
id|th-&gt;syn
)paren
)paren
(brace
id|bad_tcp_sequence
c_func
(paren
id|sk
comma
id|th
comma
id|skb-&gt;end_seq
op_minus
id|th-&gt;syn
comma
id|dev
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
r_return
id|tcp_reset
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;!syn_ok is effectively the state test in RFC793.&n;&t; */
r_if
c_cond
(paren
id|th-&gt;syn
op_logical_and
op_logical_neg
id|syn_ok
)paren
(brace
id|tcp_send_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
op_amp
id|tcp_prot
comma
id|opt
comma
id|dev
comma
id|skb-&gt;ip_hdr-&gt;tos
comma
l_int|255
)paren
suffix:semicolon
r_return
id|tcp_reset
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Process the ACK&n;&t; */
r_if
c_cond
(paren
id|th-&gt;ack
op_logical_and
op_logical_neg
id|tcp_ack
c_func
(paren
id|sk
comma
id|th
comma
id|skb-&gt;ack_seq
comma
id|len
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Our three way handshake failed.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_RECV
)paren
(brace
id|tcp_send_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|rfc_step6
suffix:colon
multiline_comment|/* I&squot;ll clean this up later */
multiline_comment|/*&n;&t; *&t;If the accepted buffer put us over our queue size we&n;&t; *&t;now drop it (we must process the ack first to avoid&n;&t; *&t;deadlock cases).&n;&t; */
multiline_comment|/*&n;&t; *&t;Process urgent data&n;&t; */
id|tcp_urg
c_func
(paren
id|sk
comma
id|th
comma
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Process the encapsulated data&n;&t; */
r_if
c_cond
(paren
id|tcp_data
c_func
(paren
id|skb
comma
id|sk
comma
id|saddr
comma
id|len
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If our receive queue has grown past its limits,&n;&t; *&t;try to prune away duplicates etc..&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;rmem_alloc
OG
id|sk-&gt;rcvbuf
)paren
id|prune_queue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;And done&n;&t; */
r_return
l_int|0
suffix:semicolon
id|no_tcp_socket
suffix:colon
multiline_comment|/*&n;&t; *&t;No such TCB. If th-&gt;rst is 0 send a reset (checked in tcp_send_reset)&n;&t; */
id|tcp_send_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
op_amp
id|tcp_prot
comma
id|opt
comma
id|dev
comma
id|skb-&gt;ip_hdr-&gt;tos
comma
l_int|255
)paren
suffix:semicolon
id|discard_it
suffix:colon
multiline_comment|/*&n;&t; *&t;Discard frame&n;&t; */
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
