multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Implementation of the Transmission Control Protocol(TCP).&n; *&n; * Version:&t;$Id: tcp_minisocks.c,v 1.5 2000/11/28 17:04:10 davem Exp $&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;&n; *&t;&t;Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/inet_common.h&gt;
macro_line|#ifdef CONFIG_SYSCTL
DECL|macro|SYNC_INIT
mdefine_line|#define SYNC_INIT 0 /* let the user enable it */
macro_line|#else
DECL|macro|SYNC_INIT
mdefine_line|#define SYNC_INIT 1
macro_line|#endif
DECL|variable|sysctl_tcp_tw_recycle
r_int
id|sysctl_tcp_tw_recycle
op_assign
l_int|0
suffix:semicolon
DECL|variable|sysctl_tcp_max_tw_buckets
r_int
id|sysctl_tcp_max_tw_buckets
op_assign
id|NR_FILE
op_star
l_int|2
suffix:semicolon
DECL|variable|sysctl_tcp_syncookies
r_int
id|sysctl_tcp_syncookies
op_assign
id|SYNC_INIT
suffix:semicolon
DECL|variable|sysctl_tcp_abort_on_overflow
r_int
id|sysctl_tcp_abort_on_overflow
op_assign
l_int|0
suffix:semicolon
DECL|function|tcp_in_window
r_static
id|__inline__
r_int
id|tcp_in_window
c_func
(paren
id|u32
id|seq
comma
id|u32
id|end_seq
comma
id|u32
id|s_win
comma
id|u32
id|e_win
)paren
(brace
r_if
c_cond
(paren
id|seq
op_eq
id|s_win
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|end_seq
comma
id|s_win
)paren
op_logical_and
id|before
c_func
(paren
id|seq
comma
id|e_win
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
(paren
id|seq
op_eq
id|e_win
op_logical_and
id|seq
op_eq
id|end_seq
)paren
suffix:semicolon
)brace
multiline_comment|/* New-style handling of TIME_WAIT sockets. */
DECL|variable|tcp_tw_count
r_int
id|tcp_tw_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Must be called with locally disabled BHs. */
DECL|function|tcp_timewait_kill
r_void
id|tcp_timewait_kill
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
)paren
(brace
r_struct
id|tcp_ehash_bucket
op_star
id|ehead
suffix:semicolon
r_struct
id|tcp_bind_hashbucket
op_star
id|bhead
suffix:semicolon
r_struct
id|tcp_bind_bucket
op_star
id|tb
suffix:semicolon
multiline_comment|/* Unlink from established hashes. */
id|ehead
op_assign
op_amp
id|tcp_ehash
(braket
id|tw-&gt;hashent
)braket
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|ehead-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tw-&gt;pprev
)paren
(brace
id|write_unlock
c_func
(paren
op_amp
id|ehead-&gt;lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tw-&gt;next
)paren
(brace
id|tw-&gt;next-&gt;pprev
op_assign
id|tw-&gt;pprev
suffix:semicolon
)brace
op_star
(paren
id|tw-&gt;pprev
)paren
op_assign
id|tw-&gt;next
suffix:semicolon
id|tw-&gt;pprev
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|ehead-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Disassociate with bind bucket. */
id|bhead
op_assign
op_amp
id|tcp_bhash
(braket
id|tcp_bhashfn
c_func
(paren
id|tw-&gt;num
)paren
)braket
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|bhead-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tb
op_assign
id|tw-&gt;tb
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|tw-&gt;bind_next
)paren
(brace
id|tw-&gt;bind_next-&gt;bind_pprev
op_assign
id|tw-&gt;bind_pprev
suffix:semicolon
)brace
op_star
(paren
id|tw-&gt;bind_pprev
)paren
op_assign
id|tw-&gt;bind_next
suffix:semicolon
id|tw-&gt;tb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;owners
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|tb-&gt;next
)paren
id|tb-&gt;next-&gt;pprev
op_assign
id|tb-&gt;pprev
suffix:semicolon
op_star
(paren
id|tb-&gt;pprev
)paren
op_assign
id|tb-&gt;next
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|tcp_bucket_cachep
comma
id|tb
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|bhead-&gt;lock
)paren
suffix:semicolon
macro_line|#ifdef INET_REFCNT_DEBUG
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|tw-&gt;refcnt
)paren
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tw_bucket %p refcnt=%d&bslash;n&quot;
comma
id|tw
comma
id|atomic_read
c_func
(paren
op_amp
id|tw-&gt;refcnt
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * * Main purpose of TIME-WAIT state is to close connection gracefully,&n; *   when one of ends sits in LAST-ACK or CLOSING retransmitting FIN&n; *   (and, probably, tail of data) and one or more our ACKs are lost.&n; * * What is TIME-WAIT timeout? It is associated with maximal packet&n; *   lifetime in the internet, which results in wrong conclusion, that&n; *   it is set to catch &quot;old duplicate segments&quot; wandering out of their path.&n; *   It is not quite correct. This timeout is calculated so that it exceeds&n; *   maximal retransmision timeout enough to allow to lose one (or more)&n; *   segments sent by peer and our ACKs. This time may be calculated from RTO.&n; * * When TIME-WAIT socket receives RST, it means that another end&n; *   finally closed and we are allowed to kill TIME-WAIT too.&n; * * Second purpose of TIME-WAIT is catching old duplicate segments.&n; *   Well, certainly it is pure paranoia, but if we load TIME-WAIT&n; *   with this semantics, we MUST NOT kill TIME-WAIT state with RSTs.&n; * * If we invented some more clever way to catch duplicates&n; *   (f.e. based on PAWS), we could truncate TIME-WAIT to several RTOs.&n; *&n; * The algorithm below is based on FORMAL INTERPRETATION of RFCs.&n; * When you compare it to RFCs, please, read section SEGMENT ARRIVES&n; * from the very beginning.&n; *&n; * NOTE. With recycling (and later with fin-wait-2) TW bucket&n; * is _not_ stateless. It means, that strictly speaking we must&n; * spinlock it. I do not want! Well, probability of misbehaviour&n; * is ridiculously low and, seems, we could use some mb() tricks&n; * to avoid misread sequence numbers, states etc.  --ANK&n; */
r_enum
id|tcp_tw_status
DECL|function|tcp_timewait_state_process
id|tcp_timewait_state_process
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
)paren
(brace
r_struct
id|tcp_opt
id|tp
suffix:semicolon
r_int
id|paws_reject
op_assign
l_int|0
suffix:semicolon
id|tp.saw_tstamp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;doff
OG
(paren
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_rshift
l_int|2
)paren
op_logical_and
id|tw-&gt;ts_recent_stamp
)paren
(brace
id|tcp_parse_options
c_func
(paren
id|skb
comma
op_amp
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp.saw_tstamp
)paren
(brace
id|tp.ts_recent
op_assign
id|tw-&gt;ts_recent
suffix:semicolon
id|tp.ts_recent_stamp
op_assign
id|tw-&gt;ts_recent_stamp
suffix:semicolon
id|paws_reject
op_assign
id|tcp_paws_check
c_func
(paren
op_amp
id|tp
comma
id|th-&gt;rst
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tw-&gt;substate
op_eq
id|TCP_FIN_WAIT2
)paren
(brace
multiline_comment|/* Just repeat all the checks of tcp_rcv_state_process() */
multiline_comment|/* Out of window, send ACK */
r_if
c_cond
(paren
id|paws_reject
op_logical_or
op_logical_neg
id|tcp_in_window
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tw-&gt;rcv_nxt
comma
id|tw-&gt;rcv_nxt
op_plus
id|tw-&gt;rcv_wnd
)paren
)paren
r_return
id|TCP_TW_ACK
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;rst
)paren
r_goto
id|kill
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;syn
op_logical_and
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_ne
id|tw-&gt;syn_seq
)paren
r_goto
id|kill_with_rst
suffix:semicolon
multiline_comment|/* Dup ACK? */
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tw-&gt;rcv_nxt
)paren
op_logical_or
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_eq
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
(brace
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
r_return
id|TCP_TW_SUCCESS
suffix:semicolon
)brace
multiline_comment|/* New data or FIN. If new data arrive after half-duplex close,&n;&t;&t; * reset.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;fin
op_logical_or
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_ne
id|tw-&gt;rcv_nxt
op_plus
l_int|1
)paren
(brace
id|kill_with_rst
suffix:colon
id|tcp_tw_deschedule
c_func
(paren
id|tw
)paren
suffix:semicolon
id|tcp_timewait_kill
c_func
(paren
id|tw
)paren
suffix:semicolon
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
r_return
id|TCP_TW_RST
suffix:semicolon
)brace
multiline_comment|/* FIN arrived, enter true time-wait state. */
id|tw-&gt;substate
op_assign
id|TCP_TIME_WAIT
suffix:semicolon
id|tw-&gt;rcv_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
r_if
c_cond
(paren
id|tp.saw_tstamp
)paren
(brace
id|tw-&gt;ts_recent_stamp
op_assign
id|xtime.tv_sec
suffix:semicolon
id|tw-&gt;ts_recent
op_assign
id|tp.rcv_tsval
suffix:semicolon
)brace
multiline_comment|/* I am shamed, but failed to make it more elegant.&n;&t;&t; * Yes, it is direct reference to IP, which is impossible&n;&t;&t; * to generalize to IPv6. Taking into account that IPv6&n;&t;&t; * do not undertsnad recycling in any case, it not&n;&t;&t; * a big problem in practice. --ANK */
r_if
c_cond
(paren
id|tw-&gt;family
op_eq
id|AF_INET
op_logical_and
id|sysctl_tcp_tw_recycle
op_logical_and
id|tw-&gt;ts_recent_stamp
op_logical_and
id|tcp_v4_tw_remember_stamp
c_func
(paren
id|tw
)paren
)paren
id|tcp_tw_schedule
c_func
(paren
id|tw
comma
id|tw-&gt;timeout
)paren
suffix:semicolon
r_else
id|tcp_tw_schedule
c_func
(paren
id|tw
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
r_return
id|TCP_TW_ACK
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Now real TIME-WAIT state.&n;&t; *&n;&t; *&t;RFC 1122:&n;&t; *&t;&quot;When a connection is [...] on TIME-WAIT state [...]&n;&t; *&t;[a TCP] MAY accept a new SYN from the remote TCP to&n;&t; *&t;reopen the connection directly, if it:&n;&t; *&t;&n;&t; *&t;(1)  assigns its initial sequence number for the new&n;&t; *&t;connection to be larger than the largest sequence&n;&t; *&t;number it used on the previous connection incarnation,&n;&t; *&t;and&n;&t; *&n;&t; *&t;(2)  returns to TIME-WAIT state if the SYN turns out &n;&t; *&t;to be an old duplicate&quot;.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|paws_reject
op_logical_and
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_eq
id|tw-&gt;rcv_nxt
op_logical_and
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_eq
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_logical_or
id|th-&gt;rst
)paren
)paren
)paren
(brace
multiline_comment|/* In window segment, it may be only reset or bare ack. */
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
multiline_comment|/* This is TIME_WAIT assasination, in two flavors.&n;&t;&t;&t; * Oh well... nobody has a sufficient solution to this&n;&t;&t;&t; * protocol bug yet.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sysctl_tcp_rfc1337
op_eq
l_int|0
)paren
(brace
id|kill
suffix:colon
id|tcp_tw_deschedule
c_func
(paren
id|tw
)paren
suffix:semicolon
id|tcp_timewait_kill
c_func
(paren
id|tw
)paren
suffix:semicolon
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
r_return
id|TCP_TW_SUCCESS
suffix:semicolon
)brace
)brace
id|tcp_tw_schedule
c_func
(paren
id|tw
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp.saw_tstamp
)paren
(brace
id|tw-&gt;ts_recent
op_assign
id|tp.rcv_tsval
suffix:semicolon
id|tw-&gt;ts_recent_stamp
op_assign
id|xtime.tv_sec
suffix:semicolon
)brace
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
r_return
id|TCP_TW_SUCCESS
suffix:semicolon
)brace
multiline_comment|/* Out of window segment.&n;&n;&t;   All the segments are ACKed immediately.&n;&n;&t;   The only exception is new SYN. We accept it, if it is&n;&t;   not old duplicate and we are not in danger to be killed&n;&t;   by delayed old duplicates. RFC check is that it has&n;&t;   newer sequence number works at rates &lt;40Mbit/sec.&n;&t;   However, if paws works, it is reliable AND even more,&n;&t;   we even may relax silly seq space cutoff.&n;&n;&t;   RED-PEN: we violate main RFC requirement, if this SYN will appear&n;&t;   old duplicate (i.e. we receive RST in reply to SYN-ACK),&n;&t;   we must return socket to time-wait state. It is not good,&n;&t;   but not fatal yet.&n;&t; */
r_if
c_cond
(paren
id|th-&gt;syn
op_logical_and
op_logical_neg
id|th-&gt;rst
op_logical_and
op_logical_neg
id|th-&gt;ack
op_logical_and
op_logical_neg
id|paws_reject
op_logical_and
(paren
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|tw-&gt;rcv_nxt
)paren
op_logical_or
(paren
id|tp.saw_tstamp
op_logical_and
(paren
id|s32
)paren
(paren
id|tw-&gt;ts_recent
op_minus
id|tp.rcv_tsval
)paren
OL
l_int|0
)paren
)paren
)paren
(brace
id|u32
id|isn
op_assign
id|tw-&gt;snd_nxt
op_plus
l_int|65535
op_plus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|isn
op_eq
l_int|0
)paren
id|isn
op_increment
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|isn
suffix:semicolon
r_return
id|TCP_TW_SYN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|paws_reject
)paren
id|NET_INC_STATS_BH
c_func
(paren
id|PAWSEstabRejected
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;rst
)paren
(brace
multiline_comment|/* In this case we must reset the TIMEWAIT timer.&n;&t;&t; *&n;&t;&t; * If it is ACKless SYN it may be both old duplicate&n;&t;&t; * and new good SYN with random sequence number &lt;rcv_nxt.&n;&t;&t; * Do not reschedule in the last case.&n;&t;&t; */
r_if
c_cond
(paren
id|paws_reject
op_logical_or
id|th-&gt;ack
)paren
id|tcp_tw_schedule
c_func
(paren
id|tw
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
multiline_comment|/* Send ACK. Note, we do not put the bucket,&n;&t;&t; * it will be released by caller.&n;&t;&t; */
r_return
id|TCP_TW_ACK
suffix:semicolon
)brace
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
r_return
id|TCP_TW_SUCCESS
suffix:semicolon
)brace
multiline_comment|/* Enter the time wait state.  This is called with locally disabled BH.&n; * Essentially we whip up a timewait bucket, copy the&n; * relevant info into it from the SK, and mess with hash chains&n; * and list linkage.&n; */
DECL|function|__tcp_tw_hashdance
r_static
r_void
id|__tcp_tw_hashdance
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_tw_bucket
op_star
id|tw
)paren
(brace
r_struct
id|tcp_ehash_bucket
op_star
id|ehead
op_assign
op_amp
id|tcp_ehash
(braket
id|sk-&gt;hashent
)braket
suffix:semicolon
r_struct
id|tcp_bind_hashbucket
op_star
id|bhead
suffix:semicolon
r_struct
id|sock
op_star
op_star
id|head
comma
op_star
id|sktw
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|ehead-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Step 1: Remove SK from established hash. */
r_if
c_cond
(paren
id|sk-&gt;pprev
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;next
)paren
(brace
id|sk-&gt;next-&gt;pprev
op_assign
id|sk-&gt;pprev
suffix:semicolon
)brace
op_star
id|sk-&gt;pprev
op_assign
id|sk-&gt;next
suffix:semicolon
id|sk-&gt;pprev
op_assign
l_int|NULL
suffix:semicolon
id|sock_prot_dec_use
c_func
(paren
id|sk-&gt;prot
)paren
suffix:semicolon
)brace
multiline_comment|/* Step 2: Hash TW into TIMEWAIT half of established hash table. */
id|head
op_assign
op_amp
(paren
id|ehead
op_plus
id|tcp_ehash_size
)paren
op_member_access_from_pointer
id|chain
suffix:semicolon
id|sktw
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|tw
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sktw-&gt;next
op_assign
op_star
id|head
)paren
op_ne
l_int|NULL
)paren
(brace
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|pprev
op_assign
op_amp
id|sktw-&gt;next
suffix:semicolon
)brace
op_star
id|head
op_assign
id|sktw
suffix:semicolon
id|sktw-&gt;pprev
op_assign
id|head
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|tw-&gt;refcnt
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|ehead-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Step 3: Put TW into bind hash. Original socket stays there too.&n;&t;   Note, that any socket with sk-&gt;num!=0 MUST be bound in binding&n;&t;   cache, even if it is closed.&n;&t; */
id|bhead
op_assign
op_amp
id|tcp_bhash
(braket
id|tcp_bhashfn
c_func
(paren
id|sk-&gt;num
)paren
)braket
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|bhead-&gt;lock
)paren
suffix:semicolon
id|tw-&gt;tb
op_assign
(paren
r_struct
id|tcp_bind_bucket
op_star
)paren
id|sk-&gt;prev
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|sk-&gt;prev
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tw-&gt;bind_next
op_assign
id|tw-&gt;tb-&gt;owners
)paren
op_ne
l_int|NULL
)paren
id|tw-&gt;tb-&gt;owners-&gt;bind_pprev
op_assign
op_amp
id|tw-&gt;bind_next
suffix:semicolon
id|tw-&gt;tb-&gt;owners
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|tw
suffix:semicolon
id|tw-&gt;bind_pprev
op_assign
op_amp
id|tw-&gt;tb-&gt;owners
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|bhead-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Move a socket to time-wait or dead fin-wait-2 state.&n; */
DECL|function|tcp_time_wait
r_void
id|tcp_time_wait
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|state
comma
r_int
id|timeo
)paren
(brace
r_struct
id|tcp_tw_bucket
op_star
id|tw
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|recycle_ok
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sysctl_tcp_tw_recycle
op_logical_and
id|tp-&gt;ts_recent_stamp
)paren
id|recycle_ok
op_assign
id|tp-&gt;af_specific
op_member_access_from_pointer
id|remember_stamp
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_tw_count
OL
id|sysctl_tcp_max_tw_buckets
)paren
id|tw
op_assign
id|kmem_cache_alloc
c_func
(paren
id|tcp_timewait_cachep
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tw
op_ne
l_int|NULL
)paren
(brace
r_int
id|rto
op_assign
(paren
id|tp-&gt;rto
op_lshift
l_int|2
)paren
op_minus
(paren
id|tp-&gt;rto
op_rshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Give us an identity. */
id|tw-&gt;daddr
op_assign
id|sk-&gt;daddr
suffix:semicolon
id|tw-&gt;rcv_saddr
op_assign
id|sk-&gt;rcv_saddr
suffix:semicolon
id|tw-&gt;bound_dev_if
op_assign
id|sk-&gt;bound_dev_if
suffix:semicolon
id|tw-&gt;num
op_assign
id|sk-&gt;num
suffix:semicolon
id|tw-&gt;state
op_assign
id|TCP_TIME_WAIT
suffix:semicolon
id|tw-&gt;substate
op_assign
id|state
suffix:semicolon
id|tw-&gt;sport
op_assign
id|sk-&gt;sport
suffix:semicolon
id|tw-&gt;dport
op_assign
id|sk-&gt;dport
suffix:semicolon
id|tw-&gt;family
op_assign
id|sk-&gt;family
suffix:semicolon
id|tw-&gt;reuse
op_assign
id|sk-&gt;reuse
suffix:semicolon
id|tw-&gt;rcv_wscale
op_assign
id|tp-&gt;rcv_wscale
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|tw-&gt;refcnt
comma
l_int|0
)paren
suffix:semicolon
id|tw-&gt;hashent
op_assign
id|sk-&gt;hashent
suffix:semicolon
id|tw-&gt;rcv_nxt
op_assign
id|tp-&gt;rcv_nxt
suffix:semicolon
id|tw-&gt;snd_nxt
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
id|tw-&gt;rcv_wnd
op_assign
id|tcp_receive_window
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tw-&gt;syn_seq
op_assign
id|tp-&gt;syn_seq
suffix:semicolon
id|tw-&gt;ts_recent
op_assign
id|tp-&gt;ts_recent
suffix:semicolon
id|tw-&gt;ts_recent_stamp
op_assign
id|tp-&gt;ts_recent_stamp
suffix:semicolon
id|tw-&gt;pprev_death
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
r_if
c_cond
(paren
id|tw-&gt;family
op_eq
id|PF_INET6
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|tw-&gt;v6_daddr
comma
op_amp
id|sk-&gt;net_pinfo.af_inet6.daddr
comma
r_sizeof
(paren
r_struct
id|in6_addr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|tw-&gt;v6_rcv_saddr
comma
op_amp
id|sk-&gt;net_pinfo.af_inet6.rcv_saddr
comma
r_sizeof
(paren
r_struct
id|in6_addr
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Linkage updates. */
id|__tcp_tw_hashdance
c_func
(paren
id|sk
comma
id|tw
)paren
suffix:semicolon
multiline_comment|/* Get the TIME_WAIT timeout firing. */
r_if
c_cond
(paren
id|timeo
OL
id|rto
)paren
id|timeo
op_assign
id|rto
suffix:semicolon
r_if
c_cond
(paren
id|recycle_ok
)paren
(brace
id|tw-&gt;timeout
op_assign
id|rto
suffix:semicolon
)brace
r_else
(brace
id|tw-&gt;timeout
op_assign
id|TCP_TIMEWAIT_LEN
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|TCP_TIME_WAIT
)paren
id|timeo
op_assign
id|TCP_TIMEWAIT_LEN
suffix:semicolon
)brace
id|tcp_tw_schedule
c_func
(paren
id|tw
comma
id|timeo
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Sorry, if we&squot;re out of memory, just CLOSE this&n;&t;&t; * socket up.  We&squot;ve got bigger problems than&n;&t;&t; * non-graceful socket closings.&n;&t;&t; */
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;TCP: time wait bucket table overflow&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|tcp_update_metrics
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_done
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* Kill off TIME_WAIT sockets once their lifetime has expired. */
DECL|variable|tcp_tw_death_row_slot
r_static
r_int
id|tcp_tw_death_row_slot
op_assign
l_int|0
suffix:semicolon
r_static
r_void
id|tcp_twkill
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|variable|tcp_tw_death_row
r_static
r_struct
id|tcp_tw_bucket
op_star
id|tcp_tw_death_row
(braket
id|TCP_TWKILL_SLOTS
)braket
suffix:semicolon
DECL|variable|tw_death_lock
r_static
id|spinlock_t
id|tw_death_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|tcp_tw_timer
r_static
r_struct
id|timer_list
id|tcp_tw_timer
op_assign
(brace
id|function
suffix:colon
id|tcp_twkill
)brace
suffix:semicolon
DECL|function|tcp_twkill
r_static
r_void
id|SMP_TIMER_NAME
c_func
(paren
id|tcp_twkill
)paren
(paren
r_int
r_int
id|dummy
)paren
(brace
r_struct
id|tcp_tw_bucket
op_star
id|tw
suffix:semicolon
r_int
id|killed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* NOTE: compare this to previous version where lock&n;&t; * was released after detaching chain. It was racy,&n;&t; * because tw buckets are scheduled in not serialized context&n;&t; * in 2.3 (with netfilter), and with softnet it is common, because&n;&t; * soft irqs are not sequenced.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_tw_count
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tw
op_assign
id|tcp_tw_death_row
(braket
id|tcp_tw_death_row_slot
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|tcp_tw_death_row
(braket
id|tcp_tw_death_row_slot
)braket
op_assign
id|tw-&gt;next_death
suffix:semicolon
id|tw-&gt;pprev_death
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
id|tcp_timewait_kill
c_func
(paren
id|tw
)paren
suffix:semicolon
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
id|killed
op_increment
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
)brace
id|tcp_tw_death_row_slot
op_assign
(paren
(paren
id|tcp_tw_death_row_slot
op_plus
l_int|1
)paren
op_amp
(paren
id|TCP_TWKILL_SLOTS
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tcp_tw_count
op_sub_assign
id|killed
)paren
op_ne
l_int|0
)paren
id|mod_timer
c_func
(paren
op_amp
id|tcp_tw_timer
comma
id|jiffies
op_plus
id|TCP_TWKILL_PERIOD
)paren
suffix:semicolon
id|net_statistics
(braket
id|smp_processor_id
c_func
(paren
)paren
op_star
l_int|2
)braket
dot
id|TimeWaited
op_add_assign
id|killed
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
)brace
id|SMP_TIMER_DEFINE
c_func
(paren
id|tcp_twkill
comma
id|tcp_twkill_task
)paren
suffix:semicolon
multiline_comment|/* These are always called from BH context.  See callers in&n; * tcp_input.c to verify this.&n; */
multiline_comment|/* This is for handling early-kills of TIME_WAIT sockets. */
DECL|function|tcp_tw_deschedule
r_void
id|tcp_tw_deschedule
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tw-&gt;pprev_death
)paren
(brace
r_if
c_cond
(paren
id|tw-&gt;next_death
)paren
(brace
id|tw-&gt;next_death-&gt;pprev_death
op_assign
id|tw-&gt;pprev_death
suffix:semicolon
)brace
op_star
id|tw-&gt;pprev_death
op_assign
id|tw-&gt;next_death
suffix:semicolon
id|tw-&gt;pprev_death
op_assign
l_int|NULL
suffix:semicolon
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|tcp_tw_count
op_eq
l_int|0
)paren
id|del_timer
c_func
(paren
op_amp
id|tcp_tw_timer
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Short-time timewait calendar */
DECL|variable|tcp_twcal_hand
r_static
r_int
id|tcp_twcal_hand
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|tcp_twcal_jiffie
r_static
r_int
id|tcp_twcal_jiffie
suffix:semicolon
r_static
r_void
id|tcp_twcal_tick
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|variable|tcp_twcal_timer
r_static
r_struct
id|timer_list
id|tcp_twcal_timer
op_assign
(brace
id|function
suffix:colon
id|tcp_twcal_tick
)brace
suffix:semicolon
DECL|variable|tcp_twcal_row
r_static
r_struct
id|tcp_tw_bucket
op_star
id|tcp_twcal_row
(braket
id|TCP_TW_RECYCLE_SLOTS
)braket
suffix:semicolon
DECL|function|tcp_tw_schedule
r_void
id|tcp_tw_schedule
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
comma
r_int
id|timeo
)paren
(brace
r_struct
id|tcp_tw_bucket
op_star
op_star
id|tpp
suffix:semicolon
r_int
id|slot
suffix:semicolon
multiline_comment|/* timeout := RTO * 3.5&n;&t; *&n;&t; * 3.5 = 1+2+0.5 to wait for two retransmits.&n;&t; *&n;&t; * RATIONALE: if FIN arrived and we entered TIME-WAIT state,&n;&t; * our ACK acking that FIN can be lost. If N subsequent retransmitted&n;&t; * FINs (or previous seqments) are lost (probability of such event&n;&t; * is p^(N+1), where p is probability to lose single packet and&n;&t; * time to detect the loss is about RTO*(2^N - 1) with exponential&n;&t; * backoff). Normal timewait length is calculated so, that we&n;&t; * waited at least for one retransmitted FIN (maximal RTO is 120sec).&n;&t; * [ BTW Linux. following BSD, violates this requirement waiting&n;&t; *   only for 60sec, we should wait at least for 240 secs.&n;&t; *   Well, 240 consumes too much of resources 8)&n;&t; * ]&n;&t; * This interval is not reduced to catch old duplicate and&n;&t; * responces to our wandering segments living for two MSLs.&n;&t; * However, if we use PAWS to detect&n;&t; * old duplicates, we can reduce the interval to bounds required&n;&t; * by RTO, rather than MSL. So, if peer understands PAWS, we&n;&t; * kill tw bucket after 3.5*RTO (it is important that this number&n;&t; * is greater than TS tick!) and detect old duplicates with help&n;&t; * of PAWS.&n;&t; */
id|slot
op_assign
(paren
id|timeo
op_plus
(paren
l_int|1
op_lshift
id|TCP_TW_RECYCLE_TICK
)paren
op_minus
l_int|1
)paren
op_rshift
id|TCP_TW_RECYCLE_TICK
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
multiline_comment|/* Unlink it, if it was scheduled */
r_if
c_cond
(paren
id|tw-&gt;pprev_death
)paren
(brace
r_if
c_cond
(paren
id|tw-&gt;next_death
)paren
(brace
id|tw-&gt;next_death-&gt;pprev_death
op_assign
id|tw-&gt;pprev_death
suffix:semicolon
)brace
op_star
id|tw-&gt;pprev_death
op_assign
id|tw-&gt;next_death
suffix:semicolon
id|tw-&gt;pprev_death
op_assign
l_int|NULL
suffix:semicolon
id|tcp_tw_count
op_decrement
suffix:semicolon
)brace
r_else
id|atomic_inc
c_func
(paren
op_amp
id|tw-&gt;refcnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_ge
id|TCP_TW_RECYCLE_SLOTS
)paren
(brace
multiline_comment|/* Schedule to slow timer */
r_if
c_cond
(paren
id|timeo
op_ge
id|TCP_TIMEWAIT_LEN
)paren
(brace
id|slot
op_assign
id|TCP_TWKILL_SLOTS
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|slot
op_assign
(paren
id|timeo
op_plus
id|TCP_TWKILL_PERIOD
op_minus
l_int|1
)paren
op_div
id|TCP_TWKILL_PERIOD
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_ge
id|TCP_TWKILL_SLOTS
)paren
id|slot
op_assign
id|TCP_TWKILL_SLOTS
op_minus
l_int|1
suffix:semicolon
)brace
id|tw-&gt;ttd
op_assign
id|jiffies
op_plus
id|timeo
suffix:semicolon
id|slot
op_assign
(paren
id|tcp_tw_death_row_slot
op_plus
id|slot
)paren
op_amp
(paren
id|TCP_TWKILL_SLOTS
op_minus
l_int|1
)paren
suffix:semicolon
id|tpp
op_assign
op_amp
id|tcp_tw_death_row
(braket
id|slot
)braket
suffix:semicolon
)brace
r_else
(brace
id|tw-&gt;ttd
op_assign
id|jiffies
op_plus
(paren
id|slot
op_lshift
id|TCP_TW_RECYCLE_TICK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_twcal_hand
OL
l_int|0
)paren
(brace
id|tcp_twcal_hand
op_assign
l_int|0
suffix:semicolon
id|tcp_twcal_jiffie
op_assign
id|jiffies
suffix:semicolon
id|tcp_twcal_timer.expires
op_assign
id|tcp_twcal_jiffie
op_plus
(paren
id|slot
op_lshift
id|TCP_TW_RECYCLE_TICK
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|tcp_twcal_timer
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|tcp_twcal_timer.expires
op_minus
id|jiffies
)paren
OG
(paren
id|slot
op_lshift
id|TCP_TW_RECYCLE_TICK
)paren
)paren
id|mod_timer
c_func
(paren
op_amp
id|tcp_twcal_timer
comma
id|jiffies
op_plus
(paren
id|slot
op_lshift
id|TCP_TW_RECYCLE_TICK
)paren
)paren
suffix:semicolon
id|slot
op_assign
(paren
id|tcp_twcal_hand
op_plus
id|slot
)paren
op_amp
(paren
id|TCP_TW_RECYCLE_SLOTS
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|tpp
op_assign
op_amp
id|tcp_twcal_row
(braket
id|slot
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|tw-&gt;next_death
op_assign
op_star
id|tpp
)paren
op_ne
l_int|NULL
)paren
(brace
(paren
op_star
id|tpp
)paren
op_member_access_from_pointer
id|pprev_death
op_assign
op_amp
id|tw-&gt;next_death
suffix:semicolon
)brace
op_star
id|tpp
op_assign
id|tw
suffix:semicolon
id|tw-&gt;pprev_death
op_assign
id|tpp
suffix:semicolon
r_if
c_cond
(paren
id|tcp_tw_count
op_increment
op_eq
l_int|0
)paren
id|mod_timer
c_func
(paren
op_amp
id|tcp_tw_timer
comma
id|jiffies
op_plus
id|TCP_TWKILL_PERIOD
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
)brace
DECL|function|tcp_twcal_tick
r_void
id|SMP_TIMER_NAME
c_func
(paren
id|tcp_twcal_tick
)paren
(paren
r_int
r_int
id|dummy
)paren
(brace
r_int
id|n
comma
id|slot
suffix:semicolon
r_int
r_int
id|j
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_int
id|killed
op_assign
l_int|0
suffix:semicolon
r_int
id|adv
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_twcal_hand
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|slot
op_assign
id|tcp_twcal_hand
suffix:semicolon
id|j
op_assign
id|tcp_twcal_jiffie
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|TCP_TW_RECYCLE_SLOTS
suffix:semicolon
id|n
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|j
op_minus
id|now
)paren
op_le
l_int|0
)paren
(brace
r_struct
id|tcp_tw_bucket
op_star
id|tw
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tw
op_assign
id|tcp_twcal_row
(braket
id|slot
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|tcp_twcal_row
(braket
id|slot
)braket
op_assign
id|tw-&gt;next_death
suffix:semicolon
id|tw-&gt;pprev_death
op_assign
l_int|NULL
suffix:semicolon
id|tcp_timewait_kill
c_func
(paren
id|tw
)paren
suffix:semicolon
id|tcp_tw_put
c_func
(paren
id|tw
)paren
suffix:semicolon
id|killed
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|adv
)paren
(brace
id|adv
op_assign
l_int|1
suffix:semicolon
id|tcp_twcal_jiffie
op_assign
id|j
suffix:semicolon
id|tcp_twcal_hand
op_assign
id|slot
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tcp_twcal_row
(braket
id|slot
)braket
op_ne
l_int|NULL
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|tcp_twcal_timer
comma
id|j
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|j
op_add_assign
(paren
l_int|1
op_lshift
id|TCP_TW_RECYCLE_TICK
)paren
suffix:semicolon
id|slot
op_assign
(paren
id|slot
op_plus
l_int|1
)paren
op_amp
(paren
id|TCP_TW_RECYCLE_SLOTS
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|tcp_twcal_hand
op_assign
op_minus
l_int|1
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
(paren
id|tcp_tw_count
op_sub_assign
id|killed
)paren
op_eq
l_int|0
)paren
id|del_timer
c_func
(paren
op_amp
id|tcp_tw_timer
)paren
suffix:semicolon
id|net_statistics
(braket
id|smp_processor_id
c_func
(paren
)paren
op_star
l_int|2
)braket
dot
id|TimeWaitKilled
op_add_assign
id|killed
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|tw_death_lock
)paren
suffix:semicolon
)brace
id|SMP_TIMER_DEFINE
c_func
(paren
id|tcp_twcal_tick
comma
id|tcp_twcal_tasklet
)paren
suffix:semicolon
multiline_comment|/* This is not only more efficient than what we used to do, it eliminates&n; * a lot of code duplication between IPv4/IPv6 SYN recv processing. -DaveM&n; *&n; * Actually, we could lots of memory writes here. tp of listening&n; * socket contains all necessary default parameters.&n; */
DECL|function|tcp_create_openreq_child
r_struct
id|sock
op_star
id|tcp_create_openreq_child
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|open_request
op_star
id|req
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sock
op_star
id|newsk
op_assign
id|sk_alloc
c_func
(paren
id|PF_INET
comma
id|GFP_ATOMIC
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newsk
op_ne
l_int|NULL
)paren
(brace
r_struct
id|tcp_opt
op_star
id|newtp
suffix:semicolon
macro_line|#ifdef CONFIG_FILTER
r_struct
id|sk_filter
op_star
id|filter
suffix:semicolon
macro_line|#endif
id|memcpy
c_func
(paren
id|newsk
comma
id|sk
comma
r_sizeof
(paren
op_star
id|newsk
)paren
)paren
suffix:semicolon
id|newsk-&gt;state
op_assign
id|TCP_SYN_RECV
suffix:semicolon
multiline_comment|/* SANITY */
id|newsk-&gt;pprev
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Clone the TCP header template */
id|newsk-&gt;dport
op_assign
id|req-&gt;rmt_port
suffix:semicolon
id|sock_lock_init
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|bh_lock_sock
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|newsk-&gt;dst_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|newsk-&gt;rmem_alloc
comma
l_int|0
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|newsk-&gt;receive_queue
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|newsk-&gt;wmem_alloc
comma
l_int|0
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|newsk-&gt;write_queue
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|newsk-&gt;omem_alloc
comma
l_int|0
)paren
suffix:semicolon
id|newsk-&gt;wmem_queued
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;forward_alloc
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;done
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;userlocks
op_assign
id|sk-&gt;userlocks
op_amp
op_complement
id|SOCK_BINDPORT_LOCK
suffix:semicolon
id|newsk-&gt;proc
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;backlog.head
op_assign
id|newsk-&gt;backlog.tail
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;callback_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|newsk-&gt;error_queue
)paren
suffix:semicolon
id|newsk-&gt;write_space
op_assign
id|tcp_write_space
suffix:semicolon
macro_line|#ifdef CONFIG_FILTER
r_if
c_cond
(paren
(paren
id|filter
op_assign
id|newsk-&gt;filter
)paren
op_ne
l_int|NULL
)paren
id|sk_filter_charge
c_func
(paren
id|newsk
comma
id|filter
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Now setup tcp_opt */
id|newtp
op_assign
op_amp
(paren
id|newsk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|newtp-&gt;pred_flags
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;rcv_nxt
op_assign
id|req-&gt;rcv_isn
op_plus
l_int|1
suffix:semicolon
id|newtp-&gt;snd_nxt
op_assign
id|req-&gt;snt_isn
op_plus
l_int|1
suffix:semicolon
id|newtp-&gt;snd_una
op_assign
id|req-&gt;snt_isn
op_plus
l_int|1
suffix:semicolon
id|newtp-&gt;snd_sml
op_assign
id|req-&gt;snt_isn
op_plus
l_int|1
suffix:semicolon
id|tcp_delack_init
c_func
(paren
id|newtp
)paren
suffix:semicolon
id|tcp_prequeue_init
c_func
(paren
id|newtp
)paren
suffix:semicolon
id|tcp_init_wl
c_func
(paren
id|newtp
comma
id|req-&gt;snt_isn
comma
id|req-&gt;rcv_isn
)paren
suffix:semicolon
id|newtp-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;backoff
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;srtt
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;mdev
op_assign
id|TCP_TIMEOUT_INIT
suffix:semicolon
id|newtp-&gt;rto
op_assign
id|TCP_TIMEOUT_INIT
suffix:semicolon
id|newtp-&gt;packets_out
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;left_out
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;retrans_out
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;sacked_out
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;fackets_out
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;snd_ssthresh
op_assign
l_int|0x7fffffff
suffix:semicolon
multiline_comment|/* So many TCP implementations out there (incorrectly) count the&n;&t;&t; * initial SYN frame in their delayed-ACK and congestion control&n;&t;&t; * algorithms that we must have the following bandaid to talk&n;&t;&t; * efficiently to them.  -DaveM&n;&t;&t; */
id|newtp-&gt;snd_cwnd
op_assign
l_int|2
suffix:semicolon
id|newtp-&gt;snd_cwnd_cnt
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;ca_state
op_assign
id|TCP_CA_Open
suffix:semicolon
id|tcp_init_xmit_timers
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|newtp-&gt;out_of_order_queue
)paren
suffix:semicolon
id|newtp-&gt;send_head
op_assign
l_int|NULL
suffix:semicolon
id|newtp-&gt;rcv_wup
op_assign
id|req-&gt;rcv_isn
op_plus
l_int|1
suffix:semicolon
id|newtp-&gt;write_seq
op_assign
id|req-&gt;snt_isn
op_plus
l_int|1
suffix:semicolon
id|newtp-&gt;pushed_seq
op_assign
id|newtp-&gt;write_seq
suffix:semicolon
id|newtp-&gt;copied_seq
op_assign
id|req-&gt;rcv_isn
op_plus
l_int|1
suffix:semicolon
id|newtp-&gt;saw_tstamp
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;dsack
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;eff_sacks
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;probes_out
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;num_sacks
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;syn_seq
op_assign
id|req-&gt;rcv_isn
suffix:semicolon
id|newtp-&gt;fin_seq
op_assign
id|req-&gt;rcv_isn
suffix:semicolon
id|newtp-&gt;urg_data
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;listen_opt
op_assign
l_int|NULL
suffix:semicolon
id|newtp-&gt;accept_queue
op_assign
id|newtp-&gt;accept_queue_tail
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Deinitialize syn_wait_lock to trap illegal accesses. */
id|memset
c_func
(paren
op_amp
id|newtp-&gt;syn_wait_lock
comma
l_int|0
comma
r_sizeof
(paren
id|newtp-&gt;syn_wait_lock
)paren
)paren
suffix:semicolon
multiline_comment|/* Back to base struct sock members. */
id|newsk-&gt;err
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;priority
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|newsk-&gt;refcnt
comma
l_int|2
)paren
suffix:semicolon
macro_line|#ifdef INET_REFCNT_DEBUG
id|atomic_inc
c_func
(paren
op_amp
id|inet_sock_nr
)paren
suffix:semicolon
macro_line|#endif
id|atomic_inc
c_func
(paren
op_amp
id|tcp_sockets_allocated
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newsk-&gt;keepopen
)paren
id|tcp_reset_keepalive_timer
c_func
(paren
id|newsk
comma
id|keepalive_time_when
c_func
(paren
id|newtp
)paren
)paren
suffix:semicolon
id|newsk-&gt;socket
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;sleep
op_assign
l_int|NULL
suffix:semicolon
id|newtp-&gt;tstamp_ok
op_assign
id|req-&gt;tstamp_ok
suffix:semicolon
r_if
c_cond
(paren
(paren
id|newtp-&gt;sack_ok
op_assign
id|req-&gt;sack_ok
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sysctl_tcp_fack
)paren
id|newtp-&gt;sack_ok
op_or_assign
l_int|2
suffix:semicolon
)brace
id|newtp-&gt;window_clamp
op_assign
id|req-&gt;window_clamp
suffix:semicolon
id|newtp-&gt;rcv_ssthresh
op_assign
id|req-&gt;rcv_wnd
suffix:semicolon
id|newtp-&gt;rcv_wnd
op_assign
id|req-&gt;rcv_wnd
suffix:semicolon
id|newtp-&gt;wscale_ok
op_assign
id|req-&gt;wscale_ok
suffix:semicolon
r_if
c_cond
(paren
id|newtp-&gt;wscale_ok
)paren
(brace
id|newtp-&gt;snd_wscale
op_assign
id|req-&gt;snd_wscale
suffix:semicolon
id|newtp-&gt;rcv_wscale
op_assign
id|req-&gt;rcv_wscale
suffix:semicolon
)brace
r_else
(brace
id|newtp-&gt;snd_wscale
op_assign
id|newtp-&gt;rcv_wscale
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;window_clamp
op_assign
id|min
c_func
(paren
id|newtp-&gt;window_clamp
comma
l_int|65535
)paren
suffix:semicolon
)brace
id|newtp-&gt;snd_wnd
op_assign
id|ntohs
c_func
(paren
id|skb-&gt;h.th-&gt;window
)paren
op_lshift
id|newtp-&gt;snd_wscale
suffix:semicolon
id|newtp-&gt;max_window
op_assign
id|newtp-&gt;snd_wnd
suffix:semicolon
r_if
c_cond
(paren
id|newtp-&gt;tstamp_ok
)paren
(brace
id|newtp-&gt;ts_recent
op_assign
id|req-&gt;ts_recent
suffix:semicolon
id|newtp-&gt;ts_recent_stamp
op_assign
id|xtime.tv_sec
suffix:semicolon
id|newtp-&gt;tcp_header_len
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
id|TCPOLEN_TSTAMP_ALIGNED
suffix:semicolon
)brace
r_else
(brace
id|newtp-&gt;ts_recent_stamp
op_assign
l_int|0
suffix:semicolon
id|newtp-&gt;tcp_header_len
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;len
op_ge
id|TCP_MIN_RCVMSS
op_plus
id|newtp-&gt;tcp_header_len
)paren
id|newtp-&gt;ack.last_seg_size
op_assign
id|skb-&gt;len
op_minus
id|newtp-&gt;tcp_header_len
suffix:semicolon
id|newtp-&gt;mss_clamp
op_assign
id|req-&gt;mss
suffix:semicolon
id|TCP_ECN_openreq_child
c_func
(paren
id|newtp
comma
id|req
)paren
suffix:semicolon
)brace
r_return
id|newsk
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Process an incoming packet for SYN_RECV sockets represented&n; *&t;as an open_request.&n; */
DECL|function|tcp_check_req
r_struct
id|sock
op_star
id|tcp_check_req
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|open_request
op_star
id|req
comma
r_struct
id|open_request
op_star
op_star
id|prev
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|u32
id|flg
op_assign
id|tcp_flag_word
c_func
(paren
id|th
)paren
op_amp
(paren
id|TCP_FLAG_RST
op_or
id|TCP_FLAG_SYN
op_or
id|TCP_FLAG_ACK
)paren
suffix:semicolon
r_int
id|paws_reject
op_assign
l_int|0
suffix:semicolon
r_struct
id|tcp_opt
id|ttp
suffix:semicolon
r_struct
id|sock
op_star
id|child
suffix:semicolon
id|ttp.saw_tstamp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;doff
OG
(paren
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_rshift
l_int|2
)paren
)paren
(brace
id|tcp_parse_options
c_func
(paren
id|skb
comma
op_amp
id|ttp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ttp.saw_tstamp
)paren
(brace
id|ttp.ts_recent
op_assign
id|req-&gt;ts_recent
suffix:semicolon
multiline_comment|/* We do not store true stamp, but it is not required,&n;&t;&t;&t; * it can be estimated (approximately)&n;&t;&t;&t; * from another data.&n;&t;&t;&t; */
id|ttp.ts_recent_stamp
op_assign
id|xtime.tv_sec
op_minus
(paren
(paren
id|TCP_TIMEOUT_INIT
op_div
id|HZ
)paren
op_lshift
id|req-&gt;retrans
)paren
suffix:semicolon
id|paws_reject
op_assign
id|tcp_paws_check
c_func
(paren
op_amp
id|ttp
comma
id|th-&gt;rst
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Check for pure retransmited SYN. */
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_eq
id|req-&gt;rcv_isn
op_logical_and
id|flg
op_eq
id|TCP_FLAG_SYN
op_logical_and
op_logical_neg
id|paws_reject
)paren
(brace
multiline_comment|/*&n;&t;&t; * RFC793 draws (Incorrectly! It was fixed in RFC1122)&n;&t;&t; * this case on figure 6 and figure 8, but formal&n;&t;&t; * protocol description says NOTHING.&n;&t;&t; * To be more exact, it says that we should send ACK,&n;&t;&t; * because this segment (at least, if it has no data)&n;&t;&t; * is out of window.&n;&t;&t; *&n;&t;&t; *  CONCLUSION: RFC793 (even with RFC1122) DOES NOT&n;&t;&t; *  describe SYN-RECV state. All the description&n;&t;&t; *  is wrong, we cannot believe to it and should&n;&t;&t; *  rely only on common sense and implementation&n;&t;&t; *  experience.&n;&t;&t; *&n;&t;&t; * Enforce &quot;SYN-ACK&quot; according to figure 8, figure 6&n;&t;&t; * of RFC793, fixed by RFC1122.&n;&t;&t; */
id|req
op_member_access_from_pointer
r_class
op_member_access_from_pointer
id|rtx_syn_ack
c_func
(paren
id|sk
comma
id|req
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Further reproduces section &quot;SEGMENT ARRIVES&quot;&n;&t;   for state SYN-RECEIVED of RFC793.&n;&t;   It is broken, however, it does not work only&n;&t;   when SYNs are crossed, which is impossible in our&n;&t;   case.&n;&n;&t;   But generally, we should (RFC lies!) to accept ACK&n;&t;   from SYNACK both here and in tcp_rcv_state_process().&n;&t;   tcp_rcv_state_process() does not, hence, we do not too.&n;&n;&t;   Note that the case is absolutely generic:&n;&t;   we cannot optimize anything here without&n;&t;   violating protocol. All the checks must be made&n;&t;   before attempt to create socket.&n;&t; */
multiline_comment|/* RFC793: &quot;first check sequence number&quot;. */
r_if
c_cond
(paren
id|paws_reject
op_logical_or
op_logical_neg
id|tcp_in_window
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|req-&gt;rcv_isn
op_plus
l_int|1
comma
id|req-&gt;rcv_isn
op_plus
l_int|1
op_plus
id|req-&gt;rcv_wnd
)paren
)paren
(brace
multiline_comment|/* Out of window: send ACK and drop. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flg
op_amp
id|TCP_FLAG_RST
)paren
)paren
id|req
op_member_access_from_pointer
r_class
op_member_access_from_pointer
id|send_ack
c_func
(paren
id|skb
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|paws_reject
)paren
id|NET_INC_STATS_BH
c_func
(paren
id|PAWSEstabRejected
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* In sequence, PAWS is OK. */
r_if
c_cond
(paren
id|ttp.saw_tstamp
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
comma
id|req-&gt;rcv_isn
op_plus
l_int|1
)paren
)paren
id|req-&gt;ts_recent
op_assign
id|ttp.rcv_tsval
suffix:semicolon
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_eq
id|req-&gt;rcv_isn
)paren
(brace
multiline_comment|/* Truncate SYN, it is out of window starting&n;&t;&t;   at req-&gt;rcv_isn+1. */
id|flg
op_and_assign
op_complement
id|TCP_FLAG_SYN
suffix:semicolon
)brace
multiline_comment|/* RFC793: &quot;second check the RST bit&quot; and&n;&t; *&t;   &quot;fourth, check the SYN bit&quot;&n;&t; */
r_if
c_cond
(paren
id|flg
op_amp
(paren
id|TCP_FLAG_RST
op_or
id|TCP_FLAG_SYN
)paren
)paren
r_goto
id|embryonic_reset
suffix:semicolon
multiline_comment|/* RFC793: &quot;fifth check the ACK field&quot; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flg
op_amp
id|TCP_FLAG_ACK
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Invalid ACK: reset will be sent by listening socket */
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|ack_seq
op_ne
id|req-&gt;snt_isn
op_plus
l_int|1
)paren
r_return
id|sk
suffix:semicolon
multiline_comment|/* Also, it would be not so bad idea to check rcv_tsecr, which&n;&t; * is essentially ACK extension and too early or too late values&n;&t; * should cause reset in unsynchronized states.&n;&t; */
multiline_comment|/* If TCP_DEFER_ACCEPT is set, drop bare ACK. */
r_if
c_cond
(paren
id|tp-&gt;defer_accept
op_logical_and
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_eq
id|req-&gt;rcv_isn
op_plus
l_int|1
)paren
(brace
id|req-&gt;acked
op_assign
l_int|1
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* OK, ACK is valid, create big socket and&n;&t; * feed this segment to it. It will repeat all&n;&t; * the tests. THIS SEGMENT MUST MOVE SOCKET TO&n;&t; * ESTABLISHED STATE. If it will be dropped after&n;&t; * socket is created, wait for troubles.&n;&t; */
id|child
op_assign
id|tp-&gt;af_specific
op_member_access_from_pointer
id|syn_recv_sock
c_func
(paren
id|sk
comma
id|skb
comma
id|req
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|child
op_eq
l_int|NULL
)paren
r_goto
id|listen_overflow
suffix:semicolon
id|tcp_synq_unlink
c_func
(paren
id|tp
comma
id|req
comma
id|prev
)paren
suffix:semicolon
id|tcp_synq_removed
c_func
(paren
id|sk
comma
id|req
)paren
suffix:semicolon
id|tcp_acceptq_queue
c_func
(paren
id|sk
comma
id|req
comma
id|child
)paren
suffix:semicolon
r_return
id|child
suffix:semicolon
id|listen_overflow
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|sysctl_tcp_abort_on_overflow
)paren
(brace
id|req-&gt;acked
op_assign
l_int|1
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|embryonic_reset
suffix:colon
id|NET_INC_STATS_BH
c_func
(paren
id|EmbryonicRsts
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flg
op_amp
id|TCP_FLAG_RST
)paren
)paren
id|req
op_member_access_from_pointer
r_class
op_member_access_from_pointer
id|send_reset
c_func
(paren
id|skb
)paren
suffix:semicolon
id|tcp_synq_drop
c_func
(paren
id|sk
comma
id|req
comma
id|prev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Queue segment on the new socket if the new socket is active,&n; * otherwise we just shortcircuit this and continue with&n; * the new socket.&n; */
DECL|function|tcp_child_process
r_int
id|tcp_child_process
c_func
(paren
r_struct
id|sock
op_star
id|parent
comma
r_struct
id|sock
op_star
id|child
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|state
op_assign
id|child-&gt;state
suffix:semicolon
r_if
c_cond
(paren
id|child-&gt;lock.users
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|tcp_rcv_state_process
c_func
(paren
id|child
comma
id|skb
comma
id|skb-&gt;h.th
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Wakeup parent, send SIGIO */
r_if
c_cond
(paren
id|state
op_eq
id|TCP_SYN_RECV
op_logical_and
id|child-&gt;state
op_ne
id|state
)paren
id|parent
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|parent
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Alas, it is possible again, because we do lookup&n;&t;&t; * in main socket hash table and lock on listening&n;&t;&t; * socket does not protect us more.&n;&t;&t; */
id|sk_add_backlog
c_func
(paren
id|child
comma
id|skb
)paren
suffix:semicolon
)brace
id|bh_unlock_sock
c_func
(paren
id|child
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|child
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
