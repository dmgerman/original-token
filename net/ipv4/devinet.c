multiline_comment|/*&n; *&t;NET3&t;IP device support routines.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; *&t;Derived from the IP parts of dev.c 1.0.19&n; * &t;&t;Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&n; *&t;Additional Authors:&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;&t;/* For CONFIG_IP_CLASSLESS */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/arp.h&gt;
multiline_comment|/* &n; *&t;Determine a default network mask, based on the IP address. &n; */
DECL|function|ip_get_mask
r_int
r_int
id|ip_get_mask
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_int
r_int
id|dst
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_eq
l_int|0L
)paren
r_return
l_int|0L
suffix:semicolon
multiline_comment|/* special case */
id|dst
op_assign
id|ntohl
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSA
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSA_NET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSB
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSB_NET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSC
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSC_NET
)paren
suffix:semicolon
multiline_comment|/*&n;  &t; *&t;Something else, probably a multicast. &n;  &t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Check the address for our address, broadcasts, etc. &n; *&n; *&t;I intend to fix this to at the very least cache the last&n; *&t;resolved entry.&n; */
DECL|function|ip_chk_addr
r_int
id|ip_chk_addr
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
macro_line|#ifndef CONFIG_IP_CLASSLESS
r_int
r_int
id|mask
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t; *&t;Accept both `all ones&squot; and `all zeros&squot; as BROADCAST. &n;&t; *&t;(Support old BSD in other words). This old BSD &n;&t; *&t;support will go very soon as it messes other things&n;&t; *&t;up.&n;&t; *&t;Also accept `loopback broadcast&squot; as BROADCAST.&n;&t; */
r_if
c_cond
(paren
id|addr
op_eq
id|INADDR_ANY
op_logical_or
id|addr
op_eq
id|INADDR_BROADCAST
op_logical_or
id|addr
op_eq
id|htonl
c_func
(paren
l_int|0x7FFFFFFFL
)paren
)paren
r_return
id|IS_BROADCAST
suffix:semicolon
macro_line|#ifndef  CONFIG_IP_CLASSLESS
id|mask
op_assign
id|ip_get_mask
c_func
(paren
id|addr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Accept all of the `loopback&squot; class A net. &n;&t; */
r_if
c_cond
(paren
(paren
id|addr
op_amp
id|mask
)paren
op_eq
id|htonl
c_func
(paren
l_int|0x7F000000L
)paren
)paren
r_return
id|IS_MYADDR
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
(paren
id|addr
op_amp
id|htonl
c_func
(paren
l_int|0x7F000000L
)paren
)paren
op_eq
id|htonl
c_func
(paren
l_int|0x7F000000L
)paren
)paren
r_return
id|IS_MYADDR
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;OK, now check the interface addresses. We could&n;&t; *&t;speed this by keeping a dev and a dev_up chain.&n;&t; */
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
op_logical_or
id|dev-&gt;family
op_ne
id|AF_INET
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;If the protocol address of the device is 0 this is special&n;&t;&t; *&t;and means we are address hunting (eg bootp).&n;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;pa_addr
op_eq
l_int|0
)paren
r_return
id|IS_MYADDR
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Is it the exact IP address? &n;&t;&t; */
r_if
c_cond
(paren
id|addr
op_eq
id|dev-&gt;pa_addr
)paren
r_return
id|IS_MYADDR
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Is it our broadcast address? &n;&t;&t; */
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_BROADCAST
)paren
op_logical_and
id|addr
op_eq
id|dev-&gt;pa_brdaddr
)paren
r_return
id|IS_BROADCAST
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Nope. Check for a subnetwork broadcast. &n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|addr
op_xor
id|dev-&gt;pa_addr
)paren
op_amp
id|dev-&gt;pa_mask
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr
op_amp
op_complement
id|dev-&gt;pa_mask
)paren
op_eq
l_int|0
)paren
r_return
id|IS_BROADCAST
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_amp
op_complement
id|dev-&gt;pa_mask
)paren
op_eq
op_complement
id|dev-&gt;pa_mask
)paren
r_return
id|IS_BROADCAST
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_IP_CLASSLESS
multiline_comment|/*&n;&t; &t; *&t;Nope. Check for Network broadcast. &n;&t; &t; */
r_if
c_cond
(paren
(paren
(paren
id|addr
op_xor
id|dev-&gt;pa_addr
)paren
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr
op_amp
op_complement
id|mask
)paren
op_eq
l_int|0
)paren
r_return
id|IS_BROADCAST
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_amp
op_complement
id|mask
)paren
op_eq
op_complement
id|mask
)paren
r_return
id|IS_BROADCAST
suffix:semicolon
)brace
macro_line|#endif
)brace
r_if
c_cond
(paren
id|IN_MULTICAST
c_func
(paren
id|ntohl
c_func
(paren
id|addr
)paren
)paren
)paren
(brace
r_return
id|IS_MULTICAST
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* no match at all */
)brace
multiline_comment|/*&n; *&t;Retrieve our own address.&n; *&n; *&t;Because the loopback address (127.0.0.1) is already recognized&n; *&t;automatically, we can use the loopback interface&squot;s address as&n; *&t;our &quot;primary&quot; interface.  This is the address used by IP et&n; *&t;al when it doesn&squot;t know which address to use (i.e. it does not&n; *&t;yet know from or to which interface to go...).&n; */
DECL|function|ip_my_addr
r_int
r_int
id|ip_my_addr
c_func
(paren
r_void
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
r_return
id|dev-&gt;pa_addr
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Find an interface that can handle addresses for a certain address. &n; */
DECL|function|ip_dev_bynet
r_struct
id|device
op_star
id|ip_dev_bynet
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|mask
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_struct
id|device
op_star
id|best_dev
op_assign
l_int|NULL
suffix:semicolon
id|__u32
id|best_mask
op_assign
id|mask
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_POINTOPOINT
)paren
(brace
r_if
c_cond
(paren
id|addr
op_eq
id|dev-&gt;pa_dstaddr
)paren
r_return
id|dev
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;pa_mask
op_amp
(paren
id|addr
op_xor
id|dev-&gt;pa_addr
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_eq
id|dev-&gt;pa_mask
)paren
r_return
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|best_dev
op_logical_and
(paren
id|best_mask
op_amp
id|dev-&gt;pa_mask
)paren
op_ne
id|best_mask
)paren
r_continue
suffix:semicolon
id|best_dev
op_assign
id|dev
suffix:semicolon
id|best_mask
op_assign
id|dev-&gt;pa_mask
suffix:semicolon
)brace
r_return
id|best_dev
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Find the first device with a given source address.&n; */
DECL|function|ip_dev_find
r_struct
id|device
op_star
id|ip_dev_find
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
op_logical_and
id|dev-&gt;pa_addr
op_eq
id|addr
)paren
(brace
r_return
id|dev
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|dev_getbytype
r_struct
id|device
op_star
id|dev_getbytype
c_func
(paren
r_int
r_int
id|type
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|type
op_logical_and
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
(paren
id|IFF_LOOPBACK
op_or
id|IFF_NOARP
)paren
)paren
)paren
r_return
id|dev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
eof
