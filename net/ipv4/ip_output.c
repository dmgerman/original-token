multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;The Internet Protocol (IP) output module.&n; *&n; * Version:&t;$Id: ip_output.c,v 1.45 1998/01/15 22:06:35 freitag Exp $&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Donald Becker, &lt;becker@super.org&gt;&n; *&t;&t;Alan Cox, &lt;Alan.Cox@linux.org&gt;&n; *&t;&t;Richard Underwood&n; *&t;&t;Stefan Becker, &lt;stefanb@yello.ping.de&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&n; *&t;See ip_input.c for original log&n; *&n; *&t;Fixes:&n; *&t;&t;Alan Cox&t;:&t;Missing nonblock feature in ip_build_xmit.&n; *&t;&t;Mike Kilburn&t;:&t;htons() missing in ip_build_xmit.&n; *&t;&t;Bradford Johnson:&t;Fix faulty handling of some frames when &n; *&t;&t;&t;&t;&t;no route is found.&n; *&t;&t;Alexander Demenshin:&t;Missing sk/skb free in ip_queue_xmit&n; *&t;&t;&t;&t;&t;(in case if packet not accepted by&n; *&t;&t;&t;&t;&t;output firewall rules)&n; *&t;&t;Alexey Kuznetsov:&t;use new route cache&n; *&t;&t;Andi Kleen:&t;&t;Fix broken PMTU recovery and remove&n; *&t;&t;&t;&t;&t;some redundant tests.&n; */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;net/snmp.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/raw.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;linux/igmp.h&gt;
macro_line|#include &lt;linux/ip_fw.h&gt;
macro_line|#include &lt;linux/firewall.h&gt;
macro_line|#include &lt;linux/mroute.h&gt;
macro_line|#include &lt;linux/netlink.h&gt;
macro_line|#include &lt;linux/ipsec.h&gt;
multiline_comment|/*&n; *      Shall we try to damage output packets if routing dev changes?&n; */
DECL|variable|sysctl_ip_dynaddr
r_int
id|sysctl_ip_dynaddr
op_assign
l_int|0
suffix:semicolon
DECL|variable|ip_id_count
r_int
id|ip_id_count
op_assign
l_int|0
suffix:semicolon
DECL|function|ip_build_pkt
r_int
id|ip_build_pkt
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|saddr
comma
id|u32
id|daddr
comma
r_struct
id|ip_options
op_star
id|opt
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
id|u32
id|final_daddr
op_assign
id|daddr
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;srr
)paren
id|daddr
op_assign
id|opt-&gt;faddr
suffix:semicolon
id|err
op_assign
id|ip_route_output
c_func
(paren
op_amp
id|rt
comma
id|daddr
comma
id|saddr
comma
id|RT_TOS
c_func
(paren
id|sk-&gt;ip_tos
)paren
op_or
(paren
id|sk-&gt;localroute
op_logical_or
l_int|0
)paren
comma
id|sk-&gt;bound_dev_if
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ip_statistics.IpOutNoRoutes
op_increment
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;is_strictroute
op_logical_and
id|rt-&gt;rt_dst
op_ne
id|rt-&gt;rt_gateway
)paren
(brace
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
id|ip_statistics.IpOutNoRoutes
op_increment
suffix:semicolon
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
)brace
id|skb-&gt;dst
op_assign
id|dst_clone
c_func
(paren
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
(paren
id|rt-&gt;u.dst.dev-&gt;hard_header_len
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now build the IP header.&n;&t; */
multiline_comment|/*&n;&t; *&t;Build the IP addresses&n;&t; */
r_if
c_cond
(paren
id|opt
)paren
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
id|opt-&gt;optlen
)paren
suffix:semicolon
r_else
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|iphdr
)paren
)paren
suffix:semicolon
id|iph-&gt;version
op_assign
l_int|4
suffix:semicolon
id|iph-&gt;ihl
op_assign
l_int|5
suffix:semicolon
id|iph-&gt;tos
op_assign
id|sk-&gt;ip_tos
suffix:semicolon
id|iph-&gt;frag_off
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;ip_pmtudisc
op_eq
id|IP_PMTUDISC_WANT
op_logical_and
op_logical_neg
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_NOPMTUDISC
)paren
)paren
id|iph-&gt;frag_off
op_or_assign
id|htons
c_func
(paren
id|IP_DF
)paren
suffix:semicolon
id|iph-&gt;ttl
op_assign
id|sk-&gt;ip_ttl
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|rt-&gt;rt_dst
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|iph-&gt;protocol
op_assign
id|sk-&gt;protocol
suffix:semicolon
id|skb-&gt;nh.iph
op_assign
id|iph
suffix:semicolon
id|skb-&gt;h.raw
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|iph
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;optlen
)paren
(brace
id|iph-&gt;ihl
op_add_assign
id|opt-&gt;optlen
op_rshift
l_int|2
suffix:semicolon
id|skb-&gt;h.raw
op_add_assign
id|opt-&gt;optlen
suffix:semicolon
id|ip_options_build
c_func
(paren
id|skb
comma
id|opt
comma
id|final_daddr
comma
id|rt
comma
l_int|0
)paren
suffix:semicolon
)brace
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine builds the appropriate hardware/IP headers for&n; * the routine.&n; */
DECL|function|ip_build_header
r_int
id|ip_build_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_struct
id|ip_options
op_star
id|opt
op_assign
id|sk-&gt;opt
suffix:semicolon
id|u32
id|daddr
op_assign
id|sk-&gt;daddr
suffix:semicolon
id|u32
id|final_daddr
op_assign
id|daddr
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;srr
)paren
id|daddr
op_assign
id|opt-&gt;faddr
suffix:semicolon
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|sk-&gt;dst_cache
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rt
op_logical_or
id|rt-&gt;u.dst.obsolete
)paren
(brace
id|sk-&gt;dst_cache
op_assign
l_int|NULL
suffix:semicolon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
id|err
op_assign
id|ip_route_output
c_func
(paren
op_amp
id|rt
comma
id|daddr
comma
id|sk-&gt;saddr
comma
id|RT_TOS
c_func
(paren
id|sk-&gt;ip_tos
)paren
op_or
(paren
id|sk-&gt;localroute
op_logical_or
l_int|0
)paren
comma
id|sk-&gt;bound_dev_if
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|sk-&gt;dst_cache
op_assign
op_amp
id|rt-&gt;u.dst
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;is_strictroute
op_logical_and
id|rt-&gt;rt_dst
op_ne
id|rt-&gt;rt_gateway
)paren
(brace
id|sk-&gt;dst_cache
op_assign
l_int|NULL
suffix:semicolon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
id|ip_statistics.IpOutNoRoutes
op_increment
suffix:semicolon
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
)brace
id|skb-&gt;dst
op_assign
id|dst_clone
c_func
(paren
id|sk-&gt;dst_cache
)paren
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
id|MAX_HEADER
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now build the IP header.&n;&t; */
multiline_comment|/*&n;&t; *&t;Build the IP addresses&n;&t; */
r_if
c_cond
(paren
id|opt
)paren
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
id|opt-&gt;optlen
)paren
suffix:semicolon
r_else
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|iphdr
)paren
)paren
suffix:semicolon
id|iph-&gt;version
op_assign
l_int|4
suffix:semicolon
id|iph-&gt;ihl
op_assign
l_int|5
suffix:semicolon
id|iph-&gt;tos
op_assign
id|sk-&gt;ip_tos
suffix:semicolon
id|iph-&gt;frag_off
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;ip_pmtudisc
op_eq
id|IP_PMTUDISC_WANT
op_logical_and
op_logical_neg
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_NOPMTUDISC
)paren
)paren
id|iph-&gt;frag_off
op_or_assign
id|htons
c_func
(paren
id|IP_DF
)paren
suffix:semicolon
id|iph-&gt;ttl
op_assign
id|sk-&gt;ip_ttl
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|rt-&gt;rt_dst
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|iph-&gt;protocol
op_assign
id|sk-&gt;protocol
suffix:semicolon
id|skb-&gt;nh.iph
op_assign
id|iph
suffix:semicolon
id|skb-&gt;h.raw
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|iph
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opt
op_logical_or
op_logical_neg
id|opt-&gt;optlen
)paren
r_return
l_int|0
suffix:semicolon
id|iph-&gt;ihl
op_add_assign
id|opt-&gt;optlen
op_rshift
l_int|2
suffix:semicolon
id|skb-&gt;h.raw
op_add_assign
id|opt-&gt;optlen
suffix:semicolon
id|ip_options_build
c_func
(paren
id|skb
comma
id|opt
comma
id|final_daddr
comma
id|rt
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__ip_finish_output
r_int
id|__ip_finish_output
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
id|ip_finish_output
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
DECL|function|ip_mc_output
r_int
id|ip_mc_output
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|skb-&gt;sk
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
id|rt-&gt;u.dst.dev
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If the indicated interface is up and running, send the packet.&n;&t; */
id|ip_statistics.IpOutRequests
op_increment
suffix:semicolon
macro_line|#ifdef CONFIG_IP_ROUTE_NAT
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_NAT
)paren
id|ip_do_nat
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Multicasts are looped back for other local users&n;&t; */
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_MULTICAST
op_logical_and
(paren
op_logical_neg
id|sk
op_logical_or
id|sk-&gt;ip_mc_loop
)paren
)paren
(brace
macro_line|#ifndef CONFIG_IP_MROUTE
macro_line|#if 1
multiline_comment|/* It should never occur. Delete it eventually. --ANK */
r_if
c_cond
(paren
op_logical_neg
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_LOCAL
)paren
op_logical_or
(paren
id|dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ip_mc_output (mc): it should never occur&bslash;n&quot;
)paren
suffix:semicolon
r_else
macro_line|#endif
macro_line|#else
multiline_comment|/* Small optimization: do not loopback not local frames,&n;&t;&t;   which returned after forwarding; they will be  dropped&n;&t;&t;   by ip_mr_input in any case.&n;&t;&t;   Note, that local frames are looped back to be delivered&n;&t;&t;   to local recipients.&n;&n;&t;&t;   This check is duplicated in ip_mr_input at the moment.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_LOCAL
)paren
op_logical_or
op_logical_neg
(paren
id|IPCB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_amp
id|IPSKB_FORWARDED
)paren
)paren
macro_line|#endif
id|dev_loopback_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Multicasts with ttl 0 must not go beyond the host */
r_if
c_cond
(paren
id|skb-&gt;nh.iph-&gt;ttl
op_eq
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_BROADCAST
)paren
(brace
macro_line|#if 1
multiline_comment|/* It should never occur. Delete it eventually. --ANK */
r_if
c_cond
(paren
op_logical_neg
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_LOCAL
)paren
op_logical_or
(paren
id|dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ip_mc_output (brd): it should never occur!&bslash;n&quot;
)paren
suffix:semicolon
r_else
macro_line|#endif
id|dev_loopback_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_return
id|ip_finish_output
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
DECL|function|ip_output
r_int
id|ip_output
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
macro_line|#ifdef CONFIG_IP_ROUTE_NAT
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
macro_line|#endif
id|ip_statistics.IpOutRequests
op_increment
suffix:semicolon
macro_line|#ifdef CONFIG_IP_ROUTE_NAT
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_NAT
)paren
id|ip_do_nat
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ip_finish_output
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IP_ACCT
DECL|function|ip_acct_output
r_int
id|ip_acct_output
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/*&n;&t; *&t;Count mapping we shortcut&n;&t; */
id|ip_fw_chk
c_func
(paren
id|skb-&gt;nh.iph
comma
id|skb-&gt;dev
comma
l_int|NULL
comma
id|ip_acct_chain
comma
l_int|0
comma
id|IP_FW_MODE_ACCT_OUT
)paren
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; *&t;Generate a checksum for an outgoing IP datagram.&n; */
DECL|function|ip_send_check
r_void
id|ip_send_check
c_func
(paren
r_struct
id|iphdr
op_star
id|iph
)paren
(brace
id|iph-&gt;check
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;check
op_assign
id|ip_fast_csum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|iph
comma
id|iph-&gt;ihl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Queues a packet to be sent, and starts the transmitter if necessary.  &n; * This routine also needs to put in the total length and compute the &n; * checksum&n; */
DECL|function|ip_queue_xmit
r_void
id|ip_queue_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|skb-&gt;sk
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_int
r_int
id|tot_len
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
id|tot_len
op_assign
id|skb-&gt;len
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|tot_len
)paren
suffix:semicolon
id|iph-&gt;id
op_assign
id|htons
c_func
(paren
id|ip_id_count
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt-&gt;u.dst.obsolete
)paren
(brace
multiline_comment|/* Ugly... ugly... but what can I do?&n;&t;&t;   Essentially it is &quot;ip_reroute_output&quot; function. --ANK&n;&t;&t;*/
r_struct
id|rtable
op_star
id|nrt
suffix:semicolon
r_if
c_cond
(paren
id|ip_route_output
c_func
(paren
op_amp
id|nrt
comma
id|rt-&gt;key.dst
comma
id|rt-&gt;key.src
comma
id|rt-&gt;key.tos
comma
id|sk
ques
c_cond
id|sk-&gt;bound_dev_if
suffix:colon
l_int|0
)paren
)paren
r_goto
id|drop
suffix:semicolon
id|skb-&gt;dst
op_assign
op_amp
id|nrt-&gt;u.dst
suffix:semicolon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
id|rt
op_assign
id|nrt
suffix:semicolon
)brace
id|dev
op_assign
id|rt-&gt;u.dst.dev
suffix:semicolon
r_if
c_cond
(paren
id|call_out_firewall
c_func
(paren
id|PF_INET
comma
id|dev
comma
id|iph
comma
l_int|NULL
comma
op_amp
id|skb
)paren
OL
id|FW_ACCEPT
)paren
r_goto
id|drop
suffix:semicolon
macro_line|#ifdef CONFIG_NET_SECURITY&t;
multiline_comment|/*&n;&t; *&t;Add an IP checksum (must do this before SECurity because&n;&t; *&t;of possible tunneling)&n;&t; */
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|call_out_firewall
c_func
(paren
id|PF_SECURITY
comma
l_int|NULL
comma
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|4
comma
op_amp
id|skb
)paren
OL
id|FW_ACCEPT
)paren
r_goto
id|drop
suffix:semicolon
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
multiline_comment|/* don&squot;t update tot_len, as the dev-&gt;mtu is already decreased */
macro_line|#endif
r_if
c_cond
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
OL
id|dev-&gt;hard_header_len
op_logical_and
id|dev-&gt;hard_header
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
multiline_comment|/* ANK: It is almost impossible, but&n;&t;&t; * if you loaded module device with hh_len &gt; MAX_HEADER,&n;&t;&t; * and if a route changed to this device,&n;&t;&t; * and if (uh...) TCP had segments queued on this route...&n;&t;&t; */
id|skb2
op_assign
id|skb_realloc_headroom
c_func
(paren
id|skb
comma
(paren
id|dev-&gt;hard_header_len
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb2
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|skb
op_assign
id|skb2
suffix:semicolon
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Do we need to fragment. Again this is inefficient.&n;&t; *&t;We need to somehow lock the original buffer and use&n;&t; *&t;bits of it.&n;&t; */
r_if
c_cond
(paren
id|tot_len
OG
id|rt-&gt;u.dst.pmtu
)paren
r_goto
id|fragment
suffix:semicolon
macro_line|#ifndef CONFIG_NET_SECURITY
multiline_comment|/*&n;&t; *&t;Add an IP checksum&n;&t; */
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|sk
)paren
id|skb-&gt;priority
op_assign
id|sk-&gt;priority
suffix:semicolon
id|skb-&gt;dst
op_member_access_from_pointer
id|output
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
id|fragment
suffix:colon
r_if
c_cond
(paren
(paren
id|iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_DF
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;sending pkt_too_big to self&bslash;n&quot;
)paren
suffix:semicolon
id|icmp_send
c_func
(paren
id|skb
comma
id|ICMP_DEST_UNREACH
comma
id|ICMP_FRAG_NEEDED
comma
id|htonl
c_func
(paren
id|rt-&gt;u.dst.pmtu
)paren
)paren
suffix:semicolon
r_goto
id|drop
suffix:semicolon
)brace
id|ip_fragment
c_func
(paren
id|skb
comma
id|skb-&gt;dst-&gt;output
)paren
suffix:semicolon
r_return
suffix:semicolon
id|drop
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Build and send a packet, with as little as one copy&n; *&n; *&t;Doesn&squot;t care much about ip options... option length can be&n; *&t;different for fragment at 0 and other fragments.&n; *&n; *&t;Note that the fragment at the highest offset is sent first,&n; *&t;so the getfrag routine can fill in the TCP/UDP checksum header&n; *&t;field in the last fragment it sends... actually it also helps&n; * &t;the reassemblers, they can put most packets in at the head of&n; *&t;the fragment queue, and they know the total size in advance. This&n; *&t;last feature will measurably improve the Linux fragment handler one&n; *&t;day.&n; *&n; *&t;The callback has five args, an arbitrary pointer (copy of frag),&n; *&t;the source IP address (may depend on the routing table), the &n; *&t;destination address (char *), the offset to copy from, and the&n; *&t;length to be copied.&n; */
DECL|function|ip_build_xmit
r_int
id|ip_build_xmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|getfrag
(paren
r_const
r_void
op_star
comma
r_char
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
comma
r_const
r_void
op_star
id|frag
comma
r_int
id|length
comma
r_struct
id|ipcm_cookie
op_star
id|ipc
comma
r_struct
id|rtable
op_star
id|rt
comma
r_int
id|flags
)paren
(brace
r_int
r_int
id|fraglen
comma
id|maxfraglen
comma
id|fragheaderlen
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|offset
comma
id|mf
suffix:semicolon
r_int
r_int
id|id
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_int
id|hh_len
op_assign
(paren
id|rt-&gt;u.dst.dev-&gt;hard_header_len
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
suffix:semicolon
r_int
id|nfrags
op_assign
l_int|0
suffix:semicolon
r_struct
id|ip_options
op_star
id|opt
op_assign
id|ipc-&gt;opt
suffix:semicolon
r_int
id|df
op_assign
id|htons
c_func
(paren
id|IP_DF
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_SECURITY
r_int
id|fw_res
suffix:semicolon
macro_line|#endif&t;
r_if
c_cond
(paren
id|sk-&gt;ip_pmtudisc
op_eq
id|IP_PMTUDISC_DONT
op_logical_or
id|rt-&gt;rt_flags
op_amp
id|RTCF_NOPMTUDISC
)paren
id|df
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Try the simple case first. This leaves fragmented frames, and by&n;&t; *&t;choice RAW frames within 20 bytes of maximum size(rare) to the long path&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;ip_hdrincl
)paren
id|length
op_add_assign
r_sizeof
(paren
r_struct
id|iphdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
op_le
id|rt-&gt;u.dst.pmtu
op_logical_and
id|opt
op_eq
l_int|NULL
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|sock_alloc_send_skb
c_func
(paren
id|sk
comma
id|length
op_plus
id|hh_len
op_plus
l_int|15
comma
l_int|0
comma
id|flags
op_amp
id|MSG_DONTWAIT
comma
op_amp
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|ip_statistics.IpOutDiscards
op_increment
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
id|skb-&gt;priority
op_assign
id|sk-&gt;priority
suffix:semicolon
id|skb-&gt;dst
op_assign
id|dst_clone
c_func
(paren
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
id|hh_len
)paren
suffix:semicolon
id|skb-&gt;nh.iph
op_assign
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
id|length
)paren
suffix:semicolon
id|dev_lock_list
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;ip_hdrincl
)paren
(brace
id|iph-&gt;version
op_assign
l_int|4
suffix:semicolon
id|iph-&gt;ihl
op_assign
l_int|5
suffix:semicolon
id|iph-&gt;tos
op_assign
id|sk-&gt;ip_tos
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|length
)paren
suffix:semicolon
id|iph-&gt;id
op_assign
id|htons
c_func
(paren
id|ip_id_count
op_increment
)paren
suffix:semicolon
id|iph-&gt;frag_off
op_assign
id|df
suffix:semicolon
id|iph-&gt;ttl
op_assign
id|sk-&gt;ip_mc_ttl
suffix:semicolon
r_if
c_cond
(paren
id|rt-&gt;rt_type
op_ne
id|RTN_MULTICAST
)paren
id|iph-&gt;ttl
op_assign
id|sk-&gt;ip_ttl
suffix:semicolon
id|iph-&gt;protocol
op_assign
id|sk-&gt;protocol
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|rt-&gt;rt_dst
suffix:semicolon
id|iph-&gt;check
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;check
op_assign
id|ip_fast_csum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|iph
comma
id|iph-&gt;ihl
)paren
suffix:semicolon
id|err
op_assign
id|getfrag
c_func
(paren
id|frag
comma
(paren
(paren
r_char
op_star
)paren
id|iph
)paren
op_plus
id|iph-&gt;ihl
op_star
l_int|4
comma
l_int|0
comma
id|length
op_minus
id|iph-&gt;ihl
op_star
l_int|4
)paren
suffix:semicolon
)brace
r_else
id|err
op_assign
id|getfrag
c_func
(paren
id|frag
comma
(paren
r_void
op_star
)paren
id|iph
comma
l_int|0
comma
id|length
)paren
suffix:semicolon
id|dev_unlock_list
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|call_out_firewall
c_func
(paren
id|PF_INET
comma
id|rt-&gt;u.dst.dev
comma
id|iph
comma
l_int|NULL
comma
op_amp
id|skb
)paren
OL
id|FW_ACCEPT
)paren
(brace
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_SECURITY
r_if
c_cond
(paren
(paren
id|fw_res
op_assign
id|call_out_firewall
c_func
(paren
id|PF_SECURITY
comma
l_int|NULL
comma
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|5
comma
op_amp
id|skb
)paren
)paren
OL
id|FW_ACCEPT
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fw_res
op_ne
id|FW_QUEUE
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|err
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_return
id|rt-&gt;u.dst
dot
id|output
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;ip_hdrincl
)paren
id|length
op_sub_assign
r_sizeof
(paren
r_struct
id|iphdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt
)paren
(brace
id|fragheaderlen
op_assign
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
id|opt-&gt;optlen
suffix:semicolon
id|maxfraglen
op_assign
(paren
(paren
id|rt-&gt;u.dst.pmtu
op_minus
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_minus
id|opt-&gt;optlen
)paren
op_amp
op_complement
l_int|7
)paren
op_plus
id|fragheaderlen
suffix:semicolon
)brace
r_else
(brace
id|fragheaderlen
op_assign
id|sk-&gt;ip_hdrincl
ques
c_cond
l_int|0
suffix:colon
r_sizeof
(paren
r_struct
id|iphdr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Fragheaderlen is the size of &squot;overhead&squot; on each buffer. Now work&n;&t;&t; *&t;out the size of the frames to send.&n;&t;&t; */
id|maxfraglen
op_assign
(paren
(paren
id|rt-&gt;u.dst.pmtu
op_minus
r_sizeof
(paren
r_struct
id|iphdr
)paren
)paren
op_amp
op_complement
l_int|7
)paren
op_plus
id|fragheaderlen
suffix:semicolon
)brace
r_if
c_cond
(paren
id|length
op_plus
id|fragheaderlen
OG
l_int|0xFFFF
)paren
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Start at the end of the frame by handling the remainder.&n;&t; */
id|offset
op_assign
id|length
op_minus
(paren
id|length
op_mod
(paren
id|maxfraglen
op_minus
id|fragheaderlen
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Amount of memory to allocate for final fragment.&n;&t; */
id|fraglen
op_assign
id|length
op_minus
id|offset
op_plus
id|fragheaderlen
suffix:semicolon
r_if
c_cond
(paren
id|length
op_minus
id|offset
op_eq
l_int|0
)paren
(brace
id|fraglen
op_assign
id|maxfraglen
suffix:semicolon
id|offset
op_sub_assign
id|maxfraglen
op_minus
id|fragheaderlen
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;The last fragment will not have MF (more fragments) set.&n;&t; */
id|mf
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Don&squot;t fragment packets for path mtu discovery.&n;&t; */
r_if
c_cond
(paren
id|offset
OG
l_int|0
op_logical_and
id|df
)paren
(brace
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Lock the device lists.&n;&t; */
id|dev_lock_list
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Get an identifier&n;&t; */
id|id
op_assign
id|htons
c_func
(paren
id|ip_id_count
op_increment
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Being outputting the bytes.&n;&t; */
r_do
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|error
suffix:semicolon
r_char
op_star
id|data
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Get the memory we require with some space left for alignment.&n;&t;&t; */
id|skb
op_assign
id|sock_alloc_send_skb
c_func
(paren
id|sk
comma
id|fraglen
op_plus
id|hh_len
op_plus
l_int|15
comma
l_int|0
comma
id|flags
op_amp
id|MSG_DONTWAIT
comma
op_amp
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|ip_statistics.IpOutDiscards
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|nfrags
OG
l_int|1
)paren
(brace
id|ip_statistics.IpFragCreates
op_increment
suffix:semicolon
)brace
id|dev_unlock_list
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Fill in the control structures&n;&t;&t; */
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
id|skb-&gt;priority
op_assign
id|sk-&gt;priority
suffix:semicolon
id|skb-&gt;dst
op_assign
id|dst_clone
c_func
(paren
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
id|hh_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Find where to start putting bytes.&n;&t;&t; */
id|data
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|fraglen
)paren
suffix:semicolon
id|skb-&gt;nh.iph
op_assign
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|data
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Only write IP header onto non-raw packets &n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;ip_hdrincl
)paren
(brace
id|iph-&gt;version
op_assign
l_int|4
suffix:semicolon
id|iph-&gt;ihl
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|opt
)paren
(brace
id|iph-&gt;ihl
op_add_assign
id|opt-&gt;optlen
op_rshift
l_int|2
suffix:semicolon
id|ip_options_build
c_func
(paren
id|skb
comma
id|opt
comma
id|ipc-&gt;addr
comma
id|rt
comma
id|offset
)paren
suffix:semicolon
)brace
id|iph-&gt;tos
op_assign
id|sk-&gt;ip_tos
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|fraglen
op_minus
id|fragheaderlen
op_plus
id|iph-&gt;ihl
op_star
l_int|4
)paren
suffix:semicolon
id|iph-&gt;id
op_assign
id|id
suffix:semicolon
id|iph-&gt;frag_off
op_assign
id|htons
c_func
(paren
id|offset
op_rshift
l_int|3
)paren
suffix:semicolon
id|iph-&gt;frag_off
op_or_assign
id|mf
op_or
id|df
suffix:semicolon
r_if
c_cond
(paren
id|rt-&gt;rt_type
op_eq
id|RTN_MULTICAST
)paren
id|iph-&gt;ttl
op_assign
id|sk-&gt;ip_mc_ttl
suffix:semicolon
r_else
id|iph-&gt;ttl
op_assign
id|sk-&gt;ip_ttl
suffix:semicolon
id|iph-&gt;protocol
op_assign
id|sk-&gt;protocol
suffix:semicolon
id|iph-&gt;check
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|rt-&gt;rt_dst
suffix:semicolon
id|iph-&gt;check
op_assign
id|ip_fast_csum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|iph
comma
id|iph-&gt;ihl
)paren
suffix:semicolon
id|data
op_add_assign
id|iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Any further fragments will have MF set.&n;&t;&t;&t; */
id|mf
op_assign
id|htons
c_func
(paren
id|IP_MF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;User data callback&n;&t;&t; */
id|err
op_assign
id|getfrag
c_func
(paren
id|frag
comma
id|data
comma
id|offset
comma
id|fraglen
op_minus
id|fragheaderlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Account for the fragment.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
op_logical_neg
id|offset
op_logical_and
id|call_out_firewall
c_func
(paren
id|PF_INET
comma
id|rt-&gt;u.dst.dev
comma
id|iph
comma
l_int|NULL
comma
op_amp
id|skb
)paren
OL
id|FW_ACCEPT
)paren
(brace
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_SECURITY
r_if
c_cond
(paren
(paren
id|fw_res
op_assign
id|call_out_firewall
c_func
(paren
id|PF_SECURITY
comma
l_int|NULL
comma
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|6
comma
op_amp
id|skb
)paren
)paren
OL
id|FW_ACCEPT
)paren
(brace
r_if
c_cond
(paren
id|fw_res
op_ne
id|FW_QUEUE
)paren
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
macro_line|#endif&t;&t;
r_if
c_cond
(paren
id|err
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|dev_unlock_list
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|offset
op_sub_assign
(paren
id|maxfraglen
op_minus
id|fragheaderlen
)paren
suffix:semicolon
id|fraglen
op_assign
id|maxfraglen
suffix:semicolon
id|nfrags
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rt-&gt;u.dst
dot
id|output
c_func
(paren
id|skb
)paren
)paren
(brace
r_if
c_cond
(paren
id|nfrags
OG
l_int|1
)paren
id|ip_statistics.IpFragCreates
op_add_assign
id|nfrags
suffix:semicolon
id|dev_unlock_list
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENETDOWN
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|offset
op_ge
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nfrags
OG
l_int|1
)paren
id|ip_statistics.IpFragCreates
op_add_assign
id|nfrags
suffix:semicolon
id|dev_unlock_list
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This IP datagram is too large to be sent in one piece.  Break it up into&n; *&t;smaller pieces (each of size equal to IP header plus&n; *&t;a block of the data of the original IP data part) that will yet fit in a&n; *&t;single device frame, and queue such a frame for sending.&n; *&n; *&t;Yes this is inefficient, feel free to submit a quicker one.&n; */
DECL|function|ip_fragment
r_void
id|ip_fragment
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
(paren
op_star
id|output
)paren
(paren
r_struct
id|sk_buff
op_star
)paren
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_int
r_char
op_star
id|raw
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_int
id|left
comma
id|mtu
comma
id|hlen
comma
id|len
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|not_last_frag
suffix:semicolon
id|u16
id|dont_fragment
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
id|dev
op_assign
id|rt-&gt;u.dst.dev
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Point into the IP datagram header.&n;&t; */
id|raw
op_assign
id|skb-&gt;nh.raw
suffix:semicolon
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|raw
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Setup starting values.&n;&t; */
id|hlen
op_assign
id|iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
id|left
op_assign
id|ntohs
c_func
(paren
id|iph-&gt;tot_len
)paren
op_minus
id|hlen
suffix:semicolon
multiline_comment|/* Space per frame */
id|mtu
op_assign
id|rt-&gt;u.dst.pmtu
op_minus
id|hlen
suffix:semicolon
multiline_comment|/* Size of data space */
id|ptr
op_assign
id|raw
op_plus
id|hlen
suffix:semicolon
multiline_comment|/* Where to start from */
multiline_comment|/*&n;&t; *&t;The protocol doesn&squot;t seem to say what to do in the case that the&n;&t; *&t;frame + options doesn&squot;t fit the mtu. As it used to fall down dead&n;&t; *&t;in this case we were fortunate it didn&squot;t happen&n;&t; */
r_if
c_cond
(paren
id|mtu
OL
l_int|8
)paren
(brace
id|ip_statistics.IpFragFails
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Fragment the datagram.&n;&t; */
id|offset
op_assign
(paren
id|ntohs
c_func
(paren
id|iph-&gt;frag_off
)paren
op_amp
id|IP_OFFSET
)paren
op_lshift
l_int|3
suffix:semicolon
id|not_last_frag
op_assign
id|iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_MF
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Nice moment: if DF is set and we are here,&n;&t; *&t;it means that packet should be fragmented and&n;&t; *&t;DF is set on fragments. If it works,&n;&t; *&t;path MTU discovery can be done by ONE segment(!). --ANK&n;&t; */
id|dont_fragment
op_assign
id|iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_DF
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Keep copying data until we run out.&n;&t; */
r_while
c_loop
(paren
id|left
OG
l_int|0
)paren
(brace
id|len
op_assign
id|left
suffix:semicolon
multiline_comment|/* IF: it doesn&squot;t fit, use &squot;mtu&squot; - the data space left */
r_if
c_cond
(paren
id|len
OG
id|mtu
)paren
id|len
op_assign
id|mtu
suffix:semicolon
multiline_comment|/* IF: we are not sending upto and including the packet end&n;&t;&t;   then align the next start on an eight byte boundary */
r_if
c_cond
(paren
id|len
OL
id|left
)paren
(brace
id|len
op_div_assign
l_int|8
suffix:semicolon
id|len
op_mul_assign
l_int|8
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Allocate buffer.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|skb2
op_assign
id|alloc_skb
c_func
(paren
id|len
op_plus
id|hlen
op_plus
id|dev-&gt;hard_header_len
op_plus
l_int|15
comma
id|GFP_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|NETDEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;IP: frag: no memory for new fragment!&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ip_statistics.IpFragFails
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Set up data on packet&n;&t;&t; */
id|skb2-&gt;when
op_assign
id|skb-&gt;when
suffix:semicolon
id|skb2-&gt;pkt_type
op_assign
id|skb-&gt;pkt_type
suffix:semicolon
id|skb2-&gt;priority
op_assign
id|skb-&gt;priority
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb2
comma
(paren
id|dev-&gt;hard_header_len
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
)paren
suffix:semicolon
id|skb_put
c_func
(paren
id|skb2
comma
id|len
op_plus
id|hlen
)paren
suffix:semicolon
id|skb2-&gt;nh.raw
op_assign
id|skb2-&gt;data
suffix:semicolon
id|skb2-&gt;h.raw
op_assign
id|skb2-&gt;data
op_plus
id|hlen
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Charge the memory for the fragment to any owner&n;&t;&t; *&t;it might possess&n;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;sk
)paren
id|skb_set_owner_w
c_func
(paren
id|skb2
comma
id|skb-&gt;sk
)paren
suffix:semicolon
id|skb2-&gt;dst
op_assign
id|dst_clone
c_func
(paren
id|skb-&gt;dst
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Copy the packet header into the new buffer.&n;&t;&t; */
id|memcpy
c_func
(paren
id|skb2-&gt;nh.raw
comma
id|raw
comma
id|hlen
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Copy a block of the IP datagram.&n;&t;&t; */
id|memcpy
c_func
(paren
id|skb2-&gt;h.raw
comma
id|ptr
comma
id|len
)paren
suffix:semicolon
id|left
op_sub_assign
id|len
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Fill in the new header fields.&n;&t;&t; */
id|iph
op_assign
id|skb2-&gt;nh.iph
suffix:semicolon
id|iph-&gt;frag_off
op_assign
id|htons
c_func
(paren
(paren
id|offset
op_rshift
l_int|3
)paren
)paren
op_or
id|dont_fragment
suffix:semicolon
multiline_comment|/* ANK: dirty, but effective trick. Upgrade options only if&n;&t;&t; * the segment to be fragmented was THE FIRST (otherwise,&n;&t;&t; * options are already fixed) and make it ONCE&n;&t;&t; * on the initial skb, so that all the following fragments&n;&t;&t; * will inherit fixed options.&n;&t;&t; */
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
)paren
id|ip_options_fragment
c_func
(paren
id|skb2
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Added AC : If we are fragmenting a fragment that&squot;s not the&n;&t;&t; *&t;&t;   last fragment then keep MF on each bit&n;&t;&t; */
r_if
c_cond
(paren
id|left
OG
l_int|0
op_logical_or
id|not_last_frag
)paren
id|iph-&gt;frag_off
op_or_assign
id|htons
c_func
(paren
id|IP_MF
)paren
suffix:semicolon
id|ptr
op_add_assign
id|len
suffix:semicolon
id|offset
op_add_assign
id|len
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Put this fragment into the sending queue.&n;&t;&t; */
id|ip_statistics.IpFragCreates
op_increment
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|len
op_plus
id|hlen
)paren
suffix:semicolon
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
id|output
c_func
(paren
id|skb2
)paren
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|ip_statistics.IpFragOKs
op_increment
suffix:semicolon
)brace
DECL|function|ip_reply
r_struct
id|sk_buff
op_star
id|ip_reply
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|payload
)paren
(brace
r_struct
(brace
r_struct
id|ip_options
id|opt
suffix:semicolon
r_char
id|data
(braket
l_int|40
)braket
suffix:semicolon
)brace
id|replyopts
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
r_struct
id|sk_buff
op_star
id|reply
suffix:semicolon
r_int
id|iphlen
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_struct
id|ipcm_cookie
id|ipc
suffix:semicolon
id|u32
id|daddr
suffix:semicolon
r_if
c_cond
(paren
id|ip_options_echo
c_func
(paren
op_amp
id|replyopts.opt
comma
id|skb
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|daddr
op_assign
id|ipc.addr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|ipc.opt
op_assign
op_amp
id|replyopts.opt
suffix:semicolon
r_if
c_cond
(paren
id|ipc.opt-&gt;srr
)paren
id|daddr
op_assign
id|replyopts.opt.faddr
suffix:semicolon
r_if
c_cond
(paren
id|ip_route_output
c_func
(paren
op_amp
id|rt
comma
id|daddr
comma
id|rt-&gt;rt_spec_dst
comma
id|RT_TOS
c_func
(paren
id|skb-&gt;nh.iph-&gt;tos
)paren
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|iphlen
op_assign
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
id|replyopts.opt.optlen
suffix:semicolon
id|reply
op_assign
id|alloc_skb
c_func
(paren
id|rt-&gt;u.dst.dev-&gt;hard_header_len
op_plus
l_int|15
op_plus
id|iphlen
op_plus
id|payload
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reply
op_eq
l_int|NULL
)paren
(brace
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|reply-&gt;priority
op_assign
id|skb-&gt;priority
suffix:semicolon
id|reply-&gt;dst
op_assign
op_amp
id|rt-&gt;u.dst
suffix:semicolon
id|skb_reserve
c_func
(paren
id|reply
comma
(paren
id|rt-&gt;u.dst.dev-&gt;hard_header_len
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now build the IP header.&n;&t; */
multiline_comment|/*&n;&t; *&t;Build the IP addresses&n;&t; */
id|reply-&gt;nh.iph
op_assign
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb_put
c_func
(paren
id|reply
comma
id|iphlen
)paren
suffix:semicolon
id|iph-&gt;version
op_assign
l_int|4
suffix:semicolon
id|iph-&gt;ihl
op_assign
id|iphlen
op_rshift
l_int|2
suffix:semicolon
id|iph-&gt;tos
op_assign
id|skb-&gt;nh.iph-&gt;tos
suffix:semicolon
id|iph-&gt;frag_off
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;ttl
op_assign
id|MAXTTL
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|rt-&gt;rt_dst
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|iph-&gt;protocol
op_assign
id|skb-&gt;nh.iph-&gt;protocol
suffix:semicolon
id|ip_options_build
c_func
(paren
id|reply
comma
op_amp
id|replyopts.opt
comma
id|daddr
comma
id|rt
comma
l_int|0
)paren
suffix:semicolon
r_return
id|reply
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;IP protocol layer initialiser&n; */
DECL|variable|ip_packet_type
r_static
r_struct
id|packet_type
id|ip_packet_type
op_assign
(brace
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
comma
l_int|NULL
comma
multiline_comment|/* All devices */
id|ip_rcv
comma
l_int|NULL
comma
l_int|NULL
comma
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
macro_line|#ifdef CONFIG_IP_MULTICAST
DECL|variable|proc_net_igmp
r_static
r_struct
id|proc_dir_entry
id|proc_net_igmp
op_assign
(brace
id|PROC_NET_IGMP
comma
l_int|4
comma
l_string|&quot;igmp&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_amp
id|proc_net_inode_operations
comma
id|ip_mc_procinfo
)brace
suffix:semicolon
macro_line|#endif
macro_line|#endif&t;
multiline_comment|/*&n; *&t;IP registers the packet type and then calls the subprotocol initialisers&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|ip_init
c_func
(paren
r_void
)paren
)paren
(brace
id|dev_add_pack
c_func
(paren
op_amp
id|ip_packet_type
)paren
suffix:semicolon
id|ip_rt_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
macro_line|#ifdef CONFIG_IP_MULTICAST
id|proc_net_register
c_func
(paren
op_amp
id|proc_net_igmp
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif&t;
)brace
eof
