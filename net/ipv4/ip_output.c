multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;The Internet Protocol (IP) output module.&n; *&n; * Version:&t;@(#)ip.c&t;1.0.16b&t;9/1/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Donald Becker, &lt;becker@super.org&gt;&n; *&t;&t;Alan Cox, &lt;Alan.Cox@linux.org&gt;&n; *&t;&t;Richard Underwood&n; *&t;&t;Stefan Becker, &lt;stefanb@yello.ping.de&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&n; *&t;See ip_input.c for original log&n; *&n; *&t;Fixes:&n; *&t;&t;Alan Cox&t;:&t;Missing nonblock feature in ip_build_xmit.&n; *&t;&t;Mike Kilburn&t;:&t;htons() missing in ip_build_xmit.&n; *&t;&t;Bradford Johnson:&t;Fix faulty handling of some frames when &n; *&t;&t;&t;&t;&t;no route is found.&n; */
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;net/snmp.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/raw.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;linux/igmp.h&gt;
macro_line|#include &lt;linux/ip_fw.h&gt;
macro_line|#include &lt;linux/firewall.h&gt;
macro_line|#include &lt;linux/mroute.h&gt;
macro_line|#include &lt;net/netlink.h&gt;
multiline_comment|/*&n; *&t;Loop a packet back to the sender.&n; */
DECL|function|ip_loopback
r_static
r_void
id|ip_loopback
c_func
(paren
r_struct
id|device
op_star
id|old_dev
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
op_amp
id|loopback_dev
suffix:semicolon
r_int
id|len
op_assign
id|ntohs
c_func
(paren
id|skb-&gt;ip_hdr-&gt;tot_len
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|newskb
op_assign
id|dev_alloc_skb
c_func
(paren
id|len
op_plus
id|dev-&gt;hard_header_len
op_plus
l_int|15
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newskb
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
id|newskb-&gt;link3
op_assign
l_int|NULL
suffix:semicolon
id|newskb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|newskb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|newskb-&gt;saddr
op_assign
id|skb-&gt;saddr
suffix:semicolon
id|newskb-&gt;daddr
op_assign
id|skb-&gt;daddr
suffix:semicolon
id|newskb-&gt;raddr
op_assign
id|skb-&gt;raddr
suffix:semicolon
id|newskb-&gt;free
op_assign
l_int|1
suffix:semicolon
id|newskb-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|newskb-&gt;users
op_assign
l_int|0
suffix:semicolon
id|newskb-&gt;pkt_type
op_assign
id|skb-&gt;pkt_type
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Put a MAC header on the packet&n;&t; */
id|ip_send
c_func
(paren
l_int|NULL
comma
id|newskb
comma
id|skb-&gt;ip_hdr-&gt;daddr
comma
id|len
comma
id|dev
comma
id|skb-&gt;ip_hdr-&gt;saddr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Add the rest of the data space.&t;&n;&t; */
id|newskb-&gt;ip_hdr
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb_put
c_func
(paren
id|newskb
comma
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|newskb-&gt;proto_priv
comma
id|skb-&gt;proto_priv
comma
r_sizeof
(paren
id|skb-&gt;proto_priv
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Copy the data&n;&t; */
id|memcpy
c_func
(paren
id|newskb-&gt;ip_hdr
comma
id|skb-&gt;ip_hdr
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Recurse. The device check against IFF_LOOPBACK will stop infinite recursion */
multiline_comment|/*printk(&quot;Loopback output queued [%lX to %lX].&bslash;n&quot;, newskb-&gt;ip_hdr-&gt;saddr,newskb-&gt;ip_hdr-&gt;daddr);*/
id|ip_queue_xmit
c_func
(paren
l_int|NULL
comma
id|dev
comma
id|newskb
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Take an skb, and fill in the MAC header.&n; */
DECL|function|ip_send
r_int
id|ip_send
c_func
(paren
r_struct
id|rtable
op_star
id|rt
comma
r_struct
id|sk_buff
op_star
id|skb
comma
id|__u32
id|daddr
comma
r_int
id|len
comma
r_struct
id|device
op_star
id|dev
comma
id|__u32
id|saddr
)paren
(brace
r_int
id|mac
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;hard_header
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Build a hardware header. Source address is our mac, destination unknown&n;&t;&t; *  &t;(rebuild header will sort this out)&n;&t;&t; */
id|skb_reserve
c_func
(paren
id|skb
comma
(paren
id|dev-&gt;hard_header_len
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
)paren
suffix:semicolon
multiline_comment|/* 16 byte aligned IP headers are good */
r_if
c_cond
(paren
id|rt
op_logical_and
id|dev
op_eq
id|rt-&gt;rt_dev
op_logical_and
id|rt-&gt;rt_hh
)paren
(brace
id|memcpy
c_func
(paren
id|skb_push
c_func
(paren
id|skb
comma
id|dev-&gt;hard_header_len
)paren
comma
id|rt-&gt;rt_hh-&gt;hh_data
comma
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt-&gt;rt_hh-&gt;hh_uptodate
)paren
r_return
id|dev-&gt;hard_header_len
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;ip_send: hh miss %08x via %08x&bslash;n&quot;
comma
id|daddr
comma
id|rt-&gt;rt_gateway
)paren
suffix:semicolon
macro_line|#endif
id|skb-&gt;arp
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;raddr
op_assign
id|daddr
suffix:semicolon
r_return
id|dev-&gt;hard_header_len
suffix:semicolon
)brace
id|mac
op_assign
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|skb
comma
id|dev
comma
id|ETH_P_IP
comma
l_int|NULL
comma
l_int|NULL
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mac
OL
l_int|0
)paren
(brace
id|mac
op_assign
op_minus
id|mac
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;raddr
op_assign
id|daddr
suffix:semicolon
multiline_comment|/* next routing address */
)brace
)brace
r_return
id|mac
suffix:semicolon
)brace
DECL|function|ip_send_room
r_static
r_int
id|ip_send_room
c_func
(paren
r_struct
id|rtable
op_star
id|rt
comma
r_struct
id|sk_buff
op_star
id|skb
comma
id|__u32
id|daddr
comma
r_int
id|len
comma
r_struct
id|device
op_star
id|dev
comma
id|__u32
id|saddr
)paren
(brace
r_int
id|mac
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;hard_header
)paren
(brace
id|skb_reserve
c_func
(paren
id|skb
comma
id|MAX_HEADER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_logical_and
id|dev
op_eq
id|rt-&gt;rt_dev
op_logical_and
id|rt-&gt;rt_hh
)paren
(brace
id|memcpy
c_func
(paren
id|skb_push
c_func
(paren
id|skb
comma
id|dev-&gt;hard_header_len
)paren
comma
id|rt-&gt;rt_hh-&gt;hh_data
comma
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt-&gt;rt_hh-&gt;hh_uptodate
)paren
r_return
id|dev-&gt;hard_header_len
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;ip_send_room: hh miss %08x via %08x&bslash;n&quot;
comma
id|daddr
comma
id|rt-&gt;rt_gateway
)paren
suffix:semicolon
macro_line|#endif
id|skb-&gt;arp
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;raddr
op_assign
id|daddr
suffix:semicolon
r_return
id|dev-&gt;hard_header_len
suffix:semicolon
)brace
id|mac
op_assign
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|skb
comma
id|dev
comma
id|ETH_P_IP
comma
l_int|NULL
comma
l_int|NULL
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mac
OL
l_int|0
)paren
(brace
id|mac
op_assign
op_minus
id|mac
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;raddr
op_assign
id|daddr
suffix:semicolon
multiline_comment|/* next routing address */
)brace
)brace
r_return
id|mac
suffix:semicolon
)brace
DECL|variable|ip_id_count
r_int
id|ip_id_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * This routine builds the appropriate hardware/IP headers for&n; * the routine.  It assumes that if *dev != NULL then the&n; * protocol knows what it&squot;s doing, otherwise it uses the&n; * routing/ARP tables to select a device struct.&n; */
DECL|function|ip_build_header
r_int
id|ip_build_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
id|__u32
id|saddr
comma
id|__u32
id|daddr
comma
r_struct
id|device
op_star
op_star
id|dev
comma
r_int
id|type
comma
r_struct
id|options
op_star
id|opt
comma
r_int
id|len
comma
r_int
id|tos
comma
r_int
id|ttl
comma
r_struct
id|rtable
op_star
op_star
id|rp
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
id|__u32
id|raddr
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
id|__u32
id|final_daddr
op_assign
id|daddr
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;srr
)paren
id|daddr
op_assign
id|opt-&gt;faddr
suffix:semicolon
multiline_comment|/*&n;&t; *&t;See if we need to look up the device.&n;&t; */
macro_line|#ifdef CONFIG_IP_MULTICAST&t;
r_if
c_cond
(paren
id|MULTICAST
c_func
(paren
id|daddr
)paren
op_logical_and
op_star
id|dev
op_eq
l_int|NULL
op_logical_and
id|skb-&gt;sk
op_logical_and
op_star
id|skb-&gt;sk-&gt;ip_mc_name
)paren
(brace
op_star
id|dev
op_assign
id|dev_get
c_func
(paren
id|skb-&gt;sk-&gt;ip_mc_name
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|rp
)paren
(brace
id|rt
op_assign
id|ip_check_route
c_func
(paren
id|rp
comma
id|daddr
comma
id|skb-&gt;localroute
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If rp != NULL rt_put following below should not&n;&t;&t; * release route, so that...&n;&t;&t; */
r_if
c_cond
(paren
id|rt
)paren
id|ATOMIC_INCR
c_func
(paren
op_amp
id|rt-&gt;rt_refcnt
)paren
suffix:semicolon
)brace
r_else
id|rt
op_assign
id|ip_rt_route
c_func
(paren
id|daddr
comma
id|skb-&gt;localroute
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|dev
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
(brace
id|ip_statistics.IpOutNoRoutes
op_increment
suffix:semicolon
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
)brace
op_star
id|dev
op_assign
id|rt-&gt;rt_dev
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|LOOPBACK
c_func
(paren
id|saddr
)paren
op_logical_and
op_logical_neg
id|LOOPBACK
c_func
(paren
id|daddr
)paren
)paren
op_logical_or
op_logical_neg
id|saddr
)paren
id|saddr
op_assign
id|rt
ques
c_cond
id|rt-&gt;rt_src
suffix:colon
(paren
op_star
id|dev
)paren
op_member_access_from_pointer
id|pa_addr
suffix:semicolon
id|raddr
op_assign
id|rt
ques
c_cond
id|rt-&gt;rt_gateway
suffix:colon
id|daddr
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;is_strictroute
op_logical_and
id|rt
op_logical_and
(paren
id|rt-&gt;rt_flags
op_amp
id|RTF_GATEWAY
)paren
)paren
(brace
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
id|ip_statistics.IpOutNoRoutes
op_increment
suffix:semicolon
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Now build the MAC header.&n;&t; */
r_if
c_cond
(paren
id|type
op_eq
id|IPPROTO_TCP
)paren
id|tmp
op_assign
id|ip_send_room
c_func
(paren
id|rt
comma
id|skb
comma
id|raddr
comma
id|len
comma
op_star
id|dev
comma
id|saddr
)paren
suffix:semicolon
r_else
id|tmp
op_assign
id|ip_send
c_func
(paren
id|rt
comma
id|skb
comma
id|raddr
comma
id|len
comma
op_star
id|dev
comma
id|saddr
)paren
suffix:semicolon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Book keeping&n;&t; */
id|skb-&gt;dev
op_assign
op_star
id|dev
suffix:semicolon
id|skb-&gt;saddr
op_assign
id|saddr
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now build the IP header.&n;&t; */
multiline_comment|/*&n;&t; *&t;If we are using IPPROTO_RAW, then we don&squot;t need an IP header, since&n;&t; *&t;one is being supplied to us by the user&n;&t; */
r_if
c_cond
(paren
id|type
op_eq
id|IPPROTO_RAW
)paren
(brace
r_return
(paren
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Build the IP addresses&n;&t; */
r_if
c_cond
(paren
id|opt
)paren
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
id|opt-&gt;optlen
)paren
suffix:semicolon
r_else
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|iphdr
)paren
)paren
suffix:semicolon
id|iph-&gt;version
op_assign
l_int|4
suffix:semicolon
id|iph-&gt;ihl
op_assign
l_int|5
suffix:semicolon
id|iph-&gt;tos
op_assign
id|tos
suffix:semicolon
id|iph-&gt;frag_off
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;ttl
op_assign
id|ttl
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|daddr
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|saddr
suffix:semicolon
id|iph-&gt;protocol
op_assign
id|type
suffix:semicolon
id|skb-&gt;ip_hdr
op_assign
id|iph
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opt
op_logical_or
op_logical_neg
id|opt-&gt;optlen
)paren
r_return
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
id|tmp
suffix:semicolon
id|iph-&gt;ihl
op_add_assign
id|opt-&gt;optlen
op_rshift
l_int|2
suffix:semicolon
id|ip_options_build
c_func
(paren
id|skb
comma
id|opt
comma
id|final_daddr
comma
(paren
op_star
id|dev
)paren
op_member_access_from_pointer
id|pa_addr
comma
l_int|0
)paren
suffix:semicolon
r_return
id|iph-&gt;ihl
op_star
l_int|4
op_plus
id|tmp
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Generate a checksum for an outgoing IP datagram.&n; */
DECL|function|ip_send_check
r_void
id|ip_send_check
c_func
(paren
r_struct
id|iphdr
op_star
id|iph
)paren
(brace
id|iph-&gt;check
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;check
op_assign
id|ip_fast_csum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|iph
comma
id|iph-&gt;ihl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Queues a packet to be sent, and starts the transmitter&n; * if necessary.  if free = 1 then we free the block after&n; * transmit, otherwise we don&squot;t. If free==2 we not only&n; * free the block but also don&squot;t assign a new ip seq number.&n; * This routine also needs to put in the total length,&n; * and compute the checksum&n; */
DECL|function|ip_queue_xmit
r_void
id|ip_queue_xmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|free
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
multiline_comment|/*&t;unsigned char *ptr;*/
multiline_comment|/* Sanity check */
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|NETDEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;IP: ip_queue_xmit dev = NULL&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Do some book-keeping in the packet for later&n;&t; */
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Find the IP header and set the length. This is bad&n;&t; *&t;but once we get the skb data handling code in the&n;&t; *&t;hardware will push its header sensibly and we will&n;&t; *&t;set skb-&gt;ip_hdr to avoid this mess and the fixed&n;&t; *&t;header length problem&n;&t; */
id|iph
op_assign
id|skb-&gt;ip_hdr
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|skb-&gt;len
op_minus
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|iph
)paren
op_minus
id|skb-&gt;data
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_FIREWALL
r_if
c_cond
(paren
id|call_out_firewall
c_func
(paren
id|PF_INET
comma
id|skb-&gt;dev
comma
id|iph
)paren
OL
id|FW_ACCEPT
)paren
(brace
multiline_comment|/* just don&squot;t send this packet */
r_return
suffix:semicolon
)brace
macro_line|#endif&t;
multiline_comment|/*&n;&t; *&t;No reassigning numbers to fragments...&n;&t; */
r_if
c_cond
(paren
id|free
op_ne
l_int|2
)paren
(brace
id|iph-&gt;id
op_assign
id|htons
c_func
(paren
id|ip_id_count
op_increment
)paren
suffix:semicolon
)brace
r_else
id|free
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* All buffers without an owner socket get freed */
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
id|free
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;free
op_assign
id|free
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Do we need to fragment. Again this is inefficient.&n;&t; *&t;We need to somehow lock the original buffer and use&n;&t; *&t;bits of it.&n;&t; */
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|iph-&gt;tot_len
)paren
OG
id|dev-&gt;mtu
)paren
(brace
id|ip_fragment
c_func
(paren
id|sk
comma
id|skb
comma
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Add an IP checksum&n;&t; */
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Print the frame when debugging&n;&t; */
multiline_comment|/*&n;&t; *&t;More debugging. You cannot queue a packet already on a list&n;&t; *&t;Spot this and moan loudly.&n;&t; */
r_if
c_cond
(paren
id|skb-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|NETDEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;ip_queue_xmit: next != NULL&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If a sender wishes the packet to remain unfreed&n;&t; *&t;we add it to his send queue. This arguably belongs&n;&t; *&t;in the TCP level since nobody else uses it. BUT&n;&t; *&t;remember IPng might change all the rules.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|free
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* The socket now has more outstanding blocks */
id|sk-&gt;packets_out
op_increment
suffix:semicolon
multiline_comment|/* Protect the list for a moment */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;link3
op_ne
l_int|NULL
)paren
(brace
id|NETDEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;ip.c: link3 != NULL&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|skb-&gt;link3
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;send_head
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;send_tail
op_assign
id|skb
suffix:semicolon
id|sk-&gt;send_head
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;send_tail-&gt;link3
op_assign
id|skb
suffix:semicolon
id|sk-&gt;send_tail
op_assign
id|skb
suffix:semicolon
)brace
multiline_comment|/* skb-&gt;link3 is NULL */
multiline_comment|/* Interrupt restore */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Remember who owns the buffer */
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If the indicated interface is up and running, send the packet.&n;&t; */
id|ip_statistics.IpOutRequests
op_increment
suffix:semicolon
macro_line|#ifdef CONFIG_IP_ACCT
id|ip_fw_chk
c_func
(paren
id|iph
comma
id|dev
comma
id|ip_acct_chain
comma
id|IP_FW_F_ACCEPT
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif&t;
macro_line|#ifdef CONFIG_IP_MULTICAST&t;
multiline_comment|/*&n;&t; *&t;Multicasts are looped back for other local users&n;&t; */
r_if
c_cond
(paren
id|MULTICAST
c_func
(paren
id|iph-&gt;daddr
)paren
op_logical_and
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
op_logical_or
id|sk-&gt;ip_mc_loop
)paren
(brace
r_if
c_cond
(paren
id|iph-&gt;daddr
op_eq
id|IGMP_ALL_HOSTS
op_logical_or
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
)paren
(brace
id|ip_loopback
c_func
(paren
id|dev
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|ip_mc_list
op_star
id|imc
op_assign
id|dev-&gt;ip_mc_list
suffix:semicolon
r_while
c_loop
(paren
id|imc
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|imc-&gt;multiaddr
op_eq
id|iph-&gt;daddr
)paren
(brace
id|ip_loopback
c_func
(paren
id|dev
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|imc
op_assign
id|imc-&gt;next
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Multicasts with ttl 0 must not go beyond the host */
r_if
c_cond
(paren
id|skb-&gt;ip_hdr-&gt;ttl
op_eq
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_BROADCAST
)paren
op_logical_and
(paren
id|iph-&gt;daddr
op_eq
id|dev-&gt;pa_brdaddr
op_logical_or
id|iph-&gt;daddr
op_eq
l_int|0xFFFFFFFF
)paren
op_logical_and
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
)paren
(brace
id|ip_loopback
c_func
(paren
id|dev
comma
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;If we have an owner use its priority setting,&n;&t;&t; *&t;otherwise use NORMAL&n;&t;&t; */
r_if
c_cond
(paren
id|sk
op_ne
l_int|NULL
)paren
(brace
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
id|sk-&gt;priority
)paren
suffix:semicolon
)brace
r_else
(brace
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
id|SOPRI_NORMAL
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk
)paren
(brace
id|sk-&gt;err
op_assign
id|ENETDOWN
suffix:semicolon
)brace
id|ip_statistics.IpOutDiscards
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|free
)paren
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Build and send a packet, with as little as one copy&n; *&n; *&t;Doesn&squot;t care much about ip options... option length can be&n; *&t;different for fragment at 0 and other fragments.&n; *&n; *&t;Note that the fragment at the highest offset is sent first,&n; *&t;so the getfrag routine can fill in the TCP/UDP checksum header&n; *&t;field in the last fragment it sends... actually it also helps&n; * &t;the reassemblers, they can put most packets in at the head of&n; *&t;the fragment queue, and they know the total size in advance. This&n; *&t;last feature will measurable improve the Linux fragment handler.&n; *&n; *&t;The callback has five args, an arbitrary pointer (copy of frag),&n; *&t;the source IP address (may depend on the routing table), the &n; *&t;destination address (char *), the offset to copy from, and the&n; *&t;length to be copied.&n; * &n; */
DECL|function|ip_build_xmit
r_int
id|ip_build_xmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_void
id|getfrag
(paren
r_const
r_void
op_star
comma
id|__u32
comma
r_char
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
comma
r_const
r_void
op_star
id|frag
comma
r_int
r_int
r_int
id|length
comma
id|__u32
id|daddr
comma
id|__u32
id|user_saddr
comma
r_struct
id|options
op_star
id|opt
comma
r_int
id|flags
comma
r_int
id|type
comma
r_int
id|noblock
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_int
r_int
id|fraglen
comma
id|maxfraglen
comma
id|fragheaderlen
suffix:semicolon
r_int
id|offset
comma
id|mf
suffix:semicolon
id|__u32
id|saddr
suffix:semicolon
r_int
r_int
id|id
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
id|__u32
id|raddr
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|hh_cache
op_star
id|hh
op_assign
l_int|NULL
suffix:semicolon
r_int
id|nfrags
op_assign
l_int|0
suffix:semicolon
id|__u32
id|true_daddr
op_assign
id|daddr
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;srr
op_logical_and
op_logical_neg
id|sk-&gt;ip_hdrincl
)paren
id|daddr
op_assign
id|opt-&gt;faddr
suffix:semicolon
id|ip_statistics.IpOutRequests
op_increment
suffix:semicolon
macro_line|#ifdef CONFIG_IP_MULTICAST&t;
r_if
c_cond
(paren
id|sk
op_logical_and
id|MULTICAST
c_func
(paren
id|daddr
)paren
op_logical_and
op_star
id|sk-&gt;ip_mc_name
)paren
(brace
id|dev
op_assign
id|dev_get
c_func
(paren
id|sk-&gt;ip_mc_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|rt
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;saddr
op_logical_and
(paren
op_logical_neg
id|LOOPBACK
c_func
(paren
id|sk-&gt;saddr
)paren
op_logical_or
id|LOOPBACK
c_func
(paren
id|daddr
)paren
)paren
)paren
id|saddr
op_assign
id|sk-&gt;saddr
suffix:semicolon
r_else
id|saddr
op_assign
id|dev-&gt;pa_addr
suffix:semicolon
)brace
r_else
(brace
macro_line|#endif&t;
id|rt
op_assign
id|ip_check_route
c_func
(paren
op_amp
id|sk-&gt;ip_route_cache
comma
id|daddr
comma
id|sk-&gt;localroute
op_logical_or
(paren
id|flags
op_amp
id|MSG_DONTROUTE
)paren
op_logical_or
(paren
id|opt
op_logical_and
id|opt-&gt;is_strictroute
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
(brace
id|ip_statistics.IpOutNoRoutes
op_increment
suffix:semicolon
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
)brace
id|saddr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|hh
op_assign
id|rt-&gt;rt_hh
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;saddr
op_logical_and
(paren
op_logical_neg
id|LOOPBACK
c_func
(paren
id|sk-&gt;saddr
)paren
op_logical_or
id|LOOPBACK
c_func
(paren
id|daddr
)paren
)paren
)paren
id|saddr
op_assign
id|sk-&gt;saddr
suffix:semicolon
id|dev
op_assign
id|rt-&gt;rt_dev
suffix:semicolon
macro_line|#ifdef CONFIG_IP_MULTICAST
)brace
r_if
c_cond
(paren
id|rt
op_logical_and
op_logical_neg
id|dev
)paren
id|dev
op_assign
id|rt-&gt;rt_dev
suffix:semicolon
macro_line|#endif&t;&t;
r_if
c_cond
(paren
id|user_saddr
)paren
id|saddr
op_assign
id|user_saddr
suffix:semicolon
id|raddr
op_assign
id|rt
ques
c_cond
id|rt-&gt;rt_gateway
suffix:colon
id|daddr
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now compute the buffer space we require&n;&t; */
multiline_comment|/*&n;&t; *&t;Try the simple case first. This leaves broadcast, multicast, fragmented frames, and by&n;&t; *&t;choice RAW frames within 20 bytes of maximum size(rare) to the long path&n;&t; */
id|length
op_add_assign
r_sizeof
(paren
r_struct
id|iphdr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;ip_hdrincl
op_logical_and
id|opt
)paren
id|length
op_add_assign
id|opt-&gt;optlen
suffix:semicolon
r_if
c_cond
(paren
id|length
op_le
id|dev-&gt;mtu
op_logical_and
op_logical_neg
id|MULTICAST
c_func
(paren
id|daddr
)paren
op_logical_and
id|daddr
op_ne
l_int|0xFFFFFFFF
op_logical_and
id|daddr
op_ne
id|dev-&gt;pa_brdaddr
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|sock_alloc_send_skb
c_func
(paren
id|sk
comma
id|length
op_plus
l_int|15
op_plus
id|dev-&gt;hard_header_len
comma
l_int|0
comma
id|noblock
comma
op_amp
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|ip_statistics.IpOutDiscards
op_increment
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;saddr
op_assign
id|saddr
suffix:semicolon
id|skb-&gt;raddr
op_assign
id|raddr
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
(paren
id|dev-&gt;hard_header_len
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hh
)paren
(brace
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_push
c_func
(paren
id|skb
comma
id|dev-&gt;hard_header_len
)paren
comma
id|hh-&gt;hh_data
comma
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hh-&gt;hh_uptodate
)paren
(brace
id|skb-&gt;arp
op_assign
l_int|0
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;ip_build_xmit: hh miss %08x via %08x&bslash;n&quot;
comma
id|rt-&gt;rt_dst
comma
id|rt-&gt;rt_gateway
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;
)brace
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;hard_header
)paren
(brace
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|skb
comma
id|dev
comma
id|ETH_P_IP
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
)paren
OG
l_int|0
)paren
(brace
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;ip_hdr
op_assign
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
id|length
)paren
suffix:semicolon
id|dev_lock_list
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;ip_hdrincl
)paren
(brace
id|iph-&gt;version
op_assign
l_int|4
suffix:semicolon
id|iph-&gt;ihl
op_assign
l_int|5
suffix:semicolon
id|iph-&gt;tos
op_assign
id|sk-&gt;ip_tos
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|length
)paren
suffix:semicolon
id|iph-&gt;id
op_assign
id|htons
c_func
(paren
id|ip_id_count
op_increment
)paren
suffix:semicolon
id|iph-&gt;frag_off
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;ttl
op_assign
id|sk-&gt;ip_ttl
suffix:semicolon
id|iph-&gt;protocol
op_assign
id|type
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|saddr
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|daddr
suffix:semicolon
r_if
c_cond
(paren
id|opt
)paren
(brace
id|iph-&gt;ihl
op_add_assign
id|opt-&gt;optlen
op_rshift
l_int|2
suffix:semicolon
id|ip_options_build
c_func
(paren
id|skb
comma
id|opt
comma
id|true_daddr
comma
id|dev-&gt;pa_addr
comma
l_int|0
)paren
suffix:semicolon
)brace
id|iph-&gt;check
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;check
op_assign
id|ip_fast_csum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|iph
comma
id|iph-&gt;ihl
)paren
suffix:semicolon
id|getfrag
c_func
(paren
id|frag
comma
id|saddr
comma
(paren
(paren
r_char
op_star
)paren
id|iph
)paren
op_plus
id|iph-&gt;ihl
op_star
l_int|4
comma
l_int|0
comma
id|length
op_minus
id|iph-&gt;ihl
op_star
l_int|4
)paren
suffix:semicolon
)brace
r_else
id|getfrag
c_func
(paren
id|frag
comma
id|saddr
comma
(paren
r_void
op_star
)paren
id|iph
comma
l_int|0
comma
id|length
op_minus
l_int|20
)paren
suffix:semicolon
id|dev_unlock_list
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_FIREWALL
r_if
c_cond
(paren
id|call_out_firewall
c_func
(paren
id|PF_INET
comma
id|skb-&gt;dev
comma
id|iph
)paren
OL
id|FW_ACCEPT
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_IP_ACCT
id|ip_fw_chk
c_func
(paren
id|iph
comma
id|dev
comma
id|ip_acct_chain
comma
id|IP_FW_F_ACCEPT
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif&t;&t;
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
id|sk-&gt;priority
)paren
suffix:semicolon
)brace
r_else
(brace
id|ip_statistics.IpOutDiscards
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|length
op_sub_assign
r_sizeof
(paren
r_struct
id|iphdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_logical_and
op_logical_neg
id|sk-&gt;ip_hdrincl
op_logical_and
id|opt
)paren
(brace
id|length
op_sub_assign
id|opt-&gt;optlen
suffix:semicolon
id|fragheaderlen
op_assign
id|dev-&gt;hard_header_len
op_plus
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
id|opt-&gt;optlen
suffix:semicolon
id|maxfraglen
op_assign
(paren
(paren
id|dev-&gt;mtu
op_minus
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_minus
id|opt-&gt;optlen
)paren
op_amp
op_complement
l_int|7
)paren
op_plus
id|fragheaderlen
suffix:semicolon
)brace
r_else
(brace
id|fragheaderlen
op_assign
id|dev-&gt;hard_header_len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;ip_hdrincl
)paren
(brace
id|fragheaderlen
op_add_assign
l_int|20
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Fragheaderlen is the size of &squot;overhead&squot; on each buffer. Now work&n;&t;&t; *&t;out the size of the frames to send.&n;&t;&t; */
id|maxfraglen
op_assign
(paren
(paren
id|dev-&gt;mtu
op_minus
l_int|20
)paren
op_amp
op_complement
l_int|7
)paren
op_plus
id|fragheaderlen
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Start at the end of the frame by handling the remainder.&n;&t; */
id|offset
op_assign
id|length
op_minus
(paren
id|length
op_mod
(paren
id|maxfraglen
op_minus
id|fragheaderlen
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Amount of memory to allocate for final fragment.&n;&t; */
id|fraglen
op_assign
id|length
op_minus
id|offset
op_plus
id|fragheaderlen
suffix:semicolon
r_if
c_cond
(paren
id|length
op_minus
id|offset
op_eq
l_int|0
)paren
(brace
id|fraglen
op_assign
id|maxfraglen
suffix:semicolon
id|offset
op_sub_assign
id|maxfraglen
op_minus
id|fragheaderlen
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;The last fragment will not have MF (more fragments) set.&n;&t; */
id|mf
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Can&squot;t fragment raw packets &n;&t; */
r_if
c_cond
(paren
id|sk-&gt;ip_hdrincl
op_logical_and
id|offset
OG
l_int|0
)paren
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Lock the device lists.&n;&t; */
id|dev_lock_list
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Get an identifier&n;&t; */
id|id
op_assign
id|htons
c_func
(paren
id|ip_id_count
op_increment
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Being outputting the bytes.&n;&t; */
r_do
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|error
suffix:semicolon
r_char
op_star
id|data
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Get the memory we require with some space left for alignment.&n;&t;&t; */
id|skb
op_assign
id|sock_alloc_send_skb
c_func
(paren
id|sk
comma
id|fraglen
op_plus
l_int|15
comma
l_int|0
comma
id|noblock
comma
op_amp
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|ip_statistics.IpOutDiscards
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|nfrags
OG
l_int|1
)paren
(brace
id|ip_statistics.IpFragCreates
op_increment
suffix:semicolon
)brace
id|dev_unlock_list
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Fill in the control structures&n;&t;&t; */
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* dubious, this one */
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;saddr
op_assign
id|saddr
suffix:semicolon
id|skb-&gt;raddr
op_assign
id|raddr
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
(paren
id|dev-&gt;hard_header_len
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
)paren
suffix:semicolon
id|data
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|fraglen
op_minus
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Save us ARP and stuff. In the optimal case we do no route lookup (route cache ok)&n;&t;&t; *&t;no ARP lookup (arp cache ok) and output. The cache checks are still too slow but&n;&t;&t; *&t;this can be fixed later. For gateway routes we ought to have a rt-&gt;.. header cache&n;&t;&t; *&t;pointer to speed header cache builds for identical targets.&n;&t;&t; */
r_if
c_cond
(paren
id|hh
)paren
(brace
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_push
c_func
(paren
id|skb
comma
id|dev-&gt;hard_header_len
)paren
comma
id|hh-&gt;hh_data
comma
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hh-&gt;hh_uptodate
)paren
(brace
id|skb-&gt;arp
op_assign
l_int|0
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;ip_build_xmit: hh miss %08x via %08x&bslash;n&quot;
comma
id|rt-&gt;rt_dst
comma
id|rt-&gt;rt_gateway
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;
)brace
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;hard_header
)paren
(brace
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|skb
comma
id|dev
comma
id|ETH_P_IP
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
)paren
OG
l_int|0
)paren
(brace
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; *&t;Find where to start putting bytes.&n;&t;&t; */
id|skb-&gt;ip_hdr
op_assign
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|data
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Only write IP header onto non-raw packets &n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;ip_hdrincl
)paren
(brace
id|iph-&gt;version
op_assign
l_int|4
suffix:semicolon
id|iph-&gt;ihl
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* ugh */
r_if
c_cond
(paren
id|opt
)paren
(brace
id|iph-&gt;ihl
op_add_assign
id|opt-&gt;optlen
op_rshift
l_int|2
suffix:semicolon
id|ip_options_build
c_func
(paren
id|skb
comma
id|opt
comma
id|true_daddr
comma
id|dev-&gt;pa_addr
comma
id|offset
)paren
suffix:semicolon
)brace
id|iph-&gt;tos
op_assign
id|sk-&gt;ip_tos
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|fraglen
op_minus
id|fragheaderlen
op_plus
id|iph-&gt;ihl
op_star
l_int|4
)paren
suffix:semicolon
id|iph-&gt;id
op_assign
id|id
suffix:semicolon
id|iph-&gt;frag_off
op_assign
id|htons
c_func
(paren
id|offset
op_rshift
l_int|3
)paren
suffix:semicolon
id|iph-&gt;frag_off
op_or_assign
id|mf
suffix:semicolon
macro_line|#ifdef CONFIG_IP_MULTICAST
r_if
c_cond
(paren
id|MULTICAST
c_func
(paren
id|daddr
)paren
)paren
id|iph-&gt;ttl
op_assign
id|sk-&gt;ip_mc_ttl
suffix:semicolon
r_else
macro_line|#endif
id|iph-&gt;ttl
op_assign
id|sk-&gt;ip_ttl
suffix:semicolon
id|iph-&gt;protocol
op_assign
id|type
suffix:semicolon
id|iph-&gt;check
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|saddr
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|daddr
suffix:semicolon
id|iph-&gt;check
op_assign
id|ip_fast_csum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|iph
comma
id|iph-&gt;ihl
)paren
suffix:semicolon
id|data
op_add_assign
id|iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Any further fragments will have MF set.&n;&t;&t;&t; */
id|mf
op_assign
id|htons
c_func
(paren
id|IP_MF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;User data callback&n;&t;&t; */
id|getfrag
c_func
(paren
id|frag
comma
id|saddr
comma
id|data
comma
id|offset
comma
id|fraglen
op_minus
id|fragheaderlen
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Account for the fragment.&n;&t;&t; */
macro_line|#ifdef CONFIG_FIREWALL
r_if
c_cond
(paren
op_logical_neg
id|offset
op_logical_and
id|call_out_firewall
c_func
(paren
id|PF_INET
comma
id|skb-&gt;dev
comma
id|iph
)paren
OL
id|FW_ACCEPT
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|dev_unlock_list
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
macro_line|#endif&t;&t;
macro_line|#ifdef CONFIG_IP_ACCT
r_if
c_cond
(paren
op_logical_neg
id|offset
)paren
(brace
id|ip_fw_chk
c_func
(paren
id|iph
comma
id|dev
comma
id|ip_acct_chain
comma
id|IP_FW_F_ACCEPT
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif&t;
id|offset
op_sub_assign
(paren
id|maxfraglen
op_minus
id|fragheaderlen
)paren
suffix:semicolon
id|fraglen
op_assign
id|maxfraglen
suffix:semicolon
macro_line|#ifdef CONFIG_IP_MULTICAST
multiline_comment|/*&n;&t;&t; *&t;Multicasts are looped back for other local users&n;&t;&t; */
r_if
c_cond
(paren
id|MULTICAST
c_func
(paren
id|daddr
)paren
op_logical_and
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Loop back any frames. The check for IGMP_ALL_HOSTS is because&n;&t;&t;&t; *&t;you are always magically a member of this group.&n;&t;&t;&t; *&n;&t;&t;&t; *&t;Always loop back all host messages when running as a multicast router.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
op_logical_or
id|sk-&gt;ip_mc_loop
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;daddr
op_eq
id|IGMP_ALL_HOSTS
op_logical_or
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
)paren
(brace
id|ip_loopback
c_func
(paren
id|dev
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|ip_mc_list
op_star
id|imc
op_assign
id|dev-&gt;ip_mc_list
suffix:semicolon
r_while
c_loop
(paren
id|imc
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|imc-&gt;multiaddr
op_eq
id|daddr
)paren
(brace
id|ip_loopback
c_func
(paren
id|dev
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|imc
op_assign
id|imc-&gt;next
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;Multicasts with ttl 0 must not go beyond the host. Fixme: avoid the&n;&t;&t;&t; *&t;extra clone.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;ip_hdr-&gt;ttl
op_eq
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|nfrags
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;BSD loops broadcasts&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_BROADCAST
)paren
op_logical_and
(paren
id|daddr
op_eq
l_int|0xFFFFFFFF
op_logical_or
id|daddr
op_eq
id|dev-&gt;pa_brdaddr
)paren
op_logical_and
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
)paren
(brace
id|ip_loopback
c_func
(paren
id|dev
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Now queue the bytes into the device.&n;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
id|sk-&gt;priority
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Whoops... &n;&t;&t;&t; */
id|ip_statistics.IpOutDiscards
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|nfrags
OG
l_int|1
)paren
(brace
id|ip_statistics.IpFragCreates
op_add_assign
id|nfrags
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|dev_unlock_list
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;BSD behaviour.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sk
op_ne
l_int|NULL
)paren
(brace
id|sk-&gt;err
op_assign
id|ENETDOWN
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* lose rest of fragments */
)brace
)brace
r_while
c_loop
(paren
id|offset
op_ge
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nfrags
OG
l_int|1
)paren
(brace
id|ip_statistics.IpFragCreates
op_add_assign
id|nfrags
suffix:semicolon
)brace
id|dev_unlock_list
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;IP protocol layer initialiser&n; */
DECL|variable|ip_packet_type
r_static
r_struct
id|packet_type
id|ip_packet_type
op_assign
(brace
l_int|0
comma
multiline_comment|/* MUTTER ntohs(ETH_P_IP),*/
l_int|NULL
comma
multiline_comment|/* All devices */
id|ip_rcv
comma
l_int|NULL
comma
l_int|NULL
comma
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_RTNETLINK
multiline_comment|/*&n; *&t;Netlink hooks for IP&n; */
DECL|function|ip_netlink_msg
r_void
id|ip_netlink_msg
c_func
(paren
r_int
r_int
id|msg
comma
id|__u32
id|daddr
comma
id|__u32
id|gw
comma
id|__u32
id|mask
comma
r_int
id|flags
comma
r_int
id|metric
comma
r_char
op_star
id|name
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|alloc_skb
c_func
(paren
r_sizeof
(paren
r_struct
id|netlink_rtinfo
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_struct
id|netlink_rtinfo
op_star
id|nrt
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|s
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
id|nrt
op_assign
(paren
r_struct
id|netlink_rtinfo
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|netlink_rtinfo
)paren
)paren
suffix:semicolon
id|nrt-&gt;rtmsg_type
op_assign
id|msg
suffix:semicolon
id|s
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|nrt-&gt;rtmsg_dst
suffix:semicolon
id|s-&gt;sin_family
op_assign
id|AF_INET
suffix:semicolon
id|s-&gt;sin_addr.s_addr
op_assign
id|daddr
suffix:semicolon
id|s
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|nrt-&gt;rtmsg_gateway
suffix:semicolon
id|s-&gt;sin_family
op_assign
id|AF_INET
suffix:semicolon
id|s-&gt;sin_addr.s_addr
op_assign
id|gw
suffix:semicolon
id|s
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|nrt-&gt;rtmsg_genmask
suffix:semicolon
id|s-&gt;sin_family
op_assign
id|AF_INET
suffix:semicolon
id|s-&gt;sin_addr.s_addr
op_assign
id|mask
suffix:semicolon
id|nrt-&gt;rtmsg_flags
op_assign
id|flags
suffix:semicolon
id|nrt-&gt;rtmsg_metric
op_assign
id|metric
suffix:semicolon
id|strcpy
c_func
(paren
id|nrt-&gt;rtmsg_device
comma
id|name
)paren
suffix:semicolon
id|netlink_post
c_func
(paren
id|NETLINK_ROUTE
comma
id|skb
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; *&t;Device notifier&n; */
DECL|function|ip_rt_event
r_static
r_int
id|ip_rt_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|event
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|event
op_eq
id|NETDEV_DOWN
)paren
(brace
id|ip_netlink_msg
c_func
(paren
id|RTMSG_DELDEVICE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ip_rt_flush
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Join the initial group if multicast.&n; */
r_if
c_cond
(paren
id|event
op_eq
id|NETDEV_UP
)paren
(brace
macro_line|#ifdef CONFIG_IP_MULTICAST&t;
id|ip_mc_allhost
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif&t;&t;
id|ip_netlink_msg
c_func
(paren
id|RTMSG_NEWDEVICE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|variable|ip_rt_notifier
r_struct
id|notifier_block
id|ip_rt_notifier
op_assign
initialization_block
suffix:semicolon
multiline_comment|/*&n; *&t;IP registers the packet type and then calls the subprotocol initialisers&n; */
DECL|function|ip_init
r_void
id|ip_init
c_func
(paren
r_void
)paren
(brace
id|ip_packet_type.type
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
id|dev_add_pack
c_func
(paren
op_amp
id|ip_packet_type
)paren
suffix:semicolon
multiline_comment|/* So we flush routes when a device is downed */
id|register_netdevice_notifier
c_func
(paren
op_amp
id|ip_rt_notifier
)paren
suffix:semicolon
multiline_comment|/*&t;ip_raw_init();&n;&t;ip_packet_init();&n;&t;ip_tcp_init();&n;&t;ip_udp_init();*/
macro_line|#ifdef CONFIG_IP_MULTICAST
id|proc_net_register
c_func
(paren
op_amp
(paren
r_struct
id|proc_dir_entry
)paren
(brace
id|PROC_NET_IGMP
comma
l_int|4
comma
l_string|&quot;igmp&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_amp
id|proc_net_inode_operations
comma
id|ip_mc_procinfo
)brace
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
