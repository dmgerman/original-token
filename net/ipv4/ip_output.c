multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;The Internet Protocol (IP) output module.&n; *&n; * Version:&t;$Id: ip_output.c,v 1.87 2000/10/25 20:07:22 davem Exp $&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Donald Becker, &lt;becker@super.org&gt;&n; *&t;&t;Alan Cox, &lt;Alan.Cox@linux.org&gt;&n; *&t;&t;Richard Underwood&n; *&t;&t;Stefan Becker, &lt;stefanb@yello.ping.de&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&n; *&t;See ip_input.c for original log&n; *&n; *&t;Fixes:&n; *&t;&t;Alan Cox&t;:&t;Missing nonblock feature in ip_build_xmit.&n; *&t;&t;Mike Kilburn&t;:&t;htons() missing in ip_build_xmit.&n; *&t;&t;Bradford Johnson:&t;Fix faulty handling of some frames when &n; *&t;&t;&t;&t;&t;no route is found.&n; *&t;&t;Alexander Demenshin:&t;Missing sk/skb free in ip_queue_xmit&n; *&t;&t;&t;&t;&t;(in case if packet not accepted by&n; *&t;&t;&t;&t;&t;output firewall rules)&n; *&t;&t;Mike McLagan&t;:&t;Routing by source&n; *&t;&t;Alexey Kuznetsov:&t;use new route cache&n; *&t;&t;Andi Kleen:&t;&t;Fix broken PMTU recovery and remove&n; *&t;&t;&t;&t;&t;some redundant tests.&n; *&t;Vitaly E. Lavrov&t;:&t;Transparent proxy revived after year coma.&n; *&t;&t;Andi Kleen&t;: &t;Replace ip_reply with ip_send_reply.&n; *&t;&t;Andi Kleen&t;:&t;Split fast and slow ip_build_xmit path &n; *&t;&t;&t;&t;&t;for decreased register pressure on x86 &n; *&t;&t;&t;&t;&t;and more readibility. &n; *&t;&t;Marc Boucher&t;:&t;When call_out_firewall returns FW_QUEUE,&n; *&t;&t;&t;&t;&t;silently drop skb instead of failing with -EPERM.&n; */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;net/snmp.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/raw.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;net/inetpeer.h&gt;
macro_line|#include &lt;linux/igmp.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4.h&gt;
macro_line|#include &lt;linux/mroute.h&gt;
macro_line|#include &lt;linux/netlink.h&gt;
multiline_comment|/*&n; *      Shall we try to damage output packets if routing dev changes?&n; */
DECL|variable|sysctl_ip_dynaddr
r_int
id|sysctl_ip_dynaddr
op_assign
l_int|0
suffix:semicolon
DECL|variable|sysctl_ip_default_ttl
r_int
id|sysctl_ip_default_ttl
op_assign
id|IPDEFTTL
suffix:semicolon
multiline_comment|/* Generate a checksum for an outgoing IP datagram. */
DECL|function|ip_send_check
id|__inline__
r_void
id|ip_send_check
c_func
(paren
r_struct
id|iphdr
op_star
id|iph
)paren
(brace
id|iph-&gt;check
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;check
op_assign
id|ip_fast_csum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|iph
comma
id|iph-&gt;ihl
)paren
suffix:semicolon
)brace
multiline_comment|/* dev_loopback_xmit for use with netfilter. */
DECL|function|ip_dev_loopback_xmit
r_static
r_int
id|ip_dev_loopback_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|newskb
)paren
(brace
id|newskb-&gt;mac.raw
op_assign
id|newskb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|newskb
comma
id|newskb-&gt;nh.raw
op_minus
id|newskb-&gt;data
)paren
suffix:semicolon
id|newskb-&gt;pkt_type
op_assign
id|PACKET_LOOPBACK
suffix:semicolon
id|newskb-&gt;ip_summed
op_assign
id|CHECKSUM_UNNECESSARY
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|newskb-&gt;dst
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
id|nf_debug_ip_loopback_xmit
c_func
(paren
id|newskb
)paren
suffix:semicolon
macro_line|#endif
id|netif_rx
c_func
(paren
id|newskb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t just hand NF_HOOK skb-&gt;dst-&gt;output, in case netfilter hook&n;   changes route */
r_static
r_inline
r_int
DECL|function|output_maybe_reroute
id|output_maybe_reroute
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
id|skb-&gt;dst
op_member_access_from_pointer
id|output
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;&t;Add an ip header to a skbuff and send it out.&n; */
DECL|function|ip_build_and_send_pkt
r_int
id|ip_build_and_send_pkt
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|saddr
comma
id|u32
id|daddr
comma
r_struct
id|ip_options
op_star
id|opt
)paren
(brace
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
multiline_comment|/* Build the IP header. */
r_if
c_cond
(paren
id|opt
)paren
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
id|opt-&gt;optlen
)paren
suffix:semicolon
r_else
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|iphdr
)paren
)paren
suffix:semicolon
id|iph-&gt;version
op_assign
l_int|4
suffix:semicolon
id|iph-&gt;ihl
op_assign
l_int|5
suffix:semicolon
id|iph-&gt;tos
op_assign
id|sk-&gt;protinfo.af_inet.tos
suffix:semicolon
id|iph-&gt;frag_off
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ip_dont_fragment
c_func
(paren
id|sk
comma
op_amp
id|rt-&gt;u.dst
)paren
)paren
id|iph-&gt;frag_off
op_or_assign
id|htons
c_func
(paren
id|IP_DF
)paren
suffix:semicolon
id|iph-&gt;ttl
op_assign
id|sk-&gt;protinfo.af_inet.ttl
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|rt-&gt;rt_dst
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|iph-&gt;protocol
op_assign
id|sk-&gt;protocol
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|skb-&gt;len
)paren
suffix:semicolon
id|ip_select_ident
c_func
(paren
id|iph
comma
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
id|skb-&gt;nh.iph
op_assign
id|iph
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;optlen
)paren
(brace
id|iph-&gt;ihl
op_add_assign
id|opt-&gt;optlen
op_rshift
l_int|2
suffix:semicolon
id|ip_options_build
c_func
(paren
id|skb
comma
id|opt
comma
id|daddr
comma
id|rt
comma
l_int|0
)paren
suffix:semicolon
)brace
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
multiline_comment|/* Send it out. */
r_return
id|NF_HOOK
c_func
(paren
id|PF_INET
comma
id|NF_IP_LOCAL_OUT
comma
id|skb
comma
l_int|NULL
comma
id|rt-&gt;u.dst.dev
comma
id|output_maybe_reroute
)paren
suffix:semicolon
)brace
DECL|function|ip_finish_output2
r_static
r_inline
r_int
id|ip_finish_output2
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|skb-&gt;dst
suffix:semicolon
r_struct
id|hh_cache
op_star
id|hh
op_assign
id|dst-&gt;hh
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
id|nf_debug_ip_finish_output2
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif /*CONFIG_NETFILTER_DEBUG*/
r_if
c_cond
(paren
id|hh
)paren
(brace
id|read_lock_bh
c_func
(paren
op_amp
id|hh-&gt;hh_lock
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb-&gt;data
op_minus
l_int|16
comma
id|hh-&gt;hh_data
comma
l_int|16
)paren
suffix:semicolon
id|read_unlock_bh
c_func
(paren
op_amp
id|hh-&gt;hh_lock
)paren
suffix:semicolon
id|skb_push
c_func
(paren
id|skb
comma
id|hh-&gt;hh_len
)paren
suffix:semicolon
r_return
id|hh
op_member_access_from_pointer
id|hh_output
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dst-&gt;neighbour
)paren
r_return
id|dst-&gt;neighbour
op_member_access_from_pointer
id|output
c_func
(paren
id|skb
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;khm&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|ip_finish_output
id|__inline__
r_int
id|ip_finish_output
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|skb-&gt;dst-&gt;dev
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
r_return
id|NF_HOOK
c_func
(paren
id|PF_INET
comma
id|NF_IP_POST_ROUTING
comma
id|skb
comma
l_int|NULL
comma
id|dev
comma
id|ip_finish_output2
)paren
suffix:semicolon
)brace
DECL|function|ip_mc_output
r_int
id|ip_mc_output
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|skb-&gt;sk
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|rt-&gt;u.dst.dev
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If the indicated interface is up and running, send the packet.&n;&t; */
id|IP_INC_STATS
c_func
(paren
id|IpOutRequests
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IP_ROUTE_NAT
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_NAT
)paren
id|ip_do_nat
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Multicasts are looped back for other local users&n;&t; */
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_MULTICAST
op_logical_and
(paren
op_logical_neg
id|sk
op_logical_or
id|sk-&gt;protinfo.af_inet.mc_loop
)paren
)paren
(brace
macro_line|#ifdef CONFIG_IP_MROUTE
multiline_comment|/* Small optimization: do not loopback not local frames,&n;&t;&t;   which returned after forwarding; they will be  dropped&n;&t;&t;   by ip_mr_input in any case.&n;&t;&t;   Note, that local frames are looped back to be delivered&n;&t;&t;   to local recipients.&n;&n;&t;&t;   This check is duplicated in ip_mr_input at the moment.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_LOCAL
)paren
op_logical_or
op_logical_neg
(paren
id|IPCB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_amp
id|IPSKB_FORWARDED
)paren
)paren
macro_line|#endif
(brace
r_struct
id|sk_buff
op_star
id|newskb
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newskb
)paren
id|NF_HOOK
c_func
(paren
id|PF_INET
comma
id|NF_IP_POST_ROUTING
comma
id|newskb
comma
l_int|NULL
comma
id|newskb-&gt;dev
comma
id|ip_dev_loopback_xmit
)paren
suffix:semicolon
)brace
multiline_comment|/* Multicasts with ttl 0 must not go beyond the host */
r_if
c_cond
(paren
id|skb-&gt;nh.iph-&gt;ttl
op_eq
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_BROADCAST
)paren
(brace
r_struct
id|sk_buff
op_star
id|newskb
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newskb
)paren
id|NF_HOOK
c_func
(paren
id|PF_INET
comma
id|NF_IP_POST_ROUTING
comma
id|newskb
comma
l_int|NULL
comma
id|newskb-&gt;dev
comma
id|ip_dev_loopback_xmit
)paren
suffix:semicolon
)brace
r_return
id|ip_finish_output
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
DECL|function|ip_output
r_int
id|ip_output
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
macro_line|#ifdef CONFIG_IP_ROUTE_NAT
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
macro_line|#endif
id|IP_INC_STATS
c_func
(paren
id|IpOutRequests
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IP_ROUTE_NAT
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTCF_NAT
)paren
id|ip_do_nat
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ip_finish_output
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* Queues a packet to be sent, and starts the transmitter if necessary.  &n; * This routine also needs to put in the total length and compute the &n; * checksum.  We use to do this in two stages, ip_build_header() then&n; * this, but that scheme created a mess when routes disappeared etc.&n; * So we do it all here, and the TCP send engine has been changed to&n; * match. (No more unroutable FIN disasters, etc. wheee...)  This will&n; * most likely make other reliable transport layers above IP easier&n; * to implement under Linux.&n; */
DECL|function|ip_queue_xmit2
r_static
r_inline
r_int
id|ip_queue_xmit2
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|skb-&gt;sk
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
id|dev
op_assign
id|rt-&gt;u.dst.dev
suffix:semicolon
multiline_comment|/* This can happen when the transport layer has segments queued&n;&t; * with a cached route, and by the time we get here things are&n;&t; * re-routed to a device with a different MTU than the original&n;&t; * device.  Sick, but we must cover it.&n;&t; */
r_if
c_cond
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
OL
id|dev-&gt;hard_header_len
op_logical_and
id|dev-&gt;hard_header
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
id|skb2
op_assign
id|skb_realloc_headroom
c_func
(paren
id|skb
comma
(paren
id|dev-&gt;hard_header_len
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb2
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|sk
)paren
id|skb_set_owner_w
c_func
(paren
id|skb2
comma
id|sk
)paren
suffix:semicolon
id|skb
op_assign
id|skb2
suffix:semicolon
id|iph
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|rt-&gt;u.dst.pmtu
)paren
r_goto
id|fragment
suffix:semicolon
r_if
c_cond
(paren
id|ip_dont_fragment
c_func
(paren
id|sk
comma
op_amp
id|rt-&gt;u.dst
)paren
)paren
id|iph-&gt;frag_off
op_or_assign
id|__constant_htons
c_func
(paren
id|IP_DF
)paren
suffix:semicolon
id|ip_select_ident
c_func
(paren
id|iph
comma
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
multiline_comment|/* Add an IP checksum. */
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
id|skb-&gt;priority
op_assign
id|sk-&gt;priority
suffix:semicolon
r_return
id|skb-&gt;dst
op_member_access_from_pointer
id|output
c_func
(paren
id|skb
)paren
suffix:semicolon
id|fragment
suffix:colon
r_if
c_cond
(paren
id|ip_dont_fragment
c_func
(paren
id|sk
comma
op_amp
id|rt-&gt;u.dst
)paren
)paren
(brace
multiline_comment|/* Reject packet ONLY if TCP might fragment&n;&t;&t; * it itself, if were careful enough.&n;&t;&t; */
id|iph-&gt;frag_off
op_or_assign
id|__constant_htons
c_func
(paren
id|IP_DF
)paren
suffix:semicolon
id|NETDEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;sending pkt_too_big to self&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|icmp_send
c_func
(paren
id|skb
comma
id|ICMP_DEST_UNREACH
comma
id|ICMP_FRAG_NEEDED
comma
id|htonl
c_func
(paren
id|rt-&gt;u.dst.pmtu
)paren
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
)brace
id|ip_select_ident
c_func
(paren
id|iph
comma
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
r_return
id|ip_fragment
c_func
(paren
id|skb
comma
id|skb-&gt;dst-&gt;output
)paren
suffix:semicolon
)brace
DECL|function|ip_queue_xmit
r_int
id|ip_queue_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|skb-&gt;sk
suffix:semicolon
r_struct
id|ip_options
op_star
id|opt
op_assign
id|sk-&gt;protinfo.af_inet.opt
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
multiline_comment|/* Make sure we can route this packet. */
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|__sk_dst_check
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
(brace
id|u32
id|daddr
suffix:semicolon
multiline_comment|/* Use correct destination address if we have options. */
id|daddr
op_assign
id|sk-&gt;daddr
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;srr
)paren
(brace
id|daddr
op_assign
id|opt-&gt;faddr
suffix:semicolon
)brace
multiline_comment|/* If this fails, retransmit mechanism of transport layer will&n;&t;&t; * keep trying until route appears or the connection times itself&n;&t;&t; * out.&n;&t;&t; */
r_if
c_cond
(paren
id|ip_route_output
c_func
(paren
op_amp
id|rt
comma
id|daddr
comma
id|sk-&gt;saddr
comma
id|RT_TOS
c_func
(paren
id|sk-&gt;protinfo.af_inet.tos
)paren
op_or
id|RTO_CONN
op_or
id|sk-&gt;localroute
comma
id|sk-&gt;bound_dev_if
)paren
)paren
r_goto
id|no_route
suffix:semicolon
id|__sk_dst_set
c_func
(paren
id|sk
comma
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
)brace
id|skb-&gt;dst
op_assign
id|dst_clone
c_func
(paren
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;is_strictroute
op_logical_and
id|rt-&gt;rt_dst
op_ne
id|rt-&gt;rt_gateway
)paren
r_goto
id|no_route
suffix:semicolon
multiline_comment|/* OK, we know where to send it, allocate and build IP header. */
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
(paren
id|opt
ques
c_cond
id|opt-&gt;optlen
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
op_star
(paren
(paren
id|__u16
op_star
)paren
id|iph
)paren
op_assign
id|htons
c_func
(paren
(paren
l_int|4
op_lshift
l_int|12
)paren
op_or
(paren
l_int|5
op_lshift
l_int|8
)paren
op_or
(paren
id|sk-&gt;protinfo.af_inet.tos
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|skb-&gt;len
)paren
suffix:semicolon
id|iph-&gt;frag_off
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;ttl
op_assign
id|sk-&gt;protinfo.af_inet.ttl
suffix:semicolon
id|iph-&gt;protocol
op_assign
id|sk-&gt;protocol
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|rt-&gt;rt_dst
suffix:semicolon
id|skb-&gt;nh.iph
op_assign
id|iph
suffix:semicolon
multiline_comment|/* Transport layer set skb-&gt;h.foo itself. */
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;optlen
)paren
(brace
id|iph-&gt;ihl
op_add_assign
id|opt-&gt;optlen
op_rshift
l_int|2
suffix:semicolon
id|ip_options_build
c_func
(paren
id|skb
comma
id|opt
comma
id|sk-&gt;daddr
comma
id|rt
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|NF_HOOK
c_func
(paren
id|PF_INET
comma
id|NF_IP_LOCAL_OUT
comma
id|skb
comma
l_int|NULL
comma
id|rt-&gt;u.dst.dev
comma
id|ip_queue_xmit2
)paren
suffix:semicolon
id|no_route
suffix:colon
id|IP_INC_STATS
c_func
(paren
id|IpOutNoRoutes
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|EHOSTUNREACH
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Build and send a packet, with as little as one copy&n; *&n; *&t;Doesn&squot;t care much about ip options... option length can be&n; *&t;different for fragment at 0 and other fragments.&n; *&n; *&t;Note that the fragment at the highest offset is sent first,&n; *&t;so the getfrag routine can fill in the TCP/UDP checksum header&n; *&t;field in the last fragment it sends... actually it also helps&n; * &t;the reassemblers, they can put most packets in at the head of&n; *&t;the fragment queue, and they know the total size in advance. This&n; *&t;last feature will measurably improve the Linux fragment handler one&n; *&t;day.&n; *&n; *&t;The callback has five args, an arbitrary pointer (copy of frag),&n; *&t;the source IP address (may depend on the routing table), the &n; *&t;destination address (char *), the offset to copy from, and the&n; *&t;length to be copied.&n; */
DECL|function|ip_build_xmit_slow
r_static
r_int
id|ip_build_xmit_slow
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|getfrag
(paren
r_const
r_void
op_star
comma
r_char
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
comma
r_const
r_void
op_star
id|frag
comma
r_int
id|length
comma
r_struct
id|ipcm_cookie
op_star
id|ipc
comma
r_struct
id|rtable
op_star
id|rt
comma
r_int
id|flags
)paren
(brace
r_int
r_int
id|fraglen
comma
id|maxfraglen
comma
id|fragheaderlen
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|offset
comma
id|mf
suffix:semicolon
r_int
id|mtu
suffix:semicolon
id|u16
id|id
op_assign
l_int|0
suffix:semicolon
r_int
id|hh_len
op_assign
(paren
id|rt-&gt;u.dst.dev-&gt;hard_header_len
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
suffix:semicolon
r_int
id|nfrags
op_assign
l_int|0
suffix:semicolon
r_struct
id|ip_options
op_star
id|opt
op_assign
id|ipc-&gt;opt
suffix:semicolon
r_int
id|df
op_assign
l_int|0
suffix:semicolon
id|mtu
op_assign
id|rt-&gt;u.dst.pmtu
suffix:semicolon
r_if
c_cond
(paren
id|ip_dont_fragment
c_func
(paren
id|sk
comma
op_amp
id|rt-&gt;u.dst
)paren
)paren
id|df
op_assign
id|htons
c_func
(paren
id|IP_DF
)paren
suffix:semicolon
id|length
op_sub_assign
r_sizeof
(paren
r_struct
id|iphdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt
)paren
(brace
id|fragheaderlen
op_assign
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_plus
id|opt-&gt;optlen
suffix:semicolon
id|maxfraglen
op_assign
(paren
(paren
id|mtu
op_minus
r_sizeof
(paren
r_struct
id|iphdr
)paren
op_minus
id|opt-&gt;optlen
)paren
op_amp
op_complement
l_int|7
)paren
op_plus
id|fragheaderlen
suffix:semicolon
)brace
r_else
(brace
id|fragheaderlen
op_assign
r_sizeof
(paren
r_struct
id|iphdr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Fragheaderlen is the size of &squot;overhead&squot; on each buffer. Now work&n;&t;&t; *&t;out the size of the frames to send.&n;&t;&t; */
id|maxfraglen
op_assign
(paren
(paren
id|mtu
op_minus
r_sizeof
(paren
r_struct
id|iphdr
)paren
)paren
op_amp
op_complement
l_int|7
)paren
op_plus
id|fragheaderlen
suffix:semicolon
)brace
r_if
c_cond
(paren
id|length
op_plus
id|fragheaderlen
OG
l_int|0xFFFF
)paren
(brace
id|ip_local_error
c_func
(paren
id|sk
comma
id|EMSGSIZE
comma
id|rt-&gt;rt_dst
comma
id|sk-&gt;dport
comma
id|mtu
)paren
suffix:semicolon
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Start at the end of the frame by handling the remainder.&n;&t; */
id|offset
op_assign
id|length
op_minus
(paren
id|length
op_mod
(paren
id|maxfraglen
op_minus
id|fragheaderlen
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Amount of memory to allocate for final fragment.&n;&t; */
id|fraglen
op_assign
id|length
op_minus
id|offset
op_plus
id|fragheaderlen
suffix:semicolon
r_if
c_cond
(paren
id|length
op_minus
id|offset
op_eq
l_int|0
)paren
(brace
id|fraglen
op_assign
id|maxfraglen
suffix:semicolon
id|offset
op_sub_assign
id|maxfraglen
op_minus
id|fragheaderlen
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;The last fragment will not have MF (more fragments) set.&n;&t; */
id|mf
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Don&squot;t fragment packets for path mtu discovery.&n;&t; */
r_if
c_cond
(paren
id|offset
OG
l_int|0
op_logical_and
id|sk-&gt;protinfo.af_inet.pmtudisc
op_eq
id|IP_PMTUDISC_DO
)paren
(brace
id|ip_local_error
c_func
(paren
id|sk
comma
id|EMSGSIZE
comma
id|rt-&gt;rt_dst
comma
id|sk-&gt;dport
comma
id|mtu
)paren
suffix:semicolon
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PROBE
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Begin outputting the bytes.&n;&t; */
r_do
(brace
r_char
op_star
id|data
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Get the memory we require with some space left for alignment.&n;&t;&t; */
id|skb
op_assign
id|sock_alloc_send_skb
c_func
(paren
id|sk
comma
id|fraglen
op_plus
id|hh_len
op_plus
l_int|15
comma
l_int|0
comma
id|flags
op_amp
id|MSG_DONTWAIT
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Fill in the control structures&n;&t;&t; */
id|skb-&gt;priority
op_assign
id|sk-&gt;priority
suffix:semicolon
id|skb-&gt;dst
op_assign
id|dst_clone
c_func
(paren
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
id|hh_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Find where to start putting bytes.&n;&t;&t; */
id|data
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|fraglen
)paren
suffix:semicolon
id|skb-&gt;nh.iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|data
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Only write IP header onto non-raw packets &n;&t;&t; */
(brace
r_struct
id|iphdr
op_star
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|data
suffix:semicolon
id|iph-&gt;version
op_assign
l_int|4
suffix:semicolon
id|iph-&gt;ihl
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|opt
)paren
(brace
id|iph-&gt;ihl
op_add_assign
id|opt-&gt;optlen
op_rshift
l_int|2
suffix:semicolon
id|ip_options_build
c_func
(paren
id|skb
comma
id|opt
comma
id|ipc-&gt;addr
comma
id|rt
comma
id|offset
)paren
suffix:semicolon
)brace
id|iph-&gt;tos
op_assign
id|sk-&gt;protinfo.af_inet.tos
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|fraglen
op_minus
id|fragheaderlen
op_plus
id|iph-&gt;ihl
op_star
l_int|4
)paren
suffix:semicolon
id|iph-&gt;frag_off
op_assign
id|htons
c_func
(paren
id|offset
op_rshift
l_int|3
)paren
op_or
id|mf
op_or
id|df
suffix:semicolon
id|iph-&gt;id
op_assign
id|id
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mf
)paren
(brace
r_if
c_cond
(paren
id|offset
op_logical_or
op_logical_neg
id|df
)paren
(brace
multiline_comment|/* Select an unpredictable ident only&n;&t;&t;&t;&t;&t; * for packets without DF or having&n;&t;&t;&t;&t;&t; * been fragmented.&n;&t;&t;&t;&t;&t; */
id|__ip_select_ident
c_func
(paren
id|iph
comma
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
id|id
op_assign
id|iph-&gt;id
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Any further fragments will have MF set.&n;&t;&t;&t;&t; */
id|mf
op_assign
id|htons
c_func
(paren
id|IP_MF
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rt-&gt;rt_type
op_eq
id|RTN_MULTICAST
)paren
id|iph-&gt;ttl
op_assign
id|sk-&gt;protinfo.af_inet.mc_ttl
suffix:semicolon
r_else
id|iph-&gt;ttl
op_assign
id|sk-&gt;protinfo.af_inet.ttl
suffix:semicolon
id|iph-&gt;protocol
op_assign
id|sk-&gt;protocol
suffix:semicolon
id|iph-&gt;check
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|rt-&gt;rt_dst
suffix:semicolon
id|iph-&gt;check
op_assign
id|ip_fast_csum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|iph
comma
id|iph-&gt;ihl
)paren
suffix:semicolon
id|data
op_add_assign
id|iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;User data callback&n;&t;&t; */
r_if
c_cond
(paren
id|getfrag
c_func
(paren
id|frag
comma
id|data
comma
id|offset
comma
id|fraglen
op_minus
id|fragheaderlen
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|offset
op_sub_assign
(paren
id|maxfraglen
op_minus
id|fragheaderlen
)paren
suffix:semicolon
id|fraglen
op_assign
id|maxfraglen
suffix:semicolon
id|nfrags
op_increment
suffix:semicolon
id|err
op_assign
id|NF_HOOK
c_func
(paren
id|PF_INET
comma
id|NF_IP_LOCAL_OUT
comma
id|skb
comma
l_int|NULL
comma
id|skb-&gt;dst-&gt;dev
comma
id|output_maybe_reroute
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_if
c_cond
(paren
id|err
OG
l_int|0
)paren
id|err
op_assign
id|sk-&gt;protinfo.af_inet.recverr
ques
c_cond
id|net_xmit_errno
c_func
(paren
id|err
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|error
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|offset
op_ge
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nfrags
OG
l_int|1
)paren
id|ip_statistics
(braket
id|smp_processor_id
c_func
(paren
)paren
op_star
l_int|2
op_plus
op_logical_neg
id|in_softirq
c_func
(paren
)paren
)braket
dot
id|IpFragCreates
op_add_assign
id|nfrags
suffix:semicolon
id|out
suffix:colon
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|IP_INC_STATS
c_func
(paren
id|IpOutDiscards
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nfrags
OG
l_int|1
)paren
id|ip_statistics
(braket
id|smp_processor_id
c_func
(paren
)paren
op_star
l_int|2
op_plus
op_logical_neg
id|in_softirq
c_func
(paren
)paren
)braket
dot
id|IpFragCreates
op_add_assign
id|nfrags
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Fast path for unfragmented packets.&n; */
DECL|function|ip_build_xmit
r_int
id|ip_build_xmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|getfrag
(paren
r_const
r_void
op_star
comma
r_char
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
comma
r_const
r_void
op_star
id|frag
comma
r_int
id|length
comma
r_struct
id|ipcm_cookie
op_star
id|ipc
comma
r_struct
id|rtable
op_star
id|rt
comma
r_int
id|flags
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|df
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Try the simple case first. This leaves fragmented frames, and by&n;&t; *&t;choice RAW frames within 20 bytes of maximum size(rare) to the long path&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;protinfo.af_inet.hdrincl
)paren
(brace
id|length
op_add_assign
r_sizeof
(paren
r_struct
id|iphdr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * &t;Check for slow path.&n;&t;&t; */
r_if
c_cond
(paren
id|length
OG
id|rt-&gt;u.dst.pmtu
op_logical_or
id|ipc-&gt;opt
op_ne
l_int|NULL
)paren
r_return
id|ip_build_xmit_slow
c_func
(paren
id|sk
comma
id|getfrag
comma
id|frag
comma
id|length
comma
id|ipc
comma
id|rt
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|length
OG
id|rt-&gt;u.dst.dev-&gt;mtu
)paren
(brace
id|ip_local_error
c_func
(paren
id|sk
comma
id|EMSGSIZE
comma
id|rt-&gt;rt_dst
comma
id|sk-&gt;dport
comma
id|rt-&gt;u.dst.dev-&gt;mtu
)paren
suffix:semicolon
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PROBE
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Do path mtu discovery if needed.&n;&t; */
id|df
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ip_dont_fragment
c_func
(paren
id|sk
comma
op_amp
id|rt-&gt;u.dst
)paren
)paren
id|df
op_assign
id|htons
c_func
(paren
id|IP_DF
)paren
suffix:semicolon
multiline_comment|/* &n;&t; *&t;Fast path for unfragmented frames without options. &n;&t; */
(brace
r_int
id|hh_len
op_assign
(paren
id|rt-&gt;u.dst.dev-&gt;hard_header_len
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
suffix:semicolon
id|skb
op_assign
id|sock_alloc_send_skb
c_func
(paren
id|sk
comma
id|length
op_plus
id|hh_len
op_plus
l_int|15
comma
l_int|0
comma
id|flags
op_amp
id|MSG_DONTWAIT
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
id|hh_len
)paren
suffix:semicolon
)brace
id|skb-&gt;priority
op_assign
id|sk-&gt;priority
suffix:semicolon
id|skb-&gt;dst
op_assign
id|dst_clone
c_func
(paren
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
id|skb-&gt;nh.iph
op_assign
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;protinfo.af_inet.hdrincl
)paren
(brace
id|iph-&gt;version
op_assign
l_int|4
suffix:semicolon
id|iph-&gt;ihl
op_assign
l_int|5
suffix:semicolon
id|iph-&gt;tos
op_assign
id|sk-&gt;protinfo.af_inet.tos
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|length
)paren
suffix:semicolon
id|iph-&gt;frag_off
op_assign
id|df
suffix:semicolon
id|iph-&gt;ttl
op_assign
id|sk-&gt;protinfo.af_inet.mc_ttl
suffix:semicolon
id|ip_select_ident
c_func
(paren
id|iph
comma
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt-&gt;rt_type
op_ne
id|RTN_MULTICAST
)paren
id|iph-&gt;ttl
op_assign
id|sk-&gt;protinfo.af_inet.ttl
suffix:semicolon
id|iph-&gt;protocol
op_assign
id|sk-&gt;protocol
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|rt-&gt;rt_dst
suffix:semicolon
id|iph-&gt;check
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;check
op_assign
id|ip_fast_csum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|iph
comma
id|iph-&gt;ihl
)paren
suffix:semicolon
id|err
op_assign
id|getfrag
c_func
(paren
id|frag
comma
(paren
(paren
r_char
op_star
)paren
id|iph
)paren
op_plus
id|iph-&gt;ihl
op_star
l_int|4
comma
l_int|0
comma
id|length
op_minus
id|iph-&gt;ihl
op_star
l_int|4
)paren
suffix:semicolon
)brace
r_else
id|err
op_assign
id|getfrag
c_func
(paren
id|frag
comma
(paren
r_void
op_star
)paren
id|iph
comma
l_int|0
comma
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|error_fault
suffix:semicolon
id|err
op_assign
id|NF_HOOK
c_func
(paren
id|PF_INET
comma
id|NF_IP_LOCAL_OUT
comma
id|skb
comma
l_int|NULL
comma
id|rt-&gt;u.dst.dev
comma
id|output_maybe_reroute
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OG
l_int|0
)paren
id|err
op_assign
id|sk-&gt;protinfo.af_inet.recverr
ques
c_cond
id|net_xmit_errno
c_func
(paren
id|err
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|error
suffix:semicolon
id|out
suffix:colon
r_return
l_int|0
suffix:semicolon
id|error_fault
suffix:colon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|error
suffix:colon
id|IP_INC_STATS
c_func
(paren
id|IpOutDiscards
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This IP datagram is too large to be sent in one piece.  Break it up into&n; *&t;smaller pieces (each of size equal to IP header plus&n; *&t;a block of the data of the original IP data part) that will yet fit in a&n; *&t;single device frame, and queue such a frame for sending.&n; *&n; *&t;Yes this is inefficient, feel free to submit a quicker one.&n; */
DECL|function|ip_fragment
r_int
id|ip_fragment
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
(paren
op_star
id|output
)paren
(paren
r_struct
id|sk_buff
op_star
)paren
)paren
(brace
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_int
r_char
op_star
id|raw
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_int
r_int
id|mtu
comma
id|hlen
comma
id|left
comma
id|len
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|not_last_frag
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|dev
op_assign
id|rt-&gt;u.dst.dev
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Point into the IP datagram header.&n;&t; */
id|raw
op_assign
id|skb-&gt;nh.raw
suffix:semicolon
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|raw
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Setup starting values.&n;&t; */
id|hlen
op_assign
id|iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
id|left
op_assign
id|ntohs
c_func
(paren
id|iph-&gt;tot_len
)paren
op_minus
id|hlen
suffix:semicolon
multiline_comment|/* Space per frame */
id|mtu
op_assign
id|rt-&gt;u.dst.pmtu
op_minus
id|hlen
suffix:semicolon
multiline_comment|/* Size of data space */
id|ptr
op_assign
id|raw
op_plus
id|hlen
suffix:semicolon
multiline_comment|/* Where to start from */
multiline_comment|/*&n;&t; *&t;Fragment the datagram.&n;&t; */
id|offset
op_assign
(paren
id|ntohs
c_func
(paren
id|iph-&gt;frag_off
)paren
op_amp
id|IP_OFFSET
)paren
op_lshift
l_int|3
suffix:semicolon
id|not_last_frag
op_assign
id|iph-&gt;frag_off
op_amp
id|htons
c_func
(paren
id|IP_MF
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Keep copying data until we run out.&n;&t; */
r_while
c_loop
(paren
id|left
OG
l_int|0
)paren
(brace
id|len
op_assign
id|left
suffix:semicolon
multiline_comment|/* IF: it doesn&squot;t fit, use &squot;mtu&squot; - the data space left */
r_if
c_cond
(paren
id|len
OG
id|mtu
)paren
id|len
op_assign
id|mtu
suffix:semicolon
multiline_comment|/* IF: we are not sending upto and including the packet end&n;&t;&t;   then align the next start on an eight byte boundary */
r_if
c_cond
(paren
id|len
OL
id|left
)paren
(brace
id|len
op_and_assign
op_complement
l_int|7
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Allocate buffer.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|skb2
op_assign
id|alloc_skb
c_func
(paren
id|len
op_plus
id|hlen
op_plus
id|dev-&gt;hard_header_len
op_plus
l_int|15
comma
id|GFP_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|NETDEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;IP: frag: no memory for new fragment!&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Set up data on packet&n;&t;&t; */
id|skb2-&gt;pkt_type
op_assign
id|skb-&gt;pkt_type
suffix:semicolon
id|skb2-&gt;priority
op_assign
id|skb-&gt;priority
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb2
comma
(paren
id|dev-&gt;hard_header_len
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
)paren
suffix:semicolon
id|skb_put
c_func
(paren
id|skb2
comma
id|len
op_plus
id|hlen
)paren
suffix:semicolon
id|skb2-&gt;nh.raw
op_assign
id|skb2-&gt;data
suffix:semicolon
id|skb2-&gt;h.raw
op_assign
id|skb2-&gt;data
op_plus
id|hlen
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Charge the memory for the fragment to any owner&n;&t;&t; *&t;it might possess&n;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;sk
)paren
id|skb_set_owner_w
c_func
(paren
id|skb2
comma
id|skb-&gt;sk
)paren
suffix:semicolon
id|skb2-&gt;dst
op_assign
id|dst_clone
c_func
(paren
id|skb-&gt;dst
)paren
suffix:semicolon
id|skb2-&gt;dev
op_assign
id|skb-&gt;dev
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Copy the packet header into the new buffer.&n;&t;&t; */
id|memcpy
c_func
(paren
id|skb2-&gt;nh.raw
comma
id|raw
comma
id|hlen
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Copy a block of the IP datagram.&n;&t;&t; */
id|memcpy
c_func
(paren
id|skb2-&gt;h.raw
comma
id|ptr
comma
id|len
)paren
suffix:semicolon
id|left
op_sub_assign
id|len
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Fill in the new header fields.&n;&t;&t; */
id|iph
op_assign
id|skb2-&gt;nh.iph
suffix:semicolon
id|iph-&gt;frag_off
op_assign
id|htons
c_func
(paren
(paren
id|offset
op_rshift
l_int|3
)paren
)paren
suffix:semicolon
multiline_comment|/* ANK: dirty, but effective trick. Upgrade options only if&n;&t;&t; * the segment to be fragmented was THE FIRST (otherwise,&n;&t;&t; * options are already fixed) and make it ONCE&n;&t;&t; * on the initial skb, so that all the following fragments&n;&t;&t; * will inherit fixed options.&n;&t;&t; */
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
)paren
id|ip_options_fragment
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Added AC : If we are fragmenting a fragment that&squot;s not the&n;&t;&t; *&t;&t;   last fragment then keep MF on each bit&n;&t;&t; */
r_if
c_cond
(paren
id|left
OG
l_int|0
op_logical_or
id|not_last_frag
)paren
id|iph-&gt;frag_off
op_or_assign
id|htons
c_func
(paren
id|IP_MF
)paren
suffix:semicolon
id|ptr
op_add_assign
id|len
suffix:semicolon
id|offset
op_add_assign
id|len
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER
multiline_comment|/* Connection association is same as pre-frag packet */
id|skb2-&gt;nfct
op_assign
id|skb-&gt;nfct
suffix:semicolon
id|nf_conntrack_get
c_func
(paren
id|skb2-&gt;nfct
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
id|skb2-&gt;nf_debug
op_assign
id|skb-&gt;nf_debug
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n;&t;&t; *&t;Put this fragment into the sending queue.&n;&t;&t; */
id|IP_INC_STATS
c_func
(paren
id|IpFragCreates
)paren
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|htons
c_func
(paren
id|len
op_plus
id|hlen
)paren
suffix:semicolon
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
id|err
op_assign
id|output
c_func
(paren
id|skb2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|fail
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|IP_INC_STATS
c_func
(paren
id|IpFragOKs
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|fail
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|IP_INC_STATS
c_func
(paren
id|IpFragFails
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Fetch data from kernel space and fill in checksum if needed.&n; */
DECL|function|ip_reply_glue_bits
r_static
r_int
id|ip_reply_glue_bits
c_func
(paren
r_const
r_void
op_star
id|dptr
comma
r_char
op_star
id|to
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|fraglen
)paren
(brace
r_struct
id|ip_reply_arg
op_star
id|dp
op_assign
(paren
r_struct
id|ip_reply_arg
op_star
)paren
id|dptr
suffix:semicolon
id|u16
op_star
id|pktp
op_assign
(paren
id|u16
op_star
)paren
id|to
suffix:semicolon
r_struct
id|iovec
op_star
id|iov
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|hdrflag
op_assign
l_int|1
suffix:semicolon
id|iov
op_assign
op_amp
id|dp-&gt;iov
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|iov-&gt;iov_len
)paren
(brace
id|offset
op_sub_assign
id|iov-&gt;iov_len
suffix:semicolon
id|iov
op_increment
suffix:semicolon
id|hdrflag
op_assign
l_int|0
suffix:semicolon
)brace
id|len
op_assign
id|iov-&gt;iov_len
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|fraglen
OG
id|len
)paren
(brace
multiline_comment|/* overlapping. */
id|dp-&gt;csum
op_assign
id|csum_partial_copy_nocheck
c_func
(paren
id|iov-&gt;iov_base
op_plus
id|offset
comma
id|to
comma
id|len
comma
id|dp-&gt;csum
)paren
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|fraglen
op_sub_assign
id|len
suffix:semicolon
id|to
op_add_assign
id|len
suffix:semicolon
id|iov
op_increment
suffix:semicolon
)brace
id|dp-&gt;csum
op_assign
id|csum_partial_copy_nocheck
c_func
(paren
id|iov-&gt;iov_base
op_plus
id|offset
comma
id|to
comma
id|fraglen
comma
id|dp-&gt;csum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hdrflag
op_logical_and
id|dp-&gt;csumoffset
)paren
op_star
(paren
id|pktp
op_plus
id|dp-&gt;csumoffset
)paren
op_assign
id|csum_fold
c_func
(paren
id|dp-&gt;csum
)paren
suffix:semicolon
multiline_comment|/* fill in checksum */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Generic function to send a packet as reply to another packet.&n; *&t;Used to send TCP resets so far. ICMP should use this function too.&n; *&n; *&t;Should run single threaded per socket because it uses the sock &n; *     &t;structure to pass arguments.&n; */
DECL|function|ip_send_reply
r_void
id|ip_send_reply
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|ip_reply_arg
op_star
id|arg
comma
r_int
r_int
id|len
)paren
(brace
r_struct
(brace
r_struct
id|ip_options
id|opt
suffix:semicolon
r_char
id|data
(braket
l_int|40
)braket
suffix:semicolon
)brace
id|replyopts
suffix:semicolon
r_struct
id|ipcm_cookie
id|ipc
suffix:semicolon
id|u32
id|daddr
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|skb-&gt;dst
suffix:semicolon
r_if
c_cond
(paren
id|ip_options_echo
c_func
(paren
op_amp
id|replyopts.opt
comma
id|skb
)paren
)paren
r_return
suffix:semicolon
id|daddr
op_assign
id|ipc.addr
op_assign
id|rt-&gt;rt_src
suffix:semicolon
id|ipc.opt
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|replyopts.opt.optlen
)paren
(brace
id|ipc.opt
op_assign
op_amp
id|replyopts.opt
suffix:semicolon
r_if
c_cond
(paren
id|ipc.opt-&gt;srr
)paren
id|daddr
op_assign
id|replyopts.opt.faddr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip_route_output
c_func
(paren
op_amp
id|rt
comma
id|daddr
comma
id|rt-&gt;rt_spec_dst
comma
id|RT_TOS
c_func
(paren
id|skb-&gt;nh.iph-&gt;tos
)paren
comma
l_int|0
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* And let IP do all the hard work.&n;&n;&t;   This chunk is not reenterable, hence spinlock.&n;&t;   Note that it uses the fact, that this function is called&n;&t;   with locally disabled BH and that sk cannot be already spinlocked.&n;&t; */
id|bh_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;protinfo.af_inet.tos
op_assign
id|skb-&gt;nh.iph-&gt;tos
suffix:semicolon
id|sk-&gt;priority
op_assign
id|skb-&gt;priority
suffix:semicolon
id|sk-&gt;protocol
op_assign
id|skb-&gt;nh.iph-&gt;protocol
suffix:semicolon
id|ip_build_xmit
c_func
(paren
id|sk
comma
id|ip_reply_glue_bits
comma
id|arg
comma
id|len
comma
op_amp
id|ipc
comma
id|rt
comma
id|MSG_DONTWAIT
)paren
suffix:semicolon
id|bh_unlock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;IP protocol layer initialiser&n; */
DECL|variable|ip_packet_type
r_static
r_struct
id|packet_type
id|ip_packet_type
op_assign
(brace
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
comma
l_int|NULL
comma
multiline_comment|/* All devices */
id|ip_rcv
comma
(paren
r_void
op_star
)paren
l_int|1
comma
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;IP registers the packet type and then calls the subprotocol initialisers&n; */
DECL|function|ip_init
r_void
id|__init
id|ip_init
c_func
(paren
r_void
)paren
(brace
id|dev_add_pack
c_func
(paren
op_amp
id|ip_packet_type
)paren
suffix:semicolon
id|ip_rt_init
c_func
(paren
)paren
suffix:semicolon
id|inet_initpeers
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IP_MULTICAST
id|proc_net_create
c_func
(paren
l_string|&quot;igmp&quot;
comma
l_int|0
comma
id|ip_mc_procinfo
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
