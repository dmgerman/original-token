multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Implementation of the Transmission Control Protocol(TCP).&n; *&n; * Version:&t;$Id: tcp_output.c,v 1.63 1998/03/13 14:15:55 davem Exp $&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;&n; *&t;&t;Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; */
multiline_comment|/*&n; * Changes:&t;Pedro Roque&t;:&t;Retransmit queue handled by TCP.&n; *&t;&t;&t;&t;:&t;Fragmentation on mtu decrease&n; *&t;&t;&t;&t;:&t;Segment collapse on retransmit&n; *&t;&t;&t;&t;:&t;AF independence&n; *&n; *&t;&t;Linus Torvalds&t;:&t;send_delayed_ack&n; *&t;&t;David S. Miller&t;:&t;Charge memory using the right skb&n; *&t;&t;&t;&t;&t;during syn/ack processing.&n; *&n; */
macro_line|#include &lt;net/tcp.h&gt;
r_extern
r_int
id|sysctl_tcp_timestamps
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_window_scaling
suffix:semicolon
multiline_comment|/* Get rid of any delayed acks, we sent one already.. */
DECL|function|clear_delayed_acks
r_static
id|__inline__
r_void
id|clear_delayed_acks
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|tp-&gt;delayed_acks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tcp_in_quickack_mode
c_func
(paren
id|tp
)paren
)paren
(brace
id|tp-&gt;ato
op_assign
(paren
(paren
id|HZ
op_div
l_int|100
)paren
op_star
l_int|2
)paren
suffix:semicolon
)brace
id|tcp_clear_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_DACK
)paren
suffix:semicolon
)brace
DECL|function|update_send_head
r_static
id|__inline__
r_void
id|update_send_head
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
id|tp-&gt;send_head
op_assign
id|tp-&gt;send_head-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;send_head
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
id|tp-&gt;send_head
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is the main buffer sending routine. We queue the buffer&n; *&t;having checked it is sane seeming.&n; */
DECL|function|tcp_send_skb
r_void
id|tcp_send_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|force_queue
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/* Length of packet (not counting length of pre-tcp headers). */
id|size
op_assign
id|skb-&gt;len
op_minus
(paren
(paren
r_int
r_char
op_star
)paren
id|th
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/* If there is a FIN or a SYN we add it onto the size. */
r_if
c_cond
(paren
id|th-&gt;fin
op_logical_or
id|th-&gt;syn
)paren
(brace
r_if
c_cond
(paren
id|th-&gt;syn
)paren
(brace
id|size
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;fin
)paren
(brace
id|size
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Actual processing. */
id|skb-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
suffix:semicolon
id|skb-&gt;end_seq
op_assign
id|skb-&gt;seq
op_plus
id|size
op_minus
l_int|4
op_star
id|th-&gt;doff
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|force_queue
op_logical_and
id|tp-&gt;send_head
op_eq
l_int|NULL
op_logical_and
id|tcp_snd_test
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
multiline_comment|/* This is going straight out. */
id|tp-&gt;last_ack_sent
op_assign
id|tp-&gt;rcv_nxt
suffix:semicolon
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|tp-&gt;rcv_nxt
)paren
suffix:semicolon
id|th-&gt;window
op_assign
id|htons
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|tcp_update_options
c_func
(paren
(paren
id|__u32
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
comma
id|tp
)paren
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|send_check
c_func
(paren
id|sk
comma
id|th
comma
id|size
comma
id|skb
)paren
suffix:semicolon
id|buff
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_goto
id|queue
suffix:semicolon
id|clear_delayed_acks
c_func
(paren
id|sk
)paren
suffix:semicolon
id|skb_set_owner_w
c_func
(paren
id|buff
comma
id|sk
)paren
suffix:semicolon
id|tp-&gt;snd_nxt
op_assign
id|skb-&gt;end_seq
suffix:semicolon
id|tp-&gt;packets_out
op_increment
suffix:semicolon
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|buff
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_timer_is_set
c_func
(paren
id|sk
comma
id|TIME_RETRANS
)paren
)paren
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|queue
suffix:colon
multiline_comment|/* Remember where we must start sending. */
r_if
c_cond
(paren
id|tp-&gt;send_head
op_eq
l_int|NULL
)paren
id|tp-&gt;send_head
op_assign
id|skb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|force_queue
op_logical_and
id|tp-&gt;packets_out
op_eq
l_int|0
op_logical_and
op_logical_neg
id|tp-&gt;pending
)paren
(brace
id|tp-&gt;pending
op_assign
id|TIME_PROBE0
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Function to create two new tcp segments.&n; *&t;Shrinks the given segment to the specified size and appends a new&n; *&t;segment with the rest of the packet to the list.&n; *&t;This won&squot;t be called frenquently, I hope... &n; */
DECL|function|tcp_fragment
r_static
r_int
id|tcp_fragment
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
id|u32
id|len
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
comma
op_star
id|nth
suffix:semicolon
r_int
id|nsize
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
multiline_comment|/* Size of new segment. */
id|nsize
op_assign
id|skb-&gt;tail
op_minus
(paren
(paren
r_int
r_char
op_star
)paren
(paren
id|th
)paren
op_plus
id|tp-&gt;tcp_header_len
)paren
op_minus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|nsize
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tcp_fragment: bug size &lt;= 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Get a new skb... force flag on. */
id|buff
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|nsize
op_plus
l_int|128
op_plus
id|sk-&gt;prot-&gt;max_header
op_plus
l_int|15
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Put headers on the new packet. */
id|tmp
op_assign
id|tp-&gt;af_specific
op_member_access_from_pointer
id|build_net_header
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|buff
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Move the TCP header over. */
id|nth
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
id|tp-&gt;tcp_header_len
)paren
suffix:semicolon
id|buff-&gt;h.th
op_assign
id|nth
suffix:semicolon
id|memcpy
c_func
(paren
id|nth
comma
id|th
comma
id|tp-&gt;tcp_header_len
)paren
suffix:semicolon
multiline_comment|/* Correct the new header. */
id|buff-&gt;seq
op_assign
id|skb-&gt;seq
op_plus
id|len
suffix:semicolon
id|buff-&gt;end_seq
op_assign
id|skb-&gt;end_seq
suffix:semicolon
id|nth-&gt;seq
op_assign
id|htonl
c_func
(paren
id|buff-&gt;seq
)paren
suffix:semicolon
id|nth-&gt;check
op_assign
l_int|0
suffix:semicolon
id|nth-&gt;doff
op_assign
id|th-&gt;doff
suffix:semicolon
multiline_comment|/* urg data is always an headache */
r_if
c_cond
(paren
id|th-&gt;urg
)paren
(brace
r_if
c_cond
(paren
id|th-&gt;urg_ptr
OG
id|len
)paren
(brace
id|th-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|nth-&gt;urg_ptr
op_sub_assign
id|len
suffix:semicolon
)brace
r_else
(brace
id|nth-&gt;urg
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Copy data tail to our new buffer. */
id|buff-&gt;csum
op_assign
id|csum_partial_copy
c_func
(paren
(paren
(paren
id|u8
op_star
)paren
(paren
id|th
)paren
op_plus
id|tp-&gt;tcp_header_len
)paren
op_plus
id|len
comma
id|skb_put
c_func
(paren
id|buff
comma
id|nsize
)paren
comma
id|nsize
comma
l_int|0
)paren
suffix:semicolon
id|skb-&gt;end_seq
op_sub_assign
id|nsize
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
id|skb-&gt;len
op_minus
id|nsize
)paren
suffix:semicolon
multiline_comment|/* Remember to checksum this packet afterwards. */
id|th-&gt;check
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;csum
op_assign
id|csum_partial
c_func
(paren
(paren
id|u8
op_star
)paren
(paren
id|th
)paren
op_plus
id|tp-&gt;tcp_header_len
comma
id|skb-&gt;tail
op_minus
(paren
(paren
id|u8
op_star
)paren
(paren
id|th
)paren
op_plus
id|tp-&gt;tcp_header_len
)paren
comma
l_int|0
)paren
suffix:semicolon
id|skb_append
c_func
(paren
id|skb
comma
id|buff
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tcp_wrxmit_prob
r_static
r_void
id|tcp_wrxmit_prob
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/* This is acked data. We can discard it. This cannot currently occur. */
id|tp-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tcp_write_xmit: bug skb in write queue&bslash;n&quot;
)paren
suffix:semicolon
id|update_send_head
c_func
(paren
id|sk
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
DECL|function|tcp_wrxmit_frag
r_static
r_int
id|tcp_wrxmit_frag
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|size
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;tcp_write_xmit: frag needed size=%d mss=%d&bslash;n&quot;
comma
id|size
comma
id|sk-&gt;mss
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_fragment
c_func
(paren
id|sk
comma
id|skb
comma
id|sk-&gt;mss
)paren
)paren
(brace
multiline_comment|/* !tcp_frament Failed! */
id|tp-&gt;send_head
op_assign
id|skb
suffix:semicolon
id|tp-&gt;packets_out
op_decrement
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;This routine writes packets to the network.&n; *&t;It advances the send_head.&n; *&t;This happens as incoming acks open up the remote window for us.&n; */
DECL|function|tcp_write_xmit
r_void
id|tcp_write_xmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|u16
id|rcv_wnd
suffix:semicolon
r_int
id|sent_pkts
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The bytes will have to remain here. In time closedown will&n;&t; * empty the write queue and all will be happy.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&t;Anything on the transmit queue that fits the window can&n;&t; *&t;be added providing we are:&n;&t; *&n;&t; *&t;a) following SWS avoidance [and Nagle algorithm]&n;&t; *&t;b) not exceeding our congestion window.&n;&t; *&t;c) not retransmiting [Nagle]&n;&t; */
id|rcv_wnd
op_assign
id|htons
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|tp-&gt;send_head
)paren
op_logical_and
id|tcp_snd_test
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/* See if we really need to send the packet. (debugging code) */
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|skb-&gt;end_seq
comma
id|tp-&gt;snd_una
)paren
)paren
(brace
id|tcp_wrxmit_prob
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&t;Put in the ack seq and window at this point rather&n;&t;&t; *&t;than earlier, in order to keep them monotonic.&n;&t;&t; *&t;We really want to avoid taking back window allocations.&n;&t;&t; *&t;That&squot;s legal, but RFC1122 says it&squot;s frowned on.&n;&t;&t; *&t;Ack and window will in general have changed since&n;&t;&t; *&t;this packet was put on the write queue.&n;&t;&t; */
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
id|size
op_assign
id|skb-&gt;len
op_minus
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|th
)paren
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_minus
(paren
id|th-&gt;doff
op_lshift
l_int|2
)paren
OG
id|sk-&gt;mss
)paren
(brace
r_if
c_cond
(paren
id|tcp_wrxmit_frag
c_func
(paren
id|sk
comma
id|skb
comma
id|size
)paren
)paren
r_break
suffix:semicolon
id|size
op_assign
id|skb-&gt;len
op_minus
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|th
)paren
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
)brace
id|tp-&gt;last_ack_sent
op_assign
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|tp-&gt;rcv_nxt
)paren
suffix:semicolon
id|th-&gt;window
op_assign
id|rcv_wnd
suffix:semicolon
id|tcp_update_options
c_func
(paren
(paren
id|__u32
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
comma
id|tp
)paren
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|send_check
c_func
(paren
id|sk
comma
id|th
comma
id|size
comma
id|skb
)paren
suffix:semicolon
macro_line|#ifdef TCP_DEBUG
r_if
c_cond
(paren
id|before
c_func
(paren
id|skb-&gt;end_seq
comma
id|tp-&gt;snd_nxt
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tcp_write_xmit:&quot;
l_string|&quot; sending already sent seq&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|buff
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
multiline_comment|/* Advance the send_head.  This one is going out. */
id|update_send_head
c_func
(paren
id|sk
)paren
suffix:semicolon
id|clear_delayed_acks
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;packets_out
op_increment
suffix:semicolon
id|skb_set_owner_w
c_func
(paren
id|buff
comma
id|sk
)paren
suffix:semicolon
id|tp-&gt;snd_nxt
op_assign
id|skb-&gt;end_seq
suffix:semicolon
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
id|sent_pkts
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|buff
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sent_pkts
op_logical_and
op_logical_neg
id|tcp_timer_is_set
c_func
(paren
id|sk
comma
id|TIME_RETRANS
)paren
)paren
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
multiline_comment|/* This function returns the amount that we can raise the&n; * usable window based on the following constraints&n; *  &n; * 1. The window can never be shrunk once it is offered (RFC 793)&n; * 2. We limit memory per socket&n; *&n; * RFC 1122:&n; * &quot;the suggested [SWS] avoidance algoritm for the receiver is to keep&n; *  RECV.NEXT + RCV.WIN fixed until:&n; *  RCV.BUFF - RCV.USER - RCV.WINDOW &gt;= min(1/2 RCV.BUFF, MSS)&quot;&n; *&n; * i.e. don&squot;t raise the right edge of the window until you can raise&n; * it at least MSS bytes.&n; *&n; * Unfortunately, the recomended algorithm breaks header prediction,&n; * since header prediction assumes th-&gt;window stays fixed.&n; *&n; * Strictly speaking, keeping th-&gt;window fixed violates the receiver&n; * side SWS prevention criteria. The problem is that under this rule&n; * a stream of single byte packets will cause the right side of the&n; * window to always advance by a single byte.&n; * &n; * Of course, if the sender implements sender side SWS prevention&n; * then this will not be a problem.&n; * &n; * BSD seems to make the following compromise:&n; * &n; *&t;If the free space is less than the 1/4 of the maximum&n; *&t;space available and the free space is less than 1/2 mss,&n; *&t;then set the window to 0.&n; *&t;Otherwise, just prevent the window from shrinking&n; *&t;and from being larger than the largest representable value.&n; *&n; * This prevents incremental opening of the window in the regime&n; * where TCP is limited by the speed of the reader side taking&n; * data out of the TCP receive queue. It does nothing about&n; * those cases where the window is constrained on the sender side&n; * because the pipeline is full.&n; *&n; * BSD also seems to &quot;accidentally&quot; limit itself to windows that are a&n; * multiple of MSS, at least until the free space gets quite small.&n; * This would appear to be a side effect of the mbuf implementation.&n; * Combining these two algorithms results in the observed behavior&n; * of having a fixed window size at almost all times.&n; *&n; * Below we obtain similar behavior by forcing the offered window to&n; * a multiple of the mss when it is feasible to do so.&n; *&n; * FIXME: In our current implementation the value returned by sock_rpsace(sk)&n; * is the total space we have allocated to the socket to store skbuf&squot;s.&n; * The current design assumes that up to half of that space will be&n; * taken by headers, and the remaining space will be available for TCP data.&n; * This should be accounted for correctly instead.&n; */
DECL|function|__tcp_select_window
id|u32
id|__tcp_select_window
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_int
r_int
id|mss
op_assign
id|sk-&gt;mss
suffix:semicolon
r_int
r_int
id|free_space
suffix:semicolon
id|u32
id|window
comma
id|cur_win
suffix:semicolon
id|free_space
op_assign
(paren
id|sk-&gt;rcvbuf
op_minus
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;window_clamp
)paren
(brace
id|free_space
op_assign
id|min
c_func
(paren
id|tp-&gt;window_clamp
comma
id|free_space
)paren
suffix:semicolon
id|mss
op_assign
id|min
c_func
(paren
id|tp-&gt;window_clamp
comma
id|mss
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;tcp_select_window: tp-&gt;window_clamp == 0.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mss
OL
l_int|1
)paren
(brace
id|mss
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;tcp_select_window: sk-&gt;mss fell to 0.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|cur_win
op_assign
id|tcp_receive_window
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free_space
OL
id|sk-&gt;rcvbuf
op_div
l_int|4
op_logical_and
id|free_space
OL
id|mss
op_div
l_int|2
)paren
(brace
id|window
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get the largest window that is a nice multiple of mss.&n;&t;&t; * Window clamp already applied above.&n;&t;&t; * If our current window offering is within 1 mss of the&n;&t;&t; * free space we just keep it. This prevents the divide&n;&t;&t; * and multiply from happening most of the time.&n;&t;&t; * We also don&squot;t do any window rounding when the free space&n;&t;&t; * is too small.&n;&t;&t; */
id|window
op_assign
id|tp-&gt;rcv_wnd
suffix:semicolon
r_if
c_cond
(paren
(paren
id|window
op_le
(paren
id|free_space
op_minus
id|mss
)paren
)paren
op_logical_or
(paren
id|window
OG
id|free_space
)paren
)paren
id|window
op_assign
(paren
id|free_space
op_div
id|mss
)paren
op_star
id|mss
suffix:semicolon
)brace
r_return
id|window
suffix:semicolon
)brace
DECL|function|tcp_retrans_try_collapse
r_static
r_int
id|tcp_retrans_try_collapse
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th1
comma
op_star
id|th2
suffix:semicolon
r_int
id|size1
comma
id|size2
comma
id|avail
suffix:semicolon
r_struct
id|sk_buff
op_star
id|buff
op_assign
id|skb-&gt;next
suffix:semicolon
id|th1
op_assign
id|skb-&gt;h.th
suffix:semicolon
r_if
c_cond
(paren
id|th1-&gt;urg
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|avail
op_assign
id|skb_tailroom
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Size of TCP payload. */
id|size1
op_assign
id|skb-&gt;tail
op_minus
(paren
(paren
id|u8
op_star
)paren
(paren
id|th1
)paren
op_plus
(paren
id|th1-&gt;doff
op_lshift
l_int|2
)paren
)paren
suffix:semicolon
id|th2
op_assign
id|buff-&gt;h.th
suffix:semicolon
id|size2
op_assign
id|buff-&gt;tail
op_minus
(paren
(paren
id|u8
op_star
)paren
(paren
id|th2
)paren
op_plus
(paren
id|th2-&gt;doff
op_lshift
l_int|2
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size2
OG
id|avail
op_logical_or
id|size1
op_plus
id|size2
OG
id|sk-&gt;mss
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Ok.  We will be able to collapse the packet. */
id|skb_unlink
c_func
(paren
id|buff
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|size2
)paren
comma
(paren
(paren
r_char
op_star
)paren
id|th2
)paren
op_plus
(paren
id|th2-&gt;doff
op_lshift
l_int|2
)paren
comma
id|size2
)paren
suffix:semicolon
multiline_comment|/* Update sizes on original skb, both TCP and IP. */
id|skb-&gt;end_seq
op_add_assign
id|buff-&gt;end_seq
op_minus
id|buff-&gt;seq
suffix:semicolon
r_if
c_cond
(paren
id|th2-&gt;urg
)paren
(brace
id|th1-&gt;urg
op_assign
l_int|1
suffix:semicolon
id|th1-&gt;urg_ptr
op_assign
id|th2-&gt;urg_ptr
op_plus
id|size1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th2-&gt;fin
)paren
id|th1-&gt;fin
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* ... and off you go. */
id|kfree_skb
c_func
(paren
id|buff
)paren
suffix:semicolon
id|tp-&gt;packets_out
op_decrement
suffix:semicolon
multiline_comment|/* Header checksum will be set by the retransmit procedure&n;&t; * after calling rebuild header.&n;&t; */
id|th1-&gt;check
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;csum
op_assign
id|csum_partial
c_func
(paren
(paren
id|u8
op_star
)paren
(paren
id|th1
)paren
op_plus
(paren
id|th1-&gt;doff
op_lshift
l_int|2
)paren
comma
id|size1
op_plus
id|size2
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Do a simple retransmit without using the backoff mechanisms in&n; * tcp_timer. This is used to speed up path mtu recovery. Note that&n; * these simple retransmit aren&squot;t counted in the usual tcp retransmit&n; * backoff counters. &n; * The socket is already locked here.&n; */
DECL|function|tcp_simple_retransmit
r_void
id|tcp_simple_retransmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/* Clear delay ack timer. */
id|tcp_clear_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_DACK
)paren
suffix:semicolon
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Don&squot;t muck with the congestion window here. */
id|tp-&gt;dup_acks
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;high_seq
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
multiline_comment|/* FIXME: make the current rtt sample invalid */
id|tcp_do_retransmit
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;A socket has timed out on its send queue and wants to do a&n; *&t;little retransmitting.&n; *&t;retrans_head can be different from the head of the write_queue&n; *&t;if we are doing fast retransmit.&n; */
DECL|function|tcp_do_retransmit
r_void
id|tcp_do_retransmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|all
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;retrans_head
op_eq
l_int|NULL
)paren
id|tp-&gt;retrans_head
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;retrans_head
op_eq
id|tp-&gt;send_head
)paren
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|tp-&gt;retrans_head
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_int
id|tcp_size
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/* In general it&squot;s OK just to use the old packet.  However we&n;&t;&t; * need to use the current ack and window fields.  Urg and&n;&t;&t; * urg_ptr could possibly stand to be updated as well, but we&n;&t;&t; * don&squot;t keep the necessary data.  That shouldn&squot;t be a problem,&n;&t;&t; * if the other end is doing the right thing.  Since we&squot;re&n;&t;&t; * changing the packet, we have to issue a new IP identifier.&n;&t;&t; */
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
id|tcp_size
op_assign
id|skb-&gt;tail
op_minus
(paren
(paren
r_int
r_char
op_star
)paren
(paren
id|th
)paren
op_plus
id|tp-&gt;tcp_header_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_size
OG
id|sk-&gt;mss
)paren
(brace
r_if
c_cond
(paren
id|tcp_fragment
c_func
(paren
id|sk
comma
id|skb
comma
id|sk-&gt;mss
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tcp_fragment failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|tp-&gt;packets_out
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;syn
op_logical_and
id|tcp_size
OL
(paren
id|sk-&gt;mss
op_rshift
l_int|1
)paren
op_logical_and
id|skb-&gt;next
op_ne
id|tp-&gt;send_head
op_logical_and
id|skb-&gt;next
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
id|tcp_retrans_try_collapse
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;af_specific
op_member_access_from_pointer
id|rebuild_header
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
(brace
macro_line|#ifdef TCP_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tcp_do_rebuild_header failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;retransmit sending seq=%x&bslash;n&quot;
comma
id|skb-&gt;seq
)paren
suffix:semicolon
multiline_comment|/* Update ack and window. */
id|tp-&gt;last_ack_sent
op_assign
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|tp-&gt;rcv_nxt
)paren
suffix:semicolon
id|th-&gt;window
op_assign
id|ntohs
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|tcp_update_options
c_func
(paren
(paren
id|__u32
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
comma
id|tp
)paren
suffix:semicolon
id|size
op_assign
id|skb-&gt;tail
op_minus
(paren
r_int
r_char
op_star
)paren
id|th
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|send_check
c_func
(paren
id|sk
comma
id|th
comma
id|size
comma
id|skb
)paren
suffix:semicolon
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
id|buff
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|skb_set_owner_w
c_func
(paren
id|buff
comma
id|sk
)paren
suffix:semicolon
id|clear_delayed_acks
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|buff
)paren
suffix:semicolon
multiline_comment|/* Count retransmissions. */
id|ct
op_increment
suffix:semicolon
id|sk-&gt;prot-&gt;retransmits
op_increment
suffix:semicolon
id|tcp_statistics.TcpRetransSegs
op_increment
suffix:semicolon
multiline_comment|/* Only one retransmit requested. */
r_if
c_cond
(paren
op_logical_neg
id|all
)paren
r_break
suffix:semicolon
multiline_comment|/* This should cut it off before we send too many packets. */
r_if
c_cond
(paren
id|ct
op_ge
id|tp-&gt;snd_cwnd
)paren
r_break
suffix:semicolon
multiline_comment|/* Advance the pointer. */
id|tp-&gt;retrans_head
op_assign
id|skb-&gt;next
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;retrans_head
op_eq
id|tp-&gt;send_head
)paren
op_logical_or
(paren
id|tp-&gt;retrans_head
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* Send a fin.  The caller locks the socket for us.  This cannot be&n; * allowed to fail queueing a FIN frame under any circumstances.&n; */
DECL|function|tcp_send_fin
r_void
id|tcp_send_fin
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/* Optimization, tack on the FIN if we have a queue of&n;&t; * unsent frames.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;send_head
op_ne
l_int|NULL
)paren
(brace
r_struct
id|sk_buff
op_star
id|tail
op_assign
id|skb_peek_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
op_assign
id|tail-&gt;h.th
suffix:semicolon
r_int
id|data_len
suffix:semicolon
multiline_comment|/* Unfortunately tcp_write_xmit won&squot;t check for going over&n;&t;&t; * the MSS due to the FIN sequence number, so we have to&n;&t;&t; * watch out for it here.&n;&t;&t; */
id|data_len
op_assign
(paren
id|tail-&gt;tail
op_minus
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|th
)paren
op_plus
id|tp-&gt;tcp_header_len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_len
op_ge
id|sk-&gt;mss
)paren
(brace
r_goto
id|build_new_frame
suffix:semicolon
)brace
multiline_comment|/* ho hum... */
multiline_comment|/* tcp_write_xmit() will checksum the header etc. for us. */
id|th-&gt;fin
op_assign
l_int|1
suffix:semicolon
id|tail-&gt;end_seq
op_increment
suffix:semicolon
)brace
r_else
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
id|build_new_frame
suffix:colon
id|buff
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
(paren
id|BASE_ACK_SIZE
op_plus
id|tp-&gt;tcp_header_len
op_plus
r_sizeof
(paren
r_struct
id|sk_buff
)paren
)paren
comma
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* We can only fail due to low memory situations, not&n;&t;&t;&t; * due to going over our sndbuf limits (due to the&n;&t;&t;&t; * force flag passed to sock_wmalloc).  So just keep&n;&t;&t;&t; * trying.  We cannot allow this fail.  The socket is&n;&t;&t;&t; * still locked, so we need not check if the connection&n;&t;&t;&t; * was reset in the meantime etc.&n;&t;&t;&t; */
r_goto
id|build_new_frame
suffix:semicolon
)brace
multiline_comment|/* Administrivia. */
id|buff-&gt;csum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Put in the IP header and routing stuff.&n;&t;&t; *&n;&t;&t; * FIXME:&n;&t;&t; * We can fail if the interface for the route&n;&t;&t; * this socket takes goes down right before&n;&t;&t; * we get here.  ANK is there a way to point&n;&t;&t; * this into a &quot;black hole&quot; route in such a&n;&t;&t; * case?  Ideally, we should still be able to&n;&t;&t; * queue this and let the retransmit timer&n;&t;&t; * keep trying until the destination becomes&n;&t;&t; * reachable once more.  -DaveM&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;af_specific
op_member_access_from_pointer
id|build_net_header
c_func
(paren
id|sk
comma
id|buff
)paren
OL
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|buff
)paren
suffix:semicolon
r_goto
id|update_write_seq
suffix:semicolon
)brace
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
id|tp-&gt;tcp_header_len
)paren
suffix:semicolon
id|buff-&gt;h.th
op_assign
id|th
suffix:semicolon
id|memcpy
c_func
(paren
id|th
comma
(paren
r_void
op_star
)paren
op_amp
(paren
id|sk-&gt;dummy_th
)paren
comma
r_sizeof
(paren
op_star
id|th
)paren
)paren
suffix:semicolon
id|th-&gt;seq
op_assign
id|htonl
c_func
(paren
id|tp-&gt;write_seq
)paren
suffix:semicolon
id|th-&gt;fin
op_assign
l_int|1
suffix:semicolon
id|tcp_build_options
c_func
(paren
(paren
id|__u32
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
comma
id|tp
)paren
suffix:semicolon
multiline_comment|/* This makes sure we do things like abide by the congestion&n;&t;&t; * window and other constraints which prevent us from sending.&n;&t;&t; */
id|tcp_send_skb
c_func
(paren
id|sk
comma
id|buff
comma
l_int|0
)paren
suffix:semicolon
)brace
id|update_write_seq
suffix:colon
multiline_comment|/* So that we recognize the ACK coming back for&n;&t; * this FIN as being legitimate.&n;&t; */
id|tp-&gt;write_seq
op_increment
suffix:semicolon
)brace
multiline_comment|/* WARNING: This routine must only be called when we have already sent&n; * a SYN packet that crossed the incoming SYN that caused this routine&n; * to get called. If this assumption fails then the initial rcv_wnd&n; * and rcv_wscale values will not be correct.&n; *&n; * XXX When you have time Dave, redo this to use tcp_send_skb() just&n; * XXX like tcp_send_fin() above now does.... -DaveM&n; */
DECL|function|tcp_send_synack
r_int
id|tcp_send_synack
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|skb
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|MAX_SYN_SIZE
op_plus
r_sizeof
(paren
r_struct
id|sk_buff
)paren
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|tmp
op_assign
id|tp-&gt;af_specific
op_member_access_from_pointer
id|build_net_header
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|skb-&gt;h.th
op_assign
id|th
suffix:semicolon
id|memset
c_func
(paren
id|th
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|th-&gt;syn
op_assign
l_int|1
suffix:semicolon
id|th-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|th-&gt;source
op_assign
id|sk-&gt;dummy_th.source
suffix:semicolon
id|th-&gt;dest
op_assign
id|sk-&gt;dummy_th.dest
suffix:semicolon
id|skb-&gt;seq
op_assign
id|tp-&gt;snd_una
suffix:semicolon
id|skb-&gt;end_seq
op_assign
id|skb-&gt;seq
op_plus
l_int|1
multiline_comment|/* th-&gt;syn */
suffix:semicolon
id|th-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|skb-&gt;seq
)paren
suffix:semicolon
multiline_comment|/* This is a resend of a previous SYN, now with an ACK.&n;&t; * we must reuse the previously offered window.&n;&t; */
id|th-&gt;window
op_assign
id|htons
c_func
(paren
id|tp-&gt;rcv_wnd
)paren
suffix:semicolon
id|tp-&gt;last_ack_sent
op_assign
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|tp-&gt;rcv_nxt
)paren
suffix:semicolon
id|tmp
op_assign
id|tcp_syn_build_options
c_func
(paren
id|skb
comma
id|sk-&gt;mss
comma
id|tp-&gt;tstamp_ok
comma
id|tp-&gt;wscale_ok
comma
id|tp-&gt;rcv_wscale
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|th-&gt;doff
op_assign
(paren
r_sizeof
(paren
op_star
id|th
)paren
op_plus
id|tmp
)paren
op_rshift
l_int|2
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|send_check
c_func
(paren
id|sk
comma
id|th
comma
r_sizeof
(paren
op_star
id|th
)paren
op_plus
id|tmp
comma
id|skb
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
id|buff
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
)paren
(brace
id|skb_set_owner_w
c_func
(paren
id|buff
comma
id|sk
)paren
suffix:semicolon
id|tp-&gt;packets_out
op_increment
suffix:semicolon
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|buff
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|TCP_TIMEOUT_INIT
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Send out a delayed ack, the caller does the policy checking&n; * to see if we should even be here.  See tcp_input.c:tcp_ack_snd_check()&n; * for details.&n; */
DECL|function|tcp_send_delayed_ack
r_void
id|tcp_send_delayed_ack
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_int
id|max_timeout
)paren
(brace
r_int
r_int
id|timeout
suffix:semicolon
multiline_comment|/* Stay within the limit we were given */
id|timeout
op_assign
id|tp-&gt;ato
suffix:semicolon
r_if
c_cond
(paren
id|timeout
OG
id|max_timeout
)paren
id|timeout
op_assign
id|max_timeout
suffix:semicolon
id|timeout
op_add_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Use new timeout only if there wasn&squot;t a older one earlier. */
r_if
c_cond
(paren
(paren
op_logical_neg
id|tp-&gt;delack_timer.prev
op_logical_or
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;delack_timer
)paren
)paren
op_logical_or
(paren
id|timeout
OL
id|tp-&gt;delack_timer.expires
)paren
)paren
id|tp-&gt;delack_timer.expires
op_assign
id|timeout
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|tp-&gt;delack_timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine sends an ack and also updates the window. &n; */
DECL|function|tcp_send_ack
r_void
id|tcp_send_ack
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* We have been reset, we may not send again. */
multiline_comment|/* We need to grab some memory, and put together an ack,&n;&t; * and then put it into the queue to be sent.&n;&t; */
id|buff
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|BASE_ACK_SIZE
op_plus
id|tp-&gt;tcp_header_len
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&t;Force it to send an ack. We don&squot;t have to do this&n;&t;&t; *&t;(ACK is unreliable) but it&squot;s much better use of&n;&t;&t; *&t;bandwidth on slow links to send a spare ack than&n;&t;&t; *&t;resend packets.&n;&t;&t; */
id|tcp_send_delayed_ack
c_func
(paren
id|tp
comma
id|HZ
op_div
l_int|2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|clear_delayed_acks
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Assemble a suitable TCP frame. */
id|buff-&gt;csum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Put in the IP header and routing stuff. */
id|tmp
op_assign
id|tp-&gt;af_specific
op_member_access_from_pointer
id|build_net_header
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|buff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
id|tp-&gt;tcp_header_len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|th
comma
op_amp
id|sk-&gt;dummy_th
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
multiline_comment|/* Swap the send and the receive. */
id|th-&gt;window
op_assign
id|ntohs
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|th-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|tp-&gt;snd_nxt
)paren
suffix:semicolon
id|tp-&gt;last_ack_sent
op_assign
id|tp-&gt;rcv_nxt
suffix:semicolon
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|tp-&gt;rcv_nxt
)paren
suffix:semicolon
id|tcp_build_and_update_options
c_func
(paren
(paren
id|__u32
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
comma
id|tp
)paren
suffix:semicolon
multiline_comment|/* Fill in the packet and send it. */
id|tp-&gt;af_specific
op_member_access_from_pointer
id|send_check
c_func
(paren
id|sk
comma
id|th
comma
id|tp-&gt;tcp_header_len
comma
id|buff
)paren
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|buff
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine sends a packet with an out of date sequence&n; *&t;number. It assumes the other end will try to ack it.&n; */
DECL|function|tcp_write_wakeup
r_void
id|tcp_write_wakeup
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
comma
op_star
id|skb
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
r_return
suffix:semicolon
multiline_comment|/* After a valid reset we can send no more. */
multiline_comment|/*&t;Write data can still be transmitted/retransmitted in the&n;&t; *&t;following states.  If any other state is encountered, return.&n;&t; *&t;[listen/close will never occur here anyway]&n;&t; */
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|sk-&gt;state
)paren
op_amp
op_complement
(paren
id|TCPF_ESTABLISHED
op_or
id|TCPF_CLOSE_WAIT
op_or
id|TCPF_FIN_WAIT1
op_or
id|TCPF_LAST_ACK
op_or
id|TCPF_CLOSING
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|before
c_func
(paren
id|tp-&gt;snd_nxt
comma
id|tp-&gt;snd_una
op_plus
id|tp-&gt;snd_wnd
)paren
op_logical_and
(paren
id|skb
op_assign
id|tp-&gt;send_head
)paren
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_int
r_int
id|win_size
suffix:semicolon
multiline_comment|/* We are probing the opening of a window&n;&t;    &t; * but the window size is != 0&n;&t;    &t; * must have been a result SWS avoidance ( sender )&n;&t;    &t; */
id|win_size
op_assign
id|tp-&gt;snd_wnd
op_minus
(paren
id|tp-&gt;snd_nxt
op_minus
id|tp-&gt;snd_una
)paren
suffix:semicolon
r_if
c_cond
(paren
id|win_size
OL
id|skb-&gt;end_seq
op_minus
id|skb-&gt;seq
)paren
(brace
r_if
c_cond
(paren
id|tcp_fragment
c_func
(paren
id|sk
comma
id|skb
comma
id|win_size
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tcp_write_wakeup: &quot;
l_string|&quot;fragment failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
id|tcp_update_options
c_func
(paren
(paren
id|__u32
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
comma
id|tp
)paren
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|send_check
c_func
(paren
id|sk
comma
id|th
comma
id|th-&gt;doff
op_star
l_int|4
op_plus
id|win_size
comma
id|skb
)paren
suffix:semicolon
id|buff
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|skb_set_owner_w
c_func
(paren
id|buff
comma
id|sk
)paren
suffix:semicolon
id|tp-&gt;packets_out
op_increment
suffix:semicolon
id|clear_delayed_acks
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_timer_is_set
c_func
(paren
id|sk
comma
id|TIME_RETRANS
)paren
)paren
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
id|update_send_head
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;snd_nxt
op_assign
id|skb-&gt;end_seq
suffix:semicolon
)brace
r_else
(brace
id|buff
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|MAX_ACK_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|buff-&gt;csum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Put in the IP header and routing stuff. */
id|tmp
op_assign
id|tp-&gt;af_specific
op_member_access_from_pointer
id|build_net_header
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|buff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
id|tp-&gt;tcp_header_len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
(paren
r_void
op_star
)paren
op_amp
id|sk-&gt;dummy_th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
multiline_comment|/*&t;Use a previous sequence.&n;&t;&t; *&t;This should cause the other end to send an ack.&n;&t;&t; */
id|t1-&gt;seq
op_assign
id|htonl
c_func
(paren
id|tp-&gt;snd_nxt
op_minus
l_int|1
)paren
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|tp-&gt;rcv_nxt
)paren
suffix:semicolon
id|t1-&gt;window
op_assign
id|htons
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|tcp_build_and_update_options
c_func
(paren
(paren
id|__u32
op_star
)paren
(paren
id|t1
op_plus
l_int|1
)paren
comma
id|tp
)paren
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|send_check
c_func
(paren
id|sk
comma
id|t1
comma
id|tp-&gt;tcp_header_len
comma
id|buff
)paren
suffix:semicolon
)brace
multiline_comment|/* Send it. */
id|tp-&gt;af_specific
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|buff
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;A window probe timeout has occurred.&n; *&t;If window is not closed send a partial packet&n; *&t;else a zero probe.&n; */
DECL|function|tcp_send_probe0
r_void
id|tcp_send_probe0
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|tcp_write_wakeup
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;pending
op_assign
id|TIME_PROBE0
suffix:semicolon
id|tp-&gt;backoff
op_increment
suffix:semicolon
id|tp-&gt;probes_out
op_increment
suffix:semicolon
id|tcp_reset_xmit_timer
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|min
c_func
(paren
id|tp-&gt;rto
op_lshift
id|tp-&gt;backoff
comma
l_int|120
op_star
id|HZ
)paren
)paren
suffix:semicolon
)brace
eof
