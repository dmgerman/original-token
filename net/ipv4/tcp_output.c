multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Implementation of the Transmission Control Protocol(TCP).&n; *&n; * Version:&t;@(#)tcp_input.c&t;1.0.16&t;05/25/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;&n; *&t;&t;Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; */
multiline_comment|/*&n; * Changes:&t;Pedro Roque&t;:&t;Retransmit queue handled by TCP.&n; *&t;&t;&t;&t;:&t;Fragmentation on mtu decrease&n; *&t;&t;&t;&t;:&t;Segment collapse on retransmit&n; *&t;&t;&t;&t;:&t;AF independence&n; *&n; *&t;&t;Linus Torvalds&t;:&t;send_delayed_ack&n; *&n; */
macro_line|#include &lt;net/tcp.h&gt;
multiline_comment|/*&n; *&t;Get rid of any delayed acks, we sent one already..&n; */
DECL|function|clear_delayed_acks
r_static
id|__inline__
r_void
id|clear_delayed_acks
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sk-&gt;delayed_acks
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;bytes_rcv
op_assign
l_int|0
suffix:semicolon
id|tcp_clear_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_DACK
)paren
suffix:semicolon
)brace
DECL|function|update_send_head
r_static
id|__inline__
r_void
id|update_send_head
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
id|tp-&gt;send_head
op_assign
id|tp-&gt;send_head-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;send_head
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
(brace
id|tp-&gt;send_head
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|tcp_snd_test
r_static
id|__inline__
r_int
id|tcp_snd_test
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|nagle_check
op_assign
l_int|1
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/*&n;&t; *&t;RFC 1122 - section 4.2.3.4&n;&t; *&n;&t; *&t;We must queue if&n;&t; *&n;&t; *&t;a) The right edge of this frame exceeds the window&n;&t; *&t;b) There are packets in flight and we have a small segment&n;&t; *&t;   [SWS avoidance and Nagle algorithm]&n;&t; *&t;   (part of SWS is done on packetization)&n;&t; *&t;c) We are retransmiting [Nagle]&n;&t; *&t;d) We have too many packets &squot;in flight&squot;&n;&t; */
id|len
op_assign
id|skb-&gt;end_seq
op_minus
id|skb-&gt;seq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;nonagle
op_logical_and
id|len
OL
(paren
id|sk-&gt;mss
op_rshift
l_int|1
)paren
op_logical_and
id|sk-&gt;packets_out
)paren
(brace
id|nagle_check
op_assign
l_int|0
suffix:semicolon
)brace
r_return
(paren
id|nagle_check
op_logical_and
id|sk-&gt;packets_out
OL
id|sk-&gt;cong_window
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|skb-&gt;end_seq
comma
id|tp-&gt;snd_una
op_plus
id|tp-&gt;snd_wnd
)paren
op_logical_and
id|sk-&gt;retransmits
op_eq
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is the main buffer sending routine. We queue the buffer&n; *&t;having checked it is sane seeming.&n; */
DECL|function|tcp_send_skb
r_int
id|tcp_send_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/*&n;&t; *&t;length of packet (not counting length of pre-tcp headers) &n;&t; */
id|size
op_assign
id|skb-&gt;len
op_minus
(paren
(paren
r_int
r_char
op_star
)paren
id|th
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Sanity check it.. &n;&t; */
r_if
c_cond
(paren
id|size
template_param
id|skb-&gt;len
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tcp_send_skb: bad skb (skb = %p, data = %p, th = %p, len = %u)&bslash;n&quot;
comma
id|skb
comma
id|skb-&gt;data
comma
id|th
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If we have queued a header size packet.. (these crash a few&n;&t; *&t;tcp stacks if ack is not set)&n;&t; */
r_if
c_cond
(paren
id|size
op_eq
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
(brace
multiline_comment|/* &n;                 * If it&squot;s got a syn or fin discard&n;                 */
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;syn
op_logical_and
op_logical_neg
id|th-&gt;fin
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tcp_send_skb: attempt to queue a bogon.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Actual processing.&n;&t; */
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
id|skb-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
suffix:semicolon
id|skb-&gt;end_seq
op_assign
id|skb-&gt;seq
op_plus
id|size
op_minus
l_int|4
op_star
id|th-&gt;doff
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;send_head
op_logical_or
op_logical_neg
id|tcp_snd_test
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t; * Remember where we must start sending&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;send_head
op_eq
l_int|NULL
)paren
id|tp-&gt;send_head
op_assign
id|skb
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;packets_out
op_eq
l_int|0
op_logical_and
op_logical_neg
id|tp-&gt;pending
)paren
(brace
id|tp-&gt;pending
op_assign
id|TIME_PROBE0
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;This is going straight out&n;&t;&t; */
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
id|clear_delayed_acks
c_func
(paren
id|sk
)paren
suffix:semicolon
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|tp-&gt;rcv_nxt
)paren
suffix:semicolon
id|th-&gt;window
op_assign
id|htons
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|send_check
c_func
(paren
id|sk
comma
id|th
comma
id|size
comma
id|skb
)paren
suffix:semicolon
id|tp-&gt;snd_nxt
op_assign
id|skb-&gt;end_seq
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|sk-&gt;packets_out
)paren
suffix:semicolon
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
id|buff
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|skb_set_owner_w
c_func
(paren
id|buff
comma
id|sk
)paren
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|buff
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_timer_is_set
c_func
(paren
id|sk
comma
id|TIME_RETRANS
)paren
)paren
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Function to create two new tcp segments.&n; *&t;Shrinks the given segment to the specified size and appends a new&n; *&t;segment with the rest of the packet to the list.&n; *&t;This won&squot;t be called frenquently, I hope... &n; */
DECL|function|tcp_fragment
r_static
r_int
id|tcp_fragment
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
id|u32
id|len
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
comma
op_star
id|nth
suffix:semicolon
r_int
id|nsize
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
multiline_comment|/* size of new segment */
id|nsize
op_assign
id|skb-&gt;tail
op_minus
(paren
(paren
r_int
r_char
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
)paren
op_minus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|nsize
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tcp_fragment: bug size &lt;= 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Get a new skb... force flag on&n;&t; */
id|buff
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|nsize
op_plus
l_int|128
op_plus
id|sk-&gt;prot-&gt;max_header
op_plus
l_int|15
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Put headers on the new packet&n;&t; */
id|tmp
op_assign
id|tp-&gt;af_specific
op_member_access_from_pointer
id|build_net_header
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|buff
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Move the TCP header over&n;&t; */
id|nth
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
r_sizeof
(paren
op_star
id|th
)paren
)paren
suffix:semicolon
id|buff-&gt;h.th
op_assign
id|nth
suffix:semicolon
id|memcpy
c_func
(paren
id|nth
comma
id|th
comma
r_sizeof
(paren
op_star
id|th
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Correct the new header&n;&t; */
id|buff-&gt;seq
op_assign
id|skb-&gt;seq
op_plus
id|len
suffix:semicolon
id|buff-&gt;end_seq
op_assign
id|skb-&gt;end_seq
suffix:semicolon
id|nth-&gt;seq
op_assign
id|htonl
c_func
(paren
id|buff-&gt;seq
)paren
suffix:semicolon
id|nth-&gt;check
op_assign
l_int|0
suffix:semicolon
id|nth-&gt;doff
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* urg data is always an headache */
r_if
c_cond
(paren
id|th-&gt;urg
)paren
(brace
r_if
c_cond
(paren
id|th-&gt;urg_ptr
OG
id|len
)paren
(brace
id|th-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|nth-&gt;urg_ptr
op_sub_assign
id|len
suffix:semicolon
)brace
r_else
(brace
id|nth-&gt;urg
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Copy TCP options and data start to our new buffer&n;&t; */
id|buff-&gt;csum
op_assign
id|csum_partial_copy
c_func
(paren
(paren
(paren
id|u8
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
)paren
op_plus
id|len
comma
id|skb_put
c_func
(paren
id|buff
comma
id|nsize
)paren
comma
id|nsize
comma
l_int|0
)paren
suffix:semicolon
id|skb-&gt;end_seq
op_sub_assign
id|nsize
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
id|skb-&gt;len
op_minus
id|nsize
)paren
suffix:semicolon
multiline_comment|/* remember to checksum this packet afterwards */
id|th-&gt;check
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;csum
op_assign
id|csum_partial
c_func
(paren
(paren
id|u8
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
comma
id|skb-&gt;tail
op_minus
(paren
(paren
id|u8
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
id|skb_append
c_func
(paren
id|skb
comma
id|buff
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tcp_wrxmit_prob
r_static
r_void
id|tcp_wrxmit_prob
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/*&n;&t; *&t;This is acked data. We can discard it. This &n;&t; *&t;cannot currently occur.&n;&t; */
id|sk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tcp_write_xmit: bug skb in write queue&bslash;n&quot;
)paren
suffix:semicolon
id|update_send_head
c_func
(paren
id|sk
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
DECL|function|tcp_wrxmit_frag
r_static
r_int
id|tcp_wrxmit_frag
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|size
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tcp_write_xmit: frag needed size=%d mss=%d&bslash;n&quot;
comma
id|size
comma
id|sk-&gt;mss
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_fragment
c_func
(paren
id|sk
comma
id|skb
comma
id|sk-&gt;mss
)paren
)paren
(brace
multiline_comment|/* !tcp_frament Failed! */
id|tp-&gt;send_head
op_assign
id|skb
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|sk-&gt;packets_out
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &n;&t;&t; * If tcp_fragment succeded then&n;&t;&t; * the send head is the resulting&n;&t;&t; * fragment&n;&t;&t; */
id|tp-&gt;send_head
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;This routine writes packets to the network.&n; *&t;It advances the send_head.&n; *&t;This happens as incoming acks open up the remote window for us.&n; */
DECL|function|tcp_write_xmit
r_void
id|tcp_write_xmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
id|u16
id|rcv_wnd
suffix:semicolon
r_int
id|sent_pkts
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;The bytes will have to remain here. In time closedown will&n;&t; *&t;empty the write queue and all will be happy &n;&t; */
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Anything on the transmit queue that fits the window can&n;&t; *&t;be added providing we are:&n;&t; *&n;&t; *&t;a) following SWS avoidance [and Nagle algorithm]&n;&t; *&t;b) not exceeding our congestion window.&n;&t; *&t;c) not retransmiting [Nagle]&n;&t; */
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
id|rcv_wnd
op_assign
id|htons
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|tp-&gt;send_head
)paren
op_logical_and
id|tcp_snd_test
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_int
id|size
suffix:semicolon
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;See if we really need to send the packet. &n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|skb-&gt;end_seq
comma
id|tp-&gt;snd_una
)paren
)paren
(brace
id|tcp_wrxmit_prob
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * Advance the send_head&n;&t;&t; * This one is going out.&n;&t;&t; */
id|update_send_head
c_func
(paren
id|sk
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|sk-&gt;packets_out
)paren
suffix:semicolon
multiline_comment|/*&n; * put in the ack seq and window at this point rather than earlier,&n; * in order to keep them monotonic.  We really want to avoid taking&n; * back window allocations.  That&squot;s legal, but RFC1122 says it&squot;s frowned on.&n; * Ack and window will in general have changed since this packet was put&n; * on the write queue.&n; */
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
id|size
op_assign
id|skb-&gt;len
op_minus
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|th
)paren
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_minus
(paren
id|th-&gt;doff
op_lshift
l_int|2
)paren
OG
id|sk-&gt;mss
)paren
(brace
r_if
c_cond
(paren
id|tcp_wrxmit_frag
c_func
(paren
id|sk
comma
id|skb
comma
id|size
)paren
)paren
r_break
suffix:semicolon
)brace
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|tp-&gt;rcv_nxt
)paren
suffix:semicolon
id|th-&gt;window
op_assign
id|rcv_wnd
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|send_check
c_func
(paren
id|sk
comma
id|th
comma
id|size
comma
id|skb
)paren
suffix:semicolon
macro_line|#ifdef TCP_DEBUG
r_if
c_cond
(paren
id|before
c_func
(paren
id|skb-&gt;end_seq
comma
id|tp-&gt;snd_nxt
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tcp_write_xmit:&quot;
l_string|&quot; sending already sent seq&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif&t;&t;
id|tp-&gt;snd_nxt
op_assign
id|skb-&gt;end_seq
suffix:semicolon
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
id|clear_delayed_acks
c_func
(paren
id|sk
)paren
suffix:semicolon
id|buff
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|skb_set_owner_w
c_func
(paren
id|buff
comma
id|sk
)paren
suffix:semicolon
id|sent_pkts
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|buff
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sent_pkts
op_logical_and
op_logical_neg
id|tcp_timer_is_set
c_func
(paren
id|sk
comma
id|TIME_RETRANS
)paren
)paren
(brace
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *      This function returns the amount that we can raise the&n; *      usable window based on the following constraints&n; *  &n; *&t;1. The window can never be shrunk once it is offered (RFC 793)&n; *&t;2. We limit memory per socket&n; */
DECL|function|tcp_select_window
r_int
r_int
id|tcp_select_window
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_int
id|mss
op_assign
id|sk-&gt;mss
suffix:semicolon
r_int
id|free_space
op_assign
id|sock_rspace
c_func
(paren
id|sk
)paren
suffix:semicolon
r_int
id|window
suffix:semicolon
r_int
id|cur_win
suffix:semicolon
r_int
id|usable
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;window_clamp
)paren
(brace
id|free_space
op_assign
id|min
c_func
(paren
id|sk-&gt;window_clamp
comma
id|free_space
)paren
suffix:semicolon
id|mss
op_assign
id|min
c_func
(paren
id|sk-&gt;window_clamp
comma
id|mss
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * compute the actual window i.e.&n;&t; * old_window - received_bytes_on_that_win&n;&t; */
id|cur_win
op_assign
id|tp-&gt;rcv_wup
op_minus
(paren
id|tp-&gt;rcv_nxt
op_minus
id|tp-&gt;rcv_wnd
)paren
suffix:semicolon
id|window
op_assign
id|tp-&gt;rcv_wnd
suffix:semicolon
r_if
c_cond
(paren
id|cur_win
OL
l_int|0
)paren
(brace
id|cur_win
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;TSW: win &lt; 0 w=%d 1=%u 2=%u&bslash;n&quot;
comma
id|tp-&gt;rcv_wnd
comma
id|tp-&gt;rcv_nxt
comma
id|tp-&gt;rcv_wup
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * RFC 1122:&n;&t; * &quot;the suggested [SWS] avoidance algoritm for the receiver is to keep&n;&t; *  RECV.NEXT + RCV.WIN fixed until:&n;&t; *  RCV.BUFF - RCV.USER - RCV.WINDOW &gt;= min(1/2 RCV.BUFF, MSS)&quot;&n;&t; *&n;&t; * i.e. don&squot;t raise the right edge of the window until you can&squot;t raise&n;&t; * it MSS bytes&n;&t; */
multiline_comment|/*&n;&t; * It would be a good idea if it didn&squot;t break header prediction.&n;&t; * and BSD made the header predition standard...&n;&t; * It expects the same value in the header i.e. th-&gt;window to be&n;&t; * constant&n;&t; */
id|usable
op_assign
id|free_space
op_minus
id|cur_win
suffix:semicolon
r_if
c_cond
(paren
id|usable
OL
l_int|0
)paren
(brace
id|usable
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|window
OL
id|usable
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Window is not blocking the sender&n;&t;&t; *&t;and we have enought free space for it&n;&t;&t; */
r_if
c_cond
(paren
id|cur_win
OG
(paren
id|sk-&gt;mss
op_lshift
l_int|1
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|window
op_ge
id|usable
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;We are offering too much, cut it down... &n;&t;&t; *&t;but don&squot;t shrink the window&n;&t;&t; */
id|window
op_assign
id|max
c_func
(paren
id|usable
comma
id|cur_win
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|usable
op_minus
id|window
)paren
op_ge
id|mss
)paren
(brace
id|window
op_add_assign
id|mss
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|tp-&gt;rcv_wnd
op_assign
id|window
suffix:semicolon
id|tp-&gt;rcv_wup
op_assign
id|tp-&gt;rcv_nxt
suffix:semicolon
r_return
id|window
suffix:semicolon
)brace
DECL|function|tcp_retrans_try_collapse
r_static
r_int
id|tcp_retrans_try_collapse
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcphdr
op_star
id|th1
comma
op_star
id|th2
suffix:semicolon
r_int
id|size1
comma
id|size2
comma
id|avail
suffix:semicolon
r_struct
id|sk_buff
op_star
id|buff
op_assign
id|skb-&gt;next
suffix:semicolon
id|th1
op_assign
id|skb-&gt;h.th
suffix:semicolon
r_if
c_cond
(paren
id|th1-&gt;urg
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|avail
op_assign
id|skb_tailroom
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  size of tcp payload&n;&t; */
id|size1
op_assign
id|skb-&gt;tail
op_minus
(paren
id|u8
op_star
)paren
(paren
id|th1
op_plus
l_int|1
)paren
suffix:semicolon
id|th2
op_assign
id|buff-&gt;h.th
suffix:semicolon
id|size2
op_assign
id|buff-&gt;tail
op_minus
(paren
id|u8
op_star
)paren
(paren
id|th2
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size2
OG
id|avail
op_logical_or
id|size1
op_plus
id|size2
OG
id|sk-&gt;mss
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *  ok. we will be able to collapse the packet&n;&t; */
id|skb_unlink
c_func
(paren
id|buff
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|size2
)paren
comma
(paren
(paren
r_char
op_star
)paren
id|th2
)paren
op_plus
(paren
id|th2-&gt;doff
op_lshift
l_int|2
)paren
comma
id|size2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * update sizes on original skb. both TCP and IP&n;&t; */
id|skb-&gt;end_seq
op_add_assign
id|size2
suffix:semicolon
r_if
c_cond
(paren
id|th2-&gt;urg
)paren
(brace
id|th1-&gt;urg
op_assign
l_int|1
suffix:semicolon
id|th1-&gt;urg_ptr
op_assign
id|th2-&gt;urg_ptr
op_plus
id|size1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * ... and off you go.&n;&t; */
id|kfree_skb
c_func
(paren
id|buff
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|sk-&gt;packets_out
)paren
suffix:semicolon
multiline_comment|/* &n;&t; *&t;Header checksum will be set by the retransmit procedure&n;&t; *&t;after calling rebuild header&n;&t; */
id|th1-&gt;check
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;csum
op_assign
id|csum_partial
c_func
(paren
(paren
id|u8
op_star
)paren
(paren
id|th1
op_plus
l_int|1
)paren
comma
id|size1
op_plus
id|size2
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;A socket has timed out on its send queue and wants to do a&n; *&t;little retransmitting.&n; *&t;retransmit_head can be different from the head of the write_queue&n; *&t;if we are doing fast retransmit.&n; */
DECL|function|tcp_do_retransmit
r_void
id|tcp_do_retransmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|all
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;retrans_head
op_eq
l_int|NULL
)paren
id|tp-&gt;retrans_head
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;retrans_head
op_eq
id|tp-&gt;send_head
)paren
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|tp-&gt;retrans_head
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_int
id|tcp_size
suffix:semicolon
r_int
id|size
suffix:semicolon
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In general it&squot;s OK just to use the old packet.  However we&n;&t;&t; * need to use the current ack and window fields.  Urg and&n;&t;&t; * urg_ptr could possibly stand to be updated as well, but we&n;&t;&t; * don&squot;t keep the necessary data.  That shouldn&squot;t be a problem,&n;&t;&t; * if the other end is doing the right thing.  Since we&squot;re&n;&t;&t; * changing the packet, we have to issue a new IP identifier.&n;&t;&t; */
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
id|tcp_size
op_assign
id|skb-&gt;tail
op_minus
(paren
(paren
r_int
r_char
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcp_size
OG
id|sk-&gt;mss
)paren
(brace
r_if
c_cond
(paren
id|tcp_fragment
c_func
(paren
id|sk
comma
id|skb
comma
id|sk-&gt;mss
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tcp_fragment failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|sk-&gt;packets_out
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;syn
op_logical_and
id|tcp_size
OL
(paren
id|sk-&gt;mss
op_rshift
l_int|1
)paren
op_logical_and
id|skb-&gt;next
op_ne
id|tp-&gt;send_head
op_logical_and
id|skb-&gt;next
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
(brace
id|tcp_retrans_try_collapse
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;af_specific
op_member_access_from_pointer
id|rebuild_header
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
(brace
macro_line|#ifdef TCP_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tcp_do_rebuild_header failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
id|printk
c_func
(paren
l_string|&quot;retransmit sending&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;update ack and window&n;&t;&t; */
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|tp-&gt;rcv_nxt
)paren
suffix:semicolon
id|th-&gt;window
op_assign
id|ntohs
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|size
op_assign
id|skb-&gt;tail
op_minus
(paren
r_int
r_char
op_star
)paren
id|th
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|send_check
c_func
(paren
id|sk
comma
id|th
comma
id|size
comma
id|skb
)paren
suffix:semicolon
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
id|buff
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|skb_set_owner_w
c_func
(paren
id|buff
comma
id|sk
)paren
suffix:semicolon
id|clear_delayed_acks
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|buff
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Count retransmissions&n;&t;&t; */
id|ct
op_increment
suffix:semicolon
id|sk-&gt;prot-&gt;retransmits
op_increment
suffix:semicolon
id|tcp_statistics.TcpRetransSegs
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Record the high sequence number to help avoid doing&n;&t;&t; * to much fast retransmission.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;retransmits
)paren
id|tp-&gt;high_seq
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Only one retransmit requested.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|all
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;This should cut it off before we send too many packets.&n;&t;&t; */
r_if
c_cond
(paren
id|ct
op_ge
id|sk-&gt;cong_window
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Advance the pointer&n;&t;&t; */
id|tp-&gt;retrans_head
op_assign
id|skb-&gt;next
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;retrans_head
op_eq
id|tp-&gt;send_head
)paren
op_logical_or
(paren
id|tp-&gt;retrans_head
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
(brace
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send a fin.&n; */
DECL|function|tcp_send_fin
r_void
id|tcp_send_fin
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
op_amp
id|sk-&gt;dummy_th
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|buff
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|MAX_RESET_SIZE
comma
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* This is a disaster if it occurs */
id|printk
c_func
(paren
l_string|&quot;tcp_send_fin: Impossible malloc failure&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Administrivia&n;&t; */
id|buff-&gt;csum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Put in the IP header and routing stuff. &n;&t; */
id|tmp
op_assign
id|tp-&gt;af_specific
op_member_access_from_pointer
id|build_net_header
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
r_int
id|t
suffix:semicolon
multiline_comment|/*&n;  &t;&t; *&t;Finish anyway, treat this as a send that got lost. &n;  &t;&t; *&t;(Not good).&n;  &t;&t; */
id|kfree_skb
c_func
(paren
id|buff
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|sk-&gt;write_seq
op_increment
suffix:semicolon
id|t
op_assign
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
)brace
r_else
id|tcp_reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;We ought to check if the end of the queue is a buffer and&n;&t; *&t;if so simply add the fin to that buffer, not send it ahead.&n;&t; */
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|buff-&gt;h.th
op_assign
id|t1
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
id|th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
id|buff-&gt;seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|sk-&gt;write_seq
op_increment
suffix:semicolon
id|buff-&gt;end_seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|t1-&gt;seq
op_assign
id|htonl
c_func
(paren
id|buff-&gt;seq
)paren
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|tp-&gt;rcv_nxt
)paren
suffix:semicolon
id|t1-&gt;window
op_assign
id|htons
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|t1-&gt;fin
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|send_check
c_func
(paren
id|sk
comma
id|t1
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|buff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The fin can only be transmited after the data.&n; &t; */
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|buff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;send_head
op_eq
l_int|NULL
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb1
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|sk-&gt;packets_out
)paren
suffix:semicolon
id|tp-&gt;snd_nxt
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|buff-&gt;when
op_assign
id|jiffies
suffix:semicolon
id|skb1
op_assign
id|skb_clone
c_func
(paren
id|buff
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|skb_set_owner_w
c_func
(paren
id|skb1
comma
id|sk
)paren
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|skb1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_timer_is_set
c_func
(paren
id|sk
comma
id|TIME_RETRANS
)paren
)paren
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
)brace
DECL|function|tcp_send_synack
r_int
id|tcp_send_synack
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|skb
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|MAX_SYN_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|tmp
op_assign
id|tp-&gt;af_specific
op_member_access_from_pointer
id|build_net_header
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|skb-&gt;h.th
op_assign
id|th
suffix:semicolon
id|memset
c_func
(paren
id|th
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|th-&gt;syn
op_assign
l_int|1
suffix:semicolon
id|th-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|th-&gt;source
op_assign
id|sk-&gt;dummy_th.source
suffix:semicolon
id|th-&gt;dest
op_assign
id|sk-&gt;dummy_th.dest
suffix:semicolon
id|skb-&gt;seq
op_assign
id|tp-&gt;snd_una
suffix:semicolon
id|skb-&gt;end_seq
op_assign
id|skb-&gt;seq
op_plus
l_int|1
multiline_comment|/* th-&gt;syn */
suffix:semicolon
id|th-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|skb-&gt;seq
)paren
suffix:semicolon
id|th-&gt;window
op_assign
id|ntohs
c_func
(paren
id|tp-&gt;rcv_wnd
)paren
suffix:semicolon
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|tp-&gt;rcv_nxt
)paren
suffix:semicolon
id|th-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|th
)paren
op_div
l_int|4
op_plus
l_int|1
suffix:semicolon
id|ptr
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|TCPOLEN_MSS
)paren
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
id|TCPOPT_MSS
suffix:semicolon
id|ptr
(braket
l_int|1
)braket
op_assign
id|TCPOLEN_MSS
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
(paren
(paren
id|sk-&gt;mss
)paren
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|ptr
(braket
l_int|3
)braket
op_assign
(paren
id|sk-&gt;mss
)paren
op_amp
l_int|0xff
suffix:semicolon
id|skb-&gt;csum
op_assign
id|csum_partial
c_func
(paren
id|ptr
comma
id|TCPOLEN_MSS
comma
l_int|0
)paren
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|send_check
c_func
(paren
id|sk
comma
id|th
comma
r_sizeof
(paren
op_star
id|th
)paren
op_plus
l_int|4
comma
id|skb
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|sk-&gt;packets_out
)paren
suffix:semicolon
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
id|buff
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|skb_set_owner_w
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|buff
)paren
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|TCP_TIMEOUT_INIT
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Set up the timers for sending a delayed ack..&n; *&n; *      rules for delaying an ack:&n; *      - delay time &lt;= 0.5 HZ&n; *      - must send at least every 2 full sized packets&n; *      - we don&squot;t have a window update to send&n; */
DECL|function|tcp_send_delayed_ack
r_void
id|tcp_send_delayed_ack
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|max_timeout
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_int
r_int
id|timeout
comma
id|now
suffix:semicolon
multiline_comment|/* Calculate new timeout */
id|now
op_assign
id|jiffies
suffix:semicolon
id|timeout
op_assign
id|tp-&gt;ato
suffix:semicolon
r_if
c_cond
(paren
id|timeout
OG
id|max_timeout
op_logical_or
id|sk-&gt;bytes_rcv
OG
(paren
id|sk-&gt;mss
op_lshift
l_int|2
)paren
)paren
(brace
id|timeout
op_assign
id|now
suffix:semicolon
)brace
r_else
id|timeout
op_add_assign
id|now
suffix:semicolon
multiline_comment|/* Use new timeout only if there wasn&squot;t a older one earlier  */
r_if
c_cond
(paren
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;delack_timer
)paren
op_logical_or
id|timeout
OL
id|tp-&gt;delack_timer.expires
)paren
(brace
id|tp-&gt;delack_timer.expires
op_assign
id|timeout
suffix:semicolon
)brace
id|add_timer
c_func
(paren
op_amp
id|tp-&gt;delack_timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine sends an ack and also updates the window. &n; */
DECL|function|tcp_send_ack
r_void
id|tcp_send_ack
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
multiline_comment|/* We have been reset, we may not send again */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We need to grab some memory, and put together an ack,&n;&t; * and then put it into the queue to be sent.&n;&t; */
id|buff
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|MAX_ACK_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* &n;&t;&t; *&t;Force it to send an ack. We don&squot;t have to do this&n;&t;&t; *&t;(ACK is unreliable) but it&squot;s much better use of &n;&t;&t; *&t;bandwidth on slow links to send a spare ack than&n;&t;&t; *&t;resend packets. &n;&t;&t; */
id|tcp_send_delayed_ack
c_func
(paren
id|sk
comma
id|HZ
op_div
l_int|2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|clear_delayed_acks
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Assemble a suitable TCP frame&n;&t; */
id|buff-&gt;csum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t; *&t;Put in the IP header and routing stuff. &n;&t; */
id|tmp
op_assign
id|tp-&gt;af_specific
op_member_access_from_pointer
id|build_net_header
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|buff
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|th
comma
op_amp
id|sk-&gt;dummy_th
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Swap the send and the receive. &n;&t; */
id|th-&gt;window
op_assign
id|ntohs
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|th-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|tp-&gt;snd_nxt
)paren
suffix:semicolon
id|th-&gt;ack_seq
op_assign
id|ntohl
c_func
(paren
id|tp-&gt;rcv_nxt
)paren
suffix:semicolon
multiline_comment|/*&n;  &t; *&t;Fill in the packet and send it&n;  &t; */
id|tp-&gt;af_specific
op_member_access_from_pointer
id|send_check
c_func
(paren
id|sk
comma
id|th
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
comma
id|buff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;rtcp_send_ack: seq %x ack %x&bslash;n&quot;
comma
id|tp-&gt;snd_nxt
comma
id|tp-&gt;rcv_nxt
)paren
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|buff
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine sends a packet with an out of date sequence&n; *&t;number. It assumes the other end will try to ack it.&n; */
DECL|function|tcp_write_wakeup
r_void
id|tcp_write_wakeup
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
comma
op_star
id|skb
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
r_return
suffix:semicolon
multiline_comment|/* After a valid reset we can send no more */
multiline_comment|/*&n;&t; *&t;Write data can still be transmitted/retransmitted in the&n;&t; *&t;following states.  If any other state is encountered, return.&n;&t; *&t;[listen/close will never occur here anyway]&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_CLOSE_WAIT
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_FIN_WAIT1
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_LAST_ACK
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_CLOSING
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|tp-&gt;snd_nxt
comma
id|tp-&gt;snd_una
op_plus
id|tp-&gt;snd_wnd
)paren
op_logical_and
(paren
id|skb
op_assign
id|tp-&gt;send_head
)paren
)paren
(brace
multiline_comment|/*&n;&t;    &t; * We are probing the opening of a window&n;&t;    &t; * but the window size is != 0&n;&t;    &t; * must have been a result SWS avoidance ( sender )&n;&t;    &t; */
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_int
r_int
id|win_size
suffix:semicolon
id|win_size
op_assign
id|tp-&gt;snd_wnd
op_minus
(paren
id|tp-&gt;snd_nxt
op_minus
id|tp-&gt;snd_una
)paren
suffix:semicolon
r_if
c_cond
(paren
id|win_size
OL
id|skb-&gt;end_seq
op_minus
id|skb-&gt;seq
)paren
(brace
r_if
c_cond
(paren
id|tcp_fragment
c_func
(paren
id|sk
comma
id|skb
comma
id|win_size
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tcp_write_wakeup: &quot;
l_string|&quot;fragment failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|send_check
c_func
(paren
id|sk
comma
id|th
comma
id|th-&gt;doff
op_star
l_int|4
op_plus
id|win_size
comma
id|skb
)paren
suffix:semicolon
id|buff
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|skb_set_owner_w
c_func
(paren
id|buff
comma
id|sk
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|sk-&gt;packets_out
)paren
suffix:semicolon
id|clear_delayed_acks
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_timer_is_set
c_func
(paren
id|sk
comma
id|TIME_RETRANS
)paren
)paren
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
id|update_send_head
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;snd_nxt
op_assign
id|skb-&gt;end_seq
suffix:semicolon
)brace
r_else
(brace
id|buff
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|MAX_ACK_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|buff-&gt;csum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Put in the IP header and routing stuff. &n;&t;&t; */
id|tmp
op_assign
id|tp-&gt;af_specific
op_member_access_from_pointer
id|build_net_header
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|buff
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
(paren
r_void
op_star
)paren
op_amp
id|sk-&gt;dummy_th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Use a previous sequence.&n;&t;&t; *&t;This should cause the other end to send an ack.&n;&t;&t; */
id|t1-&gt;seq
op_assign
id|htonl
c_func
(paren
id|tp-&gt;snd_nxt
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&t;&t;t1-&gt;fin = 0;&t;-- We are sending a &squot;previous&squot; sequence, and 0 bytes of data - thus no FIN bit */
id|t1-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|tp-&gt;rcv_nxt
)paren
suffix:semicolon
id|t1-&gt;window
op_assign
id|htons
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|send_check
c_func
(paren
id|sk
comma
id|t1
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|buff
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Send it.&n;&t; */
id|tp-&gt;af_specific
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|buff
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;A window probe timeout has occurred.&n; *&t;If window is not closed send a partial packet&n; *&t;else a zero probe.&n; */
DECL|function|tcp_send_probe0
r_void
id|tcp_send_probe0
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
r_return
suffix:semicolon
multiline_comment|/* After a valid reset we can send no more */
id|tcp_write_wakeup
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;pending
op_assign
id|TIME_PROBE0
suffix:semicolon
id|tp-&gt;backoff
op_increment
suffix:semicolon
id|tp-&gt;probes_out
op_increment
suffix:semicolon
id|tcp_reset_xmit_timer
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|min
c_func
(paren
id|tp-&gt;rto
op_lshift
id|tp-&gt;backoff
comma
l_int|120
op_star
id|HZ
)paren
)paren
suffix:semicolon
)brace
eof
