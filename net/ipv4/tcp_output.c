multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Implementation of the Transmission Control Protocol(TCP).&n; *&n; * Version:&t;$Id: tcp_output.c,v 1.98 1998/12/12 06:43:35 davem Exp $&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;&n; *&t;&t;Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; */
multiline_comment|/*&n; * Changes:&t;Pedro Roque&t;:&t;Retransmit queue handled by TCP.&n; *&t;&t;&t;&t;:&t;Fragmentation on mtu decrease&n; *&t;&t;&t;&t;:&t;Segment collapse on retransmit&n; *&t;&t;&t;&t;:&t;AF independence&n; *&n; *&t;&t;Linus Torvalds&t;:&t;send_delayed_ack&n; *&t;&t;David S. Miller&t;:&t;Charge memory using the right skb&n; *&t;&t;&t;&t;&t;during syn/ack processing.&n; *&t;&t;David S. Miller :&t;Output engine completely rewritten.&n; *&n; */
macro_line|#include &lt;net/tcp.h&gt;
r_extern
r_int
id|sysctl_tcp_timestamps
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_window_scaling
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_sack
suffix:semicolon
multiline_comment|/* People can turn this off for buggy TCP&squot;s found in printers etc. */
DECL|variable|sysctl_tcp_retrans_collapse
r_int
id|sysctl_tcp_retrans_collapse
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Get rid of any delayed acks, we sent one already.. */
DECL|function|clear_delayed_acks
r_static
id|__inline__
r_void
id|clear_delayed_acks
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|tp-&gt;delayed_acks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tcp_in_quickack_mode
c_func
(paren
id|tp
)paren
)paren
(brace
id|tp-&gt;ato
op_assign
(paren
(paren
id|HZ
op_div
l_int|100
)paren
op_star
l_int|2
)paren
suffix:semicolon
)brace
id|tcp_clear_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_DACK
)paren
suffix:semicolon
)brace
DECL|function|update_send_head
r_static
id|__inline__
r_void
id|update_send_head
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
id|tp-&gt;send_head
op_assign
id|tp-&gt;send_head-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;send_head
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
id|tp-&gt;send_head
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* This routine actually transmits TCP packets queued in by&n; * tcp_do_sendmsg().  This is used by both the initial&n; * transmission and possible later retransmissions.&n; * All SKB&squot;s seen here are completely headerless.  It is our&n; * job to build the TCP header, and pass the packet down to&n; * IP so it can do the same plus pass the packet off to the&n; * device.&n; *&n; * We are working here with either a clone of the original&n; * SKB, or a fresh unique copy made by the retransmit engine.&n; */
DECL|function|tcp_transmit_skb
r_void
id|tcp_transmit_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|tcp_skb_cb
op_star
id|tcb
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
suffix:semicolon
r_int
id|tcp_header_size
op_assign
id|tp-&gt;tcp_header_len
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_int
id|sysctl_flags
suffix:semicolon
DECL|macro|SYSCTL_FLAG_TSTAMPS
mdefine_line|#define SYSCTL_FLAG_TSTAMPS&t;0x1
DECL|macro|SYSCTL_FLAG_WSCALE
mdefine_line|#define SYSCTL_FLAG_WSCALE&t;0x2
DECL|macro|SYSCTL_FLAG_SACK
mdefine_line|#define SYSCTL_FLAG_SACK&t;0x4
id|sysctl_flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tcb-&gt;flags
op_amp
id|TCPCB_FLAG_SYN
)paren
(brace
id|tcp_header_size
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
id|TCPOLEN_MSS
suffix:semicolon
r_if
c_cond
(paren
id|sysctl_tcp_timestamps
)paren
(brace
id|tcp_header_size
op_add_assign
id|TCPOLEN_TSTAMP_ALIGNED
suffix:semicolon
id|sysctl_flags
op_or_assign
id|SYSCTL_FLAG_TSTAMPS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sysctl_tcp_window_scaling
)paren
(brace
id|tcp_header_size
op_add_assign
id|TCPOLEN_WSCALE_ALIGNED
suffix:semicolon
id|sysctl_flags
op_or_assign
id|SYSCTL_FLAG_WSCALE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sysctl_tcp_sack
)paren
(brace
id|sysctl_flags
op_or_assign
id|SYSCTL_FLAG_SACK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sysctl_tcp_timestamps
)paren
(brace
id|tcp_header_size
op_add_assign
id|TCPOLEN_SACKPERM_ALIGNED
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|tp-&gt;sack_ok
op_logical_and
id|tp-&gt;num_sacks
)paren
(brace
multiline_comment|/* A SACK is 2 pad bytes, a 2 byte header, plus&n;&t;&t;&t; * 2 32-bit sequence numbers for each SACK block.&n;&t;&t;&t; */
id|tcp_header_size
op_add_assign
(paren
id|TCPOLEN_SACK_BASE_ALIGNED
op_plus
(paren
id|tp-&gt;num_sacks
op_star
id|TCPOLEN_SACK_PERBLOCK
)paren
)paren
suffix:semicolon
)brace
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
id|tcp_header_size
)paren
suffix:semicolon
id|skb-&gt;h.th
op_assign
id|th
suffix:semicolon
id|skb_set_owner_w
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/* Build TCP header and checksum it. */
id|th-&gt;source
op_assign
id|sk-&gt;sport
suffix:semicolon
id|th-&gt;dest
op_assign
id|sk-&gt;dport
suffix:semicolon
id|th-&gt;seq
op_assign
id|htonl
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
suffix:semicolon
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|tp-&gt;rcv_nxt
)paren
suffix:semicolon
id|th-&gt;doff
op_assign
(paren
id|tcp_header_size
op_rshift
l_int|2
)paren
suffix:semicolon
id|th-&gt;res1
op_assign
l_int|0
suffix:semicolon
op_star
(paren
(paren
(paren
id|__u8
op_star
)paren
id|th
)paren
op_plus
l_int|13
)paren
op_assign
id|tcb-&gt;flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tcb-&gt;flags
op_amp
id|TCPCB_FLAG_SYN
)paren
)paren
(brace
id|th-&gt;window
op_assign
id|htons
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
)brace
id|th-&gt;check
op_assign
l_int|0
suffix:semicolon
id|th-&gt;urg_ptr
op_assign
id|ntohs
c_func
(paren
id|tcb-&gt;urg_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcb-&gt;flags
op_amp
id|TCPCB_FLAG_SYN
)paren
(brace
multiline_comment|/* RFC1323: The window in SYN &amp; SYN/ACK segments&n;&t;&t;&t; * is never scaled.&n;&t;&t;&t; */
id|th-&gt;window
op_assign
id|htons
c_func
(paren
id|tp-&gt;rcv_wnd
)paren
suffix:semicolon
id|tcp_syn_build_options
c_func
(paren
(paren
id|__u32
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
comma
id|tp-&gt;mss_clamp
comma
(paren
id|sysctl_flags
op_amp
id|SYSCTL_FLAG_TSTAMPS
)paren
comma
(paren
id|sysctl_flags
op_amp
id|SYSCTL_FLAG_SACK
)paren
comma
(paren
id|sysctl_flags
op_amp
id|SYSCTL_FLAG_WSCALE
)paren
comma
id|tp-&gt;rcv_wscale
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
)paren
suffix:semicolon
)brace
r_else
(brace
id|tcp_build_and_update_options
c_func
(paren
(paren
id|__u32
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
comma
id|tp
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
)paren
suffix:semicolon
)brace
id|tp-&gt;af_specific
op_member_access_from_pointer
id|send_check
c_func
(paren
id|sk
comma
id|th
comma
id|skb-&gt;len
comma
id|skb
)paren
suffix:semicolon
id|clear_delayed_acks
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;last_ack_sent
op_assign
id|tp-&gt;rcv_nxt
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
id|tp-&gt;af_specific
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
DECL|macro|SYSCTL_FLAG_TSTAMPS
macro_line|#undef SYSCTL_FLAG_TSTAMPS
DECL|macro|SYSCTL_FLAG_WSCALE
macro_line|#undef SYSCTL_FLAG_WSCALE
DECL|macro|SYSCTL_FLAG_SACK
macro_line|#undef SYSCTL_FLAG_SACK
)brace
multiline_comment|/* This is the main buffer sending routine. We queue the buffer&n; * and decide whether to queue or transmit now.&n; */
DECL|function|tcp_send_skb
r_void
id|tcp_send_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|force_queue
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/* Advance write_seq and place onto the write_queue. */
id|tp-&gt;write_seq
op_add_assign
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_minus
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|force_queue
op_logical_and
id|tp-&gt;send_head
op_eq
l_int|NULL
op_logical_and
id|tcp_snd_test
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
(brace
multiline_comment|/* Send it out now. */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|jiffies
suffix:semicolon
id|tp-&gt;snd_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
id|tp-&gt;packets_out
op_increment
suffix:semicolon
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_KERNEL
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_timer_is_set
c_func
(paren
id|sk
comma
id|TIME_RETRANS
)paren
)paren
(brace
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Queue it, remembering where we must start sending. */
r_if
c_cond
(paren
id|tp-&gt;send_head
op_eq
l_int|NULL
)paren
id|tp-&gt;send_head
op_assign
id|skb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|force_queue
op_logical_and
id|tp-&gt;packets_out
op_eq
l_int|0
op_logical_and
op_logical_neg
id|tp-&gt;pending
)paren
(brace
id|tp-&gt;pending
op_assign
id|TIME_PROBE0
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Function to create two new TCP segments.  Shrinks the given segment&n; * to the specified size and appends a new segment with the rest of the&n; * packet to the list.  This won&squot;t be called frequently, I hope. &n; * Remember, these are still headerless SKBs at this point.&n; */
DECL|function|tcp_fragment
r_static
r_int
id|tcp_fragment
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
id|u32
id|len
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_int
id|nsize
op_assign
id|skb-&gt;len
op_minus
id|len
suffix:semicolon
id|u16
id|flags
suffix:semicolon
multiline_comment|/* Get a new skb... force flag on. */
id|buff
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
(paren
id|nsize
op_plus
id|MAX_HEADER
op_plus
id|sk-&gt;prot-&gt;max_header
)paren
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* We&squot;ll just try again later. */
multiline_comment|/* Reserve space for headers. */
id|skb_reserve
c_func
(paren
id|buff
comma
id|MAX_HEADER
op_plus
id|sk-&gt;prot-&gt;max_header
)paren
suffix:semicolon
multiline_comment|/* Correct the sequence numbers. */
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_plus
id|len
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
multiline_comment|/* PSH and FIN should only be set in the second packet. */
id|flags
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_assign
id|flags
op_amp
op_complement
(paren
id|TCPCB_FLAG_FIN
op_or
id|TCPCB_FLAG_PSH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|TCPCB_FLAG_URG
)paren
(brace
id|u16
id|old_urg_ptr
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|urg_ptr
suffix:semicolon
multiline_comment|/* Urgent data is always a pain in the ass. */
r_if
c_cond
(paren
id|old_urg_ptr
OG
id|len
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_and_assign
op_complement
(paren
id|TCPCB_FLAG_URG
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
id|old_urg_ptr
op_minus
id|len
suffix:semicolon
)brace
r_else
(brace
id|flags
op_and_assign
op_complement
(paren
id|TCPCB_FLAG_URG
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|TCPCB_FLAG_URG
)paren
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
l_int|0
suffix:semicolon
)brace
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|flags
op_assign
id|flags
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|sacked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Copy and checksum data tail into the new buffer. */
id|buff-&gt;csum
op_assign
id|csum_partial_copy
c_func
(paren
id|skb-&gt;data
op_plus
id|len
comma
id|skb_put
c_func
(paren
id|buff
comma
id|nsize
)paren
comma
id|nsize
comma
l_int|0
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_sub_assign
id|nsize
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
id|skb-&gt;len
op_minus
id|nsize
)paren
suffix:semicolon
multiline_comment|/* Rechecksum original buffer. */
id|skb-&gt;csum
op_assign
id|csum_partial
c_func
(paren
id|skb-&gt;data
comma
id|skb-&gt;len
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Link BUFF into the send queue. */
id|__skb_append
c_func
(paren
id|skb
comma
id|buff
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function synchronize snd mss to current pmtu/exthdr set.&n;&n;   tp-&gt;user_mss is mss set by user by TCP_MAXSEG. It does NOT counts&n;   for TCP options, but includes only bare TCP header.&n;&n;   tp-&gt;mss_clamp is mss negotiated at connection setup.&n;   It is minumum of user_mss and mss received with SYN.&n;   It also does not include TCP options.&n;&n;   tp-&gt;pmtu_cookie is last pmtu, seen by this function.&n;&n;   tp-&gt;mss_cache is current effective sending mss, including&n;   all tcp options except for SACKs. It is evaluated,&n;   taking into account current pmtu, but never exceeds&n;   tp-&gt;mss_clamp.&n;&n;   NOTE1. rfc1122 clearly states that advertised MSS&n;   DOES NOT include either tcp or ip options.&n;&n;   NOTE2. tp-&gt;pmtu_cookie and tp-&gt;mss_cache are READ ONLY outside&n;   this function.&t;&t;&t;--ANK (980731)&n; */
DECL|function|tcp_sync_mss
r_int
id|tcp_sync_mss
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|pmtu
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_int
id|mss_now
suffix:semicolon
multiline_comment|/* Calculate base mss without TCP options:&n;&t;   It is MMS_S - sizeof(tcphdr) of rfc1122&n;&t;*/
id|mss_now
op_assign
id|pmtu
op_minus
id|tp-&gt;af_specific-&gt;net_header_len
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
multiline_comment|/* Clamp it (mss_clamp does not include tcp options) */
r_if
c_cond
(paren
id|mss_now
OG
id|tp-&gt;mss_clamp
)paren
id|mss_now
op_assign
id|tp-&gt;mss_clamp
suffix:semicolon
multiline_comment|/* Now subtract TCP options size, not including SACKs */
id|mss_now
op_sub_assign
id|tp-&gt;tcp_header_len
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
multiline_comment|/* Now subtract optional transport overhead */
id|mss_now
op_sub_assign
id|tp-&gt;ext_header_len
suffix:semicolon
multiline_comment|/* It we got too small (or even negative) value,&n;&t;   clamp it by 8 from below. Why 8 ?&n;&t;   Well, it could be 1 with the same success,&n;&t;   but if IP accepted segment of length 1,&n;&t;   it would love 8 even more 8)&t;&t;--ANK (980731)&n;&t; */
r_if
c_cond
(paren
id|mss_now
OL
l_int|8
)paren
id|mss_now
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* And store cached results */
id|tp-&gt;pmtu_cookie
op_assign
id|pmtu
suffix:semicolon
id|tp-&gt;mss_cache
op_assign
id|mss_now
suffix:semicolon
r_return
id|mss_now
suffix:semicolon
)brace
multiline_comment|/* This routine writes packets to the network.  It advances the&n; * send_head.  This happens as incoming acks open up the remote&n; * window for us.&n; */
DECL|function|tcp_write_xmit
r_void
id|tcp_write_xmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
r_int
id|mss_now
suffix:semicolon
multiline_comment|/* Account for SACKS, we may need to fragment due to this.&n;&t; * It is just like the real MSS changing on us midstream.&n;&t; * We also handle things correctly when the user adds some&n;&t; * IP options mid-stream.  Silly to do, but cover it.&n;&t; */
id|mss_now
op_assign
id|tcp_current_mss
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* If we are zapped, the bytes will have to remain here.&n;&t; * In time closedown will empty the write queue and all&n;&t; * will be happy.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;zapped
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|sent_pkts
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Anything on the transmit queue that fits the window can&n;&t;&t; * be added providing we are:&n;&t;&t; *&n;&t;&t; * a) following SWS avoidance [and Nagle algorithm]&n;&t;&t; * b) not exceeding our congestion window.&n;&t;&t; * c) not retransmitting [Nagle]&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|tp-&gt;send_head
)paren
op_logical_and
id|tcp_snd_test
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|mss_now
)paren
(brace
r_if
c_cond
(paren
id|tcp_fragment
c_func
(paren
id|sk
comma
id|skb
comma
id|mss_now
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Advance the send_head.  This one is going out. */
id|update_send_head
c_func
(paren
id|sk
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|jiffies
suffix:semicolon
id|tp-&gt;snd_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
id|tp-&gt;packets_out
op_increment
suffix:semicolon
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
)paren
suffix:semicolon
id|sent_pkts
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If we sent anything, make sure the retransmit&n;&t;&t; * timer is active.&n;&t;&t; */
r_if
c_cond
(paren
id|sent_pkts
op_logical_and
op_logical_neg
id|tcp_timer_is_set
c_func
(paren
id|sk
comma
id|TIME_RETRANS
)paren
)paren
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This function returns the amount that we can raise the&n; * usable window based on the following constraints&n; *  &n; * 1. The window can never be shrunk once it is offered (RFC 793)&n; * 2. We limit memory per socket&n; *&n; * RFC 1122:&n; * &quot;the suggested [SWS] avoidance algorithm for the receiver is to keep&n; *  RECV.NEXT + RCV.WIN fixed until:&n; *  RCV.BUFF - RCV.USER - RCV.WINDOW &gt;= min(1/2 RCV.BUFF, MSS)&quot;&n; *&n; * i.e. don&squot;t raise the right edge of the window until you can raise&n; * it at least MSS bytes.&n; *&n; * Unfortunately, the recommended algorithm breaks header prediction,&n; * since header prediction assumes th-&gt;window stays fixed.&n; *&n; * Strictly speaking, keeping th-&gt;window fixed violates the receiver&n; * side SWS prevention criteria. The problem is that under this rule&n; * a stream of single byte packets will cause the right side of the&n; * window to always advance by a single byte.&n; * &n; * Of course, if the sender implements sender side SWS prevention&n; * then this will not be a problem.&n; * &n; * BSD seems to make the following compromise:&n; * &n; *&t;If the free space is less than the 1/4 of the maximum&n; *&t;space available and the free space is less than 1/2 mss,&n; *&t;then set the window to 0.&n; *&t;Otherwise, just prevent the window from shrinking&n; *&t;and from being larger than the largest representable value.&n; *&n; * This prevents incremental opening of the window in the regime&n; * where TCP is limited by the speed of the reader side taking&n; * data out of the TCP receive queue. It does nothing about&n; * those cases where the window is constrained on the sender side&n; * because the pipeline is full.&n; *&n; * BSD also seems to &quot;accidentally&quot; limit itself to windows that are a&n; * multiple of MSS, at least until the free space gets quite small.&n; * This would appear to be a side effect of the mbuf implementation.&n; * Combining these two algorithms results in the observed behavior&n; * of having a fixed window size at almost all times.&n; *&n; * Below we obtain similar behavior by forcing the offered window to&n; * a multiple of the mss when it is feasible to do so.&n; *&n; * Note, we don&squot;t &quot;adjust&quot; for TIMESTAMP or SACK option bytes.&n; */
DECL|function|__tcp_select_window
id|u32
id|__tcp_select_window
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_int
r_int
id|mss
op_assign
id|tp-&gt;mss_cache
suffix:semicolon
r_int
id|free_space
suffix:semicolon
id|u32
id|window
suffix:semicolon
multiline_comment|/* Sometimes free_space can be &lt; 0. */
id|free_space
op_assign
(paren
id|sk-&gt;rcvbuf
op_minus
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;window_clamp
)paren
(brace
r_if
c_cond
(paren
id|free_space
OG
(paren
(paren
r_int
)paren
id|tp-&gt;window_clamp
)paren
)paren
id|free_space
op_assign
id|tp-&gt;window_clamp
suffix:semicolon
id|mss
op_assign
id|min
c_func
(paren
id|tp-&gt;window_clamp
comma
id|mss
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;tcp_select_window: tp-&gt;window_clamp == 0.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mss
OL
l_int|1
)paren
(brace
id|mss
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;tcp_select_window: sk-&gt;mss fell to 0.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|free_space
OL
(paren
id|sk-&gt;rcvbuf
op_div
l_int|4
)paren
)paren
op_logical_and
(paren
id|free_space
OL
(paren
(paren
r_int
)paren
(paren
id|mss
op_div
l_int|2
)paren
)paren
)paren
)paren
(brace
id|window
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;pred_flags
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get the largest window that is a nice multiple of mss.&n;&t;&t; * Window clamp already applied above.&n;&t;&t; * If our current window offering is within 1 mss of the&n;&t;&t; * free space we just keep it. This prevents the divide&n;&t;&t; * and multiply from happening most of the time.&n;&t;&t; * We also don&squot;t do any window rounding when the free space&n;&t;&t; * is too small.&n;&t;&t; */
id|window
op_assign
id|tp-&gt;rcv_wnd
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
(paren
r_int
)paren
id|window
)paren
op_le
(paren
id|free_space
op_minus
(paren
(paren
r_int
)paren
id|mss
)paren
)paren
)paren
op_logical_or
(paren
(paren
(paren
r_int
)paren
id|window
)paren
OG
id|free_space
)paren
)paren
id|window
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|free_space
)paren
op_div
id|mss
)paren
op_star
id|mss
suffix:semicolon
)brace
r_return
id|window
suffix:semicolon
)brace
multiline_comment|/* Attempt to collapse two adjacent SKB&squot;s during retransmission. */
DECL|function|tcp_retrans_try_collapse
r_static
r_void
id|tcp_retrans_try_collapse
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|mss_now
)paren
(brace
r_struct
id|sk_buff
op_star
id|next_skb
op_assign
id|skb-&gt;next
suffix:semicolon
multiline_comment|/* The first test we must make is that neither of these two&n;&t; * SKB&squot;s are still referenced by someone else.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|skb_cloned
c_func
(paren
id|skb
)paren
op_logical_and
op_logical_neg
id|skb_cloned
c_func
(paren
id|next_skb
)paren
)paren
(brace
r_int
id|skb_size
op_assign
id|skb-&gt;len
comma
id|next_skb_size
op_assign
id|next_skb-&gt;len
suffix:semicolon
id|u16
id|flags
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
suffix:semicolon
multiline_comment|/* Punt if the first SKB has URG set. */
r_if
c_cond
(paren
id|flags
op_amp
id|TCPCB_FLAG_URG
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Also punt if next skb has been SACK&squot;d. */
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|next_skb
)paren
op_member_access_from_pointer
id|sacked
op_amp
id|TCPCB_SACKED_ACKED
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Punt if not enough space exists in the first SKB for&n;&t;&t; * the data in the second, or the total combined payload&n;&t;&t; * would exceed the MSS.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|next_skb_size
OG
id|skb_tailroom
c_func
(paren
id|skb
)paren
)paren
op_logical_or
(paren
(paren
id|skb_size
op_plus
id|next_skb_size
)paren
OG
id|mss_now
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Ok.  We will be able to collapse the packet. */
id|__skb_unlink
c_func
(paren
id|next_skb
comma
id|next_skb-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
op_mod
l_int|4
)paren
(brace
multiline_comment|/* Must copy and rechecksum all data. */
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|next_skb_size
)paren
comma
id|next_skb-&gt;data
comma
id|next_skb_size
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
id|csum_partial
c_func
(paren
id|skb-&gt;data
comma
id|skb-&gt;len
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Optimize, actually we could also combine next_skb-&gt;csum&n;&t;&t;&t; * to skb-&gt;csum using a single add w/carry operation too.&n;&t;&t;&t; */
id|skb-&gt;csum
op_assign
id|csum_partial_copy
c_func
(paren
id|next_skb-&gt;data
comma
id|skb_put
c_func
(paren
id|skb
comma
id|next_skb_size
)paren
comma
id|next_skb_size
comma
id|skb-&gt;csum
)paren
suffix:semicolon
)brace
multiline_comment|/* Update sequence range on original skb. */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|next_skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
multiline_comment|/* Merge over control information. */
id|flags
op_or_assign
id|TCP_SKB_CB
c_func
(paren
id|next_skb
)paren
op_member_access_from_pointer
id|flags
suffix:semicolon
multiline_comment|/* This moves PSH/FIN etc. over */
r_if
c_cond
(paren
id|flags
op_amp
id|TCPCB_FLAG_URG
)paren
(brace
id|u16
id|urgptr
op_assign
id|TCP_SKB_CB
c_func
(paren
id|next_skb
)paren
op_member_access_from_pointer
id|urg_ptr
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
id|urgptr
op_plus
id|skb_size
suffix:semicolon
)brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_assign
id|flags
suffix:semicolon
multiline_comment|/* All done, get rid of second SKB and account for it so&n;&t;&t; * packet counting does not break.&n;&t;&t; */
id|kfree_skb
c_func
(paren
id|next_skb
)paren
suffix:semicolon
id|sk-&gt;tp_pinfo.af_tcp.packets_out
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/* Do a simple retransmit without using the backoff mechanisms in&n; * tcp_timer. This is used for path mtu discovery. &n; * The socket is already locked here.&n; */
DECL|function|tcp_simple_retransmit
r_void
id|tcp_simple_retransmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|mss
op_assign
id|tcp_current_mss
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t muck with the congestion window here. */
id|tp-&gt;dup_acks
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;high_seq
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Input control flow will see that this was retransmitted&n;&t; * and not use it for RTT calculation in the absence of&n;&t; * the timestamp option.&n;&t; */
r_for
c_loop
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
(paren
(paren
id|skb
op_ne
id|tp-&gt;send_head
)paren
op_logical_and
(paren
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
suffix:semicolon
id|skb
op_assign
id|skb-&gt;next
)paren
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|mss
)paren
id|tcp_retransmit_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
DECL|function|update_retrans_head
r_static
id|__inline__
r_void
id|update_retrans_head
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
id|tp-&gt;retrans_head
op_assign
id|tp-&gt;retrans_head-&gt;next
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;retrans_head
op_eq
id|tp-&gt;send_head
)paren
op_logical_or
(paren
id|tp-&gt;retrans_head
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
(brace
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* This retransmits one SKB.  Policy decisions and retransmit queue&n; * state updates are done by the caller.  Returns non-zero if an&n; * error occurred which prevented the send.&n; */
DECL|function|tcp_retransmit_skb
r_int
id|tcp_retransmit_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
r_int
id|cur_mss
op_assign
id|tcp_current_mss
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|cur_mss
)paren
(brace
r_if
c_cond
(paren
id|tcp_fragment
c_func
(paren
id|sk
comma
id|skb
comma
id|cur_mss
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* We&squot;ll try again later. */
multiline_comment|/* New SKB created, account for it. */
id|tp-&gt;packets_out
op_increment
suffix:semicolon
)brace
multiline_comment|/* Collapse two adjacent packets if worthwhile and we can. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_amp
id|TCPCB_FLAG_SYN
)paren
op_logical_and
(paren
id|skb-&gt;len
OL
(paren
id|cur_mss
op_rshift
l_int|1
)paren
)paren
op_logical_and
(paren
id|skb-&gt;next
op_ne
id|tp-&gt;send_head
)paren
op_logical_and
(paren
id|skb-&gt;next
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
op_logical_and
(paren
id|sysctl_tcp_retrans_collapse
op_ne
l_int|0
)paren
)paren
(brace
id|tcp_retrans_try_collapse
c_func
(paren
id|sk
comma
id|skb
comma
id|cur_mss
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;af_specific
op_member_access_from_pointer
id|rebuild_header
c_func
(paren
id|sk
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Routing failure or similar. */
multiline_comment|/* Ok, we&squot;re gonna send it out, update state. */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_or_assign
id|TCPCB_SACKED_RETRANS
suffix:semicolon
id|tp-&gt;retrans_out
op_increment
suffix:semicolon
multiline_comment|/* Make a copy, if the first transmission SKB clone we made&n;&t; * is still in somebody&squot;s hands, else make a clone.&n;&t; */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|skb_cloned
c_func
(paren
id|skb
)paren
)paren
(brace
id|skb
op_assign
id|skb_copy
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
r_else
id|skb
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* Update global TCP statistics and return success. */
id|sk-&gt;prot-&gt;retransmits
op_increment
suffix:semicolon
id|tcp_statistics.TcpRetransSegs
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This gets called after a retransmit timeout, and the initially&n; * retransmitted data is acknowledged.  It tries to continue&n; * resending the rest of the retransmit queue, until either&n; * we&squot;ve sent it all or the congestion window limit is reached.&n; * If doing SACK, the first ACK which comes back for a timeout&n; * based retransmit packet might feed us FACK information again.&n; * If so, we use it to avoid unnecessarily retransmissions.&n; */
DECL|function|tcp_xmit_retransmit_queue
r_void
id|tcp_xmit_retransmit_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;retrans_head
op_eq
l_int|NULL
)paren
id|tp-&gt;retrans_head
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;retrans_head
op_eq
id|tp-&gt;send_head
)paren
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Each time, advance the retrans_head if we got&n;&t; * a packet out or we skipped one because it was&n;&t; * SACK&squot;d.  -DaveM&n;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|tp-&gt;retrans_head
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* If it has been ack&squot;d by a SACK block, we don&squot;t&n;&t;&t; * retransmit it.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_amp
id|TCPCB_SACKED_ACKED
)paren
)paren
(brace
multiline_comment|/* Send it out, punt if error occurred. */
r_if
c_cond
(paren
id|tcp_retransmit_skb
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|update_retrans_head
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Stop retransmitting if we&squot;ve hit the congestion&n;&t;&t;&t; * window limit.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;retrans_out
op_ge
id|tp-&gt;snd_cwnd
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
id|update_retrans_head
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Using FACK information, retransmit all missing frames at the receiver&n; * up to the forward most SACK&squot;d packet (tp-&gt;fackets_out) if the packet&n; * has not been retransmitted already.&n; */
DECL|function|tcp_fack_retransmit
r_void
id|tcp_fack_retransmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
r_int
id|packet_cnt
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|skb
op_ne
id|tp-&gt;send_head
)paren
op_logical_and
(paren
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
(brace
id|__u8
id|sacked
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
suffix:semicolon
r_if
c_cond
(paren
id|sacked
op_amp
(paren
id|TCPCB_SACKED_ACKED
op_or
id|TCPCB_SACKED_RETRANS
)paren
)paren
(brace
r_goto
id|next_packet
suffix:semicolon
)brace
multiline_comment|/* Ok, retransmit it. */
r_if
c_cond
(paren
id|tcp_retransmit_skb
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tcp_packets_in_flight
c_func
(paren
id|tp
)paren
op_ge
id|tp-&gt;snd_cwnd
)paren
(brace
r_break
suffix:semicolon
)brace
id|next_packet
suffix:colon
id|packet_cnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|packet_cnt
op_ge
id|tp-&gt;fackets_out
)paren
(brace
r_break
suffix:semicolon
)brace
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/* Send a fin.  The caller locks the socket for us.  This cannot be&n; * allowed to fail queueing a FIN frame under any circumstances.&n; */
DECL|function|tcp_send_fin
r_void
id|tcp_send_fin
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|skb_peek_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
r_int
r_int
id|mss_now
suffix:semicolon
multiline_comment|/* Optimization, tack on the FIN if we have a queue of&n;&t; * unsent frames.  But be careful about outgoing SACKS&n;&t; * and IP options.&n;&t; */
id|mss_now
op_assign
id|tcp_current_mss
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;send_head
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|skb-&gt;len
OL
id|mss_now
)paren
)paren
(brace
multiline_comment|/* tcp_write_xmit() takes care of the rest. */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_or_assign
id|TCPCB_FLAG_FIN
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_increment
suffix:semicolon
id|tp-&gt;write_seq
op_increment
suffix:semicolon
multiline_comment|/* Special case to avoid Nagle bogosity.  If this&n;&t;&t; * segment is the last segment, and it was queued&n;&t;&t; * due to Nagle/SWS-avoidance, send it out now.&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;send_head
op_eq
id|skb
op_logical_and
op_logical_neg
id|sk-&gt;nonagle
op_logical_and
id|skb-&gt;len
OL
(paren
id|tp-&gt;mss_cache
op_rshift
l_int|1
)paren
op_logical_and
id|tp-&gt;packets_out
op_logical_and
op_logical_neg
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_amp
id|TCPCB_FLAG_URG
)paren
)paren
(brace
id|update_send_head
c_func
(paren
id|sk
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|jiffies
suffix:semicolon
id|tp-&gt;snd_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
id|tp-&gt;packets_out
op_increment
suffix:semicolon
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_timer_is_set
c_func
(paren
id|sk
comma
id|TIME_RETRANS
)paren
)paren
(brace
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* Socket is locked, keep trying until memory is available. */
r_do
(brace
id|skb
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
(paren
id|MAX_HEADER
op_plus
id|sk-&gt;prot-&gt;max_header
)paren
comma
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|skb
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Reserve space for headers and prepare control bits. */
id|skb_reserve
c_func
(paren
id|skb
comma
id|MAX_HEADER
op_plus
id|sk-&gt;prot-&gt;max_header
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_assign
(paren
id|TCPCB_FLAG_ACK
op_or
id|TCPCB_FLAG_FIN
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FIN eats a sequence byte, write_seq advanced by tcp_send_skb(). */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_assign
id|tp-&gt;write_seq
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_plus
l_int|1
suffix:semicolon
id|tcp_send_skb
c_func
(paren
id|sk
comma
id|skb
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* We get here when a process closes a file descriptor (either due to&n; * an explicit close() or as a byproduct of exit()&squot;ing) and there&n; * was unread data in the receive queue.  This behavior is recommended&n; * by draft-ietf-tcpimpl-prob-03.txt section 3.10.  -DaveM&n; */
DECL|function|tcp_send_active_reset
r_void
id|tcp_send_active_reset
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* NOTE: No TCP options attached and we never retransmit this. */
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|MAX_HEADER
op_plus
id|sk-&gt;prot-&gt;max_header
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
suffix:semicolon
multiline_comment|/* Reserve space for headers and prepare control bits. */
id|skb_reserve
c_func
(paren
id|skb
comma
id|MAX_HEADER
op_plus
id|sk-&gt;prot-&gt;max_header
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_assign
(paren
id|TCPCB_FLAG_ACK
op_or
id|TCPCB_FLAG_RST
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Send it off. */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_assign
id|tp-&gt;write_seq
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|jiffies
suffix:semicolon
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* WARNING: This routine must only be called when we have already sent&n; * a SYN packet that crossed the incoming SYN that caused this routine&n; * to get called. If this assumption fails then the initial rcv_wnd&n; * and rcv_wscale values will not be correct.&n; */
DECL|function|tcp_send_synack
r_int
id|tcp_send_synack
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
(paren
id|MAX_HEADER
op_plus
id|sk-&gt;prot-&gt;max_header
)paren
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Reserve space for headers and prepare control bits. */
id|skb_reserve
c_func
(paren
id|skb
comma
id|MAX_HEADER
op_plus
id|sk-&gt;prot-&gt;max_header
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_assign
(paren
id|TCPCB_FLAG_ACK
op_or
id|TCPCB_FLAG_SYN
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* SYN eats a sequence byte. */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_assign
id|tp-&gt;snd_una
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_plus
l_int|1
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|jiffies
suffix:semicolon
id|tp-&gt;packets_out
op_increment
suffix:semicolon
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Prepare a SYN-ACK.&n; */
DECL|function|tcp_make_synack
r_struct
id|sk_buff
op_star
id|tcp_make_synack
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|dst_entry
op_star
id|dst
comma
r_struct
id|open_request
op_star
id|req
comma
r_int
id|mss
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_int
id|tcp_header_size
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|MAX_HEADER
op_plus
id|sk-&gt;prot-&gt;max_header
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Reserve space for headers. */
id|skb_reserve
c_func
(paren
id|skb
comma
id|MAX_HEADER
op_plus
id|sk-&gt;prot-&gt;max_header
)paren
suffix:semicolon
id|skb-&gt;dst
op_assign
id|dst_clone
c_func
(paren
id|dst
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t offer more than they did.&n;&t; * This way we don&squot;t have to memorize who said what.&n;&t; * FIXME: maybe this should be changed for better performance&n;&t; * with syncookies.&n;&t; */
id|req-&gt;mss
op_assign
id|min
c_func
(paren
id|mss
comma
id|req-&gt;mss
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;mss
OL
l_int|8
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;initial req-&gt;mss below 8&bslash;n&quot;
)paren
suffix:semicolon
id|req-&gt;mss
op_assign
l_int|8
suffix:semicolon
)brace
id|tcp_header_size
op_assign
(paren
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
id|TCPOLEN_MSS
op_plus
(paren
id|req-&gt;tstamp_ok
ques
c_cond
id|TCPOLEN_TSTAMP_ALIGNED
suffix:colon
l_int|0
)paren
op_plus
(paren
id|req-&gt;wscale_ok
ques
c_cond
id|TCPOLEN_WSCALE_ALIGNED
suffix:colon
l_int|0
)paren
op_plus
multiline_comment|/* SACK_PERM is in the place of NOP NOP of TS */
(paren
(paren
id|req-&gt;sack_ok
op_logical_and
op_logical_neg
id|req-&gt;tstamp_ok
)paren
ques
c_cond
id|TCPOLEN_SACKPERM_ALIGNED
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|skb-&gt;h.th
op_assign
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
id|tcp_header_size
)paren
suffix:semicolon
id|memset
c_func
(paren
id|th
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|th-&gt;syn
op_assign
l_int|1
suffix:semicolon
id|th-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|th-&gt;source
op_assign
id|sk-&gt;sport
suffix:semicolon
id|th-&gt;dest
op_assign
id|req-&gt;rmt_port
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_assign
id|req-&gt;snt_isn
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_plus
l_int|1
suffix:semicolon
id|th-&gt;seq
op_assign
id|htonl
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
suffix:semicolon
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|req-&gt;rcv_isn
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rcv_wnd
op_eq
l_int|0
)paren
(brace
multiline_comment|/* ignored for retransmitted syns */
id|__u8
id|rcv_wscale
suffix:semicolon
multiline_comment|/* Set this up on the first call only */
id|req-&gt;window_clamp
op_assign
id|skb-&gt;dst-&gt;window
suffix:semicolon
id|tcp_select_initial_window
c_func
(paren
id|sock_rspace
c_func
(paren
id|sk
)paren
op_div
l_int|2
comma
id|req-&gt;mss
comma
op_amp
id|req-&gt;rcv_wnd
comma
op_amp
id|req-&gt;window_clamp
comma
id|req-&gt;wscale_ok
comma
op_amp
id|rcv_wscale
)paren
suffix:semicolon
id|req-&gt;rcv_wscale
op_assign
id|rcv_wscale
suffix:semicolon
)brace
multiline_comment|/* RFC1323: The window in SYN &amp; SYN/ACK segments is never scaled. */
id|th-&gt;window
op_assign
id|htons
c_func
(paren
id|req-&gt;rcv_wnd
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|jiffies
suffix:semicolon
id|tcp_syn_build_options
c_func
(paren
(paren
id|__u32
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
comma
id|req-&gt;mss
comma
id|req-&gt;tstamp_ok
comma
id|req-&gt;sack_ok
comma
id|req-&gt;wscale_ok
comma
id|req-&gt;rcv_wscale
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|th-&gt;doff
op_assign
(paren
id|tcp_header_size
op_rshift
l_int|2
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
DECL|function|tcp_connect
r_void
id|tcp_connect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|buff
comma
r_int
id|mtu
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|sk-&gt;dst_cache
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/* Reserve space for headers. */
id|skb_reserve
c_func
(paren
id|buff
comma
id|MAX_HEADER
op_plus
id|sk-&gt;prot-&gt;max_header
)paren
suffix:semicolon
id|tp-&gt;snd_wnd
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;snd_wl1
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;snd_wl2
op_assign
id|tp-&gt;write_seq
suffix:semicolon
id|tp-&gt;snd_una
op_assign
id|tp-&gt;write_seq
suffix:semicolon
id|tp-&gt;rcv_nxt
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We&squot;ll fix this up when we get a response from the other end.&n;&t; * See tcp_input.c:tcp_rcv_state_process case TCP_SYN_SENT.&n;&t; */
id|tp-&gt;tcp_header_len
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
(paren
id|sysctl_tcp_timestamps
ques
c_cond
id|TCPOLEN_TSTAMP_ALIGNED
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/* If user gave his TCP_MAXSEG, record it to clamp */
r_if
c_cond
(paren
id|tp-&gt;user_mss
)paren
id|tp-&gt;mss_clamp
op_assign
id|tp-&gt;user_mss
suffix:semicolon
id|tcp_sync_mss
c_func
(paren
id|sk
comma
id|mtu
)paren
suffix:semicolon
multiline_comment|/* Now unpleasant action: if initial pmtu is too low&n;&t;   set lower clamp. I am not sure that it is good.&n;&t;   To be more exact, I do not think that clamping at value, which&n;&t;   is apparently transient and may improve in future is good idea.&n;&t;   It would be better to wait until peer will returns its MSS&n;&t;   (probably 65535 too) and now advertise something sort of 65535&n;&t;   or at least first hop device mtu. Is it clear, what I mean?&n;&t;   We should tell peer what maximal mss we expect to RECEIVE,&n;&t;   it has nothing to do with pmtu.&n;&t;   I am afraid someone will be confused by such huge value.&n;&t;                                                   --ANK (980731)&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;mss_cache
op_plus
id|tp-&gt;tcp_header_len
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
OL
id|tp-&gt;mss_clamp
)paren
id|tp-&gt;mss_clamp
op_assign
id|tp-&gt;mss_cache
op_plus
id|tp-&gt;tcp_header_len
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|flags
op_assign
id|TCPCB_FLAG_SYN
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|sacked
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
l_int|0
suffix:semicolon
id|buff-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|seq
op_assign
id|tp-&gt;write_seq
op_increment
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|tp-&gt;write_seq
suffix:semicolon
id|tp-&gt;snd_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
id|tp-&gt;window_clamp
op_assign
id|dst-&gt;window
suffix:semicolon
id|tcp_select_initial_window
c_func
(paren
id|sock_rspace
c_func
(paren
id|sk
)paren
op_div
l_int|2
comma
id|tp-&gt;mss_clamp
comma
op_amp
id|tp-&gt;rcv_wnd
comma
op_amp
id|tp-&gt;window_clamp
comma
id|sysctl_tcp_window_scaling
comma
op_amp
id|tp-&gt;rcv_wscale
)paren
suffix:semicolon
multiline_comment|/* Ok, now lock the socket before we make it visible to&n;&t; * the incoming packet engine.&n;&t; */
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Socket identity change complete, no longer&n;&t; * in TCP_CLOSE, so enter ourselves into the&n;&t; * hash tables.&n;&t; */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_SYN_SENT
)paren
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|hash
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;rto
op_assign
id|dst-&gt;rtt
suffix:semicolon
id|tcp_init_xmit_timers
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;fackets_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;retrans_out
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Send it off. */
id|__skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|buff
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|when
op_assign
id|jiffies
suffix:semicolon
id|tp-&gt;packets_out
op_increment
suffix:semicolon
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|skb_clone
c_func
(paren
id|buff
comma
id|GFP_KERNEL
)paren
)paren
suffix:semicolon
id|tcp_statistics.TcpActiveOpens
op_increment
suffix:semicolon
multiline_comment|/* Timer for repeating the SYN until an answer. */
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
multiline_comment|/* Now, it is safe to release the socket. */
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* Send out a delayed ack, the caller does the policy checking&n; * to see if we should even be here.  See tcp_input.c:tcp_ack_snd_check()&n; * for details.&n; */
DECL|function|tcp_send_delayed_ack
r_void
id|tcp_send_delayed_ack
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_int
id|max_timeout
)paren
(brace
r_int
r_int
id|timeout
suffix:semicolon
multiline_comment|/* Stay within the limit we were given */
id|timeout
op_assign
id|tp-&gt;ato
suffix:semicolon
r_if
c_cond
(paren
id|timeout
OG
id|max_timeout
)paren
id|timeout
op_assign
id|max_timeout
suffix:semicolon
id|timeout
op_add_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Use new timeout only if there wasn&squot;t a older one earlier. */
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;delack_timer.prev
)paren
(brace
id|tp-&gt;delack_timer.expires
op_assign
id|timeout
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|tp-&gt;delack_timer
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|timeout
OL
id|tp-&gt;delack_timer.expires
)paren
id|mod_timer
c_func
(paren
op_amp
id|tp-&gt;delack_timer
comma
id|timeout
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This routine sends an ack and also updates the window. */
DECL|function|tcp_send_ack
r_void
id|tcp_send_ack
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
multiline_comment|/* If we have been reset, we may not send again. */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;zapped
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
multiline_comment|/* We are not putting this on the write queue, so&n;&t;&t; * tcp_transmit_skb() will set the ownership to this&n;&t;&t; * sock.&n;&t;&t; */
id|buff
op_assign
id|alloc_skb
c_func
(paren
id|MAX_HEADER
op_plus
id|sk-&gt;prot-&gt;max_header
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Force it to send an ack. We don&squot;t have to do this&n;&t;&t;&t; * (ACK is unreliable) but it&squot;s much better use of&n;&t;&t;&t; * bandwidth on slow links to send a spare ack than&n;&t;&t;&t; * resend packets.&n;&t;&t;&t; */
id|tcp_send_delayed_ack
c_func
(paren
id|tp
comma
id|HZ
op_div
l_int|2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Reserve space for headers and prepare control bits. */
id|skb_reserve
c_func
(paren
id|buff
comma
id|MAX_HEADER
op_plus
id|sk-&gt;prot-&gt;max_header
)paren
suffix:semicolon
id|buff-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|flags
op_assign
id|TCPCB_FLAG_ACK
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|sacked
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Send it off, this clears delayed acks for us. */
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|when
op_assign
id|jiffies
suffix:semicolon
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This routine sends a packet with an out of date sequence&n; * number. It assumes the other end will try to ack it.&n; */
DECL|function|tcp_write_wakeup
r_void
id|tcp_write_wakeup
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
multiline_comment|/* After a valid reset we can send no more. */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;zapped
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* Write data can still be transmitted/retransmitted in the&n;&t;&t; * following states.  If any other state is encountered, return.&n;&t;&t; * [listen/close will never occur here anyway]&n;&t;&t; */
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|sk-&gt;state
)paren
op_amp
op_complement
(paren
id|TCPF_ESTABLISHED
op_or
id|TCPF_CLOSE_WAIT
op_or
id|TCPF_FIN_WAIT1
op_or
id|TCPF_LAST_ACK
op_or
id|TCPF_CLOSING
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|before
c_func
(paren
id|tp-&gt;snd_nxt
comma
id|tp-&gt;snd_una
op_plus
id|tp-&gt;snd_wnd
)paren
op_logical_and
(paren
(paren
id|skb
op_assign
id|tp-&gt;send_head
)paren
op_ne
l_int|NULL
)paren
)paren
(brace
r_int
r_int
id|win_size
suffix:semicolon
multiline_comment|/* We are probing the opening of a window&n;&t;&t;&t; * but the window size is != 0&n;&t;&t;&t; * must have been a result SWS avoidance ( sender )&n;&t;&t;&t; */
id|win_size
op_assign
id|tp-&gt;snd_wnd
op_minus
(paren
id|tp-&gt;snd_nxt
op_minus
id|tp-&gt;snd_una
)paren
suffix:semicolon
r_if
c_cond
(paren
id|win_size
OL
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_minus
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
(brace
r_if
c_cond
(paren
id|tcp_fragment
c_func
(paren
id|sk
comma
id|skb
comma
id|win_size
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Let a retransmit get it. */
)brace
id|update_send_head
c_func
(paren
id|sk
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|jiffies
suffix:semicolon
id|tp-&gt;snd_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
id|tp-&gt;packets_out
op_increment
suffix:semicolon
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_timer_is_set
c_func
(paren
id|sk
comma
id|TIME_RETRANS
)paren
)paren
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We don&squot;t queue it, tcp_transmit_skb() sets ownership. */
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|MAX_HEADER
op_plus
id|sk-&gt;prot-&gt;max_header
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* Reserve space for headers and set control bits. */
id|skb_reserve
c_func
(paren
id|skb
comma
id|MAX_HEADER
op_plus
id|sk-&gt;prot-&gt;max_header
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_assign
id|TCPCB_FLAG_ACK
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Use a previous sequence.  This should cause the other&n;&t;&t;&t; * end to send an ack.  Don&squot;t queue or clone SKB, just&n;&t;&t;&t; * send it.&n;&t;&t;&t; */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_assign
id|tp-&gt;snd_nxt
op_minus
l_int|1
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|jiffies
suffix:semicolon
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* A window probe timeout has occurred.  If window is not closed send&n; * a partial packet else a zero probe.&n; */
DECL|function|tcp_send_probe0
r_void
id|tcp_send_probe0
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|tcp_write_wakeup
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;pending
op_assign
id|TIME_PROBE0
suffix:semicolon
id|tp-&gt;backoff
op_increment
suffix:semicolon
id|tp-&gt;probes_out
op_increment
suffix:semicolon
id|tcp_reset_xmit_timer
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|min
c_func
(paren
id|tp-&gt;rto
op_lshift
id|tp-&gt;backoff
comma
l_int|120
op_star
id|HZ
)paren
)paren
suffix:semicolon
)brace
eof
