multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Implementation of the Transmission Control Protocol(TCP).&n; *&n; * Version:&t;$Id: tcp_output.c,v 1.121 2000/02/08 21:27:19 davem Exp $&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;&n; *&t;&t;Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; */
multiline_comment|/*&n; * Changes:&t;Pedro Roque&t;:&t;Retransmit queue handled by TCP.&n; *&t;&t;&t;&t;:&t;Fragmentation on mtu decrease&n; *&t;&t;&t;&t;:&t;Segment collapse on retransmit&n; *&t;&t;&t;&t;:&t;AF independence&n; *&n; *&t;&t;Linus Torvalds&t;:&t;send_delayed_ack&n; *&t;&t;David S. Miller&t;:&t;Charge memory using the right skb&n; *&t;&t;&t;&t;&t;during syn/ack processing.&n; *&t;&t;David S. Miller :&t;Output engine completely rewritten.&n; *&t;&t;Andrea Arcangeli:&t;SYNACK carry ts_recent in tsecr.&n; *&t;&t;Cacophonix Gaul :&t;draft-minshall-nagle-01&n; *&n; */
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
multiline_comment|/* People can turn this off for buggy TCP&squot;s found in printers etc. */
DECL|variable|sysctl_tcp_retrans_collapse
r_int
id|sysctl_tcp_retrans_collapse
op_assign
l_int|1
suffix:semicolon
DECL|function|update_send_head
r_static
id|__inline__
r_void
id|update_send_head
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
id|tp-&gt;send_head
op_assign
id|tp-&gt;send_head-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;send_head
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
id|tp-&gt;send_head
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Calculate mss to advertise in SYN segment.&n; * RFC1122, RFC1063, draft-ietf-tcpimpl-pmtud-01 state that:&n; *&n; * 1. It is independent of path mtu.&n; * 2. Ideally, it is maximal possible segment size i.e. 65535-40.&n; * 3. For IPv4 it is reasonable to calculate it from maximal MTU of&n; *    attached devices, because some buggy hosts are confused by&n; *    large MSS.&n; * 4. We do not make 3, we advertise MSS, calculated from first&n; *    hop device mtu, but allow to raise it to ip_rt_min_advmss.&n; *    This may be overriden via information stored in routing table.&n; * 5. Value 65535 for MSS is valid in IPv6 and means &quot;as large as possible,&n; *    probably even Jumbo&quot;.&n; */
DECL|function|tcp_advertise_mss
r_static
id|__u16
id|tcp_advertise_mss
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|__sk_dst_get
c_func
(paren
id|sk
)paren
suffix:semicolon
r_int
id|mss
op_assign
id|tp-&gt;advmss
suffix:semicolon
r_if
c_cond
(paren
id|dst
op_logical_and
id|dst-&gt;advmss
OL
id|mss
)paren
(brace
id|mss
op_assign
id|dst-&gt;advmss
suffix:semicolon
id|tp-&gt;advmss
op_assign
id|mss
suffix:semicolon
)brace
r_return
(paren
id|__u16
)paren
id|mss
suffix:semicolon
)brace
DECL|function|tcp_event_data_sent
r_static
id|__inline__
r_void
id|tcp_event_data_sent
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* If we had a reply for ato after last received&n;&t; * packet, enter pingpong mode.&n;&t; */
r_if
c_cond
(paren
(paren
id|u32
)paren
(paren
id|tp-&gt;lsndtime
op_minus
id|tp-&gt;ack.lrcvtime
)paren
OL
id|tp-&gt;ack.ato
)paren
id|tp-&gt;ack.pingpong
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;lsndtime
op_assign
id|tcp_time_stamp
suffix:semicolon
)brace
DECL|function|tcp_event_ack_sent
r_static
id|__inline__
r_void
id|tcp_event_ack_sent
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|tcp_dec_quickack_mode
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;ack.pending
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;ack.rcv_segs
op_assign
l_int|0
suffix:semicolon
id|tcp_clear_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_DACK
)paren
suffix:semicolon
)brace
multiline_comment|/* This routine actually transmits TCP packets queued in by&n; * tcp_do_sendmsg().  This is used by both the initial&n; * transmission and possible later retransmissions.&n; * All SKB&squot;s seen here are completely headerless.  It is our&n; * job to build the TCP header, and pass the packet down to&n; * IP so it can do the same plus pass the packet off to the&n; * device.&n; *&n; * We are working here with either a clone of the original&n; * SKB, or a fresh unique copy made by the retransmit engine.&n; */
DECL|function|tcp_transmit_skb
r_int
id|tcp_transmit_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|tcp_skb_cb
op_star
id|tcb
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
suffix:semicolon
r_int
id|tcp_header_size
op_assign
id|tp-&gt;tcp_header_len
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_int
id|sysctl_flags
suffix:semicolon
r_int
id|err
suffix:semicolon
DECL|macro|SYSCTL_FLAG_TSTAMPS
mdefine_line|#define SYSCTL_FLAG_TSTAMPS&t;0x1
DECL|macro|SYSCTL_FLAG_WSCALE
mdefine_line|#define SYSCTL_FLAG_WSCALE&t;0x2
DECL|macro|SYSCTL_FLAG_SACK
mdefine_line|#define SYSCTL_FLAG_SACK&t;0x4
id|sysctl_flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tcb-&gt;flags
op_amp
id|TCPCB_FLAG_SYN
)paren
(brace
id|tcp_header_size
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
id|TCPOLEN_MSS
suffix:semicolon
r_if
c_cond
(paren
id|sysctl_tcp_timestamps
)paren
(brace
id|tcp_header_size
op_add_assign
id|TCPOLEN_TSTAMP_ALIGNED
suffix:semicolon
id|sysctl_flags
op_or_assign
id|SYSCTL_FLAG_TSTAMPS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sysctl_tcp_window_scaling
)paren
(brace
id|tcp_header_size
op_add_assign
id|TCPOLEN_WSCALE_ALIGNED
suffix:semicolon
id|sysctl_flags
op_or_assign
id|SYSCTL_FLAG_WSCALE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sysctl_tcp_sack
)paren
(brace
id|sysctl_flags
op_or_assign
id|SYSCTL_FLAG_SACK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sysctl_flags
op_amp
id|SYSCTL_FLAG_TSTAMPS
)paren
)paren
(brace
id|tcp_header_size
op_add_assign
id|TCPOLEN_SACKPERM_ALIGNED
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|tp-&gt;sack_ok
op_logical_and
id|tp-&gt;num_sacks
)paren
(brace
multiline_comment|/* A SACK is 2 pad bytes, a 2 byte header, plus&n;&t;&t;&t; * 2 32-bit sequence numbers for each SACK block.&n;&t;&t;&t; */
id|tcp_header_size
op_add_assign
(paren
id|TCPOLEN_SACK_BASE_ALIGNED
op_plus
(paren
id|tp-&gt;num_sacks
op_star
id|TCPOLEN_SACK_PERBLOCK
)paren
)paren
suffix:semicolon
)brace
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
id|tcp_header_size
)paren
suffix:semicolon
id|skb-&gt;h.th
op_assign
id|th
suffix:semicolon
id|skb_set_owner_w
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/* Build TCP header and checksum it. */
id|th-&gt;source
op_assign
id|sk-&gt;sport
suffix:semicolon
id|th-&gt;dest
op_assign
id|sk-&gt;dport
suffix:semicolon
id|th-&gt;seq
op_assign
id|htonl
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
suffix:semicolon
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|tp-&gt;rcv_nxt
)paren
suffix:semicolon
id|th-&gt;doff
op_assign
(paren
id|tcp_header_size
op_rshift
l_int|2
)paren
suffix:semicolon
id|th-&gt;res1
op_assign
l_int|0
suffix:semicolon
op_star
(paren
(paren
(paren
id|__u8
op_star
)paren
id|th
)paren
op_plus
l_int|13
)paren
op_assign
id|tcb-&gt;flags
suffix:semicolon
id|th-&gt;check
op_assign
l_int|0
suffix:semicolon
id|th-&gt;urg_ptr
op_assign
id|ntohs
c_func
(paren
id|tcb-&gt;urg_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcb-&gt;flags
op_amp
id|TCPCB_FLAG_SYN
)paren
(brace
multiline_comment|/* RFC1323: The window in SYN &amp; SYN/ACK segments&n;&t;&t;&t; * is never scaled.&n;&t;&t;&t; */
id|th-&gt;window
op_assign
id|htons
c_func
(paren
id|tp-&gt;rcv_wnd
)paren
suffix:semicolon
id|tcp_syn_build_options
c_func
(paren
(paren
id|__u32
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
comma
id|tcp_advertise_mss
c_func
(paren
id|sk
)paren
comma
(paren
id|sysctl_flags
op_amp
id|SYSCTL_FLAG_TSTAMPS
)paren
comma
(paren
id|sysctl_flags
op_amp
id|SYSCTL_FLAG_SACK
)paren
comma
(paren
id|sysctl_flags
op_amp
id|SYSCTL_FLAG_WSCALE
)paren
comma
id|tp-&gt;rcv_wscale
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
comma
id|tp-&gt;ts_recent
)paren
suffix:semicolon
)brace
r_else
(brace
id|th-&gt;window
op_assign
id|htons
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|tcp_build_and_update_options
c_func
(paren
(paren
id|__u32
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
comma
id|tp
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
)paren
suffix:semicolon
)brace
id|tp-&gt;af_specific
op_member_access_from_pointer
id|send_check
c_func
(paren
id|sk
comma
id|th
comma
id|skb-&gt;len
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;ack
)paren
id|tcp_event_ack_sent
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
op_ne
id|tcp_header_size
)paren
id|tcp_event_data_sent
c_func
(paren
id|tp
comma
id|skb
)paren
suffix:semicolon
id|TCP_INC_STATS
c_func
(paren
id|TcpOutSegs
)paren
suffix:semicolon
id|err
op_assign
id|tp-&gt;af_specific
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_le
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|tcp_enter_cong_avoid
c_func
(paren
id|tp
)paren
suffix:semicolon
multiline_comment|/* NET_XMIT_CN is special. It does not guarantee,&n;&t;&t; * that this packet is lost. It tells that device&n;&t;&t; * is about to start to drop packets or already&n;&t;&t; * drops some packets of the same priority and&n;&t;&t; * invokes us to send less aggressively.&n;&t;&t; */
r_return
id|err
op_eq
id|NET_XMIT_CN
ques
c_cond
l_int|0
suffix:colon
id|err
suffix:semicolon
)brace
r_return
op_minus
id|ENOBUFS
suffix:semicolon
DECL|macro|SYSCTL_FLAG_TSTAMPS
macro_line|#undef SYSCTL_FLAG_TSTAMPS
DECL|macro|SYSCTL_FLAG_WSCALE
macro_line|#undef SYSCTL_FLAG_WSCALE
DECL|macro|SYSCTL_FLAG_SACK
macro_line|#undef SYSCTL_FLAG_SACK
)brace
multiline_comment|/* This is the main buffer sending routine. We queue the buffer&n; * and decide whether to queue or transmit now.&n; *&n; * NOTE: probe0 timer is not checked, do not forget tcp_push_pending_frames,&n; * otherwise socket can stall.&n; */
DECL|function|tcp_send_skb
r_void
id|tcp_send_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|force_queue
comma
r_int
id|cur_mss
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/* Advance write_seq and place onto the write_queue. */
id|tp-&gt;write_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|force_queue
op_logical_and
id|tp-&gt;send_head
op_eq
l_int|NULL
op_logical_and
id|tcp_snd_test
c_func
(paren
id|tp
comma
id|skb
comma
id|cur_mss
comma
l_int|1
)paren
)paren
(brace
multiline_comment|/* Send it out now. */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|tcp_time_stamp
suffix:semicolon
r_if
c_cond
(paren
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|tp-&gt;snd_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
id|tcp_minshall_update
c_func
(paren
id|tp
comma
id|cur_mss
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|tp-&gt;packets_out
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_timer_is_set
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
)paren
)paren
(brace
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Queue it, remembering where we must start sending. */
r_if
c_cond
(paren
id|tp-&gt;send_head
op_eq
l_int|NULL
)paren
id|tp-&gt;send_head
op_assign
id|skb
suffix:semicolon
)brace
multiline_comment|/* Function to create two new TCP segments.  Shrinks the given segment&n; * to the specified size and appends a new segment with the rest of the&n; * packet to the list.  This won&squot;t be called frequently, I hope. &n; * Remember, these are still headerless SKBs at this point.&n; */
DECL|function|tcp_fragment
r_static
r_int
id|tcp_fragment
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
id|u32
id|len
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_int
id|nsize
op_assign
id|skb-&gt;len
op_minus
id|len
suffix:semicolon
id|u16
id|flags
suffix:semicolon
multiline_comment|/* Get a new skb... force flag on. */
id|buff
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
(paren
id|nsize
op_plus
id|MAX_TCP_HEADER
op_plus
l_int|15
)paren
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* We&squot;ll just try again later. */
multiline_comment|/* Reserve space for headers. */
id|skb_reserve
c_func
(paren
id|buff
comma
id|MAX_TCP_HEADER
)paren
suffix:semicolon
multiline_comment|/* Correct the sequence numbers. */
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_plus
id|len
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
multiline_comment|/* PSH and FIN should only be set in the second packet. */
id|flags
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_assign
id|flags
op_amp
op_complement
(paren
id|TCPCB_FLAG_FIN
op_or
id|TCPCB_FLAG_PSH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|TCPCB_FLAG_URG
)paren
(brace
id|u16
id|old_urg_ptr
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|urg_ptr
suffix:semicolon
multiline_comment|/* Urgent data is always a pain in the ass. */
r_if
c_cond
(paren
id|old_urg_ptr
OG
id|len
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_and_assign
op_complement
(paren
id|TCPCB_FLAG_URG
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
id|old_urg_ptr
op_minus
id|len
suffix:semicolon
)brace
r_else
(brace
id|flags
op_and_assign
op_complement
(paren
id|TCPCB_FLAG_URG
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|TCPCB_FLAG_URG
)paren
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
l_int|0
suffix:semicolon
)brace
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|flags
op_assign
id|flags
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|sacked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Copy and checksum data tail into the new buffer. */
id|buff-&gt;csum
op_assign
id|csum_partial_copy_nocheck
c_func
(paren
id|skb-&gt;data
op_plus
id|len
comma
id|skb_put
c_func
(paren
id|buff
comma
id|nsize
)paren
comma
id|nsize
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* This takes care of the FIN sequence number too. */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Rechecksum original buffer. */
id|skb-&gt;csum
op_assign
id|csum_partial
c_func
(paren
id|skb-&gt;data
comma
id|skb-&gt;len
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Looks stupid, but our code really uses when of&n;&t; * skbs, which it never sent before. --ANK&n;&t; *&n;&t; * NOTE: several days after I added this, Dave repaired&n;&t; * tcp_simple_retransmit() and it should not use -&gt;when&n;&t; * of never sent skbs more. I am not sure, so that&n;&t; * this line remains until more careful investigation. --ANK&n;&t; */
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|when
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
suffix:semicolon
multiline_comment|/* Link BUFF into the send queue. */
id|__skb_append
c_func
(paren
id|skb
comma
id|buff
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function synchronize snd mss to current pmtu/exthdr set.&n;&n;   tp-&gt;user_mss is mss set by user by TCP_MAXSEG. It does NOT counts&n;   for TCP options, but includes only bare TCP header.&n;&n;   tp-&gt;mss_clamp is mss negotiated at connection setup.&n;   It is minumum of user_mss and mss received with SYN.&n;   It also does not include TCP options.&n;&n;   tp-&gt;pmtu_cookie is last pmtu, seen by this function.&n;&n;   tp-&gt;mss_cache is current effective sending mss, including&n;   all tcp options except for SACKs. It is evaluated,&n;   taking into account current pmtu, but never exceeds&n;   tp-&gt;mss_clamp.&n;&n;   NOTE1. rfc1122 clearly states that advertised MSS&n;   DOES NOT include either tcp or ip options.&n;&n;   NOTE2. tp-&gt;pmtu_cookie and tp-&gt;mss_cache are READ ONLY outside&n;   this function.&t;&t;&t;--ANK (980731)&n; */
DECL|function|tcp_sync_mss
r_int
id|tcp_sync_mss
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|pmtu
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_int
id|mss_now
suffix:semicolon
multiline_comment|/* Calculate base mss without TCP options:&n;&t;   It is MMS_S - sizeof(tcphdr) of rfc1122&n;&t; */
id|mss_now
op_assign
id|pmtu
op_minus
id|tp-&gt;af_specific-&gt;net_header_len
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
multiline_comment|/* Clamp it (mss_clamp does not include tcp options) */
r_if
c_cond
(paren
id|mss_now
OG
id|tp-&gt;mss_clamp
)paren
id|mss_now
op_assign
id|tp-&gt;mss_clamp
suffix:semicolon
multiline_comment|/* Now subtract optional transport overhead */
id|mss_now
op_sub_assign
id|tp-&gt;ext_header_len
suffix:semicolon
multiline_comment|/* Then reserve room for full set of TCP options and 8 bytes of data */
r_if
c_cond
(paren
id|mss_now
OL
l_int|48
)paren
id|mss_now
op_assign
l_int|48
suffix:semicolon
multiline_comment|/* Now subtract TCP options size, not including SACKs */
id|mss_now
op_sub_assign
id|tp-&gt;tcp_header_len
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
multiline_comment|/* Bound mss with half of window */
r_if
c_cond
(paren
id|tp-&gt;max_window
op_logical_and
id|mss_now
OG
(paren
id|tp-&gt;max_window
op_rshift
l_int|1
)paren
)paren
id|mss_now
op_assign
id|max
c_func
(paren
(paren
id|tp-&gt;max_window
op_rshift
l_int|1
)paren
comma
l_int|68
op_minus
id|tp-&gt;tcp_header_len
)paren
suffix:semicolon
multiline_comment|/* And store cached results */
id|tp-&gt;pmtu_cookie
op_assign
id|pmtu
suffix:semicolon
id|tp-&gt;mss_cache
op_assign
id|mss_now
suffix:semicolon
r_return
id|mss_now
suffix:semicolon
)brace
multiline_comment|/* This routine writes packets to the network.  It advances the&n; * send_head.  This happens as incoming acks open up the remote&n; * window for us.&n; *&n; * Returns 1, if no segments are in flight and we have queued segments, but&n; * cannot send anything now because of SWS or another problem.&n; */
DECL|function|tcp_write_xmit
r_int
id|tcp_write_xmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
r_int
id|mss_now
suffix:semicolon
multiline_comment|/* If we are closed, the bytes will have to remain here.&n;&t; * In time closedown will finish, we empty the write queue and all&n;&t; * will be happy.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_CLOSE
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|sent_pkts
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Account for SACKS, we may need to fragment due to this.&n;&t;&t; * It is just like the real MSS changing on us midstream.&n;&t;&t; * We also handle things correctly when the user adds some&n;&t;&t; * IP options mid-stream.  Silly to do, but cover it.&n;&t;&t; */
id|mss_now
op_assign
id|tcp_current_mss
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Anything on the transmit queue that fits the window can&n;&t;&t; * be added providing we are:&n;&t;&t; *&n;&t;&t; * a) following SWS avoidance [and Nagle algorithm]&n;&t;&t; * b) not exceeding our congestion window.&n;&t;&t; * c) not retransmitting [Nagle]&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|tp-&gt;send_head
)paren
op_logical_and
id|tcp_snd_test
c_func
(paren
id|tp
comma
id|skb
comma
id|mss_now
comma
id|tcp_skb_is_last
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|mss_now
)paren
(brace
r_if
c_cond
(paren
id|tcp_fragment
c_func
(paren
id|sk
comma
id|skb
comma
id|mss_now
)paren
)paren
r_break
suffix:semicolon
)brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|tcp_time_stamp
suffix:semicolon
r_if
c_cond
(paren
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Advance the send_head.  This one is sent out. */
id|update_send_head
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;snd_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
id|tcp_minshall_update
c_func
(paren
id|tp
comma
id|mss_now
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|tp-&gt;packets_out
op_increment
suffix:semicolon
id|sent_pkts
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If we sent anything, make sure the retransmit&n;&t;&t; * timer is active.&n;&t;&t; */
r_if
c_cond
(paren
id|sent_pkts
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tcp_timer_is_set
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
)paren
)paren
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_logical_neg
id|tp-&gt;packets_out
op_logical_and
id|tp-&gt;send_head
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function returns the amount that we can raise the&n; * usable window based on the following constraints&n; *  &n; * 1. The window can never be shrunk once it is offered (RFC 793)&n; * 2. We limit memory per socket&n; *&n; * RFC 1122:&n; * &quot;the suggested [SWS] avoidance algorithm for the receiver is to keep&n; *  RECV.NEXT + RCV.WIN fixed until:&n; *  RCV.BUFF - RCV.USER - RCV.WINDOW &gt;= min(1/2 RCV.BUFF, MSS)&quot;&n; *&n; * i.e. don&squot;t raise the right edge of the window until you can raise&n; * it at least MSS bytes.&n; *&n; * Unfortunately, the recommended algorithm breaks header prediction,&n; * since header prediction assumes th-&gt;window stays fixed.&n; *&n; * Strictly speaking, keeping th-&gt;window fixed violates the receiver&n; * side SWS prevention criteria. The problem is that under this rule&n; * a stream of single byte packets will cause the right side of the&n; * window to always advance by a single byte.&n; * &n; * Of course, if the sender implements sender side SWS prevention&n; * then this will not be a problem.&n; * &n; * BSD seems to make the following compromise:&n; * &n; *&t;If the free space is less than the 1/4 of the maximum&n; *&t;space available and the free space is less than 1/2 mss,&n; *&t;then set the window to 0.&n; *&t;Otherwise, just prevent the window from shrinking&n; *&t;and from being larger than the largest representable value.&n; *&n; * This prevents incremental opening of the window in the regime&n; * where TCP is limited by the speed of the reader side taking&n; * data out of the TCP receive queue. It does nothing about&n; * those cases where the window is constrained on the sender side&n; * because the pipeline is full.&n; *&n; * BSD also seems to &quot;accidentally&quot; limit itself to windows that are a&n; * multiple of MSS, at least until the free space gets quite small.&n; * This would appear to be a side effect of the mbuf implementation.&n; * Combining these two algorithms results in the observed behavior&n; * of having a fixed window size at almost all times.&n; *&n; * Below we obtain similar behavior by forcing the offered window to&n; * a multiple of the mss when it is feasible to do so.&n; *&n; * Note, we don&squot;t &quot;adjust&quot; for TIMESTAMP or SACK option bytes.&n; * Regular options like TIMESTAMP are taken into account.&n; */
DECL|function|__tcp_select_window
id|u32
id|__tcp_select_window
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
multiline_comment|/* MSS for the peer&squot;s data.  Previous verions used mss_clamp&n;&t; * here.  I don&squot;t know if the value based on our guesses&n;&t; * of peer&squot;s MSS is better for the performance.  It&squot;s more correct&n;&t; * but may be worse for the performance because of rcv_mss&n;&t; * fluctuations.  --SAW  1998/11/1&n;&t; */
r_int
r_int
id|mss
op_assign
id|tp-&gt;ack.rcv_mss
suffix:semicolon
r_int
id|free_space
suffix:semicolon
id|u32
id|window
suffix:semicolon
multiline_comment|/* Sometimes free_space can be &lt; 0. */
id|free_space
op_assign
id|tcp_space
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free_space
OG
(paren
(paren
r_int
)paren
id|tp-&gt;window_clamp
)paren
)paren
id|free_space
op_assign
id|tp-&gt;window_clamp
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;window_clamp
OL
id|mss
)paren
id|mss
op_assign
id|tp-&gt;window_clamp
suffix:semicolon
r_if
c_cond
(paren
id|free_space
OL
id|min
c_func
(paren
(paren
r_int
)paren
id|tp-&gt;window_clamp
comma
id|tcp_full_space
c_func
(paren
id|sk
)paren
)paren
op_div
l_int|2
)paren
(brace
multiline_comment|/* THIS IS _VERY_ GOOD PLACE to play window clamp.&n;&t;&t; * if free_space becomes suspiciously low&n;&t;&t; * verify ratio rmem_alloc/(rcv_nxt - copied_seq),&n;&t;&t; * and if we predict that when free_space will be lower mss,&n;&t;&t; * rmem_alloc will run out of rcvbuf*2, shrink window_clamp.&n;&t;&t; * It will eliminate most of prune events! Very simple,&n;&t;&t; * it is the next thing to do.&t;&t;&t;--ANK&n;&t;&t; *&n;&t;&t; * Provided we found a way to raise it back...  --ANK&n;&t;&t; */
id|tp-&gt;ack.quick
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|free_space
OL
(paren
(paren
r_int
)paren
(paren
id|mss
op_div
l_int|2
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the largest window that is a nice multiple of mss.&n;&t; * Window clamp already applied above.&n;&t; * If our current window offering is within 1 mss of the&n;&t; * free space we just keep it. This prevents the divide&n;&t; * and multiply from happening most of the time.&n;&t; * We also don&squot;t do any window rounding when the free space&n;&t; * is too small.&n;&t; */
id|window
op_assign
id|tp-&gt;rcv_wnd
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
(paren
r_int
)paren
id|window
)paren
op_le
(paren
id|free_space
op_minus
(paren
(paren
r_int
)paren
id|mss
)paren
)paren
)paren
op_logical_or
(paren
(paren
(paren
r_int
)paren
id|window
)paren
OG
id|free_space
)paren
)paren
id|window
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|free_space
)paren
op_div
id|mss
)paren
op_star
id|mss
suffix:semicolon
r_return
id|window
suffix:semicolon
)brace
multiline_comment|/* Attempt to collapse two adjacent SKB&squot;s during retransmission. */
DECL|function|tcp_retrans_try_collapse
r_static
r_void
id|tcp_retrans_try_collapse
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|mss_now
)paren
(brace
r_struct
id|sk_buff
op_star
id|next_skb
op_assign
id|skb-&gt;next
suffix:semicolon
multiline_comment|/* The first test we must make is that neither of these two&n;&t; * SKB&squot;s are still referenced by someone else.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|skb_cloned
c_func
(paren
id|skb
)paren
op_logical_and
op_logical_neg
id|skb_cloned
c_func
(paren
id|next_skb
)paren
)paren
(brace
r_int
id|skb_size
op_assign
id|skb-&gt;len
comma
id|next_skb_size
op_assign
id|next_skb-&gt;len
suffix:semicolon
id|u16
id|flags
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
suffix:semicolon
multiline_comment|/* Punt if the first SKB has URG set. */
r_if
c_cond
(paren
id|flags
op_amp
id|TCPCB_FLAG_URG
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Also punt if next skb has been SACK&squot;d. */
r_if
c_cond
(paren
id|TCP_SKB_CB
c_func
(paren
id|next_skb
)paren
op_member_access_from_pointer
id|sacked
op_amp
id|TCPCB_SACKED_ACKED
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Punt if not enough space exists in the first SKB for&n;&t;&t; * the data in the second, or the total combined payload&n;&t;&t; * would exceed the MSS.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|next_skb_size
OG
id|skb_tailroom
c_func
(paren
id|skb
)paren
)paren
op_logical_or
(paren
(paren
id|skb_size
op_plus
id|next_skb_size
)paren
OG
id|mss_now
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Ok.  We will be able to collapse the packet. */
id|__skb_unlink
c_func
(paren
id|next_skb
comma
id|next_skb-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
op_mod
l_int|4
)paren
(brace
multiline_comment|/* Must copy and rechecksum all data. */
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|next_skb_size
)paren
comma
id|next_skb-&gt;data
comma
id|next_skb_size
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
id|csum_partial
c_func
(paren
id|skb-&gt;data
comma
id|skb-&gt;len
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Optimize, actually we could also combine next_skb-&gt;csum&n;&t;&t;&t; * to skb-&gt;csum using a single add w/carry operation too.&n;&t;&t;&t; */
id|skb-&gt;csum
op_assign
id|csum_partial_copy_nocheck
c_func
(paren
id|next_skb-&gt;data
comma
id|skb_put
c_func
(paren
id|skb
comma
id|next_skb_size
)paren
comma
id|next_skb_size
comma
id|skb-&gt;csum
)paren
suffix:semicolon
)brace
multiline_comment|/* Update sequence range on original skb. */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|next_skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
multiline_comment|/* Merge over control information. */
id|flags
op_or_assign
id|TCP_SKB_CB
c_func
(paren
id|next_skb
)paren
op_member_access_from_pointer
id|flags
suffix:semicolon
multiline_comment|/* This moves PSH/FIN etc. over */
r_if
c_cond
(paren
id|flags
op_amp
id|TCPCB_FLAG_URG
)paren
(brace
id|u16
id|urgptr
op_assign
id|TCP_SKB_CB
c_func
(paren
id|next_skb
)paren
op_member_access_from_pointer
id|urg_ptr
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
id|urgptr
op_plus
id|skb_size
suffix:semicolon
)brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_assign
id|flags
suffix:semicolon
multiline_comment|/* All done, get rid of second SKB and account for it so&n;&t;&t; * packet counting does not break.&n;&t;&t; */
id|kfree_skb
c_func
(paren
id|next_skb
)paren
suffix:semicolon
id|sk-&gt;tp_pinfo.af_tcp.packets_out
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/* Do a simple retransmit without using the backoff mechanisms in&n; * tcp_timer. This is used for path mtu discovery. &n; * The socket is already locked here.&n; */
DECL|function|tcp_simple_retransmit
r_void
id|tcp_simple_retransmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
comma
op_star
id|old_next_skb
suffix:semicolon
r_int
r_int
id|mss
op_assign
id|tcp_current_mss
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t muck with the congestion window here. */
id|tp-&gt;dup_acks
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;high_seq
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Input control flow will see that this was retransmitted&n;&t; * and not use it for RTT calculation in the absence of&n;&t; * the timestamp option.&n;&t; */
r_for
c_loop
(paren
id|old_next_skb
op_assign
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
(paren
(paren
id|skb
op_ne
id|tp-&gt;send_head
)paren
op_logical_and
(paren
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
suffix:semicolon
id|skb
op_assign
id|skb-&gt;next
)paren
(brace
r_int
id|resend_skb
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Our goal is to push out the packets which we&n;&t;&t; * sent already, but are being chopped up now to&n;&t;&t; * account for the PMTU information we have.&n;&t;&t; *&n;&t;&t; * As we resend the queue, packets are fragmented&n;&t;&t; * into two pieces, and when we try to send the&n;&t;&t; * second piece it may be collapsed together with&n;&t;&t; * a subsequent packet, and so on.  -DaveM&n;&t;&t; */
r_if
c_cond
(paren
id|old_next_skb
op_ne
id|skb
op_logical_or
id|skb-&gt;len
OG
id|mss
)paren
id|resend_skb
op_assign
l_int|1
suffix:semicolon
id|old_next_skb
op_assign
id|skb-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|resend_skb
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|tcp_retransmit_skb
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
DECL|function|update_retrans_head
r_static
id|__inline__
r_void
id|update_retrans_head
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
id|tp-&gt;retrans_head
op_assign
id|tp-&gt;retrans_head-&gt;next
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;retrans_head
op_eq
id|tp-&gt;send_head
)paren
op_logical_or
(paren
id|tp-&gt;retrans_head
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
(brace
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
id|tp-&gt;rexmt_done
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* This retransmits one SKB.  Policy decisions and retransmit queue&n; * state updates are done by the caller.  Returns non-zero if an&n; * error occurred which prevented the send.&n; */
DECL|function|tcp_retransmit_skb
r_int
id|tcp_retransmit_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
r_int
id|cur_mss
op_assign
id|tcp_current_mss
c_func
(paren
id|sk
)paren
suffix:semicolon
macro_line|#ifdef TCP_DEBUG
multiline_comment|/* It was possible this summer, that retransmit timer&n;&t; * raced with its deletion and hit socket with packets_out==0.&n;&t; * I fixed it, but preserved the check in the place,&n;&t; * where the fault occured. --ANK&n;&t; */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tcp_retransmit_skb: bug, skb==NULL, caller=%p&bslash;n&quot;
comma
id|NET_CALLER
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|cur_mss
)paren
(brace
r_if
c_cond
(paren
id|tcp_fragment
c_func
(paren
id|sk
comma
id|skb
comma
id|cur_mss
)paren
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* We&squot;ll try again later. */
multiline_comment|/* New SKB created, account for it. */
id|tp-&gt;packets_out
op_increment
suffix:semicolon
)brace
multiline_comment|/* Collapse two adjacent packets if worthwhile and we can. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_amp
id|TCPCB_FLAG_SYN
)paren
op_logical_and
(paren
id|skb-&gt;len
OL
(paren
id|cur_mss
op_rshift
l_int|1
)paren
)paren
op_logical_and
(paren
id|skb-&gt;next
op_ne
id|tp-&gt;send_head
)paren
op_logical_and
(paren
id|skb-&gt;next
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
op_logical_and
(paren
id|sysctl_tcp_retrans_collapse
op_ne
l_int|0
)paren
)paren
(brace
id|tcp_retrans_try_collapse
c_func
(paren
id|sk
comma
id|skb
comma
id|cur_mss
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;af_specific
op_member_access_from_pointer
id|rebuild_header
c_func
(paren
id|sk
)paren
)paren
(brace
r_return
op_minus
id|EHOSTUNREACH
suffix:semicolon
)brace
multiline_comment|/* Routing failure or similar. */
multiline_comment|/* Some Solaris stacks overoptimize and ignore the FIN on a&n;&t; * retransmit when old data is attached.  So strip it off&n;&t; * since it is cheap to do so and saves bytes on the network.&n;&t; */
r_if
c_cond
(paren
id|skb-&gt;len
OG
l_int|0
op_logical_and
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_amp
id|TCPCB_FLAG_FIN
)paren
op_logical_and
id|tp-&gt;snd_una
op_eq
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_minus
l_int|1
)paren
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_minus
l_int|1
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Ok, we&squot;re gonna send it out, update state. */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_or_assign
id|TCPCB_SACKED_RETRANS
suffix:semicolon
id|tp-&gt;retrans_out
op_increment
suffix:semicolon
multiline_comment|/* Make a copy, if the first transmission SKB clone we made&n;&t; * is still in somebody&squot;s hands, else make a clone.&n;&t; */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|tcp_time_stamp
suffix:semicolon
r_if
c_cond
(paren
id|skb_cloned
c_func
(paren
id|skb
)paren
)paren
(brace
id|skb
op_assign
id|skb_copy
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
r_else
id|skb
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
multiline_comment|/* Update global TCP statistics and return success. */
id|TCP_INC_STATS
c_func
(paren
id|TcpRetransSegs
)paren
suffix:semicolon
r_return
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* This gets called after a retransmit timeout, and the initially&n; * retransmitted data is acknowledged.  It tries to continue&n; * resending the rest of the retransmit queue, until either&n; * we&squot;ve sent it all or the congestion window limit is reached.&n; * If doing SACK, the first ACK which comes back for a timeout&n; * based retransmit packet might feed us FACK information again.&n; * If so, we use it to avoid unnecessarily retransmissions.&n; */
DECL|function|tcp_xmit_retransmit_queue
r_void
id|tcp_xmit_retransmit_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;retrans_head
op_eq
l_int|NULL
op_logical_and
id|tp-&gt;rexmt_done
op_eq
l_int|0
)paren
id|tp-&gt;retrans_head
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;retrans_head
op_eq
id|tp-&gt;send_head
)paren
id|tp-&gt;retrans_head
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Each time, advance the retrans_head if we got&n;&t; * a packet out or we skipped one because it was&n;&t; * SACK&squot;d.  -DaveM&n;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|tp-&gt;retrans_head
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* If it has been ack&squot;d by a SACK block, we don&squot;t&n;&t;&t; * retransmit it.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_amp
id|TCPCB_SACKED_ACKED
)paren
)paren
(brace
multiline_comment|/* Send it out, punt if error occurred. */
r_if
c_cond
(paren
id|tcp_retransmit_skb
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|update_retrans_head
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Stop retransmitting if we&squot;ve hit the congestion&n;&t;&t;&t; * window limit.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;retrans_out
op_ge
id|tp-&gt;snd_cwnd
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
id|update_retrans_head
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Using FACK information, retransmit all missing frames at the receiver&n; * up to the forward most SACK&squot;d packet (tp-&gt;fackets_out) if the packet&n; * has not been retransmitted already.&n; */
DECL|function|tcp_fack_retransmit
r_void
id|tcp_fack_retransmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
r_int
id|packet_cnt
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|skb
op_ne
id|tp-&gt;send_head
)paren
op_logical_and
(paren
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
(brace
id|__u8
id|sacked
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
suffix:semicolon
r_if
c_cond
(paren
id|sacked
op_amp
(paren
id|TCPCB_SACKED_ACKED
op_or
id|TCPCB_SACKED_RETRANS
)paren
)paren
(brace
r_goto
id|next_packet
suffix:semicolon
)brace
multiline_comment|/* Ok, retransmit it. */
r_if
c_cond
(paren
id|tcp_retransmit_skb
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tcp_packets_in_flight
c_func
(paren
id|tp
)paren
op_ge
id|tp-&gt;snd_cwnd
)paren
(brace
r_break
suffix:semicolon
)brace
id|next_packet
suffix:colon
id|packet_cnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|packet_cnt
op_ge
id|tp-&gt;fackets_out
)paren
(brace
r_break
suffix:semicolon
)brace
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/* Send a fin.  The caller locks the socket for us.  This cannot be&n; * allowed to fail queueing a FIN frame under any circumstances.&n; */
DECL|function|tcp_send_fin
r_void
id|tcp_send_fin
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|skb_peek_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
r_int
r_int
id|mss_now
suffix:semicolon
multiline_comment|/* Optimization, tack on the FIN if we have a queue of&n;&t; * unsent frames.  But be careful about outgoing SACKS&n;&t; * and IP options.&n;&t; */
id|mss_now
op_assign
id|tcp_current_mss
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Please, find seven differences of 2.3.33 and loook&n;&t; * what I broke here. 8) --ANK&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;send_head
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* tcp_write_xmit() takes care of the rest. */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_or_assign
id|TCPCB_FLAG_FIN
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_increment
suffix:semicolon
id|tp-&gt;write_seq
op_increment
suffix:semicolon
multiline_comment|/* Special case to avoid Nagle bogosity.  If this&n;&t;&t; * segment is the last segment, and it was queued&n;&t;&t; * due to Nagle/SWS-avoidance, send it out now.&n;&t;&t; *&n;&t;&t; * Hmm... actually it overrides also congestion&n;&t;&t; * avoidance (OK for FIN) and retransmit phase&n;&t;&t; * (not OK? Added.).&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;send_head
op_eq
id|skb
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|tp-&gt;write_seq
comma
id|tp-&gt;snd_una
op_plus
id|tp-&gt;snd_wnd
)paren
op_logical_and
op_logical_neg
id|tp-&gt;retransmits
)paren
(brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|tcp_time_stamp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|update_send_head
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;snd_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
id|tp-&gt;packets_out
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_timer_is_set
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
)paren
)paren
(brace
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
)brace
r_else
id|tcp_check_probe_timer
c_func
(paren
id|sk
comma
id|tp
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Socket is locked, keep trying until memory is available. */
r_do
(brace
id|skb
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|MAX_TCP_HEADER
op_plus
l_int|15
comma
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|skb
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Reserve space for headers and prepare control bits. */
id|skb_reserve
c_func
(paren
id|skb
comma
id|MAX_TCP_HEADER
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_assign
(paren
id|TCPCB_FLAG_ACK
op_or
id|TCPCB_FLAG_FIN
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FIN eats a sequence byte, write_seq advanced by tcp_send_skb(). */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_assign
id|tp-&gt;write_seq
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_plus
l_int|1
suffix:semicolon
id|tcp_send_skb
c_func
(paren
id|sk
comma
id|skb
comma
l_int|0
comma
id|mss_now
)paren
suffix:semicolon
id|__tcp_push_pending_frames
c_func
(paren
id|sk
comma
id|tp
comma
id|mss_now
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* We get here when a process closes a file descriptor (either due to&n; * an explicit close() or as a byproduct of exit()&squot;ing) and there&n; * was unread data in the receive queue.  This behavior is recommended&n; * by draft-ietf-tcpimpl-prob-03.txt section 3.10.  -DaveM&n; */
DECL|function|tcp_send_active_reset
r_void
id|tcp_send_active_reset
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|priority
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* NOTE: No TCP options attached and we never retransmit this. */
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|MAX_TCP_HEADER
op_plus
l_int|15
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
suffix:semicolon
multiline_comment|/* Reserve space for headers and prepare control bits. */
id|skb_reserve
c_func
(paren
id|skb
comma
id|MAX_TCP_HEADER
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_assign
(paren
id|TCPCB_FLAG_ACK
op_or
id|TCPCB_FLAG_RST
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Send it off. */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|tcp_time_stamp
suffix:semicolon
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* WARNING: This routine must only be called when we have already sent&n; * a SYN packet that crossed the incoming SYN that caused this routine&n; * to get called. If this assumption fails then the initial rcv_wnd&n; * and rcv_wscale values will not be correct.&n; */
DECL|function|tcp_send_synack
r_int
id|tcp_send_synack
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|MAX_TCP_HEADER
op_plus
l_int|15
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Reserve space for headers and prepare control bits. */
id|skb_reserve
c_func
(paren
id|skb
comma
id|MAX_TCP_HEADER
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_assign
(paren
id|TCPCB_FLAG_ACK
op_or
id|TCPCB_FLAG_SYN
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* SYN eats a sequence byte. */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_assign
id|tp-&gt;snd_una
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_plus
l_int|1
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|tcp_time_stamp
suffix:semicolon
id|tp-&gt;packets_out
op_increment
suffix:semicolon
r_return
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Prepare a SYN-ACK.&n; */
DECL|function|tcp_make_synack
r_struct
id|sk_buff
op_star
id|tcp_make_synack
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|dst_entry
op_star
id|dst
comma
r_struct
id|open_request
op_star
id|req
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_int
id|tcp_header_size
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|MAX_TCP_HEADER
op_plus
l_int|15
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Reserve space for headers. */
id|skb_reserve
c_func
(paren
id|skb
comma
id|MAX_TCP_HEADER
)paren
suffix:semicolon
id|skb-&gt;dst
op_assign
id|dst_clone
c_func
(paren
id|dst
)paren
suffix:semicolon
id|tcp_header_size
op_assign
(paren
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
id|TCPOLEN_MSS
op_plus
(paren
id|req-&gt;tstamp_ok
ques
c_cond
id|TCPOLEN_TSTAMP_ALIGNED
suffix:colon
l_int|0
)paren
op_plus
(paren
id|req-&gt;wscale_ok
ques
c_cond
id|TCPOLEN_WSCALE_ALIGNED
suffix:colon
l_int|0
)paren
op_plus
multiline_comment|/* SACK_PERM is in the place of NOP NOP of TS */
(paren
(paren
id|req-&gt;sack_ok
op_logical_and
op_logical_neg
id|req-&gt;tstamp_ok
)paren
ques
c_cond
id|TCPOLEN_SACKPERM_ALIGNED
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|skb-&gt;h.th
op_assign
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
id|tcp_header_size
)paren
suffix:semicolon
id|memset
c_func
(paren
id|th
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|th-&gt;syn
op_assign
l_int|1
suffix:semicolon
id|th-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|th-&gt;source
op_assign
id|sk-&gt;sport
suffix:semicolon
id|th-&gt;dest
op_assign
id|req-&gt;rmt_port
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_assign
id|req-&gt;snt_isn
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_plus
l_int|1
suffix:semicolon
id|th-&gt;seq
op_assign
id|htonl
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
suffix:semicolon
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|req-&gt;rcv_isn
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rcv_wnd
op_eq
l_int|0
)paren
(brace
multiline_comment|/* ignored for retransmitted syns */
id|__u8
id|rcv_wscale
suffix:semicolon
multiline_comment|/* Set this up on the first call only */
id|req-&gt;window_clamp
op_assign
id|tp-&gt;window_clamp
ques
c_cond
suffix:colon
id|skb-&gt;dst-&gt;window
suffix:semicolon
multiline_comment|/* tcp_full_space because it is guaranteed to be the first packet */
id|tcp_select_initial_window
c_func
(paren
id|tcp_full_space
c_func
(paren
id|sk
)paren
comma
id|dst-&gt;advmss
op_minus
(paren
id|req-&gt;tstamp_ok
ques
c_cond
id|TCPOLEN_TSTAMP_ALIGNED
suffix:colon
l_int|0
)paren
comma
op_amp
id|req-&gt;rcv_wnd
comma
op_amp
id|req-&gt;window_clamp
comma
id|req-&gt;wscale_ok
comma
op_amp
id|rcv_wscale
)paren
suffix:semicolon
id|req-&gt;rcv_wscale
op_assign
id|rcv_wscale
suffix:semicolon
)brace
multiline_comment|/* RFC1323: The window in SYN &amp; SYN/ACK segments is never scaled. */
id|th-&gt;window
op_assign
id|htons
c_func
(paren
id|req-&gt;rcv_wnd
)paren
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|tcp_time_stamp
suffix:semicolon
id|tcp_syn_build_options
c_func
(paren
(paren
id|__u32
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
comma
id|dst-&gt;advmss
comma
id|req-&gt;tstamp_ok
comma
id|req-&gt;sack_ok
comma
id|req-&gt;wscale_ok
comma
id|req-&gt;rcv_wscale
comma
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
comma
id|req-&gt;ts_recent
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|th-&gt;doff
op_assign
(paren
id|tcp_header_size
op_rshift
l_int|2
)paren
suffix:semicolon
id|TCP_INC_STATS
c_func
(paren
id|TcpOutSegs
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
DECL|function|tcp_connect
r_int
id|tcp_connect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|buff
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|__sk_dst_get
c_func
(paren
id|sk
)paren
suffix:semicolon
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
multiline_comment|/* Reserve space for headers. */
id|skb_reserve
c_func
(paren
id|buff
comma
id|MAX_TCP_HEADER
)paren
suffix:semicolon
multiline_comment|/* We&squot;ll fix this up when we get a response from the other end.&n;&t; * See tcp_input.c:tcp_rcv_state_process case TCP_SYN_SENT.&n;&t; */
id|tp-&gt;tcp_header_len
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
(paren
id|sysctl_tcp_timestamps
ques
c_cond
id|TCPOLEN_TSTAMP_ALIGNED
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/* If user gave his TCP_MAXSEG, record it to clamp */
r_if
c_cond
(paren
id|tp-&gt;user_mss
)paren
id|tp-&gt;mss_clamp
op_assign
id|tp-&gt;user_mss
suffix:semicolon
id|tp-&gt;max_window
op_assign
l_int|0
suffix:semicolon
id|tcp_sync_mss
c_func
(paren
id|sk
comma
id|dst-&gt;pmtu
)paren
suffix:semicolon
id|tcp_initialize_rcv_mss
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;window_clamp
)paren
id|tp-&gt;window_clamp
op_assign
id|dst-&gt;window
suffix:semicolon
id|tp-&gt;advmss
op_assign
id|dst-&gt;advmss
suffix:semicolon
id|tcp_select_initial_window
c_func
(paren
id|tcp_full_space
c_func
(paren
id|sk
)paren
comma
id|tp-&gt;advmss
op_minus
(paren
id|tp-&gt;tcp_header_len
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
comma
op_amp
id|tp-&gt;rcv_wnd
comma
op_amp
id|tp-&gt;window_clamp
comma
id|sysctl_tcp_window_scaling
comma
op_amp
id|tp-&gt;rcv_wscale
)paren
suffix:semicolon
multiline_comment|/* Socket identity change complete, no longer&n;&t; * in TCP_CLOSE, so enter ourselves into the&n;&t; * hash tables.&n;&t; */
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_SYN_SENT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;af_specific
op_member_access_from_pointer
id|hash_connecting
c_func
(paren
id|sk
)paren
)paren
r_goto
id|err_out
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;done
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;snd_wnd
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;snd_wl1
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;snd_wl2
op_assign
id|tp-&gt;write_seq
suffix:semicolon
id|tp-&gt;snd_una
op_assign
id|tp-&gt;write_seq
suffix:semicolon
id|tp-&gt;snd_sml
op_assign
id|tp-&gt;write_seq
suffix:semicolon
id|tp-&gt;rcv_nxt
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;rcv_wup
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;copied_seq
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;rto
op_assign
id|TCP_TIMEOUT_INIT
suffix:semicolon
id|tcp_init_xmit_timers
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;fackets_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;retrans_out
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|flags
op_assign
id|TCPCB_FLAG_SYN
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|sacked
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
l_int|0
suffix:semicolon
id|buff-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|seq
op_assign
id|tp-&gt;write_seq
op_increment
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|tp-&gt;write_seq
suffix:semicolon
id|tp-&gt;snd_nxt
op_assign
id|tp-&gt;write_seq
suffix:semicolon
multiline_comment|/* Send it off. */
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|when
op_assign
id|tcp_time_stamp
suffix:semicolon
id|tp-&gt;syn_stamp
op_assign
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|when
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|buff
)paren
suffix:semicolon
id|tp-&gt;packets_out
op_increment
suffix:semicolon
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|skb_clone
c_func
(paren
id|buff
comma
id|GFP_KERNEL
)paren
)paren
suffix:semicolon
id|TCP_INC_STATS
c_func
(paren
id|TcpActiveOpens
)paren
suffix:semicolon
multiline_comment|/* Timer for repeating the SYN until an answer. */
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|buff
)paren
suffix:semicolon
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
)brace
multiline_comment|/* Send out a delayed ack, the caller does the policy checking&n; * to see if we should even be here.  See tcp_input.c:tcp_ack_snd_check()&n; * for details.&n; */
DECL|function|tcp_send_delayed_ack
r_void
id|tcp_send_delayed_ack
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
multiline_comment|/* Stay within the limit we were given */
id|timeout
op_assign
id|jiffies
op_plus
id|tp-&gt;ack.ato
suffix:semicolon
multiline_comment|/* Use new timeout only if there wasn&squot;t a older one earlier. */
id|spin_lock_bh
c_func
(paren
op_amp
id|sk-&gt;timer_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;delack_timer.prev
op_logical_or
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;delack_timer
)paren
)paren
(brace
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;delack_timer.expires
op_assign
id|timeout
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If delack timer was blocked or is about to expire,&n;&t;&t; * send ACK now.&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;ack.blocked
op_logical_or
id|time_before_eq
c_func
(paren
id|tp-&gt;delack_timer.expires
comma
id|jiffies
op_plus
(paren
id|tp-&gt;ack.ato
op_rshift
l_int|2
)paren
)paren
)paren
(brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;timer_lock
)paren
suffix:semicolon
id|tcp_send_ack
c_func
(paren
id|sk
)paren
suffix:semicolon
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|timeout
comma
id|tp-&gt;delack_timer.expires
)paren
)paren
id|tp-&gt;delack_timer.expires
op_assign
id|timeout
suffix:semicolon
)brace
id|add_timer
c_func
(paren
op_amp
id|tp-&gt;delack_timer
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;timer_lock
)paren
suffix:semicolon
macro_line|#ifdef TCP_FORMAL_WINDOW
multiline_comment|/* Explanation. Header prediction path does not handle&n;&t; * case of zero window. If we send ACK immediately, pred_flags&n;&t; * are reset when sending ACK. If rcv_nxt is advanced and&n;&t; * ack is not sent, than delayed ack is scheduled.&n;&t; * Hence, it is the best place to check for zero window.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;pred_flags
)paren
(brace
r_if
c_cond
(paren
id|tcp_receive_window
c_func
(paren
id|tp
)paren
op_eq
l_int|0
)paren
id|tp-&gt;pred_flags
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|tp-&gt;out_of_order_queue
)paren
op_eq
l_int|0
op_logical_and
op_logical_neg
id|tp-&gt;urg_data
)paren
id|tcp_fast_path_on
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/* This routine sends an ack and also updates the window. */
DECL|function|tcp_send_ack
r_void
id|tcp_send_ack
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
multiline_comment|/* If we have been reset, we may not send again. */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_CLOSE
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
multiline_comment|/* We are not putting this on the write queue, so&n;&t;&t; * tcp_transmit_skb() will set the ownership to this&n;&t;&t; * sock.&n;&t;&t; */
id|buff
op_assign
id|alloc_skb
c_func
(paren
id|MAX_TCP_HEADER
op_plus
l_int|15
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
id|tp-&gt;ack.pending
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;ack.ato
op_assign
id|TCP_ATO_MAX
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_DACK
comma
id|TCP_DELACK_MAX
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Reserve space for headers and prepare control bits. */
id|skb_reserve
c_func
(paren
id|buff
comma
id|MAX_TCP_HEADER
)paren
suffix:semicolon
id|buff-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|flags
op_assign
id|TCPCB_FLAG_ACK
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|sacked
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Send it off, this clears delayed acks for us. */
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|buff
)paren
op_member_access_from_pointer
id|when
op_assign
id|tcp_time_stamp
suffix:semicolon
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This routine sends a packet with an out of date sequence&n; * number. It assumes the other end will try to ack it.&n; */
DECL|function|tcp_write_wakeup
r_int
id|tcp_write_wakeup
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_CLOSE
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* Now this function is never called, while&n;&t;&t; * we have something not ACKed in queue.&n;&t;&t; */
id|BUG_TRAP
c_func
(paren
id|tp-&gt;snd_una
op_eq
id|tp-&gt;snd_nxt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;snd_wnd
OG
(paren
id|tp-&gt;snd_nxt
op_minus
id|tp-&gt;snd_una
)paren
op_logical_and
(paren
(paren
id|skb
op_assign
id|tp-&gt;send_head
)paren
op_ne
l_int|NULL
)paren
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
r_int
id|win_size
suffix:semicolon
multiline_comment|/* We are probing the opening of a window&n;&t;&t;&t; * but the window size is != 0&n;&t;&t;&t; * must have been a result SWS avoidance ( sender )&n;&t;&t;&t; */
id|win_size
op_assign
id|tp-&gt;snd_wnd
op_minus
(paren
id|tp-&gt;snd_nxt
op_minus
id|tp-&gt;snd_una
)paren
suffix:semicolon
r_if
c_cond
(paren
id|win_size
OL
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_minus
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
)paren
(brace
r_if
c_cond
(paren
id|tcp_fragment
c_func
(paren
id|sk
comma
id|skb
comma
id|win_size
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|tcp_time_stamp
suffix:semicolon
id|err
op_assign
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|update_send_head
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tp-&gt;snd_nxt
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
id|tp-&gt;packets_out
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_timer_is_set
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
)paren
)paren
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_RETRANS
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We don&squot;t queue it, tcp_transmit_skb() sets ownership. */
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|MAX_TCP_HEADER
op_plus
l_int|15
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Reserve space for headers and set control bits. */
id|skb_reserve
c_func
(paren
id|skb
comma
id|MAX_TCP_HEADER
)paren
suffix:semicolon
id|skb-&gt;csum
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_assign
id|TCPCB_FLAG_ACK
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|sacked
op_assign
l_int|0
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Use a previous sequence.  This should cause the other&n;&t;&t;&t; * end to send an ack.  Don&squot;t queue or clone SKB, just&n;&t;&t;&t; * send it.&n;&t;&t;&t; *&n;&t;&t;&t; * RED-PEN: logically it should be snd_una-1.&n;&t;&t;&t; * snd_nxt-1 will not be acked. snd_una==snd_nxt&n;&t;&t;&t; * in this place however. Right?&n;&t;&t;&t; */
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
op_assign
id|tp-&gt;snd_una
op_minus
l_int|1
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|when
op_assign
id|tcp_time_stamp
suffix:semicolon
r_return
id|tcp_transmit_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* A window probe timeout has occurred.  If window is not closed send&n; * a partial packet else a zero probe.&n; */
DECL|function|tcp_send_probe0
r_void
id|tcp_send_probe0
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|tcp_write_wakeup
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;packets_out
op_logical_or
op_logical_neg
id|tp-&gt;send_head
)paren
(brace
multiline_comment|/* Cancel probe timer, if it is not required. */
id|tp-&gt;probes_out
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;backoff
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
op_le
l_int|0
)paren
(brace
id|tp-&gt;backoff
op_increment
suffix:semicolon
id|tp-&gt;probes_out
op_increment
suffix:semicolon
id|tcp_reset_xmit_timer
(paren
id|sk
comma
id|TCP_TIME_PROBE0
comma
id|min
c_func
(paren
id|tp-&gt;rto
op_lshift
id|tp-&gt;backoff
comma
id|TCP_RTO_MAX
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If packet was not sent due to local congestion,&n;&t;&t; * do not backoff and do not remember probes_out.&n;&t;&t; * Let local senders to fight for local resources.&n;&t;&t; *&n;&t;&t; * Use accumulated backoff yet.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;probes_out
)paren
id|tp-&gt;probes_out
op_assign
l_int|1
suffix:semicolon
id|tcp_reset_xmit_timer
(paren
id|sk
comma
id|TCP_TIME_PROBE0
comma
id|min
c_func
(paren
id|tp-&gt;rto
op_lshift
id|tp-&gt;backoff
comma
id|TCP_RESOURCE_PROBE_INTERVAL
)paren
)paren
suffix:semicolon
)brace
)brace
eof
