multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Implementation of the Transmission Control Protocol(TCP).&n; *&n; * Version:&t;@(#)tcp_input.c&t;1.0.16&t;05/25/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;&n; *&t;&t;Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; *&n; * Fixes:&t;Eric Schenk&t;: avoid multiple retransmissions in one&n; *&t;&t;&t;&t;: round trip timeout.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
multiline_comment|/*&n; * RFC 1122 says:&n; *&n; * &quot;the suggested [SWS] avoidance algorithm for the receiver is to keep&n; *  RECV.NEXT + RCV.WIN fixed until:&n; *  RCV.BUFF - RCV.USER - RCV.WINDOW &gt;= min(1/2 RCV.BUFF, MSS)&quot;&n; *&n; * Experiments against BSD and Solaris machines show that following&n; * these rules results in the BSD and Solaris machines making very&n; * bad guesses about how much data they can have in flight.&n; *&n; * Instead we follow the BSD lead and offer a window that gives&n; * the size of the current free space, truncated to a multiple&n; * of 1024 bytes. If the window is smaller than&n; * &t;min(sk-&gt;mss, MAX_WINDOW/2)&n; * then we advertise the window as having size 0, unless this&n; * would shrink the window we offered last time.&n; * This results in as much as double the throughput as the original&n; * implementation.&n; *&n; * We do BSD style SWS avoidance -- note that RFC1122 only says we&n; * must do silly window avoidance, it does not require that we use&n; * the suggested algorithm.&n; *&n; * The &quot;rcvbuf&quot; and &quot;rmem_alloc&quot; values are shifted by 1, because&n; * they also contain buffer handling overhead etc, so the window&n; * we actually use is essentially based on only half those values.&n; */
DECL|function|tcp_new_window
r_int
id|tcp_new_window
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
r_int
id|window
suffix:semicolon
r_int
r_int
id|minwin
comma
id|maxwin
suffix:semicolon
multiline_comment|/* Get minimum and maximum window values.. */
id|minwin
op_assign
id|sk-&gt;mss
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|minwin
)paren
id|minwin
op_assign
id|sk-&gt;mtu
suffix:semicolon
id|maxwin
op_assign
id|sk-&gt;window_clamp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|maxwin
)paren
id|maxwin
op_assign
id|MAX_WINDOW
suffix:semicolon
r_if
c_cond
(paren
id|minwin
OG
id|maxwin
op_div
l_int|2
)paren
id|minwin
op_assign
id|maxwin
op_div
l_int|2
suffix:semicolon
multiline_comment|/* Get current rcvbuf size.. */
id|window
op_assign
id|sk-&gt;rcvbuf
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|window
OL
id|minwin
)paren
(brace
id|sk-&gt;rcvbuf
op_assign
id|minwin
op_star
l_int|2
suffix:semicolon
id|window
op_assign
id|minwin
suffix:semicolon
)brace
multiline_comment|/* Check rcvbuf against used and minimum window */
id|window
op_sub_assign
id|sk-&gt;rmem_alloc
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|window
op_minus
id|minwin
)paren
OL
l_int|0
)paren
multiline_comment|/* SWS avoidance */
id|window
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|window
OG
l_int|1023
)paren
id|window
op_and_assign
op_complement
l_int|1023
suffix:semicolon
r_if
c_cond
(paren
id|window
OG
id|maxwin
)paren
id|window
op_assign
id|maxwin
suffix:semicolon
r_return
id|window
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get rid of any delayed acks, we sent one already..&n; */
DECL|function|clear_delayed_acks
r_static
id|__inline__
r_void
id|clear_delayed_acks
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sk-&gt;ack_timed
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;bytes_rcv
op_assign
l_int|0
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;delack_timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is the main buffer sending routine. We queue the buffer&n; *&t;having checked it is sane seeming.&n; */
DECL|function|tcp_send_skb
r_void
id|tcp_send_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|size
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
multiline_comment|/*&n;&t; *&t;length of packet (not counting length of pre-tcp headers) &n;&t; */
id|size
op_assign
id|skb-&gt;len
op_minus
(paren
(paren
r_int
r_char
op_star
)paren
id|th
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Sanity check it.. &n;&t; */
r_if
c_cond
(paren
id|size
template_param
id|skb-&gt;len
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;tcp_send_skb: bad skb (skb = %p, data = %p, th = %p, len = %lu)&bslash;n&quot;
comma
id|skb
comma
id|skb-&gt;data
comma
id|th
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If we have queued a header size packet.. (these crash a few&n;&t; *&t;tcp stacks if ack is not set)&n;&t; */
r_if
c_cond
(paren
id|size
op_eq
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
(brace
multiline_comment|/* If it&squot;s got a syn or fin it&squot;s notionally included in the size..*/
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;syn
op_logical_and
op_logical_neg
id|th-&gt;fin
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;tcp_send_skb: attempt to queue a bogon.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Actual processing.&n;&t; */
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
id|skb-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
suffix:semicolon
id|skb-&gt;end_seq
op_assign
id|skb-&gt;seq
op_plus
id|size
op_minus
l_int|4
op_star
id|th-&gt;doff
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We must queue if&n;&t; *&n;&t; *&t;a) The right edge of this frame exceeds the window&n;&t; *&t;b) We are retransmitting (Nagle&squot;s rule)&n;&t; *&t;c) We have too many packets &squot;in flight&squot;&n;&t; */
r_if
c_cond
(paren
id|after
c_func
(paren
id|skb-&gt;end_seq
comma
id|sk-&gt;window_seq
)paren
op_logical_or
(paren
id|sk-&gt;retransmits
op_logical_and
id|sk-&gt;ip_xmit_timeout
op_eq
id|TIME_WRITE
)paren
op_logical_or
id|sk-&gt;packets_out
op_ge
id|sk-&gt;cong_window
)paren
(brace
multiline_comment|/* checksum will be supplied by tcp_write_xmit.  So&n;&t;&t; * we shouldn&squot;t need to set it at all.  I&squot;m being paranoid */
id|th-&gt;check
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;tcp_send_partial: next != NULL&bslash;n&quot;
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|before
c_func
(paren
id|sk-&gt;window_seq
comma
id|sk-&gt;write_queue.next-&gt;end_seq
)paren
op_logical_and
id|sk-&gt;send_head
op_eq
l_int|NULL
op_logical_and
id|sk-&gt;ack_backlog
op_eq
l_int|0
)paren
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; *&t;This is going straight out&n;&t;&t; */
id|clear_delayed_acks
c_func
(paren
id|sk
)paren
suffix:semicolon
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|th-&gt;window
op_assign
id|htons
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|th
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
id|size
comma
id|skb
)paren
suffix:semicolon
id|sk-&gt;sent_seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;This is mad. The tcp retransmit queue is put together&n;&t;&t; *&t;by the ip layer. This causes half the problems with&n;&t;&t; *&t;unroutable FIN&squot;s and other things.&n;&t;&t; */
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|skb-&gt;dev
comma
id|skb
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Set for next retransmit based on expected ACK time&n;&t;&t; *&t;of the first packet in the resend queue.&n;&t;&t; *&t;This is no longer a window behind.&n;&t;&t; */
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Locking problems lead us to a messy situation where we can have&n; *&t;multiple partially complete buffers queued up. This is really bad&n; *&t;as we don&squot;t want to be sending partial buffers. Fix this with&n; *&t;a semaphore or similar to lock tcp_write per socket.&n; *&n; *&t;These routines are pretty self descriptive.&n; */
DECL|function|tcp_dequeue_partial
r_struct
id|sk_buff
op_star
id|tcp_dequeue_partial
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb
op_assign
id|sk-&gt;partial
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
id|sk-&gt;partial
op_assign
l_int|NULL
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;partial_timer
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Empty the partial queue&n; */
DECL|function|tcp_send_partial
r_void
id|tcp_send_partial
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|tcp_dequeue_partial
c_func
(paren
id|sk
)paren
)paren
op_ne
l_int|NULL
)paren
id|tcp_send_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Queue a partial frame&n; */
DECL|function|tcp_enqueue_partial
r_void
id|tcp_enqueue_partial
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|tmp
op_assign
id|sk-&gt;partial
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;partial_timer
)paren
suffix:semicolon
id|sk-&gt;partial
op_assign
id|skb
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|sk-&gt;partial_timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Wait up to 1 second for the buffer to fill.&n;&t; */
id|sk-&gt;partial_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|sk-&gt;partial_timer.function
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|tcp_send_partial
suffix:semicolon
id|sk-&gt;partial_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;partial_timer
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
id|tcp_send_skb
c_func
(paren
id|sk
comma
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;This routine takes stuff off of the write queue,&n; *&t;and puts it in the xmit queue. This happens as incoming acks&n; *&t;open up the remote window for us.&n; */
DECL|function|tcp_write_xmit
r_void
id|tcp_write_xmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/*&n;&t; *&t;The bytes will have to remain here. In time closedown will&n;&t; *&t;empty the write queue and all will be happy &n;&t; */
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Anything on the transmit queue that fits the window can&n;&t; *&t;be added providing we are not&n;&t; *&n;&t; *&t;a) retransmitting (Nagle&squot;s rule)&n;&t; *&t;b) exceeding our congestion window.&n;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
op_ne
l_int|NULL
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|skb-&gt;end_seq
comma
id|sk-&gt;window_seq
)paren
op_logical_and
(paren
id|sk-&gt;retransmits
op_eq
l_int|0
op_logical_or
id|sk-&gt;ip_xmit_timeout
op_ne
id|TIME_WRITE
op_logical_or
op_logical_neg
id|after
c_func
(paren
id|skb-&gt;end_seq
comma
id|sk-&gt;rcv_ack_seq
)paren
)paren
op_logical_and
id|sk-&gt;packets_out
OL
id|sk-&gt;cong_window
)paren
(brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;See if we really need to send the packet. &n;&t;&t; */
r_if
c_cond
(paren
id|before
c_func
(paren
id|skb-&gt;end_seq
comma
id|sk-&gt;rcv_ack_seq
op_plus
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;This is acked data. We can discard it. This &n;&t;&t;&t; *&t;cannot currently occur.&n;&t;&t;&t; */
id|sk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/*&n; * put in the ack seq and window at this point rather than earlier,&n; * in order to keep them monotonic.  We really want to avoid taking&n; * back window allocations.  That&squot;s legal, but RFC1122 says it&squot;s frowned on.&n; * Ack and window will in general have changed since this packet was put&n; * on the write queue.&n; */
id|iph
op_assign
id|skb-&gt;ip_hdr
suffix:semicolon
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|iph
)paren
op_plus
(paren
id|iph-&gt;ihl
op_lshift
l_int|2
)paren
)paren
suffix:semicolon
id|size
op_assign
id|skb-&gt;len
op_minus
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|th
)paren
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_NO_PATH_MTU_DISCOVERY
r_if
c_cond
(paren
id|size
OG
id|sk-&gt;mtu
op_minus
r_sizeof
(paren
r_struct
id|iphdr
)paren
)paren
(brace
id|iph-&gt;frag_off
op_and_assign
op_complement
id|htons
c_func
(paren
id|IP_DF
)paren
suffix:semicolon
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
)brace
macro_line|#endif
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|th-&gt;window
op_assign
id|htons
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|th
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
id|size
comma
id|skb
)paren
suffix:semicolon
id|sk-&gt;sent_seq
op_assign
id|skb-&gt;end_seq
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;IP manages our queue for some crazy reason&n;&t;&t;&t; */
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|skb-&gt;dev
comma
id|skb
comma
id|skb-&gt;free
)paren
suffix:semicolon
id|clear_delayed_acks
c_func
(paren
id|sk
)paren
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; *&t;A socket has timed out on its send queue and wants to do a&n; *&t;little retransmitting. Currently this means TCP.&n; */
DECL|function|tcp_do_retransmit
r_void
id|tcp_do_retransmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|all
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|proto
op_star
id|prot
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
id|prot
op_assign
id|sk-&gt;prot
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|all
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we are just retransmitting one packet reset&n;&t;&t; * to the start of the queue.&n;&t;&t; */
id|sk-&gt;send_next
op_assign
id|sk-&gt;send_head
suffix:semicolon
id|sk-&gt;packets_out
op_assign
l_int|0
suffix:semicolon
)brace
id|skb
op_assign
id|sk-&gt;send_head
suffix:semicolon
r_while
c_loop
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_int
id|size
suffix:semicolon
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* dl1bke 960201 - @%$$! Hope this cures strange race conditions    */
multiline_comment|/*&t;&t;   with AX.25 mode VC. (esp. DAMA)&t;&t;    */
multiline_comment|/*&t;&t;   if the buffer is locked we should not retransmit */
multiline_comment|/*&t;&t;   anyway, so we don&squot;t need all the fuss to prepare */
multiline_comment|/*&t;&t;   the buffer in this case. &t;&t;&t;    */
multiline_comment|/*&t;&t;   (the skb_pull() changes skb-&gt;data while we may   */
multiline_comment|/*&t;&t;   actually try to send the data. Ouch. A side&t;    */
multiline_comment|/*&t;&t;   effect is that we&squot;ll send some unnecessary data, */
multiline_comment|/*&t;&t;   but the alternative is disastrous...&t;    */
r_if
c_cond
(paren
id|skb_device_locked
c_func
(paren
id|skb
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Discard the surplus MAC header&n;&t;&t; */
id|skb_pull
c_func
(paren
id|skb
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|skb-&gt;ip_hdr
)paren
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In general it&squot;s OK just to use the old packet.  However we&n;&t;&t; * need to use the current ack and window fields.  Urg and&n;&t;&t; * urg_ptr could possibly stand to be updated as well, but we&n;&t;&t; * don&squot;t keep the necessary data.  That shouldn&squot;t be a problem,&n;&t;&t; * if the other end is doing the right thing.  Since we&squot;re&n;&t;&t; * changing the packet, we have to issue a new IP identifier.&n;&t;&t; */
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb-&gt;data
suffix:semicolon
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|iph
)paren
op_plus
(paren
id|iph-&gt;ihl
op_lshift
l_int|2
)paren
)paren
suffix:semicolon
id|size
op_assign
id|ntohs
c_func
(paren
id|iph-&gt;tot_len
)paren
op_minus
(paren
id|iph-&gt;ihl
op_lshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Note: We ought to check for window limits here but&n;&t;&t; *&t;currently this is done (less efficiently) elsewhere.&n;&t;&t; */
multiline_comment|/*&n;&t;&t; *&t;Put a MAC header back on (may cause ARPing)&n;&t;&t; */
(brace
multiline_comment|/* ANK: UGLY, but the bug, that was here, should be fixed.&n;&t;&t;&t; */
r_struct
id|options
op_star
id|opt
op_assign
(paren
r_struct
id|options
op_star
)paren
id|skb-&gt;proto_priv
suffix:semicolon
id|rt
op_assign
id|ip_check_route
c_func
(paren
op_amp
id|sk-&gt;ip_route_cache
comma
id|opt-&gt;srr
ques
c_cond
id|opt-&gt;faddr
suffix:colon
id|iph-&gt;daddr
comma
id|skb-&gt;localroute
)paren
suffix:semicolon
)brace
id|iph-&gt;id
op_assign
id|htons
c_func
(paren
id|ip_id_count
op_increment
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_NO_PATH_MTU_DISCOVERY
r_if
c_cond
(paren
id|rt
op_logical_and
id|ntohs
c_func
(paren
id|iph-&gt;tot_len
)paren
OG
id|rt-&gt;rt_mtu
)paren
id|iph-&gt;frag_off
op_and_assign
op_complement
id|htons
c_func
(paren
id|IP_DF
)paren
suffix:semicolon
macro_line|#endif
id|ip_send_check
c_func
(paren
id|iph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
multiline_comment|/* Deep poo */
(brace
r_if
c_cond
(paren
id|skb-&gt;sk
)paren
(brace
id|skb-&gt;sk-&gt;err_soft
op_assign
id|ENETUNREACH
suffix:semicolon
id|skb-&gt;sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|skb-&gt;sk
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|dev
op_assign
id|rt-&gt;rt_dev
suffix:semicolon
id|skb-&gt;raddr
op_assign
id|rt-&gt;rt_gateway
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|rt-&gt;rt_hh
)paren
(brace
id|memcpy
c_func
(paren
id|skb_push
c_func
(paren
id|skb
comma
id|dev-&gt;hard_header_len
)paren
comma
id|rt-&gt;rt_hh-&gt;hh_data
comma
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rt-&gt;rt_hh-&gt;hh_uptodate
)paren
(brace
id|skb-&gt;arp
op_assign
l_int|0
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;tcp_do_retransmit: hh miss %08x via %08x&bslash;n&quot;
comma
id|iph-&gt;daddr
comma
id|rt-&gt;rt_gateway
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;hard_header
)paren
(brace
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|skb
comma
id|dev
comma
id|ETH_P_IP
comma
l_int|NULL
comma
l_int|NULL
comma
id|skb-&gt;len
)paren
OL
l_int|0
)paren
(brace
id|skb-&gt;arp
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;This is not the right way to handle this. We have to&n;&t;&t;&t; *&t;issue an up to date window and ack report with this &n;&t;&t;&t; *&t;retransmit to keep the odd buggy tcp that relies on &n;&t;&t;&t; *&t;the fact BSD does this happy. &n;&t;&t;&t; *&t;We don&squot;t however need to recalculate the entire &n;&t;&t;&t; *&t;checksum, so someone wanting a small problem to play&n;&t;&t;&t; *&t;with might like to implement RFC1141/RFC1624 and speed&n;&t;&t;&t; *&t;this up by avoiding a full checksum.&n;&t;&t;&t; */
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|clear_delayed_acks
c_func
(paren
id|sk
)paren
suffix:semicolon
id|th-&gt;window
op_assign
id|ntohs
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|th
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
id|size
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;If the interface is (still) up and running, kick it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;If the packet is still being sent by the device/protocol&n;&t;&t;&t;&t; *&t;below then don&squot;t retransmit. This is both needed, and good -&n;&t;&t;&t;&t; *&t;especially with connected mode AX.25 where it stops resends&n;&t;&t;&t;&t; *&t;occurring of an as yet unsent anyway frame!&n;&t;&t;&t;&t; *&t;We still add up the counts as the round trip time wants&n;&t;&t;&t;&t; *&t;adjusting.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|sk
op_logical_and
op_logical_neg
id|skb_device_locked
c_func
(paren
id|skb
)paren
)paren
(brace
multiline_comment|/* Remove it from any existing driver queue first! */
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Now queue it */
id|ip_statistics.IpOutRequests
op_increment
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
id|sk-&gt;priority
)paren
suffix:semicolon
id|sk-&gt;packets_out
op_increment
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; *&t;Count retransmissions&n;&t;&t; */
id|sk-&gt;prot-&gt;retransmits
op_increment
suffix:semicolon
id|tcp_statistics.TcpRetransSegs
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Record the high sequence number to help avoid doing&n;&t;&t; * to much fast retransmission.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;retransmits
)paren
id|sk-&gt;high_seq
op_assign
id|sk-&gt;sent_seq
suffix:semicolon
multiline_comment|/*&n;&t;         * Advance the send_next pointer so we don&squot;t keep&n;&t;&t; * retransmitting the same stuff every time we get an ACK.&n;&t;&t; */
id|sk-&gt;send_next
op_assign
id|skb-&gt;link3
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Only one retransmit requested.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|all
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;This should cut it off before we send too many packets.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;packets_out
op_ge
id|sk-&gt;cong_window
)paren
r_break
suffix:semicolon
id|skb
op_assign
id|skb-&gt;link3
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;This routine will send an RST to the other tcp. &n; */
DECL|function|tcp_send_reset
r_void
id|tcp_send_reset
c_func
(paren
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_struct
id|proto
op_star
id|prot
comma
r_struct
id|options
op_star
id|opt
comma
r_struct
id|device
op_star
id|dev
comma
r_int
id|tos
comma
r_int
id|ttl
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_struct
id|device
op_star
id|ndev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Cannot reset a reset (Think about it).&n;&t; */
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We need to grab some memory, and put together an RST,&n;&t; * and then put it into the queue to be sent.&n;&t; */
id|buff
op_assign
id|sock_wmalloc
c_func
(paren
l_int|NULL
comma
id|MAX_RESET_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|buff-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|buff-&gt;dev
op_assign
id|dev
suffix:semicolon
id|buff-&gt;localroute
op_assign
l_int|0
suffix:semicolon
id|buff-&gt;csum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Put in the IP header and routing stuff. &n;&t; */
id|tmp
op_assign
id|prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|saddr
comma
id|daddr
comma
op_amp
id|ndev
comma
id|IPPROTO_TCP
comma
id|opt
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
comma
id|tos
comma
id|ttl
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|sock_wfree
c_func
(paren
l_int|NULL
comma
id|buff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|t1
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Swap the send and the receive. &n;&t; */
id|t1-&gt;dest
op_assign
id|th-&gt;source
suffix:semicolon
id|t1-&gt;source
op_assign
id|th-&gt;dest
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
id|t1-&gt;seq
op_assign
id|th-&gt;ack_seq
suffix:semicolon
)brace
r_else
(brace
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;syn
)paren
(brace
id|t1-&gt;ack_seq
op_assign
id|th-&gt;seq
suffix:semicolon
)brace
r_else
id|t1-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|tcp_send_check
c_func
(paren
id|t1
comma
id|saddr
comma
id|daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|buff
)paren
suffix:semicolon
id|prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
l_int|NULL
comma
id|ndev
comma
id|buff
comma
l_int|1
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send a fin.&n; */
DECL|function|tcp_send_fin
r_void
id|tcp_send_fin
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|proto
op_star
id|prot
op_assign
(paren
r_struct
id|proto
op_star
)paren
id|sk-&gt;prot
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
op_amp
id|sk-&gt;dummy_th
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|buff
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|MAX_RESET_SIZE
comma
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* This is a disaster if it occurs */
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;tcp_send_fin: Impossible malloc failure&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Administrivia&n;&t; */
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|buff-&gt;localroute
op_assign
id|sk-&gt;localroute
suffix:semicolon
id|buff-&gt;csum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Put in the IP header and routing stuff. &n;&t; */
id|tmp
op_assign
id|prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
comma
op_amp
id|sk-&gt;ip_route_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
r_int
id|t
suffix:semicolon
multiline_comment|/*&n;  &t;&t; *&t;Finish anyway, treat this as a send that got lost. &n;  &t;&t; *&t;(Not good).&n;  &t;&t; */
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|sock_wfree
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
id|sk-&gt;write_seq
op_increment
suffix:semicolon
id|t
op_assign
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
)brace
r_else
id|tcp_reset_msl_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;We ought to check if the end of the queue is a buffer and&n;&t; *&t;if so simply add the fin to that buffer, not send it ahead.&n;&t; */
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|buff-&gt;dev
op_assign
id|dev
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
id|th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
id|buff-&gt;seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|sk-&gt;write_seq
op_increment
suffix:semicolon
id|buff-&gt;end_seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|t1-&gt;seq
op_assign
id|htonl
c_func
(paren
id|buff-&gt;seq
)paren
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|t1-&gt;window
op_assign
id|htons
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|t1-&gt;fin
op_assign
l_int|1
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|buff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If there is data in the write queue, the fin must be appended to&n;&t; * the write queue.&n; &t; */
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_ne
l_int|NULL
)paren
(brace
id|buff-&gt;free
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buff-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;tcp_send_fin: next != NULL&bslash;n&quot;
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|buff
)paren
suffix:semicolon
)brace
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|buff
)paren
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;sent_seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|0
)paren
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
)brace
DECL|function|tcp_send_synack
r_void
id|tcp_send_synack
c_func
(paren
r_struct
id|sock
op_star
id|newsk
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|device
op_star
id|ndev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|buff
op_assign
id|sock_wmalloc
c_func
(paren
id|newsk
comma
id|MAX_SYN_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;err
op_assign
id|ENOMEM
suffix:semicolon
id|destroy_sock
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buff-&gt;sk
op_assign
id|newsk
suffix:semicolon
id|buff-&gt;localroute
op_assign
id|newsk-&gt;localroute
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Put in the IP header and routing stuff. &n;&t; */
id|tmp
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|newsk-&gt;saddr
comma
id|newsk-&gt;daddr
comma
op_amp
id|ndev
comma
id|IPPROTO_TCP
comma
id|newsk-&gt;opt
comma
id|MAX_SYN_SIZE
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
comma
op_amp
id|newsk-&gt;ip_route_cache
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Something went wrong. &n;&t; */
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sk-&gt;err
op_assign
id|tmp
suffix:semicolon
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|kfree_skb
c_func
(paren
id|buff
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|destroy_sock
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
id|skb-&gt;h.th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
id|buff-&gt;seq
op_assign
id|newsk-&gt;write_seq
op_increment
suffix:semicolon
id|buff-&gt;end_seq
op_assign
id|newsk-&gt;write_seq
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Swap the send and the receive. &n;&t; */
id|t1-&gt;dest
op_assign
id|skb-&gt;h.th-&gt;source
suffix:semicolon
id|t1-&gt;source
op_assign
id|newsk-&gt;dummy_th.source
suffix:semicolon
id|t1-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|buff-&gt;seq
)paren
suffix:semicolon
id|newsk-&gt;sent_seq
op_assign
id|newsk-&gt;write_seq
suffix:semicolon
id|t1-&gt;window
op_assign
id|ntohs
c_func
(paren
id|tcp_select_window
c_func
(paren
id|newsk
)paren
)paren
suffix:semicolon
id|t1-&gt;syn
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|newsk-&gt;acked_seq
)paren
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
op_plus
l_int|1
suffix:semicolon
id|ptr
op_assign
id|skb_put
c_func
(paren
id|buff
comma
l_int|4
)paren
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
l_int|2
suffix:semicolon
id|ptr
(braket
l_int|1
)braket
op_assign
l_int|4
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
(paren
(paren
id|newsk-&gt;mtu
)paren
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|ptr
(braket
l_int|3
)braket
op_assign
(paren
id|newsk-&gt;mtu
)paren
op_amp
l_int|0xff
suffix:semicolon
id|buff-&gt;csum
op_assign
id|csum_partial
c_func
(paren
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|newsk-&gt;saddr
comma
id|newsk-&gt;daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
op_plus
l_int|4
comma
id|buff
)paren
suffix:semicolon
id|newsk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|newsk
comma
id|ndev
comma
id|buff
comma
l_int|0
)paren
suffix:semicolon
id|tcp_reset_xmit_timer
c_func
(paren
id|newsk
comma
id|TIME_WRITE
comma
id|TCP_TIMEOUT_INIT
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
id|newsk
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Charge the sock_buff to newsk. &n;&t; */
id|atomic_sub
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;rmem_alloc
)paren
suffix:semicolon
id|atomic_add
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|newsk-&gt;rmem_alloc
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
id|sk-&gt;ack_backlog
op_increment
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Set up the timers for sending a delayed ack..&n; *&n; *      rules for delaying an ack:&n; *      - delay time &lt;= 0.5 HZ&n; *      - must send at least every 2 full sized packets&n; *      - we don&squot;t have a window update to send&n; *&n; * &t;additional thoughts:&n; *&t;- we should not delay sending an ACK if we have ato &gt; 0.5 HZ.&n; *&t;  My thinking about this is that in this case we will just be&n; *&t;  systematically skewing the RTT calculation. (The rule about&n; *&t;  sending every two full sized packets will never need to be&n; *&t;  invoked, the delayed ack will be sent before the ATO timeout&n; *&t;  every time. Of course, the relies on our having a good estimate&n; *&t;  for packet interarrival times.)&n; */
DECL|function|tcp_send_delayed_ack
r_void
id|tcp_send_delayed_ack
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|max_timeout
comma
r_int
r_int
id|timeout
)paren
(brace
r_int
r_int
id|now
suffix:semicolon
multiline_comment|/* Calculate new timeout */
id|now
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|timeout
OG
id|max_timeout
op_logical_or
id|sk-&gt;bytes_rcv
op_ge
id|sk-&gt;max_unacked
)paren
(brace
id|timeout
op_assign
id|now
suffix:semicolon
id|mark_bh
c_func
(paren
id|TIMER_BH
)paren
suffix:semicolon
)brace
r_else
(brace
id|timeout
op_add_assign
id|now
suffix:semicolon
)brace
multiline_comment|/* Use new timeout only if there wasn&squot;t a older one earlier  */
r_if
c_cond
(paren
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;delack_timer
)paren
op_logical_or
id|timeout
OL
id|sk-&gt;delack_timer.expires
)paren
id|sk-&gt;delack_timer.expires
op_assign
id|timeout
suffix:semicolon
id|sk-&gt;ack_backlog
op_increment
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;delack_timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine sends an ack and also updates the window. &n; */
DECL|function|tcp_send_ack
r_void
id|tcp_send_ack
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* We have been reset, we may not send again */
multiline_comment|/*&n;&t; *&t;If we have nothing queued for transmit and the transmit timer&n;&t; *&t;is on we are just doing an ACK timeout and need to switch&n;&t; *&t;to a keepalive.&n;&t; */
id|clear_delayed_acks
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;send_head
op_eq
l_int|NULL
op_logical_and
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_logical_and
id|sk-&gt;ip_xmit_timeout
op_eq
id|TIME_WRITE
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;keepopen
)paren
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TIME_KEEPOPEN
comma
id|TCP_TIMEOUT_LEN
)paren
suffix:semicolon
r_else
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;retransmit_timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We need to grab some memory, and put together an ack,&n;&t; * and then put it into the queue to be sent.&n;&t; */
id|buff
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|MAX_ACK_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* &n;&t;&t; *&t;Force it to send an ack. We don&squot;t have to do this&n;&t;&t; *&t;(ACK is unreliable) but it&squot;s much better use of &n;&t;&t; *&t;bandwidth on slow links to send a spare ack than&n;&t;&t; *&t;resend packets. &n;&t;&t; */
id|tcp_send_delayed_ack
c_func
(paren
id|sk
comma
id|HZ
op_div
l_int|2
comma
id|HZ
op_div
l_int|2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Assemble a suitable TCP frame&n;&t; */
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|buff-&gt;localroute
op_assign
id|sk-&gt;localroute
suffix:semicolon
id|buff-&gt;csum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t; *&t;Put in the IP header and routing stuff. &n;&t; */
id|tmp
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|MAX_ACK_SIZE
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
comma
op_amp
id|sk-&gt;ip_route_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|sock_wfree
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;  &t; *&t;Fill in the packet and send it&n;  &t; */
id|memcpy
c_func
(paren
id|t1
comma
op_amp
id|sk-&gt;dummy_th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
id|t1-&gt;seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;sent_seq
)paren
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|t1-&gt;window
op_assign
id|htons
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|buff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&bslash;rtcp_ack: seq %x ack %x&bslash;n&quot;
comma
id|sk-&gt;sent_seq
comma
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|1
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine sends a packet with an out of date sequence&n; *&t;number. It assumes the other end will try to ack it.&n; */
DECL|function|tcp_write_wakeup
r_void
id|tcp_write_wakeup
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
comma
op_star
id|skb
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
r_return
suffix:semicolon
multiline_comment|/* After a valid reset we can send no more */
multiline_comment|/*&n;&t; *&t;Write data can still be transmitted/retransmitted in the&n;&t; *&t;following states.  If any other state is encountered, return.&n;&t; *&t;[listen/close will never occur here anyway]&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_CLOSE_WAIT
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_FIN_WAIT1
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_LAST_ACK
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_CLOSING
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|sk-&gt;sent_seq
comma
id|sk-&gt;window_seq
)paren
op_logical_and
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;    &t; * We are probing the opening of a window&n;&t;    &t; * but the window size is != 0&n;&t;    &t; * must have been a result SWS avoidance ( sender )&n;&t;    &t; */
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|tcphdr
op_star
id|nth
suffix:semicolon
r_int
r_int
id|win_size
suffix:semicolon
macro_line|#if 0
r_int
r_int
id|ow_size
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; *&t;How many bytes can we send ?&n;&t;&t; */
id|win_size
op_assign
id|sk-&gt;window_seq
op_minus
id|sk-&gt;sent_seq
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Recover the buffer pointers&n;&t;&t; */
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|skb-&gt;ip_hdr
suffix:semicolon
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|iph
)paren
op_plus
(paren
id|iph-&gt;ihl
op_lshift
l_int|2
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Grab the data for a temporary frame&n;&t;&t; */
id|buff
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|win_size
op_plus
id|th-&gt;doff
op_star
l_int|4
op_plus
(paren
id|iph-&gt;ihl
op_lshift
l_int|2
)paren
op_plus
id|sk-&gt;prot-&gt;max_header
op_plus
l_int|15
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* &n;&t; &t; *&t;If we strip the packet on the write queue we must&n;&t; &t; *&t;be ready to retransmit this one &n;&t; &t; */
id|buff-&gt;free
op_assign
multiline_comment|/*0*/
l_int|1
suffix:semicolon
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|buff-&gt;localroute
op_assign
id|sk-&gt;localroute
suffix:semicolon
multiline_comment|/*&n;&t;    &t; *&t;Put headers on the new packet&n;&t;    &t; */
id|tmp
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|buff-&gt;truesize
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
comma
op_amp
id|sk-&gt;ip_route_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sock_wfree
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Move the TCP header over&n;&t;&t; */
id|buff-&gt;dev
op_assign
id|dev
suffix:semicolon
id|nth
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
r_sizeof
(paren
op_star
id|th
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|nth
comma
id|th
comma
r_sizeof
(paren
op_star
id|th
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Correct the new header&n;&t;&t; */
id|nth-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|nth-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|nth-&gt;window
op_assign
id|htons
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|nth-&gt;check
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Copy TCP options and data start to our new buffer&n;&t;&t; */
id|buff-&gt;csum
op_assign
id|csum_partial_copy
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
comma
id|skb_put
c_func
(paren
id|buff
comma
id|win_size
)paren
comma
id|win_size
op_plus
id|th-&gt;doff
op_star
l_int|4
op_minus
r_sizeof
(paren
op_star
id|th
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Remember our right edge sequence number.&n;&t;&t; */
id|buff-&gt;end_seq
op_assign
id|sk-&gt;sent_seq
op_plus
id|win_size
suffix:semicolon
id|sk-&gt;sent_seq
op_assign
id|buff-&gt;end_seq
suffix:semicolon
multiline_comment|/* Hack */
r_if
c_cond
(paren
id|th-&gt;urg
op_logical_and
id|ntohs
c_func
(paren
id|th-&gt;urg_ptr
)paren
OL
id|win_size
)paren
(brace
id|nth-&gt;urg
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Checksum the split buffer&n;&t;&t; */
id|tcp_send_check
c_func
(paren
id|nth
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
id|nth-&gt;doff
op_star
l_int|4
op_plus
id|win_size
comma
id|buff
)paren
suffix:semicolon
)brace
r_else
(brace
id|buff
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|MAX_ACK_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|buff-&gt;localroute
op_assign
id|sk-&gt;localroute
suffix:semicolon
id|buff-&gt;csum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Put in the IP header and routing stuff. &n;&t;&t; */
id|tmp
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|MAX_ACK_SIZE
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
comma
op_amp
id|sk-&gt;ip_route_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sock_wfree
c_func
(paren
id|sk
comma
id|buff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|skb_put
c_func
(paren
id|buff
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
(paren
r_void
op_star
)paren
op_amp
id|sk-&gt;dummy_th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Use a previous sequence.&n;&t;&t; *&t;This should cause the other end to send an ack.&n;&t;&t; */
id|t1-&gt;seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;sent_seq
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&t;&t;t1-&gt;fin = 0;&t;-- We are sending a &squot;previous&squot; sequence, and 0 bytes of data - thus no FIN bit */
id|t1-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|t1-&gt;window
op_assign
id|htons
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|buff
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Send it.&n;&t; */
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|1
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;A window probe timeout has occurred.&n; */
DECL|function|tcp_send_probe0
r_void
id|tcp_send_probe0
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
r_return
suffix:semicolon
multiline_comment|/* After a valid reset we can send no more */
id|tcp_write_wakeup
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;backoff
op_increment
suffix:semicolon
id|sk-&gt;rto
op_assign
id|min
c_func
(paren
id|sk-&gt;rto
op_lshift
l_int|1
comma
l_int|120
op_star
id|HZ
)paren
suffix:semicolon
id|sk-&gt;retransmits
op_increment
suffix:semicolon
id|sk-&gt;prot-&gt;retransmits
op_increment
suffix:semicolon
id|tcp_reset_xmit_timer
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
eof
