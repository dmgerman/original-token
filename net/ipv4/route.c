multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;ROUTE - implementation of the IP router.&n; *&n; * Version:&t;@(#)route.c&t;1.0.14&t;05/31/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Linus Torvalds, &lt;Linus.Torvalds@helsinki.fi&gt;&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;Verify area fixes.&n; *&t;&t;Alan Cox&t;:&t;cli() protects routing changes&n; *&t;&t;Rui Oliveira&t;:&t;ICMP routing table updates&n; *&t;&t;(rco@di.uminho.pt)&t;Routing table insertion and update&n; *&t;&t;Linus Torvalds&t;:&t;Rewrote bits to be sensible&n; *&t;&t;Alan Cox&t;:&t;Added BSD route gw semantics&n; *&t;&t;Alan Cox&t;:&t;Super /proc &gt;4K &n; *&t;&t;Alan Cox&t;:&t;MTU in route table&n; *&t;&t;Alan Cox&t;: &t;MSS actually. Also added the window&n; *&t;&t;&t;&t;&t;clamper.&n; *&t;&t;Sam Lantinga&t;:&t;Fixed route matching in rt_del()&n; *&t;&t;Alan Cox&t;:&t;Routing cache support.&n; *&t;&t;Alan Cox&t;:&t;Removed compatibility cruft.&n; *&t;&t;Alan Cox&t;:&t;RTF_REJECT support.&n; *&t;&t;Alan Cox&t;:&t;TCP irtt support.&n; *&t;&t;Jonathan Naylor&t;:&t;Added Metric support.&n; *&t;Miquel van Smoorenburg&t;:&t;BSD API fixes.&n; *&t;Miquel van Smoorenburg&t;:&t;Metrics.&n; *&t;&t;Alan Cox&t;:&t;Use __u32 properly&n; *&t;&t;Alan Cox&t;:&t;Aligned routing errors more closely with BSD&n; *&t;&t;&t;&t;&t;our system is still very different.&n; *&t;&t;Alan Cox&t;:&t;Faster /proc handling&n; *&t;Alexey Kuznetsov&t;:&t;Massive rework to support tree based routing,&n; *&t;&t;&t;&t;&t;routing caches and better behaviour.&n; *&t;&t;&n; *&t;&t;Olaf Erb&t;:&t;irtt wasnt being copied right.&n; *&t;&t;Bjorn Ekwall&t;:&t;Kerneld route support.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/netlink.h&gt;
macro_line|#ifdef CONFIG_KERNELD
macro_line|#include &lt;linux/kerneld.h&gt;
macro_line|#endif
multiline_comment|/*&n; * Forwarding Information Base definitions.&n; */
DECL|struct|fib_node
r_struct
id|fib_node
(brace
DECL|member|fib_next
r_struct
id|fib_node
op_star
id|fib_next
suffix:semicolon
DECL|member|fib_dst
id|__u32
id|fib_dst
suffix:semicolon
DECL|member|fib_use
r_int
r_int
id|fib_use
suffix:semicolon
DECL|member|fib_info
r_struct
id|fib_info
op_star
id|fib_info
suffix:semicolon
DECL|member|fib_metric
r_int
id|fib_metric
suffix:semicolon
DECL|member|fib_tos
r_int
r_char
id|fib_tos
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * This structure contains data shared by many of routes.&n; */
DECL|struct|fib_info
r_struct
id|fib_info
(brace
DECL|member|fib_next
r_struct
id|fib_info
op_star
id|fib_next
suffix:semicolon
DECL|member|fib_prev
r_struct
id|fib_info
op_star
id|fib_prev
suffix:semicolon
DECL|member|fib_gateway
id|__u32
id|fib_gateway
suffix:semicolon
DECL|member|fib_dev
r_struct
id|device
op_star
id|fib_dev
suffix:semicolon
DECL|member|fib_refcnt
r_int
id|fib_refcnt
suffix:semicolon
DECL|member|fib_window
r_int
r_int
id|fib_window
suffix:semicolon
DECL|member|fib_flags
r_int
r_int
id|fib_flags
suffix:semicolon
DECL|member|fib_mtu
r_int
r_int
id|fib_mtu
suffix:semicolon
DECL|member|fib_irtt
r_int
r_int
id|fib_irtt
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|fib_zone
r_struct
id|fib_zone
(brace
DECL|member|fz_next
r_struct
id|fib_zone
op_star
id|fz_next
suffix:semicolon
DECL|member|fz_hash_table
r_struct
id|fib_node
op_star
op_star
id|fz_hash_table
suffix:semicolon
DECL|member|fz_list
r_struct
id|fib_node
op_star
id|fz_list
suffix:semicolon
DECL|member|fz_nent
r_int
id|fz_nent
suffix:semicolon
DECL|member|fz_logmask
r_int
id|fz_logmask
suffix:semicolon
DECL|member|fz_mask
id|__u32
id|fz_mask
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|fib_zones
r_static
r_struct
id|fib_zone
op_star
id|fib_zones
(braket
l_int|33
)braket
suffix:semicolon
DECL|variable|fib_zone_list
r_static
r_struct
id|fib_zone
op_star
id|fib_zone_list
suffix:semicolon
DECL|variable|fib_loopback
r_static
r_struct
id|fib_node
op_star
id|fib_loopback
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|fib_info_list
r_static
r_struct
id|fib_info
op_star
id|fib_info_list
suffix:semicolon
multiline_comment|/*&n; * Backlogging.&n; */
DECL|macro|RT_BH_REDIRECT
mdefine_line|#define RT_BH_REDIRECT&t;&t;0
DECL|macro|RT_BH_GARBAGE_COLLECT
mdefine_line|#define RT_BH_GARBAGE_COLLECT &t;1
DECL|macro|RT_BH_FREE
mdefine_line|#define RT_BH_FREE&t; &t;2
DECL|struct|rt_req
r_struct
id|rt_req
(brace
DECL|member|rtr_next
r_struct
id|rt_req
op_star
id|rtr_next
suffix:semicolon
DECL|member|dev
r_struct
id|device
op_star
id|dev
suffix:semicolon
DECL|member|dst
id|__u32
id|dst
suffix:semicolon
DECL|member|gw
id|__u32
id|gw
suffix:semicolon
DECL|member|tos
r_int
r_char
id|tos
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|ip_rt_lock
r_int
id|ip_rt_lock
suffix:semicolon
DECL|variable|ip_rt_bh_mask
r_int
id|ip_rt_bh_mask
suffix:semicolon
DECL|variable|rt_backlog
r_static
r_struct
id|rt_req
op_star
id|rt_backlog
suffix:semicolon
multiline_comment|/*&n; * Route cache.&n; */
DECL|variable|ip_rt_hash_table
r_struct
id|rtable
op_star
id|ip_rt_hash_table
(braket
id|RT_HASH_DIVISOR
)braket
suffix:semicolon
DECL|variable|rt_cache_size
r_static
r_int
id|rt_cache_size
suffix:semicolon
DECL|variable|rt_free_queue
r_static
r_struct
id|rtable
op_star
id|rt_free_queue
suffix:semicolon
DECL|variable|rt_wait
r_struct
id|wait_queue
op_star
id|rt_wait
suffix:semicolon
r_static
r_void
id|rt_kick_backlog
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|rt_cache_add
c_func
(paren
r_int
id|hash
comma
r_struct
id|rtable
op_star
id|rth
)paren
suffix:semicolon
r_static
r_void
id|rt_cache_flush
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|rt_garbage_collect_1
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* &n; * Evaluate mask length.&n; */
DECL|function|rt_logmask
r_static
id|__inline__
r_int
id|rt_logmask
c_func
(paren
id|__u32
id|mask
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|mask
op_assign
id|ntohl
c_func
(paren
id|mask
)paren
)paren
)paren
r_return
l_int|32
suffix:semicolon
r_return
id|ffz
c_func
(paren
op_complement
id|mask
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Create mask from length.&n; */
DECL|function|rt_mask
r_static
id|__inline__
id|__u32
id|rt_mask
c_func
(paren
r_int
id|logmask
)paren
(brace
r_if
c_cond
(paren
id|logmask
op_ge
l_int|32
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|htonl
c_func
(paren
op_complement
(paren
(paren
l_int|1
op_lshift
id|logmask
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
DECL|function|fz_hash_code
r_static
id|__inline__
r_int
id|fz_hash_code
c_func
(paren
id|__u32
id|dst
comma
r_int
id|logmask
)paren
(brace
r_return
id|ip_rt_hash_code
c_func
(paren
id|ntohl
c_func
(paren
id|dst
)paren
op_rshift
id|logmask
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Free FIB node.&n; */
DECL|function|fib_free_node
r_static
r_void
id|fib_free_node
c_func
(paren
r_struct
id|fib_node
op_star
id|f
)paren
(brace
r_struct
id|fib_info
op_star
id|fi
op_assign
id|f-&gt;fib_info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|fi-&gt;fib_refcnt
)paren
(brace
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;fib_free_node: fi %08x/%s is free&bslash;n&quot;
comma
id|fi-&gt;fib_gateway
comma
id|fi-&gt;fib_dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|fi-&gt;fib_next
)paren
id|fi-&gt;fib_next-&gt;fib_prev
op_assign
id|fi-&gt;fib_prev
suffix:semicolon
r_if
c_cond
(paren
id|fi-&gt;fib_prev
)paren
id|fi-&gt;fib_prev-&gt;fib_next
op_assign
id|fi-&gt;fib_next
suffix:semicolon
r_if
c_cond
(paren
id|fi
op_eq
id|fib_info_list
)paren
id|fib_info_list
op_assign
id|fi-&gt;fib_next
suffix:semicolon
)brace
id|kfree_s
c_func
(paren
id|f
comma
r_sizeof
(paren
r_struct
id|fib_node
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find gateway route by address.&n; */
DECL|function|fib_lookup_gateway
r_static
r_struct
id|fib_node
op_star
id|fib_lookup_gateway
c_func
(paren
id|__u32
id|dst
)paren
(brace
r_struct
id|fib_zone
op_star
id|fz
suffix:semicolon
r_struct
id|fib_node
op_star
id|f
suffix:semicolon
r_for
c_loop
(paren
id|fz
op_assign
id|fib_zone_list
suffix:semicolon
id|fz
suffix:semicolon
id|fz
op_assign
id|fz-&gt;fz_next
)paren
(brace
r_if
c_cond
(paren
id|fz-&gt;fz_hash_table
)paren
id|f
op_assign
id|fz-&gt;fz_hash_table
(braket
id|fz_hash_code
c_func
(paren
id|dst
comma
id|fz-&gt;fz_logmask
)paren
)braket
suffix:semicolon
r_else
id|f
op_assign
id|fz-&gt;fz_list
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|f
suffix:semicolon
id|f
op_assign
id|f-&gt;fib_next
)paren
(brace
r_if
c_cond
(paren
(paren
id|dst
op_xor
id|f-&gt;fib_dst
)paren
op_amp
id|fz-&gt;fz_mask
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;fib_info-&gt;fib_flags
op_amp
id|RTF_GATEWAY
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|f
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Find local route by address.&n; * FIXME: I use &quot;longest match&quot; principle. If destination&n; *&t;  has some non-local route, I&squot;ll not search shorter matches.&n; *&t;  It&squot;s possible, I&squot;m wrong, but I wanted to prevent following&n; *&t;  situation:&n; *&t;route add 193.233.7.128 netmask 255.255.255.192 gw xxxxxx&n; *&t;route add 193.233.7.0&t;netmask 255.255.255.0 eth1&n; *&t;  (Two ethernets connected by serial line, one is small and other is large)&n; *&t;  Host 193.233.7.129 is locally unreachable,&n; *&t;  but old (&lt;=1.3.37) code will send packets destined for it to eth1.&n; *&n; */
DECL|function|fib_lookup_local
r_static
r_struct
id|fib_node
op_star
id|fib_lookup_local
c_func
(paren
id|__u32
id|dst
)paren
(brace
r_struct
id|fib_zone
op_star
id|fz
suffix:semicolon
r_struct
id|fib_node
op_star
id|f
suffix:semicolon
r_for
c_loop
(paren
id|fz
op_assign
id|fib_zone_list
suffix:semicolon
id|fz
suffix:semicolon
id|fz
op_assign
id|fz-&gt;fz_next
)paren
(brace
r_int
id|longest_match_found
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fz-&gt;fz_hash_table
)paren
id|f
op_assign
id|fz-&gt;fz_hash_table
(braket
id|fz_hash_code
c_func
(paren
id|dst
comma
id|fz-&gt;fz_logmask
)paren
)braket
suffix:semicolon
r_else
id|f
op_assign
id|fz-&gt;fz_list
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|f
suffix:semicolon
id|f
op_assign
id|f-&gt;fib_next
)paren
(brace
r_if
c_cond
(paren
(paren
id|dst
op_xor
id|f-&gt;fib_dst
)paren
op_amp
id|fz-&gt;fz_mask
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|f-&gt;fib_info-&gt;fib_flags
op_amp
id|RTF_GATEWAY
)paren
)paren
r_return
id|f
suffix:semicolon
id|longest_match_found
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|longest_match_found
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Main lookup routine.&n; *&t;IMPORTANT NOTE: this algorithm has small difference from &lt;=1.3.37 visible&n; *&t;by user. It doesn&squot;t route non-CIDR broadcasts by default.&n; *&n; *&t;F.e.&n; *&t;&t;ifconfig eth0 193.233.7.65 netmask 255.255.255.192 broadcast 193.233.7.255&n; *&t;is valid, but if you really are not able (not allowed, do not want) to&n; *&t;use CIDR compliant broadcast 193.233.7.127, you should add host route:&n; *&t;&t;route add -host 193.233.7.255 eth0&n; */
DECL|function|fib_lookup
r_static
r_struct
id|fib_node
op_star
id|fib_lookup
c_func
(paren
id|__u32
id|dst
)paren
(brace
r_struct
id|fib_zone
op_star
id|fz
suffix:semicolon
r_struct
id|fib_node
op_star
id|f
suffix:semicolon
r_for
c_loop
(paren
id|fz
op_assign
id|fib_zone_list
suffix:semicolon
id|fz
suffix:semicolon
id|fz
op_assign
id|fz-&gt;fz_next
)paren
(brace
r_if
c_cond
(paren
id|fz-&gt;fz_hash_table
)paren
id|f
op_assign
id|fz-&gt;fz_hash_table
(braket
id|fz_hash_code
c_func
(paren
id|dst
comma
id|fz-&gt;fz_logmask
)paren
)braket
suffix:semicolon
r_else
id|f
op_assign
id|fz-&gt;fz_list
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|f
suffix:semicolon
id|f
op_assign
id|f-&gt;fib_next
)paren
(brace
r_if
c_cond
(paren
(paren
id|dst
op_xor
id|f-&gt;fib_dst
)paren
op_amp
id|fz-&gt;fz_mask
)paren
r_continue
suffix:semicolon
r_return
id|f
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|get_gw_dev
r_static
id|__inline__
r_struct
id|device
op_star
id|get_gw_dev
c_func
(paren
id|__u32
id|gw
)paren
(brace
r_struct
id|fib_node
op_star
id|f
suffix:semicolon
id|f
op_assign
id|fib_lookup_gateway
c_func
(paren
id|gw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
r_return
id|f-&gt;fib_info-&gt;fib_dev
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Used by &squot;rt_add()&squot; when we can&squot;t get the netmask any other way..&n; *&n; *&t;If the lower byte or two are zero, we guess the mask based on the&n; *&t;number of zero 8-bit net numbers, otherwise we use the &quot;default&quot;&n; *&t;masks judging by the destination address and our device netmask.&n; */
DECL|function|default_mask
r_static
id|__u32
r_int
r_int
id|default_mask
c_func
(paren
id|__u32
id|dst
)paren
(brace
id|dst
op_assign
id|ntohl
c_func
(paren
id|dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSA
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSA_NET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSB
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSB_NET
)paren
suffix:semicolon
r_return
id|htonl
c_func
(paren
id|IN_CLASSC_NET
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;If no mask is specified then generate a default entry.&n; */
DECL|function|guess_mask
r_static
id|__u32
id|guess_mask
c_func
(paren
id|__u32
id|dst
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
id|__u32
id|mask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dst
)paren
r_return
l_int|0
suffix:semicolon
id|mask
op_assign
id|default_mask
c_func
(paren
id|dst
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dst
op_xor
id|dev-&gt;pa_addr
)paren
op_amp
id|mask
)paren
r_return
id|mask
suffix:semicolon
r_return
id|dev-&gt;pa_mask
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Check if a mask is acceptable.&n; */
DECL|function|bad_mask
r_static
r_inline
r_int
id|bad_mask
c_func
(paren
id|__u32
id|mask
comma
id|__u32
id|addr
)paren
(brace
r_if
c_cond
(paren
id|addr
op_amp
(paren
id|mask
op_assign
op_complement
id|mask
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|mask
op_assign
id|ntohl
c_func
(paren
id|mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
(paren
id|mask
op_plus
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fib_del_list
r_static
r_int
id|fib_del_list
c_func
(paren
r_struct
id|fib_node
op_star
op_star
id|fp
comma
id|__u32
id|dst
comma
r_struct
id|device
op_star
id|dev
comma
id|__u32
id|gtw
comma
r_int
id|flags
comma
r_int
id|metric
comma
id|__u32
id|mask
)paren
(brace
r_struct
id|fib_node
op_star
id|f
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|f
op_assign
op_star
id|fp
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|fib_info
op_star
id|fi
op_assign
id|f-&gt;fib_info
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Make sure the destination and netmask match.&n;&t;&t; *&t;metric, gateway and device are also checked&n;&t;&t; *&t;if they were specified.&n;&t;&t; */
r_if
c_cond
(paren
id|f-&gt;fib_dst
op_ne
id|dst
op_logical_or
(paren
id|gtw
op_logical_and
id|fi-&gt;fib_gateway
op_ne
id|gtw
)paren
op_logical_or
(paren
id|metric
op_ge
l_int|0
op_logical_and
id|f-&gt;fib_metric
op_ne
id|metric
)paren
op_logical_or
(paren
id|dev
op_logical_and
id|fi-&gt;fib_dev
op_ne
id|dev
)paren
)paren
(brace
id|fp
op_assign
op_amp
id|f-&gt;fib_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|fp
op_assign
id|f-&gt;fib_next
suffix:semicolon
r_if
c_cond
(paren
id|fib_loopback
op_eq
id|f
)paren
id|fib_loopback
op_assign
l_int|NULL
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|ip_netlink_msg
c_func
(paren
id|RTMSG_DELROUTE
comma
id|dst
comma
id|gtw
comma
id|mask
comma
id|flags
comma
id|metric
comma
id|fi-&gt;fib_dev-&gt;name
)paren
suffix:semicolon
id|fib_free_node
c_func
(paren
id|f
)paren
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
r_return
id|found
suffix:semicolon
)brace
DECL|function|fib_del_1
r_static
id|__inline__
r_int
id|fib_del_1
c_func
(paren
id|__u32
id|dst
comma
id|__u32
id|mask
comma
r_struct
id|device
op_star
id|dev
comma
id|__u32
id|gtw
comma
r_int
id|flags
comma
r_int
id|metric
)paren
(brace
r_struct
id|fib_node
op_star
op_star
id|fp
suffix:semicolon
r_struct
id|fib_zone
op_star
id|fz
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mask
)paren
(brace
r_for
c_loop
(paren
id|fz
op_assign
id|fib_zone_list
suffix:semicolon
id|fz
suffix:semicolon
id|fz
op_assign
id|fz-&gt;fz_next
)paren
(brace
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|fz-&gt;fz_hash_table
)paren
id|fp
op_assign
op_amp
id|fz-&gt;fz_hash_table
(braket
id|fz_hash_code
c_func
(paren
id|dst
comma
id|fz-&gt;fz_logmask
)paren
)braket
suffix:semicolon
r_else
id|fp
op_assign
op_amp
id|fz-&gt;fz_list
suffix:semicolon
id|tmp
op_assign
id|fib_del_list
c_func
(paren
id|fp
comma
id|dst
comma
id|dev
comma
id|gtw
comma
id|flags
comma
id|metric
comma
id|mask
)paren
suffix:semicolon
id|fz-&gt;fz_nent
op_sub_assign
id|tmp
suffix:semicolon
id|found
op_add_assign
id|tmp
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|fz
op_assign
id|fib_zones
(braket
id|rt_logmask
c_func
(paren
id|mask
)paren
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|fz-&gt;fz_hash_table
)paren
id|fp
op_assign
op_amp
id|fz-&gt;fz_hash_table
(braket
id|fz_hash_code
c_func
(paren
id|dst
comma
id|fz-&gt;fz_logmask
)paren
)braket
suffix:semicolon
r_else
id|fp
op_assign
op_amp
id|fz-&gt;fz_list
suffix:semicolon
id|found
op_assign
id|fib_del_list
c_func
(paren
id|fp
comma
id|dst
comma
id|dev
comma
id|gtw
comma
id|flags
comma
id|metric
comma
id|mask
)paren
suffix:semicolon
id|fz-&gt;fz_nent
op_sub_assign
id|found
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|rt_cache_flush
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ESRCH
suffix:semicolon
)brace
DECL|function|fib_create_info
r_static
r_struct
id|fib_info
op_star
id|fib_create_info
c_func
(paren
id|__u32
id|gw
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|flags
comma
r_int
r_int
id|mss
comma
r_int
r_int
id|window
comma
r_int
r_int
id|irtt
)paren
(brace
r_struct
id|fib_info
op_star
id|fi
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|RTF_MSS
)paren
)paren
(brace
id|mss
op_assign
id|dev-&gt;mtu
suffix:semicolon
macro_line|#ifdef CONFIG_NO_PATH_MTU_DISCOVERY
multiline_comment|/*&n;&t;&t; *&t;If MTU was not specified, use default.&n;&t;&t; *&t;If you want to increase MTU for some net (local subnet)&n;&t;&t; *&t;use &quot;route add .... mss xxx&quot;.&n;&t;&t; *&n;&t;&t; * &t;The MTU isnt currently always used and computed as it&n;&t;&t; *&t;should be as far as I can tell. [Still verifying this is right]&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|RTF_GATEWAY
)paren
op_logical_and
id|mss
OG
l_int|576
)paren
id|mss
op_assign
l_int|576
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|RTF_WINDOW
)paren
)paren
id|window
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|RTF_IRTT
)paren
)paren
id|irtt
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|fi
op_assign
id|fib_info_list
suffix:semicolon
id|fi
suffix:semicolon
id|fi
op_assign
id|fi-&gt;fib_next
)paren
(brace
r_if
c_cond
(paren
id|fi-&gt;fib_gateway
op_ne
id|gw
op_logical_or
id|fi-&gt;fib_dev
op_ne
id|dev
op_logical_or
id|fi-&gt;fib_flags
op_ne
id|flags
op_logical_or
id|fi-&gt;fib_mtu
op_ne
id|mss
op_logical_or
id|fi-&gt;fib_window
op_ne
id|window
op_logical_or
id|fi-&gt;fib_irtt
op_ne
id|irtt
)paren
r_continue
suffix:semicolon
id|fi-&gt;fib_refcnt
op_increment
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;fib_create_info: fi %08x/%s is duplicate&bslash;n&quot;
comma
id|fi-&gt;fib_gateway
comma
id|fi-&gt;fib_dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
id|fi
suffix:semicolon
)brace
id|fi
op_assign
(paren
r_struct
id|fib_info
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|fib_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fi
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|fi
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|fib_info
)paren
)paren
suffix:semicolon
id|fi-&gt;fib_flags
op_assign
id|flags
suffix:semicolon
id|fi-&gt;fib_dev
op_assign
id|dev
suffix:semicolon
id|fi-&gt;fib_gateway
op_assign
id|gw
suffix:semicolon
id|fi-&gt;fib_mtu
op_assign
id|mss
suffix:semicolon
id|fi-&gt;fib_window
op_assign
id|window
suffix:semicolon
id|fi-&gt;fib_refcnt
op_increment
suffix:semicolon
id|fi-&gt;fib_next
op_assign
id|fib_info_list
suffix:semicolon
id|fi-&gt;fib_prev
op_assign
l_int|NULL
suffix:semicolon
id|fi-&gt;fib_irtt
op_assign
id|irtt
suffix:semicolon
r_if
c_cond
(paren
id|fib_info_list
)paren
id|fib_info_list-&gt;fib_prev
op_assign
id|fi
suffix:semicolon
id|fib_info_list
op_assign
id|fi
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;fib_create_info: fi %08x/%s is created&bslash;n&quot;
comma
id|fi-&gt;fib_gateway
comma
id|fi-&gt;fib_dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_return
id|fi
suffix:semicolon
)brace
DECL|function|fib_add_1
r_static
id|__inline__
r_void
id|fib_add_1
c_func
(paren
r_int
id|flags
comma
id|__u32
id|dst
comma
id|__u32
id|mask
comma
id|__u32
id|gw
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|mss
comma
r_int
r_int
id|window
comma
r_int
r_int
id|irtt
comma
r_int
id|metric
)paren
(brace
r_struct
id|fib_node
op_star
id|f
comma
op_star
id|f1
suffix:semicolon
r_struct
id|fib_node
op_star
op_star
id|fp
suffix:semicolon
r_struct
id|fib_node
op_star
op_star
id|dup_fp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|fib_zone
op_star
id|fz
suffix:semicolon
r_struct
id|fib_info
op_star
id|fi
suffix:semicolon
r_int
id|logmask
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|RTF_HOST
)paren
id|mask
op_assign
l_int|0xffffffff
suffix:semicolon
multiline_comment|/*&n;&t; * If mask is not specified, try to guess it.&n;&t; */
r_else
r_if
c_cond
(paren
op_logical_neg
id|mask
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|dst
op_xor
id|dev-&gt;pa_addr
)paren
op_amp
id|dev-&gt;pa_mask
)paren
)paren
(brace
id|mask
op_assign
id|dev-&gt;pa_mask
suffix:semicolon
id|flags
op_and_assign
op_complement
id|RTF_GATEWAY
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|RTF_DYNAMIC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Dynamic route to my own net rejected&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
id|mask
op_assign
id|guess_mask
c_func
(paren
id|dst
comma
id|dev
)paren
suffix:semicolon
id|dst
op_and_assign
id|mask
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;A gateway must be reachable and not a local address&n;&t; */
r_if
c_cond
(paren
id|gw
op_eq
id|dev-&gt;pa_addr
)paren
id|flags
op_and_assign
op_complement
id|RTF_GATEWAY
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|RTF_GATEWAY
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Don&squot;t try to add a gateway we can&squot;t reach.. &n;&t;&t; *&t;Tunnel devices are exempt from this rule.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|dev
op_ne
id|get_gw_dev
c_func
(paren
id|gw
)paren
)paren
op_logical_and
id|dev-&gt;type
op_ne
id|ARPHRD_TUNNEL
)paren
r_return
suffix:semicolon
id|flags
op_or_assign
id|RTF_GATEWAY
suffix:semicolon
)brace
r_else
id|gw
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate an entry and fill it in.&n;&t; */
id|f
op_assign
(paren
r_struct
id|fib_node
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|fib_node
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|memset
c_func
(paren
id|f
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|fib_node
)paren
)paren
suffix:semicolon
id|f-&gt;fib_dst
op_assign
id|dst
suffix:semicolon
id|f-&gt;fib_metric
op_assign
id|metric
suffix:semicolon
id|f-&gt;fib_tos
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fi
op_assign
id|fib_create_info
c_func
(paren
id|gw
comma
id|dev
comma
id|flags
comma
id|mss
comma
id|window
comma
id|irtt
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|kfree_s
c_func
(paren
id|f
comma
r_sizeof
(paren
r_struct
id|fib_node
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|f-&gt;fib_info
op_assign
id|fi
suffix:semicolon
id|logmask
op_assign
id|rt_logmask
c_func
(paren
id|mask
)paren
suffix:semicolon
id|fz
op_assign
id|fib_zones
(braket
id|logmask
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fz
)paren
(brace
r_int
id|i
suffix:semicolon
id|fz
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|fib_zone
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fz
)paren
(brace
id|fib_free_node
c_func
(paren
id|f
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|fz
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|fib_zone
)paren
)paren
suffix:semicolon
id|fz-&gt;fz_logmask
op_assign
id|logmask
suffix:semicolon
id|fz-&gt;fz_mask
op_assign
id|mask
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|logmask
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
id|fib_zones
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|fz-&gt;fz_next
op_assign
id|fib_zone_list
suffix:semicolon
id|fib_zone_list
op_assign
id|fz
suffix:semicolon
)brace
r_else
(brace
id|fz-&gt;fz_next
op_assign
id|fib_zones
(braket
id|i
)braket
op_member_access_from_pointer
id|fz_next
suffix:semicolon
id|fib_zones
(braket
id|i
)braket
op_member_access_from_pointer
id|fz_next
op_assign
id|fz
suffix:semicolon
)brace
id|fib_zones
(braket
id|logmask
)braket
op_assign
id|fz
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If zone overgrows RTZ_HASHING_LIMIT, create hash table.&n;&t; */
r_if
c_cond
(paren
id|fz-&gt;fz_nent
op_ge
id|RTZ_HASHING_LIMIT
op_logical_and
op_logical_neg
id|fz-&gt;fz_hash_table
op_logical_and
id|logmask
OL
l_int|32
)paren
(brace
r_struct
id|fib_node
op_star
op_star
id|ht
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG
id|printk
c_func
(paren
l_string|&quot;fib_add_1: hashing for zone %d started&bslash;n&quot;
comma
id|logmask
)paren
suffix:semicolon
macro_line|#endif
id|ht
op_assign
id|kmalloc
c_func
(paren
id|RTZ_HASH_DIVISOR
op_star
r_sizeof
(paren
r_struct
id|rtable
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ht
)paren
(brace
id|memset
c_func
(paren
id|ht
comma
l_int|0
comma
id|RTZ_HASH_DIVISOR
op_star
r_sizeof
(paren
r_struct
id|fib_node
op_star
)paren
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|f1
op_assign
id|fz-&gt;fz_list
suffix:semicolon
r_while
c_loop
(paren
id|f1
)paren
(brace
r_struct
id|fib_node
op_star
id|next
suffix:semicolon
r_int
id|hash
op_assign
id|fz_hash_code
c_func
(paren
id|f1-&gt;fib_dst
comma
id|logmask
)paren
suffix:semicolon
id|next
op_assign
id|f1-&gt;fib_next
suffix:semicolon
id|f1-&gt;fib_next
op_assign
id|ht
(braket
id|hash
)braket
suffix:semicolon
id|ht
(braket
id|hash
)braket
op_assign
id|f1
suffix:semicolon
id|f1
op_assign
id|next
suffix:semicolon
)brace
id|fz-&gt;fz_list
op_assign
l_int|NULL
suffix:semicolon
id|fz-&gt;fz_hash_table
op_assign
id|ht
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|fz-&gt;fz_hash_table
)paren
id|fp
op_assign
op_amp
id|fz-&gt;fz_hash_table
(braket
id|fz_hash_code
c_func
(paren
id|dst
comma
id|logmask
)paren
)braket
suffix:semicolon
r_else
id|fp
op_assign
op_amp
id|fz-&gt;fz_list
suffix:semicolon
multiline_comment|/*&n;&t; * Scan list to find the first route with the same destination&n;&t; */
r_while
c_loop
(paren
(paren
id|f1
op_assign
op_star
id|fp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|f1-&gt;fib_dst
op_eq
id|dst
)paren
r_break
suffix:semicolon
id|fp
op_assign
op_amp
id|f1-&gt;fib_next
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find route with the same destination and less (or equal) metric.&n;&t; */
r_while
c_loop
(paren
(paren
id|f1
op_assign
op_star
id|fp
)paren
op_ne
l_int|NULL
op_logical_and
id|f1-&gt;fib_dst
op_eq
id|dst
)paren
(brace
r_if
c_cond
(paren
id|f1-&gt;fib_metric
op_ge
id|metric
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Record route with the same destination and gateway,&n;&t;&t; *&t;but less metric. We&squot;ll delete it &n;&t;&t; *&t;after instantiation of new route.&n;&t;&t; */
r_if
c_cond
(paren
id|f1-&gt;fib_info-&gt;fib_gateway
op_eq
id|gw
)paren
id|dup_fp
op_assign
id|fp
suffix:semicolon
id|fp
op_assign
op_amp
id|f1-&gt;fib_next
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Is it already present?&n;&t; */
r_if
c_cond
(paren
id|f1
op_logical_and
id|f1-&gt;fib_metric
op_eq
id|metric
op_logical_and
id|f1-&gt;fib_info
op_eq
id|fi
)paren
(brace
id|fib_free_node
c_func
(paren
id|f
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Insert new entry to the list.&n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|f-&gt;fib_next
op_assign
id|f1
suffix:semicolon
op_star
id|fp
op_assign
id|f
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fib_loopback
op_logical_and
(paren
id|fi-&gt;fib_dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
)paren
id|fib_loopback
op_assign
id|f
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|fz-&gt;fz_nent
op_increment
suffix:semicolon
id|ip_netlink_msg
c_func
(paren
id|RTMSG_NEWROUTE
comma
id|dst
comma
id|gw
comma
id|mask
comma
id|flags
comma
id|metric
comma
id|fi-&gt;fib_dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Delete route with the same destination and gateway.&n;&t; *&t;Note that we should have at most one such route.&n;&t; */
r_if
c_cond
(paren
id|dup_fp
)paren
id|fp
op_assign
id|dup_fp
suffix:semicolon
r_else
id|fp
op_assign
op_amp
id|f-&gt;fib_next
suffix:semicolon
r_while
c_loop
(paren
(paren
id|f1
op_assign
op_star
id|fp
)paren
op_ne
l_int|NULL
op_logical_and
id|f1-&gt;fib_dst
op_eq
id|dst
)paren
(brace
r_if
c_cond
(paren
id|f1-&gt;fib_info-&gt;fib_gateway
op_eq
id|gw
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|fp
op_assign
id|f1-&gt;fib_next
suffix:semicolon
r_if
c_cond
(paren
id|fib_loopback
op_eq
id|f1
)paren
id|fib_loopback
op_assign
l_int|NULL
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|ip_netlink_msg
c_func
(paren
id|RTMSG_DELROUTE
comma
id|dst
comma
id|gw
comma
id|mask
comma
id|flags
comma
id|metric
comma
id|f1-&gt;fib_info-&gt;fib_dev-&gt;name
)paren
suffix:semicolon
id|fib_free_node
c_func
(paren
id|f1
)paren
suffix:semicolon
id|fz-&gt;fz_nent
op_decrement
suffix:semicolon
r_break
suffix:semicolon
)brace
id|fp
op_assign
op_amp
id|f1-&gt;fib_next
suffix:semicolon
)brace
id|rt_cache_flush
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|rt_flush_list
r_static
r_int
id|rt_flush_list
c_func
(paren
r_struct
id|fib_node
op_star
op_star
id|fp
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_struct
id|fib_node
op_star
id|f
suffix:semicolon
r_while
c_loop
(paren
(paren
id|f
op_assign
op_star
id|fp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|f-&gt;fib_info-&gt;fib_dev
op_ne
id|dev
)paren
(brace
id|fp
op_assign
op_amp
id|f-&gt;fib_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|fp
op_assign
id|f-&gt;fib_next
suffix:semicolon
r_if
c_cond
(paren
id|fib_loopback
op_eq
id|f
)paren
id|fib_loopback
op_assign
l_int|NULL
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|fib_free_node
c_func
(paren
id|f
)paren
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
r_return
id|found
suffix:semicolon
)brace
DECL|function|fib_flush_1
r_static
id|__inline__
r_void
id|fib_flush_1
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|fib_zone
op_star
id|fz
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|fz
op_assign
id|fib_zone_list
suffix:semicolon
id|fz
suffix:semicolon
id|fz
op_assign
id|fz-&gt;fz_next
)paren
(brace
r_if
c_cond
(paren
id|fz-&gt;fz_hash_table
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|tmp
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RTZ_HASH_DIVISOR
suffix:semicolon
id|i
op_increment
)paren
id|tmp
op_add_assign
id|rt_flush_list
c_func
(paren
op_amp
id|fz-&gt;fz_hash_table
(braket
id|i
)braket
comma
id|dev
)paren
suffix:semicolon
id|fz-&gt;fz_nent
op_sub_assign
id|tmp
suffix:semicolon
id|found
op_add_assign
id|tmp
suffix:semicolon
)brace
r_else
(brace
r_int
id|tmp
suffix:semicolon
id|tmp
op_assign
id|rt_flush_list
c_func
(paren
op_amp
id|fz-&gt;fz_list
comma
id|dev
)paren
suffix:semicolon
id|fz-&gt;fz_nent
op_sub_assign
id|tmp
suffix:semicolon
id|found
op_add_assign
id|tmp
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|found
)paren
id|rt_cache_flush
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Called from the PROCfs module. This outputs /proc/net/route.&n; *&n; *&t;We preserve the old format but pad the buffers out. This means that&n; *&t;we can spin over the other entries as we read them. Remember the&n; *&t;gated BGP4 code could need to read 60,000+ routes on occasion (thats&n; *&t;about 7Mb of data). To do that ok we will need to also cache the&n; *&t;last route we got to (reads will generally be following on from&n; *&t;one another without gaps).&n; */
DECL|function|rt_get_info
r_int
id|rt_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|dummy
)paren
(brace
r_struct
id|fib_zone
op_star
id|fz
suffix:semicolon
r_struct
id|fib_node
op_star
id|f
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_char
id|temp
(braket
l_int|129
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|pos
op_assign
l_int|128
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
l_int|128
)paren
(brace
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%-127s&bslash;n&quot;
comma
l_string|&quot;Iface&bslash;tDestination&bslash;tGateway &bslash;tFlags&bslash;tRefCnt&bslash;tUse&bslash;tMetric&bslash;tMask&bslash;t&bslash;tMTU&bslash;tWindow&bslash;tIRTT&quot;
)paren
suffix:semicolon
id|len
op_assign
l_int|128
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ip_rt_lock
)paren
id|sleep_on
c_func
(paren
op_amp
id|rt_wait
)paren
suffix:semicolon
id|ip_rt_fast_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|fz
op_assign
id|fib_zone_list
suffix:semicolon
id|fz
suffix:semicolon
id|fz
op_assign
id|fz-&gt;fz_next
)paren
(brace
r_int
id|maxslot
suffix:semicolon
r_struct
id|fib_node
op_star
op_star
id|fp
suffix:semicolon
r_if
c_cond
(paren
id|fz-&gt;fz_nent
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_plus
l_int|128
op_star
id|fz-&gt;fz_nent
op_le
id|offset
)paren
(brace
id|pos
op_add_assign
l_int|128
op_star
id|fz-&gt;fz_nent
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fz-&gt;fz_hash_table
)paren
(brace
id|maxslot
op_assign
id|RTZ_HASH_DIVISOR
suffix:semicolon
id|fp
op_assign
id|fz-&gt;fz_hash_table
suffix:semicolon
)brace
r_else
(brace
id|maxslot
op_assign
l_int|1
suffix:semicolon
id|fp
op_assign
op_amp
id|fz-&gt;fz_list
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|maxslot
suffix:semicolon
id|i
op_increment
comma
id|fp
op_increment
)paren
(brace
r_for
c_loop
(paren
id|f
op_assign
op_star
id|fp
suffix:semicolon
id|f
suffix:semicolon
id|f
op_assign
id|f-&gt;fib_next
)paren
(brace
r_struct
id|fib_info
op_star
id|fi
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Spin through entries until we are ready&n;&t;&t;&t;&t; */
id|pos
op_add_assign
l_int|128
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_le
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|fi
op_assign
id|f-&gt;fib_info
suffix:semicolon
id|sprintf
c_func
(paren
id|temp
comma
l_string|&quot;%s&bslash;t%08lX&bslash;t%08lX&bslash;t%02X&bslash;t%d&bslash;t%lu&bslash;t%d&bslash;t%08lX&bslash;t%d&bslash;t%lu&bslash;t%u&quot;
comma
id|fi-&gt;fib_dev-&gt;name
comma
(paren
r_int
r_int
)paren
id|f-&gt;fib_dst
comma
(paren
r_int
r_int
)paren
id|fi-&gt;fib_gateway
comma
id|fi-&gt;fib_flags
comma
l_int|0
comma
id|f-&gt;fib_use
comma
id|f-&gt;fib_metric
comma
(paren
r_int
r_int
)paren
id|fz-&gt;fz_mask
comma
(paren
r_int
)paren
id|fi-&gt;fib_mtu
comma
id|fi-&gt;fib_window
comma
(paren
r_int
)paren
id|fi-&gt;fib_irtt
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%-127s&bslash;n&quot;
comma
id|temp
)paren
suffix:semicolon
id|len
op_add_assign
l_int|128
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|offset
op_plus
id|length
)paren
r_goto
id|done
suffix:semicolon
)brace
)brace
)brace
id|done
suffix:colon
id|ip_rt_unlock
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|rt_wait
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|len
op_minus
(paren
id|pos
op_minus
id|offset
)paren
suffix:semicolon
id|len
op_assign
id|pos
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|rt_cache_get_info
r_int
id|rt_cache_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|dummy
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_char
id|temp
(braket
l_int|129
)braket
suffix:semicolon
r_struct
id|rtable
op_star
id|r
suffix:semicolon
r_int
id|i
suffix:semicolon
id|pos
op_assign
l_int|128
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
l_int|128
)paren
(brace
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%-127s&bslash;n&quot;
comma
l_string|&quot;Iface&bslash;tDestination&bslash;tGateway &bslash;tFlags&bslash;tRefCnt&bslash;tUse&bslash;tMetric&bslash;tSource&bslash;t&bslash;tMTU&bslash;tWindow&bslash;tIRTT&bslash;tHH&bslash;tARP&quot;
)paren
suffix:semicolon
id|len
op_assign
l_int|128
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ip_rt_lock
)paren
id|sleep_on
c_func
(paren
op_amp
id|rt_wait
)paren
suffix:semicolon
id|ip_rt_fast_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RT_HASH_DIVISOR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|r
op_assign
id|ip_rt_hash_table
(braket
id|i
)braket
suffix:semicolon
id|r
suffix:semicolon
id|r
op_assign
id|r-&gt;rt_next
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Spin through entries until we are ready&n;&t;&t;&t; */
id|pos
op_add_assign
l_int|128
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_le
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|temp
comma
l_string|&quot;%s&bslash;t%08lX&bslash;t%08lX&bslash;t%02X&bslash;t%d&bslash;t%u&bslash;t%d&bslash;t%08lX&bslash;t%d&bslash;t%lu&bslash;t%u&bslash;t%d&bslash;t%1d&quot;
comma
id|r-&gt;rt_dev-&gt;name
comma
(paren
r_int
r_int
)paren
id|r-&gt;rt_dst
comma
(paren
r_int
r_int
)paren
id|r-&gt;rt_gateway
comma
id|r-&gt;rt_flags
comma
id|r-&gt;rt_refcnt
comma
id|r-&gt;rt_use
comma
l_int|0
comma
(paren
r_int
r_int
)paren
id|r-&gt;rt_src
comma
(paren
r_int
)paren
id|r-&gt;rt_mtu
comma
id|r-&gt;rt_window
comma
(paren
r_int
)paren
id|r-&gt;rt_irtt
comma
id|r-&gt;rt_hh
ques
c_cond
id|r-&gt;rt_hh-&gt;hh_refcnt
suffix:colon
op_minus
l_int|1
comma
id|r-&gt;rt_hh
ques
c_cond
id|r-&gt;rt_hh-&gt;hh_uptodate
suffix:colon
l_int|0
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%-127s&bslash;n&quot;
comma
id|temp
)paren
suffix:semicolon
id|len
op_add_assign
l_int|128
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|offset
op_plus
id|length
)paren
r_goto
id|done
suffix:semicolon
)brace
)brace
id|done
suffix:colon
id|ip_rt_unlock
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|rt_wait
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|len
op_minus
(paren
id|pos
op_minus
id|offset
)paren
suffix:semicolon
id|len
op_assign
id|pos
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|rt_free
r_static
r_void
id|rt_free
c_func
(paren
r_struct
id|rtable
op_star
id|rt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rt-&gt;rt_refcnt
)paren
(brace
r_struct
id|hh_cache
op_star
id|hh
op_assign
id|rt-&gt;rt_hh
suffix:semicolon
id|rt-&gt;rt_hh
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|hh
op_logical_and
op_logical_neg
op_decrement
id|hh-&gt;hh_refcnt
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|hh
comma
r_sizeof
(paren
r_struct
id|hh_cache
)paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|rt
comma
r_sizeof
(paren
r_struct
id|rt_table
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rt-&gt;rt_next
op_assign
id|rt_free_queue
suffix:semicolon
id|rt-&gt;rt_flags
op_and_assign
op_complement
id|RTF_UP
suffix:semicolon
id|rt_free_queue
op_assign
id|rt
suffix:semicolon
id|ip_rt_bh_mask
op_or_assign
id|RT_BH_FREE
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;rt_free: %08x&bslash;n&quot;
comma
id|rt-&gt;rt_dst
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * RT &quot;bottom half&quot; handlers. Called with masked inetrrupts.&n; */
DECL|function|rt_kick_free_queue
r_static
id|__inline__
r_void
id|rt_kick_free_queue
c_func
(paren
r_void
)paren
(brace
r_struct
id|rtable
op_star
id|rt
comma
op_star
op_star
id|rtp
suffix:semicolon
id|rtp
op_assign
op_amp
id|rt_free_queue
suffix:semicolon
r_while
c_loop
(paren
(paren
id|rt
op_assign
op_star
id|rtp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rt-&gt;rt_refcnt
)paren
(brace
r_struct
id|hh_cache
op_star
id|hh
op_assign
id|rt-&gt;rt_hh
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|__u32
id|daddr
op_assign
id|rt-&gt;rt_dst
suffix:semicolon
macro_line|#endif
op_star
id|rtp
op_assign
id|rt-&gt;rt_next
suffix:semicolon
id|rt-&gt;rt_hh
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|hh
op_logical_and
op_logical_neg
op_decrement
id|hh-&gt;hh_refcnt
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|hh
comma
r_sizeof
(paren
r_struct
id|hh_cache
)paren
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|rt
comma
r_sizeof
(paren
r_struct
id|rt_table
)paren
)paren
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;rt_kick_free_queue: %08x is free&bslash;n&quot;
comma
id|daddr
)paren
suffix:semicolon
macro_line|#endif
id|cli
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|rtp
op_assign
op_amp
id|rt-&gt;rt_next
suffix:semicolon
)brace
)brace
DECL|function|ip_rt_run_bh
r_void
id|ip_rt_run_bh
c_func
(paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip_rt_bh_mask
op_logical_and
op_logical_neg
id|ip_rt_lock
)paren
(brace
r_if
c_cond
(paren
id|ip_rt_bh_mask
op_amp
id|RT_BH_REDIRECT
)paren
id|rt_kick_backlog
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip_rt_bh_mask
op_amp
id|RT_BH_GARBAGE_COLLECT
)paren
(brace
id|ip_rt_fast_lock
c_func
(paren
)paren
suffix:semicolon
id|ip_rt_bh_mask
op_and_assign
op_complement
id|RT_BH_GARBAGE_COLLECT
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|rt_garbage_collect_1
c_func
(paren
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ip_rt_fast_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip_rt_bh_mask
op_amp
id|RT_BH_FREE
)paren
id|rt_kick_free_queue
c_func
(paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|ip_rt_check_expire
r_void
id|ip_rt_check_expire
c_func
(paren
)paren
(brace
id|ip_rt_fast_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip_rt_lock
op_eq
l_int|1
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|rtable
op_star
id|rth
comma
op_star
op_star
id|rthp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RT_HASH_DIVISOR
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rthp
op_assign
op_amp
id|ip_rt_hash_table
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|rth
op_assign
op_star
id|rthp
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|rtable
op_star
id|rth_next
op_assign
id|rth-&gt;rt_next
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Cleanup aged off entries.&n;&t;&t;&t;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rth-&gt;rt_refcnt
op_logical_and
id|rth-&gt;rt_lastuse
op_plus
id|RT_CACHE_TIMEOUT
OL
id|now
)paren
(brace
op_star
id|rthp
op_assign
id|rth_next
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|rt_cache_size
op_decrement
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;rt_check_expire clean %02x@%08x&bslash;n&quot;
comma
id|i
comma
id|rth-&gt;rt_dst
)paren
suffix:semicolon
macro_line|#endif
id|rt_free
c_func
(paren
id|rth
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rth_next
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * LRU ordering.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|rth-&gt;rt_lastuse
op_plus
id|RT_CACHE_BUBBLE_THRESHOULD
OL
id|rth_next-&gt;rt_lastuse
op_logical_or
(paren
id|rth-&gt;rt_lastuse
OL
id|rth_next-&gt;rt_lastuse
op_logical_and
id|rth-&gt;rt_use
OL
id|rth_next-&gt;rt_use
)paren
)paren
(brace
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;rt_check_expire bubbled %02x@%08x&lt;-&gt;%08x&bslash;n&quot;
comma
id|i
comma
id|rth-&gt;rt_dst
comma
id|rth_next-&gt;rt_dst
)paren
suffix:semicolon
macro_line|#endif
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|rthp
op_assign
id|rth_next
suffix:semicolon
id|rth-&gt;rt_next
op_assign
id|rth_next-&gt;rt_next
suffix:semicolon
id|rth_next-&gt;rt_next
op_assign
id|rth
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|rthp
op_assign
op_amp
id|rth_next-&gt;rt_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|rthp
op_assign
op_amp
id|rth-&gt;rt_next
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|rt_kick_free_queue
c_func
(paren
)paren
suffix:semicolon
)brace
id|ip_rt_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|rt_redirect_1
r_static
r_void
id|rt_redirect_1
c_func
(paren
id|__u32
id|dst
comma
id|__u32
id|gw
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_int
r_int
id|hash
op_assign
id|ip_rt_hash_code
c_func
(paren
id|dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gw
op_eq
id|dev-&gt;pa_addr
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ne
id|get_gw_dev
c_func
(paren
id|gw
)paren
)paren
r_return
suffix:semicolon
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|rtable
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|memset
c_func
(paren
id|rt
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|rtable
)paren
)paren
suffix:semicolon
id|rt-&gt;rt_flags
op_assign
id|RTF_DYNAMIC
op_or
id|RTF_MODIFIED
op_or
id|RTF_HOST
op_or
id|RTF_GATEWAY
op_or
id|RTF_UP
suffix:semicolon
id|rt-&gt;rt_dst
op_assign
id|dst
suffix:semicolon
id|rt-&gt;rt_dev
op_assign
id|dev
suffix:semicolon
id|rt-&gt;rt_gateway
op_assign
id|gw
suffix:semicolon
id|rt-&gt;rt_src
op_assign
id|dev-&gt;pa_addr
suffix:semicolon
id|rt-&gt;rt_mtu
op_assign
id|dev-&gt;mtu
suffix:semicolon
macro_line|#ifdef CONFIG_NO_PATH_MTU_DISCOVERY
r_if
c_cond
(paren
id|dev-&gt;mtu
OG
l_int|576
)paren
id|rt-&gt;rt_mtu
op_assign
l_int|576
suffix:semicolon
macro_line|#endif
id|rt-&gt;rt_lastuse
op_assign
id|jiffies
suffix:semicolon
id|rt-&gt;rt_refcnt
op_assign
l_int|1
suffix:semicolon
id|rt_cache_add
c_func
(paren
id|hash
comma
id|rt
)paren
suffix:semicolon
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|rt_cache_flush
r_static
r_void
id|rt_cache_flush
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|rtable
op_star
id|rth
comma
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RT_HASH_DIVISOR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|nr
op_assign
l_int|0
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rth
op_assign
id|ip_rt_hash_table
(braket
id|i
)braket
)paren
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ip_rt_hash_table
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|rth
suffix:semicolon
id|rth
op_assign
id|next
)paren
(brace
id|next
op_assign
id|rth-&gt;rt_next
suffix:semicolon
id|rt_cache_size
op_decrement
suffix:semicolon
id|nr
op_increment
suffix:semicolon
id|rth-&gt;rt_next
op_assign
l_int|NULL
suffix:semicolon
id|rt_free
c_func
(paren
id|rth
)paren
suffix:semicolon
)brace
macro_line|#if RT_CACHE_DEBUG &gt;= 2
r_if
c_cond
(paren
id|nr
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;rt_cache_flush: %d@%02x&bslash;n&quot;
comma
id|nr
comma
id|i
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if RT_CACHE_DEBUG &gt;= 1
r_if
c_cond
(paren
id|rt_cache_size
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rt_cache_flush: bug rt_cache_size=%d&bslash;n&quot;
comma
id|rt_cache_size
)paren
suffix:semicolon
id|rt_cache_size
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|function|rt_garbage_collect_1
r_static
r_void
id|rt_garbage_collect_1
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|expire
op_assign
id|RT_CACHE_TIMEOUT
op_rshift
l_int|1
suffix:semicolon
r_struct
id|rtable
op_star
id|rth
comma
op_star
op_star
id|rthp
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RT_HASH_DIVISOR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ip_rt_hash_table
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|rthp
op_assign
op_amp
id|ip_rt_hash_table
(braket
id|i
)braket
suffix:semicolon
(paren
id|rth
op_assign
op_star
id|rthp
)paren
suffix:semicolon
id|rthp
op_assign
op_amp
id|rth-&gt;rt_next
)paren
(brace
r_if
c_cond
(paren
id|rth-&gt;rt_lastuse
op_plus
id|expire
op_star
(paren
id|rth-&gt;rt_refcnt
op_plus
l_int|1
)paren
OG
id|now
)paren
r_continue
suffix:semicolon
id|rt_cache_size
op_decrement
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|rthp
op_assign
id|rth-&gt;rt_next
suffix:semicolon
id|rth-&gt;rt_next
op_assign
l_int|NULL
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|rt_free
c_func
(paren
id|rth
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rt_cache_size
OL
id|RT_CACHE_SIZE_MAX
)paren
r_return
suffix:semicolon
id|expire
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|rt_req_enqueue
r_static
id|__inline__
r_void
id|rt_req_enqueue
c_func
(paren
r_struct
id|rt_req
op_star
op_star
id|q
comma
r_struct
id|rt_req
op_star
id|rtr
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|rt_req
op_star
id|tail
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|tail
op_assign
op_star
id|q
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tail
)paren
id|rtr-&gt;rtr_next
op_assign
id|rtr
suffix:semicolon
r_else
(brace
id|rtr-&gt;rtr_next
op_assign
id|tail-&gt;rtr_next
suffix:semicolon
id|tail-&gt;rtr_next
op_assign
id|rtr
suffix:semicolon
)brace
op_star
id|q
op_assign
id|rtr
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Caller should mask interrupts.&n; */
DECL|function|rt_req_dequeue
r_static
id|__inline__
r_struct
id|rt_req
op_star
id|rt_req_dequeue
c_func
(paren
r_struct
id|rt_req
op_star
op_star
id|q
)paren
(brace
r_struct
id|rt_req
op_star
id|rtr
suffix:semicolon
r_if
c_cond
(paren
op_star
id|q
)paren
(brace
id|rtr
op_assign
(paren
op_star
id|q
)paren
op_member_access_from_pointer
id|rtr_next
suffix:semicolon
(paren
op_star
id|q
)paren
op_member_access_from_pointer
id|rtr_next
op_assign
id|rtr-&gt;rtr_next
suffix:semicolon
r_if
c_cond
(paren
id|rtr-&gt;rtr_next
op_eq
id|rtr
)paren
op_star
id|q
op_assign
l_int|NULL
suffix:semicolon
id|rtr-&gt;rtr_next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|rtr
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;   Called with masked interrupts&n; */
DECL|function|rt_kick_backlog
r_static
r_void
id|rt_kick_backlog
c_func
(paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ip_rt_lock
)paren
(brace
r_struct
id|rt_req
op_star
id|rtr
suffix:semicolon
id|ip_rt_fast_lock
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|rtr
op_assign
id|rt_req_dequeue
c_func
(paren
op_amp
id|rt_backlog
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|rt_redirect_1
c_func
(paren
id|rtr-&gt;dst
comma
id|rtr-&gt;gw
comma
id|rtr-&gt;dev
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|rtr
comma
r_sizeof
(paren
r_struct
id|rt_req
)paren
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|ip_rt_bh_mask
op_and_assign
op_complement
id|RT_BH_REDIRECT
suffix:semicolon
id|ip_rt_fast_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * rt_{del|add|flush} called only from USER process. Waiting is OK.&n; */
DECL|function|rt_del
r_static
r_int
id|rt_del
c_func
(paren
id|__u32
id|dst
comma
id|__u32
id|mask
comma
r_struct
id|device
op_star
id|dev
comma
id|__u32
id|gtw
comma
r_int
id|rt_flags
comma
r_int
id|metric
)paren
(brace
r_int
id|retval
suffix:semicolon
r_while
c_loop
(paren
id|ip_rt_lock
)paren
id|sleep_on
c_func
(paren
op_amp
id|rt_wait
)paren
suffix:semicolon
id|ip_rt_fast_lock
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
id|fib_del_1
c_func
(paren
id|dst
comma
id|mask
comma
id|dev
comma
id|gtw
comma
id|rt_flags
comma
id|metric
)paren
suffix:semicolon
id|ip_rt_unlock
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|rt_wait
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|rt_add
r_static
r_void
id|rt_add
c_func
(paren
r_int
id|flags
comma
id|__u32
id|dst
comma
id|__u32
id|mask
comma
id|__u32
id|gw
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|mss
comma
r_int
r_int
id|window
comma
r_int
r_int
id|irtt
comma
r_int
id|metric
)paren
(brace
r_while
c_loop
(paren
id|ip_rt_lock
)paren
id|sleep_on
c_func
(paren
op_amp
id|rt_wait
)paren
suffix:semicolon
id|ip_rt_fast_lock
c_func
(paren
)paren
suffix:semicolon
id|fib_add_1
c_func
(paren
id|flags
comma
id|dst
comma
id|mask
comma
id|gw
comma
id|dev
comma
id|mss
comma
id|window
comma
id|irtt
comma
id|metric
)paren
suffix:semicolon
id|ip_rt_unlock
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|rt_wait
)paren
suffix:semicolon
)brace
DECL|function|ip_rt_flush
r_void
id|ip_rt_flush
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_while
c_loop
(paren
id|ip_rt_lock
)paren
id|sleep_on
c_func
(paren
op_amp
id|rt_wait
)paren
suffix:semicolon
id|ip_rt_fast_lock
c_func
(paren
)paren
suffix:semicolon
id|fib_flush_1
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ip_rt_unlock
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|rt_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   Called by ICMP module.&n; */
DECL|function|ip_rt_redirect
r_void
id|ip_rt_redirect
c_func
(paren
id|__u32
id|src
comma
id|__u32
id|dst
comma
id|__u32
id|gw
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|rt_req
op_star
id|rtr
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
id|rt
op_assign
id|ip_rt_route
c_func
(paren
id|dst
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rt
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|rt-&gt;rt_gateway
op_ne
id|src
op_logical_or
id|rt-&gt;rt_dev
op_ne
id|dev
op_logical_or
(paren
(paren
id|gw
op_xor
id|dev-&gt;pa_addr
)paren
op_amp
id|dev-&gt;pa_mask
)paren
op_logical_or
id|ip_chk_addr
c_func
(paren
id|gw
)paren
)paren
(brace
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ip_rt_put
c_func
(paren
id|rt
)paren
suffix:semicolon
id|ip_rt_fast_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip_rt_lock
op_eq
l_int|1
)paren
(brace
id|rt_redirect_1
c_func
(paren
id|dst
comma
id|gw
comma
id|dev
)paren
suffix:semicolon
id|ip_rt_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rtr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|rt_req
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtr
)paren
(brace
id|rtr-&gt;dst
op_assign
id|dst
suffix:semicolon
id|rtr-&gt;gw
op_assign
id|gw
suffix:semicolon
id|rtr-&gt;dev
op_assign
id|dev
suffix:semicolon
id|rt_req_enqueue
c_func
(paren
op_amp
id|rt_backlog
comma
id|rtr
)paren
suffix:semicolon
id|ip_rt_bh_mask
op_or_assign
id|RT_BH_REDIRECT
suffix:semicolon
)brace
id|ip_rt_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|rt_garbage_collect
r_static
id|__inline__
r_void
id|rt_garbage_collect
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|ip_rt_lock
op_eq
l_int|1
)paren
(brace
id|rt_garbage_collect_1
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ip_rt_bh_mask
op_or_assign
id|RT_BH_GARBAGE_COLLECT
suffix:semicolon
)brace
DECL|function|rt_cache_add
r_static
r_void
id|rt_cache_add
c_func
(paren
r_int
id|hash
comma
r_struct
id|rtable
op_star
id|rth
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|rtable
op_star
op_star
id|rthp
suffix:semicolon
id|__u32
id|daddr
op_assign
id|rth-&gt;rt_dst
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
r_if
c_cond
(paren
id|ip_rt_lock
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rt_cache_add: ip_rt_lock==%d&bslash;n&quot;
comma
id|ip_rt_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rth-&gt;rt_dev-&gt;header_cache_bind
)paren
(brace
r_struct
id|rtable
op_star
id|rtg
op_assign
id|rth
suffix:semicolon
r_if
c_cond
(paren
id|rth-&gt;rt_gateway
op_ne
id|daddr
)paren
(brace
id|ip_rt_fast_unlock
c_func
(paren
)paren
suffix:semicolon
id|rtg
op_assign
id|ip_rt_route
c_func
(paren
id|rth-&gt;rt_gateway
comma
l_int|0
)paren
suffix:semicolon
id|ip_rt_fast_lock
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rtg
)paren
(brace
r_if
c_cond
(paren
id|rtg
op_eq
id|rth
)paren
id|rtg-&gt;rt_dev
op_member_access_from_pointer
id|header_cache_bind
c_func
(paren
op_amp
id|rtg-&gt;rt_hh
comma
id|rtg-&gt;rt_dev
comma
id|ETH_P_IP
comma
id|rtg-&gt;rt_dst
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|rtg-&gt;rt_hh
)paren
id|ATOMIC_INCR
c_func
(paren
op_amp
id|rtg-&gt;rt_hh-&gt;hh_refcnt
)paren
suffix:semicolon
id|rth-&gt;rt_hh
op_assign
id|rtg-&gt;rt_hh
suffix:semicolon
id|ip_rt_put
c_func
(paren
id|rtg
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|rt_cache_size
op_ge
id|RT_CACHE_SIZE_MAX
)paren
id|rt_garbage_collect
c_func
(paren
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|rth-&gt;rt_next
op_assign
id|ip_rt_hash_table
(braket
id|hash
)braket
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
r_if
c_cond
(paren
id|rth-&gt;rt_next
)paren
(brace
r_struct
id|rtable
op_star
id|trth
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rt_cache @%02x: %08x&quot;
comma
id|hash
comma
id|daddr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|trth
op_assign
id|rth-&gt;rt_next
suffix:semicolon
id|trth
suffix:semicolon
id|trth
op_assign
id|trth-&gt;rt_next
)paren
id|printk
c_func
(paren
l_string|&quot; . %08x&quot;
comma
id|trth-&gt;rt_dst
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ip_rt_hash_table
(braket
id|hash
)braket
op_assign
id|rth
suffix:semicolon
id|rthp
op_assign
op_amp
id|rth-&gt;rt_next
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|rt_cache_size
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Cleanup duplicate (and aged off) entries.&n;&t; */
r_while
c_loop
(paren
(paren
id|rth
op_assign
op_star
id|rthp
)paren
op_ne
l_int|NULL
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|rth-&gt;rt_refcnt
op_logical_and
id|rth-&gt;rt_lastuse
op_plus
id|RT_CACHE_TIMEOUT
OL
id|now
)paren
op_logical_or
id|rth-&gt;rt_dst
op_eq
id|daddr
)paren
(brace
op_star
id|rthp
op_assign
id|rth-&gt;rt_next
suffix:semicolon
id|rt_cache_size
op_decrement
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;rt_cache clean %02x@%08x&bslash;n&quot;
comma
id|hash
comma
id|rth-&gt;rt_dst
)paren
suffix:semicolon
macro_line|#endif
id|rt_free
c_func
(paren
id|rth
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|rthp
op_assign
op_amp
id|rth-&gt;rt_next
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   RT should be already locked.&n;   &n;   We could improve this by keeping a chain of say 32 struct rtable&squot;s&n;   last freed for fast recycling.&n;   &n; */
DECL|function|ip_rt_slow_route
r_struct
id|rtable
op_star
id|ip_rt_slow_route
(paren
id|__u32
id|daddr
comma
r_int
id|local
)paren
(brace
r_int
id|hash
op_assign
id|ip_rt_hash_code
c_func
(paren
id|daddr
)paren
op_xor
id|local
suffix:semicolon
r_struct
id|rtable
op_star
id|rth
suffix:semicolon
r_struct
id|fib_node
op_star
id|f
suffix:semicolon
r_struct
id|fib_info
op_star
id|fi
suffix:semicolon
id|__u32
id|saddr
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;rt_cache miss @%08x&bslash;n&quot;
comma
id|daddr
)paren
suffix:semicolon
macro_line|#endif
id|rth
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|rtable
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rth
)paren
(brace
id|ip_rt_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|local
)paren
id|f
op_assign
id|fib_lookup_local
c_func
(paren
id|daddr
)paren
suffix:semicolon
r_else
id|f
op_assign
id|fib_lookup
(paren
id|daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
(brace
id|fi
op_assign
id|f-&gt;fib_info
suffix:semicolon
id|f-&gt;fib_use
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|f
op_logical_or
(paren
id|fi-&gt;fib_flags
op_amp
id|RTF_REJECT
)paren
)paren
(brace
macro_line|#ifdef CONFIG_KERNELD&t;
r_char
id|wanted_route
(braket
l_int|20
)braket
suffix:semicolon
macro_line|#endif&t;&t;
macro_line|#if RT_CACHE_DEBUG &gt;= 2
id|printk
c_func
(paren
l_string|&quot;rt_route failed @%08x&bslash;n&quot;
comma
id|daddr
)paren
suffix:semicolon
macro_line|#endif
id|ip_rt_unlock
c_func
(paren
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|rth
comma
r_sizeof
(paren
r_struct
id|rtable
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_KERNELD&t;&t;
id|daddr
op_assign
id|ntohl
c_func
(paren
id|daddr
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|wanted_route
comma
l_string|&quot;%d.%d.%d.%d&quot;
comma
(paren
r_int
)paren
(paren
id|daddr
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
comma
(paren
r_int
)paren
(paren
id|daddr
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
comma
(paren
r_int
)paren
(paren
id|daddr
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
(paren
r_int
)paren
id|daddr
op_amp
l_int|0xff
)paren
suffix:semicolon
id|kerneld_route
c_func
(paren
id|wanted_route
)paren
suffix:semicolon
multiline_comment|/* Dynamic route request */
macro_line|#endif&t;&t;
r_return
l_int|NULL
suffix:semicolon
)brace
id|saddr
op_assign
id|fi-&gt;fib_dev-&gt;pa_addr
suffix:semicolon
r_if
c_cond
(paren
id|daddr
op_eq
id|fi-&gt;fib_dev-&gt;pa_addr
)paren
(brace
id|f-&gt;fib_use
op_decrement
suffix:semicolon
r_if
c_cond
(paren
(paren
id|f
op_assign
id|fib_loopback
)paren
op_ne
l_int|NULL
)paren
(brace
id|f-&gt;fib_use
op_increment
suffix:semicolon
id|fi
op_assign
id|f-&gt;fib_info
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|f
)paren
(brace
id|ip_rt_unlock
c_func
(paren
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|rth
comma
r_sizeof
(paren
r_struct
id|rtable
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|rth-&gt;rt_dst
op_assign
id|daddr
suffix:semicolon
id|rth-&gt;rt_src
op_assign
id|saddr
suffix:semicolon
id|rth-&gt;rt_lastuse
op_assign
id|jiffies
suffix:semicolon
id|rth-&gt;rt_refcnt
op_assign
l_int|1
suffix:semicolon
id|rth-&gt;rt_use
op_assign
l_int|1
suffix:semicolon
id|rth-&gt;rt_next
op_assign
l_int|NULL
suffix:semicolon
id|rth-&gt;rt_hh
op_assign
l_int|NULL
suffix:semicolon
id|rth-&gt;rt_gateway
op_assign
id|fi-&gt;fib_gateway
suffix:semicolon
id|rth-&gt;rt_dev
op_assign
id|fi-&gt;fib_dev
suffix:semicolon
id|rth-&gt;rt_mtu
op_assign
id|fi-&gt;fib_mtu
suffix:semicolon
id|rth-&gt;rt_window
op_assign
id|fi-&gt;fib_window
suffix:semicolon
id|rth-&gt;rt_irtt
op_assign
id|fi-&gt;fib_irtt
suffix:semicolon
id|rth-&gt;rt_tos
op_assign
id|f-&gt;fib_tos
suffix:semicolon
id|rth-&gt;rt_flags
op_assign
id|fi-&gt;fib_flags
op_or
id|RTF_HOST
suffix:semicolon
r_if
c_cond
(paren
id|local
)paren
id|rth-&gt;rt_flags
op_or_assign
id|RTF_LOCAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rth-&gt;rt_flags
op_amp
id|RTF_GATEWAY
)paren
)paren
id|rth-&gt;rt_gateway
op_assign
id|rth-&gt;rt_dst
suffix:semicolon
r_if
c_cond
(paren
id|ip_rt_lock
op_eq
l_int|1
)paren
id|rt_cache_add
c_func
(paren
id|hash
comma
id|rth
)paren
suffix:semicolon
r_else
(brace
id|rt_free
c_func
(paren
id|rth
)paren
suffix:semicolon
macro_line|#if RT_CACHE_DEBUG &gt;= 1
id|printk
c_func
(paren
l_string|&quot;rt_cache: route to %08x was born dead&bslash;n&quot;
comma
id|daddr
)paren
suffix:semicolon
macro_line|#endif
)brace
id|ip_rt_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|rth
suffix:semicolon
)brace
DECL|function|ip_rt_put
r_void
id|ip_rt_put
c_func
(paren
r_struct
id|rtable
op_star
id|rt
)paren
(brace
r_if
c_cond
(paren
id|rt
)paren
id|ATOMIC_DECR
c_func
(paren
op_amp
id|rt-&gt;rt_refcnt
)paren
suffix:semicolon
)brace
DECL|function|ip_rt_route
r_struct
id|rtable
op_star
id|ip_rt_route
c_func
(paren
id|__u32
id|daddr
comma
r_int
id|local
)paren
(brace
r_struct
id|rtable
op_star
id|rth
suffix:semicolon
id|ip_rt_fast_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|rth
op_assign
id|ip_rt_hash_table
(braket
id|ip_rt_hash_code
c_func
(paren
id|daddr
)paren
op_xor
id|local
)braket
suffix:semicolon
id|rth
suffix:semicolon
id|rth
op_assign
id|rth-&gt;rt_next
)paren
(brace
r_if
c_cond
(paren
id|rth-&gt;rt_dst
op_eq
id|daddr
)paren
(brace
id|rth-&gt;rt_lastuse
op_assign
id|jiffies
suffix:semicolon
id|ATOMIC_INCR
c_func
(paren
op_amp
id|rth-&gt;rt_use
)paren
suffix:semicolon
id|ATOMIC_INCR
c_func
(paren
op_amp
id|rth-&gt;rt_refcnt
)paren
suffix:semicolon
id|ip_rt_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|rth
suffix:semicolon
)brace
)brace
r_return
id|ip_rt_slow_route
(paren
id|daddr
comma
id|local
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Process a route add request from the user, or from a kernel&n; *&t;task.&n; */
DECL|function|ip_rt_new
r_int
id|ip_rt_new
c_func
(paren
r_struct
id|rtentry
op_star
id|r
)paren
(brace
r_int
id|err
suffix:semicolon
r_char
op_star
id|devname
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|__u32
id|daddr
comma
id|mask
comma
id|gw
suffix:semicolon
r_int
id|metric
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If a device is specified find it.&n;&t; */
r_if
c_cond
(paren
(paren
id|devname
op_assign
id|r-&gt;rt_dev
)paren
op_ne
l_int|NULL
)paren
(brace
id|err
op_assign
id|getname
c_func
(paren
id|devname
comma
op_amp
id|devname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|dev
op_assign
id|dev_get
c_func
(paren
id|devname
)paren
suffix:semicolon
id|putname
c_func
(paren
id|devname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If the device isn&squot;t INET, don&squot;t allow it&n;&t; */
r_if
c_cond
(paren
id|r-&gt;rt_dst.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Make local copies of the important bits&n;&t; *&t;We decrement the metric by one for BSD compatibility.&n;&t; */
id|flags
op_assign
id|r-&gt;rt_flags
suffix:semicolon
id|daddr
op_assign
(paren
id|__u32
)paren
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_dst
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
suffix:semicolon
id|mask
op_assign
(paren
id|__u32
)paren
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_genmask
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
suffix:semicolon
id|gw
op_assign
(paren
id|__u32
)paren
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_gateway
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
suffix:semicolon
id|metric
op_assign
id|r-&gt;rt_metric
OG
l_int|0
ques
c_cond
id|r-&gt;rt_metric
op_minus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;BSD emulation: Permits route add someroute gw one-of-my-addresses&n;&t; *&t;to indicate which iface. Not as clean as the nice Linux dev technique&n;&t; *&t;but people keep using it...  (and gated likes it ;))&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_and
(paren
id|flags
op_amp
id|RTF_GATEWAY
)paren
)paren
(brace
r_struct
id|device
op_star
id|dev2
suffix:semicolon
r_for
c_loop
(paren
id|dev2
op_assign
id|dev_base
suffix:semicolon
id|dev2
op_ne
l_int|NULL
suffix:semicolon
id|dev2
op_assign
id|dev2-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev2-&gt;flags
op_amp
id|IFF_UP
)paren
op_logical_and
id|dev2-&gt;pa_addr
op_eq
id|gw
)paren
(brace
id|flags
op_and_assign
op_complement
id|RTF_GATEWAY
suffix:semicolon
id|dev
op_assign
id|dev2
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; *&t;Ignore faulty masks&n;&t; */
r_if
c_cond
(paren
id|bad_mask
c_func
(paren
id|mask
comma
id|daddr
)paren
)paren
id|mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Set the mask to nothing for host routes.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|RTF_HOST
)paren
id|mask
op_assign
l_int|0xffffffff
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mask
op_logical_and
id|r-&gt;rt_genmask.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
multiline_comment|/*&n;&t; *&t;You can only gateway IP via IP..&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|RTF_GATEWAY
)paren
(brace
r_if
c_cond
(paren
id|r-&gt;rt_gateway.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
id|dev
op_assign
id|get_gw_dev
c_func
(paren
id|gw
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
id|dev
op_assign
id|ip_dev_check
c_func
(paren
id|daddr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Unknown device.&n;&t; */
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Add the route&n;&t; */
id|rt_add
c_func
(paren
id|flags
comma
id|daddr
comma
id|mask
comma
id|gw
comma
id|dev
comma
id|r-&gt;rt_mss
comma
id|r-&gt;rt_window
comma
id|r-&gt;rt_irtt
comma
id|metric
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Remove a route, as requested by the user.&n; */
DECL|function|rt_kill
r_static
r_int
id|rt_kill
c_func
(paren
r_struct
id|rtentry
op_star
id|r
)paren
(brace
r_struct
id|sockaddr_in
op_star
id|trg
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|msk
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|gtw
suffix:semicolon
r_char
op_star
id|devname
suffix:semicolon
r_int
id|err
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|trg
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_dst
suffix:semicolon
id|msk
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_genmask
suffix:semicolon
id|gtw
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_gateway
suffix:semicolon
r_if
c_cond
(paren
(paren
id|devname
op_assign
id|r-&gt;rt_dev
)paren
op_ne
l_int|NULL
)paren
(brace
id|err
op_assign
id|getname
c_func
(paren
id|devname
comma
op_amp
id|devname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|dev
op_assign
id|dev_get
c_func
(paren
id|devname
)paren
suffix:semicolon
id|putname
c_func
(paren
id|devname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * metric can become negative here if it wasn&squot;t filled in&n;&t; * but that&squot;s a fortunate accident; we really use that in rt_del.&n;&t; */
id|err
op_assign
id|rt_del
c_func
(paren
(paren
id|__u32
)paren
id|trg-&gt;sin_addr.s_addr
comma
(paren
id|__u32
)paren
id|msk-&gt;sin_addr.s_addr
comma
id|dev
comma
(paren
id|__u32
)paren
id|gtw-&gt;sin_addr.s_addr
comma
id|r-&gt;rt_flags
comma
id|r-&gt;rt_metric
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Handle IP routing ioctl calls. These are used to manipulate the routing tables&n; */
DECL|function|ip_rt_ioctl
r_int
id|ip_rt_ioctl
c_func
(paren
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|rtentry
id|rt
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCADDRT
suffix:colon
multiline_comment|/* Add a route */
r_case
id|SIOCDELRT
suffix:colon
multiline_comment|/* Delete a route */
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|rtentry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|rt
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|rtentry
)paren
)paren
suffix:semicolon
r_return
(paren
id|cmd
op_eq
id|SIOCDELRT
)paren
ques
c_cond
id|rt_kill
c_func
(paren
op_amp
id|rt
)paren
suffix:colon
id|ip_rt_new
c_func
(paren
op_amp
id|rt
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|ip_rt_advice
r_void
id|ip_rt_advice
c_func
(paren
r_struct
id|rtable
op_star
op_star
id|rp
comma
r_int
id|advice
)paren
(brace
multiline_comment|/* Thanks! */
r_return
suffix:semicolon
)brace
eof
