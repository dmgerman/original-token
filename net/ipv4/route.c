multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;ROUTE - implementation of the IP router.&n; *&n; * Version:&t;@(#)route.c&t;1.0.14&t;05/31/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Linus Torvalds, &lt;Linus.Torvalds@helsinki.fi&gt;&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;Verify area fixes.&n; *&t;&t;Alan Cox&t;:&t;cli() protects routing changes&n; *&t;&t;Rui Oliveira&t;:&t;ICMP routing table updates&n; *&t;&t;(rco@di.uminho.pt)&t;Routing table insertion and update&n; *&t;&t;Linus Torvalds&t;:&t;Rewrote bits to be sensible&n; *&t;&t;Alan Cox&t;:&t;Added BSD route gw semantics&n; *&t;&t;Alan Cox&t;:&t;Super /proc &gt;4K &n; *&t;&t;Alan Cox&t;:&t;MTU in route table&n; *&t;&t;Alan Cox&t;: &t;MSS actually. Also added the window&n; *&t;&t;&t;&t;&t;clamper.&n; *&t;&t;Sam Lantinga&t;:&t;Fixed route matching in rt_del()&n; *&t;&t;Alan Cox&t;:&t;Routing cache support.&n; *&t;&t;Alan Cox&t;:&t;Removed compatibility cruft.&n; *&t;&t;Alan Cox&t;:&t;RTF_REJECT support.&n; *&t;&t;Alan Cox&t;:&t;TCP irtt support.&n; *&t;&t;Jonathan Naylor&t;:&t;Added Metric support.&n; *&t;Miquel van Smoorenburg&t;:&t;BSD API fixes.&n; *&t;Miquel van Smoorenburg&t;:&t;Metrics.&n; *&t;&t;Alan Cox&t;:&t;Use __u32 properly&n; *&t;&t;Alan Cox&t;:&t;Aligned routing errors more closely with BSD&n; *&t;&t;&t;&t;&t;our system is still very different.&n; *&t;&t;Alan Cox&t;:&t;Faster /proc handling&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;net/netlink.h&gt;
multiline_comment|/*&n; *&t;The routing table list&n; */
DECL|variable|rt_base
r_static
r_struct
id|rtable
op_star
id|rt_base
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|rt_stamp
r_int
r_int
id|rt_stamp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Routing table version stamp for caches ( 0 is &squot;unset&squot; ) */
multiline_comment|/*&n; *&t;Pointer to the loopback route&n; */
DECL|variable|rt_loopback
r_static
r_struct
id|rtable
op_star
id|rt_loopback
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; *&t;Remove a routing table entry.&n; */
DECL|function|rt_del
r_static
r_int
id|rt_del
c_func
(paren
id|__u32
id|dst
comma
id|__u32
id|mask
comma
r_char
op_star
id|devname
comma
id|__u32
id|gtw
comma
r_int
id|rt_flags
comma
r_int
id|metric
)paren
(brace
r_struct
id|rtable
op_star
id|r
comma
op_star
op_star
id|rp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
id|rp
op_assign
op_amp
id|rt_base
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This must be done with interrupts off because we could take&n;&t; *&t;an ICMP_REDIRECT.&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|r
op_assign
op_star
id|rp
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Make sure the destination and netmask match.&n;&t;&t; *&t;metric, gateway and device are also checked&n;&t;&t; *&t;if they were specified.&n;&t;&t; */
r_if
c_cond
(paren
id|r-&gt;rt_dst
op_ne
id|dst
op_logical_or
(paren
id|mask
op_logical_and
id|r-&gt;rt_mask
op_ne
id|mask
)paren
op_logical_or
(paren
id|gtw
op_logical_and
id|r-&gt;rt_gateway
op_ne
id|gtw
)paren
op_logical_or
(paren
id|metric
op_ge
l_int|0
op_logical_and
id|r-&gt;rt_metric
op_ne
id|metric
)paren
op_logical_or
(paren
id|devname
op_logical_and
id|strcmp
c_func
(paren
(paren
id|r-&gt;rt_dev
)paren
op_member_access_from_pointer
id|name
comma
id|devname
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|rp
op_assign
op_amp
id|r-&gt;rt_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
op_star
id|rp
op_assign
id|r-&gt;rt_next
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;If we delete the loopback route update its pointer.&n;&t;&t; */
r_if
c_cond
(paren
id|rt_loopback
op_eq
id|r
)paren
id|rt_loopback
op_assign
l_int|NULL
suffix:semicolon
id|ip_netlink_msg
c_func
(paren
id|RTMSG_DELROUTE
comma
id|dst
comma
id|gtw
comma
id|mask
comma
id|rt_flags
comma
id|metric
comma
id|r-&gt;rt_dev-&gt;name
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|r
comma
r_sizeof
(paren
r_struct
id|rtable
)paren
)paren
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
)brace
id|rt_stamp
op_increment
suffix:semicolon
multiline_comment|/* New table revision */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ESRCH
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Remove all routing table entries for a device. This is called when&n; *&t;a device is downed.&n; */
DECL|function|ip_rt_flush
r_void
id|ip_rt_flush
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|rtable
op_star
id|r
suffix:semicolon
r_struct
id|rtable
op_star
op_star
id|rp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|rp
op_assign
op_amp
id|rt_base
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|r
op_assign
op_star
id|rp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|r-&gt;rt_dev
op_ne
id|dev
)paren
(brace
id|rp
op_assign
op_amp
id|r-&gt;rt_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
op_star
id|rp
op_assign
id|r-&gt;rt_next
suffix:semicolon
r_if
c_cond
(paren
id|rt_loopback
op_eq
id|r
)paren
id|rt_loopback
op_assign
l_int|NULL
suffix:semicolon
id|kfree_s
c_func
(paren
id|r
comma
r_sizeof
(paren
r_struct
id|rtable
)paren
)paren
suffix:semicolon
)brace
id|rt_stamp
op_increment
suffix:semicolon
multiline_comment|/* New table revision */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Used by &squot;rt_add()&squot; when we can&squot;t get the netmask any other way..&n; *&n; *&t;If the lower byte or two are zero, we guess the mask based on the&n; *&t;number of zero 8-bit net numbers, otherwise we use the &quot;default&quot;&n; *&t;masks judging by the destination address and our device netmask.&n; */
DECL|function|default_mask
r_static
id|__u32
r_int
r_int
id|default_mask
c_func
(paren
id|__u32
id|dst
)paren
(brace
id|dst
op_assign
id|ntohl
c_func
(paren
id|dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSA
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSA_NET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSB
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSB_NET
)paren
suffix:semicolon
r_return
id|htonl
c_func
(paren
id|IN_CLASSC_NET
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;If no mask is specified then generate a default entry.&n; */
DECL|function|guess_mask
r_static
id|__u32
id|guess_mask
c_func
(paren
id|__u32
id|dst
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
id|__u32
id|mask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dst
)paren
r_return
l_int|0
suffix:semicolon
id|mask
op_assign
id|default_mask
c_func
(paren
id|dst
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dst
op_xor
id|dev-&gt;pa_addr
)paren
op_amp
id|mask
)paren
r_return
id|mask
suffix:semicolon
r_return
id|dev-&gt;pa_mask
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Find the route entry through which our gateway will be reached&n; */
DECL|function|get_gw_dev
r_static
r_inline
r_struct
id|device
op_star
id|get_gw_dev
c_func
(paren
id|__u32
id|gw
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_for
c_loop
(paren
id|rt
op_assign
id|rt_base
suffix:semicolon
suffix:semicolon
id|rt
op_assign
id|rt-&gt;rt_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rt
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|gw
op_xor
id|rt-&gt;rt_dst
)paren
op_amp
id|rt-&gt;rt_mask
)paren
r_continue
suffix:semicolon
multiline_comment|/* &n;&t;&t; *&t;Gateways behind gateways are a no-no &n;&t;&t; */
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTF_GATEWAY
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|rt-&gt;rt_dev
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Rewrote rt_add(), as the old one was weird - Linus&n; *&n; *&t;This routine is used to update the IP routing table, either&n; *&t;from the kernel (ICMP_REDIRECT) or via an ioctl call issued&n; *&t;by the superuser.&n; */
DECL|function|ip_rt_add
r_void
id|ip_rt_add
c_func
(paren
r_int
id|flags
comma
id|__u32
id|dst
comma
id|__u32
id|mask
comma
id|__u32
id|gw
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|mtu
comma
r_int
r_int
id|window
comma
r_int
r_int
id|irtt
comma
r_int
id|metric
)paren
(brace
r_struct
id|rtable
op_star
id|r
comma
op_star
id|rt
suffix:semicolon
r_struct
id|rtable
op_star
op_star
id|rp
suffix:semicolon
r_int
r_int
id|cpuflags
suffix:semicolon
r_int
id|duplicate
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;A host is a unique machine and has no network bits.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|RTF_HOST
)paren
(brace
id|mask
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Calculate the network mask&n;&t; */
r_else
r_if
c_cond
(paren
op_logical_neg
id|mask
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|dst
op_xor
id|dev-&gt;pa_addr
)paren
op_amp
id|dev-&gt;pa_mask
)paren
)paren
(brace
id|mask
op_assign
id|dev-&gt;pa_mask
suffix:semicolon
id|flags
op_and_assign
op_complement
id|RTF_GATEWAY
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|RTF_DYNAMIC
)paren
(brace
multiline_comment|/*printk(&quot;Dynamic route to my own net rejected&bslash;n&quot;);*/
r_return
suffix:semicolon
)brace
)brace
r_else
id|mask
op_assign
id|guess_mask
c_func
(paren
id|dst
comma
id|dev
)paren
suffix:semicolon
id|dst
op_and_assign
id|mask
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;A gateway must be reachable and not a local address&n;&t; */
r_if
c_cond
(paren
id|gw
op_eq
id|dev-&gt;pa_addr
)paren
id|flags
op_and_assign
op_complement
id|RTF_GATEWAY
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|RTF_GATEWAY
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Don&squot;t try to add a gateway we can&squot;t reach.. &n;&t;&t; */
r_if
c_cond
(paren
id|dev
op_ne
id|get_gw_dev
c_func
(paren
id|gw
)paren
)paren
r_return
suffix:semicolon
id|flags
op_or_assign
id|RTF_GATEWAY
suffix:semicolon
)brace
r_else
id|gw
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate an entry and fill it in.&n;&t; */
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|rtable
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|rt
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|rtable
)paren
)paren
suffix:semicolon
id|rt-&gt;rt_flags
op_assign
id|flags
op_or
id|RTF_UP
suffix:semicolon
id|rt-&gt;rt_dst
op_assign
id|dst
suffix:semicolon
id|rt-&gt;rt_dev
op_assign
id|dev
suffix:semicolon
id|rt-&gt;rt_gateway
op_assign
id|gw
suffix:semicolon
id|rt-&gt;rt_mask
op_assign
id|mask
suffix:semicolon
id|rt-&gt;rt_mss
op_assign
id|dev-&gt;mtu
op_minus
id|HEADER_SIZE
suffix:semicolon
id|rt-&gt;rt_metric
op_assign
id|metric
suffix:semicolon
id|rt-&gt;rt_window
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Default is no clamping */
multiline_comment|/* Are the MSS/Window valid ? */
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTF_MSS
)paren
(brace
id|rt-&gt;rt_mss
op_assign
id|mtu
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTF_WINDOW
)paren
(brace
id|rt-&gt;rt_window
op_assign
id|window
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTF_IRTT
)paren
(brace
id|rt-&gt;rt_irtt
op_assign
id|irtt
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;What we have to do is loop though this until we have&n;&t; *&t;found the first address which has a higher generality than&n;&t; *&t;the one in rt.  Then we can put rt in right before it.&n;&t; *&t;The interrupts must be off for this process.&n;&t; */
id|save_flags
c_func
(paren
id|cpuflags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Remove old route if we are getting a duplicate. &n;&t; */
id|rp
op_assign
op_amp
id|rt_base
suffix:semicolon
r_while
c_loop
(paren
(paren
id|r
op_assign
op_star
id|rp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|r-&gt;rt_dst
op_ne
id|dst
op_logical_or
id|r-&gt;rt_mask
op_ne
id|mask
)paren
(brace
id|rp
op_assign
op_amp
id|r-&gt;rt_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r-&gt;rt_metric
op_ne
id|metric
op_logical_and
id|r-&gt;rt_gateway
op_ne
id|gw
)paren
(brace
id|duplicate
op_assign
l_int|1
suffix:semicolon
id|rp
op_assign
op_amp
id|r-&gt;rt_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
op_star
id|rp
op_assign
id|r-&gt;rt_next
suffix:semicolon
r_if
c_cond
(paren
id|rt_loopback
op_eq
id|r
)paren
id|rt_loopback
op_assign
l_int|NULL
suffix:semicolon
id|ip_netlink_msg
c_func
(paren
id|RTMSG_DELROUTE
comma
id|dst
comma
id|gw
comma
id|mask
comma
id|flags
comma
id|metric
comma
id|rt-&gt;rt_dev-&gt;name
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|r
comma
r_sizeof
(paren
r_struct
id|rtable
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Add the new route &n;&t; */
id|rp
op_assign
op_amp
id|rt_base
suffix:semicolon
r_while
c_loop
(paren
(paren
id|r
op_assign
op_star
id|rp
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * When adding a duplicate route, add it before&n;&t;&t; * the route with a higher metric.&n;&t;&t; */
r_if
c_cond
(paren
id|duplicate
op_logical_and
id|r-&gt;rt_dst
op_eq
id|dst
op_logical_and
id|r-&gt;rt_mask
op_eq
id|mask
op_logical_and
id|r-&gt;rt_metric
OG
id|metric
)paren
r_break
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t; * Otherwise, just add it before the&n;&t;&t; * route with a higher generality.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|r-&gt;rt_mask
op_amp
id|mask
)paren
op_ne
id|mask
)paren
r_break
suffix:semicolon
id|rp
op_assign
op_amp
id|r-&gt;rt_next
suffix:semicolon
)brace
id|rt-&gt;rt_next
op_assign
id|r
suffix:semicolon
op_star
id|rp
op_assign
id|rt
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Update the loopback route&n;&t; */
r_if
c_cond
(paren
(paren
id|rt-&gt;rt_dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
op_logical_and
op_logical_neg
id|rt_loopback
)paren
id|rt_loopback
op_assign
id|rt
suffix:semicolon
id|rt_stamp
op_increment
suffix:semicolon
multiline_comment|/* New table revision */
multiline_comment|/*&n;&t; *&t;Restore the interrupts and return&n;&t; */
id|restore_flags
c_func
(paren
id|cpuflags
)paren
suffix:semicolon
id|ip_netlink_msg
c_func
(paren
id|RTMSG_NEWROUTE
comma
id|dst
comma
id|gw
comma
id|mask
comma
id|flags
comma
id|metric
comma
id|rt-&gt;rt_dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Check if a mask is acceptable.&n; */
DECL|function|bad_mask
r_static
r_inline
r_int
id|bad_mask
c_func
(paren
id|__u32
id|mask
comma
id|__u32
id|addr
)paren
(brace
r_if
c_cond
(paren
id|addr
op_amp
(paren
id|mask
op_assign
op_complement
id|mask
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|mask
op_assign
id|ntohl
c_func
(paren
id|mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
(paren
id|mask
op_plus
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Process a route add request from the user&n; */
DECL|function|rt_new
r_static
r_int
id|rt_new
c_func
(paren
r_struct
id|rtentry
op_star
id|r
)paren
(brace
r_int
id|err
suffix:semicolon
r_char
op_star
id|devname
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|__u32
id|daddr
comma
id|mask
comma
id|gw
suffix:semicolon
r_int
id|metric
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If a device is specified find it.&n;&t; */
r_if
c_cond
(paren
(paren
id|devname
op_assign
id|r-&gt;rt_dev
)paren
op_ne
l_int|NULL
)paren
(brace
id|err
op_assign
id|getname
c_func
(paren
id|devname
comma
op_amp
id|devname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|dev
op_assign
id|dev_get
c_func
(paren
id|devname
)paren
suffix:semicolon
id|putname
c_func
(paren
id|devname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If the device isn&squot;t INET, don&squot;t allow it&n;&t; */
r_if
c_cond
(paren
id|r-&gt;rt_dst.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Make local copies of the important bits&n;&t; *&t;We decrement the metric by one for BSD compatibility.&n;&t; */
id|flags
op_assign
id|r-&gt;rt_flags
suffix:semicolon
id|daddr
op_assign
(paren
id|__u32
)paren
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_dst
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
suffix:semicolon
id|mask
op_assign
(paren
id|__u32
)paren
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_genmask
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
suffix:semicolon
id|gw
op_assign
(paren
id|__u32
)paren
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_gateway
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
suffix:semicolon
id|metric
op_assign
id|r-&gt;rt_metric
OG
l_int|0
ques
c_cond
id|r-&gt;rt_metric
op_minus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;BSD emulation: Permits route add someroute gw one-of-my-addresses&n;&t; *&t;to indicate which iface. Not as clean as the nice Linux dev technique&n;&t; *&t;but people keep using it... &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_and
(paren
id|flags
op_amp
id|RTF_GATEWAY
)paren
)paren
(brace
r_struct
id|device
op_star
id|dev2
suffix:semicolon
r_for
c_loop
(paren
id|dev2
op_assign
id|dev_base
suffix:semicolon
id|dev2
op_ne
l_int|NULL
suffix:semicolon
id|dev2
op_assign
id|dev2-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev2-&gt;flags
op_amp
id|IFF_UP
)paren
op_logical_and
id|dev2-&gt;pa_addr
op_eq
id|gw
)paren
(brace
id|flags
op_and_assign
op_complement
id|RTF_GATEWAY
suffix:semicolon
id|dev
op_assign
id|dev2
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; *&t;Ignore faulty masks&n;&t; */
r_if
c_cond
(paren
id|bad_mask
c_func
(paren
id|mask
comma
id|daddr
)paren
)paren
id|mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Set the mask to nothing for host routes.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|RTF_HOST
)paren
id|mask
op_assign
l_int|0xffffffff
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mask
op_logical_and
id|r-&gt;rt_genmask.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
multiline_comment|/*&n;&t; *&t;You can only gateway IP via IP..&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|RTF_GATEWAY
)paren
(brace
r_if
c_cond
(paren
id|r-&gt;rt_gateway.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
id|dev
op_assign
id|get_gw_dev
c_func
(paren
id|gw
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
id|dev
op_assign
id|ip_dev_check
c_func
(paren
id|daddr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Unknown device.&n;&t; */
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Add the route&n;&t; */
id|ip_rt_add
c_func
(paren
id|flags
comma
id|daddr
comma
id|mask
comma
id|gw
comma
id|dev
comma
id|r-&gt;rt_mss
comma
id|r-&gt;rt_window
comma
id|r-&gt;rt_irtt
comma
id|metric
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Remove a route, as requested by the user.&n; */
DECL|function|rt_kill
r_static
r_int
id|rt_kill
c_func
(paren
r_struct
id|rtentry
op_star
id|r
)paren
(brace
r_struct
id|sockaddr_in
op_star
id|trg
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|msk
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|gtw
suffix:semicolon
r_char
op_star
id|devname
suffix:semicolon
r_int
id|err
suffix:semicolon
id|trg
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_dst
suffix:semicolon
id|msk
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_genmask
suffix:semicolon
id|gtw
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_gateway
suffix:semicolon
r_if
c_cond
(paren
(paren
id|devname
op_assign
id|r-&gt;rt_dev
)paren
op_ne
l_int|NULL
)paren
(brace
id|err
op_assign
id|getname
c_func
(paren
id|devname
comma
op_amp
id|devname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * metric can become negative here if it wasn&squot;t filled in&n;&t; * but that&squot;s a fortunate accident; we really use that in rt_del.&n;&t; */
id|err
op_assign
id|rt_del
c_func
(paren
(paren
id|__u32
)paren
id|trg-&gt;sin_addr.s_addr
comma
(paren
id|__u32
)paren
id|msk-&gt;sin_addr.s_addr
comma
id|devname
comma
(paren
id|__u32
)paren
id|gtw-&gt;sin_addr.s_addr
comma
id|r-&gt;rt_flags
comma
id|r-&gt;rt_metric
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devname
op_ne
l_int|NULL
)paren
id|putname
c_func
(paren
id|devname
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Called from the PROCfs module. This outputs /proc/net/route.&n; *&n; *&t;We preserve the old format but pad the buffers out. This means that&n; *&t;we can spin over the other entries as we read them. Remember the&n; *&t;gated BGP4 code could need to read 60,000+ routes on occasion (thats&n; *&t;about 7Mb of data). To do that ok we will need to also cache the&n; *&t;last route we got to (reads will generally be following on from&n; *&t;one another without gaps).&n; */
DECL|function|rt_get_info
r_int
id|rt_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|dummy
)paren
(brace
r_struct
id|rtable
op_star
id|r
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
r_char
id|temp
(braket
l_int|129
)braket
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
l_int|128
)paren
(brace
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%-127s&bslash;n&quot;
comma
l_string|&quot;Iface&bslash;tDestination&bslash;tGateway &bslash;tFlags&bslash;tRefCnt&bslash;tUse&bslash;tMetric&bslash;tMask&bslash;t&bslash;tMTU&bslash;tWindow&bslash;tIRTT&quot;
)paren
suffix:semicolon
id|pos
op_assign
l_int|128
suffix:semicolon
)brace
r_for
c_loop
(paren
id|r
op_assign
id|rt_base
suffix:semicolon
id|r
op_ne
l_int|NULL
suffix:semicolon
id|r
op_assign
id|r-&gt;rt_next
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Spin through entries until we are ready&n;&t;&t; */
r_if
c_cond
(paren
id|pos
op_plus
l_int|128
OL
id|offset
)paren
(brace
id|pos
op_add_assign
l_int|128
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|temp
comma
l_string|&quot;%s&bslash;t%08lX&bslash;t%08lX&bslash;t%02X&bslash;t%d&bslash;t%lu&bslash;t%d&bslash;t%08lX&bslash;t%d&bslash;t%lu&bslash;t%u&quot;
comma
id|r-&gt;rt_dev-&gt;name
comma
(paren
r_int
r_int
)paren
id|r-&gt;rt_dst
comma
(paren
r_int
r_int
)paren
id|r-&gt;rt_gateway
comma
id|r-&gt;rt_flags
comma
id|r-&gt;rt_refcnt
comma
id|r-&gt;rt_use
comma
id|r-&gt;rt_metric
comma
(paren
r_int
r_int
)paren
id|r-&gt;rt_mask
comma
(paren
r_int
)paren
id|r-&gt;rt_mss
comma
id|r-&gt;rt_window
comma
(paren
r_int
)paren
id|r-&gt;rt_irtt
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%-127s&bslash;n&quot;
comma
id|temp
)paren
suffix:semicolon
id|len
op_add_assign
l_int|128
suffix:semicolon
id|pos
op_add_assign
l_int|128
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is hackish, but results in better code. Use &quot;-S&quot; to see why.&n; */
DECL|macro|early_out
mdefine_line|#define early_out ({ goto no_route; 1; })
multiline_comment|/*&n; *&t;Route a packet. This needs to be fairly quick. Florian &amp; Co. &n; *&t;suggested a unified ARP and IP routing cache. Done right its&n; *&t;probably a brilliant idea. I&squot;d actually suggest a unified&n; *&t;ARP/IP routing/Socket pointer cache. Volunteers welcome&n; */
DECL|function|ip_rt_route
r_struct
id|rtable
op_star
id|ip_rt_route
c_func
(paren
id|__u32
id|daddr
comma
r_struct
id|options
op_star
id|opt
comma
id|__u32
op_star
id|src_addr
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_for
c_loop
(paren
id|rt
op_assign
id|rt_base
suffix:semicolon
id|rt
op_ne
l_int|NULL
op_logical_or
id|early_out
suffix:semicolon
id|rt
op_assign
id|rt-&gt;rt_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|rt-&gt;rt_dst
op_xor
id|daddr
)paren
op_amp
id|rt-&gt;rt_mask
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;broadcast addresses can be special cases.. &n;&t;&t; */
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTF_GATEWAY
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rt-&gt;rt_dev-&gt;flags
op_amp
id|IFF_BROADCAST
)paren
op_logical_and
(paren
id|rt-&gt;rt_dev-&gt;pa_brdaddr
op_eq
id|daddr
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTF_REJECT
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|src_addr
op_ne
l_int|NULL
)paren
(brace
op_star
id|src_addr
op_assign
id|rt-&gt;rt_dev-&gt;pa_addr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|daddr
op_eq
id|rt-&gt;rt_dev-&gt;pa_addr
)paren
(brace
r_if
c_cond
(paren
(paren
id|rt
op_assign
id|rt_loopback
)paren
op_eq
l_int|NULL
)paren
r_goto
id|no_route
suffix:semicolon
)brace
id|rt-&gt;rt_use
op_increment
suffix:semicolon
r_return
id|rt
suffix:semicolon
id|no_route
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|ip_rt_local
r_struct
id|rtable
op_star
id|ip_rt_local
c_func
(paren
id|__u32
id|daddr
comma
r_struct
id|options
op_star
id|opt
comma
id|__u32
op_star
id|src_addr
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_for
c_loop
(paren
id|rt
op_assign
id|rt_base
suffix:semicolon
id|rt
op_ne
l_int|NULL
op_logical_or
id|early_out
suffix:semicolon
id|rt
op_assign
id|rt-&gt;rt_next
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;No routed addressing.&n;&t;&t; */
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTF_GATEWAY
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|rt-&gt;rt_dst
op_xor
id|daddr
)paren
op_amp
id|rt-&gt;rt_mask
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;broadcast addresses can be special cases.. &n;&t;&t; */
r_if
c_cond
(paren
(paren
id|rt-&gt;rt_dev-&gt;flags
op_amp
id|IFF_BROADCAST
)paren
op_logical_and
id|rt-&gt;rt_dev-&gt;pa_brdaddr
op_eq
id|daddr
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|src_addr
op_ne
l_int|NULL
)paren
(brace
op_star
id|src_addr
op_assign
id|rt-&gt;rt_dev-&gt;pa_addr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|daddr
op_eq
id|rt-&gt;rt_dev-&gt;pa_addr
)paren
(brace
r_if
c_cond
(paren
(paren
id|rt
op_assign
id|rt_loopback
)paren
op_eq
l_int|NULL
)paren
r_goto
id|no_route
suffix:semicolon
)brace
id|rt-&gt;rt_use
op_increment
suffix:semicolon
r_return
id|rt
suffix:semicolon
id|no_route
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Handle IP routing ioctl calls. These are used to manipulate the routing tables&n; */
DECL|function|ip_rt_ioctl
r_int
id|ip_rt_ioctl
c_func
(paren
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|rtentry
id|rt
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCADDRT
suffix:colon
multiline_comment|/* Add a route */
r_case
id|SIOCDELRT
suffix:colon
multiline_comment|/* Delete a route */
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|rtentry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|rt
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|rtentry
)paren
)paren
suffix:semicolon
r_return
(paren
id|cmd
op_eq
id|SIOCDELRT
)paren
ques
c_cond
id|rt_kill
c_func
(paren
op_amp
id|rt
)paren
suffix:colon
id|rt_new
c_func
(paren
op_amp
id|rt
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
eof
