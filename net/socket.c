multiline_comment|/*&n; * NET&t;&t;An implementation of the SOCKET network access protocol.&n; *&n; * Version:&t;@(#)socket.c&t;1.1.93&t;18/02/95&n; *&n; * Authors:&t;Orest Zborowski, &lt;obz@Kodak.COM&gt;&n; *&t;&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&n; * Fixes:&n; *&t;&t;Anonymous&t;:&t;NOTSOCK/BADF cleanup. Error fix in&n; *&t;&t;&t;&t;&t;shutdown()&n; *&t;&t;Alan Cox&t;:&t;verify_area() fixes&n; *&t;&t;Alan Cox&t;:&t;Removed DDI&n; *&t;&t;Jonathan Kamens&t;:&t;SOCK_DGRAM reconnect bug&n; *&t;&t;Alan Cox&t;:&t;Moved a load of checks to the very&n; *&t;&t;&t;&t;&t;top level.&n; *&t;&t;Alan Cox&t;:&t;Move address structures to/from user&n; *&t;&t;&t;&t;&t;mode above the protocol layers.&n; *&t;&t;Rob Janssen&t;:&t;Allow 0 length sends.&n; *&t;&t;Alan Cox&t;:&t;Asynchronous I/O support (cribbed from the&n; *&t;&t;&t;&t;&t;tty drivers).&n; *&t;&t;Niibe Yutaka&t;:&t;Asynchronous I/O for writes (4.4BSD style)&n; *&t;&t;Jeff Uphoff&t;:&t;Made max number of sockets command-line&n; *&t;&t;&t;&t;&t;configurable.&n; *&t;&t;Matti Aarnio&t;:&t;Made the number of sockets dynamic,&n; *&t;&t;&t;&t;&t;to be allocated when needed, and mr.&n; *&t;&t;&t;&t;&t;Uphoff&squot;s max is used as max to be&n; *&t;&t;&t;&t;&t;allowed to allocate.&n; *&t;&t;Linus&t;&t;:&t;Argh. removed all the socket allocation&n; *&t;&t;&t;&t;&t;altogether: it&squot;s in the inode now.&n; *&t;&t;Alan Cox&t;:&t;Made sock_alloc()/sock_release() public&n; *&t;&t;&t;&t;&t;for NetROM and future kernel nfsd type&n; *&t;&t;&t;&t;&t;stuff.&n; *&t;&t;Alan Cox&t;:&t;sendmsg/recvmsg basics.&n; *&t;&t;Tom Dyas&t;:&t;Export net symbols.&n; *&t;&t;Marcin Dalecki&t;:&t;Fixed problems with CONFIG_NET=&quot;n&quot;.&n; *&t;&t;Alan Cox&t;:&t;Added thread locking to sys_* calls&n; *&t;&t;&t;&t;&t;for sockets. May have errors at the&n; *&t;&t;&t;&t;&t;moment.&n; *&t;&t;Kevin Buhr&t;:&t;Fixed the dumb errors in the above.&n; *&t;&t;Andi Kleen&t;:&t;Some small cleanups, optimizations,&n; *&t;&t;&t;&t;&t;and fixed a copy_from_user() bug.&n; *&t;&t;Tigran Aivazian&t;:&t;sys_send(args) calls sys_sendto(args, NULL, 0)&n; *&t;&t;Tigran Aivazian&t;:&t;Made listen(2) backlog sanity checks &n; *&t;&t;&t;&t;&t;protocol-independent&n; *&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; *&n; *&t;This module is effectively the top level interface to the BSD socket&n; *&t;paradigm. &n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/wanrouter.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/cache.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#if defined(CONFIG_KMOD) &amp;&amp; defined(CONFIG_NET)
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;net/scm.h&gt;
macro_line|#include &lt;linux/netfilter.h&gt;
r_static
r_int
id|sock_no_open
c_func
(paren
r_struct
id|inode
op_star
id|irrelevant
comma
r_struct
id|file
op_star
id|dontcare
)paren
suffix:semicolon
r_static
id|loff_t
id|sock_lseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|whence
)paren
suffix:semicolon
r_static
id|ssize_t
id|sock_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|size
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
r_static
id|ssize_t
id|sock_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|size
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
r_static
r_int
id|sock_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
suffix:semicolon
r_static
r_int
id|sock_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
r_int
id|sock_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
suffix:semicolon
r_static
r_int
id|sock_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|sock_fasync
c_func
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|on
)paren
suffix:semicolon
r_static
id|ssize_t
id|sock_readv
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_struct
id|iovec
op_star
id|vector
comma
r_int
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
r_static
id|ssize_t
id|sock_writev
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_struct
id|iovec
op_star
id|vector
comma
r_int
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Socket files have a set of &squot;special&squot; operations as well as the generic file ones. These don&squot;t appear&n; *&t;in the operation structures but are done directly via the socketcall() multiplexor.&n; */
DECL|variable|socket_file_ops
r_static
r_struct
id|file_operations
id|socket_file_ops
op_assign
(brace
id|llseek
suffix:colon
id|sock_lseek
comma
id|read
suffix:colon
id|sock_read
comma
id|write
suffix:colon
id|sock_write
comma
id|poll
suffix:colon
id|sock_poll
comma
id|ioctl
suffix:colon
id|sock_ioctl
comma
id|mmap
suffix:colon
id|sock_mmap
comma
id|open
suffix:colon
id|sock_no_open
comma
multiline_comment|/* special open code to disallow open via /proc */
id|release
suffix:colon
id|sock_close
comma
id|fasync
suffix:colon
id|sock_fasync
comma
id|readv
suffix:colon
id|sock_readv
comma
id|writev
suffix:colon
id|sock_writev
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;The protocol list. Each protocol is registered in here.&n; */
DECL|variable|net_families
r_static
r_struct
id|net_proto_family
op_star
id|net_families
(braket
id|NPROTO
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
DECL|variable|net_family_lockct
r_static
id|atomic_t
id|net_family_lockct
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|net_family_lock
r_static
id|spinlock_t
id|net_family_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* The strategy is: modifications net_family vector are short, do not&n;   sleep and veeery rare, but read access should be free of any exclusive&n;   locks.&n; */
DECL|function|net_family_write_lock
r_static
r_void
id|net_family_write_lock
c_func
(paren
r_void
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|net_family_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|net_family_lockct
)paren
op_ne
l_int|0
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|net_family_lock
)paren
suffix:semicolon
id|current-&gt;policy
op_or_assign
id|SCHED_YIELD
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|net_family_lock
)paren
suffix:semicolon
)brace
)brace
DECL|function|net_family_write_unlock
r_static
id|__inline__
r_void
id|net_family_write_unlock
c_func
(paren
r_void
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|net_family_lock
)paren
suffix:semicolon
)brace
DECL|function|net_family_read_lock
r_static
id|__inline__
r_void
id|net_family_read_lock
c_func
(paren
r_void
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|net_family_lockct
)paren
suffix:semicolon
id|spin_unlock_wait
c_func
(paren
op_amp
id|net_family_lock
)paren
suffix:semicolon
)brace
DECL|function|net_family_read_unlock
r_static
id|__inline__
r_void
id|net_family_read_unlock
c_func
(paren
r_void
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|net_family_lockct
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|net_family_write_lock
mdefine_line|#define net_family_write_lock() do { } while(0)
DECL|macro|net_family_write_unlock
mdefine_line|#define net_family_write_unlock() do { } while(0)
DECL|macro|net_family_read_lock
mdefine_line|#define net_family_read_lock() do { } while(0)
DECL|macro|net_family_read_unlock
mdefine_line|#define net_family_read_unlock() do { } while(0)
macro_line|#endif
multiline_comment|/*&n; *&t;Statistics counters of the socket lists&n; */
r_static
r_union
(brace
DECL|member|counter
r_int
id|counter
suffix:semicolon
DECL|member|__pad
r_char
id|__pad
(braket
id|SMP_CACHE_BYTES
)braket
suffix:semicolon
DECL|variable|__cacheline_aligned
)brace
id|sockets_in_use
(braket
id|NR_CPUS
)braket
id|__cacheline_aligned
op_assign
(brace
(brace
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Support routines. Move socket addresses back and forth across the kernel/user&n; *&t;divide and look after the messy bits.&n; */
DECL|macro|MAX_SOCK_ADDR
mdefine_line|#define MAX_SOCK_ADDR&t;128&t;&t;/* 108 for Unix domain - &n;&t;&t;&t;&t;&t;   16 for IP, 16 for IPX,&n;&t;&t;&t;&t;&t;   24 for IPv6,&n;&t;&t;&t;&t;&t;   about 80 for AX.25 &n;&t;&t;&t;&t;&t;   must be at least one bigger than&n;&t;&t;&t;&t;&t;   the AF_UNIX size (see net/unix/af_unix.c&n;&t;&t;&t;&t;&t;   :unix_mkname()).  &n;&t;&t;&t;&t;&t; */
multiline_comment|/**&n; *&t;move_addr_to_kernel&t;-&t;copy a socket address into kernel space&n; *&t;@uaddr: Address in user space&n; *&t;@kaddr: Address in kernel space&n; *&t;@ulen: Length in user space&n; *&n; *&t;The address is copied into kernel space. If the provided address is&n; *&t;too long an error code of -EINVAL is returned. If the copy gives&n; *&t;invalid addresses -EFAULT is returned. On a success 0 is returned.&n; */
DECL|function|move_addr_to_kernel
r_int
id|move_addr_to_kernel
c_func
(paren
r_void
op_star
id|uaddr
comma
r_int
id|ulen
comma
r_void
op_star
id|kaddr
)paren
(brace
r_if
c_cond
(paren
id|ulen
id|MAX_SOCK_ADDR
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ulen
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|kaddr
comma
id|uaddr
comma
id|ulen
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;move_addr_to_user&t;-&t;copy an address to user space&n; *&t;@kaddr: kernel space address&n; *&t;@klen: length of address in kernel&n; *&t;@uaddr: user space address&n; *&t;@ulen: pointer to user length field&n; *&n; *&t;The value pointed to by ulen on entry is the buffer length available.&n; *&t;This is overwritten with the buffer space used. -EINVAL is returned&n; *&t;if an overlong buffer is specified or a negative buffer size. -EFAULT&n; *&t;is returned if either the buffer or the length field are not&n; *&t;accessible.&n; *&t;After copying the data up to the limit the user specifies, the true&n; *&t;length of the data is written over the length limit the user&n; *&t;specified. Zero is returned for a success.&n; */
DECL|function|move_addr_to_user
r_int
id|move_addr_to_user
c_func
(paren
r_void
op_star
id|kaddr
comma
r_int
id|klen
comma
r_void
op_star
id|uaddr
comma
r_int
op_star
id|ulen
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|get_user
c_func
(paren
id|len
comma
id|ulen
)paren
)paren
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
id|klen
)paren
(brace
id|len
op_assign
id|klen
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
id|MAX_SOCK_ADDR
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|uaddr
comma
id|kaddr
comma
id|len
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;&quot;fromlen shall refer to the value before truncation..&quot;&n;&t; *&t;&t;&t;1003.1g&n;&t; */
r_return
id|__put_user
c_func
(paren
id|klen
comma
id|ulen
)paren
suffix:semicolon
)brace
DECL|macro|SOCKFS_MAGIC
mdefine_line|#define SOCKFS_MAGIC 0x534F434B
DECL|function|sockfs_statfs
r_static
r_int
id|sockfs_statfs
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|statfs
op_star
id|buf
)paren
(brace
id|buf-&gt;f_type
op_assign
id|SOCKFS_MAGIC
suffix:semicolon
id|buf-&gt;f_bsize
op_assign
l_int|1024
suffix:semicolon
id|buf-&gt;f_namelen
op_assign
l_int|255
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|sockfs_ops
r_static
r_struct
id|super_operations
id|sockfs_ops
op_assign
(brace
id|statfs
suffix:colon
id|sockfs_statfs
comma
)brace
suffix:semicolon
DECL|function|sockfs_read_super
r_static
r_struct
id|super_block
op_star
id|sockfs_read_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|data
comma
r_int
id|silent
)paren
(brace
r_struct
id|inode
op_star
id|root
op_assign
id|new_inode
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root
)paren
r_return
l_int|NULL
suffix:semicolon
id|root-&gt;i_mode
op_assign
id|S_IFDIR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
suffix:semicolon
id|root-&gt;i_uid
op_assign
id|root-&gt;i_gid
op_assign
l_int|0
suffix:semicolon
id|root-&gt;i_atime
op_assign
id|root-&gt;i_mtime
op_assign
id|root-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|sb-&gt;s_blocksize
op_assign
l_int|1024
suffix:semicolon
id|sb-&gt;s_blocksize_bits
op_assign
l_int|10
suffix:semicolon
id|sb-&gt;s_magic
op_assign
id|SOCKFS_MAGIC
suffix:semicolon
id|sb-&gt;s_op
op_assign
op_amp
id|sockfs_ops
suffix:semicolon
id|sb-&gt;s_root
op_assign
id|d_alloc
c_func
(paren
l_int|NULL
comma
op_amp
(paren
r_const
r_struct
id|qstr
)paren
(brace
l_string|&quot;socket:&quot;
comma
l_int|7
comma
l_int|0
)brace
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb-&gt;s_root
)paren
(brace
id|iput
c_func
(paren
id|root
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|sb-&gt;s_root-&gt;d_sb
op_assign
id|sb
suffix:semicolon
id|sb-&gt;s_root-&gt;d_parent
op_assign
id|sb-&gt;s_root
suffix:semicolon
id|d_instantiate
c_func
(paren
id|sb-&gt;s_root
comma
id|root
)paren
suffix:semicolon
r_return
id|sb
suffix:semicolon
)brace
DECL|variable|sock_mnt
r_static
r_struct
id|vfsmount
op_star
id|sock_mnt
suffix:semicolon
r_static
id|DECLARE_FSTYPE
c_func
(paren
id|sock_fs_type
comma
l_string|&quot;sockfs&quot;
comma
id|sockfs_read_super
comma
id|FS_NOMOUNT
op_or
id|FS_SINGLE
)paren
suffix:semicolon
DECL|function|sockfs_delete_dentry
r_static
r_int
id|sockfs_delete_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|sockfs_dentry_operations
r_static
r_struct
id|dentry_operations
id|sockfs_dentry_operations
op_assign
(brace
id|d_delete
suffix:colon
id|sockfs_delete_dentry
comma
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Obtains the first available file descriptor and sets it up for use.&n; *&n; *&t;This functions creates file structure and maps it to fd space&n; *&t;of current process. On success it returns file descriptor&n; *&t;and file struct implicitly stored in sock-&gt;file.&n; *&t;Note that another thread may close file descriptor before we return&n; *&t;from this function. We use the fact that now we do not refer&n; *&t;to socket after mapping. If one day we will need it, this&n; *&t;function will inincrement ref. count on file by 1.&n; *&n; *&t;In any case returned fd MAY BE not valid!&n; *&t;This race condition is inavoidable&n; *&t;with shared fd spaces, we cannot solve is inside kernel,&n; *&t;but we take care of internal coherence yet.&n; */
DECL|function|sock_map_fd
r_static
r_int
id|sock_map_fd
c_func
(paren
r_struct
id|socket
op_star
id|sock
)paren
(brace
r_int
id|fd
suffix:semicolon
r_struct
id|qstr
id|this
suffix:semicolon
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Find a file descriptor suitable for return to the user. &n;&t; */
id|fd
op_assign
id|get_unused_fd
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
op_ge
l_int|0
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|get_empty_filp
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
(brace
id|put_unused_fd
c_func
(paren
id|fd
)paren
suffix:semicolon
id|fd
op_assign
op_minus
id|ENFILE
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;[%lu]&quot;
comma
id|sock-&gt;inode-&gt;i_ino
)paren
suffix:semicolon
id|this.name
op_assign
id|name
suffix:semicolon
id|this.len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|this.hash
op_assign
id|sock-&gt;inode-&gt;i_ino
suffix:semicolon
id|file-&gt;f_dentry
op_assign
id|d_alloc
c_func
(paren
id|sock_mnt-&gt;mnt_sb-&gt;s_root
comma
op_amp
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_dentry
)paren
(brace
id|put_filp
c_func
(paren
id|file
)paren
suffix:semicolon
id|put_unused_fd
c_func
(paren
id|fd
)paren
suffix:semicolon
id|fd
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|file-&gt;f_dentry-&gt;d_op
op_assign
op_amp
id|sockfs_dentry_operations
suffix:semicolon
id|d_add
c_func
(paren
id|file-&gt;f_dentry
comma
id|sock-&gt;inode
)paren
suffix:semicolon
id|file-&gt;f_vfsmnt
op_assign
id|mntget
c_func
(paren
id|sock_mnt
)paren
suffix:semicolon
id|sock-&gt;file
op_assign
id|file
suffix:semicolon
id|file-&gt;f_op
op_assign
id|sock-&gt;inode-&gt;i_fop
op_assign
op_amp
id|socket_file_ops
suffix:semicolon
id|file-&gt;f_mode
op_assign
l_int|3
suffix:semicolon
id|file-&gt;f_flags
op_assign
id|O_RDWR
suffix:semicolon
id|file-&gt;f_pos
op_assign
l_int|0
suffix:semicolon
id|fd_install
c_func
(paren
id|fd
comma
id|file
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|fd
suffix:semicolon
)brace
DECL|function|socki_lookup
r_extern
id|__inline__
r_struct
id|socket
op_star
id|socki_lookup
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_return
op_amp
id|inode-&gt;u.socket_i
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;sockfd_lookup&t;- &t;Go from a file number to its socket slot&n; *&t;@fd: file handle&n; *&t;@err: pointer to an error code return&n; *&n; *&t;The file handle passed in is locked and the socket it is bound&n; *&t;too is returned. If an error occurs the err pointer is overwritten&n; *&t;with a negative errno code and NULL is returned. The function checks&n; *&t;for both invalid handles and passing a handle which is not a socket.&n; *&n; *&t;On a success the socket object pointer is returned.&n; */
DECL|function|sockfd_lookup
r_struct
id|socket
op_star
id|sockfd_lookup
c_func
(paren
r_int
id|fd
comma
r_int
op_star
id|err
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
)paren
)paren
(brace
op_star
id|err
op_assign
op_minus
id|EBADF
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_sock
op_logical_or
op_logical_neg
(paren
id|sock
op_assign
id|socki_lookup
c_func
(paren
id|inode
)paren
)paren
)paren
(brace
op_star
id|err
op_assign
op_minus
id|ENOTSOCK
suffix:semicolon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sock-&gt;file
op_ne
id|file
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;socki_lookup: socket file changed!&bslash;n&quot;
)paren
suffix:semicolon
id|sock-&gt;file
op_assign
id|file
suffix:semicolon
)brace
r_return
id|sock
suffix:semicolon
)brace
DECL|function|sockfd_put
r_extern
id|__inline__
r_void
id|sockfd_put
c_func
(paren
r_struct
id|socket
op_star
id|sock
)paren
(brace
id|fput
c_func
(paren
id|sock-&gt;file
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;sock_alloc&t;-&t;allocate a socket&n; *&t;&n; *&t;Allocate a new inode and socket object. The two are bound together&n; *&t;and initialised. The socket is then returned. If we are out of inodes&n; *&t;NULL is returned.&n; */
DECL|function|sock_alloc
r_struct
id|socket
op_star
id|sock_alloc
c_func
(paren
r_void
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|socket
op_star
id|sock
suffix:semicolon
id|inode
op_assign
id|get_empty_inode
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_return
l_int|NULL
suffix:semicolon
id|inode-&gt;i_sb
op_assign
id|sock_mnt-&gt;mnt_sb
suffix:semicolon
id|sock
op_assign
id|socki_lookup
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode-&gt;i_mode
op_assign
id|S_IFSOCK
op_or
id|S_IRWXUGO
suffix:semicolon
id|inode-&gt;i_sock
op_assign
l_int|1
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|current-&gt;fsgid
suffix:semicolon
id|sock-&gt;inode
op_assign
id|inode
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|sock-&gt;wait
)paren
suffix:semicolon
id|sock-&gt;fasync_list
op_assign
l_int|NULL
suffix:semicolon
id|sock-&gt;state
op_assign
id|SS_UNCONNECTED
suffix:semicolon
id|sock-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|sock-&gt;ops
op_assign
l_int|NULL
suffix:semicolon
id|sock-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|sock-&gt;file
op_assign
l_int|NULL
suffix:semicolon
id|sockets_in_use
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|counter
op_increment
suffix:semicolon
r_return
id|sock
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;In theory you can&squot;t get an open on this inode, but /proc provides&n; *&t;a back door. Remember to keep it shut otherwise you&squot;ll let the&n; *&t;creepy crawlies in.&n; */
DECL|function|sock_no_open
r_static
r_int
id|sock_no_open
c_func
(paren
r_struct
id|inode
op_star
id|irrelevant
comma
r_struct
id|file
op_star
id|dontcare
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;sock_release&t;-&t;close a socket&n; *&t;@sock: socket to close&n; *&n; *&t;The socket is released from the protocol stack if it has a release&n; *&t;callback, and the inode is then released if the socket is bound to&n; *&t;an inode not a file. &n; */
DECL|function|sock_release
r_void
id|sock_release
c_func
(paren
r_struct
id|socket
op_star
id|sock
)paren
(brace
r_if
c_cond
(paren
id|sock-&gt;ops
)paren
id|sock-&gt;ops
op_member_access_from_pointer
id|release
c_func
(paren
id|sock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sock-&gt;fasync_list
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sock_release: fasync list not empty!&bslash;n&quot;
)paren
suffix:semicolon
id|sockets_in_use
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|counter
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock-&gt;file
)paren
(brace
id|iput
c_func
(paren
id|sock-&gt;inode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sock-&gt;file
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|sock_sendmsg
r_int
id|sock_sendmsg
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|size
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|scm_cookie
id|scm
suffix:semicolon
id|err
op_assign
id|scm_send
c_func
(paren
id|sock
comma
id|msg
comma
op_amp
id|scm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ge
l_int|0
)paren
(brace
id|err
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|sendmsg
c_func
(paren
id|sock
comma
id|msg
comma
id|size
comma
op_amp
id|scm
)paren
suffix:semicolon
id|scm_destroy
c_func
(paren
op_amp
id|scm
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|sock_recvmsg
r_int
id|sock_recvmsg
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|size
comma
r_int
id|flags
)paren
(brace
r_struct
id|scm_cookie
id|scm
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|scm
comma
l_int|0
comma
r_sizeof
(paren
id|scm
)paren
)paren
suffix:semicolon
id|size
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|recvmsg
c_func
(paren
id|sock
comma
id|msg
comma
id|size
comma
id|flags
comma
op_amp
id|scm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_ge
l_int|0
)paren
id|scm_recv
c_func
(paren
id|sock
comma
id|msg
comma
op_amp
id|scm
comma
id|flags
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Sockets are not seekable.&n; */
DECL|function|sock_lseek
r_static
id|loff_t
id|sock_lseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|whence
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Read data from a socket. ubuf is a user mode pointer. We make sure the user&n; *&t;area ubuf...ubuf+size-1 is writable before asking the protocol.&n; */
DECL|function|sock_read
r_static
id|ssize_t
id|sock_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|ubuf
comma
r_int
id|size
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_struct
id|iovec
id|iov
suffix:semicolon
r_struct
id|msghdr
id|msg
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
multiline_comment|/* Match SYS5 behaviour */
r_return
l_int|0
suffix:semicolon
id|sock
op_assign
id|socki_lookup
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
id|msg.msg_name
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_namelen
op_assign
l_int|0
suffix:semicolon
id|msg.msg_iov
op_assign
op_amp
id|iov
suffix:semicolon
id|msg.msg_iovlen
op_assign
l_int|1
suffix:semicolon
id|msg.msg_control
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_controllen
op_assign
l_int|0
suffix:semicolon
id|iov.iov_base
op_assign
id|ubuf
suffix:semicolon
id|iov.iov_len
op_assign
id|size
suffix:semicolon
id|flags
op_assign
op_logical_neg
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
ques
c_cond
l_int|0
suffix:colon
id|MSG_DONTWAIT
suffix:semicolon
r_return
id|sock_recvmsg
c_func
(paren
id|sock
comma
op_amp
id|msg
comma
id|size
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Write data to a socket. We verify that the user area ubuf..ubuf+size-1&n; *&t;is readable by the user process.&n; */
DECL|function|sock_write
r_static
id|ssize_t
id|sock_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|ubuf
comma
r_int
id|size
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_struct
id|msghdr
id|msg
suffix:semicolon
r_struct
id|iovec
id|iov
suffix:semicolon
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Match SYS5 behaviour */
r_return
l_int|0
suffix:semicolon
)brace
id|sock
op_assign
id|socki_lookup
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
id|msg.msg_name
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_namelen
op_assign
l_int|0
suffix:semicolon
id|msg.msg_iov
op_assign
op_amp
id|iov
suffix:semicolon
id|msg.msg_iovlen
op_assign
l_int|1
suffix:semicolon
id|msg.msg_control
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_controllen
op_assign
l_int|0
suffix:semicolon
id|msg.msg_flags
op_assign
op_logical_neg
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
ques
c_cond
l_int|0
suffix:colon
id|MSG_DONTWAIT
suffix:semicolon
r_if
c_cond
(paren
id|sock-&gt;type
op_eq
id|SOCK_SEQPACKET
)paren
id|msg.msg_flags
op_or_assign
id|MSG_EOR
suffix:semicolon
id|iov.iov_base
op_assign
(paren
r_void
op_star
)paren
id|ubuf
suffix:semicolon
id|iov.iov_len
op_assign
id|size
suffix:semicolon
r_return
id|sock_sendmsg
c_func
(paren
id|sock
comma
op_amp
id|msg
comma
id|size
)paren
suffix:semicolon
)brace
DECL|function|sock_readv_writev
r_int
id|sock_readv_writev
c_func
(paren
r_int
id|type
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_struct
id|iovec
op_star
id|iov
comma
r_int
id|count
comma
r_int
id|size
)paren
(brace
r_struct
id|msghdr
id|msg
suffix:semicolon
r_struct
id|socket
op_star
id|sock
suffix:semicolon
id|sock
op_assign
id|socki_lookup
c_func
(paren
id|inode
)paren
suffix:semicolon
id|msg.msg_name
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_namelen
op_assign
l_int|0
suffix:semicolon
id|msg.msg_control
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_controllen
op_assign
l_int|0
suffix:semicolon
id|msg.msg_iov
op_assign
(paren
r_struct
id|iovec
op_star
)paren
id|iov
suffix:semicolon
id|msg.msg_iovlen
op_assign
id|count
suffix:semicolon
id|msg.msg_flags
op_assign
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
ques
c_cond
id|MSG_DONTWAIT
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* read() does a VERIFY_WRITE */
r_if
c_cond
(paren
id|type
op_eq
id|VERIFY_WRITE
)paren
r_return
id|sock_recvmsg
c_func
(paren
id|sock
comma
op_amp
id|msg
comma
id|size
comma
id|msg.msg_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sock-&gt;type
op_eq
id|SOCK_SEQPACKET
)paren
id|msg.msg_flags
op_or_assign
id|MSG_EOR
suffix:semicolon
r_return
id|sock_sendmsg
c_func
(paren
id|sock
comma
op_amp
id|msg
comma
id|size
)paren
suffix:semicolon
)brace
DECL|function|sock_readv
r_static
id|ssize_t
id|sock_readv
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_struct
id|iovec
op_star
id|vector
comma
r_int
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|tot_len
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
id|tot_len
op_add_assign
id|vector
(braket
id|i
)braket
dot
id|iov_len
suffix:semicolon
r_return
id|sock_readv_writev
c_func
(paren
id|VERIFY_WRITE
comma
id|file-&gt;f_dentry-&gt;d_inode
comma
id|file
comma
id|vector
comma
id|count
comma
id|tot_len
)paren
suffix:semicolon
)brace
DECL|function|sock_writev
r_static
id|ssize_t
id|sock_writev
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_struct
id|iovec
op_star
id|vector
comma
r_int
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|tot_len
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
id|tot_len
op_add_assign
id|vector
(braket
id|i
)braket
dot
id|iov_len
suffix:semicolon
r_return
id|sock_readv_writev
c_func
(paren
id|VERIFY_READ
comma
id|file-&gt;f_dentry-&gt;d_inode
comma
id|file
comma
id|vector
comma
id|count
comma
id|tot_len
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;With an ioctl arg may well be a user mode pointer, but we don&squot;t know what to do&n; *&t;with it - that&squot;s up to the protocol still.&n; */
DECL|function|sock_ioctl
r_int
id|sock_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_int
id|err
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|sock
op_assign
id|socki_lookup
c_func
(paren
id|inode
)paren
suffix:semicolon
id|err
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|ioctl
c_func
(paren
id|sock
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* No kernel lock held - perfect */
DECL|function|sock_poll
r_static
r_int
r_int
id|sock_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|socket
op_star
id|sock
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We can&squot;t return errors to poll, so it&squot;s either yes or no. &n;&t; */
id|sock
op_assign
id|socki_lookup
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
r_return
id|sock-&gt;ops
op_member_access_from_pointer
id|poll
c_func
(paren
id|file
comma
id|sock
comma
id|wait
)paren
suffix:semicolon
)brace
DECL|function|sock_mmap
r_static
r_int
id|sock_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|socket
op_star
id|sock
op_assign
id|socki_lookup
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
r_return
id|sock-&gt;ops
op_member_access_from_pointer
id|mmap
c_func
(paren
id|file
comma
id|sock
comma
id|vma
)paren
suffix:semicolon
)brace
DECL|function|sock_close
r_int
id|sock_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
multiline_comment|/*&n;&t; *&t;It was possible the inode is NULL we were &n;&t; *&t;closing an unfinished socket. &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;sock_close: NULL inode&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sock_fasync
c_func
(paren
op_minus
l_int|1
comma
id|filp
comma
l_int|0
)paren
suffix:semicolon
id|sock_release
c_func
(paren
id|socki_lookup
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Update the socket async list&n; *&n; *&t;Fasync_list locking strategy.&n; *&n; *&t;1. fasync_list is modified only under process context socket lock&n; *&t;   i.e. under semaphore.&n; *&t;2. fasync_list is used under read_lock(&amp;sk-&gt;callback_lock)&n; *&t;   or under socket lock.&n; *&t;3. fasync_list can be used from softirq context, so that&n; *&t;   modification under socket lock have to be enhanced with&n; *&t;   write_lock_bh(&amp;sk-&gt;callback_lock).&n; *&t;&t;&t;&t;&t;&t;&t;--ANK (990710)&n; */
DECL|function|sock_fasync
r_static
r_int
id|sock_fasync
c_func
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|on
)paren
(brace
r_struct
id|fasync_struct
op_star
id|fa
comma
op_star
id|fna
op_assign
l_int|NULL
comma
op_star
op_star
id|prev
suffix:semicolon
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_if
c_cond
(paren
id|on
)paren
(brace
id|fna
op_assign
(paren
r_struct
id|fasync_struct
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|fasync_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fna
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|sock
op_assign
id|socki_lookup
c_func
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sk
op_assign
id|sock-&gt;sk
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|prev
op_assign
op_amp
(paren
id|sock-&gt;fasync_list
)paren
suffix:semicolon
r_for
c_loop
(paren
id|fa
op_assign
op_star
id|prev
suffix:semicolon
id|fa
op_ne
l_int|NULL
suffix:semicolon
id|prev
op_assign
op_amp
id|fa-&gt;fa_next
comma
id|fa
op_assign
op_star
id|prev
)paren
r_if
c_cond
(paren
id|fa-&gt;fa_file
op_eq
id|filp
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|on
)paren
(brace
r_if
c_cond
(paren
id|fa
op_ne
l_int|NULL
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
id|fa-&gt;fa_fd
op_assign
id|fd
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fna
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|fna-&gt;fa_file
op_assign
id|filp
suffix:semicolon
id|fna-&gt;fa_fd
op_assign
id|fd
suffix:semicolon
id|fna-&gt;magic
op_assign
id|FASYNC_MAGIC
suffix:semicolon
id|fna-&gt;fa_next
op_assign
id|sock-&gt;fasync_list
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
id|sock-&gt;fasync_list
op_assign
id|fna
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|fa
op_ne
l_int|NULL
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
op_star
id|prev
op_assign
id|fa-&gt;fa_next
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fa
)paren
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|release_sock
c_func
(paren
id|sock-&gt;sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function may be called only under socket lock or callback_lock */
DECL|function|sock_wake_async
r_int
id|sock_wake_async
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|how
comma
r_int
id|band
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sock
op_logical_or
op_logical_neg
id|sock-&gt;fasync_list
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|how
)paren
(brace
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SOCK_ASYNC_WAITDATA
comma
op_amp
id|sock-&gt;flags
)paren
)paren
r_break
suffix:semicolon
r_goto
id|call_kill
suffix:semicolon
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|test_and_clear_bit
c_func
(paren
id|SOCK_ASYNC_NOSPACE
comma
op_amp
id|sock-&gt;flags
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* fall through */
r_case
l_int|0
suffix:colon
id|call_kill
suffix:colon
id|__kill_fasync
c_func
(paren
id|sock-&gt;fasync_list
comma
id|SIGIO
comma
id|band
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|__kill_fasync
c_func
(paren
id|sock-&gt;fasync_list
comma
id|SIGURG
comma
id|band
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sock_create
r_int
id|sock_create
c_func
(paren
r_int
id|family
comma
r_int
id|type
comma
r_int
id|protocol
comma
r_struct
id|socket
op_star
op_star
id|res
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|socket
op_star
id|sock
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Check protocol is in range&n;&t; */
r_if
c_cond
(paren
id|family
OL
l_int|0
op_logical_or
id|family
op_ge
id|NPROTO
)paren
(brace
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
)brace
multiline_comment|/* Compatibility.&n;&n;&t;   This uglymoron is moved from INET layer to here to avoid&n;&t;   deadlock in module load.&n;&t; */
r_if
c_cond
(paren
id|family
op_eq
id|PF_INET
op_logical_and
id|type
op_eq
id|SOCK_PACKET
)paren
(brace
r_static
r_int
id|warned
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|warned
)paren
(brace
id|warned
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s uses obsolete (PF_INET,SOCK_PACKET)&bslash;n&quot;
comma
id|current-&gt;comm
)paren
suffix:semicolon
)brace
id|family
op_assign
id|PF_PACKET
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_KMOD) &amp;&amp; defined(CONFIG_NET)
multiline_comment|/* Attempt to load a protocol module if the find failed. &n;&t; * &n;&t; * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user &n;&t; * requested real, full-featured networking support upon configuration.&n;&t; * Otherwise module support will break!&n;&t; */
r_if
c_cond
(paren
id|net_families
(braket
id|family
)braket
op_eq
l_int|NULL
)paren
(brace
r_char
id|module_name
(braket
l_int|30
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|module_name
comma
l_string|&quot;net-pf-%d&quot;
comma
id|family
)paren
suffix:semicolon
id|request_module
c_func
(paren
id|module_name
)paren
suffix:semicolon
)brace
macro_line|#endif
id|net_family_read_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_families
(braket
id|family
)braket
op_eq
l_int|NULL
)paren
(brace
id|i
op_assign
op_minus
id|EAFNOSUPPORT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Allocate the socket and allow the family to set things up. if&n; *&t;the protocol is 0, the family is instructed to select an appropriate&n; *&t;default.&n; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sock
op_assign
id|sock_alloc
c_func
(paren
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;socket: no more sockets&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
op_minus
id|ENFILE
suffix:semicolon
multiline_comment|/* Not exactly a match, but its the&n;&t;&t;&t;&t;&t;   closest posix thing */
r_goto
id|out
suffix:semicolon
)brace
id|sock-&gt;type
op_assign
id|type
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|net_families
(braket
id|family
)braket
op_member_access_from_pointer
id|create
c_func
(paren
id|sock
comma
id|protocol
)paren
)paren
OL
l_int|0
)paren
(brace
id|sock_release
c_func
(paren
id|sock
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
op_star
id|res
op_assign
id|sock
suffix:semicolon
id|out
suffix:colon
id|net_family_read_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|sys_socket
id|asmlinkage
r_int
id|sys_socket
c_func
(paren
r_int
id|family
comma
r_int
id|type
comma
r_int
id|protocol
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|socket
op_star
id|sock
suffix:semicolon
id|retval
op_assign
id|sock_create
c_func
(paren
id|family
comma
id|type
comma
id|protocol
comma
op_amp
id|sock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|retval
op_assign
id|sock_map_fd
c_func
(paren
id|sock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out_release
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* It may be already another descriptor 8) Not kernel problem. */
r_return
id|retval
suffix:semicolon
id|out_release
suffix:colon
id|sock_release
c_func
(paren
id|sock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Create a pair of connected sockets.&n; */
DECL|function|sys_socketpair
id|asmlinkage
r_int
id|sys_socketpair
c_func
(paren
r_int
id|family
comma
r_int
id|type
comma
r_int
id|protocol
comma
r_int
id|usockvec
(braket
l_int|2
)braket
)paren
(brace
r_struct
id|socket
op_star
id|sock1
comma
op_star
id|sock2
suffix:semicolon
r_int
id|fd1
comma
id|fd2
comma
id|err
suffix:semicolon
multiline_comment|/*&n;&t; * Obtain the first socket and check if the underlying protocol&n;&t; * supports the socketpair call.&n;&t; */
id|err
op_assign
id|sock_create
c_func
(paren
id|family
comma
id|type
comma
id|protocol
comma
op_amp
id|sock1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|sock_create
c_func
(paren
id|family
comma
id|type
comma
id|protocol
comma
op_amp
id|sock2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_release_1
suffix:semicolon
id|err
op_assign
id|sock1-&gt;ops
op_member_access_from_pointer
id|socketpair
c_func
(paren
id|sock1
comma
id|sock2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_release_both
suffix:semicolon
id|fd1
op_assign
id|fd2
op_assign
op_minus
l_int|1
suffix:semicolon
id|err
op_assign
id|sock_map_fd
c_func
(paren
id|sock1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_release_both
suffix:semicolon
id|fd1
op_assign
id|err
suffix:semicolon
id|err
op_assign
id|sock_map_fd
c_func
(paren
id|sock2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_close_1
suffix:semicolon
id|fd2
op_assign
id|err
suffix:semicolon
multiline_comment|/* fd1 and fd2 may be already another descriptors.&n;&t; * Not kernel problem.&n;&t; */
id|err
op_assign
id|put_user
c_func
(paren
id|fd1
comma
op_amp
id|usockvec
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
id|put_user
c_func
(paren
id|fd2
comma
op_amp
id|usockvec
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
r_return
l_int|0
suffix:semicolon
id|sys_close
c_func
(paren
id|fd2
)paren
suffix:semicolon
id|sys_close
c_func
(paren
id|fd1
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|out_close_1
suffix:colon
id|sock_release
c_func
(paren
id|sock2
)paren
suffix:semicolon
id|sys_close
c_func
(paren
id|fd1
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|out_release_both
suffix:colon
id|sock_release
c_func
(paren
id|sock2
)paren
suffix:semicolon
id|out_release_1
suffix:colon
id|sock_release
c_func
(paren
id|sock1
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Bind a name to a socket. Nothing much to do here since it&squot;s&n; *&t;the protocol&squot;s responsibility to handle the local address.&n; *&n; *&t;We move the socket address to kernel space before we call&n; *&t;the protocol layer (having also checked the address is ok).&n; */
DECL|function|sys_bind
id|asmlinkage
r_int
id|sys_bind
c_func
(paren
r_int
id|fd
comma
r_struct
id|sockaddr
op_star
id|umyaddr
comma
r_int
id|addrlen
)paren
(brace
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_char
id|address
(braket
id|MAX_SOCK_ADDR
)braket
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sock
op_assign
id|sockfd_lookup
c_func
(paren
id|fd
comma
op_amp
id|err
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|move_addr_to_kernel
c_func
(paren
id|umyaddr
comma
id|addrlen
comma
id|address
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|err
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|bind
c_func
(paren
id|sock
comma
(paren
r_struct
id|sockaddr
op_star
)paren
id|address
comma
id|addrlen
)paren
suffix:semicolon
)brace
id|sockfd_put
c_func
(paren
id|sock
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Perform a listen. Basically, we allow the protocol to do anything&n; *&t;necessary for a listen, and if that works, we mark the socket as&n; *&t;ready for listening.&n; */
DECL|function|sys_listen
id|asmlinkage
r_int
id|sys_listen
c_func
(paren
r_int
id|fd
comma
r_int
id|backlog
)paren
(brace
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sock
op_assign
id|sockfd_lookup
c_func
(paren
id|fd
comma
op_amp
id|err
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|backlog
OG
id|SOMAXCONN
)paren
id|backlog
op_assign
id|SOMAXCONN
suffix:semicolon
id|err
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|listen
c_func
(paren
id|sock
comma
id|backlog
)paren
suffix:semicolon
id|sockfd_put
c_func
(paren
id|sock
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;For accept, we attempt to create a new socket, set up the link&n; *&t;with the client, wake up the client, then return the new&n; *&t;connected fd. We collect the address of the connector in kernel&n; *&t;space and move it to user at the very end. This is unclean because&n; *&t;we open the socket then return an error.&n; *&n; *&t;1003.1g adds the ability to recvmsg() to query connection pending&n; *&t;status to recvmsg. We need to add that support in a way thats&n; *&t;clean when we restucture accept also.&n; */
DECL|function|sys_accept
id|asmlinkage
r_int
id|sys_accept
c_func
(paren
r_int
id|fd
comma
r_struct
id|sockaddr
op_star
id|upeer_sockaddr
comma
r_int
op_star
id|upeer_addrlen
)paren
(brace
r_struct
id|socket
op_star
id|sock
comma
op_star
id|newsock
suffix:semicolon
r_int
id|err
comma
id|len
suffix:semicolon
r_char
id|address
(braket
id|MAX_SOCK_ADDR
)braket
suffix:semicolon
id|sock
op_assign
id|sockfd_lookup
c_func
(paren
id|fd
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
op_minus
id|EMFILE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|newsock
op_assign
id|sock_alloc
c_func
(paren
)paren
)paren
)paren
r_goto
id|out_put
suffix:semicolon
id|newsock-&gt;type
op_assign
id|sock-&gt;type
suffix:semicolon
id|newsock-&gt;ops
op_assign
id|sock-&gt;ops
suffix:semicolon
id|err
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|accept
c_func
(paren
id|sock
comma
id|newsock
comma
id|sock-&gt;file-&gt;f_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_release
suffix:semicolon
r_if
c_cond
(paren
id|upeer_sockaddr
)paren
(brace
r_if
c_cond
(paren
id|newsock-&gt;ops
op_member_access_from_pointer
id|getname
c_func
(paren
id|newsock
comma
(paren
r_struct
id|sockaddr
op_star
)paren
id|address
comma
op_amp
id|len
comma
l_int|2
)paren
OL
l_int|0
)paren
(brace
id|err
op_assign
op_minus
id|ECONNABORTED
suffix:semicolon
r_goto
id|out_release
suffix:semicolon
)brace
id|err
op_assign
id|move_addr_to_user
c_func
(paren
id|address
comma
id|len
comma
id|upeer_sockaddr
comma
id|upeer_addrlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_release
suffix:semicolon
)brace
multiline_comment|/* File flags are not inherited via accept() unlike another OSes. */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|sock_map_fd
c_func
(paren
id|newsock
)paren
)paren
OL
l_int|0
)paren
r_goto
id|out_release
suffix:semicolon
id|out_put
suffix:colon
id|sockfd_put
c_func
(paren
id|sock
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_release
suffix:colon
id|sock_release
c_func
(paren
id|newsock
)paren
suffix:semicolon
r_goto
id|out_put
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Attempt to connect to a socket with the server address.  The address&n; *&t;is in user space so we verify it is OK and move it to kernel space.&n; *&n; *&t;For 1003.1g we need to add clean support for a bind to AF_UNSPEC to&n; *&t;break bindings&n; *&n; *&t;NOTE: 1003.1g draft 6.3 is broken with respect to AX.25/NetROM and&n; *&t;other SEQPACKET protocols that take time to connect() as it doesn&squot;t&n; *&t;include the -EINPROGRESS status for such sockets.&n; */
DECL|function|sys_connect
id|asmlinkage
r_int
id|sys_connect
c_func
(paren
r_int
id|fd
comma
r_struct
id|sockaddr
op_star
id|uservaddr
comma
r_int
id|addrlen
)paren
(brace
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_char
id|address
(braket
id|MAX_SOCK_ADDR
)braket
suffix:semicolon
r_int
id|err
suffix:semicolon
id|sock
op_assign
id|sockfd_lookup
c_func
(paren
id|fd
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|move_addr_to_kernel
c_func
(paren
id|uservaddr
comma
id|addrlen
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_put
suffix:semicolon
id|err
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|connect
c_func
(paren
id|sock
comma
(paren
r_struct
id|sockaddr
op_star
)paren
id|address
comma
id|addrlen
comma
id|sock-&gt;file-&gt;f_flags
)paren
suffix:semicolon
id|out_put
suffix:colon
id|sockfd_put
c_func
(paren
id|sock
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get the local address (&squot;name&squot;) of a socket object. Move the obtained&n; *&t;name to user space.&n; */
DECL|function|sys_getsockname
id|asmlinkage
r_int
id|sys_getsockname
c_func
(paren
r_int
id|fd
comma
r_struct
id|sockaddr
op_star
id|usockaddr
comma
r_int
op_star
id|usockaddr_len
)paren
(brace
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_char
id|address
(braket
id|MAX_SOCK_ADDR
)braket
suffix:semicolon
r_int
id|len
comma
id|err
suffix:semicolon
id|sock
op_assign
id|sockfd_lookup
c_func
(paren
id|fd
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|getname
c_func
(paren
id|sock
comma
(paren
r_struct
id|sockaddr
op_star
)paren
id|address
comma
op_amp
id|len
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_put
suffix:semicolon
id|err
op_assign
id|move_addr_to_user
c_func
(paren
id|address
comma
id|len
comma
id|usockaddr
comma
id|usockaddr_len
)paren
suffix:semicolon
id|out_put
suffix:colon
id|sockfd_put
c_func
(paren
id|sock
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get the remote address (&squot;name&squot;) of a socket object. Move the obtained&n; *&t;name to user space.&n; */
DECL|function|sys_getpeername
id|asmlinkage
r_int
id|sys_getpeername
c_func
(paren
r_int
id|fd
comma
r_struct
id|sockaddr
op_star
id|usockaddr
comma
r_int
op_star
id|usockaddr_len
)paren
(brace
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_char
id|address
(braket
id|MAX_SOCK_ADDR
)braket
suffix:semicolon
r_int
id|len
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sock
op_assign
id|sockfd_lookup
c_func
(paren
id|fd
comma
op_amp
id|err
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|err
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|getname
c_func
(paren
id|sock
comma
(paren
r_struct
id|sockaddr
op_star
)paren
id|address
comma
op_amp
id|len
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
id|move_addr_to_user
c_func
(paren
id|address
comma
id|len
comma
id|usockaddr
comma
id|usockaddr_len
)paren
suffix:semicolon
id|sockfd_put
c_func
(paren
id|sock
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send a datagram to a given address. We move the address into kernel&n; *&t;space and check the user space data area is readable before invoking&n; *&t;the protocol.&n; */
DECL|function|sys_sendto
id|asmlinkage
r_int
id|sys_sendto
c_func
(paren
r_int
id|fd
comma
r_void
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|flags
comma
r_struct
id|sockaddr
op_star
id|addr
comma
r_int
id|addr_len
)paren
(brace
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_char
id|address
(braket
id|MAX_SOCK_ADDR
)braket
suffix:semicolon
r_int
id|err
suffix:semicolon
r_struct
id|msghdr
id|msg
suffix:semicolon
r_struct
id|iovec
id|iov
suffix:semicolon
id|sock
op_assign
id|sockfd_lookup
c_func
(paren
id|fd
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock
)paren
r_goto
id|out
suffix:semicolon
id|iov.iov_base
op_assign
id|buff
suffix:semicolon
id|iov.iov_len
op_assign
id|len
suffix:semicolon
id|msg.msg_name
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_iov
op_assign
op_amp
id|iov
suffix:semicolon
id|msg.msg_iovlen
op_assign
l_int|1
suffix:semicolon
id|msg.msg_control
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_controllen
op_assign
l_int|0
suffix:semicolon
id|msg.msg_namelen
op_assign
id|addr_len
suffix:semicolon
r_if
c_cond
(paren
id|addr
)paren
(brace
id|err
op_assign
id|move_addr_to_kernel
c_func
(paren
id|addr
comma
id|addr_len
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_put
suffix:semicolon
id|msg.msg_name
op_assign
id|address
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sock-&gt;file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
id|flags
op_or_assign
id|MSG_DONTWAIT
suffix:semicolon
id|msg.msg_flags
op_assign
id|flags
suffix:semicolon
id|err
op_assign
id|sock_sendmsg
c_func
(paren
id|sock
comma
op_amp
id|msg
comma
id|len
)paren
suffix:semicolon
id|out_put
suffix:colon
id|sockfd_put
c_func
(paren
id|sock
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send a datagram down a socket. &n; */
DECL|function|sys_send
id|asmlinkage
r_int
id|sys_send
c_func
(paren
r_int
id|fd
comma
r_void
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|flags
)paren
(brace
r_return
id|sys_sendto
c_func
(paren
id|fd
comma
id|buff
comma
id|len
comma
id|flags
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Receive a frame from the socket and optionally record the address of the &n; *&t;sender. We verify the buffers are writable and if needed move the&n; *&t;sender address from kernel to user space.&n; */
DECL|function|sys_recvfrom
id|asmlinkage
r_int
id|sys_recvfrom
c_func
(paren
r_int
id|fd
comma
r_void
op_star
id|ubuf
comma
r_int
id|size
comma
r_int
id|flags
comma
r_struct
id|sockaddr
op_star
id|addr
comma
r_int
op_star
id|addr_len
)paren
(brace
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_struct
id|iovec
id|iov
suffix:semicolon
r_struct
id|msghdr
id|msg
suffix:semicolon
r_char
id|address
(braket
id|MAX_SOCK_ADDR
)braket
suffix:semicolon
r_int
id|err
comma
id|err2
suffix:semicolon
id|sock
op_assign
id|sockfd_lookup
c_func
(paren
id|fd
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock
)paren
r_goto
id|out
suffix:semicolon
id|msg.msg_control
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_controllen
op_assign
l_int|0
suffix:semicolon
id|msg.msg_iovlen
op_assign
l_int|1
suffix:semicolon
id|msg.msg_iov
op_assign
op_amp
id|iov
suffix:semicolon
id|iov.iov_len
op_assign
id|size
suffix:semicolon
id|iov.iov_base
op_assign
id|ubuf
suffix:semicolon
id|msg.msg_name
op_assign
id|address
suffix:semicolon
id|msg.msg_namelen
op_assign
id|MAX_SOCK_ADDR
suffix:semicolon
r_if
c_cond
(paren
id|sock-&gt;file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
id|flags
op_or_assign
id|MSG_DONTWAIT
suffix:semicolon
id|err
op_assign
id|sock_recvmsg
c_func
(paren
id|sock
comma
op_amp
id|msg
comma
id|size
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ge
l_int|0
op_logical_and
id|addr
op_ne
l_int|NULL
op_logical_and
id|msg.msg_namelen
)paren
(brace
id|err2
op_assign
id|move_addr_to_user
c_func
(paren
id|address
comma
id|msg.msg_namelen
comma
id|addr
comma
id|addr_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err2
OL
l_int|0
)paren
(brace
id|err
op_assign
id|err2
suffix:semicolon
)brace
)brace
id|sockfd_put
c_func
(paren
id|sock
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Receive a datagram from a socket. &n; */
DECL|function|sys_recv
id|asmlinkage
r_int
id|sys_recv
c_func
(paren
r_int
id|fd
comma
r_void
op_star
id|ubuf
comma
r_int
id|size
comma
r_int
id|flags
)paren
(brace
r_return
id|sys_recvfrom
c_func
(paren
id|fd
comma
id|ubuf
comma
id|size
comma
id|flags
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Set a socket option. Because we don&squot;t know the option lengths we have&n; *&t;to pass the user mode parameter for the protocols to sort out.&n; */
DECL|function|sys_setsockopt
id|asmlinkage
r_int
id|sys_setsockopt
c_func
(paren
r_int
id|fd
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sock
op_assign
id|sockfd_lookup
c_func
(paren
id|fd
comma
op_amp
id|err
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|level
op_eq
id|SOL_SOCKET
)paren
id|err
op_assign
id|sock_setsockopt
c_func
(paren
id|sock
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_else
id|err
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|setsockopt
c_func
(paren
id|sock
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
id|sockfd_put
c_func
(paren
id|sock
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get a socket option. Because we don&squot;t know the option lengths we have&n; *&t;to pass a user mode parameter for the protocols to sort out.&n; */
DECL|function|sys_getsockopt
id|asmlinkage
r_int
id|sys_getsockopt
c_func
(paren
r_int
id|fd
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sock
op_assign
id|sockfd_lookup
c_func
(paren
id|fd
comma
op_amp
id|err
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|level
op_eq
id|SOL_SOCKET
)paren
id|err
op_assign
id|sock_getsockopt
c_func
(paren
id|sock
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_else
id|err
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|getsockopt
c_func
(paren
id|sock
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
id|sockfd_put
c_func
(paren
id|sock
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Shutdown a socket.&n; */
DECL|function|sys_shutdown
id|asmlinkage
r_int
id|sys_shutdown
c_func
(paren
r_int
id|fd
comma
r_int
id|how
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sock
op_assign
id|sockfd_lookup
c_func
(paren
id|fd
comma
op_amp
id|err
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|err
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|shutdown
c_func
(paren
id|sock
comma
id|how
)paren
suffix:semicolon
id|sockfd_put
c_func
(paren
id|sock
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;BSD sendmsg interface&n; */
DECL|function|sys_sendmsg
id|asmlinkage
r_int
id|sys_sendmsg
c_func
(paren
r_int
id|fd
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|flags
)paren
(brace
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_char
id|address
(braket
id|MAX_SOCK_ADDR
)braket
suffix:semicolon
r_struct
id|iovec
id|iovstack
(braket
id|UIO_FASTIOV
)braket
comma
op_star
id|iov
op_assign
id|iovstack
suffix:semicolon
r_int
r_char
id|ctl
(braket
r_sizeof
(paren
r_struct
id|cmsghdr
)paren
op_plus
l_int|20
)braket
suffix:semicolon
multiline_comment|/* 20 is size of ipv6_pktinfo */
r_int
r_char
op_star
id|ctl_buf
op_assign
id|ctl
suffix:semicolon
r_struct
id|msghdr
id|msg_sys
suffix:semicolon
r_int
id|err
comma
id|ctl_len
comma
id|iov_size
comma
id|total_len
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|msg_sys
comma
id|msg
comma
r_sizeof
(paren
r_struct
id|msghdr
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|sock
op_assign
id|sockfd_lookup
c_func
(paren
id|fd
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* do not move before msg_sys is valid */
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|msg_sys.msg_iovlen
OG
id|UIO_MAXIOV
)paren
r_goto
id|out_put
suffix:semicolon
multiline_comment|/* Check whether to allocate the iovec area*/
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|iov_size
op_assign
id|msg_sys.msg_iovlen
op_star
r_sizeof
(paren
r_struct
id|iovec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg_sys.msg_iovlen
OG
id|UIO_FASTIOV
)paren
(brace
id|iov
op_assign
id|sock_kmalloc
c_func
(paren
id|sock-&gt;sk
comma
id|iov_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iov
)paren
r_goto
id|out_put
suffix:semicolon
)brace
multiline_comment|/* This will also move the address data into kernel space */
id|err
op_assign
id|verify_iovec
c_func
(paren
op_amp
id|msg_sys
comma
id|iov
comma
id|address
comma
id|VERIFY_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_freeiov
suffix:semicolon
id|total_len
op_assign
id|err
suffix:semicolon
id|err
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
r_if
c_cond
(paren
id|msg_sys.msg_controllen
OG
id|INT_MAX
)paren
r_goto
id|out_freeiov
suffix:semicolon
id|ctl_len
op_assign
id|msg_sys.msg_controllen
suffix:semicolon
r_if
c_cond
(paren
id|ctl_len
)paren
(brace
r_if
c_cond
(paren
id|ctl_len
OG
r_sizeof
(paren
id|ctl
)paren
)paren
(brace
id|ctl_buf
op_assign
id|sock_kmalloc
c_func
(paren
id|sock-&gt;sk
comma
id|ctl_len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctl_buf
op_eq
l_int|NULL
)paren
r_goto
id|out_freeiov
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|ctl_buf
comma
id|msg_sys.msg_control
comma
id|ctl_len
)paren
)paren
r_goto
id|out_freectl
suffix:semicolon
id|msg_sys.msg_control
op_assign
id|ctl_buf
suffix:semicolon
)brace
id|msg_sys.msg_flags
op_assign
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|sock-&gt;file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
id|msg_sys.msg_flags
op_or_assign
id|MSG_DONTWAIT
suffix:semicolon
id|err
op_assign
id|sock_sendmsg
c_func
(paren
id|sock
comma
op_amp
id|msg_sys
comma
id|total_len
)paren
suffix:semicolon
id|out_freectl
suffix:colon
r_if
c_cond
(paren
id|ctl_buf
op_ne
id|ctl
)paren
id|sock_kfree_s
c_func
(paren
id|sock-&gt;sk
comma
id|ctl_buf
comma
id|ctl_len
)paren
suffix:semicolon
id|out_freeiov
suffix:colon
r_if
c_cond
(paren
id|iov
op_ne
id|iovstack
)paren
id|sock_kfree_s
c_func
(paren
id|sock-&gt;sk
comma
id|iov
comma
id|iov_size
)paren
suffix:semicolon
id|out_put
suffix:colon
id|sockfd_put
c_func
(paren
id|sock
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;BSD recvmsg interface&n; */
DECL|function|sys_recvmsg
id|asmlinkage
r_int
id|sys_recvmsg
c_func
(paren
r_int
id|fd
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_struct
id|iovec
id|iovstack
(braket
id|UIO_FASTIOV
)braket
suffix:semicolon
r_struct
id|iovec
op_star
id|iov
op_assign
id|iovstack
suffix:semicolon
r_struct
id|msghdr
id|msg_sys
suffix:semicolon
r_int
r_int
id|cmsg_ptr
suffix:semicolon
r_int
id|err
comma
id|iov_size
comma
id|total_len
comma
id|len
suffix:semicolon
multiline_comment|/* kernel mode address */
r_char
id|addr
(braket
id|MAX_SOCK_ADDR
)braket
suffix:semicolon
multiline_comment|/* user mode address pointers */
r_struct
id|sockaddr
op_star
id|uaddr
suffix:semicolon
r_int
op_star
id|uaddr_len
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|msg_sys
comma
id|msg
comma
r_sizeof
(paren
r_struct
id|msghdr
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|sock
op_assign
id|sockfd_lookup
c_func
(paren
id|fd
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|msg_sys.msg_iovlen
OG
id|UIO_MAXIOV
)paren
r_goto
id|out_put
suffix:semicolon
multiline_comment|/* Check whether to allocate the iovec area*/
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|iov_size
op_assign
id|msg_sys.msg_iovlen
op_star
r_sizeof
(paren
r_struct
id|iovec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg_sys.msg_iovlen
OG
id|UIO_FASTIOV
)paren
(brace
id|iov
op_assign
id|sock_kmalloc
c_func
(paren
id|sock-&gt;sk
comma
id|iov_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iov
)paren
r_goto
id|out_put
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Save the user-mode address (verify_iovec will change the&n;&t; *&t;kernel msghdr to use the kernel address space)&n;&t; */
id|uaddr
op_assign
id|msg_sys.msg_name
suffix:semicolon
id|uaddr_len
op_assign
op_amp
id|msg-&gt;msg_namelen
suffix:semicolon
id|err
op_assign
id|verify_iovec
c_func
(paren
op_amp
id|msg_sys
comma
id|iov
comma
id|addr
comma
id|VERIFY_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_freeiov
suffix:semicolon
id|total_len
op_assign
id|err
suffix:semicolon
id|cmsg_ptr
op_assign
(paren
r_int
r_int
)paren
id|msg_sys.msg_control
suffix:semicolon
id|msg_sys.msg_flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sock-&gt;file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
id|flags
op_or_assign
id|MSG_DONTWAIT
suffix:semicolon
id|err
op_assign
id|sock_recvmsg
c_func
(paren
id|sock
comma
op_amp
id|msg_sys
comma
id|total_len
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_freeiov
suffix:semicolon
id|len
op_assign
id|err
suffix:semicolon
r_if
c_cond
(paren
id|uaddr
op_ne
l_int|NULL
op_logical_and
id|msg_sys.msg_namelen
)paren
(brace
id|err
op_assign
id|move_addr_to_user
c_func
(paren
id|addr
comma
id|msg_sys.msg_namelen
comma
id|uaddr
comma
id|uaddr_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_freeiov
suffix:semicolon
)brace
id|err
op_assign
id|__put_user
c_func
(paren
id|msg_sys.msg_flags
comma
op_amp
id|msg-&gt;msg_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_freeiov
suffix:semicolon
id|err
op_assign
id|__put_user
c_func
(paren
(paren
r_int
r_int
)paren
id|msg_sys.msg_control
op_minus
id|cmsg_ptr
comma
op_amp
id|msg-&gt;msg_controllen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_freeiov
suffix:semicolon
id|err
op_assign
id|len
suffix:semicolon
id|out_freeiov
suffix:colon
r_if
c_cond
(paren
id|iov
op_ne
id|iovstack
)paren
id|sock_kfree_s
c_func
(paren
id|sock-&gt;sk
comma
id|iov
comma
id|iov_size
)paren
suffix:semicolon
id|out_put
suffix:colon
id|sockfd_put
c_func
(paren
id|sock
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Perform a file control on a socket file descriptor.&n; *&n; *&t;Doesn&squot;t acquire a fd lock, because no network fcntl&n; *&t;function sleeps currently.&n; */
DECL|function|sock_fcntl
r_int
id|sock_fcntl
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|socket
op_star
id|sock
suffix:semicolon
id|sock
op_assign
id|socki_lookup
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sock
op_logical_and
id|sock-&gt;ops
)paren
r_return
id|sock_no_fcntl
c_func
(paren
id|sock
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Argument list sizes for sys_socketcall */
DECL|macro|AL
mdefine_line|#define AL(x) ((x) * sizeof(unsigned long))
DECL|variable|nargs
r_static
r_int
r_char
id|nargs
(braket
l_int|18
)braket
op_assign
initialization_block
suffix:semicolon
DECL|macro|AL
macro_line|#undef AL
multiline_comment|/*&n; *&t;System call vectors. &n; *&n; *&t;Argument checking cleaned up. Saved 20% in size.&n; *  This function doesn&squot;t need to set the kernel lock because&n; *  it is set by the callees. &n; */
DECL|function|sys_socketcall
id|asmlinkage
r_int
id|sys_socketcall
c_func
(paren
r_int
id|call
comma
r_int
r_int
op_star
id|args
)paren
(brace
r_int
r_int
id|a
(braket
l_int|6
)braket
suffix:semicolon
r_int
r_int
id|a0
comma
id|a1
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|call
id|SYS_RECVMSG
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* copy_from_user should be SMP safe. */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|a
comma
id|args
comma
id|nargs
(braket
id|call
)braket
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|a0
op_assign
id|a
(braket
l_int|0
)braket
suffix:semicolon
id|a1
op_assign
id|a
(braket
l_int|1
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|call
)paren
(brace
r_case
id|SYS_SOCKET
suffix:colon
id|err
op_assign
id|sys_socket
c_func
(paren
id|a0
comma
id|a1
comma
id|a
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYS_BIND
suffix:colon
id|err
op_assign
id|sys_bind
c_func
(paren
id|a0
comma
(paren
r_struct
id|sockaddr
op_star
)paren
id|a1
comma
id|a
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYS_CONNECT
suffix:colon
id|err
op_assign
id|sys_connect
c_func
(paren
id|a0
comma
(paren
r_struct
id|sockaddr
op_star
)paren
id|a1
comma
id|a
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYS_LISTEN
suffix:colon
id|err
op_assign
id|sys_listen
c_func
(paren
id|a0
comma
id|a1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYS_ACCEPT
suffix:colon
id|err
op_assign
id|sys_accept
c_func
(paren
id|a0
comma
(paren
r_struct
id|sockaddr
op_star
)paren
id|a1
comma
(paren
r_int
op_star
)paren
id|a
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYS_GETSOCKNAME
suffix:colon
id|err
op_assign
id|sys_getsockname
c_func
(paren
id|a0
comma
(paren
r_struct
id|sockaddr
op_star
)paren
id|a1
comma
(paren
r_int
op_star
)paren
id|a
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYS_GETPEERNAME
suffix:colon
id|err
op_assign
id|sys_getpeername
c_func
(paren
id|a0
comma
(paren
r_struct
id|sockaddr
op_star
)paren
id|a1
comma
(paren
r_int
op_star
)paren
id|a
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYS_SOCKETPAIR
suffix:colon
id|err
op_assign
id|sys_socketpair
c_func
(paren
id|a0
comma
id|a1
comma
id|a
(braket
l_int|2
)braket
comma
(paren
r_int
op_star
)paren
id|a
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYS_SEND
suffix:colon
id|err
op_assign
id|sys_send
c_func
(paren
id|a0
comma
(paren
r_void
op_star
)paren
id|a1
comma
id|a
(braket
l_int|2
)braket
comma
id|a
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYS_SENDTO
suffix:colon
id|err
op_assign
id|sys_sendto
c_func
(paren
id|a0
comma
(paren
r_void
op_star
)paren
id|a1
comma
id|a
(braket
l_int|2
)braket
comma
id|a
(braket
l_int|3
)braket
comma
(paren
r_struct
id|sockaddr
op_star
)paren
id|a
(braket
l_int|4
)braket
comma
id|a
(braket
l_int|5
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYS_RECV
suffix:colon
id|err
op_assign
id|sys_recv
c_func
(paren
id|a0
comma
(paren
r_void
op_star
)paren
id|a1
comma
id|a
(braket
l_int|2
)braket
comma
id|a
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYS_RECVFROM
suffix:colon
id|err
op_assign
id|sys_recvfrom
c_func
(paren
id|a0
comma
(paren
r_void
op_star
)paren
id|a1
comma
id|a
(braket
l_int|2
)braket
comma
id|a
(braket
l_int|3
)braket
comma
(paren
r_struct
id|sockaddr
op_star
)paren
id|a
(braket
l_int|4
)braket
comma
(paren
r_int
op_star
)paren
id|a
(braket
l_int|5
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYS_SHUTDOWN
suffix:colon
id|err
op_assign
id|sys_shutdown
c_func
(paren
id|a0
comma
id|a1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYS_SETSOCKOPT
suffix:colon
id|err
op_assign
id|sys_setsockopt
c_func
(paren
id|a0
comma
id|a1
comma
id|a
(braket
l_int|2
)braket
comma
(paren
r_char
op_star
)paren
id|a
(braket
l_int|3
)braket
comma
id|a
(braket
l_int|4
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYS_GETSOCKOPT
suffix:colon
id|err
op_assign
id|sys_getsockopt
c_func
(paren
id|a0
comma
id|a1
comma
id|a
(braket
l_int|2
)braket
comma
(paren
r_char
op_star
)paren
id|a
(braket
l_int|3
)braket
comma
(paren
r_int
op_star
)paren
id|a
(braket
l_int|4
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYS_SENDMSG
suffix:colon
id|err
op_assign
id|sys_sendmsg
c_func
(paren
id|a0
comma
(paren
r_struct
id|msghdr
op_star
)paren
id|a1
comma
id|a
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYS_RECVMSG
suffix:colon
id|err
op_assign
id|sys_recvmsg
c_func
(paren
id|a0
comma
(paren
r_struct
id|msghdr
op_star
)paren
id|a1
comma
id|a
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This function is called by a protocol handler that wants to&n; *&t;advertise its address family, and have it linked into the&n; *&t;SOCKET module.&n; */
DECL|function|sock_register
r_int
id|sock_register
c_func
(paren
r_struct
id|net_proto_family
op_star
id|ops
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|ops-&gt;family
op_ge
id|NPROTO
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;protocol %d &gt;= NPROTO(%d)&bslash;n&quot;
comma
id|ops-&gt;family
comma
id|NPROTO
)paren
suffix:semicolon
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
id|net_family_write_lock
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|net_families
(braket
id|ops-&gt;family
)braket
op_eq
l_int|NULL
)paren
(brace
id|net_families
(braket
id|ops-&gt;family
)braket
op_assign
id|ops
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|net_family_write_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This function is called by a protocol handler that wants to&n; *&t;remove its address family, and have it unlinked from the&n; *&t;SOCKET module.&n; */
DECL|function|sock_unregister
r_int
id|sock_unregister
c_func
(paren
r_int
id|family
)paren
(brace
r_if
c_cond
(paren
id|family
OL
l_int|0
op_logical_or
id|family
op_ge
id|NPROTO
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|net_family_write_lock
c_func
(paren
)paren
suffix:semicolon
id|net_families
(braket
id|family
)braket
op_assign
l_int|NULL
suffix:semicolon
id|net_family_write_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_extern
r_void
id|sk_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_WAN_ROUTER
r_extern
r_void
id|wanrouter_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
DECL|function|sock_init
r_void
id|__init
id|sock_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Linux NET4.0 for Linux 2.4&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Based upon Swansea University Computer Society NET3.039&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Initialize all address (protocol) families. &n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NPROTO
suffix:semicolon
id|i
op_increment
)paren
id|net_families
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Initialize sock SLAB cache.&n;&t; */
id|sk_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef SLAB_SKB
multiline_comment|/*&n;&t; *&t;Initialize skbuff SLAB cache &n;&t; */
id|skb_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Wan router layer. &n;&t; */
macro_line|#ifdef CONFIG_WAN_ROUTER&t; 
id|wanrouter_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Initialize the protocols module. &n;&t; */
id|register_filesystem
c_func
(paren
op_amp
id|sock_fs_type
)paren
suffix:semicolon
id|sock_mnt
op_assign
id|kern_mount
c_func
(paren
op_amp
id|sock_fs_type
)paren
suffix:semicolon
multiline_comment|/* The real protocol initialization is performed when&n;&t; *  do_initcalls is run.  &n;&t; */
multiline_comment|/*&n;&t; * The netlink device handler may be needed early.&n;&t; */
macro_line|#ifdef  CONFIG_RTNETLINK
id|rtnetlink_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NETLINK_DEV
id|init_netlink
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NETFILTER
id|netfilter_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|socket_get_info
r_int
id|socket_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_int
id|len
comma
id|cpu
suffix:semicolon
r_int
id|counter
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|smp_num_cpus
suffix:semicolon
id|cpu
op_increment
)paren
id|counter
op_add_assign
id|sockets_in_use
(braket
id|cpu_logical_map
c_func
(paren
id|cpu
)paren
)braket
dot
id|counter
suffix:semicolon
multiline_comment|/* It can be negative, by the way. 8) */
r_if
c_cond
(paren
id|counter
OL
l_int|0
)paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;sockets: used %d&bslash;n&quot;
comma
id|counter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|len
)paren
(brace
op_star
id|start
op_assign
id|buffer
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
id|len
op_sub_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
eof
