multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;WE - A simple WD8003, WD8013 and SMC Elite-16 driver.&n; *&n; * Version:&t;$Id: handler.c,v 1.0.0 1993/02/15 00:00:00 waltje Exp $&n; *&n; * Authors:&t;Original taken from the 386BSD operating system.&n; *&t;&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Bob Harris, &lt;rth@sparta.com&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;netinet/in.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &quot;dp8390.h&quot;
macro_line|#include &quot;we8003.h&quot;
DECL|variable|interrupt_mask
r_static
r_int
r_char
id|interrupt_mask
suffix:semicolon
DECL|variable|stats
r_static
r_struct
id|enet_statistics
id|stats
suffix:semicolon
multiline_comment|/* Statistics collection */
DECL|variable|max_pages
r_static
r_int
r_char
id|max_pages
suffix:semicolon
multiline_comment|/* Board memory/256 */
DECL|variable|wd_debug
r_static
r_int
r_char
id|wd_debug
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* turns on/off debug messages */
DECL|variable|dconfig
r_static
r_int
r_char
id|dconfig
op_assign
id|WD_DCONFIG
suffix:semicolon
multiline_comment|/* default data configuration */
DECL|variable|tx_aborted
r_static
r_int
id|tx_aborted
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Empties tx bit bucket */
r_static
r_void
id|wd_trs
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_int
DECL|function|max
id|max
c_func
(paren
r_int
id|a
comma
r_int
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
OG
id|b
)paren
r_return
(paren
id|a
)paren
suffix:semicolon
r_return
(paren
id|b
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|wd_start
id|wd_start
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_char
id|cmd
suffix:semicolon
id|interrupt_mask
op_assign
id|RECV_MASK
op_or
id|TRANS_MASK
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|cmd
op_assign
id|inb_p
c_func
(paren
id|WD_COMM
)paren
suffix:semicolon
id|cmd
op_and_assign
op_complement
(paren
id|CSTOP
op_or
id|CPAGE
)paren
suffix:semicolon
id|cmd
op_or_assign
id|CSTART
suffix:semicolon
id|outb_p
c_func
(paren
id|cmd
comma
id|WD_COMM
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|interrupt_mask
comma
id|WD_IMR
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|wd8003_open
id|wd8003_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_char
id|cmd
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* we probably don&squot;t want to be interrupted here. */
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* This section of code is mostly copied from the bsd driver which is&n;     mostly copied from somewhere else. */
multiline_comment|/* The somewhere else is probably the cmwymr(sp?) dos packet driver */
id|cmd
op_assign
id|inb_p
c_func
(paren
id|WD_COMM
)paren
suffix:semicolon
id|cmd
op_or_assign
id|CSTOP
suffix:semicolon
id|cmd
op_and_assign
op_complement
(paren
id|CSTART
op_or
id|CPAGE
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|cmd
comma
id|WD_COMM
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
id|WD_IMR
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|dconfig
comma
id|WD_DCR
)paren
suffix:semicolon
multiline_comment|/*Zero the remote byte count. */
id|outb_p
c_func
(paren
l_int|0
comma
id|WD_RBY0
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
id|WD_RBY1
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|WD_MCONFIG
comma
id|WD_RCC
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|WD_TCONFIG
comma
id|WD_TRC
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
id|WD_TRPG
)paren
suffix:semicolon
multiline_comment|/* Set the transmit page start = 0 */
id|outb_p
c_func
(paren
id|max_pages
comma
id|WD_PSTOP
)paren
suffix:semicolon
multiline_comment|/* (read) page stop = top of board memory */
id|outb_p
c_func
(paren
id|WD_TXBS
comma
id|WD_PSTRT
)paren
suffix:semicolon
multiline_comment|/* (read) page start = cur = bnd = top of tx memory */
id|outb_p
c_func
(paren
id|WD_TXBS
comma
id|WD_BNDR
)paren
suffix:semicolon
multiline_comment|/* clear interrupt status. */
id|outb_p
c_func
(paren
l_int|0xff
comma
id|WD_ISR
)paren
suffix:semicolon
multiline_comment|/* we don&squot;t want no stinking interrupts. */
id|outb_p
c_func
(paren
l_int|0
comma
id|WD_IMR
)paren
suffix:semicolon
id|cmd
op_or_assign
l_int|1
op_lshift
id|CPAGE_SHIFT
suffix:semicolon
id|outb_p
c_func
(paren
id|cmd
comma
id|WD_COMM
)paren
suffix:semicolon
multiline_comment|/* set the ether address. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETHER_ADDR_LEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb_p
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|WD_PAR0
op_plus
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* National recommends setting the boundry &lt; current page register */
id|outb_p
c_func
(paren
id|WD_TXBS
op_plus
l_int|1
comma
id|WD_CUR
)paren
suffix:semicolon
multiline_comment|/* Set the current page = page start + 1 */
multiline_comment|/* set the multicast address. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETHER_ADDR_LEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb_p
c_func
(paren
id|dev-&gt;broadcast
(braket
id|i
)braket
comma
id|WD_MAR0
op_plus
id|i
)paren
suffix:semicolon
)brace
id|cmd
op_and_assign
op_complement
(paren
id|CPAGE
op_or
id|CRDMA
)paren
suffix:semicolon
id|cmd
op_or_assign
l_int|4
op_lshift
id|CRDMA_SHIFT
suffix:semicolon
id|outb_p
c_func
(paren
id|cmd
comma
id|WD_COMM
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|WD_RCONFIG
comma
id|WD_RCC
)paren
suffix:semicolon
id|wd_start
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* This routine just calls the ether rcv_int. */
r_static
r_int
DECL|function|wdget
id|wdget
c_func
(paren
r_volatile
r_struct
id|wd_ring
op_star
id|ring
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_char
op_star
id|fptr
suffix:semicolon
r_int
id|len
suffix:semicolon
id|fptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|ring
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* some people have bugs in their hardware which let&n;     ring-&gt;count be 0.  It shouldn&squot;t happen, but we&n;     should check for it. */
id|len
op_assign
id|ring-&gt;count
op_minus
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|56
)paren
id|printk
(paren
l_string|&quot;we.c: Hardware problem, runt packet. ring-&gt;count = %d&bslash;n&quot;
comma
id|ring-&gt;count
)paren
suffix:semicolon
r_return
(paren
id|dev_rint
c_func
(paren
id|fptr
comma
id|len
comma
l_int|0
comma
id|dev
)paren
)paren
suffix:semicolon
)brace
r_int
DECL|function|wd8003_start_xmit
id|wd8003_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_char
id|cmd
suffix:semicolon
r_int
id|len
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
(brace
multiline_comment|/* put in a time out. */
r_if
c_cond
(paren
id|jiffies
op_minus
id|dev-&gt;trans_start
OL
l_int|30
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;wd8003 transmit timed out. &bslash;n&quot;
)paren
suffix:semicolon
)brace
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|wd_trs
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* this should check to see if it&squot;s been killed. */
r_if
c_cond
(paren
id|skb-&gt;dev
op_ne
id|dev
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;arp
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;rebuild_header
(paren
id|skb
op_plus
l_int|1
comma
id|dev
)paren
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;dev
op_eq
id|dev
)paren
(brace
id|arp_queue
(paren
id|skb
)paren
suffix:semicolon
)brace
id|cli
(paren
)paren
suffix:semicolon
multiline_comment|/* arp_queue turns them back on. */
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|memcpy
(paren
(paren
r_int
r_char
op_star
)paren
id|dev-&gt;mem_start
comma
id|skb
op_plus
l_int|1
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
multiline_comment|/* now we need to set up the card info. */
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|len
op_assign
id|max
c_func
(paren
id|len
comma
id|ETHER_MIN_LEN
)paren
suffix:semicolon
multiline_comment|/* actually we should zero out&n;&t;&t;&t;&t;  the extra memory. */
multiline_comment|/*  printk (&quot;start_xmit len - %d&bslash;n&quot;, len);*/
id|cmd
op_assign
id|inb_p
c_func
(paren
id|WD_COMM
)paren
suffix:semicolon
id|cmd
op_and_assign
op_complement
id|CPAGE
suffix:semicolon
id|outb_p
c_func
(paren
id|cmd
comma
id|WD_COMM
)paren
suffix:semicolon
id|interrupt_mask
op_or_assign
id|TRANS_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;interrupt
)paren
)paren
id|outb
(paren
id|interrupt_mask
comma
id|WD_IMR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|len
op_amp
l_int|0xff
comma
id|WD_TB0
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|len
op_rshift
l_int|8
comma
id|WD_TB1
)paren
suffix:semicolon
id|cmd
op_or_assign
id|CTRANS
suffix:semicolon
id|outb_p
c_func
(paren
id|cmd
comma
id|WD_COMM
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;free
)paren
(brace
id|kfree_skb
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* tell the card about the new boundary. */
r_static
r_void
DECL|function|wd_put_bnd
id|wd_put_bnd
c_func
(paren
r_int
r_char
id|bnd
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_char
id|cmd
suffix:semicolon
multiline_comment|/* Ensure page 0 selected */
id|cmd
op_assign
id|inb_p
c_func
(paren
id|CR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_amp
l_int|0x40
)paren
(brace
id|outb_p
c_func
(paren
id|cmd
op_amp
(paren
op_complement
id|CPAGE1
)paren
comma
id|WD_COMM
)paren
suffix:semicolon
multiline_comment|/* select page 0 */
id|outb_p
c_func
(paren
id|bnd
comma
id|WD_BNDR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|cmd
op_or
id|CPAGE1
comma
id|WD_COMM
)paren
suffix:semicolon
multiline_comment|/* reselect page 1 */
)brace
r_else
(brace
id|outb_p
c_func
(paren
id|bnd
comma
id|WD_BNDR
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
r_char
DECL|function|wd_get_bnd
id|wd_get_bnd
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_char
id|cmd
comma
id|bnd
suffix:semicolon
multiline_comment|/* Ensure page 0 selected */
id|cmd
op_assign
id|inb_p
c_func
(paren
id|WD_COMM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_amp
l_int|0x40
)paren
(brace
id|outb_p
c_func
(paren
id|cmd
op_amp
(paren
op_complement
id|CPAGE1
)paren
comma
id|WD_COMM
)paren
suffix:semicolon
multiline_comment|/* select page 0 */
id|bnd
op_assign
id|inb_p
c_func
(paren
id|WD_BNDR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|cmd
op_or
id|CPAGE1
comma
id|WD_COMM
)paren
suffix:semicolon
multiline_comment|/* reselect page 1 */
r_return
(paren
id|bnd
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
(paren
id|inb_p
c_func
(paren
id|WD_BNDR
)paren
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
r_char
DECL|function|wd_get_cur
id|wd_get_cur
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_char
id|cmd
comma
id|cur
suffix:semicolon
multiline_comment|/* Ensure page 1 selected */
id|cmd
op_assign
id|inb_p
c_func
(paren
id|WD_COMM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_amp
l_int|0x40
)paren
(brace
r_return
(paren
id|inb_p
c_func
(paren
id|WD_CUR
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb_p
c_func
(paren
id|cmd
op_or
id|CPAGE1
comma
id|WD_COMM
)paren
suffix:semicolon
multiline_comment|/* select page 1 */
id|cur
op_assign
id|inb_p
c_func
(paren
id|WD_CUR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|cmd
op_amp
(paren
op_complement
id|CPAGE1
)paren
comma
id|WD_COMM
)paren
suffix:semicolon
multiline_comment|/* reselect page 0 */
r_return
(paren
id|cur
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This routine handles the packet recieved interrupt. */
multiline_comment|/* Debug routines slow things down, but reveal bugs... */
multiline_comment|/* Modified Boundry Page Register to follow Current Page */
r_static
r_void
DECL|function|wd_rcv
id|wd_rcv
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_char
id|pkt
suffix:semicolon
multiline_comment|/* Next packet page start */
r_int
r_char
id|bnd
suffix:semicolon
multiline_comment|/* Last packet page end */
r_int
r_char
id|cur
suffix:semicolon
multiline_comment|/* Future packet page start */
r_int
r_char
id|cmd
suffix:semicolon
multiline_comment|/* Command register save */
r_volatile
r_struct
id|wd_ring
op_star
id|ring
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Calculate next packet location */
id|cur
op_assign
id|wd_get_cur
c_func
(paren
id|dev
)paren
suffix:semicolon
id|bnd
op_assign
id|wd_get_bnd
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pkt
op_assign
id|bnd
op_plus
l_int|1
)paren
op_eq
id|max_pages
)paren
(brace
id|pkt
op_assign
id|WD_TXBS
suffix:semicolon
)brace
r_while
c_loop
(paren
id|done
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|pkt
op_ne
id|cur
)paren
(brace
multiline_comment|/* Position pointer to packet in card ring buffer */
id|ring
op_assign
(paren
r_volatile
r_struct
id|wd_ring
op_star
)paren
(paren
id|dev-&gt;mem_start
op_plus
(paren
id|pkt
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
multiline_comment|/* Ensure a valid packet */
r_if
c_cond
(paren
id|ring-&gt;status
op_amp
l_int|1
)paren
(brace
multiline_comment|/* Too small and too big packets are&n;&t;&t;     filtered by the board */
r_if
c_cond
(paren
id|wd_debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nwd8013 - wdget: bnd = %d, pkt = %d, &quot;
l_string|&quot;cur = %d, status = %d, len = %d, next = %d&quot;
comma
id|bnd
comma
id|pkt
comma
id|cur
comma
id|ring-&gt;status
comma
id|ring-&gt;count
comma
id|ring-&gt;next
)paren
suffix:semicolon
)brace
id|stats.rx_packets
op_increment
suffix:semicolon
multiline_comment|/* count all receives */
id|done
op_assign
id|wdget
c_func
(paren
id|ring
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* get the packet */
multiline_comment|/* Calculate next packet location */
id|pkt
op_assign
id|ring-&gt;next
suffix:semicolon
multiline_comment|/* Compute new boundry - tell the chip */
r_if
c_cond
(paren
(paren
id|bnd
op_assign
id|pkt
op_minus
l_int|1
)paren
OL
id|WD_TXBS
)paren
(brace
id|bnd
op_assign
id|max_pages
op_minus
l_int|1
suffix:semicolon
)brace
id|wd_put_bnd
c_func
(paren
id|bnd
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* update our copy of cur. */
id|cur
op_assign
id|wd_get_cur
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Bad packet in ring buffer -&n;&t;&t;&t;   should not happen due to hardware filtering */
id|printk
c_func
(paren
l_string|&quot;wd8013 - bad packet: len = %d, status = x%x, &quot;
l_string|&quot;bnd = %d, pkt = %d, cur = %d&bslash;n&quot;
l_string|&quot;trashing receive buffer!&quot;
comma
id|ring-&gt;count
comma
id|ring-&gt;status
comma
id|bnd
comma
id|pkt
comma
id|cur
)paren
suffix:semicolon
multiline_comment|/* Reset bnd = cur-1 */
r_if
c_cond
(paren
(paren
id|bnd
op_assign
id|wd_get_cur
c_func
(paren
id|dev
)paren
op_minus
l_int|1
)paren
OL
id|WD_TXBS
)paren
(brace
id|bnd
op_assign
id|max_pages
op_minus
l_int|1
suffix:semicolon
)brace
id|wd_put_bnd
c_func
(paren
id|bnd
comma
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* return */
)brace
)brace
r_else
(brace
id|done
op_assign
id|dev_rint
c_func
(paren
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* reset to page 0 */
id|cmd
op_assign
id|inb_p
c_func
(paren
id|WD_COMM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_amp
l_int|0x40
)paren
(brace
id|outb_p
c_func
(paren
id|cmd
op_amp
op_complement
(paren
id|CPAGE1
)paren
comma
id|WD_COMM
)paren
suffix:semicolon
multiline_comment|/* select page 0 */
)brace
)brace
multiline_comment|/* Handle the &quot;receiver overrun&quot; interrupt. */
r_static
r_void
DECL|function|wd_rx_over
id|wd_rx_over
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_char
id|cmd
comma
id|dummy
suffix:semicolon
r_register
r_int
id|io
suffix:semicolon
multiline_comment|/*&n;   * Nothing actually has been overwritten;&n;   * the chip has stopped at the boundry but&n;   * we must get it going again - according&n;   * to National Semiconductor.&n;   */
id|printk
c_func
(paren
l_string|&quot;wd_rx_over&bslash;n&quot;
)paren
suffix:semicolon
id|cmd
op_assign
id|inb_p
c_func
(paren
id|CR
)paren
suffix:semicolon
multiline_comment|/* get current command register */
id|cmd
op_assign
(paren
id|cmd
op_amp
op_complement
(paren
id|STA
op_or
id|PS0
op_or
id|PS1
)paren
)paren
op_or
id|STOP
suffix:semicolon
multiline_comment|/* toggle start and stop bits, select page 0 */
id|outb_p
c_func
(paren
id|cmd
comma
id|CR
)paren
suffix:semicolon
id|dummy
op_assign
id|inb_p
c_func
(paren
id|RBCR0
)paren
suffix:semicolon
multiline_comment|/* required to detect reset status */
id|dummy
op_assign
id|inb_p
c_func
(paren
id|RBCR1
)paren
suffix:semicolon
id|wd_rcv
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* clear out received packets */
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|ISR
)paren
op_amp
id|PRX
)paren
(brace
id|outb_p
c_func
(paren
id|PRX
comma
id|ISR
)paren
suffix:semicolon
)brace
multiline_comment|/* acknowledge RX interrupt */
r_while
c_loop
(paren
(paren
id|inb_p
c_func
(paren
id|ISR
)paren
op_amp
id|RST
)paren
op_eq
l_int|0
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* wait for reset to be completed */
id|outb_p
c_func
(paren
id|RST
comma
id|ISR
)paren
suffix:semicolon
multiline_comment|/* acknowledge RST interrupt */
id|outb_p
c_func
(paren
(paren
id|cmd
op_amp
op_complement
id|STOP
)paren
op_or
id|STA
comma
id|CR
)paren
suffix:semicolon
multiline_comment|/* Start NIC */
id|outb_p
c_func
(paren
id|WD_TCONFIG
comma
id|TCR
)paren
suffix:semicolon
multiline_comment|/* resume normal mode */
)brace
multiline_comment|/*&n; * This get&squot;s the transmit interrupts. It assumes command page 0 is set, and&n; * returns with command page 0 set.&n; */
r_static
r_void
DECL|function|wd_trs
id|wd_trs
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_char
id|errors
suffix:semicolon
r_if
c_cond
(paren
id|wd_debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nwd_trs() - TX complete, status = x%x&quot;
comma
id|inb_p
c_func
(paren
id|TSR
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|errors
op_assign
id|inb_p
c_func
(paren
id|TSR
)paren
op_amp
id|PTXOK
)paren
op_logical_or
id|tx_aborted
)paren
(brace
r_if
c_cond
(paren
(paren
id|errors
op_amp
op_complement
l_int|0x02
)paren
op_eq
l_int|0
)paren
(brace
id|stats.tx_packets
op_increment
suffix:semicolon
id|tx_aborted
op_assign
l_int|0
suffix:semicolon
)brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
(paren
id|INET_BH
)paren
suffix:semicolon
macro_line|#if 0&t;&t;
multiline_comment|/* attempt to start a new transmission. */
id|len
op_assign
id|dev_tint
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|dev-&gt;mem_start
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
l_int|0
)paren
(brace
id|len
op_assign
id|max
c_func
(paren
id|len
comma
id|ETHER_MIN_LEN
)paren
suffix:semicolon
id|cmd
op_assign
id|inb_p
c_func
(paren
id|WD_COMM
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|len
op_amp
l_int|0xff
comma
id|WD_TB0
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|len
op_rshift
l_int|8
comma
id|WD_TB1
)paren
suffix:semicolon
id|cmd
op_or_assign
id|CTRANS
suffix:semicolon
id|outb_p
c_func
(paren
id|cmd
comma
id|WD_COMM
)paren
suffix:semicolon
id|interrupt_mask
op_or_assign
id|TRANS_MASK
suffix:semicolon
)brace
r_else
(brace
id|dev-&gt;tbusy
op_assign
l_int|0
id|interrupt_mask
op_and_assign
op_complement
id|TRANS_MASK
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* TX error occurred! - H/W will reschedule */
r_if
c_cond
(paren
id|errors
op_amp
id|CRS
)paren
(brace
id|stats.tx_carrier_errors
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nwd8013 - network cable short!&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|errors
op_amp
id|COL
)paren
id|stats.collisions
op_add_assign
id|inb_p
c_func
(paren
id|NCR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errors
op_amp
id|CDH
)paren
id|stats.tx_heartbeat_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|errors
op_amp
id|OWC
)paren
id|stats.tx_window_errors
op_increment
suffix:semicolon
)brace
)brace
r_void
DECL|function|wd8003_interrupt
id|wd8003_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
(brace
r_int
r_char
id|cmd
suffix:semicolon
r_int
r_char
id|errors
suffix:semicolon
r_int
r_char
id|isr
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_struct
id|pt_regs
op_star
id|ptr
suffix:semicolon
r_int
id|irq
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|ptr
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
id|reg_ptr
suffix:semicolon
id|irq
op_assign
op_minus
(paren
id|ptr-&gt;orig_eax
op_plus
l_int|2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
id|irq
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;we.c: irq %d for unknown device&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* this could take a long time, we should have interrupts on. */
id|cmd
op_assign
id|inb_p
c_func
(paren
id|CR
)paren
suffix:semicolon
multiline_comment|/* Select page 0 */
r_if
c_cond
(paren
id|cmd
op_amp
(paren
id|PS0
op_or
id|PS1
)paren
)paren
(brace
id|cmd
op_and_assign
op_complement
(paren
id|PS0
op_or
id|PS1
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|cmd
comma
id|CR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wd_debug
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;nwd8013 - interrupt isr = x%x&quot;
comma
id|inb_p
c_func
(paren
id|ISR
)paren
)paren
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|1
suffix:semicolon
r_do
(brace
multiline_comment|/* find out who called */
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Check for overrunning receive buffer first */
r_if
c_cond
(paren
(paren
id|isr
op_assign
id|inb_p
c_func
(paren
id|ISR
)paren
)paren
op_amp
id|OVW
)paren
(brace
multiline_comment|/* Receiver overwrite warning */
id|stats.rx_over_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|wd_debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nwd8013 overrun bnd = %d, cur = %d&quot;
comma
id|wd_get_bnd
c_func
(paren
id|dev
)paren
comma
id|wd_get_cur
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
)brace
id|wd_rx_over
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* performs wd_rcv() as well */
id|outb_p
c_func
(paren
id|OVW
comma
id|ISR
)paren
suffix:semicolon
multiline_comment|/* acknowledge interrupt */
)brace
r_else
r_if
c_cond
(paren
id|isr
op_amp
id|PRX
)paren
(brace
multiline_comment|/* got a packet. */
id|wd_rcv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|PRX
comma
id|ISR
)paren
suffix:semicolon
multiline_comment|/* acknowledge interrupt */
)brace
multiline_comment|/* This completes rx processing... whats next */
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|ISR
)paren
op_amp
id|PTX
)paren
(brace
multiline_comment|/* finished sending a packet. */
id|wd_trs
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|PTX
comma
id|ISR
)paren
suffix:semicolon
multiline_comment|/* acknowledge interrupt */
)brace
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|ISR
)paren
op_amp
id|RXE
)paren
(brace
multiline_comment|/* recieve error */
id|stats.rx_errors
op_increment
suffix:semicolon
multiline_comment|/* general errors */
id|errors
op_assign
id|inb_p
c_func
(paren
id|RSR
)paren
suffix:semicolon
multiline_comment|/* detailed errors */
r_if
c_cond
(paren
id|errors
op_amp
id|CRC
)paren
id|stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|errors
op_amp
id|FAE
)paren
id|stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|errors
op_amp
id|FO
)paren
id|stats.rx_fifo_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|errors
op_amp
id|MPA
)paren
id|stats.rx_missed_errors
op_increment
suffix:semicolon
id|outb_p
c_func
(paren
id|RXE
comma
id|ISR
)paren
suffix:semicolon
multiline_comment|/* acknowledge interrupt */
)brace
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|ISR
)paren
op_amp
id|TXE
)paren
(brace
multiline_comment|/* transmit aborted! */
id|stats.tx_errors
op_increment
suffix:semicolon
multiline_comment|/* general errors */
id|errors
op_assign
id|inb_p
c_func
(paren
id|TSR
)paren
suffix:semicolon
multiline_comment|/* get detailed errors */
r_if
c_cond
(paren
id|errors
op_amp
id|ABT
)paren
(brace
id|stats.tx_aborted_errors
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nwd8013 - network cable open!&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|errors
op_amp
id|FU
)paren
(brace
id|stats.tx_fifo_errors
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nwd8013 - TX FIFO underrun!&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Cannot do anymore - empty the bit bucket */
id|tx_aborted
op_assign
l_int|1
suffix:semicolon
id|wd_trs
c_func
(paren
id|dev
)paren
suffix:semicolon
id|tx_aborted
op_assign
l_int|0
suffix:semicolon
id|outb_p
c_func
(paren
id|TXE
comma
id|ISR
)paren
suffix:semicolon
multiline_comment|/* acknowledge interrupt */
)brace
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|ISR
)paren
op_amp
id|CNTE
)paren
(brace
multiline_comment|/* Tally counters overflowing */
id|errors
op_assign
id|inb_p
c_func
(paren
id|CNTR0
)paren
suffix:semicolon
id|errors
op_assign
id|inb_p
c_func
(paren
id|CNTR1
)paren
suffix:semicolon
id|errors
op_assign
id|inb_p
c_func
(paren
id|CNTR2
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|CNTE
comma
id|ISR
)paren
suffix:semicolon
multiline_comment|/* acknowledge interrupt */
)brace
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|ISR
)paren
op_amp
id|RST
)paren
(brace
multiline_comment|/* Reset has been performed */
id|outb_p
c_func
(paren
id|RST
comma
id|ISR
)paren
suffix:semicolon
)brace
multiline_comment|/* acknowledge interrupt */
r_if
c_cond
(paren
id|wd_debug
)paren
(brace
r_if
c_cond
(paren
(paren
id|isr
op_assign
id|inb_p
c_func
(paren
id|ISR
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nwd8013 - ISR not cleared = x%x&quot;
comma
id|isr
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_increment
id|count
OG
id|max_pages
op_plus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nwd8013_interrupt - infinite loop detected, isr = x%x, count = %d&quot;
comma
id|isr
comma
id|count
)paren
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|inb_p
c_func
(paren
id|ISR
)paren
op_ne
l_int|0
)paren
(brace
suffix:semicolon
)brace
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
)brace
DECL|variable|wd8003_sigaction
r_static
r_struct
id|sigaction
id|wd8003_sigaction
op_assign
(brace
id|wd8003_interrupt
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/* Probe for a WD80x3 board. */
r_static
r_int
DECL|function|we8003_probe
id|we8003_probe
c_func
(paren
r_struct
id|ddconf
op_star
id|conf
)paren
(brace
r_int
r_char
id|csum
suffix:semicolon
r_register
r_int
id|io
suffix:semicolon
r_int
id|i
suffix:semicolon
id|io
op_assign
id|conf-&gt;ioaddr
suffix:semicolon
id|csum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|csum
op_add_assign
id|inb_p
c_func
(paren
id|io
op_plus
id|WD_ROM
op_plus
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|csum
op_ne
id|WD_CHECK
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;%s: Warning: board not found at IO=0x%X.&bslash;n&quot;
comma
id|io
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Check for a 16-bit ISA controller.  Set a flag if found. */
r_static
r_void
DECL|function|we8003_8bit
id|we8003_8bit
c_func
(paren
r_struct
id|ddi
op_star
id|dev
)paren
(brace
macro_line|#if !FORCE_8BIT
r_int
r_char
id|csum
suffix:semicolon
r_register
r_int
id|io
suffix:semicolon
r_int
id|i
suffix:semicolon
id|io
op_assign
id|dev-&gt;config.ioaddr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|io
op_plus
id|EN_SAPROM
op_plus
id|i
)paren
op_ne
id|inb_p
c_func
(paren
id|io
op_plus
id|EN_CMD
op_plus
id|i
)paren
)paren
(brace
multiline_comment|/* Fiddle with 16-bit bit. */
id|csum
op_assign
id|inb_p
c_func
(paren
id|io
op_plus
id|EN_REG1
)paren
suffix:semicolon
multiline_comment|/* Attempt to clear 16-bit bit. */
id|outb
c_func
(paren
id|csum
op_xor
id|BUS16
comma
id|io
op_plus
id|EN_REG1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|csum
op_amp
id|BUS16
)paren
op_eq
(paren
id|inb_p
c_func
(paren
id|io
op_plus
id|EN_REG1
)paren
op_amp
id|BUS16
)paren
)paren
(brace
id|outb_p
c_func
(paren
id|LAN16ENABLE
op_or
id|MEMMASK
comma
id|io
op_plus
id|EN_REG5
)paren
suffix:semicolon
id|outb
c_func
(paren
id|csum
comma
id|io
op_plus
id|EN_REG1
)paren
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|DDI_FBUS16
suffix:semicolon
r_break
suffix:semicolon
)brace
id|outb
c_func
(paren
id|csum
comma
id|io
op_plus
id|EN_REG1
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
multiline_comment|/* Setup and clear the on-board memory. */
r_static
r_void
DECL|function|we8003_cmem
id|we8003_cmem
c_func
(paren
r_struct
id|ddi
op_star
id|dev
)paren
(brace
r_register
r_int
id|io
suffix:semicolon
id|io
op_assign
id|dev-&gt;config.ioaddr
suffix:semicolon
id|outb_p
c_func
(paren
id|WD_IMEM
comma
id|io
op_plus
id|WD_CTL
)paren
suffix:semicolon
multiline_comment|/* mapin the interface memory&t;*/
multiline_comment|/* FIXME: clear the interface memory here. */
)brace
multiline_comment|/* Fetch and record the interface&squot;s hardware address. */
r_static
r_void
DECL|function|we8003_geth
id|we8003_geth
c_func
(paren
r_struct
id|ddi
op_star
id|dev
)paren
(brace
r_register
r_int
id|io
suffix:semicolon
r_register
r_int
id|i
suffix:semicolon
id|io
op_assign
id|dev-&gt;config.ioaddr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETHER_ADDR_LEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|inb_p
c_func
(paren
id|io
op_plus
id|WD_ROM
op_plus
id|i
)paren
suffix:semicolon
id|dev-&gt;broadcast
(braket
id|i
)braket
op_assign
l_int|0xff
suffix:semicolon
)brace
)brace
multiline_comment|/* Initialize the WD8003 hardware. */
r_int
DECL|function|we8003_conf
id|we8003_conf
c_func
(paren
r_struct
id|ddi
op_star
id|dev
)paren
(brace
multiline_comment|/*&n;   * Check for any boards present.  We must change this one&n;   * time to include complete AutoProbe, but for now, we just&n;   * see if we need to initialize a board at all. - FvK&n;   */
r_if
c_cond
(paren
id|dev-&gt;config.ioaddr
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* fake it&squot;s OK */
r_if
c_cond
(paren
id|we8003_probe
c_func
(paren
op_amp
id|dev-&gt;config
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Check for 16-bit board- it doesn&squot;t have register 0/8 aliasing. */
id|we8003_8bit
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Set up and clear the shared memory. */
id|we8003_cmem
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Fetch and record the hardware address. */
id|we8003_geth
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Clear the statistics */
id|memset
(paren
(paren
r_char
op_star
)paren
op_amp
id|stats
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|enet_statistics
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|irqaction
(paren
id|dev-&gt;irq
comma
op_amp
id|we8003_sigaction
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to get IRQ%d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
