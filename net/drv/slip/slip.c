multiline_comment|/*&n; * slip.c&t;This module implements the SLIP protocol for kernel-based&n; *&t;&t;devices like TTY.  It interfaces between a raw TTY, and the&n; *&t;&t;kernel&squot;s NET protocol layers (via DDI).&n; *&n; * Version:&t;@(#)slip.c&t;0.5.0&t;(02/11/93)&n; *&n; * Authors:&t;Laurence Culhane, &lt;loz@holmes.demon.co.uk&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uwalt.nl.mugnet.org&gt;&n; */
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/termios.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/slip.h&gt;
macro_line|#include &lt;netinet/in.h&gt;
DECL|macro|SLIP_VERSION
mdefine_line|#define&t;SLIP_VERSION&t;&quot;0.5.0&quot;
DECL|macro|SL_DUMP
mdefine_line|#define&t;SL_DUMP
DECL|macro|SL_DEBUG
mdefine_line|#define&t;SL_DEBUG
macro_line|#ifdef&t;SL_DEBUG
DECL|macro|PRINTK
macro_line|#   define PRINTK(x)&t;printk x
macro_line|#else
DECL|macro|PRINTK
macro_line|#   define PRINTK(x)&t;/**/
macro_line|#endif
multiline_comment|/* Define some IP layer stuff.  Not all systems have it. */
macro_line|#ifdef SL_DUMP
DECL|macro|IP_VERSION
macro_line|#  define&t;IP_VERSION&t;4&t;/* version# of our IP software&t;*/
DECL|macro|IPF_F_OFFSET
macro_line|#  define&t;IPF_F_OFFSET&t;0x1fff&t;/* Offset field&t;&t;&t;*/
DECL|macro|IPF_DF
macro_line|#  define&t;IPF_DF&t;&t;0x4000&t;/* Don&squot;t fragment flag&t;&t;*/
DECL|macro|IPF_MF
macro_line|#  define&t;IPF_MF&t;&t;0x2000&t;/* More Fragments flag&t;&t;*/
DECL|struct|ipheader
r_typedef
r_struct
id|ipheader
(brace
DECL|member|v_ihl
id|u_char
id|v_ihl
suffix:semicolon
multiline_comment|/* Version + IP header length&t;*/
DECL|member|tos
id|u_char
id|tos
suffix:semicolon
multiline_comment|/* Type of service&t;&t;*/
DECL|member|length
id|u_short
id|length
suffix:semicolon
multiline_comment|/* Total length&t;&t;&t;*/
DECL|member|id
id|u_short
id|id
suffix:semicolon
multiline_comment|/* Identification&t;&t;*/
DECL|member|fl_offs
id|u_short
id|fl_offs
suffix:semicolon
multiline_comment|/* Flags + fragment offset&t;*/
DECL|member|ttl
id|u_char
id|ttl
suffix:semicolon
multiline_comment|/* Time to live&t;&t;&t;*/
DECL|member|protocol
id|u_char
id|protocol
suffix:semicolon
multiline_comment|/* Protocol&t;&t;&t;*/
DECL|member|checksum
id|u_short
id|checksum
suffix:semicolon
multiline_comment|/* Header checksum&t;&t;*/
DECL|member|source
id|u_long
id|source
suffix:semicolon
multiline_comment|/* Source address&t;&t;*/
DECL|member|dest
id|u_long
id|dest
suffix:semicolon
multiline_comment|/* Destination address&t;&t;*/
DECL|typedef|IP
)brace
id|IP
suffix:semicolon
DECL|macro|IP_OF_COPIED
macro_line|#   define&t;IP_OF_COPIED&t;0x80&t;/* Copied-on-fragmentation flag&t;*/
DECL|macro|IP_OF_CLASS
macro_line|#   define&t;IP_OF_CLASS&t;0x60&t;/* Option class&t;&t;&t;*/
DECL|macro|IP_OF_NUMBER
macro_line|#   define&t;IP_OF_NUMBER&t;0x1f&t;/* Option number&t;&t;*/
DECL|macro|IPO_EOL
macro_line|#   define&t;IPO_EOL&t;&t;0&t;/* End of options list&t;&t;*/
DECL|macro|IPO_NOOP
macro_line|#   define&t;IPO_NOOP&t;1&t;/* No Operation&t;&t;&t;*/
DECL|macro|IPO_SECURITY
macro_line|#   define&t;IPO_SECURITY&t;2&t;/* Security parameters&t;&t;*/
DECL|macro|IPO_LSROUTE
macro_line|#   define&t;IPO_LSROUTE&t;3&t;/* Loose Source Routing&t;&t;*/
DECL|macro|IPO_TIMESTAMP
macro_line|#   define&t;IPO_TIMESTAMP&t;4&t;/* Internet Timestamp&t;&t;*/
DECL|macro|IPO_RROUTE
macro_line|#   define&t;IPO_RROUTE&t;7&t;/* Record Route&t;&t;&t;*/
DECL|macro|IPO_STREAMID
macro_line|#   define&t;IPO_STREAMID&t;8&t;/* Stream ID&t;&t;&t;*/
DECL|macro|IPO_SSROUTE
macro_line|#   define&t;IPO_SSROUTE&t;9&t;/* Strict Source Routing&t;*/
DECL|macro|IP_TS_ONLY
macro_line|#   define&t;IP_TS_ONLY&t;0&t;/* Time stamps only&t;&t;*/
DECL|macro|IP_TS_ADDRESS
macro_line|#   define&t;IP_TS_ADDRESS&t;1&t;/* Addresses + Time stamps&t;*/
DECL|macro|IP_TS_PRESPEC
macro_line|#   define&t;IP_TS_PRESPEC&t;3&t;/* Prespecified addresses only&t;*/
macro_line|#endif
multiline_comment|/* This table holds the control blocks for all SLIP channels. */
DECL|variable|sl_ctrl
r_static
r_struct
id|slip
id|sl_ctrl
(braket
id|SL_NRUNIT
)braket
suffix:semicolon
macro_line|#ifdef SL_DUMP
multiline_comment|/* Dump the contents of an IP datagram. */
r_static
r_void
DECL|function|ip_dump
id|ip_dump
c_func
(paren
r_int
r_char
op_star
id|ptr
comma
r_int
id|len
)paren
(brace
r_int
id|hdr_ver
comma
id|hdr_len
comma
id|dta_len
comma
id|dta_off
suffix:semicolon
id|IP
op_star
id|ip
suffix:semicolon
r_extern
r_char
op_star
id|in_ntoa
c_func
(paren
r_int
id|num
)paren
suffix:semicolon
id|ip
op_assign
(paren
id|IP
op_star
)paren
id|ptr
suffix:semicolon
id|hdr_ver
op_assign
(paren
id|ip-&gt;v_ihl
op_amp
l_int|0xF0
)paren
op_rshift
l_int|4
suffix:semicolon
id|hdr_len
op_assign
(paren
id|ip-&gt;v_ihl
op_amp
l_int|0x0F
)paren
op_star
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|dta_len
op_assign
id|ntohs
c_func
(paren
id|ip-&gt;length
)paren
suffix:semicolon
id|dta_off
op_assign
(paren
id|ntohs
c_func
(paren
id|ip-&gt;fl_offs
)paren
op_amp
id|IPF_F_OFFSET
)paren
op_lshift
l_int|3
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;r*****&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SLIP: %s-&gt;&quot;
comma
id|in_ntoa
c_func
(paren
id|ip-&gt;source
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|ip-&gt;dest
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; len %u ihl %u ttl %u prot %u&quot;
comma
id|dta_len
comma
id|ip-&gt;v_ihl
op_amp
l_int|0xFF
comma
id|ip-&gt;ttl
op_amp
l_int|0xFF
comma
id|ip-&gt;protocol
op_amp
l_int|0xFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;tos
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot; tos %u&quot;
comma
id|ip-&gt;tos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dta_off
op_ne
l_int|0
op_logical_or
(paren
id|ntohs
c_func
(paren
id|ip-&gt;fl_offs
)paren
op_amp
id|IPF_MF
)paren
)paren
id|printk
c_func
(paren
l_string|&quot; id %u offs %u&quot;
comma
id|ntohs
c_func
(paren
id|ip-&gt;id
)paren
comma
id|dta_off
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|ip-&gt;fl_offs
)paren
op_amp
id|IPF_DF
)paren
id|printk
c_func
(paren
l_string|&quot; DF&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|ip-&gt;fl_offs
)paren
op_amp
id|IPF_MF
)paren
id|printk
c_func
(paren
l_string|&quot; MF&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n*****&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Read data from a TTY queue.  This function will eventually&n; * be moved into the TTY layer itself, making it available for&n; * other layers, too.&n; */
DECL|function|tty_read_data
r_int
id|tty_read_data
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|max
)paren
(brace
r_register
r_int
id|count
suffix:semicolon
r_register
r_int
r_char
id|c
suffix:semicolon
multiline_comment|/* Keep fetching characters from TTY until done or full. */
id|count
op_assign
l_int|0
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;SLIP: tty_read:&quot;
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|max
op_decrement
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|EMPTY
c_func
(paren
op_amp
id|tty-&gt;read_q
)paren
)paren
r_break
suffix:semicolon
id|c
op_assign
(paren
id|get_tty_queue
c_func
(paren
op_amp
id|tty-&gt;read_q
)paren
op_amp
l_int|0377
)paren
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|c
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot; %02x&quot;
comma
(paren
r_int
)paren
(paren
id|c
op_amp
l_int|255
)paren
)paren
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
id|PRINTK
(paren
(paren
l_string|&quot;&bslash;r&bslash;nSLIP: tty_read: read %d bytes&bslash;r&bslash;n&quot;
comma
id|count
)paren
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * Write data to a TTY queue.  This function will eventually&n; * be moved into the TTY layer itself, making it available for&n; * other layers, too.&n; */
DECL|function|tty_write_data
r_void
id|tty_write_data
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
multiline_comment|/* PRINTK ((&quot;SLIP: tty_write: writing %d bytes&bslash;r&bslash;n&quot;, count)); */
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|put_tty_queue
c_func
(paren
op_star
id|buf
op_increment
comma
op_amp
id|tty-&gt;write_q
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Flush a TTY write queue by calling the TTY layer.  This&n; * function will eventually be moved into the TTY layer itself,&n; * making it available for other layers, too.&n; */
DECL|function|tty_flush
r_void
id|tty_flush
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
multiline_comment|/* PRINTK ((&quot;SLIP: tty_flush: flusing the toilet...&bslash;r&bslash;n&quot;)); */
multiline_comment|/*&n;&t; * This should also tell TTY which function to call-back&n;&t; * when the work is done, allowing us to clean up and&n;&t; * possibly start another output...&n;&t; */
id|tty_write_flush
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* Find a SLIP channel from its `tty&squot; link. */
r_static
r_struct
id|slip
op_star
DECL|function|sl_find
id|sl_find
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|slip
op_star
id|sl
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SL_NRUNIT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sl
op_assign
op_amp
id|sl_ctrl
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|sl-&gt;tty
op_eq
id|tty
)paren
r_return
id|sl
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Find a free SLIP channel, and link in this `tty&squot; line. */
r_static
r_inline
r_struct
id|slip
op_star
DECL|function|sl_alloc
id|sl_alloc
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|slip
op_star
id|sl
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SL_NRUNIT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sl
op_assign
op_amp
id|sl_ctrl
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|sl-&gt;inuse
op_eq
l_int|0
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;pushfl ; popl %0 ; cli&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|flags
)paren
)paren
suffix:semicolon
id|sl-&gt;inuse
op_increment
suffix:semicolon
id|sl-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;pushl %0 ; popfl&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|flags
)paren
)paren
suffix:semicolon
r_return
id|sl
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Free a SLIP channel. */
r_static
r_inline
r_void
DECL|function|sl_free
id|sl_free
c_func
(paren
r_struct
id|slip
op_star
id|sl
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|sl-&gt;inuse
op_eq
l_int|1
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;pushfl ; popl %0 ; cli&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|flags
)paren
)paren
suffix:semicolon
id|sl-&gt;inuse
op_decrement
suffix:semicolon
id|sl-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;pushl %0 ; popfl&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|flags
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Stuff one byte into a SLIP queue. */
r_static
r_inline
r_void
DECL|function|put_sl_queue
id|put_sl_queue
c_func
(paren
r_struct
id|sl_queue
op_star
id|queue
comma
r_char
id|c
)paren
(brace
r_int
id|head
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;pushfl ; popl %0 ; cli&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|flags
)paren
)paren
suffix:semicolon
id|head
op_assign
(paren
id|queue-&gt;head
op_plus
l_int|1
)paren
op_amp
(paren
id|SL_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head
op_ne
id|queue-&gt;tail
)paren
(brace
id|queue-&gt;buf
(braket
id|queue-&gt;head
)braket
op_assign
id|c
suffix:semicolon
id|queue-&gt;head
op_assign
id|head
suffix:semicolon
)brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;pushl %0 ; popfl&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|flags
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Release &squot;i&squot; bytes from a SLIP queue. */
r_static
r_inline
r_void
DECL|function|eat_sl_queue
id|eat_sl_queue
c_func
(paren
r_struct
id|sl_queue
op_star
id|queue
comma
r_int
id|i
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;pushfl ; popl %0 ; cli&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|flags
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|queue-&gt;tail
op_ne
id|queue-&gt;head
)paren
id|queue-&gt;tail
op_assign
(paren
id|queue-&gt;tail
op_plus
id|i
)paren
op_amp
(paren
id|SL_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;pushl %0 ; popfl&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|flags
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the &quot;sending&quot; flag.  This must be atomic, hence the ASM. */
r_static
r_inline
r_void
DECL|function|sl_lock
id|sl_lock
c_func
(paren
r_struct
id|slip
op_star
id|sl
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;pushfl ; popl %0 ; cli&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|flags
)paren
)paren
suffix:semicolon
id|sl-&gt;sending
op_assign
l_int|1
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;pushl %0 ; popfl&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|flags
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Clear the &quot;sending&quot; flag.  This must be atomic, hence the ASM. */
r_static
r_inline
r_void
DECL|function|sl_unlock
id|sl_unlock
c_func
(paren
r_struct
id|slip
op_star
id|sl
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;pushfl ; popl %0 ; cli&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|flags
)paren
)paren
suffix:semicolon
id|sl-&gt;sending
op_assign
l_int|0
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;pushl %0 ; popfl&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|flags
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Send one completely decapsulated IP datagram to the IP layer. */
r_static
r_void
DECL|function|sl_recv
id|sl_recv
c_func
(paren
r_struct
id|slip
op_star
id|sl
comma
r_int
id|len
)paren
(brace
macro_line|#if 0
r_struct
id|device
op_star
id|dev
suffix:semicolon
macro_line|#endif
r_register
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
id|done
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;SLIP: sending one dgram to IP (len=%d)&bslash;r&bslash;n&quot;
comma
id|len
)paren
)paren
suffix:semicolon
macro_line|#ifdef SL_DUMP
id|printk
c_func
(paren
l_string|&quot;&lt;&lt; iface &bslash;&quot;sl%d&bslash;&quot; recv:&bslash;r&bslash;n&quot;
comma
id|sl-&gt;line
)paren
suffix:semicolon
id|ip_dump
c_func
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|sl-&gt;rcv_queue.buf
(braket
id|sl-&gt;rcv_queue.tail
)braket
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Bump the datagram to the upper layers... */
macro_line|#if 0
id|dev
op_assign
id|sl-&gt;dev
suffix:semicolon
id|p
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|sl-&gt;rcv_queue.buf
(braket
id|sl-&gt;rcv_queue.tail
)braket
suffix:semicolon
r_do
(brace
id|done
op_assign
id|dev_rint
c_func
(paren
id|p
comma
id|len
comma
l_int|0
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done
op_eq
l_int|1
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
macro_line|#endif
id|eat_sl_queue
c_func
(paren
op_amp
id|sl-&gt;rcv_queue
comma
id|len
)paren
suffix:semicolon
id|sl-&gt;rcvd
op_increment
suffix:semicolon
)brace
multiline_comment|/* Encapsulate one IP datagram and stuff into a TTY queue. */
r_static
r_void
DECL|function|sl_send
id|sl_send
c_func
(paren
r_struct
id|slip
op_star
id|sl
comma
r_int
r_char
op_star
id|p
comma
r_int
id|len
)paren
(brace
r_register
r_int
r_char
op_star
id|bp
suffix:semicolon
r_register
r_int
id|count
suffix:semicolon
multiline_comment|/* PRINTK ((&quot;SLIP: sl_send(0x%X, %d) called&bslash;n&quot;, p, len)); */
id|bp
op_assign
(paren
r_int
r_char
op_star
)paren
id|sl-&gt;xbuff
suffix:semicolon
macro_line|#ifdef SL_DUMP
id|printk
c_func
(paren
l_string|&quot;&gt;&gt; iface &bslash;&quot;sl%d&bslash;&quot; sent:&bslash;r&bslash;n&quot;
comma
id|sl-&gt;line
)paren
suffix:semicolon
id|ip_dump
c_func
(paren
id|p
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Send an initial END character to flush out any&n;&t; * data that may have accumulated in the receiver&n;&t; * due to line noise.&n;&t; */
op_star
id|bp
op_increment
op_assign
id|END
suffix:semicolon
id|count
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * For each byte in the packet, send the appropriate&n;&t; * character sequence, according to the SLIP protocol.&n;&t; * FIXME: change this to copy blocks of characters between&n;&t; *&t;  special characters to improve speed.&n;&t; */
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
r_switch
c_cond
(paren
op_star
id|p
)paren
(brace
r_case
id|END
suffix:colon
op_star
id|bp
op_increment
op_assign
id|ESC
suffix:semicolon
op_star
id|bp
op_increment
op_assign
id|ESC_END
suffix:semicolon
id|count
op_add_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ESC
suffix:colon
op_star
id|bp
op_increment
op_assign
id|ESC
suffix:semicolon
op_star
id|bp
op_increment
op_assign
id|ESC_ESC
suffix:semicolon
id|count
op_add_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|bp
op_increment
op_assign
op_star
id|p
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
id|p
op_increment
suffix:semicolon
)brace
op_star
id|bp
op_increment
op_assign
id|END
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|sl-&gt;sent
op_increment
suffix:semicolon
id|tty_write_data
c_func
(paren
id|sl-&gt;tty
comma
id|sl-&gt;xbuff
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* stuff into TTY&t;*/
)brace
multiline_comment|/* Encapsulate an IP datagram and kick it into a TTY queue. */
r_static
r_int
DECL|function|sl_start_xmit
id|sl_start_xmit
c_func
(paren
r_void
multiline_comment|/*struct sk_buff*/
op_star
id|skb
comma
r_void
multiline_comment|/*struct device*/
op_star
id|dev
)paren
(brace
r_struct
id|slip
op_star
id|sl
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Find the correct SLIP channel to use. */
id|sl
op_assign
op_amp
id|sl_ctrl
(braket
id|dev-&gt;base_addr
)braket
suffix:semicolon
id|tty
op_assign
id|sl-&gt;tty
suffix:semicolon
multiline_comment|/* PRINTK ((&quot;SLIP: sl_start_xmit(&bslash;&quot;%s&bslash;&quot;) skb=0x%X busy=%d&bslash;n&quot;,&n;&t;&t;&t;&t;&t;dev-&gt;name, skb, sl-&gt;sending)); */
multiline_comment|/*&n;&t; * If we are busy already- too bad.  We ought to be able&n;&t; * to queue things at this point, to allow for a little&n;&t; * frame buffer.  Oh well...&n;&t; */
r_if
c_cond
(paren
id|sl-&gt;sending
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;SLIP: sl_start_xmit: BUSY&bslash;r&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* We were not, so we are now... :-) */
id|sti
c_func
(paren
)paren
suffix:semicolon
id|sl_lock
c_func
(paren
id|sl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* PRINTK ((&quot;SLIP: sl_start_xmit: encaps(0x%X, %d)&bslash;r&bslash;n&quot;,&n;&t;&t;&t;&t;&t;(unsigned) skb, skb-&gt;len));&t;*/
id|sl_send
c_func
(paren
id|sl
comma
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
comma
id|skb-&gt;len
)paren
suffix:semicolon
)brace
multiline_comment|/* PRINTK ((&quot;SLIP: sl_start_xmit: kicking TTY!&bslash;n&quot;)); */
id|tty_flush
c_func
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/* kick TTY in the butt */
id|sl_unlock
c_func
(paren
id|sl
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the frame type ID.  Shouldn&squot;t we pick this up from the&n; * frame on which we have to operate, like in &squot;eth&squot; ? - FvK&n; */
r_static
r_int
r_int
DECL|function|sl_type_trans
id|sl_type_trans
(paren
r_void
multiline_comment|/*struct sk_buff*/
op_star
id|skb
comma
r_void
multiline_comment|/*struct device*/
op_star
id|dev
)paren
(brace
macro_line|#ifdef notdef
r_struct
id|slip
op_star
id|sl
suffix:semicolon
id|sl
op_assign
id|sl_ctrl
(braket
id|dev-&gt;base_addr
)braket
suffix:semicolon
r_return
id|sl-&gt;type
suffix:semicolon
macro_line|#else
r_return
id|NET16
c_func
(paren
id|ETHERTYPE_IP
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Open the low-level part of the SLIP channel. Easy! */
r_static
r_int
DECL|function|sl_open
id|sl_open
c_func
(paren
r_void
multiline_comment|/*struct device*/
op_star
id|dev
)paren
(brace
r_struct
id|slip
op_star
id|sl
suffix:semicolon
macro_line|#if 0
id|sl
op_assign
op_amp
id|sl_ctrl
(braket
id|dev-&gt;base_addr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|sl-&gt;tty
op_eq
l_int|NULL
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;SLIP: channel sl%d not connected!&bslash;n&quot;
comma
id|sl-&gt;line
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|sl-&gt;escape
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* SLIP state machine&t;&t;*/
id|sl-&gt;received
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* SLIP receiver count&t;&t;*/
id|PRINTK
(paren
(paren
l_string|&quot;SLIP: channel sl%d opened.&bslash;n&quot;
comma
id|sl-&gt;line
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Close the low-level part of the SLIP channel. Easy! */
r_static
r_int
DECL|function|sl_close
id|sl_close
c_func
(paren
r_void
multiline_comment|/*struct device*/
op_star
id|dev
)paren
(brace
r_struct
id|slip
op_star
id|sl
suffix:semicolon
macro_line|#if 0
id|sl
op_assign
op_amp
id|sl_ctrl
(braket
id|dev-&gt;base_addr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|sl-&gt;tty
op_eq
l_int|NULL
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;SLIP: channel sl%d not connected!&bslash;n&quot;
comma
id|sl-&gt;line
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|sl_free
c_func
(paren
id|sl
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The next two lines should be handled by a &quot;dev_down()&quot;&n;&t; * function, which takes care of shutting down an inter-&n;&t; * face.  It would also be called by the &quot;ip&quot; module when&n;&t; * an interface is brought down manually.&n;&t; */
id|del_devroute
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;up
op_assign
l_int|0
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;SLIP: channel sl%d closed.&bslash;n&quot;
comma
id|sl-&gt;line
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle the &squot;receiver data ready&squot; interrupt.&n; * This function is called by the &squot;tty_io&squot; module in the kernel when&n; * a block of SLIP data has been received, which can now be decapsulated&n; * and sent on to some IP layer for further processing.&n; */
r_static
r_void
DECL|function|slip_recv
id|slip_recv
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
r_char
id|buff
(braket
id|SL_MTU
op_star
l_int|2
)braket
suffix:semicolon
r_register
r_int
r_char
op_star
id|p
suffix:semicolon
r_register
r_int
id|count
suffix:semicolon
r_struct
id|slip
op_star
id|sl
suffix:semicolon
r_int
r_char
id|c
suffix:semicolon
macro_line|#if 0
id|PRINTK
(paren
(paren
l_string|&quot;SLIP: slip_recv(%d) called&bslash;n&quot;
comma
id|tty-&gt;line
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sl
op_assign
id|sl_find
c_func
(paren
id|tty
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* not connected */
r_if
c_cond
(paren
id|SL_FULL
c_func
(paren
op_amp
id|sl-&gt;rcv_queue
)paren
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;SLIP: recv queue full&bslash;r&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|count
op_assign
id|tty_read_data
c_func
(paren
id|tty
comma
id|buff
comma
(paren
id|SL_MTU
op_star
l_int|2
)paren
)paren
)paren
OG
l_int|0
)paren
(brace
id|p
op_assign
id|buff
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
id|c
op_assign
op_star
id|p
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
id|ESC
suffix:colon
id|sl-&gt;escape
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ESC_ESC
suffix:colon
r_if
c_cond
(paren
id|sl-&gt;escape
)paren
id|c
op_assign
id|ESC
suffix:semicolon
id|put_sl_queue
c_func
(paren
op_amp
id|sl-&gt;rcv_queue
comma
id|c
)paren
suffix:semicolon
id|sl-&gt;escape
op_assign
l_int|0
suffix:semicolon
id|sl-&gt;received
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ESC_END
suffix:colon
r_if
c_cond
(paren
id|sl-&gt;escape
)paren
id|c
op_assign
id|END
suffix:semicolon
id|put_sl_queue
c_func
(paren
op_amp
id|sl-&gt;rcv_queue
comma
id|c
)paren
suffix:semicolon
id|sl-&gt;escape
op_assign
l_int|0
suffix:semicolon
id|sl-&gt;received
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|END
suffix:colon
id|sl-&gt;escape
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sl-&gt;received
OL
l_int|3
)paren
(brace
r_if
c_cond
(paren
id|sl-&gt;received
)paren
id|eat_sl_queue
c_func
(paren
op_amp
id|sl-&gt;rcv_queue
comma
id|sl-&gt;received
)paren
suffix:semicolon
id|sl-&gt;received
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|PRINTK
(paren
(paren
l_string|&quot;SLIP: full frame received!&bslash;r&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sl_recv
c_func
(paren
id|sl
comma
id|sl-&gt;received
)paren
suffix:semicolon
id|sl-&gt;received
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|put_sl_queue
c_func
(paren
op_amp
id|sl-&gt;rcv_queue
comma
id|c
)paren
suffix:semicolon
id|sl-&gt;escape
op_assign
l_int|0
suffix:semicolon
id|sl-&gt;received
op_increment
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
)brace
multiline_comment|/* Return the channel number of a SLIP connection. */
r_static
r_int
DECL|function|slip_chan
id|slip_chan
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|slip
op_star
id|sl
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sl
op_assign
id|sl_find
c_func
(paren
id|tty
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* not connected */
r_return
id|sl-&gt;line
suffix:semicolon
)brace
multiline_comment|/*&n; * Open the high-level part of the SLIP channel.  &n; * This function is called by the TTY module when the&n; * SLIP line discipline is called for.  Because we are&n; * sure the tty line exists, we only have to link it to&n; * a free SLIP channel...&n; */
r_static
r_int
DECL|function|slip_open
id|slip_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|slip
op_star
id|sl
suffix:semicolon
multiline_comment|/* First make sure we&squot;re not already connected. */
r_if
c_cond
(paren
(paren
id|sl
op_assign
id|sl_find
c_func
(paren
id|tty
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;SLIP: TTY %d already connected to sl%d !&bslash;n&quot;
comma
id|tty-&gt;line
comma
id|sl-&gt;line
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
multiline_comment|/* OK.  Find a free SLIP channel to use. */
r_if
c_cond
(paren
(paren
id|sl
op_assign
id|sl_alloc
c_func
(paren
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;SLIP: TTY %d not connected: all channels in use!&bslash;n&quot;
comma
id|tty-&gt;line
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENFILE
suffix:semicolon
)brace
id|sl-&gt;tty
op_assign
id|tty
suffix:semicolon
multiline_comment|/* Link the TTY line to this channel. */
(paren
r_void
)paren
id|sl_open
c_func
(paren
id|sl-&gt;dev
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;SLIP: TTY %d connected to sl%d.&bslash;n&quot;
comma
id|tty-&gt;line
comma
id|sl-&gt;line
)paren
)paren
suffix:semicolon
multiline_comment|/* Done.  We have linked the TTY line to a channel. */
r_return
id|sl-&gt;line
suffix:semicolon
)brace
multiline_comment|/*&n; * Close down a SLIP channel.&n; * This means flushing out any pending queues, and then restoring the&n; * TTY line discipline to what it was before it got hooked to SLIP&n; * (which usually is TTY again).&n; */
r_static
r_void
DECL|function|slip_close
id|slip_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|slip
op_star
id|sl
suffix:semicolon
multiline_comment|/* First make sure we&squot;re connected. */
r_if
c_cond
(paren
(paren
id|sl
op_assign
id|sl_find
c_func
(paren
id|tty
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;SLIP: TTY %d not connected !&bslash;n&quot;
comma
id|tty-&gt;line
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
(paren
r_void
)paren
id|sl_close
c_func
(paren
id|sl-&gt;dev
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;SLIP: TTY %d disconnected from sl%d.&bslash;n&quot;
comma
id|tty-&gt;line
comma
id|sl-&gt;line
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize the SLIP driver.  Called by DDI. */
r_int
DECL|function|slip_init
id|slip_init
c_func
(paren
r_struct
id|ddi
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|slip
op_star
id|sl
suffix:semicolon
macro_line|#if 1
id|PRINTK
c_func
(paren
(paren
l_string|&quot;SLIP/DDI: version %s (%d channels, buffer=0x%X:%d)&bslash;n&quot;
comma
id|ddi-&gt;ioaddr
comma
id|ddi-&gt;memaddr
comma
id|ddi-&gt;memsize
)paren
)paren
suffix:semicolon
macro_line|#else
id|sl
op_assign
op_amp
id|sl_ctrl
(braket
id|dev-&gt;base_addr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|already
op_increment
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SLIP: version %s (%d channels): &quot;
comma
id|SLIP_VERSION
comma
id|SL_NRUNIT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|tty_set_ldisc
c_func
(paren
id|N_SLIP
comma
id|slip_open
comma
id|slip_close
comma
id|slip_chan
comma
id|slip_recv
)paren
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;OK&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;ERROR: %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* Set up the &quot;SLIP Control Block&quot;. */
id|sl-&gt;inuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not allocated now&t;*/
id|sl-&gt;line
op_assign
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/* SLIP channel number&t;*/
id|sl-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* pointer to TTY line&t;*/
id|sl-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* pointer to DEVICE&t;*/
id|sl-&gt;sending
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* locked on output&t;*/
id|sl-&gt;rcv_queue.head
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ptr to RECV queue&t;*/
id|sl-&gt;rcv_queue.tail
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ptr to RECV queue&t;*/
id|sl-&gt;escape
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* SLIP state machine&t;*/
id|sl-&gt;received
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* SLIP receiver count&t;*/
id|sl-&gt;sent
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* #frames sent out&t;*/
id|sl-&gt;rcvd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* #frames received&t;*/
id|sl-&gt;errors
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not used at present&t;*/
multiline_comment|/* Finish setting up the DEVICE info. */
id|dev-&gt;mtu
op_assign
id|SL_MTU
suffix:semicolon
id|dev-&gt;rmem_end
op_assign
(paren
r_int
r_int
)paren
op_amp
id|sl-&gt;rcv_queue.buf
(braket
id|SL_BUF_SIZE
op_minus
l_int|1
)braket
suffix:semicolon
id|dev-&gt;rmem_start
op_assign
(paren
r_int
r_int
)paren
op_amp
id|sl-&gt;rcv_queue.buf
(braket
l_int|0
)braket
suffix:semicolon
id|dev-&gt;mem_end
op_assign
(paren
r_int
r_int
)paren
op_amp
id|sl-&gt;xbuff
(braket
(paren
id|SL_MTU
op_star
l_int|2
)paren
op_minus
l_int|1
)braket
suffix:semicolon
id|dev-&gt;mem_start
op_assign
(paren
r_int
r_int
)paren
op_amp
id|sl-&gt;xbuff
(braket
l_int|0
)braket
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|sl_start_xmit
suffix:semicolon
id|dev-&gt;open
op_assign
id|sl_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|sl_close
suffix:semicolon
id|dev-&gt;hard_header
op_assign
id|sl_hard_header
suffix:semicolon
id|dev-&gt;add_arp
op_assign
id|sl_add_arp
suffix:semicolon
id|dev-&gt;type_trans
op_assign
id|sl_type_trans
suffix:semicolon
id|dev-&gt;hard_header_len
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;addr_len
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;type
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FIXME: ??? */
id|dev-&gt;queue_xmit
op_assign
id|dev_queue_xmit
suffix:semicolon
id|dev-&gt;rebuild_header
op_assign
id|sl_rebuild_header
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_NUMBUFFS
suffix:semicolon
id|i
op_increment
)paren
id|dev-&gt;buffs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
eof
