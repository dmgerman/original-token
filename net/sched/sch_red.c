multiline_comment|/*&n; * net/sched/sch_red.c&t;Random Early Detection scheduler.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; * Authors:&t;Alexey Kuznetsov, &lt;kuznet@ms2.inr.ac.ru&gt;&n; */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/pkt_sched.h&gt;
multiline_comment|/*&t;Random Early Detection (RED) algorithm.&n;&t;=======================================&n;&n;&t;Source: Sally Floyd and Van Jacobson, &quot;Random Early Detection Gateways&n;&t;for Congestion Avoidance&quot;, 1993, IEEE/ACM Transactions on Networking.&n;&n;&t;This file codes a &quot;divisionless&quot; version of RED algorithm&n;&t;written down in Fig.17 of the paper.&n;&n;Short description.&n;------------------&n;&n;&t;When new packet arrives we calculate average queue length:&n;&n;&t;avg = (1-W)*avg + W*current_queue_len,&n;&n;&t;W is filter time constant (choosen as 2^(-Wlog)), controlling&n;&t;inertia of algorithm. To allow larger bursts, W should be&n;&t;decreased.&n;&n;&t;if (avg &gt; th_max) -&gt; packet marked (dropped).&n;&t;if (avg &lt; th_min) -&gt; packet passes.&n;&t;if (th_min &lt; avg &lt; th_max) we calculate probability:&n;&n;&t;Pb = max_P * (avg - th_min)/(th_max-th_min)&n;&n;&t;and mark (drop) packet with this probability.&n;&t;Pb changes from 0 (at avg==th_min) to max_P (avg==th_max).&n;&t;max_P should be small (not 1!).&n;&n;&t;NB.&t;SF&amp;VJ assumed that Pb[avg] is linear function. I think it&n;&t;        is wrong. I&squot;d make:&n;&t;&t;P[th_min] = 0, P[th_max] = 1;&n;&t;&t;dP/davg[th_min] = 0, dP/davg[th_max] = infinity, or a large number.&n;&n;&t;I choose max_P as a number between 0.01 and 0.1, so that&n;&t;C1 = max_P/(th_max-th_min) is power of two: C1 = 2^(-C1log)&n;&n;&t;Parameters, settable by user (with default values):&n;&n;&t;qmaxbytes=256K - hard limit on queue length, should be chosen &gt;qth_max&n;&t;                 to allow packet bursts. This parameter does not&n;&t;&t;&t; affect algorithm behaviour and can be chosen&n;&t;&t;&t; arbitrarily high (well, less than ram size)&n;&t;&t;&t; Really, this limit will never be achieved&n;&t;&t;&t; if RED works correctly.&n;&t;qth_min=32K&n;&t;qth_max=128K   - qth_max should be at least 2*qth_min&n;&t;Wlog=8&t;       - log(1/W).&n;&t;Alog=Wlog      - fixed point position in th_min and th_max.&n;&t;Rlog=10&n;&t;C1log=24       - C1log = trueC1log+Alog-Rlog&n;&t;                 so that trueC1log=22 and max_P~0.02&n;&t;&n;&n;NOTES:&n;&n;Upper bound on W.&n;-----------------&n;&n;&t;If you want to allow bursts of L packets of size S,&n;&t;you should choose W:&n;&n;&t;L + 1 -th_min/S &lt; (1-(1-W)^L)/W&n;&n;&t;For th_min/S = 32&n;&n;&t;log(W)&t;L&n;&t;-1&t;33&n;&t;-2&t;35&n;&t;-3&t;39&n;&t;-4&t;46&n;&t;-5&t;57&n;&t;-6&t;75&n;&t;-7&t;101&n;&t;-8&t;135&n;&t;-9&t;190&n;&t;etc.&n; */
DECL|struct|red_sched_data
r_struct
id|red_sched_data
(brace
multiline_comment|/* Parameters */
DECL|member|qmaxbytes
r_int
r_int
id|qmaxbytes
suffix:semicolon
multiline_comment|/* HARD maximal queue length&t;*/
DECL|member|qth_min
r_int
r_int
id|qth_min
suffix:semicolon
multiline_comment|/* Min average length threshold: A scaled */
DECL|member|qth_max
r_int
r_int
id|qth_max
suffix:semicolon
multiline_comment|/* Max average length threshold: A scaled */
DECL|member|Alog
r_char
id|Alog
suffix:semicolon
multiline_comment|/* Point position in average lengths */
DECL|member|Wlog
r_char
id|Wlog
suffix:semicolon
multiline_comment|/* log(W)&t;&t;*/
DECL|member|Rlog
r_char
id|Rlog
suffix:semicolon
multiline_comment|/* random number bits&t;*/
DECL|member|C1log
r_char
id|C1log
suffix:semicolon
multiline_comment|/* log(1/C1)&t;&t;*/
DECL|member|Slog
r_char
id|Slog
suffix:semicolon
DECL|member|Stab
r_char
id|Stab
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/* Variables */
DECL|member|qbytes
r_int
r_int
id|qbytes
suffix:semicolon
multiline_comment|/* Queue length in bytes&t;*/
DECL|member|qave
r_int
r_int
id|qave
suffix:semicolon
multiline_comment|/* Average queue length: A scaled */
DECL|member|qcount
r_int
id|qcount
suffix:semicolon
multiline_comment|/* Packets since last random number generation */
DECL|member|qR
r_int
id|qR
suffix:semicolon
multiline_comment|/* Cached random number [0..1&lt;Rlog) */
DECL|member|qidlestart
id|psched_time_t
id|qidlestart
suffix:semicolon
multiline_comment|/* Start of idle period&t;&t;*/
)brace
suffix:semicolon
multiline_comment|/* Stolen from igmp.c. */
DECL|function|red_random
r_static
id|__inline__
r_int
id|red_random
c_func
(paren
r_int
id|log
)paren
(brace
r_static
r_int
r_int
id|seed
op_assign
l_int|152L
suffix:semicolon
id|seed
op_assign
id|seed
op_star
l_int|69069L
op_plus
l_int|1
suffix:semicolon
r_return
(paren
id|seed
op_xor
id|jiffies
)paren
op_amp
(paren
(paren
l_int|1
op_lshift
id|log
)paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|red_enqueue
id|red_enqueue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|red_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|red_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
id|psched_time_t
id|now
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PSCHED_IS_PASTPERFECT
c_func
(paren
id|q-&gt;qidlestart
)paren
)paren
(brace
r_int
id|us_idle
suffix:semicolon
id|PSCHED_SET_PASTPERFECT
c_func
(paren
id|q-&gt;qidlestart
)paren
suffix:semicolon
id|PSCHED_GET_TIME
c_func
(paren
id|now
)paren
suffix:semicolon
id|us_idle
op_assign
id|PSCHED_TDIFF_SAFE
c_func
(paren
id|now
comma
id|q-&gt;qidlestart
comma
(paren
l_int|256
op_lshift
id|q-&gt;Slog
)paren
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* It is wrong, but I do not think that SF+VJ proposal is reasonable&n;   and did not invented anything more clever 8)&n;&n;   The problem: ideally, average length queue recalcultion should&n;   be done over constant clock intervals. It is too expensive, so that&n;   calculation is driven by outgoing packets.&n;   When queue is idle we have to model this clock by hands.&n;&n;   SF+VJ proposed to &quot;generate&quot; m = (idletime/bandwidth)*average_pkt_size&n;   dummy packets as burst after idle time, i.e.&n;&n;          q-&gt;qave *= (1-W)^m&n;&n;   It is apparently overcomplicated solution (f.e. we have to precompute&n;   a table to make this calculation for reasonable time)&n;   I believe, that a simpler model may be used here,&n;   but it is field for experiments.&n;*/
id|q-&gt;qave
op_rshift_assign
id|q-&gt;Stab
(braket
(paren
id|us_idle
op_rshift
id|q-&gt;Slog
)paren
op_amp
l_int|0xFF
)braket
suffix:semicolon
)brace
id|q-&gt;qave
op_add_assign
(paren
(paren
id|q-&gt;qbytes
op_lshift
id|q-&gt;Alog
)paren
op_minus
id|q-&gt;qave
)paren
op_rshift
id|q-&gt;Wlog
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;qave
OL
id|q-&gt;qth_min
)paren
(brace
id|enqueue
suffix:colon
id|q-&gt;qcount
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;qbytes
op_le
id|q-&gt;qmaxbytes
)paren
(brace
id|skb_queue_tail
c_func
(paren
op_amp
id|sch-&gt;q
comma
id|skb
)paren
suffix:semicolon
id|q-&gt;qbytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|drop
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|q-&gt;qave
op_ge
id|q-&gt;qth_max
)paren
(brace
id|q-&gt;qcount
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|drop
suffix:semicolon
)brace
id|q-&gt;qcount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;qcount
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
(paren
id|q-&gt;qave
op_minus
id|q-&gt;qth_min
)paren
op_star
id|q-&gt;qcount
)paren
op_rshift
id|q-&gt;C1log
)paren
OL
id|q-&gt;qR
)paren
r_goto
id|enqueue
suffix:semicolon
id|q-&gt;qcount
op_assign
l_int|0
suffix:semicolon
id|q-&gt;qR
op_assign
id|red_random
c_func
(paren
id|q-&gt;Rlog
)paren
suffix:semicolon
r_goto
id|drop
suffix:semicolon
)brace
id|q-&gt;qR
op_assign
id|red_random
c_func
(paren
id|q-&gt;Rlog
)paren
suffix:semicolon
r_goto
id|enqueue
suffix:semicolon
)brace
r_static
r_struct
id|sk_buff
op_star
DECL|function|red_dequeue
id|red_dequeue
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|red_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|red_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sch-&gt;q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
id|q-&gt;qbytes
op_sub_assign
id|skb-&gt;len
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
id|PSCHED_GET_TIME
c_func
(paren
id|q-&gt;qidlestart
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_void
DECL|function|red_reset
id|red_reset
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|red_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|red_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sch-&gt;q
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|q-&gt;qbytes
op_sub_assign
id|skb-&gt;len
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|q-&gt;qbytes
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;red_reset: qbytes=%lu&bslash;n&quot;
comma
id|q-&gt;qbytes
)paren
suffix:semicolon
id|q-&gt;qbytes
op_assign
l_int|0
suffix:semicolon
)brace
id|PSCHED_SET_PASTPERFECT
c_func
(paren
id|q-&gt;qidlestart
)paren
suffix:semicolon
id|q-&gt;qave
op_assign
l_int|0
suffix:semicolon
id|q-&gt;qcount
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|red_init
r_static
r_int
id|red_init
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|pschedctl
op_star
id|pctl
)paren
(brace
r_struct
id|red_sched_data
op_star
id|q
suffix:semicolon
r_struct
id|redctl
op_star
id|ctl
op_assign
(paren
r_struct
id|redctl
op_star
)paren
id|pctl-&gt;args
suffix:semicolon
id|q
op_assign
(paren
r_struct
id|red_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|pctl-&gt;arglen
OL
r_sizeof
(paren
r_struct
id|redctl
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|q-&gt;Wlog
op_assign
id|ctl-&gt;Wlog
suffix:semicolon
id|q-&gt;Alog
op_assign
id|ctl-&gt;Alog
suffix:semicolon
id|q-&gt;Rlog
op_assign
id|ctl-&gt;Rlog
suffix:semicolon
id|q-&gt;C1log
op_assign
id|ctl-&gt;C1log
suffix:semicolon
id|q-&gt;Slog
op_assign
id|ctl-&gt;Slog
suffix:semicolon
id|q-&gt;qth_min
op_assign
id|ctl-&gt;qth_min
suffix:semicolon
id|q-&gt;qth_max
op_assign
id|ctl-&gt;qth_max
suffix:semicolon
id|q-&gt;qmaxbytes
op_assign
id|ctl-&gt;qmaxbytes
suffix:semicolon
id|memcpy
c_func
(paren
id|q-&gt;Stab
comma
id|ctl-&gt;Stab
comma
l_int|256
)paren
suffix:semicolon
id|q-&gt;qcount
op_assign
op_minus
l_int|1
suffix:semicolon
id|PSCHED_SET_PASTPERFECT
c_func
(paren
id|q-&gt;qidlestart
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|red_ops
r_struct
id|Qdisc_ops
id|red_ops
op_assign
(brace
l_int|NULL
comma
l_string|&quot;red&quot;
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|red_sched_data
)paren
comma
id|red_enqueue
comma
id|red_dequeue
comma
id|red_reset
comma
l_int|NULL
comma
id|red_init
comma
l_int|NULL
)brace
suffix:semicolon
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
multiline_comment|/* Load once and never free it. */
id|MOD_INC_USE_COUNT
suffix:semicolon
id|err
op_assign
id|register_qdisc
c_func
(paren
op_amp
id|red_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
)brace
macro_line|#endif
eof
