multiline_comment|/*&n; * net/sched/sch_csz.c&t;Clark-Shenker-Zhang scheduler.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; * Authors:&t;Alexey Kuznetsov, &lt;kuznet@ms2.inr.ac.ru&gt;&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/pkt_sched.h&gt;
multiline_comment|/*&t;Clark-Shenker-Zhang algorithm.&n;&t;=======================================&n;&n;&t;SOURCE.&n;&n;&t;David D. Clark, Scott Shenker and Lixia Zhang&n;&t;&quot;Supporting Real-Time Applications in an Integrated Services Packet&n;&t;Network: Architecture and Mechanism&quot;.&n;&n;&t;CBQ presents a flexible universal algorithm for packet scheduling,&n;&t;but it has pretty poor delay characteristics.&n;&t;Round-robin scheduling and link-sharing goals&n;&t;apparently contradict minimization of network delay and jitter.&n;&t;Moreover, correct handling of predictive flows seems to be&n;&t;impossible in CBQ.&n;&n;&t;CSZ presents a more precise but less flexible and less efficient&n;&t;approach. As I understand it, the main idea is to create&n;&t;WFQ flows for each guaranteed service and to allocate&n;&t;the rest of bandwith to dummy flow-0. Flow-0 comprises&n;&t;the predictive services and the best effort traffic;&n;&t;it is handled by a priority scheduler with the highest&n;&t;priority band allocated&t;for predictive services, and the rest ---&n;&t;to the best effort packets.&n;&n;&t;Note that in CSZ flows are NOT limited to their bandwidth.  It&n;&t;is supposed that the flow passed admission control at the edge&n;&t;of the QoS network and it doesn&squot;t need further shaping. Any&n;&t;attempt to improve the flow or to shape it to a token bucket&n;&t;at intermediate hops will introduce undesired delays and raise&n;&t;jitter.&n;&n;&t;At the moment CSZ is the only scheduler that provides&n;&t;true guaranteed service. Another schemes (including CBQ)&n;&t;do not provide guaranteed delay and randomize jitter.&n;&t;There is a proof (Sally Floyd), that delay&n;&t;can be estimated by a IntServ compliant formula.&n;&t;This result is true formally, but it is wrong in principle.&n;&t;It takes into account only round-robin delays,&n;&t;ignoring delays introduced by link sharing i.e. overlimiting.&n;&t;Note that temporary overlimits are inevitable because&n;&t;real links are not ideal, and the real algorithm must take this&n;&t;into account.&n;&n;        ALGORITHM.&n;&n;&t;--- Notations.&n;&n;&t;$B$ is link bandwidth (bits/sec).&n;&n;&t;$I$ is set of all flows, including flow $0$.&n;&t;Every flow $a &bslash;in I$ has associated bandwidth slice $r_a &lt; 1$ and&n;&t;$&bslash;sum_{a &bslash;in I} r_a = 1$.&n;&n;&t;--- Flow model.&n;&n;&t;Let $m_a$ is the number of backlogged bits in flow $a$.&n;&t;The flow is {&bslash;em active}, if $m_a &gt; 0$.&n;&t;This number is a discontinuous function of time;&n;&t;when a packet $i$ arrives:&n;&t;&bslash;[&n;&t;m_a(t_i+0) - m_a(t_i-0) = L^i,&n;&t;&bslash;]&n;&t;where $L^i$ is the length of the arrived packet.&n;&t;The flow queue is drained continuously until $m_a == 0$:&n;&t;&bslash;[&n;&t;{d m_a &bslash;over dt} = - { B r_a &bslash;over &bslash;sum_{b &bslash;in A} r_b}.&n;&t;&bslash;]&n;&t;I.e. flow rates are their allocated rates proportionally&n;&t;scaled to take all available link bandwidth. Apparently,&n;&t;it is not the only possible policy. F.e. CBQ classes&n;&t;without borrowing would be modelled by:&n;&t;&bslash;[&n;&t;{d m_a &bslash;over dt} = - B r_a .&n;&t;&bslash;]&n;&t;More complicated hierarchical bandwidth allocation&n;&t;policies are possible, but unfortunately, the basic&n;&t;flow equations have a simple solution only for proportional&n;&t;scaling.&n;&n;&t;--- Departure times.&n;&n;&t;We calculate the time until the last bit of packet is sent:&n;&t;&bslash;[&n;&t;E_a^i(t) = { m_a(t_i) - &bslash;delta_a(t) &bslash;over r_a },&n;&t;&bslash;]&n;&t;where $&bslash;delta_a(t)$ is number of bits drained since $t_i$.&n;&t;We have to evaluate $E_a^i$ for all queued packets,&n;&t;then find the packet with minimal $E_a^i$ and send it.&n;&n;&t;This sounds good, but direct implementation of the algorithm&n;&t;is absolutely infeasible. Luckily, if flow rates&n;&t;are scaled proportionally, the equations have a simple solution.&n;&t;&n;&t;The differential equation for $E_a^i$ is&n;&t;&bslash;[&n;&t;{d E_a^i (t) &bslash;over dt } = - { d &bslash;delta_a(t) &bslash;over dt} { 1 &bslash;over r_a} =&n;&t;{ B &bslash;over &bslash;sum_{b &bslash;in A} r_b}&n;&t;&bslash;]&n;&t;with initial condition&n;&t;&bslash;[&n;&t;E_a^i (t_i) = { m_a(t_i) &bslash;over r_a } .&n;&t;&bslash;]&n;&n;&t;Let&squot;s introduce an auxiliary function $R(t)$:&n;&n;&t;--- Round number.&n;&n;&t;Consider the following model: we rotate over active flows,&n;&t;sending $r_a B$ bits from every flow, so that we send&n;&t;$B &bslash;sum_{a &bslash;in A} r_a$ bits per round, that takes&n;&t;$&bslash;sum_{a &bslash;in A} r_a$ seconds.&n;&t;&n;&t;Hence, $R(t)$ (round number) is a monotonically increasing&n;&t;linear function&t;of time when $A$ is not changed&n;&t;&bslash;[&n;&t;{ d R(t) &bslash;over dt } = { 1 &bslash;over &bslash;sum_{a &bslash;in A} r_a }&n;&t;&bslash;]&n;&t;and it is continuous when $A$ changes.&n;&n;&t;The central observation is that the quantity&n;&t;$F_a^i = R(t) + E_a^i(t)/B$ does not depend on time at all!&n;&t;$R(t)$ does not depend on flow, so that $F_a^i$ can be&n;&t;calculated only once on packet arrival, and we need not&n;&t;recalculate $E$ numbers and resorting queues.&n;&t;The number $F_a^i$ is called finish number of the packet.&n;&t;It is just the value of $R(t)$ when the last bit of packet&n;&t;is sent out.&n;&n;&t;Maximal finish number on flow is called finish number of flow&n;&t;and minimal one is &quot;start number of flow&quot;.&n;&t;Apparently, flow is active if and only if $F_a &bslash;leq R$.&n;&n;&t;When a packet of length $L_i$ bit arrives to flow $a$ at time $t_i$,&n;&t;we calculate $F_a^i$ as:&n;&n;&t;If flow was inactive ($F_a &lt; R$):&n;&t;$F_a^i = R(t) + {L_i &bslash;over B r_a}$&n;&t;otherwise&n;&t;$F_a^i = F_a + {L_i &bslash;over B r_a}$&n;&n;&t;These equations complete the algorithm specification.&n;&n;&t;It looks pretty hairy, but there is a simple&n;&t;procedure for solving these equations.&n;&t;See procedure csz_update(), that is a generalization of&n;&t;the algorithm from S. Keshav&squot;s thesis Chapter 3&n;&t;&quot;Efficient Implementation of Fair Queeing&quot;.&n;&n;&t;NOTES.&n;&n;&t;* We implement only the simplest variant of CSZ,&n;&t;when flow-0 is a explicit 4band priority fifo.&n;&t;This is bad, but we need a &quot;peek&quot; operation in addition&n;&t;to &quot;dequeue&quot; to implement complete CSZ.&n;&t;I do not want to do that, unless it is absolutely&n;&t;necessary.&n;&t;&n;&t;* A primitive support for token bucket filtering&n;&t;presents itself too. It directly contradicts CSZ, but&n;&t;even though the Internet is on the globe ... :-)&n;&t;&quot;the edges of the network&quot; really exist.&n;&t;&n;&t;BUGS.&n;&n;&t;* Fixed point arithmetic is overcomplicated, suboptimal and even&n;&t;wrong. Check it later.  */
multiline_comment|/* This number is arbitrary */
DECL|macro|CSZ_GUARANTEED
mdefine_line|#define CSZ_GUARANTEED&t;&t;16
DECL|macro|CSZ_FLOWS
mdefine_line|#define CSZ_FLOWS&t;&t;(CSZ_GUARANTEED+4)
DECL|struct|csz_head
r_struct
id|csz_head
(brace
DECL|member|snext
r_struct
id|csz_head
op_star
id|snext
suffix:semicolon
DECL|member|sprev
r_struct
id|csz_head
op_star
id|sprev
suffix:semicolon
DECL|member|fnext
r_struct
id|csz_head
op_star
id|fnext
suffix:semicolon
DECL|member|fprev
r_struct
id|csz_head
op_star
id|fprev
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|csz_flow
r_struct
id|csz_flow
(brace
DECL|member|snext
r_struct
id|csz_head
op_star
id|snext
suffix:semicolon
DECL|member|sprev
r_struct
id|csz_head
op_star
id|sprev
suffix:semicolon
DECL|member|fnext
r_struct
id|csz_head
op_star
id|fnext
suffix:semicolon
DECL|member|fprev
r_struct
id|csz_head
op_star
id|fprev
suffix:semicolon
multiline_comment|/* Parameters */
DECL|member|rate
r_struct
id|tc_ratespec
id|rate
suffix:semicolon
DECL|member|slice
r_struct
id|tc_ratespec
id|slice
suffix:semicolon
DECL|member|L_tab
id|u32
op_star
id|L_tab
suffix:semicolon
multiline_comment|/* Lookup table for L/(B*r_a) values */
DECL|member|limit
r_int
r_int
id|limit
suffix:semicolon
multiline_comment|/* Maximal length of queue */
macro_line|#ifdef CSZ_PLUS_TBF
DECL|member|peakrate
r_struct
id|tc_ratespec
id|peakrate
suffix:semicolon
DECL|member|buffer
id|__u32
id|buffer
suffix:semicolon
multiline_comment|/* Depth of token bucket, normalized&n;&t;&t;&t;&t;&t;   as L/(B*r_a) */
DECL|member|mtu
id|__u32
id|mtu
suffix:semicolon
macro_line|#endif
multiline_comment|/* Variables */
macro_line|#ifdef CSZ_PLUS_TBF
DECL|member|tokens
r_int
r_int
id|tokens
suffix:semicolon
multiline_comment|/* Tokens number: usecs */
DECL|member|t_tbf
id|psched_time_t
id|t_tbf
suffix:semicolon
DECL|member|R_tbf
r_int
r_int
id|R_tbf
suffix:semicolon
DECL|member|throttled
r_int
id|throttled
suffix:semicolon
macro_line|#endif
DECL|member|peeked
r_int
id|peeked
suffix:semicolon
DECL|member|start
r_int
r_int
id|start
suffix:semicolon
multiline_comment|/* Finish number of the first skb */
DECL|member|finish
r_int
r_int
id|finish
suffix:semicolon
multiline_comment|/* Finish number of the flow */
DECL|member|q
r_struct
id|sk_buff_head
id|q
suffix:semicolon
multiline_comment|/* FIFO queue */
)brace
suffix:semicolon
DECL|macro|L2R
mdefine_line|#define L2R(f,L) ((f)-&gt;L_tab[(L)&gt;&gt;(f)-&gt;slice.cell_log])
DECL|struct|csz_sched_data
r_struct
id|csz_sched_data
(brace
multiline_comment|/* Parameters */
DECL|member|rate_log
r_int
r_char
id|rate_log
suffix:semicolon
multiline_comment|/* fixed point position for rate;&n;&t;&t;&t;&t;&t; * really we need not it */
DECL|member|R_log
r_int
r_char
id|R_log
suffix:semicolon
multiline_comment|/* fixed point position for round number */
DECL|member|delta_log
r_int
r_char
id|delta_log
suffix:semicolon
multiline_comment|/* 1&lt;&lt;delta_log is maximal timeout in usecs;&n;&t;&t;&t;&t;&t; * 21 &lt;-&gt; 2.1sec is MAXIMAL value */
multiline_comment|/* Variables */
DECL|member|filter_list
r_struct
id|tcf_proto
op_star
id|filter_list
suffix:semicolon
DECL|member|prio2band
id|u8
id|prio2band
(braket
id|TC_PRIO_MAX
op_plus
l_int|1
)braket
suffix:semicolon
macro_line|#ifdef CSZ_PLUS_TBF
DECL|member|wd_timer
r_struct
id|timer_list
id|wd_timer
suffix:semicolon
DECL|member|wd_expires
r_int
id|wd_expires
suffix:semicolon
macro_line|#endif
DECL|member|t_c
id|psched_time_t
id|t_c
suffix:semicolon
multiline_comment|/* Time check-point */
DECL|member|R_c
r_int
r_int
id|R_c
suffix:semicolon
multiline_comment|/* R-number check-point&t;*/
DECL|member|rate
r_int
r_int
id|rate
suffix:semicolon
multiline_comment|/* Current sum of rates of active flows */
DECL|member|s
r_struct
id|csz_head
id|s
suffix:semicolon
multiline_comment|/* Flows sorted by &quot;start&quot; */
DECL|member|f
r_struct
id|csz_head
id|f
suffix:semicolon
multiline_comment|/* Flows sorted by &quot;finish&quot;&t;*/
DECL|member|other
r_struct
id|sk_buff_head
id|other
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Predicted (0) and the best efforts&n;&t;&t;&t;&t;&t;    classes (1,2,3) */
DECL|member|flow
r_struct
id|csz_flow
id|flow
(braket
id|CSZ_GUARANTEED
)braket
suffix:semicolon
multiline_comment|/* Array of flows */
)brace
suffix:semicolon
multiline_comment|/* These routines (csz_insert_finish and csz_insert_start) are&n;   the most time consuming part of all the algorithm.&n;&n;   We insert to sorted list, so that time&n;   is linear with respect to number of active flows in the worst case.&n;   Note that we have not very large number of guaranteed flows,&n;   so that logarithmic algorithms (heap etc.) are useless,&n;   they are slower than linear one when length of list &lt;= 32.&n;&n;   Heap would take sence if we used WFQ for best efforts&n;   flows, but SFQ is better choice in this case.&n; */
multiline_comment|/* Insert flow &quot;this&quot; to the list &quot;b&quot; before&n;   flow with greater finish number.&n; */
macro_line|#if 0
multiline_comment|/* Scan forward */
r_extern
id|__inline__
r_void
id|csz_insert_finish
c_func
(paren
r_struct
id|csz_head
op_star
id|b
comma
r_struct
id|csz_flow
op_star
id|this
)paren
(brace
r_struct
id|csz_head
op_star
id|f
op_assign
id|b-&gt;fnext
suffix:semicolon
r_int
r_int
id|finish
op_assign
id|this-&gt;finish
suffix:semicolon
r_while
c_loop
(paren
id|f
op_ne
id|b
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_struct
id|csz_flow
op_star
)paren
id|f
)paren
op_member_access_from_pointer
id|finish
op_minus
id|finish
OG
l_int|0
)paren
r_break
suffix:semicolon
id|f
op_assign
id|f-&gt;fnext
suffix:semicolon
)brace
id|this-&gt;fnext
op_assign
id|f
suffix:semicolon
id|this-&gt;fprev
op_assign
id|f-&gt;fprev
suffix:semicolon
id|this-&gt;fnext-&gt;fprev
op_assign
id|this-&gt;fprev-&gt;fnext
op_assign
(paren
r_struct
id|csz_head
op_star
)paren
id|this
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/* Scan backward */
DECL|function|csz_insert_finish
r_extern
id|__inline__
r_void
id|csz_insert_finish
c_func
(paren
r_struct
id|csz_head
op_star
id|b
comma
r_struct
id|csz_flow
op_star
id|this
)paren
(brace
r_struct
id|csz_head
op_star
id|f
op_assign
id|b-&gt;fprev
suffix:semicolon
r_int
r_int
id|finish
op_assign
id|this-&gt;finish
suffix:semicolon
r_while
c_loop
(paren
id|f
op_ne
id|b
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_struct
id|csz_flow
op_star
)paren
id|f
)paren
op_member_access_from_pointer
id|finish
op_minus
id|finish
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|f
op_assign
id|f-&gt;fprev
suffix:semicolon
)brace
id|this-&gt;fnext
op_assign
id|f-&gt;fnext
suffix:semicolon
id|this-&gt;fprev
op_assign
id|f
suffix:semicolon
id|this-&gt;fnext-&gt;fprev
op_assign
id|this-&gt;fprev-&gt;fnext
op_assign
(paren
r_struct
id|csz_head
op_star
)paren
id|this
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Insert flow &quot;this&quot; to the list &quot;b&quot; before&n;   flow with greater start number.&n; */
DECL|function|csz_insert_start
r_extern
id|__inline__
r_void
id|csz_insert_start
c_func
(paren
r_struct
id|csz_head
op_star
id|b
comma
r_struct
id|csz_flow
op_star
id|this
)paren
(brace
r_struct
id|csz_head
op_star
id|f
op_assign
id|b-&gt;snext
suffix:semicolon
r_int
r_int
id|start
op_assign
id|this-&gt;start
suffix:semicolon
r_while
c_loop
(paren
id|f
op_ne
id|b
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_struct
id|csz_flow
op_star
)paren
id|f
)paren
op_member_access_from_pointer
id|start
op_minus
id|start
OG
l_int|0
)paren
r_break
suffix:semicolon
id|f
op_assign
id|f-&gt;snext
suffix:semicolon
)brace
id|this-&gt;snext
op_assign
id|f
suffix:semicolon
id|this-&gt;sprev
op_assign
id|f-&gt;sprev
suffix:semicolon
id|this-&gt;snext-&gt;sprev
op_assign
id|this-&gt;sprev-&gt;snext
op_assign
(paren
r_struct
id|csz_head
op_star
)paren
id|this
suffix:semicolon
)brace
multiline_comment|/* Calculate and return current round number.&n;   It is another time consuming part, but&n;   it is impossible to avoid it.&n;&n;   It costs O(N) that make all the algorithm useful only&n;   to play with closest to ideal fluid model.&n;&n;   There exist less academic, but more practical modifications,&n;   which might have even better characteristics (WF2Q+, HPFQ, HFSC)&n; */
DECL|function|csz_update
r_static
r_int
r_int
id|csz_update
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|csz_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|csz_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|csz_flow
op_star
id|a
suffix:semicolon
r_int
r_int
id|F
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|psched_time_t
id|now
suffix:semicolon
r_int
r_int
id|delay
suffix:semicolon
r_int
r_int
id|R_c
suffix:semicolon
id|PSCHED_GET_TIME
c_func
(paren
id|now
)paren
suffix:semicolon
id|delay
op_assign
id|PSCHED_TDIFF_SAFE
c_func
(paren
id|now
comma
id|q-&gt;t_c
comma
l_int|0
comma
r_goto
id|do_reset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delay
op_rshift
id|q-&gt;delta_log
)paren
(brace
id|do_reset
suffix:colon
multiline_comment|/* Delta is too large.&n;&t;&t;   It is possible if MTU/BW &gt; 1&lt;&lt;q-&gt;delta_log&n;&t;&t;   (i.e. configuration error) or because of hardware&n;&t;&t;   fault. We have no choice...&n;&t;&t; */
id|qdisc_reset
c_func
(paren
id|sch
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|q-&gt;t_c
op_assign
id|now
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|a
op_assign
(paren
r_struct
id|csz_flow
op_star
)paren
id|q-&gt;f.fnext
suffix:semicolon
multiline_comment|/* No more active flows. Reset R and exit. */
r_if
c_cond
(paren
id|a
op_eq
(paren
r_struct
id|csz_flow
op_star
)paren
op_amp
id|q-&gt;f
)paren
(brace
macro_line|#ifdef CSZ_DEBUG
r_if
c_cond
(paren
id|q-&gt;rate
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;csz_update: rate!=0 on inactive csz&bslash;n&quot;
)paren
suffix:semicolon
id|q-&gt;rate
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
id|q-&gt;R_c
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|F
op_assign
id|a-&gt;finish
suffix:semicolon
macro_line|#ifdef CSZ_DEBUG
r_if
c_cond
(paren
id|q-&gt;rate
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;csz_update: rate=0 on active csz&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|do_reset
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; *           tmp = (t - q-&gt;t_c)/q-&gt;rate;&n;&t;&t; */
id|tmp
op_assign
(paren
(paren
id|delay
op_lshift
(paren
l_int|31
op_minus
id|q-&gt;delta_log
)paren
)paren
op_div
id|q-&gt;rate
)paren
op_rshift
(paren
l_int|31
op_minus
id|q-&gt;delta_log
op_plus
id|q-&gt;R_log
)paren
suffix:semicolon
id|tmp
op_add_assign
id|q-&gt;R_c
suffix:semicolon
multiline_comment|/* OK, this flow (and all flows with greater&n;&t;&t;   finish numbers) is still active */
r_if
c_cond
(paren
id|F
op_minus
id|tmp
OG
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* It is more not active */
id|a-&gt;fprev-&gt;fnext
op_assign
id|a-&gt;fnext
suffix:semicolon
id|a-&gt;fnext-&gt;fprev
op_assign
id|a-&gt;fprev
suffix:semicolon
multiline_comment|/*&n;&t;&t; * q-&gt;t_c += (F - q-&gt;R_c)*q-&gt;rate&n;&t;&t; */
id|tmp
op_assign
(paren
(paren
id|F
op_minus
id|q-&gt;R_c
)paren
op_star
id|q-&gt;rate
)paren
op_lshift
id|q-&gt;R_log
suffix:semicolon
id|R_c
op_assign
id|F
suffix:semicolon
id|q-&gt;rate
op_sub_assign
id|a-&gt;slice.rate
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|delay
op_minus
id|tmp
)paren
op_ge
l_int|0
)paren
(brace
id|delay
op_sub_assign
id|tmp
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|delay
op_assign
l_int|0
suffix:semicolon
)brace
id|q-&gt;R_c
op_assign
id|tmp
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|csz_classify
r_int
id|csz_classify
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|csz_sched_data
op_star
id|q
)paren
(brace
r_return
id|CSZ_GUARANTEED
suffix:semicolon
)brace
r_static
r_int
DECL|function|csz_enqueue
id|csz_enqueue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|csz_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|csz_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_int
id|flow_id
op_assign
id|csz_classify
c_func
(paren
id|skb
comma
id|q
)paren
suffix:semicolon
r_int
r_int
id|R
suffix:semicolon
r_int
id|prio
op_assign
l_int|0
suffix:semicolon
r_struct
id|csz_flow
op_star
id|this
suffix:semicolon
r_if
c_cond
(paren
id|flow_id
op_ge
id|CSZ_GUARANTEED
)paren
(brace
id|prio
op_assign
id|flow_id
op_minus
id|CSZ_GUARANTEED
suffix:semicolon
id|flow_id
op_assign
l_int|0
suffix:semicolon
)brace
id|this
op_assign
op_amp
id|q-&gt;flow
(braket
id|flow_id
)braket
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;q.qlen
op_ge
id|this-&gt;limit
op_logical_or
id|this-&gt;L_tab
op_eq
l_int|NULL
)paren
(brace
id|sch-&gt;stats.drops
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
id|NET_XMIT_DROP
suffix:semicolon
)brace
id|R
op_assign
id|csz_update
c_func
(paren
id|sch
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|this-&gt;finish
op_minus
id|R
)paren
op_ge
l_int|0
)paren
(brace
multiline_comment|/* It was active */
id|this-&gt;finish
op_add_assign
id|L2R
c_func
(paren
id|this
comma
id|skb-&gt;len
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It is inactive; activate it */
id|this-&gt;finish
op_assign
id|R
op_plus
id|L2R
c_func
(paren
id|this
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|q-&gt;rate
op_add_assign
id|this-&gt;slice.rate
suffix:semicolon
id|csz_insert_finish
c_func
(paren
op_amp
id|q-&gt;f
comma
id|this
)paren
suffix:semicolon
)brace
multiline_comment|/* If this flow was empty, remember start number&n;&t;   and insert it into start queue */
r_if
c_cond
(paren
id|this-&gt;q.qlen
op_eq
l_int|0
)paren
(brace
id|this-&gt;start
op_assign
id|this-&gt;finish
suffix:semicolon
id|csz_insert_start
c_func
(paren
op_amp
id|q-&gt;s
comma
id|this
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flow_id
)paren
id|skb_queue_tail
c_func
(paren
op_amp
id|this-&gt;q
comma
id|skb
)paren
suffix:semicolon
r_else
id|skb_queue_tail
c_func
(paren
op_amp
id|q-&gt;other
(braket
id|prio
)braket
comma
id|skb
)paren
suffix:semicolon
id|sch-&gt;q.qlen
op_increment
suffix:semicolon
id|sch-&gt;stats.bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|sch-&gt;stats.packets
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|__inline__
r_struct
id|sk_buff
op_star
DECL|function|skb_dequeue_best
id|skb_dequeue_best
c_func
(paren
r_struct
id|csz_sched_data
op_star
id|q
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|q-&gt;other
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
id|q-&gt;flow
(braket
l_int|0
)braket
dot
id|q.qlen
op_decrement
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
id|__inline__
r_struct
id|sk_buff
op_star
DECL|function|skb_peek_best
id|skb_peek_best
c_func
(paren
r_struct
id|csz_sched_data
op_star
id|q
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|q-&gt;other
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
r_return
id|skb
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CSZ_PLUS_TBF
DECL|function|csz_watchdog
r_static
r_void
id|csz_watchdog
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|Qdisc
op_star
id|sch
op_assign
(paren
r_struct
id|Qdisc
op_star
)paren
id|arg
suffix:semicolon
id|qdisc_wakeup
c_func
(paren
id|sch-&gt;dev
)paren
suffix:semicolon
)brace
r_static
id|__inline__
r_void
DECL|function|csz_move_queue
id|csz_move_queue
c_func
(paren
r_struct
id|csz_flow
op_star
id|this
comma
r_int
id|delta
)paren
(brace
id|this-&gt;fprev-&gt;fnext
op_assign
id|this-&gt;fnext
suffix:semicolon
id|this-&gt;fnext-&gt;fprev
op_assign
id|this-&gt;fprev
suffix:semicolon
id|this-&gt;start
op_add_assign
id|delta
suffix:semicolon
id|this-&gt;finish
op_add_assign
id|delta
suffix:semicolon
id|csz_insert_finish
c_func
(paren
id|this
)paren
suffix:semicolon
)brace
DECL|function|csz_enough_tokens
r_static
id|__inline__
r_int
id|csz_enough_tokens
c_func
(paren
r_struct
id|csz_sched_data
op_star
id|q
comma
r_struct
id|csz_flow
op_star
id|this
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|toks
suffix:semicolon
r_int
id|shift
suffix:semicolon
id|psched_time_t
id|now
suffix:semicolon
id|PSCHED_GET_TIME
c_func
(paren
id|now
)paren
suffix:semicolon
id|toks
op_assign
id|PSCHED_TDIFF
c_func
(paren
id|now
comma
id|t_tbf
)paren
op_plus
id|this-&gt;tokens
op_minus
id|L2R
c_func
(paren
id|q
comma
id|this
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|shift
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;throttled
)paren
(brace
multiline_comment|/* Remember aposteriory delay */
r_int
r_int
id|R
op_assign
id|csz_update
c_func
(paren
id|q
)paren
suffix:semicolon
id|shift
op_assign
id|R
op_minus
id|this-&gt;R_tbf
suffix:semicolon
id|this-&gt;R_tbf
op_assign
id|R
suffix:semicolon
)brace
r_if
c_cond
(paren
id|toks
op_ge
l_int|0
)paren
(brace
multiline_comment|/* Now we have enough tokens to proceed */
id|this-&gt;tokens
op_assign
id|toks
op_le
id|this-&gt;depth
ques
c_cond
id|toks
suffix:colon
id|this-&gt;depth
suffix:semicolon
id|this-&gt;t_tbf
op_assign
id|now
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;throttled
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Flow was throttled. Update its start&amp;finish numbers&n;&t;&t;   with delay calculated aposteriori.&n;&t;&t; */
id|this-&gt;throttled
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|shift
OG
l_int|0
)paren
id|csz_move_queue
c_func
(paren
id|this
comma
id|shift
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;throttled
)paren
(brace
multiline_comment|/* Flow has just been throttled; remember&n;&t;&t;   current round number to calculate aposteriori delay&n;&t;&t; */
id|this-&gt;throttled
op_assign
l_int|1
suffix:semicolon
id|this-&gt;R_tbf
op_assign
id|csz_update
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
multiline_comment|/* Move all the queue to the time when it will be allowed to send.&n;&t;   We should translate time to round number, but it is impossible,&n;&t;   so that we made the most conservative estimate i.e. we suppose&n;&t;   that only this flow is active and, hence, R = t.&n;&t;   Really toks &lt;= R &lt;= toks/r_a.&n;&n;&t;   This apriory shift in R will be adjusted later to reflect&n;&t;   real delay. We cannot avoid it because of:&n;&t;   - throttled flow continues to be active from the viewpoint&n;&t;     of CSZ, so that it would acquire the highest priority,&n;&t;     if you not adjusted start numbers.&n;&t;   - Eventually, finish number would become less than round&n;&t;     number and flow were declared inactive.&n;&t; */
id|toks
op_assign
op_minus
id|toks
suffix:semicolon
multiline_comment|/* Remeber, that we should start watchdog */
r_if
c_cond
(paren
id|toks
OL
id|q-&gt;wd_expires
)paren
id|q-&gt;wd_expires
op_assign
id|toks
suffix:semicolon
id|toks
op_rshift_assign
id|q-&gt;R_log
suffix:semicolon
id|shift
op_add_assign
id|toks
suffix:semicolon
r_if
c_cond
(paren
id|shift
OG
l_int|0
)paren
(brace
id|this-&gt;R_tbf
op_add_assign
id|toks
suffix:semicolon
id|csz_move_queue
c_func
(paren
id|this
comma
id|shift
)paren
suffix:semicolon
)brace
id|csz_insert_start
c_func
(paren
id|this
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_static
r_struct
id|sk_buff
op_star
DECL|function|csz_dequeue
id|csz_dequeue
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|csz_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|csz_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|csz_flow
op_star
id|this
suffix:semicolon
macro_line|#ifdef CSZ_PLUS_TBF
id|q-&gt;wd_expires
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|this
op_assign
(paren
r_struct
id|csz_flow
op_star
)paren
id|q-&gt;s.snext
suffix:semicolon
r_while
c_loop
(paren
id|this
op_ne
(paren
r_struct
id|csz_flow
op_star
)paren
op_amp
id|q-&gt;s
)paren
(brace
multiline_comment|/* First of all: unlink from start list */
id|this-&gt;sprev-&gt;snext
op_assign
id|this-&gt;snext
suffix:semicolon
id|this-&gt;snext-&gt;sprev
op_assign
id|this-&gt;sprev
suffix:semicolon
r_if
c_cond
(paren
id|this
op_ne
op_amp
id|q-&gt;flow
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* Guaranteed flow */
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
op_amp
id|this-&gt;q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
macro_line|#ifdef CSZ_PLUS_TBF
r_if
c_cond
(paren
id|this-&gt;depth
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|csz_enough_tokens
c_func
(paren
id|q
comma
id|this
comma
id|skb
)paren
)paren
r_continue
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|this-&gt;q.qlen
)paren
(brace
r_struct
id|sk_buff
op_star
id|nskb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|this-&gt;q
)paren
suffix:semicolon
id|this-&gt;start
op_add_assign
id|L2R
c_func
(paren
id|this
comma
id|nskb-&gt;len
)paren
suffix:semicolon
id|csz_insert_start
c_func
(paren
op_amp
id|q-&gt;s
comma
id|this
)paren
suffix:semicolon
)brace
id|sch-&gt;q.qlen
op_decrement
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Predicted or best effort flow */
id|skb
op_assign
id|skb_dequeue_best
c_func
(paren
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
r_int
id|peeked
op_assign
id|this-&gt;peeked
suffix:semicolon
id|this-&gt;peeked
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|this-&gt;q.qlen
)paren
(brace
r_struct
id|sk_buff
op_star
id|nskb
suffix:semicolon
r_int
id|dequeued
op_assign
id|L2R
c_func
(paren
id|this
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* We got not the same thing that&n;&t;&t;&t;&t;&t;   peeked earlier; adjust start number&n;&t;&t;&t;&t;&t;   */
r_if
c_cond
(paren
id|peeked
op_ne
id|dequeued
op_logical_and
id|peeked
)paren
id|this-&gt;start
op_add_assign
id|dequeued
op_minus
id|peeked
suffix:semicolon
id|nskb
op_assign
id|skb_peek_best
c_func
(paren
id|q
)paren
suffix:semicolon
id|peeked
op_assign
id|L2R
c_func
(paren
id|this
comma
id|nskb-&gt;len
)paren
suffix:semicolon
id|this-&gt;start
op_add_assign
id|peeked
suffix:semicolon
id|this-&gt;peeked
op_assign
id|peeked
suffix:semicolon
id|csz_insert_start
c_func
(paren
op_amp
id|q-&gt;s
comma
id|this
)paren
suffix:semicolon
)brace
id|sch-&gt;q.qlen
op_decrement
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef CSZ_PLUS_TBF
multiline_comment|/* We are about to return no skb.&n;&t;   Schedule watchdog timer, if it occurred because of shaping.&n;&t; */
r_if
c_cond
(paren
id|q-&gt;wd_expires
)paren
(brace
r_int
r_int
id|delay
op_assign
id|PSCHED_US2JIFFIE
c_func
(paren
id|q-&gt;wd_expires
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|q-&gt;wd_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delay
op_eq
l_int|0
)paren
id|delay
op_assign
l_int|1
suffix:semicolon
id|q-&gt;wd_timer.expires
op_assign
id|jiffies
op_plus
id|delay
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|q-&gt;wd_timer
)paren
suffix:semicolon
id|sch-&gt;stats.overlimits
op_increment
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_void
DECL|function|csz_reset
id|csz_reset
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|csz_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|csz_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
id|skb_queue_purge
c_func
(paren
op_amp
id|q-&gt;other
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CSZ_GUARANTEED
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|csz_flow
op_star
id|this
op_assign
id|q-&gt;flow
op_plus
id|i
suffix:semicolon
id|skb_queue_purge
c_func
(paren
op_amp
id|this-&gt;q
)paren
suffix:semicolon
id|this-&gt;snext
op_assign
id|this-&gt;sprev
op_assign
id|this-&gt;fnext
op_assign
id|this-&gt;fprev
op_assign
(paren
r_struct
id|csz_head
op_star
)paren
id|this
suffix:semicolon
id|this-&gt;start
op_assign
id|this-&gt;finish
op_assign
l_int|0
suffix:semicolon
)brace
id|q-&gt;s.snext
op_assign
id|q-&gt;s.sprev
op_assign
op_amp
id|q-&gt;s
suffix:semicolon
id|q-&gt;f.fnext
op_assign
id|q-&gt;f.fprev
op_assign
op_amp
id|q-&gt;f
suffix:semicolon
id|q-&gt;R_c
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CSZ_PLUS_TBF
id|PSCHED_GET_TIME
c_func
(paren
op_amp
id|q-&gt;t_tbf
)paren
suffix:semicolon
id|q-&gt;tokens
op_assign
id|q-&gt;depth
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|q-&gt;wd_timer
)paren
suffix:semicolon
macro_line|#endif
id|sch-&gt;q.qlen
op_assign
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|csz_destroy
id|csz_destroy
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|function|csz_init
r_static
r_int
id|csz_init
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|rtattr
op_star
id|opt
)paren
(brace
r_struct
id|csz_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|csz_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|rtattr
op_star
id|tb
(braket
id|TCA_CSZ_PTAB
)braket
suffix:semicolon
r_struct
id|tc_csz_qopt
op_star
id|qopt
suffix:semicolon
r_int
id|i
suffix:semicolon
id|rtattr_parse
c_func
(paren
id|tb
comma
id|TCA_CSZ_PTAB
comma
id|RTA_DATA
c_func
(paren
id|opt
)paren
comma
id|RTA_PAYLOAD
c_func
(paren
id|opt
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CSZ_PARMS
op_minus
l_int|1
)braket
op_eq
l_int|NULL
op_logical_or
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_CSZ_PARMS
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
op_star
id|qopt
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|qopt
op_assign
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_CSZ_PARMS
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|q-&gt;R_log
op_assign
id|qopt-&gt;R_log
suffix:semicolon
id|q-&gt;delta_log
op_assign
id|qopt-&gt;delta_log
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|TC_PRIO_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|qopt-&gt;priomap
(braket
id|i
)braket
op_ge
id|CSZ_FLOWS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|q-&gt;prio2band
(braket
id|i
)braket
op_assign
id|qopt-&gt;priomap
(braket
id|i
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
id|skb_queue_head_init
c_func
(paren
op_amp
id|q-&gt;other
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CSZ_GUARANTEED
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|csz_flow
op_star
id|this
op_assign
id|q-&gt;flow
op_plus
id|i
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|this-&gt;q
)paren
suffix:semicolon
id|this-&gt;snext
op_assign
id|this-&gt;sprev
op_assign
id|this-&gt;fnext
op_assign
id|this-&gt;fprev
op_assign
(paren
r_struct
id|csz_head
op_star
)paren
id|this
suffix:semicolon
id|this-&gt;start
op_assign
id|this-&gt;finish
op_assign
l_int|0
suffix:semicolon
)brace
id|q-&gt;s.snext
op_assign
id|q-&gt;s.sprev
op_assign
op_amp
id|q-&gt;s
suffix:semicolon
id|q-&gt;f.fnext
op_assign
id|q-&gt;f.fprev
op_assign
op_amp
id|q-&gt;f
suffix:semicolon
id|q-&gt;R_c
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CSZ_PLUS_TBF
id|init_timer
c_func
(paren
op_amp
id|q-&gt;wd_timer
)paren
suffix:semicolon
id|q-&gt;wd_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sch
suffix:semicolon
id|q-&gt;wd_timer.function
op_assign
id|csz_watchdog
suffix:semicolon
macro_line|#endif
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_RTNETLINK
DECL|function|csz_dump
r_static
r_int
id|csz_dump
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|csz_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|csz_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
r_struct
id|rtattr
op_star
id|rta
suffix:semicolon
r_struct
id|tc_csz_qopt
id|opt
suffix:semicolon
id|rta
op_assign
(paren
r_struct
id|rtattr
op_star
)paren
id|b
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_OPTIONS
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|opt.flows
op_assign
id|CSZ_FLOWS
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|opt.priomap
comma
id|q-&gt;prio2band
comma
id|TC_PRIO_MAX
op_plus
l_int|1
)paren
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_CSZ_PARMS
comma
r_sizeof
(paren
id|opt
)paren
comma
op_amp
id|opt
)paren
suffix:semicolon
id|rta-&gt;rta_len
op_assign
id|skb-&gt;tail
op_minus
id|b
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
DECL|function|csz_graft
r_static
r_int
id|csz_graft
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|cl
comma
r_struct
id|Qdisc
op_star
r_new
comma
r_struct
id|Qdisc
op_star
op_star
id|old
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|csz_leaf
r_static
r_struct
id|Qdisc
op_star
id|csz_leaf
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|cl
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|csz_get
r_static
r_int
r_int
id|csz_get
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
id|u32
id|classid
)paren
(brace
r_struct
id|csz_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|csz_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_int
r_int
id|band
op_assign
id|TC_H_MIN
c_func
(paren
id|classid
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|band
op_ge
id|CSZ_FLOWS
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|band
OL
id|CSZ_GUARANTEED
op_logical_and
id|q-&gt;flow
(braket
id|band
)braket
dot
id|L_tab
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|band
op_plus
l_int|1
suffix:semicolon
)brace
DECL|function|csz_bind
r_static
r_int
r_int
id|csz_bind
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|parent
comma
id|u32
id|classid
)paren
(brace
r_return
id|csz_get
c_func
(paren
id|sch
comma
id|classid
)paren
suffix:semicolon
)brace
DECL|function|csz_put
r_static
r_void
id|csz_put
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|cl
)paren
(brace
r_return
suffix:semicolon
)brace
DECL|function|csz_change
r_static
r_int
id|csz_change
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
id|u32
id|handle
comma
id|u32
id|parent
comma
r_struct
id|rtattr
op_star
op_star
id|tca
comma
r_int
r_int
op_star
id|arg
)paren
(brace
r_int
r_int
id|cl
op_assign
op_star
id|arg
suffix:semicolon
r_struct
id|csz_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|csz_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|rtattr
op_star
id|opt
op_assign
id|tca
(braket
id|TCA_OPTIONS
op_minus
l_int|1
)braket
suffix:semicolon
r_struct
id|rtattr
op_star
id|tb
(braket
id|TCA_CSZ_PTAB
)braket
suffix:semicolon
r_struct
id|tc_csz_copt
op_star
id|copt
suffix:semicolon
id|rtattr_parse
c_func
(paren
id|tb
comma
id|TCA_CSZ_PTAB
comma
id|RTA_DATA
c_func
(paren
id|opt
)paren
comma
id|RTA_PAYLOAD
c_func
(paren
id|opt
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CSZ_PARMS
op_minus
l_int|1
)braket
op_eq
l_int|NULL
op_logical_or
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_CSZ_PARMS
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
op_star
id|copt
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|copt
op_assign
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_CSZ_PARMS
op_minus
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CSZ_RTAB
op_minus
l_int|1
)braket
op_logical_and
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_CSZ_RTAB
op_minus
l_int|1
)braket
)paren
OL
l_int|1024
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|cl
)paren
(brace
r_struct
id|csz_flow
op_star
id|a
suffix:semicolon
id|cl
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_ge
id|CSZ_FLOWS
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_ge
id|CSZ_GUARANTEED
op_logical_or
id|q-&gt;flow
(braket
id|cl
)braket
dot
id|L_tab
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|a
op_assign
op_amp
id|q-&gt;flow
(braket
id|cl
)braket
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|sch-&gt;dev-&gt;queue_lock
)paren
suffix:semicolon
macro_line|#if 0
id|a-&gt;rate_log
op_assign
id|copt-&gt;rate_log
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CSZ_PLUS_TBF
id|a-&gt;limit
op_assign
id|copt-&gt;limit
suffix:semicolon
id|a-&gt;rate
op_assign
id|copt-&gt;rate
suffix:semicolon
id|a-&gt;buffer
op_assign
id|copt-&gt;buffer
suffix:semicolon
id|a-&gt;mtu
op_assign
id|copt-&gt;mtu
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CSZ_RTAB
op_minus
l_int|1
)braket
)paren
id|memcpy
c_func
(paren
id|a-&gt;L_tab
comma
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_CSZ_RTAB
op_minus
l_int|1
)braket
)paren
comma
l_int|1024
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|sch-&gt;dev-&gt;queue_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* NI */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|csz_delete
r_static
r_int
id|csz_delete
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|cl
)paren
(brace
r_struct
id|csz_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|csz_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|csz_flow
op_star
id|a
suffix:semicolon
id|cl
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_ge
id|CSZ_FLOWS
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_ge
id|CSZ_GUARANTEED
op_logical_or
id|q-&gt;flow
(braket
id|cl
)braket
dot
id|L_tab
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|a
op_assign
op_amp
id|q-&gt;flow
(braket
id|cl
)braket
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|sch-&gt;dev-&gt;queue_lock
)paren
suffix:semicolon
id|a-&gt;fprev-&gt;fnext
op_assign
id|a-&gt;fnext
suffix:semicolon
id|a-&gt;fnext-&gt;fprev
op_assign
id|a-&gt;fprev
suffix:semicolon
id|a-&gt;sprev-&gt;snext
op_assign
id|a-&gt;snext
suffix:semicolon
id|a-&gt;snext-&gt;sprev
op_assign
id|a-&gt;sprev
suffix:semicolon
id|a-&gt;start
op_assign
id|a-&gt;finish
op_assign
l_int|0
suffix:semicolon
id|kfree
c_func
(paren
id|xchg
c_func
(paren
op_amp
id|q-&gt;flow
(braket
id|cl
)braket
dot
id|L_tab
comma
l_int|NULL
)paren
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|sch-&gt;dev-&gt;queue_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_RTNETLINK
DECL|function|csz_dump_class
r_static
r_int
id|csz_dump_class
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|cl
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcmsg
op_star
id|tcm
)paren
(brace
r_struct
id|csz_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|csz_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
r_struct
id|rtattr
op_star
id|rta
suffix:semicolon
r_struct
id|tc_csz_copt
id|opt
suffix:semicolon
id|tcm-&gt;tcm_handle
op_assign
id|sch-&gt;handle
op_or
id|cl
suffix:semicolon
id|cl
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|cl
OG
id|CSZ_FLOWS
)paren
r_goto
id|rtattr_failure
suffix:semicolon
r_if
c_cond
(paren
id|cl
OL
id|CSZ_GUARANTEED
)paren
(brace
r_struct
id|csz_flow
op_star
id|f
op_assign
op_amp
id|q-&gt;flow
(braket
id|cl
)braket
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;L_tab
op_eq
l_int|NULL
)paren
r_goto
id|rtattr_failure
suffix:semicolon
id|rta
op_assign
(paren
r_struct
id|rtattr
op_star
)paren
id|b
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_OPTIONS
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|opt.limit
op_assign
id|f-&gt;limit
suffix:semicolon
id|opt.rate
op_assign
id|f-&gt;rate
suffix:semicolon
id|opt.slice
op_assign
id|f-&gt;slice
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|opt.peakrate
comma
l_int|0
comma
r_sizeof
(paren
id|opt.peakrate
)paren
)paren
suffix:semicolon
macro_line|#ifdef CSZ_PLUS_TBF
id|opt.buffer
op_assign
id|f-&gt;buffer
suffix:semicolon
id|opt.mtu
op_assign
id|f-&gt;mtu
suffix:semicolon
macro_line|#else
id|opt.buffer
op_assign
l_int|0
suffix:semicolon
id|opt.mtu
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_CSZ_PARMS
comma
r_sizeof
(paren
id|opt
)paren
comma
op_amp
id|opt
)paren
suffix:semicolon
id|rta-&gt;rta_len
op_assign
id|skb-&gt;tail
op_minus
id|b
suffix:semicolon
)brace
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
DECL|function|csz_walk
r_static
r_void
id|csz_walk
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|qdisc_walker
op_star
id|arg
)paren
(brace
r_struct
id|csz_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|csz_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_int
id|prio
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|arg-&gt;stop
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|prio
op_assign
l_int|0
suffix:semicolon
id|prio
OL
id|CSZ_FLOWS
suffix:semicolon
id|prio
op_increment
)paren
(brace
r_if
c_cond
(paren
id|arg-&gt;count
OL
id|arg-&gt;skip
)paren
(brace
id|arg-&gt;count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prio
OL
id|CSZ_GUARANTEED
op_logical_and
id|q-&gt;flow
(braket
id|prio
)braket
dot
id|L_tab
op_eq
l_int|NULL
)paren
(brace
id|arg-&gt;count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
op_member_access_from_pointer
id|fn
c_func
(paren
id|sch
comma
id|prio
op_plus
l_int|1
comma
id|arg
)paren
OL
l_int|0
)paren
(brace
id|arg-&gt;stop
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|arg-&gt;count
op_increment
suffix:semicolon
)brace
)brace
DECL|function|csz_find_tcf
r_static
r_struct
id|tcf_proto
op_star
op_star
id|csz_find_tcf
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|cl
)paren
(brace
r_struct
id|csz_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|csz_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|cl
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
op_amp
id|q-&gt;filter_list
suffix:semicolon
)brace
DECL|variable|csz_class_ops
r_struct
id|Qdisc_class_ops
id|csz_class_ops
op_assign
(brace
id|csz_graft
comma
id|csz_leaf
comma
id|csz_get
comma
id|csz_put
comma
id|csz_change
comma
id|csz_delete
comma
id|csz_walk
comma
id|csz_find_tcf
comma
id|csz_bind
comma
id|csz_put
comma
macro_line|#ifdef CONFIG_RTNETLINK
id|csz_dump_class
comma
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|csz_qdisc_ops
r_struct
id|Qdisc_ops
id|csz_qdisc_ops
op_assign
(brace
l_int|NULL
comma
op_amp
id|csz_class_ops
comma
l_string|&quot;csz&quot;
comma
r_sizeof
(paren
r_struct
id|csz_sched_data
)paren
comma
id|csz_enqueue
comma
id|csz_dequeue
comma
l_int|NULL
comma
l_int|NULL
comma
id|csz_init
comma
id|csz_reset
comma
id|csz_destroy
comma
l_int|NULL
multiline_comment|/* csz_change */
comma
macro_line|#ifdef CONFIG_RTNETLINK
id|csz_dump
comma
macro_line|#endif
)brace
suffix:semicolon
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|register_qdisc
c_func
(paren
op_amp
id|csz_qdisc_ops
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|unregister_qdisc
c_func
(paren
op_amp
id|csz_qdisc_ops
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
