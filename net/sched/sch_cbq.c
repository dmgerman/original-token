multiline_comment|/*&n; * net/sched/sch_cbq.c&t;Class-Based Queueing discipline.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; * Authors:&t;Alexey Kuznetsov, &lt;kuznet@ms2.inr.ac.ru&gt;&n; *&n; */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/pkt_sched.h&gt;
multiline_comment|/*&t;Class-Based Queueing (CBQ) algorithm.&n;&t;=======================================&n;&n;&t;Sources: [1] Sally Floyd and Van Jacobson, &quot;Link-sharing and Resource&n;&t;         Management Models for Packet Networks&quot;,&n;&t;&t; IEEE/ACM Transactions on Networking, Vol.3, No.4, 1995&n;&n;&t;         [2] Sally Floyd, &quot;Notes on CBQ and Guaranted Service&quot;, 1995&n;&n;&t;         [3] Sally Floyd, &quot;Notes on Class-Based Queueing: Setting&n;&t;&t; Parameters&quot;, 1996&n;&n;&t;Algorithm skeleton is taken from from NS simulator cbq.cc.&n;&n;&t;-----------------------------------------------------------------------&n;&n;&t;Differences from NS version.&n;&n;&t;--- WRR algorith is different. Our version looks more reasonable :-)&n;&t;and fair when quanta are allowed to be less than MTU.&n;&n;&t;--- cl-&gt;aveidle is REALLY limited from below by cl-&gt;minidle.&n;&t;Seems, it was bug in NS.&n;&n;&t;--- Purely lexical change: &quot;depth&quot; -&gt; &quot;level&quot;, &quot;maxdepth&quot; -&gt; &quot;toplevel&quot;.&n;&t;When depth increases we expect, that the thing becomes lower, does not it? :-)&n;&t;Besides that, &quot;depth&quot; word is semantically overloaded ---&n;&t;&quot;token bucket depth&quot;, &quot;sfq depth&quot;... Besides that, the algorithm&n;&t;was called &quot;top-LEVEL sharing&quot;.&n;&n;&t;PROBLEM.&n;&n;&t;--- Linux has no EOI event at the moment, so that we cannot&n;&t;estimate true class idle time. Three workarounds are possible,&n;&t;all of them have drawbacks:&n;&n;&t;1. (as now) Consider the next dequeue event as sign that&n;&t;previous packet is finished. It is wrong because of ping-pong&n;&t;buffers, but on permanently loaded link it is true.&n;&t;2. (NS approach) Use as link busy time estimate skb-&gt;leb/&quot;physical&n;&t;bandwidth&quot;. Even more wrong f.e. on ethernet real busy time much&n;&t;higher because of collisions.&n;&t;3. (seems, the most clever) Split net bh to two parts:&n;&t;NETRX_BH (for received packets) and preserve NET_BH for transmitter.&n;&t;It will not require driver changes (NETRX_BH flag will be set&n;&t;in netif_rx), but will allow to trace EOIs more precisely&n;&t;and will save useless checks in net_bh. Besides that we will&n;&t;have to eliminate random calling hard_start_xmit with dev-&gt;tbusy flag&n;&t;(done) and to drop failure_q --- i.e. if !dev-&gt;tbusy hard_start_xmit&n;&t;MUST succeed; failed packets will be dropped on the floor.&n;*/
DECL|macro|CBQ_TOPLEVEL_SHARING
mdefine_line|#define CBQ_TOPLEVEL_SHARING
multiline_comment|/* #define CBQ_NO_TRICKERY */
DECL|macro|CBQ_CLASSIFIER
mdefine_line|#define CBQ_CLASSIFIER(skb, q) ((q)-&gt;fallback_class)
DECL|struct|cbq_class
r_struct
id|cbq_class
(brace
multiline_comment|/* Parameters */
DECL|member|priority
r_int
id|priority
suffix:semicolon
multiline_comment|/* priority */
macro_line|#ifdef CBQ_TOPLEVEL_SHARING
DECL|member|level
r_int
id|level
suffix:semicolon
multiline_comment|/* level of the class in hierarchy:&n;&t;&t;&t;&t;&t;&t;   0 for leaf classes, and maximal&n;&t;&t;&t;&t;&t;&t;   level of childrens + 1 for nodes.&n;&t;&t;&t;&t;&t;&t; */
macro_line|#endif
DECL|member|maxidle
r_int
id|maxidle
suffix:semicolon
multiline_comment|/* Class paramters: see below. */
DECL|member|minidle
r_int
id|minidle
suffix:semicolon
DECL|member|filter_log
r_int
id|filter_log
suffix:semicolon
macro_line|#ifndef CBQ_NO_TRICKERY
DECL|member|extradelay
r_int
id|extradelay
suffix:semicolon
macro_line|#endif
DECL|member|quantum
r_int
id|quantum
suffix:semicolon
multiline_comment|/* Allotment per WRR round */
DECL|member|rquantum
r_int
id|rquantum
suffix:semicolon
multiline_comment|/* Relative allotment: see below */
DECL|member|cell_log
r_int
id|cell_log
suffix:semicolon
DECL|member|L_tab
r_int
r_int
id|L_tab
(braket
l_int|256
)braket
suffix:semicolon
DECL|member|qdisc
r_struct
id|Qdisc
op_star
id|qdisc
suffix:semicolon
multiline_comment|/* ptr to CBQ discipline */
DECL|member|root
r_struct
id|cbq_class
op_star
id|root
suffix:semicolon
multiline_comment|/* Ptr to root class;&n;&t;&t;&t;&t;&t;&t;   root can be not unique.&n;&t;&t;&t;&t;&t;&t; */
DECL|member|parent
r_struct
id|cbq_class
op_star
id|parent
suffix:semicolon
multiline_comment|/* Ptr to parent in the class tree */
DECL|member|borrow
r_struct
id|cbq_class
op_star
id|borrow
suffix:semicolon
multiline_comment|/* NULL if class is bandwidth limited;&n;&t;&t;&t;&t;&t;&t;   parent otherwise */
DECL|member|q
r_struct
id|Qdisc
op_star
id|q
suffix:semicolon
multiline_comment|/* Elementary queueing discipline */
DECL|member|next
r_struct
id|cbq_class
op_star
id|next
suffix:semicolon
multiline_comment|/* next class in this priority band */
DECL|member|next_alive
r_struct
id|cbq_class
op_star
id|next_alive
suffix:semicolon
multiline_comment|/* next class with backlog in this priority band */
multiline_comment|/* Variables */
DECL|member|last
id|psched_time_t
id|last
suffix:semicolon
DECL|member|undertime
id|psched_time_t
id|undertime
suffix:semicolon
DECL|member|avgidle
r_int
id|avgidle
suffix:semicolon
DECL|member|deficit
r_int
id|deficit
suffix:semicolon
multiline_comment|/* Saved deficit for WRR */
DECL|member|awake
r_char
id|awake
suffix:semicolon
multiline_comment|/* Class is in alive list */
macro_line|#if 0
r_void
(paren
op_star
id|overlimit
)paren
(paren
r_struct
id|cbq_class
op_star
id|cl
)paren
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
DECL|macro|L2T
mdefine_line|#define L2T(cl,len)&t;((cl)-&gt;L_tab[(len)&gt;&gt;(cl)-&gt;cell_log])
DECL|struct|cbq_sched_data
r_struct
id|cbq_sched_data
(brace
DECL|member|classes
r_struct
id|cbq_class
op_star
id|classes
(braket
id|CBQ_MAXPRIO
)braket
suffix:semicolon
multiline_comment|/* List of all classes */
DECL|member|nclasses
r_int
id|nclasses
(braket
id|CBQ_MAXPRIO
)braket
suffix:semicolon
DECL|member|quanta
r_int
id|quanta
(braket
id|CBQ_MAXPRIO
)braket
suffix:semicolon
DECL|member|mtu
r_int
id|mtu
suffix:semicolon
DECL|member|cell_log
r_int
id|cell_log
suffix:semicolon
DECL|member|L_tab
r_int
r_int
id|L_tab
(braket
l_int|256
)braket
suffix:semicolon
DECL|member|fallback_class
r_struct
id|cbq_class
op_star
id|fallback_class
suffix:semicolon
DECL|member|activemask
r_int
id|activemask
suffix:semicolon
DECL|member|active
r_struct
id|cbq_class
op_star
id|active
(braket
id|CBQ_MAXPRIO
)braket
suffix:semicolon
multiline_comment|/* List of all classes&n;&t;&t;&t;&t;&t;&t;&t;   with backlog */
DECL|member|last_sent
r_struct
id|cbq_class
op_star
id|last_sent
suffix:semicolon
DECL|member|last_sent_len
r_int
id|last_sent_len
suffix:semicolon
DECL|member|now
id|psched_time_t
id|now
suffix:semicolon
multiline_comment|/* Cached timestamp */
DECL|member|wd_timer
r_struct
id|timer_list
id|wd_timer
suffix:semicolon
multiline_comment|/* Wathchdog timer, that&n;&t;&t;&t;&t;&t;&t;   started when CBQ has&n;&t;&t;&t;&t;&t;&t;   backlog, but cannot&n;&t;&t;&t;&t;&t;&t;   transmit just now */
DECL|member|wd_expires
r_int
r_int
id|wd_expires
suffix:semicolon
macro_line|#ifdef CBQ_TOPLEVEL_SHARING
DECL|member|borrowed
r_struct
id|cbq_class
op_star
id|borrowed
suffix:semicolon
DECL|member|toplevel
r_int
id|toplevel
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/*&n;   WRR quanta&n;   ----------&n;&n;   cl-&gt;quantum is number added to class allotment on every round.&n;   cl-&gt;rquantum is &quot;relative&quot; quantum.&n;&n;   For real-time classes:&n;&n;   cl-&gt;quantum = (cl-&gt;rquantum*q-&gt;nclasses[prio]*q-&gt;mtu)/q-&gt;quanta[prio]&n;&n;   where q-&gt;quanta[prio] is sum of all rquanta for given priority.&n;   cl-&gt;rquantum can be identified with absolute rate of the class&n;   in arbitrary units (f.e. bytes/sec)&n;&n;   In this case, delay introduced by round-robin was estimated by&n;   Sally Floyd [2] as:&n;&n;   D = q-&gt;nclasses*q-&gt;mtu/(bandwidth/2)&n;&n;   Note, that D does not depend on class rate (it is very bad),&n;   but not much worse than Gallager-Parekh estimate for CSZ&n;   C/R = q-&gt;mtu/rate, when real-time classes have close rates.&n;&n;   For not real-time classes this folmula is not necessary,&n;   so that cl-&gt;quantum can be set to any reasonable not zero value.&n;   Apparently, it should be proportional to class rate, if the&n;   rate is not zero.&n;*/
multiline_comment|/*&n;   maxidle, minidle, extradelay&n;   ----------------------------&n;&n;   CBQ estimator calculates smoothed class idle time cl-&gt;aveidle,&n;   considering class as virtual interface with corresponding bandwidth.&n;   When cl-&gt;aveidle wants to be less than zero, class is overlimit.&n;   When it is positive, class is underlimit.&n;&n;   * maxidle bounds aveidle from above.&n;     It controls maximal length of burst in this class after&n;     long period of idle time. Burstness of active class&n;     is controlled by filter constant cl-&gt;filter_log,&n;     but this number is related to burst length only indirectly.&n;&n;   * minidle is a negative number, normally set to zero.&n;     Setting it to not zero value allows avgidle to drop&n;     below zero, effectively penalizing class, when it is overlimit.&n;     When the class load will decrease, it will take a time to&n;     raise negative avgidle to put the class at limit.&n;     It should be set to zero for leaf classes.&n;&n;   * extradelay is penalty in delay, when a class goes overlimit.&n;     I believe this parameter is useless and confusing.&n;     Setting it to not zero forces class to accumulate&n;     its &quot;idleness&quot; for extradelay and then send BURST of packets&n;     until going to overlimit again. Non-sense.&n;&n;   For details see [1] and [3].&n;&n;   Really, minidle and extradelay are irrelevant to real scheduling&n;   task. As I understand, SF&amp;VJ introduced them to experiment&n;   with CBQ simulator in attempts to fix erratic behaviour&n;   of ancestor-only (and, partially, top-level) algorithm.&n;&n;   WARNING.&n;&n;   User passes them measured in usecs, but cl-&gt;minidle,&n;   cl-&gt;maxidle and cl-&gt;aveidle are scaled with cl-&gt;filter_log&n;   in the text of the scheduler.&n;*/
multiline_comment|/*&n;   A packet has just been enqueued on the empty class.&n;   cbq_wakeup_class adds it to the tail of active class list&n;   of its priority band.&n; */
DECL|function|cbq_wakeup_class
r_static
id|__inline__
r_void
id|cbq_wakeup_class
c_func
(paren
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|cl-&gt;qdisc-&gt;data
suffix:semicolon
r_int
id|prio
op_assign
id|cl-&gt;priority
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl_tail
suffix:semicolon
id|cl-&gt;awake
op_assign
l_int|1
suffix:semicolon
id|cl_tail
op_assign
id|q-&gt;active
(braket
id|prio
)braket
suffix:semicolon
id|q-&gt;active
(braket
id|prio
)braket
op_assign
id|cl
suffix:semicolon
r_if
c_cond
(paren
id|cl_tail
op_ne
l_int|NULL
)paren
(brace
id|cl-&gt;next_alive
op_assign
id|cl_tail-&gt;next_alive
suffix:semicolon
id|cl-&gt;deficit
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|cl-&gt;next_alive
op_assign
id|cl
suffix:semicolon
id|q-&gt;activemask
op_or_assign
(paren
l_int|1
op_lshift
id|prio
)paren
suffix:semicolon
id|cl-&gt;deficit
op_assign
id|cl-&gt;quantum
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|cbq_enqueue
id|cbq_enqueue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
op_assign
id|CBQ_CLASSIFIER
c_func
(paren
id|skb
comma
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;q
op_member_access_from_pointer
id|enqueue
c_func
(paren
id|skb
comma
id|cl-&gt;q
)paren
op_eq
l_int|1
)paren
(brace
id|sch-&gt;q.qlen
op_increment
suffix:semicolon
macro_line|#ifdef CBQ_TOPLEVEL_SHARING
r_if
c_cond
(paren
id|q-&gt;toplevel
OG
l_int|0
)paren
(brace
id|psched_time_t
id|now
suffix:semicolon
id|PSCHED_GET_TIME
c_func
(paren
id|now
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PSCHED_TLESS
c_func
(paren
id|cl-&gt;undertime
comma
id|now
)paren
)paren
id|q-&gt;toplevel
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|q-&gt;toplevel
OG
l_int|1
op_logical_and
id|cl-&gt;borrow
op_logical_and
id|PSCHED_TLESS
c_func
(paren
id|cl-&gt;borrow-&gt;undertime
comma
id|now
)paren
)paren
id|q-&gt;toplevel
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|cl-&gt;awake
)paren
id|cbq_wakeup_class
c_func
(paren
id|cl
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cbq_delay
r_static
id|__inline__
r_void
id|cbq_delay
c_func
(paren
r_struct
id|cbq_sched_data
op_star
id|q
comma
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_int
id|delay
suffix:semicolon
id|delay
op_assign
id|PSCHED_TDIFF
c_func
(paren
id|cl-&gt;undertime
comma
id|q-&gt;now
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;wd_expires
op_eq
l_int|0
op_logical_or
id|q-&gt;wd_expires
op_minus
id|delay
OG
l_int|0
)paren
id|q-&gt;wd_expires
op_assign
id|delay
suffix:semicolon
)brace
DECL|function|cbq_watchdog
r_static
r_void
id|cbq_watchdog
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|Qdisc
op_star
id|sch
op_assign
(paren
r_struct
id|Qdisc
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
id|q-&gt;wd_timer.expires
op_assign
l_int|0
suffix:semicolon
id|q-&gt;wd_timer.function
op_assign
l_int|NULL
suffix:semicolon
id|qdisc_wakeup
c_func
(paren
id|sch-&gt;dev
)paren
suffix:semicolon
)brace
r_static
id|__inline__
r_void
DECL|function|cbq_update
id|cbq_update
c_func
(paren
r_struct
id|cbq_sched_data
op_star
id|q
)paren
(brace
r_struct
id|cbq_class
op_star
id|cl
suffix:semicolon
r_for
c_loop
(paren
id|cl
op_assign
id|q-&gt;last_sent
suffix:semicolon
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;parent
)paren
(brace
r_int
id|avgidle
op_assign
id|cl-&gt;avgidle
suffix:semicolon
r_int
id|idle
suffix:semicolon
multiline_comment|/*&n;&t;&t;   (now - last) is total time between packet right edges.&n;&t;&t;   (last_pktlen/rate) is &quot;virtual&quot; busy time, so that&n;&n;&t;&t;         idle = (now - last) - last_pktlen/rate&n;&t;&t; */
id|idle
op_assign
id|PSCHED_TDIFF
c_func
(paren
id|q-&gt;now
comma
id|cl-&gt;last
)paren
op_minus
id|L2T
c_func
(paren
id|cl
comma
id|q-&gt;last_sent_len
)paren
suffix:semicolon
multiline_comment|/* true_avgidle := (1-W)*true_avgidle + W*idle,&n;&t;&t;   where W=2^{-filter_log}. But cl-&gt;avgidle is scaled:&n;&t;&t;   cl-&gt;avgidle == true_avgidle/W,&n;&t;&t;   hence:&n;&t;&t; */
id|avgidle
op_add_assign
id|idle
op_minus
(paren
id|avgidle
op_rshift
id|cl-&gt;filter_log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avgidle
op_le
l_int|0
)paren
(brace
multiline_comment|/* Overlimit or at-limit */
macro_line|#ifdef CBQ_NO_TRICKERY
id|avgidle
op_assign
l_int|0
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|avgidle
OL
id|cl-&gt;minidle
)paren
id|avgidle
op_assign
id|cl-&gt;minidle
suffix:semicolon
macro_line|#endif
multiline_comment|/* This line was missing in NS. */
id|cl-&gt;avgidle
op_assign
id|avgidle
suffix:semicolon
multiline_comment|/* Calculate expected time, when this class&n;&t;&t;&t;   will be allowed to send.&n;&t;&t;&t;   It will occur, when:&n;&t;&t;&t;   (1-W)*true_avgidle + W*delay = 0, i.e.&n;&t;&t;&t;   idle = (1/W - 1)*(-true_avgidle)&n;&t;&t;&t;   or&n;&t;&t;&t;   idle = (1 - W)*(-cl-&gt;avgidle);&n;&n;&t;&t;&t;   That is not all.&n;&t;&t;&t;   We want to set undertime to the moment, when&n;&t;&t;&t;   the class is allowed to start next transmission i.e.&n;&t;&t;&t;   (undertime + next_pktlen/phys_bandwidth)&n;&t;&t;&t;   - now - next_pktlen/rate = idle&n;&t;&t;&t;   or&n;&t;&t;&t;   undertime = now + idle + next_pktlen/rate&n;&t;&t;&t;   - next_pktlen/phys_bandwidth&n;&n;&t;&t;&t;   We do not know next packet length, but can&n;&t;&t;&t;   estimate it with average packet length&n;&t;&t;&t;   or current packet_length.&n;&t;&t;&t; */
id|idle
op_assign
(paren
op_minus
id|avgidle
)paren
op_minus
(paren
(paren
op_minus
id|avgidle
)paren
op_rshift
id|cl-&gt;filter_log
)paren
suffix:semicolon
id|idle
op_add_assign
id|L2T
c_func
(paren
id|q
comma
id|q-&gt;last_sent_len
)paren
suffix:semicolon
id|idle
op_sub_assign
id|L2T
c_func
(paren
id|cl
comma
id|q-&gt;last_sent_len
)paren
suffix:semicolon
id|PSCHED_TADD2
c_func
(paren
id|q-&gt;now
comma
id|idle
comma
id|cl-&gt;undertime
)paren
suffix:semicolon
macro_line|#ifndef CBQ_NO_TRICKERY
multiline_comment|/* Do not forget extra delay :-) */
id|PSCHED_TADD
c_func
(paren
id|cl-&gt;undertime
comma
id|cl-&gt;extradelay
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* Underlimit */
id|PSCHED_SET_PASTPERFECT
c_func
(paren
id|cl-&gt;undertime
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avgidle
OG
id|cl-&gt;maxidle
)paren
id|cl-&gt;avgidle
op_assign
id|cl-&gt;maxidle
suffix:semicolon
r_else
id|cl-&gt;avgidle
op_assign
id|avgidle
suffix:semicolon
)brace
id|cl-&gt;last
op_assign
id|q-&gt;now
suffix:semicolon
)brace
macro_line|#ifdef CBQ_TOPLEVEL_SHARING
id|cl
op_assign
id|q-&gt;last_sent
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;borrowed
op_logical_and
id|q-&gt;toplevel
op_ge
id|q-&gt;borrowed-&gt;level
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;q-&gt;q.qlen
op_le
l_int|1
op_logical_or
id|PSCHED_TLESS
c_func
(paren
id|q-&gt;now
comma
id|q-&gt;borrowed-&gt;undertime
)paren
)paren
id|q-&gt;toplevel
op_assign
id|CBQ_MAXLEVEL
suffix:semicolon
r_else
r_if
c_cond
(paren
id|q-&gt;borrowed
op_ne
id|cl
)paren
id|q-&gt;toplevel
op_assign
id|q-&gt;borrowed-&gt;level
suffix:semicolon
)brace
macro_line|#endif
id|q-&gt;last_sent
op_assign
l_int|NULL
suffix:semicolon
)brace
r_static
id|__inline__
r_int
DECL|function|cbq_under_limit
id|cbq_under_limit
c_func
(paren
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|cl-&gt;qdisc-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|this_cl
op_assign
id|cl
suffix:semicolon
r_if
c_cond
(paren
id|PSCHED_IS_PASTPERFECT
c_func
(paren
id|cl-&gt;undertime
)paren
op_logical_or
id|cl-&gt;parent
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|PSCHED_TLESS
c_func
(paren
id|cl-&gt;undertime
comma
id|q-&gt;now
)paren
)paren
(brace
id|q-&gt;borrowed
op_assign
id|cl
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|PSCHED_IS_PASTPERFECT
c_func
(paren
id|cl-&gt;undertime
)paren
op_logical_and
id|PSCHED_TLESS
c_func
(paren
id|q-&gt;now
comma
id|cl-&gt;undertime
)paren
)paren
(brace
id|cl
op_assign
id|cl-&gt;borrow
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
l_int|NULL
macro_line|#ifdef CBQ_TOPLEVEL_SHARING
op_logical_or
id|cl-&gt;level
OG
id|q-&gt;toplevel
macro_line|#endif
)paren
(brace
macro_line|#if 0
id|this_cl
op_member_access_from_pointer
id|overlimit
c_func
(paren
id|this_cl
)paren
suffix:semicolon
macro_line|#else
id|cbq_delay
c_func
(paren
id|q
comma
id|this_cl
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|q-&gt;borrowed
op_assign
id|cl
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
id|__inline__
r_struct
id|sk_buff
op_star
DECL|function|cbq_dequeue_prio
id|cbq_dequeue_prio
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
id|prio
comma
r_int
id|fallback
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl_tail
comma
op_star
id|cl_prev
comma
op_star
id|cl
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|deficit
suffix:semicolon
id|cl_tail
op_assign
id|cl_prev
op_assign
id|q-&gt;active
(braket
id|prio
)braket
suffix:semicolon
id|cl
op_assign
id|cl_prev-&gt;next_alive
suffix:semicolon
r_do
(brace
id|deficit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Start round */
r_do
(brace
multiline_comment|/* Class is empty */
r_if
c_cond
(paren
id|cl-&gt;q-&gt;q.qlen
op_eq
l_int|0
)paren
r_goto
id|skip_class
suffix:semicolon
r_if
c_cond
(paren
id|fallback
)paren
(brace
multiline_comment|/* Fallback pass: all classes are overlimit;&n;&t;&t;&t;&t;   we send from the first class that is allowed&n;&t;&t;&t;&t;   to borrow.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|cl-&gt;borrow
op_eq
l_int|NULL
)paren
r_goto
id|skip_class
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Normal pass: check that class is under limit */
r_if
c_cond
(paren
op_logical_neg
id|cbq_under_limit
c_func
(paren
id|cl
)paren
)paren
r_goto
id|skip_class
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cl-&gt;deficit
op_le
l_int|0
)paren
(brace
multiline_comment|/* Class exhausted its allotment per this&n;&t;&t;&t;&t;   round.&n;&t;&t;&t;&t; */
id|deficit
op_assign
l_int|1
suffix:semicolon
r_goto
id|next_class
suffix:semicolon
)brace
id|skb
op_assign
id|cl-&gt;q
op_member_access_from_pointer
id|dequeue
c_func
(paren
id|cl-&gt;q
)paren
suffix:semicolon
multiline_comment|/* Class did not give us any skb :-(&n;&t;&t;&t;   It could occur if cl-&gt;q == &quot;tbf&quot;&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_goto
id|skip_class
suffix:semicolon
id|cl-&gt;deficit
op_sub_assign
id|skb-&gt;len
suffix:semicolon
id|q-&gt;last_sent
op_assign
id|cl
suffix:semicolon
id|q-&gt;last_sent_len
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;deficit
op_le
l_int|0
)paren
(brace
id|q-&gt;active
(braket
id|prio
)braket
op_assign
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;next_alive
suffix:semicolon
id|cl-&gt;deficit
op_add_assign
id|cl-&gt;quantum
suffix:semicolon
)brace
r_return
id|skb
suffix:semicolon
id|skip_class
suffix:colon
id|cl-&gt;deficit
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;q-&gt;q.qlen
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Class is empty, declare it dead */
id|cl_prev-&gt;next_alive
op_assign
id|cl-&gt;next_alive
suffix:semicolon
id|cl-&gt;awake
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Did cl_tail point to it? */
r_if
c_cond
(paren
id|cl
op_eq
id|cl_tail
)paren
(brace
multiline_comment|/* Repair it! */
id|cl_tail
op_assign
id|cl_prev
suffix:semicolon
multiline_comment|/* Was it the last class in this band? */
r_if
c_cond
(paren
id|cl
op_eq
id|cl_tail
)paren
(brace
multiline_comment|/* Kill the band! */
id|q-&gt;active
(braket
id|prio
)braket
op_assign
l_int|NULL
suffix:semicolon
id|q-&gt;activemask
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|prio
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
id|next_class
suffix:colon
id|cl_prev
op_assign
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;next_alive
suffix:semicolon
id|cl-&gt;deficit
op_add_assign
id|cl-&gt;quantum
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cl_prev
op_ne
id|cl_tail
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|deficit
)paren
suffix:semicolon
id|q-&gt;active
(braket
id|prio
)braket
op_assign
id|cl_prev
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
id|__inline__
r_struct
id|sk_buff
op_star
DECL|function|cbq_dequeue_1
id|cbq_dequeue_1
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
id|fallback
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|activemask
suffix:semicolon
id|activemask
op_assign
id|q-&gt;activemask
suffix:semicolon
r_while
c_loop
(paren
id|activemask
)paren
(brace
r_int
id|prio
op_assign
id|ffz
c_func
(paren
op_complement
id|activemask
)paren
suffix:semicolon
id|activemask
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|prio
)paren
suffix:semicolon
id|skb
op_assign
id|cbq_dequeue_prio
c_func
(paren
id|sch
comma
id|prio
comma
id|fallback
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
r_return
id|skb
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_struct
id|sk_buff
op_star
DECL|function|cbq_dequeue
id|cbq_dequeue
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
id|PSCHED_GET_TIME
c_func
(paren
id|q-&gt;now
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;last_sent
)paren
id|cbq_update
c_func
(paren
id|q
)paren
suffix:semicolon
id|q-&gt;wd_expires
op_assign
l_int|0
suffix:semicolon
id|skb
op_assign
id|cbq_dequeue_1
c_func
(paren
id|sch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
r_return
id|skb
suffix:semicolon
multiline_comment|/* All the classes are overlimit.&n;&t;   Search for overlimit class, which is allowed to borrow&n;&t;   and use it as fallback case.&n;&t; */
macro_line|#ifdef CBQ_TOPLEVEL_SHARING
id|q-&gt;toplevel
op_assign
id|CBQ_MAXLEVEL
suffix:semicolon
macro_line|#endif
id|skb
op_assign
id|cbq_dequeue_1
c_func
(paren
id|sch
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
r_return
id|skb
suffix:semicolon
multiline_comment|/* No packets in scheduler or nobody wants to give them to us :-(&n;&t;   Sigh... start watchdog timer in the last case. */
r_if
c_cond
(paren
id|sch-&gt;q.qlen
op_logical_and
id|q-&gt;wd_expires
)paren
(brace
r_if
c_cond
(paren
id|q-&gt;wd_timer.function
)paren
id|del_timer
c_func
(paren
op_amp
id|q-&gt;wd_timer
)paren
suffix:semicolon
id|q-&gt;wd_timer.function
op_assign
id|cbq_watchdog
suffix:semicolon
id|q-&gt;wd_timer.expires
op_assign
id|jiffies
op_plus
id|PSCHED_US2JIFFIE
c_func
(paren
id|q-&gt;wd_expires
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|q-&gt;wd_timer
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* CBQ class maintanance routines */
DECL|function|cbq_adjust_levels
r_static
r_void
id|cbq_adjust_levels
c_func
(paren
r_struct
id|cbq_class
op_star
id|this
)paren
(brace
r_struct
id|cbq_class
op_star
id|cl
suffix:semicolon
r_for
c_loop
(paren
id|cl
op_assign
id|this-&gt;parent
suffix:semicolon
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;parent
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;level
OG
id|this-&gt;level
)paren
r_return
suffix:semicolon
id|cl-&gt;level
op_assign
id|this-&gt;level
op_plus
l_int|1
suffix:semicolon
id|this
op_assign
id|cl
suffix:semicolon
)brace
)brace
DECL|function|cbq_normalize_quanta
r_static
r_void
id|cbq_normalize_quanta
c_func
(paren
r_struct
id|cbq_sched_data
op_star
id|q
comma
r_int
id|prio
)paren
(brace
r_struct
id|cbq_class
op_star
id|cl
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;quanta
(braket
id|prio
)braket
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|cl
op_assign
id|q-&gt;classes
(braket
id|prio
)braket
suffix:semicolon
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;rquantum
)paren
id|cl-&gt;quantum
op_assign
(paren
id|cl-&gt;rquantum
op_star
id|q-&gt;mtu
op_star
id|q-&gt;nclasses
(braket
id|prio
)braket
)paren
op_div
id|q-&gt;quanta
(braket
id|prio
)braket
suffix:semicolon
)brace
)brace
DECL|function|cbq_unlink_class
r_static
id|__inline__
r_int
id|cbq_unlink_class
c_func
(paren
r_struct
id|cbq_class
op_star
id|this
)paren
(brace
r_struct
id|cbq_class
op_star
id|cl
comma
op_star
op_star
id|clp
suffix:semicolon
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|this-&gt;qdisc-&gt;data
suffix:semicolon
r_for
c_loop
(paren
id|clp
op_assign
op_amp
id|q-&gt;classes
(braket
id|this-&gt;priority
)braket
suffix:semicolon
(paren
id|cl
op_assign
op_star
id|clp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|clp
op_assign
op_amp
id|cl-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cl
op_eq
id|this
)paren
(brace
op_star
id|clp
op_assign
id|cl-&gt;next
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
DECL|function|cbq_prune
r_static
r_int
id|cbq_prune
c_func
(paren
r_struct
id|cbq_class
op_star
id|this
)paren
(brace
r_struct
id|cbq_class
op_star
id|cl
suffix:semicolon
r_int
id|prio
op_assign
id|this-&gt;priority
suffix:semicolon
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|this-&gt;qdisc-&gt;data
suffix:semicolon
id|qdisc_reset
c_func
(paren
id|this-&gt;q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cbq_unlink_class
c_func
(paren
id|this
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;awake
)paren
(brace
r_struct
id|cbq_class
op_star
id|cl_prev
op_assign
id|q-&gt;active
(braket
id|prio
)braket
suffix:semicolon
r_do
(brace
id|cl
op_assign
id|cl_prev-&gt;next_alive
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
id|this
)paren
(brace
id|cl_prev-&gt;next_alive
op_assign
id|cl-&gt;next_alive
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
id|q-&gt;active
(braket
id|prio
)braket
)paren
(brace
id|q-&gt;active
(braket
id|prio
)braket
op_assign
id|cl
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
id|q-&gt;active
(braket
id|prio
)braket
)paren
(brace
id|q-&gt;active
(braket
id|prio
)braket
op_assign
l_int|NULL
suffix:semicolon
id|q-&gt;activemask
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|prio
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|cl
op_assign
id|cl-&gt;next_alive
suffix:semicolon
id|cl-&gt;deficit
op_add_assign
id|cl-&gt;quantum
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|cl_prev
op_assign
id|cl
)paren
op_ne
id|q-&gt;active
(braket
id|prio
)braket
)paren
suffix:semicolon
)brace
op_decrement
id|q-&gt;nclasses
(braket
id|prio
)braket
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;rquantum
)paren
(brace
id|q-&gt;quanta
(braket
id|prio
)braket
op_sub_assign
id|this-&gt;rquantum
suffix:semicolon
id|cbq_normalize_quanta
c_func
(paren
id|q
comma
id|prio
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|q-&gt;fallback_class
op_eq
id|this
)paren
id|q-&gt;fallback_class
op_assign
l_int|NULL
suffix:semicolon
id|this-&gt;parent
op_assign
l_int|NULL
suffix:semicolon
id|this-&gt;borrow
op_assign
l_int|NULL
suffix:semicolon
id|this-&gt;root
op_assign
id|this
suffix:semicolon
id|this-&gt;qdisc
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cbq_graft
r_static
r_int
id|cbq_graft
c_func
(paren
r_struct
id|cbq_class
op_star
id|this
comma
r_struct
id|cbq_class
op_star
id|parent
)paren
(brace
r_struct
id|cbq_class
op_star
id|cl
comma
op_star
op_star
id|clp
suffix:semicolon
r_int
id|prio
op_assign
id|this-&gt;priority
suffix:semicolon
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|this-&gt;qdisc-&gt;data
suffix:semicolon
id|qdisc_reset
c_func
(paren
id|this-&gt;q
)paren
suffix:semicolon
r_for
c_loop
(paren
id|clp
op_assign
op_amp
id|q-&gt;classes
(braket
id|prio
)braket
suffix:semicolon
(paren
id|cl
op_assign
op_star
id|clp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|clp
op_assign
op_amp
id|cl-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cl
op_eq
id|this
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|cl-&gt;next
op_assign
l_int|NULL
suffix:semicolon
op_star
id|clp
op_assign
id|cl
suffix:semicolon
id|cl-&gt;parent
op_assign
id|parent
suffix:semicolon
id|cl-&gt;borrow
op_assign
id|parent
suffix:semicolon
id|cl-&gt;root
op_assign
id|parent
ques
c_cond
id|parent-&gt;root
suffix:colon
id|cl
suffix:semicolon
op_increment
id|q-&gt;nclasses
(braket
id|prio
)braket
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;rquantum
)paren
(brace
id|q-&gt;quanta
(braket
id|prio
)braket
op_add_assign
id|this-&gt;rquantum
suffix:semicolon
id|cbq_normalize_quanta
c_func
(paren
id|q
comma
id|prio
)paren
suffix:semicolon
)brace
id|cbq_adjust_levels
c_func
(paren
id|this
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|cbq_reset
id|cbq_reset
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
suffix:semicolon
r_int
id|prio
suffix:semicolon
id|q-&gt;activemask
op_assign
l_int|0
suffix:semicolon
id|q-&gt;last_sent
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;wd_timer.function
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|q-&gt;wd_timer
)paren
suffix:semicolon
id|q-&gt;wd_timer.expires
op_assign
l_int|0
suffix:semicolon
id|q-&gt;wd_timer.function
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CBQ_TOPLEVEL_SHARING
id|q-&gt;toplevel
op_assign
id|CBQ_MAXLEVEL
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|prio
op_assign
l_int|0
suffix:semicolon
id|prio
OL
id|CBQ_MAXPRIO
suffix:semicolon
id|prio
op_increment
)paren
(brace
id|q-&gt;active
(braket
id|prio
)braket
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|cl
op_assign
id|q-&gt;classes
(braket
id|prio
)braket
suffix:semicolon
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;next
)paren
(brace
id|qdisc_reset
c_func
(paren
id|cl-&gt;q
)paren
suffix:semicolon
id|cl-&gt;next_alive
op_assign
l_int|NULL
suffix:semicolon
id|PSCHED_SET_PASTPERFECT
c_func
(paren
id|cl-&gt;undertime
)paren
suffix:semicolon
id|cl-&gt;avgidle
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;deficit
op_assign
l_int|0
suffix:semicolon
id|cl-&gt;awake
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
DECL|function|cbq_destroy
id|cbq_destroy
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
comma
op_star
op_star
id|clp
suffix:semicolon
r_int
id|prio
suffix:semicolon
r_for
c_loop
(paren
id|prio
op_assign
l_int|0
suffix:semicolon
id|prio
OL
id|CBQ_MAXPRIO
suffix:semicolon
id|prio
op_increment
)paren
(brace
r_struct
id|cbq_class
op_star
id|cl_head
op_assign
id|q-&gt;classes
(braket
id|prio
)braket
suffix:semicolon
r_for
c_loop
(paren
id|clp
op_assign
op_amp
id|cl_head
suffix:semicolon
(paren
id|cl
op_assign
op_star
id|clp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|clp
op_assign
op_amp
id|cl-&gt;next
)paren
(brace
id|qdisc_destroy
c_func
(paren
id|cl-&gt;q
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cl
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|cbq_control
r_static
r_int
id|cbq_control
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
suffix:semicolon
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
multiline_comment|/* Do attachment here. It is the last thing to do. */
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|cbq_init
r_static
r_int
id|cbq_init
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
suffix:semicolon
r_struct
id|cbqctl
op_star
id|ctl
op_assign
(paren
r_struct
id|cbqctl
op_star
)paren
id|arg
suffix:semicolon
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|q-&gt;wd_timer
)paren
suffix:semicolon
id|q-&gt;wd_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sch
suffix:semicolon
macro_line|#ifdef CBQ_TOPLEVEL_SHARING
id|q-&gt;toplevel
op_assign
id|CBQ_MAXLEVEL
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|cbq_ops
r_struct
id|Qdisc_ops
id|cbq_ops
op_assign
(brace
l_int|NULL
comma
l_string|&quot;cbq&quot;
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cbq_sched_data
)paren
comma
id|cbq_enqueue
comma
id|cbq_dequeue
comma
id|cbq_reset
comma
id|cbq_destroy
comma
id|cbq_init
comma
id|cbq_control
comma
)brace
suffix:semicolon
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
multiline_comment|/* Load once and never free it. */
id|MOD_INC_USE_COUNT
suffix:semicolon
id|err
op_assign
id|register_qdisc
c_func
(paren
op_amp
id|cbq_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
)brace
macro_line|#endif
eof
