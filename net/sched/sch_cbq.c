multiline_comment|/*&n; * net/sched/sch_cbq.c&t;Class-Based Queueing discipline.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; * Authors:&t;Alexey Kuznetsov, &lt;kuznet@ms2.inr.ac.ru&gt;&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/pkt_sched.h&gt;
multiline_comment|/*&t;Class-Based Queueing (CBQ) algorithm.&n;&t;=======================================&n;&n;&t;Sources: [1] Sally Floyd and Van Jacobson, &quot;Link-sharing and Resource&n;&t;         Management Models for Packet Networks&quot;,&n;&t;&t; IEEE/ACM Transactions on Networking, Vol.3, No.4, 1995&n;&n;&t;         [2] Sally Floyd, &quot;Notes on CBQ and Guaranted Service&quot;, 1995&n;&n;&t;         [3] Sally Floyd, &quot;Notes on Class-Based Queueing: Setting&n;&t;&t; Parameters&quot;, 1996&n;&n;&t;&t; [4] Sally Floyd and Michael Speer, &quot;Experimental Results&n;&t;&t; for Class-Based Queueing&quot;, 1998, not published.&n;&n;&t;-----------------------------------------------------------------------&n;&n;&t;Algorithm skeleton was taken from NS simulator cbq.cc.&n;&t;If someone wants to check this code against the LBL version,&n;&t;he should take into account that ONLY the skeleton was borrowed,&n;&t;the implementation is different. Particularly:&n;&n;&t;--- The WRR algorithm is different. Our version looks more&n;        reasonable (I hope) and works when quanta are allowed to be&n;        less than MTU, which is always the case when real time classes&n;        have small rates. Note, that the statement of [3] is&n;        incomplete, delay may actually be estimated even if class&n;        per-round allotment is less than MTU. Namely, if per-round&n;        allotment is W*r_i, and r_1+...+r_k = r &lt; 1&n;&n;&t;delay_i &lt;= ([MTU/(W*r_i)]*W*r + W*r + k*MTU)/B&n;&n;&t;In the worst case we have IntServ estimate with D = W*r+k*MTU&n;&t;and C = MTU*r. The proof (if correct at all) is trivial.&n;&n;&n;&t;--- It seems that cbq-2.0 is not very accurate. At least, I cannot&n;&t;interpret some places, which look like wrong translations&n;&t;from NS. Anyone is advised to find these differences&n;&t;and explain to me, why I am wrong 8).&n;&n;&t;--- Linux has no EOI event, so that we cannot estimate true class&n;&t;idle time. Workaround is to consider the next dequeue event&n;&t;as sign that previous packet is finished. This is wrong because of&n;&t;internal device queueing, but on a permanently loaded link it is true.&n;&t;Moreover, combined with clock integrator, this scheme looks&n;&t;very close to an ideal solution.  */
r_struct
id|cbq_sched_data
suffix:semicolon
DECL|struct|cbq_class
r_struct
id|cbq_class
(brace
DECL|member|next
r_struct
id|cbq_class
op_star
id|next
suffix:semicolon
multiline_comment|/* hash table link */
DECL|member|next_alive
r_struct
id|cbq_class
op_star
id|next_alive
suffix:semicolon
multiline_comment|/* next class with backlog in this priority band */
multiline_comment|/* Parameters */
DECL|member|classid
id|u32
id|classid
suffix:semicolon
DECL|member|priority
r_int
r_char
id|priority
suffix:semicolon
multiline_comment|/* class priority */
DECL|member|priority2
r_int
r_char
id|priority2
suffix:semicolon
multiline_comment|/* priority to be used after overlimit */
DECL|member|ewma_log
r_int
r_char
id|ewma_log
suffix:semicolon
multiline_comment|/* time constant for idle time calculation */
DECL|member|ovl_strategy
r_int
r_char
id|ovl_strategy
suffix:semicolon
macro_line|#ifdef CONFIG_NET_CLS_POLICE
DECL|member|police
r_int
r_char
id|police
suffix:semicolon
macro_line|#endif
DECL|member|defmap
id|u32
id|defmap
suffix:semicolon
multiline_comment|/* Link-sharing scheduler parameters */
DECL|member|maxidle
r_int
id|maxidle
suffix:semicolon
multiline_comment|/* Class paramters: see below. */
DECL|member|offtime
r_int
id|offtime
suffix:semicolon
DECL|member|minidle
r_int
id|minidle
suffix:semicolon
DECL|member|avpkt
id|u32
id|avpkt
suffix:semicolon
DECL|member|R_tab
r_struct
id|qdisc_rate_table
op_star
id|R_tab
suffix:semicolon
multiline_comment|/* Overlimit strategy parameters */
DECL|member|overlimit
r_void
(paren
op_star
id|overlimit
)paren
(paren
r_struct
id|cbq_class
op_star
id|cl
)paren
suffix:semicolon
DECL|member|penalty
r_int
id|penalty
suffix:semicolon
multiline_comment|/* General scheduler (WRR) parameters */
DECL|member|allot
r_int
id|allot
suffix:semicolon
DECL|member|quantum
r_int
id|quantum
suffix:semicolon
multiline_comment|/* Allotment per WRR round */
DECL|member|weight
r_int
id|weight
suffix:semicolon
multiline_comment|/* Relative allotment: see below */
DECL|member|qdisc
r_struct
id|Qdisc
op_star
id|qdisc
suffix:semicolon
multiline_comment|/* Ptr to CBQ discipline */
DECL|member|split
r_struct
id|cbq_class
op_star
id|split
suffix:semicolon
multiline_comment|/* Ptr to split node */
DECL|member|share
r_struct
id|cbq_class
op_star
id|share
suffix:semicolon
multiline_comment|/* Ptr to LS parent in the class tree */
DECL|member|tparent
r_struct
id|cbq_class
op_star
id|tparent
suffix:semicolon
multiline_comment|/* Ptr to tree parent in the class tree */
DECL|member|borrow
r_struct
id|cbq_class
op_star
id|borrow
suffix:semicolon
multiline_comment|/* NULL if class is bandwidth limited;&n;&t;&t;&t;&t;&t;&t;   parent otherwise */
DECL|member|sibling
r_struct
id|cbq_class
op_star
id|sibling
suffix:semicolon
multiline_comment|/* Sibling chain */
DECL|member|children
r_struct
id|cbq_class
op_star
id|children
suffix:semicolon
multiline_comment|/* Pointer to children chain */
DECL|member|q
r_struct
id|Qdisc
op_star
id|q
suffix:semicolon
multiline_comment|/* Elementary queueing discipline */
multiline_comment|/* Variables */
DECL|member|cpriority
r_int
r_char
id|cpriority
suffix:semicolon
multiline_comment|/* Effective priority */
DECL|member|delayed
r_int
r_char
id|delayed
suffix:semicolon
DECL|member|level
r_int
r_char
id|level
suffix:semicolon
multiline_comment|/* level of the class in hierarchy:&n;&t;&t;&t;&t;&t;&t;   0 for leaf classes, and maximal&n;&t;&t;&t;&t;&t;&t;   level of children + 1 for nodes.&n;&t;&t;&t;&t;&t;&t; */
DECL|member|last
id|psched_time_t
id|last
suffix:semicolon
multiline_comment|/* Last end of service */
DECL|member|undertime
id|psched_time_t
id|undertime
suffix:semicolon
DECL|member|avgidle
r_int
id|avgidle
suffix:semicolon
DECL|member|deficit
r_int
id|deficit
suffix:semicolon
multiline_comment|/* Saved deficit for WRR */
DECL|member|penalized
r_int
r_int
id|penalized
suffix:semicolon
DECL|member|stats
r_struct
id|tc_stats
id|stats
suffix:semicolon
DECL|member|xstats
r_struct
id|tc_cbq_xstats
id|xstats
suffix:semicolon
DECL|member|filter_list
r_struct
id|tcf_proto
op_star
id|filter_list
suffix:semicolon
DECL|member|refcnt
r_int
id|refcnt
suffix:semicolon
DECL|member|filters
r_int
id|filters
suffix:semicolon
DECL|member|defaults
r_struct
id|cbq_class
op_star
id|defaults
(braket
id|TC_PRIO_MAX
op_plus
l_int|1
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|cbq_sched_data
r_struct
id|cbq_sched_data
(brace
DECL|member|classes
r_struct
id|cbq_class
op_star
id|classes
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Hash table of all classes */
DECL|member|nclasses
r_int
id|nclasses
(braket
id|TC_CBQ_MAXPRIO
op_plus
l_int|1
)braket
suffix:semicolon
DECL|member|quanta
r_int
id|quanta
(braket
id|TC_CBQ_MAXPRIO
op_plus
l_int|1
)braket
suffix:semicolon
DECL|member|link
r_struct
id|cbq_class
id|link
suffix:semicolon
DECL|member|activemask
r_int
id|activemask
suffix:semicolon
DECL|member|active
r_struct
id|cbq_class
op_star
id|active
(braket
id|TC_CBQ_MAXPRIO
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* List of all classes&n;&t;&t;&t;&t;&t;&t;&t;&t;   with backlog */
macro_line|#ifdef CONFIG_NET_CLS_POLICE
DECL|member|rx_class
r_struct
id|cbq_class
op_star
id|rx_class
suffix:semicolon
macro_line|#endif
DECL|member|tx_class
r_struct
id|cbq_class
op_star
id|tx_class
suffix:semicolon
DECL|member|tx_borrowed
r_struct
id|cbq_class
op_star
id|tx_borrowed
suffix:semicolon
DECL|member|tx_len
r_int
id|tx_len
suffix:semicolon
DECL|member|now
id|psched_time_t
id|now
suffix:semicolon
multiline_comment|/* Cached timestamp */
DECL|member|now_rt
id|psched_time_t
id|now_rt
suffix:semicolon
multiline_comment|/* Cached real time */
DECL|member|pmask
r_int
id|pmask
suffix:semicolon
DECL|member|delay_timer
r_struct
id|timer_list
id|delay_timer
suffix:semicolon
DECL|member|wd_timer
r_struct
id|timer_list
id|wd_timer
suffix:semicolon
multiline_comment|/* Watchdog timer,&n;&t;&t;&t;&t;&t;&t;   started when CBQ has&n;&t;&t;&t;&t;&t;&t;   backlog, but cannot&n;&t;&t;&t;&t;&t;&t;   transmit just now */
DECL|member|wd_expires
r_int
id|wd_expires
suffix:semicolon
DECL|member|toplevel
r_int
id|toplevel
suffix:semicolon
DECL|member|hgenerator
id|u32
id|hgenerator
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|L2T
mdefine_line|#define L2T(cl,len)&t;((cl)-&gt;R_tab-&gt;data[(len)&gt;&gt;(cl)-&gt;R_tab-&gt;rate.cell_log])
DECL|function|cbq_hash
r_static
id|__inline__
r_int
id|cbq_hash
c_func
(paren
id|u32
id|h
)paren
(brace
id|h
op_xor_assign
id|h
op_rshift
l_int|8
suffix:semicolon
id|h
op_xor_assign
id|h
op_rshift
l_int|4
suffix:semicolon
r_return
id|h
op_amp
l_int|0xF
suffix:semicolon
)brace
r_static
id|__inline__
r_struct
id|cbq_class
op_star
DECL|function|cbq_class_lookup
id|cbq_class_lookup
c_func
(paren
r_struct
id|cbq_sched_data
op_star
id|q
comma
id|u32
id|classid
)paren
(brace
r_struct
id|cbq_class
op_star
id|cl
suffix:semicolon
r_for
c_loop
(paren
id|cl
op_assign
id|q-&gt;classes
(braket
id|cbq_hash
c_func
(paren
id|classid
)paren
)braket
suffix:semicolon
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;next
)paren
r_if
c_cond
(paren
id|cl-&gt;classid
op_eq
id|classid
)paren
r_return
id|cl
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_CLS_POLICE
r_static
r_struct
id|cbq_class
op_star
DECL|function|cbq_reclassify
id|cbq_reclassify
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|cbq_class
op_star
id|this
)paren
(brace
r_struct
id|cbq_class
op_star
id|cl
comma
op_star
r_new
suffix:semicolon
r_for
c_loop
(paren
id|cl
op_assign
id|this-&gt;tparent
suffix:semicolon
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;tparent
)paren
r_if
c_cond
(paren
(paren
r_new
op_assign
id|cl-&gt;defaults
(braket
id|TC_PRIO_BESTEFFORT
)braket
)paren
op_ne
l_int|NULL
op_logical_and
r_new
op_ne
id|this
)paren
r_return
r_new
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Classify packet. The procedure is pretty complicated, but&n;   it allows us to combine link sharing and priority scheduling&n;   transparently.&n;&n;   Namely, you can put link sharing rules (f.e. route based) at root of CBQ,&n;   so that it resolves to split nodes. Then packets are classified&n;   by logical priority, or a more specific classifier may be attached&n;   to the split node.&n; */
r_static
r_struct
id|cbq_class
op_star
DECL|function|cbq_classify
id|cbq_classify
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|head
op_assign
op_amp
id|q-&gt;link
suffix:semicolon
r_struct
id|cbq_class
op_star
op_star
id|defmap
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
op_assign
l_int|NULL
suffix:semicolon
id|u32
id|prio
op_assign
id|skb-&gt;priority
suffix:semicolon
r_struct
id|tcf_result
id|res
suffix:semicolon
multiline_comment|/*&n;&t; *  Step 1. If skb-&gt;priority points to one of our classes, use it.&n;&t; */
r_if
c_cond
(paren
id|TC_H_MAJ
c_func
(paren
id|prio
op_xor
id|sch-&gt;handle
)paren
op_eq
l_int|0
op_logical_and
(paren
id|cl
op_assign
id|cbq_class_lookup
c_func
(paren
id|q
comma
id|prio
)paren
)paren
op_ne
l_int|NULL
)paren
r_return
id|cl
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|defmap
op_assign
id|head-&gt;defaults
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Step 2+n. Apply classifier.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|head-&gt;filter_list
op_logical_or
(paren
id|result
op_assign
id|tc_classify
c_func
(paren
id|skb
comma
id|head-&gt;filter_list
comma
op_amp
id|res
)paren
)paren
OL
l_int|0
)paren
r_goto
id|fallback
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cl
op_assign
(paren
r_void
op_star
)paren
id|res
dot
r_class
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|TC_H_MAJ
c_func
(paren
id|res.classid
)paren
)paren
id|cl
op_assign
id|cbq_class_lookup
c_func
(paren
id|q
comma
id|res.classid
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|cl
op_assign
id|defmap
(braket
id|res.classid
op_amp
id|TC_PRIO_MAX
)braket
)paren
op_eq
l_int|NULL
)paren
id|cl
op_assign
id|defmap
(braket
id|TC_PRIO_BESTEFFORT
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
l_int|NULL
op_logical_or
id|cl-&gt;level
op_ge
id|head-&gt;level
)paren
r_goto
id|fallback
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_CLS_POLICE
r_switch
c_cond
(paren
id|result
)paren
(brace
r_case
id|TC_POLICE_RECLASSIFY
suffix:colon
r_return
id|cbq_reclassify
c_func
(paren
id|skb
comma
id|cl
)paren
suffix:semicolon
r_case
id|TC_POLICE_SHOT
suffix:colon
r_return
l_int|NULL
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|cl-&gt;level
op_eq
l_int|0
)paren
r_return
id|cl
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Step 3+n. If classifier selected a link sharing class,&n;&t;&t; *&t;   apply agency specific classifier.&n;&t;&t; *&t;   Repeat this procdure until we hit a leaf node.&n;&t;&t; */
id|head
op_assign
id|cl
suffix:semicolon
)brace
id|fallback
suffix:colon
id|cl
op_assign
id|head
suffix:semicolon
multiline_comment|/*&n;&t; * Step 4. No success...&n;&t; */
r_if
c_cond
(paren
id|TC_H_MAJ
c_func
(paren
id|prio
)paren
op_eq
l_int|0
op_logical_and
op_logical_neg
(paren
id|cl
op_assign
id|head-&gt;defaults
(braket
id|prio
op_amp
id|TC_PRIO_MAX
)braket
)paren
op_logical_and
op_logical_neg
(paren
id|cl
op_assign
id|head-&gt;defaults
(braket
id|TC_PRIO_BESTEFFORT
)braket
)paren
)paren
r_return
id|head
suffix:semicolon
r_return
id|cl
suffix:semicolon
)brace
multiline_comment|/*&n;   A packet has just been enqueued on the empty class.&n;   cbq_activate_class adds it to the tail of active class list&n;   of its priority band.&n; */
DECL|function|cbq_activate_class
r_static
id|__inline__
r_void
id|cbq_activate_class
c_func
(paren
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|cl-&gt;qdisc-&gt;data
suffix:semicolon
r_int
id|prio
op_assign
id|cl-&gt;cpriority
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl_tail
suffix:semicolon
id|cl_tail
op_assign
id|q-&gt;active
(braket
id|prio
)braket
suffix:semicolon
id|q-&gt;active
(braket
id|prio
)braket
op_assign
id|cl
suffix:semicolon
r_if
c_cond
(paren
id|cl_tail
op_ne
l_int|NULL
)paren
(brace
id|cl-&gt;next_alive
op_assign
id|cl_tail-&gt;next_alive
suffix:semicolon
id|cl_tail-&gt;next_alive
op_assign
id|cl
suffix:semicolon
)brace
r_else
(brace
id|cl-&gt;next_alive
op_assign
id|cl
suffix:semicolon
id|q-&gt;activemask
op_or_assign
(paren
l_int|1
op_lshift
id|prio
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   Unlink class from active chain.&n;   Note that this same procedure is done directly in cbq_dequeue*&n;   during round-robin procedure.&n; */
DECL|function|cbq_deactivate_class
r_static
r_void
id|cbq_deactivate_class
c_func
(paren
r_struct
id|cbq_class
op_star
id|this
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|this-&gt;qdisc-&gt;data
suffix:semicolon
r_int
id|prio
op_assign
id|this-&gt;cpriority
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl_prev
op_assign
id|q-&gt;active
(braket
id|prio
)braket
suffix:semicolon
r_do
(brace
id|cl
op_assign
id|cl_prev-&gt;next_alive
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
id|this
)paren
(brace
id|cl_prev-&gt;next_alive
op_assign
id|cl-&gt;next_alive
suffix:semicolon
id|cl-&gt;next_alive
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
id|q-&gt;active
(braket
id|prio
)braket
)paren
(brace
id|q-&gt;active
(braket
id|prio
)braket
op_assign
id|cl_prev
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
id|q-&gt;active
(braket
id|prio
)braket
)paren
(brace
id|q-&gt;active
(braket
id|prio
)braket
op_assign
l_int|NULL
suffix:semicolon
id|q-&gt;activemask
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|prio
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|cl
op_assign
id|cl_prev-&gt;next_alive
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|cl_prev
op_assign
id|cl
)paren
op_ne
id|q-&gt;active
(braket
id|prio
)braket
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|cbq_mark_toplevel
id|cbq_mark_toplevel
c_func
(paren
r_struct
id|cbq_sched_data
op_star
id|q
comma
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_int
id|toplevel
op_assign
id|q-&gt;toplevel
suffix:semicolon
r_if
c_cond
(paren
id|toplevel
OG
id|cl-&gt;level
op_logical_and
op_logical_neg
(paren
id|cl-&gt;q-&gt;flags
op_amp
id|TCQ_F_THROTTLED
)paren
)paren
(brace
id|psched_time_t
id|now
suffix:semicolon
id|psched_tdiff_t
id|incr
suffix:semicolon
id|PSCHED_GET_TIME
c_func
(paren
id|now
)paren
suffix:semicolon
id|incr
op_assign
id|PSCHED_TDIFF
c_func
(paren
id|now
comma
id|q-&gt;now_rt
)paren
suffix:semicolon
id|PSCHED_TADD2
c_func
(paren
id|q-&gt;now
comma
id|incr
comma
id|now
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|PSCHED_TLESS
c_func
(paren
id|cl-&gt;undertime
comma
id|now
)paren
)paren
(brace
id|q-&gt;toplevel
op_assign
id|cl-&gt;level
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|cl
op_assign
id|cl-&gt;borrow
)paren
op_ne
l_int|NULL
op_logical_and
id|toplevel
OG
id|cl-&gt;level
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|cbq_enqueue
id|cbq_enqueue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
op_assign
id|cbq_classify
c_func
(paren
id|skb
comma
id|sch
)paren
suffix:semicolon
r_int
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
r_int
id|ret
op_assign
id|NET_XMIT_POLICED
suffix:semicolon
macro_line|#ifdef CONFIG_NET_CLS_POLICE
id|q-&gt;rx_class
op_assign
id|cl
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cl
)paren
(brace
macro_line|#ifdef CONFIG_NET_CLS_POLICE
id|cl-&gt;q-&gt;__parent
op_assign
id|sch
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cl-&gt;q
op_member_access_from_pointer
id|enqueue
c_func
(paren
id|skb
comma
id|cl-&gt;q
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|sch-&gt;q.qlen
op_increment
suffix:semicolon
id|sch-&gt;stats.packets
op_increment
suffix:semicolon
id|sch-&gt;stats.bytes
op_add_assign
id|len
suffix:semicolon
id|cbq_mark_toplevel
c_func
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cl-&gt;next_alive
)paren
id|cbq_activate_class
c_func
(paren
id|cl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|sch-&gt;stats.drops
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
l_int|NULL
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_else
(brace
id|cbq_mark_toplevel
c_func
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
id|cl-&gt;stats.drops
op_increment
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|cbq_requeue
id|cbq_requeue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cl
op_assign
id|q-&gt;tx_class
)paren
op_eq
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|sch-&gt;stats.drops
op_increment
suffix:semicolon
r_return
id|NET_XMIT_CN
suffix:semicolon
)brace
id|q-&gt;tx_class
op_assign
l_int|NULL
suffix:semicolon
id|cbq_mark_toplevel
c_func
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_CLS_POLICE
id|q-&gt;rx_class
op_assign
id|cl
suffix:semicolon
id|cl-&gt;q-&gt;__parent
op_assign
id|sch
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cl-&gt;q-&gt;ops
op_member_access_from_pointer
id|requeue
c_func
(paren
id|skb
comma
id|cl-&gt;q
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|sch-&gt;q.qlen
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cl-&gt;next_alive
)paren
id|cbq_activate_class
c_func
(paren
id|cl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sch-&gt;stats.drops
op_increment
suffix:semicolon
id|cl-&gt;stats.drops
op_increment
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Overlimit actions */
multiline_comment|/* TC_CBQ_OVL_CLASSIC: (default) penalize leaf class by adding offtime */
DECL|function|cbq_ovl_classic
r_static
r_void
id|cbq_ovl_classic
c_func
(paren
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|cl-&gt;qdisc-&gt;data
suffix:semicolon
id|psched_tdiff_t
id|delay
op_assign
id|PSCHED_TDIFF
c_func
(paren
id|cl-&gt;undertime
comma
id|q-&gt;now
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cl-&gt;delayed
)paren
(brace
id|delay
op_add_assign
id|cl-&gt;offtime
suffix:semicolon
multiline_comment|/* &n;&t;&t;   Class goes to sleep, so that it will have no&n;&t;&t;   chance to work avgidle. Let&squot;s forgive it 8)&n;&n;&t;&t;   BTW cbq-2.0 has a crap in this&n;&t;&t;   place, apparently they forgot to shift it by cl-&gt;ewma_log.&n;&t;&t; */
r_if
c_cond
(paren
id|cl-&gt;avgidle
OL
l_int|0
)paren
id|delay
op_sub_assign
(paren
op_minus
id|cl-&gt;avgidle
)paren
op_minus
(paren
(paren
op_minus
id|cl-&gt;avgidle
)paren
op_rshift
id|cl-&gt;ewma_log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;avgidle
OL
id|cl-&gt;minidle
)paren
id|cl-&gt;avgidle
op_assign
id|cl-&gt;minidle
suffix:semicolon
r_if
c_cond
(paren
id|delay
op_le
l_int|0
)paren
id|delay
op_assign
l_int|1
suffix:semicolon
id|PSCHED_TADD2
c_func
(paren
id|q-&gt;now
comma
id|delay
comma
id|cl-&gt;undertime
)paren
suffix:semicolon
id|cl-&gt;xstats.overactions
op_increment
suffix:semicolon
id|cl-&gt;delayed
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|q-&gt;wd_expires
op_eq
l_int|0
op_logical_or
id|q-&gt;wd_expires
OG
id|delay
)paren
id|q-&gt;wd_expires
op_assign
id|delay
suffix:semicolon
multiline_comment|/* Dirty work! We must schedule wakeups based on&n;&t;   real available rate, rather than leaf rate,&n;&t;   which may be tiny (even zero).&n;&t; */
r_if
c_cond
(paren
id|q-&gt;toplevel
op_eq
id|TC_CBQ_MAXLEVEL
)paren
(brace
r_struct
id|cbq_class
op_star
id|b
suffix:semicolon
id|psched_tdiff_t
id|base_delay
op_assign
id|q-&gt;wd_expires
suffix:semicolon
r_for
c_loop
(paren
id|b
op_assign
id|cl-&gt;borrow
suffix:semicolon
id|b
suffix:semicolon
id|b
op_assign
id|b-&gt;borrow
)paren
(brace
id|delay
op_assign
id|PSCHED_TDIFF
c_func
(paren
id|b-&gt;undertime
comma
id|q-&gt;now
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delay
OL
id|base_delay
)paren
(brace
r_if
c_cond
(paren
id|delay
op_le
l_int|0
)paren
id|delay
op_assign
l_int|1
suffix:semicolon
id|base_delay
op_assign
id|delay
suffix:semicolon
)brace
)brace
id|q-&gt;wd_expires
op_assign
id|delay
suffix:semicolon
)brace
)brace
multiline_comment|/* TC_CBQ_OVL_RCLASSIC: penalize by offtime classes in hierarchy, when&n;   they go overlimit&n; */
DECL|function|cbq_ovl_rclassic
r_static
r_void
id|cbq_ovl_rclassic
c_func
(paren
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|cl-&gt;qdisc-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|this
op_assign
id|cl
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|cl-&gt;level
OG
id|q-&gt;toplevel
)paren
(brace
id|cl
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|cl
op_assign
id|cl-&gt;borrow
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
l_int|NULL
)paren
id|cl
op_assign
id|this
suffix:semicolon
id|cbq_ovl_classic
c_func
(paren
id|cl
)paren
suffix:semicolon
)brace
multiline_comment|/* TC_CBQ_OVL_DELAY: delay until it will go to underlimit */
DECL|function|cbq_ovl_delay
r_static
r_void
id|cbq_ovl_delay
c_func
(paren
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|cl-&gt;qdisc-&gt;data
suffix:semicolon
id|psched_tdiff_t
id|delay
op_assign
id|PSCHED_TDIFF
c_func
(paren
id|cl-&gt;undertime
comma
id|q-&gt;now
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cl-&gt;delayed
)paren
(brace
r_int
r_int
id|sched
op_assign
id|jiffies
suffix:semicolon
id|delay
op_add_assign
id|cl-&gt;offtime
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;avgidle
OL
l_int|0
)paren
id|delay
op_sub_assign
(paren
op_minus
id|cl-&gt;avgidle
)paren
op_minus
(paren
(paren
op_minus
id|cl-&gt;avgidle
)paren
op_rshift
id|cl-&gt;ewma_log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;avgidle
OL
id|cl-&gt;minidle
)paren
id|cl-&gt;avgidle
op_assign
id|cl-&gt;minidle
suffix:semicolon
id|PSCHED_TADD2
c_func
(paren
id|q-&gt;now
comma
id|delay
comma
id|cl-&gt;undertime
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delay
OG
l_int|0
)paren
(brace
id|sched
op_add_assign
id|PSCHED_US2JIFFIE
c_func
(paren
id|delay
)paren
op_plus
id|cl-&gt;penalty
suffix:semicolon
id|cl-&gt;penalized
op_assign
id|sched
suffix:semicolon
id|cl-&gt;cpriority
op_assign
id|TC_CBQ_MAXPRIO
suffix:semicolon
id|q-&gt;pmask
op_or_assign
(paren
l_int|1
op_lshift
id|TC_CBQ_MAXPRIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
id|q-&gt;delay_timer
)paren
op_logical_and
(paren
r_int
)paren
(paren
id|q-&gt;delay_timer.expires
op_minus
id|sched
)paren
OG
l_int|0
)paren
id|q-&gt;delay_timer.expires
op_assign
id|sched
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|q-&gt;delay_timer
)paren
suffix:semicolon
id|cl-&gt;delayed
op_assign
l_int|1
suffix:semicolon
id|cl-&gt;xstats.overactions
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|delay
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|q-&gt;wd_expires
op_eq
l_int|0
op_logical_or
id|q-&gt;wd_expires
OG
id|delay
)paren
id|q-&gt;wd_expires
op_assign
id|delay
suffix:semicolon
)brace
multiline_comment|/* TC_CBQ_OVL_LOWPRIO: penalize class by lowering its priority band */
DECL|function|cbq_ovl_lowprio
r_static
r_void
id|cbq_ovl_lowprio
c_func
(paren
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|cl-&gt;qdisc-&gt;data
suffix:semicolon
id|cl-&gt;penalized
op_assign
id|jiffies
op_plus
id|cl-&gt;penalty
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;cpriority
op_ne
id|cl-&gt;priority2
)paren
(brace
id|cl-&gt;cpriority
op_assign
id|cl-&gt;priority2
suffix:semicolon
id|q-&gt;pmask
op_or_assign
(paren
l_int|1
op_lshift
id|cl-&gt;cpriority
)paren
suffix:semicolon
id|cl-&gt;xstats.overactions
op_increment
suffix:semicolon
)brace
id|cbq_ovl_classic
c_func
(paren
id|cl
)paren
suffix:semicolon
)brace
multiline_comment|/* TC_CBQ_OVL_DROP: penalize class by dropping */
DECL|function|cbq_ovl_drop
r_static
r_void
id|cbq_ovl_drop
c_func
(paren
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;q-&gt;ops-&gt;drop
)paren
r_if
c_cond
(paren
id|cl-&gt;q-&gt;ops
op_member_access_from_pointer
id|drop
c_func
(paren
id|cl-&gt;q
)paren
)paren
id|cl-&gt;qdisc-&gt;q.qlen
op_decrement
suffix:semicolon
id|cl-&gt;xstats.overactions
op_increment
suffix:semicolon
id|cbq_ovl_classic
c_func
(paren
id|cl
)paren
suffix:semicolon
)brace
DECL|function|cbq_watchdog
r_static
r_void
id|cbq_watchdog
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|Qdisc
op_star
id|sch
op_assign
(paren
r_struct
id|Qdisc
op_star
)paren
id|arg
suffix:semicolon
id|sch-&gt;flags
op_and_assign
op_complement
id|TCQ_F_THROTTLED
suffix:semicolon
id|netif_schedule
c_func
(paren
id|sch-&gt;dev
)paren
suffix:semicolon
)brace
DECL|function|cbq_undelay_prio
r_static
r_int
r_int
id|cbq_undelay_prio
c_func
(paren
r_struct
id|cbq_sched_data
op_star
id|q
comma
r_int
id|prio
)paren
(brace
r_struct
id|cbq_class
op_star
id|cl
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl_prev
op_assign
id|q-&gt;active
(braket
id|prio
)braket
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_int
r_int
id|sched
op_assign
id|now
suffix:semicolon
r_if
c_cond
(paren
id|cl_prev
op_eq
l_int|NULL
)paren
r_return
id|now
suffix:semicolon
r_do
(brace
id|cl
op_assign
id|cl_prev-&gt;next_alive
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|now
op_minus
id|cl-&gt;penalized
)paren
OG
l_int|0
)paren
(brace
id|cl_prev-&gt;next_alive
op_assign
id|cl-&gt;next_alive
suffix:semicolon
id|cl-&gt;next_alive
op_assign
l_int|NULL
suffix:semicolon
id|cl-&gt;cpriority
op_assign
id|cl-&gt;priority
suffix:semicolon
id|cl-&gt;delayed
op_assign
l_int|0
suffix:semicolon
id|cbq_activate_class
c_func
(paren
id|cl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
id|q-&gt;active
(braket
id|prio
)braket
)paren
(brace
id|q-&gt;active
(braket
id|prio
)braket
op_assign
id|cl_prev
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
id|q-&gt;active
(braket
id|prio
)braket
)paren
(brace
id|q-&gt;active
(braket
id|prio
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|cl
op_assign
id|cl_prev-&gt;next_alive
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|sched
op_minus
id|cl-&gt;penalized
)paren
OG
l_int|0
)paren
id|sched
op_assign
id|cl-&gt;penalized
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|cl_prev
op_assign
id|cl
)paren
op_ne
id|q-&gt;active
(braket
id|prio
)braket
)paren
suffix:semicolon
r_return
(paren
r_int
)paren
(paren
id|sched
op_minus
id|now
)paren
suffix:semicolon
)brace
DECL|function|cbq_undelay
r_static
r_void
id|cbq_undelay
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|Qdisc
op_star
id|sch
op_assign
(paren
r_struct
id|Qdisc
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_int
id|delay
op_assign
l_int|0
suffix:semicolon
r_int
id|pmask
suffix:semicolon
id|pmask
op_assign
id|q-&gt;pmask
suffix:semicolon
id|q-&gt;pmask
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|pmask
)paren
(brace
r_int
id|prio
op_assign
id|ffz
c_func
(paren
op_complement
id|pmask
)paren
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|pmask
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|prio
)paren
suffix:semicolon
id|tmp
op_assign
id|cbq_undelay_prio
c_func
(paren
id|q
comma
id|prio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OG
l_int|0
)paren
(brace
id|q-&gt;pmask
op_or_assign
l_int|1
op_lshift
id|prio
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
id|delay
op_logical_or
id|delay
op_eq
l_int|0
)paren
id|delay
op_assign
id|tmp
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|delay
)paren
(brace
id|q-&gt;delay_timer.expires
op_assign
id|jiffies
op_plus
id|delay
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|q-&gt;delay_timer
)paren
suffix:semicolon
)brace
id|sch-&gt;flags
op_and_assign
op_complement
id|TCQ_F_THROTTLED
suffix:semicolon
id|netif_schedule
c_func
(paren
id|sch-&gt;dev
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_CLS_POLICE
DECL|function|cbq_reshape_fail
r_static
r_int
id|cbq_reshape_fail
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|child
)paren
(brace
r_int
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
r_struct
id|Qdisc
op_star
id|sch
op_assign
id|child-&gt;__parent
suffix:semicolon
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
op_assign
id|q-&gt;rx_class
suffix:semicolon
id|q-&gt;rx_class
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_logical_and
(paren
id|cl
op_assign
id|cbq_reclassify
c_func
(paren
id|skb
comma
id|cl
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|cbq_mark_toplevel
c_func
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
id|q-&gt;rx_class
op_assign
id|cl
suffix:semicolon
id|cl-&gt;q-&gt;__parent
op_assign
id|sch
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;q
op_member_access_from_pointer
id|enqueue
c_func
(paren
id|skb
comma
id|cl-&gt;q
)paren
op_eq
l_int|0
)paren
(brace
id|sch-&gt;q.qlen
op_increment
suffix:semicolon
id|sch-&gt;stats.packets
op_increment
suffix:semicolon
id|sch-&gt;stats.bytes
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cl-&gt;next_alive
)paren
id|cbq_activate_class
c_func
(paren
id|cl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sch-&gt;stats.drops
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sch-&gt;stats.drops
op_increment
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* &n;   It is mission critical procedure.&n;&n;   We &quot;regenerate&quot; toplevel cutoff, if transmitting class&n;   has backlog and it is not regulated. It is not part of&n;   original CBQ description, but looks more reasonable.&n;   Probably, it is wrong. This question needs further investigation.&n;*/
r_static
id|__inline__
r_void
DECL|function|cbq_update_toplevel
id|cbq_update_toplevel
c_func
(paren
r_struct
id|cbq_sched_data
op_star
id|q
comma
r_struct
id|cbq_class
op_star
id|cl
comma
r_struct
id|cbq_class
op_star
id|borrowed
)paren
(brace
r_if
c_cond
(paren
id|cl
op_logical_and
id|q-&gt;toplevel
op_ge
id|borrowed-&gt;level
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;q-&gt;q.qlen
OG
l_int|1
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
id|PSCHED_IS_PASTPERFECT
c_func
(paren
id|borrowed-&gt;undertime
)paren
)paren
(brace
id|q-&gt;toplevel
op_assign
id|borrowed-&gt;level
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|borrowed
op_assign
id|borrowed-&gt;borrow
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#if 0&t;
multiline_comment|/* It is not necessary now. Uncommenting it&n;&t;   will save CPU cycles, but decrease fairness.&n;&t; */
id|q-&gt;toplevel
op_assign
id|TC_CBQ_MAXLEVEL
suffix:semicolon
macro_line|#endif
)brace
)brace
r_static
r_void
DECL|function|cbq_update
id|cbq_update
c_func
(paren
r_struct
id|cbq_sched_data
op_star
id|q
)paren
(brace
r_struct
id|cbq_class
op_star
id|this
op_assign
id|q-&gt;tx_class
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
op_assign
id|this
suffix:semicolon
r_int
id|len
op_assign
id|q-&gt;tx_len
suffix:semicolon
id|q-&gt;tx_class
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;share
)paren
(brace
r_int
id|avgidle
op_assign
id|cl-&gt;avgidle
suffix:semicolon
r_int
id|idle
suffix:semicolon
id|cl-&gt;stats.packets
op_increment
suffix:semicolon
id|cl-&gt;stats.bytes
op_add_assign
id|len
suffix:semicolon
multiline_comment|/*&n;&t;&t;   (now - last) is total time between packet right edges.&n;&t;&t;   (last_pktlen/rate) is &quot;virtual&quot; busy time, so that&n;&n;&t;&t;         idle = (now - last) - last_pktlen/rate&n;&t;&t; */
id|idle
op_assign
id|PSCHED_TDIFF
c_func
(paren
id|q-&gt;now
comma
id|cl-&gt;last
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|idle
OG
l_int|128
op_star
l_int|1024
op_star
l_int|1024
)paren
(brace
id|avgidle
op_assign
id|cl-&gt;maxidle
suffix:semicolon
)brace
r_else
(brace
id|idle
op_sub_assign
id|L2T
c_func
(paren
id|cl
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* true_avgidle := (1-W)*true_avgidle + W*idle,&n;&t;&t;   where W=2^{-ewma_log}. But cl-&gt;avgidle is scaled:&n;&t;&t;   cl-&gt;avgidle == true_avgidle/W,&n;&t;&t;   hence:&n;&t;&t; */
id|avgidle
op_add_assign
id|idle
op_minus
(paren
id|avgidle
op_rshift
id|cl-&gt;ewma_log
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|avgidle
op_le
l_int|0
)paren
(brace
multiline_comment|/* Overlimit or at-limit */
r_if
c_cond
(paren
id|avgidle
OL
id|cl-&gt;minidle
)paren
id|avgidle
op_assign
id|cl-&gt;minidle
suffix:semicolon
id|cl-&gt;avgidle
op_assign
id|avgidle
suffix:semicolon
multiline_comment|/* Calculate expected time, when this class&n;&t;&t;&t;   will be allowed to send.&n;&t;&t;&t;   It will occur, when:&n;&t;&t;&t;   (1-W)*true_avgidle + W*delay = 0, i.e.&n;&t;&t;&t;   idle = (1/W - 1)*(-true_avgidle)&n;&t;&t;&t;   or&n;&t;&t;&t;   idle = (1 - W)*(-cl-&gt;avgidle);&n;&t;&t;&t; */
id|idle
op_assign
(paren
op_minus
id|avgidle
)paren
op_minus
(paren
(paren
op_minus
id|avgidle
)paren
op_rshift
id|cl-&gt;ewma_log
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;   That is not all.&n;&t;&t;&t;   To maintain the rate allocated to the class,&n;&t;&t;&t;   we add to undertime virtual clock,&n;&t;&t;&t;   necesary to complete transmitted packet.&n;&t;&t;&t;   (len/phys_bandwidth has been already passed&n;&t;&t;&t;   to the moment of cbq_update)&n;&t;&t;&t; */
id|idle
op_sub_assign
id|L2T
c_func
(paren
op_amp
id|q-&gt;link
comma
id|len
)paren
suffix:semicolon
id|idle
op_add_assign
id|L2T
c_func
(paren
id|cl
comma
id|len
)paren
suffix:semicolon
id|PSCHED_AUDIT_TDIFF
c_func
(paren
id|idle
)paren
suffix:semicolon
id|PSCHED_TADD2
c_func
(paren
id|q-&gt;now
comma
id|idle
comma
id|cl-&gt;undertime
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Underlimit */
id|PSCHED_SET_PASTPERFECT
c_func
(paren
id|cl-&gt;undertime
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avgidle
OG
id|cl-&gt;maxidle
)paren
id|cl-&gt;avgidle
op_assign
id|cl-&gt;maxidle
suffix:semicolon
r_else
id|cl-&gt;avgidle
op_assign
id|avgidle
suffix:semicolon
)brace
id|cl-&gt;last
op_assign
id|q-&gt;now
suffix:semicolon
)brace
id|cbq_update_toplevel
c_func
(paren
id|q
comma
id|this
comma
id|q-&gt;tx_borrowed
)paren
suffix:semicolon
)brace
r_static
id|__inline__
r_struct
id|cbq_class
op_star
DECL|function|cbq_under_limit
id|cbq_under_limit
c_func
(paren
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|cl-&gt;qdisc-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|this_cl
op_assign
id|cl
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;tparent
op_eq
l_int|NULL
)paren
r_return
id|cl
suffix:semicolon
r_if
c_cond
(paren
id|PSCHED_IS_PASTPERFECT
c_func
(paren
id|cl-&gt;undertime
)paren
op_logical_or
op_logical_neg
id|PSCHED_TLESS
c_func
(paren
id|q-&gt;now
comma
id|cl-&gt;undertime
)paren
)paren
(brace
id|cl-&gt;delayed
op_assign
l_int|0
suffix:semicolon
r_return
id|cl
suffix:semicolon
)brace
r_do
(brace
multiline_comment|/* It is very suspicious place. Now overlimit&n;&t;&t;   action is generated for not bounded classes&n;&t;&t;   only if link is completely congested.&n;&t;&t;   Though it is in agree with ancestor-only paradigm,&n;&t;&t;   it looks very stupid. Particularly,&n;&t;&t;   it means that this chunk of code will either&n;&t;&t;   never be called or result in strong amplification&n;&t;&t;   of burstiness. Dangerous, silly, and, however,&n;&t;&t;   no another solution exists.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|cl
op_assign
id|cl-&gt;borrow
)paren
op_eq
l_int|NULL
)paren
(brace
id|this_cl-&gt;stats.overlimits
op_increment
suffix:semicolon
id|this_cl
op_member_access_from_pointer
id|overlimit
c_func
(paren
id|this_cl
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cl-&gt;level
OG
id|q-&gt;toplevel
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|PSCHED_IS_PASTPERFECT
c_func
(paren
id|cl-&gt;undertime
)paren
op_logical_and
id|PSCHED_TLESS
c_func
(paren
id|q-&gt;now
comma
id|cl-&gt;undertime
)paren
)paren
suffix:semicolon
id|cl-&gt;delayed
op_assign
l_int|0
suffix:semicolon
r_return
id|cl
suffix:semicolon
)brace
r_static
id|__inline__
r_struct
id|sk_buff
op_star
DECL|function|cbq_dequeue_prio
id|cbq_dequeue_prio
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
id|prio
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl_tail
comma
op_star
id|cl_prev
comma
op_star
id|cl
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|deficit
suffix:semicolon
id|cl_tail
op_assign
id|cl_prev
op_assign
id|q-&gt;active
(braket
id|prio
)braket
suffix:semicolon
id|cl
op_assign
id|cl_prev-&gt;next_alive
suffix:semicolon
r_do
(brace
id|deficit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Start round */
r_do
(brace
r_struct
id|cbq_class
op_star
id|borrow
op_assign
id|cl
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;q-&gt;q.qlen
op_logical_and
(paren
id|borrow
op_assign
id|cbq_under_limit
c_func
(paren
id|cl
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|skip_class
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;deficit
op_le
l_int|0
)paren
(brace
multiline_comment|/* Class exhausted its allotment per&n;&t;&t;&t;&t;   this round. Switch to the next one.&n;&t;&t;&t;&t; */
id|deficit
op_assign
l_int|1
suffix:semicolon
id|cl-&gt;deficit
op_add_assign
id|cl-&gt;quantum
suffix:semicolon
r_goto
id|next_class
suffix:semicolon
)brace
id|skb
op_assign
id|cl-&gt;q
op_member_access_from_pointer
id|dequeue
c_func
(paren
id|cl-&gt;q
)paren
suffix:semicolon
multiline_comment|/* Class did not give us any skb :-(&n;&t;&t;&t;   It could occur even if cl-&gt;q-&gt;q.qlen != 0 &n;&t;&t;&t;   f.e. if cl-&gt;q == &quot;tbf&quot;&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_goto
id|skip_class
suffix:semicolon
id|cl-&gt;deficit
op_sub_assign
id|skb-&gt;len
suffix:semicolon
id|q-&gt;tx_class
op_assign
id|cl
suffix:semicolon
id|q-&gt;tx_borrowed
op_assign
id|borrow
suffix:semicolon
r_if
c_cond
(paren
id|borrow
op_ne
id|cl
)paren
(brace
macro_line|#ifndef CBQ_XSTATS_BORROWS_BYTES
id|borrow-&gt;xstats.borrows
op_increment
suffix:semicolon
id|cl-&gt;xstats.borrows
op_increment
suffix:semicolon
macro_line|#else
id|borrow-&gt;xstats.borrows
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|cl-&gt;xstats.borrows
op_add_assign
id|skb-&gt;len
suffix:semicolon
macro_line|#endif
)brace
id|q-&gt;tx_len
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;deficit
op_le
l_int|0
)paren
(brace
id|q-&gt;active
(braket
id|prio
)braket
op_assign
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;next_alive
suffix:semicolon
id|cl-&gt;deficit
op_add_assign
id|cl-&gt;quantum
suffix:semicolon
)brace
r_return
id|skb
suffix:semicolon
id|skip_class
suffix:colon
r_if
c_cond
(paren
id|cl-&gt;q-&gt;q.qlen
op_eq
l_int|0
op_logical_or
id|prio
op_ne
id|cl-&gt;cpriority
)paren
(brace
multiline_comment|/* Class is empty or penalized.&n;&t;&t;&t;&t;   Unlink it from active chain.&n;&t;&t;&t;&t; */
id|cl_prev-&gt;next_alive
op_assign
id|cl-&gt;next_alive
suffix:semicolon
id|cl-&gt;next_alive
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Did cl_tail point to it? */
r_if
c_cond
(paren
id|cl
op_eq
id|cl_tail
)paren
(brace
multiline_comment|/* Repair it! */
id|cl_tail
op_assign
id|cl_prev
suffix:semicolon
multiline_comment|/* Was it the last class in this band? */
r_if
c_cond
(paren
id|cl
op_eq
id|cl_tail
)paren
(brace
multiline_comment|/* Kill the band! */
id|q-&gt;active
(braket
id|prio
)braket
op_assign
l_int|NULL
suffix:semicolon
id|q-&gt;activemask
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|prio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;q-&gt;q.qlen
)paren
id|cbq_activate_class
c_func
(paren
id|cl
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|q-&gt;active
(braket
id|prio
)braket
op_assign
id|cl_tail
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cl-&gt;q-&gt;q.qlen
)paren
id|cbq_activate_class
c_func
(paren
id|cl
)paren
suffix:semicolon
id|cl
op_assign
id|cl_prev
suffix:semicolon
)brace
id|next_class
suffix:colon
id|cl_prev
op_assign
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;next_alive
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cl_prev
op_ne
id|cl_tail
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|deficit
)paren
suffix:semicolon
id|q-&gt;active
(braket
id|prio
)braket
op_assign
id|cl_prev
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
id|__inline__
r_struct
id|sk_buff
op_star
DECL|function|cbq_dequeue_1
id|cbq_dequeue_1
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|activemask
suffix:semicolon
id|activemask
op_assign
id|q-&gt;activemask
op_amp
l_int|0xFF
suffix:semicolon
r_while
c_loop
(paren
id|activemask
)paren
(brace
r_int
id|prio
op_assign
id|ffz
c_func
(paren
op_complement
id|activemask
)paren
suffix:semicolon
id|activemask
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|prio
)paren
suffix:semicolon
id|skb
op_assign
id|cbq_dequeue_prio
c_func
(paren
id|sch
comma
id|prio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
r_return
id|skb
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_struct
id|sk_buff
op_star
DECL|function|cbq_dequeue
id|cbq_dequeue
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
id|psched_time_t
id|now
suffix:semicolon
id|psched_tdiff_t
id|incr
suffix:semicolon
id|PSCHED_GET_TIME
c_func
(paren
id|now
)paren
suffix:semicolon
id|incr
op_assign
id|PSCHED_TDIFF
c_func
(paren
id|now
comma
id|q-&gt;now_rt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;tx_class
)paren
(brace
id|psched_tdiff_t
id|incr2
suffix:semicolon
multiline_comment|/* Time integrator. We calculate EOS time&n;&t;&t;   by adding expected packet transmittion time.&n;&t;&t;   If real time is greater, we warp artificial clock,&n;&t;&t;   so that:&n;&n;&t;&t;   cbq_time = max(real_time, work);&n;&t;&t; */
id|incr2
op_assign
id|L2T
c_func
(paren
op_amp
id|q-&gt;link
comma
id|q-&gt;tx_len
)paren
suffix:semicolon
id|PSCHED_TADD
c_func
(paren
id|q-&gt;now
comma
id|incr2
)paren
suffix:semicolon
id|cbq_update
c_func
(paren
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|incr
op_sub_assign
id|incr2
)paren
OL
l_int|0
)paren
id|incr
op_assign
l_int|0
suffix:semicolon
)brace
id|PSCHED_TADD
c_func
(paren
id|q-&gt;now
comma
id|incr
)paren
suffix:semicolon
id|q-&gt;now_rt
op_assign
id|now
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|q-&gt;wd_expires
op_assign
l_int|0
suffix:semicolon
id|skb
op_assign
id|cbq_dequeue_1
c_func
(paren
id|sch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
id|sch-&gt;q.qlen
op_decrement
suffix:semicolon
id|sch-&gt;flags
op_and_assign
op_complement
id|TCQ_F_THROTTLED
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/* All the classes are overlimit.&n;&n;&t;&t;   It is possible, if:&n;&n;&t;&t;   1. Scheduler is empty.&n;&t;&t;   2. Toplevel cutoff inhibited borrowing.&n;&t;&t;   3. Root class is overlimit.&n;&n;&t;&t;   Reset 2d and 3d conditions and retry.&n;&n;&t;&t;   Note, that NS and cbq-2.0 are buggy, peeking&n;&t;&t;   an arbitrary class is appropriate for ancestor-only&n;&t;&t;   sharing, but not for toplevel algorithm.&n;&n;&t;&t;   Our version is better, but slower, because it requires&n;&t;&t;   two passes, but it is unavoidable with top-level sharing.&n;&t;&t;*/
r_if
c_cond
(paren
id|q-&gt;toplevel
op_eq
id|TC_CBQ_MAXLEVEL
op_logical_and
id|PSCHED_IS_PASTPERFECT
c_func
(paren
id|q-&gt;link.undertime
)paren
)paren
r_break
suffix:semicolon
id|q-&gt;toplevel
op_assign
id|TC_CBQ_MAXLEVEL
suffix:semicolon
id|PSCHED_SET_PASTPERFECT
c_func
(paren
id|q-&gt;link.undertime
)paren
suffix:semicolon
)brace
multiline_comment|/* No packets in scheduler or nobody wants to give them to us :-(&n;&t;   Sigh... start watchdog timer in the last case. */
r_if
c_cond
(paren
id|sch-&gt;q.qlen
)paren
(brace
id|sch-&gt;stats.overlimits
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;wd_expires
op_logical_and
op_logical_neg
id|netif_queue_stopped
c_func
(paren
id|sch-&gt;dev
)paren
)paren
(brace
r_int
id|delay
op_assign
id|PSCHED_US2JIFFIE
c_func
(paren
id|q-&gt;wd_expires
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|q-&gt;wd_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delay
op_le
l_int|0
)paren
id|delay
op_assign
l_int|1
suffix:semicolon
id|q-&gt;wd_timer.expires
op_assign
id|jiffies
op_plus
id|delay
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|q-&gt;wd_timer
)paren
suffix:semicolon
id|sch-&gt;flags
op_or_assign
id|TCQ_F_THROTTLED
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* CBQ class maintanance routines */
DECL|function|cbq_adjust_levels
r_static
r_void
id|cbq_adjust_levels
c_func
(paren
r_struct
id|cbq_class
op_star
id|this
)paren
(brace
r_if
c_cond
(paren
id|this
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_do
(brace
r_int
id|level
op_assign
l_int|0
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cl
op_assign
id|this-&gt;children
)paren
op_ne
l_int|NULL
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
id|cl-&gt;level
OG
id|level
)paren
id|level
op_assign
id|cl-&gt;level
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|cl
op_assign
id|cl-&gt;sibling
)paren
op_ne
id|this-&gt;children
)paren
suffix:semicolon
)brace
id|this-&gt;level
op_assign
id|level
op_plus
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|this
op_assign
id|this-&gt;tparent
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|cbq_normalize_quanta
r_static
r_void
id|cbq_normalize_quanta
c_func
(paren
r_struct
id|cbq_sched_data
op_star
id|q
comma
r_int
id|prio
)paren
(brace
r_struct
id|cbq_class
op_star
id|cl
suffix:semicolon
r_int
id|h
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;quanta
(braket
id|prio
)braket
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
l_int|16
suffix:semicolon
id|h
op_increment
)paren
(brace
r_for
c_loop
(paren
id|cl
op_assign
id|q-&gt;classes
(braket
id|h
)braket
suffix:semicolon
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;next
)paren
(brace
multiline_comment|/* BUGGGG... Beware! This expression suffer of&n;&t;&t;&t;   arithmetic overflows!&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cl-&gt;priority
op_eq
id|prio
)paren
(brace
id|cl-&gt;quantum
op_assign
(paren
id|cl-&gt;weight
op_star
id|cl-&gt;allot
op_star
id|q-&gt;nclasses
(braket
id|prio
)braket
)paren
op_div
id|q-&gt;quanta
(braket
id|prio
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cl-&gt;quantum
op_le
l_int|0
op_logical_or
id|cl-&gt;quantum
OG
l_int|32
op_star
id|cl-&gt;qdisc-&gt;dev-&gt;mtu
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;CBQ: class %08x has bad quantum==%ld, repaired.&bslash;n&quot;
comma
id|cl-&gt;classid
comma
id|cl-&gt;quantum
)paren
suffix:semicolon
id|cl-&gt;quantum
op_assign
id|cl-&gt;qdisc-&gt;dev-&gt;mtu
op_div
l_int|2
op_plus
l_int|1
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|cbq_sync_defmap
r_static
r_void
id|cbq_sync_defmap
c_func
(paren
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|cl-&gt;qdisc-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|split
op_assign
id|cl-&gt;split
suffix:semicolon
r_int
id|h
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|split
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|TC_PRIO_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|split-&gt;defaults
(braket
id|i
)braket
op_eq
id|cl
op_logical_and
op_logical_neg
(paren
id|cl-&gt;defmap
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
id|split-&gt;defaults
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|TC_PRIO_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|level
op_assign
id|split-&gt;level
suffix:semicolon
r_if
c_cond
(paren
id|split-&gt;defaults
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
l_int|16
suffix:semicolon
id|h
op_increment
)paren
(brace
r_struct
id|cbq_class
op_star
id|c
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
id|q-&gt;classes
(braket
id|h
)braket
suffix:semicolon
id|c
suffix:semicolon
id|c
op_assign
id|c-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|c-&gt;split
op_eq
id|split
op_logical_and
id|c-&gt;level
OL
id|level
op_logical_and
id|c-&gt;defmap
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
id|split-&gt;defaults
(braket
id|i
)braket
op_assign
id|c
suffix:semicolon
id|level
op_assign
id|c-&gt;level
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
DECL|function|cbq_change_defmap
r_static
r_void
id|cbq_change_defmap
c_func
(paren
r_struct
id|cbq_class
op_star
id|cl
comma
id|u32
id|splitid
comma
id|u32
id|def
comma
id|u32
id|mask
)paren
(brace
r_struct
id|cbq_class
op_star
id|split
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|splitid
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|split
op_assign
id|cl-&gt;split
)paren
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|splitid
op_assign
id|split-&gt;classid
suffix:semicolon
)brace
r_if
c_cond
(paren
id|split
op_eq
l_int|NULL
op_logical_or
id|split-&gt;classid
op_ne
id|splitid
)paren
(brace
r_for
c_loop
(paren
id|split
op_assign
id|cl-&gt;tparent
suffix:semicolon
id|split
suffix:semicolon
id|split
op_assign
id|split-&gt;tparent
)paren
r_if
c_cond
(paren
id|split-&gt;classid
op_eq
id|splitid
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|split
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;split
op_ne
id|split
)paren
(brace
id|cl-&gt;defmap
op_assign
l_int|0
suffix:semicolon
id|cbq_sync_defmap
c_func
(paren
id|cl
)paren
suffix:semicolon
id|cl-&gt;split
op_assign
id|split
suffix:semicolon
id|cl-&gt;defmap
op_assign
id|def
op_amp
id|mask
suffix:semicolon
)brace
r_else
id|cl-&gt;defmap
op_assign
(paren
id|cl-&gt;defmap
op_amp
op_complement
id|mask
)paren
op_or
(paren
id|def
op_amp
id|mask
)paren
suffix:semicolon
id|cbq_sync_defmap
c_func
(paren
id|cl
)paren
suffix:semicolon
)brace
DECL|function|cbq_unlink_class
r_static
r_void
id|cbq_unlink_class
c_func
(paren
r_struct
id|cbq_class
op_star
id|this
)paren
(brace
r_struct
id|cbq_class
op_star
id|cl
comma
op_star
op_star
id|clp
suffix:semicolon
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|this-&gt;qdisc-&gt;data
suffix:semicolon
r_for
c_loop
(paren
id|clp
op_assign
op_amp
id|q-&gt;classes
(braket
id|cbq_hash
c_func
(paren
id|this-&gt;classid
)paren
)braket
suffix:semicolon
(paren
id|cl
op_assign
op_star
id|clp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|clp
op_assign
op_amp
id|cl-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cl
op_eq
id|this
)paren
(brace
op_star
id|clp
op_assign
id|cl-&gt;next
suffix:semicolon
id|cl-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|this-&gt;tparent
)paren
(brace
id|clp
op_assign
op_amp
id|this-&gt;sibling
suffix:semicolon
id|cl
op_assign
op_star
id|clp
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|cl
op_eq
id|this
)paren
(brace
op_star
id|clp
op_assign
id|cl-&gt;sibling
suffix:semicolon
r_break
suffix:semicolon
)brace
id|clp
op_assign
op_amp
id|cl-&gt;sibling
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|cl
op_assign
op_star
id|clp
)paren
op_ne
id|this-&gt;sibling
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;tparent-&gt;children
op_eq
id|this
)paren
(brace
id|this-&gt;tparent-&gt;children
op_assign
id|this-&gt;sibling
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;sibling
op_eq
id|this
)paren
id|this-&gt;tparent-&gt;children
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
id|BUG_TRAP
c_func
(paren
id|this-&gt;sibling
op_eq
id|this
)paren
suffix:semicolon
)brace
)brace
DECL|function|cbq_link_class
r_static
r_void
id|cbq_link_class
c_func
(paren
r_struct
id|cbq_class
op_star
id|this
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|this-&gt;qdisc-&gt;data
suffix:semicolon
r_int
id|h
op_assign
id|cbq_hash
c_func
(paren
id|this-&gt;classid
)paren
suffix:semicolon
r_struct
id|cbq_class
op_star
id|parent
op_assign
id|this-&gt;tparent
suffix:semicolon
id|this-&gt;sibling
op_assign
id|this
suffix:semicolon
id|this-&gt;next
op_assign
id|q-&gt;classes
(braket
id|h
)braket
suffix:semicolon
id|q-&gt;classes
(braket
id|h
)braket
op_assign
id|this
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|parent-&gt;children
op_eq
l_int|NULL
)paren
(brace
id|parent-&gt;children
op_assign
id|this
suffix:semicolon
)brace
r_else
(brace
id|this-&gt;sibling
op_assign
id|parent-&gt;children-&gt;sibling
suffix:semicolon
id|parent-&gt;children-&gt;sibling
op_assign
id|this
suffix:semicolon
)brace
)brace
DECL|function|cbq_drop
r_static
r_int
id|cbq_drop
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
comma
op_star
id|cl_head
suffix:semicolon
r_int
id|prio
suffix:semicolon
r_for
c_loop
(paren
id|prio
op_assign
id|TC_CBQ_MAXPRIO
suffix:semicolon
id|prio
op_ge
l_int|0
suffix:semicolon
id|prio
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|cl_head
op_assign
id|q-&gt;active
(braket
id|prio
)braket
)paren
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|cl
op_assign
id|cl_head
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|cl-&gt;q-&gt;ops-&gt;drop
op_logical_and
id|cl-&gt;q-&gt;ops
op_member_access_from_pointer
id|drop
c_func
(paren
id|cl-&gt;q
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|cl
op_assign
id|cl-&gt;next_alive
)paren
op_ne
id|cl_head
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|cbq_reset
id|cbq_reset
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
suffix:semicolon
r_int
id|prio
suffix:semicolon
r_int
id|h
suffix:semicolon
id|q-&gt;activemask
op_assign
l_int|0
suffix:semicolon
id|q-&gt;pmask
op_assign
l_int|0
suffix:semicolon
id|q-&gt;tx_class
op_assign
l_int|NULL
suffix:semicolon
id|q-&gt;tx_borrowed
op_assign
l_int|NULL
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|q-&gt;wd_timer
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|q-&gt;delay_timer
)paren
suffix:semicolon
id|q-&gt;toplevel
op_assign
id|TC_CBQ_MAXLEVEL
suffix:semicolon
id|PSCHED_GET_TIME
c_func
(paren
id|q-&gt;now
)paren
suffix:semicolon
id|q-&gt;now_rt
op_assign
id|q-&gt;now
suffix:semicolon
r_for
c_loop
(paren
id|prio
op_assign
l_int|0
suffix:semicolon
id|prio
op_le
id|TC_CBQ_MAXPRIO
suffix:semicolon
id|prio
op_increment
)paren
id|q-&gt;active
(braket
id|prio
)braket
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
l_int|16
suffix:semicolon
id|h
op_increment
)paren
(brace
r_for
c_loop
(paren
id|cl
op_assign
id|q-&gt;classes
(braket
id|h
)braket
suffix:semicolon
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;next
)paren
(brace
id|qdisc_reset
c_func
(paren
id|cl-&gt;q
)paren
suffix:semicolon
id|cl-&gt;next_alive
op_assign
l_int|NULL
suffix:semicolon
id|PSCHED_SET_PASTPERFECT
c_func
(paren
id|cl-&gt;undertime
)paren
suffix:semicolon
id|cl-&gt;avgidle
op_assign
id|cl-&gt;maxidle
suffix:semicolon
id|cl-&gt;deficit
op_assign
id|cl-&gt;quantum
suffix:semicolon
id|cl-&gt;cpriority
op_assign
id|cl-&gt;priority
suffix:semicolon
)brace
)brace
id|sch-&gt;q.qlen
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|cbq_set_lss
r_static
r_int
id|cbq_set_lss
c_func
(paren
r_struct
id|cbq_class
op_star
id|cl
comma
r_struct
id|tc_cbq_lssopt
op_star
id|lss
)paren
(brace
r_if
c_cond
(paren
id|lss-&gt;change
op_amp
id|TCF_CBQ_LSS_FLAGS
)paren
(brace
id|cl-&gt;share
op_assign
(paren
id|lss-&gt;flags
op_amp
id|TCF_CBQ_LSS_ISOLATED
)paren
ques
c_cond
l_int|NULL
suffix:colon
id|cl-&gt;tparent
suffix:semicolon
id|cl-&gt;borrow
op_assign
(paren
id|lss-&gt;flags
op_amp
id|TCF_CBQ_LSS_BOUNDED
)paren
ques
c_cond
l_int|NULL
suffix:colon
id|cl-&gt;tparent
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lss-&gt;change
op_amp
id|TCF_CBQ_LSS_EWMA
)paren
id|cl-&gt;ewma_log
op_assign
id|lss-&gt;ewma_log
suffix:semicolon
r_if
c_cond
(paren
id|lss-&gt;change
op_amp
id|TCF_CBQ_LSS_AVPKT
)paren
id|cl-&gt;avpkt
op_assign
id|lss-&gt;avpkt
suffix:semicolon
r_if
c_cond
(paren
id|lss-&gt;change
op_amp
id|TCF_CBQ_LSS_MINIDLE
)paren
id|cl-&gt;minidle
op_assign
op_minus
(paren
r_int
)paren
id|lss-&gt;minidle
suffix:semicolon
r_if
c_cond
(paren
id|lss-&gt;change
op_amp
id|TCF_CBQ_LSS_MAXIDLE
)paren
(brace
id|cl-&gt;maxidle
op_assign
id|lss-&gt;maxidle
suffix:semicolon
id|cl-&gt;avgidle
op_assign
id|lss-&gt;maxidle
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lss-&gt;change
op_amp
id|TCF_CBQ_LSS_OFFTIME
)paren
id|cl-&gt;offtime
op_assign
id|lss-&gt;offtime
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cbq_rmprio
r_static
r_void
id|cbq_rmprio
c_func
(paren
r_struct
id|cbq_sched_data
op_star
id|q
comma
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
id|q-&gt;nclasses
(braket
id|cl-&gt;priority
)braket
op_decrement
suffix:semicolon
id|q-&gt;quanta
(braket
id|cl-&gt;priority
)braket
op_sub_assign
id|cl-&gt;weight
suffix:semicolon
id|cbq_normalize_quanta
c_func
(paren
id|q
comma
id|cl-&gt;priority
)paren
suffix:semicolon
)brace
DECL|function|cbq_addprio
r_static
r_void
id|cbq_addprio
c_func
(paren
r_struct
id|cbq_sched_data
op_star
id|q
comma
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
id|q-&gt;nclasses
(braket
id|cl-&gt;priority
)braket
op_increment
suffix:semicolon
id|q-&gt;quanta
(braket
id|cl-&gt;priority
)braket
op_add_assign
id|cl-&gt;weight
suffix:semicolon
id|cbq_normalize_quanta
c_func
(paren
id|q
comma
id|cl-&gt;priority
)paren
suffix:semicolon
)brace
DECL|function|cbq_set_wrr
r_static
r_int
id|cbq_set_wrr
c_func
(paren
r_struct
id|cbq_class
op_star
id|cl
comma
r_struct
id|tc_cbq_wrropt
op_star
id|wrr
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|cl-&gt;qdisc-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|wrr-&gt;allot
)paren
id|cl-&gt;allot
op_assign
id|wrr-&gt;allot
suffix:semicolon
r_if
c_cond
(paren
id|wrr-&gt;weight
)paren
id|cl-&gt;weight
op_assign
id|wrr-&gt;weight
suffix:semicolon
r_if
c_cond
(paren
id|wrr-&gt;priority
)paren
(brace
id|cl-&gt;priority
op_assign
id|wrr-&gt;priority
op_minus
l_int|1
suffix:semicolon
id|cl-&gt;cpriority
op_assign
id|cl-&gt;priority
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;priority
op_ge
id|cl-&gt;priority2
)paren
id|cl-&gt;priority2
op_assign
id|TC_CBQ_MAXPRIO
op_minus
l_int|1
suffix:semicolon
)brace
id|cbq_addprio
c_func
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cbq_set_overlimit
r_static
r_int
id|cbq_set_overlimit
c_func
(paren
r_struct
id|cbq_class
op_star
id|cl
comma
r_struct
id|tc_cbq_ovl
op_star
id|ovl
)paren
(brace
r_switch
c_cond
(paren
id|ovl-&gt;strategy
)paren
(brace
r_case
id|TC_CBQ_OVL_CLASSIC
suffix:colon
id|cl-&gt;overlimit
op_assign
id|cbq_ovl_classic
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TC_CBQ_OVL_DELAY
suffix:colon
id|cl-&gt;overlimit
op_assign
id|cbq_ovl_delay
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TC_CBQ_OVL_LOWPRIO
suffix:colon
r_if
c_cond
(paren
id|ovl-&gt;priority2
op_minus
l_int|1
op_ge
id|TC_CBQ_MAXPRIO
op_logical_or
id|ovl-&gt;priority2
op_minus
l_int|1
op_le
id|cl-&gt;priority
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|cl-&gt;priority2
op_assign
id|ovl-&gt;priority2
op_minus
l_int|1
suffix:semicolon
id|cl-&gt;overlimit
op_assign
id|cbq_ovl_lowprio
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TC_CBQ_OVL_DROP
suffix:colon
id|cl-&gt;overlimit
op_assign
id|cbq_ovl_drop
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TC_CBQ_OVL_RCLASSIC
suffix:colon
id|cl-&gt;overlimit
op_assign
id|cbq_ovl_rclassic
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|cl-&gt;penalty
op_assign
(paren
id|ovl-&gt;penalty
op_star
id|HZ
)paren
op_div
l_int|1000
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_CLS_POLICE
DECL|function|cbq_set_police
r_static
r_int
id|cbq_set_police
c_func
(paren
r_struct
id|cbq_class
op_star
id|cl
comma
r_struct
id|tc_cbq_police
op_star
id|p
)paren
(brace
id|cl-&gt;police
op_assign
id|p-&gt;police
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;q-&gt;handle
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;police
op_eq
id|TC_POLICE_RECLASSIFY
)paren
id|cl-&gt;q-&gt;reshape_fail
op_assign
id|cbq_reshape_fail
suffix:semicolon
r_else
id|cl-&gt;q-&gt;reshape_fail
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|cbq_set_fopt
r_static
r_int
id|cbq_set_fopt
c_func
(paren
r_struct
id|cbq_class
op_star
id|cl
comma
r_struct
id|tc_cbq_fopt
op_star
id|fopt
)paren
(brace
id|cbq_change_defmap
c_func
(paren
id|cl
comma
id|fopt-&gt;split
comma
id|fopt-&gt;defmap
comma
id|fopt-&gt;defchange
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cbq_init
r_static
r_int
id|cbq_init
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|rtattr
op_star
id|opt
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|rtattr
op_star
id|tb
(braket
id|TCA_CBQ_MAX
)braket
suffix:semicolon
r_struct
id|tc_ratespec
op_star
id|r
suffix:semicolon
r_if
c_cond
(paren
id|rtattr_parse
c_func
(paren
id|tb
comma
id|TCA_CBQ_MAX
comma
id|RTA_DATA
c_func
(paren
id|opt
)paren
comma
id|RTA_PAYLOAD
c_func
(paren
id|opt
)paren
)paren
OL
l_int|0
op_logical_or
id|tb
(braket
id|TCA_CBQ_RTAB
op_minus
l_int|1
)braket
op_eq
l_int|NULL
op_logical_or
id|tb
(braket
id|TCA_CBQ_RATE
op_minus
l_int|1
)braket
op_eq
l_int|NULL
op_logical_or
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_CBQ_RATE
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
r_struct
id|tc_ratespec
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CBQ_LSSOPT
op_minus
l_int|1
)braket
op_logical_and
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_CBQ_LSSOPT
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
r_struct
id|tc_cbq_lssopt
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|r
op_assign
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_CBQ_RATE
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q-&gt;link.R_tab
op_assign
id|qdisc_get_rtab
c_func
(paren
id|r
comma
id|tb
(braket
id|TCA_CBQ_RTAB
op_minus
l_int|1
)braket
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|q-&gt;link.refcnt
op_assign
l_int|1
suffix:semicolon
id|q-&gt;link.sibling
op_assign
op_amp
id|q-&gt;link
suffix:semicolon
id|q-&gt;link.classid
op_assign
id|sch-&gt;handle
suffix:semicolon
id|q-&gt;link.qdisc
op_assign
id|sch
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|q-&gt;link.q
op_assign
id|qdisc_create_dflt
c_func
(paren
id|sch-&gt;dev
comma
op_amp
id|pfifo_qdisc_ops
)paren
)paren
)paren
id|q-&gt;link.q
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|q-&gt;link.priority
op_assign
id|TC_CBQ_MAXPRIO
op_minus
l_int|1
suffix:semicolon
id|q-&gt;link.priority2
op_assign
id|TC_CBQ_MAXPRIO
op_minus
l_int|1
suffix:semicolon
id|q-&gt;link.cpriority
op_assign
id|TC_CBQ_MAXPRIO
op_minus
l_int|1
suffix:semicolon
id|q-&gt;link.ovl_strategy
op_assign
id|TC_CBQ_OVL_CLASSIC
suffix:semicolon
id|q-&gt;link.overlimit
op_assign
id|cbq_ovl_classic
suffix:semicolon
id|q-&gt;link.allot
op_assign
id|psched_mtu
c_func
(paren
id|sch-&gt;dev
)paren
suffix:semicolon
id|q-&gt;link.quantum
op_assign
id|q-&gt;link.allot
suffix:semicolon
id|q-&gt;link.weight
op_assign
id|q-&gt;link.R_tab-&gt;rate.rate
suffix:semicolon
id|q-&gt;link.ewma_log
op_assign
id|TC_CBQ_DEF_EWMA
suffix:semicolon
id|q-&gt;link.avpkt
op_assign
id|q-&gt;link.allot
op_div
l_int|2
suffix:semicolon
id|q-&gt;link.minidle
op_assign
op_minus
l_int|0x7FFFFFFF
suffix:semicolon
id|q-&gt;link.stats.lock
op_assign
op_amp
id|sch-&gt;dev-&gt;queue_lock
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|q-&gt;wd_timer
)paren
suffix:semicolon
id|q-&gt;wd_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sch
suffix:semicolon
id|q-&gt;wd_timer.function
op_assign
id|cbq_watchdog
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|q-&gt;delay_timer
)paren
suffix:semicolon
id|q-&gt;delay_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sch
suffix:semicolon
id|q-&gt;delay_timer.function
op_assign
id|cbq_undelay
suffix:semicolon
id|q-&gt;toplevel
op_assign
id|TC_CBQ_MAXLEVEL
suffix:semicolon
id|PSCHED_GET_TIME
c_func
(paren
id|q-&gt;now
)paren
suffix:semicolon
id|q-&gt;now_rt
op_assign
id|q-&gt;now
suffix:semicolon
id|cbq_link_class
c_func
(paren
op_amp
id|q-&gt;link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CBQ_LSSOPT
op_minus
l_int|1
)braket
)paren
id|cbq_set_lss
c_func
(paren
op_amp
id|q-&gt;link
comma
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_CBQ_LSSOPT
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|cbq_addprio
c_func
(paren
id|q
comma
op_amp
id|q-&gt;link
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_RTNETLINK
DECL|function|cbq_dump_rate
r_static
id|__inline__
r_int
id|cbq_dump_rate
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_CBQ_RATE
comma
r_sizeof
(paren
id|cl-&gt;R_tab-&gt;rate
)paren
comma
op_amp
id|cl-&gt;R_tab-&gt;rate
)paren
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|cbq_dump_lss
r_static
id|__inline__
r_int
id|cbq_dump_lss
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
r_struct
id|tc_cbq_lssopt
id|opt
suffix:semicolon
id|opt.flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;borrow
op_eq
l_int|NULL
)paren
id|opt.flags
op_or_assign
id|TCF_CBQ_LSS_BOUNDED
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;share
op_eq
l_int|NULL
)paren
id|opt.flags
op_or_assign
id|TCF_CBQ_LSS_ISOLATED
suffix:semicolon
id|opt.ewma_log
op_assign
id|cl-&gt;ewma_log
suffix:semicolon
id|opt.level
op_assign
id|cl-&gt;level
suffix:semicolon
id|opt.avpkt
op_assign
id|cl-&gt;avpkt
suffix:semicolon
id|opt.maxidle
op_assign
id|cl-&gt;maxidle
suffix:semicolon
id|opt.minidle
op_assign
(paren
id|u32
)paren
(paren
op_minus
id|cl-&gt;minidle
)paren
suffix:semicolon
id|opt.offtime
op_assign
id|cl-&gt;offtime
suffix:semicolon
id|opt.change
op_assign
op_complement
l_int|0
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_CBQ_LSSOPT
comma
r_sizeof
(paren
id|opt
)paren
comma
op_amp
id|opt
)paren
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|cbq_dump_wrr
r_static
id|__inline__
r_int
id|cbq_dump_wrr
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
r_struct
id|tc_cbq_wrropt
id|opt
suffix:semicolon
id|opt.flags
op_assign
l_int|0
suffix:semicolon
id|opt.allot
op_assign
id|cl-&gt;allot
suffix:semicolon
id|opt.priority
op_assign
id|cl-&gt;priority
op_plus
l_int|1
suffix:semicolon
id|opt.cpriority
op_assign
id|cl-&gt;cpriority
op_plus
l_int|1
suffix:semicolon
id|opt.weight
op_assign
id|cl-&gt;weight
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_CBQ_WRROPT
comma
r_sizeof
(paren
id|opt
)paren
comma
op_amp
id|opt
)paren
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|cbq_dump_ovl
r_static
id|__inline__
r_int
id|cbq_dump_ovl
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
r_struct
id|tc_cbq_ovl
id|opt
suffix:semicolon
id|opt.strategy
op_assign
id|cl-&gt;ovl_strategy
suffix:semicolon
id|opt.priority2
op_assign
id|cl-&gt;priority2
op_plus
l_int|1
suffix:semicolon
id|opt.penalty
op_assign
(paren
id|cl-&gt;penalty
op_star
l_int|1000
)paren
op_div
id|HZ
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_CBQ_OVL_STRATEGY
comma
r_sizeof
(paren
id|opt
)paren
comma
op_amp
id|opt
)paren
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|cbq_dump_fopt
r_static
id|__inline__
r_int
id|cbq_dump_fopt
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
r_struct
id|tc_cbq_fopt
id|opt
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;split
op_logical_or
id|cl-&gt;defmap
)paren
(brace
id|opt.split
op_assign
id|cl-&gt;split
ques
c_cond
id|cl-&gt;split-&gt;classid
suffix:colon
l_int|0
suffix:semicolon
id|opt.defmap
op_assign
id|cl-&gt;defmap
suffix:semicolon
id|opt.defchange
op_assign
op_complement
l_int|0
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_CBQ_FOPT
comma
r_sizeof
(paren
id|opt
)paren
comma
op_amp
id|opt
)paren
suffix:semicolon
)brace
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_CLS_POLICE
DECL|function|cbq_dump_police
r_static
id|__inline__
r_int
id|cbq_dump_police
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
r_struct
id|tc_cbq_police
id|opt
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;police
)paren
(brace
id|opt.police
op_assign
id|cl-&gt;police
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_CBQ_POLICE
comma
r_sizeof
(paren
id|opt
)paren
comma
op_amp
id|opt
)paren
suffix:semicolon
)brace
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
DECL|function|cbq_dump_attr
r_static
r_int
id|cbq_dump_attr
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_if
c_cond
(paren
id|cbq_dump_lss
c_func
(paren
id|skb
comma
id|cl
)paren
OL
l_int|0
op_logical_or
id|cbq_dump_rate
c_func
(paren
id|skb
comma
id|cl
)paren
OL
l_int|0
op_logical_or
id|cbq_dump_wrr
c_func
(paren
id|skb
comma
id|cl
)paren
OL
l_int|0
op_logical_or
id|cbq_dump_ovl
c_func
(paren
id|skb
comma
id|cl
)paren
OL
l_int|0
op_logical_or
macro_line|#ifdef CONFIG_NET_CLS_POLICE
id|cbq_dump_police
c_func
(paren
id|skb
comma
id|cl
)paren
OL
l_int|0
op_logical_or
macro_line|#endif
id|cbq_dump_fopt
c_func
(paren
id|skb
comma
id|cl
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cbq_copy_xstats
r_int
id|cbq_copy_xstats
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tc_cbq_xstats
op_star
id|st
)paren
(brace
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_XSTATS
comma
r_sizeof
(paren
op_star
id|st
)paren
comma
id|st
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|rtattr_failure
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|cbq_dump
r_static
r_int
id|cbq_dump
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
r_struct
id|rtattr
op_star
id|rta
suffix:semicolon
id|rta
op_assign
(paren
r_struct
id|rtattr
op_star
)paren
id|b
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_OPTIONS
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cbq_dump_attr
c_func
(paren
id|skb
comma
op_amp
id|q-&gt;link
)paren
OL
l_int|0
)paren
r_goto
id|rtattr_failure
suffix:semicolon
id|rta-&gt;rta_len
op_assign
id|skb-&gt;tail
op_minus
id|b
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|sch-&gt;dev-&gt;queue_lock
)paren
suffix:semicolon
id|q-&gt;link.xstats.avgidle
op_assign
id|q-&gt;link.avgidle
suffix:semicolon
r_if
c_cond
(paren
id|cbq_copy_xstats
c_func
(paren
id|skb
comma
op_amp
id|q-&gt;link.xstats
)paren
)paren
(brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|sch-&gt;dev-&gt;queue_lock
)paren
suffix:semicolon
r_goto
id|rtattr_failure
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|sch-&gt;dev-&gt;queue_lock
)paren
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|cbq_dump_class
id|cbq_dump_class
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcmsg
op_star
id|tcm
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
op_assign
(paren
r_struct
id|cbq_class
op_star
)paren
id|arg
suffix:semicolon
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
r_struct
id|rtattr
op_star
id|rta
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;tparent
)paren
id|tcm-&gt;tcm_parent
op_assign
id|cl-&gt;tparent-&gt;classid
suffix:semicolon
r_else
id|tcm-&gt;tcm_parent
op_assign
id|TC_H_ROOT
suffix:semicolon
id|tcm-&gt;tcm_handle
op_assign
id|cl-&gt;classid
suffix:semicolon
id|tcm-&gt;tcm_info
op_assign
id|cl-&gt;q-&gt;handle
suffix:semicolon
id|rta
op_assign
(paren
r_struct
id|rtattr
op_star
)paren
id|b
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_OPTIONS
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cbq_dump_attr
c_func
(paren
id|skb
comma
id|cl
)paren
OL
l_int|0
)paren
r_goto
id|rtattr_failure
suffix:semicolon
id|rta-&gt;rta_len
op_assign
id|skb-&gt;tail
op_minus
id|b
suffix:semicolon
id|cl-&gt;stats.qlen
op_assign
id|cl-&gt;q-&gt;q.qlen
suffix:semicolon
r_if
c_cond
(paren
id|qdisc_copy_stats
c_func
(paren
id|skb
comma
op_amp
id|cl-&gt;stats
)paren
)paren
r_goto
id|rtattr_failure
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|sch-&gt;dev-&gt;queue_lock
)paren
suffix:semicolon
id|cl-&gt;xstats.avgidle
op_assign
id|cl-&gt;avgidle
suffix:semicolon
id|cl-&gt;xstats.undertime
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PSCHED_IS_PASTPERFECT
c_func
(paren
id|cl-&gt;undertime
)paren
)paren
id|cl-&gt;xstats.undertime
op_assign
id|PSCHED_TDIFF
c_func
(paren
id|cl-&gt;undertime
comma
id|q-&gt;now
)paren
suffix:semicolon
id|q-&gt;link.xstats.avgidle
op_assign
id|q-&gt;link.avgidle
suffix:semicolon
r_if
c_cond
(paren
id|cbq_copy_xstats
c_func
(paren
id|skb
comma
op_amp
id|cl-&gt;xstats
)paren
)paren
(brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|sch-&gt;dev-&gt;queue_lock
)paren
suffix:semicolon
r_goto
id|rtattr_failure
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|sch-&gt;dev-&gt;queue_lock
)paren
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
DECL|function|cbq_graft
r_static
r_int
id|cbq_graft
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
comma
r_struct
id|Qdisc
op_star
r_new
comma
r_struct
id|Qdisc
op_star
op_star
id|old
)paren
(brace
r_struct
id|cbq_class
op_star
id|cl
op_assign
(paren
r_struct
id|cbq_class
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|cl
)paren
(brace
r_if
c_cond
(paren
r_new
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
r_new
op_assign
id|qdisc_create_dflt
c_func
(paren
id|sch-&gt;dev
comma
op_amp
id|pfifo_qdisc_ops
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_NET_CLS_POLICE
r_if
c_cond
(paren
id|cl-&gt;police
op_eq
id|TC_POLICE_RECLASSIFY
)paren
r_new
op_member_access_from_pointer
id|reshape_fail
op_assign
id|cbq_reshape_fail
suffix:semicolon
macro_line|#endif
)brace
id|sch_tree_lock
c_func
(paren
id|sch
)paren
suffix:semicolon
op_star
id|old
op_assign
id|cl-&gt;q
suffix:semicolon
id|cl-&gt;q
op_assign
r_new
suffix:semicolon
id|qdisc_reset
c_func
(paren
op_star
id|old
)paren
suffix:semicolon
id|sch_tree_unlock
c_func
(paren
id|sch
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_static
r_struct
id|Qdisc
op_star
DECL|function|cbq_leaf
id|cbq_leaf
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|cbq_class
op_star
id|cl
op_assign
(paren
r_struct
id|cbq_class
op_star
)paren
id|arg
suffix:semicolon
r_return
id|cl
ques
c_cond
id|cl-&gt;q
suffix:colon
l_int|NULL
suffix:semicolon
)brace
DECL|function|cbq_get
r_static
r_int
r_int
id|cbq_get
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
id|u32
id|classid
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
op_assign
id|cbq_class_lookup
c_func
(paren
id|q
comma
id|classid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
)paren
(brace
id|cl-&gt;refcnt
op_increment
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|cl
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cbq_destroy_filters
r_static
r_void
id|cbq_destroy_filters
c_func
(paren
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
r_struct
id|tcf_proto
op_star
id|tp
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tp
op_assign
id|cl-&gt;filter_list
)paren
op_ne
l_int|NULL
)paren
(brace
id|cl-&gt;filter_list
op_assign
id|tp-&gt;next
suffix:semicolon
id|tp-&gt;ops
op_member_access_from_pointer
id|destroy
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
)brace
DECL|function|cbq_destroy_class
r_static
r_void
id|cbq_destroy_class
c_func
(paren
r_struct
id|cbq_class
op_star
id|cl
)paren
(brace
id|cbq_destroy_filters
c_func
(paren
id|cl
)paren
suffix:semicolon
id|qdisc_destroy
c_func
(paren
id|cl-&gt;q
)paren
suffix:semicolon
id|qdisc_put_rtab
c_func
(paren
id|cl-&gt;R_tab
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_ESTIMATOR
id|qdisc_kill_estimator
c_func
(paren
op_amp
id|cl-&gt;stats
)paren
suffix:semicolon
macro_line|#endif
id|kfree
c_func
(paren
id|cl
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|cbq_destroy
id|cbq_destroy
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
suffix:semicolon
r_int
id|h
suffix:semicolon
macro_line|#ifdef CONFIG_NET_CLS_POLICE
id|q-&gt;rx_class
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
l_int|16
suffix:semicolon
id|h
op_increment
)paren
(brace
r_for
c_loop
(paren
id|cl
op_assign
id|q-&gt;classes
(braket
id|h
)braket
suffix:semicolon
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;next
)paren
id|cbq_destroy_filters
c_func
(paren
id|cl
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
l_int|16
suffix:semicolon
id|h
op_increment
)paren
(brace
r_for
c_loop
(paren
id|cl
op_assign
id|q-&gt;classes
(braket
id|h
)braket
suffix:semicolon
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;next
)paren
r_if
c_cond
(paren
id|cl
op_ne
op_amp
id|q-&gt;link
)paren
id|cbq_destroy_class
c_func
(paren
id|cl
)paren
suffix:semicolon
)brace
id|qdisc_put_rtab
c_func
(paren
id|q-&gt;link.R_tab
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|function|cbq_put
r_static
r_void
id|cbq_put
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|cbq_class
op_star
id|cl
op_assign
(paren
r_struct
id|cbq_class
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|cl-&gt;refcnt
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef CONFIG_NET_CLS_POLICE
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|sch-&gt;dev-&gt;queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;rx_class
op_eq
id|cl
)paren
id|q-&gt;rx_class
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|sch-&gt;dev-&gt;queue_lock
)paren
suffix:semicolon
macro_line|#endif
id|cbq_destroy_class
c_func
(paren
id|cl
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|cbq_change_class
id|cbq_change_class
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
id|u32
id|classid
comma
id|u32
id|parentid
comma
r_struct
id|rtattr
op_star
op_star
id|tca
comma
r_int
r_int
op_star
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
op_assign
(paren
r_struct
id|cbq_class
op_star
)paren
op_star
id|arg
suffix:semicolon
r_struct
id|rtattr
op_star
id|opt
op_assign
id|tca
(braket
id|TCA_OPTIONS
op_minus
l_int|1
)braket
suffix:semicolon
r_struct
id|rtattr
op_star
id|tb
(braket
id|TCA_CBQ_MAX
)braket
suffix:semicolon
r_struct
id|cbq_class
op_star
id|parent
suffix:semicolon
r_struct
id|qdisc_rate_table
op_star
id|rtab
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_eq
l_int|NULL
op_logical_or
id|rtattr_parse
c_func
(paren
id|tb
comma
id|TCA_CBQ_MAX
comma
id|RTA_DATA
c_func
(paren
id|opt
)paren
comma
id|RTA_PAYLOAD
c_func
(paren
id|opt
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CBQ_OVL_STRATEGY
op_minus
l_int|1
)braket
op_logical_and
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_CBQ_OVL_STRATEGY
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
r_struct
id|tc_cbq_ovl
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CBQ_FOPT
op_minus
l_int|1
)braket
op_logical_and
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_CBQ_FOPT
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
r_struct
id|tc_cbq_fopt
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CBQ_RATE
op_minus
l_int|1
)braket
op_logical_and
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_CBQ_RATE
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
r_struct
id|tc_ratespec
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CBQ_LSSOPT
op_minus
l_int|1
)braket
op_logical_and
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_CBQ_LSSOPT
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
r_struct
id|tc_cbq_lssopt
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CBQ_WRROPT
op_minus
l_int|1
)braket
op_logical_and
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_CBQ_WRROPT
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
r_struct
id|tc_cbq_wrropt
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#ifdef CONFIG_NET_CLS_POLICE
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CBQ_POLICE
op_minus
l_int|1
)braket
op_logical_and
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_CBQ_POLICE
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
r_struct
id|tc_cbq_police
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cl
)paren
(brace
multiline_comment|/* Check parent */
r_if
c_cond
(paren
id|parentid
)paren
(brace
r_if
c_cond
(paren
id|cl-&gt;tparent
op_logical_and
id|cl-&gt;tparent-&gt;classid
op_ne
id|parentid
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cl-&gt;tparent
op_logical_and
id|parentid
op_ne
id|TC_H_ROOT
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CBQ_RATE
op_minus
l_int|1
)braket
)paren
(brace
id|rtab
op_assign
id|qdisc_get_rtab
c_func
(paren
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_CBQ_RATE
op_minus
l_int|1
)braket
)paren
comma
id|tb
(braket
id|TCA_CBQ_RTAB
op_minus
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtab
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Change class parameters */
id|sch_tree_lock
c_func
(paren
id|sch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;next_alive
op_ne
l_int|NULL
)paren
id|cbq_deactivate_class
c_func
(paren
id|cl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtab
)paren
(brace
id|rtab
op_assign
id|xchg
c_func
(paren
op_amp
id|cl-&gt;R_tab
comma
id|rtab
)paren
suffix:semicolon
id|qdisc_put_rtab
c_func
(paren
id|rtab
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CBQ_LSSOPT
op_minus
l_int|1
)braket
)paren
id|cbq_set_lss
c_func
(paren
id|cl
comma
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_CBQ_LSSOPT
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CBQ_WRROPT
op_minus
l_int|1
)braket
)paren
(brace
id|cbq_rmprio
c_func
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
id|cbq_set_wrr
c_func
(paren
id|cl
comma
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_CBQ_WRROPT
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CBQ_OVL_STRATEGY
op_minus
l_int|1
)braket
)paren
id|cbq_set_overlimit
c_func
(paren
id|cl
comma
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_CBQ_OVL_STRATEGY
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_CLS_POLICE
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CBQ_POLICE
op_minus
l_int|1
)braket
)paren
id|cbq_set_police
c_func
(paren
id|cl
comma
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_CBQ_POLICE
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CBQ_FOPT
op_minus
l_int|1
)braket
)paren
id|cbq_set_fopt
c_func
(paren
id|cl
comma
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_CBQ_FOPT
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;q-&gt;q.qlen
)paren
id|cbq_activate_class
c_func
(paren
id|cl
)paren
suffix:semicolon
id|sch_tree_unlock
c_func
(paren
id|sch
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_ESTIMATOR
r_if
c_cond
(paren
id|tca
(braket
id|TCA_RATE
op_minus
l_int|1
)braket
)paren
(brace
id|qdisc_kill_estimator
c_func
(paren
op_amp
id|cl-&gt;stats
)paren
suffix:semicolon
id|qdisc_new_estimator
c_func
(paren
op_amp
id|cl-&gt;stats
comma
id|tca
(braket
id|TCA_RATE
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|parentid
op_eq
id|TC_H_ROOT
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CBQ_WRROPT
op_minus
l_int|1
)braket
op_eq
l_int|NULL
op_logical_or
id|tb
(braket
id|TCA_CBQ_RATE
op_minus
l_int|1
)braket
op_eq
l_int|NULL
op_logical_or
id|tb
(braket
id|TCA_CBQ_LSSOPT
op_minus
l_int|1
)braket
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|rtab
op_assign
id|qdisc_get_rtab
c_func
(paren
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_CBQ_RATE
op_minus
l_int|1
)braket
)paren
comma
id|tb
(braket
id|TCA_CBQ_RTAB
op_minus
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtab
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|classid
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|TC_H_MAJ
c_func
(paren
id|classid
op_xor
id|sch-&gt;handle
)paren
op_logical_or
id|cbq_class_lookup
c_func
(paren
id|q
comma
id|classid
)paren
)paren
r_goto
id|failure
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
id|classid
op_assign
id|TC_H_MAKE
c_func
(paren
id|sch-&gt;handle
comma
l_int|0x8000
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x8000
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_increment
id|q-&gt;hgenerator
op_ge
l_int|0x8000
)paren
id|q-&gt;hgenerator
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cbq_class_lookup
c_func
(paren
id|q
comma
id|classid
op_or
id|q-&gt;hgenerator
)paren
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|ENOSR
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
l_int|0x8000
)paren
r_goto
id|failure
suffix:semicolon
id|classid
op_assign
id|classid
op_or
id|q-&gt;hgenerator
suffix:semicolon
)brace
id|parent
op_assign
op_amp
id|q-&gt;link
suffix:semicolon
r_if
c_cond
(paren
id|parentid
)paren
(brace
id|parent
op_assign
id|cbq_class_lookup
c_func
(paren
id|q
comma
id|parentid
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_eq
l_int|NULL
)paren
r_goto
id|failure
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
id|cl
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|cl
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
l_int|NULL
)paren
r_goto
id|failure
suffix:semicolon
id|memset
c_func
(paren
id|cl
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cl
)paren
)paren
suffix:semicolon
id|cl-&gt;R_tab
op_assign
id|rtab
suffix:semicolon
id|rtab
op_assign
l_int|NULL
suffix:semicolon
id|cl-&gt;refcnt
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cl-&gt;q
op_assign
id|qdisc_create_dflt
c_func
(paren
id|sch-&gt;dev
comma
op_amp
id|pfifo_qdisc_ops
)paren
)paren
)paren
id|cl-&gt;q
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|cl-&gt;classid
op_assign
id|classid
suffix:semicolon
id|cl-&gt;tparent
op_assign
id|parent
suffix:semicolon
id|cl-&gt;qdisc
op_assign
id|sch
suffix:semicolon
id|cl-&gt;allot
op_assign
id|parent-&gt;allot
suffix:semicolon
id|cl-&gt;quantum
op_assign
id|cl-&gt;allot
suffix:semicolon
id|cl-&gt;weight
op_assign
id|cl-&gt;R_tab-&gt;rate.rate
suffix:semicolon
id|cl-&gt;stats.lock
op_assign
op_amp
id|sch-&gt;dev-&gt;queue_lock
suffix:semicolon
id|sch_tree_lock
c_func
(paren
id|sch
)paren
suffix:semicolon
id|cbq_link_class
c_func
(paren
id|cl
)paren
suffix:semicolon
id|cl-&gt;borrow
op_assign
id|cl-&gt;tparent
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;tparent
op_ne
op_amp
id|q-&gt;link
)paren
id|cl-&gt;share
op_assign
id|cl-&gt;tparent
suffix:semicolon
id|cbq_adjust_levels
c_func
(paren
id|parent
)paren
suffix:semicolon
id|cl-&gt;minidle
op_assign
op_minus
l_int|0x7FFFFFFF
suffix:semicolon
id|cbq_set_lss
c_func
(paren
id|cl
comma
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_CBQ_LSSOPT
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|cbq_set_wrr
c_func
(paren
id|cl
comma
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_CBQ_WRROPT
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;ewma_log
op_eq
l_int|0
)paren
id|cl-&gt;ewma_log
op_assign
id|q-&gt;link.ewma_log
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;maxidle
op_eq
l_int|0
)paren
id|cl-&gt;maxidle
op_assign
id|q-&gt;link.maxidle
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;avpkt
op_eq
l_int|0
)paren
id|cl-&gt;avpkt
op_assign
id|q-&gt;link.avpkt
suffix:semicolon
id|cl-&gt;overlimit
op_assign
id|cbq_ovl_classic
suffix:semicolon
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CBQ_OVL_STRATEGY
op_minus
l_int|1
)braket
)paren
id|cbq_set_overlimit
c_func
(paren
id|cl
comma
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_CBQ_OVL_STRATEGY
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_CLS_POLICE
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CBQ_POLICE
op_minus
l_int|1
)braket
)paren
id|cbq_set_police
c_func
(paren
id|cl
comma
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_CBQ_POLICE
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tb
(braket
id|TCA_CBQ_FOPT
op_minus
l_int|1
)braket
)paren
id|cbq_set_fopt
c_func
(paren
id|cl
comma
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_CBQ_FOPT
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|sch_tree_unlock
c_func
(paren
id|sch
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_ESTIMATOR
r_if
c_cond
(paren
id|tca
(braket
id|TCA_RATE
op_minus
l_int|1
)braket
)paren
id|qdisc_new_estimator
c_func
(paren
op_amp
id|cl-&gt;stats
comma
id|tca
(braket
id|TCA_RATE
op_minus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
op_star
id|arg
op_assign
(paren
r_int
r_int
)paren
id|cl
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|failure
suffix:colon
id|qdisc_put_rtab
c_func
(paren
id|rtab
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|cbq_delete
r_static
r_int
id|cbq_delete
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
op_assign
(paren
r_struct
id|cbq_class
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;filters
op_logical_or
id|cl-&gt;children
op_logical_or
id|cl
op_eq
op_amp
id|q-&gt;link
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|sch_tree_lock
c_func
(paren
id|sch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl-&gt;next_alive
)paren
id|cbq_deactivate_class
c_func
(paren
id|cl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;tx_borrowed
op_eq
id|cl
)paren
id|q-&gt;tx_borrowed
op_assign
id|q-&gt;tx_class
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;tx_class
op_eq
id|cl
)paren
(brace
id|q-&gt;tx_class
op_assign
l_int|NULL
suffix:semicolon
id|q-&gt;tx_borrowed
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_CLS_POLICE
r_if
c_cond
(paren
id|q-&gt;rx_class
op_eq
id|cl
)paren
id|q-&gt;rx_class
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|cbq_unlink_class
c_func
(paren
id|cl
)paren
suffix:semicolon
id|cbq_adjust_levels
c_func
(paren
id|cl-&gt;tparent
)paren
suffix:semicolon
id|cl-&gt;defmap
op_assign
l_int|0
suffix:semicolon
id|cbq_sync_defmap
c_func
(paren
id|cl
)paren
suffix:semicolon
id|cbq_rmprio
c_func
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
id|sch_tree_unlock
c_func
(paren
id|sch
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|cl-&gt;refcnt
op_eq
l_int|0
)paren
id|cbq_destroy_class
c_func
(paren
id|cl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cbq_find_tcf
r_static
r_struct
id|tcf_proto
op_star
op_star
id|cbq_find_tcf
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
op_assign
(paren
r_struct
id|cbq_class
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
l_int|NULL
)paren
id|cl
op_assign
op_amp
id|q-&gt;link
suffix:semicolon
r_return
op_amp
id|cl-&gt;filter_list
suffix:semicolon
)brace
DECL|function|cbq_bind_filter
r_static
r_int
r_int
id|cbq_bind_filter
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|parent
comma
id|u32
id|classid
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_struct
id|cbq_class
op_star
id|p
op_assign
(paren
r_struct
id|cbq_class
op_star
)paren
id|parent
suffix:semicolon
r_struct
id|cbq_class
op_star
id|cl
op_assign
id|cbq_class_lookup
c_func
(paren
id|q
comma
id|classid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
)paren
(brace
r_if
c_cond
(paren
id|p
op_logical_and
id|p-&gt;level
op_le
id|cl-&gt;level
)paren
r_return
l_int|0
suffix:semicolon
id|cl-&gt;filters
op_increment
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|cl
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cbq_unbind_filter
r_static
r_void
id|cbq_unbind_filter
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|cbq_class
op_star
id|cl
op_assign
(paren
r_struct
id|cbq_class
op_star
)paren
id|arg
suffix:semicolon
id|cl-&gt;filters
op_decrement
suffix:semicolon
)brace
DECL|function|cbq_walk
r_static
r_void
id|cbq_walk
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|qdisc_walker
op_star
id|arg
)paren
(brace
r_struct
id|cbq_sched_data
op_star
id|q
op_assign
(paren
r_struct
id|cbq_sched_data
op_star
)paren
id|sch-&gt;data
suffix:semicolon
r_int
id|h
suffix:semicolon
r_if
c_cond
(paren
id|arg-&gt;stop
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
l_int|16
suffix:semicolon
id|h
op_increment
)paren
(brace
r_struct
id|cbq_class
op_star
id|cl
suffix:semicolon
r_for
c_loop
(paren
id|cl
op_assign
id|q-&gt;classes
(braket
id|h
)braket
suffix:semicolon
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|arg-&gt;count
OL
id|arg-&gt;skip
)paren
(brace
id|arg-&gt;count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
op_member_access_from_pointer
id|fn
c_func
(paren
id|sch
comma
(paren
r_int
r_int
)paren
id|cl
comma
id|arg
)paren
OL
l_int|0
)paren
(brace
id|arg-&gt;stop
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|arg-&gt;count
op_increment
suffix:semicolon
)brace
)brace
)brace
DECL|variable|cbq_class_ops
r_static
r_struct
id|Qdisc_class_ops
id|cbq_class_ops
op_assign
(brace
id|cbq_graft
comma
id|cbq_leaf
comma
id|cbq_get
comma
id|cbq_put
comma
id|cbq_change_class
comma
id|cbq_delete
comma
id|cbq_walk
comma
id|cbq_find_tcf
comma
id|cbq_bind_filter
comma
id|cbq_unbind_filter
comma
macro_line|#ifdef CONFIG_RTNETLINK
id|cbq_dump_class
comma
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|cbq_qdisc_ops
r_struct
id|Qdisc_ops
id|cbq_qdisc_ops
op_assign
(brace
l_int|NULL
comma
op_amp
id|cbq_class_ops
comma
l_string|&quot;cbq&quot;
comma
r_sizeof
(paren
r_struct
id|cbq_sched_data
)paren
comma
id|cbq_enqueue
comma
id|cbq_dequeue
comma
id|cbq_requeue
comma
id|cbq_drop
comma
id|cbq_init
comma
id|cbq_reset
comma
id|cbq_destroy
comma
l_int|NULL
multiline_comment|/* cbq_change */
comma
macro_line|#ifdef CONFIG_RTNETLINK
id|cbq_dump
comma
macro_line|#endif
)brace
suffix:semicolon
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|register_qdisc
c_func
(paren
op_amp
id|cbq_qdisc_ops
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|unregister_qdisc
c_func
(paren
op_amp
id|cbq_qdisc_ops
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
