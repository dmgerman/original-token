multiline_comment|/*&n; * net/sched/sch_api.c&t;Packet scheduler API.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; * Authors:&t;Alexey Kuznetsov, &lt;kuznet@ms2.inr.ac.ru&gt;&n; */
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/pkt_sched.h&gt;
DECL|macro|BUG_TRAP
mdefine_line|#define BUG_TRAP(x) if (!(x)) { printk(&quot;Assertion (&quot; #x &quot;) failed at &quot; __FILE__ &quot;(%d):&quot; __FUNCTION__ &quot;&bslash;n&quot;, __LINE__); }
macro_line|#ifdef CONFIG_RTNETLINK
r_static
r_int
id|qdisc_notify
c_func
(paren
r_struct
id|sk_buff
op_star
id|oskb
comma
r_struct
id|nlmsghdr
op_star
id|n
comma
r_struct
id|Qdisc
op_star
id|old
comma
r_struct
id|Qdisc
op_star
r_new
)paren
suffix:semicolon
r_static
r_int
id|tclass_notify
c_func
(paren
r_struct
id|sk_buff
op_star
id|oskb
comma
r_struct
id|nlmsghdr
op_star
id|n
comma
r_struct
id|Qdisc
op_star
id|q
comma
r_int
r_int
id|cl
comma
r_int
id|event
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&n;   Short review.&n;   -------------&n;&n;   This file consists of two interrelated parts:&n;&n;   1. queueing disciplines manager frontend.&n;   2. traffic classes manager frontend.&n;&n;   Generally, queueing discipline (&quot;qdisc&quot;) is a black box,&n;   which is able to enqueue packets and to dequeue them (when&n;   device is ready to send something) in order and at times&n;   determined by algorithm hidden in it.&n;&n;   qdisc&squot;s are divided to two categories:&n;   - &quot;queues&quot;, which have no internal structure visible from outside.&n;   - &quot;schedulers&quot;, which split all the packets to &quot;traffic classes&quot;,&n;     using &quot;packet classifiers&quot; (look at cls_api.c)&n;&n;   In turn, classes may have child qdiscs (as rule, queues)&n;   attached to them etc. etc. etc.&n;&n;   The goal of the routines in this file is to translate&n;   information supplied by user in the form of handles&n;   to more intelligible for kernel form, to make some sanity&n;   checks and part of work, which is common to all qdiscs&n;   and to provide rtnetlink notifications.&n;&n;   All real intelligent work is done inside qdisc modules.&n;&n;&n;&n;   Every discipline has two major routines: enqueue and dequeue.&n;&n;   ---dequeue&n;&n;   dequeue usually returns a skb to send. It is allowed to return NULL,&n;   but it does not mean that queue is empty, it just means that&n;   discipline does not want to send anything this time.&n;   Queue is really empty if q-&gt;q.qlen == 0.&n;   For complicated disciplines with multiple queues q-&gt;q is not&n;   real packet queue, but however q-&gt;q.qlen must be valid.&n;&n;   ---enqueue&n;&n;   enqueue returns number of enqueued packets i.e. this number is 1,&n;   if packet was enqueued sucessfully and &lt;1 if something (not&n;   necessary THIS packet) was dropped.&n;&n;   Auxiliary routines:&n;&n;   ---requeue&n;&n;   requeues once dequeued packet. It is used for non-standard or&n;   just buggy devices, which can defer output even if dev-&gt;tbusy=0.&n;&n;   ---reset&n;&n;   returns qdisc to initial state: purge all buffers, clear all&n;   timers, counters (except for statistics) etc.&n;&n;   ---init&n;&n;   initializes newly created qdisc.&n;&n;   ---destroy&n;&n;   destroys resources allocated by init and during lifetime of qdisc.&n; */
multiline_comment|/************************************************&n; *&t;Queueing disciplines manipulation.&t;*&n; ************************************************/
multiline_comment|/* The list of all installed queueing disciplines. */
DECL|variable|qdisc_base
r_static
r_struct
id|Qdisc_ops
op_star
id|qdisc_base
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Register/uregister queueing discipline */
DECL|function|register_qdisc
r_int
id|register_qdisc
c_func
(paren
r_struct
id|Qdisc_ops
op_star
id|qops
)paren
(brace
r_struct
id|Qdisc_ops
op_star
id|q
comma
op_star
op_star
id|qp
suffix:semicolon
r_for
c_loop
(paren
id|qp
op_assign
op_amp
id|qdisc_base
suffix:semicolon
(paren
id|q
op_assign
op_star
id|qp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|qp
op_assign
op_amp
id|q-&gt;next
)paren
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|qops-&gt;id
comma
id|q-&gt;id
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|qops-&gt;enqueue
op_eq
l_int|NULL
)paren
id|qops-&gt;enqueue
op_assign
id|noop_qdisc_ops.enqueue
suffix:semicolon
r_if
c_cond
(paren
id|qops-&gt;requeue
op_eq
l_int|NULL
)paren
id|qops-&gt;requeue
op_assign
id|noop_qdisc_ops.requeue
suffix:semicolon
r_if
c_cond
(paren
id|qops-&gt;dequeue
op_eq
l_int|NULL
)paren
id|qops-&gt;dequeue
op_assign
id|noop_qdisc_ops.dequeue
suffix:semicolon
id|qops-&gt;next
op_assign
l_int|NULL
suffix:semicolon
op_star
id|qp
op_assign
id|qops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unregister_qdisc
r_int
id|unregister_qdisc
c_func
(paren
r_struct
id|Qdisc_ops
op_star
id|qops
)paren
(brace
r_struct
id|Qdisc_ops
op_star
id|q
comma
op_star
op_star
id|qp
suffix:semicolon
r_for
c_loop
(paren
id|qp
op_assign
op_amp
id|qdisc_base
suffix:semicolon
(paren
id|q
op_assign
op_star
id|qp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|qp
op_assign
op_amp
id|q-&gt;next
)paren
r_if
c_cond
(paren
id|q
op_eq
id|qops
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
op_star
id|qp
op_assign
id|q-&gt;next
suffix:semicolon
id|q-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We know handle. Find qdisc among all qdisc&squot;s attached to device&n;   (root qdisc, all its children, children of children etc.)&n; */
DECL|function|qdisc_lookup
r_struct
id|Qdisc
op_star
id|qdisc_lookup
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u32
id|handle
)paren
(brace
r_struct
id|Qdisc
op_star
id|q
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
id|dev-&gt;qdisc_list
suffix:semicolon
id|q
suffix:semicolon
id|q
op_assign
id|q-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|q-&gt;handle
op_eq
id|handle
)paren
r_return
id|q
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* We know classid. Find qdisc among all qdisc&squot;s attached to device&n;   (root qdisc, all its children, children of children etc.)&n; */
DECL|function|qdisc_lookup_class
r_struct
id|Qdisc
op_star
id|qdisc_lookup_class
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u32
id|classid
)paren
(brace
r_struct
id|Qdisc
op_star
id|q
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
id|dev-&gt;qdisc_list
suffix:semicolon
id|q
suffix:semicolon
id|q
op_assign
id|q-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|q-&gt;classid
op_eq
id|classid
)paren
r_return
id|q
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Find queueing discipline by name */
DECL|function|qdisc_lookup_ops
r_struct
id|Qdisc_ops
op_star
id|qdisc_lookup_ops
c_func
(paren
r_struct
id|rtattr
op_star
id|kind
)paren
(brace
r_struct
id|Qdisc_ops
op_star
id|q
suffix:semicolon
r_if
c_cond
(paren
id|kind
)paren
(brace
r_for
c_loop
(paren
id|q
op_assign
id|qdisc_base
suffix:semicolon
id|q
suffix:semicolon
id|q
op_assign
id|q-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|rtattr_strcmp
c_func
(paren
id|kind
comma
id|q-&gt;id
)paren
op_eq
l_int|0
)paren
r_return
id|q
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|qdisc_rtab_list
r_static
r_struct
id|qdisc_rate_table
op_star
id|qdisc_rtab_list
suffix:semicolon
DECL|function|qdisc_get_rtab
r_struct
id|qdisc_rate_table
op_star
id|qdisc_get_rtab
c_func
(paren
r_struct
id|tc_ratespec
op_star
id|r
comma
r_struct
id|rtattr
op_star
id|tab
)paren
(brace
r_struct
id|qdisc_rate_table
op_star
id|rtab
suffix:semicolon
r_for
c_loop
(paren
id|rtab
op_assign
id|qdisc_rtab_list
suffix:semicolon
id|rtab
suffix:semicolon
id|rtab
op_assign
id|rtab-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
op_amp
id|rtab-&gt;rate
comma
id|r
comma
r_sizeof
(paren
r_struct
id|tc_ratespec
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|rtab-&gt;refcnt
op_increment
suffix:semicolon
r_return
id|rtab
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tab
op_eq
l_int|NULL
op_logical_or
id|r-&gt;rate
op_eq
l_int|0
op_logical_or
id|r-&gt;cell_log
op_eq
l_int|0
op_logical_or
id|RTA_PAYLOAD
c_func
(paren
id|tab
)paren
op_ne
l_int|1024
)paren
r_return
l_int|NULL
suffix:semicolon
id|rtab
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|rtab
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtab
)paren
(brace
id|rtab-&gt;rate
op_assign
op_star
id|r
suffix:semicolon
id|rtab-&gt;refcnt
op_assign
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|rtab-&gt;data
comma
id|RTA_DATA
c_func
(paren
id|tab
)paren
comma
l_int|1024
)paren
suffix:semicolon
id|rtab-&gt;next
op_assign
id|qdisc_rtab_list
suffix:semicolon
id|qdisc_rtab_list
op_assign
id|rtab
suffix:semicolon
)brace
r_return
id|rtab
suffix:semicolon
)brace
DECL|function|qdisc_put_rtab
r_void
id|qdisc_put_rtab
c_func
(paren
r_struct
id|qdisc_rate_table
op_star
id|tab
)paren
(brace
r_struct
id|qdisc_rate_table
op_star
id|rtab
comma
op_star
op_star
id|rtabp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tab
op_logical_or
op_decrement
id|tab-&gt;refcnt
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|rtabp
op_assign
op_amp
id|qdisc_rtab_list
suffix:semicolon
(paren
id|rtab
op_assign
op_star
id|rtabp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|rtabp
op_assign
op_amp
id|rtab-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|rtab
op_eq
id|tab
)paren
(brace
op_star
id|rtabp
op_assign
id|rtab-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|rtab
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Allocate an unique handle from space managed by kernel */
DECL|function|qdisc_alloc_handle
id|u32
id|qdisc_alloc_handle
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
op_assign
l_int|0x10000
suffix:semicolon
r_static
id|u32
id|autohandle
op_assign
id|TC_H_MAKE
c_func
(paren
l_int|0x80000000U
comma
l_int|0
)paren
suffix:semicolon
r_do
(brace
id|autohandle
op_add_assign
id|TC_H_MAKE
c_func
(paren
l_int|0x10000U
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|autohandle
op_eq
id|TC_H_MAKE
c_func
(paren
id|TC_H_ROOT
comma
l_int|0
)paren
)paren
id|autohandle
op_assign
id|TC_H_MAKE
c_func
(paren
l_int|0x80000000U
comma
l_int|0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|qdisc_lookup
c_func
(paren
id|dev
comma
id|autohandle
)paren
op_logical_and
op_decrement
id|i
OG
l_int|0
)paren
suffix:semicolon
r_return
id|i
OG
l_int|0
ques
c_cond
id|autohandle
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Graft qdisc &quot;new&quot; to class &quot;classid&quot; of qdisc &quot;parent&quot; or&n;   to device &quot;dev&quot;.&n;&n;   Old qdisc is not destroyed but returned in *old.&n; */
DECL|function|qdisc_graft
r_int
id|qdisc_graft
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|Qdisc
op_star
id|parent
comma
id|u32
id|classid
comma
r_struct
id|Qdisc
op_star
r_new
comma
r_struct
id|Qdisc
op_star
op_star
id|old
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_eq
l_int|NULL
)paren
(brace
id|BUG_TRAP
c_func
(paren
id|classid
op_eq
id|TC_H_ROOT
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
)paren
(brace
r_new
op_member_access_from_pointer
id|parent
op_assign
l_int|NULL
suffix:semicolon
r_new
op_member_access_from_pointer
id|classid
op_assign
id|TC_H_ROOT
suffix:semicolon
)brace
op_star
id|old
op_assign
id|dev_set_scheduler
c_func
(paren
id|dev
comma
r_new
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|Qdisc_class_ops
op_star
id|cops
op_assign
id|parent-&gt;ops-&gt;cl_ops
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|classid
op_ne
id|TC_H_ROOT
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|cops
)paren
(brace
r_int
r_int
id|cl
op_assign
id|cops
op_member_access_from_pointer
id|get
c_func
(paren
id|parent
comma
id|classid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
)paren
(brace
id|err
op_assign
id|cops
op_member_access_from_pointer
id|graft
c_func
(paren
id|parent
comma
id|cl
comma
r_new
comma
id|old
)paren
suffix:semicolon
id|cops
op_member_access_from_pointer
id|put
c_func
(paren
id|parent
comma
id|cl
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|err
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_RTNETLINK
multiline_comment|/*&n;   Allocate and initialize new qdisc.&n;&n;   Parameters are passed via opt.&n; */
r_static
r_struct
id|Qdisc
op_star
DECL|function|qdisc_create
id|qdisc_create
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|Qdisc_ops
op_star
id|ops
comma
id|u32
id|handle
comma
id|u32
id|parentid
comma
r_struct
id|rtattr
op_star
op_star
id|tca
comma
r_int
op_star
id|errp
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|rtattr
op_star
id|kind
op_assign
id|tca
(braket
id|TCA_KIND
op_minus
l_int|1
)braket
suffix:semicolon
r_struct
id|Qdisc
op_star
id|sch
op_assign
l_int|NULL
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
r_new
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ops
op_eq
l_int|NULL
)paren
(brace
id|ops
op_assign
id|qdisc_lookup_ops
c_func
(paren
id|kind
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ops
op_eq
l_int|NULL
)paren
r_goto
id|err_out
suffix:semicolon
r_new
op_assign
l_int|1
suffix:semicolon
)brace
id|size
op_assign
r_sizeof
(paren
op_star
id|sch
)paren
op_plus
id|ops-&gt;priv_size
suffix:semicolon
id|sch
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sch
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* Grrr... Resolve race condition with module unload */
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
r_new
)paren
(brace
r_if
c_cond
(paren
id|ops
op_ne
id|qdisc_lookup_ops
c_func
(paren
id|kind
)paren
)paren
r_goto
id|err_out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|kind
)paren
(brace
r_if
c_cond
(paren
id|rtattr_strcmp
c_func
(paren
id|kind
comma
id|ops-&gt;id
)paren
)paren
r_goto
id|err_out
suffix:semicolon
)brace
id|memset
c_func
(paren
id|sch
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|sch-&gt;q
)paren
suffix:semicolon
id|sch-&gt;ops
op_assign
id|ops
suffix:semicolon
id|sch-&gt;enqueue
op_assign
id|ops-&gt;enqueue
suffix:semicolon
id|sch-&gt;dequeue
op_assign
id|ops-&gt;dequeue
suffix:semicolon
id|sch-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|handle
op_eq
l_int|0
)paren
(brace
id|handle
op_assign
id|qdisc_alloc_handle
c_func
(paren
id|dev
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|handle
op_eq
l_int|0
)paren
r_goto
id|err_out
suffix:semicolon
)brace
id|sch-&gt;handle
op_assign
id|handle
suffix:semicolon
id|sch-&gt;classid
op_assign
id|parentid
suffix:semicolon
r_if
c_cond
(paren
id|ops-&gt;init
op_logical_and
(paren
id|err
op_assign
id|ops
op_member_access_from_pointer
id|init
c_func
(paren
id|sch
comma
id|tca
(braket
id|TCA_OPTIONS
op_minus
l_int|1
)braket
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|sch-&gt;next
op_assign
id|dev-&gt;qdisc_list
suffix:semicolon
id|dev-&gt;qdisc_list
op_assign
id|sch
suffix:semicolon
macro_line|#ifdef CONFIG_NET_ESTIMATOR
r_if
c_cond
(paren
id|tca
(braket
id|TCA_RATE
op_minus
l_int|1
)braket
)paren
id|qdisc_new_estimator
c_func
(paren
op_amp
id|sch-&gt;stats
comma
id|tca
(braket
id|TCA_RATE
op_minus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
r_return
id|sch
suffix:semicolon
)brace
id|err_out
suffix:colon
op_star
id|errp
op_assign
id|err
suffix:semicolon
r_if
c_cond
(paren
id|sch
)paren
id|kfree
c_func
(paren
id|sch
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;   Create/delete/change/get qdisc.&n; */
DECL|function|tc_ctl_qdisc
r_static
r_int
id|tc_ctl_qdisc
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|nlmsghdr
op_star
id|n
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|tcmsg
op_star
id|tcm
op_assign
id|NLMSG_DATA
c_func
(paren
id|n
)paren
suffix:semicolon
r_struct
id|rtattr
op_star
op_star
id|tca
op_assign
id|arg
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
id|u32
id|clid
op_assign
id|tcm-&gt;tcm_parent
suffix:semicolon
r_struct
id|Qdisc
op_star
id|old_q
suffix:semicolon
r_struct
id|Qdisc
op_star
id|q
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|Qdisc
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|Qdisc
op_star
id|leaf
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|Qdisc_ops
op_star
id|qops
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/* Find device */
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|dev_get_by_index
c_func
(paren
id|tcm-&gt;tcm_ifindex
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* If parent is specified, it must exist&n;&t;   and tcm_parent selects a class in parent which&n;&t;   new qdisc will be attached to.&n;&n;&t;   The place may be already busy by another qdisc,&n;&t;   remember this fact, if it was not auto-created discipline.&n;&t; */
r_if
c_cond
(paren
id|clid
)paren
(brace
r_if
c_cond
(paren
id|clid
op_ne
id|TC_H_ROOT
)paren
(brace
id|p
op_assign
id|qdisc_lookup
c_func
(paren
id|dev
comma
id|TC_H_MAJ
c_func
(paren
id|clid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|leaf
op_assign
id|qdisc_lookup_class
c_func
(paren
id|dev
comma
id|clid
)paren
suffix:semicolon
)brace
r_else
id|leaf
op_assign
id|dev-&gt;qdisc_sleeping
suffix:semicolon
r_if
c_cond
(paren
id|leaf
op_logical_and
id|leaf-&gt;flags
op_amp
id|TCQ_F_DEFAULT
op_logical_and
id|n-&gt;nlmsg_type
op_eq
id|RTM_NEWQDISC
)paren
id|leaf
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;   Also, leaf may be exactly that qdisc, which we want&n;&t;&t;   to control. Remember this to avoid one more qdisc_lookup.&n;&t;&t; */
r_if
c_cond
(paren
id|leaf
op_logical_and
id|leaf-&gt;handle
op_eq
id|tcm-&gt;tcm_handle
)paren
id|q
op_assign
id|leaf
suffix:semicolon
)brace
multiline_comment|/* Try to locate the discipline */
r_if
c_cond
(paren
id|tcm-&gt;tcm_handle
op_logical_and
id|q
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|TC_H_MIN
c_func
(paren
id|tcm-&gt;tcm_handle
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|q
op_assign
id|qdisc_lookup
c_func
(paren
id|dev
comma
id|tcm-&gt;tcm_handle
)paren
suffix:semicolon
)brace
multiline_comment|/* If discipline already exists, check that its real parent&n;&t;   matches to one selected by tcm_parent.&n;&t; */
r_if
c_cond
(paren
id|q
)paren
(brace
r_if
c_cond
(paren
id|clid
op_logical_and
id|p
op_ne
id|q-&gt;parent
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|BUG_TRAP
c_func
(paren
op_logical_neg
id|leaf
op_logical_or
id|leaf
op_eq
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tca
(braket
id|TCA_KIND
op_minus
l_int|1
)braket
op_logical_and
id|rtattr_strcmp
c_func
(paren
id|tca
(braket
id|TCA_KIND
op_minus
l_int|1
)braket
comma
id|q-&gt;ops-&gt;id
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|clid
op_assign
id|q-&gt;classid
suffix:semicolon
r_goto
id|process_existing
suffix:semicolon
)brace
multiline_comment|/* The discipline is known not to exist.&n;&t;   If parent was not selected too, return error.&n;&t; */
r_if
c_cond
(paren
id|clid
op_eq
l_int|0
)paren
r_return
id|tcm-&gt;tcm_handle
ques
c_cond
op_minus
id|ENOENT
suffix:colon
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Check for the case when leaf is exactly the thing,&n;&t;   that you want.&n;&t; */
r_if
c_cond
(paren
id|leaf
op_logical_and
id|tcm-&gt;tcm_handle
op_eq
l_int|0
)paren
(brace
id|q
op_assign
id|leaf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tca
(braket
id|TCA_KIND
op_minus
l_int|1
)braket
op_logical_or
id|rtattr_strcmp
c_func
(paren
id|tca
(braket
id|TCA_KIND
op_minus
l_int|1
)braket
comma
id|q-&gt;ops-&gt;id
)paren
op_eq
l_int|0
)paren
r_goto
id|process_existing
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n-&gt;nlmsg_type
op_ne
id|RTM_NEWQDISC
op_logical_or
op_logical_neg
(paren
id|n-&gt;nlmsg_flags
op_amp
id|NLM_F_CREATE
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|leaf
op_logical_and
id|n-&gt;nlmsg_flags
op_amp
id|NLM_F_EXCL
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
id|create_and_graft
suffix:colon
id|q
op_assign
id|qdisc_create
c_func
(paren
id|dev
comma
id|qops
comma
id|tcm-&gt;tcm_handle
comma
id|clid
comma
id|tca
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
op_eq
l_int|NULL
)paren
r_return
id|err
suffix:semicolon
id|graft
suffix:colon
id|err
op_assign
id|qdisc_graft
c_func
(paren
id|dev
comma
id|p
comma
id|clid
comma
id|q
comma
op_amp
id|old_q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_if
c_cond
(paren
id|q
)paren
id|qdisc_destroy
c_func
(paren
id|q
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|qdisc_notify
c_func
(paren
id|skb
comma
id|n
comma
id|old_q
comma
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_q
)paren
id|qdisc_destroy
c_func
(paren
id|old_q
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|process_existing
suffix:colon
r_switch
c_cond
(paren
id|n-&gt;nlmsg_type
)paren
(brace
r_case
id|RTM_NEWQDISC
suffix:colon
r_if
c_cond
(paren
id|n-&gt;nlmsg_flags
op_amp
id|NLM_F_EXCL
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
id|qops
op_assign
id|q-&gt;ops
suffix:semicolon
r_goto
id|create_and_graft
suffix:semicolon
r_case
id|RTM_GETQDISC
suffix:colon
id|qdisc_notify
c_func
(paren
id|skb
comma
id|n
comma
l_int|NULL
comma
id|q
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|RTM_DELQDISC
suffix:colon
id|q
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|graft
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|tc_fill_qdisc
r_static
r_int
id|tc_fill_qdisc
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|q
comma
id|pid_t
id|pid
comma
id|u32
id|seq
comma
r_int
id|flags
comma
r_int
id|event
)paren
(brace
r_struct
id|tcmsg
op_star
id|tcm
suffix:semicolon
r_struct
id|nlmsghdr
op_star
id|nlh
suffix:semicolon
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
id|nlh
op_assign
id|NLMSG_PUT
c_func
(paren
id|skb
comma
id|pid
comma
id|seq
comma
id|event
comma
r_sizeof
(paren
op_star
id|tcm
)paren
)paren
suffix:semicolon
id|nlh-&gt;nlmsg_flags
op_assign
id|flags
suffix:semicolon
id|tcm
op_assign
id|NLMSG_DATA
c_func
(paren
id|nlh
)paren
suffix:semicolon
id|tcm-&gt;tcm_family
op_assign
id|AF_UNSPEC
suffix:semicolon
id|tcm-&gt;tcm_ifindex
op_assign
id|q-&gt;dev
ques
c_cond
id|q-&gt;dev-&gt;ifindex
suffix:colon
l_int|0
suffix:semicolon
id|tcm-&gt;tcm_parent
op_assign
id|q-&gt;classid
suffix:semicolon
id|tcm-&gt;tcm_handle
op_assign
id|q-&gt;handle
suffix:semicolon
id|tcm-&gt;tcm_info
op_assign
l_int|0
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_KIND
comma
id|IFNAMSIZ
comma
id|q-&gt;ops-&gt;id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;ops-&gt;dump
op_logical_and
id|q-&gt;ops
op_member_access_from_pointer
id|dump
c_func
(paren
id|q
comma
id|skb
)paren
OL
l_int|0
)paren
r_goto
id|rtattr_failure
suffix:semicolon
id|q-&gt;stats.qlen
op_assign
id|q-&gt;q.qlen
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_STATS
comma
r_sizeof
(paren
id|q-&gt;stats
)paren
comma
op_amp
id|q-&gt;stats
)paren
suffix:semicolon
id|nlh-&gt;nlmsg_len
op_assign
id|skb-&gt;tail
op_minus
id|b
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|nlmsg_failure
suffix:colon
id|rtattr_failure
suffix:colon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|qdisc_notify
r_static
r_int
id|qdisc_notify
c_func
(paren
r_struct
id|sk_buff
op_star
id|oskb
comma
r_struct
id|nlmsghdr
op_star
id|n
comma
r_struct
id|Qdisc
op_star
id|old
comma
r_struct
id|Qdisc
op_star
r_new
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|pid_t
id|pid
op_assign
id|oskb
ques
c_cond
id|NETLINK_CB
c_func
(paren
id|oskb
)paren
dot
id|pid
suffix:colon
l_int|0
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|NLMSG_GOODSIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
op_minus
id|ENOBUFS
suffix:semicolon
r_if
c_cond
(paren
id|old
op_logical_and
op_logical_neg
(paren
id|old-&gt;flags
op_amp
id|TCQ_F_DEFAULT
)paren
)paren
(brace
r_if
c_cond
(paren
id|tc_fill_qdisc
c_func
(paren
id|skb
comma
id|old
comma
id|pid
comma
id|n-&gt;nlmsg_seq
comma
l_int|0
comma
id|RTM_DELQDISC
)paren
OL
l_int|0
)paren
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
r_new
)paren
(brace
r_if
c_cond
(paren
id|tc_fill_qdisc
c_func
(paren
id|skb
comma
r_new
comma
id|pid
comma
id|n-&gt;nlmsg_seq
comma
id|old
ques
c_cond
id|NLM_F_REPLACE
suffix:colon
l_int|0
comma
id|RTM_NEWQDISC
)paren
OL
l_int|0
)paren
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;len
)paren
r_return
id|rtnetlink_send
c_func
(paren
id|skb
comma
id|pid
comma
id|RTMGRP_TC
comma
id|n-&gt;nlmsg_flags
op_amp
id|NLM_F_ECHO
)paren
suffix:semicolon
id|err_out
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|tc_dump_qdisc
r_static
r_int
id|tc_dump_qdisc
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|netlink_callback
op_star
id|cb
)paren
(brace
r_int
id|idx
comma
id|q_idx
suffix:semicolon
r_int
id|s_idx
comma
id|s_q_idx
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_struct
id|Qdisc
op_star
id|q
suffix:semicolon
id|s_idx
op_assign
id|cb-&gt;args
(braket
l_int|0
)braket
suffix:semicolon
id|s_q_idx
op_assign
id|q_idx
op_assign
id|cb-&gt;args
(braket
l_int|1
)braket
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
comma
id|idx
op_assign
l_int|0
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
comma
id|idx
op_increment
)paren
(brace
r_if
c_cond
(paren
id|idx
OL
id|s_idx
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|idx
OG
id|s_idx
)paren
id|s_q_idx
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
id|dev-&gt;qdisc_list
comma
id|q_idx
op_assign
l_int|0
suffix:semicolon
id|q
suffix:semicolon
id|q
op_assign
id|q-&gt;next
comma
id|q_idx
op_increment
)paren
(brace
r_if
c_cond
(paren
id|q_idx
OL
id|s_q_idx
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tc_fill_qdisc
c_func
(paren
id|skb
comma
id|q
comma
id|NETLINK_CB
c_func
(paren
id|cb-&gt;skb
)paren
dot
id|pid
comma
id|cb-&gt;nlh-&gt;nlmsg_seq
comma
id|NLM_F_MULTI
comma
id|RTM_NEWQDISC
)paren
op_le
l_int|0
)paren
r_goto
id|done
suffix:semicolon
)brace
)brace
id|done
suffix:colon
id|cb-&gt;args
(braket
l_int|0
)braket
op_assign
id|idx
suffix:semicolon
id|cb-&gt;args
(braket
l_int|1
)braket
op_assign
id|q_idx
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
)brace
multiline_comment|/************************************************&n; *&t;Traffic classes manipulation.&t;&t;*&n; ************************************************/
DECL|function|tc_ctl_tclass
r_static
r_int
id|tc_ctl_tclass
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|nlmsghdr
op_star
id|n
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|tcmsg
op_star
id|tcm
op_assign
id|NLMSG_DATA
c_func
(paren
id|n
)paren
suffix:semicolon
r_struct
id|rtattr
op_star
op_star
id|tca
op_assign
id|arg
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_struct
id|Qdisc
op_star
id|q
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|Qdisc_class_ops
op_star
id|cops
suffix:semicolon
r_int
r_int
id|cl
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|new_cl
suffix:semicolon
id|u32
id|pid
op_assign
id|tcm-&gt;tcm_parent
suffix:semicolon
id|u32
id|clid
op_assign
id|tcm-&gt;tcm_handle
suffix:semicolon
id|u32
id|qid
op_assign
id|TC_H_MAJ
c_func
(paren
id|clid
)paren
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|dev_get_by_index
c_func
(paren
id|tcm-&gt;tcm_ifindex
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t;   parent == TC_H_UNSPEC - unspecified parent.&n;&t;   parent == TC_H_ROOT   - class is root, which has no parent.&n;&t;   parent == X:0&t; - parent is root class.&n;&t;   parent == X:Y&t; - parent is a node in hierarchy.&n;&t;   parent == 0:Y&t; - parent is X:Y, where X:0 is qdisc.&n;&n;&t;   handle == 0:0&t; - generate handle from kernel pool.&n;&t;   handle == 0:Y&t; - class is X:Y, where X:0 is qdisc.&n;&t;   handle == X:Y&t; - clear.&n;&t;   handle == X:0&t; - root class.&n;&t; */
multiline_comment|/* Step 1. Determine qdisc handle X:0 */
r_if
c_cond
(paren
id|pid
op_ne
id|TC_H_ROOT
)paren
(brace
id|u32
id|qid1
op_assign
id|TC_H_MAJ
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qid
op_logical_and
id|qid1
)paren
(brace
multiline_comment|/* If both majors are known, they must be identical. */
r_if
c_cond
(paren
id|qid
op_ne
id|qid1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|qid1
)paren
(brace
id|qid
op_assign
id|qid1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|qid
op_eq
l_int|0
)paren
id|qid
op_assign
id|dev-&gt;qdisc_sleeping-&gt;handle
suffix:semicolon
multiline_comment|/* Now qid is genuine qdisc handle consistent&n;&t;&t;   both with parent and child.&n;&n;&t;&t;   TC_H_MAJ(pid) still may be unspecified, complete it now.&n;&t;&t; */
r_if
c_cond
(paren
id|pid
)paren
id|pid
op_assign
id|TC_H_MAKE
c_func
(paren
id|qid
comma
id|pid
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|qid
op_eq
l_int|0
)paren
id|qid
op_assign
id|dev-&gt;qdisc_sleeping-&gt;handle
suffix:semicolon
)brace
multiline_comment|/* OK. Locate qdisc */
r_if
c_cond
(paren
(paren
id|q
op_assign
id|qdisc_lookup
c_func
(paren
id|dev
comma
id|qid
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
multiline_comment|/* An check that it supports classes */
id|cops
op_assign
id|q-&gt;ops-&gt;cl_ops
suffix:semicolon
r_if
c_cond
(paren
id|cops
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Now try to get class */
r_if
c_cond
(paren
id|clid
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|pid
op_eq
id|TC_H_ROOT
)paren
id|clid
op_assign
id|qid
suffix:semicolon
)brace
r_else
id|clid
op_assign
id|TC_H_MAKE
c_func
(paren
id|qid
comma
id|clid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clid
)paren
id|cl
op_assign
id|cops
op_member_access_from_pointer
id|get
c_func
(paren
id|q
comma
id|clid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
l_int|0
)paren
(brace
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|n-&gt;nlmsg_type
op_ne
id|RTM_NEWTCLASS
op_logical_or
op_logical_neg
(paren
id|n-&gt;nlmsg_flags
op_amp
id|NLM_F_CREATE
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|n-&gt;nlmsg_type
)paren
(brace
r_case
id|RTM_NEWTCLASS
suffix:colon
id|err
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|n-&gt;nlmsg_flags
op_amp
id|NLM_F_EXCL
)paren
r_goto
id|out
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RTM_DELTCLASS
suffix:colon
id|err
op_assign
id|cops
op_member_access_from_pointer
r_delete
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
id|tclass_notify
c_func
(paren
id|skb
comma
id|n
comma
id|q
comma
id|cl
comma
id|RTM_DELTCLASS
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
id|RTM_GETTCLASS
suffix:colon
id|err
op_assign
id|tclass_notify
c_func
(paren
id|skb
comma
id|n
comma
id|q
comma
id|cl
comma
id|RTM_NEWTCLASS
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|new_cl
op_assign
id|cl
suffix:semicolon
id|err
op_assign
id|cops
op_member_access_from_pointer
id|change
c_func
(paren
id|q
comma
id|clid
comma
id|pid
comma
id|tca
comma
op_amp
id|new_cl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
id|tclass_notify
c_func
(paren
id|skb
comma
id|n
comma
id|q
comma
id|new_cl
comma
id|RTM_NEWTCLASS
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|cl
)paren
id|cops
op_member_access_from_pointer
id|put
c_func
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|tc_fill_tclass
r_static
r_int
id|tc_fill_tclass
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|q
comma
r_int
r_int
id|cl
comma
id|pid_t
id|pid
comma
id|u32
id|seq
comma
r_int
id|flags
comma
r_int
id|event
)paren
(brace
r_struct
id|tcmsg
op_star
id|tcm
suffix:semicolon
r_struct
id|nlmsghdr
op_star
id|nlh
suffix:semicolon
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
id|nlh
op_assign
id|NLMSG_PUT
c_func
(paren
id|skb
comma
id|pid
comma
id|seq
comma
id|event
comma
r_sizeof
(paren
op_star
id|tcm
)paren
)paren
suffix:semicolon
id|nlh-&gt;nlmsg_flags
op_assign
id|flags
suffix:semicolon
id|tcm
op_assign
id|NLMSG_DATA
c_func
(paren
id|nlh
)paren
suffix:semicolon
id|tcm-&gt;tcm_family
op_assign
id|AF_UNSPEC
suffix:semicolon
id|tcm-&gt;tcm_ifindex
op_assign
id|q-&gt;dev
ques
c_cond
id|q-&gt;dev-&gt;ifindex
suffix:colon
l_int|0
suffix:semicolon
id|tcm-&gt;tcm_parent
op_assign
id|q-&gt;handle
suffix:semicolon
id|tcm-&gt;tcm_handle
op_assign
id|q-&gt;handle
suffix:semicolon
id|tcm-&gt;tcm_info
op_assign
l_int|0
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_KIND
comma
id|IFNAMSIZ
comma
id|q-&gt;ops-&gt;id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;ops-&gt;cl_ops-&gt;dump
op_logical_and
id|q-&gt;ops-&gt;cl_ops
op_member_access_from_pointer
id|dump
c_func
(paren
id|q
comma
id|cl
comma
id|skb
comma
id|tcm
)paren
OL
l_int|0
)paren
r_goto
id|rtattr_failure
suffix:semicolon
id|nlh-&gt;nlmsg_len
op_assign
id|skb-&gt;tail
op_minus
id|b
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|nlmsg_failure
suffix:colon
id|rtattr_failure
suffix:colon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|tclass_notify
r_static
r_int
id|tclass_notify
c_func
(paren
r_struct
id|sk_buff
op_star
id|oskb
comma
r_struct
id|nlmsghdr
op_star
id|n
comma
r_struct
id|Qdisc
op_star
id|q
comma
r_int
r_int
id|cl
comma
r_int
id|event
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|pid_t
id|pid
op_assign
id|oskb
ques
c_cond
id|NETLINK_CB
c_func
(paren
id|oskb
)paren
dot
id|pid
suffix:colon
l_int|0
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|NLMSG_GOODSIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
op_minus
id|ENOBUFS
suffix:semicolon
r_if
c_cond
(paren
id|tc_fill_tclass
c_func
(paren
id|skb
comma
id|q
comma
id|cl
comma
id|pid
comma
id|n-&gt;nlmsg_seq
comma
l_int|0
comma
id|event
)paren
OL
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|rtnetlink_send
c_func
(paren
id|skb
comma
id|pid
comma
id|RTMGRP_TC
comma
id|n-&gt;nlmsg_flags
op_amp
id|NLM_F_ECHO
)paren
suffix:semicolon
)brace
DECL|struct|qdisc_dump_args
r_struct
id|qdisc_dump_args
(brace
DECL|member|w
r_struct
id|qdisc_walker
id|w
suffix:semicolon
DECL|member|skb
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
DECL|member|cb
r_struct
id|netlink_callback
op_star
id|cb
suffix:semicolon
)brace
suffix:semicolon
DECL|function|qdisc_class_dump
r_static
r_int
id|qdisc_class_dump
c_func
(paren
r_struct
id|Qdisc
op_star
id|q
comma
r_int
r_int
id|cl
comma
r_struct
id|qdisc_walker
op_star
id|arg
)paren
(brace
r_struct
id|qdisc_dump_args
op_star
id|a
op_assign
(paren
r_struct
id|qdisc_dump_args
op_star
)paren
id|arg
suffix:semicolon
r_return
id|tc_fill_tclass
c_func
(paren
id|a-&gt;skb
comma
id|q
comma
id|cl
comma
id|NETLINK_CB
c_func
(paren
id|a-&gt;cb-&gt;skb
)paren
dot
id|pid
comma
id|a-&gt;cb-&gt;nlh-&gt;nlmsg_seq
comma
id|NLM_F_MULTI
comma
id|RTM_NEWTCLASS
)paren
suffix:semicolon
)brace
DECL|function|tc_dump_tclass
r_static
r_int
id|tc_dump_tclass
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|netlink_callback
op_star
id|cb
)paren
(brace
r_int
id|t
suffix:semicolon
r_int
id|s_t
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_struct
id|Qdisc
op_star
id|q
suffix:semicolon
r_struct
id|tcmsg
op_star
id|tcm
op_assign
(paren
r_struct
id|tcmsg
op_star
)paren
id|NLMSG_DATA
c_func
(paren
id|cb-&gt;nlh
)paren
suffix:semicolon
r_struct
id|qdisc_dump_args
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|cb-&gt;nlh-&gt;nlmsg_len
OL
id|NLMSG_LENGTH
c_func
(paren
r_sizeof
(paren
op_star
id|tcm
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|dev_get_by_index
c_func
(paren
id|tcm-&gt;tcm_ifindex
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|s_t
op_assign
id|cb-&gt;args
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
id|dev-&gt;qdisc_list
comma
id|t
op_assign
l_int|0
suffix:semicolon
id|q
suffix:semicolon
id|q
op_assign
id|q-&gt;next
comma
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
id|t
OL
id|s_t
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;ops-&gt;cl_ops
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tcm-&gt;tcm_parent
op_logical_and
id|TC_H_MAJ
c_func
(paren
id|tcm-&gt;tcm_parent
)paren
op_ne
id|q-&gt;handle
op_logical_and
(paren
id|tcm-&gt;tcm_parent
op_ne
id|TC_H_ROOT
op_logical_or
id|q-&gt;parent
op_ne
l_int|NULL
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|t
OG
id|s_t
)paren
id|memset
c_func
(paren
op_amp
id|cb-&gt;args
(braket
l_int|1
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|cb-&gt;args
)paren
op_minus
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|arg.w.fn
op_assign
id|qdisc_class_dump
suffix:semicolon
id|arg.skb
op_assign
id|skb
suffix:semicolon
id|arg.cb
op_assign
id|cb
suffix:semicolon
id|arg.w.stop
op_assign
l_int|0
suffix:semicolon
id|arg.w.skip
op_assign
id|cb-&gt;args
(braket
l_int|1
)braket
suffix:semicolon
id|arg.w.count
op_assign
l_int|0
suffix:semicolon
id|q-&gt;ops-&gt;cl_ops
op_member_access_from_pointer
id|walk
c_func
(paren
id|q
comma
op_amp
id|arg.w
)paren
suffix:semicolon
id|cb-&gt;args
(braket
l_int|1
)braket
op_assign
id|arg.w.count
suffix:semicolon
r_if
c_cond
(paren
id|arg.w.stop
)paren
r_break
suffix:semicolon
)brace
id|cb-&gt;args
(braket
l_int|0
)braket
op_assign
id|t
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|psched_us_per_tick
r_int
id|psched_us_per_tick
op_assign
l_int|1
suffix:semicolon
DECL|variable|psched_tick_per_us
r_int
id|psched_tick_per_us
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|psched_read_proc
r_static
r_int
id|psched_read_proc
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%08x %08x&bslash;n&quot;
comma
id|psched_tick_per_us
comma
id|psched_us_per_tick
)paren
suffix:semicolon
id|len
op_sub_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
)brace
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|psched_time_base
id|psched_time_t
id|psched_time_base
suffix:semicolon
macro_line|#if PSCHED_CLOCK_SOURCE == PSCHED_CPU
DECL|variable|psched_clock_per_hz
id|psched_tdiff_t
id|psched_clock_per_hz
suffix:semicolon
DECL|variable|psched_clock_scale
r_int
id|psched_clock_scale
suffix:semicolon
macro_line|#endif
macro_line|#ifdef PSCHED_WATCHER
DECL|variable|psched_time_mark
id|u32
id|psched_time_mark
suffix:semicolon
r_static
r_void
id|psched_tick
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|variable|psched_timer
r_static
r_struct
id|timer_list
id|psched_timer
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0L
comma
id|psched_tick
)brace
suffix:semicolon
DECL|function|psched_tick
r_static
r_void
id|psched_tick
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
macro_line|#if PSCHED_CLOCK_SOURCE == PSCHED_CPU
id|psched_time_t
id|dummy_stamp
suffix:semicolon
id|PSCHED_GET_TIME
c_func
(paren
id|dummy_stamp
)paren
suffix:semicolon
id|psched_timer.expires
op_assign
id|jiffies
op_plus
l_int|4
op_star
id|HZ
suffix:semicolon
macro_line|#else
r_int
r_int
id|jiffies
op_assign
id|now
suffix:semicolon
id|psched_time_base
op_assign
(paren
(paren
id|u64
)paren
id|now
)paren
op_lshift
id|PSCHED_JSCALE
suffix:semicolon
id|psched_time_mark
op_assign
id|now
suffix:semicolon
id|psched_timer.expires
op_assign
id|jiffies
op_plus
l_int|60
op_star
l_int|60
op_star
id|HZ
suffix:semicolon
macro_line|#endif
id|add_timer
c_func
(paren
op_amp
id|psched_timer
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if PSCHED_CLOCK_SOURCE == PSCHED_CPU
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
id|psched_calibrate_clock
c_func
(paren
r_void
)paren
)paren
(brace
id|psched_time_t
id|stamp
comma
id|stamp1
suffix:semicolon
r_struct
id|timeval
id|tv
comma
id|tv1
suffix:semicolon
id|psched_tdiff_t
id|delay
suffix:semicolon
r_int
id|rdelay
suffix:semicolon
r_int
r_int
id|stop
suffix:semicolon
macro_line|#if CPU == 586 || CPU == 686
r_if
c_cond
(paren
op_logical_neg
(paren
id|boot_cpu_data.x86_capability
op_amp
id|X86_FEATURE_TSC
)paren
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef PSCHED_WATCHER
id|psched_tick
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|stop
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|10
suffix:semicolon
id|PSCHED_GET_TIME
c_func
(paren
id|stamp
)paren
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|stop
)paren
id|boundary
c_func
(paren
)paren
suffix:semicolon
id|PSCHED_GET_TIME
c_func
(paren
id|stamp1
)paren
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv1
)paren
suffix:semicolon
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
id|delay
op_assign
id|PSCHED_TDIFF
c_func
(paren
id|stamp1
comma
id|stamp
)paren
suffix:semicolon
id|rdelay
op_assign
id|tv1.tv_usec
op_minus
id|tv.tv_usec
suffix:semicolon
id|rdelay
op_add_assign
(paren
id|tv1.tv_sec
op_minus
id|tv.tv_sec
)paren
op_star
l_int|1000000
suffix:semicolon
r_if
c_cond
(paren
id|rdelay
OG
id|delay
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|delay
op_div_assign
id|rdelay
suffix:semicolon
id|psched_tick_per_us
op_assign
id|delay
suffix:semicolon
r_while
c_loop
(paren
(paren
id|delay
op_rshift_assign
l_int|1
)paren
op_ne
l_int|0
)paren
id|psched_clock_scale
op_increment
suffix:semicolon
id|psched_us_per_tick
op_assign
l_int|1
op_lshift
id|psched_clock_scale
suffix:semicolon
id|psched_clock_per_hz
op_assign
(paren
id|delay
op_star
(paren
l_int|1000000
op_div
id|HZ
)paren
)paren
op_rshift
id|psched_clock_scale
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
id|pktsched_init
c_func
(paren
r_void
)paren
)paren
(brace
macro_line|#ifdef CONFIG_PROC_FS
r_struct
id|proc_dir_entry
op_star
id|ent
suffix:semicolon
macro_line|#endif
macro_line|#if PSCHED_CLOCK_SOURCE == PSCHED_CPU
r_if
c_cond
(paren
id|psched_calibrate_clock
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#elif PSCHED_CLOCK_SOURCE == PSCHED_JIFFIES
id|psched_tick_per_us
op_assign
id|HZ
op_lshift
id|PSCHED_JSCALE
suffix:semicolon
id|psched_us_per_tick
op_assign
l_int|1000000
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_RTNETLINK
r_struct
id|rtnetlink_link
op_star
id|link_p
op_assign
id|rtnetlink_links
(braket
id|PF_UNSPEC
)braket
suffix:semicolon
multiline_comment|/* Setup rtnetlink links. It is made here to avoid&n;&t;   exporting large number of public symbols.&n;&t; */
r_if
c_cond
(paren
id|link_p
)paren
(brace
id|link_p
(braket
id|RTM_NEWQDISC
op_minus
id|RTM_BASE
)braket
dot
id|doit
op_assign
id|tc_ctl_qdisc
suffix:semicolon
id|link_p
(braket
id|RTM_DELQDISC
op_minus
id|RTM_BASE
)braket
dot
id|doit
op_assign
id|tc_ctl_qdisc
suffix:semicolon
id|link_p
(braket
id|RTM_GETQDISC
op_minus
id|RTM_BASE
)braket
dot
id|doit
op_assign
id|tc_ctl_qdisc
suffix:semicolon
id|link_p
(braket
id|RTM_GETQDISC
op_minus
id|RTM_BASE
)braket
dot
id|dumpit
op_assign
id|tc_dump_qdisc
suffix:semicolon
id|link_p
(braket
id|RTM_NEWTCLASS
op_minus
id|RTM_BASE
)braket
dot
id|doit
op_assign
id|tc_ctl_tclass
suffix:semicolon
id|link_p
(braket
id|RTM_DELTCLASS
op_minus
id|RTM_BASE
)braket
dot
id|doit
op_assign
id|tc_ctl_tclass
suffix:semicolon
id|link_p
(braket
id|RTM_GETTCLASS
op_minus
id|RTM_BASE
)braket
dot
id|doit
op_assign
id|tc_ctl_tclass
suffix:semicolon
id|link_p
(braket
id|RTM_GETTCLASS
op_minus
id|RTM_BASE
)braket
dot
id|dumpit
op_assign
id|tc_dump_tclass
suffix:semicolon
)brace
macro_line|#endif
DECL|macro|INIT_QDISC
mdefine_line|#define INIT_QDISC(name) { &bslash;&n;          extern struct Qdisc_ops name##_qdisc_ops; &bslash;&n;          register_qdisc(&amp;##name##_qdisc_ops); &bslash;&n;&t;}
id|INIT_QDISC
c_func
(paren
id|pfifo
)paren
suffix:semicolon
id|INIT_QDISC
c_func
(paren
id|bfifo
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_SCH_CBQ
id|INIT_QDISC
c_func
(paren
id|cbq
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_CSZ
id|INIT_QDISC
c_func
(paren
id|csz
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_HPFQ
id|INIT_QDISC
c_func
(paren
id|hpfq
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_HFSC
id|INIT_QDISC
c_func
(paren
id|hfsc
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_RED
id|INIT_QDISC
c_func
(paren
id|red
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_SFQ
id|INIT_QDISC
c_func
(paren
id|sfq
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_TBF
id|INIT_QDISC
c_func
(paren
id|tbf
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_TEQL
id|teql_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_PRIO
id|INIT_QDISC
c_func
(paren
id|prio
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_CLS
id|tc_filter_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_PROC_FS
id|ent
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;net/psched&quot;
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ent-&gt;read_proc
op_assign
id|psched_read_proc
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
eof
