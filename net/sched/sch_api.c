multiline_comment|/*&n; * net/sched/sch_api.c&t;Packet scheduler API.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; * Authors:&t;Alexey Kuznetsov, &lt;kuznet@ms2.inr.ac.ru&gt;&n; *&n; * Fixes:&n; *&n; * Rani Assaf &lt;rani@magic.metawire.com&gt; :980802: JIFFIES and CPU clock sources are repaired.&n; * Eduardo J. Blanco &lt;ejbs@netlabs.com.uy&gt; :990222: kmod support&n; * Jamal Hadi Salim &lt;hadi@nortelnetworks.com&gt;: 990601: ingress support&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/pkt_sched.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#ifdef CONFIG_RTNETLINK
r_static
r_int
id|qdisc_notify
c_func
(paren
r_struct
id|sk_buff
op_star
id|oskb
comma
r_struct
id|nlmsghdr
op_star
id|n
comma
id|u32
id|clid
comma
r_struct
id|Qdisc
op_star
id|old
comma
r_struct
id|Qdisc
op_star
r_new
)paren
suffix:semicolon
r_static
r_int
id|tclass_notify
c_func
(paren
r_struct
id|sk_buff
op_star
id|oskb
comma
r_struct
id|nlmsghdr
op_star
id|n
comma
r_struct
id|Qdisc
op_star
id|q
comma
r_int
r_int
id|cl
comma
r_int
id|event
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&n;   Short review.&n;   -------------&n;&n;   This file consists of two interrelated parts:&n;&n;   1. queueing disciplines manager frontend.&n;   2. traffic classes manager frontend.&n;&n;   Generally, queueing discipline (&quot;qdisc&quot;) is a black box,&n;   which is able to enqueue packets and to dequeue them (when&n;   device is ready to send something) in order and at times&n;   determined by algorithm hidden in it.&n;&n;   qdisc&squot;s are divided to two categories:&n;   - &quot;queues&quot;, which have no internal structure visible from outside.&n;   - &quot;schedulers&quot;, which split all the packets to &quot;traffic classes&quot;,&n;     using &quot;packet classifiers&quot; (look at cls_api.c)&n;&n;   In turn, classes may have child qdiscs (as rule, queues)&n;   attached to them etc. etc. etc.&n;&n;   The goal of the routines in this file is to translate&n;   information supplied by user in the form of handles&n;   to more intelligible for kernel form, to make some sanity&n;   checks and part of work, which is common to all qdiscs&n;   and to provide rtnetlink notifications.&n;&n;   All real intelligent work is done inside qdisc modules.&n;&n;&n;&n;   Every discipline has two major routines: enqueue and dequeue.&n;&n;   ---dequeue&n;&n;   dequeue usually returns a skb to send. It is allowed to return NULL,&n;   but it does not mean that queue is empty, it just means that&n;   discipline does not want to send anything this time.&n;   Queue is really empty if q-&gt;q.qlen == 0.&n;   For complicated disciplines with multiple queues q-&gt;q is not&n;   real packet queue, but however q-&gt;q.qlen must be valid.&n;&n;   ---enqueue&n;&n;   enqueue returns 0, if packet was enqueued successfully.&n;   If packet (this one or another one) was dropped, it returns&n;   not zero error code.&n;   NET_XMIT_DROP &t;- this packet dropped&n;     Expected action: do not backoff, but wait until queue will clear.&n;   NET_XMIT_CN&t; &t;- probably this packet enqueued, but another one dropped.&n;     Expected action: backoff or ignore&n;   NET_XMIT_POLICED&t;- dropped by police.&n;     Expected action: backoff or error to real-time apps.&n;&n;   Auxiliary routines:&n;&n;   ---requeue&n;&n;   requeues once dequeued packet. It is used for non-standard or&n;   just buggy devices, which can defer output even if dev-&gt;tbusy=0.&n;&n;   ---reset&n;&n;   returns qdisc to initial state: purge all buffers, clear all&n;   timers, counters (except for statistics) etc.&n;&n;   ---init&n;&n;   initializes newly created qdisc.&n;&n;   ---destroy&n;&n;   destroys resources allocated by init and during lifetime of qdisc.&n;&n;   ---change&n;&n;   changes qdisc parameters.&n; */
multiline_comment|/* Protects list of registered TC modules. It is pure SMP lock. */
DECL|variable|qdisc_mod_lock
r_static
id|rwlock_t
id|qdisc_mod_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/************************************************&n; *&t;Queueing disciplines manipulation.&t;*&n; ************************************************/
multiline_comment|/* The list of all installed queueing disciplines. */
DECL|variable|qdisc_base
r_static
r_struct
id|Qdisc_ops
op_star
id|qdisc_base
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Register/uregister queueing discipline */
DECL|function|register_qdisc
r_int
id|register_qdisc
c_func
(paren
r_struct
id|Qdisc_ops
op_star
id|qops
)paren
(brace
r_struct
id|Qdisc_ops
op_star
id|q
comma
op_star
op_star
id|qp
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|qdisc_mod_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|qp
op_assign
op_amp
id|qdisc_base
suffix:semicolon
(paren
id|q
op_assign
op_star
id|qp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|qp
op_assign
op_amp
id|q-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|qops-&gt;id
comma
id|q-&gt;id
)paren
op_eq
l_int|0
)paren
(brace
id|write_unlock
c_func
(paren
op_amp
id|qdisc_mod_lock
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|qops-&gt;enqueue
op_eq
l_int|NULL
)paren
id|qops-&gt;enqueue
op_assign
id|noop_qdisc_ops.enqueue
suffix:semicolon
r_if
c_cond
(paren
id|qops-&gt;requeue
op_eq
l_int|NULL
)paren
id|qops-&gt;requeue
op_assign
id|noop_qdisc_ops.requeue
suffix:semicolon
r_if
c_cond
(paren
id|qops-&gt;dequeue
op_eq
l_int|NULL
)paren
id|qops-&gt;dequeue
op_assign
id|noop_qdisc_ops.dequeue
suffix:semicolon
id|qops-&gt;next
op_assign
l_int|NULL
suffix:semicolon
op_star
id|qp
op_assign
id|qops
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|qdisc_mod_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unregister_qdisc
r_int
id|unregister_qdisc
c_func
(paren
r_struct
id|Qdisc_ops
op_star
id|qops
)paren
(brace
r_struct
id|Qdisc_ops
op_star
id|q
comma
op_star
op_star
id|qp
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|qdisc_mod_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|qp
op_assign
op_amp
id|qdisc_base
suffix:semicolon
(paren
id|q
op_assign
op_star
id|qp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|qp
op_assign
op_amp
id|q-&gt;next
)paren
r_if
c_cond
(paren
id|q
op_eq
id|qops
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|q
)paren
(brace
op_star
id|qp
op_assign
id|q-&gt;next
suffix:semicolon
id|q-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|qdisc_mod_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* We know handle. Find qdisc among all qdisc&squot;s attached to device&n;   (root qdisc, all its children, children of children etc.)&n; */
DECL|function|qdisc_lookup
r_struct
id|Qdisc
op_star
id|qdisc_lookup
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u32
id|handle
)paren
(brace
r_struct
id|Qdisc
op_star
id|q
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
id|dev-&gt;qdisc_list
suffix:semicolon
id|q
suffix:semicolon
id|q
op_assign
id|q-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|q-&gt;handle
op_eq
id|handle
)paren
r_return
id|q
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|qdisc_leaf
r_struct
id|Qdisc
op_star
id|qdisc_leaf
c_func
(paren
r_struct
id|Qdisc
op_star
id|p
comma
id|u32
id|classid
)paren
(brace
r_int
r_int
id|cl
suffix:semicolon
r_struct
id|Qdisc
op_star
id|leaf
suffix:semicolon
r_struct
id|Qdisc_class_ops
op_star
id|cops
op_assign
id|p-&gt;ops-&gt;cl_ops
suffix:semicolon
r_if
c_cond
(paren
id|cops
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|cl
op_assign
id|cops
op_member_access_from_pointer
id|get
c_func
(paren
id|p
comma
id|classid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|leaf
op_assign
id|cops
op_member_access_from_pointer
id|leaf
c_func
(paren
id|p
comma
id|cl
)paren
suffix:semicolon
id|cops
op_member_access_from_pointer
id|put
c_func
(paren
id|p
comma
id|cl
)paren
suffix:semicolon
r_return
id|leaf
suffix:semicolon
)brace
multiline_comment|/* Find queueing discipline by name */
DECL|function|qdisc_lookup_ops
r_struct
id|Qdisc_ops
op_star
id|qdisc_lookup_ops
c_func
(paren
r_struct
id|rtattr
op_star
id|kind
)paren
(brace
r_struct
id|Qdisc_ops
op_star
id|q
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|kind
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|qdisc_mod_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
id|qdisc_base
suffix:semicolon
id|q
suffix:semicolon
id|q
op_assign
id|q-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|rtattr_strcmp
c_func
(paren
id|kind
comma
id|q-&gt;id
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|qdisc_mod_lock
)paren
suffix:semicolon
)brace
r_return
id|q
suffix:semicolon
)brace
DECL|variable|qdisc_rtab_list
r_static
r_struct
id|qdisc_rate_table
op_star
id|qdisc_rtab_list
suffix:semicolon
DECL|function|qdisc_get_rtab
r_struct
id|qdisc_rate_table
op_star
id|qdisc_get_rtab
c_func
(paren
r_struct
id|tc_ratespec
op_star
id|r
comma
r_struct
id|rtattr
op_star
id|tab
)paren
(brace
r_struct
id|qdisc_rate_table
op_star
id|rtab
suffix:semicolon
r_for
c_loop
(paren
id|rtab
op_assign
id|qdisc_rtab_list
suffix:semicolon
id|rtab
suffix:semicolon
id|rtab
op_assign
id|rtab-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
op_amp
id|rtab-&gt;rate
comma
id|r
comma
r_sizeof
(paren
r_struct
id|tc_ratespec
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|rtab-&gt;refcnt
op_increment
suffix:semicolon
r_return
id|rtab
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tab
op_eq
l_int|NULL
op_logical_or
id|r-&gt;rate
op_eq
l_int|0
op_logical_or
id|r-&gt;cell_log
op_eq
l_int|0
op_logical_or
id|RTA_PAYLOAD
c_func
(paren
id|tab
)paren
op_ne
l_int|1024
)paren
r_return
l_int|NULL
suffix:semicolon
id|rtab
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|rtab
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtab
)paren
(brace
id|rtab-&gt;rate
op_assign
op_star
id|r
suffix:semicolon
id|rtab-&gt;refcnt
op_assign
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|rtab-&gt;data
comma
id|RTA_DATA
c_func
(paren
id|tab
)paren
comma
l_int|1024
)paren
suffix:semicolon
id|rtab-&gt;next
op_assign
id|qdisc_rtab_list
suffix:semicolon
id|qdisc_rtab_list
op_assign
id|rtab
suffix:semicolon
)brace
r_return
id|rtab
suffix:semicolon
)brace
DECL|function|qdisc_put_rtab
r_void
id|qdisc_put_rtab
c_func
(paren
r_struct
id|qdisc_rate_table
op_star
id|tab
)paren
(brace
r_struct
id|qdisc_rate_table
op_star
id|rtab
comma
op_star
op_star
id|rtabp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tab
op_logical_or
op_decrement
id|tab-&gt;refcnt
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|rtabp
op_assign
op_amp
id|qdisc_rtab_list
suffix:semicolon
(paren
id|rtab
op_assign
op_star
id|rtabp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|rtabp
op_assign
op_amp
id|rtab-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|rtab
op_eq
id|tab
)paren
(brace
op_star
id|rtabp
op_assign
id|rtab-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|rtab
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Allocate an unique handle from space managed by kernel */
DECL|function|qdisc_alloc_handle
id|u32
id|qdisc_alloc_handle
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|i
op_assign
l_int|0x10000
suffix:semicolon
r_static
id|u32
id|autohandle
op_assign
id|TC_H_MAKE
c_func
(paren
l_int|0x80000000U
comma
l_int|0
)paren
suffix:semicolon
r_do
(brace
id|autohandle
op_add_assign
id|TC_H_MAKE
c_func
(paren
l_int|0x10000U
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|autohandle
op_eq
id|TC_H_MAKE
c_func
(paren
id|TC_H_ROOT
comma
l_int|0
)paren
)paren
id|autohandle
op_assign
id|TC_H_MAKE
c_func
(paren
l_int|0x80000000U
comma
l_int|0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|qdisc_lookup
c_func
(paren
id|dev
comma
id|autohandle
)paren
op_logical_and
op_decrement
id|i
OG
l_int|0
)paren
suffix:semicolon
r_return
id|i
OG
l_int|0
ques
c_cond
id|autohandle
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Attach toplevel qdisc to device dev */
r_static
r_struct
id|Qdisc
op_star
DECL|function|dev_graft_qdisc
id|dev_graft_qdisc
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_struct
id|Qdisc
op_star
id|oqdisc
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
id|dev_deactivate
c_func
(paren
id|dev
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|qdisc_tree_lock
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qdisc
op_logical_and
id|qdisc-&gt;flags
op_amp
id|TCQ_F_INGRES
)paren
(brace
id|oqdisc
op_assign
id|dev-&gt;qdisc_ingress
suffix:semicolon
multiline_comment|/* Prune old scheduler */
r_if
c_cond
(paren
id|oqdisc
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|oqdisc-&gt;refcnt
)paren
op_le
l_int|1
)paren
(brace
multiline_comment|/* delete */
id|qdisc_reset
c_func
(paren
id|oqdisc
)paren
suffix:semicolon
id|dev-&gt;qdisc_ingress
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* new */
id|dev-&gt;qdisc_ingress
op_assign
id|qdisc
suffix:semicolon
)brace
)brace
r_else
(brace
id|oqdisc
op_assign
id|dev-&gt;qdisc_sleeping
suffix:semicolon
multiline_comment|/* Prune old scheduler */
r_if
c_cond
(paren
id|oqdisc
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|oqdisc-&gt;refcnt
)paren
op_le
l_int|1
)paren
id|qdisc_reset
c_func
(paren
id|oqdisc
)paren
suffix:semicolon
multiline_comment|/* ... and graft new one */
r_if
c_cond
(paren
id|qdisc
op_eq
l_int|NULL
)paren
id|qdisc
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|dev-&gt;qdisc_sleeping
op_assign
id|qdisc
suffix:semicolon
id|dev-&gt;qdisc
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|qdisc_tree_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
id|dev_activate
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|oqdisc
suffix:semicolon
)brace
multiline_comment|/* Graft qdisc &quot;new&quot; to class &quot;classid&quot; of qdisc &quot;parent&quot; or&n;   to device &quot;dev&quot;.&n;&n;   Old qdisc is not destroyed but returned in *old.&n; */
DECL|function|qdisc_graft
r_int
id|qdisc_graft
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|Qdisc
op_star
id|parent
comma
id|u32
id|classid
comma
r_struct
id|Qdisc
op_star
r_new
comma
r_struct
id|Qdisc
op_star
op_star
id|old
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|Qdisc
op_star
id|q
op_assign
op_star
id|old
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|q
op_logical_and
id|q-&gt;flags
op_amp
id|TCQ_F_INGRES
)paren
(brace
op_star
id|old
op_assign
id|dev_graft_qdisc
c_func
(paren
id|dev
comma
id|q
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|old
op_assign
id|dev_graft_qdisc
c_func
(paren
id|dev
comma
r_new
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|Qdisc_class_ops
op_star
id|cops
op_assign
id|parent-&gt;ops-&gt;cl_ops
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|cops
)paren
(brace
r_int
r_int
id|cl
op_assign
id|cops
op_member_access_from_pointer
id|get
c_func
(paren
id|parent
comma
id|classid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
)paren
(brace
id|err
op_assign
id|cops
op_member_access_from_pointer
id|graft
c_func
(paren
id|parent
comma
id|cl
comma
r_new
comma
id|old
)paren
suffix:semicolon
id|cops
op_member_access_from_pointer
id|put
c_func
(paren
id|parent
comma
id|cl
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|err
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_RTNETLINK
multiline_comment|/*&n;   Allocate and initialize new qdisc.&n;&n;   Parameters are passed via opt.&n; */
r_static
r_struct
id|Qdisc
op_star
DECL|function|qdisc_create
id|qdisc_create
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u32
id|handle
comma
r_struct
id|rtattr
op_star
op_star
id|tca
comma
r_int
op_star
id|errp
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|rtattr
op_star
id|kind
op_assign
id|tca
(braket
id|TCA_KIND
op_minus
l_int|1
)braket
suffix:semicolon
r_struct
id|Qdisc
op_star
id|sch
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|Qdisc_ops
op_star
id|ops
suffix:semicolon
r_int
id|size
suffix:semicolon
id|ops
op_assign
id|qdisc_lookup_ops
c_func
(paren
id|kind
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_KMOD
r_if
c_cond
(paren
id|ops
op_eq
l_int|NULL
op_logical_and
id|tca
(braket
id|TCA_KIND
op_minus
l_int|1
)braket
op_ne
l_int|NULL
)paren
(brace
r_char
id|module_name
(braket
l_int|4
op_plus
id|IFNAMSIZ
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|RTA_PAYLOAD
c_func
(paren
id|kind
)paren
op_le
id|IFNAMSIZ
)paren
(brace
id|sprintf
c_func
(paren
id|module_name
comma
l_string|&quot;sch_%s&quot;
comma
(paren
r_char
op_star
)paren
id|RTA_DATA
c_func
(paren
id|kind
)paren
)paren
suffix:semicolon
id|request_module
(paren
id|module_name
)paren
suffix:semicolon
id|ops
op_assign
id|qdisc_lookup_ops
c_func
(paren
id|kind
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ops
op_eq
l_int|NULL
)paren
r_goto
id|err_out
suffix:semicolon
id|size
op_assign
r_sizeof
(paren
op_star
id|sch
)paren
op_plus
id|ops-&gt;priv_size
suffix:semicolon
id|sch
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sch
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* Grrr... Resolve race condition with module unload */
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ops
op_ne
id|qdisc_lookup_ops
c_func
(paren
id|kind
)paren
)paren
r_goto
id|err_out
suffix:semicolon
id|memset
c_func
(paren
id|sch
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|sch-&gt;q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|handle
op_eq
id|TC_H_INGRESS
)paren
id|sch-&gt;flags
op_or_assign
id|TCQ_F_INGRES
suffix:semicolon
id|sch-&gt;ops
op_assign
id|ops
suffix:semicolon
id|sch-&gt;enqueue
op_assign
id|ops-&gt;enqueue
suffix:semicolon
id|sch-&gt;dequeue
op_assign
id|ops-&gt;dequeue
suffix:semicolon
id|sch-&gt;dev
op_assign
id|dev
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|sch-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|sch-&gt;stats.lock
op_assign
op_amp
id|dev-&gt;queue_lock
suffix:semicolon
r_if
c_cond
(paren
id|handle
op_eq
l_int|0
)paren
(brace
id|handle
op_assign
id|qdisc_alloc_handle
c_func
(paren
id|dev
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|handle
op_eq
l_int|0
)paren
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|handle
op_eq
id|TC_H_INGRESS
)paren
id|sch-&gt;handle
op_assign
id|TC_H_MAKE
c_func
(paren
id|TC_H_INGRESS
comma
l_int|0
)paren
suffix:semicolon
r_else
id|sch-&gt;handle
op_assign
id|handle
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ops-&gt;init
op_logical_or
(paren
id|err
op_assign
id|ops
op_member_access_from_pointer
id|init
c_func
(paren
id|sch
comma
id|tca
(braket
id|TCA_OPTIONS
op_minus
l_int|1
)braket
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|qdisc_tree_lock
)paren
suffix:semicolon
id|sch-&gt;next
op_assign
id|dev-&gt;qdisc_list
suffix:semicolon
id|dev-&gt;qdisc_list
op_assign
id|sch
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|qdisc_tree_lock
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_ESTIMATOR
r_if
c_cond
(paren
id|tca
(braket
id|TCA_RATE
op_minus
l_int|1
)braket
)paren
id|qdisc_new_estimator
c_func
(paren
op_amp
id|sch-&gt;stats
comma
id|tca
(braket
id|TCA_RATE
op_minus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
r_return
id|sch
suffix:semicolon
)brace
id|err_out
suffix:colon
op_star
id|errp
op_assign
id|err
suffix:semicolon
r_if
c_cond
(paren
id|sch
)paren
id|kfree
c_func
(paren
id|sch
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|qdisc_change
r_static
r_int
id|qdisc_change
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|rtattr
op_star
op_star
id|tca
)paren
(brace
r_if
c_cond
(paren
id|tca
(braket
id|TCA_OPTIONS
op_minus
l_int|1
)braket
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|sch-&gt;ops-&gt;change
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|sch-&gt;ops
op_member_access_from_pointer
id|change
c_func
(paren
id|sch
comma
id|tca
(braket
id|TCA_OPTIONS
op_minus
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_ESTIMATOR
r_if
c_cond
(paren
id|tca
(braket
id|TCA_RATE
op_minus
l_int|1
)braket
)paren
(brace
id|qdisc_kill_estimator
c_func
(paren
op_amp
id|sch-&gt;stats
)paren
suffix:semicolon
id|qdisc_new_estimator
c_func
(paren
op_amp
id|sch-&gt;stats
comma
id|tca
(braket
id|TCA_RATE
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|struct|check_loop_arg
r_struct
id|check_loop_arg
(brace
DECL|member|w
r_struct
id|qdisc_walker
id|w
suffix:semicolon
DECL|member|p
r_struct
id|Qdisc
op_star
id|p
suffix:semicolon
DECL|member|depth
r_int
id|depth
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
id|check_loop_fn
c_func
(paren
r_struct
id|Qdisc
op_star
id|q
comma
r_int
r_int
id|cl
comma
r_struct
id|qdisc_walker
op_star
id|w
)paren
suffix:semicolon
DECL|function|check_loop
r_static
r_int
id|check_loop
c_func
(paren
r_struct
id|Qdisc
op_star
id|q
comma
r_struct
id|Qdisc
op_star
id|p
comma
r_int
id|depth
)paren
(brace
r_struct
id|check_loop_arg
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;ops-&gt;cl_ops
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|arg.w.stop
op_assign
id|arg.w.skip
op_assign
id|arg.w.count
op_assign
l_int|0
suffix:semicolon
id|arg.w.fn
op_assign
id|check_loop_fn
suffix:semicolon
id|arg.depth
op_assign
id|depth
suffix:semicolon
id|arg.p
op_assign
id|p
suffix:semicolon
id|q-&gt;ops-&gt;cl_ops
op_member_access_from_pointer
id|walk
c_func
(paren
id|q
comma
op_amp
id|arg.w
)paren
suffix:semicolon
r_return
id|arg.w.stop
ques
c_cond
op_minus
id|ELOOP
suffix:colon
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|check_loop_fn
id|check_loop_fn
c_func
(paren
r_struct
id|Qdisc
op_star
id|q
comma
r_int
r_int
id|cl
comma
r_struct
id|qdisc_walker
op_star
id|w
)paren
(brace
r_struct
id|Qdisc
op_star
id|leaf
suffix:semicolon
r_struct
id|Qdisc_class_ops
op_star
id|cops
op_assign
id|q-&gt;ops-&gt;cl_ops
suffix:semicolon
r_struct
id|check_loop_arg
op_star
id|arg
op_assign
(paren
r_struct
id|check_loop_arg
op_star
)paren
id|w
suffix:semicolon
id|leaf
op_assign
id|cops
op_member_access_from_pointer
id|leaf
c_func
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|leaf
)paren
(brace
r_if
c_cond
(paren
id|leaf
op_eq
id|arg-&gt;p
op_logical_or
id|arg-&gt;depth
OG
l_int|7
)paren
r_return
op_minus
id|ELOOP
suffix:semicolon
r_return
id|check_loop
c_func
(paren
id|leaf
comma
id|arg-&gt;p
comma
id|arg-&gt;depth
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Delete/get qdisc.&n; */
DECL|function|tc_get_qdisc
r_static
r_int
id|tc_get_qdisc
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|nlmsghdr
op_star
id|n
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|tcmsg
op_star
id|tcm
op_assign
id|NLMSG_DATA
c_func
(paren
id|n
)paren
suffix:semicolon
r_struct
id|rtattr
op_star
op_star
id|tca
op_assign
id|arg
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|u32
id|clid
op_assign
id|tcm-&gt;tcm_parent
suffix:semicolon
r_struct
id|Qdisc
op_star
id|q
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|Qdisc
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|__dev_get_by_index
c_func
(paren
id|tcm-&gt;tcm_ifindex
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|clid
)paren
(brace
r_if
c_cond
(paren
id|clid
op_ne
id|TC_H_ROOT
)paren
(brace
r_if
c_cond
(paren
id|TC_H_MAJ
c_func
(paren
id|clid
)paren
op_ne
id|TC_H_MAJ
c_func
(paren
id|TC_H_INGRESS
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|p
op_assign
id|qdisc_lookup
c_func
(paren
id|dev
comma
id|TC_H_MAJ
c_func
(paren
id|clid
)paren
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|q
op_assign
id|qdisc_leaf
c_func
(paren
id|p
comma
id|clid
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ingress */
id|q
op_assign
id|dev-&gt;qdisc_ingress
suffix:semicolon
)brace
)brace
r_else
(brace
id|q
op_assign
id|dev-&gt;qdisc_sleeping
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|tcm-&gt;tcm_handle
op_logical_and
id|q-&gt;handle
op_ne
id|tcm-&gt;tcm_handle
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|q
op_assign
id|qdisc_lookup
c_func
(paren
id|dev
comma
id|tcm-&gt;tcm_handle
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tca
(braket
id|TCA_KIND
op_minus
l_int|1
)braket
op_logical_and
id|rtattr_strcmp
c_func
(paren
id|tca
(braket
id|TCA_KIND
op_minus
l_int|1
)braket
comma
id|q-&gt;ops-&gt;id
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|n-&gt;nlmsg_type
op_eq
id|RTM_DELQDISC
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|clid
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;handle
op_eq
l_int|0
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|qdisc_graft
c_func
(paren
id|dev
comma
id|p
comma
id|clid
comma
l_int|NULL
comma
op_amp
id|q
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|q
)paren
(brace
id|qdisc_notify
c_func
(paren
id|skb
comma
id|n
comma
id|clid
comma
id|q
comma
l_int|NULL
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|qdisc_destroy
c_func
(paren
id|q
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|qdisc_notify
c_func
(paren
id|skb
comma
id|n
comma
id|clid
comma
l_int|NULL
comma
id|q
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;   Create/change qdisc.&n; */
DECL|function|tc_modify_qdisc
r_static
r_int
id|tc_modify_qdisc
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|nlmsghdr
op_star
id|n
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|tcmsg
op_star
id|tcm
op_assign
id|NLMSG_DATA
c_func
(paren
id|n
)paren
suffix:semicolon
r_struct
id|rtattr
op_star
op_star
id|tca
op_assign
id|arg
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|u32
id|clid
op_assign
id|tcm-&gt;tcm_parent
suffix:semicolon
r_struct
id|Qdisc
op_star
id|q
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|Qdisc
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|__dev_get_by_index
c_func
(paren
id|tcm-&gt;tcm_ifindex
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|clid
)paren
(brace
r_if
c_cond
(paren
id|clid
op_ne
id|TC_H_ROOT
)paren
(brace
r_if
c_cond
(paren
id|clid
op_ne
id|TC_H_INGRESS
)paren
(brace
r_if
c_cond
(paren
(paren
id|p
op_assign
id|qdisc_lookup
c_func
(paren
id|dev
comma
id|TC_H_MAJ
c_func
(paren
id|clid
)paren
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|q
op_assign
id|qdisc_leaf
c_func
(paren
id|p
comma
id|clid
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*ingress */
id|q
op_assign
id|dev-&gt;qdisc_ingress
suffix:semicolon
)brace
)brace
r_else
(brace
id|q
op_assign
id|dev-&gt;qdisc_sleeping
suffix:semicolon
)brace
multiline_comment|/* It may be default qdisc, ignore it */
r_if
c_cond
(paren
id|q
op_logical_and
id|q-&gt;handle
op_eq
l_int|0
)paren
id|q
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
op_logical_or
op_logical_neg
id|tcm-&gt;tcm_handle
op_logical_or
id|q-&gt;handle
op_ne
id|tcm-&gt;tcm_handle
)paren
(brace
r_if
c_cond
(paren
id|tcm-&gt;tcm_handle
)paren
(brace
r_if
c_cond
(paren
id|q
op_logical_and
op_logical_neg
(paren
id|n-&gt;nlmsg_flags
op_amp
id|NLM_F_REPLACE
)paren
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|TC_H_MIN
c_func
(paren
id|tcm-&gt;tcm_handle
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q
op_assign
id|qdisc_lookup
c_func
(paren
id|dev
comma
id|tcm-&gt;tcm_handle
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|create_n_graft
suffix:semicolon
r_if
c_cond
(paren
id|n-&gt;nlmsg_flags
op_amp
id|NLM_F_EXCL
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|tca
(braket
id|TCA_KIND
op_minus
l_int|1
)braket
op_logical_and
id|rtattr_strcmp
c_func
(paren
id|tca
(braket
id|TCA_KIND
op_minus
l_int|1
)braket
comma
id|q-&gt;ops-&gt;id
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|q
op_eq
id|p
op_logical_or
(paren
id|p
op_logical_and
id|check_loop
c_func
(paren
id|q
comma
id|p
comma
l_int|0
)paren
)paren
)paren
r_return
op_minus
id|ELOOP
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|q-&gt;refcnt
)paren
suffix:semicolon
r_goto
id|graft
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|q
op_eq
l_int|NULL
)paren
r_goto
id|create_n_graft
suffix:semicolon
multiline_comment|/* This magic test requires explanation.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; *   We know, that some child q is already&n;&t;&t;&t;&t; *   attached to this parent and have choice:&n;&t;&t;&t;&t; *   either to change it or to create/graft new one.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; *   1. We are allowed to create/graft only&n;&t;&t;&t;&t; *   if CREATE and REPLACE flags are set.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; *   2. If EXCL is set, requestor wanted to say,&n;&t;&t;&t;&t; *   that qdisc tcm_handle is not expected&n;&t;&t;&t;&t; *   to exist, so that we choose create/graft too.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; *   3. The last case is when no flags are set.&n;&t;&t;&t;&t; *   Alas, it is sort of hole in API, we&n;&t;&t;&t;&t; *   cannot decide what to do unambiguously.&n;&t;&t;&t;&t; *   For now we select create/graft, if&n;&t;&t;&t;&t; *   user gave KIND, which does not match existing.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|n-&gt;nlmsg_flags
op_amp
id|NLM_F_CREATE
)paren
op_logical_and
(paren
id|n-&gt;nlmsg_flags
op_amp
id|NLM_F_REPLACE
)paren
op_logical_and
(paren
(paren
id|n-&gt;nlmsg_flags
op_amp
id|NLM_F_EXCL
)paren
op_logical_or
(paren
id|tca
(braket
id|TCA_KIND
op_minus
l_int|1
)braket
op_logical_and
id|rtattr_strcmp
c_func
(paren
id|tca
(braket
id|TCA_KIND
op_minus
l_int|1
)braket
comma
id|q-&gt;ops-&gt;id
)paren
)paren
)paren
)paren
r_goto
id|create_n_graft
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|tcm-&gt;tcm_handle
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|q
op_assign
id|qdisc_lookup
c_func
(paren
id|dev
comma
id|tcm-&gt;tcm_handle
)paren
suffix:semicolon
)brace
multiline_comment|/* Change qdisc parameters */
r_if
c_cond
(paren
id|q
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|n-&gt;nlmsg_flags
op_amp
id|NLM_F_EXCL
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|tca
(braket
id|TCA_KIND
op_minus
l_int|1
)braket
op_logical_and
id|rtattr_strcmp
c_func
(paren
id|tca
(braket
id|TCA_KIND
op_minus
l_int|1
)braket
comma
id|q-&gt;ops-&gt;id
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|qdisc_change
c_func
(paren
id|q
comma
id|tca
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
id|qdisc_notify
c_func
(paren
id|skb
comma
id|n
comma
id|clid
comma
l_int|NULL
comma
id|q
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|create_n_graft
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|n-&gt;nlmsg_flags
op_amp
id|NLM_F_CREATE
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|clid
op_eq
id|TC_H_INGRESS
)paren
id|q
op_assign
id|qdisc_create
c_func
(paren
id|dev
comma
id|tcm-&gt;tcm_parent
comma
id|tca
comma
op_amp
id|err
)paren
suffix:semicolon
r_else
id|q
op_assign
id|qdisc_create
c_func
(paren
id|dev
comma
id|tcm-&gt;tcm_handle
comma
id|tca
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
op_eq
l_int|NULL
)paren
r_return
id|err
suffix:semicolon
id|graft
suffix:colon
r_if
c_cond
(paren
l_int|1
)paren
(brace
r_struct
id|Qdisc
op_star
id|old_q
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
id|qdisc_graft
c_func
(paren
id|dev
comma
id|p
comma
id|clid
comma
id|q
comma
op_amp
id|old_q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_if
c_cond
(paren
id|q
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|qdisc_destroy
c_func
(paren
id|q
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
id|qdisc_notify
c_func
(paren
id|skb
comma
id|n
comma
id|clid
comma
id|old_q
comma
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_q
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|qdisc_destroy
c_func
(paren
id|old_q
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|qdisc_copy_stats
r_int
id|qdisc_copy_stats
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tc_stats
op_star
id|st
)paren
(brace
id|spin_lock_bh
c_func
(paren
id|st-&gt;lock
)paren
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_STATS
comma
(paren
r_char
op_star
)paren
op_amp
id|st-&gt;lock
op_minus
(paren
r_char
op_star
)paren
id|st
comma
id|st
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
id|st-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|rtattr_failure
suffix:colon
id|spin_unlock_bh
c_func
(paren
id|st-&gt;lock
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|tc_fill_qdisc
r_static
r_int
id|tc_fill_qdisc
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|q
comma
id|u32
id|clid
comma
id|u32
id|pid
comma
id|u32
id|seq
comma
r_int
id|flags
comma
r_int
id|event
)paren
(brace
r_struct
id|tcmsg
op_star
id|tcm
suffix:semicolon
r_struct
id|nlmsghdr
op_star
id|nlh
suffix:semicolon
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
id|nlh
op_assign
id|NLMSG_PUT
c_func
(paren
id|skb
comma
id|pid
comma
id|seq
comma
id|event
comma
r_sizeof
(paren
op_star
id|tcm
)paren
)paren
suffix:semicolon
id|nlh-&gt;nlmsg_flags
op_assign
id|flags
suffix:semicolon
id|tcm
op_assign
id|NLMSG_DATA
c_func
(paren
id|nlh
)paren
suffix:semicolon
id|tcm-&gt;tcm_family
op_assign
id|AF_UNSPEC
suffix:semicolon
id|tcm-&gt;tcm_ifindex
op_assign
id|q-&gt;dev
ques
c_cond
id|q-&gt;dev-&gt;ifindex
suffix:colon
l_int|0
suffix:semicolon
id|tcm-&gt;tcm_parent
op_assign
id|clid
suffix:semicolon
id|tcm-&gt;tcm_handle
op_assign
id|q-&gt;handle
suffix:semicolon
id|tcm-&gt;tcm_info
op_assign
id|atomic_read
c_func
(paren
op_amp
id|q-&gt;refcnt
)paren
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_KIND
comma
id|IFNAMSIZ
comma
id|q-&gt;ops-&gt;id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;ops-&gt;dump
op_logical_and
id|q-&gt;ops
op_member_access_from_pointer
id|dump
c_func
(paren
id|q
comma
id|skb
)paren
OL
l_int|0
)paren
r_goto
id|rtattr_failure
suffix:semicolon
id|q-&gt;stats.qlen
op_assign
id|q-&gt;q.qlen
suffix:semicolon
r_if
c_cond
(paren
id|qdisc_copy_stats
c_func
(paren
id|skb
comma
op_amp
id|q-&gt;stats
)paren
)paren
r_goto
id|rtattr_failure
suffix:semicolon
id|nlh-&gt;nlmsg_len
op_assign
id|skb-&gt;tail
op_minus
id|b
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|nlmsg_failure
suffix:colon
id|rtattr_failure
suffix:colon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|qdisc_notify
r_static
r_int
id|qdisc_notify
c_func
(paren
r_struct
id|sk_buff
op_star
id|oskb
comma
r_struct
id|nlmsghdr
op_star
id|n
comma
id|u32
id|clid
comma
r_struct
id|Qdisc
op_star
id|old
comma
r_struct
id|Qdisc
op_star
r_new
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|u32
id|pid
op_assign
id|oskb
ques
c_cond
id|NETLINK_CB
c_func
(paren
id|oskb
)paren
dot
id|pid
suffix:colon
l_int|0
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|NLMSG_GOODSIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
op_minus
id|ENOBUFS
suffix:semicolon
r_if
c_cond
(paren
id|old
op_logical_and
id|old-&gt;handle
)paren
(brace
r_if
c_cond
(paren
id|tc_fill_qdisc
c_func
(paren
id|skb
comma
id|old
comma
id|clid
comma
id|pid
comma
id|n-&gt;nlmsg_seq
comma
l_int|0
comma
id|RTM_DELQDISC
)paren
OL
l_int|0
)paren
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
r_new
)paren
(brace
r_if
c_cond
(paren
id|tc_fill_qdisc
c_func
(paren
id|skb
comma
r_new
comma
id|clid
comma
id|pid
comma
id|n-&gt;nlmsg_seq
comma
id|old
ques
c_cond
id|NLM_F_REPLACE
suffix:colon
l_int|0
comma
id|RTM_NEWQDISC
)paren
OL
l_int|0
)paren
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;len
)paren
r_return
id|rtnetlink_send
c_func
(paren
id|skb
comma
id|pid
comma
id|RTMGRP_TC
comma
id|n-&gt;nlmsg_flags
op_amp
id|NLM_F_ECHO
)paren
suffix:semicolon
id|err_out
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|tc_dump_qdisc
r_static
r_int
id|tc_dump_qdisc
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|netlink_callback
op_star
id|cb
)paren
(brace
r_int
id|idx
comma
id|q_idx
suffix:semicolon
r_int
id|s_idx
comma
id|s_q_idx
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|Qdisc
op_star
id|q
suffix:semicolon
id|s_idx
op_assign
id|cb-&gt;args
(braket
l_int|0
)braket
suffix:semicolon
id|s_q_idx
op_assign
id|q_idx
op_assign
id|cb-&gt;args
(braket
l_int|1
)braket
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
comma
id|idx
op_assign
l_int|0
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
comma
id|idx
op_increment
)paren
(brace
r_if
c_cond
(paren
id|idx
OL
id|s_idx
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|idx
OG
id|s_idx
)paren
id|s_q_idx
op_assign
l_int|0
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|qdisc_tree_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
id|dev-&gt;qdisc_list
comma
id|q_idx
op_assign
l_int|0
suffix:semicolon
id|q
suffix:semicolon
id|q
op_assign
id|q-&gt;next
comma
id|q_idx
op_increment
)paren
(brace
r_if
c_cond
(paren
id|q_idx
OL
id|s_q_idx
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tc_fill_qdisc
c_func
(paren
id|skb
comma
id|q
comma
l_int|0
comma
id|NETLINK_CB
c_func
(paren
id|cb-&gt;skb
)paren
dot
id|pid
comma
id|cb-&gt;nlh-&gt;nlmsg_seq
comma
id|NLM_F_MULTI
comma
id|RTM_NEWQDISC
)paren
op_le
l_int|0
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|qdisc_tree_lock
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|qdisc_tree_lock
)paren
suffix:semicolon
)brace
id|done
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|cb-&gt;args
(braket
l_int|0
)braket
op_assign
id|idx
suffix:semicolon
id|cb-&gt;args
(braket
l_int|1
)braket
op_assign
id|q_idx
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
)brace
multiline_comment|/************************************************&n; *&t;Traffic classes manipulation.&t;&t;*&n; ************************************************/
DECL|function|tc_ctl_tclass
r_static
r_int
id|tc_ctl_tclass
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|nlmsghdr
op_star
id|n
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|tcmsg
op_star
id|tcm
op_assign
id|NLMSG_DATA
c_func
(paren
id|n
)paren
suffix:semicolon
r_struct
id|rtattr
op_star
op_star
id|tca
op_assign
id|arg
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|Qdisc
op_star
id|q
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|Qdisc_class_ops
op_star
id|cops
suffix:semicolon
r_int
r_int
id|cl
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|new_cl
suffix:semicolon
id|u32
id|pid
op_assign
id|tcm-&gt;tcm_parent
suffix:semicolon
id|u32
id|clid
op_assign
id|tcm-&gt;tcm_handle
suffix:semicolon
id|u32
id|qid
op_assign
id|TC_H_MAJ
c_func
(paren
id|clid
)paren
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|__dev_get_by_index
c_func
(paren
id|tcm-&gt;tcm_ifindex
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t;   parent == TC_H_UNSPEC - unspecified parent.&n;&t;   parent == TC_H_ROOT   - class is root, which has no parent.&n;&t;   parent == X:0&t; - parent is root class.&n;&t;   parent == X:Y&t; - parent is a node in hierarchy.&n;&t;   parent == 0:Y&t; - parent is X:Y, where X:0 is qdisc.&n;&n;&t;   handle == 0:0&t; - generate handle from kernel pool.&n;&t;   handle == 0:Y&t; - class is X:Y, where X:0 is qdisc.&n;&t;   handle == X:Y&t; - clear.&n;&t;   handle == X:0&t; - root class.&n;&t; */
multiline_comment|/* Step 1. Determine qdisc handle X:0 */
r_if
c_cond
(paren
id|pid
op_ne
id|TC_H_ROOT
)paren
(brace
id|u32
id|qid1
op_assign
id|TC_H_MAJ
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qid
op_logical_and
id|qid1
)paren
(brace
multiline_comment|/* If both majors are known, they must be identical. */
r_if
c_cond
(paren
id|qid
op_ne
id|qid1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|qid1
)paren
(brace
id|qid
op_assign
id|qid1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|qid
op_eq
l_int|0
)paren
id|qid
op_assign
id|dev-&gt;qdisc_sleeping-&gt;handle
suffix:semicolon
multiline_comment|/* Now qid is genuine qdisc handle consistent&n;&t;&t;   both with parent and child.&n;&n;&t;&t;   TC_H_MAJ(pid) still may be unspecified, complete it now.&n;&t;&t; */
r_if
c_cond
(paren
id|pid
)paren
id|pid
op_assign
id|TC_H_MAKE
c_func
(paren
id|qid
comma
id|pid
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|qid
op_eq
l_int|0
)paren
id|qid
op_assign
id|dev-&gt;qdisc_sleeping-&gt;handle
suffix:semicolon
)brace
multiline_comment|/* OK. Locate qdisc */
r_if
c_cond
(paren
(paren
id|q
op_assign
id|qdisc_lookup
c_func
(paren
id|dev
comma
id|qid
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
multiline_comment|/* An check that it supports classes */
id|cops
op_assign
id|q-&gt;ops-&gt;cl_ops
suffix:semicolon
r_if
c_cond
(paren
id|cops
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Now try to get class */
r_if
c_cond
(paren
id|clid
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|pid
op_eq
id|TC_H_ROOT
)paren
id|clid
op_assign
id|qid
suffix:semicolon
)brace
r_else
id|clid
op_assign
id|TC_H_MAKE
c_func
(paren
id|qid
comma
id|clid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clid
)paren
id|cl
op_assign
id|cops
op_member_access_from_pointer
id|get
c_func
(paren
id|q
comma
id|clid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cl
op_eq
l_int|0
)paren
(brace
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|n-&gt;nlmsg_type
op_ne
id|RTM_NEWTCLASS
op_logical_or
op_logical_neg
(paren
id|n-&gt;nlmsg_flags
op_amp
id|NLM_F_CREATE
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|n-&gt;nlmsg_type
)paren
(brace
r_case
id|RTM_NEWTCLASS
suffix:colon
id|err
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|n-&gt;nlmsg_flags
op_amp
id|NLM_F_EXCL
)paren
r_goto
id|out
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RTM_DELTCLASS
suffix:colon
id|err
op_assign
id|cops
op_member_access_from_pointer
r_delete
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
id|tclass_notify
c_func
(paren
id|skb
comma
id|n
comma
id|q
comma
id|cl
comma
id|RTM_DELTCLASS
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
id|RTM_GETTCLASS
suffix:colon
id|err
op_assign
id|tclass_notify
c_func
(paren
id|skb
comma
id|n
comma
id|q
comma
id|cl
comma
id|RTM_NEWTCLASS
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|new_cl
op_assign
id|cl
suffix:semicolon
id|err
op_assign
id|cops
op_member_access_from_pointer
id|change
c_func
(paren
id|q
comma
id|clid
comma
id|pid
comma
id|tca
comma
op_amp
id|new_cl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
id|tclass_notify
c_func
(paren
id|skb
comma
id|n
comma
id|q
comma
id|new_cl
comma
id|RTM_NEWTCLASS
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|cl
)paren
id|cops
op_member_access_from_pointer
id|put
c_func
(paren
id|q
comma
id|cl
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|tc_fill_tclass
r_static
r_int
id|tc_fill_tclass
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|q
comma
r_int
r_int
id|cl
comma
id|u32
id|pid
comma
id|u32
id|seq
comma
r_int
id|flags
comma
r_int
id|event
)paren
(brace
r_struct
id|tcmsg
op_star
id|tcm
suffix:semicolon
r_struct
id|nlmsghdr
op_star
id|nlh
suffix:semicolon
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
id|nlh
op_assign
id|NLMSG_PUT
c_func
(paren
id|skb
comma
id|pid
comma
id|seq
comma
id|event
comma
r_sizeof
(paren
op_star
id|tcm
)paren
)paren
suffix:semicolon
id|nlh-&gt;nlmsg_flags
op_assign
id|flags
suffix:semicolon
id|tcm
op_assign
id|NLMSG_DATA
c_func
(paren
id|nlh
)paren
suffix:semicolon
id|tcm-&gt;tcm_family
op_assign
id|AF_UNSPEC
suffix:semicolon
id|tcm-&gt;tcm_ifindex
op_assign
id|q-&gt;dev
ques
c_cond
id|q-&gt;dev-&gt;ifindex
suffix:colon
l_int|0
suffix:semicolon
id|tcm-&gt;tcm_parent
op_assign
id|q-&gt;handle
suffix:semicolon
id|tcm-&gt;tcm_handle
op_assign
id|q-&gt;handle
suffix:semicolon
id|tcm-&gt;tcm_info
op_assign
l_int|0
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_KIND
comma
id|IFNAMSIZ
comma
id|q-&gt;ops-&gt;id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;ops-&gt;cl_ops-&gt;dump
op_logical_and
id|q-&gt;ops-&gt;cl_ops
op_member_access_from_pointer
id|dump
c_func
(paren
id|q
comma
id|cl
comma
id|skb
comma
id|tcm
)paren
OL
l_int|0
)paren
r_goto
id|rtattr_failure
suffix:semicolon
id|nlh-&gt;nlmsg_len
op_assign
id|skb-&gt;tail
op_minus
id|b
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|nlmsg_failure
suffix:colon
id|rtattr_failure
suffix:colon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|tclass_notify
r_static
r_int
id|tclass_notify
c_func
(paren
r_struct
id|sk_buff
op_star
id|oskb
comma
r_struct
id|nlmsghdr
op_star
id|n
comma
r_struct
id|Qdisc
op_star
id|q
comma
r_int
r_int
id|cl
comma
r_int
id|event
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|u32
id|pid
op_assign
id|oskb
ques
c_cond
id|NETLINK_CB
c_func
(paren
id|oskb
)paren
dot
id|pid
suffix:colon
l_int|0
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|NLMSG_GOODSIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
op_minus
id|ENOBUFS
suffix:semicolon
r_if
c_cond
(paren
id|tc_fill_tclass
c_func
(paren
id|skb
comma
id|q
comma
id|cl
comma
id|pid
comma
id|n-&gt;nlmsg_seq
comma
l_int|0
comma
id|event
)paren
OL
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|rtnetlink_send
c_func
(paren
id|skb
comma
id|pid
comma
id|RTMGRP_TC
comma
id|n-&gt;nlmsg_flags
op_amp
id|NLM_F_ECHO
)paren
suffix:semicolon
)brace
DECL|struct|qdisc_dump_args
r_struct
id|qdisc_dump_args
(brace
DECL|member|w
r_struct
id|qdisc_walker
id|w
suffix:semicolon
DECL|member|skb
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
DECL|member|cb
r_struct
id|netlink_callback
op_star
id|cb
suffix:semicolon
)brace
suffix:semicolon
DECL|function|qdisc_class_dump
r_static
r_int
id|qdisc_class_dump
c_func
(paren
r_struct
id|Qdisc
op_star
id|q
comma
r_int
r_int
id|cl
comma
r_struct
id|qdisc_walker
op_star
id|arg
)paren
(brace
r_struct
id|qdisc_dump_args
op_star
id|a
op_assign
(paren
r_struct
id|qdisc_dump_args
op_star
)paren
id|arg
suffix:semicolon
r_return
id|tc_fill_tclass
c_func
(paren
id|a-&gt;skb
comma
id|q
comma
id|cl
comma
id|NETLINK_CB
c_func
(paren
id|a-&gt;cb-&gt;skb
)paren
dot
id|pid
comma
id|a-&gt;cb-&gt;nlh-&gt;nlmsg_seq
comma
id|NLM_F_MULTI
comma
id|RTM_NEWTCLASS
)paren
suffix:semicolon
)brace
DECL|function|tc_dump_tclass
r_static
r_int
id|tc_dump_tclass
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|netlink_callback
op_star
id|cb
)paren
(brace
r_int
id|t
suffix:semicolon
r_int
id|s_t
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|Qdisc
op_star
id|q
suffix:semicolon
r_struct
id|tcmsg
op_star
id|tcm
op_assign
(paren
r_struct
id|tcmsg
op_star
)paren
id|NLMSG_DATA
c_func
(paren
id|cb-&gt;nlh
)paren
suffix:semicolon
r_struct
id|qdisc_dump_args
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|cb-&gt;nlh-&gt;nlmsg_len
OL
id|NLMSG_LENGTH
c_func
(paren
r_sizeof
(paren
op_star
id|tcm
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|dev_get_by_index
c_func
(paren
id|tcm-&gt;tcm_ifindex
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|s_t
op_assign
id|cb-&gt;args
(braket
l_int|0
)braket
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|qdisc_tree_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
id|dev-&gt;qdisc_list
comma
id|t
op_assign
l_int|0
suffix:semicolon
id|q
suffix:semicolon
id|q
op_assign
id|q-&gt;next
comma
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
id|t
OL
id|s_t
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;ops-&gt;cl_ops
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tcm-&gt;tcm_parent
op_logical_and
id|TC_H_MAJ
c_func
(paren
id|tcm-&gt;tcm_parent
)paren
op_ne
id|q-&gt;handle
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|t
OG
id|s_t
)paren
id|memset
c_func
(paren
op_amp
id|cb-&gt;args
(braket
l_int|1
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|cb-&gt;args
)paren
op_minus
r_sizeof
(paren
id|cb-&gt;args
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|arg.w.fn
op_assign
id|qdisc_class_dump
suffix:semicolon
id|arg.skb
op_assign
id|skb
suffix:semicolon
id|arg.cb
op_assign
id|cb
suffix:semicolon
id|arg.w.stop
op_assign
l_int|0
suffix:semicolon
id|arg.w.skip
op_assign
id|cb-&gt;args
(braket
l_int|1
)braket
suffix:semicolon
id|arg.w.count
op_assign
l_int|0
suffix:semicolon
id|q-&gt;ops-&gt;cl_ops
op_member_access_from_pointer
id|walk
c_func
(paren
id|q
comma
op_amp
id|arg.w
)paren
suffix:semicolon
id|cb-&gt;args
(braket
l_int|1
)braket
op_assign
id|arg.w.count
suffix:semicolon
r_if
c_cond
(paren
id|arg.w.stop
)paren
r_break
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|qdisc_tree_lock
)paren
suffix:semicolon
id|cb-&gt;args
(braket
l_int|0
)braket
op_assign
id|t
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|psched_us_per_tick
r_int
id|psched_us_per_tick
op_assign
l_int|1
suffix:semicolon
DECL|variable|psched_tick_per_us
r_int
id|psched_tick_per_us
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|psched_read_proc
r_static
r_int
id|psched_read_proc
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%08x %08x %08x %08x&bslash;n&quot;
comma
id|psched_tick_per_us
comma
id|psched_us_per_tick
comma
l_int|1000000
comma
id|HZ
)paren
suffix:semicolon
id|len
op_sub_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
)brace
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if PSCHED_CLOCK_SOURCE == PSCHED_GETTIMEOFDAY
DECL|function|psched_tod_diff
r_int
id|psched_tod_diff
c_func
(paren
r_int
id|delta_sec
comma
r_int
id|bound
)paren
(brace
r_int
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|bound
op_le
l_int|1000000
op_logical_or
id|delta_sec
OG
(paren
l_int|0x7FFFFFFF
op_div
l_int|1000000
)paren
op_minus
l_int|1
)paren
r_return
id|bound
suffix:semicolon
id|delta
op_assign
id|delta_sec
op_star
l_int|1000000
suffix:semicolon
r_if
c_cond
(paren
id|delta
OG
id|bound
)paren
id|delta
op_assign
id|bound
suffix:semicolon
r_return
id|delta
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|psched_time_base
id|psched_time_t
id|psched_time_base
suffix:semicolon
macro_line|#if PSCHED_CLOCK_SOURCE == PSCHED_CPU
DECL|variable|psched_clock_per_hz
id|psched_tdiff_t
id|psched_clock_per_hz
suffix:semicolon
DECL|variable|psched_clock_scale
r_int
id|psched_clock_scale
suffix:semicolon
macro_line|#endif
macro_line|#ifdef PSCHED_WATCHER
DECL|variable|psched_time_mark
id|PSCHED_WATCHER
id|psched_time_mark
suffix:semicolon
r_static
r_void
id|psched_tick
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|variable|psched_timer
r_static
r_struct
id|timer_list
id|psched_timer
op_assign
(brace
id|function
suffix:colon
id|psched_tick
)brace
suffix:semicolon
DECL|function|psched_tick
r_static
r_void
id|psched_tick
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
macro_line|#if PSCHED_CLOCK_SOURCE == PSCHED_CPU
id|psched_time_t
id|dummy_stamp
suffix:semicolon
id|PSCHED_GET_TIME
c_func
(paren
id|dummy_stamp
)paren
suffix:semicolon
multiline_comment|/* It is OK up to 4GHz cpu */
id|psched_timer.expires
op_assign
id|jiffies
op_plus
l_int|1
op_star
id|HZ
suffix:semicolon
macro_line|#else
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
id|psched_time_base
op_assign
(paren
(paren
id|u64
)paren
id|now
)paren
op_lshift
id|PSCHED_JSCALE
suffix:semicolon
id|psched_time_mark
op_assign
id|now
suffix:semicolon
id|psched_timer.expires
op_assign
id|now
op_plus
l_int|60
op_star
l_int|60
op_star
id|HZ
suffix:semicolon
macro_line|#endif
id|add_timer
c_func
(paren
op_amp
id|psched_timer
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if PSCHED_CLOCK_SOURCE == PSCHED_CPU
DECL|function|psched_calibrate_clock
r_int
id|__init
id|psched_calibrate_clock
c_func
(paren
r_void
)paren
(brace
id|psched_time_t
id|stamp
comma
id|stamp1
suffix:semicolon
r_struct
id|timeval
id|tv
comma
id|tv1
suffix:semicolon
id|psched_tdiff_t
id|delay
suffix:semicolon
r_int
id|rdelay
suffix:semicolon
r_int
r_int
id|stop
suffix:semicolon
macro_line|#ifdef PSCHED_WATCHER
id|psched_tick
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|stop
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|10
suffix:semicolon
id|PSCHED_GET_TIME
c_func
(paren
id|stamp
)paren
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|stop
)paren
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|PSCHED_GET_TIME
c_func
(paren
id|stamp1
)paren
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv1
)paren
suffix:semicolon
id|delay
op_assign
id|PSCHED_TDIFF
c_func
(paren
id|stamp1
comma
id|stamp
)paren
suffix:semicolon
id|rdelay
op_assign
id|tv1.tv_usec
op_minus
id|tv.tv_usec
suffix:semicolon
id|rdelay
op_add_assign
(paren
id|tv1.tv_sec
op_minus
id|tv.tv_sec
)paren
op_star
l_int|1000000
suffix:semicolon
r_if
c_cond
(paren
id|rdelay
OG
id|delay
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|delay
op_div_assign
id|rdelay
suffix:semicolon
id|psched_tick_per_us
op_assign
id|delay
suffix:semicolon
r_while
c_loop
(paren
(paren
id|delay
op_rshift_assign
l_int|1
)paren
op_ne
l_int|0
)paren
id|psched_clock_scale
op_increment
suffix:semicolon
id|psched_us_per_tick
op_assign
l_int|1
op_lshift
id|psched_clock_scale
suffix:semicolon
id|psched_clock_per_hz
op_assign
(paren
id|psched_tick_per_us
op_star
(paren
l_int|1000000
op_div
id|HZ
)paren
)paren
op_rshift
id|psched_clock_scale
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|pktsched_init
r_int
id|__init
id|pktsched_init
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_RTNETLINK
r_struct
id|rtnetlink_link
op_star
id|link_p
suffix:semicolon
macro_line|#endif
macro_line|#if PSCHED_CLOCK_SOURCE == PSCHED_CPU
r_if
c_cond
(paren
id|psched_calibrate_clock
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#elif PSCHED_CLOCK_SOURCE == PSCHED_JIFFIES
id|psched_tick_per_us
op_assign
id|HZ
op_lshift
id|PSCHED_JSCALE
suffix:semicolon
id|psched_us_per_tick
op_assign
l_int|1000000
suffix:semicolon
macro_line|#ifdef PSCHED_WATCHER
id|psched_tick
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
macro_line|#ifdef CONFIG_RTNETLINK
id|link_p
op_assign
id|rtnetlink_links
(braket
id|PF_UNSPEC
)braket
suffix:semicolon
multiline_comment|/* Setup rtnetlink links. It is made here to avoid&n;&t;   exporting large number of public symbols.&n;&t; */
r_if
c_cond
(paren
id|link_p
)paren
(brace
id|link_p
(braket
id|RTM_NEWQDISC
op_minus
id|RTM_BASE
)braket
dot
id|doit
op_assign
id|tc_modify_qdisc
suffix:semicolon
id|link_p
(braket
id|RTM_DELQDISC
op_minus
id|RTM_BASE
)braket
dot
id|doit
op_assign
id|tc_get_qdisc
suffix:semicolon
id|link_p
(braket
id|RTM_GETQDISC
op_minus
id|RTM_BASE
)braket
dot
id|doit
op_assign
id|tc_get_qdisc
suffix:semicolon
id|link_p
(braket
id|RTM_GETQDISC
op_minus
id|RTM_BASE
)braket
dot
id|dumpit
op_assign
id|tc_dump_qdisc
suffix:semicolon
id|link_p
(braket
id|RTM_NEWTCLASS
op_minus
id|RTM_BASE
)braket
dot
id|doit
op_assign
id|tc_ctl_tclass
suffix:semicolon
id|link_p
(braket
id|RTM_DELTCLASS
op_minus
id|RTM_BASE
)braket
dot
id|doit
op_assign
id|tc_ctl_tclass
suffix:semicolon
id|link_p
(braket
id|RTM_GETTCLASS
op_minus
id|RTM_BASE
)braket
dot
id|doit
op_assign
id|tc_ctl_tclass
suffix:semicolon
id|link_p
(braket
id|RTM_GETTCLASS
op_minus
id|RTM_BASE
)braket
dot
id|dumpit
op_assign
id|tc_dump_tclass
suffix:semicolon
)brace
macro_line|#endif
DECL|macro|INIT_QDISC
mdefine_line|#define INIT_QDISC(name) { &bslash;&n;          extern struct Qdisc_ops name##_qdisc_ops; &bslash;&n;          register_qdisc(&amp; name##_qdisc_ops);       &bslash;&n;&t;}
id|INIT_QDISC
c_func
(paren
id|pfifo
)paren
suffix:semicolon
id|INIT_QDISC
c_func
(paren
id|bfifo
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_SCH_CBQ
id|INIT_QDISC
c_func
(paren
id|cbq
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_CSZ
id|INIT_QDISC
c_func
(paren
id|csz
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_HPFQ
id|INIT_QDISC
c_func
(paren
id|hpfq
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_HFSC
id|INIT_QDISC
c_func
(paren
id|hfsc
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_RED
id|INIT_QDISC
c_func
(paren
id|red
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_GRED
id|INIT_QDISC
c_func
(paren
id|gred
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_INGRESS
id|INIT_QDISC
c_func
(paren
id|ingress
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_DSMARK
id|INIT_QDISC
c_func
(paren
id|dsmark
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_SFQ
id|INIT_QDISC
c_func
(paren
id|sfq
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_TBF
id|INIT_QDISC
c_func
(paren
id|tbf
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_TEQL
id|teql_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_PRIO
id|INIT_QDISC
c_func
(paren
id|prio
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_ATM
id|INIT_QDISC
c_func
(paren
id|atm
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_CLS
id|tc_filter_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_PROC_FS
id|create_proc_read_entry
c_func
(paren
l_string|&quot;net/psched&quot;
comma
l_int|0
comma
l_int|0
comma
id|psched_read_proc
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
eof
