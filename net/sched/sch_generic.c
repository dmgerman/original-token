multiline_comment|/*&n; * net/sched/sch_generic.c&t;Generic packet scheduler routines.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; * Authors:&t;Alexey Kuznetsov, &lt;kuznet@ms2.inr.ac.ru&gt;&n; */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/pkt_sched.h&gt;
DECL|macro|BUG_TRAP
mdefine_line|#define BUG_TRAP(x) if (!(x)) { printk(&quot;Assertion (&quot; #x &quot;) failed at &quot; __FILE__ &quot;(%d):&quot; __FUNCTION__ &quot;&bslash;n&quot;, __LINE__); }
multiline_comment|/* Main transmission queue. */
DECL|variable|qdisc_head
r_struct
id|Qdisc_head
id|qdisc_head
op_assign
(brace
op_amp
id|qdisc_head
comma
op_amp
id|qdisc_head
)brace
suffix:semicolon
DECL|variable|qdisc_runqueue_lock
id|spinlock_t
id|qdisc_runqueue_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Main qdisc structure lock. &n;&n;   However, modifications&n;   to data, participating in scheduling must be additionally&n;   protected with dev-&gt;queue_lock spinlock.&n;&n;   The idea is the following:&n;   - enqueue, dequeue are serialized via top level device&n;     spinlock dev-&gt;queue_lock.&n;   - tree walking is protected by read_lock(qdisc_tree_lock)&n;     and this lock is used only in process context.&n;   - updates to tree are made only under rtnl semaphore,&n;     hence this lock may be made without local bh disabling.&n;&n;   qdisc_tree_lock must be grabbed BEFORE dev-&gt;queue_lock!&n; */
DECL|variable|qdisc_tree_lock
id|rwlock_t
id|qdisc_tree_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Anti deadlock rules:&n;&n;   qdisc_runqueue_lock protects main transmission list qdisc_head.&n;   Run list is accessed only under this spinlock.&n;&n;   dev-&gt;queue_lock serializes queue accesses for this device&n;   AND dev-&gt;qdisc pointer itself.&n;&n;   dev-&gt;xmit_lock serializes accesses to device driver.&n;&n;   dev-&gt;queue_lock and dev-&gt;xmit_lock are mutually exclusive,&n;   if one is grabbed, another must be free.&n;&n;   qdisc_runqueue_lock may be requested under dev-&gt;queue_lock,&n;   but neither dev-&gt;queue_lock nor dev-&gt;xmit_lock may be requested&n;   under qdisc_runqueue_lock.&n; */
multiline_comment|/* Kick device.&n;   Note, that this procedure can be called by a watchdog timer, so that&n;   we do not check dev-&gt;tbusy flag here.&n;&n;   Returns:  0  - queue is empty.&n;            &gt;0  - queue is not empty, but throttled.&n;&t;    &lt;0  - queue is not empty. Device is throttled, if dev-&gt;tbusy != 0.&n;&n;   NOTE: Called under dev-&gt;queue_lock with locally disabled BH.&n;*/
DECL|function|qdisc_restart
r_int
id|qdisc_restart
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|Qdisc
op_star
id|q
op_assign
id|dev-&gt;qdisc
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|q
op_member_access_from_pointer
id|dequeue
c_func
(paren
id|q
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Dequeue packet and release queue */
id|spin_unlock
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|netdev_nit
)paren
id|dev_queue_xmit_nit
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|spin_trylock
c_func
(paren
op_amp
id|dev-&gt;xmit_lock
)paren
)paren
(brace
multiline_comment|/* Remember that the driver is grabbed by us. */
id|dev-&gt;xmit_lock_owner
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|hard_start_xmit
c_func
(paren
id|skb
comma
id|dev
)paren
op_eq
l_int|0
)paren
(brace
id|dev-&gt;xmit_lock_owner
op_assign
op_minus
l_int|1
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dev-&gt;xmit_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|dev-&gt;qdisc-&gt;tx_last
op_assign
id|jiffies
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Release the driver */
id|dev-&gt;xmit_lock_owner
op_assign
op_minus
l_int|1
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dev-&gt;xmit_lock
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* So, someone grabbed the driver. */
multiline_comment|/* It may be transient configuration error,&n;&t;&t;&t;   when hard_start_xmit() recurses. We detect&n;&t;&t;&t;   it by checking xmit owner and drop the&n;&t;&t;&t;   packet when deadloop is detected.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;xmit_lock_owner
op_eq
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Dead loop on virtual %s, fix it urgently!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Otherwise, packet is requeued&n;&t;&t;&t;   and will be sent by the next net_bh run.&n;&t;&t;&t; */
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
multiline_comment|/* Device kicked us out :(&n;&t;&t;   This is possible in three cases:&n;&n;&t;&t;   0. driver is locked&n;&t;&t;   1. fastroute is enabled&n;&t;&t;   2. device cannot determine busy state&n;&t;&t;      before start of transmission (f.e. dialout)&n;&t;&t;   3. device is buggy (ppp)&n;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|q
op_assign
id|dev-&gt;qdisc
suffix:semicolon
id|q-&gt;ops
op_member_access_from_pointer
id|requeue
c_func
(paren
id|skb
comma
id|q
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|dev-&gt;qdisc-&gt;q.qlen
suffix:semicolon
)brace
r_static
id|__inline__
r_void
DECL|function|qdisc_stop_run
id|qdisc_stop_run
c_func
(paren
r_struct
id|Qdisc
op_star
id|q
)paren
(brace
id|q-&gt;h.forw-&gt;back
op_assign
id|q-&gt;h.back
suffix:semicolon
id|q-&gt;h.back-&gt;forw
op_assign
id|q-&gt;h.forw
suffix:semicolon
id|q-&gt;h.forw
op_assign
l_int|NULL
suffix:semicolon
)brace
r_extern
id|__inline__
r_void
DECL|function|qdisc_continue_run
id|qdisc_continue_run
c_func
(paren
r_struct
id|Qdisc
op_star
id|q
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|qdisc_on_runqueue
c_func
(paren
id|q
)paren
op_logical_and
id|q-&gt;dev
)paren
(brace
id|q-&gt;h.forw
op_assign
op_amp
id|qdisc_head
suffix:semicolon
id|q-&gt;h.back
op_assign
id|qdisc_head.back
suffix:semicolon
id|qdisc_head.back-&gt;forw
op_assign
op_amp
id|q-&gt;h
suffix:semicolon
id|qdisc_head.back
op_assign
op_amp
id|q-&gt;h
suffix:semicolon
)brace
)brace
r_static
id|__inline__
r_int
DECL|function|qdisc_init_run
id|qdisc_init_run
c_func
(paren
r_struct
id|Qdisc_head
op_star
id|lh
)paren
(brace
r_if
c_cond
(paren
id|qdisc_head.forw
op_ne
op_amp
id|qdisc_head
)paren
(brace
op_star
id|lh
op_assign
id|qdisc_head
suffix:semicolon
id|lh-&gt;forw-&gt;back
op_assign
id|lh
suffix:semicolon
id|lh-&gt;back-&gt;forw
op_assign
id|lh
suffix:semicolon
id|qdisc_head.forw
op_assign
op_amp
id|qdisc_head
suffix:semicolon
id|qdisc_head.back
op_assign
op_amp
id|qdisc_head
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Scan transmission queue and kick devices.&n;&n;   Deficiency: slow devices (ppp) and fast ones (100Mb ethernet)&n;   share one queue. This means that if we have a lot of loaded ppp channels,&n;   we will scan a long list on every 100Mb EOI.&n;   I have no idea how to solve it using only &quot;anonymous&quot; Linux mark_bh().&n;&n;   To change queue from device interrupt? Ough... only not this...&n;&n;   This function is called only from net_bh.&n; */
DECL|function|qdisc_run_queues
r_void
id|qdisc_run_queues
c_func
(paren
r_void
)paren
(brace
r_struct
id|Qdisc_head
id|lh
comma
op_star
id|h
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|qdisc_runqueue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qdisc_init_run
c_func
(paren
op_amp
id|lh
)paren
)paren
r_goto
id|out
suffix:semicolon
r_while
c_loop
(paren
(paren
id|h
op_assign
id|lh.forw
)paren
op_ne
op_amp
id|lh
)paren
(brace
r_int
id|res
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_struct
id|Qdisc
op_star
id|q
op_assign
(paren
r_struct
id|Qdisc
op_star
)paren
id|h
suffix:semicolon
id|qdisc_stop_run
c_func
(paren
id|q
)paren
suffix:semicolon
id|dev
op_assign
id|q-&gt;dev
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|qdisc_runqueue_lock
)paren
suffix:semicolon
id|res
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|spin_trylock
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|dev-&gt;tbusy
op_logical_and
(paren
id|res
op_assign
id|qdisc_restart
c_func
(paren
id|dev
)paren
)paren
OL
l_int|0
)paren
multiline_comment|/* NOTHING */
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|qdisc_runqueue_lock
)paren
suffix:semicolon
multiline_comment|/* If qdisc is not empty add it to the tail of list */
r_if
c_cond
(paren
id|res
)paren
id|qdisc_continue_run
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|qdisc_runqueue_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Periodic watchdog timer to recover from hard/soft device bugs. */
r_static
r_void
id|dev_do_watchdog
c_func
(paren
r_int
r_int
id|dummy
)paren
suffix:semicolon
DECL|variable|dev_watchdog
r_static
r_struct
id|timer_list
id|dev_watchdog
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0L
comma
l_int|0L
comma
op_amp
id|dev_do_watchdog
)brace
suffix:semicolon
multiline_comment|/*   This function is called only from timer */
DECL|function|dev_do_watchdog
r_static
r_void
id|dev_do_watchdog
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_struct
id|Qdisc_head
id|lh
comma
op_star
id|h
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|qdisc_runqueue_lock
)paren
)paren
(brace
multiline_comment|/* No hurry with watchdog. */
id|mod_timer
c_func
(paren
op_amp
id|dev_watchdog
comma
id|jiffies
op_plus
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|qdisc_init_run
c_func
(paren
op_amp
id|lh
)paren
)paren
r_goto
id|out
suffix:semicolon
r_while
c_loop
(paren
(paren
id|h
op_assign
id|lh.forw
)paren
op_ne
op_amp
id|lh
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_struct
id|Qdisc
op_star
id|q
op_assign
(paren
r_struct
id|Qdisc
op_star
)paren
id|h
suffix:semicolon
id|qdisc_stop_run
c_func
(paren
id|q
)paren
suffix:semicolon
id|dev
op_assign
id|q-&gt;dev
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|qdisc_runqueue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|spin_trylock
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
)paren
(brace
id|q
op_assign
id|dev-&gt;qdisc
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;tbusy
op_logical_and
id|jiffies
op_minus
id|q-&gt;tx_last
OG
id|q-&gt;tx_timeo
)paren
id|qdisc_restart
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|qdisc_runqueue_lock
)paren
suffix:semicolon
id|qdisc_continue_run
c_func
(paren
id|dev-&gt;qdisc
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|mod_timer
c_func
(paren
op_amp
id|dev_watchdog
comma
id|jiffies
op_plus
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|qdisc_runqueue_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* &quot;NOOP&quot; scheduler: the best scheduler, recommended for all interfaces&n;   under all circumstances. It is difficult to invent anything faster or&n;   cheaper.&n; */
r_static
r_int
DECL|function|noop_enqueue
id|noop_enqueue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|sk_buff
op_star
DECL|function|noop_dequeue
id|noop_dequeue
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_int
DECL|function|noop_requeue
id|noop_requeue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s deferred output. It is buggy.&bslash;n&quot;
comma
id|skb-&gt;dev-&gt;name
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|noop_qdisc_ops
r_struct
id|Qdisc_ops
id|noop_qdisc_ops
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;noop&quot;
comma
l_int|0
comma
id|noop_enqueue
comma
id|noop_dequeue
comma
id|noop_requeue
comma
)brace
suffix:semicolon
DECL|variable|noop_qdisc
r_struct
id|Qdisc
id|noop_qdisc
op_assign
(brace
(brace
l_int|NULL
)brace
comma
id|noop_enqueue
comma
id|noop_dequeue
comma
id|TCQ_F_BUILTIN
comma
op_amp
id|noop_qdisc_ops
comma
)brace
suffix:semicolon
DECL|variable|noqueue_qdisc_ops
r_struct
id|Qdisc_ops
id|noqueue_qdisc_ops
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;noqueue&quot;
comma
l_int|0
comma
id|noop_enqueue
comma
id|noop_dequeue
comma
id|noop_requeue
comma
)brace
suffix:semicolon
DECL|variable|noqueue_qdisc
r_struct
id|Qdisc
id|noqueue_qdisc
op_assign
(brace
(brace
l_int|NULL
)brace
comma
l_int|NULL
comma
id|noop_dequeue
comma
id|TCQ_F_BUILTIN
comma
op_amp
id|noqueue_qdisc_ops
comma
)brace
suffix:semicolon
DECL|variable|prio2band
r_static
r_const
id|u8
id|prio2band
(braket
id|TC_PRIO_MAX
op_plus
l_int|1
)braket
op_assign
(brace
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)brace
suffix:semicolon
multiline_comment|/* 3-band FIFO queue: old style, but should be a bit faster than&n;   generic prio+fifo combination.&n; */
r_static
r_int
DECL|function|pfifo_fast_enqueue
id|pfifo_fast_enqueue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_struct
id|sk_buff_head
op_star
id|list
suffix:semicolon
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff_head
op_star
)paren
id|qdisc-&gt;data
)paren
op_plus
id|prio2band
(braket
id|skb-&gt;priority
op_amp
id|TC_PRIO_MAX
)braket
suffix:semicolon
r_if
c_cond
(paren
id|list-&gt;qlen
op_le
id|skb-&gt;dev-&gt;tx_queue_len
)paren
(brace
id|__skb_queue_tail
c_func
(paren
id|list
comma
id|skb
)paren
suffix:semicolon
id|qdisc-&gt;q.qlen
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|qdisc-&gt;stats.drops
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|sk_buff
op_star
DECL|function|pfifo_fast_dequeue
id|pfifo_fast_dequeue
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_int
id|prio
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff_head
op_star
)paren
id|qdisc-&gt;data
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_for
c_loop
(paren
id|prio
op_assign
l_int|0
suffix:semicolon
id|prio
OL
l_int|3
suffix:semicolon
id|prio
op_increment
comma
id|list
op_increment
)paren
(brace
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
id|qdisc-&gt;q.qlen
op_decrement
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfifo_fast_requeue
id|pfifo_fast_requeue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_struct
id|sk_buff_head
op_star
id|list
suffix:semicolon
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff_head
op_star
)paren
id|qdisc-&gt;data
)paren
op_plus
id|prio2band
(braket
id|skb-&gt;priority
op_amp
id|TC_PRIO_MAX
)braket
suffix:semicolon
id|__skb_queue_head
c_func
(paren
id|list
comma
id|skb
)paren
suffix:semicolon
id|qdisc-&gt;q.qlen
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfifo_fast_reset
id|pfifo_fast_reset
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_int
id|prio
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff_head
op_star
)paren
id|qdisc-&gt;data
)paren
suffix:semicolon
r_for
c_loop
(paren
id|prio
op_assign
l_int|0
suffix:semicolon
id|prio
OL
l_int|3
suffix:semicolon
id|prio
op_increment
)paren
id|skb_queue_purge
c_func
(paren
id|list
op_plus
id|prio
)paren
suffix:semicolon
id|qdisc-&gt;q.qlen
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|pfifo_fast_init
r_static
r_int
id|pfifo_fast_init
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
comma
r_struct
id|rtattr
op_star
id|opt
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|list
suffix:semicolon
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff_head
op_star
)paren
id|qdisc-&gt;data
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|skb_queue_head_init
c_func
(paren
id|list
op_plus
id|i
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pfifo_fast_ops
r_static
r_struct
id|Qdisc_ops
id|pfifo_fast_ops
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;pfifo_fast&quot;
comma
l_int|3
op_star
r_sizeof
(paren
r_struct
id|sk_buff_head
)paren
comma
id|pfifo_fast_enqueue
comma
id|pfifo_fast_dequeue
comma
id|pfifo_fast_requeue
comma
l_int|NULL
comma
id|pfifo_fast_init
comma
id|pfifo_fast_reset
comma
)brace
suffix:semicolon
DECL|function|qdisc_create_dflt
r_struct
id|Qdisc
op_star
id|qdisc_create_dflt
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|Qdisc_ops
op_star
id|ops
)paren
(brace
r_struct
id|Qdisc
op_star
id|sch
suffix:semicolon
r_int
id|size
op_assign
r_sizeof
(paren
op_star
id|sch
)paren
op_plus
id|ops-&gt;priv_size
suffix:semicolon
id|sch
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sch
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|sch
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|sch-&gt;q
)paren
suffix:semicolon
id|sch-&gt;ops
op_assign
id|ops
suffix:semicolon
id|sch-&gt;enqueue
op_assign
id|ops-&gt;enqueue
suffix:semicolon
id|sch-&gt;dequeue
op_assign
id|ops-&gt;dequeue
suffix:semicolon
id|sch-&gt;dev
op_assign
id|dev
suffix:semicolon
id|sch-&gt;stats.lock
op_assign
op_amp
id|dev-&gt;queue_lock
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|sch-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ops-&gt;init
op_logical_or
id|ops
op_member_access_from_pointer
id|init
c_func
(paren
id|sch
comma
l_int|NULL
)paren
op_eq
l_int|0
)paren
r_return
id|sch
suffix:semicolon
id|kfree
c_func
(paren
id|sch
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Under dev-&gt;queue_lock and BH! */
DECL|function|qdisc_reset
r_void
id|qdisc_reset
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_struct
id|Qdisc_ops
op_star
id|ops
op_assign
id|qdisc-&gt;ops
suffix:semicolon
r_if
c_cond
(paren
id|ops-&gt;reset
)paren
id|ops
op_member_access_from_pointer
id|reset
c_func
(paren
id|qdisc
)paren
suffix:semicolon
)brace
multiline_comment|/* Under dev-&gt;queue_lock and BH! */
DECL|function|qdisc_destroy
r_void
id|qdisc_destroy
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_struct
id|Qdisc_ops
op_star
id|ops
op_assign
id|qdisc-&gt;ops
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|qdisc-&gt;refcnt
)paren
)paren
r_return
suffix:semicolon
id|dev
op_assign
id|qdisc-&gt;dev
suffix:semicolon
macro_line|#ifdef CONFIG_NET_SCHED
r_if
c_cond
(paren
id|dev
)paren
(brace
r_struct
id|Qdisc
op_star
id|q
comma
op_star
op_star
id|qp
suffix:semicolon
r_for
c_loop
(paren
id|qp
op_assign
op_amp
id|qdisc-&gt;dev-&gt;qdisc_list
suffix:semicolon
(paren
id|q
op_assign
op_star
id|qp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|qp
op_assign
op_amp
id|q-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|q
op_eq
id|qdisc
)paren
(brace
op_star
id|qp
op_assign
id|q-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef CONFIG_NET_ESTIMATOR
id|qdisc_kill_estimator
c_func
(paren
op_amp
id|qdisc-&gt;stats
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
r_if
c_cond
(paren
id|ops-&gt;reset
)paren
id|ops
op_member_access_from_pointer
id|reset
c_func
(paren
id|qdisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ops-&gt;destroy
)paren
id|ops
op_member_access_from_pointer
id|destroy
c_func
(paren
id|qdisc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|qdisc-&gt;flags
op_amp
id|TCQ_F_BUILTIN
)paren
)paren
id|kfree
c_func
(paren
id|qdisc
)paren
suffix:semicolon
)brace
DECL|function|dev_activate
r_void
id|dev_activate
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
multiline_comment|/* No queueing discipline is attached to device;&n;&t;   create default one i.e. pfifo_fast for devices,&n;&t;   which need queueing and noqueue_qdisc for&n;&t;   virtual interfaces&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;qdisc_sleeping
op_eq
op_amp
id|noop_qdisc
)paren
(brace
r_struct
id|Qdisc
op_star
id|qdisc
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;tx_queue_len
)paren
(brace
id|qdisc
op_assign
id|qdisc_create_dflt
c_func
(paren
id|dev
comma
op_amp
id|pfifo_fast_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qdisc
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: activation failed&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
id|qdisc
op_assign
op_amp
id|noqueue_qdisc
suffix:semicolon
)brace
id|write_lock
c_func
(paren
op_amp
id|qdisc_tree_lock
)paren
suffix:semicolon
id|dev-&gt;qdisc_sleeping
op_assign
id|qdisc
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|qdisc_tree_lock
)paren
suffix:semicolon
)brace
id|spin_lock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|qdisc_runqueue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;qdisc
op_assign
id|dev-&gt;qdisc_sleeping
)paren
op_ne
op_amp
id|noqueue_qdisc
)paren
(brace
id|dev-&gt;qdisc-&gt;tx_timeo
op_assign
l_int|5
op_star
id|HZ
suffix:semicolon
id|dev-&gt;qdisc-&gt;tx_last
op_assign
id|jiffies
op_minus
id|dev-&gt;qdisc-&gt;tx_timeo
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|dev_watchdog
)paren
)paren
id|dev_watchdog.expires
op_assign
id|jiffies
op_plus
l_int|5
op_star
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|dev_watchdog
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|qdisc_runqueue_lock
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
)brace
DECL|function|dev_deactivate
r_void
id|dev_deactivate
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|Qdisc
op_star
id|qdisc
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|qdisc
op_assign
id|dev-&gt;qdisc
suffix:semicolon
id|dev-&gt;qdisc
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|qdisc_reset
c_func
(paren
id|qdisc
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|qdisc_runqueue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qdisc_on_runqueue
c_func
(paren
id|qdisc
)paren
)paren
id|qdisc_stop_run
c_func
(paren
id|qdisc
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|qdisc_runqueue_lock
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
)brace
DECL|function|dev_init_scheduler
r_void
id|dev_init_scheduler
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|qdisc_tree_lock
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|dev-&gt;qdisc
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|dev-&gt;qdisc_sleeping
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|dev-&gt;qdisc_list
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|qdisc_tree_lock
)paren
suffix:semicolon
)brace
DECL|function|dev_shutdown
r_void
id|dev_shutdown
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|Qdisc
op_star
id|qdisc
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|qdisc_tree_lock
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|qdisc
op_assign
id|dev-&gt;qdisc_sleeping
suffix:semicolon
id|dev-&gt;qdisc
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|dev-&gt;qdisc_sleeping
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|qdisc_destroy
c_func
(paren
id|qdisc
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|dev-&gt;qdisc_list
op_eq
l_int|NULL
)paren
suffix:semicolon
id|dev-&gt;qdisc_list
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|qdisc_tree_lock
)paren
suffix:semicolon
)brace
eof
