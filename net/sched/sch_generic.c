multiline_comment|/*&n; * net/sched/sch_generic.c&t;Generic packet scheduler routines.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; * Authors:&t;Alexey Kuznetsov, &lt;kuznet@ms2.inr.ac.ru&gt;&n; */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/pkt_sched.h&gt;
DECL|macro|BUG_TRAP
mdefine_line|#define BUG_TRAP(x) if (!(x)) { printk(&quot;Assertion (&quot; #x &quot;) failed at &quot; __FILE__ &quot;(%d):&quot; __FUNCTION__ &quot;&bslash;n&quot;, __LINE__); }
multiline_comment|/* Main transmission queue. */
DECL|variable|qdisc_head
r_struct
id|Qdisc_head
id|qdisc_head
op_assign
(brace
op_amp
id|qdisc_head
)brace
suffix:semicolon
multiline_comment|/* Kick device.&n;   Note, that this procedure can be called by a watchdog timer, so that&n;   we do not check dev-&gt;tbusy flag here.&n;&n;   Returns:  0  - queue is empty.&n;            &gt;0  - queue is not empty, but throttled.&n;&t;    &lt;0  - queue is not empty. Device is throttled, if dev-&gt;tbusy != 0.&n;&n;   NOTE: Called only from NET BH&n;*/
DECL|function|qdisc_restart
r_int
id|qdisc_restart
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|Qdisc
op_star
id|q
op_assign
id|dev-&gt;qdisc
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|q
op_member_access_from_pointer
id|dequeue
c_func
(paren
id|q
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|netdev_nit
)paren
id|dev_queue_xmit_nit
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|hard_start_xmit
c_func
(paren
id|skb
comma
id|dev
)paren
op_eq
l_int|0
)paren
(brace
id|q-&gt;tx_last
op_assign
id|jiffies
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Device kicked us out :(&n;&t;&t;   This is possible in three cases:&n;&n;&t;&t;   1. fastroute is enabled&n;&t;&t;   2. device cannot determine busy state&n;&t;&t;      before start of transmission (f.e. dialout)&n;&t;&t;   3. device is buggy (ppp)&n;&t;&t; */
id|q-&gt;ops
op_member_access_from_pointer
id|requeue
c_func
(paren
id|skb
comma
id|q
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|q-&gt;q.qlen
suffix:semicolon
)brace
multiline_comment|/* Scan transmission queue and kick devices.&n;&n;   Deficiency: slow devices (ppp) and fast ones (100Mb ethernet)&n;   share one queue. This means that if we have a lot of loaded ppp channels,&n;   we will scan a long list on every 100Mb EOI.&n;   I have no idea how to solve it using only &quot;anonymous&quot; Linux mark_bh().&n;&n;   To change queue from device interrupt? Ough... only not this...&n; */
DECL|function|qdisc_run_queues
r_void
id|qdisc_run_queues
c_func
(paren
r_void
)paren
(brace
r_struct
id|Qdisc_head
op_star
op_star
id|hp
comma
op_star
id|h
suffix:semicolon
id|hp
op_assign
op_amp
id|qdisc_head.forw
suffix:semicolon
r_while
c_loop
(paren
(paren
id|h
op_assign
op_star
id|hp
)paren
op_ne
op_amp
id|qdisc_head
)paren
(brace
r_int
id|res
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|Qdisc
op_star
id|q
op_assign
(paren
r_struct
id|Qdisc
op_star
)paren
id|h
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
id|q-&gt;dev
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|dev-&gt;tbusy
op_logical_and
(paren
id|res
op_assign
id|qdisc_restart
c_func
(paren
id|dev
)paren
)paren
OL
l_int|0
)paren
multiline_comment|/* NOTHING */
suffix:semicolon
multiline_comment|/* An explanation is necessary here.&n;&t;&t;   qdisc_restart called dev-&gt;hard_start_xmit,&n;&t;&t;   if device is virtual, it could trigger one more&n;&t;&t;   dev_queue_xmit and a new device could appear&n;&t;&t;   in the active chain. In this case we cannot unlink&n;&t;&t;   the empty queue, because we lost the back pointer.&n;&t;&t;   No problem, we will unlink it during the next round.&n;&t;&t; */
r_if
c_cond
(paren
id|res
op_eq
l_int|0
op_logical_and
op_star
id|hp
op_eq
id|h
)paren
(brace
op_star
id|hp
op_assign
id|h-&gt;forw
suffix:semicolon
id|h-&gt;forw
op_assign
l_int|NULL
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|hp
op_assign
op_amp
id|h-&gt;forw
suffix:semicolon
)brace
)brace
multiline_comment|/* Periodic watchdoc timer to recover from hard/soft device bugs. */
r_static
r_void
id|dev_do_watchdog
c_func
(paren
r_int
r_int
id|dummy
)paren
suffix:semicolon
DECL|variable|dev_watchdog
r_static
r_struct
id|timer_list
id|dev_watchdog
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0L
comma
l_int|0L
comma
op_amp
id|dev_do_watchdog
)brace
suffix:semicolon
DECL|function|dev_do_watchdog
r_static
r_void
id|dev_do_watchdog
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_struct
id|Qdisc_head
op_star
id|h
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
id|qdisc_head.forw
suffix:semicolon
id|h
op_ne
op_amp
id|qdisc_head
suffix:semicolon
id|h
op_assign
id|h-&gt;forw
)paren
(brace
r_struct
id|Qdisc
op_star
id|q
op_assign
(paren
r_struct
id|Qdisc
op_star
)paren
id|h
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
id|q-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;tbusy
op_logical_and
id|jiffies
op_minus
id|q-&gt;tx_last
OG
id|q-&gt;tx_timeo
)paren
id|qdisc_restart
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|dev_watchdog.expires
op_assign
id|jiffies
op_plus
l_int|5
op_star
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|dev_watchdog
)paren
suffix:semicolon
)brace
multiline_comment|/* &quot;NOOP&quot; scheduler: the best scheduler, recommended for all interfaces&n;   under all circumstances. It is difficult to invent anything faster or&n;   cheaper.&n; */
r_static
r_int
DECL|function|noop_enqueue
id|noop_enqueue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|sk_buff
op_star
DECL|function|noop_dequeue
id|noop_dequeue
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_int
DECL|function|noop_requeue
id|noop_requeue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s deferred output. It is buggy.&bslash;n&quot;
comma
id|skb-&gt;dev-&gt;name
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|noop_qdisc_ops
r_struct
id|Qdisc_ops
id|noop_qdisc_ops
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;noop&quot;
comma
l_int|0
comma
id|noop_enqueue
comma
id|noop_dequeue
comma
id|noop_requeue
comma
)brace
suffix:semicolon
DECL|variable|noop_qdisc
r_struct
id|Qdisc
id|noop_qdisc
op_assign
(brace
(brace
l_int|NULL
)brace
comma
id|noop_enqueue
comma
id|noop_dequeue
comma
id|TCQ_F_BUILTIN
comma
op_amp
id|noop_qdisc_ops
comma
)brace
suffix:semicolon
DECL|variable|noqueue_qdisc_ops
r_struct
id|Qdisc_ops
id|noqueue_qdisc_ops
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;noqueue&quot;
comma
l_int|0
comma
id|noop_enqueue
comma
id|noop_dequeue
comma
id|noop_requeue
comma
)brace
suffix:semicolon
DECL|variable|noqueue_qdisc
r_struct
id|Qdisc
id|noqueue_qdisc
op_assign
(brace
(brace
l_int|NULL
)brace
comma
l_int|NULL
comma
l_int|NULL
comma
id|TCQ_F_BUILTIN
comma
op_amp
id|noqueue_qdisc_ops
comma
)brace
suffix:semicolon
DECL|variable|prio2band
r_static
r_const
id|u8
id|prio2band
(braket
id|TC_PRIO_MAX
op_plus
l_int|1
)braket
op_assign
(brace
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)brace
suffix:semicolon
multiline_comment|/* 3-band FIFO queue: old style, but should be a bit faster than&n;   generic prio+fifo combination.&n; */
r_static
r_int
DECL|function|pfifo_fast_enqueue
id|pfifo_fast_enqueue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_struct
id|sk_buff_head
op_star
id|list
suffix:semicolon
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff_head
op_star
)paren
id|qdisc-&gt;data
)paren
op_plus
id|prio2band
(braket
id|skb-&gt;priority
op_amp
id|TC_PRIO_MAX
)braket
suffix:semicolon
r_if
c_cond
(paren
id|list-&gt;qlen
op_le
id|skb-&gt;dev-&gt;tx_queue_len
)paren
(brace
id|__skb_queue_tail
c_func
(paren
id|list
comma
id|skb
)paren
suffix:semicolon
id|qdisc-&gt;q.qlen
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|qdisc-&gt;stats.drops
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|sk_buff
op_star
DECL|function|pfifo_fast_dequeue
id|pfifo_fast_dequeue
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_int
id|prio
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff_head
op_star
)paren
id|qdisc-&gt;data
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_for
c_loop
(paren
id|prio
op_assign
l_int|0
suffix:semicolon
id|prio
OL
l_int|3
suffix:semicolon
id|prio
op_increment
comma
id|list
op_increment
)paren
(brace
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
id|qdisc-&gt;q.qlen
op_decrement
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfifo_fast_requeue
id|pfifo_fast_requeue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_struct
id|sk_buff_head
op_star
id|list
suffix:semicolon
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff_head
op_star
)paren
id|qdisc-&gt;data
)paren
op_plus
id|prio2band
(braket
id|skb-&gt;priority
op_amp
id|TC_PRIO_MAX
)braket
suffix:semicolon
id|__skb_queue_head
c_func
(paren
id|list
comma
id|skb
)paren
suffix:semicolon
id|qdisc-&gt;q.qlen
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfifo_fast_reset
id|pfifo_fast_reset
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_int
id|prio
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff_head
op_star
)paren
id|qdisc-&gt;data
)paren
suffix:semicolon
r_for
c_loop
(paren
id|prio
op_assign
l_int|0
suffix:semicolon
id|prio
OL
l_int|3
suffix:semicolon
id|prio
op_increment
)paren
id|skb_queue_purge
c_func
(paren
id|list
op_plus
id|prio
)paren
suffix:semicolon
id|qdisc-&gt;q.qlen
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|pfifo_fast_init
r_static
r_int
id|pfifo_fast_init
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
comma
r_struct
id|rtattr
op_star
id|opt
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|list
suffix:semicolon
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff_head
op_star
)paren
id|qdisc-&gt;data
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|skb_queue_head_init
c_func
(paren
id|list
op_plus
id|i
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pfifo_fast_ops
r_static
r_struct
id|Qdisc_ops
id|pfifo_fast_ops
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;pfifo_fast&quot;
comma
l_int|3
op_star
r_sizeof
(paren
r_struct
id|sk_buff_head
)paren
comma
id|pfifo_fast_enqueue
comma
id|pfifo_fast_dequeue
comma
id|pfifo_fast_requeue
comma
l_int|NULL
comma
id|pfifo_fast_init
comma
id|pfifo_fast_reset
comma
)brace
suffix:semicolon
DECL|function|qdisc_create_dflt
r_struct
id|Qdisc
op_star
id|qdisc_create_dflt
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|Qdisc_ops
op_star
id|ops
)paren
(brace
r_struct
id|Qdisc
op_star
id|sch
suffix:semicolon
r_int
id|size
op_assign
r_sizeof
(paren
op_star
id|sch
)paren
op_plus
id|ops-&gt;priv_size
suffix:semicolon
id|sch
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sch
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|sch
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|sch-&gt;q
)paren
suffix:semicolon
id|sch-&gt;ops
op_assign
id|ops
suffix:semicolon
id|sch-&gt;enqueue
op_assign
id|ops-&gt;enqueue
suffix:semicolon
id|sch-&gt;dequeue
op_assign
id|ops-&gt;dequeue
suffix:semicolon
id|sch-&gt;dev
op_assign
id|dev
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|sch-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ops-&gt;init
op_logical_or
id|ops
op_member_access_from_pointer
id|init
c_func
(paren
id|sch
comma
l_int|NULL
)paren
op_eq
l_int|0
)paren
r_return
id|sch
suffix:semicolon
id|kfree
c_func
(paren
id|sch
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|qdisc_reset
r_void
id|qdisc_reset
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_struct
id|Qdisc_ops
op_star
id|ops
op_assign
id|qdisc-&gt;ops
suffix:semicolon
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ops-&gt;reset
)paren
id|ops
op_member_access_from_pointer
id|reset
c_func
(paren
id|qdisc
)paren
suffix:semicolon
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|qdisc_destroy
r_void
id|qdisc_destroy
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_struct
id|Qdisc_ops
op_star
id|ops
op_assign
id|qdisc-&gt;ops
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|qdisc-&gt;refcnt
)paren
)paren
r_return
suffix:semicolon
macro_line|#ifdef CONFIG_NET_SCHED
r_if
c_cond
(paren
id|qdisc-&gt;dev
)paren
(brace
r_struct
id|Qdisc
op_star
id|q
comma
op_star
op_star
id|qp
suffix:semicolon
r_for
c_loop
(paren
id|qp
op_assign
op_amp
id|qdisc-&gt;dev-&gt;qdisc_list
suffix:semicolon
(paren
id|q
op_assign
op_star
id|qp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|qp
op_assign
op_amp
id|q-&gt;next
)paren
r_if
c_cond
(paren
id|q
op_eq
id|qdisc
)paren
(brace
op_star
id|qp
op_assign
id|q-&gt;next
suffix:semicolon
id|q-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_NET_ESTIMATOR
id|qdisc_kill_estimator
c_func
(paren
op_amp
id|qdisc-&gt;stats
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ops-&gt;reset
)paren
id|ops
op_member_access_from_pointer
id|reset
c_func
(paren
id|qdisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ops-&gt;destroy
)paren
id|ops
op_member_access_from_pointer
id|destroy
c_func
(paren
id|qdisc
)paren
suffix:semicolon
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|qdisc-&gt;flags
op_amp
id|TCQ_F_BUILTIN
)paren
)paren
id|kfree
c_func
(paren
id|qdisc
)paren
suffix:semicolon
)brace
DECL|function|dev_activate
r_void
id|dev_activate
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
multiline_comment|/* No queueing discipline is attached to device;&n;&t;   create default one i.e. pfifo_fast for devices,&n;&t;   which need queueing and noqueue_qdisc for&n;&t;   virtual interfaces&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;qdisc_sleeping
op_eq
op_amp
id|noop_qdisc
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;tx_queue_len
)paren
(brace
r_struct
id|Qdisc
op_star
id|qdisc
suffix:semicolon
id|qdisc
op_assign
id|qdisc_create_dflt
c_func
(paren
id|dev
comma
op_amp
id|pfifo_fast_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qdisc
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: activation failed&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev-&gt;qdisc_sleeping
op_assign
id|qdisc
suffix:semicolon
)brace
r_else
id|dev-&gt;qdisc_sleeping
op_assign
op_amp
id|noqueue_qdisc
suffix:semicolon
)brace
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;qdisc
op_assign
id|dev-&gt;qdisc_sleeping
)paren
op_ne
op_amp
id|noqueue_qdisc
)paren
(brace
id|dev-&gt;qdisc-&gt;tx_timeo
op_assign
l_int|5
op_star
id|HZ
suffix:semicolon
id|dev-&gt;qdisc-&gt;tx_last
op_assign
id|jiffies
op_minus
id|dev-&gt;qdisc-&gt;tx_timeo
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|dev_watchdog
)paren
)paren
id|dev_watchdog.expires
op_assign
id|jiffies
op_plus
l_int|5
op_star
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|dev_watchdog
)paren
suffix:semicolon
)brace
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|dev_deactivate
r_void
id|dev_deactivate
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|Qdisc
op_star
id|qdisc
suffix:semicolon
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
id|qdisc
op_assign
id|xchg
c_func
(paren
op_amp
id|dev-&gt;qdisc
comma
op_amp
id|noop_qdisc
)paren
suffix:semicolon
id|qdisc_reset
c_func
(paren
id|qdisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qdisc-&gt;h.forw
)paren
(brace
r_struct
id|Qdisc_head
op_star
op_star
id|hp
comma
op_star
id|h
suffix:semicolon
r_for
c_loop
(paren
id|hp
op_assign
op_amp
id|qdisc_head.forw
suffix:semicolon
(paren
id|h
op_assign
op_star
id|hp
)paren
op_ne
op_amp
id|qdisc_head
suffix:semicolon
id|hp
op_assign
op_amp
id|h-&gt;forw
)paren
(brace
r_if
c_cond
(paren
id|h
op_eq
op_amp
id|qdisc-&gt;h
)paren
(brace
op_star
id|hp
op_assign
id|h-&gt;forw
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|dev_init_scheduler
r_void
id|dev_init_scheduler
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|dev-&gt;qdisc
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|dev-&gt;qdisc_sleeping
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|dev-&gt;qdisc_list
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|dev_shutdown
r_void
id|dev_shutdown
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|Qdisc
op_star
id|qdisc
suffix:semicolon
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
id|qdisc
op_assign
id|dev-&gt;qdisc_sleeping
suffix:semicolon
id|dev-&gt;qdisc
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|dev-&gt;qdisc_sleeping
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|qdisc_destroy
c_func
(paren
id|qdisc
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|dev-&gt;qdisc_list
op_eq
l_int|NULL
)paren
suffix:semicolon
id|dev-&gt;qdisc_list
op_assign
l_int|NULL
suffix:semicolon
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
)brace
eof
