multiline_comment|/*&n; * net/sched/sch_generic.c&t;Generic packet scheduler routines.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; * Authors:&t;Alexey Kuznetsov, &lt;kuznet@ms2.inr.ac.ru&gt;&n; */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/pkt_sched.h&gt;
DECL|variable|qdisc_head
r_struct
id|Qdisc_head
id|qdisc_head
op_assign
(brace
op_amp
id|qdisc_head
)brace
suffix:semicolon
DECL|variable|qdisc_base
r_static
r_struct
id|Qdisc_ops
op_star
id|qdisc_base
op_assign
l_int|NULL
suffix:semicolon
r_static
r_int
id|default_requeue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|qdisc
)paren
suffix:semicolon
multiline_comment|/* NOTES.&n;&n;   Every discipline has two major routines: enqueue and dequeue.&n;&n;   ---dequeue&n;&n;   dequeue usually returns a skb to send. It is allowed to return NULL,&n;   but it does not mean that queue is empty, it just means that&n;   discipline does not want to send anything this time.&n;   Queue is really empty if q-&gt;q.qlen == 0.&n;   For complicated disciplines with multiple queues q-&gt;q is not&n;   real packet queue, but however q-&gt;q.qlen must be valid.&n;&n;   ---enqueue&n;&n;   enqueue returns number of enqueued packets i.e. this number is 1,&n;   if packet was enqueued sucessfully and &lt;1 if something (not&n;   necessary THIS packet) was dropped.&n;&n; */
DECL|function|register_qdisc
r_int
id|register_qdisc
c_func
(paren
r_struct
id|Qdisc_ops
op_star
id|qops
)paren
(brace
r_struct
id|Qdisc_ops
op_star
id|q
comma
op_star
op_star
id|qp
suffix:semicolon
r_for
c_loop
(paren
id|qp
op_assign
op_amp
id|qdisc_base
suffix:semicolon
(paren
id|q
op_assign
op_star
id|qp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|qp
op_assign
op_amp
id|q-&gt;next
)paren
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|qops-&gt;id
comma
id|q-&gt;id
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
id|qops-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|qops-&gt;refcnt
op_assign
l_int|0
suffix:semicolon
op_star
id|qp
op_assign
id|qops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unregister_qdisc
r_int
id|unregister_qdisc
c_func
(paren
r_struct
id|Qdisc_ops
op_star
id|qops
)paren
(brace
r_struct
id|Qdisc_ops
op_star
id|q
comma
op_star
op_star
id|qp
suffix:semicolon
r_for
c_loop
(paren
id|qp
op_assign
op_amp
id|qdisc_base
suffix:semicolon
(paren
id|q
op_assign
op_star
id|qp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|qp
op_assign
op_amp
id|q-&gt;next
)paren
r_if
c_cond
(paren
id|q
op_eq
id|qops
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;requeue
op_eq
l_int|NULL
)paren
id|q-&gt;requeue
op_assign
id|default_requeue
suffix:semicolon
op_star
id|qp
op_assign
id|q-&gt;next
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|qdisc_lookup
r_struct
id|Qdisc
op_star
id|qdisc_lookup
c_func
(paren
r_int
id|handle
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* &quot;NOOP&quot; scheduler: the best scheduler, recommended for all interfaces&n;   in all curcumstances. It is difficult to invent anything more&n;   fast or cheap.&n; */
r_static
r_int
DECL|function|noop_enqueue
id|noop_enqueue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|sk_buff
op_star
DECL|function|noop_dequeue
id|noop_dequeue
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|noop_qdisc
r_struct
id|Qdisc
id|noop_qdisc
op_assign
(brace
(brace
l_int|NULL
)brace
comma
id|noop_enqueue
comma
id|noop_dequeue
comma
)brace
suffix:semicolon
DECL|variable|noqueue_qdisc
r_struct
id|Qdisc
id|noqueue_qdisc
op_assign
(brace
(brace
l_int|NULL
)brace
comma
l_int|NULL
comma
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/* 3-band FIFO queue: old style, but should be a bit faster (several CPU insns) */
r_static
r_int
DECL|function|pfifo_fast_enqueue
id|pfifo_fast_enqueue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_const
r_static
id|u8
id|prio2band
(braket
l_int|8
)braket
op_assign
(brace
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|list
suffix:semicolon
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff_head
op_star
)paren
id|qdisc-&gt;data
)paren
op_plus
id|prio2band
(braket
id|skb-&gt;priority
op_amp
l_int|7
)braket
suffix:semicolon
r_if
c_cond
(paren
id|list-&gt;qlen
op_le
id|skb-&gt;dev-&gt;tx_queue_len
)paren
(brace
id|__skb_queue_tail
c_func
(paren
id|list
comma
id|skb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|qdisc-&gt;dropped
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|sk_buff
op_star
DECL|function|pfifo_fast_dequeue
id|pfifo_fast_dequeue
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_int
id|prio
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff_head
op_star
)paren
id|qdisc-&gt;data
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_for
c_loop
(paren
id|prio
op_assign
l_int|0
suffix:semicolon
id|prio
OL
l_int|3
suffix:semicolon
id|prio
op_increment
comma
id|list
op_increment
)paren
(brace
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
r_return
id|skb
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_int
DECL|function|pfifo_fast_requeue
id|pfifo_fast_requeue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_const
r_static
id|u8
id|prio2band
(braket
l_int|8
)braket
op_assign
(brace
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|list
suffix:semicolon
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff_head
op_star
)paren
id|qdisc-&gt;data
)paren
op_plus
id|prio2band
(braket
id|skb-&gt;priority
op_amp
l_int|7
)braket
suffix:semicolon
id|__skb_queue_head
c_func
(paren
id|list
comma
id|skb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_void
DECL|function|pfifo_fast_reset
id|pfifo_fast_reset
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_int
id|prio
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff_head
op_star
)paren
id|qdisc-&gt;data
)paren
suffix:semicolon
r_for
c_loop
(paren
id|prio
op_assign
l_int|0
suffix:semicolon
id|prio
OL
l_int|3
suffix:semicolon
id|prio
op_increment
)paren
id|skb_queue_purge
c_func
(paren
id|list
op_plus
id|prio
)paren
suffix:semicolon
)brace
DECL|function|pfifo_fast_init
r_static
r_int
id|pfifo_fast_init
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|list
suffix:semicolon
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff_head
op_star
)paren
id|qdisc-&gt;data
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
id|skb_queue_head_init
c_func
(paren
id|list
op_plus
id|i
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pfifo_fast_ops
r_static
r_struct
id|Qdisc_ops
id|pfifo_fast_ops
op_assign
(brace
l_int|NULL
comma
l_string|&quot;pfifo_fast&quot;
comma
l_int|1
comma
l_int|3
op_star
r_sizeof
(paren
r_struct
id|sk_buff_head
)paren
comma
id|pfifo_fast_enqueue
comma
id|pfifo_fast_dequeue
comma
id|pfifo_fast_reset
comma
l_int|NULL
comma
id|pfifo_fast_init
comma
l_int|NULL
comma
id|pfifo_fast_requeue
)brace
suffix:semicolon
r_static
r_int
DECL|function|default_requeue
id|default_requeue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s deferred output. It is buggy.&bslash;n&quot;
comma
id|skb-&gt;dev-&gt;name
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|Qdisc
op_star
DECL|function|qdisc_alloc
id|qdisc_alloc
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|Qdisc_ops
op_star
id|ops
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|Qdisc
op_star
id|sch
suffix:semicolon
r_int
id|size
op_assign
r_sizeof
(paren
op_star
id|sch
)paren
op_plus
id|ops-&gt;priv_size
suffix:semicolon
id|sch
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sch
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|sch
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|sch-&gt;q
)paren
suffix:semicolon
id|sch-&gt;ops
op_assign
id|ops
suffix:semicolon
id|sch-&gt;enqueue
op_assign
id|ops-&gt;enqueue
suffix:semicolon
id|sch-&gt;dequeue
op_assign
id|ops-&gt;dequeue
suffix:semicolon
id|sch-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|ops-&gt;init
op_logical_and
id|ops
op_member_access_from_pointer
id|init
c_func
(paren
id|sch
comma
id|arg
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|ops-&gt;refcnt
op_increment
suffix:semicolon
r_return
id|sch
suffix:semicolon
)brace
DECL|function|qdisc_reset
r_void
id|qdisc_reset
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_struct
id|Qdisc_ops
op_star
id|ops
op_assign
id|qdisc-&gt;ops
suffix:semicolon
r_if
c_cond
(paren
id|ops
)paren
(brace
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ops-&gt;reset
)paren
id|ops
op_member_access_from_pointer
id|reset
c_func
(paren
id|qdisc
)paren
suffix:semicolon
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|qdisc_destroy
r_void
id|qdisc_destroy
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_struct
id|Qdisc_ops
op_star
id|ops
op_assign
id|qdisc-&gt;ops
suffix:semicolon
r_if
c_cond
(paren
id|ops
)paren
(brace
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ops-&gt;reset
)paren
id|ops
op_member_access_from_pointer
id|reset
c_func
(paren
id|qdisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ops-&gt;destroy
)paren
id|ops
op_member_access_from_pointer
id|destroy
c_func
(paren
id|qdisc
)paren
suffix:semicolon
id|ops-&gt;refcnt
op_decrement
suffix:semicolon
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|qdisc
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
id|dev_do_watchdog
c_func
(paren
r_int
r_int
id|dummy
)paren
suffix:semicolon
DECL|variable|dev_watchdog
r_static
r_struct
id|timer_list
id|dev_watchdog
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0L
comma
l_int|0L
comma
op_amp
id|dev_do_watchdog
)brace
suffix:semicolon
DECL|function|dev_do_watchdog
r_static
r_void
id|dev_do_watchdog
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_struct
id|Qdisc_head
op_star
id|h
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
id|qdisc_head.forw
suffix:semicolon
id|h
op_ne
op_amp
id|qdisc_head
suffix:semicolon
id|h
op_assign
id|h-&gt;forw
)paren
(brace
r_struct
id|Qdisc
op_star
id|q
op_assign
(paren
r_struct
id|Qdisc
op_star
)paren
id|h
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
id|q-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;tbusy
op_logical_and
id|jiffies
op_minus
id|q-&gt;tx_last
OG
id|q-&gt;tx_timeo
)paren
(brace
id|qdisc_restart
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
id|dev_watchdog.expires
op_assign
id|jiffies
op_plus
l_int|5
op_star
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|dev_watchdog
)paren
suffix:semicolon
)brace
DECL|function|dev_activate
r_void
id|dev_activate
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
multiline_comment|/* No queueing discipline is attached to device;&n;&t;   create default one i.e. pfifo_fast for devices,&n;&t;   which need queueing and noqueue_qdisc for&n;&t;   virtual intrfaces&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;qdisc_sleeping
op_eq
op_amp
id|noop_qdisc
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;tx_queue_len
)paren
(brace
r_struct
id|Qdisc
op_star
id|qdisc
suffix:semicolon
id|qdisc
op_assign
id|qdisc_alloc
c_func
(paren
id|dev
comma
op_amp
id|pfifo_fast_ops
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qdisc
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|dev-&gt;qdisc_sleeping
op_assign
id|qdisc
suffix:semicolon
)brace
r_else
id|dev-&gt;qdisc_sleeping
op_assign
op_amp
id|noqueue_qdisc
suffix:semicolon
)brace
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;qdisc
op_assign
id|dev-&gt;qdisc_sleeping
)paren
op_ne
op_amp
id|noqueue_qdisc
)paren
(brace
id|dev-&gt;qdisc-&gt;tx_timeo
op_assign
l_int|5
op_star
id|HZ
suffix:semicolon
id|dev-&gt;qdisc-&gt;tx_last
op_assign
id|jiffies
op_minus
id|dev-&gt;qdisc-&gt;tx_timeo
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev_watchdog.expires
)paren
(brace
id|dev_watchdog.expires
op_assign
id|jiffies
op_plus
l_int|5
op_star
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|dev_watchdog
)paren
suffix:semicolon
)brace
)brace
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|dev_deactivate
r_void
id|dev_deactivate
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|Qdisc
op_star
id|qdisc
suffix:semicolon
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
id|qdisc
op_assign
id|dev-&gt;qdisc
suffix:semicolon
id|dev-&gt;qdisc
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|qdisc_reset
c_func
(paren
id|qdisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qdisc-&gt;h.forw
)paren
(brace
r_struct
id|Qdisc_head
op_star
op_star
id|hp
comma
op_star
id|h
suffix:semicolon
r_for
c_loop
(paren
id|hp
op_assign
op_amp
id|qdisc_head.forw
suffix:semicolon
(paren
id|h
op_assign
op_star
id|hp
)paren
op_ne
op_amp
id|qdisc_head
suffix:semicolon
id|hp
op_assign
op_amp
id|h-&gt;forw
)paren
(brace
r_if
c_cond
(paren
id|h
op_eq
op_amp
id|qdisc-&gt;h
)paren
(brace
op_star
id|hp
op_assign
id|h-&gt;forw
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|dev_init_scheduler
r_void
id|dev_init_scheduler
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|dev-&gt;qdisc
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|dev-&gt;qdisc_sleeping
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
)brace
DECL|function|dev_shutdown
r_void
id|dev_shutdown
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|Qdisc
op_star
id|qdisc
suffix:semicolon
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
id|qdisc
op_assign
id|dev-&gt;qdisc_sleeping
suffix:semicolon
id|dev-&gt;qdisc_sleeping
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|qdisc_destroy
c_func
(paren
id|qdisc
)paren
suffix:semicolon
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|dev_set_scheduler
r_void
id|dev_set_scheduler
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|Qdisc
op_star
id|qdisc
)paren
(brace
r_struct
id|Qdisc
op_star
id|oqdisc
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
id|dev_deactivate
c_func
(paren
id|dev
)paren
suffix:semicolon
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
id|oqdisc
op_assign
id|dev-&gt;qdisc_sleeping
suffix:semicolon
multiline_comment|/* Destroy old scheduler */
r_if
c_cond
(paren
id|oqdisc
)paren
id|qdisc_destroy
c_func
(paren
id|oqdisc
)paren
suffix:semicolon
multiline_comment|/* ... and attach new one */
id|dev-&gt;qdisc_sleeping
op_assign
id|qdisc
suffix:semicolon
id|dev-&gt;qdisc
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
id|dev_activate
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Kick the queue &quot;q&quot;.&n;   Note, that this procedure is called by watchdog timer, so that&n;   we do not check dev-&gt;tbusy flag here.&n;&n;   Returns:  0  - queue is empty.&n;            &gt;0  - queue is not empty, but throttled.&n;&t;    &lt;0  - queue is not empty. Device is throttled, if dev-&gt;tbusy != 0.&n;&n;   NOTE: Called only from NET BH&n;*/
DECL|function|qdisc_restart
r_int
id|qdisc_restart
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|Qdisc
op_star
id|q
op_assign
id|dev-&gt;qdisc
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|q
op_member_access_from_pointer
id|dequeue
c_func
(paren
id|q
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|netdev_nit
)paren
id|dev_queue_xmit_nit
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|hard_start_xmit
c_func
(paren
id|skb
comma
id|dev
)paren
op_eq
l_int|0
)paren
(brace
id|q-&gt;tx_last
op_assign
id|jiffies
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|q-&gt;ops
)paren
(brace
id|q-&gt;ops
op_member_access_from_pointer
id|requeue
c_func
(paren
id|skb
comma
id|q
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: it is impossible!!!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
r_return
id|q-&gt;q.qlen
suffix:semicolon
)brace
DECL|function|qdisc_run_queues
r_void
id|qdisc_run_queues
c_func
(paren
r_void
)paren
(brace
r_struct
id|Qdisc_head
op_star
op_star
id|hp
comma
op_star
id|h
suffix:semicolon
id|hp
op_assign
op_amp
id|qdisc_head.forw
suffix:semicolon
r_while
c_loop
(paren
(paren
id|h
op_assign
op_star
id|hp
)paren
op_ne
op_amp
id|qdisc_head
)paren
(brace
r_int
id|res
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|Qdisc
op_star
id|q
op_assign
(paren
r_struct
id|Qdisc
op_star
)paren
id|h
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
id|q-&gt;dev
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|dev-&gt;tbusy
op_logical_and
(paren
id|res
op_assign
id|qdisc_restart
c_func
(paren
id|dev
)paren
)paren
OL
l_int|0
)paren
multiline_comment|/* NOTHING */
suffix:semicolon
multiline_comment|/* The explanation is necessary here.&n;&t;&t;   qdisc_restart called dev-&gt;hard_start_xmit,&n;&t;&t;   if device is virtual, it could trigger one more&n;&t;&t;   dev_queue_xmit and new device could appear&n;&t;&t;   in active chain. In this case we cannot unlink&n;&t;&t;   empty queue, because we lost back pointer.&n;&t;&t;   No problem, we will unlink it during the next round.&n;&t;&t; */
r_if
c_cond
(paren
id|res
op_eq
l_int|0
op_logical_and
op_star
id|hp
op_eq
id|h
)paren
(brace
op_star
id|hp
op_assign
id|h-&gt;forw
suffix:semicolon
id|h-&gt;forw
op_assign
l_int|NULL
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|hp
op_assign
op_amp
id|h-&gt;forw
suffix:semicolon
)brace
)brace
DECL|function|tc_init
r_int
id|tc_init
c_func
(paren
r_struct
id|pschedctl
op_star
id|pctl
)paren
(brace
r_struct
id|Qdisc
op_star
id|q
suffix:semicolon
r_struct
id|Qdisc_ops
op_star
id|qops
suffix:semicolon
r_if
c_cond
(paren
id|pctl-&gt;handle
)paren
(brace
id|q
op_assign
id|qdisc_lookup
c_func
(paren
id|pctl-&gt;handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|qops
op_assign
id|q-&gt;ops
suffix:semicolon
r_if
c_cond
(paren
id|pctl-&gt;ifindex
op_logical_and
id|q-&gt;dev-&gt;ifindex
op_ne
id|pctl-&gt;ifindex
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|tc_destroy
r_int
id|tc_destroy
c_func
(paren
r_struct
id|pschedctl
op_star
id|pctl
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|tc_attach
r_int
id|tc_attach
c_func
(paren
r_struct
id|pschedctl
op_star
id|pctl
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|tc_detach
r_int
id|tc_detach
c_func
(paren
r_struct
id|pschedctl
op_star
id|pctl
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|psched_ioctl
r_int
id|psched_ioctl
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
r_struct
id|pschedctl
id|ctl
suffix:semicolon
r_struct
id|pschedctl
op_star
id|pctl
op_assign
op_amp
id|ctl
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ctl
comma
id|arg
comma
r_sizeof
(paren
id|ctl
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|ctl.arglen
OG
l_int|0
)paren
(brace
id|pctl
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ctl
)paren
op_plus
id|ctl.arglen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pctl
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOBUFS
suffix:semicolon
id|memcpy
c_func
(paren
id|pctl
comma
op_amp
id|ctl
comma
r_sizeof
(paren
id|ctl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|pctl-&gt;args
comma
(paren
(paren
r_struct
id|pschedctl
op_star
)paren
id|arg
)paren
op_member_access_from_pointer
id|args
comma
id|ctl.arglen
)paren
)paren
(brace
id|kfree
c_func
(paren
id|pctl
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ctl.command
)paren
(brace
r_case
id|PSCHED_TC_INIT
suffix:colon
id|err
op_assign
id|tc_init
c_func
(paren
id|pctl
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PSCHED_TC_DESTROY
suffix:colon
id|err
op_assign
id|tc_destroy
c_func
(paren
id|pctl
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PSCHED_TC_ATTACH
suffix:colon
id|err
op_assign
id|tc_attach
c_func
(paren
id|pctl
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PSCHED_TC_DETACH
suffix:colon
id|err
op_assign
id|tc_detach
c_func
(paren
id|pctl
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pctl
op_ne
op_amp
id|ctl
)paren
id|kfree
c_func
(paren
id|pctl
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
id|pktsched_init
c_func
(paren
r_void
)paren
)paren
(brace
DECL|macro|INIT_QDISC
mdefine_line|#define INIT_QDISC(name) { &bslash;&n;          extern struct Qdisc_ops name##_ops; &bslash;&n;          register_qdisc(&amp;##name##_ops); &bslash;&n;&t;}
id|register_qdisc
c_func
(paren
op_amp
id|pfifo_fast_ops
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_SCH_CBQ
id|INIT_QDISC
c_func
(paren
id|cbq
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_CSZ
id|INIT_QDISC
c_func
(paren
id|csz
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_RED
id|INIT_QDISC
c_func
(paren
id|red
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_SFQ
id|INIT_QDISC
c_func
(paren
id|sfq
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_TBF
id|INIT_QDISC
c_func
(paren
id|tbf
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_PFIFO
id|INIT_QDISC
c_func
(paren
id|pfifo
)paren
suffix:semicolon
id|INIT_QDISC
c_func
(paren
id|bfifo
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCH_PRIO
id|INIT_QDISC
c_func
(paren
id|prio
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
eof
