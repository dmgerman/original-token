multiline_comment|/* net/sched/sch_atm.c - ATM VC selection &quot;queueing discipline&quot; */
multiline_comment|/* Written 1998-2000 by Werner Almesberger, EPFL ICA */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/atmdev.h&gt;
macro_line|#include &lt;linux/atmclip.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/file.h&gt; /* for fput */
macro_line|#include &lt;net/pkt_sched.h&gt;
macro_line|#include &lt;net/sock.h&gt;
r_extern
r_struct
id|socket
op_star
id|sockfd_lookup
c_func
(paren
r_int
id|fd
comma
r_int
op_star
id|err
)paren
suffix:semicolon
multiline_comment|/* @@@ fix this */
DECL|macro|sockfd_put
mdefine_line|#define sockfd_put(sock) fput((sock)-&gt;file)&t;/* @@@ copied because it&squot;s&n;&t;&t;&t;&t;&t;&t;   __inline__ in socket.c */
macro_line|#if 0 /* control */
mdefine_line|#define DPRINTK(format,args...) printk(KERN_DEBUG format,##args)
macro_line|#else
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(format,args...)
macro_line|#endif
macro_line|#if 0 /* data */
mdefine_line|#define D2PRINTK(format,args...) printk(KERN_DEBUG format,##args)
macro_line|#else
DECL|macro|D2PRINTK
mdefine_line|#define D2PRINTK(format,args...)
macro_line|#endif
multiline_comment|/*&n; * The ATM queuing discipline provides a framework for invoking classifiers&n; * (aka &quot;filters&quot;), which in turn select classes of this queuing discipline.&n; * Each class maps the flow(s) it is handling to a given VC. Multiple classes&n; * may share the same VC.&n; *&n; * When creating a class, VCs are specified by passing the number of the open&n; * socket descriptor by which the calling process references the VC. The kernel&n; * keeps the VC open at least until all classes using it are removed.&n; *&n; * In this file, most functions are named atm_tc_* to avoid confusion with all&n; * the atm_* in net/atm. This naming convention differs from what&squot;s used in the&n; * rest of net/sched.&n; *&n; * Known bugs:&n; *  - sometimes messes up the IP stack&n; *  - any manipulations besides the few operations described in the README, are&n; *    untested and likely to crash the system&n; *  - should lock the flow while there is data in the queue (?)&n; */
DECL|macro|PRIV
mdefine_line|#define PRIV(sch) ((struct atm_qdisc_data *) (sch)-&gt;data)
DECL|macro|VCC2FLOW
mdefine_line|#define VCC2FLOW(vcc) ((struct atm_flow_data *) ((vcc)-&gt;user_back))
DECL|struct|atm_flow_data
r_struct
id|atm_flow_data
(brace
DECL|member|q
r_struct
id|Qdisc
op_star
id|q
suffix:semicolon
multiline_comment|/* FIFO, TBF, etc. */
DECL|member|filter_list
r_struct
id|tcf_proto
op_star
id|filter_list
suffix:semicolon
DECL|member|vcc
r_struct
id|atm_vcc
op_star
id|vcc
suffix:semicolon
multiline_comment|/* VCC; NULL if VCC is closed */
DECL|member|old_pop
r_void
(paren
op_star
id|old_pop
)paren
(paren
r_struct
id|atm_vcc
op_star
id|vcc
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
multiline_comment|/* chaining */
DECL|member|parent
r_struct
id|atm_qdisc_data
op_star
id|parent
suffix:semicolon
multiline_comment|/* parent qdisc */
DECL|member|sock
r_struct
id|socket
op_star
id|sock
suffix:semicolon
multiline_comment|/* for closing */
DECL|member|classid
id|u32
id|classid
suffix:semicolon
multiline_comment|/* x:y type ID */
DECL|member|ref
r_int
id|ref
suffix:semicolon
multiline_comment|/* reference count */
DECL|member|stats
r_struct
id|tc_stats
id|stats
suffix:semicolon
DECL|member|next
r_struct
id|atm_flow_data
op_star
id|next
suffix:semicolon
DECL|member|excess
r_struct
id|atm_flow_data
op_star
id|excess
suffix:semicolon
multiline_comment|/* flow for excess traffic;&n;&t;&t;&t;&t;&t;&t;   NULL to set CLP instead */
DECL|member|hdr_len
r_int
id|hdr_len
suffix:semicolon
DECL|member|hdr
r_int
r_char
id|hdr
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* header data; MUST BE LAST */
)brace
suffix:semicolon
DECL|struct|atm_qdisc_data
r_struct
id|atm_qdisc_data
(brace
DECL|member|link
r_struct
id|atm_flow_data
id|link
suffix:semicolon
multiline_comment|/* unclassified skbs go here */
DECL|member|flows
r_struct
id|atm_flow_data
op_star
id|flows
suffix:semicolon
multiline_comment|/* NB: &quot;link&quot; is also on this&n;&t;&t;&t;&t;&t;&t;   list */
DECL|member|task
r_struct
id|tasklet_struct
id|task
suffix:semicolon
multiline_comment|/* requeue tasklet */
)brace
suffix:semicolon
multiline_comment|/* ------------------------- Class/flow operations ------------------------- */
DECL|function|find_flow
r_static
r_int
id|find_flow
c_func
(paren
r_struct
id|atm_qdisc_data
op_star
id|qdisc
comma
r_struct
id|atm_flow_data
op_star
id|flow
)paren
(brace
r_struct
id|atm_flow_data
op_star
id|walk
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;find_flow(qdisc %p,flow %p)&bslash;n&quot;
comma
id|qdisc
comma
id|flow
)paren
suffix:semicolon
r_for
c_loop
(paren
id|walk
op_assign
id|qdisc-&gt;flows
suffix:semicolon
id|walk
suffix:semicolon
id|walk
op_assign
id|walk-&gt;next
)paren
r_if
c_cond
(paren
id|walk
op_eq
id|flow
)paren
r_return
l_int|1
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;find_flow: not found&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lookup_flow
r_static
id|__inline__
r_struct
id|atm_flow_data
op_star
id|lookup_flow
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
id|u32
id|classid
)paren
(brace
r_struct
id|atm_flow_data
op_star
id|flow
suffix:semicolon
r_for
c_loop
(paren
id|flow
op_assign
id|PRIV
c_func
(paren
id|sch
)paren
op_member_access_from_pointer
id|flows
suffix:semicolon
id|flow
suffix:semicolon
id|flow
op_assign
id|flow-&gt;next
)paren
r_if
c_cond
(paren
id|flow-&gt;classid
op_eq
id|classid
)paren
r_break
suffix:semicolon
r_return
id|flow
suffix:semicolon
)brace
DECL|function|atm_tc_graft
r_static
r_int
id|atm_tc_graft
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
comma
r_struct
id|Qdisc
op_star
r_new
comma
r_struct
id|Qdisc
op_star
op_star
id|old
)paren
(brace
r_struct
id|atm_qdisc_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|sch
)paren
suffix:semicolon
r_struct
id|atm_flow_data
op_star
id|flow
op_assign
(paren
r_struct
id|atm_flow_data
op_star
)paren
id|arg
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_graft(sch %p,[qdisc %p],flow %p,new %p,old %p)&bslash;n&quot;
comma
id|sch
comma
id|p
comma
id|flow
comma
r_new
comma
id|old
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|find_flow
c_func
(paren
id|p
comma
id|flow
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_new
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
op_star
id|old
op_assign
id|xchg
c_func
(paren
op_amp
id|flow-&gt;q
comma
r_new
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|old
)paren
id|qdisc_reset
c_func
(paren
op_star
id|old
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|atm_tc_leaf
r_static
r_struct
id|Qdisc
op_star
id|atm_tc_leaf
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|cl
)paren
(brace
r_struct
id|atm_flow_data
op_star
id|flow
op_assign
(paren
r_struct
id|atm_flow_data
op_star
)paren
id|cl
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_leaf(sch %p,flow %p)&bslash;n&quot;
comma
id|sch
comma
id|flow
)paren
suffix:semicolon
r_return
id|flow
ques
c_cond
id|flow-&gt;q
suffix:colon
l_int|NULL
suffix:semicolon
)brace
DECL|function|atm_tc_get
r_static
r_int
r_int
id|atm_tc_get
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
id|u32
id|classid
)paren
(brace
r_struct
id|atm_qdisc_data
op_star
id|p
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
op_assign
id|PRIV
c_func
(paren
id|sch
)paren
suffix:semicolon
r_struct
id|atm_flow_data
op_star
id|flow
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_get(sch %p,[qdisc %p],classid %x)&bslash;n&quot;
comma
id|sch
comma
id|p
comma
id|classid
)paren
suffix:semicolon
id|flow
op_assign
id|lookup_flow
c_func
(paren
id|sch
comma
id|classid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flow
)paren
id|flow-&gt;ref
op_increment
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_get: flow %p&bslash;n&quot;
comma
id|flow
)paren
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|flow
suffix:semicolon
)brace
DECL|function|atm_tc_bind_filter
r_static
r_int
r_int
id|atm_tc_bind_filter
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|parent
comma
id|u32
id|classid
)paren
(brace
r_return
id|atm_tc_get
c_func
(paren
id|sch
comma
id|classid
)paren
suffix:semicolon
)brace
DECL|function|destroy_filters
r_static
r_void
id|destroy_filters
c_func
(paren
r_struct
id|atm_flow_data
op_star
id|flow
)paren
(brace
r_struct
id|tcf_proto
op_star
id|filter
suffix:semicolon
r_while
c_loop
(paren
(paren
id|filter
op_assign
id|flow-&gt;filter_list
)paren
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;destroy_filters: destroying filter %p&bslash;n&quot;
comma
id|filter
)paren
suffix:semicolon
id|flow-&gt;filter_list
op_assign
id|filter-&gt;next
suffix:semicolon
id|filter-&gt;ops
op_member_access_from_pointer
id|destroy
c_func
(paren
id|filter
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * atm_tc_put handles all destructions, including the ones that are explicitly&n; * requested (atm_tc_destroy, etc.). The assumption here is that we never drop&n; * anything that still seems to be in use.&n; */
DECL|function|atm_tc_put
r_static
r_void
id|atm_tc_put
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|cl
)paren
(brace
r_struct
id|atm_qdisc_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|sch
)paren
suffix:semicolon
r_struct
id|atm_flow_data
op_star
id|flow
op_assign
(paren
r_struct
id|atm_flow_data
op_star
)paren
id|cl
suffix:semicolon
r_struct
id|atm_flow_data
op_star
op_star
id|prev
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_put(sch %p,[qdisc %p],flow %p)&bslash;n&quot;
comma
id|sch
comma
id|p
comma
id|flow
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|flow-&gt;ref
)paren
r_return
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_put: destroying&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|prev
op_assign
op_amp
id|p-&gt;flows
suffix:semicolon
op_star
id|prev
suffix:semicolon
id|prev
op_assign
op_amp
(paren
op_star
id|prev
)paren
op_member_access_from_pointer
id|next
)paren
r_if
c_cond
(paren
op_star
id|prev
op_eq
id|flow
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|prev
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;atm_tc_put: class %p not found&bslash;n&quot;
comma
id|flow
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
op_star
id|prev
op_assign
id|flow-&gt;next
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_put: qdisc %p&bslash;n&quot;
comma
id|flow-&gt;q
)paren
suffix:semicolon
id|qdisc_destroy
c_func
(paren
id|flow-&gt;q
)paren
suffix:semicolon
id|destroy_filters
c_func
(paren
id|flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flow-&gt;sock
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_put: f_count %d&bslash;n&quot;
comma
id|file_count
c_func
(paren
id|flow-&gt;sock-&gt;file
)paren
)paren
suffix:semicolon
id|flow-&gt;vcc-&gt;pop
op_assign
id|flow-&gt;old_pop
suffix:semicolon
id|sockfd_put
c_func
(paren
id|flow-&gt;sock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flow-&gt;excess
)paren
id|atm_tc_put
c_func
(paren
id|sch
comma
(paren
r_int
r_int
)paren
id|flow-&gt;excess
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flow
op_ne
op_amp
id|p-&gt;link
)paren
id|kfree
c_func
(paren
id|flow
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If flow == &amp;p-&gt;link, the qdisc no longer works at this point and&n;&t; * needs to be removed. (By the caller of atm_tc_put.)&n;&t; */
)brace
DECL|function|sch_atm_pop
r_static
r_void
id|sch_atm_pop
c_func
(paren
r_struct
id|atm_vcc
op_star
id|vcc
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|atm_qdisc_data
op_star
id|p
op_assign
id|VCC2FLOW
c_func
(paren
id|vcc
)paren
op_member_access_from_pointer
id|parent
suffix:semicolon
id|D2PRINTK
c_func
(paren
l_string|&quot;sch_atm_pop(vcc %p,skb %p,[qdisc %p])&bslash;n&quot;
comma
id|vcc
comma
id|skb
comma
id|p
)paren
suffix:semicolon
id|VCC2FLOW
c_func
(paren
id|vcc
)paren
op_member_access_from_pointer
id|old_pop
c_func
(paren
id|vcc
comma
id|skb
)paren
suffix:semicolon
id|tasklet_schedule
c_func
(paren
op_amp
id|p-&gt;task
)paren
suffix:semicolon
)brace
DECL|function|atm_tc_change
r_static
r_int
id|atm_tc_change
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
id|u32
id|classid
comma
id|u32
id|parent
comma
r_struct
id|rtattr
op_star
op_star
id|tca
comma
r_int
r_int
op_star
id|arg
)paren
(brace
r_struct
id|atm_qdisc_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|sch
)paren
suffix:semicolon
r_struct
id|atm_flow_data
op_star
id|flow
op_assign
(paren
r_struct
id|atm_flow_data
op_star
)paren
op_star
id|arg
suffix:semicolon
r_struct
id|atm_flow_data
op_star
id|excess
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|rtattr
op_star
id|opt
op_assign
id|tca
(braket
id|TCA_OPTIONS
op_minus
l_int|1
)braket
suffix:semicolon
r_struct
id|rtattr
op_star
id|tb
(braket
id|TCA_ATM_MAX
)braket
suffix:semicolon
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_int
id|fd
comma
id|error
comma
id|hdr_len
suffix:semicolon
r_void
op_star
id|hdr
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_change(sch %p,[qdisc %p],classid %x,parent %x,&quot;
l_string|&quot;flow %p,opt %p)&bslash;n&quot;
comma
id|sch
comma
id|p
comma
id|classid
comma
id|parent
comma
id|flow
comma
id|opt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The concept of parents doesn&squot;t apply for this qdisc.&n;&t; */
r_if
c_cond
(paren
id|parent
op_logical_and
id|parent
op_ne
id|TC_H_ROOT
op_logical_and
id|parent
op_ne
id|sch-&gt;handle
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * ATM classes cannot be changed. In order to change properties of the&n;&t; * ATM connection, that socket needs to be modified directly (via the&n;&t; * native ATM API. In order to send a flow to a different VC, the old&n;&t; * class needs to be removed and a new one added. (This may be changed&n;&t; * later.)&n;&t; */
r_if
c_cond
(paren
id|flow
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_eq
l_int|NULL
op_logical_or
id|rtattr_parse
c_func
(paren
id|tb
comma
id|TCA_ATM_MAX
comma
id|RTA_DATA
c_func
(paren
id|opt
)paren
comma
id|RTA_PAYLOAD
c_func
(paren
id|opt
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tb
(braket
id|TCA_ATM_FD
op_minus
l_int|1
)braket
op_logical_or
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_ATM_FD
op_minus
l_int|1
)braket
)paren
OL
r_sizeof
(paren
id|fd
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|fd
op_assign
op_star
(paren
r_int
op_star
)paren
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_ATM_FD
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_change: fd %d&bslash;n&quot;
comma
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb
(braket
id|TCA_ATM_HDR
op_minus
l_int|1
)braket
)paren
(brace
id|hdr_len
op_assign
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_ATM_HDR
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|hdr
op_assign
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_ATM_HDR
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|hdr_len
op_assign
id|RFC1483LLC_LEN
suffix:semicolon
id|hdr
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* default LLC/SNAP for IP */
)brace
r_if
c_cond
(paren
op_logical_neg
id|tb
(braket
id|TCA_ATM_EXCESS
op_minus
l_int|1
)braket
)paren
id|excess
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|RTA_PAYLOAD
c_func
(paren
id|tb
(braket
id|TCA_ATM_EXCESS
op_minus
l_int|1
)braket
)paren
op_ne
r_sizeof
(paren
id|u32
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|excess
op_assign
(paren
r_struct
id|atm_flow_data
op_star
)paren
id|atm_tc_get
c_func
(paren
id|sch
comma
op_star
(paren
id|u32
op_star
)paren
id|RTA_DATA
c_func
(paren
id|tb
(braket
id|TCA_ATM_EXCESS
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|excess
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_change: type %d, payload %d, hdr_len %d&bslash;n&quot;
comma
id|opt-&gt;rta_type
comma
id|RTA_PAYLOAD
c_func
(paren
id|opt
)paren
comma
id|hdr_len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sock
op_assign
id|sockfd_lookup
c_func
(paren
id|fd
comma
op_amp
id|error
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* f_count++ */
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_change: f_count %d&bslash;n&quot;
comma
id|file_count
c_func
(paren
id|sock-&gt;file
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sock-&gt;ops-&gt;family
op_ne
id|PF_ATMSVC
op_logical_and
id|sock-&gt;ops-&gt;family
op_ne
id|PF_ATMPVC
)paren
(brace
id|error
op_assign
op_minus
id|EPROTOTYPE
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* @@@ should check if the socket is really operational or we&squot;ll crash&n;&t;   on vcc-&gt;send */
r_if
c_cond
(paren
id|classid
)paren
(brace
r_if
c_cond
(paren
id|TC_H_MAJ
c_func
(paren
id|classid
op_xor
id|sch-&gt;handle
)paren
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_change: classid mismatch&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|find_flow
c_func
(paren
id|p
comma
id|flow
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|cl
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|0x8000
suffix:semicolon
id|i
op_increment
)paren
(brace
id|classid
op_assign
id|TC_H_MAKE
c_func
(paren
id|sch-&gt;handle
comma
l_int|0x8000
op_or
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cl
op_assign
id|atm_tc_get
c_func
(paren
id|sch
comma
id|classid
)paren
)paren
)paren
r_break
suffix:semicolon
id|atm_tc_put
c_func
(paren
id|sch
comma
id|cl
)paren
suffix:semicolon
)brace
)brace
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_change: new id %x&bslash;n&quot;
comma
id|classid
)paren
suffix:semicolon
id|flow
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|atm_flow_data
)paren
op_plus
id|hdr_len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_change: flow %p&bslash;n&quot;
comma
id|flow
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flow
)paren
(brace
id|error
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|memset
c_func
(paren
id|flow
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|flow
)paren
)paren
suffix:semicolon
id|flow-&gt;filter_list
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flow-&gt;q
op_assign
id|qdisc_create_dflt
c_func
(paren
id|sch-&gt;dev
comma
op_amp
id|pfifo_qdisc_ops
)paren
)paren
)paren
id|flow-&gt;q
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_change: qdisc %p&bslash;n&quot;
comma
id|flow-&gt;q
)paren
suffix:semicolon
id|flow-&gt;sock
op_assign
id|sock
suffix:semicolon
id|flow-&gt;vcc
op_assign
id|ATM_SD
c_func
(paren
id|sock
)paren
suffix:semicolon
multiline_comment|/* speedup */
id|flow-&gt;vcc-&gt;user_back
op_assign
id|flow
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_change: vcc %p&bslash;n&quot;
comma
id|flow-&gt;vcc
)paren
suffix:semicolon
id|flow-&gt;old_pop
op_assign
id|flow-&gt;vcc-&gt;pop
suffix:semicolon
id|flow-&gt;parent
op_assign
id|p
suffix:semicolon
id|flow-&gt;vcc-&gt;pop
op_assign
id|sch_atm_pop
suffix:semicolon
id|flow-&gt;classid
op_assign
id|classid
suffix:semicolon
id|flow-&gt;ref
op_assign
l_int|1
suffix:semicolon
id|flow-&gt;excess
op_assign
id|excess
suffix:semicolon
id|flow-&gt;next
op_assign
id|p-&gt;link.next
suffix:semicolon
id|p-&gt;link.next
op_assign
id|flow
suffix:semicolon
id|flow-&gt;hdr_len
op_assign
id|hdr_len
suffix:semicolon
r_if
c_cond
(paren
id|hdr
)paren
id|memcpy
c_func
(paren
id|flow-&gt;hdr
comma
id|hdr
comma
id|hdr_len
)paren
suffix:semicolon
r_else
(brace
id|memcpy
c_func
(paren
id|flow-&gt;hdr
comma
id|llc_oui
comma
r_sizeof
(paren
id|llc_oui
)paren
)paren
suffix:semicolon
(paren
(paren
id|u16
op_star
)paren
id|flow-&gt;hdr
)paren
(braket
l_int|3
)braket
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
)brace
op_star
id|arg
op_assign
(paren
r_int
r_int
)paren
id|flow
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
r_if
c_cond
(paren
id|excess
)paren
id|atm_tc_put
c_func
(paren
id|sch
comma
(paren
r_int
r_int
)paren
id|excess
)paren
suffix:semicolon
id|sockfd_put
c_func
(paren
id|sock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|atm_tc_delete
r_static
r_int
id|atm_tc_delete
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|atm_qdisc_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|sch
)paren
suffix:semicolon
r_struct
id|atm_flow_data
op_star
id|flow
op_assign
(paren
r_struct
id|atm_flow_data
op_star
)paren
id|arg
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_delete(sch %p,[qdisc %p],flow %p)&bslash;n&quot;
comma
id|sch
comma
id|p
comma
id|flow
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|find_flow
c_func
(paren
id|PRIV
c_func
(paren
id|sch
)paren
comma
id|flow
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|flow-&gt;filter_list
op_logical_or
id|flow
op_eq
op_amp
id|p-&gt;link
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/*&n;&t; * Reference count must be 2: one for &quot;keepalive&quot; (set at class&n;&t; * creation), and one for the reference held when calling delete.&n;&t; */
r_if
c_cond
(paren
id|flow-&gt;ref
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;atm_tc_delete: flow-&gt;ref == %d&bslash;n&quot;
comma
id|flow-&gt;ref
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flow-&gt;ref
OG
l_int|2
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* catch references via excess, etc.*/
id|atm_tc_put
c_func
(paren
id|sch
comma
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|atm_tc_walk
r_static
r_void
id|atm_tc_walk
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|qdisc_walker
op_star
id|walker
)paren
(brace
r_struct
id|atm_qdisc_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|sch
)paren
suffix:semicolon
r_struct
id|atm_flow_data
op_star
id|flow
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_walk(sch %p,[qdisc %p],walker %p)&bslash;n&quot;
comma
id|sch
comma
id|p
comma
id|walker
)paren
suffix:semicolon
r_if
c_cond
(paren
id|walker-&gt;stop
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|flow
op_assign
id|p-&gt;flows
suffix:semicolon
id|flow
suffix:semicolon
id|flow
op_assign
id|flow-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|walker-&gt;count
op_ge
id|walker-&gt;skip
)paren
r_if
c_cond
(paren
id|walker
op_member_access_from_pointer
id|fn
c_func
(paren
id|sch
comma
(paren
r_int
r_int
)paren
id|flow
comma
id|walker
)paren
OL
l_int|0
)paren
(brace
id|walker-&gt;stop
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|walker-&gt;count
op_increment
suffix:semicolon
)brace
)brace
DECL|function|atm_tc_find_tcf
r_static
r_struct
id|tcf_proto
op_star
op_star
id|atm_tc_find_tcf
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|cl
)paren
(brace
r_struct
id|atm_qdisc_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|sch
)paren
suffix:semicolon
r_struct
id|atm_flow_data
op_star
id|flow
op_assign
(paren
r_struct
id|atm_flow_data
op_star
)paren
id|cl
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_find_tcf(sch %p,[qdisc %p],flow %p)&bslash;n&quot;
comma
id|sch
comma
id|p
comma
id|flow
)paren
suffix:semicolon
r_return
id|flow
ques
c_cond
op_amp
id|flow-&gt;filter_list
suffix:colon
op_amp
id|p-&gt;link.filter_list
suffix:semicolon
)brace
multiline_comment|/* --------------------------- Qdisc operations ---------------------------- */
DECL|function|atm_tc_enqueue
r_static
r_int
id|atm_tc_enqueue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|atm_qdisc_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|sch
)paren
suffix:semicolon
r_struct
id|atm_flow_data
op_star
id|flow
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* @@@ */
r_struct
id|tcf_result
id|res
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|ret
op_assign
id|NET_XMIT_POLICED
suffix:semicolon
id|D2PRINTK
c_func
(paren
l_string|&quot;atm_tc_enqueue(skb %p,sch %p,[qdisc %p])&bslash;n&quot;
comma
id|skb
comma
id|sch
comma
id|p
)paren
suffix:semicolon
id|result
op_assign
id|TC_POLICE_OK
suffix:semicolon
multiline_comment|/* be nice to gcc */
r_if
c_cond
(paren
id|TC_H_MAJ
c_func
(paren
id|skb-&gt;priority
)paren
op_ne
id|sch-&gt;handle
op_logical_or
op_logical_neg
(paren
id|flow
op_assign
(paren
r_struct
id|atm_flow_data
op_star
)paren
id|atm_tc_get
c_func
(paren
id|sch
comma
id|skb-&gt;priority
)paren
)paren
)paren
r_for
c_loop
(paren
id|flow
op_assign
id|p-&gt;flows
suffix:semicolon
id|flow
suffix:semicolon
id|flow
op_assign
id|flow-&gt;next
)paren
r_if
c_cond
(paren
id|flow-&gt;filter_list
)paren
(brace
id|result
op_assign
id|tc_classify
c_func
(paren
id|skb
comma
id|flow-&gt;filter_list
comma
op_amp
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_continue
suffix:semicolon
id|flow
op_assign
(paren
r_struct
id|atm_flow_data
op_star
)paren
id|res
dot
r_class
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flow
)paren
id|flow
op_assign
id|lookup_flow
c_func
(paren
id|sch
comma
id|res.classid
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|flow
)paren
id|flow
op_assign
op_amp
id|p-&gt;link
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|flow-&gt;vcc
)paren
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|atm_options
op_assign
id|flow-&gt;vcc-&gt;atm_options
suffix:semicolon
multiline_comment|/*@@@ looks good ... but it&squot;s not supposed to work :-)*/
macro_line|#ifdef CONFIG_NET_CLS_POLICE
r_switch
c_cond
(paren
id|result
)paren
(brace
r_case
id|TC_POLICE_SHOT
suffix:colon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TC_POLICE_RECLASSIFY
suffix:colon
r_if
c_cond
(paren
id|flow-&gt;excess
)paren
id|flow
op_assign
id|flow-&gt;excess
suffix:semicolon
r_else
(brace
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|atm_options
op_or_assign
id|ATM_ATMOPT_CLP
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* fall through */
r_case
id|TC_POLICE_OK
suffix:colon
multiline_comment|/* fall through */
r_default
suffix:colon
r_break
suffix:semicolon
)brace
macro_line|#endif
)brace
r_if
c_cond
(paren
macro_line|#ifdef CONFIG_NET_CLS_POLICE
id|result
op_eq
id|TC_POLICE_SHOT
op_logical_or
macro_line|#endif
(paren
id|ret
op_assign
id|flow-&gt;q
op_member_access_from_pointer
id|enqueue
c_func
(paren
id|skb
comma
id|flow-&gt;q
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|sch-&gt;stats.drops
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|flow
)paren
id|flow-&gt;stats.drops
op_increment
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|sch-&gt;stats.bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|sch-&gt;stats.packets
op_increment
suffix:semicolon
id|flow-&gt;stats.bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|flow-&gt;stats.packets
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Okay, this may seem weird. We pretend we&squot;ve dropped the packet if&n;&t; * it goes via ATM. The reason for this is that the outer qdisc&n;&t; * expects to be able to q-&gt;dequeue the packet later on if we return&n;&t; * success at this place. Also, sch-&gt;q.qdisc needs to reflect whether&n;&t; * there is a packet egligible for dequeuing or not. Note that the&n;&t; * statistics of the outer qdisc are necessarily wrong because of all&n;&t; * this. There&squot;s currently no correct solution for this.&n;&t; */
r_if
c_cond
(paren
id|flow
op_eq
op_amp
id|p-&gt;link
)paren
(brace
id|sch-&gt;q.qlen
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|tasklet_schedule
c_func
(paren
op_amp
id|p-&gt;task
)paren
suffix:semicolon
r_return
id|NET_XMIT_BYPASS
suffix:semicolon
)brace
multiline_comment|/*&n; * Dequeue packets and send them over ATM. Note that we quite deliberately&n; * avoid checking net_device&squot;s flow control here, simply because sch_atm&n; * uses its own channels, which have nothing to do with any CLIP/LANE/or&n; * non-ATM interfaces.&n; */
DECL|function|sch_atm_dequeue
r_static
r_void
id|sch_atm_dequeue
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|Qdisc
op_star
id|sch
op_assign
(paren
r_struct
id|Qdisc
op_star
)paren
id|data
suffix:semicolon
r_struct
id|atm_qdisc_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|sch
)paren
suffix:semicolon
r_struct
id|atm_flow_data
op_star
id|flow
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|D2PRINTK
c_func
(paren
l_string|&quot;sch_atm_dequeue(sch %p,[qdisc %p])&bslash;n&quot;
comma
id|sch
comma
id|p
)paren
suffix:semicolon
r_for
c_loop
(paren
id|flow
op_assign
id|p-&gt;link.next
suffix:semicolon
id|flow
suffix:semicolon
id|flow
op_assign
id|flow-&gt;next
)paren
multiline_comment|/*&n;&t;&t; * If traffic is properly shaped, this won&squot;t generate nasty&n;&t;&t; * little bursts. Otherwise, it may ... (but that&squot;s okay)&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|flow-&gt;q
op_member_access_from_pointer
id|dequeue
c_func
(paren
id|flow-&gt;q
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|atm_may_send
c_func
(paren
id|flow-&gt;vcc
comma
id|skb-&gt;truesize
)paren
)paren
(brace
(paren
r_void
)paren
id|flow-&gt;q-&gt;ops
op_member_access_from_pointer
id|requeue
c_func
(paren
id|skb
comma
id|flow-&gt;q
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|D2PRINTK
c_func
(paren
l_string|&quot;atm_tc_deqeueue: sending on class %p&bslash;n&quot;
comma
id|flow
)paren
suffix:semicolon
multiline_comment|/* remove any LL header somebody else has attached */
id|skb_pull
c_func
(paren
id|skb
comma
(paren
r_char
op_star
)paren
id|skb-&gt;nh.iph
op_minus
(paren
r_char
op_star
)paren
id|skb-&gt;data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
OL
id|flow-&gt;hdr_len
)paren
(brace
r_struct
id|sk_buff
op_star
r_new
suffix:semicolon
r_new
op_assign
id|skb_realloc_headroom
c_func
(paren
id|skb
comma
id|flow-&gt;hdr_len
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_continue
suffix:semicolon
id|skb
op_assign
r_new
suffix:semicolon
)brace
id|D2PRINTK
c_func
(paren
l_string|&quot;sch_atm_dequeue: ip %p, data %p&bslash;n&quot;
comma
id|skb-&gt;nh.iph
comma
id|skb-&gt;data
)paren
suffix:semicolon
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc
op_assign
id|flow-&gt;vcc
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_push
c_func
(paren
id|skb
comma
id|flow-&gt;hdr_len
)paren
comma
id|flow-&gt;hdr
comma
id|flow-&gt;hdr_len
)paren
suffix:semicolon
id|atomic_add
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|flow-&gt;vcc-&gt;tx_inuse
)paren
suffix:semicolon
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|iovcnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* atm.atm_options are already set by atm_tc_enqueue */
(paren
r_void
)paren
id|flow-&gt;vcc
op_member_access_from_pointer
id|send
c_func
(paren
id|flow-&gt;vcc
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
DECL|function|atm_tc_dequeue
r_static
r_struct
id|sk_buff
op_star
id|atm_tc_dequeue
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|atm_qdisc_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|sch
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|D2PRINTK
c_func
(paren
l_string|&quot;atm_tc_dequeue(sch %p,[qdisc %p])&bslash;n&quot;
comma
id|sch
comma
id|p
)paren
suffix:semicolon
id|tasklet_schedule
c_func
(paren
op_amp
id|p-&gt;task
)paren
suffix:semicolon
id|skb
op_assign
id|p-&gt;link.q
op_member_access_from_pointer
id|dequeue
c_func
(paren
id|p-&gt;link.q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|sch-&gt;q.qlen
op_decrement
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
DECL|function|atm_tc_requeue
r_static
r_int
id|atm_tc_requeue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|atm_qdisc_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|sch
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|D2PRINTK
c_func
(paren
l_string|&quot;atm_tc_requeue(skb %p,sch %p,[qdisc %p])&bslash;n&quot;
comma
id|skb
comma
id|sch
comma
id|p
)paren
suffix:semicolon
id|ret
op_assign
id|p-&gt;link.q-&gt;ops
op_member_access_from_pointer
id|requeue
c_func
(paren
id|skb
comma
id|p-&gt;link.q
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|sch-&gt;q.qlen
op_increment
suffix:semicolon
r_else
(brace
id|sch-&gt;stats.drops
op_increment
suffix:semicolon
id|p-&gt;link.stats.drops
op_increment
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|atm_tc_drop
r_static
r_int
id|atm_tc_drop
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|atm_qdisc_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|sch
)paren
suffix:semicolon
r_struct
id|atm_flow_data
op_star
id|flow
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_drop(sch %p,[qdisc %p])&bslash;n&quot;
comma
id|sch
comma
id|p
)paren
suffix:semicolon
r_for
c_loop
(paren
id|flow
op_assign
id|p-&gt;flows
suffix:semicolon
id|flow
suffix:semicolon
id|flow
op_assign
id|flow-&gt;next
)paren
r_if
c_cond
(paren
id|flow-&gt;q-&gt;ops-&gt;drop
op_logical_and
id|flow-&gt;q-&gt;ops
op_member_access_from_pointer
id|drop
c_func
(paren
id|flow-&gt;q
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|atm_tc_init
r_static
r_int
id|atm_tc_init
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|rtattr
op_star
id|opt
)paren
(brace
r_struct
id|atm_qdisc_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|sch
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_init(sch %p,[qdisc %p],opt %p)&bslash;n&quot;
comma
id|sch
comma
id|p
comma
id|opt
)paren
suffix:semicolon
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
id|p-&gt;flows
op_assign
op_amp
id|p-&gt;link
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;link.q
op_assign
id|qdisc_create_dflt
c_func
(paren
id|sch-&gt;dev
comma
op_amp
id|pfifo_qdisc_ops
)paren
)paren
)paren
(brace
id|p-&gt;link.q
op_assign
op_amp
id|noop_qdisc
suffix:semicolon
)brace
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_init: link (%p) qdisc %p&bslash;n&quot;
comma
op_amp
id|p-&gt;link
comma
id|p-&gt;link.q
)paren
suffix:semicolon
id|p-&gt;link.filter_list
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;link.vcc
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;link.sock
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;link.classid
op_assign
id|sch-&gt;handle
suffix:semicolon
id|p-&gt;link.ref
op_assign
l_int|1
suffix:semicolon
id|p-&gt;link.next
op_assign
l_int|NULL
suffix:semicolon
id|tasklet_init
c_func
(paren
op_amp
id|p-&gt;task
comma
id|sch_atm_dequeue
comma
(paren
r_int
r_int
)paren
id|sch
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|atm_tc_reset
r_static
r_void
id|atm_tc_reset
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|atm_qdisc_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|sch
)paren
suffix:semicolon
r_struct
id|atm_flow_data
op_star
id|flow
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_reset(sch %p,[qdisc %p])&bslash;n&quot;
comma
id|sch
comma
id|p
)paren
suffix:semicolon
r_for
c_loop
(paren
id|flow
op_assign
id|p-&gt;flows
suffix:semicolon
id|flow
suffix:semicolon
id|flow
op_assign
id|flow-&gt;next
)paren
id|qdisc_reset
c_func
(paren
id|flow-&gt;q
)paren
suffix:semicolon
id|sch-&gt;q.qlen
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|atm_tc_destroy
r_static
r_void
id|atm_tc_destroy
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
)paren
(brace
r_struct
id|atm_qdisc_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|sch
)paren
suffix:semicolon
r_struct
id|atm_flow_data
op_star
id|flow
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_destroy(sch %p,[qdisc %p])&bslash;n&quot;
comma
id|sch
comma
id|p
)paren
suffix:semicolon
multiline_comment|/* races ? */
r_while
c_loop
(paren
(paren
id|flow
op_assign
id|p-&gt;flows
)paren
)paren
(brace
id|destroy_filters
c_func
(paren
id|flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flow-&gt;ref
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;atm_destroy: %p-&gt;ref = %d&bslash;n&quot;
comma
id|flow
comma
id|flow-&gt;ref
)paren
suffix:semicolon
id|atm_tc_put
c_func
(paren
id|sch
comma
(paren
r_int
r_int
)paren
id|flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;flows
op_eq
id|flow
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;atm_destroy: putting flow %p didn&squot;t &quot;
l_string|&quot;kill it&bslash;n&quot;
comma
id|flow
)paren
suffix:semicolon
id|p-&gt;flows
op_assign
id|flow-&gt;next
suffix:semicolon
multiline_comment|/* brute force */
r_break
suffix:semicolon
)brace
)brace
id|tasklet_kill
c_func
(paren
op_amp
id|p-&gt;task
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_RTNETLINK
DECL|function|atm_tc_dump_class
r_static
r_int
id|atm_tc_dump_class
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_int
r_int
id|cl
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcmsg
op_star
id|tcm
)paren
(brace
r_struct
id|atm_qdisc_data
op_star
id|p
op_assign
id|PRIV
c_func
(paren
id|sch
)paren
suffix:semicolon
r_struct
id|atm_flow_data
op_star
id|flow
op_assign
(paren
r_struct
id|atm_flow_data
op_star
)paren
id|cl
suffix:semicolon
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
r_struct
id|rtattr
op_star
id|rta
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atm_tc_dump_class(sch %p,[qdisc %p],flow %p,skb %p,tcm %p)&bslash;n&quot;
comma
id|sch
comma
id|p
comma
id|flow
comma
id|skb
comma
id|tcm
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|find_flow
c_func
(paren
id|p
comma
id|flow
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|tcm-&gt;tcm_handle
op_assign
id|flow-&gt;classid
suffix:semicolon
id|rta
op_assign
(paren
r_struct
id|rtattr
op_star
)paren
id|b
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_OPTIONS
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_ATM_HDR
comma
id|flow-&gt;hdr_len
comma
id|flow-&gt;hdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flow-&gt;vcc
)paren
(brace
r_struct
id|sockaddr_atmpvc
id|pvc
suffix:semicolon
r_int
id|state
suffix:semicolon
id|pvc.sap_family
op_assign
id|AF_ATMPVC
suffix:semicolon
id|pvc.sap_addr.itf
op_assign
id|flow-&gt;vcc-&gt;dev
ques
c_cond
id|flow-&gt;vcc-&gt;dev-&gt;number
suffix:colon
op_minus
l_int|1
suffix:semicolon
id|pvc.sap_addr.vpi
op_assign
id|flow-&gt;vcc-&gt;vpi
suffix:semicolon
id|pvc.sap_addr.vci
op_assign
id|flow-&gt;vcc-&gt;vci
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_ATM_ADDR
comma
r_sizeof
(paren
id|pvc
)paren
comma
op_amp
id|pvc
)paren
suffix:semicolon
id|state
op_assign
id|ATM_VF2VS
c_func
(paren
id|flow-&gt;vcc-&gt;flags
)paren
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_ATM_STATE
comma
r_sizeof
(paren
id|state
)paren
comma
op_amp
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flow-&gt;excess
)paren
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_ATM_EXCESS
comma
r_sizeof
(paren
id|u32
)paren
comma
op_amp
id|flow-&gt;classid
)paren
suffix:semicolon
r_else
(brace
r_static
id|u32
id|zero
op_assign
l_int|0
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|TCA_ATM_EXCESS
comma
r_sizeof
(paren
id|zero
)paren
comma
op_amp
id|zero
)paren
suffix:semicolon
)brace
id|rta-&gt;rta_len
op_assign
id|skb-&gt;tail
op_minus
id|b
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|rtattr_failure
suffix:colon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|atm_tc_dump
r_static
r_int
id|atm_tc_dump
c_func
(paren
r_struct
id|Qdisc
op_star
id|sch
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|atm_class_ops
r_static
r_struct
id|Qdisc_class_ops
id|atm_class_ops
op_assign
(brace
id|atm_tc_graft
comma
multiline_comment|/* graft */
id|atm_tc_leaf
comma
multiline_comment|/* leaf */
id|atm_tc_get
comma
multiline_comment|/* get */
id|atm_tc_put
comma
multiline_comment|/* put */
id|atm_tc_change
comma
multiline_comment|/* change */
id|atm_tc_delete
comma
multiline_comment|/* delete */
id|atm_tc_walk
comma
multiline_comment|/* walk */
id|atm_tc_find_tcf
comma
multiline_comment|/* tcf_chain */
id|atm_tc_bind_filter
comma
multiline_comment|/* bind_tcf */
id|atm_tc_put
comma
multiline_comment|/* unbind_tcf */
macro_line|#ifdef CONFIG_RTNETLINK
id|atm_tc_dump_class
comma
multiline_comment|/* dump */
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|atm_qdisc_ops
r_struct
id|Qdisc_ops
id|atm_qdisc_ops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* next */
op_amp
id|atm_class_ops
comma
multiline_comment|/* cl_ops */
l_string|&quot;atm&quot;
comma
r_sizeof
(paren
r_struct
id|atm_qdisc_data
)paren
comma
id|atm_tc_enqueue
comma
multiline_comment|/* enqueue */
id|atm_tc_dequeue
comma
multiline_comment|/* dequeue */
id|atm_tc_requeue
comma
multiline_comment|/* requeue */
id|atm_tc_drop
comma
multiline_comment|/* drop */
id|atm_tc_init
comma
multiline_comment|/* init */
id|atm_tc_reset
comma
multiline_comment|/* reset */
id|atm_tc_destroy
comma
multiline_comment|/* destroy */
l_int|NULL
comma
multiline_comment|/* change */
macro_line|#ifdef CONFIG_RTNETLINK
id|atm_tc_dump
multiline_comment|/* dump */
macro_line|#endif
)brace
suffix:semicolon
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|register_qdisc
c_func
(paren
op_amp
id|atm_qdisc_ops
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|unregister_qdisc
c_func
(paren
op_amp
id|atm_qdisc_ops
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
