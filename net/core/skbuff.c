multiline_comment|/*&n; *&t;Routines having to do with the &squot;struct sk_buff&squot; memory handlers.&n; *&n; *&t;Authors:&t;Alan Cox &lt;iiitac@pyr.swan.ac.uk&gt;&n; *&t;&t;&t;Florian La Roche &lt;rzsfl@rz.uni-sb.de&gt;&n; *&n; *&t;Version:&t;$Id: skbuff.c,v 1.75 2000/12/08 17:15:53 davem Exp $&n; *&n; *&t;Fixes:&t;&n; *&t;&t;Alan Cox&t;:&t;Fixed the worst of the load balancer bugs.&n; *&t;&t;Dave Platt&t;:&t;Interrupt stacking fix.&n; *&t;Richard Kooijman&t;:&t;Timestamp fixes.&n; *&t;&t;Alan Cox&t;:&t;Changed buffer format.&n; *&t;&t;Alan Cox&t;:&t;destructor hook for AF_UNIX etc.&n; *&t;&t;Linus Torvalds&t;:&t;Better skb_clone.&n; *&t;&t;Alan Cox&t;:&t;Added skb_copy.&n; *&t;&t;Alan Cox&t;:&t;Added all the changed routines Linus&n; *&t;&t;&t;&t;&t;only put in the headers&n; *&t;&t;Ray VanTassle&t;:&t;Fixed --skb-&gt;lock in free&n; *&t;&t;Alan Cox&t;:&t;skb_copy copy arp field&n; *&t;&t;Andi Kleen&t;:&t;slabified it.&n; *&n; *&t;NOTE:&n; *&t;&t;The __skb_ routines should be called with interrupts &n; *&t;disabled, or you better be *real* sure that the operation is atomic &n; *&t;with respect to whatever list is being frobbed (e.g. via lock_sock()&n; *&t;or via disabling bottom half handlers, etc).&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License&n; *&t;as published by the Free Software Foundation; either version&n; *&t;2 of the License, or (at your option) any later version.&n; */
multiline_comment|/*&n; *&t;The functions in this file will not compile correctly with gcc 2.4.x&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/cache.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/dst.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
DECL|variable|sysctl_hot_list_len
r_int
id|sysctl_hot_list_len
op_assign
l_int|128
suffix:semicolon
DECL|variable|skbuff_head_cache
r_static
id|kmem_cache_t
op_star
id|skbuff_head_cache
suffix:semicolon
r_static
r_union
(brace
DECL|member|list
r_struct
id|sk_buff_head
id|list
suffix:semicolon
DECL|member|pad
r_char
id|pad
(braket
id|SMP_CACHE_BYTES
)braket
suffix:semicolon
DECL|variable|skb_head_pool
)brace
id|skb_head_pool
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/*&n; *&t;Keep out-of-line to prevent kernel bloat.&n; *&t;__builtin_return_address is not used because it is not always&n; *&t;reliable. &n; */
multiline_comment|/**&n; *&t;skb_over_panic&t;- &t;private function&n; *&t;@skb: buffer&n; *&t;@sz: size&n; *&t;@here: address&n; *&n; *&t;Out of line support code for skb_put(). Not user callable.&n; */
DECL|function|skb_over_panic
r_void
id|skb_over_panic
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|sz
comma
r_void
op_star
id|here
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;skput:over: %p:%d put:%d dev:%s&quot;
comma
id|here
comma
id|skb-&gt;len
comma
id|sz
comma
id|skb-&gt;dev
ques
c_cond
id|skb-&gt;dev-&gt;name
suffix:colon
l_string|&quot;&lt;NULL&gt;&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_under_panic&t;- &t;private function&n; *&t;@skb: buffer&n; *&t;@sz: size&n; *&t;@here: address&n; *&n; *&t;Out of line support code for skb_push(). Not user callable.&n; */
DECL|function|skb_under_panic
r_void
id|skb_under_panic
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|sz
comma
r_void
op_star
id|here
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;skput:under: %p:%d put:%d dev:%s&quot;
comma
id|here
comma
id|skb-&gt;len
comma
id|sz
comma
id|skb-&gt;dev
ques
c_cond
id|skb-&gt;dev-&gt;name
suffix:colon
l_string|&quot;&lt;NULL&gt;&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|skb_head_from_pool
r_static
id|__inline__
r_struct
id|sk_buff
op_star
id|skb_head_from_pool
c_func
(paren
r_void
)paren
(brace
r_struct
id|sk_buff_head
op_star
id|list
op_assign
op_amp
id|skb_head_pool
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|list
suffix:semicolon
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
id|list
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
id|list
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|skb_head_to_pool
r_static
id|__inline__
r_void
id|skb_head_to_pool
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sk_buff_head
op_star
id|list
op_assign
op_amp
id|skb_head_pool
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|list
suffix:semicolon
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
id|list
)paren
OL
id|sysctl_hot_list_len
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__skb_queue_head
c_func
(paren
id|list
comma
id|skb
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|kmem_cache_free
c_func
(paren
id|skbuff_head_cache
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* &t;Allocate a new skbuff. We do this ourselves so we can fill in a few&n; *&t;&squot;private&squot; fields and also do memory statistics to find all the&n; *&t;[BEEP] leaks.&n; * &n; */
multiline_comment|/**&n; *&t;alloc_skb&t;-&t;allocate a network buffer&n; *&t;@size: size to allocate&n; *&t;@gfp_mask: allocation mask&n; *&n; *&t;Allocate a new &amp;sk_buff. The returned buffer has no headroom and a&n; *&t;tail room of size bytes. The object has a reference count of one.&n; *&t;The return is the buffer. On a failure the return is %NULL.&n; *&n; *&t;Buffers may only be allocated from interrupts using a @gfp_mask of&n; *&t;%GFP_ATOMIC.&n; */
DECL|function|alloc_skb
r_struct
id|sk_buff
op_star
id|alloc_skb
c_func
(paren
r_int
r_int
id|size
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|u8
op_star
id|data
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
op_logical_and
(paren
id|gfp_mask
op_amp
id|__GFP_WAIT
)paren
)paren
(brace
r_static
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|count
OL
l_int|5
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;alloc_skb called nonatomically &quot;
l_string|&quot;from interrupt %p&bslash;n&quot;
comma
id|NET_CALLER
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|gfp_mask
op_and_assign
op_complement
id|__GFP_WAIT
suffix:semicolon
)brace
multiline_comment|/* Get the HEAD */
id|skb
op_assign
id|skb_head_from_pool
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|skb
op_assign
id|kmem_cache_alloc
c_func
(paren
id|skbuff_head_cache
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_goto
id|nohead
suffix:semicolon
)brace
multiline_comment|/* Get the DATA. Size must match skb_add_mtu(). */
id|size
op_assign
(paren
(paren
id|size
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
)paren
suffix:semicolon
id|data
op_assign
id|kmalloc
c_func
(paren
id|size
op_plus
r_sizeof
(paren
id|atomic_t
)paren
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
l_int|NULL
)paren
r_goto
id|nodata
suffix:semicolon
multiline_comment|/* XXX: does not include slab overhead */
id|skb-&gt;truesize
op_assign
id|size
op_plus
r_sizeof
(paren
r_struct
id|sk_buff
)paren
suffix:semicolon
multiline_comment|/* Load the data pointers. */
id|skb-&gt;head
op_assign
id|data
suffix:semicolon
id|skb-&gt;data
op_assign
id|data
suffix:semicolon
id|skb-&gt;tail
op_assign
id|data
suffix:semicolon
id|skb-&gt;end
op_assign
id|data
op_plus
id|size
suffix:semicolon
multiline_comment|/* Set up other state */
id|skb-&gt;len
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;cloned
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|skb-&gt;users
comma
l_int|1
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
id|skb_datarefp
c_func
(paren
id|skb
)paren
comma
l_int|1
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
id|nodata
suffix:colon
id|skb_head_to_pool
c_func
(paren
id|skb
)paren
suffix:semicolon
id|nohead
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Slab constructor for a skb head. &n; */
DECL|function|skb_headerinit
r_static
r_inline
r_void
id|skb_headerinit
c_func
(paren
r_void
op_star
id|p
comma
id|kmem_cache_t
op_star
id|cache
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|p
suffix:semicolon
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;stamp.tv_sec
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No idea about time */
id|skb-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;dst
op_assign
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|skb-&gt;cb
comma
l_int|0
comma
r_sizeof
(paren
id|skb-&gt;cb
)paren
)paren
suffix:semicolon
id|skb-&gt;pkt_type
op_assign
id|PACKET_HOST
suffix:semicolon
multiline_comment|/* Default type */
id|skb-&gt;ip_summed
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;priority
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;security
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* By default packets are insecure */
id|skb-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER
id|skb-&gt;nfmark
op_assign
id|skb-&gt;nfcache
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;nfct
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
id|skb-&gt;nf_debug
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCHED
id|skb-&gt;tc_index
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *&t;Free an skbuff by memory without cleaning the state. &n; */
DECL|function|kfree_skbmem
r_void
id|kfree_skbmem
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;cloned
op_logical_or
id|atomic_dec_and_test
c_func
(paren
id|skb_datarefp
c_func
(paren
id|skb
)paren
)paren
)paren
id|kfree
c_func
(paren
id|skb-&gt;head
)paren
suffix:semicolon
id|skb_head_to_pool
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;__kfree_skb - private function &n; *&t;@skb: buffer&n; *&n; *&t;Free an sk_buff. Release anything attached to the buffer. &n; *&t;Clean the state. This is an internal helper function. Users should&n; *&t;always call kfree_skb&n; */
DECL|function|__kfree_skb
r_void
id|__kfree_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;list
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Warning: kfree_skb passed an skb still &quot;
l_string|&quot;on a list (from %p).&bslash;n&quot;
comma
id|NET_CALLER
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|dst_release
c_func
(paren
id|skb-&gt;dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;destructor
)paren
(brace
r_if
c_cond
(paren
id|in_irq
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Warning: kfree_skb on hard IRQ %p&bslash;n&quot;
comma
id|NET_CALLER
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
)brace
id|skb
op_member_access_from_pointer
id|destructor
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NETFILTER
id|nf_conntrack_put
c_func
(paren
id|skb-&gt;nfct
)paren
suffix:semicolon
macro_line|#endif
id|skb_headerinit
c_func
(paren
id|skb
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* clean state */
id|kfree_skbmem
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_clone&t;-&t;duplicate an sk_buff&n; *&t;@skb: buffer to clone&n; *&t;@gfp_mask: allocation priority&n; *&n; *&t;Duplicate an &amp;sk_buff. The new one is not owned by a socket. Both&n; *&t;copies share the same packet data but not structure. The new&n; *&t;buffer has a reference count of 1. If the allocation fails the &n; *&t;function returns %NULL otherwise the new buffer is returned.&n; *&t;&n; *&t;If this function is called from an interrupt gfp_mask() must be&n; *&t;%GFP_ATOMIC.&n; */
DECL|function|skb_clone
r_struct
id|sk_buff
op_star
id|skb_clone
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|sk_buff
op_star
id|n
suffix:semicolon
id|n
op_assign
id|skb_head_from_pool
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
(brace
id|n
op_assign
id|kmem_cache_alloc
c_func
(paren
id|skbuff_head_cache
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|n
comma
id|skb
comma
r_sizeof
(paren
op_star
id|n
)paren
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
id|skb_datarefp
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
id|skb-&gt;cloned
op_assign
l_int|1
suffix:semicolon
id|dst_clone
c_func
(paren
id|n-&gt;dst
)paren
suffix:semicolon
id|n-&gt;cloned
op_assign
l_int|1
suffix:semicolon
id|n-&gt;next
op_assign
id|n-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|n-&gt;users
comma
l_int|1
)paren
suffix:semicolon
id|n-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER
id|nf_conntrack_get
c_func
(paren
id|skb-&gt;nfct
)paren
suffix:semicolon
macro_line|#endif
r_return
id|n
suffix:semicolon
)brace
DECL|function|copy_skb_header
r_static
r_void
id|copy_skb_header
c_func
(paren
r_struct
id|sk_buff
op_star
r_new
comma
r_const
r_struct
id|sk_buff
op_star
id|old
)paren
(brace
multiline_comment|/*&n;&t; *&t;Shift between the two data areas in bytes&n;&t; */
r_int
r_int
id|offset
op_assign
r_new
op_member_access_from_pointer
id|data
op_minus
id|old-&gt;data
suffix:semicolon
r_new
op_member_access_from_pointer
id|list
op_assign
l_int|NULL
suffix:semicolon
r_new
op_member_access_from_pointer
id|sk
op_assign
l_int|NULL
suffix:semicolon
r_new
op_member_access_from_pointer
id|dev
op_assign
id|old-&gt;dev
suffix:semicolon
r_new
op_member_access_from_pointer
id|priority
op_assign
id|old-&gt;priority
suffix:semicolon
r_new
op_member_access_from_pointer
id|protocol
op_assign
id|old-&gt;protocol
suffix:semicolon
r_new
op_member_access_from_pointer
id|dst
op_assign
id|dst_clone
c_func
(paren
id|old-&gt;dst
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|h.raw
op_assign
id|old-&gt;h.raw
op_plus
id|offset
suffix:semicolon
r_new
op_member_access_from_pointer
id|nh.raw
op_assign
id|old-&gt;nh.raw
op_plus
id|offset
suffix:semicolon
r_new
op_member_access_from_pointer
id|mac.raw
op_assign
id|old-&gt;mac.raw
op_plus
id|offset
suffix:semicolon
id|memcpy
c_func
(paren
r_new
op_member_access_from_pointer
id|cb
comma
id|old-&gt;cb
comma
r_sizeof
(paren
id|old-&gt;cb
)paren
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|used
op_assign
id|old-&gt;used
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|users
comma
l_int|1
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|pkt_type
op_assign
id|old-&gt;pkt_type
suffix:semicolon
r_new
op_member_access_from_pointer
id|stamp
op_assign
id|old-&gt;stamp
suffix:semicolon
r_new
op_member_access_from_pointer
id|destructor
op_assign
l_int|NULL
suffix:semicolon
r_new
op_member_access_from_pointer
id|security
op_assign
id|old-&gt;security
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER
r_new
op_member_access_from_pointer
id|nfmark
op_assign
id|old-&gt;nfmark
suffix:semicolon
r_new
op_member_access_from_pointer
id|nfcache
op_assign
id|old-&gt;nfcache
suffix:semicolon
r_new
op_member_access_from_pointer
id|nfct
op_assign
id|old-&gt;nfct
suffix:semicolon
id|nf_conntrack_get
c_func
(paren
r_new
op_member_access_from_pointer
id|nfct
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
r_new
op_member_access_from_pointer
id|nf_debug
op_assign
id|old-&gt;nf_debug
suffix:semicolon
macro_line|#endif
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCHED
r_new
op_member_access_from_pointer
id|tc_index
op_assign
id|old-&gt;tc_index
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/**&n; *&t;skb_copy&t;-&t;copy an sk_buff&n; *&t;@skb: buffer to copy&n; *&t;@gfp_mask: allocation priority&n; *&n; *&t;Make a copy of both an &amp;sk_buff and its data. This is used when the&n; *&t;caller wishes to modify the data and needs a private copy of the &n; *&t;data to alter. Returns %NULL on failure or the pointer to the buffer&n; *&t;on success. The returned buffer has a reference count of 1.&n; *&n; *&t;You must pass %GFP_ATOMIC as the allocation priority if this function&n; *&t;is called from an interrupt.&n; */
DECL|function|skb_copy
r_struct
id|sk_buff
op_star
id|skb_copy
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|sk_buff
op_star
id|n
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate the copy buffer&n;&t; */
id|n
op_assign
id|alloc_skb
c_func
(paren
id|skb-&gt;end
op_minus
id|skb-&gt;head
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Set the data pointer */
id|skb_reserve
c_func
(paren
id|n
comma
id|skb-&gt;data
op_minus
id|skb-&gt;head
)paren
suffix:semicolon
multiline_comment|/* Set the tail pointer and length */
id|skb_put
c_func
(paren
id|n
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Copy the bytes */
id|memcpy
c_func
(paren
id|n-&gt;head
comma
id|skb-&gt;head
comma
id|skb-&gt;end
op_minus
id|skb-&gt;head
)paren
suffix:semicolon
id|n-&gt;csum
op_assign
id|skb-&gt;csum
suffix:semicolon
id|copy_skb_header
c_func
(paren
id|n
comma
id|skb
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_copy_expand&t;-&t;copy and expand sk_buff&n; *&t;@skb: buffer to copy&n; *&t;@newheadroom: new free bytes at head&n; *&t;@newtailroom: new free bytes at tail&n; *&t;@gfp_mask: allocation priority&n; *&n; *&t;Make a copy of both an &amp;sk_buff and its data and while doing so &n; *&t;allocate additional space.&n; *&n; *&t;This is used when the caller wishes to modify the data and needs a &n; *&t;private copy of the data to alter as well as more space for new fields.&n; *&t;Returns %NULL on failure or the pointer to the buffer&n; *&t;on success. The returned buffer has a reference count of 1.&n; *&n; *&t;You must pass %GFP_ATOMIC as the allocation priority if this function&n; *&t;is called from an interrupt.&n; */
DECL|function|skb_copy_expand
r_struct
id|sk_buff
op_star
id|skb_copy_expand
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|newheadroom
comma
r_int
id|newtailroom
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|sk_buff
op_star
id|n
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate the copy buffer&n;&t; */
id|n
op_assign
id|alloc_skb
c_func
(paren
id|newheadroom
op_plus
(paren
id|skb-&gt;tail
op_minus
id|skb-&gt;data
)paren
op_plus
id|newtailroom
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|n
comma
id|newheadroom
)paren
suffix:semicolon
multiline_comment|/* Set the tail pointer and length */
id|skb_put
c_func
(paren
id|n
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Copy the data only. */
id|memcpy
c_func
(paren
id|n-&gt;data
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|copy_skb_header
c_func
(paren
id|n
comma
id|skb
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* &n; * &t;Tune the memory allocator for a new MTU size.&n; */
r_void
id|skb_add_mtu
c_func
(paren
r_int
id|mtu
)paren
(brace
multiline_comment|/* Must match allocation in alloc_skb */
id|mtu
op_assign
(paren
(paren
id|mtu
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
)paren
op_plus
r_sizeof
(paren
id|atomic_t
)paren
suffix:semicolon
id|kmem_add_cache_size
c_func
(paren
id|mtu
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|skb_init
r_void
id|__init
id|skb_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|skbuff_head_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;skbuff_head_cache&quot;
comma
r_sizeof
(paren
r_struct
id|sk_buff
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
id|skb_headerinit
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skbuff_head_cache
)paren
id|panic
c_func
(paren
l_string|&quot;cannot create skbuff cache&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|skb_queue_head_init
c_func
(paren
op_amp
id|skb_head_pool
(braket
id|i
)braket
dot
id|list
)paren
suffix:semicolon
)brace
eof
