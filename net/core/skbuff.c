multiline_comment|/*&n; *&t;Routines having to do with the &squot;struct sk_buff&squot; memory handlers.&n; *&n; *&t;Authors:&t;Alan Cox &lt;iiitac@pyr.swan.ac.uk&gt;&n; *&t;&t;&t;Florian La Roche &lt;rzsfl@rz.uni-sb.de&gt;&n; *&n; *&t;Version:&t;$Id: skbuff.c,v 1.55 1999/02/23 08:12:27 davem Exp $&n; *&n; *&t;Fixes:&t;&n; *&t;&t;Alan Cox&t;:&t;Fixed the worst of the load balancer bugs.&n; *&t;&t;Dave Platt&t;:&t;Interrupt stacking fix.&n; *&t;Richard Kooijman&t;:&t;Timestamp fixes.&n; *&t;&t;Alan Cox&t;:&t;Changed buffer format.&n; *&t;&t;Alan Cox&t;:&t;destructor hook for AF_UNIX etc.&n; *&t;&t;Linus Torvalds&t;:&t;Better skb_clone.&n; *&t;&t;Alan Cox&t;:&t;Added skb_copy.&n; *&t;&t;Alan Cox&t;:&t;Added all the changed routines Linus&n; *&t;&t;&t;&t;&t;only put in the headers&n; *&t;&t;Ray VanTassle&t;:&t;Fixed --skb-&gt;lock in free&n; *&t;&t;Alan Cox&t;:&t;skb_copy copy arp field&n; *&t;&t;Andi Kleen&t;:&t;slabified it.&n; *&n; *&t;NOTE:&n; *&t;&t;The __skb_ routines should be called with interrupts &n; *&t;disabled, or you better be *real* sure that the operation is atomic &n; *&t;with respect to whatever list is being frobbed (e.g. via lock_sock()&n; *&t;or via disabling bottom half handlers, etc).&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License&n; *&t;as published by the Free Software Foundation; either version&n; *&t;2 of the License, or (at your option) any later version.&n; */
multiline_comment|/*&n; *&t;The functions in this file will not compile correctly with gcc 2.4.x&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/dst.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
multiline_comment|/*&n; * Skb list spinlock&n; */
DECL|variable|skb_queue_lock
id|spinlock_t
id|skb_queue_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; *&t;Resource tracking variables&n; */
DECL|variable|net_skbcount
r_static
id|atomic_t
id|net_skbcount
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|net_allocs
r_static
id|atomic_t
id|net_allocs
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|net_fails
r_static
id|atomic_t
id|net_fails
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_extern
id|atomic_t
id|ip_frag_mem
suffix:semicolon
DECL|variable|skbuff_head_cache
r_static
id|kmem_cache_t
op_star
id|skbuff_head_cache
suffix:semicolon
multiline_comment|/*&n; *&t;Keep out-of-line to prevent kernel bloat.&n; *&t;__builtin_return_address is not used because it is not always&n; *&t;reliable. &n; */
DECL|function|skb_over_panic
r_void
id|skb_over_panic
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|sz
comma
r_void
op_star
id|here
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;skput:over: %p:%d put:%d dev:%s&quot;
comma
id|here
comma
id|skb-&gt;len
comma
id|sz
comma
id|skb-&gt;dev
ques
c_cond
id|skb-&gt;dev-&gt;name
suffix:colon
l_string|&quot;&lt;NULL&gt;&quot;
)paren
suffix:semicolon
)brace
DECL|function|skb_under_panic
r_void
id|skb_under_panic
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|sz
comma
r_void
op_star
id|here
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;skput:under: %p:%d put:%d dev:%s&quot;
comma
id|here
comma
id|skb-&gt;len
comma
id|sz
comma
id|skb-&gt;dev
ques
c_cond
id|skb-&gt;dev-&gt;name
suffix:colon
l_string|&quot;&lt;NULL&gt;&quot;
)paren
suffix:semicolon
)brace
DECL|function|show_net_buffers
r_void
id|show_net_buffers
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Networking buffers in use          : %u&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|net_skbcount
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Total network buffer allocations   : %u&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|net_allocs
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Total failed network buffer allocs : %u&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|net_fails
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_INET
id|printk
c_func
(paren
l_string|&quot;IP fragment buffer size            : %u&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|ip_frag_mem
)paren
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
multiline_comment|/* &t;Allocate a new skbuff. We do this ourselves so we can fill in a few&n; *&t;&squot;private&squot; fields and also do memory statistics to find all the&n; *&t;[BEEP] leaks.&n; * &n; */
DECL|function|alloc_skb
r_struct
id|sk_buff
op_star
id|alloc_skb
c_func
(paren
r_int
r_int
id|size
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|u8
op_star
id|data
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
op_logical_and
(paren
id|gfp_mask
op_amp
id|__GFP_WAIT
)paren
)paren
(brace
r_static
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|count
OL
l_int|5
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;alloc_skb called nonatomically &quot;
l_string|&quot;from interrupt %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
id|gfp_mask
op_and_assign
op_complement
id|__GFP_WAIT
suffix:semicolon
)brace
multiline_comment|/* Get the HEAD */
id|skb
op_assign
id|kmem_cache_alloc
c_func
(paren
id|skbuff_head_cache
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_goto
id|nohead
suffix:semicolon
multiline_comment|/* Get the DATA. Size must match skb_add_mtu(). */
id|size
op_assign
(paren
(paren
id|size
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
)paren
suffix:semicolon
id|data
op_assign
id|kmalloc
c_func
(paren
id|size
op_plus
r_sizeof
(paren
id|atomic_t
)paren
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
l_int|NULL
)paren
r_goto
id|nodata
suffix:semicolon
multiline_comment|/* Note that this counter is useless now - you can just look in the&n;&t; * skbuff_head entry in /proc/slabinfo. We keep it only for emergency&n;&t; * cases.&n;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|net_allocs
)paren
suffix:semicolon
id|skb-&gt;truesize
op_assign
id|size
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|net_skbcount
)paren
suffix:semicolon
multiline_comment|/* Load the data pointers. */
id|skb-&gt;head
op_assign
id|data
suffix:semicolon
id|skb-&gt;data
op_assign
id|data
suffix:semicolon
id|skb-&gt;tail
op_assign
id|data
suffix:semicolon
id|skb-&gt;end
op_assign
id|data
op_plus
id|size
suffix:semicolon
multiline_comment|/* Set up other state */
id|skb-&gt;len
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;is_clone
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;cloned
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|skb-&gt;users
comma
l_int|1
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
id|skb_datarefp
c_func
(paren
id|skb
)paren
comma
l_int|1
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
id|nodata
suffix:colon
id|kmem_cache_free
c_func
(paren
id|skbuff_head_cache
comma
id|skb
)paren
suffix:semicolon
id|nohead
suffix:colon
id|atomic_inc
c_func
(paren
op_amp
id|net_fails
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Slab constructor for a skb head. &n; */
DECL|function|skb_headerinit
r_static
r_inline
r_void
id|skb_headerinit
c_func
(paren
r_void
op_star
id|p
comma
id|kmem_cache_t
op_star
id|cache
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|p
suffix:semicolon
id|skb-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;pkt_type
op_assign
id|PACKET_HOST
suffix:semicolon
multiline_comment|/* Default type */
id|skb-&gt;pkt_bridged
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Not bridged */
id|skb-&gt;prev
op_assign
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;stamp.tv_sec
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No idea about time */
id|skb-&gt;ip_summed
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;security
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* By default packets are insecure */
id|skb-&gt;dst
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef CONFIG_IP_FIREWALL
id|skb-&gt;fwmark
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|memset
c_func
(paren
id|skb-&gt;cb
comma
l_int|0
comma
r_sizeof
(paren
id|skb-&gt;cb
)paren
)paren
suffix:semicolon
id|skb-&gt;priority
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Free an skbuff by memory without cleaning the state. &n; */
DECL|function|kfree_skbmem
r_void
id|kfree_skbmem
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;cloned
op_logical_or
id|atomic_dec_and_test
c_func
(paren
id|skb_datarefp
c_func
(paren
id|skb
)paren
)paren
)paren
id|kfree
c_func
(paren
id|skb-&gt;head
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|skbuff_head_cache
comma
id|skb
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|net_skbcount
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Free an sk_buff. Release anything attached to the buffer. Clean the state.&n; */
DECL|function|__kfree_skb
r_void
id|__kfree_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;list
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Warning: kfree_skb passed an skb still &quot;
l_string|&quot;on a list (from %p).&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|dst_release
c_func
(paren
id|skb-&gt;dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;destructor
)paren
(brace
id|skb
op_member_access_from_pointer
id|destructor
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|skb_headerinit
c_func
(paren
id|skb
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* clean state */
id|kfree_skbmem
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Duplicate an sk_buff. The new one is not owned by a socket.&n; */
DECL|function|skb_clone
r_struct
id|sk_buff
op_star
id|skb_clone
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|sk_buff
op_star
id|n
suffix:semicolon
id|n
op_assign
id|kmem_cache_alloc
c_func
(paren
id|skbuff_head_cache
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
l_int|NULL
suffix:semicolon
id|memcpy
c_func
(paren
id|n
comma
id|skb
comma
r_sizeof
(paren
op_star
id|n
)paren
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
id|skb_datarefp
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
id|skb-&gt;cloned
op_assign
l_int|1
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|net_allocs
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|net_skbcount
)paren
suffix:semicolon
id|dst_clone
c_func
(paren
id|n-&gt;dst
)paren
suffix:semicolon
id|n-&gt;cloned
op_assign
l_int|1
suffix:semicolon
id|n-&gt;next
op_assign
id|n-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;is_clone
op_assign
l_int|1
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|n-&gt;users
comma
l_int|1
)paren
suffix:semicolon
id|n-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is slower, and copies the whole data area &n; */
DECL|function|skb_copy
r_struct
id|sk_buff
op_star
id|skb_copy
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|sk_buff
op_star
id|n
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate the copy buffer&n;&t; */
id|n
op_assign
id|alloc_skb
c_func
(paren
id|skb-&gt;end
op_minus
id|skb-&gt;head
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Shift between the two data areas in bytes&n;&t; */
id|offset
op_assign
id|n-&gt;head
op_minus
id|skb-&gt;head
suffix:semicolon
multiline_comment|/* Set the data pointer */
id|skb_reserve
c_func
(paren
id|n
comma
id|skb-&gt;data
op_minus
id|skb-&gt;head
)paren
suffix:semicolon
multiline_comment|/* Set the tail pointer and length */
id|skb_put
c_func
(paren
id|n
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Copy the bytes */
id|memcpy
c_func
(paren
id|n-&gt;head
comma
id|skb-&gt;head
comma
id|skb-&gt;end
op_minus
id|skb-&gt;head
)paren
suffix:semicolon
id|n-&gt;csum
op_assign
id|skb-&gt;csum
suffix:semicolon
id|n-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|n-&gt;priority
op_assign
id|skb-&gt;priority
suffix:semicolon
id|n-&gt;protocol
op_assign
id|skb-&gt;protocol
suffix:semicolon
id|n-&gt;dst
op_assign
id|dst_clone
c_func
(paren
id|skb-&gt;dst
)paren
suffix:semicolon
id|n-&gt;h.raw
op_assign
id|skb-&gt;h.raw
op_plus
id|offset
suffix:semicolon
id|n-&gt;nh.raw
op_assign
id|skb-&gt;nh.raw
op_plus
id|offset
suffix:semicolon
id|n-&gt;mac.raw
op_assign
id|skb-&gt;mac.raw
op_plus
id|offset
suffix:semicolon
id|memcpy
c_func
(paren
id|n-&gt;cb
comma
id|skb-&gt;cb
comma
r_sizeof
(paren
id|skb-&gt;cb
)paren
)paren
suffix:semicolon
id|n-&gt;used
op_assign
id|skb-&gt;used
suffix:semicolon
id|n-&gt;is_clone
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|n-&gt;users
comma
l_int|1
)paren
suffix:semicolon
id|n-&gt;pkt_type
op_assign
id|skb-&gt;pkt_type
suffix:semicolon
id|n-&gt;stamp
op_assign
id|skb-&gt;stamp
suffix:semicolon
id|n-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;security
op_assign
id|skb-&gt;security
suffix:semicolon
macro_line|#ifdef CONFIG_IP_FIREWALL
id|n-&gt;fwmark
op_assign
id|skb-&gt;fwmark
suffix:semicolon
macro_line|#endif
r_return
id|n
suffix:semicolon
)brace
DECL|function|skb_realloc_headroom
r_struct
id|sk_buff
op_star
id|skb_realloc_headroom
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|newheadroom
)paren
(brace
r_struct
id|sk_buff
op_star
id|n
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
id|headroom
op_assign
id|skb_headroom
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate the copy buffer&n;&t; */
id|n
op_assign
id|alloc_skb
c_func
(paren
id|skb-&gt;truesize
op_plus
id|newheadroom
op_minus
id|headroom
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|n
comma
id|newheadroom
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Shift between the two data areas in bytes&n;&t; */
id|offset
op_assign
id|n-&gt;data
op_minus
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* Set the tail pointer and length */
id|skb_put
c_func
(paren
id|n
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Copy the bytes */
id|memcpy
c_func
(paren
id|n-&gt;data
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|n-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;priority
op_assign
id|skb-&gt;priority
suffix:semicolon
id|n-&gt;protocol
op_assign
id|skb-&gt;protocol
suffix:semicolon
id|n-&gt;dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|n-&gt;dst
op_assign
id|dst_clone
c_func
(paren
id|skb-&gt;dst
)paren
suffix:semicolon
id|n-&gt;h.raw
op_assign
id|skb-&gt;h.raw
op_plus
id|offset
suffix:semicolon
id|n-&gt;nh.raw
op_assign
id|skb-&gt;nh.raw
op_plus
id|offset
suffix:semicolon
id|n-&gt;mac.raw
op_assign
id|skb-&gt;mac.raw
op_plus
id|offset
suffix:semicolon
id|memcpy
c_func
(paren
id|n-&gt;cb
comma
id|skb-&gt;cb
comma
r_sizeof
(paren
id|skb-&gt;cb
)paren
)paren
suffix:semicolon
id|n-&gt;used
op_assign
id|skb-&gt;used
suffix:semicolon
id|n-&gt;is_clone
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|n-&gt;users
comma
l_int|1
)paren
suffix:semicolon
id|n-&gt;pkt_type
op_assign
id|skb-&gt;pkt_type
suffix:semicolon
id|n-&gt;stamp
op_assign
id|skb-&gt;stamp
suffix:semicolon
id|n-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;security
op_assign
id|skb-&gt;security
suffix:semicolon
macro_line|#ifdef CONFIG_IP_FIREWALL
id|n-&gt;fwmark
op_assign
id|skb-&gt;fwmark
suffix:semicolon
macro_line|#endif
r_return
id|n
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* &n; * &t;Tune the memory allocator for a new MTU size.&n; */
r_void
id|skb_add_mtu
c_func
(paren
r_int
id|mtu
)paren
(brace
multiline_comment|/* Must match allocation in alloc_skb */
id|mtu
op_assign
(paren
(paren
id|mtu
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
)paren
op_plus
r_sizeof
(paren
id|atomic_t
)paren
suffix:semicolon
id|kmem_add_cache_size
c_func
(paren
id|mtu
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|skb_init
r_void
id|__init
id|skb_init
c_func
(paren
r_void
)paren
(brace
id|skbuff_head_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;skbuff_head_cache&quot;
comma
r_sizeof
(paren
r_struct
id|sk_buff
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
id|skb_headerinit
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skbuff_head_cache
)paren
id|panic
c_func
(paren
l_string|&quot;cannot create skbuff cache&quot;
)paren
suffix:semicolon
)brace
eof
