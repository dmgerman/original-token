multiline_comment|/*&n; *&t;Routines having to do with the &squot;struct sk_buff&squot; memory handlers.&n; *&n; *&t;Authors:&t;Alan Cox &lt;iiitac@pyr.swan.ac.uk&gt;&n; *&t;&t;&t;Florian La Roche &lt;rzsfl@rz.uni-sb.de&gt;&n; *&n; *&t;Fixes:&t;&n; *&t;&t;Alan Cox&t;:&t;Fixed the worst of the load balancer bugs.&n; *&t;&t;Dave Platt&t;:&t;Interrupt stacking fix.&n; *&t;Richard Kooijman&t;:&t;Timestamp fixes.&n; *&t;&t;Alan Cox&t;:&t;Changed buffer format.&n; *&t;&t;Alan Cox&t;:&t;destructor hook for AF_UNIX etc.&n; *&t;&t;Linus Torvalds&t;:&t;Better skb_clone.&n; *&t;&t;Alan Cox&t;:&t;Added skb_copy.&n; *&t;&t;Alan Cox&t;:&t;Added all the changed routines Linus&n; *&t;&t;&t;&t;&t;only put in the headers&n; *&t;&t;Ray VanTassle&t;:&t;Fixed --skb-&gt;lock in free&n; *&t;&t;Alan Cox&t;:&t;skb_copy copy arp field&n; *&n; *&t;NOTE:&n; *&t;&t;The __skb_ routines should be called with interrupts &n; *&t;disabled, or you better be *real* sure that the operation is atomic &n; *&t;with respect to whatever list is being frobbed (e.g. via lock_sock()&n; *&t;or via disabling bottom half handlers, etc).&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License&n; *&t;as published by the Free Software Foundation; either version&n; *&t;2 of the License, or (at your option) any later version.&n; */
multiline_comment|/*&n; *&t;The functions in this file will not compile correctly with gcc 2.4.x&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/dst.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
multiline_comment|/*&n; *&t;Resource tracking variables&n; */
DECL|variable|net_skbcount
id|atomic_t
id|net_skbcount
op_assign
l_int|0
suffix:semicolon
DECL|variable|net_allocs
id|atomic_t
id|net_allocs
op_assign
l_int|0
suffix:semicolon
DECL|variable|net_fails
id|atomic_t
id|net_fails
op_assign
l_int|0
suffix:semicolon
r_extern
id|atomic_t
id|ip_frag_mem
suffix:semicolon
multiline_comment|/*&n; *&t;Strings we don&squot;t want inline&squot;s duplicating&n; */
DECL|variable|skb_push_errstr
r_char
op_star
id|skb_push_errstr
op_assign
l_string|&quot;skpush:under: %p:%d&quot;
suffix:semicolon
DECL|variable|skb_put_errstr
r_char
op_star
id|skb_put_errstr
op_assign
l_string|&quot;skput:over: %p:%d&quot;
suffix:semicolon
DECL|function|show_net_buffers
r_void
id|show_net_buffers
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Networking buffers in use          : %u&bslash;n&quot;
comma
id|net_skbcount
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Total network buffer allocations   : %u&bslash;n&quot;
comma
id|net_allocs
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Total failed network buffer allocs : %u&bslash;n&quot;
comma
id|net_fails
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_INET
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;IP fragment buffer size            : %u&bslash;n&quot;
comma
id|ip_frag_mem
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
macro_line|#if CONFIG_SKB_CHECK
multiline_comment|/*&n; *&t;Debugging paranoia. Used for debugging network stacks.&n; */
DECL|function|skb_check
r_int
id|skb_check
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|head
comma
r_int
id|line
comma
r_char
op_star
id|file
)paren
(brace
r_if
c_cond
(paren
id|head
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;magic_debug_cookie
op_ne
id|SK_HEAD_SKB
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;File: %s Line %d, found a bad skb-head&bslash;n&quot;
comma
id|file
comma
id|line
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;next
op_logical_or
op_logical_neg
id|skb-&gt;prev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;skb_check: head without next or prev&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;next-&gt;magic_debug_cookie
op_ne
id|SK_HEAD_SKB
op_logical_and
id|skb-&gt;next-&gt;magic_debug_cookie
op_ne
id|SK_GOOD_SKB
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;File: %s Line %d, bad next head-skb member&bslash;n&quot;
comma
id|file
comma
id|line
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;prev-&gt;magic_debug_cookie
op_ne
id|SK_HEAD_SKB
op_logical_and
id|skb-&gt;prev-&gt;magic_debug_cookie
op_ne
id|SK_GOOD_SKB
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;File: %s Line %d, bad prev head-skb member&bslash;n&quot;
comma
id|file
comma
id|line
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;next
op_ne
l_int|NULL
op_logical_and
id|skb-&gt;next-&gt;magic_debug_cookie
op_ne
id|SK_HEAD_SKB
op_logical_and
id|skb-&gt;next-&gt;magic_debug_cookie
op_ne
id|SK_GOOD_SKB
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;File: %s Line %d, bad next skb member&bslash;n&quot;
comma
id|file
comma
id|line
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;prev
op_ne
l_int|NULL
op_logical_and
id|skb-&gt;prev-&gt;magic_debug_cookie
op_ne
id|SK_HEAD_SKB
op_logical_and
id|skb-&gt;prev-&gt;magic_debug_cookie
op_ne
id|SK_GOOD_SKB
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;File: %s Line %d, bad prev skb member&bslash;n&quot;
comma
id|file
comma
id|line
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;magic_debug_cookie
op_eq
id|SK_FREED_SKB
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;File: %s Line %d, found a freed skb lurking in the undergrowth!&bslash;n&quot;
comma
id|file
comma
id|line
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;skb=%p, real size=%d, free=%d&bslash;n&quot;
comma
id|skb
comma
id|skb-&gt;truesize
comma
id|skb-&gt;free
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;magic_debug_cookie
op_ne
id|SK_GOOD_SKB
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;File: %s Line %d, passed a non skb!&bslash;n&quot;
comma
id|file
comma
id|line
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;skb=%p, real size=%d, free=%d&bslash;n&quot;
comma
id|skb
comma
id|skb-&gt;truesize
comma
id|skb-&gt;free
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;head
OG
id|skb-&gt;data
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;File: %s Line %d, head &gt; data !&bslash;n&quot;
comma
id|file
comma
id|line
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;skb=%p, head=%p, data=%p&bslash;n&quot;
comma
id|skb
comma
id|skb-&gt;head
comma
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;tail
OG
id|skb-&gt;end
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;File: %s Line %d, tail &gt; end!&bslash;n&quot;
comma
id|file
comma
id|line
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;skb=%p, tail=%p, end=%p&bslash;n&quot;
comma
id|skb
comma
id|skb-&gt;tail
comma
id|skb-&gt;end
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;data
OG
id|skb-&gt;tail
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;File: %s Line %d, data &gt; tail!&bslash;n&quot;
comma
id|file
comma
id|line
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;skb=%p, data=%p, tail=%p&bslash;n&quot;
comma
id|skb
comma
id|skb-&gt;data
comma
id|skb-&gt;tail
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;tail
op_minus
id|skb-&gt;data
op_ne
id|skb-&gt;len
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;File: %s Line %d, wrong length&bslash;n&quot;
comma
id|file
comma
id|line
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;skb=%p, data=%p, end=%p len=%ld&bslash;n&quot;
comma
id|skb
comma
id|skb-&gt;data
comma
id|skb-&gt;end
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|skb-&gt;end
OG
(paren
r_int
r_int
)paren
id|skb
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;File: %s Line %d, control overrun&bslash;n&quot;
comma
id|file
comma
id|line
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;skb=%p, end=%p&bslash;n&quot;
comma
id|skb
comma
id|skb-&gt;end
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Guess it might be acceptable then */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if CONFIG_SKB_CHECK
DECL|function|skb_queue_head_init
r_void
id|skb_queue_head_init
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
id|list-&gt;prev
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
suffix:semicolon
id|list-&gt;next
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
suffix:semicolon
id|list-&gt;qlen
op_assign
l_int|0
suffix:semicolon
id|list-&gt;magic_debug_cookie
op_assign
id|SK_HEAD_SKB
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Insert an sk_buff at the start of a list.&n; */
DECL|function|skb_queue_head
r_void
id|skb_queue_head
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list_
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sk_buff
op_star
id|list
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|list_
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|IS_SKB_HEAD
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newsk-&gt;next
op_logical_or
id|newsk-&gt;prev
)paren
id|printk
c_func
(paren
l_string|&quot;Suspicious queue head: sk_buff on list!&bslash;n&quot;
)paren
suffix:semicolon
id|newsk-&gt;next
op_assign
id|list-&gt;next
suffix:semicolon
id|newsk-&gt;prev
op_assign
id|list
suffix:semicolon
id|newsk-&gt;next-&gt;prev
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;prev-&gt;next
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;list
op_assign
id|list_
suffix:semicolon
id|list_-&gt;qlen
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|__skb_queue_head
r_void
id|__skb_queue_head
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list_
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_struct
id|sk_buff
op_star
id|list
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|list_
suffix:semicolon
id|IS_SKB
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|IS_SKB_HEAD
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newsk-&gt;next
op_logical_or
id|newsk-&gt;prev
)paren
id|printk
c_func
(paren
l_string|&quot;Suspicious queue head: sk_buff on list!&bslash;n&quot;
)paren
suffix:semicolon
id|newsk-&gt;next
op_assign
id|list-&gt;next
suffix:semicolon
id|newsk-&gt;prev
op_assign
id|list
suffix:semicolon
id|newsk-&gt;next-&gt;prev
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;prev-&gt;next
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;list
op_assign
id|list_
suffix:semicolon
id|list_-&gt;qlen
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Insert an sk_buff at the end of a list.&n; */
DECL|function|skb_queue_tail
r_void
id|skb_queue_tail
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list_
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sk_buff
op_star
id|list
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|list_
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newsk-&gt;next
op_logical_or
id|newsk-&gt;prev
)paren
id|printk
c_func
(paren
l_string|&quot;Suspicious queue tail: sk_buff on list!&bslash;n&quot;
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|IS_SKB_HEAD
c_func
(paren
id|list
)paren
suffix:semicolon
id|newsk-&gt;next
op_assign
id|list
suffix:semicolon
id|newsk-&gt;prev
op_assign
id|list-&gt;prev
suffix:semicolon
id|newsk-&gt;next-&gt;prev
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;prev-&gt;next
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;list
op_assign
id|list_
suffix:semicolon
id|list_-&gt;qlen
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|__skb_queue_tail
r_void
id|__skb_queue_tail
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list_
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_struct
id|sk_buff
op_star
id|list
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|list_
suffix:semicolon
r_if
c_cond
(paren
id|newsk-&gt;next
op_logical_or
id|newsk-&gt;prev
)paren
id|printk
c_func
(paren
l_string|&quot;Suspicious queue tail: sk_buff on list!&bslash;n&quot;
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|IS_SKB_HEAD
c_func
(paren
id|list
)paren
suffix:semicolon
id|newsk-&gt;next
op_assign
id|list
suffix:semicolon
id|newsk-&gt;prev
op_assign
id|list-&gt;prev
suffix:semicolon
id|newsk-&gt;next-&gt;prev
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;prev-&gt;next
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;list
op_assign
id|list_
suffix:semicolon
id|list_-&gt;qlen
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Remove an sk_buff from a list. This routine is also interrupt safe&n; *&t;so you can grab read and free buffers as another process adds them.&n; */
DECL|function|skb_dequeue
r_struct
id|sk_buff
op_star
id|skb_dequeue
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list_
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sk_buff
op_star
id|result
suffix:semicolon
r_struct
id|sk_buff
op_star
id|list
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|list_
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|IS_SKB_HEAD
c_func
(paren
id|list
)paren
suffix:semicolon
id|result
op_assign
id|list-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|list
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|result-&gt;next-&gt;prev
op_assign
id|list
suffix:semicolon
id|list-&gt;next
op_assign
id|result-&gt;next
suffix:semicolon
id|result-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|result-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|list_-&gt;qlen
op_decrement
suffix:semicolon
id|result-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|__skb_dequeue
r_struct
id|sk_buff
op_star
id|__skb_dequeue
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list_
)paren
(brace
r_struct
id|sk_buff
op_star
id|result
suffix:semicolon
r_struct
id|sk_buff
op_star
id|list
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|list_
suffix:semicolon
id|IS_SKB_HEAD
c_func
(paren
id|list
)paren
suffix:semicolon
id|result
op_assign
id|list-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|list
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|result-&gt;next-&gt;prev
op_assign
id|list
suffix:semicolon
id|list-&gt;next
op_assign
id|result-&gt;next
suffix:semicolon
id|result-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|result-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|list_-&gt;qlen
op_decrement
suffix:semicolon
id|result-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|IS_SKB
c_func
(paren
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Insert a packet before another one in a list.&n; */
DECL|function|skb_insert
r_void
id|skb_insert
c_func
(paren
r_struct
id|sk_buff
op_star
id|old
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|IS_SKB
c_func
(paren
id|old
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|newsk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old-&gt;next
op_logical_or
op_logical_neg
id|old-&gt;prev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;insert before unlisted item!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newsk-&gt;next
op_logical_or
id|newsk-&gt;prev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;inserted item is already on a list.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|newsk-&gt;next
op_assign
id|old
suffix:semicolon
id|newsk-&gt;prev
op_assign
id|old-&gt;prev
suffix:semicolon
id|old-&gt;prev
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;prev-&gt;next
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;list
op_assign
id|old-&gt;list
suffix:semicolon
id|newsk-&gt;list-&gt;qlen
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Insert a packet before another one in a list.&n; */
DECL|function|__skb_insert
r_void
id|__skb_insert
c_func
(paren
r_struct
id|sk_buff
op_star
id|newsk
comma
r_struct
id|sk_buff
op_star
id|prev
comma
r_struct
id|sk_buff
op_star
id|next
comma
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
id|IS_SKB
c_func
(paren
id|prev
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev-&gt;next
op_logical_or
op_logical_neg
id|prev-&gt;prev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;insert after unlisted item!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|next-&gt;next
op_logical_or
op_logical_neg
id|next-&gt;prev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;insert before unlisted item!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newsk-&gt;next
op_logical_or
id|newsk-&gt;prev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;inserted item is already on a list.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|newsk-&gt;next
op_assign
id|next
suffix:semicolon
id|newsk-&gt;prev
op_assign
id|prev
suffix:semicolon
id|next-&gt;prev
op_assign
id|newsk
suffix:semicolon
id|prev-&gt;next
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;list
op_assign
id|list
suffix:semicolon
id|list-&gt;qlen
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Place a packet after a given packet in a list.&n; */
DECL|function|skb_append
r_void
id|skb_append
c_func
(paren
r_struct
id|sk_buff
op_star
id|old
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|IS_SKB
c_func
(paren
id|old
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|newsk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old-&gt;next
op_logical_or
op_logical_neg
id|old-&gt;prev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;append before unlisted item!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newsk-&gt;next
op_logical_or
id|newsk-&gt;prev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;append item is already on a list.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|newsk-&gt;prev
op_assign
id|old
suffix:semicolon
id|newsk-&gt;next
op_assign
id|old-&gt;next
suffix:semicolon
id|newsk-&gt;next-&gt;prev
op_assign
id|newsk
suffix:semicolon
id|old-&gt;next
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;list
op_assign
id|old-&gt;list
suffix:semicolon
id|newsk-&gt;list-&gt;qlen
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Remove an sk_buff from its list. Works even without knowing the list it&n; *&t;is sitting on, which can be handy at times. It also means that THE LIST&n; *&t;MUST EXIST when you unlink. Thus a list must have its contents unlinked&n; *&t;_FIRST_.&n; */
DECL|function|skb_unlink
r_void
id|skb_unlink
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;list
)paren
(brace
id|skb-&gt;list-&gt;qlen
op_decrement
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb-&gt;prev
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb-&gt;next
suffix:semicolon
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;list
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef PARANOID_BUGHUNT_MODE&t;/* This is legal but we sometimes want to watch it */
r_else
id|printk
c_func
(paren
l_string|&quot;skb_unlink: not a linked element&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|__skb_unlink
r_void
id|__skb_unlink
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;list
)paren
(brace
id|skb-&gt;list-&gt;qlen
op_decrement
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb-&gt;prev
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb-&gt;next
suffix:semicolon
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;list
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef PARANOID_BUGHUNT_MODE&t;/* This is legal but we sometimes want to watch it */
r_else
id|printk
c_func
(paren
l_string|&quot;skb_unlink: not a linked element&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *&t;Add data to an sk_buff&n; */
DECL|function|skb_put
r_int
r_char
op_star
id|skb_put
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_char
op_star
id|tmp
op_assign
id|skb-&gt;tail
suffix:semicolon
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb-&gt;tail
op_add_assign
id|len
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|len
suffix:semicolon
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;tail
OG
id|skb-&gt;end
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;skput:over: %p:%d&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
comma
id|len
)paren
suffix:semicolon
)brace
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|skb_push
r_int
r_char
op_star
id|skb_push
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb-&gt;data
op_sub_assign
id|len
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|len
suffix:semicolon
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;data
OL
id|skb-&gt;head
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;skpush:under: %p:%d&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
comma
id|len
)paren
suffix:semicolon
)brace
r_return
id|skb-&gt;data
suffix:semicolon
)brace
DECL|function|skb_pull
r_int
r_char
op_star
id|skb_pull
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|skb-&gt;len
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|skb-&gt;data
op_add_assign
id|len
suffix:semicolon
id|skb-&gt;len
op_sub_assign
id|len
suffix:semicolon
r_return
id|skb-&gt;data
suffix:semicolon
)brace
DECL|function|skb_headroom
r_int
id|skb_headroom
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
id|skb-&gt;data
op_minus
id|skb-&gt;head
suffix:semicolon
)brace
DECL|function|skb_tailroom
r_int
id|skb_tailroom
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
id|skb-&gt;end
op_minus
id|skb-&gt;tail
suffix:semicolon
)brace
DECL|function|skb_reserve
r_void
id|skb_reserve
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb-&gt;data
op_add_assign
id|len
suffix:semicolon
id|skb-&gt;tail
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;tail
OG
id|skb-&gt;end
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;sk_res: over&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;data
OL
id|skb-&gt;head
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;sk_res: under&quot;
)paren
suffix:semicolon
)brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
DECL|function|skb_trim
r_void
id|skb_trim
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|len
)paren
(brace
id|skb-&gt;len
op_assign
id|len
suffix:semicolon
id|skb-&gt;tail
op_assign
id|skb-&gt;data
op_plus
id|len
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/**************************************************************************&n;&n;      Stuff below this point isn&squot;t debugging duplicates of the inlines&n;      used for buffer handling&n;      &n;***************************************************************************/
multiline_comment|/*&n; *&t;Free an sk_buff. Release anything attached to the buffer.&n; */
DECL|function|__kfree_skb
r_void
id|__kfree_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
macro_line|#if CONFIG_SKB_CHECK
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;kfree_skb: skb = NULL (from %p)&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|skb-&gt;list
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Warning: kfree_skb passed an skb still on a list (from %p).&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|dst_release
c_func
(paren
id|skb-&gt;dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;destructor
)paren
(brace
id|skb
op_member_access_from_pointer
id|destructor
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|kfree_skbmem
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Allocate a new skbuff. We do this ourselves so we can fill in a few &squot;private&squot;&n; *&t;fields and also do memory statistics to find all the [BEEP] leaks.&n; *&n; *&t;Note: For now we put the header after the data to get better cache&n; *&t;usage. Once we have a good cache aware kmalloc this will cease&n; *&t;to be a good idea.&n; */
DECL|function|alloc_skb
r_struct
id|sk_buff
op_star
id|alloc_skb
c_func
(paren
r_int
r_int
id|size
comma
r_int
id|priority
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
r_char
op_star
id|bptr
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_logical_and
id|intr_count
op_logical_and
id|priority
op_ne
id|GFP_ATOMIC
)paren
(brace
r_static
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|count
OL
l_int|5
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;alloc_skb called nonatomically from interrupt %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|priority
op_assign
id|GFP_ATOMIC
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;FIXME: We could do with an architecture dependant&n;&t; *&t;&squot;alignment mask&squot;.&n;&t; */
id|size
op_assign
(paren
id|size
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
suffix:semicolon
multiline_comment|/* Allow for alignments. Make a multiple of 16 bytes */
id|len
op_assign
id|size
suffix:semicolon
id|size
op_add_assign
r_sizeof
(paren
r_struct
id|sk_buff
)paren
suffix:semicolon
multiline_comment|/* And stick the control itself on the end */
multiline_comment|/*&n;&t; *&t;Allocate some space&n;&t; */
id|bptr
op_assign
(paren
r_int
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bptr
op_eq
l_int|NULL
)paren
(brace
id|net_fails
op_increment
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef PARANOID_BUGHUNT_MODE
r_if
c_cond
(paren
id|skb-&gt;magic_debug_cookie
op_eq
id|SK_GOOD_SKB
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Kernel kmalloc handed us an existing skb (%p)&bslash;n&quot;
comma
id|skb
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Now we play a little game with the caches. Linux kmalloc is&n;&t; *&t;a bit cache dumb, in fact its just about maximally non &n;&t; *&t;optimal for typical kernel buffers. We actually run faster&n;&t; *&t;by doing the following. Which is to deliberately put the&n;&t; *&t;skb at the _end_ not the start of the memory block.&n;&t; */
id|net_allocs
op_increment
suffix:semicolon
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
(paren
id|bptr
op_plus
id|size
)paren
op_minus
l_int|1
suffix:semicolon
id|skb-&gt;count
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* only one reference to this */
id|skb-&gt;data_skb
op_assign
id|skb
suffix:semicolon
multiline_comment|/* and we&squot;re our own data skb */
id|skb-&gt;pkt_type
op_assign
id|PACKET_HOST
suffix:semicolon
multiline_comment|/* Default type */
id|skb-&gt;pkt_bridged
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Not bridged */
id|skb-&gt;prev
op_assign
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;truesize
op_assign
id|size
suffix:semicolon
id|skb-&gt;stamp.tv_sec
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No idea about time */
id|skb-&gt;ip_summed
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;security
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* By default packets are insecure */
id|skb-&gt;dst
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|skb-&gt;cb
comma
l_int|0
comma
r_sizeof
(paren
id|skb-&gt;cb
)paren
)paren
suffix:semicolon
id|skb-&gt;priority
op_assign
id|SOPRI_NORMAL
suffix:semicolon
id|net_skbcount
op_increment
suffix:semicolon
macro_line|#if CONFIG_SKB_CHECK
id|skb-&gt;magic_debug_cookie
op_assign
id|SK_GOOD_SKB
suffix:semicolon
macro_line|#endif
id|skb-&gt;users
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Load the data pointers */
id|skb-&gt;head
op_assign
id|bptr
suffix:semicolon
id|skb-&gt;data
op_assign
id|bptr
suffix:semicolon
id|skb-&gt;tail
op_assign
id|bptr
suffix:semicolon
id|skb-&gt;end
op_assign
id|bptr
op_plus
id|len
suffix:semicolon
id|skb-&gt;len
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;inclone
op_assign
l_int|0
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Free an skbuff by memory&n; */
DECL|function|__kfree_skbmem
r_extern
r_inline
r_void
id|__kfree_skbmem
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* don&squot;t do anything if somebody still uses us */
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|skb-&gt;count
)paren
)paren
(brace
id|kfree
c_func
(paren
id|skb-&gt;head
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|net_skbcount
)paren
suffix:semicolon
)brace
)brace
DECL|function|kfree_skbmem
r_void
id|kfree_skbmem
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_void
op_star
id|addr
op_assign
id|skb-&gt;head
suffix:semicolon
multiline_comment|/* don&squot;t do anything if somebody still uses us */
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|skb-&gt;count
)paren
)paren
(brace
r_int
id|free_head
suffix:semicolon
id|free_head
op_assign
(paren
id|skb-&gt;inclone
op_ne
id|SKB_CLONE_INLINE
)paren
suffix:semicolon
multiline_comment|/* free the skb that contains the actual data if we&squot;ve clone()&squot;d */
r_if
c_cond
(paren
id|skb-&gt;data_skb
op_ne
id|skb
)paren
(brace
id|addr
op_assign
id|skb
suffix:semicolon
id|__kfree_skbmem
c_func
(paren
id|skb-&gt;data_skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|free_head
)paren
id|kfree
c_func
(paren
id|addr
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|net_skbcount
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Duplicate an sk_buff. The new one is not owned by a socket.&n; */
DECL|function|skb_clone
r_struct
id|sk_buff
op_star
id|skb_clone
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|priority
)paren
(brace
r_struct
id|sk_buff
op_star
id|n
suffix:semicolon
r_int
id|inbuff
op_assign
l_int|0
suffix:semicolon
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;inclone
op_logical_and
id|skb_tailroom
c_func
(paren
id|skb
)paren
op_ge
r_sizeof
(paren
r_struct
id|sk_buff
)paren
)paren
(brace
id|n
op_assign
(paren
(paren
r_struct
id|sk_buff
op_star
)paren
id|skb-&gt;end
)paren
op_minus
l_int|1
suffix:semicolon
id|skb-&gt;end
op_sub_assign
r_sizeof
(paren
r_struct
id|sk_buff
)paren
suffix:semicolon
id|skb-&gt;inclone
op_assign
id|SKB_CLONE_ORIG
suffix:semicolon
id|inbuff
op_assign
id|SKB_CLONE_INLINE
suffix:semicolon
)brace
r_else
(brace
id|n
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|n
)paren
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|n
comma
id|skb
comma
r_sizeof
(paren
op_star
id|n
)paren
)paren
suffix:semicolon
id|n-&gt;count
op_assign
l_int|1
suffix:semicolon
id|skb
op_assign
id|skb-&gt;data_skb
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|skb-&gt;count
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|net_allocs
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|net_skbcount
)paren
suffix:semicolon
id|dst_clone
c_func
(paren
id|n-&gt;dst
)paren
suffix:semicolon
id|n-&gt;data_skb
op_assign
id|skb
suffix:semicolon
id|n-&gt;next
op_assign
id|n-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;tries
op_assign
l_int|0
suffix:semicolon
id|n-&gt;users
op_assign
l_int|1
suffix:semicolon
id|n-&gt;inclone
op_assign
id|inbuff
suffix:semicolon
id|n-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is slower, and copies the whole data area &n; */
DECL|function|skb_copy
r_struct
id|sk_buff
op_star
id|skb_copy
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|priority
)paren
(brace
r_struct
id|sk_buff
op_star
id|n
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate the copy buffer&n;&t; */
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|n
op_assign
id|alloc_skb
c_func
(paren
id|skb-&gt;end
op_minus
id|skb-&gt;head
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Shift between the two data areas in bytes&n;&t; */
id|offset
op_assign
id|n-&gt;head
op_minus
id|skb-&gt;head
suffix:semicolon
multiline_comment|/* Set the data pointer */
id|skb_reserve
c_func
(paren
id|n
comma
id|skb-&gt;data
op_minus
id|skb-&gt;head
)paren
suffix:semicolon
multiline_comment|/* Set the tail pointer and length */
id|skb_put
c_func
(paren
id|n
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Copy the bytes */
id|memcpy
c_func
(paren
id|n-&gt;head
comma
id|skb-&gt;head
comma
id|skb-&gt;end
op_minus
id|skb-&gt;head
)paren
suffix:semicolon
id|n-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;when
op_assign
id|skb-&gt;when
suffix:semicolon
id|n-&gt;dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|n-&gt;priority
op_assign
id|skb-&gt;priority
suffix:semicolon
id|n-&gt;protocol
op_assign
id|skb-&gt;protocol
suffix:semicolon
id|n-&gt;dst
op_assign
id|dst_clone
c_func
(paren
id|skb-&gt;dst
)paren
suffix:semicolon
id|n-&gt;h.raw
op_assign
id|skb-&gt;h.raw
op_plus
id|offset
suffix:semicolon
id|n-&gt;nh.raw
op_assign
id|skb-&gt;nh.raw
op_plus
id|offset
suffix:semicolon
id|n-&gt;mac.raw
op_assign
id|skb-&gt;mac.raw
op_plus
id|offset
suffix:semicolon
id|n-&gt;seq
op_assign
id|skb-&gt;seq
suffix:semicolon
id|n-&gt;end_seq
op_assign
id|skb-&gt;end_seq
suffix:semicolon
id|n-&gt;ack_seq
op_assign
id|skb-&gt;ack_seq
suffix:semicolon
id|n-&gt;acked
op_assign
id|skb-&gt;acked
suffix:semicolon
id|memcpy
c_func
(paren
id|n-&gt;cb
comma
id|skb-&gt;cb
comma
r_sizeof
(paren
id|skb-&gt;cb
)paren
)paren
suffix:semicolon
id|n-&gt;used
op_assign
id|skb-&gt;used
suffix:semicolon
id|n-&gt;arp
op_assign
id|skb-&gt;arp
suffix:semicolon
id|n-&gt;tries
op_assign
l_int|0
suffix:semicolon
id|n-&gt;users
op_assign
l_int|1
suffix:semicolon
id|n-&gt;pkt_type
op_assign
id|skb-&gt;pkt_type
suffix:semicolon
id|n-&gt;stamp
op_assign
id|skb-&gt;stamp
suffix:semicolon
id|n-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;security
op_assign
id|skb-&gt;security
suffix:semicolon
id|IS_SKB
c_func
(paren
id|n
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|function|skb_realloc_headroom
r_struct
id|sk_buff
op_star
id|skb_realloc_headroom
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|newheadroom
)paren
(brace
r_struct
id|sk_buff
op_star
id|n
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
id|headroom
op_assign
id|skb_headroom
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate the copy buffer&n;&t; */
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|n
op_assign
id|alloc_skb
c_func
(paren
id|skb-&gt;truesize
op_plus
id|newheadroom
op_minus
id|headroom
op_minus
r_sizeof
(paren
r_struct
id|sk_buff
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|n
comma
id|newheadroom
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Shift between the two data areas in bytes&n;&t; */
id|offset
op_assign
id|n-&gt;data
op_minus
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* Set the tail pointer and length */
id|skb_put
c_func
(paren
id|n
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Copy the bytes */
id|memcpy
c_func
(paren
id|n-&gt;data
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|n-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;when
op_assign
id|skb-&gt;when
suffix:semicolon
id|n-&gt;priority
op_assign
id|skb-&gt;priority
suffix:semicolon
id|n-&gt;protocol
op_assign
id|skb-&gt;protocol
suffix:semicolon
id|n-&gt;dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|n-&gt;dst
op_assign
id|dst_clone
c_func
(paren
id|skb-&gt;dst
)paren
suffix:semicolon
id|n-&gt;h.raw
op_assign
id|skb-&gt;h.raw
op_plus
id|offset
suffix:semicolon
id|n-&gt;nh.raw
op_assign
id|skb-&gt;nh.raw
op_plus
id|offset
suffix:semicolon
id|n-&gt;mac.raw
op_assign
id|skb-&gt;mac.raw
op_plus
id|offset
suffix:semicolon
id|memcpy
c_func
(paren
id|n-&gt;cb
comma
id|skb-&gt;cb
comma
r_sizeof
(paren
id|skb-&gt;cb
)paren
)paren
suffix:semicolon
id|n-&gt;seq
op_assign
id|skb-&gt;seq
suffix:semicolon
id|n-&gt;end_seq
op_assign
id|skb-&gt;end_seq
suffix:semicolon
id|n-&gt;ack_seq
op_assign
id|skb-&gt;ack_seq
suffix:semicolon
id|n-&gt;acked
op_assign
id|skb-&gt;acked
suffix:semicolon
id|n-&gt;used
op_assign
id|skb-&gt;used
suffix:semicolon
id|n-&gt;arp
op_assign
id|skb-&gt;arp
suffix:semicolon
id|n-&gt;tries
op_assign
l_int|0
suffix:semicolon
id|n-&gt;users
op_assign
l_int|1
suffix:semicolon
id|n-&gt;pkt_type
op_assign
id|skb-&gt;pkt_type
suffix:semicolon
id|n-&gt;stamp
op_assign
id|skb-&gt;stamp
suffix:semicolon
id|n-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;security
op_assign
id|skb-&gt;security
suffix:semicolon
id|IS_SKB
c_func
(paren
id|n
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|function|dev_alloc_skb
r_struct
id|sk_buff
op_star
id|dev_alloc_skb
c_func
(paren
r_int
r_int
id|length
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|length
op_plus
l_int|16
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|16
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
eof
