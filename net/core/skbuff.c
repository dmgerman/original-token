multiline_comment|/*&n; *&t;Routines having to do with the &squot;struct sk_buff&squot; memory handlers.&n; *&n; *&t;Authors:&t;Alan Cox &lt;iiitac@pyr.swan.ac.uk&gt;&n; *&t;&t;&t;Florian La Roche &lt;rzsfl@rz.uni-sb.de&gt;&n; *&n; *&t;Fixes:&t;&n; *&t;&t;Alan Cox&t;:&t;Fixed the worst of the load balancer bugs.&n; *&t;&t;Dave Platt&t;:&t;Interrupt stacking fix.&n; *&t;Richard Kooijman&t;:&t;Timestamp fixes.&n; *&t;&t;Alan Cox&t;:&t;Changed buffer format.&n; *&t;&t;Alan Cox&t;:&t;destructor hook for AF_UNIX etc.&n; *&t;&t;Linus Torvalds&t;:&t;Better skb_clone.&n; *&t;&t;Alan Cox&t;:&t;Added skb_copy.&n; *&t;&t;Alan Cox&t;:&t;Added all the changed routines Linus&n; *&t;&t;&t;&t;&t;only put in the headers&n; *&t;&t;Ray VanTassle&t;:&t;Fixed --skb-&gt;lock in free&n; *&t;&t;Alan Cox&t;:&t;skb_copy copy arp field&n; *&n; *&t;NOTE:&n; *&t;&t;The __skb_ routines should be called with interrupts &n; *&t;disabled, or you better be *real* sure that the operation is atomic &n; *&t;with respect to whatever list is being frobbed (e.g. via lock_sock()&n; *&t;or via disabling bottom half handlers, etc).&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License&n; *&t;as published by the Free Software Foundation; either version&n; *&t;2 of the License, or (at your option) any later version.&n; */
multiline_comment|/*&n; *&t;The functions in this file will not compile correctly with gcc 2.4.x&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/dst.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
multiline_comment|/*&n; *&t;Resource tracking variables&n; */
DECL|variable|net_skbcount
r_static
id|atomic_t
id|net_skbcount
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|net_allocs
r_static
id|atomic_t
id|net_allocs
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|net_fails
r_static
id|atomic_t
id|net_fails
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_extern
id|atomic_t
id|ip_frag_mem
suffix:semicolon
multiline_comment|/*&n; *&t;Strings we don&squot;t want inline&squot;s duplicating&n; */
DECL|variable|skb_push_errstr
r_char
op_star
id|skb_push_errstr
op_assign
l_string|&quot;skpush:under: %p:%d&quot;
suffix:semicolon
DECL|variable|skb_put_errstr
r_char
op_star
id|skb_put_errstr
op_assign
l_string|&quot;skput:over: %p:%d&quot;
suffix:semicolon
DECL|function|show_net_buffers
r_void
id|show_net_buffers
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Networking buffers in use          : %u&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|net_skbcount
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Total network buffer allocations   : %u&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|net_allocs
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Total failed network buffer allocs : %u&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|net_fails
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_INET
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;IP fragment buffer size            : %u&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|ip_frag_mem
)paren
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
multiline_comment|/*&n; *&t;Free an sk_buff. Release anything attached to the buffer.&n; */
DECL|function|__kfree_skb
r_void
id|__kfree_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;list
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Warning: kfree_skb passed an skb still &quot;
l_string|&quot;on a list (from %p).&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|dst_release
c_func
(paren
id|skb-&gt;dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;destructor
)paren
(brace
id|skb
op_member_access_from_pointer
id|destructor
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|kfree_skbmem
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Allocate a new skbuff. We do this ourselves so we can fill in a few &squot;private&squot;&n; *&t;fields and also do memory statistics to find all the [BEEP] leaks.&n; *&n; *&t;Note: For now we put the header after the data to get better cache&n; *&t;usage. Once we have a good cache aware kmalloc this will cease&n; *&t;to be a good idea.&n; */
DECL|function|alloc_skb
r_struct
id|sk_buff
op_star
id|alloc_skb
c_func
(paren
r_int
r_int
id|size
comma
r_int
id|priority
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_char
op_star
id|bptr
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
op_logical_and
id|priority
op_ne
id|GFP_ATOMIC
)paren
(brace
r_static
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|count
OL
l_int|5
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;alloc_skb called nonatomically &quot;
l_string|&quot;from interrupt %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|priority
op_assign
id|GFP_ATOMIC
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;FIXME: We could do with an architecture dependant&n;&t; *&t;&squot;alignment mask&squot;.&n;&t; */
multiline_comment|/* Allow for alignments. Make a multiple of 16 bytes */
id|size
op_assign
(paren
id|size
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
suffix:semicolon
id|len
op_assign
id|size
suffix:semicolon
multiline_comment|/* And stick the control itself on the end */
id|size
op_add_assign
r_sizeof
(paren
r_struct
id|sk_buff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate some space&n;&t; */
id|bptr
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bptr
op_eq
l_int|NULL
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|net_fails
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Now we play a little game with the caches. Linux kmalloc is&n;&t; *&t;a bit cache dumb, in fact its just about maximally non &n;&t; *&t;optimal for typical kernel buffers. We actually run faster&n;&t; *&t;by doing the following. Which is to deliberately put the&n;&t; *&t;skb at the _end_ not the start of the memory block.&n;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|net_allocs
)paren
suffix:semicolon
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
(paren
id|bptr
op_plus
id|size
)paren
op_minus
l_int|1
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|skb-&gt;count
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* only one reference to this */
id|skb-&gt;data_skb
op_assign
id|skb
suffix:semicolon
multiline_comment|/* and we&squot;re our own data skb */
id|skb-&gt;pkt_type
op_assign
id|PACKET_HOST
suffix:semicolon
multiline_comment|/* Default type */
id|skb-&gt;pkt_bridged
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Not bridged */
id|skb-&gt;prev
op_assign
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;truesize
op_assign
id|size
suffix:semicolon
id|skb-&gt;stamp.tv_sec
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No idea about time */
id|skb-&gt;ip_summed
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;security
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* By default packets are insecure */
id|skb-&gt;dst
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|skb-&gt;cb
comma
l_int|0
comma
r_sizeof
(paren
id|skb-&gt;cb
)paren
)paren
suffix:semicolon
id|skb-&gt;priority
op_assign
id|SOPRI_NORMAL
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|net_skbcount
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|skb-&gt;users
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Load the data pointers. */
id|skb-&gt;head
op_assign
id|bptr
suffix:semicolon
id|skb-&gt;data
op_assign
id|bptr
suffix:semicolon
id|skb-&gt;tail
op_assign
id|bptr
suffix:semicolon
id|skb-&gt;end
op_assign
id|bptr
op_plus
id|len
suffix:semicolon
id|skb-&gt;len
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;inclone
op_assign
l_int|0
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Free an skbuff by memory&n; */
DECL|function|__kfree_skbmem
r_extern
r_inline
r_void
id|__kfree_skbmem
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* don&squot;t do anything if somebody still uses us */
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|skb-&gt;count
)paren
)paren
(brace
id|kfree
c_func
(paren
id|skb-&gt;head
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|net_skbcount
)paren
suffix:semicolon
)brace
)brace
DECL|function|kfree_skbmem
r_void
id|kfree_skbmem
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_void
op_star
id|addr
op_assign
id|skb-&gt;head
suffix:semicolon
multiline_comment|/* don&squot;t do anything if somebody still uses us */
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|skb-&gt;count
)paren
)paren
(brace
r_int
id|free_head
op_assign
(paren
id|skb-&gt;inclone
op_ne
id|SKB_CLONE_INLINE
)paren
suffix:semicolon
multiline_comment|/* free the skb that contains the actual data if we&squot;ve clone()&squot;d */
r_if
c_cond
(paren
id|skb-&gt;data_skb
op_ne
id|skb
)paren
(brace
id|addr
op_assign
id|skb
suffix:semicolon
id|__kfree_skbmem
c_func
(paren
id|skb-&gt;data_skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|free_head
)paren
id|kfree
c_func
(paren
id|addr
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|net_skbcount
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Duplicate an sk_buff. The new one is not owned by a socket.&n; */
DECL|function|skb_clone
r_struct
id|sk_buff
op_star
id|skb_clone
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|priority
)paren
(brace
r_struct
id|sk_buff
op_star
id|n
suffix:semicolon
r_int
id|inbuff
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;inclone
op_logical_and
id|skb_tailroom
c_func
(paren
id|skb
)paren
op_ge
r_sizeof
(paren
r_struct
id|sk_buff
)paren
)paren
(brace
id|n
op_assign
(paren
(paren
r_struct
id|sk_buff
op_star
)paren
id|skb-&gt;end
)paren
op_minus
l_int|1
suffix:semicolon
id|skb-&gt;end
op_sub_assign
r_sizeof
(paren
r_struct
id|sk_buff
)paren
suffix:semicolon
id|skb-&gt;inclone
op_assign
id|SKB_CLONE_ORIG
suffix:semicolon
id|inbuff
op_assign
id|SKB_CLONE_INLINE
suffix:semicolon
)brace
r_else
(brace
id|n
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|n
)paren
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|n
comma
id|skb
comma
r_sizeof
(paren
op_star
id|n
)paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|n-&gt;count
comma
l_int|1
)paren
suffix:semicolon
id|skb
op_assign
id|skb-&gt;data_skb
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|skb-&gt;count
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|net_allocs
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|net_skbcount
)paren
suffix:semicolon
id|dst_clone
c_func
(paren
id|n-&gt;dst
)paren
suffix:semicolon
id|n-&gt;data_skb
op_assign
id|skb
suffix:semicolon
id|n-&gt;next
op_assign
id|n-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;tries
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|n-&gt;users
comma
l_int|1
)paren
suffix:semicolon
id|n-&gt;inclone
op_assign
id|inbuff
suffix:semicolon
id|n-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is slower, and copies the whole data area &n; */
DECL|function|skb_copy
r_struct
id|sk_buff
op_star
id|skb_copy
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|priority
)paren
(brace
r_struct
id|sk_buff
op_star
id|n
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate the copy buffer&n;&t; */
id|n
op_assign
id|alloc_skb
c_func
(paren
id|skb-&gt;end
op_minus
id|skb-&gt;head
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Shift between the two data areas in bytes&n;&t; */
id|offset
op_assign
id|n-&gt;head
op_minus
id|skb-&gt;head
suffix:semicolon
multiline_comment|/* Set the data pointer */
id|skb_reserve
c_func
(paren
id|n
comma
id|skb-&gt;data
op_minus
id|skb-&gt;head
)paren
suffix:semicolon
multiline_comment|/* Set the tail pointer and length */
id|skb_put
c_func
(paren
id|n
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Copy the bytes */
id|memcpy
c_func
(paren
id|n-&gt;head
comma
id|skb-&gt;head
comma
id|skb-&gt;end
op_minus
id|skb-&gt;head
)paren
suffix:semicolon
id|n-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;when
op_assign
id|skb-&gt;when
suffix:semicolon
id|n-&gt;dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|n-&gt;priority
op_assign
id|skb-&gt;priority
suffix:semicolon
id|n-&gt;protocol
op_assign
id|skb-&gt;protocol
suffix:semicolon
id|n-&gt;dst
op_assign
id|dst_clone
c_func
(paren
id|skb-&gt;dst
)paren
suffix:semicolon
id|n-&gt;h.raw
op_assign
id|skb-&gt;h.raw
op_plus
id|offset
suffix:semicolon
id|n-&gt;nh.raw
op_assign
id|skb-&gt;nh.raw
op_plus
id|offset
suffix:semicolon
id|n-&gt;mac.raw
op_assign
id|skb-&gt;mac.raw
op_plus
id|offset
suffix:semicolon
id|n-&gt;seq
op_assign
id|skb-&gt;seq
suffix:semicolon
id|n-&gt;end_seq
op_assign
id|skb-&gt;end_seq
suffix:semicolon
id|n-&gt;ack_seq
op_assign
id|skb-&gt;ack_seq
suffix:semicolon
id|memcpy
c_func
(paren
id|n-&gt;cb
comma
id|skb-&gt;cb
comma
r_sizeof
(paren
id|skb-&gt;cb
)paren
)paren
suffix:semicolon
id|n-&gt;used
op_assign
id|skb-&gt;used
suffix:semicolon
id|n-&gt;arp
op_assign
id|skb-&gt;arp
suffix:semicolon
id|n-&gt;tries
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|n-&gt;users
comma
l_int|1
)paren
suffix:semicolon
id|n-&gt;pkt_type
op_assign
id|skb-&gt;pkt_type
suffix:semicolon
id|n-&gt;stamp
op_assign
id|skb-&gt;stamp
suffix:semicolon
id|n-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;security
op_assign
id|skb-&gt;security
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|function|skb_realloc_headroom
r_struct
id|sk_buff
op_star
id|skb_realloc_headroom
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|newheadroom
)paren
(brace
r_struct
id|sk_buff
op_star
id|n
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
id|headroom
op_assign
id|skb_headroom
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate the copy buffer&n;&t; */
id|n
op_assign
id|alloc_skb
c_func
(paren
id|skb-&gt;truesize
op_plus
id|newheadroom
op_minus
id|headroom
op_minus
r_sizeof
(paren
r_struct
id|sk_buff
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|n
comma
id|newheadroom
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Shift between the two data areas in bytes&n;&t; */
id|offset
op_assign
id|n-&gt;data
op_minus
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* Set the tail pointer and length */
id|skb_put
c_func
(paren
id|n
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Copy the bytes */
id|memcpy
c_func
(paren
id|n-&gt;data
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|n-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;when
op_assign
id|skb-&gt;when
suffix:semicolon
id|n-&gt;priority
op_assign
id|skb-&gt;priority
suffix:semicolon
id|n-&gt;protocol
op_assign
id|skb-&gt;protocol
suffix:semicolon
id|n-&gt;dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|n-&gt;dst
op_assign
id|dst_clone
c_func
(paren
id|skb-&gt;dst
)paren
suffix:semicolon
id|n-&gt;h.raw
op_assign
id|skb-&gt;h.raw
op_plus
id|offset
suffix:semicolon
id|n-&gt;nh.raw
op_assign
id|skb-&gt;nh.raw
op_plus
id|offset
suffix:semicolon
id|n-&gt;mac.raw
op_assign
id|skb-&gt;mac.raw
op_plus
id|offset
suffix:semicolon
id|memcpy
c_func
(paren
id|n-&gt;cb
comma
id|skb-&gt;cb
comma
r_sizeof
(paren
id|skb-&gt;cb
)paren
)paren
suffix:semicolon
id|n-&gt;seq
op_assign
id|skb-&gt;seq
suffix:semicolon
id|n-&gt;end_seq
op_assign
id|skb-&gt;end_seq
suffix:semicolon
id|n-&gt;ack_seq
op_assign
id|skb-&gt;ack_seq
suffix:semicolon
id|n-&gt;used
op_assign
id|skb-&gt;used
suffix:semicolon
id|n-&gt;arp
op_assign
id|skb-&gt;arp
suffix:semicolon
id|n-&gt;tries
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|n-&gt;users
comma
l_int|1
)paren
suffix:semicolon
id|n-&gt;pkt_type
op_assign
id|skb-&gt;pkt_type
suffix:semicolon
id|n-&gt;stamp
op_assign
id|skb-&gt;stamp
suffix:semicolon
id|n-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;security
op_assign
id|skb-&gt;security
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|function|dev_alloc_skb
r_struct
id|sk_buff
op_star
id|dev_alloc_skb
c_func
(paren
r_int
r_int
id|length
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|length
op_plus
l_int|16
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|16
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
eof
