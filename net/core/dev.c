multiline_comment|/*&n; * &t;NET3&t;Protocol independent device support routines.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; *&t;Derived from the non IP parts of dev.c 1.0.19&n; * &t;&t;Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&n; *&t;Additional Authors:&n; *&t;&t;Florian la Roche &lt;rzsfl@rz.uni-sb.de&gt;&n; *&t;&t;Alan Cox &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;David Hinds &lt;dhinds@allegro.stanford.edu&gt;&n; *&t;&t;Alexey Kuznetsov &lt;kuznet@ms2.inr.ac.ru&gt;&n; *&t;&t;Adam Sulmicki &lt;adam@cfar.umd.edu&gt;&n; *              Pekka Riikonen &lt;priikone@poesidon.pspt.fi&gt;&n; *&n; *&t;Changes:&n; *&t;&t;Alan Cox&t;:&t;device private ioctl copies fields back.&n; *&t;&t;Alan Cox&t;:&t;Transmit queue code does relevant stunts to&n; *&t;&t;&t;&t;&t;keep the queue safe.&n; *&t;&t;Alan Cox&t;:&t;Fixed double lock.&n; *&t;&t;Alan Cox&t;:&t;Fixed promisc NULL pointer trap&n; *&t;&t;????????&t;:&t;Support the full private ioctl range&n; *&t;&t;Alan Cox&t;:&t;Moved ioctl permission check into drivers&n; *&t;&t;Tim Kordas&t;:&t;SIOCADDMULTI/SIOCDELMULTI&n; *&t;&t;Alan Cox&t;:&t;100 backlog just doesn&squot;t cut it when&n; *&t;&t;&t;&t;&t;you start doing multicast video 8)&n; *&t;&t;Alan Cox&t;:&t;Rewrote net_bh and list manager.&n; *&t;&t;Alan Cox&t;: &t;Fix ETH_P_ALL echoback lengths.&n; *&t;&t;Alan Cox&t;:&t;Took out transmit every packet pass&n; *&t;&t;&t;&t;&t;Saved a few bytes in the ioctl handler&n; *&t;&t;Alan Cox&t;:&t;Network driver sets packet type before calling netif_rx. Saves&n; *&t;&t;&t;&t;&t;a function call a packet.&n; *&t;&t;Alan Cox&t;:&t;Hashed net_bh()&n; *&t;&t;Richard Kooijman:&t;Timestamp fixes.&n; *&t;&t;Alan Cox&t;:&t;Wrong field in SIOCGIFDSTADDR&n; *&t;&t;Alan Cox&t;:&t;Device lock protection.&n; *&t;&t;Alan Cox&t;: &t;Fixed nasty side effect of device close changes.&n; *&t;&t;Rudi Cilibrasi&t;:&t;Pass the right thing to set_mac_address()&n; *&t;&t;Dave Miller&t;:&t;32bit quantity for the device lock to make it work out&n; *&t;&t;&t;&t;&t;on a Sparc.&n; *&t;&t;Bjorn Ekwall&t;:&t;Added KERNELD hack.&n; *&t;&t;Alan Cox&t;:&t;Cleaned up the backlog initialise.&n; *&t;&t;Craig Metz&t;:&t;SIOCGIFCONF fix if space for under&n; *&t;&t;&t;&t;&t;1 device.&n; *&t;    Thomas Bogendoerfer :&t;Return ENODEV for dev_open, if there&n; *&t;&t;&t;&t;&t;is no device open function.&n; *&t;&t;Andi Kleen&t;:&t;Fix error reporting for SIOCGIFCONF&n; *&t;    Michael Chastain&t;:&t;Fix signed/unsigned for SIOCGIFCONF&n; *&t;&t;Cyrus Durgin&t;:&t;Cleaned for KMOD&n; *&t;&t;Adam Sulmicki   :&t;Bug Fix : Network Device Unload&n; *&t;&t;&t;&t;&t;A network device unload needs to purge&n; *&t;&t;&t;&t;&t;the backlog queue.&n; *&t;Paul Rusty Russell&t;:&t;SIOCSIFNAME&n; *              Pekka Riikonen  :&t;Netdev boot-time settings code&n; *              Andrew Morton   :       Make unregister_netdevice wait indefinitely on dev-&gt;refcnt&n; * &t;&t;J Hadi Salim&t;:&t;- Backlog queue sampling&n; *&t;&t;&t;&t;        - netif_rx() feedback&t;&n; */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/brlock.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/if_bridge.h&gt;
macro_line|#include &lt;linux/divert.h&gt;
macro_line|#include &lt;net/dst.h&gt;
macro_line|#include &lt;net/pkt_sched.h&gt;
macro_line|#include &lt;net/profile.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#if defined(CONFIG_NET_RADIO) || defined(CONFIG_NET_PCMCIA_RADIO)
macro_line|#include &lt;linux/wireless.h&gt;&t;&t;/* Note : will define WIRELESS_EXT */
macro_line|#endif&t;/* CONFIG_NET_RADIO || CONFIG_NET_PCMCIA_RADIO */
macro_line|#ifdef CONFIG_PLIP
r_extern
r_int
id|plip_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* This define, if set, will randomly drop a packet when congestion&n; * is more than moderate.  It helps fairness in the multi-interface&n; * case when one of them is a hog, but it kills performance for the&n; * single interface case so it is off now by default.&n; */
DECL|macro|RAND_LIE
macro_line|#undef RAND_LIE
multiline_comment|/* Setting this will sample the queue lengths and thus congestion&n; * via a timer instead of as each packet is received.&n; */
DECL|macro|OFFLINE_SAMPLE
macro_line|#undef OFFLINE_SAMPLE
id|NET_PROFILE_DEFINE
c_func
(paren
id|dev_queue_xmit
)paren
id|NET_PROFILE_DEFINE
c_func
(paren
id|softnet_process
)paren
r_const
r_char
op_star
id|if_port_text
(braket
)braket
op_assign
(brace
l_string|&quot;unknown&quot;
comma
l_string|&quot;BNC&quot;
comma
l_string|&quot;10baseT&quot;
comma
l_string|&quot;AUI&quot;
comma
l_string|&quot;100baseT&quot;
comma
l_string|&quot;100baseTX&quot;
comma
l_string|&quot;100baseFX&quot;
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;The list of packet types we will receive (as opposed to discard)&n; *&t;and the routines to invoke.&n; *&n; *&t;Why 16. Because with 16 the only overlap we get on a hash of the&n; *&t;low nibble of the protocol value is RARP/SNAP/X.25. &n; *&n; *&t;&t;0800&t;IP&n; *&t;&t;0001&t;802.3&n; *&t;&t;0002&t;AX.25&n; *&t;&t;0004&t;802.2&n; *&t;&t;8035&t;RARP&n; *&t;&t;0005&t;SNAP&n; *&t;&t;0805&t;X.25&n; *&t;&t;0806&t;ARP&n; *&t;&t;8137&t;IPX&n; *&t;&t;0009&t;Localtalk&n; *&t;&t;86DD&t;IPv6&n; */
DECL|variable|ptype_base
r_static
r_struct
id|packet_type
op_star
id|ptype_base
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* 16 way hashed list */
DECL|variable|ptype_all
r_static
r_struct
id|packet_type
op_star
id|ptype_all
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Taps */
macro_line|#ifdef OFFLINE_SAMPLE
r_static
r_void
id|sample_queue
c_func
(paren
r_int
r_int
id|dummy
)paren
suffix:semicolon
DECL|variable|samp_timer
r_static
r_struct
id|timer_list
id|samp_timer
op_assign
(brace
id|function
suffix:colon
id|sample_queue
)brace
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_HOTPLUG
r_static
r_int
id|net_run_sbin_hotplug
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_char
op_star
id|action
)paren
suffix:semicolon
macro_line|#else
DECL|macro|net_run_sbin_hotplug
mdefine_line|#define net_run_sbin_hotplug(dev, action) ({ 0; })
macro_line|#endif
multiline_comment|/*&n; *&t;Our notifier list&n; */
DECL|variable|netdev_chain
r_static
r_struct
id|notifier_block
op_star
id|netdev_chain
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; *&t;Device drivers call our routines to queue packets here. We empty the&n; *&t;queue in the local softnet handler.&n; */
DECL|variable|__cacheline_aligned
r_struct
id|softnet_data
id|softnet_data
(braket
id|NR_CPUS
)braket
id|__cacheline_aligned
suffix:semicolon
macro_line|#ifdef CONFIG_NET_FASTROUTE
DECL|variable|netdev_fastroute
r_int
id|netdev_fastroute
suffix:semicolon
DECL|variable|netdev_fastroute_obstacles
r_int
id|netdev_fastroute_obstacles
suffix:semicolon
macro_line|#endif
multiline_comment|/******************************************************************************************&n;&n;&t;&t;Protocol management and registration routines&n;&n;*******************************************************************************************/
multiline_comment|/*&n; *&t;For efficiency&n; */
DECL|variable|netdev_nit
r_int
id|netdev_nit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; *&t;Add a protocol ID to the list. Now that the input handler is&n; *&t;smarter we can dispense with all the messy stuff that used to be&n; *&t;here.&n; *&n; *&t;BEWARE!!! Protocol handlers, mangling input packets,&n; *&t;MUST BE last in hash buckets and checking protocol handlers&n; *&t;MUST start from promiscous ptype_all chain in net_bh.&n; *&t;It is true now, do not change it.&n; *&t;Explantion follows: if protocol handler, mangling packet, will&n; *&t;be the first on list, it is not able to sense, that packet&n; *&t;is cloned and should be copied-on-write, so that it will&n; *&t;change it and subsequent readers will get broken packet.&n; *&t;&t;&t;&t;&t;&t;&t;--ANK (980803)&n; */
multiline_comment|/**&n; *&t;dev_add_pack - add packet handler&n; *&t;@pt: packet type declaration&n; * &n; *&t;Add a protocol handler to the networking stack. The passed &amp;packet_type&n; *&t;is linked into kernel lists and may not be freed until it has been&n; *&t;removed from the kernel lists.&n; */
DECL|function|dev_add_pack
r_void
id|dev_add_pack
c_func
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_int
id|hash
suffix:semicolon
id|br_write_lock_bh
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_FASTROUTE
multiline_comment|/* Hack to detect packet socket */
r_if
c_cond
(paren
id|pt-&gt;data
)paren
(brace
id|netdev_fastroute_obstacles
op_increment
suffix:semicolon
id|dev_clear_fastroute
c_func
(paren
id|pt-&gt;dev
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|pt-&gt;type
op_eq
id|htons
c_func
(paren
id|ETH_P_ALL
)paren
)paren
(brace
id|netdev_nit
op_increment
suffix:semicolon
id|pt-&gt;next
op_assign
id|ptype_all
suffix:semicolon
id|ptype_all
op_assign
id|pt
suffix:semicolon
)brace
r_else
(brace
id|hash
op_assign
id|ntohs
c_func
(paren
id|pt-&gt;type
)paren
op_amp
l_int|15
suffix:semicolon
id|pt-&gt;next
op_assign
id|ptype_base
(braket
id|hash
)braket
suffix:semicolon
id|ptype_base
(braket
id|hash
)braket
op_assign
id|pt
suffix:semicolon
)brace
id|br_write_unlock_bh
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_remove_pack&t; - remove packet handler&n; *&t;@pt: packet type declaration&n; * &n; *&t;Remove a protocol handler that was previously added to the kernel&n; *&t;protocol handlers by dev_add_pack(). The passed &amp;packet_type is removed&n; *&t;from the kernel lists and can be freed or reused once this function&n; *&t;returns.&n; */
DECL|function|dev_remove_pack
r_void
id|dev_remove_pack
c_func
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|packet_type
op_star
op_star
id|pt1
suffix:semicolon
id|br_write_lock_bh
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pt-&gt;type
op_eq
id|htons
c_func
(paren
id|ETH_P_ALL
)paren
)paren
(brace
id|netdev_nit
op_decrement
suffix:semicolon
id|pt1
op_assign
op_amp
id|ptype_all
suffix:semicolon
)brace
r_else
(brace
id|pt1
op_assign
op_amp
id|ptype_base
(braket
id|ntohs
c_func
(paren
id|pt-&gt;type
)paren
op_amp
l_int|15
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
(paren
op_star
id|pt1
)paren
op_ne
l_int|NULL
suffix:semicolon
id|pt1
op_assign
op_amp
(paren
(paren
op_star
id|pt1
)paren
op_member_access_from_pointer
id|next
)paren
)paren
(brace
r_if
c_cond
(paren
id|pt
op_eq
(paren
op_star
id|pt1
)paren
)paren
(brace
op_star
id|pt1
op_assign
id|pt-&gt;next
suffix:semicolon
macro_line|#ifdef CONFIG_NET_FASTROUTE
r_if
c_cond
(paren
id|pt-&gt;data
)paren
id|netdev_fastroute_obstacles
op_decrement
suffix:semicolon
macro_line|#endif
id|br_write_unlock_bh
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|br_write_unlock_bh
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;dev_remove_pack: %p not found.&bslash;n&quot;
comma
id|pt
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;&n;&t;&t;      Device Boot-time Settings Routines&n;&n;*******************************************************************************/
multiline_comment|/* Boot time configuration table */
DECL|variable|dev_boot_setup
r_static
r_struct
id|netdev_boot_setup
id|dev_boot_setup
(braket
id|NETDEV_BOOT_SETUP_MAX
)braket
suffix:semicolon
multiline_comment|/**&n; *&t;netdev_boot_setup_add&t;- add new setup entry&n; *&t;@name: name of the device&n; *&t;@map: configured settings for the device&n; *&n; *&t;Adds new setup entry to the dev_boot_setup list.  The function&n; *&t;returns 0 on error and 1 on success.  This is a generic routine to&n; *&t;all netdevices.&n; */
DECL|function|netdev_boot_setup_add
r_int
id|netdev_boot_setup_add
c_func
(paren
r_char
op_star
id|name
comma
r_struct
id|ifmap
op_star
id|map
)paren
(brace
r_struct
id|netdev_boot_setup
op_star
id|s
suffix:semicolon
r_int
id|i
suffix:semicolon
id|s
op_assign
id|dev_boot_setup
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NETDEV_BOOT_SETUP_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|s
(braket
id|i
)braket
dot
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
id|s
(braket
id|i
)braket
dot
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot; &squot;
)paren
(brace
id|memset
c_func
(paren
id|s
(braket
id|i
)braket
dot
id|name
comma
l_int|0
comma
r_sizeof
(paren
id|s
(braket
id|i
)braket
dot
id|name
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|s
(braket
id|i
)braket
dot
id|name
comma
id|name
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|s
(braket
id|i
)braket
dot
id|map
comma
id|map
comma
r_sizeof
(paren
id|s
(braket
id|i
)braket
dot
id|map
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_ge
id|NETDEV_BOOT_SETUP_MAX
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;netdev_boot_setup_check&t;- check boot time settings&n; *&t;@dev: the netdevice&n; *&n; * &t;Check boot time settings for the device.&n; *&t;The found settings are set for the device to be used&n; *&t;later in the device probing.&n; *&t;Returns 0 if no settings found, 1 if they are.&n; */
DECL|function|netdev_boot_setup_check
r_int
id|netdev_boot_setup_check
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|netdev_boot_setup
op_star
id|s
suffix:semicolon
r_int
id|i
suffix:semicolon
id|s
op_assign
id|dev_boot_setup
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NETDEV_BOOT_SETUP_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|s
(braket
id|i
)braket
dot
id|name
(braket
l_int|0
)braket
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
id|s
(braket
id|i
)braket
dot
id|name
(braket
l_int|0
)braket
op_ne
l_char|&squot; &squot;
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|dev-&gt;name
comma
id|s
(braket
id|i
)braket
dot
id|name
comma
id|strlen
c_func
(paren
id|s
(braket
id|i
)braket
dot
id|name
)paren
)paren
)paren
(brace
id|dev-&gt;irq
op_assign
id|s
(braket
id|i
)braket
dot
id|map.irq
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|s
(braket
id|i
)braket
dot
id|map.base_addr
suffix:semicolon
id|dev-&gt;mem_start
op_assign
id|s
(braket
id|i
)braket
dot
id|map.mem_start
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|s
(braket
id|i
)braket
dot
id|map.mem_end
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Saves at boot time configured settings for any netdevice.&n; */
DECL|function|netdev_boot_setup
r_static
r_int
id|__init
id|netdev_boot_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|ints
(braket
l_int|5
)braket
suffix:semicolon
r_struct
id|ifmap
id|map
suffix:semicolon
id|str
op_assign
id|get_options
c_func
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|str
op_logical_or
op_logical_neg
op_star
id|str
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Save settings */
id|memset
c_func
(paren
op_amp
id|map
comma
op_minus
l_int|1
comma
r_sizeof
(paren
id|map
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|0
)paren
id|map.irq
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|1
)paren
id|map.base_addr
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|2
)paren
id|map.mem_start
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|3
)paren
id|map.mem_end
op_assign
id|ints
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Add new entry to the list */
r_return
id|netdev_boot_setup_add
c_func
(paren
id|str
comma
op_amp
id|map
)paren
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;netdev=&quot;
comma
id|netdev_boot_setup
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************************&n;&n;&t;&t;&t;    Device Interface Subroutines&n;&n;******************************************************************************************/
multiline_comment|/**&n; *&t;__dev_get_by_name&t;- find a device by its name &n; *&t;@name: name to find&n; *&n; *&t;Find an interface by name. Must be called under RTNL semaphore&n; *&t;or @dev_base_lock. If the name is found a pointer to the device&n; *&t;is returned. If the name is not found then %NULL is returned. The&n; *&t;reference counters are not incremented so the caller must be&n; *&t;careful with locks.&n; */
DECL|function|__dev_get_by_name
r_struct
id|net_device
op_star
id|__dev_get_by_name
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|dev-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
r_return
id|dev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_get_by_name&t;&t;- find a device by its name&n; *&t;@name: name to find&n; *&n; *&t;Find an interface by name. This can be called from any &n; *&t;context and does its own locking. The returned handle has&n; *&t;the usage count incremented and the caller must use dev_put() to&n; *&t;release it when it is no longer needed. %NULL is returned if no&n; *&t;matching device is found.&n; */
DECL|function|dev_get_by_name
r_struct
id|net_device
op_star
id|dev_get_by_name
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|dev
op_assign
id|__dev_get_by_name
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
id|dev_hold
c_func
(paren
id|dev
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/* &n;   Return value is changed to int to prevent illegal usage in future.&n;   It is still legal to use to check for device existance.&n;&n;   User should understand, that the result returned by this function&n;   is meaningless, if it was not issued under rtnl semaphore.&n; */
multiline_comment|/**&n; *&t;dev_get&t;-&t;test if a device exists&n; *&t;@name:&t;name to test for&n; *&n; *&t;Test if a name exists. Returns true if the name is found. In order&n; *&t;to be sure the name is not allocated or removed during the test the&n; *&t;caller must hold the rtnl semaphore.&n; *&n; *&t;This function primarily exists for back compatibility with older&n; *&t;drivers. &n; */
DECL|function|dev_get
r_int
id|dev_get
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|dev
op_assign
id|__dev_get_by_name
c_func
(paren
id|name
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_return
id|dev
op_ne
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;__dev_get_by_index - find a device by its ifindex&n; *&t;@ifindex: index of device&n; *&n; *&t;Search for an interface by index. Returns %NULL if the device&n; *&t;is not found or a pointer to the device. The device has not&n; *&t;had its reference counter increased so the caller must be careful&n; *&t;about locking. The caller must hold either the RTNL semaphore&n; *&t;or @dev_base_lock.&n; */
DECL|function|__dev_get_by_index
r_struct
id|net_device
op_star
id|__dev_get_by_index
c_func
(paren
r_int
id|ifindex
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;ifindex
op_eq
id|ifindex
)paren
r_return
id|dev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_get_by_index - find a device by its ifindex&n; *&t;@ifindex: index of device&n; *&n; *&t;Search for an interface by index. Returns NULL if the device&n; *&t;is not found or a pointer to the device. The device returned has &n; *&t;had a reference added and the pointer is safe until the user calls&n; *&t;dev_put to indicate they have finished with it.&n; */
DECL|function|dev_get_by_index
r_struct
id|net_device
op_star
id|dev_get_by_index
c_func
(paren
r_int
id|ifindex
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|dev
op_assign
id|__dev_get_by_index
c_func
(paren
id|ifindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
id|dev_hold
c_func
(paren
id|dev
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_getbyhwaddr - find a device by its hardware addres&n; *&t;@type: media type of device&n; *&t;@ha: hardware address&n; *&n; *&t;Search for an interface by MAC address. Returns NULL if the device&n; *&t;is not found or a pointer to the device. The caller must hold the&n; *&t;rtnl semaphore. The returned device has not had its ref count increased&n; *&t;and the caller must therefore be careful about locking&n; *&n; *&t;BUGS:&n; *&t;If the API was consistent this would be __dev_get_by_hwaddr&n; */
DECL|function|dev_getbyhwaddr
r_struct
id|net_device
op_star
id|dev_getbyhwaddr
c_func
(paren
r_int
r_int
id|type
comma
r_char
op_star
id|ha
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|ASSERT_RTNL
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|type
op_logical_and
id|memcmp
c_func
(paren
id|dev-&gt;dev_addr
comma
id|ha
comma
id|dev-&gt;addr_len
)paren
op_eq
l_int|0
)paren
r_return
id|dev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_alloc_name - allocate a name for a device&n; *&t;@dev: device &n; *&t;@name: name format string&n; *&n; *&t;Passed a format string - eg &quot;lt%d&quot; it will try and find a suitable&n; *&t;id. Not efficient for many devices, not called a lot. The caller&n; *&t;must hold the dev_base or rtnl lock while allocating the name and&n; *&t;adding the device in order to avoid duplicates. Returns the number&n; *&t;of the unit assigned or a negative errno code.&n; */
DECL|function|dev_alloc_name
r_int
id|dev_alloc_name
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
id|buf
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If you need over 100 please also fix the algorithm...&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|buf
comma
id|name
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__dev_get_by_name
c_func
(paren
id|buf
)paren
op_eq
l_int|NULL
)paren
(brace
id|strcpy
c_func
(paren
id|dev-&gt;name
comma
id|buf
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENFILE
suffix:semicolon
multiline_comment|/* Over 100 of the things .. bail out! */
)brace
multiline_comment|/**&n; *&t;dev_alloc - allocate a network device and name&n; *&t;@name: name format string&n; *&t;@err: error return pointer&n; *&n; *&t;Passed a format string, eg. &quot;lt%d&quot;, it will allocate a network device&n; *&t;and space for the name. %NULL is returned if no memory is available.&n; *&t;If the allocation succeeds then the name is assigned and the &n; *&t;device pointer returned. %NULL is returned if the name allocation&n; *&t;failed. The cause of an error is returned as a negative errno code&n; *&t;in the variable @err points to.&n; *&n; *&t;The caller must hold the @dev_base or RTNL locks when doing this in&n; *&t;order to avoid duplicate name allocations.&n; */
DECL|function|dev_alloc
r_struct
id|net_device
op_star
id|dev_alloc
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
op_star
id|err
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
op_star
id|err
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device
)paren
)paren
suffix:semicolon
op_star
id|err
op_assign
id|dev_alloc_name
c_func
(paren
id|dev
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|err
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;netdev_state_change - device changes state&n; *&t;@dev: device to cause notification&n; *&n; *&t;Called to indicate a device has changed state. This function calls&n; *&t;the notifier chains for netdev_chain and sends a NEWLINK message&n; *&t;to the routing socket.&n; */
DECL|function|netdev_state_change
r_void
id|netdev_state_change
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGE
comma
id|dev
)paren
suffix:semicolon
id|rtmsg_ifinfo
c_func
(paren
id|RTM_NEWLINK
comma
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_KMOD
multiline_comment|/**&n; *&t;dev_load &t;- load a network module&n; *&t;@name: name of interface&n; *&n; *&t;If a network interface is not present and the process has suitable&n; *&t;privileges this function loads the module. If module loading is not&n; *&t;available in this kernel then it becomes a nop.&n; */
DECL|function|dev_load
r_void
id|dev_load
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev_get
c_func
(paren
id|name
)paren
op_logical_and
id|capable
c_func
(paren
id|CAP_SYS_MODULE
)paren
)paren
id|request_module
c_func
(paren
id|name
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|dev_load
r_extern
r_inline
r_void
(def_block
id|dev_load
c_func
(paren
r_const
r_char
op_star
id|unused
)paren
(brace
suffix:semicolon
)brace
)def_block
macro_line|#endif
DECL|function|default_rebuild_header
r_static
r_int
id|default_rebuild_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: default_rebuild_header called -- BUG!&bslash;n&quot;
comma
id|skb-&gt;dev
ques
c_cond
id|skb-&gt;dev-&gt;name
suffix:colon
l_string|&quot;NULL!!!&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_open&t;- prepare an interface for use. &n; *&t;@dev:&t;device to open&n; *&n; *&t;Takes a device from down to up state. The device&squot;s private open&n; *&t;function is invoked and then the multicast lists are loaded. Finally&n; *&t;the device is moved into the up state and a %NETDEV_UP message is&n; *&t;sent to the netdev notifier chain.&n; *&n; *&t;Calling this function on an active interface is a nop. On a failure&n; *&t;a negative errno code is returned.&n; */
DECL|function|dev_open
r_int
id|dev_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Is it already up?&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Is it even present?&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|netif_device_present
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Call device private open method&n;&t; */
r_if
c_cond
(paren
id|try_inc_mod_count
c_func
(paren
id|dev-&gt;owner
)paren
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;open
)paren
(brace
id|ret
op_assign
id|dev
op_member_access_from_pointer
id|open
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
op_logical_and
id|dev-&gt;owner
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|dev-&gt;owner
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If it went open OK then:&n;&t; */
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Set the flags.&n;&t;&t; */
id|dev-&gt;flags
op_or_assign
id|IFF_UP
suffix:semicolon
id|set_bit
c_func
(paren
id|__LINK_STATE_START
comma
op_amp
id|dev-&gt;state
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Initialize multicasting status &n;&t;&t; */
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Wakeup transmit queue engine&n;&t;&t; */
id|dev_activate
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;... and announce new interface.&n;&t;&t; */
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_UP
comma
id|dev
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_FASTROUTE
DECL|function|dev_do_clear_fastroute
r_static
r_void
id|dev_do_clear_fastroute
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;accept_fastpath
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|NETDEV_FASTROUTE_HMASK
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
suffix:semicolon
id|write_lock_irq
c_func
(paren
op_amp
id|dev-&gt;fastpath_lock
)paren
suffix:semicolon
id|dst
op_assign
id|dev-&gt;fastpath
(braket
id|i
)braket
suffix:semicolon
id|dev-&gt;fastpath
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|dev-&gt;fastpath_lock
)paren
suffix:semicolon
id|dst_release
c_func
(paren
id|dst
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|dev_clear_fastroute
r_void
id|dev_clear_fastroute
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev
)paren
(brace
id|dev_do_clear_fastroute
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
id|dev_do_clear_fastroute
c_func
(paren
id|dev
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/**&n; *&t;dev_close - shutdown an interface.&n; *&t;@dev: device to shutdown&n; *&n; *&t;This function moves an active device into down state. A &n; *&t;%NETDEV_GOING_DOWN is sent to the netdev notifier chain. The device&n; *&t;is then deactivated and finally a %NETDEV_DOWN is sent to the notifier&n; *&t;chain.&n; */
DECL|function|dev_close
r_int
id|dev_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Tell people we are going down, so that they can&n;&t; *&t;prepare to death, when device is still operating.&n;&t; */
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_GOING_DOWN
comma
id|dev
)paren
suffix:semicolon
id|dev_deactivate
c_func
(paren
id|dev
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|__LINK_STATE_START
comma
op_amp
id|dev-&gt;state
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Call the device specific close. This cannot fail.&n;&t; *&t;Only if device is UP&n;&t; *&n;&t; *&t;We allow it to be called even after a DETACH hot-plug&n;&t; *&t;event.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;stop
)paren
id|dev
op_member_access_from_pointer
id|stop
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Device is now down.&n;&t; */
id|dev-&gt;flags
op_and_assign
op_complement
id|IFF_UP
suffix:semicolon
macro_line|#ifdef CONFIG_NET_FASTROUTE
id|dev_clear_fastroute
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Tell people we are down&n;&t; */
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_DOWN
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Drop the module refcount&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;owner
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|dev-&gt;owner
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Device change register/unregister. These are not inline or static&n; *&t;as we export them to the world.&n; */
multiline_comment|/**&n; *&t;register_netdevice_notifier - register a network notifier block&n; *&t;@nb: notifier&n; *&n; *&t;Register a notifier to be called when network device events occur.&n; *&t;The notifier passed is linked into the kernel structures and must&n; *&t;not be reused until it has been unregistered. A negative errno code&n; *&t;is returned on a failure.&n; */
DECL|function|register_netdevice_notifier
r_int
id|register_netdevice_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_return
id|notifier_chain_register
c_func
(paren
op_amp
id|netdev_chain
comma
id|nb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;unregister_netdevice_notifier - unregister a network notifier block&n; *&t;@nb: notifier&n; *&n; *&t;Unregister a notifier previously registered by&n; *&t;register_netdevice_notifier(). The notifier is unlinked into the&n; *&t;kernel structures and may then be reused. A negative errno code&n; *&t;is returned on a failure.&n; */
DECL|function|unregister_netdevice_notifier
r_int
id|unregister_netdevice_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_return
id|notifier_chain_unregister
c_func
(paren
op_amp
id|netdev_chain
comma
id|nb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Support routine. Sends outgoing frames to any network&n; *&t;taps currently in use.&n; */
DECL|function|dev_queue_xmit_nit
r_void
id|dev_queue_xmit_nit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|packet_type
op_star
id|ptype
suffix:semicolon
id|get_fast_time
c_func
(paren
op_amp
id|skb-&gt;stamp
)paren
suffix:semicolon
id|br_read_lock
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ptype
op_assign
id|ptype_all
suffix:semicolon
id|ptype
op_ne
l_int|NULL
suffix:semicolon
id|ptype
op_assign
id|ptype-&gt;next
)paren
(brace
multiline_comment|/* Never send packets back to the socket&n;&t;&t; * they originated from - MvS (miquels@drinkel.ow.org)&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ptype-&gt;dev
op_eq
id|dev
op_logical_or
op_logical_neg
id|ptype-&gt;dev
)paren
op_logical_and
(paren
(paren
r_struct
id|sock
op_star
)paren
id|ptype-&gt;data
op_ne
id|skb-&gt;sk
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
multiline_comment|/* skb-&gt;nh should be correctly&n;&t;&t;&t;   set by sender, so that the second statement is&n;&t;&t;&t;   just protection against buggy protocols.&n;&t;&t;&t; */
id|skb2-&gt;mac.raw
op_assign
id|skb2-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|skb2-&gt;nh.raw
OL
id|skb2-&gt;data
op_logical_or
id|skb2-&gt;nh.raw
op_ge
id|skb2-&gt;tail
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;protocol %04x is buggy, dev %s&bslash;n&quot;
comma
id|skb2-&gt;protocol
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|skb2-&gt;nh.raw
op_assign
id|skb2-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;hard_header
)paren
id|skb2-&gt;nh.raw
op_add_assign
id|dev-&gt;hard_header_len
suffix:semicolon
)brace
id|skb2-&gt;h.raw
op_assign
id|skb2-&gt;nh.raw
suffix:semicolon
id|skb2-&gt;pkt_type
op_assign
id|PACKET_OUTGOING
suffix:semicolon
id|ptype
op_member_access_from_pointer
id|func
c_func
(paren
id|skb2
comma
id|skb-&gt;dev
comma
id|ptype
)paren
suffix:semicolon
)brace
)brace
id|br_read_unlock
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_queue_xmit - transmit a buffer&n; *&t;@skb: buffer to transmit&n; *&t;&n; *&t;Queue a buffer for transmission to a network device. The caller must&n; *&t;have set the device and priority and built the buffer before calling this &n; *&t;function. The function can be called from an interrupt.&n; *&n; *&t;A negative errno code is returned on a failure. A success does not&n; *&t;guarantee the frame will be transmitted as it may be dropped due&n; *&t;to congestion or traffic shaping.&n; */
DECL|function|dev_queue_xmit
r_int
id|dev_queue_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
r_struct
id|Qdisc
op_star
id|q
suffix:semicolon
multiline_comment|/* Grab device queue */
id|spin_lock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|q
op_assign
id|dev-&gt;qdisc
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;enqueue
)paren
(brace
r_int
id|ret
op_assign
id|q
op_member_access_from_pointer
id|enqueue
c_func
(paren
id|skb
comma
id|q
)paren
suffix:semicolon
id|qdisc_run
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
r_return
id|ret
op_eq
id|NET_XMIT_BYPASS
ques
c_cond
id|NET_XMIT_SUCCESS
suffix:colon
id|ret
suffix:semicolon
)brace
multiline_comment|/* The device has no queue. Common case for software devices:&n;&t;   loopback, all the sorts of tunnels...&n;&n;&t;   Really, it is unlikely that xmit_lock protection is necessary here.&n;&t;   (f.e. loopback and IP tunnels are clean ignoring statistics counters.)&n;&t;   However, it is possible, that they rely on protection&n;&t;   made by us here.&n;&n;&t;   Check this and shot the lock. It is not prone from deadlocks.&n;&t;   Either shot noqueue qdisc, it is even simpler 8)&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;xmit_lock_owner
op_ne
id|cpu
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dev-&gt;xmit_lock
)paren
suffix:semicolon
id|dev-&gt;xmit_lock_owner
op_assign
id|cpu
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|netdev_nit
)paren
id|dev_queue_xmit_nit
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|hard_start_xmit
c_func
(paren
id|skb
comma
id|dev
)paren
op_eq
l_int|0
)paren
(brace
id|dev-&gt;xmit_lock_owner
op_assign
op_minus
l_int|1
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|dev-&gt;xmit_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|dev-&gt;xmit_lock_owner
op_assign
op_minus
l_int|1
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|dev-&gt;xmit_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Virtual device %s asks to queue packet!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|ENETDOWN
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Recursion is detected! It is possible, unfortunately */
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Dead loop on virtual device %s, fix it urgently!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|ENETDOWN
suffix:semicolon
)brace
multiline_comment|/*=======================================================================&n;&t;&t;&t;Receiver routines&n;  =======================================================================*/
DECL|variable|netdev_max_backlog
r_int
id|netdev_max_backlog
op_assign
l_int|300
suffix:semicolon
multiline_comment|/* These numbers are selected based on intuition and some&n; * experimentatiom, if you have more scientific way of doing this&n; * please go ahead and fix things.&n; */
DECL|variable|no_cong_thresh
r_int
id|no_cong_thresh
op_assign
l_int|10
suffix:semicolon
DECL|variable|no_cong
r_int
id|no_cong
op_assign
l_int|20
suffix:semicolon
DECL|variable|lo_cong
r_int
id|lo_cong
op_assign
l_int|100
suffix:semicolon
DECL|variable|mod_cong
r_int
id|mod_cong
op_assign
l_int|290
suffix:semicolon
DECL|variable|netdev_rx_stat
r_struct
id|netif_rx_stats
id|netdev_rx_stat
(braket
id|NR_CPUS
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_NET_HW_FLOWCONTROL
DECL|variable|netdev_dropping
id|atomic_t
id|netdev_dropping
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|netdev_fc_mask
r_static
r_int
r_int
id|netdev_fc_mask
op_assign
l_int|1
suffix:semicolon
DECL|variable|netdev_fc_xoff
r_int
r_int
id|netdev_fc_xoff
op_assign
l_int|0
suffix:semicolon
DECL|variable|netdev_fc_lock
id|spinlock_t
id|netdev_fc_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_static
r_struct
(brace
DECL|member|stimul
r_void
(paren
op_star
id|stimul
)paren
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
DECL|member|dev
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
DECL|variable|netdev_fc_slots
)brace
id|netdev_fc_slots
(braket
l_int|32
)braket
suffix:semicolon
DECL|function|netdev_register_fc
r_int
id|netdev_register_fc
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
(paren
op_star
id|stimul
)paren
(paren
r_struct
id|net_device
op_star
id|dev
)paren
)paren
(brace
r_int
id|bit
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|netdev_fc_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|netdev_fc_mask
op_ne
op_complement
l_int|0UL
)paren
(brace
id|bit
op_assign
id|ffz
c_func
(paren
id|netdev_fc_mask
)paren
suffix:semicolon
id|netdev_fc_slots
(braket
id|bit
)braket
dot
id|stimul
op_assign
id|stimul
suffix:semicolon
id|netdev_fc_slots
(braket
id|bit
)braket
dot
id|dev
op_assign
id|dev
suffix:semicolon
id|set_bit
c_func
(paren
id|bit
comma
op_amp
id|netdev_fc_mask
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|bit
comma
op_amp
id|netdev_fc_xoff
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|netdev_fc_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|bit
suffix:semicolon
)brace
DECL|function|netdev_unregister_fc
r_void
id|netdev_unregister_fc
c_func
(paren
r_int
id|bit
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|netdev_fc_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bit
OG
l_int|0
)paren
(brace
id|netdev_fc_slots
(braket
id|bit
)braket
dot
id|stimul
op_assign
l_int|NULL
suffix:semicolon
id|netdev_fc_slots
(braket
id|bit
)braket
dot
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|clear_bit
c_func
(paren
id|bit
comma
op_amp
id|netdev_fc_mask
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|bit
comma
op_amp
id|netdev_fc_xoff
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|netdev_fc_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|netdev_wakeup
r_static
r_void
id|netdev_wakeup
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|xoff
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|netdev_fc_lock
)paren
suffix:semicolon
id|xoff
op_assign
id|netdev_fc_xoff
suffix:semicolon
id|netdev_fc_xoff
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|xoff
)paren
(brace
r_int
id|i
op_assign
id|ffz
c_func
(paren
op_complement
id|xoff
)paren
suffix:semicolon
id|xoff
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
id|netdev_fc_slots
(braket
id|i
)braket
dot
id|stimul
c_func
(paren
id|netdev_fc_slots
(braket
id|i
)braket
dot
id|dev
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|netdev_fc_lock
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|get_sample_stats
r_static
r_void
id|get_sample_stats
c_func
(paren
r_int
id|cpu
)paren
(brace
macro_line|#ifdef RAND_LIE
r_int
r_int
id|rd
suffix:semicolon
r_int
id|rq
suffix:semicolon
macro_line|#endif
r_int
id|blog
op_assign
id|softnet_data
(braket
id|cpu
)braket
dot
id|input_pkt_queue.qlen
suffix:semicolon
r_int
id|avg_blog
op_assign
id|softnet_data
(braket
id|cpu
)braket
dot
id|avg_blog
suffix:semicolon
id|avg_blog
op_assign
(paren
id|avg_blog
op_rshift
l_int|1
)paren
op_plus
(paren
id|blog
op_rshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avg_blog
OG
id|mod_cong
)paren
(brace
multiline_comment|/* Above moderate congestion levels. */
id|softnet_data
(braket
id|cpu
)braket
dot
id|cng_level
op_assign
id|NET_RX_CN_HIGH
suffix:semicolon
macro_line|#ifdef RAND_LIE
id|rd
op_assign
id|net_random
c_func
(paren
)paren
suffix:semicolon
id|rq
op_assign
id|rd
op_mod
id|netdev_max_backlog
suffix:semicolon
r_if
c_cond
(paren
id|rq
OL
id|avg_blog
)paren
multiline_comment|/* unlucky bastard */
id|softnet_data
(braket
id|cpu
)braket
dot
id|cng_level
op_assign
id|NET_RX_DROP
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|avg_blog
OG
id|lo_cong
)paren
(brace
id|softnet_data
(braket
id|cpu
)braket
dot
id|cng_level
op_assign
id|NET_RX_CN_MOD
suffix:semicolon
macro_line|#ifdef RAND_LIE
id|rd
op_assign
id|net_random
c_func
(paren
)paren
suffix:semicolon
id|rq
op_assign
id|rd
op_mod
id|netdev_max_backlog
suffix:semicolon
r_if
c_cond
(paren
id|rq
OL
id|avg_blog
)paren
multiline_comment|/* unlucky bastard */
id|softnet_data
(braket
id|cpu
)braket
dot
id|cng_level
op_assign
id|NET_RX_CN_HIGH
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|avg_blog
OG
id|no_cong
)paren
id|softnet_data
(braket
id|cpu
)braket
dot
id|cng_level
op_assign
id|NET_RX_CN_LOW
suffix:semicolon
r_else
multiline_comment|/* no congestion */
id|softnet_data
(braket
id|cpu
)braket
dot
id|cng_level
op_assign
id|NET_RX_SUCCESS
suffix:semicolon
id|softnet_data
(braket
id|cpu
)braket
dot
id|avg_blog
op_assign
id|avg_blog
suffix:semicolon
)brace
macro_line|#ifdef OFFLINE_SAMPLE
DECL|function|sample_queue
r_static
r_void
id|sample_queue
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
multiline_comment|/* 10 ms 0r 1ms -- i dont care -- JHS */
r_int
id|next_tick
op_assign
l_int|1
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|get_sample_stats
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|next_tick
op_add_assign
id|jiffies
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|samp_timer
comma
id|next_tick
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; *&t;netif_rx&t;-&t;post buffer to the network code&n; *&t;@skb: buffer to post&n; *&n; *&t;This function receives a packet from a device driver and queues it for&n; *&t;the upper (protocol) levels to process.  It always succeeds. The buffer&n; *&t;may be dropped during processing for congestion control or by the &n; *&t;protocol layers.&n; *      &n; *&t;return values:&n; *&t;NET_RX_SUCCESS&t;(no congestion)           &n; *&t;NET_RX_CN_LOW     (low congestion) &n; *&t;NET_RX_CN_MOD     (moderate congestion)&n; *&t;NET_RX_CN_HIGH    (high congestion) &n; *&t;NET_RX_DROP    (packet was dropped)&n; *      &n; *      &n; */
DECL|function|netif_rx
r_int
id|netif_rx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|this_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_struct
id|softnet_data
op_star
id|queue
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;stamp.tv_sec
op_eq
l_int|0
)paren
id|get_fast_time
c_func
(paren
op_amp
id|skb-&gt;stamp
)paren
suffix:semicolon
multiline_comment|/* The code is rearranged so that the path is the most&n;&t;   short when CPU is congested, but is still operating.&n;&t; */
id|queue
op_assign
op_amp
id|softnet_data
(braket
id|this_cpu
)braket
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|netdev_rx_stat
(braket
id|this_cpu
)braket
dot
id|total
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|queue-&gt;input_pkt_queue.qlen
op_le
id|netdev_max_backlog
)paren
(brace
r_if
c_cond
(paren
id|queue-&gt;input_pkt_queue.qlen
)paren
(brace
r_if
c_cond
(paren
id|queue-&gt;throttle
)paren
r_goto
id|drop
suffix:semicolon
id|enqueue
suffix:colon
id|dev_hold
c_func
(paren
id|skb-&gt;dev
)paren
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
op_amp
id|queue-&gt;input_pkt_queue
comma
id|skb
)paren
suffix:semicolon
id|__cpu_raise_softirq
c_func
(paren
id|this_cpu
comma
id|NET_RX_SOFTIRQ
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifndef OFFLINE_SAMPLE
id|get_sample_stats
c_func
(paren
id|this_cpu
)paren
suffix:semicolon
macro_line|#endif
r_return
id|softnet_data
(braket
id|this_cpu
)braket
dot
id|cng_level
suffix:semicolon
)brace
r_if
c_cond
(paren
id|queue-&gt;throttle
)paren
(brace
id|queue-&gt;throttle
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_NET_HW_FLOWCONTROL
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|netdev_dropping
)paren
)paren
id|netdev_wakeup
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_goto
id|enqueue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|queue-&gt;throttle
op_eq
l_int|0
)paren
(brace
id|queue-&gt;throttle
op_assign
l_int|1
suffix:semicolon
id|netdev_rx_stat
(braket
id|this_cpu
)braket
dot
id|throttled
op_increment
suffix:semicolon
macro_line|#ifdef CONFIG_NET_HW_FLOWCONTROL
id|atomic_inc
c_func
(paren
op_amp
id|netdev_dropping
)paren
suffix:semicolon
macro_line|#endif
)brace
id|drop
suffix:colon
id|netdev_rx_stat
(braket
id|this_cpu
)braket
dot
id|dropped
op_increment
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
id|NET_RX_DROP
suffix:semicolon
)brace
multiline_comment|/* Deliver skb to an old protocol, which is not threaded well&n;   or which do not understand shared skbs.&n; */
DECL|function|deliver_to_old_ones
r_static
r_int
id|deliver_to_old_ones
c_func
(paren
r_struct
id|packet_type
op_star
id|pt
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|last
)paren
(brace
r_static
id|spinlock_t
id|net_bh_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_int
id|ret
op_assign
id|NET_RX_DROP
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|last
)paren
(brace
id|skb
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* The assumption (correct one) is that old protocols&n;&t;   did not depened on BHs different of NET_BH and TIMER_BH.&n;&t; */
multiline_comment|/* Emulate NET_BH with special spinlock */
id|spin_lock
c_func
(paren
op_amp
id|net_bh_lock
)paren
suffix:semicolon
multiline_comment|/* Disable timers and wait for all timers completion */
id|tasklet_disable
c_func
(paren
id|bh_task_vec
op_plus
id|TIMER_BH
)paren
suffix:semicolon
id|ret
op_assign
id|pt
op_member_access_from_pointer
id|func
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
id|pt
)paren
suffix:semicolon
id|tasklet_enable
c_func
(paren
id|bh_task_vec
op_plus
id|TIMER_BH
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|net_bh_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Reparent skb to master device. This function is called&n; * only from net_rx_action under BR_NETPROTO_LOCK. It is misuse&n; * of BR_NETPROTO_LOCK, but it is OK for now.&n; */
DECL|function|skb_bond
r_static
id|__inline__
r_void
id|skb_bond
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;master
)paren
(brace
id|dev_hold
c_func
(paren
id|dev-&gt;master
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev-&gt;master
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
DECL|function|net_tx_action
r_static
r_void
id|net_tx_action
c_func
(paren
r_struct
id|softirq_action
op_star
id|h
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|softnet_data
(braket
id|cpu
)braket
dot
id|completion_queue
)paren
(brace
r_struct
id|sk_buff
op_star
id|clist
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|clist
op_assign
id|softnet_data
(braket
id|cpu
)braket
dot
id|completion_queue
suffix:semicolon
id|softnet_data
(braket
id|cpu
)braket
dot
id|completion_queue
op_assign
l_int|NULL
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|clist
op_ne
l_int|NULL
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|clist
suffix:semicolon
id|clist
op_assign
id|clist-&gt;next
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|skb-&gt;users
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|softnet_data
(braket
id|cpu
)braket
dot
id|output_queue
)paren
(brace
r_struct
id|net_device
op_star
id|head
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|head
op_assign
id|softnet_data
(braket
id|cpu
)braket
dot
id|output_queue
suffix:semicolon
id|softnet_data
(braket
id|cpu
)braket
dot
id|output_queue
op_assign
l_int|NULL
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|head
op_ne
l_int|NULL
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|head
suffix:semicolon
id|head
op_assign
id|head-&gt;next_sched
suffix:semicolon
id|smp_mb__before_clear_bit
c_func
(paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|__LINK_STATE_SCHED
comma
op_amp
id|dev-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|spin_trylock
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
)paren
(brace
id|qdisc_run
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|netif_schedule
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/**&n; *&t;net_call_rx_atomic&n; *&t;@fn: function to call&n; *&n; *&t;Make a function call that is atomic with respect to the protocol&n; *&t;layers.&n; */
DECL|function|net_call_rx_atomic
r_void
id|net_call_rx_atomic
c_func
(paren
r_void
(paren
op_star
id|fn
)paren
(paren
r_void
)paren
)paren
(brace
id|br_write_lock_bh
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
id|fn
c_func
(paren
)paren
suffix:semicolon
id|br_write_unlock_bh
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)
DECL|variable|br_handle_frame_hook
r_void
(paren
op_star
id|br_handle_frame_hook
)paren
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
DECL|function|handle_bridge
r_static
r_int
id|__inline__
id|handle_bridge
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|packet_type
op_star
id|pt_prev
)paren
(brace
r_int
id|ret
op_assign
id|NET_RX_DROP
suffix:semicolon
r_if
c_cond
(paren
id|pt_prev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pt_prev-&gt;data
)paren
id|ret
op_assign
id|deliver_to_old_ones
c_func
(paren
id|pt_prev
comma
id|skb
comma
l_int|0
)paren
suffix:semicolon
r_else
(brace
id|atomic_inc
c_func
(paren
op_amp
id|skb-&gt;users
)paren
suffix:semicolon
id|ret
op_assign
id|pt_prev
op_member_access_from_pointer
id|func
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
id|pt_prev
)paren
suffix:semicolon
)brace
)brace
id|br_handle_frame_hook
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_DIVERT
DECL|function|handle_diverter
r_static
r_inline
r_void
id|handle_diverter
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* if diversion is supported on device, then divert */
r_if
c_cond
(paren
id|skb-&gt;dev-&gt;divert
op_logical_and
id|skb-&gt;dev-&gt;divert-&gt;divert
)paren
id|divert_frame
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
macro_line|#endif   /* CONFIG_NET_DIVERT */
DECL|function|net_rx_action
r_static
r_void
id|net_rx_action
c_func
(paren
r_struct
id|softirq_action
op_star
id|h
)paren
(brace
r_int
id|this_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_struct
id|softnet_data
op_star
id|queue
op_assign
op_amp
id|softnet_data
(braket
id|this_cpu
)braket
suffix:semicolon
r_int
r_int
id|start_time
op_assign
id|jiffies
suffix:semicolon
r_int
id|bugdet
op_assign
id|netdev_max_backlog
suffix:semicolon
id|br_read_lock
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|net_device
op_star
id|rx_dev
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
op_amp
id|queue-&gt;input_pkt_queue
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|skb_bond
c_func
(paren
id|skb
)paren
suffix:semicolon
id|rx_dev
op_assign
id|skb-&gt;dev
suffix:semicolon
macro_line|#ifdef CONFIG_NET_FASTROUTE
r_if
c_cond
(paren
id|skb-&gt;pkt_type
op_eq
id|PACKET_FASTROUTE
)paren
(brace
id|netdev_rx_stat
(braket
id|this_cpu
)braket
dot
id|fastroute_deferred_out
op_increment
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
id|dev_put
c_func
(paren
id|rx_dev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#endif
id|skb-&gt;h.raw
op_assign
id|skb-&gt;nh.raw
op_assign
id|skb-&gt;data
suffix:semicolon
(brace
r_struct
id|packet_type
op_star
id|ptype
comma
op_star
id|pt_prev
suffix:semicolon
r_int
r_int
id|type
op_assign
id|skb-&gt;protocol
suffix:semicolon
id|pt_prev
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|ptype
op_assign
id|ptype_all
suffix:semicolon
id|ptype
suffix:semicolon
id|ptype
op_assign
id|ptype-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ptype-&gt;dev
op_logical_or
id|ptype-&gt;dev
op_eq
id|skb-&gt;dev
)paren
(brace
r_if
c_cond
(paren
id|pt_prev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pt_prev-&gt;data
)paren
(brace
id|deliver_to_old_ones
c_func
(paren
id|pt_prev
comma
id|skb
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|atomic_inc
c_func
(paren
op_amp
id|skb-&gt;users
)paren
suffix:semicolon
id|pt_prev
op_member_access_from_pointer
id|func
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
id|pt_prev
)paren
suffix:semicolon
)brace
)brace
id|pt_prev
op_assign
id|ptype
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_NET_DIVERT
r_if
c_cond
(paren
id|skb-&gt;dev-&gt;divert
op_logical_and
id|skb-&gt;dev-&gt;divert-&gt;divert
)paren
id|handle_diverter
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_NET_DIVERT */
macro_line|#if defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)
r_if
c_cond
(paren
id|skb-&gt;dev-&gt;br_port
op_ne
l_int|NULL
op_logical_and
id|br_handle_frame_hook
op_ne
l_int|NULL
)paren
(brace
id|handle_bridge
c_func
(paren
id|skb
comma
id|pt_prev
)paren
suffix:semicolon
id|dev_put
c_func
(paren
id|rx_dev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#endif
r_for
c_loop
(paren
id|ptype
op_assign
id|ptype_base
(braket
id|ntohs
c_func
(paren
id|type
)paren
op_amp
l_int|15
)braket
suffix:semicolon
id|ptype
suffix:semicolon
id|ptype
op_assign
id|ptype-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ptype-&gt;type
op_eq
id|type
op_logical_and
(paren
op_logical_neg
id|ptype-&gt;dev
op_logical_or
id|ptype-&gt;dev
op_eq
id|skb-&gt;dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|pt_prev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pt_prev-&gt;data
)paren
id|deliver_to_old_ones
c_func
(paren
id|pt_prev
comma
id|skb
comma
l_int|0
)paren
suffix:semicolon
r_else
(brace
id|atomic_inc
c_func
(paren
op_amp
id|skb-&gt;users
)paren
suffix:semicolon
id|pt_prev
op_member_access_from_pointer
id|func
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
id|pt_prev
)paren
suffix:semicolon
)brace
)brace
id|pt_prev
op_assign
id|ptype
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pt_prev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pt_prev-&gt;data
)paren
id|deliver_to_old_ones
c_func
(paren
id|pt_prev
comma
id|skb
comma
l_int|1
)paren
suffix:semicolon
r_else
id|pt_prev
op_member_access_from_pointer
id|func
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
id|pt_prev
)paren
suffix:semicolon
)brace
r_else
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|dev_put
c_func
(paren
id|rx_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bugdet
op_decrement
template_param
l_int|1
)paren
r_goto
id|softnet_break
suffix:semicolon
macro_line|#ifdef CONFIG_NET_HW_FLOWCONTROL
r_if
c_cond
(paren
id|queue-&gt;throttle
op_logical_and
id|queue-&gt;input_pkt_queue.qlen
OL
id|no_cong_thresh
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|netdev_dropping
)paren
)paren
(brace
id|queue-&gt;throttle
op_assign
l_int|0
suffix:semicolon
id|netdev_wakeup
c_func
(paren
)paren
suffix:semicolon
r_goto
id|softnet_break
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
id|br_read_unlock
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|queue-&gt;throttle
)paren
(brace
id|queue-&gt;throttle
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_NET_HW_FLOWCONTROL
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|netdev_dropping
)paren
)paren
id|netdev_wakeup
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|NET_PROFILE_LEAVE
c_func
(paren
id|softnet_process
)paren
suffix:semicolon
r_return
suffix:semicolon
id|softnet_break
suffix:colon
id|br_read_unlock
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|netdev_rx_stat
(braket
id|this_cpu
)braket
dot
id|time_squeeze
op_increment
suffix:semicolon
id|__cpu_raise_softirq
c_func
(paren
id|this_cpu
comma
id|NET_RX_SOFTIRQ
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|NET_PROFILE_LEAVE
c_func
(paren
id|softnet_process
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|variable|gifconf_list
r_static
id|gifconf_func_t
op_star
id|gifconf_list
(braket
id|NPROTO
)braket
suffix:semicolon
multiline_comment|/**&n; *&t;register_gifconf&t;-&t;register a SIOCGIF handler&n; *&t;@family: Address family&n; *&t;@gifconf: Function handler&n; *&n; *&t;Register protocol dependent address dumping routines. The handler&n; *&t;that is passed must not be freed or reused until it has been replaced&n; *&t;by another handler.&n; */
DECL|function|register_gifconf
r_int
id|register_gifconf
c_func
(paren
r_int
r_int
id|family
comma
id|gifconf_func_t
op_star
id|gifconf
)paren
(brace
r_if
c_cond
(paren
id|family
op_ge
id|NPROTO
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|gifconf_list
(braket
id|family
)braket
op_assign
id|gifconf
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Map an interface index to its name (SIOCGIFNAME)&n; */
multiline_comment|/*&n; *&t;We need this ioctl for efficient implementation of the&n; *&t;if_indextoname() function required by the IPv6 API.  Without&n; *&t;it, we would have to search all the interfaces to find a&n; *&t;match.  --pb&n; */
DECL|function|dev_ifname
r_static
r_int
id|dev_ifname
c_func
(paren
r_struct
id|ifreq
op_star
id|arg
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|ifreq
id|ifr
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fetch the caller&squot;s info block. &n;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ifr
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|dev
op_assign
id|__dev_get_by_index
c_func
(paren
id|ifr.ifr_ifindex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|ifr.ifr_name
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Perform a SIOCGIFCONF call. This structure will change&n; *&t;size eventually, and there is nothing I can do about it.&n; *&t;Thus we will need a &squot;compatibility mode&squot;.&n; */
DECL|function|dev_ifconf
r_static
r_int
id|dev_ifconf
c_func
(paren
r_char
op_star
id|arg
)paren
(brace
r_struct
id|ifconf
id|ifc
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_char
op_star
id|pos
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|total
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fetch the caller&squot;s info block. &n;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ifc
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifconf
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|pos
op_assign
id|ifc.ifc_buf
suffix:semicolon
id|len
op_assign
id|ifc.ifc_len
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Loop over the interfaces, and write an info block for each. &n;&t; */
id|total
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NPROTO
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|gifconf_list
(braket
id|i
)braket
)paren
(brace
r_int
id|done
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_eq
l_int|NULL
)paren
(brace
id|done
op_assign
id|gifconf_list
(braket
id|i
)braket
(paren
id|dev
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|done
op_assign
id|gifconf_list
(braket
id|i
)braket
(paren
id|dev
comma
id|pos
op_plus
id|total
comma
id|len
op_minus
id|total
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|done
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|total
op_add_assign
id|done
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; *&t;All done.  Write the updated control block back to the caller. &n;&t; */
id|ifc.ifc_len
op_assign
id|total
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifc
comma
r_sizeof
(paren
r_struct
id|ifconf
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* &n;&t; * &t;Both BSD and Solaris return 0 here, so we do too.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is invoked by the /proc filesystem handler to display a device&n; *&t;in detail.&n; */
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|sprintf_stats
r_static
r_int
id|sprintf_stats
c_func
(paren
r_char
op_star
id|buffer
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_device_stats
op_star
id|stats
op_assign
(paren
id|dev-&gt;get_stats
ques
c_cond
id|dev
op_member_access_from_pointer
id|get_stats
c_func
(paren
id|dev
)paren
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|stats
)paren
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%6s:%8lu %7lu %4lu %4lu %4lu %5lu %10lu %9lu %8lu %7lu %4lu %4lu %4lu %5lu %7lu %10lu&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|stats-&gt;rx_bytes
comma
id|stats-&gt;rx_packets
comma
id|stats-&gt;rx_errors
comma
id|stats-&gt;rx_dropped
op_plus
id|stats-&gt;rx_missed_errors
comma
id|stats-&gt;rx_fifo_errors
comma
id|stats-&gt;rx_length_errors
op_plus
id|stats-&gt;rx_over_errors
op_plus
id|stats-&gt;rx_crc_errors
op_plus
id|stats-&gt;rx_frame_errors
comma
id|stats-&gt;rx_compressed
comma
id|stats-&gt;multicast
comma
id|stats-&gt;tx_bytes
comma
id|stats-&gt;tx_packets
comma
id|stats-&gt;tx_errors
comma
id|stats-&gt;tx_dropped
comma
id|stats-&gt;tx_fifo_errors
comma
id|stats-&gt;collisions
comma
id|stats-&gt;tx_carrier_errors
op_plus
id|stats-&gt;tx_aborted_errors
op_plus
id|stats-&gt;tx_window_errors
op_plus
id|stats-&gt;tx_heartbeat_errors
comma
id|stats-&gt;tx_compressed
)paren
suffix:semicolon
r_else
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%6s: No statistics available.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Called from the PROCfs module. This now uses the new arbitrary sized /proc/net interface&n; *&t;to create /proc/net/dev&n; */
DECL|function|dev_get_info
r_static
r_int
id|dev_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|size
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;Inter-|   Receive                                                |  Transmit&bslash;n&quot;
l_string|&quot; face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
id|size
op_assign
id|sprintf_stats
c_func
(paren
id|buffer
op_plus
id|len
comma
id|dev
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
r_break
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start slop */
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
multiline_comment|/* Ending slop */
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|dev_proc_stats
r_static
r_int
id|dev_proc_stats
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|i
comma
id|lcpu
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|lcpu
op_assign
l_int|0
suffix:semicolon
id|lcpu
OL
id|smp_num_cpus
suffix:semicolon
id|lcpu
op_increment
)paren
(brace
id|i
op_assign
id|cpu_logical_map
c_func
(paren
id|lcpu
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%08x %08x %08x %08x %08x %08x %08x %08x %08x&bslash;n&quot;
comma
id|netdev_rx_stat
(braket
id|i
)braket
dot
id|total
comma
id|netdev_rx_stat
(braket
id|i
)braket
dot
id|dropped
comma
id|netdev_rx_stat
(braket
id|i
)braket
dot
id|time_squeeze
comma
id|netdev_rx_stat
(braket
id|i
)braket
dot
id|throttled
comma
id|netdev_rx_stat
(braket
id|i
)braket
dot
id|fastroute_hit
comma
id|netdev_rx_stat
(braket
id|i
)braket
dot
id|fastroute_success
comma
id|netdev_rx_stat
(braket
id|i
)braket
dot
id|fastroute_defer
comma
id|netdev_rx_stat
(braket
id|i
)braket
dot
id|fastroute_deferred_out
comma
macro_line|#if 0
id|netdev_rx_stat
(braket
id|i
)braket
dot
id|fastroute_latency_reduction
macro_line|#else
id|netdev_rx_stat
(braket
id|i
)braket
dot
id|cpu_collision
macro_line|#endif
)paren
suffix:semicolon
)brace
id|len
op_sub_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_PROC_FS */
macro_line|#ifdef WIRELESS_EXT
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/*&n; * Print one entry of /proc/net/wireless&n; * This is a clone of /proc/net/dev (just above)&n; */
DECL|function|sprintf_wireless_stats
r_static
r_int
id|sprintf_wireless_stats
c_func
(paren
r_char
op_star
id|buffer
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* Get stats from the driver */
r_struct
id|iw_statistics
op_star
id|stats
op_assign
(paren
id|dev-&gt;get_wireless_stats
ques
c_cond
id|dev
op_member_access_from_pointer
id|get_wireless_stats
c_func
(paren
id|dev
)paren
suffix:colon
(paren
r_struct
id|iw_statistics
op_star
)paren
l_int|NULL
)paren
suffix:semicolon
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|stats
op_ne
(paren
r_struct
id|iw_statistics
op_star
)paren
l_int|NULL
)paren
(brace
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%6s: %04x  %3d%c  %3d%c  %3d%c  %6d %6d %6d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|stats-&gt;status
comma
id|stats-&gt;qual.qual
comma
id|stats-&gt;qual.updated
op_amp
l_int|1
ques
c_cond
l_char|&squot;.&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|stats-&gt;qual.level
comma
id|stats-&gt;qual.updated
op_amp
l_int|2
ques
c_cond
l_char|&squot;.&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|stats-&gt;qual.noise
comma
id|stats-&gt;qual.updated
op_amp
l_int|4
ques
c_cond
l_char|&squot;.&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|stats-&gt;discard.nwid
comma
id|stats-&gt;discard.code
comma
id|stats-&gt;discard.misc
)paren
suffix:semicolon
id|stats-&gt;qual.updated
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|size
op_assign
l_int|0
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * Print info for /proc/net/wireless (print all entries)&n; * This is a clone of /proc/net/dev (just above)&n; */
DECL|function|dev_get_wireless_info
r_static
r_int
id|dev_get_wireless_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|size
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;Inter-| sta-|   Quality        |   Discarded packets&bslash;n&quot;
l_string|&quot; face | tus | link level noise |  nwid  crypt   misc&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
id|size
op_assign
id|sprintf_wireless_stats
c_func
(paren
id|buffer
op_plus
id|len
comma
id|dev
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
r_break
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start slop */
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
multiline_comment|/* Ending slop */
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_PROC_FS */
macro_line|#endif&t;/* WIRELESS_EXT */
multiline_comment|/**&n; *&t;netdev_set_master&t;-&t;set up master/slave pair&n; *&t;@slave: slave device&n; *&t;@master: new master device&n; *&n; *&t;Changes the master device of the slave. Pass %NULL to break the&n; *&t;bonding. The caller must hold the RTNL semaphore. On a failure&n; *&t;a negative errno code is returned. On success the reference counts&n; *&t;are adjusted, %RTM_NEWLINK is sent to the routing socket and the&n; *&t;function returns zero.&n; */
DECL|function|netdev_set_master
r_int
id|netdev_set_master
c_func
(paren
r_struct
id|net_device
op_star
id|slave
comma
r_struct
id|net_device
op_star
id|master
)paren
(brace
r_struct
id|net_device
op_star
id|old
op_assign
id|slave-&gt;master
suffix:semicolon
id|ASSERT_RTNL
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|master
)paren
(brace
r_if
c_cond
(paren
id|old
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|dev_hold
c_func
(paren
id|master
)paren
suffix:semicolon
)brace
id|br_write_lock_bh
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
id|slave-&gt;master
op_assign
id|master
suffix:semicolon
id|br_write_unlock_bh
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old
)paren
id|dev_put
c_func
(paren
id|old
)paren
suffix:semicolon
r_if
c_cond
(paren
id|master
)paren
id|slave-&gt;flags
op_or_assign
id|IFF_SLAVE
suffix:semicolon
r_else
id|slave-&gt;flags
op_and_assign
op_complement
id|IFF_SLAVE
suffix:semicolon
id|rtmsg_ifinfo
c_func
(paren
id|RTM_NEWLINK
comma
id|slave
comma
id|IFF_SLAVE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_set_promiscuity&t;- update promiscuity count on a device&n; *&t;@dev: device&n; *&t;@inc: modifier&n; *&n; *&t;Add or remove promsicuity from a device. While the count in the device&n; *&t;remains above zero the interface remains promiscuous. Once it hits zero&n; *&t;the device reverts back to normal filtering operation. A negative inc&n; *&t;value is used to drop promiscuity on the device.&n; */
DECL|function|dev_set_promiscuity
r_void
id|dev_set_promiscuity
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|inc
)paren
(brace
r_int
r_int
id|old_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|IFF_PROMISC
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;promiscuity
op_add_assign
id|inc
)paren
op_eq
l_int|0
)paren
id|dev-&gt;flags
op_and_assign
op_complement
id|IFF_PROMISC
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_xor
id|old_flags
)paren
(brace
macro_line|#ifdef CONFIG_NET_FASTROUTE
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|netdev_fastroute_obstacles
op_increment
suffix:semicolon
id|dev_clear_fastroute
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
id|netdev_fastroute_obstacles
op_decrement
suffix:semicolon
macro_line|#endif
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;device %s %s promiscuous mode&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
ques
c_cond
l_string|&quot;entered&quot;
suffix:colon
l_string|&quot;left&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;dev_set_allmulti&t;- update allmulti count on a device&n; *&t;@dev: device&n; *&t;@inc: modifier&n; *&n; *&t;Add or remove reception of all multicast frames to a device. While the&n; *&t;count in the device remains above zero the interface remains listening&n; *&t;to all interfaces. Once it hits zero the device reverts back to normal&n; *&t;filtering operation. A negative @inc value is used to drop the counter&n; *&t;when releasing a resource needing all multicasts.&n; */
DECL|function|dev_set_allmulti
r_void
id|dev_set_allmulti
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|inc
)paren
(brace
r_int
r_int
id|old_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|IFF_ALLMULTI
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;allmulti
op_add_assign
id|inc
)paren
op_eq
l_int|0
)paren
id|dev-&gt;flags
op_and_assign
op_complement
id|IFF_ALLMULTI
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_xor
id|old_flags
)paren
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|dev_change_flags
r_int
id|dev_change_flags
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|flags
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|old_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Set the flags on our device.&n;&t; */
id|dev-&gt;flags
op_assign
(paren
id|flags
op_amp
(paren
id|IFF_DEBUG
op_or
id|IFF_NOTRAILERS
op_or
id|IFF_NOARP
op_or
id|IFF_DYNAMIC
op_or
id|IFF_MULTICAST
op_or
id|IFF_PORTSEL
op_or
id|IFF_AUTOMEDIA
)paren
)paren
op_or
(paren
id|dev-&gt;flags
op_amp
(paren
id|IFF_UP
op_or
id|IFF_VOLATILE
op_or
id|IFF_PROMISC
op_or
id|IFF_ALLMULTI
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Load in the correct multicast list now the flags have changed.&n;&t; */
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Have we downed the interface. We handle IFF_UP ourselves&n;&t; *&t;according to user attempts to set it, rather than blindly&n;&t; *&t;setting it.&n;&t; */
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|old_flags
op_xor
id|flags
)paren
op_amp
id|IFF_UP
)paren
multiline_comment|/* Bit is different  ? */
(brace
id|ret
op_assign
(paren
(paren
id|old_flags
op_amp
id|IFF_UP
)paren
ques
c_cond
id|dev_close
suffix:colon
id|dev_open
)paren
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
op_logical_and
(paren
(paren
id|old_flags
op_xor
id|dev-&gt;flags
)paren
op_amp
op_complement
(paren
id|IFF_UP
op_or
id|IFF_PROMISC
op_or
id|IFF_ALLMULTI
op_or
id|IFF_VOLATILE
)paren
)paren
)paren
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGE
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_xor
id|dev-&gt;gflags
)paren
op_amp
id|IFF_PROMISC
)paren
(brace
r_int
id|inc
op_assign
(paren
id|flags
op_amp
id|IFF_PROMISC
)paren
ques
c_cond
op_plus
l_int|1
suffix:colon
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;gflags
op_xor_assign
id|IFF_PROMISC
suffix:semicolon
id|dev_set_promiscuity
c_func
(paren
id|dev
comma
id|inc
)paren
suffix:semicolon
)brace
multiline_comment|/* NOTE: order of synchronization of IFF_PROMISC and IFF_ALLMULTI&n;&t;   is important. Some (broken) drivers set IFF_PROMISC, when&n;&t;   IFF_ALLMULTI is requested not asking us and not reporting.&n;&t; */
r_if
c_cond
(paren
(paren
id|flags
op_xor
id|dev-&gt;gflags
)paren
op_amp
id|IFF_ALLMULTI
)paren
(brace
r_int
id|inc
op_assign
(paren
id|flags
op_amp
id|IFF_ALLMULTI
)paren
ques
c_cond
op_plus
l_int|1
suffix:colon
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;gflags
op_xor_assign
id|IFF_ALLMULTI
suffix:semicolon
id|dev_set_allmulti
c_func
(paren
id|dev
comma
id|inc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_flags
op_xor
id|dev-&gt;flags
)paren
id|rtmsg_ifinfo
c_func
(paren
id|RTM_NEWLINK
comma
id|dev
comma
id|old_flags
op_xor
id|dev-&gt;flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Perform the SIOCxIFxxx calls. &n; */
DECL|function|dev_ifsioc
r_static
r_int
id|dev_ifsioc
c_func
(paren
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
r_int
id|cmd
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|__dev_get_by_name
c_func
(paren
id|ifr-&gt;ifr_name
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCGIFFLAGS
suffix:colon
multiline_comment|/* Get interface flags */
id|ifr-&gt;ifr_flags
op_assign
(paren
id|dev-&gt;flags
op_amp
op_complement
(paren
id|IFF_PROMISC
op_or
id|IFF_ALLMULTI
op_or
id|IFF_RUNNING
)paren
)paren
op_or
(paren
id|dev-&gt;gflags
op_amp
(paren
id|IFF_PROMISC
op_or
id|IFF_ALLMULTI
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|dev
)paren
op_logical_and
id|netif_carrier_ok
c_func
(paren
id|dev
)paren
)paren
id|ifr-&gt;ifr_flags
op_or_assign
id|IFF_RUNNING
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFFLAGS
suffix:colon
multiline_comment|/* Set interface flags */
r_return
id|dev_change_flags
c_func
(paren
id|dev
comma
id|ifr-&gt;ifr_flags
)paren
suffix:semicolon
r_case
id|SIOCGIFMETRIC
suffix:colon
multiline_comment|/* Get the metric on the interface (currently unused) */
id|ifr-&gt;ifr_metric
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFMETRIC
suffix:colon
multiline_comment|/* Set the metric on the interface (currently unused) */
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_case
id|SIOCGIFMTU
suffix:colon
multiline_comment|/* Get the MTU of a device */
id|ifr-&gt;ifr_mtu
op_assign
id|dev-&gt;mtu
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFMTU
suffix:colon
multiline_comment|/* Set the MTU of a device */
r_if
c_cond
(paren
id|ifr-&gt;ifr_mtu
op_eq
id|dev-&gt;mtu
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;MTU must be positive.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ifr-&gt;ifr_mtu
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|netif_device_present
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;change_mtu
)paren
id|err
op_assign
id|dev
op_member_access_from_pointer
id|change_mtu
c_func
(paren
id|dev
comma
id|ifr-&gt;ifr_mtu
)paren
suffix:semicolon
r_else
(brace
id|dev-&gt;mtu
op_assign
id|ifr-&gt;ifr_mtu
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGEMTU
comma
id|dev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
r_case
id|SIOCGIFHWADDR
suffix:colon
id|memcpy
c_func
(paren
id|ifr-&gt;ifr_hwaddr.sa_data
comma
id|dev-&gt;dev_addr
comma
id|MAX_ADDR_LEN
)paren
suffix:semicolon
id|ifr-&gt;ifr_hwaddr.sa_family
op_assign
id|dev-&gt;type
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFHWADDR
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_mac_address
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|ifr-&gt;ifr_hwaddr.sa_family
op_ne
id|dev-&gt;type
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|netif_device_present
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|err
op_assign
id|dev
op_member_access_from_pointer
id|set_mac_address
c_func
(paren
id|dev
comma
op_amp
id|ifr-&gt;ifr_hwaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGEADDR
comma
id|dev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
r_case
id|SIOCSIFHWBROADCAST
suffix:colon
r_if
c_cond
(paren
id|ifr-&gt;ifr_hwaddr.sa_family
op_ne
id|dev-&gt;type
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;broadcast
comma
id|ifr-&gt;ifr_hwaddr.sa_data
comma
id|MAX_ADDR_LEN
)paren
suffix:semicolon
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGEADDR
comma
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCGIFMAP
suffix:colon
id|ifr-&gt;ifr_map.mem_start
op_assign
id|dev-&gt;mem_start
suffix:semicolon
id|ifr-&gt;ifr_map.mem_end
op_assign
id|dev-&gt;mem_end
suffix:semicolon
id|ifr-&gt;ifr_map.base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|ifr-&gt;ifr_map.irq
op_assign
id|dev-&gt;irq
suffix:semicolon
id|ifr-&gt;ifr_map.dma
op_assign
id|dev-&gt;dma
suffix:semicolon
id|ifr-&gt;ifr_map.port
op_assign
id|dev-&gt;if_port
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFMAP
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_config
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|netif_device_present
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_return
id|dev
op_member_access_from_pointer
id|set_config
c_func
(paren
id|dev
comma
op_amp
id|ifr-&gt;ifr_map
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_case
id|SIOCADDMULTI
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_multicast_list
op_eq
l_int|NULL
op_logical_or
id|ifr-&gt;ifr_hwaddr.sa_family
op_ne
id|AF_UNSPEC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|netif_device_present
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|dev_mc_add
c_func
(paren
id|dev
comma
id|ifr-&gt;ifr_hwaddr.sa_data
comma
id|dev-&gt;addr_len
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCDELMULTI
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_multicast_list
op_eq
l_int|NULL
op_logical_or
id|ifr-&gt;ifr_hwaddr.sa_family
op_ne
id|AF_UNSPEC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|netif_device_present
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|dev_mc_delete
c_func
(paren
id|dev
comma
id|ifr-&gt;ifr_hwaddr.sa_data
comma
id|dev-&gt;addr_len
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCGIFINDEX
suffix:colon
id|ifr-&gt;ifr_ifindex
op_assign
id|dev-&gt;ifindex
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCGIFTXQLEN
suffix:colon
id|ifr-&gt;ifr_qlen
op_assign
id|dev-&gt;tx_queue_len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFTXQLEN
suffix:colon
r_if
c_cond
(paren
id|ifr-&gt;ifr_qlen
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
id|ifr-&gt;ifr_qlen
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFNAME
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|__dev_get_by_name
c_func
(paren
id|ifr-&gt;ifr_newname
)paren
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;name
comma
id|ifr-&gt;ifr_newname
comma
id|IFNAMSIZ
)paren
suffix:semicolon
id|dev-&gt;name
(braket
id|IFNAMSIZ
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGENAME
comma
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Unknown or private ioctl&n;&t;&t; */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
(paren
id|cmd
op_ge
id|SIOCDEVPRIVATE
op_logical_and
id|cmd
op_le
id|SIOCDEVPRIVATE
op_plus
l_int|15
)paren
op_logical_or
id|cmd
op_eq
id|SIOCETHTOOL
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;do_ioctl
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|netif_device_present
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_return
id|dev
op_member_access_from_pointer
id|do_ioctl
c_func
(paren
id|dev
comma
id|ifr
comma
id|cmd
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
macro_line|#ifdef WIRELESS_EXT
r_if
c_cond
(paren
id|cmd
op_ge
id|SIOCIWFIRST
op_logical_and
id|cmd
op_le
id|SIOCIWLAST
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;do_ioctl
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|netif_device_present
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_return
id|dev
op_member_access_from_pointer
id|do_ioctl
c_func
(paren
id|dev
comma
id|ifr
comma
id|cmd
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
macro_line|#endif&t;/* WIRELESS_EXT */
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This function handles all &quot;interface&quot;-type I/O control requests. The actual&n; *&t;&squot;doing&squot; part of this is dev_ifsioc above.&n; */
multiline_comment|/**&n; *&t;dev_ioctl&t;-&t;network device ioctl&n; *&t;@cmd: command to issue&n; *&t;@arg: pointer to a struct ifreq in user space&n; *&n; *&t;Issue ioctl functions to devices. This is normally called by the&n; *&t;user space syscall interfaces but can sometimes be useful for &n; *&t;other purposes. The return value is the return from the syscall if&n; *&t;positive or a negative errno code on error.&n; */
DECL|function|dev_ioctl
r_int
id|dev_ioctl
c_func
(paren
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|ifreq
id|ifr
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_char
op_star
id|colon
suffix:semicolon
multiline_comment|/* One special case: SIOCGIFCONF takes ifconf argument&n;&t;   and requires shared lock, because it sleeps writing&n;&t;   to user space.&n;&t; */
r_if
c_cond
(paren
id|cmd
op_eq
id|SIOCGIFCONF
)paren
(brace
id|rtnl_shlock
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|dev_ifconf
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
id|rtnl_shunlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|SIOCGIFNAME
)paren
(brace
r_return
id|dev_ifname
c_func
(paren
(paren
r_struct
id|ifreq
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ifr
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ifr.ifr_name
(braket
id|IFNAMSIZ
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|colon
op_assign
id|strchr
c_func
(paren
id|ifr.ifr_name
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|colon
)paren
op_star
id|colon
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;See which interface the caller is talking about. &n;&t; */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;These ioctl calls:&n;&t;&t; *&t;- can be done by all.&n;&t;&t; *&t;- atomic and do not require locking.&n;&t;&t; *&t;- return a value&n;&t;&t; */
r_case
id|SIOCGIFFLAGS
suffix:colon
r_case
id|SIOCGIFMETRIC
suffix:colon
r_case
id|SIOCGIFMTU
suffix:colon
r_case
id|SIOCGIFHWADDR
suffix:colon
r_case
id|SIOCGIFSLAVE
suffix:colon
r_case
id|SIOCGIFMAP
suffix:colon
r_case
id|SIOCGIFINDEX
suffix:colon
r_case
id|SIOCGIFTXQLEN
suffix:colon
id|dev_load
c_func
(paren
id|ifr.ifr_name
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|ret
op_assign
id|dev_ifsioc
c_func
(paren
op_amp
id|ifr
comma
id|cmd
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
r_if
c_cond
(paren
id|colon
)paren
op_star
id|colon
op_assign
l_char|&squot;:&squot;
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;These ioctl calls:&n;&t;&t; *&t;- require superuser power.&n;&t;&t; *&t;- require strict serialization.&n;&t;&t; *&t;- do not return a value&n;&t;&t; */
r_case
id|SIOCSIFFLAGS
suffix:colon
r_case
id|SIOCSIFMETRIC
suffix:colon
r_case
id|SIOCSIFMTU
suffix:colon
r_case
id|SIOCSIFMAP
suffix:colon
r_case
id|SIOCSIFHWADDR
suffix:colon
r_case
id|SIOCSIFSLAVE
suffix:colon
r_case
id|SIOCADDMULTI
suffix:colon
r_case
id|SIOCDELMULTI
suffix:colon
r_case
id|SIOCSIFHWBROADCAST
suffix:colon
r_case
id|SIOCSIFTXQLEN
suffix:colon
r_case
id|SIOCSIFNAME
suffix:colon
r_case
id|SIOCETHTOOL
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|dev_load
c_func
(paren
id|ifr.ifr_name
)paren
suffix:semicolon
id|dev_probe_lock
c_func
(paren
)paren
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|dev_ifsioc
c_func
(paren
op_amp
id|ifr
comma
id|cmd
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
id|dev_probe_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
r_case
id|SIOCGIFMEM
suffix:colon
multiline_comment|/* Get the per device memory space. We can add this but currently&n;&t;&t;&t;   do not support it */
r_case
id|SIOCSIFMEM
suffix:colon
multiline_comment|/* Set the per device memory buffer space. Not applicable in our case */
r_case
id|SIOCSIFLINK
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Unknown or private ioctl.&n;&t;&t; */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|cmd
op_ge
id|SIOCDEVPRIVATE
op_logical_and
id|cmd
op_le
id|SIOCDEVPRIVATE
op_plus
l_int|15
)paren
(brace
id|dev_load
c_func
(paren
id|ifr.ifr_name
)paren
suffix:semicolon
id|dev_probe_lock
c_func
(paren
)paren
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|dev_ifsioc
c_func
(paren
op_amp
id|ifr
comma
id|cmd
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
id|dev_probe_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef WIRELESS_EXT
multiline_comment|/* Take care of Wireless Extensions */
r_if
c_cond
(paren
id|cmd
op_ge
id|SIOCIWFIRST
op_logical_and
id|cmd
op_le
id|SIOCIWLAST
)paren
(brace
multiline_comment|/* If command is `set a parameter&squot;, or&n;&t;&t;&t;&t; * `get the encoding parameters&squot;, check if&n;&t;&t;&t;&t; * the user has the right to do it */
r_if
c_cond
(paren
id|IW_IS_SET
c_func
(paren
id|cmd
)paren
op_logical_or
(paren
id|cmd
op_eq
id|SIOCGIWENCODE
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
id|dev_load
c_func
(paren
id|ifr.ifr_name
)paren
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|dev_ifsioc
c_func
(paren
op_amp
id|ifr
comma
id|cmd
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
id|IW_IS_GET
c_func
(paren
id|cmd
)paren
op_logical_and
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif&t;/* WIRELESS_EXT */
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;dev_new_index&t;-&t;allocate an ifindex&n; *&n; *&t;Returns a suitable unique value for a new device interface&n; *&t;number.  The caller must hold the rtnl semaphore or the&n; *&t;dev_base_lock to be sure it remains unique.&n; */
DECL|function|dev_new_index
r_int
id|dev_new_index
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|ifindex
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_increment
id|ifindex
op_le
l_int|0
)paren
id|ifindex
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|__dev_get_by_index
c_func
(paren
id|ifindex
)paren
op_eq
l_int|NULL
)paren
r_return
id|ifindex
suffix:semicolon
)brace
)brace
DECL|variable|dev_boot_phase
r_static
r_int
id|dev_boot_phase
op_assign
l_int|1
suffix:semicolon
multiline_comment|/**&n; *&t;register_netdevice&t;- register a network device&n; *&t;@dev: device to register&n; *&t;&n; *&t;Take a completed network device structure and add it to the kernel&n; *&t;interfaces. A %NETDEV_REGISTER message is sent to the netdev notifier&n; *&t;chain. 0 is returned on success. A negative errno code is returned&n; *&t;on a failure to set up the device, or if the name is a duplicate.&n; *&n; *&t;Callers must hold the rtnl semaphore.  See the comment at the&n; *&t;end of Space.c for details about the locking.  You may want&n; *&t;register_netdev() instead of this.&n; *&n; *&t;BUGS:&n; *&t;The locking appears insufficient to guarantee two parallel registers&n; *&t;will not get the same name.&n; */
DECL|function|register_netdevice
r_int
id|register_netdevice
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_device
op_star
id|d
comma
op_star
op_star
id|dp
suffix:semicolon
macro_line|#ifdef CONFIG_NET_DIVERT
r_int
id|ret
suffix:semicolon
macro_line|#endif
id|spin_lock_init
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|dev-&gt;xmit_lock
)paren
suffix:semicolon
id|dev-&gt;xmit_lock_owner
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_NET_FASTROUTE
id|dev-&gt;fastpath_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|dev_boot_phase
)paren
(brace
macro_line|#ifdef CONFIG_NET_DIVERT
id|ret
op_assign
id|alloc_divert_blk
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
macro_line|#endif /* CONFIG_NET_DIVERT */
multiline_comment|/* This is NOT bug, but I am not sure, that all the&n;&t;&t;   devices, initialized before netdev module is started&n;&t;&t;   are sane. &n;&n;&t;&t;   Now they are chained to device boot list&n;&t;&t;   and probed later. If a module is initialized&n;&t;&t;   before netdev, but assumes that dev-&gt;init&n;&t;&t;   is really called by register_netdev(), it will fail.&n;&n;&t;&t;   So that this message should be printed for a while.&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;early initialization of device %s is deferred&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Check for existence, and append to tail of chain */
r_for
c_loop
(paren
id|dp
op_assign
op_amp
id|dev_base
suffix:semicolon
(paren
id|d
op_assign
op_star
id|dp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|dp
op_assign
op_amp
id|d-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|d
op_eq
id|dev
op_logical_or
id|strcmp
c_func
(paren
id|d-&gt;name
comma
id|dev-&gt;name
)paren
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
)brace
id|dev-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
op_star
id|dp
op_assign
id|dev
suffix:semicolon
id|dev_hold
c_func
(paren
id|dev
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Default initial state at registry is that the&n;&t;&t; *&t;device is present.&n;&t;&t; */
id|set_bit
c_func
(paren
id|__LINK_STATE_PRESENT
comma
op_amp
id|dev-&gt;state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_DIVERT
id|ret
op_assign
id|alloc_divert_blk
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
macro_line|#endif /* CONFIG_NET_DIVERT */
id|dev-&gt;iflink
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Init, if this function is available */
r_if
c_cond
(paren
id|dev-&gt;init
op_logical_and
id|dev
op_member_access_from_pointer
id|init
c_func
(paren
id|dev
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|dev-&gt;ifindex
op_assign
id|dev_new_index
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;iflink
op_eq
op_minus
l_int|1
)paren
id|dev-&gt;iflink
op_assign
id|dev-&gt;ifindex
suffix:semicolon
multiline_comment|/* Check for existence, and append to tail of chain */
r_for
c_loop
(paren
id|dp
op_assign
op_amp
id|dev_base
suffix:semicolon
(paren
id|d
op_assign
op_star
id|dp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|dp
op_assign
op_amp
id|d-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|d
op_eq
id|dev
op_logical_or
id|strcmp
c_func
(paren
id|d-&gt;name
comma
id|dev-&gt;name
)paren
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;nil rebuild_header routine,&n;&t; *&t;that should be never called and used as just bug trap.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;rebuild_header
op_eq
l_int|NULL
)paren
id|dev-&gt;rebuild_header
op_assign
id|default_rebuild_header
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Default initial state at registry is that the&n;&t; *&t;device is present.&n;&t; */
id|set_bit
c_func
(paren
id|__LINK_STATE_PRESENT
comma
op_amp
id|dev-&gt;state
)paren
suffix:semicolon
id|dev-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|dev_init_scheduler
c_func
(paren
id|dev
)paren
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
op_star
id|dp
op_assign
id|dev
suffix:semicolon
id|dev_hold
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;deadbeaf
op_assign
l_int|0
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
multiline_comment|/* Notify protocols, that a new device appeared. */
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_REGISTER
comma
id|dev
)paren
suffix:semicolon
id|net_run_sbin_hotplug
c_func
(paren
id|dev
comma
l_string|&quot;register&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;netdev_finish_unregister - complete unregistration&n; *&t;@dev: device&n; *&n; *&t;Destroy and free a dead device. A value of zero is returned on&n; *&t;success.&n; */
DECL|function|netdev_finish_unregister
r_int
id|netdev_finish_unregister
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|BUG_TRAP
c_func
(paren
id|dev-&gt;ip_ptr
op_eq
l_int|NULL
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|dev-&gt;ip6_ptr
op_eq
l_int|NULL
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|dev-&gt;dn_ptr
op_eq
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;deadbeaf
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Freeing alive device %p, %s&bslash;n&quot;
comma
id|dev
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef NET_REFCNT_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;netdev_finish_unregister: %s%s.&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|dev-&gt;features
op_amp
id|NETIF_F_DYNALLOC
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;, old style&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|dev-&gt;destructor
)paren
id|dev
op_member_access_from_pointer
id|destructor
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;features
op_amp
id|NETIF_F_DYNALLOC
)paren
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;unregister_netdevice - remove device from the kernel&n; *&t;@dev: device&n; *&n; *&t;This function shuts down a device interface and removes it&n; *&t;from the kernel tables. On success 0 is returned, on a failure&n; *&t;a negative errno code is returned.&n; *&n; *&t;Callers must hold the rtnl semaphore.  See the comment at the&n; *&t;end of Space.c for details about the locking.  You may want&n; *&t;unregister_netdev() instead of this.&n; */
DECL|function|unregister_netdevice
r_int
id|unregister_netdevice
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|now
comma
id|warning_time
suffix:semicolon
r_struct
id|net_device
op_star
id|d
comma
op_star
op_star
id|dp
suffix:semicolon
multiline_comment|/* If device is running, close it first. */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
id|dev_close
c_func
(paren
id|dev
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|dev-&gt;deadbeaf
op_eq
l_int|0
)paren
suffix:semicolon
id|dev-&gt;deadbeaf
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* And unlink it from device chain. */
r_for
c_loop
(paren
id|dp
op_assign
op_amp
id|dev_base
suffix:semicolon
(paren
id|d
op_assign
op_star
id|dp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|dp
op_assign
op_amp
id|d-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|d
op_eq
id|dev
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
op_star
id|dp
op_assign
id|d-&gt;next
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|d
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;unregister_netdevice: device %s/%p never was registered&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Synchronize to net_rx_action. */
id|br_write_lock_bh
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
id|br_write_unlock_bh
c_func
(paren
id|BR_NETPROTO_LOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev_boot_phase
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef CONFIG_NET_FASTROUTE
id|dev_clear_fastroute
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Shutdown queueing discipline. */
id|dev_shutdown
c_func
(paren
id|dev
)paren
suffix:semicolon
id|net_run_sbin_hotplug
c_func
(paren
id|dev
comma
l_string|&quot;unregister&quot;
)paren
suffix:semicolon
multiline_comment|/* Notify protocols, that we are about to destroy&n;&t;&t;   this device. They should clean all the things.&n;&t;&t; */
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_UNREGISTER
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Flush the multicast chain&n;&t;&t; */
id|dev_mc_discard
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;uninit
)paren
id|dev
op_member_access_from_pointer
id|uninit
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Notifier chain MUST detach us from master device. */
id|BUG_TRAP
c_func
(paren
id|dev-&gt;master
op_eq
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_DIVERT
id|free_divert_blk
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|dev-&gt;features
op_amp
id|NETIF_F_DYNALLOC
)paren
(brace
macro_line|#ifdef NET_REFCNT_DEBUG
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
op_ne
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;unregister_netdevice: holding %s refcnt=%d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|atomic_read
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Last reference is our one */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
op_eq
l_int|1
)paren
(brace
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef NET_REFCNT_DEBUG
id|printk
c_func
(paren
l_string|&quot;unregister_netdevice: waiting %s refcnt=%d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|atomic_read
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* EXPLANATION. If dev-&gt;refcnt is not now 1 (our own reference)&n;&t;   it means that someone in the kernel still has a reference&n;&t;   to this device and we cannot release it.&n;&n;&t;   &quot;New style&quot; devices have destructors, hence we can return from this&n;&t;   function and destructor will do all the work later.  As of kernel 2.4.0&n;&t;   there are very few &quot;New Style&quot; devices.&n;&n;&t;   &quot;Old style&quot; devices expect that the device is free of any references&n;&t;   upon exit from this function.&n;&t;   We cannot return from this function until all such references have&n;&t;   fallen away.  This is because the caller of this function will probably&n;&t;   immediately kfree(*dev) and then be unloaded via sys_delete_module.&n;&n;&t;   So, we linger until all references fall away.  The duration of the&n;&t;   linger is basically unbounded! It is driven by, for example, the&n;&t;   current setting of sysctl_ipfrag_time.&n;&n;&t;   After 1 second, we start to rebroadcast unregister notifications&n;&t;   in hope that careless clients will release the device.&n;&n;&t; */
id|now
op_assign
id|warning_time
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|now
)paren
OG
l_int|1
op_star
id|HZ
)paren
(brace
multiline_comment|/* Rebroadcast unregister notification */
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_UNREGISTER
comma
id|dev
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|4
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|warning_time
)paren
OG
l_int|10
op_star
id|HZ
)paren
(brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;unregister_netdevice: waiting for %s to &quot;
l_string|&quot;become free. Usage count = %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|atomic_read
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
)paren
suffix:semicolon
id|warning_time
op_assign
id|jiffies
suffix:semicolon
)brace
)brace
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Initialize the DEV module. At boot time this walks the device list and&n; *&t;unhooks any devices that fail to initialise (normally hardware not &n; *&t;present) and leaves us with a valid list of present and active devices.&n; *&n; */
r_extern
r_void
id|net_device_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|ip_auto_config
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_DIVERT
r_extern
r_void
id|dv_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_NET_DIVERT */
multiline_comment|/*&n; *       Callers must hold the rtnl semaphore.  See the comment at the&n; *       end of Space.c for details about the locking.&n; */
DECL|function|net_dev_init
r_int
id|__init
id|net_dev_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|net_device
op_star
id|dev
comma
op_star
op_star
id|dp
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef CONFIG_NET_SCHED
id|pktsched_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_DIVERT
id|dv_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_NET_DIVERT */
multiline_comment|/*&n;&t; *&t;Initialise the packet receive queues.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|softnet_data
op_star
id|queue
suffix:semicolon
id|queue
op_assign
op_amp
id|softnet_data
(braket
id|i
)braket
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|queue-&gt;input_pkt_queue
)paren
suffix:semicolon
id|queue-&gt;throttle
op_assign
l_int|0
suffix:semicolon
id|queue-&gt;cng_level
op_assign
l_int|0
suffix:semicolon
id|queue-&gt;avg_blog
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* arbitrary non-zero */
id|queue-&gt;completion_queue
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_PROFILE
id|net_profile_init
c_func
(paren
)paren
suffix:semicolon
id|NET_PROFILE_REGISTER
c_func
(paren
id|dev_queue_xmit
)paren
suffix:semicolon
id|NET_PROFILE_REGISTER
c_func
(paren
id|softnet_process
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef OFFLINE_SAMPLE
id|samp_timer.expires
op_assign
id|jiffies
op_plus
(paren
l_int|10
op_star
id|HZ
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|samp_timer
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Add the devices.&n;&t; *&t;If the call to dev-&gt;init fails, the dev is removed&n;&t; *&t;from the chain disconnecting the device until the&n;&t; *&t;next reboot.&n;&t; *&n;&t; *&t;NB At boot phase networking is dead. No locking is required.&n;&t; *&t;But we still preserve dev_base_lock for sanity.&n;&t; */
id|dp
op_assign
op_amp
id|dev_base
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dev
op_assign
op_star
id|dp
)paren
op_ne
l_int|NULL
)paren
(brace
id|spin_lock_init
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|dev-&gt;xmit_lock
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_FASTROUTE
id|dev-&gt;fastpath_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
macro_line|#endif
id|dev-&gt;xmit_lock_owner
op_assign
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;iflink
op_assign
op_minus
l_int|1
suffix:semicolon
id|dev_hold
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Allocate name. If the init() fails&n;&t;&t; * the name will be reissued correctly.&n;&t;&t; */
r_if
c_cond
(paren
id|strchr
c_func
(paren
id|dev-&gt;name
comma
l_char|&squot;%&squot;
)paren
)paren
id|dev_alloc_name
c_func
(paren
id|dev
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Check boot time settings for the device.&n;&t;&t; */
id|netdev_boot_setup_check
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;init
op_logical_and
id|dev
op_member_access_from_pointer
id|init
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * It failed to come up. It will be unhooked later.&n;&t;&t;&t; * dev_alloc_name can now advance to next suitable&n;&t;&t;&t; * name that is checked next.&n;&t;&t;&t; */
id|dev-&gt;deadbeaf
op_assign
l_int|1
suffix:semicolon
id|dp
op_assign
op_amp
id|dev-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|dp
op_assign
op_amp
id|dev-&gt;next
suffix:semicolon
id|dev-&gt;ifindex
op_assign
id|dev_new_index
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;iflink
op_eq
op_minus
l_int|1
)paren
id|dev-&gt;iflink
op_assign
id|dev-&gt;ifindex
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;rebuild_header
op_eq
l_int|NULL
)paren
id|dev-&gt;rebuild_header
op_assign
id|default_rebuild_header
suffix:semicolon
id|dev_init_scheduler
c_func
(paren
id|dev
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|__LINK_STATE_PRESENT
comma
op_amp
id|dev-&gt;state
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Unhook devices that failed to come up&n;&t; */
id|dp
op_assign
op_amp
id|dev_base
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dev
op_assign
op_star
id|dp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;deadbeaf
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
op_star
id|dp
op_assign
id|dev-&gt;next
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|dp
op_assign
op_amp
id|dev-&gt;next
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_PROC_FS
id|proc_net_create
c_func
(paren
l_string|&quot;dev&quot;
comma
l_int|0
comma
id|dev_get_info
)paren
suffix:semicolon
id|create_proc_read_entry
c_func
(paren
l_string|&quot;net/softnet_stat&quot;
comma
l_int|0
comma
l_int|0
comma
id|dev_proc_stats
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef WIRELESS_EXT
id|proc_net_create
c_func
(paren
l_string|&quot;wireless&quot;
comma
l_int|0
comma
id|dev_get_wireless_info
)paren
suffix:semicolon
macro_line|#endif&t;/* WIRELESS_EXT */
macro_line|#endif&t;/* CONFIG_PROC_FS */
id|dev_boot_phase
op_assign
l_int|0
suffix:semicolon
id|open_softirq
c_func
(paren
id|NET_TX_SOFTIRQ
comma
id|net_tx_action
comma
l_int|NULL
)paren
suffix:semicolon
id|open_softirq
c_func
(paren
id|NET_RX_SOFTIRQ
comma
id|net_rx_action
comma
l_int|NULL
)paren
suffix:semicolon
id|dst_init
c_func
(paren
)paren
suffix:semicolon
id|dev_mcast_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Initialise network devices&n;&t; */
id|net_device_init
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_HOTPLUG
multiline_comment|/* Notify userspace when a netdevice event occurs,&n; * by running &squot;/sbin/hotplug net&squot; with certain&n; * environment variables set.&n; */
DECL|function|net_run_sbin_hotplug
r_static
r_int
id|net_run_sbin_hotplug
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_char
op_star
id|action
)paren
(brace
r_char
op_star
id|argv
(braket
l_int|3
)braket
comma
op_star
id|envp
(braket
l_int|5
)braket
comma
id|ifname
(braket
l_int|12
op_plus
id|IFNAMSIZ
)braket
comma
id|action_str
(braket
l_int|32
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|sprintf
c_func
(paren
id|ifname
comma
l_string|&quot;INTERFACE=%s&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|action_str
comma
l_string|&quot;ACTION=%s&quot;
comma
id|action
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|argv
(braket
id|i
op_increment
)braket
op_assign
id|hotplug_path
suffix:semicolon
id|argv
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;net&quot;
suffix:semicolon
id|argv
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* minimal command environment */
id|envp
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;HOME=/&quot;
suffix:semicolon
id|envp
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;
suffix:semicolon
id|envp
(braket
id|i
op_increment
)braket
op_assign
id|ifname
suffix:semicolon
id|envp
(braket
id|i
op_increment
)braket
op_assign
id|action_str
suffix:semicolon
id|envp
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|call_usermodehelper
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
id|argv
comma
id|envp
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
