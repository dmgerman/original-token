multiline_comment|/*&n; * &t;NET3&t;Protocol independent device support routines.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; *&t;Derived from the non IP parts of dev.c 1.0.19&n; * &t;&t;Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&n; *&t;Additional Authors:&n; *&t;&t;Florian la Roche &lt;rzsfl@rz.uni-sb.de&gt;&n; *&t;&t;Alan Cox &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;David Hinds &lt;dhinds@allegro.stanford.edu&gt;&n; *&n; *&t;Changes:&n; *&t;&t;Alan Cox&t;:&t;device private ioctl copies fields back.&n; *&t;&t;Alan Cox&t;:&t;Transmit queue code does relevant stunts to&n; *&t;&t;&t;&t;&t;keep the queue safe.&n; *&t;&t;Alan Cox&t;:&t;Fixed double lock.&n; *&t;&t;Alan Cox&t;:&t;Fixed promisc NULL pointer trap&n; *&t;&t;????????&t;:&t;Support the full private ioctl range&n; *&t;&t;Alan Cox&t;:&t;Moved ioctl permission check into drivers&n; *&t;&t;Tim Kordas&t;:&t;SIOCADDMULTI/SIOCDELMULTI&n; *&t;&t;Alan Cox&t;:&t;100 backlog just doesn&squot;t cut it when&n; *&t;&t;&t;&t;&t;you start doing multicast video 8)&n; *&t;&t;Alan Cox&t;:&t;Rewrote net_bh and list manager.&n; *&t;&t;Alan Cox&t;: &t;Fix ETH_P_ALL echoback lengths.&n; *&t;&t;Alan Cox&t;:&t;Took out transmit every packet pass&n; *&t;&t;&t;&t;&t;Saved a few bytes in the ioctl handler&n; *&t;&t;Alan Cox&t;:&t;Network driver sets packet type before calling netif_rx. Saves&n; *&t;&t;&t;&t;&t;a function call a packet.&n; *&t;&t;Alan Cox&t;:&t;Hashed net_bh()&n; *&t;&t;Richard Kooijman:&t;Timestamp fixes.&n; *&t;&t;Alan Cox&t;:&t;Wrong field in SIOCGIFDSTADDR&n; *&t;&t;Alan Cox&t;:&t;Device lock protection.&n; *&t;&t;Alan Cox&t;: &t;Fixed nasty side effect of device close changes.&n; *&t;&t;Rudi Cilibrasi&t;:&t;Pass the right thing to set_mac_address()&n; *&t;&t;Dave Miller&t;:&t;32bit quantity for the device lock to make it work out&n; *&t;&t;&t;&t;&t;on a Sparc.&n; *&n; */
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#ifdef CONFIG_NET_ALIAS
macro_line|#include &lt;linux/net_alias.h&gt;
macro_line|#endif
multiline_comment|/*&n; *&t;The list of packet types we will receive (as opposed to discard)&n; *&t;and the routines to invoke.&n; */
DECL|variable|ptype_base
r_struct
id|packet_type
op_star
id|ptype_base
(braket
l_int|16
)braket
suffix:semicolon
DECL|variable|ptype_all
r_struct
id|packet_type
op_star
id|ptype_all
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Taps */
multiline_comment|/*&n; *&t;Device list lock&n; */
DECL|variable|dev_lockct
r_int
id|dev_lockct
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; *&t;Our notifier list&n; */
DECL|variable|netdev_chain
r_struct
id|notifier_block
op_star
id|netdev_chain
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; *&t;Device drivers call our routines to queue packets here. We empty the&n; *&t;queue in the bottom half handler.&n; */
DECL|variable|backlog
r_static
r_struct
id|sk_buff_head
id|backlog
op_assign
(brace
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|backlog
comma
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|backlog
macro_line|#if CONFIG_SKB_CHECK
comma
id|SK_HEAD_SKB
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* &n; *&t;We don&squot;t overdo the queue or we will thrash memory badly.&n; */
DECL|variable|backlog_size
r_static
r_int
id|backlog_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; *&t;Return the lesser of the two values. &n; */
DECL|function|min
r_static
id|__inline__
r_int
r_int
id|min
c_func
(paren
r_int
r_int
id|a
comma
r_int
r_int
id|b
)paren
(brace
r_return
(paren
id|a
OL
id|b
)paren
ques
c_cond
id|a
suffix:colon
id|b
suffix:semicolon
)brace
multiline_comment|/******************************************************************************************&n;&n;&t;&t;Protocol management and registration routines&n;&n;*******************************************************************************************/
multiline_comment|/*&n; *&t;For efficiency&n; */
DECL|variable|dev_nit
r_static
r_int
id|dev_nit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; *&t;Add a protocol ID to the list. Now that the input handler is&n; *&t;smarter we can dispense with all the messy stuff that used to be&n; *&t;here.&n; */
DECL|function|dev_add_pack
r_void
id|dev_add_pack
c_func
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_int
id|hash
suffix:semicolon
r_if
c_cond
(paren
id|pt-&gt;type
op_eq
id|htons
c_func
(paren
id|ETH_P_ALL
)paren
)paren
(brace
id|dev_nit
op_increment
suffix:semicolon
id|pt-&gt;next
op_assign
id|ptype_all
suffix:semicolon
id|ptype_all
op_assign
id|pt
suffix:semicolon
)brace
r_else
(brace
id|hash
op_assign
id|ntohs
c_func
(paren
id|pt-&gt;type
)paren
op_amp
l_int|15
suffix:semicolon
id|pt-&gt;next
op_assign
id|ptype_base
(braket
id|hash
)braket
suffix:semicolon
id|ptype_base
(braket
id|hash
)braket
op_assign
id|pt
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Remove a protocol ID from the list.&n; */
DECL|function|dev_remove_pack
r_void
id|dev_remove_pack
c_func
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|packet_type
op_star
op_star
id|pt1
suffix:semicolon
r_if
c_cond
(paren
id|pt-&gt;type
op_eq
id|htons
c_func
(paren
id|ETH_P_ALL
)paren
)paren
(brace
id|dev_nit
op_decrement
suffix:semicolon
id|pt1
op_assign
op_amp
id|ptype_all
suffix:semicolon
)brace
r_else
id|pt1
op_assign
op_amp
id|ptype_base
(braket
id|ntohs
c_func
(paren
id|pt-&gt;type
)paren
op_amp
l_int|15
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
(paren
op_star
id|pt1
)paren
op_ne
l_int|NULL
suffix:semicolon
id|pt1
op_assign
op_amp
(paren
(paren
op_star
id|pt1
)paren
op_member_access_from_pointer
id|next
)paren
)paren
(brace
r_if
c_cond
(paren
id|pt
op_eq
(paren
op_star
id|pt1
)paren
)paren
(brace
op_star
id|pt1
op_assign
id|pt-&gt;next
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;dev_remove_pack: %p not found.&bslash;n&quot;
comma
id|pt
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************************&n;&n;&t;&t;&t;    Device Interface Subroutines&n;&n;******************************************************************************************/
multiline_comment|/* &n; *&t;Find an interface by name.&n; */
DECL|function|dev_get
r_struct
id|device
op_star
id|dev_get
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|dev-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
r_return
id|dev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Prepare an interface for use. &n; */
DECL|function|dev_open
r_int
id|dev_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Call device private open method&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;open
)paren
id|ret
op_assign
id|dev
op_member_access_from_pointer
id|open
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If it went open OK then set the flags&n;&t; */
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|dev-&gt;flags
op_or_assign
(paren
id|IFF_UP
op_or
id|IFF_RUNNING
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Initialise multicasting status &n;&t;&t; */
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_UP
comma
id|dev
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Completely shutdown an interface.&n; */
DECL|function|dev_close
r_int
id|dev_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Call the device specific close. This cannot fail.&n;&t; *&t;Only if device is UP&n;&t; */
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
op_logical_and
id|dev-&gt;stop
)paren
id|dev
op_member_access_from_pointer
id|stop
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Device is now down.&n;&t; */
id|dev-&gt;flags
op_and_assign
op_complement
(paren
id|IFF_UP
op_or
id|IFF_RUNNING
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Tell people we are going down&n;&t; */
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_DOWN
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Flush the multicast chain&n;&t; */
id|dev_mc_discard
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Blank the IP addresses&n;&t; */
id|dev-&gt;pa_addr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_dstaddr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_brdaddr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Purge any queued packets when we down the link &n;&t; */
r_while
c_loop
(paren
id|ct
OL
id|DEV_NUMBUFFS
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|dev-&gt;buffs
(braket
id|ct
)braket
)paren
)paren
op_ne
l_int|NULL
)paren
r_if
c_cond
(paren
id|skb-&gt;free
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
id|ct
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Device change register/unregister. These are not inline or static&n; *&t;as we export them to the world.&n; */
DECL|function|register_netdevice_notifier
r_int
id|register_netdevice_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_return
id|notifier_chain_register
c_func
(paren
op_amp
id|netdev_chain
comma
id|nb
)paren
suffix:semicolon
)brace
DECL|function|unregister_netdevice_notifier
r_int
id|unregister_netdevice_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_return
id|notifier_chain_unregister
c_func
(paren
op_amp
id|netdev_chain
comma
id|nb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send (or queue for sending) a packet. &n; *&n; *&t;IMPORTANT: When this is called to resend frames. The caller MUST&n; *&t;already have locked the sk_buff. Apart from that we do the&n; *&t;rest of the magic.&n; */
DECL|function|dev_queue_xmit
r_void
id|dev_queue_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_int
id|pri
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|packet_type
op_star
id|ptype
suffix:semicolon
r_int
id|where
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* used to say if the packet should go&t;*/
multiline_comment|/* at the front or the back of the&t;*/
multiline_comment|/* queue - front is a retransmit try&t;*/
r_if
c_cond
(paren
id|pri
op_ge
l_int|0
op_logical_and
op_logical_neg
id|skb_device_locked
c_func
(paren
id|skb
)paren
)paren
(brace
id|skb_device_lock
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* Shove a lock on the frame */
macro_line|#if CONFIG_SKB_CHECK 
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif    
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Negative priority is used to flag a frame that is being pulled from the&n;&t; *&t;queue front as a retransmit attempt. It therefore goes back on the queue&n;&t; *&t;start on a failure.&n;&t; */
r_if
c_cond
(paren
id|pri
OL
l_int|0
)paren
(brace
id|pri
op_assign
op_minus
id|pri
op_minus
l_int|1
suffix:semicolon
id|where
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_DEBUG
r_if
c_cond
(paren
id|pri
op_ge
id|DEV_NUMBUFFS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bad priority in dev_queue_xmit.&bslash;n&quot;
)paren
suffix:semicolon
id|pri
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *&t;If the address has not been resolved. Call the device header rebuilder.&n;&t; *&t;This can cover all protocols and technically not just ARP either.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;arp
op_logical_and
id|dev
op_member_access_from_pointer
id|rebuild_header
c_func
(paren
id|skb-&gt;data
comma
id|dev
comma
id|skb-&gt;raddr
comma
id|skb
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&n;&t; * &t;If dev is an alias, switch to its main device.&n;&t; *&t;&quot;arp&quot; resolution has been made with alias device, so&n;&t; *&t;arp entries refer to alias, not main.&n;&t; *&n;&t; */
macro_line|#ifdef CONFIG_NET_ALIAS
r_if
c_cond
(paren
id|net_alias_is
c_func
(paren
id|dev
)paren
)paren
id|skb-&gt;dev
op_assign
id|dev
op_assign
id|net_alias_main_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|where
)paren
multiline_comment|/* Always keep order. It helps other hosts&n;&t;&t;&t;&t;&t;   far more than it costs us */
(brace
id|skb_queue_tail
c_func
(paren
id|dev-&gt;buffs
op_plus
id|pri
comma
id|skb
)paren
suffix:semicolon
id|skb_device_unlock
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Buffer is on the device queue and can be freed safely */
id|skb
op_assign
id|skb_dequeue
c_func
(paren
id|dev-&gt;buffs
op_plus
id|pri
)paren
suffix:semicolon
id|skb_device_lock
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* New buffer needs locking down */
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* copy outgoing packets to any sniffer packet handlers */
r_if
c_cond
(paren
op_logical_neg
id|where
op_logical_and
id|dev_nit
)paren
(brace
id|skb-&gt;stamp
op_assign
id|xtime
suffix:semicolon
r_for
c_loop
(paren
id|ptype
op_assign
id|ptype_all
suffix:semicolon
id|ptype
op_ne
l_int|NULL
suffix:semicolon
id|ptype
op_assign
id|ptype-&gt;next
)paren
(brace
multiline_comment|/* Never send packets back to the socket&n;&t;&t;&t; * they originated from - MvS (miquels@drinkel.ow.org)&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|ptype-&gt;dev
op_eq
id|dev
op_logical_or
op_logical_neg
id|ptype-&gt;dev
)paren
op_logical_and
(paren
(paren
r_struct
id|sock
op_star
)paren
id|ptype-&gt;data
op_ne
id|skb-&gt;sk
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|skb2-&gt;h.raw
op_assign
id|skb2-&gt;data
op_plus
id|dev-&gt;hard_header_len
suffix:semicolon
id|skb2-&gt;mac.raw
op_assign
id|skb2-&gt;data
suffix:semicolon
id|ptype
op_member_access_from_pointer
id|func
c_func
(paren
id|skb2
comma
id|skb-&gt;dev
comma
id|ptype
)paren
suffix:semicolon
)brace
)brace
)brace
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|hard_start_xmit
c_func
(paren
id|skb
comma
id|dev
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Packet is now solely the responsibility of the driver&n;&t;&t; */
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Transmission failed, put skb back into a list. Once on the list it&squot;s safe and&n;&t; *&t;no longer device locked (it can be freed safely from the device queue)&n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb_device_unlock
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
id|dev-&gt;buffs
op_plus
id|pri
comma
id|skb
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Receive a packet from a device driver and queue it for the upper&n; *&t;(protocol) levels.  It always succeeds. This is the recommended &n; *&t;interface to use.&n; */
DECL|function|netif_rx
r_void
id|netif_rx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_static
r_int
id|dropping
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Any received buffers are un-owned and should be discarded&n;&t; *&t;when freed. These will be updated later as the frames get&n;&t; *&t;owners.&n;&t; */
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;stamp.tv_sec
op_eq
l_int|0
)paren
(brace
id|skb-&gt;stamp
op_assign
id|xtime
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Check that we aren&squot;t overdoing things.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|backlog_size
)paren
id|dropping
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|backlog_size
OG
l_int|300
)paren
id|dropping
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dropping
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Add it to the &quot;backlog&quot; queue. &n;&t; */
macro_line|#if CONFIG_SKB_CHECK
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif&t;
id|skb_queue_tail
c_func
(paren
op_amp
id|backlog
comma
id|skb
)paren
suffix:semicolon
id|backlog_size
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If any packet arrived, mark it for processing after the&n;&t; *&t;hardware interrupt returns.&n;&t; */
macro_line|#ifdef CONFIG_NET_RUNONIRQ&t;/* Dont enable yet, needs some driver mods */
id|net_bh
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The old interface to fetch a packet from a device driver.&n; *&t;This function is the base level entry point for all drivers that&n; *&t;want to send a packet to the upper (protocol) levels.  It takes&n; *&t;care of de-multiplexing the packet to the various modules based&n; *&t;on their protocol ID.&n; *&n; *&t;Return values:&t;1 &lt;- exit I can&squot;t do any more&n; *&t;&t;&t;0 &lt;- feed me more (i.e. &quot;done&quot;, &quot;OK&quot;). &n; *&n; *&t;This function is OBSOLETE and should not be used by any new&n; *&t;device.&n; */
DECL|function|dev_rint
r_int
id|dev_rint
c_func
(paren
r_int
r_char
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|flags
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_static
r_int
id|dropping
op_assign
l_int|0
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|to
suffix:semicolon
r_int
id|amount
comma
id|left
suffix:semicolon
r_int
id|len2
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
op_logical_or
id|buff
op_eq
l_int|NULL
op_logical_or
id|len
op_le
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|IN_SKBUFF
)paren
(brace
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|buff
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dropping
)paren
(brace
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|backlog
)paren
op_ne
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;INET: dev_rint: no longer dropping packets.&bslash;n&quot;
)paren
suffix:semicolon
id|dropping
op_assign
l_int|0
suffix:semicolon
)brace
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;dev_rint: packet dropped on %s (no memory) !&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|dropping
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; *&t;First we copy the packet into a buffer, and save it for later. We&n;&t;&t; *&t;in effect handle the incoming data as if it were from a circular buffer&n;&t;&t; */
id|to
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
id|left
op_assign
id|len
suffix:semicolon
id|len2
op_assign
id|len
suffix:semicolon
r_while
c_loop
(paren
id|len2
OG
l_int|0
)paren
(brace
id|amount
op_assign
id|min
c_func
(paren
id|len2
comma
(paren
r_int
r_int
)paren
id|dev-&gt;rmem_end
op_minus
(paren
r_int
r_int
)paren
id|buff
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|to
comma
id|buff
comma
id|amount
)paren
suffix:semicolon
id|len2
op_sub_assign
id|amount
suffix:semicolon
id|left
op_sub_assign
id|amount
suffix:semicolon
id|buff
op_add_assign
id|amount
suffix:semicolon
id|to
op_add_assign
id|amount
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|buff
op_eq
id|dev-&gt;rmem_end
)paren
id|buff
op_assign
(paren
r_int
r_char
op_star
)paren
id|dev-&gt;rmem_start
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Tag the frame and kick it to the proper receive routine&n;&t; */
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;OK, all done. &n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine causes all interfaces to try to send some data. &n; */
DECL|function|dev_transmit
r_void
id|dev_transmit
c_func
(paren
r_void
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_ne
l_int|0
op_logical_and
op_logical_neg
id|dev-&gt;tbusy
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Kick the device&n;&t;&t;&t; */
id|dev_tint
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**********************************************************************************&n;&n;&t;&t;&t;Receive Queue Processor&n;&t;&t;&t;&n;***********************************************************************************/
multiline_comment|/*&n; *&t;This is a single non-reentrant routine which takes the received packet&n; *&t;queue and throws it at the networking layers in the hope that something&n; *&t;useful will emerge.&n; */
DECL|variable|in_bh
r_volatile
r_int
r_int
id|in_bh
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Non-reentrant remember */
DECL|function|in_net_bh
r_int
id|in_net_bh
c_func
(paren
)paren
multiline_comment|/* Used by timer.c */
(brace
r_return
id|in_bh
op_eq
l_int|0
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;When we are called the queue is ready to grab, the interrupts are&n; *&t;on and hardware can interrupt and queue to the receive queue a we&n; *&t;run with no problems.&n; *&t;This is run as a bottom half after an interrupt handler that does&n; *&t;mark_bh(NET_BH);&n; */
DECL|function|net_bh
r_void
id|net_bh
c_func
(paren
r_void
op_star
id|tmp
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|packet_type
op_star
id|ptype
suffix:semicolon
r_struct
id|packet_type
op_star
id|pt_prev
suffix:semicolon
r_int
r_int
id|type
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Atomically check and mark our BUSY state. &n;&t; */
r_if
c_cond
(paren
id|set_bit
c_func
(paren
l_int|1
comma
(paren
r_void
op_star
)paren
op_amp
id|in_bh
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Can we send anything now? We want to clear the&n;&t; *&t;decks for any more sends that get done as we&n;&t; *&t;process the input. This also minimises the&n;&t; *&t;latency on a transmit interrupt bh.&n;&t; */
id|dev_transmit
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Any data left to process. This may occur because a&n;&t; *&t;mark_bh() is done after we empty the queue including&n;&t; *&t;that from the device which does a mark_bh() just after&n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;While the queue is not empty&n;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|backlog
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;We have a packet. Therefore the queue has shrunk&n;&t;&t; */
id|backlog_size
op_decrement
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;*&t;Bump the pointer to the next structure.&n;&t;&t;*&n;&t;&t;*&t;On entry to the protocol layer. skb-&gt;data and&n;&t;&t;*&t;skb-&gt;h.raw point to the MAC and encapsulated data&n;&t;&t;*/
id|skb-&gt;h.raw
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t;&t;* &t;Fetch the packet protocol ID. &n;&t;&t;*/
id|type
op_assign
id|skb-&gt;protocol
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;We got a packet ID.  Now loop over the &quot;known protocols&quot;&n;&t;&t; * &t;list. There are two lists. The ptype_all list of taps (normally empty)&n;&t;&t; *&t;and the main protocol list which is hashed perfectly for normal protocols.&n;&t;&t; */
id|pt_prev
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|ptype
op_assign
id|ptype_all
suffix:semicolon
id|ptype
op_ne
l_int|NULL
suffix:semicolon
id|ptype
op_assign
id|ptype-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|pt_prev
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb2
)paren
(brace
id|pt_prev
op_member_access_from_pointer
id|func
c_func
(paren
id|skb2
comma
id|skb-&gt;dev
comma
id|pt_prev
)paren
suffix:semicolon
)brace
)brace
id|pt_prev
op_assign
id|ptype
suffix:semicolon
)brace
r_for
c_loop
(paren
id|ptype
op_assign
id|ptype_base
(braket
id|ntohs
c_func
(paren
id|type
)paren
op_amp
l_int|15
)braket
suffix:semicolon
id|ptype
op_ne
l_int|NULL
suffix:semicolon
id|ptype
op_assign
id|ptype-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ptype-&gt;type
op_eq
id|type
op_logical_and
(paren
op_logical_neg
id|ptype-&gt;dev
op_logical_or
id|ptype-&gt;dev
op_eq
id|skb-&gt;dev
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;We already have a match queued. Deliver&n;&t;&t;&t;&t; *&t;to it and then remember the new match&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|pt_prev
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;Kick the protocol handler. This should be fast&n;&t;&t;&t;&t;&t; *&t;and efficient code.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|skb2
)paren
(brace
id|pt_prev
op_member_access_from_pointer
id|func
c_func
(paren
id|skb2
comma
id|skb-&gt;dev
comma
id|pt_prev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Remember the current last to do */
id|pt_prev
op_assign
id|ptype
suffix:semicolon
)brace
)brace
multiline_comment|/* End of protocol list loop */
multiline_comment|/*&n;&t;&t; *&t;Is there a last item to send to ?&n;&t;&t; */
r_if
c_cond
(paren
id|pt_prev
)paren
(brace
id|pt_prev
op_member_access_from_pointer
id|func
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
id|pt_prev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * &t;Has an unknown packet has been received ?&n;&t;&t; */
r_else
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Again, see if we can transmit anything now. &n;&t;&t; *&t;[Ought to take this out judging by tests it slows&n;&t;&t; *&t; us down not speeds us up]&n;&t;&t; */
macro_line|#ifdef CONFIG_XMIT_EVERY
id|dev_transmit
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif&t;&t;
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* End of queue loop */
multiline_comment|/*&n;  &t; *&t;We have emptied the queue&n;  &t; */
id|in_bh
op_assign
l_int|0
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;One last output flush.&n;&t; */
id|dev_transmit
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine is called when an device driver (i.e. an&n; *&t;interface) is ready to transmit a packet.&n; */
DECL|function|dev_tint
r_void
id|dev_tint
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * aliases do not trasmit (by now :)&n;&t; */
macro_line|#ifdef CONFIG_NET_ALIAS
r_if
c_cond
(paren
id|net_alias_is
c_func
(paren
id|dev
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Work the queues in priority order&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_NUMBUFFS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Pull packets from the queue&n;&t;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|dev-&gt;buffs
(braket
id|i
)braket
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Stop anyone freeing the buffer while we retransmit it&n;&t;&t;&t; */
id|skb_device_lock
c_func
(paren
id|skb
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Feed them to the output stage and if it fails&n;&t;&t;&t; *&t;indicate they re-queue at the front.&n;&t;&t;&t; */
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
op_minus
id|i
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;If we can take no more then stop here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
r_return
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Perform a SIOCGIFCONF call. This structure will change&n; *&t;size shortly, and there is nothing I can do about it.&n; *&t;Thus we will need a &squot;compatibility mode&squot;.&n; */
DECL|function|dev_ifconf
r_static
r_int
id|dev_ifconf
c_func
(paren
r_char
op_star
id|arg
)paren
(brace
r_struct
id|ifconf
id|ifc
suffix:semicolon
r_struct
id|ifreq
id|ifr
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_char
op_star
id|pos
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fetch the caller&squot;s info block. &n;&t; */
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifconf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|ifc
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifconf
)paren
)paren
suffix:semicolon
id|len
op_assign
id|ifc.ifc_len
suffix:semicolon
id|pos
op_assign
id|ifc.ifc_buf
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We now walk the device list filling each active device&n;&t; *&t;into the array.&n;&t; */
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|pos
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Loop over the interfaces, and write an info block for each. &n;&t; */
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
(brace
multiline_comment|/* Downed devices don&squot;t count */
r_continue
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|ifr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|ifr.ifr_name
comma
id|dev-&gt;name
)paren
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_addr.s_addr
op_assign
id|dev-&gt;pa_addr
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Have we run out of space here ?&n;&t;&t; */
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Write this block to the caller&squot;s space. &n;&t;&t; */
id|memcpy_tofs
c_func
(paren
id|pos
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|pos
op_add_assign
r_sizeof
(paren
r_struct
id|ifreq
)paren
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
r_struct
id|ifreq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;All done.  Write the updated control block back to the caller. &n;&t; */
id|ifc.ifc_len
op_assign
(paren
id|pos
op_minus
id|ifc.ifc_buf
)paren
suffix:semicolon
id|ifc.ifc_req
op_assign
(paren
r_struct
id|ifreq
op_star
)paren
id|ifc.ifc_buf
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifc
comma
r_sizeof
(paren
r_struct
id|ifconf
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Report how much was filled in&n;&t; */
r_return
id|pos
op_minus
id|arg
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is invoked by the /proc filesystem handler to display a device&n; *&t;in detail.&n; */
DECL|function|sprintf_stats
r_static
r_int
id|sprintf_stats
c_func
(paren
r_char
op_star
id|buffer
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|enet_statistics
op_star
id|stats
op_assign
(paren
id|dev-&gt;get_stats
ques
c_cond
id|dev
op_member_access_from_pointer
id|get_stats
c_func
(paren
id|dev
)paren
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|stats
)paren
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%6s:%7d %4d %4d %4d %4d %8d %4d %4d %4d %5d %4d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|stats-&gt;rx_packets
comma
id|stats-&gt;rx_errors
comma
id|stats-&gt;rx_dropped
op_plus
id|stats-&gt;rx_missed_errors
comma
id|stats-&gt;rx_fifo_errors
comma
id|stats-&gt;rx_length_errors
op_plus
id|stats-&gt;rx_over_errors
op_plus
id|stats-&gt;rx_crc_errors
op_plus
id|stats-&gt;rx_frame_errors
comma
id|stats-&gt;tx_packets
comma
id|stats-&gt;tx_errors
comma
id|stats-&gt;tx_dropped
comma
id|stats-&gt;tx_fifo_errors
comma
id|stats-&gt;collisions
comma
id|stats-&gt;tx_carrier_errors
op_plus
id|stats-&gt;tx_aborted_errors
op_plus
id|stats-&gt;tx_window_errors
op_plus
id|stats-&gt;tx_heartbeat_errors
)paren
suffix:semicolon
r_else
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%6s: No statistics available.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Called from the PROCfs module. This now uses the new arbitrary sized /proc/net interface&n; *&t;to create /proc/net/dev&n; */
DECL|function|dev_get_info
r_int
id|dev_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|dummy
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|size
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;Inter-|   Receive                  |  Transmit&bslash;n&quot;
l_string|&quot; face |packets errs drop fifo frame|packets errs drop fifo colls carrier&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
id|size
op_assign
id|sprintf_stats
c_func
(paren
id|buffer
op_plus
id|len
comma
id|dev
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start slop */
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
multiline_comment|/* Ending slop */
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This checks bitmasks for the ioctl calls for devices.&n; */
DECL|function|bad_mask
r_static
r_inline
r_int
id|bad_mask
c_func
(paren
r_int
r_int
id|mask
comma
r_int
r_int
id|addr
)paren
(brace
r_if
c_cond
(paren
id|addr
op_amp
(paren
id|mask
op_assign
op_complement
id|mask
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|mask
op_assign
id|ntohl
c_func
(paren
id|mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
(paren
id|mask
op_plus
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Perform the SIOCxIFxxx calls. &n; *&n; *&t;The socket layer has seen an ioctl the address family thinks is&n; *&t;for the device. At this point we get invoked to make a decision&n; */
DECL|function|dev_ifsioc
r_static
r_int
id|dev_ifsioc
c_func
(paren
r_void
op_star
id|arg
comma
r_int
r_int
id|getset
)paren
(brace
r_struct
id|ifreq
id|ifr
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fetch the caller&squot;s info block into kernel space&n;&t; */
r_int
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|ifr
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;See which interface the caller is talking about. &n;&t; */
multiline_comment|/*&n;&t; *&n;&t; *&t;net_alias_dev_get(): dev_get() with added alias naming magic.&n;&t; *&t;only allow alias creation/deletion if (getset==SIOCSIFADDR)&n;&t; *&n;&t; */
macro_line|#ifdef CONFIG_NET_ALIAS
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|net_alias_dev_get
c_func
(paren
id|ifr.ifr_name
comma
id|getset
op_eq
id|SIOCSIFADDR
comma
op_amp
id|err
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
id|err
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|dev_get
c_func
(paren
id|ifr.ifr_name
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|getset
)paren
(brace
r_case
id|SIOCGIFFLAGS
suffix:colon
multiline_comment|/* Get interface flags */
id|ifr.ifr_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
r_goto
id|rarok
suffix:semicolon
r_case
id|SIOCSIFFLAGS
suffix:colon
multiline_comment|/* Set interface flags */
(brace
r_int
id|old_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;We are not allowed to potentially close/unload&n;&t;&t;&t;&t; *&t;a device until we get this lock.&n;&t;&t;&t;&t; */
id|dev_lock_wait
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Set the flags on our device.&n;&t;&t;&t;&t; */
id|dev-&gt;flags
op_assign
(paren
id|ifr.ifr_flags
op_amp
(paren
id|IFF_BROADCAST
op_or
id|IFF_DEBUG
op_or
id|IFF_LOOPBACK
op_or
id|IFF_POINTOPOINT
op_or
id|IFF_NOTRAILERS
op_or
id|IFF_RUNNING
op_or
id|IFF_NOARP
op_or
id|IFF_PROMISC
op_or
id|IFF_ALLMULTI
op_or
id|IFF_SLAVE
op_or
id|IFF_MASTER
op_or
id|IFF_MULTICAST
)paren
)paren
op_or
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Load in the correct multicast list now the flags have changed.&n;&t;&t;&t;&t; */
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;  &t; *&t;Have we downed the interface. We handle IFF_UP ourselves&n;&t;&t;&t;  &t; *&t;according to user attempts to set it, rather than blindly&n;&t;&t;&t;  &t; *&t;setting it.&n;&t;&t;&t;  &t; */
r_if
c_cond
(paren
(paren
id|old_flags
op_xor
id|ifr.ifr_flags
)paren
op_amp
id|IFF_UP
)paren
multiline_comment|/* Bit is different  ? */
(brace
r_if
c_cond
(paren
id|old_flags
op_amp
id|IFF_UP
)paren
(brace
multiline_comment|/* Gone down */
id|ret
op_assign
id|dev_close
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Come up */
(brace
id|ret
op_assign
id|dev_open
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|dev-&gt;flags
op_and_assign
op_complement
id|IFF_UP
suffix:semicolon
)brace
multiline_comment|/* Open failed */
)brace
)brace
r_else
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Load in the correct multicast list now the flags have changed.&n;&t;&t;&t;&t; */
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIOCGIFADDR
suffix:colon
multiline_comment|/* Get interface address (and family) */
r_if
c_cond
(paren
id|ifr.ifr_addr.sa_family
op_eq
id|AF_UNSPEC
)paren
(brace
id|memcpy
c_func
(paren
id|ifr.ifr_hwaddr.sa_data
comma
id|dev-&gt;dev_addr
comma
id|MAX_ADDR_LEN
)paren
suffix:semicolon
id|ifr.ifr_hwaddr.sa_family
op_assign
id|dev-&gt;type
suffix:semicolon
r_goto
id|rarok
suffix:semicolon
)brace
r_else
(brace
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_addr.s_addr
op_assign
id|dev-&gt;pa_addr
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_port
op_assign
l_int|0
suffix:semicolon
)brace
r_goto
id|rarok
suffix:semicolon
r_case
id|SIOCSIFADDR
suffix:colon
multiline_comment|/* Set interface address (and family) */
multiline_comment|/*&n;&t;&t;&t; *&t;BSDism. SIOCSIFADDR family=AF_UNSPEC sets the&n;&t;&t;&t; *&t;physical address. We can cope with this now.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ifr.ifr_addr.sa_family
op_eq
id|AF_UNSPEC
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;set_mac_address
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
id|ret
op_assign
id|dev
op_member_access_from_pointer
id|set_mac_address
c_func
(paren
id|dev
comma
op_amp
id|ifr.ifr_addr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;if dev is an alias, must rehash to update&n;&t;&t;&t;&t; *&t;address change&n;&t;&t;&t;&t; */
macro_line|#ifdef CONFIG_NET_ALIAS
r_if
c_cond
(paren
id|net_alias_is
c_func
(paren
id|dev
)paren
)paren
id|net_alias_dev_rehash
c_func
(paren
id|dev
comma
op_amp
id|ifr.ifr_addr
)paren
suffix:semicolon
macro_line|#endif
id|dev-&gt;pa_addr
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_addr.s_addr
suffix:semicolon
id|dev-&gt;family
op_assign
id|ifr.ifr_addr.sa_family
suffix:semicolon
macro_line|#ifdef CONFIG_INET&t;
multiline_comment|/* This is naughty. When net-032e comes out It wants moving into the net032&n;&t;&t;&t;&t;   code not the kernel. Till then it can sit here (SIGH) */
id|dev-&gt;pa_mask
op_assign
id|ip_get_mask
c_func
(paren
id|dev-&gt;pa_addr
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;
id|dev-&gt;pa_brdaddr
op_assign
id|dev-&gt;pa_addr
op_or
op_complement
id|dev-&gt;pa_mask
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIOCGIFBRDADDR
suffix:colon
multiline_comment|/* Get the broadcast address */
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_broadaddr.sin_addr.s_addr
op_assign
id|dev-&gt;pa_brdaddr
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_broadaddr.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_broadaddr.sin_port
op_assign
l_int|0
suffix:semicolon
r_goto
id|rarok
suffix:semicolon
r_case
id|SIOCSIFBRDADDR
suffix:colon
multiline_comment|/* Set the broadcast address */
id|dev-&gt;pa_brdaddr
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_broadaddr.sin_addr.s_addr
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFDSTADDR
suffix:colon
multiline_comment|/* Get the destination address (for point-to-point links) */
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_dstaddr.sin_addr.s_addr
op_assign
id|dev-&gt;pa_dstaddr
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_dstaddr.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_dstaddr.sin_port
op_assign
l_int|0
suffix:semicolon
r_goto
id|rarok
suffix:semicolon
r_case
id|SIOCSIFDSTADDR
suffix:colon
multiline_comment|/* Set the destination address (for point-to-point links) */
id|dev-&gt;pa_dstaddr
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_dstaddr.sin_addr.s_addr
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFNETMASK
suffix:colon
multiline_comment|/* Get the netmask for the interface */
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_netmask.sin_addr.s_addr
op_assign
id|dev-&gt;pa_mask
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_netmask.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_netmask.sin_port
op_assign
l_int|0
suffix:semicolon
r_goto
id|rarok
suffix:semicolon
r_case
id|SIOCSIFNETMASK
suffix:colon
multiline_comment|/* Set the netmask for the interface */
(brace
r_int
r_int
id|mask
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_netmask.sin_addr.s_addr
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;The mask we set must be legal.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|bad_mask
c_func
(paren
id|mask
comma
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|dev-&gt;pa_mask
op_assign
id|mask
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIOCGIFMETRIC
suffix:colon
multiline_comment|/* Get the metric on the interface (currently unused) */
id|ifr.ifr_metric
op_assign
id|dev-&gt;metric
suffix:semicolon
r_goto
id|rarok
suffix:semicolon
r_case
id|SIOCSIFMETRIC
suffix:colon
multiline_comment|/* Set the metric on the interface (currently unused) */
id|dev-&gt;metric
op_assign
id|ifr.ifr_metric
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFMTU
suffix:colon
multiline_comment|/* Get the MTU of a device */
id|ifr.ifr_mtu
op_assign
id|dev-&gt;mtu
suffix:semicolon
r_goto
id|rarok
suffix:semicolon
r_case
id|SIOCSIFMTU
suffix:colon
multiline_comment|/* Set the MTU of a device */
multiline_comment|/*&n;&t;&t;&t; *&t;MTU must be positive.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ifr.ifr_mtu
OL
l_int|68
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev-&gt;mtu
op_assign
id|ifr.ifr_mtu
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFMEM
suffix:colon
multiline_comment|/* Get the per device memory space. We can add this but currently&n;&t;&t;&t;&t;&t;   do not support it */
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFMEM
suffix:colon
multiline_comment|/* Set the per device memory buffer space. Not applicable in our case */
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFHWADDR
suffix:colon
id|memcpy
c_func
(paren
id|ifr.ifr_hwaddr.sa_data
comma
id|dev-&gt;dev_addr
comma
id|MAX_ADDR_LEN
)paren
suffix:semicolon
id|ifr.ifr_hwaddr.sa_family
op_assign
id|dev-&gt;type
suffix:semicolon
r_goto
id|rarok
suffix:semicolon
r_case
id|SIOCSIFHWADDR
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_mac_address
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ifr.ifr_hwaddr.sa_family
op_ne
id|dev-&gt;type
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ret
op_assign
id|dev
op_member_access_from_pointer
id|set_mac_address
c_func
(paren
id|dev
comma
op_amp
id|ifr.ifr_hwaddr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFMAP
suffix:colon
id|ifr.ifr_map.mem_start
op_assign
id|dev-&gt;mem_start
suffix:semicolon
id|ifr.ifr_map.mem_end
op_assign
id|dev-&gt;mem_end
suffix:semicolon
id|ifr.ifr_map.base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|ifr.ifr_map.irq
op_assign
id|dev-&gt;irq
suffix:semicolon
id|ifr.ifr_map.dma
op_assign
id|dev-&gt;dma
suffix:semicolon
id|ifr.ifr_map.port
op_assign
id|dev-&gt;if_port
suffix:semicolon
r_goto
id|rarok
suffix:semicolon
r_case
id|SIOCSIFMAP
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_config
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_return
id|dev
op_member_access_from_pointer
id|set_config
c_func
(paren
id|dev
comma
op_amp
id|ifr.ifr_map
)paren
suffix:semicolon
r_case
id|SIOCADDMULTI
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_multicast_list
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ifr.ifr_hwaddr.sa_family
op_ne
id|AF_UNSPEC
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev_mc_add
c_func
(paren
id|dev
comma
id|ifr.ifr_hwaddr.sa_data
comma
id|dev-&gt;addr_len
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCDELMULTI
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_multicast_list
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ifr.ifr_hwaddr.sa_family
op_ne
id|AF_UNSPEC
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev_mc_delete
c_func
(paren
id|dev
comma
id|ifr.ifr_hwaddr.sa_data
comma
id|dev-&gt;addr_len
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Unknown or private ioctl&n;&t;&t; */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
(paren
id|getset
op_ge
id|SIOCDEVPRIVATE
)paren
op_logical_and
(paren
id|getset
op_le
(paren
id|SIOCDEVPRIVATE
op_plus
l_int|15
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;do_ioctl
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
id|ret
op_assign
id|dev
op_member_access_from_pointer
id|do_ioctl
c_func
(paren
id|dev
comma
op_amp
id|ifr
comma
id|getset
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
multiline_comment|/*&n; *&t;The load of calls that return an ifreq and ok (saves memory).&n; */
id|rarok
suffix:colon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This function handles all &quot;interface&quot;-type I/O control requests. The actual&n; *&t;&squot;doing&squot; part of this is dev_ifsioc above.&n; */
DECL|function|dev_ioctl
r_int
id|dev_ioctl
c_func
(paren
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCGIFCONF
suffix:colon
(paren
r_void
)paren
id|dev_ifconf
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Ioctl calls that can be done by all.&n;&t;&t; */
r_case
id|SIOCGIFFLAGS
suffix:colon
r_case
id|SIOCGIFADDR
suffix:colon
r_case
id|SIOCGIFDSTADDR
suffix:colon
r_case
id|SIOCGIFBRDADDR
suffix:colon
r_case
id|SIOCGIFNETMASK
suffix:colon
r_case
id|SIOCGIFMETRIC
suffix:colon
r_case
id|SIOCGIFMTU
suffix:colon
r_case
id|SIOCGIFMEM
suffix:colon
r_case
id|SIOCGIFHWADDR
suffix:colon
r_case
id|SIOCSIFHWADDR
suffix:colon
r_case
id|SIOCGIFSLAVE
suffix:colon
r_case
id|SIOCGIFMAP
suffix:colon
r_return
id|dev_ifsioc
c_func
(paren
id|arg
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Ioctl calls requiring the power of a superuser&n;&t;&t; */
r_case
id|SIOCSIFFLAGS
suffix:colon
r_case
id|SIOCSIFADDR
suffix:colon
r_case
id|SIOCSIFDSTADDR
suffix:colon
r_case
id|SIOCSIFBRDADDR
suffix:colon
r_case
id|SIOCSIFNETMASK
suffix:colon
r_case
id|SIOCSIFMETRIC
suffix:colon
r_case
id|SIOCSIFMTU
suffix:colon
r_case
id|SIOCSIFMEM
suffix:colon
r_case
id|SIOCSIFMAP
suffix:colon
r_case
id|SIOCSIFSLAVE
suffix:colon
r_case
id|SIOCADDMULTI
suffix:colon
r_case
id|SIOCDELMULTI
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_return
id|dev_ifsioc
c_func
(paren
id|arg
comma
id|cmd
)paren
suffix:semicolon
r_case
id|SIOCSIFLINK
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Unknown or private ioctl.&n;&t;&t; */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
(paren
id|cmd
op_ge
id|SIOCDEVPRIVATE
)paren
op_logical_and
(paren
id|cmd
op_le
(paren
id|SIOCDEVPRIVATE
op_plus
l_int|15
)paren
)paren
)paren
(brace
r_return
id|dev_ifsioc
c_func
(paren
id|arg
comma
id|cmd
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Initialize the DEV module. At boot time this walks the device list and&n; *&t;unhooks any devices that fail to initialise (normally hardware not &n; *&t;present) and leaves us with a valid list of present and active devices.&n; *&n; */
r_extern
r_int
id|lance_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|pi_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|dec21040_init
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|net_dev_init
r_int
id|net_dev_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|device
op_star
id|dev
comma
op_star
op_star
id|dp
suffix:semicolon
multiline_comment|/*&n;&t; * This is VeryUgly(tm).&n;&t; *&n;&t; * Some devices want to be initialized eary..&n;&t; */
macro_line|#if defined(CONFIG_LANCE)
id|lance_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_PI)
id|pi_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif&t;
macro_line|#if defined(CONFIG_PT)
id|pt_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_DEC_ELCP)
id|dec21040_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif&t;
multiline_comment|/*&n;&t; *&t;Add the devices.&n;&t; *&t;If the call to dev-&gt;init fails, the dev is removed&n;&t; *&t;from the chain disconnecting the device until the&n;&t; *&t;next reboot.&n;&t; */
id|dp
op_assign
op_amp
id|dev_base
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dev
op_assign
op_star
id|dp
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_NUMBUFFS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|skb_queue_head_init
c_func
(paren
id|dev-&gt;buffs
op_plus
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;init
op_logical_and
id|dev
op_member_access_from_pointer
id|init
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;It failed to come up. Unhook it.&n;&t;&t;&t; */
op_star
id|dp
op_assign
id|dev-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|dp
op_assign
op_amp
id|dev-&gt;next
suffix:semicolon
)brace
)brace
id|proc_net_register
c_func
(paren
op_amp
(paren
r_struct
id|proc_dir_entry
)paren
(brace
id|PROC_NET_DEV
comma
l_int|3
comma
l_string|&quot;dev&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_amp
id|proc_net_inode_operations
comma
id|dev_get_info
)brace
)paren
suffix:semicolon
multiline_comment|/*&t;&n;&t; *&t;Initialise net_alias engine &n;&t; *&n;&t; *&t;&t;- register net_alias device notifier&n;&t; *&t;&t;- register proc entries:&t;/proc/net/alias_types&n;&t; *&t;&t;&t;&t;&t;&t;&t;&t;&t;/proc/net/aliases&n;&t; */
macro_line|#ifdef CONFIG_NET_ALIAS
id|net_alias_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|bh_base
(braket
id|NET_BH
)braket
dot
id|routine
op_assign
id|net_bh
suffix:semicolon
id|enable_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
