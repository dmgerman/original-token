multiline_comment|/*&n; * &t;NET3&t;Protocol independent device support routines.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; *&t;Derived from the non IP parts of dev.c 1.0.19&n; * &t;&t;Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&n; *&t;Additional Authors:&n; *&t;&t;Florian la Roche &lt;rzsfl@rz.uni-sb.de&gt;&n; *&t;&t;Alan Cox &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;David Hinds &lt;dhinds@allegro.stanford.edu&gt;&n; *&n; *&t;Changes:&n; *&t;&t;Alan Cox&t;:&t;device private ioctl copies fields back.&n; *&t;&t;Alan Cox&t;:&t;Transmit queue code does relevant stunts to&n; *&t;&t;&t;&t;&t;keep the queue safe.&n; *&t;&t;Alan Cox&t;:&t;Fixed double lock.&n; *&t;&t;Alan Cox&t;:&t;Fixed promisc NULL pointer trap&n; *&t;&t;????????&t;:&t;Support the full private ioctl range&n; *&t;&t;Alan Cox&t;:&t;Moved ioctl permission check into drivers&n; *&t;&t;Tim Kordas&t;:&t;SIOCADDMULTI/SIOCDELMULTI&n; *&t;&t;Alan Cox&t;:&t;100 backlog just doesn&squot;t cut it when&n; *&t;&t;&t;&t;&t;you start doing multicast video 8)&n; *&t;&t;Alan Cox&t;:&t;Rewrote net_bh and list manager.&n; *&t;&t;Alan Cox&t;: &t;Fix ETH_P_ALL echoback lengths.&n; *&t;&t;Alan Cox&t;:&t;Took out transmit every packet pass&n; *&t;&t;&t;&t;&t;Saved a few bytes in the ioctl handler&n; *&t;&t;Alan Cox&t;:&t;Network driver sets packet type before calling netif_rx. Saves&n; *&t;&t;&t;&t;&t;a function call a packet.&n; *&t;&t;Alan Cox&t;:&t;Hashed net_bh()&n; *&t;&t;Richard Kooijman:&t;Timestamp fixes.&n; *&t;&t;Alan Cox&t;:&t;Wrong field in SIOCGIFDSTADDR&n; *&t;&t;Alan Cox&t;:&t;Device lock protection.&n; *&t;&t;Alan Cox&t;: &t;Fixed nasty side effect of device close changes.&n; *&t;&t;Rudi Cilibrasi&t;:&t;Pass the right thing to set_mac_address()&n; *&t;&t;Dave Miller&t;:&t;32bit quantity for the device lock to make it work out&n; *&t;&t;&t;&t;&t;on a Sparc.&n; *&t;&t;Bjorn Ekwall&t;:&t;Added KERNELD hack.&n; *&t;&t;Alan Cox&t;:&t;Cleaned up the backlog initialise.&n; *&t;&t;Craig Metz&t;:&t;SIOCGIFCONF fix if space for under&n; *&t;&t;&t;&t;&t;1 device.&n; *&t;    Thomas Bogendoerfer :&t;Return ENODEV for dev_open, if there&n; *&t;&t;&t;&t;&t;is no device open function.&n; *&n; */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#include &lt;net/slhc.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;net/br.h&gt;
macro_line|#ifdef CONFIG_NET_ALIAS
macro_line|#include &lt;linux/net_alias.h&gt;
macro_line|#endif
macro_line|#ifdef CONFIG_KERNELD
macro_line|#include &lt;linux/kerneld.h&gt;
macro_line|#endif
macro_line|#ifdef CONFIG_NET_RADIO
macro_line|#include &lt;linux/wireless.h&gt;
macro_line|#endif&t;/* CONFIG_NET_RADIO */
multiline_comment|/*&n; *&t;The list of devices, that are able to output.&n; */
DECL|variable|dev_up_base
r_static
r_struct
id|device
op_star
id|dev_up_base
suffix:semicolon
multiline_comment|/*&n; *&t;The list of packet types we will receive (as opposed to discard)&n; *&t;and the routines to invoke.&n; */
DECL|variable|ptype_base
r_struct
id|packet_type
op_star
id|ptype_base
(braket
l_int|16
)braket
suffix:semicolon
DECL|variable|ptype_all
r_struct
id|packet_type
op_star
id|ptype_all
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Taps */
multiline_comment|/*&n; *&t;Device list lock&n; */
DECL|variable|dev_lockct
id|atomic_t
id|dev_lockct
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; *&t;Our notifier list&n; */
DECL|variable|netdev_chain
r_struct
id|notifier_block
op_star
id|netdev_chain
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; *&t;Device drivers call our routines to queue packets here. We empty the&n; *&t;queue in the bottom half handler.&n; */
DECL|variable|backlog
r_static
r_struct
id|sk_buff_head
id|backlog
suffix:semicolon
multiline_comment|/* &n; *&t;We don&squot;t overdo the queue or we will thrash memory badly.&n; */
DECL|variable|backlog_size
r_static
r_int
id|backlog_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/******************************************************************************************&n;&n;&t;&t;Protocol management and registration routines&n;&n;*******************************************************************************************/
multiline_comment|/*&n; *&t;For efficiency&n; */
DECL|variable|dev_nit
r_static
r_int
id|dev_nit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; *&t;Add a protocol ID to the list. Now that the input handler is&n; *&t;smarter we can dispense with all the messy stuff that used to be&n; *&t;here.&n; */
DECL|function|dev_add_pack
r_void
id|dev_add_pack
c_func
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_int
id|hash
suffix:semicolon
r_if
c_cond
(paren
id|pt-&gt;type
op_eq
id|htons
c_func
(paren
id|ETH_P_ALL
)paren
)paren
(brace
id|dev_nit
op_increment
suffix:semicolon
id|pt-&gt;next
op_assign
id|ptype_all
suffix:semicolon
id|ptype_all
op_assign
id|pt
suffix:semicolon
)brace
r_else
(brace
id|hash
op_assign
id|ntohs
c_func
(paren
id|pt-&gt;type
)paren
op_amp
l_int|15
suffix:semicolon
id|pt-&gt;next
op_assign
id|ptype_base
(braket
id|hash
)braket
suffix:semicolon
id|ptype_base
(braket
id|hash
)braket
op_assign
id|pt
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Remove a protocol ID from the list.&n; */
DECL|function|dev_remove_pack
r_void
id|dev_remove_pack
c_func
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|packet_type
op_star
op_star
id|pt1
suffix:semicolon
r_if
c_cond
(paren
id|pt-&gt;type
op_eq
id|htons
c_func
(paren
id|ETH_P_ALL
)paren
)paren
(brace
id|dev_nit
op_decrement
suffix:semicolon
id|pt1
op_assign
op_amp
id|ptype_all
suffix:semicolon
)brace
r_else
id|pt1
op_assign
op_amp
id|ptype_base
(braket
id|ntohs
c_func
(paren
id|pt-&gt;type
)paren
op_amp
l_int|15
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
(paren
op_star
id|pt1
)paren
op_ne
l_int|NULL
suffix:semicolon
id|pt1
op_assign
op_amp
(paren
(paren
op_star
id|pt1
)paren
op_member_access_from_pointer
id|next
)paren
)paren
(brace
r_if
c_cond
(paren
id|pt
op_eq
(paren
op_star
id|pt1
)paren
)paren
(brace
op_star
id|pt1
op_assign
id|pt-&gt;next
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;dev_remove_pack: %p not found.&bslash;n&quot;
comma
id|pt
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************************&n;&n;&t;&t;&t;    Device Interface Subroutines&n;&n;******************************************************************************************/
multiline_comment|/* &n; *&t;Find an interface by name.&n; */
DECL|function|dev_get
r_struct
id|device
op_star
id|dev_get
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|dev-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
r_return
id|dev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Find and possibly load an interface.&n; */
macro_line|#ifdef CONFIG_KERNELD
DECL|function|dev_load
r_void
id|dev_load
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev_get
c_func
(paren
id|name
)paren
)paren
(brace
macro_line|#ifdef CONFIG_NET_ALIAS
r_const
r_char
op_star
id|sptr
suffix:semicolon
r_for
c_loop
(paren
id|sptr
op_assign
id|name
suffix:semicolon
op_star
id|sptr
suffix:semicolon
id|sptr
op_increment
)paren
r_if
c_cond
(paren
op_star
id|sptr
op_eq
l_char|&squot;:&squot;
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|sptr
op_logical_and
op_star
(paren
id|sptr
op_plus
l_int|1
)paren
)paren
)paren
macro_line|#endif
id|request_module
c_func
(paren
id|name
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n; *&t;Prepare an interface for use. &n; */
DECL|function|dev_open
r_int
id|dev_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Call device private open method&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;open
)paren
id|ret
op_assign
id|dev
op_member_access_from_pointer
id|open
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If it went open OK then set the flags&n;&t; */
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|dev-&gt;flags
op_or_assign
(paren
id|IFF_UP
op_or
id|IFF_RUNNING
)paren
suffix:semicolon
id|dev-&gt;hash
op_assign
id|dev_hash_name
c_func
(paren
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Initialise multicasting status &n;&t;&t; */
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_UP
comma
id|dev
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_ALIAS
r_if
c_cond
(paren
op_logical_neg
id|net_alias_is
c_func
(paren
id|dev
)paren
op_logical_or
id|dev-&gt;tx_queue_len
)paren
macro_line|#else
r_if
c_cond
(paren
id|dev-&gt;tx_queue_len
)paren
macro_line|#endif
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dev-&gt;next_up
op_assign
id|dev_up_base
suffix:semicolon
id|dev_up_base
op_assign
id|dev
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Completely shutdown an interface.&n; */
DECL|function|dev_close
r_int
id|dev_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
r_struct
id|device
op_star
op_star
id|devp
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Call the device specific close. This cannot fail.&n;&t; *&t;Only if device is UP&n;&t; */
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
op_logical_and
id|dev-&gt;stop
)paren
id|dev
op_member_access_from_pointer
id|stop
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Device is now down.&n;&t; */
id|dev-&gt;flags
op_and_assign
op_complement
(paren
id|IFF_UP
op_or
id|IFF_RUNNING
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Tell people we are going down&n;&t; */
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_DOWN
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Flush the multicast chain&n;&t; */
id|dev_mc_discard
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Purge any queued packets when we down the link &n;&t; */
r_while
c_loop
(paren
id|ct
OL
id|DEV_NUMBUFFS
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|dev-&gt;buffs
(braket
id|ct
)braket
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
id|ct
op_increment
suffix:semicolon
)brace
id|devp
op_assign
op_amp
id|dev_up_base
suffix:semicolon
r_while
c_loop
(paren
op_star
id|devp
)paren
(brace
r_if
c_cond
(paren
op_star
id|devp
op_eq
id|dev
)paren
(brace
op_star
id|devp
op_assign
id|dev-&gt;next_up
suffix:semicolon
r_break
suffix:semicolon
)brace
id|devp
op_assign
op_amp
(paren
op_star
id|devp
)paren
op_member_access_from_pointer
id|next_up
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Device change register/unregister. These are not inline or static&n; *&t;as we export them to the world.&n; */
DECL|function|register_netdevice_notifier
r_int
id|register_netdevice_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_return
id|notifier_chain_register
c_func
(paren
op_amp
id|netdev_chain
comma
id|nb
)paren
suffix:semicolon
)brace
DECL|function|unregister_netdevice_notifier
r_int
id|unregister_netdevice_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_return
id|notifier_chain_unregister
c_func
(paren
op_amp
id|netdev_chain
comma
id|nb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send (or queue for sending) a packet. &n; *&n; *&t;IMPORTANT: When this is called to resend frames. The caller MUST&n; *&t;already have locked the sk_buff. Apart from that we do the&n; *&t;rest of the magic.&n; */
DECL|function|do_dev_queue_xmit
r_static
r_void
id|do_dev_queue_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_int
id|pri
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|list
suffix:semicolon
r_int
id|retransmission
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* used to say if the packet should go&t;*/
multiline_comment|/* at the front or the back of the&t;*/
multiline_comment|/* queue - front is a retransmit try&t;*/
macro_line|#if CONFIG_SKB_CHECK 
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif    
multiline_comment|/*&n;&t; *&t;Negative priority is used to flag a frame that is being pulled from the&n;&t; *&t;queue front as a retransmit attempt. It therefore goes back on the queue&n;&t; *&t;start on a failure.&n;&t; */
r_if
c_cond
(paren
id|pri
OL
l_int|0
)paren
(brace
id|pri
op_assign
op_minus
id|pri
op_minus
l_int|1
suffix:semicolon
id|retransmission
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_DEBUG
r_if
c_cond
(paren
id|pri
op_ge
id|DEV_NUMBUFFS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bad priority in do_dev_queue_xmit.&bslash;n&quot;
)paren
suffix:semicolon
id|pri
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *&t;If we are bridging and this is directly generated output&n;&t; *&t;pass the frame via the bridge.&n;&t; */
macro_line|#ifdef CONFIG_BRIDGE
r_if
c_cond
(paren
id|skb-&gt;pkt_bridged
op_ne
id|IS_BRIDGED
op_logical_and
id|br_stats.flags
op_amp
id|BR_UP
)paren
(brace
r_if
c_cond
(paren
id|br_tx_frame
c_func
(paren
id|skb
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif
id|list
op_assign
id|dev-&gt;buffs
op_plus
id|pri
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* if this isn&squot;t a retransmission, use the first packet instead... */
r_if
c_cond
(paren
op_logical_neg
id|retransmission
)paren
(brace
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
id|list
)paren
)paren
(brace
multiline_comment|/* avoid overrunning the device queue.. */
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
id|list
)paren
OG
id|dev-&gt;tx_queue_len
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* copy outgoing packets to any sniffer packet handlers */
r_if
c_cond
(paren
id|dev_nit
)paren
(brace
r_struct
id|packet_type
op_star
id|ptype
suffix:semicolon
id|get_fast_time
c_func
(paren
op_amp
id|skb-&gt;stamp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ptype
op_assign
id|ptype_all
suffix:semicolon
id|ptype
op_ne
l_int|NULL
suffix:semicolon
id|ptype
op_assign
id|ptype-&gt;next
)paren
(brace
multiline_comment|/* Never send packets back to the socket&n;&t;&t;&t;&t; * they originated from - MvS (miquels@drinkel.ow.org)&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|ptype-&gt;dev
op_eq
id|dev
op_logical_or
op_logical_neg
id|ptype-&gt;dev
)paren
op_logical_and
(paren
(paren
r_struct
id|sock
op_star
)paren
id|ptype-&gt;data
op_ne
id|skb-&gt;sk
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|skb2-&gt;mac.raw
op_assign
id|skb2-&gt;data
suffix:semicolon
id|skb2-&gt;nh.raw
op_assign
id|skb2-&gt;h.raw
op_assign
id|skb2-&gt;data
op_plus
id|dev-&gt;hard_header_len
suffix:semicolon
id|ptype
op_member_access_from_pointer
id|func
c_func
(paren
id|skb2
comma
id|skb-&gt;dev
comma
id|ptype
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
id|list
)paren
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
id|list
comma
id|skb
)paren
suffix:semicolon
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
id|list
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|hard_start_xmit
c_func
(paren
id|skb
comma
id|dev
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Packet is now solely the responsibility of the driver&n;&t;&t; */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Transmission failed, put skb back into a list. Once on the list it&squot;s safe and&n;&t; *&t;no longer device locked (it can be freed safely from the device queue)&n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|__skb_queue_head
c_func
(paren
id|list
comma
id|skb
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|dev_queue_xmit
r_int
id|dev_queue_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
macro_line|#if CONFIG_SKB_CHECK 
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif    
multiline_comment|/*&n;&t; *&t;If the address has not been resolved. Call the device header rebuilder.&n;&t; *&t;This can cover all protocols and technically not just ARP either.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;arp
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;rebuild_header
)paren
(brace
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|rebuild_header
c_func
(paren
id|skb
)paren
)paren
(brace
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;%s: !skb-&gt;arp &amp; !rebuild_header!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&n;&t; * &t;If dev is an alias, switch to its main device.&n;&t; *&t;&quot;arp&quot; resolution has been made with alias device, so&n;&t; *&t;arp entries refer to alias, not main.&n;&t; *&n;&t; */
macro_line|#ifdef CONFIG_NET_ALIAS
r_if
c_cond
(paren
id|net_alias_is
c_func
(paren
id|dev
)paren
)paren
id|skb-&gt;dev
op_assign
id|dev
op_assign
id|net_alias_main_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
id|do_dev_queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
id|skb-&gt;priority
)paren
suffix:semicolon
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dev_loopback_xmit
r_void
id|dev_loopback_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sk_buff
op_star
id|newskb
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newskb
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|skb_pull
c_func
(paren
id|newskb
comma
id|newskb-&gt;nh.raw
op_minus
id|newskb-&gt;data
)paren
suffix:semicolon
id|newskb-&gt;ip_summed
op_assign
id|CHECKSUM_UNNECESSARY
suffix:semicolon
r_if
c_cond
(paren
id|newskb-&gt;dst
op_eq
l_int|NULL
)paren
id|printk
c_func
(paren
l_string|&quot;BUG: packet without dst looped back 1&bslash;n&quot;
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|newskb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Receive a packet from a device driver and queue it for the upper&n; *&t;(protocol) levels.  It always succeeds. This is the recommended &n; *&t;interface to use.&n; */
DECL|function|netif_rx
r_void
id|netif_rx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_static
r_int
id|dropping
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Any received buffers are un-owned and should be discarded&n;&t; *&t;when freed. These will be updated later as the frames get&n;&t; *&t;owners.&n;&t; */
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;stamp.tv_sec
op_eq
l_int|0
)paren
(brace
id|get_fast_time
c_func
(paren
op_amp
id|skb-&gt;stamp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Check that we aren&squot;t overdoing things.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|backlog_size
)paren
id|dropping
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|backlog_size
OG
l_int|300
)paren
id|dropping
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dropping
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Add it to the &quot;backlog&quot; queue. &n;&t; */
macro_line|#if CONFIG_SKB_CHECK
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif&t;
id|skb_queue_tail
c_func
(paren
op_amp
id|backlog
comma
id|skb
)paren
suffix:semicolon
id|backlog_size
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If any packet arrived, mark it for processing after the&n;&t; *&t;hardware interrupt returns.&n;&t; */
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine causes all interfaces to try to send some data. &n; */
DECL|function|dev_transmit
r_static
r_void
id|dev_transmit
c_func
(paren
r_void
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_up_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next_up
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_ne
l_int|0
op_logical_and
op_logical_neg
id|dev-&gt;tbusy
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Kick the device&n;&t;&t;&t; */
id|dev_tint
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**********************************************************************************&n;&n;&t;&t;&t;Receive Queue Processor&n;&t;&t;&t;&n;***********************************************************************************/
multiline_comment|/*&n; *&t;When we are called the queue is ready to grab, the interrupts are&n; *&t;on and hardware can interrupt and queue to the receive queue as we&n; *&t;run with no problems.&n; *&t;This is run as a bottom half after an interrupt handler that does&n; *&t;mark_bh(NET_BH);&n; */
DECL|function|net_bh
r_void
id|net_bh
c_func
(paren
r_void
)paren
(brace
r_struct
id|packet_type
op_star
id|ptype
suffix:semicolon
r_struct
id|packet_type
op_star
id|pt_prev
suffix:semicolon
r_int
r_int
id|type
suffix:semicolon
r_int
id|nit
op_assign
l_int|301
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Can we send anything now? We want to clear the&n;&t; *&t;decks for any more sends that get done as we&n;&t; *&t;process the input. This also minimises the&n;&t; *&t;latency on a transmit interrupt bh.&n;&t; */
id|dev_transmit
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Any data left to process. This may occur because a&n;&t; *&t;mark_bh() is done after we empty the queue including&n;&t; *&t;that from the device which does a mark_bh() just after&n;&t; */
multiline_comment|/*&n;&t; *&t;While the queue is not empty..&n;&t; *&n;&t; *&t;Note that the queue never shrinks due to&n;&t; *&t;an interrupt, so we can do this test without&n;&t; *&t;disabling interrupts.&n;&t; */
r_while
c_loop
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|backlog
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|backlog.next
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;We have a packet. Therefore the queue has shrunk&n;&t;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|__skb_unlink
c_func
(paren
id|skb
comma
op_amp
id|backlog
)paren
suffix:semicolon
id|backlog_size
op_decrement
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;We do not want to spin in net_bh infinitely. --ANK&n;&t;&t; */
r_if
c_cond
(paren
op_decrement
id|nit
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|nit
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;net_bh: too many loops, dropping...&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BRIDGE
multiline_comment|/*&n;&t;&t; *&t;If we are bridging then pass the frame up to the&n;&t;&t; *&t;bridging code (if this protocol is to be bridged).&n;&t;&t; *      If it is bridged then move on&n;&t;&t; */
r_if
c_cond
(paren
id|br_stats.flags
op_amp
id|BR_UP
op_logical_and
id|br_protocol_ok
c_func
(paren
id|ntohs
c_func
(paren
id|skb-&gt;protocol
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;We pass the bridge a complete frame. This means&n;&t;&t;&t; *&t;recovering the MAC header first.&n;&t;&t;&t; */
r_int
id|offset
op_assign
id|skb-&gt;data
op_minus
id|skb-&gt;mac.raw
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb_push
c_func
(paren
id|skb
comma
id|offset
)paren
suffix:semicolon
multiline_comment|/* Put header back on for bridge */
r_if
c_cond
(paren
id|br_receive_frame
c_func
(paren
id|skb
)paren
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;Pull the MAC header off for the copy going to&n;&t;&t;&t; *&t;the upper layers.&n;&t;&t;&t; */
id|skb_pull
c_func
(paren
id|skb
comma
id|offset
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; &t; *&t;Bump the pointer to the next structure.&n;&t;&t; * &n;&t;&t; *&t;On entry to the protocol layer. skb-&gt;data and&n;&t;&t; *&t;skb-&gt;nh.raw point to the MAC and encapsulated data&n;&t;&t; */
multiline_comment|/* XXX until we figure out every place to modify.. */
id|skb-&gt;h.raw
op_assign
id|skb-&gt;nh.raw
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t;&t; * &t;Fetch the packet protocol ID. &n;&t;&t; */
id|type
op_assign
id|skb-&gt;protocol
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;We got a packet ID.  Now loop over the &quot;known protocols&quot;&n;&t;&t; * &t;list. There are two lists. The ptype_all list of taps (normally empty)&n;&t;&t; *&t;and the main protocol list which is hashed perfectly for normal protocols.&n;&t;&t; */
id|pt_prev
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|ptype
op_assign
id|ptype_all
suffix:semicolon
id|ptype
op_ne
l_int|NULL
suffix:semicolon
id|ptype
op_assign
id|ptype-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|pt_prev
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb2
)paren
(brace
id|pt_prev
op_member_access_from_pointer
id|func
c_func
(paren
id|skb2
comma
id|skb-&gt;dev
comma
id|pt_prev
)paren
suffix:semicolon
)brace
)brace
id|pt_prev
op_assign
id|ptype
suffix:semicolon
)brace
r_for
c_loop
(paren
id|ptype
op_assign
id|ptype_base
(braket
id|ntohs
c_func
(paren
id|type
)paren
op_amp
l_int|15
)braket
suffix:semicolon
id|ptype
op_ne
l_int|NULL
suffix:semicolon
id|ptype
op_assign
id|ptype-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ptype-&gt;type
op_eq
id|type
op_logical_and
(paren
op_logical_neg
id|ptype-&gt;dev
op_logical_or
id|ptype-&gt;dev
op_eq
id|skb-&gt;dev
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;We already have a match queued. Deliver&n;&t;&t;&t;&t; *&t;to it and then remember the new match&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|pt_prev
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;Kick the protocol handler. This should be fast&n;&t;&t;&t;&t;&t; *&t;and efficient code.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|skb2
)paren
(brace
id|pt_prev
op_member_access_from_pointer
id|func
c_func
(paren
id|skb2
comma
id|skb-&gt;dev
comma
id|pt_prev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Remember the current last to do */
id|pt_prev
op_assign
id|ptype
suffix:semicolon
)brace
)brace
multiline_comment|/* End of protocol list loop */
multiline_comment|/*&n;&t;&t; *&t;Is there a last item to send to ?&n;&t;&t; */
r_if
c_cond
(paren
id|pt_prev
)paren
(brace
id|pt_prev
op_member_access_from_pointer
id|func
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
id|pt_prev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * &t;Has an unknown packet has been received ?&n;&t;&t; */
r_else
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Again, see if we can transmit anything now. &n;&t;&t; *&t;[Ought to take this out judging by tests it slows&n;&t;&t; *&t; us down not speeds us up]&n;&t;&t; */
macro_line|#ifdef XMIT_EVERY
id|dev_transmit
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif&t;&t;
)brace
multiline_comment|/* End of queue loop */
multiline_comment|/*&n;  &t; *&t;We have emptied the queue&n;  &t; */
multiline_comment|/*&n;&t; *&t;One last output flush.&n;&t; */
macro_line|#ifdef XMIT_AFTER&t; 
id|dev_transmit
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *&t;This routine is called when an device driver (i.e. an&n; *&t;interface) is ready to transmit a packet.&n; */
DECL|function|dev_tint
r_void
id|dev_tint
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sk_buff_head
op_star
id|head
suffix:semicolon
multiline_comment|/*&n;&t; * aliases do not transmit (for now :) )&n;&t; */
macro_line|#ifdef CONFIG_NET_ALIAS
r_if
c_cond
(paren
id|net_alias_is
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;net alias %s transmits&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|head
op_assign
id|dev-&gt;buffs
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Work the queues in priority order&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_NUMBUFFS
suffix:semicolon
id|i
op_increment
comma
id|head
op_increment
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
id|head
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|head-&gt;next
suffix:semicolon
id|__skb_unlink
c_func
(paren
id|skb
comma
id|head
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Stop anyone freeing the buffer while we retransmit it&n;&t;&t;&t; */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Feed them to the output stage and if it fails&n;&t;&t;&t; *&t;indicate they re-queue at the front.&n;&t;&t;&t; */
id|do_dev_queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
op_minus
id|i
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;If we can take no more then stop here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
r_return
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Perform a SIOCGIFCONF call. This structure will change&n; *&t;size shortly, and there is nothing I can do about it.&n; *&t;Thus we will need a &squot;compatibility mode&squot;.&n; */
DECL|function|dev_ifconf
r_static
r_int
id|dev_ifconf
c_func
(paren
r_char
op_star
id|arg
)paren
(brace
r_struct
id|ifconf
id|ifc
suffix:semicolon
r_struct
id|ifreq
id|ifr
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_char
op_star
id|pos
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fetch the caller&squot;s info block. &n;&t; */
id|err
op_assign
id|copy_from_user
c_func
(paren
op_amp
id|ifc
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifconf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|len
op_assign
id|ifc.ifc_len
suffix:semicolon
id|pos
op_assign
id|ifc.ifc_buf
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We now walk the device list filling each active device&n;&t; *&t;into the array.&n;&t; */
multiline_comment|/*&n;&t; *&t;Loop over the interfaces, and write an info block for each. &n;&t; */
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
(brace
multiline_comment|/* Downed devices don&squot;t count */
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Have we run out of space here ?&n;&t;&t; */
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
r_break
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ifr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|ifr.ifr_name
comma
id|dev-&gt;name
)paren
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_addr.s_addr
op_assign
id|dev-&gt;pa_addr
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Write this block to the caller&squot;s space. &n;&t;&t; */
id|err
op_assign
id|copy_to_user
c_func
(paren
id|pos
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|pos
op_add_assign
r_sizeof
(paren
r_struct
id|ifreq
)paren
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
r_struct
id|ifreq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;All done.  Write the updated control block back to the caller. &n;&t; */
id|ifc.ifc_len
op_assign
(paren
id|pos
op_minus
id|ifc.ifc_buf
)paren
suffix:semicolon
id|ifc.ifc_req
op_assign
(paren
r_struct
id|ifreq
op_star
)paren
id|ifc.ifc_buf
suffix:semicolon
id|err
op_assign
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifc
comma
r_sizeof
(paren
r_struct
id|ifconf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Report how much was filled in&n;&t; */
r_return
id|pos
op_minus
id|arg
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is invoked by the /proc filesystem handler to display a device&n; *&t;in detail.&n; */
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|sprintf_stats
r_static
r_int
id|sprintf_stats
c_func
(paren
r_char
op_star
id|buffer
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|enet_statistics
op_star
id|stats
op_assign
(paren
id|dev-&gt;get_stats
ques
c_cond
id|dev
op_member_access_from_pointer
id|get_stats
c_func
(paren
id|dev
)paren
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|stats
)paren
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%6s:%7d %4d %4d %4d %4d %8d %4d %4d %4d %5d %4d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|stats-&gt;rx_packets
comma
id|stats-&gt;rx_errors
comma
id|stats-&gt;rx_dropped
op_plus
id|stats-&gt;rx_missed_errors
comma
id|stats-&gt;rx_fifo_errors
comma
id|stats-&gt;rx_length_errors
op_plus
id|stats-&gt;rx_over_errors
op_plus
id|stats-&gt;rx_crc_errors
op_plus
id|stats-&gt;rx_frame_errors
comma
id|stats-&gt;tx_packets
comma
id|stats-&gt;tx_errors
comma
id|stats-&gt;tx_dropped
comma
id|stats-&gt;tx_fifo_errors
comma
id|stats-&gt;collisions
comma
id|stats-&gt;tx_carrier_errors
op_plus
id|stats-&gt;tx_aborted_errors
op_plus
id|stats-&gt;tx_window_errors
op_plus
id|stats-&gt;tx_heartbeat_errors
)paren
suffix:semicolon
r_else
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%6s: No statistics available.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Called from the PROCfs module. This now uses the new arbitrary sized /proc/net interface&n; *&t;to create /proc/net/dev&n; */
DECL|function|dev_get_info
r_int
id|dev_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|dummy
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|size
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;Inter-|   Receive                  |  Transmit&bslash;n&quot;
l_string|&quot; face |packets errs drop fifo frame|packets errs drop fifo colls carrier&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
id|size
op_assign
id|sprintf_stats
c_func
(paren
id|buffer
op_plus
id|len
comma
id|dev
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start slop */
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
multiline_comment|/* Ending slop */
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_PROC_FS */
macro_line|#ifdef CONFIG_NET_RADIO
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/*&n; * Print one entry of /proc/net/wireless&n; * This is a clone of /proc/net/dev (just above)&n; */
DECL|function|sprintf_wireless_stats
r_static
r_int
id|sprintf_wireless_stats
c_func
(paren
r_char
op_star
id|buffer
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
multiline_comment|/* Get stats from the driver */
r_struct
id|iw_statistics
op_star
id|stats
op_assign
(paren
id|dev-&gt;get_wireless_stats
ques
c_cond
id|dev
op_member_access_from_pointer
id|get_wireless_stats
c_func
(paren
id|dev
)paren
suffix:colon
(paren
r_struct
id|iw_statistics
op_star
)paren
l_int|NULL
)paren
suffix:semicolon
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|stats
op_ne
(paren
r_struct
id|iw_statistics
op_star
)paren
l_int|NULL
)paren
(brace
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%6s: %02x  %3d%c %3d%c  %3d%c %5d %5d %5d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|stats-&gt;status
comma
id|stats-&gt;qual.qual
comma
id|stats-&gt;qual.updated
op_amp
l_int|1
ques
c_cond
l_char|&squot;.&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|stats-&gt;qual.level
comma
id|stats-&gt;qual.updated
op_amp
l_int|2
ques
c_cond
l_char|&squot;.&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|stats-&gt;qual.noise
comma
id|stats-&gt;qual.updated
op_amp
l_int|3
ques
c_cond
l_char|&squot;.&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|stats-&gt;discard.nwid
comma
id|stats-&gt;discard.codec
comma
id|stats-&gt;discard.misc
)paren
suffix:semicolon
)brace
r_else
id|size
op_assign
l_int|0
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * Print info for /proc/net/wireless (print all entries)&n; * This is a clone of /proc/net/dev (just above)&n; */
DECL|function|dev_get_wireless_info
r_int
id|dev_get_wireless_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|dummy
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|size
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;Inter-|sta|  Quality       |  Discarded packets&bslash;n&quot;
l_string|&quot; face |tus|link level noise| nwid crypt  misc&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
id|size
op_assign
id|sprintf_wireless_stats
c_func
(paren
id|buffer
op_plus
id|len
comma
id|dev
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start slop */
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
multiline_comment|/* Ending slop */
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_PROC_FS */
macro_line|#endif&t;/* CONFIG_NET_RADIO */
multiline_comment|/*&n; *&t;Perform the SIOCxIFxxx calls. &n; *&n; *&t;The socket layer has seen an ioctl the address family thinks is&n; *&t;for the device. At this point we get invoked to make a decision&n; */
DECL|function|dev_ifsioc
r_static
r_int
id|dev_ifsioc
c_func
(paren
r_void
op_star
id|arg
comma
r_int
r_int
id|getset
)paren
(brace
r_struct
id|ifreq
id|ifr
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_int
id|ret
comma
id|err
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fetch the caller&squot;s info block into kernel space&n;&t; */
id|err
op_assign
id|copy_from_user
c_func
(paren
op_amp
id|ifr
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t; *&t;See which interface the caller is talking about. &n;&t; */
multiline_comment|/*&n;&t; *&n;&t; *&t;net_alias_dev_get(): dev_get() with added alias naming magic.&n;&t; *&t;only allow alias creation/deletion if (getset==SIOCSIFADDR)&n;&t; *&n;&t; */
macro_line|#ifdef CONFIG_KERNELD
id|dev_load
c_func
(paren
id|ifr.ifr_name
)paren
suffix:semicolon
macro_line|#endif&t;
macro_line|#ifdef CONFIG_NET_ALIAS
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|net_alias_dev_get
c_func
(paren
id|ifr.ifr_name
comma
id|getset
op_eq
id|SIOCSIFADDR
comma
op_amp
id|err
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
id|err
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|dev_get
c_func
(paren
id|ifr.ifr_name
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|getset
)paren
(brace
r_case
id|SIOCGIFFLAGS
suffix:colon
multiline_comment|/* Get interface flags */
id|ifr.ifr_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
r_goto
id|rarok
suffix:semicolon
r_case
id|SIOCSIFFLAGS
suffix:colon
multiline_comment|/* Set interface flags */
(brace
r_int
id|old_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;We are not allowed to potentially close/unload&n;&t;&t;&t;&t; *&t;a device until we get this lock.&n;&t;&t;&t;&t; */
id|dev_lock_wait
c_func
(paren
)paren
suffix:semicolon
id|dev_lock_list
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Set the flags on our device.&n;&t;&t;&t;&t; */
id|dev-&gt;flags
op_assign
(paren
id|ifr.ifr_flags
op_amp
(paren
id|IFF_BROADCAST
op_or
id|IFF_DEBUG
op_or
id|IFF_LOOPBACK
op_or
id|IFF_POINTOPOINT
op_or
id|IFF_NOTRAILERS
op_or
id|IFF_RUNNING
op_or
id|IFF_NOARP
op_or
id|IFF_PROMISC
op_or
id|IFF_ALLMULTI
op_or
id|IFF_SLAVE
op_or
id|IFF_MASTER
op_or
id|IFF_MULTICAST
)paren
)paren
op_or
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Load in the correct multicast list now the flags have changed.&n;&t;&t;&t;&t; */
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;  &t; *&t;Have we downed the interface. We handle IFF_UP ourselves&n;&t;&t;&t;  &t; *&t;according to user attempts to set it, rather than blindly&n;&t;&t;&t;  &t; *&t;setting it.&n;&t;&t;&t;  &t; */
r_if
c_cond
(paren
(paren
id|old_flags
op_xor
id|ifr.ifr_flags
)paren
op_amp
id|IFF_UP
)paren
multiline_comment|/* Bit is different  ? */
(brace
r_if
c_cond
(paren
id|old_flags
op_amp
id|IFF_UP
)paren
(brace
multiline_comment|/* Gone down */
id|ret
op_assign
id|dev_close
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Come up */
(brace
id|ret
op_assign
id|dev_open
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|dev-&gt;flags
op_and_assign
op_complement
id|IFF_UP
suffix:semicolon
)brace
multiline_comment|/* Open failed */
)brace
)brace
r_else
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Load in the correct multicast list now the flags have changed.&n;&t;&t;&t;&t; */
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
op_logical_and
(paren
(paren
id|old_flags
op_xor
id|dev-&gt;flags
)paren
op_amp
op_complement
(paren
id|IFF_UP
op_or
id|IFF_RUNNING
op_or
id|IFF_PROMISC
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;SIFFL %s(%s)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGE
comma
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_xor
id|old_flags
)paren
op_amp
id|IFF_PROMISC
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s enters promiscuous mode.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s leave promiscuous mode.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
id|dev_unlock_list
c_func
(paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIOCGIFMETRIC
suffix:colon
multiline_comment|/* Get the metric on the interface (currently unused) */
id|ifr.ifr_metric
op_assign
id|dev-&gt;metric
suffix:semicolon
r_goto
id|rarok
suffix:semicolon
r_case
id|SIOCSIFMETRIC
suffix:colon
multiline_comment|/* Set the metric on the interface (currently unused) */
id|dev-&gt;metric
op_assign
id|ifr.ifr_metric
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFMTU
suffix:colon
multiline_comment|/* Get the MTU of a device */
id|ifr.ifr_mtu
op_assign
id|dev-&gt;mtu
suffix:semicolon
r_goto
id|rarok
suffix:semicolon
r_case
id|SIOCSIFMTU
suffix:colon
multiline_comment|/* Set the MTU of a device */
r_if
c_cond
(paren
id|ifr.ifr_mtu
op_eq
id|dev-&gt;mtu
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;MTU must be positive.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ifr.ifr_mtu
OL
l_int|68
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;change_mtu
)paren
id|ret
op_assign
id|dev
op_member_access_from_pointer
id|change_mtu
c_func
(paren
id|dev
comma
id|ifr.ifr_mtu
)paren
suffix:semicolon
r_else
(brace
id|dev-&gt;mtu
op_assign
id|ifr.ifr_mtu
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;SIFMTU %s(%s)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGE
comma
id|dev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIOCGIFMEM
suffix:colon
multiline_comment|/* Get the per device memory space. We can add this but currently&n;&t;&t;&t;&t;&t;   do not support it */
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFMEM
suffix:colon
multiline_comment|/* Set the per device memory buffer space. Not applicable in our case */
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFHWADDR
suffix:colon
id|memcpy
c_func
(paren
id|ifr.ifr_hwaddr.sa_data
comma
id|dev-&gt;dev_addr
comma
id|MAX_ADDR_LEN
)paren
suffix:semicolon
id|ifr.ifr_hwaddr.sa_family
op_assign
id|dev-&gt;type
suffix:semicolon
r_goto
id|rarok
suffix:semicolon
r_case
id|SIOCSIFHWADDR
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_mac_address
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ifr.ifr_hwaddr.sa_family
op_ne
id|dev-&gt;type
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ret
op_assign
id|dev
op_member_access_from_pointer
id|set_mac_address
c_func
(paren
id|dev
comma
op_amp
id|ifr.ifr_hwaddr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFMAP
suffix:colon
id|ifr.ifr_map.mem_start
op_assign
id|dev-&gt;mem_start
suffix:semicolon
id|ifr.ifr_map.mem_end
op_assign
id|dev-&gt;mem_end
suffix:semicolon
id|ifr.ifr_map.base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|ifr.ifr_map.irq
op_assign
id|dev-&gt;irq
suffix:semicolon
id|ifr.ifr_map.dma
op_assign
id|dev-&gt;dma
suffix:semicolon
id|ifr.ifr_map.port
op_assign
id|dev-&gt;if_port
suffix:semicolon
r_goto
id|rarok
suffix:semicolon
r_case
id|SIOCSIFMAP
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_config
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_return
id|dev
op_member_access_from_pointer
id|set_config
c_func
(paren
id|dev
comma
op_amp
id|ifr.ifr_map
)paren
suffix:semicolon
r_case
id|SIOCADDMULTI
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_multicast_list
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ifr.ifr_hwaddr.sa_family
op_ne
id|AF_UNSPEC
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev_mc_add
c_func
(paren
id|dev
comma
id|ifr.ifr_hwaddr.sa_data
comma
id|dev-&gt;addr_len
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCDELMULTI
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_multicast_list
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ifr.ifr_hwaddr.sa_family
op_ne
id|AF_UNSPEC
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev_mc_delete
c_func
(paren
id|dev
comma
id|ifr.ifr_hwaddr.sa_data
comma
id|dev-&gt;addr_len
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Unknown or private ioctl&n;&t;&t; */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
(paren
id|getset
op_ge
id|SIOCDEVPRIVATE
)paren
op_logical_and
(paren
id|getset
op_le
(paren
id|SIOCDEVPRIVATE
op_plus
l_int|15
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;do_ioctl
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
id|ret
op_assign
id|dev
op_member_access_from_pointer
id|do_ioctl
c_func
(paren
id|dev
comma
op_amp
id|ifr
comma
id|getset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|err
op_assign
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_RADIO
r_if
c_cond
(paren
(paren
id|getset
op_ge
id|SIOCIWFIRST
)paren
op_logical_and
(paren
id|getset
op_le
id|SIOCIWLAST
)paren
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;do_ioctl
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/* Perform the ioctl */
id|ret
op_assign
id|dev
op_member_access_from_pointer
id|do_ioctl
c_func
(paren
id|dev
comma
op_amp
id|ifr
comma
id|getset
)paren
suffix:semicolon
multiline_comment|/* If return args... */
r_if
c_cond
(paren
id|IW_IS_GET
c_func
(paren
id|getset
)paren
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_NET_RADIO */
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
multiline_comment|/*&n; *&t;The load of calls that return an ifreq and ok (saves memory).&n; */
id|rarok
suffix:colon
id|err
op_assign
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This function handles all &quot;interface&quot;-type I/O control requests. The actual&n; *&t;&squot;doing&squot; part of this is dev_ifsioc above.&n; */
DECL|function|dev_ioctl
r_int
id|dev_ioctl
c_func
(paren
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCGIFCONF
suffix:colon
(paren
r_void
)paren
id|dev_ifconf
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Ioctl calls that can be done by all.&n;&t;&t; */
r_case
id|SIOCGIFFLAGS
suffix:colon
r_case
id|SIOCGIFMETRIC
suffix:colon
r_case
id|SIOCGIFMTU
suffix:colon
r_case
id|SIOCGIFMEM
suffix:colon
r_case
id|SIOCGIFHWADDR
suffix:colon
r_case
id|SIOCSIFHWADDR
suffix:colon
r_case
id|SIOCGIFSLAVE
suffix:colon
r_case
id|SIOCGIFMAP
suffix:colon
r_return
id|dev_ifsioc
c_func
(paren
id|arg
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Ioctl calls requiring the power of a superuser&n;&t;&t; */
r_case
id|SIOCSIFFLAGS
suffix:colon
r_case
id|SIOCSIFMETRIC
suffix:colon
r_case
id|SIOCSIFMTU
suffix:colon
r_case
id|SIOCSIFMEM
suffix:colon
r_case
id|SIOCSIFMAP
suffix:colon
r_case
id|SIOCSIFSLAVE
suffix:colon
r_case
id|SIOCADDMULTI
suffix:colon
r_case
id|SIOCDELMULTI
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_return
id|dev_ifsioc
c_func
(paren
id|arg
comma
id|cmd
)paren
suffix:semicolon
r_case
id|SIOCSIFLINK
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Unknown or private ioctl.&n;&t;&t; */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
(paren
id|cmd
op_ge
id|SIOCDEVPRIVATE
)paren
op_logical_and
(paren
id|cmd
op_le
(paren
id|SIOCDEVPRIVATE
op_plus
l_int|15
)paren
)paren
)paren
(brace
r_return
id|dev_ifsioc
c_func
(paren
id|arg
comma
id|cmd
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_RADIO
r_if
c_cond
(paren
(paren
id|cmd
op_ge
id|SIOCIWFIRST
)paren
op_logical_and
(paren
id|cmd
op_le
id|SIOCIWLAST
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|IW_IS_SET
c_func
(paren
id|cmd
)paren
)paren
op_logical_and
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_return
id|dev_ifsioc
c_func
(paren
id|arg
comma
id|cmd
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_NET_RADIO */
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Initialize the DEV module. At boot time this walks the device list and&n; *&t;unhooks any devices that fail to initialise (normally hardware not &n; *&t;present) and leaves us with a valid list of present and active devices.&n; *&n; */
r_extern
r_int
id|lance_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|pi_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|bpq_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|scc_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|sdla_setup
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|dlci_setup
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|pt_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|sm_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|baycom_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
DECL|variable|proc_net_dev
r_static
r_struct
id|proc_dir_entry
id|proc_net_dev
op_assign
(brace
id|PROC_NET_DEV
comma
l_int|3
comma
l_string|&quot;dev&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_amp
id|proc_net_inode_operations
comma
id|dev_get_info
)brace
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_RADIO
macro_line|#ifdef CONFIG_PROC_FS
DECL|variable|proc_net_wireless
r_static
r_struct
id|proc_dir_entry
id|proc_net_wireless
op_assign
(brace
id|PROC_NET_WIRELESS
comma
l_int|8
comma
l_string|&quot;wireless&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_amp
id|proc_net_inode_operations
comma
id|dev_get_wireless_info
)brace
suffix:semicolon
macro_line|#endif&t;/* CONFIG_PROC_FS */
macro_line|#endif&t;/* CONFIG_NET_RADIO */
DECL|function|net_dev_init
r_int
id|net_dev_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|device
op_star
id|dev
comma
op_star
op_star
id|dp
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Initialise the packet receive queue.&n;&t; */
id|skb_queue_head_init
c_func
(paren
op_amp
id|backlog
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;The bridge has to be up before the devices&n;&t; */
macro_line|#ifdef CONFIG_BRIDGE&t; 
id|br_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif&t;
multiline_comment|/*&n;&t; * This is Very Ugly(tm).&n;&t; *&n;&t; * Some devices want to be initialized early..&n;&t; */
macro_line|#if defined(CONFIG_LANCE)
id|lance_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_PI)
id|pi_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif&t;
macro_line|#if defined(CONFIG_SCC)
id|scc_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_PT)
id|pt_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_BPQETHER)
id|bpq_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_DLCI)
id|dlci_setup
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_SDLA)
id|sdla_setup
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_BAYCOM)
id|baycom_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_SOUNDMODEM)
id|sm_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;SLHC if present needs attaching so other people see it&n;&t; *&t;even if not opened.&n;&t; */
macro_line|#if (defined(CONFIG_SLIP) &amp;&amp; defined(CONFIG_SLIP_COMPRESSED)) &bslash;&n;&t; || defined(CONFIG_PPP) &bslash;&n;    || (defined(CONFIG_ISDN) &amp;&amp; defined(CONFIG_ISDN_PPP))
id|slhc_install
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif&t;
multiline_comment|/*&n;&t; *&t;Add the devices.&n;&t; *&t;If the call to dev-&gt;init fails, the dev is removed&n;&t; *&t;from the chain disconnecting the device until the&n;&t; *&t;next reboot.&n;&t; */
id|dp
op_assign
op_amp
id|dev_base
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dev
op_assign
op_star
id|dp
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_NUMBUFFS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|skb_queue_head_init
c_func
(paren
id|dev-&gt;buffs
op_plus
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;init
op_logical_and
id|dev
op_member_access_from_pointer
id|init
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;It failed to come up. Unhook it.&n;&t;&t;&t; */
op_star
id|dp
op_assign
id|dev-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|dp
op_assign
op_amp
id|dev-&gt;next
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_PROC_FS
id|proc_net_register
c_func
(paren
op_amp
id|proc_net_dev
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_RADIO
macro_line|#ifdef CONFIG_PROC_FS
id|proc_net_register
c_func
(paren
op_amp
id|proc_net_wireless
)paren
suffix:semicolon
macro_line|#endif&t;/* CONFIG_PROC_FS */
macro_line|#endif&t;/* CONFIG_NET_RADIO */
multiline_comment|/*&t;&n;&t; *&t;Initialise net_alias engine &n;&t; *&n;&t; *&t;&t;- register net_alias device notifier&n;&t; *&t;&t;- register proc entries:&t;/proc/net/alias_types&n;&t; *&t;&t;&t;&t;&t;&t;&t;&t;&t;/proc/net/aliases&n;&t; */
macro_line|#ifdef CONFIG_NET_ALIAS
id|net_alias_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|init_bh
c_func
(paren
id|NET_BH
comma
id|net_bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
