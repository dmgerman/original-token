multiline_comment|/*&n; * &t;NET3&t;Protocol independent device support routines.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; *&t;Derived from the non IP parts of dev.c 1.0.19&n; * &t;&t;Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&n; *&t;Additional Authors:&n; *&t;&t;Florian la Roche &lt;rzsfl@rz.uni-sb.de&gt;&n; *&t;&t;Alan Cox &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;David Hinds &lt;dhinds@allegro.stanford.edu&gt;&n; *&t;&t;Alexey Kuznetsov &lt;kuznet@ms2.inr.ac.ru&gt;&n; *&t;&t;Adam Sulmicki &lt;adam@cfar.umd.edu&gt;&n; *&n; *&t;Changes:&n; *&t;&t;Alan Cox&t;:&t;device private ioctl copies fields back.&n; *&t;&t;Alan Cox&t;:&t;Transmit queue code does relevant stunts to&n; *&t;&t;&t;&t;&t;keep the queue safe.&n; *&t;&t;Alan Cox&t;:&t;Fixed double lock.&n; *&t;&t;Alan Cox&t;:&t;Fixed promisc NULL pointer trap&n; *&t;&t;????????&t;:&t;Support the full private ioctl range&n; *&t;&t;Alan Cox&t;:&t;Moved ioctl permission check into drivers&n; *&t;&t;Tim Kordas&t;:&t;SIOCADDMULTI/SIOCDELMULTI&n; *&t;&t;Alan Cox&t;:&t;100 backlog just doesn&squot;t cut it when&n; *&t;&t;&t;&t;&t;you start doing multicast video 8)&n; *&t;&t;Alan Cox&t;:&t;Rewrote net_bh and list manager.&n; *&t;&t;Alan Cox&t;: &t;Fix ETH_P_ALL echoback lengths.&n; *&t;&t;Alan Cox&t;:&t;Took out transmit every packet pass&n; *&t;&t;&t;&t;&t;Saved a few bytes in the ioctl handler&n; *&t;&t;Alan Cox&t;:&t;Network driver sets packet type before calling netif_rx. Saves&n; *&t;&t;&t;&t;&t;a function call a packet.&n; *&t;&t;Alan Cox&t;:&t;Hashed net_bh()&n; *&t;&t;Richard Kooijman:&t;Timestamp fixes.&n; *&t;&t;Alan Cox&t;:&t;Wrong field in SIOCGIFDSTADDR&n; *&t;&t;Alan Cox&t;:&t;Device lock protection.&n; *&t;&t;Alan Cox&t;: &t;Fixed nasty side effect of device close changes.&n; *&t;&t;Rudi Cilibrasi&t;:&t;Pass the right thing to set_mac_address()&n; *&t;&t;Dave Miller&t;:&t;32bit quantity for the device lock to make it work out&n; *&t;&t;&t;&t;&t;on a Sparc.&n; *&t;&t;Bjorn Ekwall&t;:&t;Added KERNELD hack.&n; *&t;&t;Alan Cox&t;:&t;Cleaned up the backlog initialise.&n; *&t;&t;Craig Metz&t;:&t;SIOCGIFCONF fix if space for under&n; *&t;&t;&t;&t;&t;1 device.&n; *&t;    Thomas Bogendoerfer :&t;Return ENODEV for dev_open, if there&n; *&t;&t;&t;&t;&t;is no device open function.&n; *&t;&t;Andi Kleen&t;:&t;Fix error reporting for SIOCGIFCONF&n; *&t;    Michael Chastain&t;:&t;Fix signed/unsigned for SIOCGIFCONF&n; *&t;&t;Cyrus Durgin&t;:&t;Cleaned for KMOD&n; *&t;&t;Adam Sulmicki   :&t;Bug Fix : Network Device Unload&n; *&t;&t;&t;&t;&t;A network device unload needs to purge&n; *&t;&t;&t;&t;&t;the backlog queue.&n; *&t;Paul Rusty Russel&t;:&t;SIOCSIFNAME&n; */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;net/slhc.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;net/br.h&gt;
macro_line|#include &lt;net/dst.h&gt;
macro_line|#include &lt;net/pkt_sched.h&gt;
macro_line|#include &lt;net/profile.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#ifdef CONFIG_NET_RADIO
macro_line|#include &lt;linux/wireless.h&gt;
macro_line|#endif&t;/* CONFIG_NET_RADIO */
macro_line|#ifdef CONFIG_PLIP
r_extern
r_int
id|plip_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
id|NET_PROFILE_DEFINE
c_func
(paren
id|dev_queue_xmit
)paren
id|NET_PROFILE_DEFINE
c_func
(paren
id|net_bh
)paren
id|NET_PROFILE_DEFINE
c_func
(paren
id|net_bh_skb
)paren
r_const
r_char
op_star
id|if_port_text
(braket
)braket
op_assign
(brace
l_string|&quot;unknown&quot;
comma
l_string|&quot;BNC&quot;
comma
l_string|&quot;10baseT&quot;
comma
l_string|&quot;AUI&quot;
comma
l_string|&quot;100baseT&quot;
comma
l_string|&quot;100baseTX&quot;
comma
l_string|&quot;100baseFX&quot;
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;The list of packet types we will receive (as opposed to discard)&n; *&t;and the routines to invoke.&n; *&n; *&t;Why 16. Because with 16 the only overlap we get on a hash of the&n; *&t;low nibble of the protocol value is RARP/SNAP/X.25. &n; *&n; *&t;&t;0800&t;IP&n; *&t;&t;0001&t;802.3&n; *&t;&t;0002&t;AX.25&n; *&t;&t;0004&t;802.2&n; *&t;&t;8035&t;RARP&n; *&t;&t;0005&t;SNAP&n; *&t;&t;0805&t;X.25&n; *&t;&t;0806&t;ARP&n; *&t;&t;8137&t;IPX&n; *&t;&t;0009&t;Localtalk&n; *&t;&t;86DD&t;IPv6&n; */
DECL|variable|ptype_base
r_static
r_struct
id|packet_type
op_star
id|ptype_base
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* 16 way hashed list */
DECL|variable|ptype_all
r_static
r_struct
id|packet_type
op_star
id|ptype_all
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Taps */
DECL|variable|ptype_lock
r_static
id|rwlock_t
id|ptype_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; *&t;Our notifier list&n; */
DECL|variable|netdev_chain
r_static
r_struct
id|notifier_block
op_star
id|netdev_chain
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; *&t;Device drivers call our routines to queue packets here. We empty the&n; *&t;queue in the bottom half handler.&n; */
DECL|variable|backlog
r_static
r_struct
id|sk_buff_head
id|backlog
suffix:semicolon
macro_line|#ifdef CONFIG_NET_FASTROUTE
DECL|variable|netdev_fastroute
r_int
id|netdev_fastroute
suffix:semicolon
DECL|variable|netdev_fastroute_obstacles
r_int
id|netdev_fastroute_obstacles
suffix:semicolon
DECL|variable|dev_fastroute_stat
r_struct
id|net_fastroute_stats
id|dev_fastroute_stat
suffix:semicolon
macro_line|#endif
r_static
r_void
id|dev_clear_backlog
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/******************************************************************************************&n;&n;&t;&t;Protocol management and registration routines&n;&n;*******************************************************************************************/
multiline_comment|/*&n; *&t;For efficiency&n; */
DECL|variable|netdev_nit
r_int
id|netdev_nit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; *&t;Add a protocol ID to the list. Now that the input handler is&n; *&t;smarter we can dispense with all the messy stuff that used to be&n; *&t;here.&n; *&n; *&t;BEWARE!!! Protocol handlers, mangling input packets,&n; *&t;MUST BE last in hash buckets and checking protocol handlers&n; *&t;MUST start from promiscous ptype_all chain in net_bh.&n; *&t;It is true now, do not change it.&n; *&t;Explantion follows: if protocol handler, mangling packet, will&n; *&t;be the first on list, it is not able to sense, that packet&n; *&t;is cloned and should be copied-on-write, so that it will&n; *&t;change it and subsequent readers will get broken packet.&n; *&t;&t;&t;&t;&t;&t;&t;--ANK (980803)&n; */
DECL|function|dev_add_pack
r_void
id|dev_add_pack
c_func
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_int
id|hash
suffix:semicolon
macro_line|#ifdef CONFIG_NET_FASTROUTE
multiline_comment|/* Hack to detect packet socket */
r_if
c_cond
(paren
id|pt-&gt;data
)paren
(brace
id|netdev_fastroute_obstacles
op_increment
suffix:semicolon
id|dev_clear_fastroute
c_func
(paren
id|pt-&gt;dev
)paren
suffix:semicolon
)brace
macro_line|#endif
id|write_lock_bh
c_func
(paren
op_amp
id|ptype_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pt-&gt;type
op_eq
id|htons
c_func
(paren
id|ETH_P_ALL
)paren
)paren
(brace
id|netdev_nit
op_increment
suffix:semicolon
id|pt-&gt;next
op_assign
id|ptype_all
suffix:semicolon
id|ptype_all
op_assign
id|pt
suffix:semicolon
)brace
r_else
(brace
id|hash
op_assign
id|ntohs
c_func
(paren
id|pt-&gt;type
)paren
op_amp
l_int|15
suffix:semicolon
id|pt-&gt;next
op_assign
id|ptype_base
(braket
id|hash
)braket
suffix:semicolon
id|ptype_base
(braket
id|hash
)braket
op_assign
id|pt
suffix:semicolon
)brace
id|write_unlock_bh
c_func
(paren
op_amp
id|ptype_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Remove a protocol ID from the list.&n; */
DECL|function|dev_remove_pack
r_void
id|dev_remove_pack
c_func
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|packet_type
op_star
op_star
id|pt1
suffix:semicolon
r_if
c_cond
(paren
id|pt-&gt;type
op_eq
id|htons
c_func
(paren
id|ETH_P_ALL
)paren
)paren
(brace
id|netdev_nit
op_decrement
suffix:semicolon
id|pt1
op_assign
op_amp
id|ptype_all
suffix:semicolon
)brace
r_else
id|pt1
op_assign
op_amp
id|ptype_base
(braket
id|ntohs
c_func
(paren
id|pt-&gt;type
)paren
op_amp
l_int|15
)braket
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|ptype_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
(paren
op_star
id|pt1
)paren
op_ne
l_int|NULL
suffix:semicolon
id|pt1
op_assign
op_amp
(paren
(paren
op_star
id|pt1
)paren
op_member_access_from_pointer
id|next
)paren
)paren
(brace
r_if
c_cond
(paren
id|pt
op_eq
(paren
op_star
id|pt1
)paren
)paren
(brace
op_star
id|pt1
op_assign
id|pt-&gt;next
suffix:semicolon
macro_line|#ifdef CONFIG_NET_FASTROUTE
r_if
c_cond
(paren
id|pt-&gt;data
)paren
id|netdev_fastroute_obstacles
op_decrement
suffix:semicolon
macro_line|#endif
id|write_unlock_bh
c_func
(paren
op_amp
id|ptype_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|write_unlock_bh
c_func
(paren
op_amp
id|ptype_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;dev_remove_pack: %p not found.&bslash;n&quot;
comma
id|pt
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************************&n;&n;&t;&t;&t;    Device Interface Subroutines&n;&n;******************************************************************************************/
multiline_comment|/* &n; *&t;Find an interface by name. May be called under rtnl semaphore&n; *&t;or dev_base_lock.&n; */
DECL|function|__dev_get_by_name
r_struct
id|net_device
op_star
id|__dev_get_by_name
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|dev-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
r_return
id|dev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Find an interface by name. Any context, dev_put() to release.&n; */
DECL|function|dev_get_by_name
r_struct
id|net_device
op_star
id|dev_get_by_name
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|dev
op_assign
id|__dev_get_by_name
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
id|dev_hold
c_func
(paren
id|dev
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/* &n;   Return value is changed to int to prevent illegal usage in future.&n;   It is still legal to use to check for device existance.&n; */
DECL|function|dev_get
r_int
id|dev_get
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|dev
op_assign
id|__dev_get_by_name
c_func
(paren
id|name
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_return
id|dev
op_ne
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Find an interface by index. May be called under rtnl semaphore&n; *&t;or dev_base_lock.&n; */
DECL|function|__dev_get_by_index
r_struct
id|net_device
op_star
id|__dev_get_by_index
c_func
(paren
r_int
id|ifindex
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;ifindex
op_eq
id|ifindex
)paren
r_return
id|dev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Find an interface by index. Any context, dev_put() to release.&n; */
DECL|function|dev_get_by_index
r_struct
id|net_device
op_star
id|dev_get_by_index
c_func
(paren
r_int
id|ifindex
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|dev
op_assign
id|__dev_get_by_index
c_func
(paren
id|ifindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
id|dev_hold
c_func
(paren
id|dev
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Find an interface by ll addr. May be called only under rtnl semaphore.&n; */
DECL|function|dev_getbyhwaddr
r_struct
id|net_device
op_star
id|dev_getbyhwaddr
c_func
(paren
r_int
r_int
id|type
comma
r_char
op_star
id|ha
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|ASSERT_RTNL
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|type
op_logical_and
id|memcmp
c_func
(paren
id|dev-&gt;dev_addr
comma
id|ha
comma
id|dev-&gt;addr_len
)paren
op_eq
l_int|0
)paren
r_return
id|dev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Passed a format string - eg &quot;lt%d&quot; it will try and find a suitable&n; *&t;id. Not efficient for many devices, not called a lot..&n; */
DECL|function|dev_alloc_name
r_int
id|dev_alloc_name
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
id|buf
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If you need over 100 please also fix the algorithm...&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|buf
comma
id|name
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__dev_get_by_name
c_func
(paren
id|buf
)paren
op_eq
l_int|NULL
)paren
(brace
id|strcpy
c_func
(paren
id|dev-&gt;name
comma
id|buf
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENFILE
suffix:semicolon
multiline_comment|/* Over 100 of the things .. bail out! */
)brace
DECL|function|dev_alloc
r_struct
id|net_device
op_star
id|dev_alloc
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
op_star
id|err
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_device
)paren
op_plus
l_int|16
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
op_star
id|err
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device
)paren
)paren
suffix:semicolon
id|dev-&gt;name
op_assign
(paren
r_char
op_star
)paren
(paren
id|dev
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Name string space */
op_star
id|err
op_assign
id|dev_alloc_name
c_func
(paren
id|dev
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|err
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|dev
suffix:semicolon
)brace
DECL|function|netdev_state_change
r_void
id|netdev_state_change
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGE
comma
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Find and possibly load an interface.&n; */
macro_line|#ifdef CONFIG_KMOD
DECL|function|dev_load
r_void
id|dev_load
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|__dev_get_by_name
c_func
(paren
id|name
)paren
op_logical_and
id|capable
c_func
(paren
id|CAP_SYS_MODULE
)paren
)paren
(brace
id|request_module
c_func
(paren
id|name
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
DECL|function|dev_load
r_extern
r_inline
r_void
(def_block
id|dev_load
c_func
(paren
r_const
r_char
op_star
id|unused
)paren
(brace
suffix:semicolon
)brace
)def_block
macro_line|#endif
DECL|function|default_rebuild_header
r_static
r_int
id|default_rebuild_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: default_rebuild_header called -- BUG!&bslash;n&quot;
comma
id|skb-&gt;dev
ques
c_cond
id|skb-&gt;dev-&gt;name
suffix:colon
l_string|&quot;NULL!!!&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Prepare an interface for use. &n; */
DECL|function|dev_open
r_int
id|dev_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Is it already up?&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Call device private open method&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;open
)paren
id|ret
op_assign
id|dev
op_member_access_from_pointer
id|open
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If it went open OK then:&n;&t; */
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;nil rebuild_header routine,&n;&t;&t; *&t;that should be never called and used as just bug trap.&n;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;rebuild_header
op_eq
l_int|NULL
)paren
id|dev-&gt;rebuild_header
op_assign
id|default_rebuild_header
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Set the flags.&n;&t;&t; */
id|dev-&gt;flags
op_or_assign
(paren
id|IFF_UP
op_or
id|IFF_RUNNING
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Initialize multicasting status &n;&t;&t; */
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Wakeup transmit queue engine&n;&t;&t; */
id|dev_activate
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;... and announce new interface.&n;&t;&t; */
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_UP
comma
id|dev
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_FASTROUTE
DECL|function|dev_do_clear_fastroute
r_static
r_void
id|dev_do_clear_fastroute
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;accept_fastpath
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|NETDEV_FASTROUTE_HMASK
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
suffix:semicolon
id|write_lock_irq
c_func
(paren
op_amp
id|dev-&gt;fastpath_lock
)paren
suffix:semicolon
id|dst
op_assign
id|dev-&gt;fastpath
(braket
id|i
)braket
suffix:semicolon
id|dev-&gt;fastpath
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|dev-&gt;fastpath_lock
)paren
suffix:semicolon
id|dst_release
c_func
(paren
id|dst
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|dev_clear_fastroute
r_void
id|dev_clear_fastroute
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev
)paren
(brace
id|dev_do_clear_fastroute
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
id|dev_do_clear_fastroute
c_func
(paren
id|dev
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n; *&t;Completely shutdown an interface.&n; */
DECL|function|dev_close
r_int
id|dev_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|dev_deactivate
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Call the device specific close. This cannot fail.&n;&t; *&t;Only if device is UP&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;stop
)paren
id|dev
op_member_access_from_pointer
id|stop
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;start
)paren
id|printk
c_func
(paren
l_string|&quot;dev_close: bug %s still running&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Device is now down.&n;&t; */
id|dev_clear_backlog
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;flags
op_and_assign
op_complement
(paren
id|IFF_UP
op_or
id|IFF_RUNNING
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_FASTROUTE
id|dev_clear_fastroute
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Tell people we are going down&n;&t; */
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_DOWN
comma
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Device change register/unregister. These are not inline or static&n; *&t;as we export them to the world.&n; */
DECL|function|register_netdevice_notifier
r_int
id|register_netdevice_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_return
id|notifier_chain_register
c_func
(paren
op_amp
id|netdev_chain
comma
id|nb
)paren
suffix:semicolon
)brace
DECL|function|unregister_netdevice_notifier
r_int
id|unregister_netdevice_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_return
id|notifier_chain_unregister
c_func
(paren
op_amp
id|netdev_chain
comma
id|nb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Support routine. Sends outgoing frames to any network&n; *&t;taps currently in use.&n; */
DECL|function|dev_queue_xmit_nit
r_void
id|dev_queue_xmit_nit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|packet_type
op_star
id|ptype
suffix:semicolon
id|get_fast_time
c_func
(paren
op_amp
id|skb-&gt;stamp
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|ptype_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ptype
op_assign
id|ptype_all
suffix:semicolon
id|ptype
op_ne
l_int|NULL
suffix:semicolon
id|ptype
op_assign
id|ptype-&gt;next
)paren
(brace
multiline_comment|/* Never send packets back to the socket&n;&t;&t; * they originated from - MvS (miquels@drinkel.ow.org)&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ptype-&gt;dev
op_eq
id|dev
op_logical_or
op_logical_neg
id|ptype-&gt;dev
)paren
op_logical_and
(paren
(paren
r_struct
id|sock
op_star
)paren
id|ptype-&gt;data
op_ne
id|skb-&gt;sk
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
multiline_comment|/* skb-&gt;nh should be correctly&n;&t;&t;&t;   set by sender, so that the second statement is&n;&t;&t;&t;   just protection against buggy protocols.&n;&t;&t;&t; */
id|skb2-&gt;mac.raw
op_assign
id|skb2-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|skb2-&gt;nh.raw
OL
id|skb2-&gt;data
op_logical_or
id|skb2-&gt;nh.raw
op_ge
id|skb2-&gt;tail
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;protocol %04x is buggy, dev %s&bslash;n&quot;
comma
id|skb2-&gt;protocol
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|skb2-&gt;nh.raw
op_assign
id|skb2-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;hard_header
)paren
id|skb2-&gt;nh.raw
op_add_assign
id|dev-&gt;hard_header_len
suffix:semicolon
)brace
id|skb2-&gt;h.raw
op_assign
id|skb2-&gt;nh.raw
suffix:semicolon
id|skb2-&gt;pkt_type
op_assign
id|PACKET_OUTGOING
suffix:semicolon
id|skb2-&gt;rx_dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|dev_hold
c_func
(paren
id|skb2-&gt;rx_dev
)paren
suffix:semicolon
id|ptype
op_member_access_from_pointer
id|func
c_func
(paren
id|skb2
comma
id|skb-&gt;dev
comma
id|ptype
)paren
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|ptype_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Fast path for loopback frames.&n; */
DECL|function|dev_loopback_xmit
r_void
id|dev_loopback_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sk_buff
op_star
id|newskb
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newskb
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|newskb-&gt;mac.raw
op_assign
id|newskb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|newskb
comma
id|newskb-&gt;nh.raw
op_minus
id|newskb-&gt;data
)paren
suffix:semicolon
id|newskb-&gt;pkt_type
op_assign
id|PACKET_LOOPBACK
suffix:semicolon
id|newskb-&gt;ip_summed
op_assign
id|CHECKSUM_UNNECESSARY
suffix:semicolon
r_if
c_cond
(paren
id|newskb-&gt;dst
op_eq
l_int|NULL
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;BUG: packet without dst looped back 1&bslash;n&quot;
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|newskb
)paren
suffix:semicolon
)brace
DECL|function|dev_queue_xmit
r_int
id|dev_queue_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
r_struct
id|Qdisc
op_star
id|q
suffix:semicolon
multiline_comment|/* Grab device queue */
id|spin_lock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|q
op_assign
id|dev-&gt;qdisc
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;enqueue
)paren
(brace
r_int
id|ret
op_assign
id|q
op_member_access_from_pointer
id|enqueue
c_func
(paren
id|skb
comma
id|q
)paren
suffix:semicolon
multiline_comment|/* If the device is not busy, kick it.&n;&t;&t; * Otherwise or if queue is not empty after kick,&n;&t;&t; * add it to run list.&n;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;tbusy
op_logical_or
id|__qdisc_wakeup
c_func
(paren
id|dev
)paren
)paren
id|qdisc_run
c_func
(paren
id|q
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* The device has no queue. Common case for software devices:&n;&t;   loopback, all the sorts of tunnels...&n;&n;&t;   Really, it is unlikely that xmit_lock protection is necessary here.&n;&t;   (f.e. loopback and IP tunnels are clean ignoring statistics counters.)&n;&t;   However, it is possible, that they rely on protection&n;&t;   made by us here.&n;&n;&t;   Check this and shot the lock. It is not prone from deadlocks.&n;&t;   Either shot noqueue qdisc, it is even simpler 8)&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;xmit_lock_owner
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dev-&gt;xmit_lock
)paren
suffix:semicolon
id|dev-&gt;xmit_lock_owner
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|netdev_nit
)paren
id|dev_queue_xmit_nit
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|hard_start_xmit
c_func
(paren
id|skb
comma
id|dev
)paren
op_eq
l_int|0
)paren
(brace
id|dev-&gt;xmit_lock_owner
op_assign
op_minus
l_int|1
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|dev-&gt;xmit_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dev-&gt;xmit_lock_owner
op_assign
op_minus
l_int|1
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|dev-&gt;xmit_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Virtual device %s asks to queue packet!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|ENETDOWN
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Recursion is detected! It is possible, unfortunately */
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Dead loop on virtual device %s, fix it urgently!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|ENETDOWN
suffix:semicolon
)brace
multiline_comment|/*=======================================================================&n;&t;&t;&t;Receiver rotutines&n;  =======================================================================*/
DECL|variable|netdev_dropping
r_int
id|netdev_dropping
op_assign
l_int|0
suffix:semicolon
DECL|variable|netdev_max_backlog
r_int
id|netdev_max_backlog
op_assign
l_int|300
suffix:semicolon
DECL|variable|netdev_rx_dropped
id|atomic_t
id|netdev_rx_dropped
suffix:semicolon
macro_line|#ifdef CONFIG_NET_HW_FLOWCONTROL
DECL|variable|netdev_throttle_events
r_int
id|netdev_throttle_events
suffix:semicolon
DECL|variable|netdev_fc_mask
r_static
r_int
r_int
id|netdev_fc_mask
op_assign
l_int|1
suffix:semicolon
DECL|variable|netdev_fc_xoff
r_int
r_int
id|netdev_fc_xoff
op_assign
l_int|0
suffix:semicolon
DECL|variable|netdev_fc_lock
id|spinlock_t
id|netdev_fc_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_static
r_struct
(brace
DECL|member|stimul
r_void
(paren
op_star
id|stimul
)paren
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
DECL|member|dev
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
DECL|variable|netdev_fc_slots
)brace
id|netdev_fc_slots
(braket
l_int|32
)braket
suffix:semicolon
DECL|function|netdev_register_fc
r_int
id|netdev_register_fc
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
(paren
op_star
id|stimul
)paren
(paren
r_struct
id|net_device
op_star
id|dev
)paren
)paren
(brace
r_int
id|bit
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|netdev_fc_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|netdev_fc_mask
op_ne
op_complement
l_int|0UL
)paren
(brace
id|bit
op_assign
id|ffz
c_func
(paren
id|netdev_fc_mask
)paren
suffix:semicolon
id|netdev_fc_slots
(braket
id|bit
)braket
dot
id|stimul
op_assign
id|stimul
suffix:semicolon
id|netdev_fc_slots
(braket
id|bit
)braket
dot
id|dev
op_assign
id|dev
suffix:semicolon
id|set_bit
c_func
(paren
id|bit
comma
op_amp
id|netdev_fc_mask
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|bit
comma
op_amp
id|netdev_fc_xoff
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|netdev_fc_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|bit
suffix:semicolon
)brace
DECL|function|netdev_unregister_fc
r_void
id|netdev_unregister_fc
c_func
(paren
r_int
id|bit
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|netdev_fc_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bit
OG
l_int|0
)paren
(brace
id|netdev_fc_slots
(braket
id|bit
)braket
dot
id|stimul
op_assign
l_int|NULL
suffix:semicolon
id|netdev_fc_slots
(braket
id|bit
)braket
dot
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|clear_bit
c_func
(paren
id|bit
comma
op_amp
id|netdev_fc_mask
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|bit
comma
op_amp
id|netdev_fc_xoff
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|netdev_fc_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|netdev_wakeup
r_static
r_void
id|netdev_wakeup
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|xoff
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|netdev_fc_lock
)paren
suffix:semicolon
id|xoff
op_assign
id|netdev_fc_xoff
suffix:semicolon
id|netdev_fc_xoff
op_assign
l_int|0
suffix:semicolon
id|netdev_dropping
op_assign
l_int|0
suffix:semicolon
id|netdev_throttle_events
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|xoff
)paren
(brace
r_int
id|i
op_assign
id|ffz
c_func
(paren
op_complement
id|xoff
)paren
suffix:semicolon
id|xoff
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
id|netdev_fc_slots
(braket
id|i
)braket
dot
id|stimul
c_func
(paren
id|netdev_fc_slots
(braket
id|i
)braket
dot
id|dev
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|netdev_fc_lock
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|dev_clear_backlog
r_static
r_void
id|dev_clear_backlog
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sk_buff_head
id|garbage
suffix:semicolon
multiline_comment|/*&n;&t; *&n;&t; *  Let now clear backlog queue. -AS&n;&t; *&n;&t; */
id|skb_queue_head_init
c_func
(paren
op_amp
id|garbage
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|backlog.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|backlog.qlen
)paren
(brace
r_struct
id|sk_buff
op_star
id|prev
comma
op_star
id|curr
suffix:semicolon
id|curr
op_assign
id|backlog.next
suffix:semicolon
r_while
c_loop
(paren
id|curr
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
(paren
op_amp
id|backlog
)paren
)paren
(brace
id|curr
op_assign
id|curr-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|curr-&gt;prev-&gt;dev
op_eq
id|dev
)paren
(brace
id|prev
op_assign
id|curr-&gt;prev
suffix:semicolon
id|__skb_unlink
c_func
(paren
id|prev
comma
op_amp
id|backlog
)paren
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
op_amp
id|garbage
comma
id|prev
)paren
suffix:semicolon
)brace
)brace
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|backlog.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|garbage.qlen
)paren
(brace
macro_line|#ifdef CONFIG_NET_HW_FLOWCONTROL
r_if
c_cond
(paren
id|netdev_dropping
)paren
id|netdev_wakeup
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
id|netdev_dropping
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|skb_queue_purge
c_func
(paren
op_amp
id|garbage
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Receive a packet from a device driver and queue it for the upper&n; *&t;(protocol) levels.  It always succeeds. &n; */
DECL|function|netif_rx
r_void
id|netif_rx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;stamp.tv_sec
op_eq
l_int|0
)paren
(brace
id|get_fast_time
c_func
(paren
op_amp
id|skb-&gt;stamp
)paren
suffix:semicolon
)brace
multiline_comment|/* The code is rearranged so that the path is the most&n;&t;   short when CPU is congested, but is still operating.&n;&t; */
r_if
c_cond
(paren
id|backlog.qlen
op_le
id|netdev_max_backlog
)paren
(brace
r_if
c_cond
(paren
id|backlog.qlen
)paren
(brace
r_if
c_cond
(paren
id|netdev_dropping
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;rx_dev
)paren
id|dev_put
c_func
(paren
id|skb-&gt;rx_dev
)paren
suffix:semicolon
id|skb-&gt;rx_dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|dev_hold
c_func
(paren
id|skb-&gt;rx_dev
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|backlog
comma
id|skb
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|netdev_rx_dropped
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_HW_FLOWCONTROL
r_if
c_cond
(paren
id|netdev_dropping
)paren
id|netdev_wakeup
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
id|netdev_dropping
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|skb-&gt;rx_dev
)paren
id|dev_put
c_func
(paren
id|skb-&gt;rx_dev
)paren
suffix:semicolon
id|skb-&gt;rx_dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|dev_hold
c_func
(paren
id|skb-&gt;rx_dev
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|backlog
comma
id|skb
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|netdev_dropping
op_assign
l_int|1
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|netdev_rx_dropped
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BRIDGE
DECL|function|handle_bridge
r_static
r_inline
r_void
id|handle_bridge
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|type
)paren
(brace
r_if
c_cond
(paren
id|br_stats.flags
op_amp
id|BR_UP
op_logical_and
id|br_protocol_ok
c_func
(paren
id|ntohs
c_func
(paren
id|type
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;We pass the bridge a complete frame. This means&n;&t;&t; *&t;recovering the MAC header first.&n;&t;&t; */
r_int
id|offset
suffix:semicolon
id|skb
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
id|offset
op_assign
id|skb-&gt;data
op_minus
id|skb-&gt;mac.raw
suffix:semicolon
id|skb_push
c_func
(paren
id|skb
comma
id|offset
)paren
suffix:semicolon
multiline_comment|/* Put header back on for bridge */
r_if
c_cond
(paren
id|br_receive_frame
c_func
(paren
id|skb
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; *&t;When we are called the queue is ready to grab, the interrupts are&n; *&t;on and hardware can interrupt and queue to the receive queue as we&n; *&t;run with no problems.&n; *&t;This is run as a bottom half after an interrupt handler that does&n; *&t;mark_bh(NET_BH);&n; */
DECL|function|net_bh
r_void
id|net_bh
c_func
(paren
r_void
)paren
(brace
r_struct
id|packet_type
op_star
id|ptype
suffix:semicolon
r_struct
id|packet_type
op_star
id|pt_prev
suffix:semicolon
r_int
r_int
id|type
suffix:semicolon
r_int
r_int
id|start_time
op_assign
id|jiffies
suffix:semicolon
id|NET_PROFILE_ENTER
c_func
(paren
id|net_bh
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Can we send anything now? We want to clear the&n;&t; *&t;decks for any more sends that get done as we&n;&t; *&t;process the input. This also minimises the&n;&t; *&t;latency on a transmit interrupt bh.&n;&t; */
r_if
c_cond
(paren
id|qdisc_pending
c_func
(paren
)paren
)paren
id|qdisc_run_queues
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Any data left to process. This may occur because a&n;&t; *&t;mark_bh() is done after we empty the queue including&n;&t; *&t;that from the device which does a mark_bh() just after&n;&t; */
multiline_comment|/*&n;&t; *&t;While the queue is not empty..&n;&t; *&n;&t; *&t;Note that the queue never shrinks due to&n;&t; *&t;an interrupt, so we can do this test without&n;&t; *&t;disabling interrupts.&n;&t; */
r_while
c_loop
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|backlog
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* Give chance to other bottom halves to run */
r_if
c_cond
(paren
id|jiffies
op_minus
id|start_time
OG
l_int|1
)paren
r_goto
id|net_bh_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;We have a packet. Therefore the queue has shrunk&n;&t;&t; */
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|backlog
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_FASTROUTE
r_if
c_cond
(paren
id|skb-&gt;pkt_type
op_eq
id|PACKET_FASTROUTE
)paren
(brace
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; &t; *&t;Bump the pointer to the next structure.&n;&t;&t; * &n;&t;&t; *&t;On entry to the protocol layer. skb-&gt;data and&n;&t;&t; *&t;skb-&gt;nh.raw point to the MAC and encapsulated data&n;&t;&t; */
multiline_comment|/* XXX until we figure out every place to modify.. */
id|skb-&gt;h.raw
op_assign
id|skb-&gt;nh.raw
op_assign
id|skb-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;mac.raw
template_param
id|skb-&gt;data
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s: wrong mac.raw ptr, proto=%04x&bslash;n&quot;
comma
id|skb-&gt;dev-&gt;name
comma
id|skb-&gt;protocol
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * &t;Fetch the packet protocol ID. &n;&t;&t; */
id|type
op_assign
id|skb-&gt;protocol
suffix:semicolon
macro_line|#ifdef CONFIG_BRIDGE
multiline_comment|/*&n;&t;&t; *&t;If we are bridging then pass the frame up to the&n;&t;&t; *&t;bridging code (if this protocol is to be bridged).&n;&t;&t; *      If it is bridged then move on&n;&t;&t; */
id|handle_bridge
c_func
(paren
id|skb
comma
id|type
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; *&t;We got a packet ID.  Now loop over the &quot;known protocols&quot;&n;&t;&t; * &t;list. There are two lists. The ptype_all list of taps (normally empty)&n;&t;&t; *&t;and the main protocol list which is hashed perfectly for normal protocols.&n;&t;&t; */
id|pt_prev
op_assign
l_int|NULL
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|ptype_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ptype
op_assign
id|ptype_all
suffix:semicolon
id|ptype
op_ne
l_int|NULL
suffix:semicolon
id|ptype
op_assign
id|ptype-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ptype-&gt;dev
op_logical_or
id|ptype-&gt;dev
op_eq
id|skb-&gt;dev
)paren
(brace
r_if
c_cond
(paren
id|pt_prev
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_if
c_cond
(paren
id|pt_prev-&gt;data
op_eq
l_int|NULL
)paren
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_else
(brace
id|skb2
op_assign
id|skb
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|skb2-&gt;users
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb2
)paren
(brace
id|pt_prev
op_member_access_from_pointer
id|func
c_func
(paren
id|skb2
comma
id|skb-&gt;dev
comma
id|pt_prev
)paren
suffix:semicolon
)brace
)brace
id|pt_prev
op_assign
id|ptype
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|ptype
op_assign
id|ptype_base
(braket
id|ntohs
c_func
(paren
id|type
)paren
op_amp
l_int|15
)braket
suffix:semicolon
id|ptype
op_ne
l_int|NULL
suffix:semicolon
id|ptype
op_assign
id|ptype-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ptype-&gt;type
op_eq
id|type
op_logical_and
(paren
op_logical_neg
id|ptype-&gt;dev
op_logical_or
id|ptype-&gt;dev
op_eq
id|skb-&gt;dev
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;We already have a match queued. Deliver&n;&t;&t;&t;&t; *&t;to it and then remember the new match&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|pt_prev
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_if
c_cond
(paren
id|pt_prev-&gt;data
op_eq
l_int|NULL
)paren
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_else
(brace
id|skb2
op_assign
id|skb
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|skb2-&gt;users
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;Kick the protocol handler. This should be fast&n;&t;&t;&t;&t;&t; *&t;and efficient code.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|skb2
)paren
(brace
id|pt_prev
op_member_access_from_pointer
id|func
c_func
(paren
id|skb2
comma
id|skb-&gt;dev
comma
id|pt_prev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Remember the current last to do */
id|pt_prev
op_assign
id|ptype
suffix:semicolon
)brace
)brace
multiline_comment|/* End of protocol list loop */
multiline_comment|/*&n;&t;&t; *&t;Is there a last item to send to ?&n;&t;&t; */
r_if
c_cond
(paren
id|pt_prev
)paren
(brace
id|pt_prev
op_member_access_from_pointer
id|func
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
id|pt_prev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * &t;Has an unknown packet has been received ?&n;&t;&t; */
r_else
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|ptype_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* End of queue loop */
multiline_comment|/*&n;  &t; *&t;We have emptied the queue&n;  &t; */
multiline_comment|/*&n;&t; *&t;One last output flush.&n;&t; */
r_if
c_cond
(paren
id|qdisc_pending
c_func
(paren
)paren
)paren
id|qdisc_run_queues
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_HW_FLOWCONTROL
r_if
c_cond
(paren
id|netdev_dropping
)paren
id|netdev_wakeup
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
id|netdev_dropping
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|NET_PROFILE_LEAVE
c_func
(paren
id|net_bh
)paren
suffix:semicolon
r_return
suffix:semicolon
id|net_bh_break
suffix:colon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
id|NET_PROFILE_LEAVE
c_func
(paren
id|net_bh
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Protocol dependent address dumping routines */
DECL|variable|gifconf_list
r_static
id|gifconf_func_t
op_star
id|gifconf_list
(braket
id|NPROTO
)braket
suffix:semicolon
DECL|function|register_gifconf
r_int
id|register_gifconf
c_func
(paren
r_int
r_int
id|family
comma
id|gifconf_func_t
op_star
id|gifconf
)paren
(brace
r_if
c_cond
(paren
id|family
op_ge
id|NPROTO
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|gifconf_list
(braket
id|family
)braket
op_assign
id|gifconf
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Map an interface index to its name (SIOCGIFNAME)&n; */
multiline_comment|/*&n; *&t;We need this ioctl for efficient implementation of the&n; *&t;if_indextoname() function required by the IPv6 API.  Without&n; *&t;it, we would have to search all the interfaces to find a&n; *&t;match.  --pb&n; */
DECL|function|dev_ifname
r_static
r_int
id|dev_ifname
c_func
(paren
r_struct
id|ifreq
op_star
id|arg
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|ifreq
id|ifr
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fetch the caller&squot;s info block. &n;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ifr
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|dev
op_assign
id|__dev_get_by_index
c_func
(paren
id|ifr.ifr_ifindex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|ifr.ifr_name
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Perform a SIOCGIFCONF call. This structure will change&n; *&t;size eventually, and there is nothing I can do about it.&n; *&t;Thus we will need a &squot;compatibility mode&squot;.&n; */
DECL|function|dev_ifconf
r_static
r_int
id|dev_ifconf
c_func
(paren
r_char
op_star
id|arg
)paren
(brace
r_struct
id|ifconf
id|ifc
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_char
op_star
id|pos
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|total
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fetch the caller&squot;s info block. &n;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ifc
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifconf
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|pos
op_assign
id|ifc.ifc_buf
suffix:semicolon
id|len
op_assign
id|ifc.ifc_len
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Loop over the interfaces, and write an info block for each. &n;&t; */
id|total
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NPROTO
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|gifconf_list
(braket
id|i
)braket
)paren
(brace
r_int
id|done
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_eq
l_int|NULL
)paren
(brace
id|done
op_assign
id|gifconf_list
(braket
id|i
)braket
(paren
id|dev
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|done
op_assign
id|gifconf_list
(braket
id|i
)braket
(paren
id|dev
comma
id|pos
op_plus
id|total
comma
id|len
op_minus
id|total
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|done
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|total
op_add_assign
id|done
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; *&t;All done.  Write the updated control block back to the caller. &n;&t; */
id|ifc.ifc_len
op_assign
id|total
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifc
comma
r_sizeof
(paren
r_struct
id|ifconf
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* &n;&t; * &t;Both BSD and Solaris return 0 here, so we do too.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is invoked by the /proc filesystem handler to display a device&n; *&t;in detail.&n; */
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|sprintf_stats
r_static
r_int
id|sprintf_stats
c_func
(paren
r_char
op_star
id|buffer
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_device_stats
op_star
id|stats
op_assign
(paren
id|dev-&gt;get_stats
ques
c_cond
id|dev
op_member_access_from_pointer
id|get_stats
c_func
(paren
id|dev
)paren
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|stats
)paren
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%6s:%8lu %7lu %4lu %4lu %4lu %5lu %10lu %9lu %8lu %7lu %4lu %4lu %4lu %5lu %7lu %10lu&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|stats-&gt;rx_bytes
comma
id|stats-&gt;rx_packets
comma
id|stats-&gt;rx_errors
comma
id|stats-&gt;rx_dropped
op_plus
id|stats-&gt;rx_missed_errors
comma
id|stats-&gt;rx_fifo_errors
comma
id|stats-&gt;rx_length_errors
op_plus
id|stats-&gt;rx_over_errors
op_plus
id|stats-&gt;rx_crc_errors
op_plus
id|stats-&gt;rx_frame_errors
comma
id|stats-&gt;rx_compressed
comma
id|stats-&gt;multicast
comma
id|stats-&gt;tx_bytes
comma
id|stats-&gt;tx_packets
comma
id|stats-&gt;tx_errors
comma
id|stats-&gt;tx_dropped
comma
id|stats-&gt;tx_fifo_errors
comma
id|stats-&gt;collisions
comma
id|stats-&gt;tx_carrier_errors
op_plus
id|stats-&gt;tx_aborted_errors
op_plus
id|stats-&gt;tx_window_errors
op_plus
id|stats-&gt;tx_heartbeat_errors
comma
id|stats-&gt;tx_compressed
)paren
suffix:semicolon
r_else
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%6s: No statistics available.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Called from the PROCfs module. This now uses the new arbitrary sized /proc/net interface&n; *&t;to create /proc/net/dev&n; */
DECL|function|dev_get_info
r_static
r_int
id|dev_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|size
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;Inter-|   Receive                                                |  Transmit&bslash;n&quot;
l_string|&quot; face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
id|size
op_assign
id|sprintf_stats
c_func
(paren
id|buffer
op_plus
id|len
comma
id|dev
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start slop */
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
multiline_comment|/* Ending slop */
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|dev_proc_stats
r_static
r_int
id|dev_proc_stats
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%08x %08x %08x %08x %08x&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|netdev_rx_dropped
)paren
comma
macro_line|#ifdef CONFIG_NET_HW_FLOWCONTROL
id|netdev_throttle_events
comma
macro_line|#else
l_int|0
comma
macro_line|#endif
macro_line|#ifdef CONFIG_NET_FASTROUTE
id|dev_fastroute_stat.hits
comma
id|dev_fastroute_stat.succeed
comma
id|dev_fastroute_stat.deferred
macro_line|#else
l_int|0
comma
l_int|0
comma
l_int|0
macro_line|#endif
)paren
suffix:semicolon
id|len
op_sub_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
)brace
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_PROC_FS */
macro_line|#ifdef CONFIG_NET_RADIO
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/*&n; * Print one entry of /proc/net/wireless&n; * This is a clone of /proc/net/dev (just above)&n; */
DECL|function|sprintf_wireless_stats
r_static
r_int
id|sprintf_wireless_stats
c_func
(paren
r_char
op_star
id|buffer
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* Get stats from the driver */
r_struct
id|iw_statistics
op_star
id|stats
op_assign
(paren
id|dev-&gt;get_wireless_stats
ques
c_cond
id|dev
op_member_access_from_pointer
id|get_wireless_stats
c_func
(paren
id|dev
)paren
suffix:colon
(paren
r_struct
id|iw_statistics
op_star
)paren
l_int|NULL
)paren
suffix:semicolon
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|stats
op_ne
(paren
r_struct
id|iw_statistics
op_star
)paren
l_int|NULL
)paren
(brace
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%6s: %04x  %3d%c  %3d%c  %3d%c  %6d %6d %6d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|stats-&gt;status
comma
id|stats-&gt;qual.qual
comma
id|stats-&gt;qual.updated
op_amp
l_int|1
ques
c_cond
l_char|&squot;.&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|stats-&gt;qual.level
comma
id|stats-&gt;qual.updated
op_amp
l_int|2
ques
c_cond
l_char|&squot;.&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|stats-&gt;qual.noise
comma
id|stats-&gt;qual.updated
op_amp
l_int|4
ques
c_cond
l_char|&squot;.&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|stats-&gt;discard.nwid
comma
id|stats-&gt;discard.code
comma
id|stats-&gt;discard.misc
)paren
suffix:semicolon
id|stats-&gt;qual.updated
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|size
op_assign
l_int|0
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * Print info for /proc/net/wireless (print all entries)&n; * This is a clone of /proc/net/dev (just above)&n; */
DECL|function|dev_get_wireless_info
r_static
r_int
id|dev_get_wireless_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|size
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;Inter-| sta-|   Quality        |   Discarded packets&bslash;n&quot;
l_string|&quot; face | tus | link level noise |  nwid  crypt   misc&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
id|size
op_assign
id|sprintf_wireless_stats
c_func
(paren
id|buffer
op_plus
id|len
comma
id|dev
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start slop */
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
multiline_comment|/* Ending slop */
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_PROC_FS */
macro_line|#endif&t;/* CONFIG_NET_RADIO */
DECL|function|dev_set_promiscuity
r_void
id|dev_set_promiscuity
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|inc
)paren
(brace
r_int
r_int
id|old_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|IFF_PROMISC
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;promiscuity
op_add_assign
id|inc
)paren
op_eq
l_int|0
)paren
id|dev-&gt;flags
op_and_assign
op_complement
id|IFF_PROMISC
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_xor
id|old_flags
)paren
(brace
macro_line|#ifdef CONFIG_NET_FASTROUTE
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|netdev_fastroute_obstacles
op_increment
suffix:semicolon
id|dev_clear_fastroute
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
id|netdev_fastroute_obstacles
op_decrement
suffix:semicolon
macro_line|#endif
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;device %s %s promiscuous mode&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
ques
c_cond
l_string|&quot;entered&quot;
suffix:colon
l_string|&quot;left&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|dev_set_allmulti
r_void
id|dev_set_allmulti
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|inc
)paren
(brace
r_int
r_int
id|old_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|IFF_ALLMULTI
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;allmulti
op_add_assign
id|inc
)paren
op_eq
l_int|0
)paren
id|dev-&gt;flags
op_and_assign
op_complement
id|IFF_ALLMULTI
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_xor
id|old_flags
)paren
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|dev_change_flags
r_int
id|dev_change_flags
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|flags
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|old_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Set the flags on our device.&n;&t; */
id|dev-&gt;flags
op_assign
(paren
id|flags
op_amp
(paren
id|IFF_DEBUG
op_or
id|IFF_NOTRAILERS
op_or
id|IFF_RUNNING
op_or
id|IFF_NOARP
op_or
id|IFF_SLAVE
op_or
id|IFF_MASTER
op_or
id|IFF_DYNAMIC
op_or
id|IFF_MULTICAST
op_or
id|IFF_PORTSEL
op_or
id|IFF_AUTOMEDIA
)paren
)paren
op_or
(paren
id|dev-&gt;flags
op_amp
(paren
id|IFF_UP
op_or
id|IFF_VOLATILE
op_or
id|IFF_PROMISC
op_or
id|IFF_ALLMULTI
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Load in the correct multicast list now the flags have changed.&n;&t; */
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Have we downed the interface. We handle IFF_UP ourselves&n;&t; *&t;according to user attempts to set it, rather than blindly&n;&t; *&t;setting it.&n;&t; */
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|old_flags
op_xor
id|flags
)paren
op_amp
id|IFF_UP
)paren
multiline_comment|/* Bit is different  ? */
(brace
id|ret
op_assign
(paren
(paren
id|old_flags
op_amp
id|IFF_UP
)paren
ques
c_cond
id|dev_close
suffix:colon
id|dev_open
)paren
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|dev_mc_upload
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
op_logical_and
(paren
(paren
id|old_flags
op_xor
id|dev-&gt;flags
)paren
op_amp
op_complement
(paren
id|IFF_UP
op_or
id|IFF_RUNNING
op_or
id|IFF_PROMISC
op_or
id|IFF_ALLMULTI
op_or
id|IFF_VOLATILE
)paren
)paren
)paren
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGE
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_xor
id|dev-&gt;gflags
)paren
op_amp
id|IFF_PROMISC
)paren
(brace
r_int
id|inc
op_assign
(paren
id|flags
op_amp
id|IFF_PROMISC
)paren
ques
c_cond
op_plus
l_int|1
suffix:colon
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;gflags
op_xor_assign
id|IFF_PROMISC
suffix:semicolon
id|dev_set_promiscuity
c_func
(paren
id|dev
comma
id|inc
)paren
suffix:semicolon
)brace
multiline_comment|/* NOTE: order of synchronization of IFF_PROMISC and IFF_ALLMULTI&n;&t;   is important. Some (broken) drivers set IFF_PROMISC, when&n;&t;   IFF_ALLMULTI is requested not asking us and not reporting.&n;&t; */
r_if
c_cond
(paren
(paren
id|flags
op_xor
id|dev-&gt;gflags
)paren
op_amp
id|IFF_ALLMULTI
)paren
(brace
r_int
id|inc
op_assign
(paren
id|flags
op_amp
id|IFF_ALLMULTI
)paren
ques
c_cond
op_plus
l_int|1
suffix:colon
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;gflags
op_xor_assign
id|IFF_ALLMULTI
suffix:semicolon
id|dev_set_allmulti
c_func
(paren
id|dev
comma
id|inc
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Perform the SIOCxIFxxx calls. &n; */
DECL|function|dev_ifsioc
r_static
r_int
id|dev_ifsioc
c_func
(paren
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
r_int
id|cmd
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|__dev_get_by_name
c_func
(paren
id|ifr-&gt;ifr_name
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCGIFFLAGS
suffix:colon
multiline_comment|/* Get interface flags */
id|ifr-&gt;ifr_flags
op_assign
(paren
id|dev-&gt;flags
op_amp
op_complement
(paren
id|IFF_PROMISC
op_or
id|IFF_ALLMULTI
)paren
)paren
op_or
(paren
id|dev-&gt;gflags
op_amp
(paren
id|IFF_PROMISC
op_or
id|IFF_ALLMULTI
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFFLAGS
suffix:colon
multiline_comment|/* Set interface flags */
r_return
id|dev_change_flags
c_func
(paren
id|dev
comma
id|ifr-&gt;ifr_flags
)paren
suffix:semicolon
r_case
id|SIOCGIFMETRIC
suffix:colon
multiline_comment|/* Get the metric on the interface (currently unused) */
id|ifr-&gt;ifr_metric
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFMETRIC
suffix:colon
multiline_comment|/* Set the metric on the interface (currently unused) */
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_case
id|SIOCGIFMTU
suffix:colon
multiline_comment|/* Get the MTU of a device */
id|ifr-&gt;ifr_mtu
op_assign
id|dev-&gt;mtu
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFMTU
suffix:colon
multiline_comment|/* Set the MTU of a device */
r_if
c_cond
(paren
id|ifr-&gt;ifr_mtu
op_eq
id|dev-&gt;mtu
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;MTU must be positive.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ifr-&gt;ifr_mtu
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;change_mtu
)paren
id|err
op_assign
id|dev
op_member_access_from_pointer
id|change_mtu
c_func
(paren
id|dev
comma
id|ifr-&gt;ifr_mtu
)paren
suffix:semicolon
r_else
(brace
id|dev-&gt;mtu
op_assign
id|ifr-&gt;ifr_mtu
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGEMTU
comma
id|dev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
r_case
id|SIOCGIFHWADDR
suffix:colon
id|memcpy
c_func
(paren
id|ifr-&gt;ifr_hwaddr.sa_data
comma
id|dev-&gt;dev_addr
comma
id|MAX_ADDR_LEN
)paren
suffix:semicolon
id|ifr-&gt;ifr_hwaddr.sa_family
op_assign
id|dev-&gt;type
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFHWADDR
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_mac_address
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ifr-&gt;ifr_hwaddr.sa_family
op_ne
id|dev-&gt;type
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|err
op_assign
id|dev
op_member_access_from_pointer
id|set_mac_address
c_func
(paren
id|dev
comma
op_amp
id|ifr-&gt;ifr_hwaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGEADDR
comma
id|dev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
r_case
id|SIOCSIFHWBROADCAST
suffix:colon
r_if
c_cond
(paren
id|ifr-&gt;ifr_hwaddr.sa_family
op_ne
id|dev-&gt;type
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|dev-&gt;broadcast
comma
id|ifr-&gt;ifr_hwaddr.sa_data
comma
id|MAX_ADDR_LEN
)paren
suffix:semicolon
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGEADDR
comma
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCGIFMAP
suffix:colon
id|ifr-&gt;ifr_map.mem_start
op_assign
id|dev-&gt;mem_start
suffix:semicolon
id|ifr-&gt;ifr_map.mem_end
op_assign
id|dev-&gt;mem_end
suffix:semicolon
id|ifr-&gt;ifr_map.base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|ifr-&gt;ifr_map.irq
op_assign
id|dev-&gt;irq
suffix:semicolon
id|ifr-&gt;ifr_map.dma
op_assign
id|dev-&gt;dma
suffix:semicolon
id|ifr-&gt;ifr_map.port
op_assign
id|dev-&gt;if_port
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFMAP
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_config
)paren
r_return
id|dev
op_member_access_from_pointer
id|set_config
c_func
(paren
id|dev
comma
op_amp
id|ifr-&gt;ifr_map
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_case
id|SIOCADDMULTI
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_multicast_list
op_eq
l_int|NULL
op_logical_or
id|ifr-&gt;ifr_hwaddr.sa_family
op_ne
id|AF_UNSPEC
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev_mc_add
c_func
(paren
id|dev
comma
id|ifr-&gt;ifr_hwaddr.sa_data
comma
id|dev-&gt;addr_len
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCDELMULTI
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_multicast_list
op_eq
l_int|NULL
op_logical_or
id|ifr-&gt;ifr_hwaddr.sa_family
op_ne
id|AF_UNSPEC
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev_mc_delete
c_func
(paren
id|dev
comma
id|ifr-&gt;ifr_hwaddr.sa_data
comma
id|dev-&gt;addr_len
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCGIFINDEX
suffix:colon
id|ifr-&gt;ifr_ifindex
op_assign
id|dev-&gt;ifindex
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCGIFTXQLEN
suffix:colon
id|ifr-&gt;ifr_qlen
op_assign
id|dev-&gt;tx_queue_len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFTXQLEN
suffix:colon
r_if
c_cond
(paren
id|ifr-&gt;ifr_qlen
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev-&gt;tx_queue_len
op_assign
id|ifr-&gt;ifr_qlen
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFNAME
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|__dev_get_by_name
c_func
(paren
id|ifr-&gt;ifr_newname
)paren
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;name
comma
id|ifr-&gt;ifr_newname
comma
id|IFNAMSIZ
)paren
suffix:semicolon
id|dev-&gt;name
(braket
id|IFNAMSIZ
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_CHANGENAME
comma
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Unknown or private ioctl&n;&t;&t; */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|cmd
op_ge
id|SIOCDEVPRIVATE
op_logical_and
id|cmd
op_le
id|SIOCDEVPRIVATE
op_plus
l_int|15
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;do_ioctl
)paren
r_return
id|dev
op_member_access_from_pointer
id|do_ioctl
c_func
(paren
id|dev
comma
id|ifr
comma
id|cmd
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_RADIO
r_if
c_cond
(paren
id|cmd
op_ge
id|SIOCIWFIRST
op_logical_and
id|cmd
op_le
id|SIOCIWLAST
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;do_ioctl
)paren
r_return
id|dev
op_member_access_from_pointer
id|do_ioctl
c_func
(paren
id|dev
comma
id|ifr
comma
id|cmd
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_NET_RADIO */
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This function handles all &quot;interface&quot;-type I/O control requests. The actual&n; *&t;&squot;doing&squot; part of this is dev_ifsioc above.&n; */
DECL|function|dev_ioctl
r_int
id|dev_ioctl
c_func
(paren
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|ifreq
id|ifr
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_char
op_star
id|colon
suffix:semicolon
multiline_comment|/* One special case: SIOCGIFCONF takes ifconf argument&n;&t;   and requires shared lock, because it sleeps writing&n;&t;   to user space.&n;&t; */
r_if
c_cond
(paren
id|cmd
op_eq
id|SIOCGIFCONF
)paren
(brace
id|rtnl_shlock
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|dev_ifconf
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
id|rtnl_shunlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|SIOCGIFNAME
)paren
(brace
r_return
id|dev_ifname
c_func
(paren
(paren
r_struct
id|ifreq
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ifr
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ifr.ifr_name
(braket
id|IFNAMSIZ
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|colon
op_assign
id|strchr
c_func
(paren
id|ifr.ifr_name
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|colon
)paren
op_star
id|colon
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;See which interface the caller is talking about. &n;&t; */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;These ioctl calls:&n;&t;&t; *&t;- can be done by all.&n;&t;&t; *&t;- atomic and do not require locking.&n;&t;&t; *&t;- return a value&n;&t;&t; */
r_case
id|SIOCGIFFLAGS
suffix:colon
r_case
id|SIOCGIFMETRIC
suffix:colon
r_case
id|SIOCGIFMTU
suffix:colon
r_case
id|SIOCGIFHWADDR
suffix:colon
r_case
id|SIOCGIFSLAVE
suffix:colon
r_case
id|SIOCGIFMAP
suffix:colon
r_case
id|SIOCGIFINDEX
suffix:colon
r_case
id|SIOCGIFTXQLEN
suffix:colon
id|dev_load
c_func
(paren
id|ifr.ifr_name
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|ret
op_assign
id|dev_ifsioc
c_func
(paren
op_amp
id|ifr
comma
id|cmd
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
r_if
c_cond
(paren
id|colon
)paren
op_star
id|colon
op_assign
l_char|&squot;:&squot;
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;These ioctl calls:&n;&t;&t; *&t;- require superuser power.&n;&t;&t; *&t;- require strict serialization.&n;&t;&t; *&t;- do not return a value&n;&t;&t; */
r_case
id|SIOCSIFFLAGS
suffix:colon
r_case
id|SIOCSIFMETRIC
suffix:colon
r_case
id|SIOCSIFMTU
suffix:colon
r_case
id|SIOCSIFMAP
suffix:colon
r_case
id|SIOCSIFHWADDR
suffix:colon
r_case
id|SIOCSIFSLAVE
suffix:colon
r_case
id|SIOCADDMULTI
suffix:colon
r_case
id|SIOCDELMULTI
suffix:colon
r_case
id|SIOCSIFHWBROADCAST
suffix:colon
r_case
id|SIOCSIFTXQLEN
suffix:colon
r_case
id|SIOCSIFNAME
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|dev_load
c_func
(paren
id|ifr.ifr_name
)paren
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|dev_ifsioc
c_func
(paren
op_amp
id|ifr
comma
id|cmd
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
r_case
id|SIOCGIFMEM
suffix:colon
multiline_comment|/* Get the per device memory space. We can add this but currently&n;&t;&t;&t;   do not support it */
r_case
id|SIOCSIFMEM
suffix:colon
multiline_comment|/* Set the per device memory buffer space. Not applicable in our case */
r_case
id|SIOCSIFLINK
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Unknown or private ioctl.&n;&t;&t; */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|cmd
op_ge
id|SIOCDEVPRIVATE
op_logical_and
id|cmd
op_le
id|SIOCDEVPRIVATE
op_plus
l_int|15
)paren
(brace
id|dev_load
c_func
(paren
id|ifr.ifr_name
)paren
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|dev_ifsioc
c_func
(paren
op_amp
id|ifr
comma
id|cmd
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_RADIO
r_if
c_cond
(paren
id|cmd
op_ge
id|SIOCIWFIRST
op_logical_and
id|cmd
op_le
id|SIOCIWLAST
)paren
(brace
id|dev_load
c_func
(paren
id|ifr.ifr_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IW_IS_SET
c_func
(paren
id|cmd
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|dev_ifsioc
c_func
(paren
op_amp
id|ifr
comma
id|cmd
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
id|IW_IS_GET
c_func
(paren
id|cmd
)paren
op_logical_and
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_NET_RADIO */
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|dev_new_index
r_int
id|dev_new_index
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|ifindex
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_increment
id|ifindex
op_le
l_int|0
)paren
id|ifindex
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|__dev_get_by_index
c_func
(paren
id|ifindex
)paren
op_eq
l_int|NULL
)paren
r_return
id|ifindex
suffix:semicolon
)brace
)brace
DECL|variable|dev_boot_phase
r_static
r_int
id|dev_boot_phase
op_assign
l_int|1
suffix:semicolon
DECL|function|register_netdevice
r_int
id|register_netdevice
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_device
op_star
id|d
comma
op_star
op_star
id|dp
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|dev-&gt;xmit_lock
)paren
suffix:semicolon
id|dev-&gt;xmit_lock_owner
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_NET_FASTROUTE
id|dev-&gt;fastpath_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|dev_boot_phase
)paren
(brace
multiline_comment|/* This is NOT bug, but I am not sure, that all the&n;&t;&t;   devices, initialized before netdev module is started&n;&t;&t;   are sane. &n;&n;&t;&t;   Now they are chained to device boot list&n;&t;&t;   and probed later. If a module is initialized&n;&t;&t;   before netdev, but assumes that dev-&gt;init&n;&t;&t;   is really called by register_netdev(), it will fail.&n;&n;&t;&t;   So that this message should be printed for a while.&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;early initialization of device %s is deferred&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Check for existence, and append to tail of chain */
r_for
c_loop
(paren
id|dp
op_assign
op_amp
id|dev_base
suffix:semicolon
(paren
id|d
op_assign
op_star
id|dp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|dp
op_assign
op_amp
id|d-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|d
op_eq
id|dev
op_logical_or
id|strcmp
c_func
(paren
id|d-&gt;name
comma
id|dev-&gt;name
)paren
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
)brace
id|dev-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
op_star
id|dp
op_assign
id|dev
suffix:semicolon
id|dev_hold
c_func
(paren
id|dev
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dev-&gt;iflink
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Init, if this function is available */
r_if
c_cond
(paren
id|dev-&gt;init
op_logical_and
id|dev
op_member_access_from_pointer
id|init
c_func
(paren
id|dev
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|dev-&gt;ifindex
op_assign
id|dev_new_index
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;iflink
op_eq
op_minus
l_int|1
)paren
id|dev-&gt;iflink
op_assign
id|dev-&gt;ifindex
suffix:semicolon
multiline_comment|/* Check for existence, and append to tail of chain */
r_for
c_loop
(paren
id|dp
op_assign
op_amp
id|dev_base
suffix:semicolon
(paren
id|d
op_assign
op_star
id|dp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|dp
op_assign
op_amp
id|d-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|d
op_eq
id|dev
op_logical_or
id|strcmp
c_func
(paren
id|d-&gt;name
comma
id|dev-&gt;name
)paren
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;nil rebuild_header routine,&n;&t; *&t;that should be never called and used as just bug trap.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;rebuild_header
op_eq
l_int|NULL
)paren
id|dev-&gt;rebuild_header
op_assign
id|default_rebuild_header
suffix:semicolon
id|dev-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|dev_init_scheduler
c_func
(paren
id|dev
)paren
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
op_star
id|dp
op_assign
id|dev
suffix:semicolon
id|dev_hold
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;deadbeaf
op_assign
l_int|0
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
multiline_comment|/* Notify protocols, that a new device appeared. */
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_REGISTER
comma
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|netdev_finish_unregister
r_int
id|netdev_finish_unregister
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|BUG_TRAP
c_func
(paren
id|dev-&gt;ip_ptr
op_eq
l_int|NULL
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|dev-&gt;ip6_ptr
op_eq
l_int|NULL
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|dev-&gt;dn_ptr
op_eq
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;deadbeaf
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Freeing alive device %p, %s&bslash;n&quot;
comma
id|dev
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef NET_REFCNT_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;netdev_finish_unregister: %s%s.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;new_style
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;, old style&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|dev-&gt;destructor
)paren
id|dev
op_member_access_from_pointer
id|destructor
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;new_style
)paren
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unregister_netdevice
r_int
id|unregister_netdevice
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|now
suffix:semicolon
r_struct
id|net_device
op_star
id|d
comma
op_star
op_star
id|dp
suffix:semicolon
multiline_comment|/* If device is running, close it first. */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
id|dev_close
c_func
(paren
id|dev
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|dev-&gt;deadbeaf
op_eq
l_int|0
)paren
suffix:semicolon
id|dev-&gt;deadbeaf
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* And unlink it from device chain. */
r_for
c_loop
(paren
id|dp
op_assign
op_amp
id|dev_base
suffix:semicolon
(paren
id|d
op_assign
op_star
id|dp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|dp
op_assign
op_amp
id|d-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|d
op_eq
id|dev
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
op_star
id|dp
op_assign
id|d-&gt;next
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|d
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;unregister_netdevice: device %s/%p never was registered&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev_boot_phase
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef CONFIG_NET_FASTROUTE
id|dev_clear_fastroute
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Shutdown queueing discipline. */
id|dev_shutdown
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Notify protocols, that we are about to destroy&n;&t;&t;   this device. They should clean all the things.&n;&t;&t; */
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_UNREGISTER
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Flush the multicast chain&n;&t;&t; */
id|dev_mc_discard
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;uninit
)paren
id|dev
op_member_access_from_pointer
id|uninit
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;new_style
)paren
(brace
macro_line|#ifdef NET_REFCNT_DEBUG
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
op_ne
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;unregister_netdevice: holding %s refcnt=%d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|atomic_read
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Last reference is our one */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
op_eq
l_int|1
)paren
(brace
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef NET_REFCNT_DEBUG
id|printk
c_func
(paren
l_string|&quot;unregister_netdevice: waiting %s refcnt=%d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|atomic_read
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* EXPLANATION. If dev-&gt;refcnt is not 1 now (1 is our own reference)&n;&t;   it means that someone in the kernel still has reference&n;&t;   to this device and we cannot release it.&n;&n;&t;   &quot;New style&quot; devices have destructors, hence we can return from this&n;&t;   function and destructor will do all the work later.&n;&n;&t;   &quot;Old style&quot; devices expect that device is free of any references&n;&t;   upon exit from this function. WE CANNOT MAKE such release&n;&t;   without delay. Note that it is not new feature. Referencing devices&n;&t;   after they are released occured in 2.0 and 2.2.&n;&t;   Now we just can know about each fact of illegal usage.&n;&n;&t;   So, we linger for 10*HZ (it is an arbitrary number)&n;&n;&t;   After 1 second, we start to rebroadcast unregister notifications&n;&t;   in hope that careless clients will release the device.&n;&n;&t;   If timeout expired, we have no choice how to cross fingers&n;&t;   and return. Real alternative would be block here forever&n;&t;   and we will make it eventually, when all peaceful citizens&n;&t;   will be notified and repaired.&n;&t; */
id|now
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|now
)paren
OG
l_int|1
op_star
id|HZ
)paren
(brace
multiline_comment|/* Rebroadcast unregister notification */
id|notifier_call_chain
c_func
(paren
op_amp
id|netdev_chain
comma
id|NETDEV_UNREGISTER
comma
id|dev
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|4
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|now
)paren
OG
l_int|10
op_star
id|HZ
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
op_ne
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;unregister_netdevice: Old style device %s leaked(refcnt=%d). Wait for crash.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|atomic_read
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Initialize the DEV module. At boot time this walks the device list and&n; *&t;unhooks any devices that fail to initialise (normally hardware not &n; *&t;present) and leaves us with a valid list of present and active devices.&n; *&n; */
r_extern
r_void
id|net_device_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|ip_auto_config
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|net_dev_init
r_int
id|__init
id|net_dev_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|net_device
op_star
id|dev
comma
op_star
op_star
id|dp
suffix:semicolon
macro_line|#ifdef CONFIG_NET_SCHED
id|pktsched_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Initialise the packet receive queue.&n;&t; */
id|skb_queue_head_init
c_func
(paren
op_amp
id|backlog
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;The bridge has to be up before the devices&n;&t; */
macro_line|#ifdef CONFIG_BRIDGE&t; 
id|br_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif&t;
macro_line|#ifdef CONFIG_NET_PROFILE
id|net_profile_init
c_func
(paren
)paren
suffix:semicolon
id|NET_PROFILE_REGISTER
c_func
(paren
id|dev_queue_xmit
)paren
suffix:semicolon
id|NET_PROFILE_REGISTER
c_func
(paren
id|net_bh
)paren
suffix:semicolon
macro_line|#if 0
id|NET_PROFILE_REGISTER
c_func
(paren
id|net_bh_skb
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Add the devices.&n;&t; *&t;If the call to dev-&gt;init fails, the dev is removed&n;&t; *&t;from the chain disconnecting the device until the&n;&t; *&t;next reboot.&n;&t; *&n;&t; *&t;NB At boot phase networking is dead. No locking is required.&n;&t; *&t;But we still preserve dev_base_lock for sanity.&n;&t; */
id|dp
op_assign
op_amp
id|dev_base
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dev
op_assign
op_star
id|dp
)paren
op_ne
l_int|NULL
)paren
(brace
id|spin_lock_init
c_func
(paren
op_amp
id|dev-&gt;queue_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|dev-&gt;xmit_lock
)paren
suffix:semicolon
id|dev-&gt;xmit_lock_owner
op_assign
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;iflink
op_assign
op_minus
l_int|1
suffix:semicolon
id|dev_hold
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;We can allocate the name ahead of time. If the&n;&t;&t; *&t;init fails the name will be reissued correctly.&n;&t;&t; */
r_if
c_cond
(paren
id|strchr
c_func
(paren
id|dev-&gt;name
comma
l_char|&squot;%&squot;
)paren
)paren
id|dev_alloc_name
c_func
(paren
id|dev
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;init
op_logical_and
id|dev
op_member_access_from_pointer
id|init
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;It failed to come up. Unhook it.&n;&t;&t;&t; */
id|write_lock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
op_star
id|dp
op_assign
id|dev-&gt;next
suffix:semicolon
id|dev-&gt;deadbeaf
op_assign
l_int|1
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|dp
op_assign
op_amp
id|dev-&gt;next
suffix:semicolon
id|dev-&gt;ifindex
op_assign
id|dev_new_index
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;iflink
op_eq
op_minus
l_int|1
)paren
id|dev-&gt;iflink
op_assign
id|dev-&gt;ifindex
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;rebuild_header
op_eq
l_int|NULL
)paren
id|dev-&gt;rebuild_header
op_assign
id|default_rebuild_header
suffix:semicolon
id|dev_init_scheduler
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_PROC_FS
id|proc_net_create
c_func
(paren
l_string|&quot;dev&quot;
comma
l_int|0
comma
id|dev_get_info
)paren
suffix:semicolon
id|create_proc_read_entry
c_func
(paren
l_string|&quot;net/dev_stat&quot;
comma
l_int|0
comma
l_int|0
comma
id|dev_proc_stats
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET_RADIO
id|proc_net_create
c_func
(paren
l_string|&quot;wireless&quot;
comma
l_int|0
comma
id|dev_get_wireless_info
)paren
suffix:semicolon
macro_line|#endif&t;/* CONFIG_NET_RADIO */
macro_line|#endif&t;/* CONFIG_PROC_FS */
id|init_bh
c_func
(paren
id|NET_BH
comma
id|net_bh
)paren
suffix:semicolon
id|dev_boot_phase
op_assign
l_int|0
suffix:semicolon
id|dst_init
c_func
(paren
)paren
suffix:semicolon
id|dev_mcast_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Initialise network devices&n;&t; */
id|net_device_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IP_PNP
id|ip_auto_config
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
eof
