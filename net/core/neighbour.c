multiline_comment|/*&n; *&t;Generic address resolution entity&n; *&n; *&t;Authors:&n; *&t;Pedro Roque&t;&t;&lt;roque@di.fc.ul.pt&gt;&n; *&t;Alexey Kuznetsov&t;&lt;kuznet@ms2.inr.ac.ru&gt;&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *      modify it under the terms of the GNU General Public License&n; *      as published by the Free Software Foundation; either version&n; *      2 of the License, or (at your option) any later version.&n; *&n; *&t;Fixes:&n; *&t;Vitaly E. Lavrov&t;releasing NULL neighbor in neigh_add.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#ifdef CONFIG_SYSCTL
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#endif
macro_line|#include &lt;net/neighbour.h&gt;
macro_line|#include &lt;net/dst.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
DECL|macro|NEIGH_DEBUG
mdefine_line|#define NEIGH_DEBUG 1
DECL|macro|NEIGH_PRINTK
mdefine_line|#define NEIGH_PRINTK(x...) printk(x)
DECL|macro|NEIGH_NOPRINTK
mdefine_line|#define NEIGH_NOPRINTK(x...) do { ; } while(0)
DECL|macro|NEIGH_PRINTK0
mdefine_line|#define NEIGH_PRINTK0 NEIGH_PRINTK
DECL|macro|NEIGH_PRINTK1
mdefine_line|#define NEIGH_PRINTK1 NEIGH_NOPRINTK
DECL|macro|NEIGH_PRINTK2
mdefine_line|#define NEIGH_PRINTK2 NEIGH_NOPRINTK
macro_line|#if NEIGH_DEBUG &gt;= 1
DECL|macro|NEIGH_PRINTK1
macro_line|#undef NEIGH_PRINTK1
DECL|macro|NEIGH_PRINTK1
mdefine_line|#define NEIGH_PRINTK1 NEIGH_PRINTK
macro_line|#endif
macro_line|#if NEIGH_DEBUG &gt;= 2
DECL|macro|NEIGH_PRINTK2
macro_line|#undef NEIGH_PRINTK2
DECL|macro|NEIGH_PRINTK2
mdefine_line|#define NEIGH_PRINTK2 NEIGH_PRINTK
macro_line|#endif
r_static
r_void
id|neigh_timer_handler
c_func
(paren
r_int
r_int
id|arg
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ARPD
r_static
r_void
id|neigh_app_notify
c_func
(paren
r_struct
id|neighbour
op_star
id|n
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|pneigh_ifdown
c_func
(paren
r_struct
id|neigh_table
op_star
id|tbl
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
DECL|variable|neigh_glbl_allocs
r_static
r_int
id|neigh_glbl_allocs
suffix:semicolon
DECL|variable|neigh_tables
r_static
r_struct
id|neigh_table
op_star
id|neigh_tables
suffix:semicolon
macro_line|#if defined(__i386__) &amp;&amp; defined(CONFIG_SMP)
DECL|macro|ASSERT_WL
mdefine_line|#define ASSERT_WL(n) if ((int)((n)-&gt;lock.lock) &gt; 0) { printk(&quot;WL assertion failed at &quot; __FILE__ &quot;(%d):&quot; __FUNCTION__ &quot;&bslash;n&quot;, __LINE__); }
macro_line|#else
DECL|macro|ASSERT_WL
mdefine_line|#define ASSERT_WL(n) do { } while(0)
macro_line|#endif
multiline_comment|/*&n;   Neighbour hash table buckets are protected with rwlock tbl-&gt;lock.&n;&n;   - All the scans/updates to hash buckets MUST be made under this lock.&n;   - NOTHING clever should be made under this lock: no callbacks&n;     to protocol backends, no attempts to send something to network.&n;     It will result in deadlocks, if backend/driver wants to use neighbour&n;     cache.&n;   - If the entry requires some non-trivial actions, increase&n;     its reference count and release table lock.&n; &n;   Neighbour entries are protected:&n;   - with reference count.&n;   - with rwlock neigh-&gt;lock&n;&n;   Reference count prevents destruction.&n;&n;   neigh-&gt;lock mainly serializes ll address data and its validity state.&n;   However, the same lock is used to protect another entry fields:&n;    - timer&n;    - resolution queue&n;&n;   Again, nothing clever shall be made under neigh-&gt;lock,&n;   the most complicated procedure, which we allow is dev-&gt;hard_header.&n;   It is supposed, that dev-&gt;hard_header is simplistic and does&n;   not make callbacks to neighbour tables.&n;&n;   The last lock is neigh_tbl_lock. It is pure SMP lock, protecting&n;   list of neighbour tables. This list is used only in process context,&n; */
DECL|variable|neigh_tbl_lock
r_static
id|rwlock_t
id|neigh_tbl_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
DECL|function|neigh_blackhole
r_static
r_int
id|neigh_blackhole
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|ENETDOWN
suffix:semicolon
)brace
multiline_comment|/*&n; * It is random distribution in the interval (1/2)*base...(3/2)*base.&n; * It corresponds to default IPv6 settings and is not overridable,&n; * because it is really reasonbale choice.&n; */
DECL|function|neigh_rand_reach_time
r_int
r_int
id|neigh_rand_reach_time
c_func
(paren
r_int
r_int
id|base
)paren
(brace
r_return
(paren
id|net_random
c_func
(paren
)paren
op_mod
id|base
)paren
op_plus
(paren
id|base
op_rshift
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|neigh_forced_gc
r_static
r_int
id|neigh_forced_gc
c_func
(paren
r_struct
id|neigh_table
op_star
id|tbl
)paren
(brace
r_int
id|shrunk
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|NEIGH_HASHMASK
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|neighbour
op_star
id|n
comma
op_star
op_star
id|np
suffix:semicolon
id|np
op_assign
op_amp
id|tbl-&gt;hash_buckets
(braket
id|i
)braket
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|n
op_assign
op_star
id|np
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Neighbour record may be discarded if:&n;&t;&t;&t;   - nobody refers to it.&n;&t;&t;&t;   - it is not premanent&n;&t;&t;&t;   - (NEW and probably wrong)&n;&t;&t;&t;     INCOMPLETE entries are kept at least for&n;&t;&t;&t;     n-&gt;parms-&gt;retrans_time, otherwise we could&n;&t;&t;&t;     flood network with resolution requests.&n;&t;&t;&t;     It is not clear, what is better table overflow&n;&t;&t;&t;     or flooding.&n;&t;&t;&t; */
id|write_lock
c_func
(paren
op_amp
id|n-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|n-&gt;refcnt
)paren
op_eq
l_int|1
op_logical_and
op_logical_neg
(paren
id|n-&gt;nud_state
op_amp
id|NUD_PERMANENT
)paren
op_logical_and
(paren
id|n-&gt;nud_state
op_ne
id|NUD_INCOMPLETE
op_logical_or
id|jiffies
op_minus
id|n-&gt;used
OG
id|n-&gt;parms-&gt;retrans_time
)paren
)paren
(brace
op_star
id|np
op_assign
id|n-&gt;next
suffix:semicolon
id|n-&gt;dead
op_assign
l_int|1
suffix:semicolon
id|shrunk
op_assign
l_int|1
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|n-&gt;lock
)paren
suffix:semicolon
id|neigh_release
c_func
(paren
id|n
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|n-&gt;lock
)paren
suffix:semicolon
id|np
op_assign
op_amp
id|n-&gt;next
suffix:semicolon
)brace
id|write_unlock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
)brace
id|tbl-&gt;last_flush
op_assign
id|jiffies
suffix:semicolon
r_return
id|shrunk
suffix:semicolon
)brace
DECL|function|neigh_del_timer
r_static
r_int
id|neigh_del_timer
c_func
(paren
r_struct
id|neighbour
op_star
id|n
)paren
(brace
r_if
c_cond
(paren
id|n-&gt;nud_state
op_amp
id|NUD_IN_TIMER
)paren
(brace
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
id|n-&gt;timer
)paren
)paren
(brace
id|neigh_release
c_func
(paren
id|n
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pneigh_queue_purge
r_static
r_void
id|pneigh_queue_purge
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
id|list
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|dev_put
c_func
(paren
id|skb-&gt;dev
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
DECL|function|neigh_ifdown
r_int
id|neigh_ifdown
c_func
(paren
r_struct
id|neigh_table
op_star
id|tbl
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|NEIGH_HASHMASK
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|neighbour
op_star
id|n
comma
op_star
op_star
id|np
suffix:semicolon
id|np
op_assign
op_amp
id|tbl-&gt;hash_buckets
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|n
op_assign
op_star
id|np
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|dev
op_logical_and
id|n-&gt;dev
op_ne
id|dev
)paren
(brace
id|np
op_assign
op_amp
id|n-&gt;next
suffix:semicolon
r_continue
suffix:semicolon
)brace
op_star
id|np
op_assign
id|n-&gt;next
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|n-&gt;lock
)paren
suffix:semicolon
id|neigh_del_timer
c_func
(paren
id|n
)paren
suffix:semicolon
id|n-&gt;dead
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|n-&gt;refcnt
)paren
op_ne
l_int|1
)paren
(brace
multiline_comment|/* The most unpleasant situation.&n;&t;&t;&t;&t;   We must destroy neighbour entry,&n;&t;&t;&t;&t;   but someone still uses it.&n;&n;&t;&t;&t;&t;   The destroy will be delayed until&n;&t;&t;&t;&t;   the last user releases us, but&n;&t;&t;&t;&t;   we must kill timers etc. and move&n;&t;&t;&t;&t;   it to safe state.&n;&t;&t;&t;&t; */
id|n-&gt;parms
op_assign
op_amp
id|tbl-&gt;parms
suffix:semicolon
id|skb_queue_purge
c_func
(paren
op_amp
id|n-&gt;arp_queue
)paren
suffix:semicolon
id|n-&gt;output
op_assign
id|neigh_blackhole
suffix:semicolon
r_if
c_cond
(paren
id|n-&gt;nud_state
op_amp
id|NUD_VALID
)paren
id|n-&gt;nud_state
op_assign
id|NUD_NOARP
suffix:semicolon
r_else
id|n-&gt;nud_state
op_assign
id|NUD_NONE
suffix:semicolon
id|NEIGH_PRINTK2
c_func
(paren
l_string|&quot;neigh %p is stray.&bslash;n&quot;
comma
id|n
)paren
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|n-&gt;lock
)paren
suffix:semicolon
id|neigh_release
c_func
(paren
id|n
)paren
suffix:semicolon
)brace
)brace
id|pneigh_ifdown
c_func
(paren
id|tbl
comma
id|dev
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|tbl-&gt;proxy_timer
)paren
suffix:semicolon
id|pneigh_queue_purge
c_func
(paren
op_amp
id|tbl-&gt;proxy_queue
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|neigh_alloc
r_static
r_struct
id|neighbour
op_star
id|neigh_alloc
c_func
(paren
r_struct
id|neigh_table
op_star
id|tbl
)paren
(brace
r_struct
id|neighbour
op_star
id|n
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|tbl-&gt;entries
OG
id|tbl-&gt;gc_thresh3
op_logical_or
(paren
id|tbl-&gt;entries
OG
id|tbl-&gt;gc_thresh2
op_logical_and
id|now
op_minus
id|tbl-&gt;last_flush
OG
l_int|5
op_star
id|HZ
)paren
)paren
(brace
r_if
c_cond
(paren
id|neigh_forced_gc
c_func
(paren
id|tbl
)paren
op_eq
l_int|0
op_logical_and
id|tbl-&gt;entries
OG
id|tbl-&gt;gc_thresh3
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
id|n
op_assign
id|kmem_cache_alloc
c_func
(paren
id|tbl-&gt;kmem_cachep
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|n
comma
l_int|0
comma
id|tbl-&gt;entry_size
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|n-&gt;arp_queue
)paren
suffix:semicolon
id|n-&gt;lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
id|n-&gt;updated
op_assign
id|n-&gt;used
op_assign
id|now
suffix:semicolon
id|n-&gt;nud_state
op_assign
id|NUD_NONE
suffix:semicolon
id|n-&gt;output
op_assign
id|neigh_blackhole
suffix:semicolon
id|n-&gt;parms
op_assign
op_amp
id|tbl-&gt;parms
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|n-&gt;timer
)paren
suffix:semicolon
id|n-&gt;timer.function
op_assign
id|neigh_timer_handler
suffix:semicolon
id|n-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|n
suffix:semicolon
id|tbl-&gt;stats.allocs
op_increment
suffix:semicolon
id|neigh_glbl_allocs
op_increment
suffix:semicolon
id|tbl-&gt;entries
op_increment
suffix:semicolon
id|n-&gt;tbl
op_assign
id|tbl
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|n-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|n-&gt;dead
op_assign
l_int|1
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|function|neigh_lookup
r_struct
id|neighbour
op_star
id|neigh_lookup
c_func
(paren
r_struct
id|neigh_table
op_star
id|tbl
comma
r_const
r_void
op_star
id|pkey
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|neighbour
op_star
id|n
suffix:semicolon
id|u32
id|hash_val
suffix:semicolon
r_int
id|key_len
op_assign
id|tbl-&gt;key_len
suffix:semicolon
id|hash_val
op_assign
id|tbl
op_member_access_from_pointer
id|hash
c_func
(paren
id|pkey
comma
id|dev
)paren
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|tbl-&gt;hash_buckets
(braket
id|hash_val
)braket
suffix:semicolon
id|n
suffix:semicolon
id|n
op_assign
id|n-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev
op_eq
id|n-&gt;dev
op_logical_and
id|memcmp
c_func
(paren
id|n-&gt;primary_key
comma
id|pkey
comma
id|key_len
)paren
op_eq
l_int|0
)paren
(brace
id|neigh_hold
c_func
(paren
id|n
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|function|neigh_create
r_struct
id|neighbour
op_star
id|neigh_create
c_func
(paren
r_struct
id|neigh_table
op_star
id|tbl
comma
r_const
r_void
op_star
id|pkey
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|neighbour
op_star
id|n
comma
op_star
id|n1
suffix:semicolon
id|u32
id|hash_val
suffix:semicolon
r_int
id|key_len
op_assign
id|tbl-&gt;key_len
suffix:semicolon
r_int
id|error
suffix:semicolon
id|n
op_assign
id|neigh_alloc
c_func
(paren
id|tbl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|NULL
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOBUFS
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|n-&gt;primary_key
comma
id|pkey
comma
id|key_len
)paren
suffix:semicolon
id|n-&gt;dev
op_assign
id|dev
suffix:semicolon
id|dev_hold
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Protocol specific setup. */
r_if
c_cond
(paren
id|tbl-&gt;constructor
op_logical_and
(paren
id|error
op_assign
id|tbl
op_member_access_from_pointer
id|constructor
c_func
(paren
id|n
)paren
)paren
OL
l_int|0
)paren
(brace
id|neigh_release
c_func
(paren
id|n
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/* Device specific setup. */
r_if
c_cond
(paren
id|n-&gt;parms
op_logical_and
id|n-&gt;parms-&gt;neigh_setup
op_logical_and
(paren
id|error
op_assign
id|n-&gt;parms
op_member_access_from_pointer
id|neigh_setup
c_func
(paren
id|n
)paren
)paren
OL
l_int|0
)paren
(brace
id|neigh_release
c_func
(paren
id|n
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
id|n-&gt;confirmed
op_assign
id|jiffies
op_minus
(paren
id|n-&gt;parms-&gt;base_reachable_time
op_lshift
l_int|1
)paren
suffix:semicolon
id|hash_val
op_assign
id|tbl
op_member_access_from_pointer
id|hash
c_func
(paren
id|pkey
comma
id|dev
)paren
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n1
op_assign
id|tbl-&gt;hash_buckets
(braket
id|hash_val
)braket
suffix:semicolon
id|n1
suffix:semicolon
id|n1
op_assign
id|n1-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev
op_eq
id|n1-&gt;dev
op_logical_and
id|memcmp
c_func
(paren
id|n1-&gt;primary_key
comma
id|pkey
comma
id|key_len
)paren
op_eq
l_int|0
)paren
(brace
id|neigh_hold
c_func
(paren
id|n1
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
id|neigh_release
c_func
(paren
id|n
)paren
suffix:semicolon
r_return
id|n1
suffix:semicolon
)brace
)brace
id|n-&gt;next
op_assign
id|tbl-&gt;hash_buckets
(braket
id|hash_val
)braket
suffix:semicolon
id|tbl-&gt;hash_buckets
(braket
id|hash_val
)braket
op_assign
id|n
suffix:semicolon
id|n-&gt;dead
op_assign
l_int|0
suffix:semicolon
id|neigh_hold
c_func
(paren
id|n
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
id|NEIGH_PRINTK2
c_func
(paren
l_string|&quot;neigh %p is created.&bslash;n&quot;
comma
id|n
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|function|pneigh_lookup
r_struct
id|pneigh_entry
op_star
id|pneigh_lookup
c_func
(paren
r_struct
id|neigh_table
op_star
id|tbl
comma
r_const
r_void
op_star
id|pkey
comma
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|creat
)paren
(brace
r_struct
id|pneigh_entry
op_star
id|n
suffix:semicolon
id|u32
id|hash_val
suffix:semicolon
r_int
id|key_len
op_assign
id|tbl-&gt;key_len
suffix:semicolon
id|hash_val
op_assign
op_star
(paren
id|u32
op_star
)paren
(paren
id|pkey
op_plus
id|key_len
op_minus
l_int|4
)paren
suffix:semicolon
id|hash_val
op_xor_assign
(paren
id|hash_val
op_rshift
l_int|16
)paren
suffix:semicolon
id|hash_val
op_xor_assign
id|hash_val
op_rshift
l_int|8
suffix:semicolon
id|hash_val
op_xor_assign
id|hash_val
op_rshift
l_int|4
suffix:semicolon
id|hash_val
op_and_assign
id|PNEIGH_HASHMASK
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|tbl-&gt;phash_buckets
(braket
id|hash_val
)braket
suffix:semicolon
id|n
suffix:semicolon
id|n
op_assign
id|n-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|n-&gt;key
comma
id|pkey
comma
id|key_len
)paren
op_eq
l_int|0
op_logical_and
(paren
id|n-&gt;dev
op_eq
id|dev
op_logical_or
op_logical_neg
id|n-&gt;dev
)paren
)paren
(brace
id|read_unlock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|creat
)paren
r_return
l_int|NULL
suffix:semicolon
id|n
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|n
)paren
op_plus
id|key_len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|memcpy
c_func
(paren
id|n-&gt;key
comma
id|pkey
comma
id|key_len
)paren
suffix:semicolon
id|n-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|tbl-&gt;pconstructor
op_logical_and
id|tbl
op_member_access_from_pointer
id|pconstructor
c_func
(paren
id|n
)paren
)paren
(brace
id|kfree
c_func
(paren
id|n
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|write_lock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
id|n-&gt;next
op_assign
id|tbl-&gt;phash_buckets
(braket
id|hash_val
)braket
suffix:semicolon
id|tbl-&gt;phash_buckets
(braket
id|hash_val
)braket
op_assign
id|n
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|function|pneigh_delete
r_int
id|pneigh_delete
c_func
(paren
r_struct
id|neigh_table
op_star
id|tbl
comma
r_const
r_void
op_star
id|pkey
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|pneigh_entry
op_star
id|n
comma
op_star
op_star
id|np
suffix:semicolon
id|u32
id|hash_val
suffix:semicolon
r_int
id|key_len
op_assign
id|tbl-&gt;key_len
suffix:semicolon
id|hash_val
op_assign
op_star
(paren
id|u32
op_star
)paren
(paren
id|pkey
op_plus
id|key_len
op_minus
l_int|4
)paren
suffix:semicolon
id|hash_val
op_xor_assign
(paren
id|hash_val
op_rshift
l_int|16
)paren
suffix:semicolon
id|hash_val
op_xor_assign
id|hash_val
op_rshift
l_int|8
suffix:semicolon
id|hash_val
op_xor_assign
id|hash_val
op_rshift
l_int|4
suffix:semicolon
id|hash_val
op_and_assign
id|PNEIGH_HASHMASK
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
op_amp
id|tbl-&gt;phash_buckets
(braket
id|hash_val
)braket
suffix:semicolon
(paren
id|n
op_assign
op_star
id|np
)paren
op_ne
l_int|NULL
suffix:semicolon
id|np
op_assign
op_amp
id|n-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|n-&gt;key
comma
id|pkey
comma
id|key_len
)paren
op_eq
l_int|0
op_logical_and
id|n-&gt;dev
op_eq
id|dev
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
op_star
id|np
op_assign
id|n-&gt;next
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbl-&gt;pdestructor
)paren
id|tbl
op_member_access_from_pointer
id|pdestructor
c_func
(paren
id|n
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|n
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
DECL|function|pneigh_ifdown
r_static
r_int
id|pneigh_ifdown
c_func
(paren
r_struct
id|neigh_table
op_star
id|tbl
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|pneigh_entry
op_star
id|n
comma
op_star
op_star
id|np
suffix:semicolon
id|u32
id|h
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
op_le
id|PNEIGH_HASHMASK
suffix:semicolon
id|h
op_increment
)paren
(brace
id|np
op_assign
op_amp
id|tbl-&gt;phash_buckets
(braket
id|h
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|n
op_assign
op_star
id|np
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|n-&gt;dev
op_eq
id|dev
op_logical_or
id|dev
op_eq
l_int|NULL
)paren
(brace
op_star
id|np
op_assign
id|n-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|tbl-&gt;pdestructor
)paren
id|tbl
op_member_access_from_pointer
id|pdestructor
c_func
(paren
id|n
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|n
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|np
op_assign
op_amp
id|n-&gt;next
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;neighbour must already be out of the table;&n; *&n; */
DECL|function|neigh_destroy
r_void
id|neigh_destroy
c_func
(paren
r_struct
id|neighbour
op_star
id|neigh
)paren
(brace
r_struct
id|hh_cache
op_star
id|hh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|neigh-&gt;dead
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Destroying alive neighbour %p from %08lx&bslash;n&quot;
comma
id|neigh
comma
op_star
(paren
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|neigh
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|neigh_del_timer
c_func
(paren
id|neigh
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;Impossible event.&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|hh
op_assign
id|neigh-&gt;hh
)paren
op_ne
l_int|NULL
)paren
(brace
id|neigh-&gt;hh
op_assign
id|hh-&gt;hh_next
suffix:semicolon
id|hh-&gt;hh_next
op_assign
l_int|NULL
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|hh-&gt;hh_lock
)paren
suffix:semicolon
id|hh-&gt;hh_output
op_assign
id|neigh_blackhole
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|hh-&gt;hh_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|hh-&gt;hh_refcnt
)paren
)paren
id|kfree
c_func
(paren
id|hh
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|neigh-&gt;ops
op_logical_and
id|neigh-&gt;ops-&gt;destructor
)paren
(paren
id|neigh-&gt;ops-&gt;destructor
)paren
(paren
id|neigh
)paren
suffix:semicolon
id|skb_queue_purge
c_func
(paren
op_amp
id|neigh-&gt;arp_queue
)paren
suffix:semicolon
id|dev_put
c_func
(paren
id|neigh-&gt;dev
)paren
suffix:semicolon
id|NEIGH_PRINTK2
c_func
(paren
l_string|&quot;neigh %p is destroyed.&bslash;n&quot;
comma
id|neigh
)paren
suffix:semicolon
id|neigh_glbl_allocs
op_decrement
suffix:semicolon
id|neigh-&gt;tbl-&gt;entries
op_decrement
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|neigh-&gt;tbl-&gt;kmem_cachep
comma
id|neigh
)paren
suffix:semicolon
)brace
multiline_comment|/* Neighbour state is suspicious;&n;   disable fast path.&n;&n;   Called with write_locked neigh.&n; */
DECL|function|neigh_suspect
r_static
r_void
id|neigh_suspect
c_func
(paren
r_struct
id|neighbour
op_star
id|neigh
)paren
(brace
r_struct
id|hh_cache
op_star
id|hh
suffix:semicolon
id|NEIGH_PRINTK2
c_func
(paren
l_string|&quot;neigh %p is suspecteded.&bslash;n&quot;
comma
id|neigh
)paren
suffix:semicolon
id|ASSERT_WL
c_func
(paren
id|neigh
)paren
suffix:semicolon
id|neigh-&gt;output
op_assign
id|neigh-&gt;ops-&gt;output
suffix:semicolon
r_for
c_loop
(paren
id|hh
op_assign
id|neigh-&gt;hh
suffix:semicolon
id|hh
suffix:semicolon
id|hh
op_assign
id|hh-&gt;hh_next
)paren
id|hh-&gt;hh_output
op_assign
id|neigh-&gt;ops-&gt;output
suffix:semicolon
)brace
multiline_comment|/* Neighbour state is OK;&n;   enable fast path.&n;&n;   Called with write_locked neigh.&n; */
DECL|function|neigh_connect
r_static
r_void
id|neigh_connect
c_func
(paren
r_struct
id|neighbour
op_star
id|neigh
)paren
(brace
r_struct
id|hh_cache
op_star
id|hh
suffix:semicolon
id|NEIGH_PRINTK2
c_func
(paren
l_string|&quot;neigh %p is connected.&bslash;n&quot;
comma
id|neigh
)paren
suffix:semicolon
id|ASSERT_WL
c_func
(paren
id|neigh
)paren
suffix:semicolon
id|neigh-&gt;output
op_assign
id|neigh-&gt;ops-&gt;connected_output
suffix:semicolon
r_for
c_loop
(paren
id|hh
op_assign
id|neigh-&gt;hh
suffix:semicolon
id|hh
suffix:semicolon
id|hh
op_assign
id|hh-&gt;hh_next
)paren
id|hh-&gt;hh_output
op_assign
id|neigh-&gt;ops-&gt;hh_output
suffix:semicolon
)brace
multiline_comment|/*&n;   Transitions NUD_STALE &lt;-&gt; NUD_REACHABLE do not occur&n;   when fast path is built: we have no timers assotiated with&n;   these states, we do not have time to check state when sending.&n;   neigh_periodic_timer check periodically neigh-&gt;confirmed&n;   time and moves NUD_REACHABLE -&gt; NUD_STALE.&n;&n;   If a routine wants to know TRUE entry state, it calls&n;   neigh_sync before checking state.&n;&n;   Called with write_locked neigh.&n; */
DECL|function|neigh_sync
r_static
r_void
id|neigh_sync
c_func
(paren
r_struct
id|neighbour
op_star
id|n
)paren
(brace
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
id|u8
id|state
op_assign
id|n-&gt;nud_state
suffix:semicolon
id|ASSERT_WL
c_func
(paren
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_amp
(paren
id|NUD_NOARP
op_or
id|NUD_PERMANENT
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|state
op_amp
id|NUD_REACHABLE
)paren
(brace
r_if
c_cond
(paren
id|now
op_minus
id|n-&gt;confirmed
OG
id|n-&gt;parms-&gt;reachable_time
)paren
(brace
id|n-&gt;nud_state
op_assign
id|NUD_STALE
suffix:semicolon
id|neigh_suspect
c_func
(paren
id|n
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|state
op_amp
id|NUD_VALID
)paren
(brace
r_if
c_cond
(paren
id|now
op_minus
id|n-&gt;confirmed
OL
id|n-&gt;parms-&gt;reachable_time
)paren
(brace
id|neigh_del_timer
c_func
(paren
id|n
)paren
suffix:semicolon
id|n-&gt;nud_state
op_assign
id|NUD_REACHABLE
suffix:semicolon
id|neigh_connect
c_func
(paren
id|n
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|neigh_periodic_timer
r_static
r_void
id|SMP_TIMER_NAME
c_func
(paren
id|neigh_periodic_timer
)paren
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|neigh_table
op_star
id|tbl
op_assign
(paren
r_struct
id|neigh_table
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_int
id|i
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;periodicly recompute ReachableTime from random function&n;&t; */
r_if
c_cond
(paren
id|now
op_minus
id|tbl-&gt;last_rand
OG
l_int|300
op_star
id|HZ
)paren
(brace
r_struct
id|neigh_parms
op_star
id|p
suffix:semicolon
id|tbl-&gt;last_rand
op_assign
id|now
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|tbl-&gt;parms
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
id|p-&gt;reachable_time
op_assign
id|neigh_rand_reach_time
c_func
(paren
id|p-&gt;base_reachable_time
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|NEIGH_HASHMASK
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|neighbour
op_star
id|n
comma
op_star
op_star
id|np
suffix:semicolon
id|np
op_assign
op_amp
id|tbl-&gt;hash_buckets
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|n
op_assign
op_star
id|np
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|state
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|n-&gt;lock
)paren
suffix:semicolon
id|state
op_assign
id|n-&gt;nud_state
suffix:semicolon
r_if
c_cond
(paren
id|state
op_amp
(paren
id|NUD_PERMANENT
op_or
id|NUD_IN_TIMER
)paren
)paren
(brace
id|write_unlock
c_func
(paren
op_amp
id|n-&gt;lock
)paren
suffix:semicolon
r_goto
id|next_elt
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|n-&gt;used
op_minus
id|n-&gt;confirmed
)paren
OL
l_int|0
)paren
id|n-&gt;used
op_assign
id|n-&gt;confirmed
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|n-&gt;refcnt
)paren
op_eq
l_int|1
op_logical_and
(paren
id|state
op_eq
id|NUD_FAILED
op_logical_or
id|now
op_minus
id|n-&gt;used
OG
id|n-&gt;parms-&gt;gc_staletime
)paren
)paren
(brace
op_star
id|np
op_assign
id|n-&gt;next
suffix:semicolon
id|n-&gt;dead
op_assign
l_int|1
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|n-&gt;lock
)paren
suffix:semicolon
id|neigh_release
c_func
(paren
id|n
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n-&gt;nud_state
op_amp
id|NUD_REACHABLE
op_logical_and
id|now
op_minus
id|n-&gt;confirmed
OG
id|n-&gt;parms-&gt;reachable_time
)paren
(brace
id|n-&gt;nud_state
op_assign
id|NUD_STALE
suffix:semicolon
id|neigh_suspect
c_func
(paren
id|n
)paren
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|n-&gt;lock
)paren
suffix:semicolon
id|next_elt
suffix:colon
id|np
op_assign
op_amp
id|n-&gt;next
suffix:semicolon
)brace
)brace
id|mod_timer
c_func
(paren
op_amp
id|tbl-&gt;gc_timer
comma
id|now
op_plus
id|tbl-&gt;gc_interval
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
DECL|function|neigh_periodic_timer
r_static
r_void
id|neigh_periodic_timer
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|neigh_table
op_star
id|tbl
op_assign
(paren
r_struct
id|neigh_table
op_star
)paren
id|arg
suffix:semicolon
id|tasklet_schedule
c_func
(paren
op_amp
id|tbl-&gt;gc_task
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|neigh_max_probes
r_static
id|__inline__
r_int
id|neigh_max_probes
c_func
(paren
r_struct
id|neighbour
op_star
id|n
)paren
(brace
r_struct
id|neigh_parms
op_star
id|p
op_assign
id|n-&gt;parms
suffix:semicolon
r_return
id|p-&gt;ucast_probes
op_plus
id|p-&gt;app_probes
op_plus
id|p-&gt;mcast_probes
suffix:semicolon
)brace
multiline_comment|/* Called when a timer expires for a neighbour entry. */
DECL|function|neigh_timer_handler
r_static
r_void
id|neigh_timer_handler
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_struct
id|neighbour
op_star
id|neigh
op_assign
(paren
r_struct
id|neighbour
op_star
)paren
id|arg
suffix:semicolon
r_int
id|state
suffix:semicolon
r_int
id|notify
op_assign
l_int|0
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
id|state
op_assign
id|neigh-&gt;nud_state
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|state
op_amp
id|NUD_IN_TIMER
)paren
)paren
(brace
macro_line|#ifndef CONFIG_SMP
id|printk
c_func
(paren
l_string|&quot;neigh: timer &amp; !nud_in_timer&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|state
op_amp
id|NUD_VALID
)paren
op_logical_and
id|now
op_minus
id|neigh-&gt;confirmed
OL
id|neigh-&gt;parms-&gt;reachable_time
)paren
(brace
id|neigh-&gt;nud_state
op_assign
id|NUD_REACHABLE
suffix:semicolon
id|NEIGH_PRINTK2
c_func
(paren
l_string|&quot;neigh %p is still alive.&bslash;n&quot;
comma
id|neigh
)paren
suffix:semicolon
id|neigh_connect
c_func
(paren
id|neigh
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|state
op_eq
id|NUD_DELAY
)paren
(brace
id|NEIGH_PRINTK2
c_func
(paren
l_string|&quot;neigh %p is probed.&bslash;n&quot;
comma
id|neigh
)paren
suffix:semicolon
id|neigh-&gt;nud_state
op_assign
id|NUD_PROBE
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|neigh-&gt;probes
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|neigh-&gt;probes
)paren
op_ge
id|neigh_max_probes
c_func
(paren
id|neigh
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|neigh-&gt;nud_state
op_assign
id|NUD_FAILED
suffix:semicolon
id|notify
op_assign
l_int|1
suffix:semicolon
id|neigh-&gt;tbl-&gt;stats.res_failed
op_increment
suffix:semicolon
id|NEIGH_PRINTK2
c_func
(paren
l_string|&quot;neigh %p is failed.&bslash;n&quot;
comma
id|neigh
)paren
suffix:semicolon
multiline_comment|/* It is very thin place. report_unreachable is very complicated&n;&t;&t;   routine. Particularly, it can hit the same neighbour entry!&n;&t;&t;   &n;&t;&t;   So that, we try to be accurate and avoid dead loop. --ANK&n;&t;&t; */
r_while
c_loop
(paren
id|neigh-&gt;nud_state
op_eq
id|NUD_FAILED
op_logical_and
(paren
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
op_amp
id|neigh-&gt;arp_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|write_unlock
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
id|neigh-&gt;ops
op_member_access_from_pointer
id|error_report
c_func
(paren
id|neigh
comma
id|skb
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
)brace
id|skb_queue_purge
c_func
(paren
op_amp
id|neigh-&gt;arp_queue
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|neigh-&gt;timer.expires
op_assign
id|now
op_plus
id|neigh-&gt;parms-&gt;retrans_time
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|neigh-&gt;timer
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
id|neigh-&gt;ops
op_member_access_from_pointer
id|solicit
c_func
(paren
id|neigh
comma
id|skb_peek
c_func
(paren
op_amp
id|neigh-&gt;arp_queue
)paren
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|neigh-&gt;probes
)paren
suffix:semicolon
r_return
suffix:semicolon
id|out
suffix:colon
id|write_unlock
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ARPD
r_if
c_cond
(paren
id|notify
op_logical_and
id|neigh-&gt;parms-&gt;app_probes
)paren
id|neigh_app_notify
c_func
(paren
id|neigh
)paren
suffix:semicolon
macro_line|#endif
id|neigh_release
c_func
(paren
id|neigh
)paren
suffix:semicolon
)brace
DECL|function|__neigh_event_send
r_int
id|__neigh_event_send
c_func
(paren
r_struct
id|neighbour
op_star
id|neigh
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|neigh-&gt;nud_state
op_amp
(paren
id|NUD_CONNECTED
op_or
id|NUD_DELAY
op_or
id|NUD_PROBE
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|neigh-&gt;nud_state
op_amp
(paren
id|NUD_STALE
op_or
id|NUD_INCOMPLETE
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|neigh-&gt;parms-&gt;mcast_probes
op_plus
id|neigh-&gt;parms-&gt;app_probes
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|neigh-&gt;probes
comma
id|neigh-&gt;parms-&gt;ucast_probes
)paren
suffix:semicolon
id|neigh-&gt;nud_state
op_assign
id|NUD_INCOMPLETE
suffix:semicolon
id|neigh_hold
c_func
(paren
id|neigh
)paren
suffix:semicolon
id|neigh-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|neigh-&gt;parms-&gt;retrans_time
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|neigh-&gt;timer
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
id|neigh-&gt;ops
op_member_access_from_pointer
id|solicit
c_func
(paren
id|neigh
comma
id|skb
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|neigh-&gt;probes
)paren
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|neigh-&gt;nud_state
op_assign
id|NUD_FAILED
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|neigh-&gt;nud_state
op_eq
id|NUD_INCOMPLETE
)paren
(brace
r_if
c_cond
(paren
id|skb
)paren
(brace
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|neigh-&gt;arp_queue
)paren
op_ge
id|neigh-&gt;parms-&gt;queue_len
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
id|buff
op_assign
id|neigh-&gt;arp_queue.prev
suffix:semicolon
id|__skb_unlink
c_func
(paren
id|buff
comma
op_amp
id|neigh-&gt;arp_queue
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|buff
)paren
suffix:semicolon
)brace
id|__skb_queue_head
c_func
(paren
op_amp
id|neigh-&gt;arp_queue
comma
id|skb
)paren
suffix:semicolon
)brace
id|write_unlock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|neigh-&gt;nud_state
op_eq
id|NUD_STALE
)paren
(brace
id|NEIGH_PRINTK2
c_func
(paren
l_string|&quot;neigh %p is delayed.&bslash;n&quot;
comma
id|neigh
)paren
suffix:semicolon
id|neigh_hold
c_func
(paren
id|neigh
)paren
suffix:semicolon
id|neigh-&gt;nud_state
op_assign
id|NUD_DELAY
suffix:semicolon
id|neigh-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|neigh-&gt;parms-&gt;delay_probe_time
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|neigh-&gt;timer
)paren
suffix:semicolon
)brace
)brace
id|write_unlock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|neigh_update_hhs
r_static
id|__inline__
r_void
id|neigh_update_hhs
c_func
(paren
r_struct
id|neighbour
op_star
id|neigh
)paren
(brace
r_struct
id|hh_cache
op_star
id|hh
suffix:semicolon
r_void
(paren
op_star
id|update
)paren
(paren
r_struct
id|hh_cache
op_star
comma
r_struct
id|net_device
op_star
comma
r_int
r_char
op_star
)paren
op_assign
id|neigh-&gt;dev-&gt;header_cache_update
suffix:semicolon
r_if
c_cond
(paren
id|update
)paren
(brace
r_for
c_loop
(paren
id|hh
op_assign
id|neigh-&gt;hh
suffix:semicolon
id|hh
suffix:semicolon
id|hh
op_assign
id|hh-&gt;hh_next
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|hh-&gt;hh_lock
)paren
suffix:semicolon
id|update
c_func
(paren
id|hh
comma
id|neigh-&gt;dev
comma
id|neigh-&gt;ha
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|hh-&gt;hh_lock
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Generic update routine.&n;   -- lladdr is new lladdr or NULL, if it is not supplied.&n;   -- new    is new state.&n;   -- override==1 allows to override existing lladdr, if it is different.&n;   -- arp==0 means that the change is administrative.&n;&n;   Caller MUST hold reference count on the entry.&n; */
DECL|function|neigh_update
r_int
id|neigh_update
c_func
(paren
r_struct
id|neighbour
op_star
id|neigh
comma
r_const
id|u8
op_star
id|lladdr
comma
id|u8
r_new
comma
r_int
id|override
comma
r_int
id|arp
)paren
(brace
id|u8
id|old
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|notify
op_assign
l_int|0
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|neigh-&gt;dev
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
id|old
op_assign
id|neigh-&gt;nud_state
suffix:semicolon
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|arp
op_logical_and
(paren
id|old
op_amp
(paren
id|NUD_NOARP
op_or
id|NUD_PERMANENT
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
r_new
op_amp
id|NUD_VALID
)paren
)paren
(brace
id|neigh_del_timer
c_func
(paren
id|neigh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old
op_amp
id|NUD_CONNECTED
)paren
id|neigh_suspect
c_func
(paren
id|neigh
)paren
suffix:semicolon
id|neigh-&gt;nud_state
op_assign
r_new
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|notify
op_assign
id|old
op_amp
id|NUD_VALID
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Compare new lladdr with cached one */
r_if
c_cond
(paren
id|dev-&gt;addr_len
op_eq
l_int|0
)paren
(brace
multiline_comment|/* First case: device needs no address. */
id|lladdr
op_assign
id|neigh-&gt;ha
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lladdr
)paren
(brace
multiline_comment|/* The second case: if something is already cached&n;&t;&t;   and a new address is proposed:&n;&t;&t;   - compare new &amp; old&n;&t;&t;   - if they are different, check override flag&n;&t;&t; */
r_if
c_cond
(paren
id|old
op_amp
id|NUD_VALID
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|lladdr
comma
id|neigh-&gt;ha
comma
id|dev-&gt;addr_len
)paren
op_eq
l_int|0
)paren
id|lladdr
op_assign
id|neigh-&gt;ha
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|override
)paren
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* No address is supplied; if we know something,&n;&t;&t;   use it, otherwise discard the request.&n;&t;&t; */
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|old
op_amp
id|NUD_VALID
)paren
)paren
r_goto
id|out
suffix:semicolon
id|lladdr
op_assign
id|neigh-&gt;ha
suffix:semicolon
)brace
id|neigh_sync
c_func
(paren
id|neigh
)paren
suffix:semicolon
id|old
op_assign
id|neigh-&gt;nud_state
suffix:semicolon
r_if
c_cond
(paren
r_new
op_amp
id|NUD_CONNECTED
)paren
id|neigh-&gt;confirmed
op_assign
id|jiffies
suffix:semicolon
id|neigh-&gt;updated
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* If entry was valid and address is not changed,&n;&t;   do not change entry state, if new one is STALE.&n;&t; */
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|old
op_amp
id|NUD_VALID
)paren
(brace
r_if
c_cond
(paren
id|lladdr
op_eq
id|neigh-&gt;ha
)paren
r_if
c_cond
(paren
r_new
op_eq
id|old
op_logical_or
(paren
r_new
op_eq
id|NUD_STALE
op_logical_and
(paren
id|old
op_amp
id|NUD_CONNECTED
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
id|neigh_del_timer
c_func
(paren
id|neigh
)paren
suffix:semicolon
id|neigh-&gt;nud_state
op_assign
r_new
suffix:semicolon
r_if
c_cond
(paren
id|lladdr
op_ne
id|neigh-&gt;ha
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|neigh-&gt;ha
comma
id|lladdr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|neigh_update_hhs
c_func
(paren
id|neigh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
r_new
op_amp
id|NUD_CONNECTED
)paren
)paren
id|neigh-&gt;confirmed
op_assign
id|jiffies
op_minus
(paren
id|neigh-&gt;parms-&gt;base_reachable_time
op_lshift
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ARPD
id|notify
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
r_new
op_eq
id|old
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
r_new
op_amp
id|NUD_CONNECTED
)paren
id|neigh_connect
c_func
(paren
id|neigh
)paren
suffix:semicolon
r_else
id|neigh_suspect
c_func
(paren
id|neigh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|old
op_amp
id|NUD_VALID
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* Again: avoid dead loop if something went wrong */
r_while
c_loop
(paren
id|neigh-&gt;nud_state
op_amp
id|NUD_VALID
op_logical_and
(paren
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
op_amp
id|neigh-&gt;arp_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|neighbour
op_star
id|n1
op_assign
id|neigh
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* On shaper/eql skb-&gt;dst-&gt;neighbour != neigh :( */
r_if
c_cond
(paren
id|skb-&gt;dst
op_logical_and
id|skb-&gt;dst-&gt;neighbour
)paren
id|n1
op_assign
id|skb-&gt;dst-&gt;neighbour
suffix:semicolon
id|n1
op_member_access_from_pointer
id|output
c_func
(paren
id|skb
)paren
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
)brace
id|skb_queue_purge
c_func
(paren
op_amp
id|neigh-&gt;arp_queue
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|write_unlock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ARPD
r_if
c_cond
(paren
id|notify
op_logical_and
id|neigh-&gt;parms-&gt;app_probes
)paren
id|neigh_app_notify
c_func
(paren
id|neigh
)paren
suffix:semicolon
macro_line|#endif
r_return
id|err
suffix:semicolon
)brace
DECL|function|neigh_event_ns
r_struct
id|neighbour
op_star
id|neigh_event_ns
c_func
(paren
r_struct
id|neigh_table
op_star
id|tbl
comma
id|u8
op_star
id|lladdr
comma
r_void
op_star
id|saddr
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|neighbour
op_star
id|neigh
suffix:semicolon
id|neigh
op_assign
id|__neigh_lookup
c_func
(paren
id|tbl
comma
id|saddr
comma
id|dev
comma
id|lladdr
op_logical_or
op_logical_neg
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|neigh
)paren
id|neigh_update
c_func
(paren
id|neigh
comma
id|lladdr
comma
id|NUD_STALE
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
r_return
id|neigh
suffix:semicolon
)brace
DECL|function|neigh_hh_init
r_static
r_void
id|neigh_hh_init
c_func
(paren
r_struct
id|neighbour
op_star
id|n
comma
r_struct
id|dst_entry
op_star
id|dst
comma
id|u16
id|protocol
)paren
(brace
r_struct
id|hh_cache
op_star
id|hh
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|dst-&gt;dev
suffix:semicolon
r_for
c_loop
(paren
id|hh
op_assign
id|n-&gt;hh
suffix:semicolon
id|hh
suffix:semicolon
id|hh
op_assign
id|hh-&gt;hh_next
)paren
r_if
c_cond
(paren
id|hh-&gt;hh_type
op_eq
id|protocol
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hh
op_logical_and
(paren
id|hh
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|hh
)paren
comma
id|GFP_ATOMIC
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|memset
c_func
(paren
id|hh
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|hh_cache
)paren
)paren
suffix:semicolon
id|hh-&gt;hh_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
id|hh-&gt;hh_type
op_assign
id|protocol
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|hh-&gt;hh_refcnt
comma
l_int|0
)paren
suffix:semicolon
id|hh-&gt;hh_next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|hard_header_cache
c_func
(paren
id|n
comma
id|hh
)paren
)paren
(brace
id|kfree
c_func
(paren
id|hh
)paren
suffix:semicolon
id|hh
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|atomic_inc
c_func
(paren
op_amp
id|hh-&gt;hh_refcnt
)paren
suffix:semicolon
id|hh-&gt;hh_next
op_assign
id|n-&gt;hh
suffix:semicolon
id|n-&gt;hh
op_assign
id|hh
suffix:semicolon
r_if
c_cond
(paren
id|n-&gt;nud_state
op_amp
id|NUD_CONNECTED
)paren
id|hh-&gt;hh_output
op_assign
id|n-&gt;ops-&gt;hh_output
suffix:semicolon
r_else
id|hh-&gt;hh_output
op_assign
id|n-&gt;ops-&gt;output
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|hh
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|hh-&gt;hh_refcnt
)paren
suffix:semicolon
id|dst-&gt;hh
op_assign
id|hh
suffix:semicolon
)brace
)brace
multiline_comment|/* This function can be used in contexts, where only old dev_queue_xmit&n;   worked, f.e. if you want to override normal output path (eql, shaper),&n;   but resoltution is not made yet.&n; */
DECL|function|neigh_compat_output
r_int
id|neigh_compat_output
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|__skb_pull
c_func
(paren
id|skb
comma
id|skb-&gt;nh.raw
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;hard_header
op_logical_and
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|skb
comma
id|dev
comma
id|ntohs
c_func
(paren
id|skb-&gt;protocol
)paren
comma
l_int|NULL
comma
l_int|NULL
comma
id|skb-&gt;len
)paren
OL
l_int|0
op_logical_and
id|dev
op_member_access_from_pointer
id|rebuild_header
c_func
(paren
id|skb
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* Slow and careful. */
DECL|function|neigh_resolve_output
r_int
id|neigh_resolve_output
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|skb-&gt;dst
suffix:semicolon
r_struct
id|neighbour
op_star
id|neigh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dst
op_logical_or
op_logical_neg
(paren
id|neigh
op_assign
id|dst-&gt;neighbour
)paren
)paren
r_goto
id|discard
suffix:semicolon
id|__skb_pull
c_func
(paren
id|skb
comma
id|skb-&gt;nh.raw
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|neigh_event_send
c_func
(paren
id|neigh
comma
id|skb
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|neigh-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;hard_header_cache
op_logical_and
id|dst-&gt;hh
op_eq
l_int|NULL
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst-&gt;hh
op_eq
l_int|NULL
)paren
id|neigh_hh_init
c_func
(paren
id|neigh
comma
id|dst
comma
id|dst-&gt;ops-&gt;protocol
)paren
suffix:semicolon
id|err
op_assign
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|skb
comma
id|dev
comma
id|ntohs
c_func
(paren
id|skb-&gt;protocol
)paren
comma
id|neigh-&gt;ha
comma
l_int|NULL
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|read_lock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
id|err
op_assign
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|skb
comma
id|dev
comma
id|ntohs
c_func
(paren
id|skb-&gt;protocol
)paren
comma
id|neigh-&gt;ha
comma
l_int|NULL
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|read_unlock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
op_ge
l_int|0
)paren
r_return
id|neigh-&gt;ops
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|discard
suffix:colon
id|NEIGH_PRINTK1
c_func
(paren
l_string|&quot;neigh_resolve_output: dst=%p neigh=%p&bslash;n&quot;
comma
id|dst
comma
id|dst
ques
c_cond
id|dst-&gt;neighbour
suffix:colon
l_int|NULL
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* As fast as possible without hh cache */
DECL|function|neigh_connected_output
r_int
id|neigh_connected_output
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|skb-&gt;dst
suffix:semicolon
r_struct
id|neighbour
op_star
id|neigh
op_assign
id|dst-&gt;neighbour
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|neigh-&gt;dev
suffix:semicolon
id|__skb_pull
c_func
(paren
id|skb
comma
id|skb-&gt;nh.raw
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
id|err
op_assign
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|skb
comma
id|dev
comma
id|ntohs
c_func
(paren
id|skb-&gt;protocol
)paren
comma
id|neigh-&gt;ha
comma
l_int|NULL
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|read_unlock_bh
c_func
(paren
op_amp
id|neigh-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ge
l_int|0
)paren
r_return
id|neigh-&gt;ops
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|neigh_proxy_process
r_static
r_void
id|neigh_proxy_process
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|neigh_table
op_star
id|tbl
op_assign
(paren
r_struct
id|neigh_table
op_star
)paren
id|arg
suffix:semicolon
r_int
id|sched_next
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|tbl-&gt;proxy_queue.lock
)paren
suffix:semicolon
id|skb
op_assign
id|tbl-&gt;proxy_queue.next
suffix:semicolon
r_while
c_loop
(paren
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|tbl-&gt;proxy_queue
)paren
(brace
r_struct
id|sk_buff
op_star
id|back
op_assign
id|skb
suffix:semicolon
r_int
id|tdif
op_assign
id|back-&gt;stamp.tv_usec
op_minus
id|now
suffix:semicolon
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|tdif
op_le
l_int|0
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|back-&gt;dev
suffix:semicolon
id|__skb_unlink
c_func
(paren
id|back
comma
op_amp
id|tbl-&gt;proxy_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbl-&gt;proxy_redo
op_logical_and
id|netif_running
c_func
(paren
id|dev
)paren
)paren
id|tbl
op_member_access_from_pointer
id|proxy_redo
c_func
(paren
id|back
)paren
suffix:semicolon
r_else
id|kfree_skb
c_func
(paren
id|back
)paren
suffix:semicolon
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|sched_next
op_logical_or
id|tdif
OL
id|sched_next
)paren
id|sched_next
op_assign
id|tdif
suffix:semicolon
)brace
id|del_timer
c_func
(paren
op_amp
id|tbl-&gt;proxy_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sched_next
)paren
id|mod_timer
c_func
(paren
op_amp
id|tbl-&gt;proxy_timer
comma
id|jiffies
op_plus
id|sched_next
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|tbl-&gt;proxy_queue.lock
)paren
suffix:semicolon
)brace
DECL|function|pneigh_enqueue
r_void
id|pneigh_enqueue
c_func
(paren
r_struct
id|neigh_table
op_star
id|tbl
comma
r_struct
id|neigh_parms
op_star
id|p
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_int
id|sched_next
op_assign
id|net_random
c_func
(paren
)paren
op_mod
id|p-&gt;proxy_delay
suffix:semicolon
r_if
c_cond
(paren
id|tbl-&gt;proxy_queue.qlen
OG
id|p-&gt;proxy_qlen
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb-&gt;stamp.tv_sec
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;stamp.tv_usec
op_assign
id|now
op_plus
id|sched_next
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|tbl-&gt;proxy_queue.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
id|tbl-&gt;proxy_timer
)paren
)paren
(brace
r_int
id|tval
op_assign
id|tbl-&gt;proxy_timer.expires
op_minus
id|now
suffix:semicolon
r_if
c_cond
(paren
id|tval
OL
id|sched_next
)paren
id|sched_next
op_assign
id|tval
suffix:semicolon
)brace
id|dst_release
c_func
(paren
id|skb-&gt;dst
)paren
suffix:semicolon
id|skb-&gt;dst
op_assign
l_int|NULL
suffix:semicolon
id|dev_hold
c_func
(paren
id|skb-&gt;dev
)paren
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
op_amp
id|tbl-&gt;proxy_queue
comma
id|skb
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|tbl-&gt;proxy_timer
comma
id|now
op_plus
id|sched_next
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|tbl-&gt;proxy_queue.lock
)paren
suffix:semicolon
)brace
DECL|function|neigh_parms_alloc
r_struct
id|neigh_parms
op_star
id|neigh_parms_alloc
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|neigh_table
op_star
id|tbl
)paren
(brace
r_struct
id|neigh_parms
op_star
id|p
suffix:semicolon
id|p
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|p
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|memcpy
c_func
(paren
id|p
comma
op_amp
id|tbl-&gt;parms
comma
r_sizeof
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
id|p-&gt;tbl
op_assign
id|tbl
suffix:semicolon
id|p-&gt;reachable_time
op_assign
id|neigh_rand_reach_time
c_func
(paren
id|p-&gt;base_reachable_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_logical_and
id|dev-&gt;neigh_setup
)paren
(brace
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|neigh_setup
c_func
(paren
id|dev
comma
id|p
)paren
)paren
(brace
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
id|write_lock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
id|p-&gt;next
op_assign
id|tbl-&gt;parms.next
suffix:semicolon
id|tbl-&gt;parms.next
op_assign
id|p
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
DECL|function|neigh_parms_release
r_void
id|neigh_parms_release
c_func
(paren
r_struct
id|neigh_table
op_star
id|tbl
comma
r_struct
id|neigh_parms
op_star
id|parms
)paren
(brace
r_struct
id|neigh_parms
op_star
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|parms
op_eq
l_int|NULL
op_logical_or
id|parms
op_eq
op_amp
id|tbl-&gt;parms
)paren
r_return
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|tbl-&gt;parms.next
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|next
)paren
(brace
r_if
c_cond
(paren
op_star
id|p
op_eq
id|parms
)paren
(brace
op_star
id|p
op_assign
id|parms-&gt;next
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SYSCTL
id|neigh_sysctl_unregister
c_func
(paren
id|parms
)paren
suffix:semicolon
macro_line|#endif
id|kfree
c_func
(paren
id|parms
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|write_unlock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
id|NEIGH_PRINTK1
c_func
(paren
l_string|&quot;neigh_parms_release: not found&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|neigh_table_init
r_void
id|neigh_table_init
c_func
(paren
r_struct
id|neigh_table
op_star
id|tbl
)paren
(brace
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
id|tbl-&gt;parms.reachable_time
op_assign
id|neigh_rand_reach_time
c_func
(paren
id|tbl-&gt;parms.base_reachable_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbl-&gt;kmem_cachep
op_eq
l_int|NULL
)paren
id|tbl-&gt;kmem_cachep
op_assign
id|kmem_cache_create
c_func
(paren
id|tbl-&gt;id
comma
(paren
id|tbl-&gt;entry_size
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|tasklet_init
c_func
(paren
op_amp
id|tbl-&gt;gc_task
comma
id|SMP_TIMER_NAME
c_func
(paren
id|neigh_periodic_timer
)paren
comma
(paren
r_int
r_int
)paren
id|tbl
)paren
suffix:semicolon
macro_line|#endif
id|init_timer
c_func
(paren
op_amp
id|tbl-&gt;gc_timer
)paren
suffix:semicolon
id|tbl-&gt;lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
id|tbl-&gt;gc_timer.data
op_assign
(paren
r_int
r_int
)paren
id|tbl
suffix:semicolon
id|tbl-&gt;gc_timer.function
op_assign
id|neigh_periodic_timer
suffix:semicolon
id|tbl-&gt;gc_timer.expires
op_assign
id|now
op_plus
id|tbl-&gt;gc_interval
op_plus
id|tbl-&gt;parms.reachable_time
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|tbl-&gt;gc_timer
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|tbl-&gt;proxy_timer
)paren
suffix:semicolon
id|tbl-&gt;proxy_timer.data
op_assign
(paren
r_int
r_int
)paren
id|tbl
suffix:semicolon
id|tbl-&gt;proxy_timer.function
op_assign
id|neigh_proxy_process
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|tbl-&gt;proxy_queue
)paren
suffix:semicolon
id|tbl-&gt;last_flush
op_assign
id|now
suffix:semicolon
id|tbl-&gt;last_rand
op_assign
id|now
op_plus
id|tbl-&gt;parms.reachable_time
op_star
l_int|20
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|neigh_tbl_lock
)paren
suffix:semicolon
id|tbl-&gt;next
op_assign
id|neigh_tables
suffix:semicolon
id|neigh_tables
op_assign
id|tbl
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|neigh_tbl_lock
)paren
suffix:semicolon
)brace
DECL|function|neigh_table_clear
r_int
id|neigh_table_clear
c_func
(paren
r_struct
id|neigh_table
op_star
id|tbl
)paren
(brace
r_struct
id|neigh_table
op_star
op_star
id|tp
suffix:semicolon
multiline_comment|/* It is not clean... Fix it to unload IPv6 module safely */
id|del_timer_sync
c_func
(paren
op_amp
id|tbl-&gt;gc_timer
)paren
suffix:semicolon
id|tasklet_kill
c_func
(paren
op_amp
id|tbl-&gt;gc_task
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|tbl-&gt;proxy_timer
)paren
suffix:semicolon
id|pneigh_queue_purge
c_func
(paren
op_amp
id|tbl-&gt;proxy_queue
)paren
suffix:semicolon
id|neigh_ifdown
c_func
(paren
id|tbl
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbl-&gt;entries
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;neighbour leakage&bslash;n&quot;
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|neigh_tbl_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tp
op_assign
op_amp
id|neigh_tables
suffix:semicolon
op_star
id|tp
suffix:semicolon
id|tp
op_assign
op_amp
(paren
op_star
id|tp
)paren
op_member_access_from_pointer
id|next
)paren
(brace
r_if
c_cond
(paren
op_star
id|tp
op_eq
id|tbl
)paren
(brace
op_star
id|tp
op_assign
id|tbl-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|write_unlock
c_func
(paren
op_amp
id|neigh_tbl_lock
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SYSCTL
id|neigh_sysctl_unregister
c_func
(paren
op_amp
id|tbl-&gt;parms
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_RTNETLINK
DECL|function|neigh_delete
r_int
id|neigh_delete
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|nlmsghdr
op_star
id|nlh
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|ndmsg
op_star
id|ndm
op_assign
id|NLMSG_DATA
c_func
(paren
id|nlh
)paren
suffix:semicolon
r_struct
id|rtattr
op_star
op_star
id|nda
op_assign
id|arg
suffix:semicolon
r_struct
id|neigh_table
op_star
id|tbl
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ndm-&gt;ndm_ifindex
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|dev_get_by_index
c_func
(paren
id|ndm-&gt;ndm_ifindex
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|neigh_tbl_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tbl
op_assign
id|neigh_tables
suffix:semicolon
id|tbl
suffix:semicolon
id|tbl
op_assign
id|tbl-&gt;next
)paren
(brace
r_struct
id|neighbour
op_star
id|n
suffix:semicolon
r_if
c_cond
(paren
id|tbl-&gt;family
op_ne
id|ndm-&gt;ndm_family
)paren
r_continue
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|neigh_tbl_lock
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|nda
(braket
id|NDA_DST
op_minus
l_int|1
)braket
op_eq
l_int|NULL
op_logical_or
id|nda
(braket
id|NDA_DST
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|rta_len
op_ne
id|RTA_LENGTH
c_func
(paren
id|tbl-&gt;key_len
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|ndm-&gt;ndm_flags
op_amp
id|NTF_PROXY
)paren
(brace
id|err
op_assign
id|pneigh_delete
c_func
(paren
id|tbl
comma
id|RTA_DATA
c_func
(paren
id|nda
(braket
id|NDA_DST
op_minus
l_int|1
)braket
)paren
comma
id|dev
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|n
op_assign
id|neigh_lookup
c_func
(paren
id|tbl
comma
id|RTA_DATA
c_func
(paren
id|nda
(braket
id|NDA_DST
op_minus
l_int|1
)braket
)paren
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
)paren
(brace
id|err
op_assign
id|neigh_update
c_func
(paren
id|n
comma
l_int|NULL
comma
id|NUD_FAILED
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|neigh_release
c_func
(paren
id|n
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_if
c_cond
(paren
id|dev
)paren
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|neigh_tbl_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
)brace
DECL|function|neigh_add
r_int
id|neigh_add
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|nlmsghdr
op_star
id|nlh
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|ndmsg
op_star
id|ndm
op_assign
id|NLMSG_DATA
c_func
(paren
id|nlh
)paren
suffix:semicolon
r_struct
id|rtattr
op_star
op_star
id|nda
op_assign
id|arg
suffix:semicolon
r_struct
id|neigh_table
op_star
id|tbl
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ndm-&gt;ndm_ifindex
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|dev_get_by_index
c_func
(paren
id|ndm-&gt;ndm_ifindex
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|neigh_tbl_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tbl
op_assign
id|neigh_tables
suffix:semicolon
id|tbl
suffix:semicolon
id|tbl
op_assign
id|tbl-&gt;next
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|neighbour
op_star
id|n
suffix:semicolon
r_if
c_cond
(paren
id|tbl-&gt;family
op_ne
id|ndm-&gt;ndm_family
)paren
r_continue
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|neigh_tbl_lock
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|nda
(braket
id|NDA_DST
op_minus
l_int|1
)braket
op_eq
l_int|NULL
op_logical_or
id|nda
(braket
id|NDA_DST
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|rta_len
op_ne
id|RTA_LENGTH
c_func
(paren
id|tbl-&gt;key_len
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|ndm-&gt;ndm_flags
op_amp
id|NTF_PROXY
)paren
(brace
id|err
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
r_if
c_cond
(paren
id|pneigh_lookup
c_func
(paren
id|tbl
comma
id|RTA_DATA
c_func
(paren
id|nda
(braket
id|NDA_DST
op_minus
l_int|1
)braket
)paren
comma
id|dev
comma
l_int|1
)paren
)paren
id|err
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|nda
(braket
id|NDA_LLADDR
op_minus
l_int|1
)braket
op_ne
l_int|NULL
op_logical_and
id|nda
(braket
id|NDA_LLADDR
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|rta_len
op_ne
id|RTA_LENGTH
c_func
(paren
id|dev-&gt;addr_len
)paren
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|n
op_assign
id|neigh_lookup
c_func
(paren
id|tbl
comma
id|RTA_DATA
c_func
(paren
id|nda
(braket
id|NDA_DST
op_minus
l_int|1
)braket
)paren
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
)paren
(brace
r_if
c_cond
(paren
id|nlh-&gt;nlmsg_flags
op_amp
id|NLM_F_EXCL
)paren
id|err
op_assign
op_minus
id|EEXIST
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|nlh-&gt;nlmsg_flags
op_amp
id|NLM_F_CREATE
)paren
)paren
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_else
(brace
id|n
op_assign
id|__neigh_lookup_errno
c_func
(paren
id|tbl
comma
id|RTA_DATA
c_func
(paren
id|nda
(braket
id|NDA_DST
op_minus
l_int|1
)braket
)paren
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|n
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|n
)paren
suffix:semicolon
id|n
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
(brace
id|err
op_assign
id|neigh_update
c_func
(paren
id|n
comma
id|nda
(braket
id|NDA_LLADDR
op_minus
l_int|1
)braket
ques
c_cond
id|RTA_DATA
c_func
(paren
id|nda
(braket
id|NDA_LLADDR
op_minus
l_int|1
)braket
)paren
suffix:colon
l_int|NULL
comma
id|ndm-&gt;ndm_state
comma
id|nlh-&gt;nlmsg_flags
op_amp
id|NLM_F_REPLACE
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
)paren
id|neigh_release
c_func
(paren
id|n
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|dev
)paren
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|neigh_tbl_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
id|dev_put
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
)brace
DECL|function|neigh_fill_info
r_static
r_int
id|neigh_fill_info
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|neighbour
op_star
id|n
comma
id|u32
id|pid
comma
id|u32
id|seq
comma
r_int
id|event
)paren
(brace
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_struct
id|ndmsg
op_star
id|ndm
suffix:semicolon
r_struct
id|nlmsghdr
op_star
id|nlh
suffix:semicolon
r_int
r_char
op_star
id|b
op_assign
id|skb-&gt;tail
suffix:semicolon
r_struct
id|nda_cacheinfo
id|ci
suffix:semicolon
r_int
id|locked
op_assign
l_int|0
suffix:semicolon
id|nlh
op_assign
id|NLMSG_PUT
c_func
(paren
id|skb
comma
id|pid
comma
id|seq
comma
id|event
comma
r_sizeof
(paren
op_star
id|ndm
)paren
)paren
suffix:semicolon
id|ndm
op_assign
id|NLMSG_DATA
c_func
(paren
id|nlh
)paren
suffix:semicolon
id|ndm-&gt;ndm_family
op_assign
id|n-&gt;ops-&gt;family
suffix:semicolon
id|ndm-&gt;ndm_flags
op_assign
id|n-&gt;flags
suffix:semicolon
id|ndm-&gt;ndm_type
op_assign
id|n-&gt;type
suffix:semicolon
id|ndm-&gt;ndm_ifindex
op_assign
id|n-&gt;dev-&gt;ifindex
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|NDA_DST
comma
id|n-&gt;tbl-&gt;key_len
comma
id|n-&gt;primary_key
)paren
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|n-&gt;lock
)paren
suffix:semicolon
id|locked
op_assign
l_int|1
suffix:semicolon
id|ndm-&gt;ndm_state
op_assign
id|n-&gt;nud_state
suffix:semicolon
r_if
c_cond
(paren
id|n-&gt;nud_state
op_amp
id|NUD_VALID
)paren
id|RTA_PUT
c_func
(paren
id|skb
comma
id|NDA_LLADDR
comma
id|n-&gt;dev-&gt;addr_len
comma
id|n-&gt;ha
)paren
suffix:semicolon
id|ci.ndm_used
op_assign
id|now
op_minus
id|n-&gt;used
suffix:semicolon
id|ci.ndm_confirmed
op_assign
id|now
op_minus
id|n-&gt;confirmed
suffix:semicolon
id|ci.ndm_updated
op_assign
id|now
op_minus
id|n-&gt;updated
suffix:semicolon
id|ci.ndm_refcnt
op_assign
id|atomic_read
c_func
(paren
op_amp
id|n-&gt;refcnt
)paren
op_minus
l_int|1
suffix:semicolon
id|read_unlock_bh
c_func
(paren
op_amp
id|n-&gt;lock
)paren
suffix:semicolon
id|locked
op_assign
l_int|0
suffix:semicolon
id|RTA_PUT
c_func
(paren
id|skb
comma
id|NDA_CACHEINFO
comma
r_sizeof
(paren
id|ci
)paren
comma
op_amp
id|ci
)paren
suffix:semicolon
id|nlh-&gt;nlmsg_len
op_assign
id|skb-&gt;tail
op_minus
id|b
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
id|nlmsg_failure
suffix:colon
id|rtattr_failure
suffix:colon
r_if
c_cond
(paren
id|locked
)paren
id|read_unlock_bh
c_func
(paren
op_amp
id|n-&gt;lock
)paren
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
id|b
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|neigh_dump_table
r_static
r_int
id|neigh_dump_table
c_func
(paren
r_struct
id|neigh_table
op_star
id|tbl
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|netlink_callback
op_star
id|cb
)paren
(brace
r_struct
id|neighbour
op_star
id|n
suffix:semicolon
r_int
id|h
comma
id|s_h
suffix:semicolon
r_int
id|idx
comma
id|s_idx
suffix:semicolon
id|s_h
op_assign
id|cb-&gt;args
(braket
l_int|1
)braket
suffix:semicolon
id|s_idx
op_assign
id|idx
op_assign
id|cb-&gt;args
(braket
l_int|2
)braket
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
op_le
id|NEIGH_HASHMASK
suffix:semicolon
id|h
op_increment
)paren
(brace
r_if
c_cond
(paren
id|h
OL
id|s_h
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|h
OG
id|s_h
)paren
id|s_idx
op_assign
l_int|0
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|tbl-&gt;hash_buckets
(braket
id|h
)braket
comma
id|idx
op_assign
l_int|0
suffix:semicolon
id|n
suffix:semicolon
id|n
op_assign
id|n-&gt;next
comma
id|idx
op_increment
)paren
(brace
r_if
c_cond
(paren
id|idx
OL
id|s_idx
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|neigh_fill_info
c_func
(paren
id|skb
comma
id|n
comma
id|NETLINK_CB
c_func
(paren
id|cb-&gt;skb
)paren
dot
id|pid
comma
id|cb-&gt;nlh-&gt;nlmsg_seq
comma
id|RTM_NEWNEIGH
)paren
op_le
l_int|0
)paren
(brace
id|read_unlock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
id|cb-&gt;args
(braket
l_int|1
)braket
op_assign
id|h
suffix:semicolon
id|cb-&gt;args
(braket
l_int|2
)braket
op_assign
id|idx
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|tbl-&gt;lock
)paren
suffix:semicolon
)brace
id|cb-&gt;args
(braket
l_int|1
)braket
op_assign
id|h
suffix:semicolon
id|cb-&gt;args
(braket
l_int|2
)braket
op_assign
id|idx
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
)brace
DECL|function|neigh_dump_info
r_int
id|neigh_dump_info
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|netlink_callback
op_star
id|cb
)paren
(brace
r_int
id|t
suffix:semicolon
r_int
id|s_t
suffix:semicolon
r_struct
id|neigh_table
op_star
id|tbl
suffix:semicolon
r_int
id|family
op_assign
(paren
(paren
r_struct
id|rtgenmsg
op_star
)paren
id|NLMSG_DATA
c_func
(paren
id|cb-&gt;nlh
)paren
)paren
op_member_access_from_pointer
id|rtgen_family
suffix:semicolon
id|s_t
op_assign
id|cb-&gt;args
(braket
l_int|0
)braket
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|neigh_tbl_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tbl
op_assign
id|neigh_tables
comma
id|t
op_assign
l_int|0
suffix:semicolon
id|tbl
suffix:semicolon
id|tbl
op_assign
id|tbl-&gt;next
comma
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
id|t
OL
id|s_t
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|family
op_logical_and
id|tbl-&gt;family
op_ne
id|family
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|t
OG
id|s_t
)paren
id|memset
c_func
(paren
op_amp
id|cb-&gt;args
(braket
l_int|1
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|cb-&gt;args
)paren
op_minus
r_sizeof
(paren
id|cb-&gt;args
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|neigh_dump_table
c_func
(paren
id|tbl
comma
id|skb
comma
id|cb
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|neigh_tbl_lock
)paren
suffix:semicolon
id|cb-&gt;args
(braket
l_int|0
)braket
op_assign
id|t
suffix:semicolon
r_return
id|skb-&gt;len
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_ARPD
DECL|function|neigh_app_ns
r_void
id|neigh_app_ns
c_func
(paren
r_struct
id|neighbour
op_star
id|n
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|nlmsghdr
op_star
id|nlh
suffix:semicolon
r_int
id|size
op_assign
id|NLMSG_SPACE
c_func
(paren
r_sizeof
(paren
r_struct
id|ndmsg
)paren
op_plus
l_int|256
)paren
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|neigh_fill_info
c_func
(paren
id|skb
comma
id|n
comma
l_int|0
comma
l_int|0
comma
id|RTM_GETNEIGH
)paren
OL
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|nlh
op_assign
(paren
r_struct
id|nlmsghdr
op_star
)paren
id|skb-&gt;data
suffix:semicolon
id|nlh-&gt;nlmsg_flags
op_assign
id|NLM_F_REQUEST
suffix:semicolon
id|NETLINK_CB
c_func
(paren
id|skb
)paren
dot
id|dst_groups
op_assign
id|RTMGRP_NEIGH
suffix:semicolon
id|netlink_broadcast
c_func
(paren
id|rtnl
comma
id|skb
comma
l_int|0
comma
id|RTMGRP_NEIGH
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
DECL|function|neigh_app_notify
r_static
r_void
id|neigh_app_notify
c_func
(paren
r_struct
id|neighbour
op_star
id|n
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|nlmsghdr
op_star
id|nlh
suffix:semicolon
r_int
id|size
op_assign
id|NLMSG_SPACE
c_func
(paren
r_sizeof
(paren
r_struct
id|ndmsg
)paren
op_plus
l_int|256
)paren
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|neigh_fill_info
c_func
(paren
id|skb
comma
id|n
comma
l_int|0
comma
l_int|0
comma
id|RTM_NEWNEIGH
)paren
OL
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|nlh
op_assign
(paren
r_struct
id|nlmsghdr
op_star
)paren
id|skb-&gt;data
suffix:semicolon
id|NETLINK_CB
c_func
(paren
id|skb
)paren
dot
id|dst_groups
op_assign
id|RTMGRP_NEIGH
suffix:semicolon
id|netlink_broadcast
c_func
(paren
id|rtnl
comma
id|skb
comma
l_int|0
comma
id|RTMGRP_NEIGH
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif
macro_line|#ifdef CONFIG_SYSCTL
DECL|struct|neigh_sysctl_table
r_struct
id|neigh_sysctl_table
(brace
DECL|member|sysctl_header
r_struct
id|ctl_table_header
op_star
id|sysctl_header
suffix:semicolon
DECL|member|neigh_vars
id|ctl_table
id|neigh_vars
(braket
l_int|17
)braket
suffix:semicolon
DECL|member|neigh_dev
id|ctl_table
id|neigh_dev
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|neigh_neigh_dir
id|ctl_table
id|neigh_neigh_dir
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|neigh_proto_dir
id|ctl_table
id|neigh_proto_dir
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|neigh_root_dir
id|ctl_table
id|neigh_root_dir
(braket
l_int|2
)braket
suffix:semicolon
DECL|variable|neigh_sysctl_template
)brace
id|neigh_sysctl_template
op_assign
(brace
l_int|NULL
comma
(brace
(brace
id|NET_NEIGH_MCAST_SOLICIT
comma
l_string|&quot;mcast_solicit&quot;
comma
l_int|NULL
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
(brace
id|NET_NEIGH_UCAST_SOLICIT
comma
l_string|&quot;ucast_solicit&quot;
comma
l_int|NULL
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
(brace
id|NET_NEIGH_APP_SOLICIT
comma
l_string|&quot;app_solicit&quot;
comma
l_int|NULL
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
(brace
id|NET_NEIGH_RETRANS_TIME
comma
l_string|&quot;retrans_time&quot;
comma
l_int|NULL
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
(brace
id|NET_NEIGH_REACHABLE_TIME
comma
l_string|&quot;base_reachable_time&quot;
comma
l_int|NULL
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec_jiffies
)brace
comma
(brace
id|NET_NEIGH_DELAY_PROBE_TIME
comma
l_string|&quot;delay_first_probe_time&quot;
comma
l_int|NULL
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec_jiffies
)brace
comma
(brace
id|NET_NEIGH_GC_STALE_TIME
comma
l_string|&quot;gc_stale_time&quot;
comma
l_int|NULL
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec_jiffies
)brace
comma
(brace
id|NET_NEIGH_UNRES_QLEN
comma
l_string|&quot;unres_qlen&quot;
comma
l_int|NULL
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
(brace
id|NET_NEIGH_PROXY_QLEN
comma
l_string|&quot;proxy_qlen&quot;
comma
l_int|NULL
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
(brace
id|NET_NEIGH_ANYCAST_DELAY
comma
l_string|&quot;anycast_delay&quot;
comma
l_int|NULL
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
(brace
id|NET_NEIGH_PROXY_DELAY
comma
l_string|&quot;proxy_delay&quot;
comma
l_int|NULL
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
(brace
id|NET_NEIGH_LOCKTIME
comma
l_string|&quot;locktime&quot;
comma
l_int|NULL
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
(brace
id|NET_NEIGH_GC_INTERVAL
comma
l_string|&quot;gc_interval&quot;
comma
l_int|NULL
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec_jiffies
)brace
comma
(brace
id|NET_NEIGH_GC_THRESH1
comma
l_string|&quot;gc_thresh1&quot;
comma
l_int|NULL
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
(brace
id|NET_NEIGH_GC_THRESH2
comma
l_string|&quot;gc_thresh2&quot;
comma
l_int|NULL
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
(brace
id|NET_NEIGH_GC_THRESH3
comma
l_string|&quot;gc_thresh3&quot;
comma
l_int|NULL
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
(brace
l_int|0
)brace
)brace
comma
(brace
(brace
id|NET_PROTO_CONF_DEFAULT
comma
l_string|&quot;default&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
l_int|NULL
)brace
comma
(brace
l_int|0
)brace
)brace
comma
(brace
(brace
l_int|0
comma
l_string|&quot;neigh&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
l_int|NULL
)brace
comma
(brace
l_int|0
)brace
)brace
comma
(brace
(brace
l_int|0
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
l_int|NULL
)brace
comma
(brace
l_int|0
)brace
)brace
comma
(brace
(brace
id|CTL_NET
comma
l_string|&quot;net&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
l_int|NULL
)brace
comma
(brace
l_int|0
)brace
)brace
)brace
suffix:semicolon
DECL|function|neigh_sysctl_register
r_int
id|neigh_sysctl_register
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|neigh_parms
op_star
id|p
comma
r_int
id|p_id
comma
r_int
id|pdev_id
comma
r_char
op_star
id|p_name
)paren
(brace
r_struct
id|neigh_sysctl_table
op_star
id|t
suffix:semicolon
id|t
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOBUFS
suffix:semicolon
id|memcpy
c_func
(paren
id|t
comma
op_amp
id|neigh_sysctl_template
comma
r_sizeof
(paren
op_star
id|t
)paren
)paren
suffix:semicolon
id|t-&gt;neigh_vars
(braket
l_int|0
)braket
dot
id|data
op_assign
op_amp
id|p-&gt;mcast_probes
suffix:semicolon
id|t-&gt;neigh_vars
(braket
l_int|1
)braket
dot
id|data
op_assign
op_amp
id|p-&gt;ucast_probes
suffix:semicolon
id|t-&gt;neigh_vars
(braket
l_int|2
)braket
dot
id|data
op_assign
op_amp
id|p-&gt;app_probes
suffix:semicolon
id|t-&gt;neigh_vars
(braket
l_int|3
)braket
dot
id|data
op_assign
op_amp
id|p-&gt;retrans_time
suffix:semicolon
id|t-&gt;neigh_vars
(braket
l_int|4
)braket
dot
id|data
op_assign
op_amp
id|p-&gt;base_reachable_time
suffix:semicolon
id|t-&gt;neigh_vars
(braket
l_int|5
)braket
dot
id|data
op_assign
op_amp
id|p-&gt;delay_probe_time
suffix:semicolon
id|t-&gt;neigh_vars
(braket
l_int|6
)braket
dot
id|data
op_assign
op_amp
id|p-&gt;gc_staletime
suffix:semicolon
id|t-&gt;neigh_vars
(braket
l_int|7
)braket
dot
id|data
op_assign
op_amp
id|p-&gt;queue_len
suffix:semicolon
id|t-&gt;neigh_vars
(braket
l_int|8
)braket
dot
id|data
op_assign
op_amp
id|p-&gt;proxy_qlen
suffix:semicolon
id|t-&gt;neigh_vars
(braket
l_int|9
)braket
dot
id|data
op_assign
op_amp
id|p-&gt;anycast_delay
suffix:semicolon
id|t-&gt;neigh_vars
(braket
l_int|10
)braket
dot
id|data
op_assign
op_amp
id|p-&gt;proxy_delay
suffix:semicolon
id|t-&gt;neigh_vars
(braket
l_int|11
)braket
dot
id|data
op_assign
op_amp
id|p-&gt;locktime
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
(brace
id|t-&gt;neigh_dev
(braket
l_int|0
)braket
dot
id|procname
op_assign
id|dev-&gt;name
suffix:semicolon
id|t-&gt;neigh_dev
(braket
l_int|0
)braket
dot
id|ctl_name
op_assign
id|dev-&gt;ifindex
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|t-&gt;neigh_vars
(braket
l_int|12
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|ctl_table
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|t-&gt;neigh_vars
(braket
l_int|12
)braket
dot
id|data
op_assign
(paren
r_int
op_star
)paren
(paren
id|p
op_plus
l_int|1
)paren
suffix:semicolon
id|t-&gt;neigh_vars
(braket
l_int|13
)braket
dot
id|data
op_assign
(paren
r_int
op_star
)paren
(paren
id|p
op_plus
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
id|t-&gt;neigh_vars
(braket
l_int|14
)braket
dot
id|data
op_assign
(paren
r_int
op_star
)paren
(paren
id|p
op_plus
l_int|1
)paren
op_plus
l_int|2
suffix:semicolon
id|t-&gt;neigh_vars
(braket
l_int|15
)braket
dot
id|data
op_assign
(paren
r_int
op_star
)paren
(paren
id|p
op_plus
l_int|1
)paren
op_plus
l_int|3
suffix:semicolon
)brace
id|t-&gt;neigh_neigh_dir
(braket
l_int|0
)braket
dot
id|ctl_name
op_assign
id|pdev_id
suffix:semicolon
id|t-&gt;neigh_proto_dir
(braket
l_int|0
)braket
dot
id|procname
op_assign
id|p_name
suffix:semicolon
id|t-&gt;neigh_proto_dir
(braket
l_int|0
)braket
dot
id|ctl_name
op_assign
id|p_id
suffix:semicolon
id|t-&gt;neigh_dev
(braket
l_int|0
)braket
dot
id|child
op_assign
id|t-&gt;neigh_vars
suffix:semicolon
id|t-&gt;neigh_neigh_dir
(braket
l_int|0
)braket
dot
id|child
op_assign
id|t-&gt;neigh_dev
suffix:semicolon
id|t-&gt;neigh_proto_dir
(braket
l_int|0
)braket
dot
id|child
op_assign
id|t-&gt;neigh_neigh_dir
suffix:semicolon
id|t-&gt;neigh_root_dir
(braket
l_int|0
)braket
dot
id|child
op_assign
id|t-&gt;neigh_proto_dir
suffix:semicolon
id|t-&gt;sysctl_header
op_assign
id|register_sysctl_table
c_func
(paren
id|t-&gt;neigh_root_dir
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;sysctl_header
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|t
)paren
suffix:semicolon
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
id|p-&gt;sysctl_table
op_assign
id|t
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|neigh_sysctl_unregister
r_void
id|neigh_sysctl_unregister
c_func
(paren
r_struct
id|neigh_parms
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;sysctl_table
)paren
(brace
r_struct
id|neigh_sysctl_table
op_star
id|t
op_assign
id|p-&gt;sysctl_table
suffix:semicolon
id|p-&gt;sysctl_table
op_assign
l_int|NULL
suffix:semicolon
id|unregister_sysctl_table
c_func
(paren
id|t-&gt;sysctl_header
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* CONFIG_SYSCTL */
eof
