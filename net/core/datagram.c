multiline_comment|/*&n; *&t;SUCS NET3:&n; *&n; *&t;Generic datagram handling routines. These are generic for all protocols. Possibly a generic IP version on top&n; *&t;of these would make sense. Not tonight however 8-).&n; *&t;This is used because UDP, RAW, PACKET, DDP, IPX, AX.25 and NetROM layer all have identical poll code and mostly&n; *&t;identical recvmsg() code. So we share it here. The poll was shared before but buried in udp.c so I moved it.&n; *&n; *&t;Authors:&t;Alan Cox &lt;alan@redhat.com&gt;. (datagram_poll() from old udp.c code)&n; *&n; *&t;Fixes:&n; *&t;&t;Alan Cox&t;:&t;NULL return from skb_peek_copy() understood&n; *&t;&t;Alan Cox&t;:&t;Rewrote skb_read_datagram to avoid the skb_peek_copy stuff.&n; *&t;&t;Alan Cox&t;:&t;Added support for SOCK_SEQPACKET. IPX can no longer use the SO_TYPE hack but&n; *&t;&t;&t;&t;&t;AX.25 now works right, and SPX is feasible.&n; *&t;&t;Alan Cox&t;:&t;Fixed write poll of non IP protocol crash.&n; *&t;&t;Florian  La Roche:&t;Changed for my new skbuff handling.&n; *&t;&t;Darryl Miles&t;:&t;Fixed non-blocking SOCK_SEQPACKET.&n; *&t;&t;Linus Torvalds&t;:&t;BSD semantic fixes.&n; *&t;&t;Alan Cox&t;:&t;Datagram iovec handling&n; *&t;&t;Darryl Miles&t;:&t;Fixed non-blocking SOCK_STREAM.&n; *&t;&t;Alan Cox&t;:&t;POSIXisms&n; *&t;&t;Pete Wyckoff    :       Unconnected accept() fix.&n; *&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
multiline_comment|/*&n; *&t;Is a socket &squot;connection oriented&squot; ?&n; */
DECL|function|connection_based
r_static
r_inline
r_int
id|connection_based
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
(paren
id|sk-&gt;type
op_eq
id|SOCK_SEQPACKET
op_logical_or
id|sk-&gt;type
op_eq
id|SOCK_STREAM
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for a packet..&n; */
DECL|function|wait_for_packet
r_static
r_int
id|wait_for_packet
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
op_star
id|err
comma
r_int
op_star
id|timeo_p
)paren
(brace
r_int
id|error
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* Socket errors? */
id|error
op_assign
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
r_goto
id|ready
suffix:semicolon
multiline_comment|/* Socket shut down? */
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Sequenced packets can come disconnected. If so we report the problem */
id|error
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_if
c_cond
(paren
id|connection_based
c_func
(paren
id|sk
)paren
op_logical_and
op_logical_neg
(paren
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* handle signals */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_goto
id|interrupted
suffix:semicolon
op_star
id|timeo_p
op_assign
id|schedule_timeout
c_func
(paren
op_star
id|timeo_p
)paren
suffix:semicolon
id|ready
suffix:colon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|interrupted
suffix:colon
id|error
op_assign
id|sock_intr_errno
c_func
(paren
op_star
id|timeo_p
)paren
suffix:semicolon
id|out
suffix:colon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
op_star
id|err
op_assign
id|error
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get a datagram skbuff, understands the peeking, nonblocking wakeups and possible&n; *&t;races. This replaces identical code in packet,raw and udp, as well as the IPX&n; *&t;AX.25 and Appletalk. It also finally fixes the long standing peek and read&n; *&t;race for datagram sockets. If you alter this routine remember it must be&n; *&t;re-entrant.&n; *&n; *&t;This function will lock the socket if a skb is returned, so the caller&n; *&t;needs to unlock the socket in that case (usually by calling skb_free_datagram)&n; *&n; *&t;* It does not lock socket since today. This function is&n; *&t;* free of race conditions. This measure should/can improve&n; *&t;* significantly datagram socket latencies at high loads,&n; *&t;* when data copying to user space takes lots of time.&n; *&t;* (BTW I&squot;ve just killed the last cli() in IP/IPv6/core/netlink/packet&n; *&t;*  8) Great win.)&n; *&t;*&t;&t;&t;                    --ANK (980729)&n; *&n; *&t;The order of the tests when we find no data waiting are specified&n; *&t;quite explicitly by POSIX 1003.1g, don&squot;t change them without having&n; *&t;the standard around please.&n; */
DECL|function|skb_recv_datagram
r_struct
id|sk_buff
op_star
id|skb_recv_datagram
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
comma
r_int
id|noblock
comma
r_int
op_star
id|err
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|timeo
suffix:semicolon
multiline_comment|/* Caller is allowed not to check sk-&gt;err before skb_recv_datagram() */
id|error
op_assign
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|no_packet
suffix:semicolon
id|timeo
op_assign
id|sock_rcvtimeo
c_func
(paren
id|sk
comma
id|noblock
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* Again only user level code calls this function, so nothing interrupt level&n;&t;&t;   will suddenly eat the receive_queue.&n;&n;&t;&t;   Look at current nfs client by the way...&n;&t;&t;   However, this function was corrent in any case. 8)&n;&t;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
(brace
r_int
r_int
id|cpu_flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sk-&gt;receive_queue.lock
comma
id|cpu_flags
)paren
suffix:semicolon
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|skb-&gt;users
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sk-&gt;receive_queue.lock
comma
id|cpu_flags
)paren
suffix:semicolon
)brace
r_else
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
r_return
id|skb
suffix:semicolon
multiline_comment|/* User doesn&squot;t want to wait */
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timeo
)paren
r_goto
id|no_packet
suffix:semicolon
)brace
r_while
c_loop
(paren
id|wait_for_packet
c_func
(paren
id|sk
comma
id|err
comma
op_amp
id|timeo
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
id|no_packet
suffix:colon
op_star
id|err
op_assign
id|error
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|skb_free_datagram
r_void
id|skb_free_datagram
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Copy a datagram to a linear buffer.&n; */
DECL|function|skb_copy_datagram
r_int
id|skb_copy_datagram
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|offset
comma
r_char
op_star
id|to
comma
r_int
id|size
)paren
(brace
r_int
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_to_user
c_func
(paren
id|to
comma
id|skb-&gt;h.raw
op_plus
id|offset
comma
id|size
)paren
)paren
id|err
op_assign
l_int|0
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Copy a datagram to an iovec.&n; *&t;Note: the iovec is modified during the copy.&n; */
DECL|function|skb_copy_datagram_iovec
r_int
id|skb_copy_datagram_iovec
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|offset
comma
r_struct
id|iovec
op_star
id|to
comma
r_int
id|size
)paren
(brace
r_return
id|memcpy_toiovec
c_func
(paren
id|to
comma
id|skb-&gt;h.raw
op_plus
id|offset
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Datagram poll: Again totally generic. This also handles&n; *&t;sequenced packet sockets providing the socket receive queue&n; *&t;is only ever holding data ready to receive.&n; *&n; *&t;Note: when you _don&squot;t_ use this routine for this protocol,&n; *&t;and you use a different write policy from sock_writeable()&n; *&t;then please supply your own write_space callback.&n; */
DECL|function|datagram_poll
r_int
r_int
id|datagram_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|socket
op_star
id|sock
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
id|sk-&gt;sleep
comma
id|wait
)paren
suffix:semicolon
id|mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* exceptional events? */
r_if
c_cond
(paren
id|sk-&gt;err
op_logical_or
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;error_queue
)paren
)paren
id|mask
op_or_assign
id|POLLERR
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_eq
id|SHUTDOWN_MASK
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
multiline_comment|/* readable? */
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
op_logical_or
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
multiline_comment|/* Connection-based need to check for termination and startup */
r_if
c_cond
(paren
id|connection_based
c_func
(paren
id|sk
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
multiline_comment|/* connection hasn&squot;t started yet? */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
)paren
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/* writable? */
r_if
c_cond
(paren
id|sock_writeable
c_func
(paren
id|sk
)paren
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
op_or
id|POLLWRBAND
suffix:semicolon
r_else
id|set_bit
c_func
(paren
id|SOCK_ASYNC_NOSPACE
comma
op_amp
id|sk-&gt;socket-&gt;flags
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
eof
