multiline_comment|/*&n; *&t;SUCS NET3:&n; *&n; *&t;Generic datagram handling routines. These are generic for all protocols. Possibly a generic IP version on top&n; *&t;of these would make sense. Not tonight however 8-).&n; *&t;This is used because UDP, RAW, PACKET and the to be released IPX layer all have identical select code and mostly&n; *&t;identical recvfrom() code. So we share it here. The select was shared before but buried in udp.c so I moved it.&n; *&n; *&t;Authors:&t;Alan Cox &lt;iiitac@pyr.swan.ac.uk&gt;. (datagram_select() from old udp.c code)&n; *&n; *&t;Fixes:&n; *&t;&t;Alan Cox&t;:&t;NULL return from skb_peek_copy() understood&n; *&t;&t;Alan Cox&t;:&t;Rewrote skb_read_datagram to avoid the skb_peek_copy stuff.&n; *&t;&t;Alan Cox&t;:&t;Added support for SOCK_SEQPACKET. IPX can no longer use the SO_TYPE hack but&n; *&t;&t;&t;&t;&t;AX.25 now works right, and SPX is feasible.&n; *&t;&t;Alan Cox&t;:&t;Fixed write select of non IP protocol crash.&n; *&t;&t;Florian  La Roche:&t;Changed for my new skbuff handling.&n; *&t;&t;Darryl Miles&t;:&t;Fixed non-blocking SOCK_SEQPACKET.&n; *&t;&t;Linus Torvalds&t;:&t;BSD semantic fixes.&n; *&t;&t;Alan Cox&t;:&t;Datagram iovec handling&n; *&n; *&t;Note:&n; *&t;&t;A lot of this will change when the protocol/socket separation&n; *&t;occurs. Using this will make things reasonably clean.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
multiline_comment|/*&n; *&t;Get a datagram skbuff, understands the peeking, nonblocking wakeups and possible&n; *&t;races. This replaces identical code in packet,raw and udp, as well as the IPX&n; *&t;AX.25 and Appletalk. It also finally fixes the long standing peek and read&n; *&t;race for datagram sockets. If you alter this routine remember it must be&n; *&t;re-entrant.&n; */
DECL|function|skb_recv_datagram
r_struct
id|sk_buff
op_star
id|skb_recv_datagram
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
comma
r_int
id|noblock
comma
r_int
op_star
id|err
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|intflags
suffix:semicolon
multiline_comment|/* Socket is inuse - so the timer doesn&squot;t attack it */
id|save_flags
c_func
(paren
id|intflags
)paren
suffix:semicolon
id|restart
suffix:colon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
op_eq
l_int|NULL
)paren
multiline_comment|/* No data */
(brace
multiline_comment|/* If we are shutdown then no more data is going to appear. We are done */
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
op_star
id|err
op_assign
l_int|0
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;err
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
op_star
id|err
op_assign
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|intflags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Sequenced packets can come disconnected. If so we report the problem */
r_if
c_cond
(paren
id|sk-&gt;type
op_eq
id|SOCK_SEQPACKET
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
op_star
id|err
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* User doesn&squot;t want to wait */
r_if
c_cond
(paren
id|noblock
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
op_star
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Interrupts off so that no packet arrives before we begin sleeping.&n;&t;&t;   Otherwise we might miss our wake up */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
op_eq
l_int|NULL
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
multiline_comment|/* Signals may need a restart of the syscall */
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|restore_flags
c_func
(paren
id|intflags
)paren
suffix:semicolon
suffix:semicolon
op_star
id|err
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;err
op_ne
l_int|0
)paren
multiline_comment|/* Error while waiting for packet&n;&t;&t;&t;&t;&t;&t;   eg an icmp sent earlier by the&n;&t;&t;&t;&t;&t;&t;   peer has finally turned up now */
(brace
op_star
id|err
op_assign
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|intflags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|intflags
)paren
suffix:semicolon
)brace
multiline_comment|/* Again only user level code calls this function, so nothing interrupt level&n;&t;     will suddenly eat the receive_queue */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
)paren
(brace
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|skb-&gt;users
op_increment
suffix:semicolon
)brace
r_else
r_goto
id|restart
suffix:semicolon
multiline_comment|/* Avoid race if someone beats us to the data */
)brace
r_else
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|skb-&gt;users
op_increment
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|intflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* shouldn&squot;t happen but .. */
op_star
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
r_return
id|skb
suffix:semicolon
)brace
DECL|function|skb_free_datagram
r_void
id|skb_free_datagram
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb-&gt;users
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;users
OG
l_int|0
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* See if it needs destroying */
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;next
op_logical_and
op_logical_neg
id|skb-&gt;prev
)paren
(brace
multiline_comment|/* Been dequeued by someone - ie it&squot;s read */
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Copy a datagram to a linear buffer.&n; */
DECL|function|skb_copy_datagram
r_void
id|skb_copy_datagram
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|offset
comma
r_char
op_star
id|to
comma
r_int
id|size
)paren
(brace
id|memcpy_tofs
c_func
(paren
id|to
comma
id|skb-&gt;h.raw
op_plus
id|offset
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Copy a datagram to an iovec.&n; */
DECL|function|skb_copy_datagram_iovec
r_void
id|skb_copy_datagram_iovec
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|offset
comma
r_struct
id|iovec
op_star
id|to
comma
r_int
id|size
)paren
(brace
id|memcpy_toiovec
c_func
(paren
id|to
comma
id|skb-&gt;h.raw
op_plus
id|offset
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Datagram select: Again totally generic. Moved from udp.c&n; *&t;Now does seqpacket.&n; */
DECL|function|datagram_select
r_int
id|datagram_select
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
(brace
id|select_wait
c_func
(paren
id|sk-&gt;sleep
comma
id|wait
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sel_type
)paren
(brace
r_case
id|SEL_IN
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;type
op_eq
id|SOCK_SEQPACKET
op_logical_and
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
(brace
multiline_comment|/* Connection closed: Wake up */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* This appears to be consistent&n;&t;&t;&t;&t;   with other stacks */
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SEL_OUT
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;type
op_eq
id|SOCK_SEQPACKET
op_logical_and
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
)paren
(brace
multiline_comment|/* Connection still in progress */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;prot
op_logical_and
id|sock_wspace
c_func
(paren
id|sk
)paren
op_ge
id|MIN_WRITE_SPACE
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;prot
op_eq
l_int|NULL
op_logical_and
id|sk-&gt;sndbuf
op_minus
id|sk-&gt;wmem_alloc
op_ge
id|MIN_WRITE_SPACE
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SEL_EX
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Socket has gone into error state (eg icmp error) */
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
