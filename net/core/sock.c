multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Generic socket support routines. Memory allocators, socket lock/release&n; *&t;&t;handler for protocols to use and generic option handler.&n; *&n; *&n; * Version:&t;@(#)sock.c&t;1.0.17&t;06/02/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Alan Cox, &lt;A.Cox@swansea.ac.uk&gt;&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;: &t;Numerous verify_area() problems&n; *&t;&t;Alan Cox&t;:&t;Connecting on a connecting socket&n; *&t;&t;&t;&t;&t;now returns an error for tcp.&n; *&t;&t;Alan Cox&t;:&t;sock-&gt;protocol is set correctly.&n; *&t;&t;&t;&t;&t;and is not sometimes left as 0.&n; *&t;&t;Alan Cox&t;:&t;connect handles icmp errors on a&n; *&t;&t;&t;&t;&t;connect properly. Unfortunately there&n; *&t;&t;&t;&t;&t;is a restart syscall nasty there. I&n; *&t;&t;&t;&t;&t;can&squot;t match BSD without hacking the C&n; *&t;&t;&t;&t;&t;library. Ideas urgently sought!&n; *&t;&t;Alan Cox&t;:&t;Disallow bind() to addresses that are&n; *&t;&t;&t;&t;&t;not ours - especially broadcast ones!!&n; *&t;&t;Alan Cox&t;:&t;Socket 1024 _IS_ ok for users. (fencepost)&n; *&t;&t;Alan Cox&t;:&t;sock_wfree/sock_rfree don&squot;t destroy sockets,&n; *&t;&t;&t;&t;&t;instead they leave that for the DESTROY timer.&n; *&t;&t;Alan Cox&t;:&t;Clean up error flag in accept&n; *&t;&t;Alan Cox&t;:&t;TCP ack handling is buggy, the DESTROY timer&n; *&t;&t;&t;&t;&t;was buggy. Put a remove_sock() in the handler&n; *&t;&t;&t;&t;&t;for memory when we hit 0. Also altered the timer&n; *&t;&t;&t;&t;&t;code. The ACK stuff can wait and needs major &n; *&t;&t;&t;&t;&t;TCP layer surgery.&n; *&t;&t;Alan Cox&t;:&t;Fixed TCP ack bug, removed remove sock&n; *&t;&t;&t;&t;&t;and fixed timer/inet_bh race.&n; *&t;&t;Alan Cox&t;:&t;Added zapped flag for TCP&n; *&t;&t;Alan Cox&t;:&t;Move kfree_skb into skbuff.c and tidied up surplus code&n; *&t;&t;Alan Cox&t;:&t;for new sk_buff allocations wmalloc/rmalloc now call alloc_skb&n; *&t;&t;Alan Cox&t;:&t;kfree_s calls now are kfree_skbmem so we can track skb resources&n; *&t;&t;Alan Cox&t;:&t;Supports socket option broadcast now as does udp. Packet and raw need fixing.&n; *&t;&t;Alan Cox&t;:&t;Added RCVBUF,SNDBUF size setting. It suddenly occurred to me how easy it was so...&n; *&t;&t;Rick Sladkey&t;:&t;Relaxed UDP rules for matching packets.&n; *&t;&t;C.E.Hawkins&t;:&t;IFF_PROMISC/SIOCGHWADDR support&n; *&t;Pauline Middelink&t;:&t;identd support&n; *&t;&t;Alan Cox&t;:&t;Fixed connect() taking signals I think.&n; *&t;&t;Alan Cox&t;:&t;SO_LINGER supported&n; *&t;&t;Alan Cox&t;:&t;Error reporting fixes&n; *&t;&t;Anonymous&t;:&t;inet_create tidied up (sk-&gt;reuse setting)&n; *&t;&t;Alan Cox&t;:&t;inet sockets don&squot;t set sk-&gt;type!&n; *&t;&t;Alan Cox&t;:&t;Split socket option code&n; *&t;&t;Alan Cox&t;:&t;Callbacks&n; *&t;&t;Alan Cox&t;:&t;Nagle flag for Charles &amp; Johannes stuff&n; *&t;&t;Alex&t;&t;:&t;Removed restriction on inet fioctl&n; *&t;&t;Alan Cox&t;:&t;Splitting INET from NET core&n; *&t;&t;Alan Cox&t;:&t;Fixed bogus SO_TYPE handling in getsockopt()&n; *&t;&t;Adam Caldwell&t;:&t;Missing return in SO_DONTROUTE/SO_DEBUG code&n; *&t;&t;Alan Cox&t;:&t;Split IP from generic code&n; *&t;&t;Alan Cox&t;:&t;New kfree_skbmem()&n; *&t;&t;Alan Cox&t;:&t;Make SO_DEBUG superuser only.&n; *&t;&t;Alan Cox&t;:&t;Allow anyone to clear SO_DEBUG&n; *&t;&t;&t;&t;&t;(compatibility fix)&n; *&t;&t;Alan Cox&t;:&t;Added optimistic memory grabbing for AF_UNIX throughput.&n; *&t;&t;Alan Cox&t;:&t;Allocator for a socket is settable.&n; *&t;&t;Alan Cox&t;:&t;SO_ERROR includes soft errors.&n; *&t;&t;Alan Cox&t;:&t;Allow NULL arguments on some SO_ opts&n; *&t;&t;Alan Cox&t;: &t;Generic socket allocation to make hooks&n; *&t;&t;&t;&t;&t;easier (suggested by Craig Metz).&n; *&t;&t;Michael Pall&t;:&t;SO_ERROR returns positive errno again&n; *              Steve Whitehouse:       Added default destructor to free&n; *                                      protocol private data.&n; *              Steve Whitehouse:       Added various other default routines&n; *                                      common to several socket families.&n; *              Chris Evans     :       Call suser() check last on F_SETOWN&n; *&t;&t;Jay Schulist&t;:&t;Added SO_ATTACH_FILTER and SO_DETACH_FILTER.&n; *&t;&t;Andi Kleen&t;:&t;Add sock_kmalloc()/sock_kfree_s()&n; *&n; * To Fix:&n; *&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#include &lt;net/rarp.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/raw.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
macro_line|#include &lt;linux/ipsec.h&gt;
macro_line|#ifdef CONFIG_FILTER
macro_line|#include &lt;linux/filter.h&gt;
macro_line|#endif
DECL|macro|min
mdefine_line|#define min(a,b)&t;((a)&lt;(b)?(a):(b))
multiline_comment|/* Run time adjustable parameters. */
DECL|variable|sysctl_wmem_max
id|__u32
id|sysctl_wmem_max
op_assign
id|SK_WMEM_MAX
suffix:semicolon
DECL|variable|sysctl_rmem_max
id|__u32
id|sysctl_rmem_max
op_assign
id|SK_RMEM_MAX
suffix:semicolon
DECL|variable|sysctl_wmem_default
id|__u32
id|sysctl_wmem_default
op_assign
id|SK_WMEM_MAX
suffix:semicolon
DECL|variable|sysctl_rmem_default
id|__u32
id|sysctl_rmem_default
op_assign
id|SK_RMEM_MAX
suffix:semicolon
DECL|variable|sysctl_core_destroy_delay
r_int
id|sysctl_core_destroy_delay
op_assign
id|SOCK_DESTROY_TIME
suffix:semicolon
multiline_comment|/* Maximal space eaten by iovec (still not made (2.1.88)!) plus some space */
DECL|variable|sysctl_optmem_max
r_int
id|sysctl_optmem_max
op_assign
r_sizeof
(paren
r_int
r_int
)paren
op_star
(paren
l_int|2
op_star
id|UIO_MAXIOV
op_plus
l_int|512
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;This is meant for all protocols to use and covers goings on&n; *&t;at the socket level. Everything here is generic.&n; */
DECL|function|sock_setsockopt
r_int
id|sock_setsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_int
id|val
suffix:semicolon
r_int
id|valbool
suffix:semicolon
r_int
id|err
suffix:semicolon
r_struct
id|linger
id|ling
suffix:semicolon
r_struct
id|ifreq
id|req
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_FILTER
r_struct
id|sock_fprog
id|fprog
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Options without arguments&n;&t; */
macro_line|#ifdef SO_DONTLINGER&t;&t;/* Compatibility item... */
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|SO_DONTLINGER
suffix:colon
id|sk-&gt;linger
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;
r_if
c_cond
(paren
id|optlen
OL
r_sizeof
(paren
r_int
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|err
op_assign
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|optval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|valbool
op_assign
id|val
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|SO_DEBUG
suffix:colon
r_if
c_cond
(paren
id|val
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EACCES
suffix:semicolon
)brace
r_else
id|sk-&gt;debug
op_assign
id|valbool
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_REUSEADDR
suffix:colon
id|sk-&gt;reuse
op_assign
id|valbool
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_TYPE
suffix:colon
r_case
id|SO_ERROR
suffix:colon
id|ret
op_assign
op_minus
id|ENOPROTOOPT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_DONTROUTE
suffix:colon
id|sk-&gt;localroute
op_assign
id|valbool
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_BROADCAST
suffix:colon
id|sk-&gt;broadcast
op_assign
id|valbool
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_SNDBUF
suffix:colon
multiline_comment|/*&n;&t;&t;&t; *&t;The spec isnt clear if ENOBUFS or EINVAL&n;&t;&t;&t; *&t;is best&n;&t;&t;&t; */
multiline_comment|/* printk(KERN_DEBUG &quot;setting SO_SNDBUF %d&bslash;n&quot;, val); */
r_if
c_cond
(paren
id|val
OG
id|sysctl_wmem_max
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* FIXME: the tcp code should be made to work even&n;&t;&t;&t; * with small sndbuf values.&n;&t;&t;&t; */
id|sk-&gt;sndbuf
op_assign
id|max
c_func
(paren
id|val
op_star
l_int|2
comma
l_int|2048
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Wake up sending tasks if we&n;&t;&t;&t; *&t;upped the value.&n;&t;&t;&t; */
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_RCVBUF
suffix:colon
multiline_comment|/* printk(KERN_DEBUG &quot;setting SO_RCVBUF %d&bslash;n&quot;, val); */
r_if
c_cond
(paren
id|val
OG
id|sysctl_rmem_max
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* FIXME: is this lower bound the right one? */
id|sk-&gt;rcvbuf
op_assign
id|max
c_func
(paren
id|val
op_star
l_int|2
comma
l_int|256
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_KEEPALIVE
suffix:colon
macro_line|#ifdef CONFIG_INET
r_if
c_cond
(paren
id|sk-&gt;protocol
op_eq
id|IPPROTO_TCP
)paren
(brace
id|tcp_set_keepalive
c_func
(paren
id|sk
comma
id|valbool
)paren
suffix:semicolon
)brace
macro_line|#endif
id|sk-&gt;keepopen
op_assign
id|valbool
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_OOBINLINE
suffix:colon
id|sk-&gt;urginline
op_assign
id|valbool
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_NO_CHECK
suffix:colon
id|sk-&gt;no_check
op_assign
id|valbool
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_PRIORITY
suffix:colon
r_if
c_cond
(paren
id|val
op_ge
l_int|0
op_logical_and
id|val
op_le
l_int|7
)paren
id|sk-&gt;priority
op_assign
id|val
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_LINGER
suffix:colon
r_if
c_cond
(paren
id|optlen
OL
r_sizeof
(paren
id|ling
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* 1003.1g */
id|err
op_assign
id|copy_from_user
c_func
(paren
op_amp
id|ling
comma
id|optval
comma
r_sizeof
(paren
id|ling
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ling.l_onoff
op_eq
l_int|0
)paren
(brace
id|sk-&gt;linger
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;lingertime
op_assign
id|ling.l_linger
suffix:semicolon
id|sk-&gt;linger
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SO_BSDCOMPAT
suffix:colon
id|sk-&gt;bsdism
op_assign
id|valbool
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_PASSCRED
suffix:colon
id|sock-&gt;passcred
op_assign
id|valbool
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_BINDTODEVICE
suffix:colon
multiline_comment|/* Bind this socket to a particular device like &quot;eth0&quot;,&n;&t;&t;&t; * as specified in an ifreq structure. If the device&n;&t;&t;&t; * is &quot;&quot;, socket is NOT bound to a device.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|valbool
)paren
(brace
id|sk-&gt;bound_dev_if
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|req
comma
id|optval
comma
r_sizeof
(paren
id|req
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Remove any cached route for this socket. */
id|dst_release
c_func
(paren
id|xchg
c_func
(paren
op_amp
id|sk-&gt;dst_cache
comma
l_int|NULL
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req.ifr_ifrn.ifrn_name
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|sk-&gt;bound_dev_if
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|dev_get
c_func
(paren
id|req.ifr_ifrn.ifrn_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|sk-&gt;bound_dev_if
op_assign
id|dev-&gt;ifindex
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_FILTER
r_case
id|SO_ATTACH_FILTER
suffix:colon
r_if
c_cond
(paren
id|optlen
OL
r_sizeof
(paren
r_struct
id|sock_fprog
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|fprog
comma
id|optval
comma
r_sizeof
(paren
id|fprog
)paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret
op_assign
id|sk_attach_filter
c_func
(paren
op_amp
id|fprog
comma
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_DETACH_FILTER
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;filter
)paren
(brace
id|fprog.filter
op_assign
id|sk-&gt;filter_data
suffix:semicolon
id|kfree_s
c_func
(paren
id|fprog.filter
comma
(paren
r_sizeof
(paren
id|fprog.filter
)paren
op_star
id|sk-&gt;filter
)paren
)paren
suffix:semicolon
id|sk-&gt;filter_data
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;filter
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
multiline_comment|/* We implement the SO_SNDLOWAT etc to&n;&t;&t;   not be settable (1003.1g 5.3) */
r_default
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sock_getsockopt
r_int
id|sock_getsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_union
(brace
r_int
id|val
suffix:semicolon
r_struct
id|linger
id|ling
suffix:semicolon
r_struct
id|timeval
id|tm
suffix:semicolon
)brace
id|v
suffix:semicolon
r_int
id|lv
op_assign
r_sizeof
(paren
r_int
)paren
comma
id|len
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|SO_DEBUG
suffix:colon
id|v.val
op_assign
id|sk-&gt;debug
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_DONTROUTE
suffix:colon
id|v.val
op_assign
id|sk-&gt;localroute
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_BROADCAST
suffix:colon
id|v.val
op_assign
id|sk-&gt;broadcast
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_SNDBUF
suffix:colon
id|v.val
op_assign
id|sk-&gt;sndbuf
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_RCVBUF
suffix:colon
id|v.val
op_assign
id|sk-&gt;rcvbuf
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_REUSEADDR
suffix:colon
id|v.val
op_assign
id|sk-&gt;reuse
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_KEEPALIVE
suffix:colon
id|v.val
op_assign
id|sk-&gt;keepopen
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_TYPE
suffix:colon
id|v.val
op_assign
id|sk-&gt;type
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_ERROR
suffix:colon
id|v.val
op_assign
op_minus
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|v.val
op_eq
l_int|0
)paren
(brace
id|v.val
op_assign
id|xchg
c_func
(paren
op_amp
id|sk-&gt;err_soft
comma
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SO_OOBINLINE
suffix:colon
id|v.val
op_assign
id|sk-&gt;urginline
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_NO_CHECK
suffix:colon
id|v.val
op_assign
id|sk-&gt;no_check
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_PRIORITY
suffix:colon
id|v.val
op_assign
id|sk-&gt;priority
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_LINGER
suffix:colon
id|lv
op_assign
r_sizeof
(paren
id|v.ling
)paren
suffix:semicolon
id|v.ling.l_onoff
op_assign
id|sk-&gt;linger
suffix:semicolon
id|v.ling.l_linger
op_assign
id|sk-&gt;lingertime
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_BSDCOMPAT
suffix:colon
id|v.val
op_assign
id|sk-&gt;bsdism
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_RCVTIMEO
suffix:colon
r_case
id|SO_SNDTIMEO
suffix:colon
id|lv
op_assign
r_sizeof
(paren
r_struct
id|timeval
)paren
suffix:semicolon
id|v.tm.tv_sec
op_assign
l_int|0
suffix:semicolon
id|v.tm.tv_usec
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_RCVLOWAT
suffix:colon
r_case
id|SO_SNDLOWAT
suffix:colon
id|v.val
op_assign
l_int|1
suffix:semicolon
r_case
id|SO_PASSCRED
suffix:colon
id|v.val
op_assign
id|sock-&gt;passcred
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_PEERCRED
suffix:colon
id|lv
op_assign
r_sizeof
(paren
id|sk-&gt;peercred
)paren
suffix:semicolon
id|len
op_assign
id|min
c_func
(paren
id|len
comma
id|lv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|optval
comma
op_amp
id|sk-&gt;peercred
comma
id|len
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_goto
id|lenout
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
)brace
id|len
op_assign
id|min
c_func
(paren
id|len
comma
id|lv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|v
comma
id|len
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|lenout
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|sk_cachep
r_static
id|kmem_cache_t
op_star
id|sk_cachep
suffix:semicolon
multiline_comment|/*&n; *&t;All socket objects are allocated here. This is for future&n; *&t;usage.&n; */
DECL|function|sk_alloc
r_struct
id|sock
op_star
id|sk_alloc
c_func
(paren
r_int
id|family
comma
r_int
id|priority
comma
r_int
id|zero_it
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|kmem_cache_alloc
c_func
(paren
id|sk_cachep
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_logical_and
id|zero_it
)paren
(brace
id|memset
c_func
(paren
id|sk
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sock
)paren
)paren
suffix:semicolon
id|sk-&gt;family
op_assign
id|family
suffix:semicolon
)brace
r_return
id|sk
suffix:semicolon
)brace
DECL|function|sk_free
r_void
id|sk_free
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;destruct
)paren
id|sk
op_member_access_from_pointer
id|destruct
c_func
(paren
id|sk
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|sk_cachep
comma
id|sk
)paren
suffix:semicolon
)brace
DECL|function|sk_init
r_void
id|sk_init
c_func
(paren
r_void
)paren
(brace
id|sk_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;sock&quot;
comma
r_sizeof
(paren
r_struct
id|sock
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Simple resource managers for sockets.&n; */
DECL|function|sock_wfree
r_void
id|sock_wfree
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|skb-&gt;sk
suffix:semicolon
macro_line|#if 1
r_if
c_cond
(paren
op_logical_neg
id|sk
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;sock_wfree: sk==NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* In case it might be waiting for more memory. */
id|atomic_sub
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;wmem_alloc
)paren
suffix:semicolon
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
DECL|function|sock_rfree
r_void
id|sock_rfree
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|skb-&gt;sk
suffix:semicolon
macro_line|#if 1
r_if
c_cond
(paren
op_logical_neg
id|sk
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;sock_rfree: sk==NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|atomic_sub
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;rmem_alloc
)paren
suffix:semicolon
)brace
DECL|function|sock_wmalloc
r_struct
id|sk_buff
op_star
id|sock_wmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
id|force
comma
r_int
id|priority
)paren
(brace
r_if
c_cond
(paren
id|force
op_logical_or
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
OL
id|sk-&gt;sndbuf
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|size
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
id|atomic_add
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;wmem_alloc
)paren
suffix:semicolon
id|skb-&gt;destructor
op_assign
id|sock_wfree
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
)brace
r_return
id|skb
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|sock_rmalloc
r_struct
id|sk_buff
op_star
id|sock_rmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
id|force
comma
r_int
id|priority
)paren
(brace
r_if
c_cond
(paren
id|force
op_logical_or
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
OL
id|sk-&gt;rcvbuf
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|size
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
id|atomic_add
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;rmem_alloc
)paren
suffix:semicolon
id|skb-&gt;destructor
op_assign
id|sock_rfree
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
)brace
r_return
id|skb
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|sock_kmalloc
r_void
op_star
id|sock_kmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|size
comma
r_int
id|priority
)paren
(brace
r_void
op_star
id|mem
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;omem_alloc
)paren
op_plus
id|size
OL
id|sysctl_optmem_max
)paren
(brace
multiline_comment|/* First do the add, to avoid the race if kmalloc&n; &t;&t; * might sleep.&n;&t;&t; */
id|atomic_add
c_func
(paren
id|size
comma
op_amp
id|sk-&gt;omem_alloc
)paren
suffix:semicolon
id|mem
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|priority
)paren
suffix:semicolon
)brace
r_return
id|mem
suffix:semicolon
)brace
DECL|function|sock_kfree_s
r_void
id|sock_kfree_s
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_void
op_star
id|mem
comma
r_int
id|size
)paren
(brace
id|kfree_s
c_func
(paren
id|mem
comma
id|size
)paren
suffix:semicolon
id|atomic_sub
c_func
(paren
id|size
comma
op_amp
id|sk-&gt;omem_alloc
)paren
suffix:semicolon
)brace
multiline_comment|/* FIXME: this is insane. We are trying suppose to be controlling how&n; * how much space we have for data bytes, not packet headers.&n; * This really points out that we need a better system for doing the&n; * receive buffer. -- erics&n; * WARNING: This is currently ONLY used in tcp. If you need it else where&n; * this will probably not be what you want. Possibly these two routines&n; * should move over to the ipv4 directory.&n; */
DECL|function|sock_rspace
r_int
r_int
id|sock_rspace
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|amt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* This used to have some bizarre complications that&n;&t;&t; * to attempt to reserve some amount of space. This doesn&squot;t&n;&t; &t; * make sense, since the number returned here does not&n;&t;&t; * actually reflect allocated space, but rather the amount&n;&t;&t; * of space we committed to. We gamble that we won&squot;t&n;&t;&t; * run out of memory, and returning a smaller number does&n;&t;&t; * not change the gamble. If we lose the gamble tcp still&n;&t;&t; * works, it may just slow down for retransmissions.&n;&t;&t; */
id|amt
op_assign
id|sk-&gt;rcvbuf
op_minus
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amt
OL
l_int|0
)paren
id|amt
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|amt
suffix:semicolon
)brace
multiline_comment|/* FIXME: this is also insane. See above comment */
DECL|function|sock_wspace
r_int
r_int
id|sock_wspace
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|amt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_ne
l_int|NULL
op_logical_and
op_logical_neg
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
)paren
(brace
id|amt
op_assign
id|sk-&gt;sndbuf
op_minus
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amt
OL
l_int|0
)paren
id|amt
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|amt
suffix:semicolon
)brace
multiline_comment|/* It is almost wait_for_tcp_memory minus release_sock/lock_sock.&n;   I think, these locks should be removed for datagram sockets.&n; */
DECL|function|sock_wait_for_wmem
r_static
r_void
id|sock_wait_for_wmem
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
id|sk-&gt;socket-&gt;flags
op_and_assign
op_complement
id|SO_NOSPACE
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
OL
id|sk-&gt;sndbuf
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Generic send/receive buffer handlers&n; */
DECL|function|sock_alloc_send_skb
r_struct
id|sk_buff
op_star
id|sock_alloc_send_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
r_int
id|fallback
comma
r_int
id|noblock
comma
r_int
op_star
id|errcode
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
r_int
id|try_size
op_assign
id|size
suffix:semicolon
id|err
op_assign
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|0
)paren
r_goto
id|failure
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;We should send SIGPIPE in these cases according to&n;&t;&t; *&t;1003.1g draft 6.4. If we (the user) did a shutdown()&n;&t;&t; *&t;call however we should not. &n;&t;&t; *&n;&t;&t; *&t;Note: This routine isnt just used for datagrams and&n;&t;&t; *&t;anyway some datagram protocols have a notion of&n;&t;&t; *&t;close down.&n;&t;&t; */
id|err
op_assign
op_minus
id|EPIPE
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
r_goto
id|failure
suffix:semicolon
r_if
c_cond
(paren
id|fallback
)paren
(brace
multiline_comment|/* The buffer get won&squot;t block, or use the atomic queue.&n;&t;&t;&t; * It does produce annoying no free page messages still.&n;&t;&t;&t; */
id|skb
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|size
comma
l_int|0
comma
id|GFP_BUFFER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
r_break
suffix:semicolon
id|try_size
op_assign
id|fallback
suffix:semicolon
)brace
id|skb
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|try_size
comma
l_int|0
comma
id|sk-&gt;allocation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;This means we have too many buffers for this socket already.&n;&t;&t; */
id|sk-&gt;socket-&gt;flags
op_or_assign
id|SO_NOSPACE
suffix:semicolon
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|noblock
)paren
r_goto
id|failure
suffix:semicolon
id|err
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_goto
id|failure
suffix:semicolon
id|sock_wait_for_wmem
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_return
id|skb
suffix:semicolon
id|failure
suffix:colon
op_star
id|errcode
op_assign
id|err
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|__release_sock
r_void
id|__release_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
macro_line|#ifdef CONFIG_INET
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;prot
op_logical_or
op_logical_neg
id|sk-&gt;backlog_rcv
)paren
r_return
suffix:semicolon
multiline_comment|/* See if we have any packets built up. */
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;back_log
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|sk-&gt;back_log.next
suffix:semicolon
id|__skb_unlink
c_func
(paren
id|skb
comma
op_amp
id|sk-&gt;back_log
)paren
suffix:semicolon
id|sk
op_member_access_from_pointer
id|backlog_rcv
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif  
)brace
multiline_comment|/*&n; *&t;Generic socket manager library. Most simpler socket families&n; *&t;use this to manage their socket lists. At some point we should&n; *&t;hash these. By making this generic we get the lot hashed for free.&n; */
DECL|function|sklist_remove_socket
r_void
id|sklist_remove_socket
c_func
(paren
r_struct
id|sock
op_star
op_star
id|list
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sock
op_star
id|s
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|s
op_assign
op_star
id|list
suffix:semicolon
r_if
c_cond
(paren
id|s
op_eq
id|sk
)paren
(brace
op_star
id|list
op_assign
id|s-&gt;next
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|s
op_logical_and
id|s-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;next
op_eq
id|sk
)paren
(brace
id|s-&gt;next
op_assign
id|sk-&gt;next
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|s
op_assign
id|s-&gt;next
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|sklist_insert_socket
r_void
id|sklist_insert_socket
c_func
(paren
r_struct
id|sock
op_star
op_star
id|list
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;next
op_assign
op_star
id|list
suffix:semicolon
op_star
id|list
op_assign
id|sk
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is only called from user mode. Thus it protects itself against&n; *&t;interrupt users but doesn&squot;t worry about being called during work.&n; *&t;Once it is removed from the queue no interrupt or bottom half will&n; *&t;touch it and we are (fairly 8-) ) safe.&n; */
r_void
id|sklist_destroy_socket
c_func
(paren
r_struct
id|sock
op_star
op_star
id|list
comma
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Handler for deferred kills.&n; */
DECL|function|sklist_destroy_timer
r_static
r_void
id|sklist_destroy_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
id|sklist_destroy_socket
c_func
(paren
l_int|NULL
comma
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Destroy a socket. We pass NULL for a list if we know the&n; *&t;socket is not on a list.&n; */
DECL|function|sklist_destroy_socket
r_void
id|sklist_destroy_socket
c_func
(paren
r_struct
id|sock
op_star
op_star
id|list
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|list
)paren
(brace
id|sklist_remove_socket
c_func
(paren
id|list
comma
id|sk
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
op_eq
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
op_eq
l_int|0
op_logical_and
id|sk-&gt;dead
)paren
(brace
id|sk_free
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; *&t;Someone is using our buffers still.. defer&n;&t;&t; */
id|init_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
id|sk-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|sysctl_core_destroy_delay
suffix:semicolon
id|sk-&gt;timer.function
op_assign
id|sklist_destroy_timer
suffix:semicolon
id|sk-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Set of default routines for initialising struct proto_ops when&n; * the protocol does not support a particular function. In certain&n; * cases where it makes no sense for a protocol to have a &quot;do nothing&quot;&n; * function, some default processing is provided.&n; */
DECL|function|sock_no_dup
r_int
id|sock_no_dup
c_func
(paren
r_struct
id|socket
op_star
id|newsock
comma
r_struct
id|socket
op_star
id|oldsock
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|oldsock-&gt;sk
suffix:semicolon
r_return
id|net_families
(braket
id|sk-&gt;family
)braket
op_member_access_from_pointer
id|create
c_func
(paren
id|newsock
comma
id|sk-&gt;protocol
)paren
suffix:semicolon
)brace
DECL|function|sock_no_release
r_int
id|sock_no_release
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|socket
op_star
id|peersock
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sock_no_bind
r_int
id|sock_no_bind
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|saddr
comma
r_int
id|len
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
DECL|function|sock_no_connect
r_int
id|sock_no_connect
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|saddr
comma
r_int
id|len
comma
r_int
id|flags
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
DECL|function|sock_no_socketpair
r_int
id|sock_no_socketpair
c_func
(paren
r_struct
id|socket
op_star
id|sock1
comma
r_struct
id|socket
op_star
id|sock2
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
DECL|function|sock_no_accept
r_int
id|sock_no_accept
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|socket
op_star
id|newsock
comma
r_int
id|flags
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
DECL|function|sock_no_getname
r_int
id|sock_no_getname
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|saddr
comma
r_int
op_star
id|len
comma
r_int
id|peer
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
DECL|function|sock_no_poll
r_int
r_int
id|sock_no_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|socket
op_star
id|sock
comma
id|poll_table
op_star
id|pt
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
DECL|function|sock_no_ioctl
r_int
id|sock_no_ioctl
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
DECL|function|sock_no_listen
r_int
id|sock_no_listen
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|backlog
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
DECL|function|sock_no_shutdown
r_int
id|sock_no_shutdown
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|how
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
DECL|function|sock_no_setsockopt
r_int
id|sock_no_setsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
DECL|function|sock_no_getsockopt
r_int
id|sock_no_getsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
DECL|function|sock_no_fcntl
r_int
id|sock_no_fcntl
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|F_SETOWN
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * This is a little restrictive, but it&squot;s the only&n;&t;&t;&t; * way to make sure that you can&squot;t send a sigurg to&n;&t;&t;&t; * another process.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|current-&gt;pgrp
op_ne
op_minus
id|arg
op_logical_and
id|current-&gt;pid
op_ne
id|arg
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|sk-&gt;proc
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|F_GETOWN
suffix:colon
r_return
id|sk-&gt;proc
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|sock_no_sendmsg
r_int
id|sock_no_sendmsg
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|msghdr
op_star
id|m
comma
r_int
id|flags
comma
r_struct
id|scm_cookie
op_star
id|scm
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
DECL|function|sock_no_recvmsg
r_int
id|sock_no_recvmsg
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|msghdr
op_star
id|m
comma
r_int
id|flags
comma
r_struct
id|scm_cookie
op_star
id|scm
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Default Socket Callbacks&n; */
DECL|function|sock_def_callback1
r_void
id|sock_def_callback1
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|wake_up_interruptible
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
)brace
DECL|function|sock_def_callback2
r_void
id|sock_def_callback2
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|wake_up_interruptible
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
id|sock_wake_async
c_func
(paren
id|sk-&gt;socket
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
DECL|function|sock_def_callback3
r_void
id|sock_def_callback3
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|wake_up_interruptible
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
id|sock_wake_async
c_func
(paren
id|sk-&gt;socket
comma
l_int|2
)paren
suffix:semicolon
)brace
)brace
DECL|function|sock_def_destruct
r_void
id|sock_def_destruct
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;protinfo.destruct_hook
)paren
id|kfree
c_func
(paren
id|sk-&gt;protinfo.destruct_hook
)paren
suffix:semicolon
)brace
DECL|function|sock_init_data
r_void
id|sock_init_data
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|skb_queue_head_init
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|sk-&gt;back_log
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|sk-&gt;error_queue
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
id|sk-&gt;allocation
op_assign
id|GFP_KERNEL
suffix:semicolon
id|sk-&gt;rcvbuf
op_assign
id|sysctl_rmem_default
suffix:semicolon
id|sk-&gt;sndbuf
op_assign
id|sysctl_wmem_default
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|sk-&gt;zapped
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;socket
op_assign
id|sock
suffix:semicolon
r_if
c_cond
(paren
id|sock
)paren
(brace
id|sk-&gt;type
op_assign
id|sock-&gt;type
suffix:semicolon
id|sk-&gt;sleep
op_assign
op_amp
id|sock-&gt;wait
suffix:semicolon
id|sock-&gt;sk
op_assign
id|sk
suffix:semicolon
)brace
id|sk-&gt;state_change
op_assign
id|sock_def_callback1
suffix:semicolon
id|sk-&gt;data_ready
op_assign
id|sock_def_callback2
suffix:semicolon
id|sk-&gt;write_space
op_assign
id|sock_def_callback3
suffix:semicolon
id|sk-&gt;error_report
op_assign
id|sock_def_callback1
suffix:semicolon
id|sk-&gt;destruct
op_assign
id|sock_def_destruct
suffix:semicolon
id|sk-&gt;peercred.pid
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;peercred.uid
op_assign
op_minus
l_int|1
suffix:semicolon
id|sk-&gt;peercred.gid
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
eof
