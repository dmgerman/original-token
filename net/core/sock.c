multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Generic socket support routines. Memory allocators, sk-&gt;inuse/release&n; *&t;&t;handler for protocols to use and generic option handler.&n; *&n; *&n; * Version:&t;@(#)sock.c&t;1.0.17&t;06/02/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Alan Cox, &lt;A.Cox@swansea.ac.uk&gt;&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;: &t;Numerous verify_area() problems&n; *&t;&t;Alan Cox&t;:&t;Connecting on a connecting socket&n; *&t;&t;&t;&t;&t;now returns an error for tcp.&n; *&t;&t;Alan Cox&t;:&t;sock-&gt;protocol is set correctly.&n; *&t;&t;&t;&t;&t;and is not sometimes left as 0.&n; *&t;&t;Alan Cox&t;:&t;connect handles icmp errors on a&n; *&t;&t;&t;&t;&t;connect properly. Unfortunately there&n; *&t;&t;&t;&t;&t;is a restart syscall nasty there. I&n; *&t;&t;&t;&t;&t;can&squot;t match BSD without hacking the C&n; *&t;&t;&t;&t;&t;library. Ideas urgently sought!&n; *&t;&t;Alan Cox&t;:&t;Disallow bind() to addresses that are&n; *&t;&t;&t;&t;&t;not ours - especially broadcast ones!!&n; *&t;&t;Alan Cox&t;:&t;Socket 1024 _IS_ ok for users. (fencepost)&n; *&t;&t;Alan Cox&t;:&t;sock_wfree/sock_rfree don&squot;t destroy sockets,&n; *&t;&t;&t;&t;&t;instead they leave that for the DESTROY timer.&n; *&t;&t;Alan Cox&t;:&t;Clean up error flag in accept&n; *&t;&t;Alan Cox&t;:&t;TCP ack handling is buggy, the DESTROY timer&n; *&t;&t;&t;&t;&t;was buggy. Put a remove_sock() in the handler&n; *&t;&t;&t;&t;&t;for memory when we hit 0. Also altered the timer&n; *&t;&t;&t;&t;&t;code. The ACK stuff can wait and needs major &n; *&t;&t;&t;&t;&t;TCP layer surgery.&n; *&t;&t;Alan Cox&t;:&t;Fixed TCP ack bug, removed remove sock&n; *&t;&t;&t;&t;&t;and fixed timer/inet_bh race.&n; *&t;&t;Alan Cox&t;:&t;Added zapped flag for TCP&n; *&t;&t;Alan Cox&t;:&t;Move kfree_skb into skbuff.c and tidied up surplus code&n; *&t;&t;Alan Cox&t;:&t;for new sk_buff allocations wmalloc/rmalloc now call alloc_skb&n; *&t;&t;Alan Cox&t;:&t;kfree_s calls now are kfree_skbmem so we can track skb resources&n; *&t;&t;Alan Cox&t;:&t;Supports socket option broadcast now as does udp. Packet and raw need fixing.&n; *&t;&t;Alan Cox&t;:&t;Added RCVBUF,SNDBUF size setting. It suddenly occurred to me how easy it was so...&n; *&t;&t;Rick Sladkey&t;:&t;Relaxed UDP rules for matching packets.&n; *&t;&t;C.E.Hawkins&t;:&t;IFF_PROMISC/SIOCGHWADDR support&n; *&t;Pauline Middelink&t;:&t;identd support&n; *&t;&t;Alan Cox&t;:&t;Fixed connect() taking signals I think.&n; *&t;&t;Alan Cox&t;:&t;SO_LINGER supported&n; *&t;&t;Alan Cox&t;:&t;Error reporting fixes&n; *&t;&t;Anonymous&t;:&t;inet_create tidied up (sk-&gt;reuse setting)&n; *&t;&t;Alan Cox&t;:&t;inet sockets don&squot;t set sk-&gt;type!&n; *&t;&t;Alan Cox&t;:&t;Split socket option code&n; *&t;&t;Alan Cox&t;:&t;Callbacks&n; *&t;&t;Alan Cox&t;:&t;Nagle flag for Charles &amp; Johannes stuff&n; *&t;&t;Alex&t;&t;:&t;Removed restriction on inet fioctl&n; *&t;&t;Alan Cox&t;:&t;Splitting INET from NET core&n; *&t;&t;Alan Cox&t;:&t;Fixed bogus SO_TYPE handling in getsockopt()&n; *&t;&t;Adam Caldwell&t;:&t;Missing return in SO_DONTROUTE/SO_DEBUG code&n; *&t;&t;Alan Cox&t;:&t;Split IP from generic code&n; *&t;&t;Alan Cox&t;:&t;New kfree_skbmem()&n; *&t;&t;Alan Cox&t;:&t;Make SO_DEBUG superuser only.&n; *&t;&t;Alan Cox&t;:&t;Allow anyone to clear SO_DEBUG&n; *&t;&t;&t;&t;&t;(compatibility fix)&n; *&t;&t;Alan Cox&t;:&t;Added optimistic memory grabbing for AF_UNIX throughput.&n; *&t;&t;Alan Cox&t;:&t;Allocator for a socket is settable.&n; *&t;&t;Alan Cox&t;:&t;SO_ERROR includes soft errors.&n; *&n; * To Fix:&n; *&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/protocol.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#include &lt;net/rarp.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/raw.h&gt;
macro_line|#include &lt;net/icmp.h&gt;
DECL|macro|min
mdefine_line|#define min(a,b)&t;((a)&lt;(b)?(a):(b))
multiline_comment|/*&n; *&t;This is meant for all protocols to use and covers goings on&n; *&t;at the socket level. Everything here is generic.&n; */
DECL|function|sock_setsockopt
r_int
id|sock_setsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_int
id|val
suffix:semicolon
r_int
id|valbool
suffix:semicolon
r_int
id|err
suffix:semicolon
r_struct
id|linger
id|ling
suffix:semicolon
r_if
c_cond
(paren
id|optval
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|optval
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|val
op_assign
id|get_user
c_func
(paren
(paren
r_int
op_star
)paren
id|optval
)paren
suffix:semicolon
id|valbool
op_assign
id|val
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|SO_DEBUG
suffix:colon
r_if
c_cond
(paren
id|val
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|sk-&gt;debug
op_assign
id|valbool
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SO_REUSEADDR
suffix:colon
id|sk-&gt;reuse
op_assign
id|valbool
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SO_TYPE
suffix:colon
r_case
id|SO_ERROR
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
r_case
id|SO_DONTROUTE
suffix:colon
id|sk-&gt;localroute
op_assign
id|valbool
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SO_BROADCAST
suffix:colon
id|sk-&gt;broadcast
op_assign
id|valbool
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SO_SNDBUF
suffix:colon
r_if
c_cond
(paren
id|val
OG
l_int|32767
)paren
(brace
id|val
op_assign
l_int|32767
suffix:semicolon
)brace
r_if
c_cond
(paren
id|val
OL
l_int|256
)paren
(brace
id|val
op_assign
l_int|256
suffix:semicolon
)brace
id|sk-&gt;sndbuf
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SO_RCVBUF
suffix:colon
r_if
c_cond
(paren
id|val
OG
l_int|32767
)paren
(brace
id|val
op_assign
l_int|32767
suffix:semicolon
)brace
r_if
c_cond
(paren
id|val
OL
l_int|256
)paren
(brace
id|val
op_assign
l_int|256
suffix:semicolon
)brace
id|sk-&gt;rcvbuf
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SO_KEEPALIVE
suffix:colon
id|sk-&gt;keepopen
op_assign
id|valbool
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SO_OOBINLINE
suffix:colon
id|sk-&gt;urginline
op_assign
id|valbool
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SO_NO_CHECK
suffix:colon
id|sk-&gt;no_check
op_assign
id|valbool
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SO_PRIORITY
suffix:colon
r_if
c_cond
(paren
id|val
op_ge
l_int|0
op_logical_and
id|val
OL
id|DEV_NUMBUFFS
)paren
(brace
id|sk-&gt;priority
op_assign
id|val
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SO_LINGER
suffix:colon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|optval
comma
r_sizeof
(paren
id|ling
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|ling
comma
id|optval
comma
r_sizeof
(paren
id|ling
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ling.l_onoff
op_eq
l_int|0
)paren
(brace
id|sk-&gt;linger
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;lingertime
op_assign
id|ling.l_linger
suffix:semicolon
id|sk-&gt;linger
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SO_BSDCOMPAT
suffix:colon
id|sk-&gt;bsdism
op_assign
id|valbool
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
)brace
)brace
DECL|function|sock_getsockopt
r_int
id|sock_getsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
r_int
id|val
suffix:semicolon
r_int
id|err
suffix:semicolon
r_struct
id|linger
id|ling
suffix:semicolon
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|SO_DEBUG
suffix:colon
id|val
op_assign
id|sk-&gt;debug
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_DONTROUTE
suffix:colon
id|val
op_assign
id|sk-&gt;localroute
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_BROADCAST
suffix:colon
id|val
op_assign
id|sk-&gt;broadcast
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_SNDBUF
suffix:colon
id|val
op_assign
id|sk-&gt;sndbuf
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_RCVBUF
suffix:colon
id|val
op_assign
id|sk-&gt;rcvbuf
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_REUSEADDR
suffix:colon
id|val
op_assign
id|sk-&gt;reuse
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_KEEPALIVE
suffix:colon
id|val
op_assign
id|sk-&gt;keepopen
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_TYPE
suffix:colon
id|val
op_assign
id|sk-&gt;type
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_ERROR
suffix:colon
id|val
op_assign
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_eq
l_int|0
)paren
(brace
id|val
op_assign
id|xchg
c_func
(paren
op_amp
id|sk-&gt;err_soft
comma
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SO_OOBINLINE
suffix:colon
id|val
op_assign
id|sk-&gt;urginline
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_NO_CHECK
suffix:colon
id|val
op_assign
id|sk-&gt;no_check
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_PRIORITY
suffix:colon
id|val
op_assign
id|sk-&gt;priority
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_LINGER
suffix:colon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|optval
comma
r_sizeof
(paren
id|ling
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|optlen
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_fs_long
c_func
(paren
r_sizeof
(paren
id|ling
)paren
comma
(paren
r_int
r_int
op_star
)paren
id|optlen
)paren
suffix:semicolon
id|ling.l_onoff
op_assign
id|sk-&gt;linger
suffix:semicolon
id|ling.l_linger
op_assign
id|sk-&gt;lingertime
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|optval
comma
op_amp
id|ling
comma
r_sizeof
(paren
id|ling
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SO_BSDCOMPAT
suffix:colon
id|val
op_assign
id|sk-&gt;bsdism
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
)brace
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|optlen
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_fs_long
c_func
(paren
r_sizeof
(paren
r_int
)paren
comma
(paren
r_int
r_int
op_star
)paren
id|optlen
)paren
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|optval
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_fs_long
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|optval
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sock_wmalloc
r_struct
id|sk_buff
op_star
id|sock_wmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
id|force
comma
r_int
id|priority
)paren
(brace
r_if
c_cond
(paren
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;wmem_alloc
op_plus
id|size
OL
id|sk-&gt;sndbuf
op_logical_or
id|force
)paren
(brace
r_struct
id|sk_buff
op_star
id|c
op_assign
id|alloc_skb
c_func
(paren
id|size
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;wmem_alloc
op_add_assign
id|c-&gt;truesize
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* was sti(); */
)brace
r_return
id|c
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|alloc_skb
c_func
(paren
id|size
comma
id|priority
)paren
suffix:semicolon
)brace
DECL|function|sock_rmalloc
r_struct
id|sk_buff
op_star
id|sock_rmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
id|force
comma
r_int
id|priority
)paren
(brace
r_if
c_cond
(paren
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;rmem_alloc
op_plus
id|size
OL
id|sk-&gt;rcvbuf
op_logical_or
id|force
)paren
(brace
r_struct
id|sk_buff
op_star
id|c
op_assign
id|alloc_skb
c_func
(paren
id|size
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;rmem_alloc
op_add_assign
id|c-&gt;truesize
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* was sti(); */
)brace
r_return
id|c
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|alloc_skb
c_func
(paren
id|size
comma
id|priority
)paren
suffix:semicolon
)brace
DECL|function|sock_rspace
r_int
r_int
id|sock_rspace
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|amt
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;rmem_alloc
op_ge
id|sk-&gt;rcvbuf
op_minus
l_int|2
op_star
id|MIN_WINDOW
)paren
r_return
l_int|0
suffix:semicolon
id|amt
op_assign
id|min
c_func
(paren
(paren
id|sk-&gt;rcvbuf
op_minus
id|sk-&gt;rmem_alloc
)paren
op_div
l_int|2
op_minus
id|MIN_WINDOW
comma
id|MAX_WINDOW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amt
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|amt
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sock_wspace
r_int
r_int
id|sock_wspace
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;wmem_alloc
op_ge
id|sk-&gt;sndbuf
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|sk-&gt;sndbuf
op_minus
id|sk-&gt;wmem_alloc
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sock_wfree
r_void
id|sock_wfree
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|s
op_assign
id|skb-&gt;truesize
suffix:semicolon
macro_line|#if CONFIG_SKB_CHECK
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif
id|kfree_skbmem
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;wmem_alloc
op_sub_assign
id|s
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* In case it might be waiting for more memory. */
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
DECL|function|sock_rfree
r_void
id|sock_rfree
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|s
op_assign
id|skb-&gt;truesize
suffix:semicolon
macro_line|#if CONFIG_SKB_CHECK
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif&t;
id|kfree_skbmem
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;rmem_alloc
op_sub_assign
id|s
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Generic send/receive buffer handlers&n; */
DECL|function|sock_alloc_send_skb
r_struct
id|sk_buff
op_star
id|sock_alloc_send_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
r_int
id|fallback
comma
r_int
id|noblock
comma
r_int
op_star
id|errcode
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|err
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|sk-&gt;err
op_ne
l_int|0
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|sk-&gt;err
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
op_star
id|errcode
op_assign
id|err
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
(brace
op_star
id|errcode
op_assign
op_minus
id|EPIPE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|fallback
)paren
(brace
id|skb
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|size
comma
l_int|0
comma
id|sk-&gt;allocation
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The buffer get won&squot;t block, or use the atomic queue. It does&n;&t;&t;&t;   produce annoying no free page messages still.... */
id|skb
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|size
comma
l_int|0
comma
id|GFP_BUFFER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|skb
op_assign
id|sock_wmalloc
c_func
(paren
id|sk
comma
id|fallback
comma
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; *&t;This means we have too many buffers for this socket already.&n;&t;&t; */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|sk-&gt;socket-&gt;flags
op_or_assign
id|SO_NOSPACE
suffix:semicolon
r_if
c_cond
(paren
id|noblock
)paren
(brace
op_star
id|errcode
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
(brace
op_star
id|errcode
op_assign
op_minus
id|EPIPE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|tmp
op_assign
id|sk-&gt;wmem_alloc
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
op_star
id|errcode
op_assign
op_minus
id|EPIPE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#if 1
r_if
c_cond
(paren
id|tmp
op_le
id|sk-&gt;wmem_alloc
)paren
macro_line|#else
multiline_comment|/* ANK: Line above seems either incorrect&n;&t;&t;&t; *&t;or useless. sk-&gt;wmem_alloc has a tiny chance to change&n;&t;&t;&t; *&t;between tmp = sk-&gt;w... and cli(),&n;&t;&t;&t; *&t;but it might(?) change earlier. In real life&n;&t;&t;&t; *&t;it does not (I never seen the message).&n;&t;&t;&t; *&t;In any case I&squot;d delete this check at all, or&n;&t;&t;&t; *&t;change it to:&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;wmem_alloc
op_plus
id|size
op_ge
id|sk-&gt;sndbuf
)paren
macro_line|#endif
(brace
r_if
c_cond
(paren
id|sk-&gt;wmem_alloc
op_le
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;sock.c: Look where I am %ld&lt;%ld&bslash;n&quot;
comma
id|tmp
comma
id|sk-&gt;wmem_alloc
)paren
suffix:semicolon
id|sk-&gt;socket-&gt;flags
op_and_assign
op_complement
id|SO_NOSPACE
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
op_star
id|errcode
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
suffix:semicolon
)brace
r_return
id|skb
suffix:semicolon
)brace
DECL|function|release_sock
r_void
id|release_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef CONFIG_INET
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;prot
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Make the backlog atomic. If we don&squot;t do this there is a tiny&n;&t; *&t;window where a packet may arrive between the sk-&gt;blog being &n;&t; *&t;tested and then set with sk-&gt;inuse still 0 causing an extra &n;&t; *&t;unwanted re-entry into release_sock().&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;blog
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sk-&gt;blog
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_INET
multiline_comment|/* See if we have any packets built up. */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;back_log
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|sk-&gt;blog
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;prot-&gt;rcv
)paren
id|sk-&gt;prot
op_member_access_from_pointer
id|rcv
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
(paren
r_struct
id|options
op_star
)paren
id|skb-&gt;proto_priv
comma
id|skb-&gt;saddr
comma
id|skb-&gt;len
comma
id|skb-&gt;daddr
comma
l_int|1
comma
multiline_comment|/* Only used for/by raw sockets. */
(paren
r_struct
id|inet_protocol
op_star
)paren
id|sk-&gt;pair
)paren
suffix:semicolon
)brace
macro_line|#endif  
id|sk-&gt;blog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_INET  
r_if
c_cond
(paren
id|sk-&gt;dead
op_logical_and
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
(brace
multiline_comment|/* Should be about 2 rtt&squot;s */
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_DONE
comma
id|min
c_func
(paren
id|sk-&gt;rtt
op_star
l_int|2
comma
id|TCP_DONE_TIME
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif  
)brace
eof
