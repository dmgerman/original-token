multiline_comment|/*&n; *&t;This code is derived from the avl functions in mmap.c&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;net/br.h&gt;
DECL|macro|_DEBUG_AVL
mdefine_line|#define _DEBUG_AVL
multiline_comment|/*&n; * Use an AVL (Adelson-Velskii and Landis) tree to speed up this search&n; * from O(n) to O(log n), where n is the number of ULAs.&n; * Written by Bruno Haible &lt;haible@ma2s2.mathematik.uni-karlsruhe.de&gt;.&n; * Taken from mmap.c, extensively modified by John Hayes &n; * &lt;hayes@netplumbing.com&gt;&n; * 98-02 Modified by Jean-Rene Peulve jr.peulve@aix.pacwan.net&n; *&t;&t;update port number when topology change&n; *&t;&t;return oldfdb when updating, for broadcast storm checking&n; *&t;&t;call addr_cmp once per node&n; */
DECL|variable|fdb_head
r_static
r_struct
id|fdb
id|fdb_head
suffix:semicolon
DECL|variable|fhp
r_static
r_struct
id|fdb
op_star
id|fhp
op_assign
op_amp
id|fdb_head
suffix:semicolon
DECL|variable|fhpp
r_static
r_struct
id|fdb
op_star
op_star
id|fhpp
op_assign
op_amp
id|fhp
suffix:semicolon
DECL|variable|fdb_inited
r_static
r_int
id|fdb_inited
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_AVL
r_static
r_void
id|printk_avl
(paren
r_struct
id|fdb
op_star
id|tree
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|addr_cmp
c_func
(paren
r_int
r_char
op_star
id|a1
comma
r_int
r_char
op_star
id|a2
)paren
suffix:semicolon
multiline_comment|/*&n; * fdb_head is the AVL tree corresponding to fdb&n; * or, more exactly, its root.&n; * A fdb has the following fields:&n; *   fdb_avl_left     left son of a tree node&n; *   fdb_avl_right    right son of a tree node&n; *   fdb_avl_height   1+max(heightof(left),heightof(right))&n; * The empty tree is represented as NULL.&n; */
macro_line|#ifndef avl_br_empty
DECL|macro|avl_br_empty
mdefine_line|#define avl_br_empty&t;(struct fdb *) NULL
macro_line|#endif
multiline_comment|/* Since the trees are balanced, their height will never be large. */
DECL|macro|avl_maxheight
mdefine_line|#define avl_maxheight&t;127
DECL|macro|heightof
mdefine_line|#define heightof(tree)&t;((tree) == avl_br_empty ? 0 : (tree)-&gt;fdb_avl_height)
multiline_comment|/*&n; * Consistency and balancing rules:&n; * 1. tree-&gt;fdb_avl_height == 1+max(heightof(tree-&gt;fdb_avl_left),heightof(tree-&gt;fdb_avl_right))&n; * 2. abs( heightof(tree-&gt;fdb_avl_left) - heightof(tree-&gt;fdb_avl_right) ) &lt;= 1&n; * 3. foreach node in tree-&gt;fdb_avl_left: node-&gt;fdb_avl_key &lt;= tree-&gt;fdb_avl_key,&n; *    foreach node in tree-&gt;fdb_avl_right: node-&gt;fdb_avl_key &gt;= tree-&gt;fdb_avl_key.&n; */
DECL|function|fdb_init
r_static
r_int
id|fdb_init
c_func
(paren
r_void
)paren
(brace
id|fdb_head.fdb_avl_height
op_assign
l_int|0
suffix:semicolon
id|fdb_head.fdb_avl_left
op_assign
(paren
r_struct
id|fdb
op_star
)paren
l_int|0
suffix:semicolon
id|fdb_head.fdb_avl_right
op_assign
(paren
r_struct
id|fdb
op_star
)paren
l_int|0
suffix:semicolon
id|fdb_inited
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|br_avl_find_addr
r_struct
id|fdb
op_star
id|br_avl_find_addr
c_func
(paren
r_int
r_char
id|addr
(braket
l_int|6
)braket
)paren
(brace
r_struct
id|fdb
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|fdb
op_star
id|tree
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fdb_inited
)paren
id|fdb_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (DEBUG_AVL)
id|printk
c_func
(paren
l_string|&quot;searching for ula %02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
id|addr
(braket
l_int|0
)braket
comma
id|addr
(braket
l_int|1
)braket
comma
id|addr
(braket
l_int|2
)braket
comma
id|addr
(braket
l_int|3
)braket
comma
id|addr
(braket
l_int|4
)braket
comma
id|addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_AVL */
r_for
c_loop
(paren
id|tree
op_assign
id|fhp
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|tree
op_eq
id|avl_br_empty
)paren
(brace
macro_line|#if (DEBUG_AVL)
id|printk
c_func
(paren
l_string|&quot;search failed, returning node 0x%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|result
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_AVL */
r_return
id|result
suffix:semicolon
)brace
macro_line|#if (DEBUG_AVL)
id|printk
c_func
(paren
l_string|&quot;node 0x%x: checking ula %02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|tree
comma
id|tree-&gt;ula
(braket
l_int|0
)braket
comma
id|tree-&gt;ula
(braket
l_int|1
)braket
comma
id|tree-&gt;ula
(braket
l_int|2
)braket
comma
id|tree-&gt;ula
(braket
l_int|3
)braket
comma
id|tree-&gt;ula
(braket
l_int|4
)braket
comma
id|tree-&gt;ula
(braket
l_int|5
)braket
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_AVL */
r_if
c_cond
(paren
id|addr_cmp
c_func
(paren
id|addr
comma
id|tree-&gt;ula
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#if (DEBUG_AVL)
id|printk
c_func
(paren
l_string|&quot;found node 0x%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|tree
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_AVL */
r_return
id|tree
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr_cmp
c_func
(paren
id|addr
comma
id|tree-&gt;ula
)paren
OL
l_int|0
)paren
(brace
id|tree
op_assign
id|tree-&gt;fdb_avl_left
suffix:semicolon
)brace
r_else
(brace
id|tree
op_assign
id|tree-&gt;fdb_avl_right
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Rebalance a tree.&n; * After inserting or deleting a node of a tree we have a sequence of subtrees&n; * nodes[0]..nodes[k-1] such that&n; * nodes[0] is the root and nodes[i+1] = nodes[i]-&gt;{fdb_avl_left|fdb_avl_right}.&n; */
DECL|function|br_avl_rebalance
r_static
r_void
id|br_avl_rebalance
(paren
r_struct
id|fdb
op_star
op_star
op_star
id|nodeplaces_ptr
comma
r_int
id|count
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fdb_inited
)paren
id|fdb_init
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|count
OG
l_int|0
suffix:semicolon
id|count
op_decrement
)paren
(brace
r_struct
id|fdb
op_star
op_star
id|nodeplace
op_assign
op_star
op_decrement
id|nodeplaces_ptr
suffix:semicolon
r_struct
id|fdb
op_star
id|node
op_assign
op_star
id|nodeplace
suffix:semicolon
r_struct
id|fdb
op_star
id|nodeleft
op_assign
id|node-&gt;fdb_avl_left
suffix:semicolon
r_struct
id|fdb
op_star
id|noderight
op_assign
id|node-&gt;fdb_avl_right
suffix:semicolon
r_int
id|heightleft
op_assign
id|heightof
c_func
(paren
id|nodeleft
)paren
suffix:semicolon
r_int
id|heightright
op_assign
id|heightof
c_func
(paren
id|noderight
)paren
suffix:semicolon
r_if
c_cond
(paren
id|heightright
op_plus
l_int|1
OL
id|heightleft
)paren
(brace
multiline_comment|/*                                                      */
multiline_comment|/*                            *                         */
multiline_comment|/*                          /   &bslash;                       */
multiline_comment|/*                       n+2      n                     */
multiline_comment|/*                                                      */
r_struct
id|fdb
op_star
id|nodeleftleft
op_assign
id|nodeleft-&gt;fdb_avl_left
suffix:semicolon
r_struct
id|fdb
op_star
id|nodeleftright
op_assign
id|nodeleft-&gt;fdb_avl_right
suffix:semicolon
r_int
id|heightleftright
op_assign
id|heightof
c_func
(paren
id|nodeleftright
)paren
suffix:semicolon
r_if
c_cond
(paren
id|heightof
c_func
(paren
id|nodeleftleft
)paren
op_ge
id|heightleftright
)paren
(brace
multiline_comment|/*                                                        */
multiline_comment|/*                *                    n+2|n+3            */
multiline_comment|/*              /   &bslash;                  /    &bslash;             */
multiline_comment|/*           n+2      n      --&gt;      /   n+1|n+2         */
multiline_comment|/*           / &bslash;                      |    /    &bslash;         */
multiline_comment|/*         n+1 n|n+1                 n+1  n|n+1  n        */
multiline_comment|/*                                                        */
id|node-&gt;fdb_avl_left
op_assign
id|nodeleftright
suffix:semicolon
id|nodeleft-&gt;fdb_avl_right
op_assign
id|node
suffix:semicolon
id|nodeleft-&gt;fdb_avl_height
op_assign
l_int|1
op_plus
(paren
id|node-&gt;fdb_avl_height
op_assign
l_int|1
op_plus
id|heightleftright
)paren
suffix:semicolon
op_star
id|nodeplace
op_assign
id|nodeleft
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*                                                        */
multiline_comment|/*                *                     n+2               */
multiline_comment|/*              /   &bslash;                 /     &bslash;             */
multiline_comment|/*           n+2      n      --&gt;    n+1     n+1           */
multiline_comment|/*           / &bslash;                    / &bslash;     / &bslash;           */
multiline_comment|/*          n  n+1                 n   L   R   n          */
multiline_comment|/*             / &bslash;                                        */
multiline_comment|/*            L   R                                       */
multiline_comment|/*                                                        */
id|nodeleft-&gt;fdb_avl_right
op_assign
id|nodeleftright-&gt;fdb_avl_left
suffix:semicolon
id|node-&gt;fdb_avl_left
op_assign
id|nodeleftright-&gt;fdb_avl_right
suffix:semicolon
id|nodeleftright-&gt;fdb_avl_left
op_assign
id|nodeleft
suffix:semicolon
id|nodeleftright-&gt;fdb_avl_right
op_assign
id|node
suffix:semicolon
id|nodeleft-&gt;fdb_avl_height
op_assign
id|node-&gt;fdb_avl_height
op_assign
id|heightleftright
suffix:semicolon
id|nodeleftright-&gt;fdb_avl_height
op_assign
id|heightleft
suffix:semicolon
op_star
id|nodeplace
op_assign
id|nodeleftright
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|heightleft
op_plus
l_int|1
OL
id|heightright
)paren
(brace
multiline_comment|/* similar to the above, just interchange &squot;left&squot; &lt;--&gt; &squot;right&squot; */
r_struct
id|fdb
op_star
id|noderightright
op_assign
id|noderight-&gt;fdb_avl_right
suffix:semicolon
r_struct
id|fdb
op_star
id|noderightleft
op_assign
id|noderight-&gt;fdb_avl_left
suffix:semicolon
r_int
id|heightrightleft
op_assign
id|heightof
c_func
(paren
id|noderightleft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|heightof
c_func
(paren
id|noderightright
)paren
op_ge
id|heightrightleft
)paren
(brace
id|node-&gt;fdb_avl_right
op_assign
id|noderightleft
suffix:semicolon
id|noderight-&gt;fdb_avl_left
op_assign
id|node
suffix:semicolon
id|noderight-&gt;fdb_avl_height
op_assign
l_int|1
op_plus
(paren
id|node-&gt;fdb_avl_height
op_assign
l_int|1
op_plus
id|heightrightleft
)paren
suffix:semicolon
op_star
id|nodeplace
op_assign
id|noderight
suffix:semicolon
)brace
r_else
(brace
id|noderight-&gt;fdb_avl_left
op_assign
id|noderightleft-&gt;fdb_avl_right
suffix:semicolon
id|node-&gt;fdb_avl_right
op_assign
id|noderightleft-&gt;fdb_avl_left
suffix:semicolon
id|noderightleft-&gt;fdb_avl_right
op_assign
id|noderight
suffix:semicolon
id|noderightleft-&gt;fdb_avl_left
op_assign
id|node
suffix:semicolon
id|noderight-&gt;fdb_avl_height
op_assign
id|node-&gt;fdb_avl_height
op_assign
id|heightrightleft
suffix:semicolon
id|noderightleft-&gt;fdb_avl_height
op_assign
id|heightright
suffix:semicolon
op_star
id|nodeplace
op_assign
id|noderightleft
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|height
op_assign
(paren
id|heightleft
OL
id|heightright
ques
c_cond
id|heightright
suffix:colon
id|heightleft
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|height
op_eq
id|node-&gt;fdb_avl_height
)paren
r_break
suffix:semicolon
id|node-&gt;fdb_avl_height
op_assign
id|height
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG_AVL
id|printk_avl
c_func
(paren
op_amp
id|fdb_head
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_AVL */
)brace
multiline_comment|/* Insert a node into a tree.&n; * Performance improvement:&n; *&t; call addr_cmp() only once per node and use result in a switch.&n; * Return old node address if we knew that MAC address already&n; * Return NULL if we insert the new node&n; */
DECL|function|br_avl_insert
r_struct
id|fdb
op_star
id|br_avl_insert
(paren
r_struct
id|fdb
op_star
id|new_node
)paren
(brace
r_struct
id|fdb
op_star
op_star
id|nodeplace
op_assign
id|fhpp
suffix:semicolon
r_struct
id|fdb
op_star
op_star
id|stack
(braket
id|avl_maxheight
)braket
suffix:semicolon
r_int
id|stack_count
op_assign
l_int|0
suffix:semicolon
r_struct
id|fdb
op_star
op_star
op_star
id|stack_ptr
op_assign
op_amp
id|stack
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* = &amp;stack[stackcount] */
r_if
c_cond
(paren
op_logical_neg
id|fdb_inited
)paren
id|fdb_init
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|fdb
op_star
id|node
suffix:semicolon
id|node
op_assign
op_star
id|nodeplace
suffix:semicolon
r_if
c_cond
(paren
id|node
op_eq
id|avl_br_empty
)paren
r_break
suffix:semicolon
op_star
id|stack_ptr
op_increment
op_assign
id|nodeplace
suffix:semicolon
id|stack_count
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|addr_cmp
c_func
(paren
id|new_node-&gt;ula
comma
id|node-&gt;ula
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* update */
r_if
c_cond
(paren
id|node-&gt;port
op_eq
id|new_node-&gt;port
)paren
(brace
id|node-&gt;flags
op_assign
id|new_node-&gt;flags
suffix:semicolon
id|node-&gt;timer
op_assign
id|new_node-&gt;timer
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|node-&gt;flags
op_amp
id|FDB_ENT_VALID
)paren
op_logical_and
id|node-&gt;port
)paren
(brace
multiline_comment|/* update fdb but never for local interfaces */
macro_line|#if (DEBUG_AVL)
id|printk
c_func
(paren
l_string|&quot;node 0x%x:port changed old=%d new=%d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|node
comma
id|node-&gt;port
comma
id|new_node-&gt;port
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* JRP: update port as well if the topology change !&n;&t;&t;&t; * Don&squot;t do this while entry is still valid otherwise&n;&t;&t;&t; * a broadcast that we flooded and is reentered by another&n;&t;&t;&t; * port would mess up the good port number.&n;&t;&t;&t; * The fdb list per port needs to be updated as well.&n;&t;&t;&t; */
id|requeue_fdb
c_func
(paren
id|node
comma
id|new_node-&gt;port
)paren
suffix:semicolon
id|node-&gt;flags
op_assign
id|new_node-&gt;flags
suffix:semicolon
id|node-&gt;timer
op_assign
id|new_node-&gt;timer
suffix:semicolon
macro_line|#if (DEBUG_AVL)
id|printk_avl
c_func
(paren
op_amp
id|fdb_head
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_AVL */
)brace
r_return
id|node
suffix:semicolon
multiline_comment|/* pass old fdb to caller */
r_case
l_int|1
suffix:colon
multiline_comment|/* new_node-&gt;ula &gt; node-&gt;ula */
id|nodeplace
op_assign
op_amp
id|node-&gt;fdb_avl_right
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* -1 =&gt; new_node-&gt;ula &lt; node-&gt;ula */
id|nodeplace
op_assign
op_amp
id|node-&gt;fdb_avl_left
suffix:semicolon
)brace
)brace
macro_line|#if (DEBUG_AVL)
id|printk
c_func
(paren
l_string|&quot;node 0x%x: adding ula %02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|new_node
comma
id|new_node-&gt;ula
(braket
l_int|0
)braket
comma
id|new_node-&gt;ula
(braket
l_int|1
)braket
comma
id|new_node-&gt;ula
(braket
l_int|2
)braket
comma
id|new_node-&gt;ula
(braket
l_int|3
)braket
comma
id|new_node-&gt;ula
(braket
l_int|4
)braket
comma
id|new_node-&gt;ula
(braket
l_int|5
)braket
)paren
suffix:semicolon
macro_line|#endif /* (DEBUG_AVL) */
id|new_node-&gt;fdb_avl_left
op_assign
id|avl_br_empty
suffix:semicolon
id|new_node-&gt;fdb_avl_right
op_assign
id|avl_br_empty
suffix:semicolon
id|new_node-&gt;fdb_avl_height
op_assign
l_int|1
suffix:semicolon
op_star
id|nodeplace
op_assign
id|new_node
suffix:semicolon
id|br_avl_rebalance
c_func
(paren
id|stack_ptr
comma
id|stack_count
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_AVL
id|printk_avl
c_func
(paren
op_amp
id|fdb_head
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_AVL */
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* this is a new node */
)brace
multiline_comment|/* Removes a node out of a tree. */
DECL|function|br_avl_remove
r_static
r_int
id|br_avl_remove
(paren
r_struct
id|fdb
op_star
id|node_to_delete
)paren
(brace
r_struct
id|fdb
op_star
op_star
id|nodeplace
op_assign
id|fhpp
suffix:semicolon
r_struct
id|fdb
op_star
op_star
id|stack
(braket
id|avl_maxheight
)braket
suffix:semicolon
r_int
id|stack_count
op_assign
l_int|0
suffix:semicolon
r_struct
id|fdb
op_star
op_star
op_star
id|stack_ptr
op_assign
op_amp
id|stack
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* = &amp;stack[stackcount] */
r_struct
id|fdb
op_star
op_star
id|nodeplace_to_delete
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fdb_inited
)paren
id|fdb_init
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|fdb
op_star
id|node
op_assign
op_star
id|nodeplace
suffix:semicolon
r_if
c_cond
(paren
id|node
op_eq
id|avl_br_empty
)paren
(brace
multiline_comment|/* what? node_to_delete not found in tree? */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;br: avl_remove: node to delete not found in tree&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
op_star
id|stack_ptr
op_increment
op_assign
id|nodeplace
suffix:semicolon
id|stack_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|addr_cmp
c_func
(paren
id|node_to_delete-&gt;ula
comma
id|node-&gt;ula
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|addr_cmp
c_func
(paren
id|node_to_delete-&gt;ula
comma
id|node-&gt;ula
)paren
OL
l_int|0
)paren
id|nodeplace
op_assign
op_amp
id|node-&gt;fdb_avl_left
suffix:semicolon
r_else
id|nodeplace
op_assign
op_amp
id|node-&gt;fdb_avl_right
suffix:semicolon
)brace
id|nodeplace_to_delete
op_assign
id|nodeplace
suffix:semicolon
multiline_comment|/* Have to remove node_to_delete = *nodeplace_to_delete. */
r_if
c_cond
(paren
id|node_to_delete-&gt;fdb_avl_left
op_eq
id|avl_br_empty
)paren
(brace
op_star
id|nodeplace_to_delete
op_assign
id|node_to_delete-&gt;fdb_avl_right
suffix:semicolon
id|stack_ptr
op_decrement
suffix:semicolon
id|stack_count
op_decrement
suffix:semicolon
)brace
r_else
(brace
r_struct
id|fdb
op_star
op_star
op_star
id|stack_ptr_to_delete
op_assign
id|stack_ptr
suffix:semicolon
r_struct
id|fdb
op_star
op_star
id|nodeplace
op_assign
op_amp
id|node_to_delete-&gt;fdb_avl_left
suffix:semicolon
r_struct
id|fdb
op_star
id|node
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|node
op_assign
op_star
id|nodeplace
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;fdb_avl_right
op_eq
id|avl_br_empty
)paren
r_break
suffix:semicolon
op_star
id|stack_ptr
op_increment
op_assign
id|nodeplace
suffix:semicolon
id|stack_count
op_increment
suffix:semicolon
id|nodeplace
op_assign
op_amp
id|node-&gt;fdb_avl_right
suffix:semicolon
)brace
op_star
id|nodeplace
op_assign
id|node-&gt;fdb_avl_left
suffix:semicolon
multiline_comment|/* node replaces node_to_delete */
id|node-&gt;fdb_avl_left
op_assign
id|node_to_delete-&gt;fdb_avl_left
suffix:semicolon
id|node-&gt;fdb_avl_right
op_assign
id|node_to_delete-&gt;fdb_avl_right
suffix:semicolon
id|node-&gt;fdb_avl_height
op_assign
id|node_to_delete-&gt;fdb_avl_height
suffix:semicolon
op_star
id|nodeplace_to_delete
op_assign
id|node
suffix:semicolon
multiline_comment|/* replace node_to_delete */
op_star
id|stack_ptr_to_delete
op_assign
op_amp
id|node-&gt;fdb_avl_left
suffix:semicolon
multiline_comment|/* replace &amp;node_to_delete-&gt;fdb_avl_left */
)brace
id|br_avl_rebalance
c_func
(paren
id|stack_ptr
comma
id|stack_count
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_AVL
multiline_comment|/* print a tree */
DECL|function|printk_avl
r_static
r_void
id|printk_avl
(paren
r_struct
id|fdb
op_star
id|tree
)paren
(brace
r_if
c_cond
(paren
id|tree
op_ne
id|avl_br_empty
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02x:%02x:%02x:%02x:%02x:%02x(%d)&quot;
comma
id|tree-&gt;ula
(braket
l_int|0
)braket
comma
id|tree-&gt;ula
(braket
l_int|1
)braket
comma
id|tree-&gt;ula
(braket
l_int|2
)braket
comma
id|tree-&gt;ula
(braket
l_int|3
)braket
comma
id|tree-&gt;ula
(braket
l_int|4
)braket
comma
id|tree-&gt;ula
(braket
l_int|5
)braket
comma
id|tree-&gt;port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;fdb_avl_left
op_ne
id|avl_br_empty
)paren
(brace
id|printk_avl
c_func
(paren
id|tree-&gt;fdb_avl_left
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&lt;&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tree-&gt;fdb_avl_right
op_ne
id|avl_br_empty
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
id|printk_avl
c_func
(paren
id|tree-&gt;fdb_avl_right
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;)&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|variable|avl_check_point
r_static
r_char
op_star
id|avl_check_point
op_assign
l_string|&quot;somewhere&quot;
suffix:semicolon
multiline_comment|/* check a tree&squot;s consistency and balancing */
DECL|function|avl_checkheights
r_static
r_void
id|avl_checkheights
(paren
r_struct
id|fdb
op_star
id|tree
)paren
(brace
r_int
id|h
comma
id|hl
comma
id|hr
suffix:semicolon
r_if
c_cond
(paren
id|tree
op_eq
id|avl_br_empty
)paren
r_return
suffix:semicolon
id|avl_checkheights
c_func
(paren
id|tree-&gt;fdb_avl_left
)paren
suffix:semicolon
id|avl_checkheights
c_func
(paren
id|tree-&gt;fdb_avl_right
)paren
suffix:semicolon
id|h
op_assign
id|tree-&gt;fdb_avl_height
suffix:semicolon
id|hl
op_assign
id|heightof
c_func
(paren
id|tree-&gt;fdb_avl_left
)paren
suffix:semicolon
id|hr
op_assign
id|heightof
c_func
(paren
id|tree-&gt;fdb_avl_right
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|h
op_eq
id|hl
op_plus
l_int|1
)paren
op_logical_and
(paren
id|hr
op_le
id|hl
)paren
op_logical_and
(paren
id|hl
op_le
id|hr
op_plus
l_int|1
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|h
op_eq
id|hr
op_plus
l_int|1
)paren
op_logical_and
(paren
id|hl
op_le
id|hr
)paren
op_logical_and
(paren
id|hr
op_le
id|hl
op_plus
l_int|1
)paren
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: avl_checkheights: heights inconsistent&bslash;n&quot;
comma
id|avl_check_point
)paren
suffix:semicolon
)brace
multiline_comment|/* check that all values stored in a tree are &lt; key */
DECL|function|avl_checkleft
r_static
r_void
id|avl_checkleft
(paren
r_struct
id|fdb
op_star
id|tree
comma
id|fdb_avl_key_t
id|key
)paren
(brace
r_if
c_cond
(paren
id|tree
op_eq
id|avl_br_empty
)paren
r_return
suffix:semicolon
id|avl_checkleft
c_func
(paren
id|tree-&gt;fdb_avl_left
comma
id|key
)paren
suffix:semicolon
id|avl_checkleft
c_func
(paren
id|tree-&gt;fdb_avl_right
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;fdb_avl_key
OL
id|key
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: avl_checkleft: left key %lu &gt;= top key %lu&bslash;n&quot;
comma
id|avl_check_point
comma
id|tree-&gt;fdb_avl_key
comma
id|key
)paren
suffix:semicolon
)brace
multiline_comment|/* check that all values stored in a tree are &gt; key */
DECL|function|avl_checkright
r_static
r_void
id|avl_checkright
(paren
r_struct
id|fdb
op_star
id|tree
comma
id|fdb_avl_key_t
id|key
)paren
(brace
r_if
c_cond
(paren
id|tree
op_eq
id|avl_br_empty
)paren
r_return
suffix:semicolon
id|avl_checkright
c_func
(paren
id|tree-&gt;fdb_avl_left
comma
id|key
)paren
suffix:semicolon
id|avl_checkright
c_func
(paren
id|tree-&gt;fdb_avl_right
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;fdb_avl_key
OG
id|key
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: avl_checkright: right key %lu &lt;= top key %lu&bslash;n&quot;
comma
id|avl_check_point
comma
id|tree-&gt;fdb_avl_key
comma
id|key
)paren
suffix:semicolon
)brace
multiline_comment|/* check that all values are properly increasing */
DECL|function|avl_checkorder
r_static
r_void
id|avl_checkorder
(paren
r_struct
id|fdb
op_star
id|tree
)paren
(brace
r_if
c_cond
(paren
id|tree
op_eq
id|avl_br_empty
)paren
r_return
suffix:semicolon
id|avl_checkorder
c_func
(paren
id|tree-&gt;fdb_avl_left
)paren
suffix:semicolon
id|avl_checkorder
c_func
(paren
id|tree-&gt;fdb_avl_right
)paren
suffix:semicolon
id|avl_checkleft
c_func
(paren
id|tree-&gt;fdb_avl_left
comma
id|tree-&gt;fdb_avl_key
)paren
suffix:semicolon
id|avl_checkright
c_func
(paren
id|tree-&gt;fdb_avl_right
comma
id|tree-&gt;fdb_avl_key
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG_AVL */
DECL|function|addr_cmp
r_static
r_int
id|addr_cmp
c_func
(paren
r_int
r_char
id|a1
(braket
)braket
comma
r_int
r_char
id|a2
(braket
)braket
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|a1
(braket
id|i
)braket
OG
id|a2
(braket
id|i
)braket
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a1
(braket
id|i
)braket
OL
id|a2
(braket
id|i
)braket
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Vova Oksman: function for copy tree to the buffer */
DECL|function|sprintf_avl
r_void
id|sprintf_avl
(paren
r_char
op_star
op_star
id|pbuffer
comma
r_struct
id|fdb
op_star
id|tree
comma
id|off_t
op_star
id|pos
comma
r_int
op_star
id|len
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
op_star
id|pos
)paren
(brace
r_if
c_cond
(paren
id|avl_br_empty
op_eq
id|tree
)paren
(brace
multiline_comment|/* begin from the root */
id|tree
op_assign
id|fhp
suffix:semicolon
)brace
op_star
id|pos
op_assign
op_star
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pos
op_ge
id|offset
op_plus
id|length
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|tree
op_ne
id|avl_br_empty
)paren
(brace
multiline_comment|/* don&squot;t write the local device */
r_if
c_cond
(paren
id|tree-&gt;port
op_ne
l_int|0
)paren
(brace
id|size
op_assign
id|sprintf
c_func
(paren
op_star
id|pbuffer
comma
l_string|&quot;%02x:%02x:%02x:%02x:%02x:%02x     %s       %d         %ld&bslash;n&quot;
comma
id|tree-&gt;ula
(braket
l_int|0
)braket
comma
id|tree-&gt;ula
(braket
l_int|1
)braket
comma
id|tree-&gt;ula
(braket
l_int|2
)braket
comma
id|tree-&gt;ula
(braket
l_int|3
)braket
comma
id|tree-&gt;ula
(braket
l_int|4
)braket
comma
id|tree-&gt;ula
(braket
l_int|5
)braket
comma
id|port_info
(braket
id|tree-&gt;port
)braket
dot
id|dev-&gt;name
comma
id|tree-&gt;flags
comma
id|CURRENT_TIME
op_minus
id|tree-&gt;timer
)paren
suffix:semicolon
(paren
op_star
id|pos
)paren
op_add_assign
id|size
suffix:semicolon
(paren
op_star
id|len
)paren
op_add_assign
id|size
suffix:semicolon
(paren
op_star
id|pbuffer
)paren
op_add_assign
id|size
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pos
op_le
id|offset
)paren
op_star
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;fdb_avl_left
op_ne
id|avl_br_empty
)paren
(brace
id|sprintf_avl
(paren
id|pbuffer
comma
id|tree-&gt;fdb_avl_left
comma
id|pos
comma
id|len
comma
id|offset
comma
id|length
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tree-&gt;fdb_avl_right
op_ne
id|avl_br_empty
)paren
(brace
id|sprintf_avl
(paren
id|pbuffer
comma
id|tree-&gt;fdb_avl_right
comma
id|pos
comma
id|len
comma
id|offset
comma
id|length
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Delete all nodes learnt by the port&n; */
DECL|function|br_avl_delete_by_port
r_void
id|br_avl_delete_by_port
c_func
(paren
r_int
id|port
)paren
(brace
r_struct
id|fdb
op_star
id|fdb
comma
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fdb_inited
)paren
id|fdb_init
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|fdb
op_assign
id|port_info
(braket
id|port
)braket
dot
id|fdb
suffix:semicolon
id|fdb
op_ne
l_int|NULL
suffix:semicolon
id|fdb
op_assign
id|next
)paren
(brace
id|next
op_assign
id|fdb-&gt;fdb_next
suffix:semicolon
id|br_avl_remove
c_func
(paren
id|fdb
)paren
suffix:semicolon
)brace
id|port_info
(braket
id|port
)braket
dot
id|fdb
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* remove the local mac too */
id|next
op_assign
id|br_avl_find_addr
c_func
(paren
id|port_info
(braket
id|port
)braket
dot
id|dev-&gt;dev_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
op_ne
l_int|NULL
)paren
id|br_avl_remove
c_func
(paren
id|next
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
eof
