multiline_comment|/*&n; *&t;Linux INET6 implementation &n; *&t;Forwarding Information Database&n; *&n; *&t;Authors:&n; *&t;Pedro Roque&t;&t;&lt;roque@di.fc.ul.pt&gt;&t;&n; *&n; *&t;$Id: ip6_fib.c,v 1.22 2000/09/12 00:38:34 davem Exp $&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *      modify it under the terms of the GNU General Public License&n; *      as published by the Free Software Foundation; either version&n; *      2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/route.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/in6.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#ifdef &t;CONFIG_PROC_FS
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#endif
macro_line|#include &lt;net/ipv6.h&gt;
macro_line|#include &lt;net/ndisc.h&gt;
macro_line|#include &lt;net/addrconf.h&gt;
macro_line|#include &lt;net/ip6_fib.h&gt;
macro_line|#include &lt;net/ip6_route.h&gt;
DECL|macro|RT6_DEBUG
mdefine_line|#define RT6_DEBUG 2
DECL|macro|CONFIG_IPV6_SUBTREES
macro_line|#undef CONFIG_IPV6_SUBTREES
macro_line|#if RT6_DEBUG &gt;= 3
DECL|macro|RT6_TRACE
mdefine_line|#define RT6_TRACE(x...) printk(KERN_DEBUG x)
macro_line|#else
DECL|macro|RT6_TRACE
mdefine_line|#define RT6_TRACE(x...) do { ; } while (0)
macro_line|#endif
DECL|variable|rt6_stats
r_struct
id|rt6_statistics
id|rt6_stats
suffix:semicolon
DECL|variable|fib6_node_kmem
r_static
id|kmem_cache_t
op_star
id|fib6_node_kmem
suffix:semicolon
DECL|enum|fib_walk_state_t
r_enum
id|fib_walk_state_t
(brace
macro_line|#ifdef CONFIG_IPV6_SUBTREES
DECL|enumerator|FWS_S
id|FWS_S
comma
macro_line|#endif
DECL|enumerator|FWS_L
id|FWS_L
comma
DECL|enumerator|FWS_R
id|FWS_R
comma
DECL|enumerator|FWS_C
id|FWS_C
comma
DECL|enumerator|FWS_U
id|FWS_U
)brace
suffix:semicolon
DECL|struct|fib6_cleaner_t
r_struct
id|fib6_cleaner_t
(brace
DECL|member|w
r_struct
id|fib6_walker_t
id|w
suffix:semicolon
DECL|member|func
r_int
(paren
op_star
id|func
)paren
(paren
r_struct
id|rt6_info
op_star
comma
r_void
op_star
id|arg
)paren
suffix:semicolon
DECL|member|arg
r_void
op_star
id|arg
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|fib6_walker_lock
id|rwlock_t
id|fib6_walker_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
macro_line|#ifdef CONFIG_IPV6_SUBTREES
DECL|macro|FWS_INIT
mdefine_line|#define FWS_INIT FWS_S
DECL|macro|SUBTREE
mdefine_line|#define SUBTREE(fn) ((fn)-&gt;subtree)
macro_line|#else
DECL|macro|FWS_INIT
mdefine_line|#define FWS_INIT FWS_L
DECL|macro|SUBTREE
mdefine_line|#define SUBTREE(fn) NULL
macro_line|#endif
r_static
r_void
id|fib6_prune_clones
c_func
(paren
r_struct
id|fib6_node
op_star
id|fn
comma
r_struct
id|rt6_info
op_star
id|rt
)paren
suffix:semicolon
r_static
r_void
id|fib6_repair_tree
c_func
(paren
r_struct
id|fib6_node
op_star
id|fn
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;A routing update causes an increase of the serial number on the&n; *&t;afected subtree. This allows for cached routes to be asynchronously&n; *&t;tested when modifications are made to the destination cache as a&n; *&t;result of redirects, path MTU changes, etc.&n; */
DECL|variable|rt_sernum
r_static
id|__u32
id|rt_sernum
op_assign
l_int|0
suffix:semicolon
DECL|variable|ip6_fib_timer
r_static
r_struct
id|timer_list
id|ip6_fib_timer
op_assign
(brace
id|function
suffix:colon
id|fib6_run_gc
)brace
suffix:semicolon
DECL|variable|fib6_walker_list
r_static
r_struct
id|fib6_walker_t
id|fib6_walker_list
op_assign
(brace
op_amp
id|fib6_walker_list
comma
op_amp
id|fib6_walker_list
comma
)brace
suffix:semicolon
DECL|macro|FOR_WALKERS
mdefine_line|#define FOR_WALKERS(w) for ((w)=fib6_walker_list.next; (w) != &amp;fib6_walker_list; (w)=(w)-&gt;next)
DECL|function|fib6_new_sernum
r_static
id|__inline__
id|u32
id|fib6_new_sernum
c_func
(paren
r_void
)paren
(brace
id|u32
id|n
op_assign
op_increment
id|rt_sernum
suffix:semicolon
r_if
c_cond
(paren
(paren
id|__s32
)paren
id|n
op_le
l_int|0
)paren
id|rt_sernum
op_assign
id|n
op_assign
l_int|1
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Auxiliary address test functions for the radix tree.&n; *&n; *&t;These assume a 32bit processor (although it will work on &n; *&t;64bit processors)&n; */
multiline_comment|/*&n; *&t;compare &quot;prefix length&quot; bits of an address&n; */
DECL|function|addr_match
r_static
id|__inline__
r_int
id|addr_match
c_func
(paren
r_void
op_star
id|token1
comma
r_void
op_star
id|token2
comma
r_int
id|prefixlen
)paren
(brace
id|__u32
op_star
id|a1
op_assign
id|token1
suffix:semicolon
id|__u32
op_star
id|a2
op_assign
id|token2
suffix:semicolon
r_int
id|pdw
suffix:semicolon
r_int
id|pbi
suffix:semicolon
id|pdw
op_assign
id|prefixlen
op_rshift
l_int|5
suffix:semicolon
multiline_comment|/* num of whole __u32 in prefix */
id|pbi
op_assign
id|prefixlen
op_amp
l_int|0x1f
suffix:semicolon
multiline_comment|/* num of bits in incomplete u32 in prefix */
r_if
c_cond
(paren
id|pdw
)paren
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|a1
comma
id|a2
comma
id|pdw
op_lshift
l_int|2
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pbi
)paren
(brace
id|__u32
id|mask
suffix:semicolon
id|mask
op_assign
id|htonl
c_func
(paren
(paren
l_int|0xffffffff
)paren
op_lshift
(paren
l_int|32
op_minus
id|pbi
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|a1
(braket
id|pdw
)braket
op_xor
id|a2
(braket
id|pdw
)braket
)paren
op_amp
id|mask
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;test bit&n; */
DECL|function|addr_bit_set
r_static
id|__inline__
r_int
id|addr_bit_set
c_func
(paren
r_void
op_star
id|token
comma
r_int
id|fn_bit
)paren
(brace
id|__u32
op_star
id|addr
op_assign
id|token
suffix:semicolon
r_return
id|htonl
c_func
(paren
l_int|1
op_lshift
(paren
(paren
op_complement
id|fn_bit
)paren
op_amp
l_int|0x1F
)paren
)paren
op_amp
id|addr
(braket
id|fn_bit
op_rshift
l_int|5
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;find the first different bit between two addresses&n; *&t;length of address must be a multiple of 32bits&n; */
DECL|function|addr_diff
r_static
id|__inline__
r_int
id|addr_diff
c_func
(paren
r_void
op_star
id|token1
comma
r_void
op_star
id|token2
comma
r_int
id|addrlen
)paren
(brace
id|__u32
op_star
id|a1
op_assign
id|token1
suffix:semicolon
id|__u32
op_star
id|a2
op_assign
id|token2
suffix:semicolon
r_int
id|i
suffix:semicolon
id|addrlen
op_rshift_assign
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|addrlen
suffix:semicolon
id|i
op_increment
)paren
(brace
id|__u32
id|xb
suffix:semicolon
id|xb
op_assign
id|a1
(braket
id|i
)braket
op_xor
id|a2
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|xb
)paren
(brace
r_int
id|j
op_assign
l_int|31
suffix:semicolon
id|xb
op_assign
id|ntohl
c_func
(paren
id|xb
)paren
suffix:semicolon
r_while
c_loop
(paren
id|test_bit
c_func
(paren
id|j
comma
op_amp
id|xb
)paren
op_eq
l_int|0
)paren
id|j
op_decrement
suffix:semicolon
r_return
(paren
id|i
op_star
l_int|32
op_plus
l_int|31
op_minus
id|j
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;we should *never* get to this point since that &n;&t; *&t;would mean the addrs are equal&n;&t; *&n;&t; *&t;However, we do get to it 8) And exacly, when&n;&t; *&t;addresses are equal 8)&n;&t; *&n;&t; *&t;ip route add 1111::/128 via ...&n;&t; *&t;ip route add 1111::/64 via ...&n;&t; *&t;and we are here.&n;&t; *&n;&t; *&t;Ideally, this function should stop comparison&n;&t; *&t;at prefix length. It does not, but it is still OK,&n;&t; *&t;if returned value is greater than prefix length.&n;&t; *&t;&t;&t;&t;&t;--ANK (980803)&n;&t; */
r_return
id|addrlen
op_lshift
l_int|5
suffix:semicolon
)brace
DECL|function|node_alloc
r_static
id|__inline__
r_struct
id|fib6_node
op_star
id|node_alloc
c_func
(paren
r_void
)paren
(brace
r_struct
id|fib6_node
op_star
id|fn
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fn
op_assign
id|kmem_cache_alloc
c_func
(paren
id|fib6_node_kmem
comma
id|SLAB_ATOMIC
)paren
)paren
op_ne
l_int|NULL
)paren
id|memset
c_func
(paren
id|fn
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|fib6_node
)paren
)paren
suffix:semicolon
r_return
id|fn
suffix:semicolon
)brace
DECL|function|node_free
r_static
id|__inline__
r_void
id|node_free
c_func
(paren
r_struct
id|fib6_node
op_star
id|fn
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|fib6_node_kmem
comma
id|fn
)paren
suffix:semicolon
)brace
DECL|function|rt6_release
r_static
id|__inline__
r_void
id|rt6_release
c_func
(paren
r_struct
id|rt6_info
op_star
id|rt
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|rt-&gt;rt6i_ref
)paren
)paren
id|dst_free
c_func
(paren
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Routing Table&n; *&n; *&t;return the apropriate node for a routing tree &quot;add&quot; operation&n; *&t;by either creating and inserting or by returning an existing&n; *&t;node.&n; */
DECL|function|fib6_add_1
r_static
r_struct
id|fib6_node
op_star
id|fib6_add_1
c_func
(paren
r_struct
id|fib6_node
op_star
id|root
comma
r_void
op_star
id|addr
comma
r_int
id|addrlen
comma
r_int
id|plen
comma
r_int
id|offset
)paren
(brace
r_struct
id|fib6_node
op_star
id|fn
comma
op_star
id|in
comma
op_star
id|ln
suffix:semicolon
r_struct
id|fib6_node
op_star
id|pn
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|rt6key
op_star
id|key
suffix:semicolon
r_int
id|bit
suffix:semicolon
r_int
id|dir
op_assign
l_int|0
suffix:semicolon
id|__u32
id|sernum
op_assign
id|fib6_new_sernum
c_func
(paren
)paren
suffix:semicolon
id|RT6_TRACE
c_func
(paren
l_string|&quot;fib6_add_1&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* insert node in tree */
id|fn
op_assign
id|root
suffix:semicolon
r_if
c_cond
(paren
id|plen
op_eq
l_int|0
)paren
r_return
id|fn
suffix:semicolon
r_do
(brace
id|key
op_assign
(paren
r_struct
id|rt6key
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|fn-&gt;leaf
op_plus
id|offset
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Prefix match&n;&t;&t; */
r_if
c_cond
(paren
id|plen
OL
id|fn-&gt;fn_bit
op_logical_or
op_logical_neg
id|addr_match
c_func
(paren
op_amp
id|key-&gt;addr
comma
id|addr
comma
id|fn-&gt;fn_bit
)paren
)paren
r_goto
id|insert_above
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Exact match ?&n;&t;&t; */
r_if
c_cond
(paren
id|plen
op_eq
id|fn-&gt;fn_bit
)paren
(brace
multiline_comment|/* clean up an intermediate node */
r_if
c_cond
(paren
(paren
id|fn-&gt;fn_flags
op_amp
id|RTN_RTINFO
)paren
op_eq
l_int|0
)paren
(brace
id|rt6_release
c_func
(paren
id|fn-&gt;leaf
)paren
suffix:semicolon
id|fn-&gt;leaf
op_assign
l_int|NULL
suffix:semicolon
)brace
id|fn-&gt;fn_sernum
op_assign
id|sernum
suffix:semicolon
r_return
id|fn
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;We have more bits to go&n;&t;&t; */
multiline_comment|/* Try to walk down on tree. */
id|fn-&gt;fn_sernum
op_assign
id|sernum
suffix:semicolon
id|dir
op_assign
id|addr_bit_set
c_func
(paren
id|addr
comma
id|fn-&gt;fn_bit
)paren
suffix:semicolon
id|pn
op_assign
id|fn
suffix:semicolon
id|fn
op_assign
id|dir
ques
c_cond
id|fn-&gt;right
suffix:colon
id|fn-&gt;left
suffix:semicolon
)brace
r_while
c_loop
(paren
id|fn
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We walked to the bottom of tree.&n;&t; *&t;Create new leaf node without children.&n;&t; */
id|ln
op_assign
id|node_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ln
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|ln-&gt;fn_bit
op_assign
id|plen
suffix:semicolon
id|ln-&gt;parent
op_assign
id|pn
suffix:semicolon
id|ln-&gt;fn_sernum
op_assign
id|sernum
suffix:semicolon
r_if
c_cond
(paren
id|dir
)paren
id|pn-&gt;right
op_assign
id|ln
suffix:semicolon
r_else
id|pn-&gt;left
op_assign
id|ln
suffix:semicolon
r_return
id|ln
suffix:semicolon
id|insert_above
suffix:colon
multiline_comment|/*&n;&t; * split since we don&squot;t have a common prefix anymore or &n;&t; * we have a less significant route.&n;&t; * we&squot;ve to insert an intermediate node on the list&n;&t; * this new node will point to the one we need to create&n;&t; * and the current&n;&t; */
id|pn
op_assign
id|fn-&gt;parent
suffix:semicolon
multiline_comment|/* find 1st bit in difference between the 2 addrs.&n;&n;&t;   See comment in addr_diff: bit may be an invalid value,&n;&t;   but if it is &gt;= plen, the value is ignored in any case.&n;&t; */
id|bit
op_assign
id|addr_diff
c_func
(paren
id|addr
comma
op_amp
id|key-&gt;addr
comma
id|addrlen
)paren
suffix:semicolon
multiline_comment|/* &n;&t; *&t;&t;(intermediate)[in]&t;&n;&t; *&t;          /&t;   &bslash;&n;&t; *&t;(new leaf node)[ln] (old node)[fn]&n;&t; */
r_if
c_cond
(paren
id|plen
OG
id|bit
)paren
(brace
id|in
op_assign
id|node_alloc
c_func
(paren
)paren
suffix:semicolon
id|ln
op_assign
id|node_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in
op_eq
l_int|NULL
op_logical_or
id|ln
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|in
)paren
id|node_free
c_func
(paren
id|in
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ln
)paren
id|node_free
c_func
(paren
id|ln
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * new intermediate node. &n;&t;&t; * RTN_RTINFO will&n;&t;&t; * be off since that an address that chooses one of&n;&t;&t; * the branches would not match less specific routes&n;&t;&t; * in the other branch&n;&t;&t; */
id|in-&gt;fn_bit
op_assign
id|bit
suffix:semicolon
id|in-&gt;parent
op_assign
id|pn
suffix:semicolon
id|in-&gt;leaf
op_assign
id|fn-&gt;leaf
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|in-&gt;leaf-&gt;rt6i_ref
)paren
suffix:semicolon
id|in-&gt;fn_sernum
op_assign
id|sernum
suffix:semicolon
multiline_comment|/* update parent pointer */
r_if
c_cond
(paren
id|dir
)paren
id|pn-&gt;right
op_assign
id|in
suffix:semicolon
r_else
id|pn-&gt;left
op_assign
id|in
suffix:semicolon
id|ln-&gt;fn_bit
op_assign
id|plen
suffix:semicolon
id|ln-&gt;parent
op_assign
id|in
suffix:semicolon
id|fn-&gt;parent
op_assign
id|in
suffix:semicolon
id|ln-&gt;fn_sernum
op_assign
id|sernum
suffix:semicolon
r_if
c_cond
(paren
id|addr_bit_set
c_func
(paren
id|addr
comma
id|bit
)paren
)paren
(brace
id|in-&gt;right
op_assign
id|ln
suffix:semicolon
id|in-&gt;left
op_assign
id|fn
suffix:semicolon
)brace
r_else
(brace
id|in-&gt;left
op_assign
id|ln
suffix:semicolon
id|in-&gt;right
op_assign
id|fn
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* plen &lt;= bit */
multiline_comment|/* &n;&t;&t; *&t;&t;(new leaf node)[ln]&n;&t;&t; *&t;          /&t;   &bslash;&n;&t;&t; *&t;     (old node)[fn] NULL&n;&t;&t; */
id|ln
op_assign
id|node_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ln
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|ln-&gt;fn_bit
op_assign
id|plen
suffix:semicolon
id|ln-&gt;parent
op_assign
id|pn
suffix:semicolon
id|ln-&gt;fn_sernum
op_assign
id|sernum
suffix:semicolon
r_if
c_cond
(paren
id|dir
)paren
id|pn-&gt;right
op_assign
id|ln
suffix:semicolon
r_else
id|pn-&gt;left
op_assign
id|ln
suffix:semicolon
r_if
c_cond
(paren
id|addr_bit_set
c_func
(paren
op_amp
id|key-&gt;addr
comma
id|plen
)paren
)paren
id|ln-&gt;right
op_assign
id|fn
suffix:semicolon
r_else
id|ln-&gt;left
op_assign
id|fn
suffix:semicolon
id|fn-&gt;parent
op_assign
id|ln
suffix:semicolon
)brace
r_return
id|ln
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Insert routing information in a node.&n; */
DECL|function|fib6_add_rt2node
r_static
r_int
id|fib6_add_rt2node
c_func
(paren
r_struct
id|fib6_node
op_star
id|fn
comma
r_struct
id|rt6_info
op_star
id|rt
)paren
(brace
r_struct
id|rt6_info
op_star
id|iter
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|rt6_info
op_star
op_star
id|ins
suffix:semicolon
id|ins
op_assign
op_amp
id|fn-&gt;leaf
suffix:semicolon
r_for
c_loop
(paren
id|iter
op_assign
id|fn-&gt;leaf
suffix:semicolon
id|iter
suffix:semicolon
id|iter
op_assign
id|iter-&gt;u.next
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Search for duplicates&n;&t;&t; */
r_if
c_cond
(paren
id|iter-&gt;rt6i_metric
op_eq
id|rt-&gt;rt6i_metric
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Same priority level&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|iter-&gt;rt6i_dev
op_eq
id|rt-&gt;rt6i_dev
)paren
op_logical_and
(paren
id|iter-&gt;rt6i_flowr
op_eq
id|rt-&gt;rt6i_flowr
)paren
op_logical_and
(paren
id|ipv6_addr_cmp
c_func
(paren
op_amp
id|iter-&gt;rt6i_gateway
comma
op_amp
id|rt-&gt;rt6i_gateway
)paren
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|iter-&gt;rt6i_flags
op_amp
id|RTF_EXPIRES
)paren
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
id|iter-&gt;rt6i_expires
op_assign
id|rt-&gt;rt6i_expires
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rt-&gt;rt6i_flags
op_amp
id|RTF_EXPIRES
)paren
)paren
(brace
id|iter-&gt;rt6i_flags
op_and_assign
op_complement
id|RTF_EXPIRES
suffix:semicolon
id|iter-&gt;rt6i_expires
op_assign
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|iter-&gt;rt6i_metric
OG
id|rt-&gt;rt6i_metric
)paren
r_break
suffix:semicolon
id|ins
op_assign
op_amp
id|iter-&gt;u.next
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;insert node&n;&t; */
id|rt-&gt;u.next
op_assign
id|iter
suffix:semicolon
op_star
id|ins
op_assign
id|rt
suffix:semicolon
id|rt-&gt;rt6i_node
op_assign
id|fn
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|rt-&gt;rt6i_ref
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_RTNETLINK
id|inet6_rt_notify
c_func
(paren
id|RTM_NEWROUTE
comma
id|rt
)paren
suffix:semicolon
macro_line|#endif
id|rt6_stats.fib_rt_entries
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fn-&gt;fn_flags
op_amp
id|RTN_RTINFO
)paren
op_eq
l_int|0
)paren
(brace
id|rt6_stats.fib_route_nodes
op_increment
suffix:semicolon
id|fn-&gt;fn_flags
op_or_assign
id|RTN_RTINFO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fib6_start_gc
r_static
id|__inline__
r_void
id|fib6_start_gc
c_func
(paren
r_struct
id|rt6_info
op_star
id|rt
)paren
(brace
r_if
c_cond
(paren
id|ip6_fib_timer.expires
op_eq
l_int|0
op_logical_and
(paren
id|rt-&gt;rt6i_flags
op_amp
(paren
id|RTF_EXPIRES
op_or
id|RTF_CACHE
)paren
)paren
)paren
id|mod_timer
c_func
(paren
op_amp
id|ip6_fib_timer
comma
id|jiffies
op_plus
id|ip6_rt_gc_interval
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Add routing information to the routing tree.&n; *&t;&lt;destination addr&gt;/&lt;source addr&gt;&n; *&t;with source addr info in sub-trees&n; */
DECL|function|fib6_add
r_int
id|fib6_add
c_func
(paren
r_struct
id|fib6_node
op_star
id|root
comma
r_struct
id|rt6_info
op_star
id|rt
)paren
(brace
r_struct
id|fib6_node
op_star
id|fn
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|fn
op_assign
id|fib6_add_1
c_func
(paren
id|root
comma
op_amp
id|rt-&gt;rt6i_dst.addr
comma
r_sizeof
(paren
r_struct
id|in6_addr
)paren
comma
id|rt-&gt;rt6i_dst.plen
comma
(paren
id|u8
op_star
)paren
op_amp
id|rt-&gt;rt6i_dst
op_minus
(paren
id|u8
op_star
)paren
id|rt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fn
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
macro_line|#ifdef CONFIG_IPV6_SUBTREES
r_if
c_cond
(paren
id|rt-&gt;rt6i_src.plen
)paren
(brace
r_struct
id|fib6_node
op_star
id|sn
suffix:semicolon
r_if
c_cond
(paren
id|fn-&gt;subtree
op_eq
l_int|NULL
)paren
(brace
r_struct
id|fib6_node
op_star
id|sfn
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Create subtree.&n;&t;&t;&t; *&n;&t;&t;&t; *&t;&t;fn[main tree]&n;&t;&t;&t; *&t;&t;|&n;&t;&t;&t; *&t;&t;sfn[subtree root]&n;&t;&t;&t; *&t;&t;   &bslash;&n;&t;&t;&t; *&t;&t;    sn[new leaf node]&n;&t;&t;&t; */
multiline_comment|/* Create subtree root node */
id|sfn
op_assign
id|node_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sfn
op_eq
l_int|NULL
)paren
r_goto
id|st_failure
suffix:semicolon
id|sfn-&gt;leaf
op_assign
op_amp
id|ip6_null_entry
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|ip6_null_entry.rt6i_ref
)paren
suffix:semicolon
id|sfn-&gt;fn_flags
op_assign
id|RTN_ROOT
suffix:semicolon
id|sfn-&gt;fn_sernum
op_assign
id|fib6_new_sernum
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Now add the first leaf node to new subtree */
id|sn
op_assign
id|fib6_add_1
c_func
(paren
id|sfn
comma
op_amp
id|rt-&gt;rt6i_src.addr
comma
r_sizeof
(paren
r_struct
id|in6_addr
)paren
comma
id|rt-&gt;rt6i_src.plen
comma
(paren
id|u8
op_star
)paren
op_amp
id|rt-&gt;rt6i_src
op_minus
(paren
id|u8
op_star
)paren
id|rt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sn
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* If it is failed, discard just allocated&n;&t;&t;&t;&t;   root, and then (in st_failure) stale node&n;&t;&t;&t;&t;   in main tree.&n;&t;&t;&t;&t; */
id|node_free
c_func
(paren
id|sfn
)paren
suffix:semicolon
r_goto
id|st_failure
suffix:semicolon
)brace
multiline_comment|/* Now link new subtree to main tree */
id|sfn-&gt;parent
op_assign
id|fn
suffix:semicolon
id|fn-&gt;subtree
op_assign
id|sfn
suffix:semicolon
r_if
c_cond
(paren
id|fn-&gt;leaf
op_eq
l_int|NULL
)paren
(brace
id|fn-&gt;leaf
op_assign
id|rt
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|rt-&gt;rt6i_ref
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|sn
op_assign
id|fib6_add_1
c_func
(paren
id|fn-&gt;subtree
comma
op_amp
id|rt-&gt;rt6i_src.addr
comma
r_sizeof
(paren
r_struct
id|in6_addr
)paren
comma
id|rt-&gt;rt6i_src.plen
comma
(paren
id|u8
op_star
)paren
op_amp
id|rt-&gt;rt6i_src
op_minus
(paren
id|u8
op_star
)paren
id|rt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sn
op_eq
l_int|NULL
)paren
r_goto
id|st_failure
suffix:semicolon
)brace
id|fn
op_assign
id|sn
suffix:semicolon
)brace
macro_line|#endif
id|err
op_assign
id|fib6_add_rt2node
c_func
(paren
id|fn
comma
id|rt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
(brace
id|fib6_start_gc
c_func
(paren
id|rt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rt-&gt;rt6i_flags
op_amp
id|RTF_CACHE
)paren
)paren
id|fib6_prune_clones
c_func
(paren
id|fn
comma
id|rt
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_if
c_cond
(paren
id|err
)paren
id|dst_free
c_func
(paren
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
macro_line|#ifdef CONFIG_IPV6_SUBTREES
multiline_comment|/* Subtree creation failed, probably main tree node&n;&t;   is orphan. If it is, shot it.&n;&t; */
id|st_failure
suffix:colon
r_if
c_cond
(paren
id|fn
op_logical_and
op_logical_neg
(paren
id|fn-&gt;fn_flags
op_amp
id|RTN_RTINFO
op_or
id|RTN_ROOT
)paren
)paren
id|fib_repair_tree
c_func
(paren
id|fn
)paren
suffix:semicolon
id|dst_free
c_func
(paren
op_amp
id|rt-&gt;u.dst
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *&t;Routing tree lookup&n; *&n; */
DECL|struct|lookup_args
r_struct
id|lookup_args
(brace
DECL|member|offset
r_int
id|offset
suffix:semicolon
multiline_comment|/* key offset on rt6_info&t;*/
DECL|member|addr
r_struct
id|in6_addr
op_star
id|addr
suffix:semicolon
multiline_comment|/* search key&t;&t;&t;*/
)brace
suffix:semicolon
DECL|function|fib6_lookup_1
r_static
r_struct
id|fib6_node
op_star
id|fib6_lookup_1
c_func
(paren
r_struct
id|fib6_node
op_star
id|root
comma
r_struct
id|lookup_args
op_star
id|args
)paren
(brace
r_struct
id|fib6_node
op_star
id|fn
suffix:semicolon
r_int
id|dir
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Descend on a tree&n;&t; */
id|fn
op_assign
id|root
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|fib6_node
op_star
id|next
suffix:semicolon
id|dir
op_assign
id|addr_bit_set
c_func
(paren
id|args-&gt;addr
comma
id|fn-&gt;fn_bit
)paren
suffix:semicolon
id|next
op_assign
id|dir
ques
c_cond
id|fn-&gt;right
suffix:colon
id|fn-&gt;left
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
(brace
id|fn
op_assign
id|next
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|fn-&gt;fn_flags
op_amp
id|RTN_ROOT
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef CONFIG_IPV6_SUBTREES
r_if
c_cond
(paren
id|fn-&gt;subtree
)paren
(brace
r_struct
id|fib6_node
op_star
id|st
suffix:semicolon
r_struct
id|lookup_args
op_star
id|narg
suffix:semicolon
id|narg
op_assign
id|args
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|narg-&gt;addr
)paren
(brace
id|st
op_assign
id|fib6_lookup_1
c_func
(paren
id|fn-&gt;subtree
comma
id|narg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
op_logical_and
op_logical_neg
(paren
id|st-&gt;fn_flags
op_amp
id|RTN_ROOT
)paren
)paren
r_return
id|st
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|fn-&gt;fn_flags
op_amp
id|RTN_RTINFO
)paren
(brace
r_struct
id|rt6key
op_star
id|key
suffix:semicolon
id|key
op_assign
(paren
r_struct
id|rt6key
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|fn-&gt;leaf
op_plus
id|args-&gt;offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr_match
c_func
(paren
op_amp
id|key-&gt;addr
comma
id|args-&gt;addr
comma
id|key-&gt;plen
)paren
)paren
r_return
id|fn
suffix:semicolon
)brace
id|fn
op_assign
id|fn-&gt;parent
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|fib6_lookup
r_struct
id|fib6_node
op_star
id|fib6_lookup
c_func
(paren
r_struct
id|fib6_node
op_star
id|root
comma
r_struct
id|in6_addr
op_star
id|daddr
comma
r_struct
id|in6_addr
op_star
id|saddr
)paren
(brace
r_struct
id|lookup_args
id|args
(braket
l_int|2
)braket
suffix:semicolon
r_struct
id|rt6_info
op_star
id|rt
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|fib6_node
op_star
id|fn
suffix:semicolon
id|args
(braket
l_int|0
)braket
dot
id|offset
op_assign
(paren
id|u8
op_star
)paren
op_amp
id|rt-&gt;rt6i_dst
op_minus
(paren
id|u8
op_star
)paren
id|rt
suffix:semicolon
id|args
(braket
l_int|0
)braket
dot
id|addr
op_assign
id|daddr
suffix:semicolon
macro_line|#ifdef CONFIG_IPV6_SUBTREES
id|args
(braket
l_int|1
)braket
dot
id|offset
op_assign
(paren
id|u8
op_star
)paren
op_amp
id|rt-&gt;rt6i_src
op_minus
(paren
id|u8
op_star
)paren
id|rt
suffix:semicolon
id|args
(braket
l_int|1
)braket
dot
id|addr
op_assign
id|saddr
suffix:semicolon
macro_line|#endif
id|fn
op_assign
id|fib6_lookup_1
c_func
(paren
id|root
comma
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fn
op_eq
l_int|NULL
)paren
id|fn
op_assign
id|root
suffix:semicolon
r_return
id|fn
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get node with sepciafied destination prefix (and source prefix,&n; *&t;if subtrees are used)&n; */
DECL|function|fib6_locate_1
r_static
r_struct
id|fib6_node
op_star
id|fib6_locate_1
c_func
(paren
r_struct
id|fib6_node
op_star
id|root
comma
r_struct
id|in6_addr
op_star
id|addr
comma
r_int
id|plen
comma
r_int
id|offset
)paren
(brace
r_struct
id|fib6_node
op_star
id|fn
suffix:semicolon
r_for
c_loop
(paren
id|fn
op_assign
id|root
suffix:semicolon
id|fn
suffix:semicolon
)paren
(brace
r_struct
id|rt6key
op_star
id|key
op_assign
(paren
r_struct
id|rt6key
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|fn-&gt;leaf
op_plus
id|offset
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Prefix match&n;&t;&t; */
r_if
c_cond
(paren
id|plen
OL
id|fn-&gt;fn_bit
op_logical_or
op_logical_neg
id|addr_match
c_func
(paren
op_amp
id|key-&gt;addr
comma
id|addr
comma
id|fn-&gt;fn_bit
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|plen
op_eq
id|fn-&gt;fn_bit
)paren
r_return
id|fn
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;We have more bits to go&n;&t;&t; */
r_if
c_cond
(paren
id|addr_bit_set
c_func
(paren
id|addr
comma
id|fn-&gt;fn_bit
)paren
)paren
id|fn
op_assign
id|fn-&gt;right
suffix:semicolon
r_else
id|fn
op_assign
id|fn-&gt;left
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|fib6_locate
r_struct
id|fib6_node
op_star
id|fib6_locate
c_func
(paren
r_struct
id|fib6_node
op_star
id|root
comma
r_struct
id|in6_addr
op_star
id|daddr
comma
r_int
id|dst_len
comma
r_struct
id|in6_addr
op_star
id|saddr
comma
r_int
id|src_len
)paren
(brace
r_struct
id|rt6_info
op_star
id|rt
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|fib6_node
op_star
id|fn
suffix:semicolon
id|fn
op_assign
id|fib6_locate_1
c_func
(paren
id|root
comma
id|daddr
comma
id|dst_len
comma
(paren
id|u8
op_star
)paren
op_amp
id|rt-&gt;rt6i_dst
op_minus
(paren
id|u8
op_star
)paren
id|rt
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IPV6_SUBTREES
r_if
c_cond
(paren
id|src_len
)paren
(brace
id|BUG_TRAP
c_func
(paren
id|saddr
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fn
op_eq
l_int|NULL
)paren
id|fn
op_assign
id|fn-&gt;subtree
suffix:semicolon
r_if
c_cond
(paren
id|fn
)paren
id|fn
op_assign
id|fib6_locate_1
c_func
(paren
id|fn
comma
id|saddr
comma
id|src_len
comma
(paren
id|u8
op_star
)paren
op_amp
id|rt-&gt;rt6i_src
op_minus
(paren
id|u8
op_star
)paren
id|rt
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|fn
op_logical_and
id|fn-&gt;fn_flags
op_amp
id|RTN_RTINFO
)paren
r_return
id|fn
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Deletion&n; *&n; */
DECL|function|fib6_find_prefix
r_static
r_struct
id|rt6_info
op_star
id|fib6_find_prefix
c_func
(paren
r_struct
id|fib6_node
op_star
id|fn
)paren
(brace
r_if
c_cond
(paren
id|fn-&gt;fn_flags
op_amp
id|RTN_ROOT
)paren
r_return
op_amp
id|ip6_null_entry
suffix:semicolon
r_while
c_loop
(paren
id|fn
)paren
(brace
r_if
c_cond
(paren
id|fn-&gt;left
)paren
(brace
r_return
id|fn-&gt;left-&gt;leaf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fn-&gt;right
)paren
(brace
r_return
id|fn-&gt;right-&gt;leaf
suffix:semicolon
)brace
id|fn
op_assign
id|SUBTREE
c_func
(paren
id|fn
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Called to trim the tree of intermediate nodes when possible. &quot;fn&quot;&n; *&t;is the node we want to try and remove.&n; */
DECL|function|fib6_repair_tree
r_static
r_void
id|fib6_repair_tree
c_func
(paren
r_struct
id|fib6_node
op_star
id|fn
)paren
(brace
r_int
id|children
suffix:semicolon
r_int
id|nstate
suffix:semicolon
r_struct
id|fib6_node
op_star
id|child
comma
op_star
id|pn
suffix:semicolon
r_struct
id|fib6_walker_t
op_star
id|w
suffix:semicolon
r_int
id|iter
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|RT6_TRACE
c_func
(paren
l_string|&quot;fixing tree: plen=%d iter=%d&bslash;n&quot;
comma
id|fn-&gt;fn_bit
comma
id|iter
)paren
suffix:semicolon
id|iter
op_increment
suffix:semicolon
id|BUG_TRAP
c_func
(paren
op_logical_neg
(paren
id|fn-&gt;fn_flags
op_amp
id|RTN_RTINFO
)paren
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
op_logical_neg
(paren
id|fn-&gt;fn_flags
op_amp
id|RTN_TL_ROOT
)paren
)paren
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|fn-&gt;leaf
op_eq
l_int|NULL
)paren
suffix:semicolon
id|children
op_assign
l_int|0
suffix:semicolon
id|child
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|fn-&gt;right
)paren
id|child
op_assign
id|fn-&gt;right
comma
id|children
op_or_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|fn-&gt;left
)paren
id|child
op_assign
id|fn-&gt;left
comma
id|children
op_or_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|children
op_eq
l_int|3
op_logical_or
id|SUBTREE
c_func
(paren
id|fn
)paren
macro_line|#ifdef CONFIG_IPV6_SUBTREES
multiline_comment|/* Subtree root (i.e. fn) may have one child */
op_logical_or
(paren
id|children
op_logical_and
id|fn-&gt;fn_flags
op_amp
id|RTN_ROOT
)paren
macro_line|#endif
)paren
(brace
id|fn-&gt;leaf
op_assign
id|fib6_find_prefix
c_func
(paren
id|fn
)paren
suffix:semicolon
macro_line|#if RT6_DEBUG &gt;= 2
r_if
c_cond
(paren
id|fn-&gt;leaf
op_eq
l_int|NULL
)paren
(brace
id|BUG_TRAP
c_func
(paren
id|fn-&gt;leaf
)paren
suffix:semicolon
id|fn-&gt;leaf
op_assign
op_amp
id|ip6_null_entry
suffix:semicolon
)brace
macro_line|#endif
id|atomic_inc
c_func
(paren
op_amp
id|fn-&gt;leaf-&gt;rt6i_ref
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pn
op_assign
id|fn-&gt;parent
suffix:semicolon
macro_line|#ifdef CONFIG_IPV6_SUBTREES
r_if
c_cond
(paren
id|SUBTREE
c_func
(paren
id|pn
)paren
op_eq
id|fn
)paren
(brace
id|BUG_TRAP
c_func
(paren
id|fn-&gt;fn_flags
op_amp
id|RTN_ROOT
)paren
suffix:semicolon
id|SUBTREE
c_func
(paren
id|pn
)paren
op_assign
l_int|NULL
suffix:semicolon
id|nstate
op_assign
id|FWS_L
suffix:semicolon
)brace
r_else
(brace
id|BUG_TRAP
c_func
(paren
op_logical_neg
(paren
id|fn-&gt;fn_flags
op_amp
id|RTN_ROOT
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|pn-&gt;right
op_eq
id|fn
)paren
id|pn-&gt;right
op_assign
id|child
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pn-&gt;left
op_eq
id|fn
)paren
id|pn-&gt;left
op_assign
id|child
suffix:semicolon
macro_line|#if RT6_DEBUG &gt;= 2
r_else
id|BUG_TRAP
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|child
)paren
id|child-&gt;parent
op_assign
id|pn
suffix:semicolon
id|nstate
op_assign
id|FWS_R
suffix:semicolon
macro_line|#ifdef CONFIG_IPV6_SUBTREES
)brace
macro_line|#endif
id|read_lock
c_func
(paren
op_amp
id|fib6_walker_lock
)paren
suffix:semicolon
id|FOR_WALKERS
c_func
(paren
id|w
)paren
(brace
r_if
c_cond
(paren
id|child
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|w-&gt;root
op_eq
id|fn
)paren
(brace
id|w-&gt;root
op_assign
id|w-&gt;node
op_assign
l_int|NULL
suffix:semicolon
id|RT6_TRACE
c_func
(paren
l_string|&quot;W %p adjusted by delroot 1&bslash;n&quot;
comma
id|w
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|w-&gt;node
op_eq
id|fn
)paren
(brace
id|RT6_TRACE
c_func
(paren
l_string|&quot;W %p adjusted by delnode 1, s=%d/%d&bslash;n&quot;
comma
id|w
comma
id|w-&gt;state
comma
id|nstate
)paren
suffix:semicolon
id|w-&gt;node
op_assign
id|pn
suffix:semicolon
id|w-&gt;state
op_assign
id|nstate
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|w-&gt;root
op_eq
id|fn
)paren
(brace
id|w-&gt;root
op_assign
id|child
suffix:semicolon
id|RT6_TRACE
c_func
(paren
l_string|&quot;W %p adjusted by delroot 2&bslash;n&quot;
comma
id|w
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|w-&gt;node
op_eq
id|fn
)paren
(brace
id|w-&gt;node
op_assign
id|child
suffix:semicolon
r_if
c_cond
(paren
id|children
op_amp
l_int|2
)paren
(brace
id|RT6_TRACE
c_func
(paren
l_string|&quot;W %p adjusted by delnode 2, s=%d&bslash;n&quot;
comma
id|w
comma
id|w-&gt;state
)paren
suffix:semicolon
id|w-&gt;state
op_assign
id|w-&gt;state
op_ge
id|FWS_R
ques
c_cond
id|FWS_U
suffix:colon
id|FWS_INIT
suffix:semicolon
)brace
r_else
(brace
id|RT6_TRACE
c_func
(paren
l_string|&quot;W %p adjusted by delnode 2, s=%d&bslash;n&quot;
comma
id|w
comma
id|w-&gt;state
)paren
suffix:semicolon
id|w-&gt;state
op_assign
id|w-&gt;state
op_ge
id|FWS_C
ques
c_cond
id|FWS_U
suffix:colon
id|FWS_INIT
suffix:semicolon
)brace
)brace
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|fib6_walker_lock
)paren
suffix:semicolon
id|node_free
c_func
(paren
id|fn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pn-&gt;fn_flags
op_amp
id|RTN_RTINFO
op_logical_or
id|SUBTREE
c_func
(paren
id|pn
)paren
)paren
r_return
suffix:semicolon
id|rt6_release
c_func
(paren
id|pn-&gt;leaf
)paren
suffix:semicolon
id|pn-&gt;leaf
op_assign
l_int|NULL
suffix:semicolon
id|fn
op_assign
id|pn
suffix:semicolon
)brace
)brace
DECL|function|fib6_del_route
r_static
r_void
id|fib6_del_route
c_func
(paren
r_struct
id|fib6_node
op_star
id|fn
comma
r_struct
id|rt6_info
op_star
op_star
id|rtp
)paren
(brace
r_struct
id|fib6_walker_t
op_star
id|w
suffix:semicolon
r_struct
id|rt6_info
op_star
id|rt
op_assign
op_star
id|rtp
suffix:semicolon
id|RT6_TRACE
c_func
(paren
l_string|&quot;fib6_del_route&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Unlink it */
op_star
id|rtp
op_assign
id|rt-&gt;u.next
suffix:semicolon
id|rt-&gt;rt6i_node
op_assign
l_int|NULL
suffix:semicolon
id|rt6_stats.fib_rt_entries
op_decrement
suffix:semicolon
multiline_comment|/* Adjust walkers */
id|read_lock
c_func
(paren
op_amp
id|fib6_walker_lock
)paren
suffix:semicolon
id|FOR_WALKERS
c_func
(paren
id|w
)paren
(brace
r_if
c_cond
(paren
id|w-&gt;state
op_eq
id|FWS_C
op_logical_and
id|w-&gt;leaf
op_eq
id|rt
)paren
(brace
id|RT6_TRACE
c_func
(paren
l_string|&quot;walker %p adjusted by delroute&bslash;n&quot;
comma
id|w
)paren
suffix:semicolon
id|w-&gt;leaf
op_assign
id|rt-&gt;u.next
suffix:semicolon
r_if
c_cond
(paren
id|w-&gt;leaf
op_eq
l_int|NULL
)paren
id|w-&gt;state
op_assign
id|FWS_U
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|fib6_walker_lock
)paren
suffix:semicolon
id|rt-&gt;u.next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* If it was last route, expunge its radix tree node */
r_if
c_cond
(paren
id|fn-&gt;leaf
op_eq
l_int|NULL
)paren
(brace
id|fn-&gt;fn_flags
op_and_assign
op_complement
id|RTN_RTINFO
suffix:semicolon
id|rt6_stats.fib_route_nodes
op_decrement
suffix:semicolon
id|fib6_repair_tree
c_func
(paren
id|fn
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_RTNETLINK
id|inet6_rt_notify
c_func
(paren
id|RTM_DELROUTE
comma
id|rt
)paren
suffix:semicolon
macro_line|#endif
id|rt6_release
c_func
(paren
id|rt
)paren
suffix:semicolon
)brace
DECL|function|fib6_del
r_int
id|fib6_del
c_func
(paren
r_struct
id|rt6_info
op_star
id|rt
)paren
(brace
r_struct
id|fib6_node
op_star
id|fn
op_assign
id|rt-&gt;rt6i_node
suffix:semicolon
r_struct
id|rt6_info
op_star
op_star
id|rtp
suffix:semicolon
macro_line|#if RT6_DEBUG &gt;= 2
r_if
c_cond
(paren
id|rt-&gt;u.dst.obsolete
OG
l_int|0
)paren
(brace
id|BUG_TRAP
c_func
(paren
id|fn
op_eq
l_int|NULL
op_logical_or
id|rt-&gt;u.dst.obsolete
op_le
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|fn
op_eq
l_int|NULL
op_logical_or
id|rt
op_eq
op_amp
id|ip6_null_entry
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|BUG_TRAP
c_func
(paren
id|fn-&gt;fn_flags
op_amp
id|RTN_RTINFO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rt-&gt;rt6i_flags
op_amp
id|RTF_CACHE
)paren
)paren
id|fib6_prune_clones
c_func
(paren
id|fn
comma
id|rt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Walk the leaf entries looking for ourself&n;&t; */
r_for
c_loop
(paren
id|rtp
op_assign
op_amp
id|fn-&gt;leaf
suffix:semicolon
op_star
id|rtp
suffix:semicolon
id|rtp
op_assign
op_amp
(paren
op_star
id|rtp
)paren
op_member_access_from_pointer
id|u.next
)paren
(brace
r_if
c_cond
(paren
op_star
id|rtp
op_eq
id|rt
)paren
(brace
id|fib6_del_route
c_func
(paren
id|fn
comma
id|rtp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Tree transversal function.&n; *&n; *&t;Certainly, it is not interrupt safe.&n; *&t;However, it is internally reenterable wrt itself and fib6_add/fib6_del.&n; *&t;It means, that we can modify tree during walking&n; *&t;and use this function for garbage collection, clone pruning,&n; *&t;cleaning tree when a device goes down etc. etc.&t;&n; *&n; *&t;It guarantees that every node will be traversed,&n; *&t;and that it will be traversed only once.&n; *&n; *&t;Callback function w-&gt;func may return:&n; *&t;0 -&gt; continue walking.&n; *&t;positive value -&gt; walking is suspended (used by tree dumps,&n; *&t;and probably by gc, if it will be split to several slices)&n; *&t;negative value -&gt; terminate walking.&n; *&n; *&t;The function itself returns:&n; *&t;0   -&gt; walk is complete.&n; *&t;&gt;0  -&gt; walk is incomplete (i.e. suspended)&n; *&t;&lt;0  -&gt; walk is terminated by an error.&n; */
DECL|function|fib6_walk_continue
r_int
id|fib6_walk_continue
c_func
(paren
r_struct
id|fib6_walker_t
op_star
id|w
)paren
(brace
r_struct
id|fib6_node
op_star
id|fn
comma
op_star
id|pn
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|fn
op_assign
id|w-&gt;node
suffix:semicolon
r_if
c_cond
(paren
id|fn
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|w-&gt;prune
op_logical_and
id|fn
op_ne
id|w-&gt;root
op_logical_and
id|fn-&gt;fn_flags
op_amp
id|RTN_RTINFO
op_logical_and
id|w-&gt;state
OL
id|FWS_C
)paren
(brace
id|w-&gt;state
op_assign
id|FWS_C
suffix:semicolon
id|w-&gt;leaf
op_assign
id|fn-&gt;leaf
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|w-&gt;state
)paren
(brace
macro_line|#ifdef CONFIG_IPV6_SUBTREES
r_case
id|FWS_S
suffix:colon
r_if
c_cond
(paren
id|SUBTREE
c_func
(paren
id|fn
)paren
)paren
(brace
id|w-&gt;node
op_assign
id|SUBTREE
c_func
(paren
id|fn
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|w-&gt;state
op_assign
id|FWS_L
suffix:semicolon
macro_line|#endif&t;
r_case
id|FWS_L
suffix:colon
r_if
c_cond
(paren
id|fn-&gt;left
)paren
(brace
id|w-&gt;node
op_assign
id|fn-&gt;left
suffix:semicolon
id|w-&gt;state
op_assign
id|FWS_INIT
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|w-&gt;state
op_assign
id|FWS_R
suffix:semicolon
r_case
id|FWS_R
suffix:colon
r_if
c_cond
(paren
id|fn-&gt;right
)paren
(brace
id|w-&gt;node
op_assign
id|fn-&gt;right
suffix:semicolon
id|w-&gt;state
op_assign
id|FWS_INIT
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|w-&gt;state
op_assign
id|FWS_C
suffix:semicolon
id|w-&gt;leaf
op_assign
id|fn-&gt;leaf
suffix:semicolon
r_case
id|FWS_C
suffix:colon
r_if
c_cond
(paren
id|w-&gt;leaf
op_logical_and
id|fn-&gt;fn_flags
op_amp
id|RTN_RTINFO
)paren
(brace
r_int
id|err
op_assign
id|w
op_member_access_from_pointer
id|func
c_func
(paren
id|w
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|w-&gt;state
op_assign
id|FWS_U
suffix:semicolon
r_case
id|FWS_U
suffix:colon
r_if
c_cond
(paren
id|fn
op_eq
id|w-&gt;root
)paren
r_return
l_int|0
suffix:semicolon
id|pn
op_assign
id|fn-&gt;parent
suffix:semicolon
id|w-&gt;node
op_assign
id|pn
suffix:semicolon
macro_line|#ifdef CONFIG_IPV6_SUBTREES
r_if
c_cond
(paren
id|SUBTREE
c_func
(paren
id|pn
)paren
op_eq
id|fn
)paren
(brace
id|BUG_TRAP
c_func
(paren
id|fn-&gt;fn_flags
op_amp
id|RTN_ROOT
)paren
suffix:semicolon
id|w-&gt;state
op_assign
id|FWS_L
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|pn-&gt;left
op_eq
id|fn
)paren
(brace
id|w-&gt;state
op_assign
id|FWS_R
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pn-&gt;right
op_eq
id|fn
)paren
(brace
id|w-&gt;state
op_assign
id|FWS_C
suffix:semicolon
id|w-&gt;leaf
op_assign
id|w-&gt;node-&gt;leaf
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#if RT6_DEBUG &gt;= 2
id|BUG_TRAP
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
DECL|function|fib6_walk
r_int
id|fib6_walk
c_func
(paren
r_struct
id|fib6_walker_t
op_star
id|w
)paren
(brace
r_int
id|res
suffix:semicolon
id|w-&gt;state
op_assign
id|FWS_INIT
suffix:semicolon
id|w-&gt;node
op_assign
id|w-&gt;root
suffix:semicolon
id|fib6_walker_link
c_func
(paren
id|w
)paren
suffix:semicolon
id|res
op_assign
id|fib6_walk_continue
c_func
(paren
id|w
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_le
l_int|0
)paren
id|fib6_walker_unlink
c_func
(paren
id|w
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|fib6_clean_node
r_static
r_int
id|fib6_clean_node
c_func
(paren
r_struct
id|fib6_walker_t
op_star
id|w
)paren
(brace
r_int
id|res
suffix:semicolon
r_struct
id|rt6_info
op_star
id|rt
suffix:semicolon
r_struct
id|fib6_cleaner_t
op_star
id|c
op_assign
(paren
r_struct
id|fib6_cleaner_t
op_star
)paren
id|w
suffix:semicolon
r_for
c_loop
(paren
id|rt
op_assign
id|w-&gt;leaf
suffix:semicolon
id|rt
suffix:semicolon
id|rt
op_assign
id|rt-&gt;u.next
)paren
(brace
id|res
op_assign
id|c
op_member_access_from_pointer
id|func
c_func
(paren
id|rt
comma
id|c-&gt;arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OL
l_int|0
)paren
(brace
id|w-&gt;leaf
op_assign
id|rt
suffix:semicolon
id|res
op_assign
id|fib6_del
c_func
(paren
id|rt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
macro_line|#if RT6_DEBUG &gt;= 2
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;fib6_clean_node: del failed: rt=%p@%p err=%d&bslash;n&quot;
comma
id|rt
comma
id|rt-&gt;rt6i_node
comma
id|res
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|BUG_TRAP
c_func
(paren
id|res
op_eq
l_int|0
)paren
suffix:semicolon
)brace
id|w-&gt;leaf
op_assign
id|rt
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Convenient frontend to tree walker.&n; *&t;&n; *&t;func is called on each route.&n; *&t;&t;It may return -1 -&gt; delete this route.&n; *&t;&t;              0  -&gt; continue walking&n; *&n; *&t;prune==1 -&gt; only immediate children of node (certainly,&n; *&t;ignoring pure split nodes) will be scanned.&n; */
DECL|function|fib6_clean_tree
r_void
id|fib6_clean_tree
c_func
(paren
r_struct
id|fib6_node
op_star
id|root
comma
r_int
(paren
op_star
id|func
)paren
(paren
r_struct
id|rt6_info
op_star
comma
r_void
op_star
id|arg
)paren
comma
r_int
id|prune
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|fib6_cleaner_t
id|c
suffix:semicolon
id|c.w.root
op_assign
id|root
suffix:semicolon
id|c.w.func
op_assign
id|fib6_clean_node
suffix:semicolon
id|c.w.prune
op_assign
id|prune
suffix:semicolon
id|c.func
op_assign
id|func
suffix:semicolon
id|c.arg
op_assign
id|arg
suffix:semicolon
id|fib6_walk
c_func
(paren
op_amp
id|c.w
)paren
suffix:semicolon
)brace
DECL|function|fib6_prune_clone
r_static
r_int
id|fib6_prune_clone
c_func
(paren
r_struct
id|rt6_info
op_star
id|rt
comma
r_void
op_star
id|arg
)paren
(brace
r_if
c_cond
(paren
id|rt-&gt;rt6i_flags
op_amp
id|RTF_CACHE
)paren
(brace
id|RT6_TRACE
c_func
(paren
l_string|&quot;pruning clone %p&bslash;n&quot;
comma
id|rt
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fib6_prune_clones
r_static
r_void
id|fib6_prune_clones
c_func
(paren
r_struct
id|fib6_node
op_star
id|fn
comma
r_struct
id|rt6_info
op_star
id|rt
)paren
(brace
id|fib6_clean_tree
c_func
(paren
id|fn
comma
id|fib6_prune_clone
comma
l_int|1
comma
id|rt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Garbage collection&n; */
DECL|struct|fib6_gc_args
r_static
r_struct
id|fib6_gc_args
(brace
DECL|member|timeout
r_int
id|timeout
suffix:semicolon
DECL|member|more
r_int
id|more
suffix:semicolon
DECL|variable|gc_args
)brace
id|gc_args
suffix:semicolon
DECL|function|fib6_age
r_static
r_int
id|fib6_age
c_func
(paren
r_struct
id|rt6_info
op_star
id|rt
comma
r_void
op_star
id|arg
)paren
(brace
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Age clones. Note, that clones are aged out&n;&t;   only if they are not in use now.&n;&t; */
r_if
c_cond
(paren
id|rt-&gt;rt6i_flags
op_amp
id|RTF_CACHE
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|rt-&gt;u.dst.__refcnt
)paren
op_eq
l_int|0
op_logical_and
(paren
r_int
)paren
(paren
id|now
op_minus
id|rt-&gt;u.dst.lastuse
)paren
op_ge
id|gc_args.timeout
)paren
(brace
id|RT6_TRACE
c_func
(paren
l_string|&quot;aging clone %p&bslash;n&quot;
comma
id|rt
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|gc_args.more
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;check addrconf expiration here.&n;&t; *&t;They are expired even if they are in use.&n;&t; */
r_if
c_cond
(paren
id|rt-&gt;rt6i_flags
op_amp
id|RTF_EXPIRES
op_logical_and
id|rt-&gt;rt6i_expires
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|now
op_minus
id|rt-&gt;rt6i_expires
)paren
OG
l_int|0
)paren
(brace
id|RT6_TRACE
c_func
(paren
l_string|&quot;expiring %p&bslash;n&quot;
comma
id|rt
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|gc_args.more
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|fib6_gc_lock
r_static
id|spinlock_t
id|fib6_gc_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|fib6_run_gc
r_void
id|fib6_run_gc
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_if
c_cond
(paren
id|dummy
op_ne
op_complement
l_int|0UL
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|fib6_gc_lock
)paren
suffix:semicolon
id|gc_args.timeout
op_assign
(paren
r_int
)paren
id|dummy
suffix:semicolon
)brace
r_else
(brace
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|fib6_gc_lock
)paren
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|ip6_fib_timer
comma
id|jiffies
op_plus
id|HZ
)paren
suffix:semicolon
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|gc_args.timeout
op_assign
id|ip6_rt_gc_interval
suffix:semicolon
)brace
id|gc_args.more
op_assign
l_int|0
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|rt6_lock
)paren
suffix:semicolon
id|fib6_clean_tree
c_func
(paren
op_amp
id|ip6_routing_table
comma
id|fib6_age
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|rt6_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gc_args.more
)paren
id|mod_timer
c_func
(paren
op_amp
id|ip6_fib_timer
comma
id|jiffies
op_plus
id|ip6_rt_gc_interval
)paren
suffix:semicolon
r_else
(brace
id|del_timer
c_func
(paren
op_amp
id|ip6_fib_timer
)paren
suffix:semicolon
id|ip6_fib_timer.expires
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|fib6_gc_lock
)paren
suffix:semicolon
)brace
DECL|function|fib6_init
r_void
id|__init
id|fib6_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fib6_node_kmem
)paren
id|fib6_node_kmem
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;fib6_nodes&quot;
comma
r_sizeof
(paren
r_struct
id|fib6_node
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|fib6_gc_cleanup
r_void
id|fib6_gc_cleanup
c_func
(paren
r_void
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|ip6_fib_timer
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
