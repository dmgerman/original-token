multiline_comment|/*&n; * Packet matching code.&n; *&n; * Copyright (C) 1999 Paul `Rusty&squot; Russell &amp; Michael J. Neuling&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/udp.h&gt;
macro_line|#include &lt;linux/icmp.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/netfilter_ipv6/ip6_tables.h&gt;
DECL|macro|IPV6_HDR_LEN
mdefine_line|#define IPV6_HDR_LEN&t;(sizeof(struct ipv6hdr))
multiline_comment|/*#define DEBUG_IP_FIREWALL*/
multiline_comment|/*#define DEBUG_ALLOW_ALL*/
multiline_comment|/* Useful for remote debugging */
multiline_comment|/*#define DEBUG_IP_FIREWALL_USER*/
macro_line|#ifdef DEBUG_IP_FIREWALL
DECL|macro|dprintf
mdefine_line|#define dprintf(format, args...)  printk(format , ## args)
macro_line|#else
DECL|macro|dprintf
mdefine_line|#define dprintf(format, args...)
macro_line|#endif
macro_line|#ifdef DEBUG_IP_FIREWALL_USER
DECL|macro|duprintf
mdefine_line|#define duprintf(format, args...) printk(format , ## args)
macro_line|#else
DECL|macro|duprintf
mdefine_line|#define duprintf(format, args...)
macro_line|#endif
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
DECL|macro|IP_NF_ASSERT
mdefine_line|#define IP_NF_ASSERT(x)&t;&t;&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (!(x))&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;printk(&quot;IP_NF_ASSERT: %s:%s:%u&bslash;n&quot;,&t;&t;&bslash;&n;&t;&t;       __FUNCTION__, __FILE__, __LINE__);&t;&bslash;&n;} while(0)
macro_line|#else
DECL|macro|IP_NF_ASSERT
mdefine_line|#define IP_NF_ASSERT(x)
macro_line|#endif
DECL|macro|SMP_ALIGN
mdefine_line|#define SMP_ALIGN(x) (((x) + SMP_CACHE_BYTES-1) &amp; ~(SMP_CACHE_BYTES-1))
multiline_comment|/* Mutex protects lists (only traversed in user context). */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|ip6t_mutex
)paren
suffix:semicolon
multiline_comment|/* Must have mutex */
DECL|macro|ASSERT_READ_LOCK
mdefine_line|#define ASSERT_READ_LOCK(x) IP_NF_ASSERT(down_trylock(&amp;ip6t_mutex) != 0)
DECL|macro|ASSERT_WRITE_LOCK
mdefine_line|#define ASSERT_WRITE_LOCK(x) IP_NF_ASSERT(down_trylock(&amp;ip6t_mutex) != 0)
macro_line|#include &lt;linux/netfilter_ipv4/lockhelp.h&gt;
macro_line|#include &lt;linux/netfilter_ipv4/listhelp.h&gt;
macro_line|#if 0
multiline_comment|/* All the better to debug you with... */
mdefine_line|#define static
mdefine_line|#define inline
macro_line|#endif
multiline_comment|/* Locking is simple: we assume at worst case there will be one packet&n;   in user context and one from bottom halves (or soft irq if Alexey&squot;s&n;   softnet patch was applied).&n;&n;   We keep a set of rules for each CPU, so we can avoid write-locking&n;   them; doing a readlock_bh() stops packets coming through if we&squot;re&n;   in user context.&n;&n;   To be cache friendly on SMP, we arrange them like so:&n;   [ n-entries ]&n;   ... cache-align padding ...&n;   [ n-entries ]&n;&n;   Hence the start of any table is given by get_table() below.  */
multiline_comment|/* The table itself */
DECL|struct|ip6t_table_info
r_struct
id|ip6t_table_info
(brace
multiline_comment|/* Size per table */
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
multiline_comment|/* Number of entries: FIXME. --RR */
DECL|member|number
r_int
r_int
id|number
suffix:semicolon
multiline_comment|/* Entry points and underflows */
DECL|member|hook_entry
r_int
r_int
id|hook_entry
(braket
id|NF_IP6_NUMHOOKS
)braket
suffix:semicolon
DECL|member|underflow
r_int
r_int
id|underflow
(braket
id|NF_IP6_NUMHOOKS
)braket
suffix:semicolon
DECL|member|padding
r_char
id|padding
(braket
id|SMP_ALIGN
c_func
(paren
(paren
id|NF_IP6_NUMHOOKS
op_star
l_int|2
op_plus
l_int|2
)paren
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
)braket
suffix:semicolon
multiline_comment|/* ip6t_entry tables: one per CPU */
DECL|member|entries
r_char
id|entries
(braket
l_int|0
)braket
suffix:semicolon
)brace
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|ip6t_target
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|ip6t_match
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|ip6t_tables
)paren
suffix:semicolon
DECL|macro|ADD_COUNTER
mdefine_line|#define ADD_COUNTER(c,b,p) do { (c).bcnt += (b); (c).pcnt += (p); } while(0)
macro_line|#ifdef CONFIG_SMP
DECL|macro|TABLE_OFFSET
mdefine_line|#define TABLE_OFFSET(t,p) (SMP_ALIGN((t)-&gt;size)*cpu_number_map(p))
macro_line|#else
DECL|macro|TABLE_OFFSET
mdefine_line|#define TABLE_OFFSET(t,p) 0
macro_line|#endif
macro_line|#if 0
mdefine_line|#define down(x) do { printk(&quot;DOWN:%u:&quot; #x &quot;&bslash;n&quot;, __LINE__); down(x); } while(0)
mdefine_line|#define down_interruptible(x) ({ int __r; printk(&quot;DOWNi:%u:&quot; #x &quot;&bslash;n&quot;, __LINE__); __r = down_interruptible(x); if (__r != 0) printk(&quot;ABORT-DOWNi:%u&bslash;n&quot;, __LINE__); __r; })
mdefine_line|#define up(x) do { printk(&quot;UP:%u:&quot; #x &quot;&bslash;n&quot;, __LINE__); up(x); } while(0)
macro_line|#endif
DECL|function|ip6_masked_addrcmp
r_static
r_int
id|ip6_masked_addrcmp
c_func
(paren
r_struct
id|in6_addr
id|addr1
comma
r_struct
id|in6_addr
id|mask
comma
r_struct
id|in6_addr
id|addr2
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr1.s6_addr
(braket
id|i
)braket
op_amp
id|mask.s6_addr
(braket
id|i
)braket
)paren
op_ne
(paren
id|addr2.s6_addr
(braket
id|i
)braket
op_amp
id|mask.s6_addr
(braket
id|i
)braket
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* takes in current header and pointer to the header */
multiline_comment|/* if another header exists, sets hdrptr to the next header&n;   and returns the new header value, else returns 0 */
DECL|function|ip6_nexthdr
r_static
id|u_int8_t
id|ip6_nexthdr
c_func
(paren
id|u_int8_t
id|currenthdr
comma
id|u_int8_t
op_star
id|hdrptr
)paren
(brace
r_int
id|i
suffix:semicolon
id|u_int8_t
id|hdrlen
comma
id|nexthdr
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|currenthdr
)paren
(brace
r_case
id|IPPROTO_AH
suffix:colon
multiline_comment|/* whoever decided to do the length of AUTH for ipv6&n;&t;&t;in 32bit units unlike other headers should be beaten...&n;&t;&t;repeatedly...with a large stick...no, an even LARGER&n;&t;&t;stick...no, you&squot;re still not thinking big enough */
id|nexthdr
op_assign
op_star
id|hdrptr
suffix:semicolon
id|hdrlen
op_assign
id|hdrptr
(braket
id|i
)braket
op_star
l_int|4
op_plus
l_int|8
suffix:semicolon
id|hdrptr
op_assign
id|hdrptr
op_plus
id|hdrlen
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*stupid rfc2402 */
r_case
id|IPPROTO_DSTOPTS
suffix:colon
r_case
id|IPPROTO_ROUTING
suffix:colon
r_case
id|IPPROTO_HOPOPTS
suffix:colon
id|nexthdr
op_assign
op_star
id|hdrptr
suffix:semicolon
id|hdrlen
op_assign
id|hdrptr
(braket
l_int|1
)braket
op_star
l_int|8
op_plus
l_int|8
suffix:semicolon
id|hdrptr
op_assign
id|hdrptr
op_plus
id|hdrlen
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IPPROTO_FRAGMENT
suffix:colon
id|nexthdr
op_assign
op_star
id|hdrptr
suffix:semicolon
id|hdrptr
op_assign
id|hdrptr
op_plus
l_int|8
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|nexthdr
suffix:semicolon
)brace
multiline_comment|/* Returns whether matches rule or not. */
r_static
r_inline
r_int
DECL|function|ip6_packet_match
id|ip6_packet_match
c_func
(paren
r_const
r_struct
id|ipv6hdr
op_star
id|ipv6
comma
r_const
r_char
op_star
id|indev
comma
r_const
r_char
op_star
id|outdev
comma
r_const
r_struct
id|ip6t_ip6
op_star
id|ip6info
comma
r_int
id|isfrag
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|ret
suffix:semicolon
DECL|macro|FWINV
mdefine_line|#define FWINV(bool,invflg) ((bool) ^ !!(ip6info-&gt;invflags &amp; invflg))
r_if
c_cond
(paren
id|FWINV
c_func
(paren
id|ip6_masked_addrcmp
c_func
(paren
id|ipv6-&gt;saddr
comma
id|ip6info-&gt;smsk
comma
id|ip6info-&gt;src
)paren
comma
id|IP6T_INV_SRCIP
)paren
op_logical_or
id|FWINV
c_func
(paren
id|ip6_masked_addrcmp
c_func
(paren
id|ipv6-&gt;daddr
comma
id|ip6info-&gt;dmsk
comma
id|ip6info-&gt;dst
)paren
comma
id|IP6T_INV_DSTIP
)paren
)paren
(brace
id|dprintf
c_func
(paren
l_string|&quot;Source or dest mismatch.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;dprintf(&quot;SRC: %u. Mask: %u. Target: %u.%s&bslash;n&quot;, ip-&gt;saddr,&n;&t;&t;&t;ipinfo-&gt;smsk.s_addr, ipinfo-&gt;src.s_addr,&n;&t;&t;&t;ipinfo-&gt;invflags &amp; IP6T_INV_SRCIP ? &quot; (INV)&quot; : &quot;&quot;);&n;&t;&t;dprintf(&quot;DST: %u. Mask: %u. Target: %u.%s&bslash;n&quot;, ip-&gt;daddr,&n;&t;&t;&t;ipinfo-&gt;dmsk.s_addr, ipinfo-&gt;dst.s_addr,&n;&t;&t;&t;ipinfo-&gt;invflags &amp; IP6T_INV_DSTIP ? &quot; (INV)&quot; : &quot;&quot;);*/
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Look for ifname matches; this should unroll nicely. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|ret
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IFNAMSIZ
op_div
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ret
op_or_assign
(paren
(paren
(paren
r_const
r_int
r_int
op_star
)paren
id|indev
)paren
(braket
id|i
)braket
op_xor
(paren
(paren
r_const
r_int
r_int
op_star
)paren
id|ip6info-&gt;iniface
)paren
(braket
id|i
)braket
)paren
op_amp
(paren
(paren
r_const
r_int
r_int
op_star
)paren
id|ip6info-&gt;iniface_mask
)paren
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FWINV
c_func
(paren
id|ret
op_ne
l_int|0
comma
id|IP6T_INV_VIA_IN
)paren
)paren
(brace
id|dprintf
c_func
(paren
l_string|&quot;VIA in mismatch (%s vs %s).%s&bslash;n&quot;
comma
id|indev
comma
id|ip6info-&gt;iniface
comma
id|ip6info-&gt;invflags
op_amp
id|IP6T_INV_VIA_IN
ques
c_cond
l_string|&quot; (INV)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|ret
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IFNAMSIZ
op_div
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ret
op_or_assign
(paren
(paren
(paren
r_const
r_int
r_int
op_star
)paren
id|outdev
)paren
(braket
id|i
)braket
op_xor
(paren
(paren
r_const
r_int
r_int
op_star
)paren
id|ip6info-&gt;outiface
)paren
(braket
id|i
)braket
)paren
op_amp
(paren
(paren
r_const
r_int
r_int
op_star
)paren
id|ip6info-&gt;outiface_mask
)paren
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FWINV
c_func
(paren
id|ret
op_ne
l_int|0
comma
id|IP6T_INV_VIA_OUT
)paren
)paren
(brace
id|dprintf
c_func
(paren
l_string|&quot;VIA out mismatch (%s vs %s).%s&bslash;n&quot;
comma
id|outdev
comma
id|ip6info-&gt;outiface
comma
id|ip6info-&gt;invflags
op_amp
id|IP6T_INV_VIA_OUT
ques
c_cond
l_string|&quot; (INV)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ... might want to do something with class and flowlabel here ... */
multiline_comment|/* look for the desired protocol header */
r_if
c_cond
(paren
(paren
id|ip6info-&gt;flags
op_amp
id|IP6T_F_PROTO
)paren
)paren
(brace
id|u_int8_t
id|currenthdr
op_assign
id|ipv6-&gt;nexthdr
suffix:semicolon
id|u_int8_t
op_star
id|hdrptr
suffix:semicolon
id|hdrptr
op_assign
(paren
id|u_int8_t
op_star
)paren
(paren
id|ipv6
op_plus
l_int|1
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|ip6info-&gt;proto
op_eq
id|currenthdr
)paren
(brace
r_if
c_cond
(paren
id|ip6info-&gt;invflags
op_amp
id|IP6T_INV_PROTO
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|currenthdr
op_assign
id|ip6_nexthdr
c_func
(paren
id|currenthdr
comma
id|hdrptr
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|currenthdr
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ip6info-&gt;invflags
op_amp
id|IP6T_INV_PROTO
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* should be ip6 safe */
r_static
r_inline
r_int
DECL|function|ip6_checkentry
id|ip6_checkentry
c_func
(paren
r_const
r_struct
id|ip6t_ip6
op_star
id|ipv6
)paren
(brace
r_if
c_cond
(paren
id|ipv6-&gt;flags
op_amp
op_complement
id|IP6T_F_MASK
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Unknown flag bits set: %08X&bslash;n&quot;
comma
id|ipv6-&gt;flags
op_amp
op_complement
id|IP6T_F_MASK
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ipv6-&gt;invflags
op_amp
op_complement
id|IP6T_INV_MASK
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Unknown invflag bits set: %08X&bslash;n&quot;
comma
id|ipv6-&gt;invflags
op_amp
op_complement
id|IP6T_INV_MASK
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|ip6t_error
id|ip6t_error
c_func
(paren
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_int
r_int
id|hooknum
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_const
r_void
op_star
id|targinfo
comma
r_void
op_star
id|userinfo
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;ip6_tables: error: `%s&squot;&bslash;n&quot;
comma
(paren
r_char
op_star
)paren
id|targinfo
)paren
suffix:semicolon
r_return
id|NF_DROP
suffix:semicolon
)brace
r_static
r_inline
DECL|function|do_match
r_int
id|do_match
c_func
(paren
r_struct
id|ip6t_entry_match
op_star
id|m
comma
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_int
id|offset
comma
r_const
r_void
op_star
id|hdr
comma
id|u_int16_t
id|datalen
comma
r_int
op_star
id|hotdrop
)paren
(brace
multiline_comment|/* Stop iteration if it doesn&squot;t match */
r_if
c_cond
(paren
op_logical_neg
id|m-&gt;u.kernel.match
op_member_access_from_pointer
id|match
c_func
(paren
id|skb
comma
id|in
comma
id|out
comma
id|m-&gt;data
comma
id|offset
comma
id|hdr
comma
id|datalen
comma
id|hotdrop
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|ip6t_entry
op_star
DECL|function|get_entry
id|get_entry
c_func
(paren
r_void
op_star
id|base
comma
r_int
r_int
id|offset
)paren
(brace
r_return
(paren
r_struct
id|ip6t_entry
op_star
)paren
(paren
id|base
op_plus
id|offset
)paren
suffix:semicolon
)brace
multiline_comment|/* Returns one of the generic firewall policies, like NF_ACCEPT. */
r_int
r_int
DECL|function|ip6t_do_table
id|ip6t_do_table
c_func
(paren
r_struct
id|sk_buff
op_star
op_star
id|pskb
comma
r_int
r_int
id|hook
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_struct
id|ip6t_table
op_star
id|table
comma
r_void
op_star
id|userdata
)paren
(brace
r_static
r_const
r_char
id|nulldevname
(braket
id|IFNAMSIZ
)braket
op_assign
(brace
l_int|0
)brace
suffix:semicolon
id|u_int16_t
id|offset
op_assign
l_int|0
suffix:semicolon
r_struct
id|ipv6hdr
op_star
id|ipv6
suffix:semicolon
r_void
op_star
id|protohdr
suffix:semicolon
id|u_int16_t
id|datalen
suffix:semicolon
r_int
id|hotdrop
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initializing verdict to NF_DROP keeps gcc happy. */
r_int
r_int
id|verdict
op_assign
id|NF_DROP
suffix:semicolon
r_const
r_char
op_star
id|indev
comma
op_star
id|outdev
suffix:semicolon
r_void
op_star
id|table_base
suffix:semicolon
r_struct
id|ip6t_entry
op_star
id|e
comma
op_star
id|back
suffix:semicolon
multiline_comment|/* Initialization */
id|ipv6
op_assign
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.ipv6h
suffix:semicolon
id|protohdr
op_assign
(paren
id|u_int32_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|ipv6
op_plus
id|IPV6_HDR_LEN
)paren
suffix:semicolon
id|datalen
op_assign
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|len
op_minus
id|IPV6_HDR_LEN
suffix:semicolon
id|indev
op_assign
id|in
ques
c_cond
id|in-&gt;name
suffix:colon
id|nulldevname
suffix:semicolon
id|outdev
op_assign
id|out
ques
c_cond
id|out-&gt;name
suffix:colon
id|nulldevname
suffix:semicolon
multiline_comment|/* We handle fragments by dealing with the first fragment as&n;&t; * if it was a normal packet.  All other fragments are treated&n;&t; * normally, except that they will NEVER match rules that ask&n;&t; * things we don&squot;t know, ie. tcp syn flag or ports).  If the&n;&t; * rule is also a fragment-specific rule, non-fragments won&squot;t&n;&t; * match it. */
id|read_lock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|table-&gt;valid_hooks
op_amp
(paren
l_int|1
op_lshift
id|hook
)paren
)paren
suffix:semicolon
id|table_base
op_assign
(paren
r_void
op_star
)paren
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|entries
op_plus
id|TABLE_OFFSET
c_func
(paren
id|table
op_member_access_from_pointer
r_private
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|e
op_assign
id|get_entry
c_func
(paren
id|table_base
comma
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|hook_entry
(braket
id|hook
)braket
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
multiline_comment|/* Check noone else using our table */
r_if
c_cond
(paren
(paren
(paren
r_struct
id|ip6t_entry
op_star
)paren
id|table_base
)paren
op_member_access_from_pointer
id|comefrom
op_ne
l_int|0xdead57ac
op_logical_and
(paren
(paren
r_struct
id|ip6t_entry
op_star
)paren
id|table_base
)paren
op_member_access_from_pointer
id|comefrom
op_ne
l_int|0xeeeeeeec
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ASSERT: CPU #%u, %s comefrom(%p) = %X&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|table-&gt;name
comma
op_amp
(paren
(paren
r_struct
id|ip6t_entry
op_star
)paren
id|table_base
)paren
op_member_access_from_pointer
id|comefrom
comma
(paren
(paren
r_struct
id|ip6t_entry
op_star
)paren
id|table_base
)paren
op_member_access_from_pointer
id|comefrom
)paren
suffix:semicolon
)brace
(paren
(paren
r_struct
id|ip6t_entry
op_star
)paren
id|table_base
)paren
op_member_access_from_pointer
id|comefrom
op_assign
l_int|0x57acc001
suffix:semicolon
macro_line|#endif
multiline_comment|/* For return from builtin chain */
id|back
op_assign
id|get_entry
c_func
(paren
id|table_base
comma
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|underflow
(braket
id|hook
)braket
)paren
suffix:semicolon
r_do
(brace
id|IP_NF_ASSERT
c_func
(paren
id|e
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|back
)paren
suffix:semicolon
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nfcache
op_or_assign
id|e-&gt;nfcache
suffix:semicolon
r_if
c_cond
(paren
id|ip6_packet_match
c_func
(paren
id|ipv6
comma
id|indev
comma
id|outdev
comma
op_amp
id|e-&gt;ipv6
comma
id|offset
)paren
)paren
(brace
r_struct
id|ip6t_entry_target
op_star
id|t
suffix:semicolon
r_if
c_cond
(paren
id|IP6T_MATCH_ITERATE
c_func
(paren
id|e
comma
id|do_match
comma
op_star
id|pskb
comma
id|in
comma
id|out
comma
id|offset
comma
id|protohdr
comma
id|datalen
comma
op_amp
id|hotdrop
)paren
op_ne
l_int|0
)paren
r_goto
id|no_match
suffix:semicolon
id|ADD_COUNTER
c_func
(paren
id|e-&gt;counters
comma
id|ntohs
c_func
(paren
id|ipv6-&gt;payload_len
)paren
op_plus
id|IPV6_HDR_LEN
comma
l_int|1
)paren
suffix:semicolon
id|t
op_assign
id|ip6t_get_target
c_func
(paren
id|e
)paren
suffix:semicolon
id|IP_NF_ASSERT
c_func
(paren
id|t-&gt;u.kernel.target
)paren
suffix:semicolon
multiline_comment|/* Standard target? */
r_if
c_cond
(paren
op_logical_neg
id|t-&gt;u.kernel.target-&gt;target
)paren
(brace
r_int
id|v
suffix:semicolon
id|v
op_assign
(paren
(paren
r_struct
id|ip6t_standard_target
op_star
)paren
id|t
)paren
op_member_access_from_pointer
id|verdict
suffix:semicolon
r_if
c_cond
(paren
id|v
OL
l_int|0
)paren
(brace
multiline_comment|/* Pop from stack? */
r_if
c_cond
(paren
id|v
op_ne
id|IP6T_RETURN
)paren
(brace
id|verdict
op_assign
(paren
r_int
)paren
(paren
op_minus
id|v
)paren
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|e
op_assign
id|back
suffix:semicolon
id|back
op_assign
id|get_entry
c_func
(paren
id|table_base
comma
id|back-&gt;comefrom
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|table_base
op_plus
id|v
op_ne
(paren
r_void
op_star
)paren
id|e
op_plus
id|e-&gt;next_offset
)paren
(brace
multiline_comment|/* Save old back ptr in next entry */
r_struct
id|ip6t_entry
op_star
id|next
op_assign
(paren
r_void
op_star
)paren
id|e
op_plus
id|e-&gt;next_offset
suffix:semicolon
id|next-&gt;comefrom
op_assign
(paren
r_void
op_star
)paren
id|back
op_minus
id|table_base
suffix:semicolon
multiline_comment|/* set back pointer to next entry */
id|back
op_assign
id|next
suffix:semicolon
)brace
id|e
op_assign
id|get_entry
c_func
(paren
id|table_base
comma
id|v
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Targets which reenter must return&n;                                   abs. verdicts */
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
(paren
(paren
r_struct
id|ip6t_entry
op_star
)paren
id|table_base
)paren
op_member_access_from_pointer
id|comefrom
op_assign
l_int|0xeeeeeeec
suffix:semicolon
macro_line|#endif
id|verdict
op_assign
id|t-&gt;u.kernel.target
op_member_access_from_pointer
id|target
c_func
(paren
id|pskb
comma
id|hook
comma
id|in
comma
id|out
comma
id|t-&gt;data
comma
id|userdata
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
r_if
c_cond
(paren
(paren
(paren
r_struct
id|ip6t_entry
op_star
)paren
id|table_base
)paren
op_member_access_from_pointer
id|comefrom
op_ne
l_int|0xeeeeeeec
op_logical_and
id|verdict
op_eq
id|IP6T_CONTINUE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Target %s reentered!&bslash;n&quot;
comma
id|t-&gt;u.kernel.target-&gt;name
)paren
suffix:semicolon
id|verdict
op_assign
id|NF_DROP
suffix:semicolon
)brace
(paren
(paren
r_struct
id|ip6t_entry
op_star
)paren
id|table_base
)paren
op_member_access_from_pointer
id|comefrom
op_assign
l_int|0x57acc001
suffix:semicolon
macro_line|#endif
multiline_comment|/* Target might have changed stuff. */
id|ipv6
op_assign
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|nh.ipv6h
suffix:semicolon
id|protohdr
op_assign
(paren
id|u_int32_t
op_star
)paren
id|ipv6
op_plus
id|IPV6_HDR_LEN
suffix:semicolon
id|datalen
op_assign
(paren
op_star
id|pskb
)paren
op_member_access_from_pointer
id|len
op_minus
id|IPV6_HDR_LEN
suffix:semicolon
r_if
c_cond
(paren
id|verdict
op_eq
id|IP6T_CONTINUE
)paren
id|e
op_assign
(paren
r_void
op_star
)paren
id|e
op_plus
id|e-&gt;next_offset
suffix:semicolon
r_else
multiline_comment|/* Verdict */
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|no_match
suffix:colon
id|e
op_assign
(paren
r_void
op_star
)paren
id|e
op_plus
id|e-&gt;next_offset
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|hotdrop
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
(paren
(paren
r_struct
id|ip6t_entry
op_star
)paren
id|table_base
)paren
op_member_access_from_pointer
id|comefrom
op_assign
l_int|0xdead57ac
suffix:semicolon
macro_line|#endif
id|read_unlock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_ALLOW_ALL
r_return
id|NF_ACCEPT
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|hotdrop
)paren
r_return
id|NF_DROP
suffix:semicolon
r_else
r_return
id|verdict
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* If it succeeds, returns element and locks mutex */
r_static
r_inline
r_void
op_star
DECL|function|find_inlist_lock_noload
id|find_inlist_lock_noload
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_const
r_char
op_star
id|name
comma
r_int
op_star
id|error
comma
r_struct
id|semaphore
op_star
id|mutex
)paren
(brace
r_void
op_star
id|ret
suffix:semicolon
macro_line|#if 1
id|duprintf
c_func
(paren
l_string|&quot;find_inlist: searching for `%s&squot; in %s.&bslash;n&quot;
comma
id|name
comma
id|head
op_eq
op_amp
id|ip6t_target
ques
c_cond
l_string|&quot;ip6t_target&quot;
suffix:colon
id|head
op_eq
op_amp
id|ip6t_match
ques
c_cond
l_string|&quot;ip6t_match&quot;
suffix:colon
id|head
op_eq
op_amp
id|ip6t_tables
ques
c_cond
l_string|&quot;ip6t_tables&quot;
suffix:colon
l_string|&quot;UNKNOWN&quot;
)paren
suffix:semicolon
macro_line|#endif
op_star
id|error
op_assign
id|down_interruptible
c_func
(paren
id|mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|error
op_ne
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|ret
op_assign
id|list_named_find
c_func
(paren
id|head
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
op_star
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|up
c_func
(paren
id|mutex
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_KMOD
DECL|macro|find_inlist_lock
mdefine_line|#define find_inlist_lock(h,n,p,e,m) find_inlist_lock_noload((h),(n),(e),(m))
macro_line|#else
r_static
r_void
op_star
DECL|function|find_inlist_lock
id|find_inlist_lock
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|prefix
comma
r_int
op_star
id|error
comma
r_struct
id|semaphore
op_star
id|mutex
)paren
(brace
r_void
op_star
id|ret
suffix:semicolon
id|ret
op_assign
id|find_inlist_lock_noload
c_func
(paren
id|head
comma
id|name
comma
id|error
comma
id|mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
r_char
id|modulename
(braket
id|IP6T_FUNCTION_MAXNAMELEN
op_plus
id|strlen
c_func
(paren
id|prefix
)paren
op_plus
l_int|1
)braket
suffix:semicolon
id|strcpy
c_func
(paren
id|modulename
comma
id|prefix
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|modulename
comma
id|name
)paren
suffix:semicolon
id|duprintf
c_func
(paren
l_string|&quot;find_inlist: loading `%s&squot;.&bslash;n&quot;
comma
id|modulename
)paren
suffix:semicolon
id|request_module
c_func
(paren
id|modulename
)paren
suffix:semicolon
id|ret
op_assign
id|find_inlist_lock_noload
c_func
(paren
id|head
comma
id|name
comma
id|error
comma
id|mutex
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif
r_static
r_inline
r_struct
id|ip6t_table
op_star
DECL|function|find_table_lock
id|find_table_lock
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
op_star
id|error
comma
r_struct
id|semaphore
op_star
id|mutex
)paren
(brace
r_return
id|find_inlist_lock
c_func
(paren
op_amp
id|ip6t_tables
comma
id|name
comma
l_string|&quot;ip6table_&quot;
comma
id|error
comma
id|mutex
)paren
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|ip6t_match
op_star
DECL|function|find_match_lock
id|find_match_lock
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
op_star
id|error
comma
r_struct
id|semaphore
op_star
id|mutex
)paren
(brace
r_return
id|find_inlist_lock
c_func
(paren
op_amp
id|ip6t_match
comma
id|name
comma
l_string|&quot;ip6t_&quot;
comma
id|error
comma
id|mutex
)paren
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|ip6t_target
op_star
DECL|function|find_target_lock
id|find_target_lock
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
op_star
id|error
comma
r_struct
id|semaphore
op_star
id|mutex
)paren
(brace
r_return
id|find_inlist_lock
c_func
(paren
op_amp
id|ip6t_target
comma
id|name
comma
l_string|&quot;ip6t_&quot;
comma
id|error
comma
id|mutex
)paren
suffix:semicolon
)brace
multiline_comment|/* All zeroes == unconditional rule. */
r_static
r_inline
r_int
DECL|function|unconditional
id|unconditional
c_func
(paren
r_const
r_struct
id|ip6t_ip6
op_star
id|ipv6
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
op_star
id|ipv6
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
(paren
r_char
op_star
)paren
id|ipv6
)paren
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
r_return
(paren
id|i
op_eq
r_sizeof
(paren
op_star
id|ipv6
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Figures out from what hook each rule can be called: returns 0 if&n;   there are loops.  Puts hook bitmask in comefrom. */
r_static
r_int
DECL|function|mark_source_chains
id|mark_source_chains
c_func
(paren
r_struct
id|ip6t_table_info
op_star
id|newinfo
comma
r_int
r_int
id|valid_hooks
)paren
(brace
r_int
r_int
id|hook
suffix:semicolon
multiline_comment|/* No recursion; use packet counter to save back ptrs (reset&n;&t;   to 0 as we leave), and comefrom to save source hook bitmask */
r_for
c_loop
(paren
id|hook
op_assign
l_int|0
suffix:semicolon
id|hook
OL
id|NF_IP6_NUMHOOKS
suffix:semicolon
id|hook
op_increment
)paren
(brace
r_int
r_int
id|pos
op_assign
id|newinfo-&gt;hook_entry
(braket
id|hook
)braket
suffix:semicolon
r_struct
id|ip6t_entry
op_star
id|e
op_assign
(paren
r_struct
id|ip6t_entry
op_star
)paren
(paren
id|newinfo-&gt;entries
op_plus
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|valid_hooks
op_amp
(paren
l_int|1
op_lshift
id|hook
)paren
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Set initial back pointer. */
id|e-&gt;counters.pcnt
op_assign
id|pos
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|ip6t_standard_target
op_star
id|t
op_assign
(paren
r_void
op_star
)paren
id|ip6t_get_target
c_func
(paren
id|e
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;comefrom
op_amp
(paren
l_int|1
op_lshift
id|NF_IP6_NUMHOOKS
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;iptables: loop hook %u pos %u %08X.&bslash;n&quot;
comma
id|hook
comma
id|pos
comma
id|e-&gt;comefrom
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|e-&gt;comefrom
op_or_assign
(paren
(paren
l_int|1
op_lshift
id|hook
)paren
op_or
(paren
l_int|1
op_lshift
id|NF_IP6_NUMHOOKS
)paren
)paren
suffix:semicolon
multiline_comment|/* Unconditional return/END. */
r_if
c_cond
(paren
id|e-&gt;target_offset
op_eq
r_sizeof
(paren
r_struct
id|ip6t_entry
)paren
op_logical_and
(paren
id|strcmp
c_func
(paren
id|t-&gt;target.u.user.name
comma
id|IP6T_STANDARD_TARGET
)paren
op_eq
l_int|0
)paren
op_logical_and
id|t-&gt;verdict
OL
l_int|0
op_logical_and
id|unconditional
c_func
(paren
op_amp
id|e-&gt;ipv6
)paren
)paren
(brace
r_int
r_int
id|oldpos
comma
id|size
suffix:semicolon
multiline_comment|/* Return: backtrack through the last&n;&t;&t;&t;&t;   big jump. */
r_do
(brace
id|e-&gt;comefrom
op_xor_assign
(paren
l_int|1
op_lshift
id|NF_IP6_NUMHOOKS
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IP_FIREWALL_USER
r_if
c_cond
(paren
id|e-&gt;comefrom
op_amp
(paren
l_int|1
op_lshift
id|NF_IP6_NUMHOOKS
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Back unset &quot;
l_string|&quot;on hook %u &quot;
l_string|&quot;rule %u&bslash;n&quot;
comma
id|hook
comma
id|pos
)paren
suffix:semicolon
)brace
macro_line|#endif
id|oldpos
op_assign
id|pos
suffix:semicolon
id|pos
op_assign
id|e-&gt;counters.pcnt
suffix:semicolon
id|e-&gt;counters.pcnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We&squot;re at the start. */
r_if
c_cond
(paren
id|pos
op_eq
id|oldpos
)paren
r_goto
id|next
suffix:semicolon
id|e
op_assign
(paren
r_struct
id|ip6t_entry
op_star
)paren
(paren
id|newinfo-&gt;entries
op_plus
id|pos
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|oldpos
op_eq
id|pos
op_plus
id|e-&gt;next_offset
)paren
suffix:semicolon
multiline_comment|/* Move along one */
id|size
op_assign
id|e-&gt;next_offset
suffix:semicolon
id|e
op_assign
(paren
r_struct
id|ip6t_entry
op_star
)paren
(paren
id|newinfo-&gt;entries
op_plus
id|pos
op_plus
id|size
)paren
suffix:semicolon
id|e-&gt;counters.pcnt
op_assign
id|pos
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
)brace
r_else
(brace
r_int
id|newpos
op_assign
id|t-&gt;verdict
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|t-&gt;target.u.user.name
comma
id|IP6T_STANDARD_TARGET
)paren
op_eq
l_int|0
op_logical_and
id|newpos
op_ge
l_int|0
)paren
(brace
multiline_comment|/* This a jump; chase it. */
id|duprintf
c_func
(paren
l_string|&quot;Jump rule %u -&gt; %u&bslash;n&quot;
comma
id|pos
comma
id|newpos
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ... this is a fallthru */
id|newpos
op_assign
id|pos
op_plus
id|e-&gt;next_offset
suffix:semicolon
)brace
id|e
op_assign
(paren
r_struct
id|ip6t_entry
op_star
)paren
(paren
id|newinfo-&gt;entries
op_plus
id|newpos
)paren
suffix:semicolon
id|e-&gt;counters.pcnt
op_assign
id|pos
suffix:semicolon
id|pos
op_assign
id|newpos
suffix:semicolon
)brace
)brace
id|next
suffix:colon
id|duprintf
c_func
(paren
l_string|&quot;Finished chain %u&bslash;n&quot;
comma
id|hook
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|cleanup_match
id|cleanup_match
c_func
(paren
r_struct
id|ip6t_entry_match
op_star
id|m
comma
r_int
r_int
op_star
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
op_logical_and
(paren
op_star
id|i
)paren
op_decrement
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;u.kernel.match-&gt;destroy
)paren
id|m-&gt;u.kernel.match
op_member_access_from_pointer
id|destroy
c_func
(paren
id|m-&gt;data
comma
id|m-&gt;u.match_size
op_minus
r_sizeof
(paren
op_star
id|m
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;u.kernel.match-&gt;me
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|m-&gt;u.kernel.match-&gt;me
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|standard_check
id|standard_check
c_func
(paren
r_const
r_struct
id|ip6t_entry_target
op_star
id|t
comma
r_int
r_int
id|max_offset
)paren
(brace
r_struct
id|ip6t_standard_target
op_star
id|targ
op_assign
(paren
r_void
op_star
)paren
id|t
suffix:semicolon
multiline_comment|/* Check standard info. */
r_if
c_cond
(paren
id|t-&gt;u.target_size
op_ne
id|IP6T_ALIGN
c_func
(paren
r_sizeof
(paren
r_struct
id|ip6t_standard_target
)paren
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;standard_check: target size %u != %u&bslash;n&quot;
comma
id|t-&gt;u.target_size
comma
id|IP6T_ALIGN
c_func
(paren
r_sizeof
(paren
r_struct
id|ip6t_standard_target
)paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|targ-&gt;verdict
op_ge
l_int|0
op_logical_and
id|targ-&gt;verdict
OG
id|max_offset
op_minus
r_sizeof
(paren
r_struct
id|ip6t_entry
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;ip6t_standard_check: bad verdict (%i)&bslash;n&quot;
comma
id|targ-&gt;verdict
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|targ-&gt;verdict
OL
op_minus
id|NF_MAX_VERDICT
op_minus
l_int|1
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;ip6t_standard_check: bad negative verdict (%i)&bslash;n&quot;
comma
id|targ-&gt;verdict
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|check_match
id|check_match
c_func
(paren
r_struct
id|ip6t_entry_match
op_star
id|m
comma
r_const
r_char
op_star
id|name
comma
r_const
r_struct
id|ip6t_ip6
op_star
id|ipv6
comma
r_int
r_int
id|hookmask
comma
r_int
r_int
op_star
id|i
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|ip6t_match
op_star
id|match
suffix:semicolon
id|match
op_assign
id|find_match_lock
c_func
(paren
id|m-&gt;u.user.name
comma
op_amp
id|ret
comma
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|match
)paren
(brace
singleline_comment|//&t;&t;duprintf(&quot;check_match: `%s&squot; not found&bslash;n&quot;, m-&gt;u.name);
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|match-&gt;me
)paren
id|__MOD_INC_USE_COUNT
c_func
(paren
id|match-&gt;me
)paren
suffix:semicolon
id|m-&gt;u.kernel.match
op_assign
id|match
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;u.kernel.match-&gt;checkentry
op_logical_and
op_logical_neg
id|m-&gt;u.kernel.match
op_member_access_from_pointer
id|checkentry
c_func
(paren
id|name
comma
id|ipv6
comma
id|m-&gt;data
comma
id|m-&gt;u.match_size
op_minus
r_sizeof
(paren
op_star
id|m
)paren
comma
id|hookmask
)paren
)paren
(brace
r_if
c_cond
(paren
id|m-&gt;u.kernel.match-&gt;me
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|m-&gt;u.kernel.match-&gt;me
)paren
suffix:semicolon
id|duprintf
c_func
(paren
l_string|&quot;ip_tables: check failed for `%s&squot;.&bslash;n&quot;
comma
id|m-&gt;u.kernel.match-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
(paren
op_star
id|i
)paren
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ip6t_standard_target
r_static
r_struct
id|ip6t_target
id|ip6t_standard_target
suffix:semicolon
r_static
r_inline
r_int
DECL|function|check_entry
id|check_entry
c_func
(paren
r_struct
id|ip6t_entry
op_star
id|e
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|size
comma
r_int
r_int
op_star
id|i
)paren
(brace
r_struct
id|ip6t_entry_target
op_star
id|t
suffix:semicolon
r_struct
id|ip6t_target
op_star
id|target
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
r_int
id|j
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ip6_checkentry
c_func
(paren
op_amp
id|e-&gt;ipv6
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;ip_tables: ip check failed %p %s.&bslash;n&quot;
comma
id|e
comma
id|name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|j
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|IP6T_MATCH_ITERATE
c_func
(paren
id|e
comma
id|check_match
comma
id|name
comma
op_amp
id|e-&gt;ipv6
comma
id|e-&gt;comefrom
comma
op_amp
id|j
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_goto
id|cleanup_matches
suffix:semicolon
id|t
op_assign
id|ip6t_get_target
c_func
(paren
id|e
)paren
suffix:semicolon
id|target
op_assign
id|find_target_lock
c_func
(paren
id|t-&gt;u.user.name
comma
op_amp
id|ret
comma
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|target
)paren
(brace
singleline_comment|//&t;&t;duprintf(&quot;check_entry: `%s&squot; not found&bslash;n&quot;, t-&gt;u.name);
r_goto
id|cleanup_matches
suffix:semicolon
)brace
r_if
c_cond
(paren
id|target-&gt;me
)paren
id|__MOD_INC_USE_COUNT
c_func
(paren
id|target-&gt;me
)paren
suffix:semicolon
id|t-&gt;u.kernel.target
op_assign
id|target
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;u.kernel.target
op_eq
op_amp
id|ip6t_standard_target
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|standard_check
c_func
(paren
id|t
comma
id|size
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|cleanup_matches
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|t-&gt;u.kernel.target-&gt;checkentry
op_logical_and
op_logical_neg
id|t-&gt;u.kernel.target
op_member_access_from_pointer
id|checkentry
c_func
(paren
id|name
comma
id|e
comma
id|t-&gt;data
comma
id|t-&gt;u.target_size
op_minus
r_sizeof
(paren
op_star
id|t
)paren
comma
id|e-&gt;comefrom
)paren
)paren
(brace
r_if
c_cond
(paren
id|t-&gt;u.kernel.target-&gt;me
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|t-&gt;u.kernel.target-&gt;me
)paren
suffix:semicolon
id|duprintf
c_func
(paren
l_string|&quot;ip_tables: check failed for `%s&squot;.&bslash;n&quot;
comma
id|t-&gt;u.kernel.target-&gt;name
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|cleanup_matches
suffix:semicolon
)brace
(paren
op_star
id|i
)paren
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|cleanup_matches
suffix:colon
id|IP6T_MATCH_ITERATE
c_func
(paren
id|e
comma
id|cleanup_match
comma
op_amp
id|j
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|check_entry_size_and_hooks
id|check_entry_size_and_hooks
c_func
(paren
r_struct
id|ip6t_entry
op_star
id|e
comma
r_struct
id|ip6t_table_info
op_star
id|newinfo
comma
r_int
r_char
op_star
id|base
comma
r_int
r_char
op_star
id|limit
comma
r_const
r_int
r_int
op_star
id|hook_entries
comma
r_const
r_int
r_int
op_star
id|underflows
comma
r_int
r_int
op_star
id|i
)paren
(brace
r_int
r_int
id|h
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|e
op_mod
id|__alignof__
c_func
(paren
r_struct
id|ip6t_entry
)paren
op_ne
l_int|0
op_logical_or
(paren
r_int
r_char
op_star
)paren
id|e
op_plus
r_sizeof
(paren
r_struct
id|ip6t_entry
)paren
op_ge
id|limit
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Bad offset %p&bslash;n&quot;
comma
id|e
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e-&gt;next_offset
OL
r_sizeof
(paren
r_struct
id|ip6t_entry
)paren
op_plus
r_sizeof
(paren
r_struct
id|ip6t_entry_target
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;checking: element %p size %u&bslash;n&quot;
comma
id|e
comma
id|e-&gt;next_offset
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Check hooks &amp; underflows */
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|NF_IP6_NUMHOOKS
suffix:semicolon
id|h
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_char
op_star
)paren
id|e
op_minus
id|base
op_eq
id|hook_entries
(braket
id|h
)braket
)paren
id|newinfo-&gt;hook_entry
(braket
id|h
)braket
op_assign
id|hook_entries
(braket
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_char
op_star
)paren
id|e
op_minus
id|base
op_eq
id|underflows
(braket
id|h
)braket
)paren
id|newinfo-&gt;underflow
(braket
id|h
)braket
op_assign
id|underflows
(braket
id|h
)braket
suffix:semicolon
)brace
multiline_comment|/* FIXME: underflows must be unconditional, standard verdicts&n;           &lt; 0 (not IP6T_RETURN). --RR */
multiline_comment|/* Clear counters and comefrom */
id|e-&gt;counters
op_assign
(paren
(paren
r_struct
id|ip6t_counters
)paren
(brace
l_int|0
comma
l_int|0
)brace
)paren
suffix:semicolon
id|e-&gt;comefrom
op_assign
l_int|0
suffix:semicolon
(paren
op_star
id|i
)paren
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|cleanup_entry
id|cleanup_entry
c_func
(paren
r_struct
id|ip6t_entry
op_star
id|e
comma
r_int
r_int
op_star
id|i
)paren
(brace
r_struct
id|ip6t_entry_target
op_star
id|t
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
(paren
op_star
id|i
)paren
op_decrement
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Cleanup all matches */
id|IP6T_MATCH_ITERATE
c_func
(paren
id|e
comma
id|cleanup_match
comma
l_int|NULL
)paren
suffix:semicolon
id|t
op_assign
id|ip6t_get_target
c_func
(paren
id|e
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;u.kernel.target-&gt;destroy
)paren
id|t-&gt;u.kernel.target
op_member_access_from_pointer
id|destroy
c_func
(paren
id|t-&gt;data
comma
id|t-&gt;u.target_size
op_minus
r_sizeof
(paren
op_star
id|t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;u.kernel.target-&gt;me
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|t-&gt;u.kernel.target-&gt;me
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Checks and translates the user-supplied table segment (held in&n;   newinfo) */
r_static
r_int
DECL|function|translate_table
id|translate_table
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|valid_hooks
comma
r_struct
id|ip6t_table_info
op_star
id|newinfo
comma
r_int
r_int
id|size
comma
r_int
r_int
id|number
comma
r_const
r_int
r_int
op_star
id|hook_entries
comma
r_const
r_int
r_int
op_star
id|underflows
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|newinfo-&gt;size
op_assign
id|size
suffix:semicolon
id|newinfo-&gt;number
op_assign
id|number
suffix:semicolon
multiline_comment|/* Init all hooks to impossible value. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NF_IP6_NUMHOOKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|newinfo-&gt;hook_entry
(braket
id|i
)braket
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|newinfo-&gt;underflow
(braket
id|i
)braket
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
)brace
id|duprintf
c_func
(paren
l_string|&quot;translate_table: size %u&bslash;n&quot;
comma
id|newinfo-&gt;size
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Walk through entries, checking offsets. */
id|ret
op_assign
id|IP6T_ENTRY_ITERATE
c_func
(paren
id|newinfo-&gt;entries
comma
id|newinfo-&gt;size
comma
id|check_entry_size_and_hooks
comma
id|newinfo
comma
id|newinfo-&gt;entries
comma
id|newinfo-&gt;entries
op_plus
id|size
comma
id|hook_entries
comma
id|underflows
comma
op_amp
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|number
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;translate_table: %u not %u entries&bslash;n&quot;
comma
id|i
comma
id|number
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Check hooks all assigned */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NF_IP6_NUMHOOKS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Only hooks which are valid */
r_if
c_cond
(paren
op_logical_neg
(paren
id|valid_hooks
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|newinfo-&gt;hook_entry
(braket
id|i
)braket
op_eq
l_int|0xFFFFFFFF
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Invalid hook entry %u %u&bslash;n&quot;
comma
id|i
comma
id|hook_entries
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newinfo-&gt;underflow
(braket
id|i
)braket
op_eq
l_int|0xFFFFFFFF
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Invalid underflow %u %u&bslash;n&quot;
comma
id|i
comma
id|underflows
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|mark_source_chains
c_func
(paren
id|newinfo
comma
id|valid_hooks
)paren
)paren
r_return
op_minus
id|ELOOP
suffix:semicolon
multiline_comment|/* Finally, each sanity check must pass */
id|i
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|IP6T_ENTRY_ITERATE
c_func
(paren
id|newinfo-&gt;entries
comma
id|newinfo-&gt;size
comma
id|check_entry
comma
id|name
comma
id|size
comma
op_amp
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|IP6T_ENTRY_ITERATE
c_func
(paren
id|newinfo-&gt;entries
comma
id|newinfo-&gt;size
comma
id|cleanup_entry
comma
op_amp
id|i
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* And one copy for every other CPU */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
(brace
id|memcpy
c_func
(paren
id|newinfo-&gt;entries
op_plus
id|SMP_ALIGN
c_func
(paren
id|newinfo-&gt;size
op_star
id|i
)paren
comma
id|newinfo-&gt;entries
comma
id|SMP_ALIGN
c_func
(paren
id|newinfo-&gt;size
)paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
r_struct
id|ip6t_table_info
op_star
DECL|function|replace_table
id|replace_table
c_func
(paren
r_struct
id|ip6t_table
op_star
id|table
comma
r_int
r_int
id|num_counters
comma
r_struct
id|ip6t_table_info
op_star
id|newinfo
comma
r_int
op_star
id|error
)paren
(brace
r_struct
id|ip6t_table_info
op_star
id|oldinfo
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
(brace
r_struct
id|ip6t_entry
op_star
id|table_base
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
(brace
id|table_base
op_assign
(paren
r_void
op_star
)paren
id|newinfo-&gt;entries
op_plus
id|TABLE_OFFSET
c_func
(paren
id|newinfo
comma
id|i
)paren
suffix:semicolon
id|table_base-&gt;comefrom
op_assign
l_int|0xdead57ac
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* Do the substitution. */
id|write_lock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Check inside lock: is the old number correct? */
r_if
c_cond
(paren
id|num_counters
op_ne
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|number
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;num_counters != table-&gt;private-&gt;number (%u/%u)&bslash;n&quot;
comma
id|num_counters
comma
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|number
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
op_star
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|oldinfo
op_assign
id|table
op_member_access_from_pointer
r_private
suffix:semicolon
id|table
op_member_access_from_pointer
r_private
op_assign
id|newinfo
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
r_return
id|oldinfo
suffix:semicolon
)brace
multiline_comment|/* Gets counters. */
r_static
r_inline
r_int
DECL|function|add_entry_to_counter
id|add_entry_to_counter
c_func
(paren
r_const
r_struct
id|ip6t_entry
op_star
id|e
comma
r_struct
id|ip6t_counters
id|total
(braket
)braket
comma
r_int
r_int
op_star
id|i
)paren
(brace
id|ADD_COUNTER
c_func
(paren
id|total
(braket
op_star
id|i
)braket
comma
id|e-&gt;counters.bcnt
comma
id|e-&gt;counters.pcnt
)paren
suffix:semicolon
(paren
op_star
id|i
)paren
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|get_counters
id|get_counters
c_func
(paren
r_const
r_struct
id|ip6t_table_info
op_star
id|t
comma
r_struct
id|ip6t_counters
id|counters
(braket
)braket
)paren
(brace
r_int
r_int
id|cpu
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|smp_num_cpus
suffix:semicolon
id|cpu
op_increment
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|IP6T_ENTRY_ITERATE
c_func
(paren
id|t-&gt;entries
op_plus
id|TABLE_OFFSET
c_func
(paren
id|t
comma
id|cpu
)paren
comma
id|t-&gt;size
comma
id|add_entry_to_counter
comma
id|counters
comma
op_amp
id|i
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|copy_entries_to_user
id|copy_entries_to_user
c_func
(paren
r_int
r_int
id|total_size
comma
r_struct
id|ip6t_table
op_star
id|table
comma
r_void
op_star
id|userptr
)paren
(brace
r_int
r_int
id|off
comma
id|num
comma
id|countersize
suffix:semicolon
r_struct
id|ip6t_entry
op_star
id|e
suffix:semicolon
r_struct
id|ip6t_counters
op_star
id|counters
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We need atomic snapshot of counters: rest doesn&squot;t change&n;&t;   (other than comefrom, which userspace doesn&squot;t care&n;&t;   about). */
id|countersize
op_assign
r_sizeof
(paren
r_struct
id|ip6t_counters
)paren
op_star
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|number
suffix:semicolon
id|counters
op_assign
id|vmalloc
c_func
(paren
id|countersize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|counters
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* First, sum counters... */
id|memset
c_func
(paren
id|counters
comma
l_int|0
comma
id|countersize
)paren
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
id|get_counters
c_func
(paren
id|table
op_member_access_from_pointer
r_private
comma
id|counters
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|table-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* ... then copy entire thing from CPU 0... */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|userptr
comma
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|entries
comma
id|total_size
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free_counters
suffix:semicolon
)brace
multiline_comment|/* FIXME: use iterator macros --RR */
multiline_comment|/* ... then go back and fix counters and names */
r_for
c_loop
(paren
id|off
op_assign
l_int|0
comma
id|num
op_assign
l_int|0
suffix:semicolon
id|off
OL
id|total_size
suffix:semicolon
id|off
op_add_assign
id|e-&gt;next_offset
comma
id|num
op_increment
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_struct
id|ip6t_entry_match
op_star
id|m
suffix:semicolon
r_struct
id|ip6t_entry_target
op_star
id|t
suffix:semicolon
id|e
op_assign
(paren
r_struct
id|ip6t_entry
op_star
)paren
(paren
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|entries
op_plus
id|off
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|userptr
op_plus
id|off
op_plus
m_offsetof
(paren
r_struct
id|ip6t_entry
comma
id|counters
)paren
comma
op_amp
id|counters
(braket
id|num
)braket
comma
r_sizeof
(paren
id|counters
(braket
id|num
)braket
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free_counters
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
r_sizeof
(paren
r_struct
id|ip6t_entry
)paren
suffix:semicolon
id|i
OL
id|e-&gt;target_offset
suffix:semicolon
id|i
op_add_assign
id|m-&gt;u.match_size
)paren
(brace
id|m
op_assign
(paren
r_void
op_star
)paren
id|e
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|userptr
op_plus
id|off
op_plus
id|i
op_plus
m_offsetof
(paren
r_struct
id|ip6t_entry_match
comma
id|u.user.name
)paren
comma
id|m-&gt;u.kernel.match-&gt;name
comma
id|strlen
c_func
(paren
id|m-&gt;u.kernel.match-&gt;name
)paren
op_plus
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free_counters
suffix:semicolon
)brace
)brace
id|t
op_assign
id|ip6t_get_target
c_func
(paren
id|e
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|userptr
op_plus
id|off
op_plus
id|e-&gt;target_offset
op_plus
m_offsetof
(paren
r_struct
id|ip6t_entry_target
comma
id|u.user.name
)paren
comma
id|t-&gt;u.kernel.target-&gt;name
comma
id|strlen
c_func
(paren
id|t-&gt;u.kernel.target-&gt;name
)paren
op_plus
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free_counters
suffix:semicolon
)brace
)brace
id|free_counters
suffix:colon
id|vfree
c_func
(paren
id|counters
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|get_entries
id|get_entries
c_func
(paren
r_const
r_struct
id|ip6t_get_entries
op_star
id|entries
comma
r_struct
id|ip6t_get_entries
op_star
id|uptr
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|ip6t_table
op_star
id|t
suffix:semicolon
id|t
op_assign
id|find_table_lock
c_func
(paren
id|entries-&gt;name
comma
op_amp
id|ret
comma
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;t-&gt;private-&gt;number = %u&bslash;n&quot;
comma
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|number
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entries-&gt;size
op_eq
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|size
)paren
id|ret
op_assign
id|copy_entries_to_user
c_func
(paren
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|size
comma
id|t
comma
id|uptr-&gt;entrytable
)paren
suffix:semicolon
r_else
(brace
id|duprintf
c_func
(paren
l_string|&quot;get_entries: I&squot;ve got %u not %u!&bslash;n&quot;
comma
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|size
comma
id|entries-&gt;size
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
)brace
r_else
id|duprintf
c_func
(paren
l_string|&quot;get_entries: Can&squot;t find %s!&bslash;n&quot;
comma
id|entries-&gt;name
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|do_replace
id|do_replace
c_func
(paren
r_void
op_star
id|user
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|ip6t_replace
id|tmp
suffix:semicolon
r_struct
id|ip6t_table
op_star
id|t
suffix:semicolon
r_struct
id|ip6t_table_info
op_star
id|newinfo
comma
op_star
id|oldinfo
suffix:semicolon
r_struct
id|ip6t_counters
op_star
id|counters
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|user
comma
r_sizeof
(paren
id|tmp
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|newinfo
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ip6t_table_info
)paren
op_plus
id|SMP_ALIGN
c_func
(paren
id|tmp.size
)paren
op_star
id|smp_num_cpus
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newinfo
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|newinfo-&gt;entries
comma
id|user
op_plus
r_sizeof
(paren
id|tmp
)paren
comma
id|tmp.size
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free_newinfo
suffix:semicolon
)brace
id|counters
op_assign
id|vmalloc
c_func
(paren
id|tmp.num_counters
op_star
r_sizeof
(paren
r_struct
id|ip6t_counters
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|counters
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|free_newinfo
suffix:semicolon
)brace
id|memset
c_func
(paren
id|counters
comma
l_int|0
comma
id|tmp.num_counters
op_star
r_sizeof
(paren
r_struct
id|ip6t_counters
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|translate_table
c_func
(paren
id|tmp.name
comma
id|tmp.valid_hooks
comma
id|newinfo
comma
id|tmp.size
comma
id|tmp.num_entries
comma
id|tmp.hook_entry
comma
id|tmp.underflow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_goto
id|free_newinfo_counters
suffix:semicolon
id|duprintf
c_func
(paren
l_string|&quot;ip_tables: Translated table&bslash;n&quot;
)paren
suffix:semicolon
id|t
op_assign
id|find_table_lock
c_func
(paren
id|tmp.name
comma
op_amp
id|ret
comma
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
r_goto
id|free_newinfo_counters_untrans
suffix:semicolon
multiline_comment|/* You lied! */
r_if
c_cond
(paren
id|tmp.valid_hooks
op_ne
id|t-&gt;valid_hooks
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Valid hook crap: %08X vs %08X&bslash;n&quot;
comma
id|tmp.valid_hooks
comma
id|t-&gt;valid_hooks
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|free_newinfo_counters_untrans_unlock
suffix:semicolon
)brace
id|oldinfo
op_assign
id|replace_table
c_func
(paren
id|t
comma
id|tmp.num_counters
comma
id|newinfo
comma
op_amp
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|oldinfo
)paren
r_goto
id|free_newinfo_counters_untrans_unlock
suffix:semicolon
multiline_comment|/* Get the old counters. */
id|get_counters
c_func
(paren
id|oldinfo
comma
id|counters
)paren
suffix:semicolon
multiline_comment|/* Decrease module usage counts and free resource */
id|IP6T_ENTRY_ITERATE
c_func
(paren
id|oldinfo-&gt;entries
comma
id|oldinfo-&gt;size
comma
id|cleanup_entry
comma
l_int|NULL
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|oldinfo
)paren
suffix:semicolon
multiline_comment|/* Silent error: too late now. */
id|copy_to_user
c_func
(paren
id|tmp.counters
comma
id|counters
comma
r_sizeof
(paren
r_struct
id|ip6t_counters
)paren
op_star
id|tmp.num_counters
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|counters
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|free_newinfo_counters_untrans_unlock
suffix:colon
id|up
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
id|free_newinfo_counters_untrans
suffix:colon
id|IP6T_ENTRY_ITERATE
c_func
(paren
id|newinfo-&gt;entries
comma
id|newinfo-&gt;size
comma
id|cleanup_entry
comma
l_int|NULL
)paren
suffix:semicolon
id|free_newinfo_counters
suffix:colon
id|vfree
c_func
(paren
id|counters
)paren
suffix:semicolon
id|free_newinfo
suffix:colon
id|vfree
c_func
(paren
id|newinfo
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* We&squot;re lazy, and add to the first CPU; overflow works its fey magic&n; * and everything is OK. */
r_static
r_inline
r_int
DECL|function|add_counter_to_entry
id|add_counter_to_entry
c_func
(paren
r_struct
id|ip6t_entry
op_star
id|e
comma
r_const
r_struct
id|ip6t_counters
id|addme
(braket
)braket
comma
r_int
r_int
op_star
id|i
)paren
(brace
macro_line|#if 0
id|duprintf
c_func
(paren
l_string|&quot;add_counter: Entry %u %lu/%lu + %lu/%lu&bslash;n&quot;
comma
op_star
id|i
comma
(paren
r_int
r_int
r_int
)paren
id|e-&gt;counters.pcnt
comma
(paren
r_int
r_int
r_int
)paren
id|e-&gt;counters.bcnt
comma
(paren
r_int
r_int
r_int
)paren
id|addme
(braket
op_star
id|i
)braket
dot
id|pcnt
comma
(paren
r_int
r_int
r_int
)paren
id|addme
(braket
op_star
id|i
)braket
dot
id|bcnt
)paren
suffix:semicolon
macro_line|#endif
id|ADD_COUNTER
c_func
(paren
id|e-&gt;counters
comma
id|addme
(braket
op_star
id|i
)braket
dot
id|bcnt
comma
id|addme
(braket
op_star
id|i
)braket
dot
id|pcnt
)paren
suffix:semicolon
(paren
op_star
id|i
)paren
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|do_add_counters
id|do_add_counters
c_func
(paren
r_void
op_star
id|user
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_struct
id|ip6t_counters_info
id|tmp
comma
op_star
id|paddc
suffix:semicolon
r_struct
id|ip6t_table
op_star
id|t
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|user
comma
r_sizeof
(paren
id|tmp
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|tmp
)paren
op_plus
id|tmp.num_counters
op_star
r_sizeof
(paren
r_struct
id|ip6t_counters
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|paddc
op_assign
id|vmalloc
c_func
(paren
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|paddc
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|paddc
comma
id|user
comma
id|len
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free
suffix:semicolon
)brace
id|t
op_assign
id|find_table_lock
c_func
(paren
id|tmp.name
comma
op_amp
id|ret
comma
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
r_goto
id|free
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|t-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|number
op_ne
id|paddc-&gt;num_counters
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|unlock_up_free
suffix:semicolon
)brace
id|i
op_assign
l_int|0
suffix:semicolon
id|IP6T_ENTRY_ITERATE
c_func
(paren
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|entries
comma
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|size
comma
id|add_counter_to_entry
comma
id|paddc-&gt;counters
comma
op_amp
id|i
)paren
suffix:semicolon
id|unlock_up_free
suffix:colon
id|write_unlock_bh
c_func
(paren
op_amp
id|t-&gt;lock
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
id|free
suffix:colon
id|vfree
c_func
(paren
id|paddc
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|do_ip6t_set_ctl
id|do_ip6t_set_ctl
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_void
op_star
id|user
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|IP6T_SO_SET_REPLACE
suffix:colon
id|ret
op_assign
id|do_replace
c_func
(paren
id|user
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IP6T_SO_SET_ADD_COUNTERS
suffix:colon
id|ret
op_assign
id|do_add_counters
c_func
(paren
id|user
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|duprintf
c_func
(paren
l_string|&quot;do_ip6t_set_ctl:  unknown request %i&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|do_ip6t_get_ctl
id|do_ip6t_get_ctl
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_void
op_star
id|user
comma
r_int
op_star
id|len
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|IP6T_SO_GET_INFO
suffix:colon
(brace
r_char
id|name
(braket
id|IP6T_TABLE_MAXNAMELEN
)braket
suffix:semicolon
r_struct
id|ip6t_table
op_star
id|t
suffix:semicolon
r_if
c_cond
(paren
op_star
id|len
op_ne
r_sizeof
(paren
r_struct
id|ip6t_getinfo
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;length %u != %u&bslash;n&quot;
comma
op_star
id|len
comma
r_sizeof
(paren
r_struct
id|ip6t_getinfo
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|name
comma
id|user
comma
r_sizeof
(paren
id|name
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|t
op_assign
id|find_table_lock
c_func
(paren
id|name
comma
op_amp
id|ret
comma
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
r_struct
id|ip6t_getinfo
id|info
suffix:semicolon
id|info.valid_hooks
op_assign
id|t-&gt;valid_hooks
suffix:semicolon
id|memcpy
c_func
(paren
id|info.hook_entry
comma
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|hook_entry
comma
r_sizeof
(paren
id|info.hook_entry
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|info.underflow
comma
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|underflow
comma
r_sizeof
(paren
id|info.underflow
)paren
)paren
suffix:semicolon
id|info.num_entries
op_assign
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|number
suffix:semicolon
id|info.size
op_assign
id|t
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|size
suffix:semicolon
id|strcpy
c_func
(paren
id|info.name
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|user
comma
op_amp
id|info
comma
op_star
id|len
)paren
op_ne
l_int|0
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_else
id|ret
op_assign
l_int|0
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|IP6T_SO_GET_ENTRIES
suffix:colon
(brace
r_struct
id|ip6t_get_entries
id|get
suffix:semicolon
r_if
c_cond
(paren
op_star
id|len
OL
r_sizeof
(paren
id|get
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;get_entries: %u &lt; %u&bslash;n&quot;
comma
op_star
id|len
comma
r_sizeof
(paren
id|get
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|get
comma
id|user
comma
r_sizeof
(paren
id|get
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|len
op_ne
r_sizeof
(paren
r_struct
id|ip6t_get_entries
)paren
op_plus
id|get.size
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;get_entries: %u != %u&bslash;n&quot;
comma
op_star
id|len
comma
r_sizeof
(paren
r_struct
id|ip6t_get_entries
)paren
op_plus
id|get.size
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
id|ret
op_assign
id|get_entries
c_func
(paren
op_amp
id|get
comma
id|user
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|duprintf
c_func
(paren
l_string|&quot;do_ip6t_get_ctl: unknown request %i&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Registration hooks for targets. */
r_int
DECL|function|ip6t_register_target
id|ip6t_register_target
c_func
(paren
r_struct
id|ip6t_target
op_star
id|target
)paren
(brace
r_int
id|ret
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|ret
op_assign
id|down_interruptible
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list_named_insert
c_func
(paren
op_amp
id|ip6t_target
comma
id|target
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;ip6t_register_target: `%s&squot; already in list!&bslash;n&quot;
comma
id|target-&gt;name
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_void
DECL|function|ip6t_unregister_target
id|ip6t_unregister_target
c_func
(paren
r_struct
id|ip6t_target
op_star
id|target
)paren
(brace
id|down
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|ip6t_target
comma
id|target
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
r_int
DECL|function|ip6t_register_match
id|ip6t_register_match
c_func
(paren
r_struct
id|ip6t_match
op_star
id|match
)paren
(brace
r_int
id|ret
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|ret
op_assign
id|down_interruptible
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list_named_insert
c_func
(paren
op_amp
id|ip6t_match
comma
id|match
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;ip6t_register_match: `%s&squot; already in list!&bslash;n&quot;
comma
id|match-&gt;name
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_void
DECL|function|ip6t_unregister_match
id|ip6t_unregister_match
c_func
(paren
r_struct
id|ip6t_match
op_star
id|match
)paren
(brace
id|down
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|ip6t_match
comma
id|match
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|function|ip6t_register_table
r_int
id|ip6t_register_table
c_func
(paren
r_struct
id|ip6t_table
op_star
id|table
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|ip6t_table_info
op_star
id|newinfo
suffix:semicolon
r_static
r_struct
id|ip6t_table_info
id|bootstrap
op_assign
(brace
l_int|0
comma
l_int|0
comma
(brace
l_int|0
)brace
comma
(brace
l_int|0
)brace
comma
(brace
)brace
comma
(brace
)brace
)brace
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|newinfo
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ip6t_table_info
)paren
op_plus
id|SMP_ALIGN
c_func
(paren
id|table-&gt;table-&gt;size
)paren
op_star
id|smp_num_cpus
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newinfo
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|newinfo-&gt;entries
comma
id|table-&gt;table-&gt;entries
comma
id|table-&gt;table-&gt;size
)paren
suffix:semicolon
id|ret
op_assign
id|translate_table
c_func
(paren
id|table-&gt;name
comma
id|table-&gt;valid_hooks
comma
id|newinfo
comma
id|table-&gt;table-&gt;size
comma
id|table-&gt;table-&gt;num_entries
comma
id|table-&gt;table-&gt;hook_entry
comma
id|table-&gt;table-&gt;underflow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|vfree
c_func
(paren
id|newinfo
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|ret
op_assign
id|down_interruptible
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|vfree
c_func
(paren
id|newinfo
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t autoload: we&squot;d eat our tail... */
r_if
c_cond
(paren
id|list_named_find
c_func
(paren
op_amp
id|ip6t_tables
comma
id|table-&gt;name
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|free_unlock
suffix:semicolon
)brace
multiline_comment|/* Simplifies replace_table code. */
id|table
op_member_access_from_pointer
r_private
op_assign
op_amp
id|bootstrap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|replace_table
c_func
(paren
id|table
comma
l_int|0
comma
id|newinfo
comma
op_amp
id|ret
)paren
)paren
r_goto
id|free_unlock
suffix:semicolon
id|duprintf
c_func
(paren
l_string|&quot;table-&gt;private-&gt;number = %u&bslash;n&quot;
comma
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|number
)paren
suffix:semicolon
id|table-&gt;lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
id|list_prepend
c_func
(paren
op_amp
id|ip6t_tables
comma
id|table
)paren
suffix:semicolon
id|unlock
suffix:colon
id|up
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
id|free_unlock
suffix:colon
id|vfree
c_func
(paren
id|newinfo
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_goto
id|unlock
suffix:semicolon
)brace
DECL|function|ip6t_unregister_table
r_void
id|ip6t_unregister_table
c_func
(paren
r_struct
id|ip6t_table
op_star
id|table
)paren
(brace
id|down
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
id|LIST_DELETE
c_func
(paren
op_amp
id|ip6t_tables
comma
id|table
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
multiline_comment|/* Decrease module usage counts and free resources */
id|IP6T_ENTRY_ITERATE
c_func
(paren
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|entries
comma
id|table
op_member_access_from_pointer
r_private
op_member_access_from_pointer
id|size
comma
id|cleanup_entry
comma
l_int|NULL
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|table
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/* Returns 1 if the port is matched by the range, 0 otherwise */
r_static
r_inline
r_int
DECL|function|port_match
id|port_match
c_func
(paren
id|u_int16_t
id|min
comma
id|u_int16_t
id|max
comma
id|u_int16_t
id|port
comma
r_int
id|invert
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
(paren
id|port
op_ge
id|min
op_logical_and
id|port
op_le
id|max
)paren
op_xor
id|invert
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|tcp_find_option
id|tcp_find_option
c_func
(paren
id|u_int8_t
id|option
comma
r_const
r_struct
id|tcphdr
op_star
id|tcp
comma
id|u_int16_t
id|datalen
comma
r_int
id|invert
comma
r_int
op_star
id|hotdrop
)paren
(brace
r_int
r_int
id|i
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
r_const
id|u_int8_t
op_star
id|opt
op_assign
(paren
id|u_int8_t
op_star
)paren
id|tcp
suffix:semicolon
id|duprintf
c_func
(paren
l_string|&quot;tcp_match: finding option&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* If we don&squot;t have the whole header, drop packet. */
r_if
c_cond
(paren
id|tcp-&gt;doff
op_star
l_int|4
OG
id|datalen
)paren
(brace
op_star
id|hotdrop
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OL
id|tcp-&gt;doff
op_star
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|opt
(braket
id|i
)braket
op_eq
id|option
)paren
r_return
op_logical_neg
id|invert
suffix:semicolon
r_if
c_cond
(paren
id|opt
(braket
id|i
)braket
OL
l_int|2
)paren
id|i
op_increment
suffix:semicolon
r_else
id|i
op_add_assign
id|opt
(braket
id|i
op_plus
l_int|1
)braket
ques
c_cond
suffix:colon
l_int|1
suffix:semicolon
)brace
r_return
id|invert
suffix:semicolon
)brace
r_static
r_int
DECL|function|tcp_match
id|tcp_match
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_const
r_void
op_star
id|matchinfo
comma
r_int
id|offset
comma
r_const
r_void
op_star
id|hdr
comma
id|u_int16_t
id|datalen
comma
r_int
op_star
id|hotdrop
)paren
(brace
r_const
r_struct
id|tcphdr
op_star
id|tcp
op_assign
id|hdr
suffix:semicolon
r_const
r_struct
id|ip6t_tcp
op_star
id|tcpinfo
op_assign
id|matchinfo
suffix:semicolon
multiline_comment|/* To quote Alan:&n;&n;&t;   Don&squot;t allow a fragment of TCP 8 bytes in. Nobody normal&n;&t;   causes this. Its a cracker trying to break in by doing a&n;&t;   flag overwrite to pass the direction checks.&n;&t;*/
r_if
c_cond
(paren
id|offset
op_eq
l_int|1
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Dropping evil TCP offset=1 frag.&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|hotdrop
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
op_logical_and
id|datalen
OL
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
(brace
multiline_comment|/* We&squot;ve been asked to examine this packet, and we&n;&t;&t;   can&squot;t.  Hence, no choice but to drop. */
id|duprintf
c_func
(paren
l_string|&quot;Dropping evil TCP offset=0 tinygram.&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|hotdrop
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* FIXME: Try tcp doff &gt;&gt; packet len against various stacks --RR */
DECL|macro|FWINVTCP
mdefine_line|#define FWINVTCP(bool,invflg) ((bool) ^ !!(tcpinfo-&gt;invflags &amp; invflg))
multiline_comment|/* Must not be a fragment. */
r_return
op_logical_neg
id|offset
op_logical_and
id|port_match
c_func
(paren
id|tcpinfo-&gt;spts
(braket
l_int|0
)braket
comma
id|tcpinfo-&gt;spts
(braket
l_int|1
)braket
comma
id|ntohs
c_func
(paren
id|tcp-&gt;source
)paren
comma
op_logical_neg
op_logical_neg
(paren
id|tcpinfo-&gt;invflags
op_amp
id|IP6T_TCP_INV_SRCPT
)paren
)paren
op_logical_and
id|port_match
c_func
(paren
id|tcpinfo-&gt;dpts
(braket
l_int|0
)braket
comma
id|tcpinfo-&gt;dpts
(braket
l_int|1
)braket
comma
id|ntohs
c_func
(paren
id|tcp-&gt;dest
)paren
comma
op_logical_neg
op_logical_neg
(paren
id|tcpinfo-&gt;invflags
op_amp
id|IP6T_TCP_INV_DSTPT
)paren
)paren
op_logical_and
id|FWINVTCP
c_func
(paren
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|tcp
)paren
(braket
l_int|13
)braket
op_amp
id|tcpinfo-&gt;flg_mask
)paren
op_eq
id|tcpinfo-&gt;flg_cmp
comma
id|IP6T_TCP_INV_FLAGS
)paren
op_logical_and
(paren
op_logical_neg
id|tcpinfo-&gt;option
op_logical_or
id|tcp_find_option
c_func
(paren
id|tcpinfo-&gt;option
comma
id|tcp
comma
id|datalen
comma
id|tcpinfo-&gt;invflags
op_amp
id|IP6T_TCP_INV_OPTION
comma
id|hotdrop
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Called when user tries to insert an entry of this type. */
r_static
r_int
DECL|function|tcp_checkentry
id|tcp_checkentry
c_func
(paren
r_const
r_char
op_star
id|tablename
comma
r_const
r_struct
id|ip6t_ip6
op_star
id|ipv6
comma
r_void
op_star
id|matchinfo
comma
r_int
r_int
id|matchsize
comma
r_int
r_int
id|hook_mask
)paren
(brace
r_const
r_struct
id|ip6t_tcp
op_star
id|tcpinfo
op_assign
id|matchinfo
suffix:semicolon
multiline_comment|/* Must specify proto == TCP, and no unknown invflags */
r_return
id|ipv6-&gt;proto
op_eq
id|IPPROTO_TCP
op_logical_and
op_logical_neg
(paren
id|ipv6-&gt;invflags
op_amp
id|IP6T_INV_PROTO
)paren
op_logical_and
id|matchsize
op_eq
id|IP6T_ALIGN
c_func
(paren
r_sizeof
(paren
r_struct
id|ip6t_tcp
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|tcpinfo-&gt;invflags
op_amp
op_complement
id|IP6T_TCP_INV_MASK
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|udp_match
id|udp_match
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_const
r_void
op_star
id|matchinfo
comma
r_int
id|offset
comma
r_const
r_void
op_star
id|hdr
comma
id|u_int16_t
id|datalen
comma
r_int
op_star
id|hotdrop
)paren
(brace
r_const
r_struct
id|udphdr
op_star
id|udp
op_assign
id|hdr
suffix:semicolon
r_const
r_struct
id|ip6t_udp
op_star
id|udpinfo
op_assign
id|matchinfo
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
op_logical_and
id|datalen
OL
r_sizeof
(paren
r_struct
id|udphdr
)paren
)paren
(brace
multiline_comment|/* We&squot;ve been asked to examine this packet, and we&n;&t;&t;   can&squot;t.  Hence, no choice but to drop. */
id|duprintf
c_func
(paren
l_string|&quot;Dropping evil UDP tinygram.&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|hotdrop
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Must not be a fragment. */
r_return
op_logical_neg
id|offset
op_logical_and
id|port_match
c_func
(paren
id|udpinfo-&gt;spts
(braket
l_int|0
)braket
comma
id|udpinfo-&gt;spts
(braket
l_int|1
)braket
comma
id|ntohs
c_func
(paren
id|udp-&gt;source
)paren
comma
op_logical_neg
op_logical_neg
(paren
id|udpinfo-&gt;invflags
op_amp
id|IP6T_UDP_INV_SRCPT
)paren
)paren
op_logical_and
id|port_match
c_func
(paren
id|udpinfo-&gt;dpts
(braket
l_int|0
)braket
comma
id|udpinfo-&gt;dpts
(braket
l_int|1
)braket
comma
id|ntohs
c_func
(paren
id|udp-&gt;dest
)paren
comma
op_logical_neg
op_logical_neg
(paren
id|udpinfo-&gt;invflags
op_amp
id|IP6T_UDP_INV_DSTPT
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Called when user tries to insert an entry of this type. */
r_static
r_int
DECL|function|udp_checkentry
id|udp_checkentry
c_func
(paren
r_const
r_char
op_star
id|tablename
comma
r_const
r_struct
id|ip6t_ip6
op_star
id|ipv6
comma
r_void
op_star
id|matchinfo
comma
r_int
r_int
id|matchinfosize
comma
r_int
r_int
id|hook_mask
)paren
(brace
r_const
r_struct
id|ip6t_udp
op_star
id|udpinfo
op_assign
id|matchinfo
suffix:semicolon
multiline_comment|/* Must specify proto == UDP, and no unknown invflags */
r_if
c_cond
(paren
id|ipv6-&gt;proto
op_ne
id|IPPROTO_UDP
op_logical_or
(paren
id|ipv6-&gt;invflags
op_amp
id|IP6T_INV_PROTO
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;ip6t_udp: Protocol %u != %u&bslash;n&quot;
comma
id|ipv6-&gt;proto
comma
id|IPPROTO_UDP
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|matchinfosize
op_ne
id|IP6T_ALIGN
c_func
(paren
r_sizeof
(paren
r_struct
id|ip6t_udp
)paren
)paren
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;ip6t_udp: matchsize %u != %u&bslash;n&quot;
comma
id|matchinfosize
comma
id|IP6T_ALIGN
c_func
(paren
r_sizeof
(paren
r_struct
id|ip6t_udp
)paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|udpinfo-&gt;invflags
op_amp
op_complement
id|IP6T_UDP_INV_MASK
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;ip6t_udp: unknown flags %X&bslash;n&quot;
comma
id|udpinfo-&gt;invflags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Returns 1 if the type and code is matched by the range, 0 otherwise */
r_static
r_inline
r_int
DECL|function|icmp_type_code_match
id|icmp_type_code_match
c_func
(paren
id|u_int8_t
id|test_type
comma
id|u_int8_t
id|min_code
comma
id|u_int8_t
id|max_code
comma
id|u_int8_t
id|type
comma
id|u_int8_t
id|code
comma
r_int
id|invert
)paren
(brace
r_return
(paren
id|type
op_eq
id|test_type
op_logical_and
id|code
op_ge
id|min_code
op_logical_and
id|code
op_le
id|max_code
)paren
op_xor
id|invert
suffix:semicolon
)brace
r_static
r_int
DECL|function|icmp_match
id|icmp_match
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_const
r_struct
id|net_device
op_star
id|in
comma
r_const
r_struct
id|net_device
op_star
id|out
comma
r_const
r_void
op_star
id|matchinfo
comma
r_int
id|offset
comma
r_const
r_void
op_star
id|hdr
comma
id|u_int16_t
id|datalen
comma
r_int
op_star
id|hotdrop
)paren
(brace
r_const
r_struct
id|icmphdr
op_star
id|icmp
op_assign
id|hdr
suffix:semicolon
r_const
r_struct
id|ip6t_icmp
op_star
id|icmpinfo
op_assign
id|matchinfo
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
op_logical_and
id|datalen
OL
l_int|2
)paren
(brace
multiline_comment|/* We&squot;ve been asked to examine this packet, and we&n;&t;&t;   can&squot;t.  Hence, no choice but to drop. */
id|duprintf
c_func
(paren
l_string|&quot;Dropping evil ICMP tinygram.&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|hotdrop
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Must not be a fragment. */
r_return
op_logical_neg
id|offset
op_logical_and
id|icmp_type_code_match
c_func
(paren
id|icmpinfo-&gt;type
comma
id|icmpinfo-&gt;code
(braket
l_int|0
)braket
comma
id|icmpinfo-&gt;code
(braket
l_int|1
)braket
comma
id|icmp-&gt;type
comma
id|icmp-&gt;code
comma
op_logical_neg
op_logical_neg
(paren
id|icmpinfo-&gt;invflags
op_amp
id|IP6T_ICMP_INV
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Called when user tries to insert an entry of this type. */
r_static
r_int
DECL|function|icmp_checkentry
id|icmp_checkentry
c_func
(paren
r_const
r_char
op_star
id|tablename
comma
r_const
r_struct
id|ip6t_ip6
op_star
id|ipv6
comma
r_void
op_star
id|matchinfo
comma
r_int
r_int
id|matchsize
comma
r_int
r_int
id|hook_mask
)paren
(brace
r_const
r_struct
id|ip6t_icmp
op_star
id|icmpinfo
op_assign
id|matchinfo
suffix:semicolon
multiline_comment|/* Must specify proto == ICMP, and no unknown invflags */
r_return
id|ipv6-&gt;proto
op_eq
id|IPPROTO_ICMP
op_logical_and
op_logical_neg
(paren
id|ipv6-&gt;invflags
op_amp
id|IP6T_INV_PROTO
)paren
op_logical_and
id|matchsize
op_eq
id|IP6T_ALIGN
c_func
(paren
r_sizeof
(paren
r_struct
id|ip6t_icmp
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|icmpinfo-&gt;invflags
op_amp
op_complement
id|IP6T_ICMP_INV
)paren
suffix:semicolon
)brace
multiline_comment|/* The built-in targets: standard (NULL) and error. */
DECL|variable|ip6t_standard_target
r_static
r_struct
id|ip6t_target
id|ip6t_standard_target
op_assign
(brace
(brace
l_int|NULL
comma
l_int|NULL
)brace
comma
id|IP6T_STANDARD_TARGET
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|ip6t_error_target
r_static
r_struct
id|ip6t_target
id|ip6t_error_target
op_assign
(brace
(brace
l_int|NULL
comma
l_int|NULL
)brace
comma
id|IP6T_ERROR_TARGET
comma
id|ip6t_error
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|ip6t_sockopts
r_static
r_struct
id|nf_sockopt_ops
id|ip6t_sockopts
op_assign
(brace
(brace
l_int|NULL
comma
l_int|NULL
)brace
comma
id|PF_INET6
comma
id|IP6T_BASE_CTL
comma
id|IP6T_SO_SET_MAX
op_plus
l_int|1
comma
id|do_ip6t_set_ctl
comma
id|IP6T_BASE_CTL
comma
id|IP6T_SO_GET_MAX
op_plus
l_int|1
comma
id|do_ip6t_get_ctl
comma
l_int|0
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|tcp_matchstruct
r_static
r_struct
id|ip6t_match
id|tcp_matchstruct
op_assign
(brace
(brace
l_int|NULL
comma
l_int|NULL
)brace
comma
l_string|&quot;tcp&quot;
comma
op_amp
id|tcp_match
comma
op_amp
id|tcp_checkentry
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|udp_matchstruct
r_static
r_struct
id|ip6t_match
id|udp_matchstruct
op_assign
(brace
(brace
l_int|NULL
comma
l_int|NULL
)brace
comma
l_string|&quot;udp&quot;
comma
op_amp
id|udp_match
comma
op_amp
id|udp_checkentry
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|icmp_matchstruct
r_static
r_struct
id|ip6t_match
id|icmp_matchstruct
op_assign
(brace
(brace
l_int|NULL
comma
l_int|NULL
)brace
comma
l_string|&quot;icmp&quot;
comma
op_amp
id|icmp_match
comma
op_amp
id|icmp_checkentry
comma
l_int|NULL
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|print_name
r_static
r_inline
r_int
id|print_name
c_func
(paren
r_const
r_struct
id|ip6t_table
op_star
id|t
comma
id|off_t
id|start_offset
comma
r_char
op_star
id|buffer
comma
r_int
id|length
comma
id|off_t
op_star
id|pos
comma
r_int
r_int
op_star
id|count
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|count
)paren
op_increment
op_ge
id|start_offset
)paren
(brace
r_int
r_int
id|namelen
suffix:semicolon
id|namelen
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
op_star
id|pos
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|t-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pos
op_plus
id|namelen
OG
id|length
)paren
(brace
multiline_comment|/* Stop iterating */
r_return
l_int|1
suffix:semicolon
)brace
op_star
id|pos
op_add_assign
id|namelen
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ip6t_get_tables
r_static
r_int
id|ip6t_get_tables
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|ip6t_mutex
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|LIST_FIND
c_func
(paren
op_amp
id|ip6t_tables
comma
id|print_name
comma
r_struct
id|ip6t_table
op_star
comma
id|offset
comma
id|buffer
comma
id|length
comma
op_amp
id|pos
comma
op_amp
id|count
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
multiline_comment|/* `start&squot; hack - see fs/proc/generic.c line ~105 */
op_star
id|start
op_assign
(paren
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|count
op_minus
id|offset
)paren
suffix:semicolon
r_return
id|pos
suffix:semicolon
)brace
macro_line|#endif /*CONFIG_PROC_FS*/
DECL|function|init
r_static
r_int
id|__init
id|init
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* Noone else will be downing sem now, so we won&squot;t sleep */
id|down
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
id|list_append
c_func
(paren
op_amp
id|ip6t_target
comma
op_amp
id|ip6t_standard_target
)paren
suffix:semicolon
id|list_append
c_func
(paren
op_amp
id|ip6t_target
comma
op_amp
id|ip6t_error_target
)paren
suffix:semicolon
id|list_append
c_func
(paren
op_amp
id|ip6t_match
comma
op_amp
id|tcp_matchstruct
)paren
suffix:semicolon
id|list_append
c_func
(paren
op_amp
id|ip6t_match
comma
op_amp
id|udp_matchstruct
)paren
suffix:semicolon
id|list_append
c_func
(paren
op_amp
id|ip6t_match
comma
op_amp
id|icmp_matchstruct
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ip6t_mutex
)paren
suffix:semicolon
multiline_comment|/* Register setsockopt */
id|ret
op_assign
id|nf_register_sockopt
c_func
(paren
op_amp
id|ip6t_sockopts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|duprintf
c_func
(paren
l_string|&quot;Unable to register sockopts.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
r_if
c_cond
(paren
op_logical_neg
id|proc_net_create
c_func
(paren
l_string|&quot;ip6_tables_names&quot;
comma
l_int|0
comma
id|ip6t_get_tables
)paren
)paren
(brace
id|nf_unregister_sockopt
c_func
(paren
op_amp
id|ip6t_sockopts
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;ip6_tables: (c)2000 Netfilter core team&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fini
r_static
r_void
id|__exit
id|fini
c_func
(paren
r_void
)paren
(brace
id|nf_unregister_sockopt
c_func
(paren
op_amp
id|ip6t_sockopts
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|proc_net_remove
c_func
(paren
l_string|&quot;ip6_tables_names&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|init
id|module_init
c_func
(paren
id|init
)paren
suffix:semicolon
DECL|variable|fini
id|module_exit
c_func
(paren
id|fini
)paren
suffix:semicolon
eof
