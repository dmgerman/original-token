multiline_comment|/* udp.c */
multiline_comment|/*&n;    Copyright (C) 1992  Ross Biro&n;&n;    This program is free software; you can redistribute it and/or modify&n;    it under the terms of the GNU General Public License as published by&n;    the Free Software Foundation; either version 2, or (at your option)&n;    any later version.&n;&n;    This program is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;    GNU General Public License for more details.&n;&n;    You should have received a copy of the GNU General Public License&n;    along with this program; if not, write to the Free Software&n;    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. &n;&n;    The Author may be reached as bir7@leland.stanford.edu or&n;    C/O Department of Mathematics; Stanford University; Stanford, CA 94305&n;*/
multiline_comment|/* $Id: udp.c,v 0.8.4.12 1993/01/26 22:04:00 bir7 Exp $ */
multiline_comment|/* $Log: udp.c,v $&n; * Revision 0.8.4.12  1993/01/26  22:04:00  bir7&n; * Added support for proc fs.&n; *&n; * Revision 0.8.4.11  1993/01/23  18:00:11  bir7&n; * added volatile keyword.&n; *&n; * Revision 0.8.4.10  1993/01/22  23:21:38  bir7&n; * Merged with 99 pl4&n; *&n; * Revision 0.8.4.9  1992/12/12  19:25:04  bir7&n; * cleaned up Log messages.&n; *&n; * Revision 0.8.4.8  1992/12/12  01:50:49  bir7&n; * Changed connect.&n; *&n; * Revision 0.8.4.7  1992/12/05  21:35:53  bir7&n; * Added more debuggin code.&n; *&n; * Revision 0.8.4.6  1992/12/03  19:52:20  bir7&n; * fixed problems in udp_error.&n; *&n; * Revision 0.8.4.5  1992/11/18  15:38:03  bir7&n; * fixed minor problem in waiting for memory.&n; *&n; * Revision 0.8.4.3  1992/11/15  14:55:30  bir7&n; * Fixed ctrl-h and added NULL checking to print_uh&n; *&n; * Revision 0.8.4.2  1992/11/10  10:38:48  bir7&n; * Change free_s to kfree_s and accidently changed free_skb to kfree_skb.&n; *&n; * Revision 0.8.4.1  1992/11/10  00:17:18  bir7&n; * version change only.&n; *&n; * Revision 0.8.3.5  1992/11/10  00:14:47  bir7&n; * Changed malloc to kmalloc and added Id and Log&n; * */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;netinet/in.h&gt;
macro_line|#include &quot;timer.h&quot;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/termios.h&gt; /* for ioctl&squot;s */
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &quot;../kern_sock.h&quot; /* for PRINTK */
macro_line|#include &quot;udp.h&quot;
macro_line|#include &quot;icmp.h&quot;
DECL|macro|UDP_DEBUG
macro_line|#undef UDP_DEBUG
macro_line|#ifdef PRINTK
DECL|macro|PRINTK
macro_line|#undef PRINTK
macro_line|#endif
macro_line|#ifdef UDP_DEBUG
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x) printk x
macro_line|#else
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x) /**/
macro_line|#endif
DECL|macro|min
mdefine_line|#define min(a,b) ((a)&lt;(b)?(a):(b))
r_static
r_void
DECL|function|print_uh
id|print_uh
c_func
(paren
r_struct
id|udp_header
op_star
id|uh
)paren
(brace
r_if
c_cond
(paren
id|uh
op_eq
l_int|NULL
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;(NULL)&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|PRINTK
c_func
(paren
(paren
l_string|&quot;source = %d, dest = %d&bslash;n&quot;
comma
id|net16
c_func
(paren
id|uh-&gt;source
)paren
comma
id|net16
c_func
(paren
id|uh-&gt;dest
)paren
)paren
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;len = %d, check = %d&bslash;n&quot;
comma
id|net16
c_func
(paren
id|uh-&gt;len
)paren
comma
id|net16
c_func
(paren
id|uh-&gt;check
)paren
)paren
)paren
suffix:semicolon
)brace
r_int
DECL|function|udp_select
id|udp_select
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
(brace
id|select_wait
c_func
(paren
id|sk-&gt;sleep
comma
id|wait
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sel_type
)paren
(brace
r_case
id|SEL_IN
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;rqueue
op_ne
l_int|NULL
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|SEL_OUT
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;prot
op_member_access_from_pointer
id|wspace
c_func
(paren
id|sk
)paren
op_ge
id|MIN_WRITE_SPACE
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|SEL_EX
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* can this ever happen? */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* this routine is called by the icmp module when it gets some&n;   sort of error condition.  If err &lt; 0 then the socket should&n;   be closed and the error returned to the user.  If err &gt; 0&n;   it&squot;s just the icmp type &lt;&lt; 8 | icmp code.  &n;   header points to the first 8 bytes of the tcp header.  We need&n;   to find the appropriate port. */
r_void
DECL|function|udp_err
id|udp_err
(paren
r_int
id|err
comma
r_int
r_char
op_star
id|header
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|saddr
comma
r_struct
id|ip_protocol
op_star
id|protocol
)paren
(brace
r_struct
id|udp_header
op_star
id|th
suffix:semicolon
r_volatile
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;udp_err (err=%d, header=%X, daddr=%X, saddr=%X, ip_protocl=%X)&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|th
op_assign
(paren
r_struct
id|udp_header
op_star
)paren
id|header
suffix:semicolon
id|sk
op_assign
id|get_sock
(paren
op_amp
id|udp_prot
comma
id|net16
c_func
(paren
id|th-&gt;dest
)paren
comma
id|saddr
comma
id|th-&gt;source
comma
id|daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
l_int|0xff00
op_eq
(paren
id|ICMP_SOURCE_QUENCH
op_lshift
l_int|8
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;cong_window
OG
l_int|1
)paren
id|sk-&gt;cong_window
op_assign
id|sk-&gt;cong_window
op_div
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sk-&gt;err
op_assign
id|icmp_err_convert
(braket
id|err
op_amp
l_int|0xff
)braket
dot
id|errno
suffix:semicolon
multiline_comment|/* it&squot;s only fatal if we have connected to them. */
r_if
c_cond
(paren
id|icmp_err_convert
(braket
id|err
op_amp
l_int|0xff
)braket
dot
id|fatal
op_logical_and
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
)paren
(brace
id|sk-&gt;prot
op_member_access_from_pointer
id|close
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|udp_check
id|udp_check
(paren
r_struct
id|udp_header
op_star
id|uh
comma
r_int
id|len
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
)paren
(brace
r_int
r_int
id|sum
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;udp_check (uh=%X, len = %d, saddr = %X, daddr = %X)&bslash;n&quot;
comma
id|uh
comma
id|len
comma
id|saddr
comma
id|daddr
)paren
)paren
suffix:semicolon
id|print_uh
(paren
id|uh
)paren
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t addl %%ecx,%%ebx&bslash;n&quot;
l_string|&quot;&bslash;t adcl %%edx,%%ebx&bslash;n&quot;
l_string|&quot;&bslash;t adcl $0, %%ebx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|daddr
)paren
comma
l_string|&quot;c&quot;
(paren
id|saddr
)paren
comma
l_string|&quot;d&quot;
(paren
(paren
id|net16
c_func
(paren
id|len
)paren
op_lshift
l_int|16
)paren
op_plus
id|IPPROTO_UDP
op_star
l_int|256
)paren
suffix:colon
l_string|&quot;cx&quot;
comma
l_string|&quot;bx&quot;
comma
l_string|&quot;dx&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|3
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;&bslash;tclc&bslash;n&quot;
l_string|&quot;1:&bslash;n&quot;
l_string|&quot;&bslash;t lodsl&bslash;n&quot;
l_string|&quot;&bslash;t adcl %%eax, %%ebx&bslash;n&quot;
l_string|&quot;&bslash;t loop 1b&bslash;n&quot;
l_string|&quot;&bslash;t adcl $0, %%ebx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
comma
l_string|&quot;=S&quot;
(paren
id|uh
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;c&quot;
(paren
id|len
op_div
l_int|4
)paren
comma
l_string|&quot;1&quot;
(paren
id|uh
)paren
suffix:colon
l_string|&quot;ax&quot;
comma
l_string|&quot;cx&quot;
comma
l_string|&quot;bx&quot;
comma
l_string|&quot;si&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* convert from 32 bits to 16 bits. */
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t movl %%ebx, %%ecx&bslash;n&quot;
l_string|&quot;&bslash;t shrl $16,%%ecx&bslash;n&quot;
l_string|&quot;&bslash;t addw %%cx, %%bx&bslash;n&quot;
l_string|&quot;&bslash;t adcw $0, %%bx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;bx&quot;
comma
l_string|&quot;cx&quot;
)paren
suffix:semicolon
multiline_comment|/* check for an extra word. */
r_if
c_cond
(paren
(paren
id|len
op_amp
l_int|2
)paren
op_ne
l_int|0
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t lodsw&bslash;n&quot;
l_string|&quot;&bslash;t addw %%ax,%%bx&bslash;n&quot;
l_string|&quot;&bslash;t adcw $0, %%bx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
comma
l_string|&quot;=S&quot;
(paren
id|uh
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;1&quot;
(paren
id|uh
)paren
suffix:colon
l_string|&quot;si&quot;
comma
l_string|&quot;ax&quot;
comma
l_string|&quot;bx&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* now check for the extra byte. */
r_if
c_cond
(paren
(paren
id|len
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t lodsb&bslash;n&quot;
l_string|&quot;&bslash;t movb $0,%%ah&bslash;n&quot;
l_string|&quot;&bslash;t addw %%ax,%%bx&bslash;n&quot;
l_string|&quot;&bslash;t adcw $0, %%bx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;S&quot;
(paren
id|uh
)paren
suffix:colon
l_string|&quot;si&quot;
comma
l_string|&quot;ax&quot;
comma
l_string|&quot;bx&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* we only want the bottom 16 bits, but we never cleared&n;     the top 16. */
r_return
(paren
(paren
op_complement
id|sum
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|udp_send_check
id|udp_send_check
(paren
r_struct
id|udp_header
op_star
id|uh
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
comma
r_int
id|len
comma
r_volatile
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|uh-&gt;check
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_logical_and
id|sk-&gt;no_check
)paren
r_return
suffix:semicolon
id|uh-&gt;check
op_assign
id|udp_check
(paren
id|uh
comma
id|len
comma
id|saddr
comma
id|daddr
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|udp_loopback
id|udp_loopback
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|port
comma
r_int
r_char
op_star
id|from
comma
r_int
id|len
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|saddr
)paren
(brace
r_struct
id|udp_header
op_star
id|uh
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_volatile
r_struct
id|sock
op_star
id|pair
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;udp_loopback &bslash;n&quot;
)paren
)paren
suffix:semicolon
id|pair
op_assign
id|get_sock
(paren
id|sk-&gt;prot
comma
id|net16
c_func
(paren
id|port
)paren
comma
id|saddr
comma
id|sk-&gt;dummy_th.source
comma
id|daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pair
op_eq
l_int|NULL
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|skb
op_assign
id|pair-&gt;prot-&gt;rmalloc
(paren
id|pair
comma
r_sizeof
(paren
op_star
id|skb
)paren
op_plus
r_sizeof
(paren
op_star
id|uh
)paren
op_plus
id|len
op_plus
l_int|4
comma
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* if we didn&squot;t get the memory, just drop the packet. */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
(paren
id|len
)paren
suffix:semicolon
id|skb-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;mem_addr
op_assign
id|skb
suffix:semicolon
id|skb-&gt;mem_len
op_assign
r_sizeof
(paren
op_star
id|skb
)paren
op_plus
id|len
op_plus
r_sizeof
(paren
op_star
id|uh
)paren
op_plus
l_int|4
suffix:semicolon
id|skb-&gt;daddr
op_assign
id|saddr
suffix:semicolon
id|skb-&gt;saddr
op_assign
id|daddr
suffix:semicolon
id|skb-&gt;len
op_assign
id|len
suffix:semicolon
id|skb-&gt;h.raw
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
suffix:semicolon
id|uh
op_assign
id|skb-&gt;h.uh
suffix:semicolon
id|uh
op_member_access_from_pointer
id|source
op_assign
id|sk-&gt;dummy_th.source
suffix:semicolon
id|uh
op_member_access_from_pointer
id|dest
op_assign
id|port
suffix:semicolon
id|uh
op_member_access_from_pointer
id|len
op_assign
id|len
op_plus
r_sizeof
(paren
op_star
id|uh
)paren
suffix:semicolon
multiline_comment|/*&t;verify_area (VERIFY_WRITE, from , len); */
id|memcpy_fromfs
c_func
(paren
id|uh
op_plus
l_int|1
comma
id|from
comma
id|len
)paren
suffix:semicolon
id|pair-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pair-&gt;rqueue
op_eq
l_int|NULL
)paren
(brace
id|pair-&gt;rqueue
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;next
op_assign
id|pair-&gt;rqueue
suffix:semicolon
id|skb-&gt;prev
op_assign
id|pair-&gt;rqueue-&gt;prev
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb
suffix:semicolon
)brace
id|wake_up
(paren
id|pair-&gt;sleep
)paren
suffix:semicolon
id|release_sock
(paren
id|pair
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
id|len
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|udp_sendto
id|udp_sendto
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|from
comma
r_int
id|len
comma
r_int
id|noblock
comma
r_int
id|flags
comma
r_struct
id|sockaddr_in
op_star
id|usin
comma
r_int
id|addr_len
)paren
(brace
multiline_comment|/* this should be easy, we just send the packet. */
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|udp_header
op_star
id|uh
suffix:semicolon
r_int
r_char
op_star
id|buff
suffix:semicolon
r_int
r_int
id|saddr
suffix:semicolon
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
r_int
id|amt
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sockaddr_in
id|sin
suffix:semicolon
multiline_comment|/* check the flags. */
r_if
c_cond
(paren
id|flags
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;sendto len = %d&bslash;n&quot;
comma
id|len
)paren
)paren
suffix:semicolon
multiline_comment|/* get and verify the address. */
r_if
c_cond
(paren
id|usin
)paren
(brace
r_if
c_cond
(paren
id|addr_len
OL
r_sizeof
(paren
id|sin
)paren
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/*&t;&t;  verify_area (VERIFY_WRITE, usin, sizeof (sin));*/
id|memcpy_fromfs
(paren
op_amp
id|sin
comma
id|usin
comma
r_sizeof
(paren
id|sin
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sin.sin_family
op_logical_and
id|sin.sin_family
op_ne
id|AF_INET
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sin.sin_port
op_eq
l_int|0
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|sin.sin_family
op_assign
id|AF_INET
suffix:semicolon
id|sin.sin_port
op_assign
id|sk-&gt;dummy_th.dest
suffix:semicolon
id|sin.sin_addr.s_addr
op_assign
id|sk-&gt;daddr
suffix:semicolon
)brace
multiline_comment|/* check for a valid saddr. */
id|saddr
op_assign
id|sk-&gt;saddr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|saddr
op_amp
l_int|0xff000000
)paren
op_eq
l_int|0
)paren
(brace
id|saddr
op_assign
id|MY_IP_ADDR
suffix:semicolon
)brace
multiline_comment|/* if it&squot;s a broadcast, make sure we get it. */
r_if
c_cond
(paren
(paren
id|sin.sin_addr.s_addr
op_amp
l_int|0xff000000
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|udp_loopback
(paren
id|sk
comma
id|sin.sin_port
comma
id|from
comma
id|len
comma
id|sin.sin_addr.s_addr
comma
id|saddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
(paren
id|err
)paren
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_int
id|tmp
suffix:semicolon
id|skb
op_assign
id|sk-&gt;prot-&gt;wmalloc
(paren
id|sk
comma
id|len
op_plus
r_sizeof
(paren
op_star
id|skb
)paren
op_plus
id|sk-&gt;prot-&gt;max_header
comma
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* this should never happen, but it is possible. */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|tmp
op_assign
id|sk-&gt;wmem_alloc
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
(paren
id|copied
)paren
suffix:semicolon
r_if
c_cond
(paren
id|noblock
)paren
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_le
id|sk-&gt;wmem_alloc
)paren
(brace
id|interruptible_sleep_on
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
(paren
id|copied
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
)brace
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|skb-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;mem_addr
op_assign
id|skb
suffix:semicolon
id|skb-&gt;mem_len
op_assign
id|len
op_plus
r_sizeof
(paren
op_star
id|skb
)paren
op_plus
id|sk-&gt;prot-&gt;max_header
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* now build the ip and dev header. */
id|buff
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
suffix:semicolon
id|tmp
op_assign
id|sk-&gt;prot-&gt;build_header
(paren
id|skb
comma
id|saddr
comma
id|sin.sin_addr.s_addr
comma
op_amp
id|dev
comma
id|IPPROTO_UDP
comma
id|sk-&gt;opt
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sk-&gt;prot-&gt;wfree
(paren
id|sk
comma
id|skb-&gt;mem_addr
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|buff
op_add_assign
id|tmp
suffix:semicolon
multiline_comment|/* we shouldn&squot;t do this, instead we should just&n;&t;&t;     let the ip protocol fragment the packet. */
id|amt
op_assign
id|min
(paren
id|len
op_plus
id|tmp
op_plus
r_sizeof
(paren
op_star
id|uh
)paren
comma
id|dev-&gt;mtu
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;amt = %d, dev = %X, dev-&gt;mtu = %d&bslash;n&quot;
comma
id|amt
comma
id|dev
comma
id|dev-&gt;mtu
)paren
)paren
suffix:semicolon
id|skb-&gt;len
op_assign
id|amt
suffix:semicolon
id|amt
op_sub_assign
id|tmp
suffix:semicolon
id|uh
op_assign
(paren
r_struct
id|udp_header
op_star
)paren
id|buff
suffix:semicolon
id|uh-&gt;len
op_assign
id|net16
c_func
(paren
id|amt
)paren
suffix:semicolon
id|uh-&gt;source
op_assign
id|sk-&gt;dummy_th.source
suffix:semicolon
id|uh-&gt;dest
op_assign
id|sin.sin_port
suffix:semicolon
id|amt
op_sub_assign
r_sizeof
(paren
op_star
id|uh
)paren
suffix:semicolon
id|buff
op_add_assign
r_sizeof
(paren
op_star
id|uh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amt
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;udp.c: amt = %d &lt; 0&bslash;n&quot;
comma
id|amt
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
id|copied
)paren
suffix:semicolon
)brace
multiline_comment|/*&t;&t;  verify_area (VERIFY_WRITE, from, amt);*/
id|memcpy_fromfs
c_func
(paren
id|buff
comma
id|from
comma
id|amt
)paren
suffix:semicolon
id|len
op_sub_assign
id|amt
suffix:semicolon
id|copied
op_add_assign
id|amt
suffix:semicolon
id|from
op_add_assign
id|amt
suffix:semicolon
id|udp_send_check
(paren
id|uh
comma
id|saddr
comma
id|sin.sin_addr.s_addr
comma
id|amt
op_plus
r_sizeof
(paren
op_star
id|uh
)paren
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;prot-&gt;queue_xmit
(paren
id|sk
comma
id|dev
comma
id|skb
comma
l_int|1
)paren
suffix:semicolon
)brace
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
id|copied
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|udp_write
id|udp_write
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|noblock
comma
r_int
id|flags
)paren
(brace
r_return
(paren
id|udp_sendto
(paren
id|sk
comma
id|buff
comma
id|len
comma
id|noblock
comma
id|flags
comma
l_int|NULL
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|udp_ioctl
id|udp_ioctl
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_default
suffix:colon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_case
id|TIOCOUTQ
suffix:colon
(brace
r_int
r_int
id|amount
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|amount
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wspace
c_func
(paren
id|sk
)paren
op_div
l_int|2
suffix:semicolon
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
id|put_fs_long
(paren
id|amount
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_case
id|TIOCINQ
suffix:colon
multiline_comment|/*      case FIONREAD:*/
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|amount
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|amount
op_assign
l_int|0
suffix:semicolon
id|skb
op_assign
id|sk-&gt;rqueue
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* we will only return the amount of this packet since that is all&n;&t;&t; that will be read. */
id|amount
op_assign
id|skb-&gt;len
suffix:semicolon
)brace
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
id|put_fs_long
(paren
id|amount
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
r_int
DECL|function|udp_recvfrom
id|udp_recvfrom
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|to
comma
r_int
id|len
comma
r_int
id|noblock
comma
r_int
id|flags
comma
r_struct
id|sockaddr_in
op_star
id|sin
comma
r_int
op_star
id|addr_len
)paren
(brace
multiline_comment|/* this should be easy, if there is something there we&n;&t;   return it, otherwise we block. */
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* this will pick up errors that occured&n;&t;   while the program was doing something&n;&t;   else. */
r_if
c_cond
(paren
id|sk-&gt;err
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
op_minus
id|sk-&gt;err
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|err
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr_len
)paren
(brace
id|verify_area
(paren
id|VERIFY_WRITE
comma
id|addr_len
comma
r_sizeof
(paren
op_star
id|addr_len
)paren
)paren
suffix:semicolon
id|put_fs_long
(paren
r_sizeof
(paren
op_star
id|sin
)paren
comma
id|addr_len
)paren
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|sk-&gt;rqueue
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|noblock
)paren
(brace
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
)brace
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rqueue
op_eq
l_int|NULL
)paren
(brace
id|interruptible_sleep_on
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
)brace
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
id|skb
op_assign
id|sk-&gt;rqueue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;next
op_eq
id|skb
)paren
(brace
id|sk-&gt;rqueue
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;rqueue
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|sk-&gt;rqueue
op_member_access_from_pointer
id|next
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb-&gt;next
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb-&gt;prev
suffix:semicolon
)brace
)brace
id|copied
op_assign
id|min
(paren
id|len
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|verify_area
(paren
id|VERIFY_WRITE
comma
id|to
comma
id|copied
)paren
suffix:semicolon
id|memcpy_tofs
(paren
id|to
comma
id|skb-&gt;h.raw
op_plus
r_sizeof
(paren
r_struct
id|udp_header
)paren
comma
id|copied
)paren
suffix:semicolon
multiline_comment|/* copy the address. */
r_if
c_cond
(paren
id|sin
)paren
(brace
r_struct
id|sockaddr_in
id|addr
suffix:semicolon
id|addr.sin_family
op_assign
id|AF_INET
suffix:semicolon
id|addr.sin_port
op_assign
id|skb-&gt;h.uh-&gt;source
suffix:semicolon
id|addr.sin_addr.s_addr
op_assign
id|skb-&gt;daddr
suffix:semicolon
id|verify_area
(paren
id|VERIFY_WRITE
comma
id|sin
comma
r_sizeof
(paren
op_star
id|sin
)paren
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|sin
comma
op_amp
id|addr
comma
r_sizeof
(paren
op_star
id|sin
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
)paren
(brace
id|kfree_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
id|copied
)paren
suffix:semicolon
)brace
r_int
DECL|function|udp_read
id|udp_read
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|noblock
comma
r_int
id|flags
)paren
(brace
r_return
(paren
id|udp_recvfrom
(paren
id|sk
comma
id|buff
comma
id|len
comma
id|noblock
comma
id|flags
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
r_int
DECL|function|udp_connect
id|udp_connect
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr_in
op_star
id|usin
comma
r_int
id|addr_len
)paren
(brace
r_struct
id|sockaddr_in
id|sin
suffix:semicolon
r_if
c_cond
(paren
id|addr_len
OL
r_sizeof
(paren
id|sin
)paren
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/*&t;verify_area (VERIFY_WRITE, usin, sizeof (sin)); */
id|memcpy_fromfs
(paren
op_amp
id|sin
comma
id|usin
comma
r_sizeof
(paren
id|sin
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sin.sin_family
op_logical_and
id|sin.sin_family
op_ne
id|AF_INET
)paren
r_return
(paren
op_minus
id|EAFNOSUPPORT
)paren
suffix:semicolon
id|sk-&gt;daddr
op_assign
id|sin.sin_addr.s_addr
suffix:semicolon
id|sk-&gt;dummy_th.dest
op_assign
id|sin.sin_port
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_ESTABLISHED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|udp_close
id|udp_close
c_func
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeout
)paren
(brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;dead
)paren
id|destroy_sock
(paren
id|sk
)paren
suffix:semicolon
r_else
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
)brace
r_int
DECL|function|udp_rcv
id|udp_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|options
op_star
id|opt
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|saddr
comma
r_int
id|redo
comma
r_struct
id|ip_protocol
op_star
id|protocol
)paren
(brace
multiline_comment|/* all we need to do is get the socket, and then do a checksum. */
r_struct
id|proto
op_star
id|prot
op_assign
op_amp
id|udp_prot
suffix:semicolon
r_volatile
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_struct
id|udp_header
op_star
id|uh
suffix:semicolon
id|uh
op_assign
(paren
r_struct
id|udp_header
op_star
)paren
id|skb-&gt;h.uh
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;add_arp
)paren
id|dev-&gt;add_arp
(paren
id|saddr
comma
id|skb
comma
id|dev
)paren
suffix:semicolon
id|sk
op_assign
id|get_sock
(paren
id|prot
comma
id|net16
c_func
(paren
id|uh-&gt;dest
)paren
comma
id|saddr
comma
id|uh-&gt;source
comma
id|daddr
)paren
suffix:semicolon
multiline_comment|/* if we don&squot;t know about the socket, forget about it. */
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|daddr
op_amp
l_int|0xff000000
op_ne
l_int|0
)paren
op_logical_and
(paren
id|daddr
op_amp
l_int|0xff000000
op_ne
l_int|0xff000000
)paren
)paren
(brace
id|icmp_reply
(paren
id|skb
comma
id|ICMP_DEST_UNREACH
comma
id|ICMP_PORT_UNREACH
comma
id|dev
)paren
suffix:semicolon
)brace
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|kfree_skb
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|redo
)paren
(brace
r_if
c_cond
(paren
id|uh-&gt;check
op_logical_and
id|udp_check
(paren
id|uh
comma
id|len
comma
id|saddr
comma
id|daddr
)paren
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;bad udp checksum&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|kfree_skb
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;len
op_assign
id|len
suffix:semicolon
multiline_comment|/* these are supposed to be switched. */
id|skb-&gt;daddr
op_assign
id|saddr
suffix:semicolon
id|skb-&gt;saddr
op_assign
id|daddr
suffix:semicolon
multiline_comment|/* Now deal with the in use. */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;inuse
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;back_log
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;back_log
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;next
op_assign
id|sk-&gt;back_log
suffix:semicolon
id|skb-&gt;prev
op_assign
id|sk-&gt;back_log-&gt;prev
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* charge it too the socket. */
r_if
c_cond
(paren
id|sk-&gt;rmem_alloc
op_plus
id|skb-&gt;mem_len
op_ge
id|SK_RMEM_MAX
)paren
(brace
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|kfree_skb
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|sk-&gt;rmem_alloc
op_add_assign
id|skb-&gt;mem_len
suffix:semicolon
multiline_comment|/* At this point we should print the thing out. */
id|PRINTK
(paren
(paren
l_string|&quot;&lt;&lt; &bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* now add it to the data chain and wake things up. */
r_if
c_cond
(paren
id|sk-&gt;rqueue
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;rqueue
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;next
op_assign
id|sk-&gt;rqueue
suffix:semicolon
id|skb-&gt;prev
op_assign
id|sk-&gt;rqueue-&gt;prev
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb
suffix:semicolon
)brace
id|skb-&gt;len
op_assign
id|len
op_minus
r_sizeof
(paren
op_star
id|uh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|wake_up
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|udp_prot
r_struct
id|proto
id|udp_prot
op_assign
(brace
id|sock_wmalloc
comma
id|sock_rmalloc
comma
id|sock_wfree
comma
id|sock_rfree
comma
id|sock_rspace
comma
id|sock_wspace
comma
id|udp_close
comma
id|udp_read
comma
id|udp_write
comma
id|udp_sendto
comma
id|udp_recvfrom
comma
id|ip_build_header
comma
id|udp_connect
comma
l_int|NULL
comma
id|ip_queue_xmit
comma
id|ip_retransmit
comma
l_int|NULL
comma
l_int|NULL
comma
id|udp_rcv
comma
id|udp_select
comma
id|udp_ioctl
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|128
comma
l_int|0
comma
(brace
l_int|NULL
comma
)brace
comma
l_string|&quot;UDP&quot;
)brace
suffix:semicolon
eof
