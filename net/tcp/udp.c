multiline_comment|/* udp.c */
multiline_comment|/*&n;    Copyright (C) 1992  Ross Biro&n;&n;    This program is free software; you can redistribute it and/or modify&n;    it under the terms of the GNU General Public License as published by&n;    the Free Software Foundation; either version 2, or (at your option)&n;    any later version.&n;&n;    This program is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;    GNU General Public License for more details.&n;&n;    You should have received a copy of the GNU General Public License&n;    along with this program; if not, write to the Free Software&n;    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. &n;&n;    The Author may be reached as bir7@leland.stanford.edu or&n;    C/O Department of Mathematics; Stanford University; Stanford, CA 94305&n;*/
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;netinet/in.h&gt;
macro_line|#include &quot;timer.h&quot;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &quot;../kern_sock.h&quot; /* for PRINTK */
macro_line|#include &quot;udp.h&quot;
macro_line|#include &quot;icmp.h&quot;
DECL|macro|min
mdefine_line|#define min(a,b) ((a)&lt;(b)?(a):(b))
r_static
r_void
DECL|function|print_uh
id|print_uh
c_func
(paren
r_struct
id|udp_header
op_star
id|uh
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;source = %d, dest = %d&bslash;n&quot;
comma
id|net16
c_func
(paren
id|uh-&gt;source
)paren
comma
id|net16
c_func
(paren
id|uh-&gt;dest
)paren
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;len = %d, check = %d&bslash;n&quot;
comma
id|net16
c_func
(paren
id|uh-&gt;len
)paren
comma
id|net16
c_func
(paren
id|uh-&gt;check
)paren
)paren
suffix:semicolon
)brace
r_int
DECL|function|udp_select
id|udp_select
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
(brace
id|select_wait
c_func
(paren
id|sk-&gt;sleep
comma
id|wait
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sel_type
)paren
(brace
r_case
id|SEL_IN
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;rqueue
op_ne
l_int|NULL
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|SEL_OUT
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;prot
op_member_access_from_pointer
id|wspace
c_func
(paren
id|sk
)paren
op_ge
id|MIN_WRITE_SPACE
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|SEL_EX
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* can this ever happen? */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* this routine is called by the icmp module when it gets some&n;   sort of error condition.  If err &lt; 0 then the socket should&n;   be closed and the error returned to the user.  If err &gt; 0&n;   it&squot;s just the icmp type &lt;&lt; 8 | icmp code.  &n;   header points to the first 8 bytes of the tcp header.  We need&n;   to find the appropriate port. */
r_void
DECL|function|udp_err
id|udp_err
(paren
r_int
id|err
comma
r_int
r_char
op_star
id|header
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|saddr
comma
r_struct
id|ip_protocol
op_star
id|protocol
)paren
(brace
r_struct
id|tcp_header
op_star
id|th
suffix:semicolon
r_volatile
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|th
op_assign
(paren
r_struct
id|tcp_header
op_star
)paren
id|header
suffix:semicolon
id|sk
op_assign
id|get_sock
(paren
op_amp
id|udp_prot
comma
id|net16
c_func
(paren
id|th-&gt;dest
)paren
comma
id|saddr
comma
id|th-&gt;source
comma
id|daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
l_int|0xff00
op_eq
(paren
id|ICMP_SOURCE_QUENCH
op_lshift
l_int|8
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;cong_window
OG
l_int|1
)paren
id|sk-&gt;cong_window
op_assign
id|sk-&gt;cong_window
op_div
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sk-&gt;err
op_assign
id|icmp_err_convert
(braket
id|err
op_amp
l_int|0xff
)braket
dot
id|errno
suffix:semicolon
r_if
c_cond
(paren
id|icmp_err_convert
(braket
id|err
op_amp
l_int|0xff
)braket
dot
id|fatal
)paren
(brace
id|sk-&gt;prot
op_member_access_from_pointer
id|close
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|udp_check
id|udp_check
(paren
r_struct
id|udp_header
op_star
id|uh
comma
r_int
id|len
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
)paren
(brace
r_int
r_int
id|sum
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;udp_check (uh=%X, len = %d, saddr = %X, daddr = %X)&bslash;n&quot;
comma
id|uh
comma
id|len
comma
id|saddr
comma
id|daddr
)paren
suffix:semicolon
id|print_uh
(paren
id|uh
)paren
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t addl %%ecx,%%ebx&bslash;n&quot;
l_string|&quot;&bslash;t adcl %%edx,%%ebx&bslash;n&quot;
l_string|&quot;&bslash;t adcl $0, %%ebx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|daddr
)paren
comma
l_string|&quot;c&quot;
(paren
id|saddr
)paren
comma
l_string|&quot;d&quot;
(paren
(paren
id|net16
c_func
(paren
id|len
)paren
op_lshift
l_int|16
)paren
op_plus
id|IP_UDP
op_star
l_int|256
)paren
suffix:colon
l_string|&quot;cx&quot;
comma
l_string|&quot;bx&quot;
comma
l_string|&quot;dx&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|3
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;&bslash;tclc&bslash;n&quot;
l_string|&quot;1:&bslash;n&quot;
l_string|&quot;&bslash;t lodsl&bslash;n&quot;
l_string|&quot;&bslash;t adcl %%eax, %%ebx&bslash;n&quot;
l_string|&quot;&bslash;t loop 1b&bslash;n&quot;
l_string|&quot;&bslash;t adcl $0, %%ebx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
comma
l_string|&quot;=S&quot;
(paren
id|uh
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;c&quot;
(paren
id|len
op_div
l_int|4
)paren
comma
l_string|&quot;1&quot;
(paren
id|uh
)paren
suffix:colon
l_string|&quot;ax&quot;
comma
l_string|&quot;cx&quot;
comma
l_string|&quot;bx&quot;
comma
l_string|&quot;si&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* convert from 32 bits to 16 bits. */
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t movl %%ebx, %%ecx&bslash;n&quot;
l_string|&quot;&bslash;t shrl $16,%%ecx&bslash;n&quot;
l_string|&quot;&bslash;t addw %%cx, %%bx&bslash;n&quot;
l_string|&quot;&bslash;t adcw $0, %%bx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;bx&quot;
comma
l_string|&quot;cx&quot;
)paren
suffix:semicolon
multiline_comment|/* check for an extra word. */
r_if
c_cond
(paren
(paren
id|len
op_amp
l_int|2
)paren
op_ne
l_int|0
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t lodsw&bslash;n&quot;
l_string|&quot;&bslash;t addw %%ax,%%bx&bslash;n&quot;
l_string|&quot;&bslash;t adcw $0, %%bx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
comma
l_string|&quot;=S&quot;
(paren
id|uh
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;1&quot;
(paren
id|uh
)paren
suffix:colon
l_string|&quot;si&quot;
comma
l_string|&quot;ax&quot;
comma
l_string|&quot;bx&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* now check for the extra byte. */
r_if
c_cond
(paren
(paren
id|len
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t lodsb&bslash;n&quot;
l_string|&quot;&bslash;t movb $0,%%ah&bslash;n&quot;
l_string|&quot;&bslash;t addw %%ax,%%bx&bslash;n&quot;
l_string|&quot;&bslash;t adcw $0, %%bx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;S&quot;
(paren
id|uh
)paren
suffix:colon
l_string|&quot;si&quot;
comma
l_string|&quot;ax&quot;
comma
l_string|&quot;bx&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* we only want the bottom 16 bits, but we never cleared&n;     the top 16. */
r_return
(paren
(paren
op_complement
id|sum
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|udp_send_check
id|udp_send_check
(paren
r_struct
id|udp_header
op_star
id|uh
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
comma
r_int
id|len
comma
r_volatile
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|uh-&gt;check
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_logical_and
id|sk-&gt;no_check
)paren
r_return
suffix:semicolon
id|uh-&gt;check
op_assign
id|udp_check
(paren
id|uh
comma
id|len
comma
id|saddr
comma
id|daddr
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|udp_loopback
id|udp_loopback
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|port
comma
r_int
r_char
op_star
id|from
comma
r_int
id|len
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|saddr
)paren
(brace
r_struct
id|udp_header
op_star
id|uh
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_volatile
r_struct
id|sock
op_star
id|pair
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;udp_loopback &bslash;n&quot;
)paren
suffix:semicolon
id|pair
op_assign
id|get_sock
(paren
id|sk-&gt;prot
comma
id|net16
c_func
(paren
id|port
)paren
comma
id|saddr
comma
id|sk-&gt;dummy_th.source
comma
id|daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pair
op_eq
l_int|NULL
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|skb
op_assign
id|pair-&gt;prot-&gt;rmalloc
(paren
id|pair
comma
r_sizeof
(paren
op_star
id|skb
)paren
op_plus
r_sizeof
(paren
op_star
id|uh
)paren
op_plus
id|len
op_plus
l_int|4
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* if we didn&squot;t get the memory, just drop the packet. */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
(paren
id|len
)paren
suffix:semicolon
id|skb-&gt;mem_addr
op_assign
id|skb
suffix:semicolon
id|skb-&gt;mem_len
op_assign
r_sizeof
(paren
op_star
id|skb
)paren
op_plus
id|len
op_plus
r_sizeof
(paren
op_star
id|uh
)paren
op_plus
l_int|4
suffix:semicolon
id|skb-&gt;daddr
op_assign
id|saddr
suffix:semicolon
id|skb-&gt;saddr
op_assign
id|daddr
suffix:semicolon
id|skb-&gt;len
op_assign
id|len
suffix:semicolon
id|skb-&gt;h.raw
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
suffix:semicolon
id|uh
op_assign
id|skb-&gt;h.uh
suffix:semicolon
id|uh
op_member_access_from_pointer
id|source
op_assign
id|sk-&gt;dummy_th.source
suffix:semicolon
id|uh
op_member_access_from_pointer
id|dest
op_assign
id|port
suffix:semicolon
id|uh
op_member_access_from_pointer
id|len
op_assign
id|len
op_plus
r_sizeof
(paren
op_star
id|uh
)paren
suffix:semicolon
id|verify_area
(paren
id|from
comma
id|len
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
id|uh
op_plus
l_int|1
comma
id|from
comma
id|len
)paren
suffix:semicolon
id|pair-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pair-&gt;rqueue
op_eq
l_int|NULL
)paren
(brace
id|pair-&gt;rqueue
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;next
op_assign
id|pair-&gt;rqueue
suffix:semicolon
id|skb-&gt;prev
op_assign
id|pair-&gt;rqueue-&gt;prev
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb
suffix:semicolon
)brace
id|wake_up
(paren
id|pair-&gt;sleep
)paren
suffix:semicolon
id|release_sock
(paren
id|pair
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
id|len
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|udp_sendto
id|udp_sendto
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|from
comma
r_int
id|len
comma
r_int
id|noblock
comma
r_int
id|flags
comma
r_struct
id|sockaddr_in
op_star
id|usin
comma
r_int
id|addr_len
)paren
(brace
multiline_comment|/* this should be easy, we just send the packet. */
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|udp_header
op_star
id|uh
suffix:semicolon
r_int
r_char
op_star
id|buff
suffix:semicolon
r_int
r_int
id|saddr
suffix:semicolon
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
r_int
id|amt
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sockaddr_in
id|sin
suffix:semicolon
multiline_comment|/* check the flags. */
r_if
c_cond
(paren
id|flags
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;sendto len = %d&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* get and verify the address. */
r_if
c_cond
(paren
id|usin
)paren
(brace
r_if
c_cond
(paren
id|addr_len
OL
r_sizeof
(paren
id|sin
)paren
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|verify_area
(paren
id|usin
comma
r_sizeof
(paren
id|sin
)paren
)paren
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|sin
comma
id|usin
comma
r_sizeof
(paren
id|sin
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sin.sin_family
op_logical_and
id|sin.sin_family
op_ne
id|AF_INET
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sin.sin_port
op_eq
l_int|0
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|sin.sin_family
op_assign
id|AF_INET
suffix:semicolon
id|sin.sin_port
op_assign
id|sk-&gt;dummy_th.dest
suffix:semicolon
id|sin.sin_addr.s_addr
op_assign
id|sk-&gt;daddr
suffix:semicolon
)brace
multiline_comment|/* check for a valid saddr. */
id|saddr
op_assign
id|sk-&gt;saddr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|saddr
op_amp
l_int|0xff000000
)paren
op_eq
l_int|0
)paren
(brace
id|saddr
op_assign
id|MY_IP_ADDR
suffix:semicolon
)brace
multiline_comment|/* if it&squot;s a broadcast, make sure we get it. */
r_if
c_cond
(paren
(paren
id|sin.sin_addr.s_addr
op_amp
l_int|0xff000000
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|udp_loopback
(paren
id|sk
comma
id|sin.sin_port
comma
id|from
comma
id|len
comma
id|sin.sin_addr.s_addr
comma
id|saddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
(paren
id|err
)paren
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_int
id|tmp
suffix:semicolon
id|skb
op_assign
id|sk-&gt;prot-&gt;wmalloc
(paren
id|sk
comma
id|len
op_plus
r_sizeof
(paren
op_star
id|skb
)paren
op_plus
id|sk-&gt;prot-&gt;max_header
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* this should never happen, but it is possible. */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;udp_sendto: write buffer full?&bslash;n&quot;
)paren
suffix:semicolon
id|print_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
op_logical_or
op_logical_neg
id|noblock
)paren
r_return
(paren
id|copied
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
)brace
id|skb-&gt;mem_addr
op_assign
id|skb
suffix:semicolon
id|skb-&gt;mem_len
op_assign
id|len
op_plus
r_sizeof
(paren
op_star
id|skb
)paren
op_plus
id|sk-&gt;prot-&gt;max_header
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* now build the ip and dev header. */
id|buff
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
suffix:semicolon
id|tmp
op_assign
id|sk-&gt;prot-&gt;build_header
(paren
id|skb
comma
id|saddr
comma
id|sin.sin_addr.s_addr
comma
op_amp
id|dev
comma
id|IP_UDP
comma
id|sk-&gt;opt
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sk-&gt;prot-&gt;wfree
(paren
id|sk
comma
id|skb-&gt;mem_addr
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|buff
op_add_assign
id|tmp
suffix:semicolon
multiline_comment|/* we shouldn&squot;t do this, instead we should just&n;&t;&t;     let the ip protocol fragment the packet. */
id|amt
op_assign
id|min
(paren
id|len
op_plus
id|tmp
op_plus
r_sizeof
(paren
op_star
id|uh
)paren
comma
id|dev-&gt;mtu
)paren
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;amt = %d, dev = %X, dev-&gt;mtu = %d&bslash;n&quot;
comma
id|amt
comma
id|dev
comma
id|dev-&gt;mtu
)paren
suffix:semicolon
id|skb-&gt;len
op_assign
id|amt
suffix:semicolon
id|amt
op_sub_assign
id|tmp
suffix:semicolon
id|uh
op_assign
(paren
r_struct
id|udp_header
op_star
)paren
id|buff
suffix:semicolon
id|uh-&gt;len
op_assign
id|net16
c_func
(paren
id|amt
)paren
suffix:semicolon
id|uh-&gt;source
op_assign
id|sk-&gt;dummy_th.source
suffix:semicolon
id|uh-&gt;dest
op_assign
id|sin.sin_port
suffix:semicolon
id|amt
op_sub_assign
r_sizeof
(paren
op_star
id|uh
)paren
suffix:semicolon
id|buff
op_add_assign
r_sizeof
(paren
op_star
id|uh
)paren
suffix:semicolon
id|verify_area
(paren
id|from
comma
id|amt
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
id|buff
comma
id|from
comma
id|amt
)paren
suffix:semicolon
id|len
op_sub_assign
id|amt
suffix:semicolon
id|copied
op_add_assign
id|amt
suffix:semicolon
id|from
op_add_assign
id|amt
suffix:semicolon
id|udp_send_check
(paren
id|uh
comma
id|saddr
comma
id|sin.sin_addr.s_addr
comma
id|amt
op_plus
r_sizeof
(paren
op_star
id|uh
)paren
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;prot-&gt;queue_xmit
(paren
id|sk
comma
id|dev
comma
id|skb
comma
l_int|1
)paren
suffix:semicolon
)brace
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
id|copied
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|udp_write
id|udp_write
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|noblock
comma
r_int
id|flags
)paren
(brace
r_return
(paren
id|udp_sendto
(paren
id|sk
comma
id|buff
comma
id|len
comma
id|noblock
comma
id|flags
comma
l_int|NULL
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_int
DECL|function|udp_recvfrom
id|udp_recvfrom
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|to
comma
r_int
id|len
comma
r_int
id|noblock
comma
r_int
id|flags
comma
r_struct
id|sockaddr_in
op_star
id|sin
comma
r_int
op_star
id|addr_len
)paren
(brace
multiline_comment|/* this should be easy, if there is something there we&n;&t;   return it, otherwise we block. */
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr_len
)paren
(brace
id|verify_area
(paren
id|addr_len
comma
r_sizeof
(paren
op_star
id|addr_len
)paren
)paren
suffix:semicolon
id|put_fs_long
(paren
r_sizeof
(paren
op_star
id|sin
)paren
comma
id|addr_len
)paren
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|sk-&gt;rqueue
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|noblock
)paren
(brace
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
)brace
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rqueue
op_eq
l_int|NULL
)paren
(brace
id|interruptible_sleep_on
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
id|skb
op_assign
id|sk-&gt;rqueue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;next
op_eq
id|skb
)paren
(brace
id|sk-&gt;rqueue
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;rqueue
op_assign
id|sk-&gt;rqueue
op_member_access_from_pointer
id|next
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb-&gt;next
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb-&gt;prev
suffix:semicolon
)brace
)brace
id|copied
op_assign
id|min
(paren
id|len
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|verify_area
(paren
id|to
comma
id|copied
)paren
suffix:semicolon
id|memcpy_tofs
(paren
id|to
comma
id|skb-&gt;h.raw
op_plus
r_sizeof
(paren
r_struct
id|udp_header
)paren
comma
id|copied
)paren
suffix:semicolon
multiline_comment|/* copy the address. */
r_if
c_cond
(paren
id|sin
)paren
(brace
r_struct
id|sockaddr_in
id|addr
suffix:semicolon
id|addr.sin_family
op_assign
id|AF_INET
suffix:semicolon
id|addr.sin_port
op_assign
id|skb-&gt;h.uh-&gt;source
suffix:semicolon
id|addr.sin_addr.s_addr
op_assign
id|skb-&gt;daddr
suffix:semicolon
id|verify_area
(paren
id|sin
comma
r_sizeof
(paren
op_star
id|sin
)paren
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|sin
comma
op_amp
id|addr
comma
r_sizeof
(paren
op_star
id|sin
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
)paren
(brace
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
id|copied
)paren
suffix:semicolon
)brace
r_int
DECL|function|udp_read
id|udp_read
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|noblock
comma
r_int
id|flags
)paren
(brace
r_return
(paren
id|udp_recvfrom
(paren
id|sk
comma
id|buff
comma
id|len
comma
id|noblock
comma
id|flags
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
r_int
DECL|function|udp_connect
id|udp_connect
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr_in
op_star
id|usin
comma
r_int
id|addr_len
)paren
(brace
r_struct
id|sockaddr_in
id|sin
suffix:semicolon
r_if
c_cond
(paren
id|addr_len
OL
r_sizeof
(paren
id|sin
)paren
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|verify_area
(paren
id|usin
comma
r_sizeof
(paren
id|sin
)paren
)paren
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|sin
comma
id|usin
comma
r_sizeof
(paren
id|sin
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sin.sin_family
op_logical_and
id|sin.sin_family
op_ne
id|AF_INET
)paren
r_return
(paren
op_minus
id|EAFNOSUPPORT
)paren
suffix:semicolon
id|sk-&gt;daddr
op_assign
id|sin.sin_addr.s_addr
suffix:semicolon
id|sk-&gt;dummy_th.dest
op_assign
id|sin.sin_port
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_ESTABLISHED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|udp_close
id|udp_close
c_func
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeout
)paren
(brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;dead
)paren
id|destroy_sock
(paren
id|sk
)paren
suffix:semicolon
r_else
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
)brace
r_int
DECL|function|udp_rcv
id|udp_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|options
op_star
id|opt
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|saddr
comma
r_int
id|redo
comma
r_struct
id|ip_protocol
op_star
id|protocol
)paren
(brace
multiline_comment|/* all we need to do is get the socket, and then do a checksum. */
r_struct
id|proto
op_star
id|prot
op_assign
op_amp
id|udp_prot
suffix:semicolon
r_volatile
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_struct
id|udp_header
op_star
id|uh
suffix:semicolon
id|uh
op_assign
(paren
r_struct
id|udp_header
op_star
)paren
id|skb-&gt;h.uh
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;add_arp
)paren
id|dev-&gt;add_arp
(paren
id|saddr
comma
id|skb
comma
id|dev
)paren
suffix:semicolon
id|sk
op_assign
id|get_sock
(paren
id|prot
comma
id|net16
c_func
(paren
id|uh-&gt;dest
)paren
comma
id|saddr
comma
id|uh-&gt;source
comma
id|daddr
)paren
suffix:semicolon
multiline_comment|/* if we don&squot;t know about the socket, forget about it. */
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
op_logical_and
(paren
id|daddr
op_amp
l_int|0xff000000
op_ne
l_int|0
)paren
op_logical_and
(paren
id|daddr
op_amp
l_int|0xff000000
op_ne
l_int|0xff000000
)paren
)paren
(brace
id|icmp_reply
(paren
id|skb
comma
id|ICMP_DEST_UNREACH
comma
id|ICMP_PORT_UNREACH
comma
id|dev
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|free_skb
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|redo
)paren
(brace
r_if
c_cond
(paren
id|uh-&gt;check
op_logical_and
id|udp_check
(paren
id|uh
comma
id|len
comma
id|saddr
comma
id|daddr
)paren
)paren
(brace
id|PRINTK
(paren
l_string|&quot;bad udp checksum&bslash;n&quot;
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|free_skb
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;len
op_assign
id|len
suffix:semicolon
multiline_comment|/* these are supposed to be switched. */
id|skb-&gt;daddr
op_assign
id|saddr
suffix:semicolon
id|skb-&gt;saddr
op_assign
id|daddr
suffix:semicolon
multiline_comment|/* Now deal with the in use. */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;inuse
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;back_log
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;back_log
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;next
op_assign
id|sk-&gt;back_log
suffix:semicolon
id|skb-&gt;prev
op_assign
id|sk-&gt;back_log-&gt;prev
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* charge it too the socket. */
r_if
c_cond
(paren
id|sk-&gt;rmem_alloc
op_plus
id|skb-&gt;mem_len
op_ge
id|SK_RMEM_MAX
)paren
(brace
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|free_skb
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|sk-&gt;rmem_alloc
op_add_assign
id|skb-&gt;mem_len
suffix:semicolon
multiline_comment|/* At this point we should print the thing out. */
id|PRINTK
(paren
l_string|&quot;&lt;&lt; &bslash;n&quot;
)paren
suffix:semicolon
id|print_sk
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* now add it to the data chain and wake things up. */
r_if
c_cond
(paren
id|sk-&gt;rqueue
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;rqueue
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;next
op_assign
id|sk-&gt;rqueue
suffix:semicolon
id|skb-&gt;prev
op_assign
id|sk-&gt;rqueue-&gt;prev
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb
suffix:semicolon
)brace
id|skb-&gt;len
op_assign
id|len
op_minus
r_sizeof
(paren
op_star
id|uh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|wake_up
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|udp_prot
r_struct
id|proto
id|udp_prot
op_assign
(brace
id|sock_wmalloc
comma
id|sock_rmalloc
comma
id|sock_wfree
comma
id|sock_rfree
comma
id|sock_rspace
comma
id|sock_wspace
comma
id|udp_close
comma
id|udp_read
comma
id|udp_write
comma
id|udp_sendto
comma
id|udp_recvfrom
comma
id|ip_build_header
comma
id|udp_connect
comma
l_int|NULL
comma
id|ip_queue_xmit
comma
id|ip_retransmit
comma
l_int|NULL
comma
l_int|NULL
comma
id|udp_rcv
comma
id|udp_select
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|128
comma
l_int|0
comma
(brace
l_int|NULL
comma
)brace
)brace
suffix:semicolon
eof
