multiline_comment|/* dev.c */
multiline_comment|/*&n;    Copyright (C) 1992  Ross Biro&n;&n;    This program is free software; you can redistribute it and/or modify&n;    it under the terms of the GNU General Public License as published by&n;    the Free Software Foundation; either version 2, or (at your option)&n;    any later version.&n;&n;    This program is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;    GNU General Public License for more details.&n;&n;    You should have received a copy of the GNU General Public License&n;    along with this program; if not, write to the Free Software&n;    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. &n;&n;    The Author may be reached as bir7@leland.stanford.edu or&n;    C/O Department of Mathematics; Stanford University; Stanford, CA 94305&n;*/
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;netinet/in.h&gt;
macro_line|#include &lt;asm/memory.h&gt;
macro_line|#include &quot;dev.h&quot;
macro_line|#include &quot;eth.h&quot;
macro_line|#include &quot;timer.h&quot;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &quot;arp.h&quot;
DECL|macro|DEV_DEBUG
macro_line|#undef DEV_DEBUG
macro_line|#ifdef DEV_DEBUG
DECL|macro|PRINTK
mdefine_line|#define PRINTK printk
macro_line|#else
DECL|macro|PRINTK
mdefine_line|#define PRINTK dummy_routine
macro_line|#endif
r_static
r_int
r_int
DECL|function|min
id|min
c_func
(paren
r_int
r_int
id|a
comma
r_int
r_int
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
OL
id|b
)paren
r_return
(paren
id|a
)paren
suffix:semicolon
r_return
(paren
id|b
)paren
suffix:semicolon
)brace
r_void
DECL|function|dev_add_pack
id|dev_add_pack
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|packet_type
op_star
id|p1
suffix:semicolon
id|pt-&gt;next
op_assign
id|ptype_base
suffix:semicolon
multiline_comment|/* see if we need to copy it. */
r_for
c_loop
(paren
id|p1
op_assign
id|ptype_base
suffix:semicolon
id|p1
op_ne
l_int|NULL
suffix:semicolon
id|p1
op_assign
id|p1-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p1-&gt;type
op_eq
id|pt-&gt;type
)paren
(brace
id|pt-&gt;copy
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|ptype_base
op_assign
id|pt
suffix:semicolon
)brace
r_void
DECL|function|dev_remove_pack
id|dev_remove_pack
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|packet_type
op_star
id|lpt
comma
op_star
id|pt1
suffix:semicolon
r_if
c_cond
(paren
id|pt
op_eq
id|ptype_base
)paren
(brace
id|ptype_base
op_assign
id|pt-&gt;next
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lpt
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|pt1
op_assign
id|ptype_base
suffix:semicolon
id|pt1-&gt;next
op_ne
l_int|NULL
suffix:semicolon
id|pt1
op_assign
id|pt1-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|pt1-&gt;next
op_eq
id|pt
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pt-&gt;copy
op_logical_and
id|lpt
)paren
id|lpt-&gt;copy
op_assign
l_int|0
suffix:semicolon
id|pt1-&gt;next
op_assign
id|pt-&gt;next
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pt1-&gt;next
op_member_access_from_pointer
id|type
op_eq
id|pt
op_member_access_from_pointer
id|type
)paren
(brace
id|lpt
op_assign
id|pt1-&gt;next
suffix:semicolon
)brace
)brace
)brace
r_struct
id|device
op_star
DECL|function|get_dev
id|get_dev
(paren
r_char
op_star
id|name
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|strcmp
(paren
id|dev-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
r_return
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_void
DECL|function|dev_queue_xmit
id|dev_queue_xmit
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_int
id|pri
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;eth_queue_xmit (skb=%X, dev=%X, pri = %d)&bslash;n&quot;
comma
id|skb
comma
id|dev
comma
id|pri
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|pri
OL
l_int|0
op_logical_or
id|pri
op_ge
id|DEV_NUMBUFFS
)paren
(brace
id|printk
(paren
l_string|&quot;bad priority in dev_queue_xmit.&bslash;n&quot;
)paren
suffix:semicolon
id|pri
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|hard_start_xmit
c_func
(paren
id|skb
comma
id|dev
)paren
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;retransmitted packet still on queue. &bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* used to say it is not currently on a send list. */
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* put skb into a bidirectional circular linked list. */
id|PRINTK
(paren
l_string|&quot;eth_queue dev-&gt;buffs[%d]=%X&bslash;n&quot;
comma
id|pri
comma
id|dev-&gt;buffs
(braket
id|pri
)braket
)paren
suffix:semicolon
multiline_comment|/* interrupts should already be cleared by hard_start_xmit. */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;buffs
(braket
id|pri
)braket
op_eq
l_int|NULL
)paren
(brace
id|dev-&gt;buffs
(braket
id|pri
)braket
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|skb2
op_assign
id|dev-&gt;buffs
(braket
id|pri
)braket
suffix:semicolon
id|skb-&gt;next
op_assign
id|skb2
suffix:semicolon
id|skb-&gt;prev
op_assign
id|skb2-&gt;prev
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* this routine now just gets the data out of the card and returns.&n;   it&squot;s return values now mean.&n;&n;   1 &lt;- exit even if you have more packets.&n;   0 &lt;- call me again no matter what.&n;  -1 &lt;- last packet not processed, try again. */
r_int
DECL|function|dev_rint
id|dev_rint
c_func
(paren
r_int
r_char
op_star
id|buff
comma
r_int
r_int
id|len
comma
r_int
id|flags
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|packet_type
op_star
id|ptype
suffix:semicolon
r_int
r_int
id|type
suffix:semicolon
r_int
r_char
id|flag
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|to
suffix:semicolon
r_int
id|amount
suffix:semicolon
multiline_comment|/* try to grab some memory. */
r_if
c_cond
(paren
id|len
OG
l_int|0
op_logical_and
id|buff
op_ne
l_int|NULL
)paren
(brace
id|skb
op_assign
id|malloc
(paren
r_sizeof
(paren
op_star
id|skb
)paren
op_plus
id|len
)paren
suffix:semicolon
id|skb-&gt;mem_len
op_assign
r_sizeof
(paren
op_star
id|skb
)paren
op_plus
id|len
suffix:semicolon
id|skb-&gt;mem_addr
op_assign
id|skb
suffix:semicolon
)brace
multiline_comment|/* firs we copy the packet into a buffer, and save it for later. */
r_if
c_cond
(paren
id|buff
op_ne
l_int|NULL
op_logical_and
id|skb
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|IN_SKBUFF
)paren
)paren
(brace
id|to
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|amount
op_assign
id|min
(paren
id|len
comma
(paren
r_int
r_int
)paren
id|dev-&gt;rmem_end
op_minus
(paren
r_int
r_int
)paren
id|buff
)paren
suffix:semicolon
id|memcpy
(paren
id|to
comma
id|buff
comma
id|amount
)paren
suffix:semicolon
id|len
op_sub_assign
id|amount
suffix:semicolon
id|buff
op_add_assign
id|amount
suffix:semicolon
id|to
op_add_assign
id|amount
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|buff
op_eq
id|dev-&gt;rmem_end
)paren
id|buff
op_assign
(paren
r_int
r_char
op_star
)paren
id|dev-&gt;rmem_start
suffix:semicolon
)brace
)brace
r_else
(brace
id|free_s
(paren
id|skb-&gt;mem_addr
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|buff
suffix:semicolon
)brace
id|skb-&gt;len
op_assign
id|len
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* now add it to the dev backlog. */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|backlog
op_eq
l_int|NULL
)paren
(brace
id|skb-&gt;prev
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next
op_assign
id|skb
suffix:semicolon
id|dev-&gt;backlog
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|skb
op_member_access_from_pointer
id|prev
op_assign
id|dev-&gt;backlog-&gt;prev
suffix:semicolon
id|skb-&gt;next
op_assign
id|dev-&gt;backlog
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
id|free_s
(paren
id|skb-&gt;mem_addr
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
multiline_comment|/* anything left to process? */
r_if
c_cond
(paren
id|dev-&gt;backlog
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;dev_rint:Dropping packets due to lack of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|skb
op_assign
id|dev-&gt;backlog
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;next
op_eq
id|skb
)paren
(brace
id|dev-&gt;backlog
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|dev-&gt;backlog
op_assign
id|skb-&gt;next
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb-&gt;prev
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* bump the pointer to the next structure. */
id|skb-&gt;h.raw
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
op_plus
id|dev-&gt;hard_header_len
suffix:semicolon
id|skb-&gt;len
op_sub_assign
id|dev-&gt;hard_header_len
suffix:semicolon
multiline_comment|/* convert the type to an ethernet type. */
id|type
op_assign
id|dev-&gt;type_trans
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* if there get to be a lot of types we should changes this to&n;      a bunch of linked lists like we do for ip protocols. */
r_for
c_loop
(paren
id|ptype
op_assign
id|ptype_base
suffix:semicolon
id|ptype
op_ne
l_int|NULL
suffix:semicolon
id|ptype
op_assign
id|ptype-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ptype-&gt;type
op_eq
id|type
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
multiline_comment|/* copy the packet if we need to. */
r_if
c_cond
(paren
id|ptype-&gt;copy
)paren
(brace
id|skb2
op_assign
id|malloc
(paren
id|skb-&gt;mem_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb2
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|memcpy
(paren
id|skb2
comma
id|skb
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
id|skb2-&gt;mem_addr
op_assign
id|skb2
suffix:semicolon
)brace
r_else
(brace
id|skb2
op_assign
id|skb
suffix:semicolon
id|flag
op_assign
l_int|1
suffix:semicolon
)brace
id|ptype-&gt;func
(paren
id|skb2
comma
id|dev
comma
id|ptype
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
id|PRINTK
(paren
l_string|&quot;discarding packet type = %X&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_else
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* This routine is called when an device interface is ready to&n;   transmit a packet.  Buffer points to where the packet should&n;   be put, and the routine returns the length of the packet.  A&n;   length of zero is interrpreted to mean the transmit buffers&n;   are empty, and the transmitter should be shut down. */
r_int
r_int
DECL|function|dev_tint
id|dev_tint
c_func
(paren
r_int
r_char
op_star
id|buff
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_NUMBUFFS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_while
c_loop
(paren
id|dev-&gt;buffs
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb
op_assign
id|dev-&gt;buffs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;next
op_eq
id|skb
)paren
(brace
id|dev-&gt;buffs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|dev-&gt;buffs
(braket
id|i
)braket
op_assign
id|skb-&gt;next
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb-&gt;next
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb-&gt;prev
suffix:semicolon
)brace
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|tmp
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;arp
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;rebuild_header
(paren
id|skb
op_plus
l_int|1
comma
id|dev
)paren
)paren
(brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|arp_queue
(paren
id|skb
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tmp
op_le
id|dev-&gt;mtu
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;send_packet
op_ne
l_int|NULL
)paren
(brace
id|dev
op_member_access_from_pointer
id|send_packet
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buff
op_ne
l_int|NULL
)paren
id|memcpy
(paren
id|buff
comma
id|skb
op_plus
l_int|1
comma
id|tmp
)paren
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;&gt;&gt;&bslash;n&quot;
)paren
suffix:semicolon
id|print_eth
(paren
(paren
r_struct
id|enet_header
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;**** bug len bigger than mtu. &bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;free
)paren
(brace
id|free_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp
op_ne
l_int|0
)paren
r_return
(paren
id|tmp
)paren
suffix:semicolon
)brace
)brace
id|PRINTK
(paren
l_string|&quot;dev_tint returning 0 &bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
eof
