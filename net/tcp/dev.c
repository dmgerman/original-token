multiline_comment|/* dev.c */
multiline_comment|/*&n;    Copyright (C) 1992  Ross Biro&n;&n;    This program is free software; you can redistribute it and/or modify&n;    it under the terms of the GNU General Public License as published by&n;    the Free Software Foundation; either version 2, or (at your option)&n;    any later version.&n;&n;    This program is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;    GNU General Public License for more details.&n;&n;    You should have received a copy of the GNU General Public License&n;    along with this program; if not, write to the Free Software&n;    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. &n;&n;    The Author may be reached as bir7@leland.stanford.edu or&n;    C/O Department of Mathematics; Stanford University; Stanford, CA 94305&n;*/
multiline_comment|/* $Id: dev.c,v 0.8.4.10 1992/12/12 19:25:04 bir7 Exp $ */
multiline_comment|/* $Log: dev.c,v $&n; * Revision 0.8.4.10  1992/12/12  19:25:04  bir7&n; * Cleaned up Log messages.&n; *&n; * Revision 0.8.4.9  1992/12/12  01:50:49  bir7&n; * *** empty log message ***&n; *&n; * Revision 0.8.4.8  1992/12/08  20:49:15  bir7&n; * Edited ctrl-h&squot;s out of log messages.&n; *&n; * Revision 0.8.4.7  1992/12/06  23:29:59  bir7&n; * Converted to using lower half interrupt routine.&n; *&n; * Revision 0.8.4.6  1992/12/05  21:35:53  bir7&n; * Updated dev-&gt;init type.&n; *&n; * Revision 0.8.4.5  1992/12/03  19:52:20  bir7&n; * Added paranoid queue checking.&n; *&n; * Revision 0.8.4.4  1992/11/18  15:38:03  bir7&n; * Fixed bug in copying packets and changed some printk&squot;s&n; *&n; * Revision 0.8.4.3  1992/11/15  14:55:30  bir7&n; * More sanity checks.&n; *&n; * Revision 0.8.4.2  1992/11/10  10:38:48  bir7&n; * Change free_s to kfree_s and accidently changed free_skb to kfree_skb.&n; *&n; * Revision 0.8.4.1  1992/11/10  00:17:18  bir7&n; * version change only.&n; *&n; * Revision 0.8.3.5  1992/11/10  00:14:47  bir7&n; * Changed malloc to kmalloc and added Id and Log&n; *&n; */
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;netinet/in.h&gt;
macro_line|#include &quot;dev.h&quot;
macro_line|#include &quot;eth.h&quot;
macro_line|#include &quot;timer.h&quot;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &quot;arp.h&quot;
DECL|macro|DEV_DEBUG
macro_line|#undef DEV_DEBUG
macro_line|#ifdef DEV_DEBUG
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x) printk x
macro_line|#else
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x) /**/
macro_line|#endif
r_static
r_int
r_int
DECL|function|min
id|min
c_func
(paren
r_int
r_int
id|a
comma
r_int
r_int
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
OL
id|b
)paren
r_return
(paren
id|a
)paren
suffix:semicolon
r_return
(paren
id|b
)paren
suffix:semicolon
)brace
r_void
DECL|function|dev_add_pack
id|dev_add_pack
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|packet_type
op_star
id|p1
suffix:semicolon
id|pt-&gt;next
op_assign
id|ptype_base
suffix:semicolon
multiline_comment|/* see if we need to copy it. */
r_for
c_loop
(paren
id|p1
op_assign
id|ptype_base
suffix:semicolon
id|p1
op_ne
l_int|NULL
suffix:semicolon
id|p1
op_assign
id|p1-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p1-&gt;type
op_eq
id|pt-&gt;type
)paren
(brace
id|pt-&gt;copy
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|ptype_base
op_assign
id|pt
suffix:semicolon
)brace
r_void
DECL|function|dev_remove_pack
id|dev_remove_pack
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|packet_type
op_star
id|lpt
comma
op_star
id|pt1
suffix:semicolon
r_if
c_cond
(paren
id|pt
op_eq
id|ptype_base
)paren
(brace
id|ptype_base
op_assign
id|pt-&gt;next
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lpt
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|pt1
op_assign
id|ptype_base
suffix:semicolon
id|pt1-&gt;next
op_ne
l_int|NULL
suffix:semicolon
id|pt1
op_assign
id|pt1-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|pt1-&gt;next
op_eq
id|pt
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pt-&gt;copy
op_logical_and
id|lpt
)paren
id|lpt-&gt;copy
op_assign
l_int|0
suffix:semicolon
id|pt1-&gt;next
op_assign
id|pt-&gt;next
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pt1-&gt;next
op_member_access_from_pointer
id|type
op_eq
id|pt
op_member_access_from_pointer
id|type
)paren
(brace
id|lpt
op_assign
id|pt1-&gt;next
suffix:semicolon
)brace
)brace
)brace
r_struct
id|device
op_star
DECL|function|get_dev
id|get_dev
(paren
r_char
op_star
id|name
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|strcmp
(paren
id|dev-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
r_return
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_void
DECL|function|dev_queue_xmit
id|dev_queue_xmit
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_int
id|pri
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;dev_queue_xmit (skb=%X, dev=%X, pri = %d)&bslash;n&quot;
comma
id|skb
comma
id|dev
comma
id|pri
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;dev.c: dev_queue_xmit: dev = NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;next
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* make sure we haven&squot;t missed an interrupt. */
id|dev-&gt;hard_start_xmit
(paren
l_int|NULL
comma
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pri
OL
l_int|0
op_logical_or
id|pri
op_ge
id|DEV_NUMBUFFS
)paren
(brace
id|printk
(paren
l_string|&quot;bad priority in dev_queue_xmit.&bslash;n&quot;
)paren
suffix:semicolon
id|pri
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|hard_start_xmit
c_func
(paren
id|skb
comma
id|dev
)paren
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* put skb into a bidirectional circular linked list. */
id|PRINTK
(paren
(paren
l_string|&quot;dev_queue_xmit dev-&gt;buffs[%d]=%X&bslash;n&quot;
comma
id|pri
comma
id|dev-&gt;buffs
(braket
id|pri
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/* interrupts should already be cleared by hard_start_xmit. */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;buffs
(braket
id|pri
)braket
op_eq
l_int|NULL
)paren
(brace
id|dev-&gt;buffs
(braket
id|pri
)braket
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|skb2
op_assign
id|dev-&gt;buffs
(braket
id|pri
)braket
suffix:semicolon
id|skb-&gt;next
op_assign
id|skb2
suffix:semicolon
id|skb-&gt;prev
op_assign
id|skb2-&gt;prev
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb
suffix:semicolon
)brace
id|skb-&gt;magic
op_assign
id|DEV_QUEUE_MAGIC
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* this routine now just gets the data out of the card and returns.&n;   it&squot;s return values now mean.&n;&n;   1 &lt;- exit even if you have more packets.&n;   0 &lt;- call me again no matter what.&n;  -1 &lt;- last packet not processed, try again.&n;&n;  It&squot;s changed now &n;  1 &lt;- exit I can&squot;t do any more&n;  0 &lt;- feed me more. &n;&n;  */
DECL|variable|backlog
r_static
r_struct
id|sk_buff
op_star
id|backlog
op_assign
l_int|NULL
suffix:semicolon
r_int
DECL|function|dev_rint
id|dev_rint
c_func
(paren
r_int
r_char
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|flags
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|to
suffix:semicolon
r_int
id|amount
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
op_logical_or
id|buff
op_eq
l_int|NULL
op_logical_or
id|len
op_le
l_int|0
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|IN_SKBUFF
)paren
(brace
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|buff
suffix:semicolon
)brace
r_else
(brace
id|skb
op_assign
id|kmalloc
(paren
r_sizeof
(paren
op_star
id|skb
)paren
op_plus
id|len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;dev_rint:dropping packet due to lack of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|skb-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;mem_len
op_assign
r_sizeof
(paren
op_star
id|skb
)paren
op_plus
id|len
suffix:semicolon
id|skb-&gt;mem_addr
op_assign
id|skb
suffix:semicolon
multiline_comment|/* first we copy the packet into a buffer, and save it for later. */
id|to
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|amount
op_assign
id|min
(paren
id|len
comma
(paren
r_int
r_int
)paren
id|dev-&gt;rmem_end
op_minus
(paren
r_int
r_int
)paren
id|buff
)paren
suffix:semicolon
id|memcpy
(paren
id|to
comma
id|buff
comma
id|amount
)paren
suffix:semicolon
id|len
op_sub_assign
id|amount
suffix:semicolon
id|buff
op_add_assign
id|amount
suffix:semicolon
id|to
op_add_assign
id|amount
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|buff
op_eq
id|dev-&gt;rmem_end
)paren
id|buff
op_assign
(paren
r_int
r_char
op_star
)paren
id|dev-&gt;rmem_start
suffix:semicolon
)brace
)brace
id|skb-&gt;len
op_assign
id|len
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* now add it to the backlog. */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|backlog
op_eq
l_int|NULL
)paren
(brace
id|skb-&gt;prev
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next
op_assign
id|skb
suffix:semicolon
id|backlog
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|skb
op_member_access_from_pointer
id|prev
op_assign
id|backlog-&gt;prev
suffix:semicolon
id|skb-&gt;next
op_assign
id|backlog
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|backlog
op_ne
l_int|NULL
)paren
id|mark_bh
c_func
(paren
id|INET_BH
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_void
DECL|function|inet_bh
id|inet_bh
c_func
(paren
r_void
op_star
id|tmp
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|packet_type
op_star
id|ptype
suffix:semicolon
r_int
r_int
id|type
suffix:semicolon
r_int
r_char
id|flag
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|in_bh
op_assign
l_int|0
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_bh
op_ne
l_int|0
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|in_bh
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* anything left to process? */
r_while
c_loop
(paren
id|backlog
op_ne
l_int|NULL
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb
op_assign
id|backlog
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;next
op_eq
id|skb
)paren
(brace
id|backlog
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|backlog
op_assign
id|skb-&gt;next
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb-&gt;prev
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* bump the pointer to the next structure. */
id|skb-&gt;h.raw
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
op_plus
id|skb-&gt;dev-&gt;hard_header_len
suffix:semicolon
id|skb-&gt;len
op_sub_assign
id|skb-&gt;dev-&gt;hard_header_len
suffix:semicolon
multiline_comment|/* convert the type to an ethernet type. */
id|type
op_assign
id|skb-&gt;dev-&gt;type_trans
(paren
id|skb
comma
id|skb-&gt;dev
)paren
suffix:semicolon
multiline_comment|/* if there get to be a lot of types we should changes this to&n;&t;  a bunch of linked lists like we do for ip protocols. */
r_for
c_loop
(paren
id|ptype
op_assign
id|ptype_base
suffix:semicolon
id|ptype
op_ne
l_int|NULL
suffix:semicolon
id|ptype
op_assign
id|ptype-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ptype-&gt;type
op_eq
id|type
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
multiline_comment|/* copy the packet if we need to. */
r_if
c_cond
(paren
id|ptype-&gt;copy
)paren
(brace
id|skb2
op_assign
id|kmalloc
(paren
id|skb-&gt;mem_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb2
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|memcpy
(paren
id|skb2
comma
id|skb
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
id|skb2-&gt;mem_addr
op_assign
id|skb2
suffix:semicolon
id|skb2-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|skb2-&gt;h.raw
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|skb2
op_plus
(paren
r_int
r_int
)paren
id|skb-&gt;h.raw
op_minus
(paren
r_int
r_int
)paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb2
op_assign
id|skb
suffix:semicolon
id|flag
op_assign
l_int|1
suffix:semicolon
)brace
id|ptype-&gt;func
(paren
id|skb2
comma
id|skb-&gt;dev
comma
id|ptype
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;discarding packet type = %X&bslash;n&quot;
comma
id|type
)paren
)paren
suffix:semicolon
id|kfree_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
)brace
id|in_bh
op_assign
l_int|0
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This routine is called when an device interface is ready to&n;   transmit a packet.  Buffer points to where the packet should&n;   be put, and the routine returns the length of the packet.  A&n;   length of zero is interrpreted to mean the transmit buffers&n;   are empty, and the transmitter should be shut down. */
r_int
r_int
DECL|function|dev_tint
id|dev_tint
c_func
(paren
r_int
r_char
op_star
id|buff
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_NUMBUFFS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_while
c_loop
(paren
id|dev-&gt;buffs
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb
op_assign
id|dev-&gt;buffs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;magic
op_ne
id|DEV_QUEUE_MAGIC
)paren
(brace
id|printk
(paren
l_string|&quot;dev.c skb with bad magic-%X: squashing queue&bslash;n&quot;
comma
id|skb-&gt;magic
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dev-&gt;buffs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|skb-&gt;magic
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;next
op_eq
id|skb
)paren
(brace
id|dev-&gt;buffs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* extra consistancy check. */
r_if
c_cond
(paren
id|skb-&gt;next
op_eq
l_int|NULL
macro_line|#ifdef CONFIG_MAX_16M
op_logical_or
(paren
r_int
r_int
)paren
(paren
id|skb-&gt;next
)paren
OG
l_int|16
op_star
l_int|1024
op_star
l_int|1024
macro_line|#endif
)paren
(brace
id|printk
(paren
l_string|&quot;dev.c: *** bug bad skb-&gt;next, squashing queue &bslash;n&quot;
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dev-&gt;buffs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|dev-&gt;buffs
(braket
id|i
)braket
op_assign
id|skb-&gt;next
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb-&gt;next
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb-&gt;prev
suffix:semicolon
)brace
)brace
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;arp
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;rebuild_header
(paren
id|skb
op_plus
l_int|1
comma
id|dev
)paren
)paren
(brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|arp_queue
(paren
id|skb
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|tmp
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_le
id|dev-&gt;mtu
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;send_packet
op_ne
l_int|NULL
)paren
(brace
id|dev
op_member_access_from_pointer
id|send_packet
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buff
op_ne
l_int|NULL
)paren
id|memcpy
(paren
id|buff
comma
id|skb
op_plus
l_int|1
comma
id|tmp
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;&gt;&gt;&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|print_eth
(paren
(paren
r_struct
id|enet_header
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;dev.c:**** bug len bigger than mtu, &quot;
l_string|&quot;squashing queue. &bslash;n&quot;
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dev-&gt;buffs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;free
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp
op_ne
l_int|0
)paren
r_return
(paren
id|tmp
)paren
suffix:semicolon
)brace
)brace
id|PRINTK
(paren
(paren
l_string|&quot;dev_tint returning 0 &bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
eof
