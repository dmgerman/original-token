multiline_comment|/* tcp.c */
multiline_comment|/*&n;     Copyright (C) 1992  Ross Biro&n;&n;     This program is free software; you can redistribute it and/or modify&n;     it under the terms of the GNU General Public License as published by&n;     the Free Software Foundation; either version 2, or (at your option)&n;     any later version.&n;&n;     This program is distributed in the hope that it will be useful,&n;     but WITHOUT ANY WARRANTY; without even the implied warranty of&n;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;     GNU General Public License for more details.&n;&n;     You should have received a copy of the GNU General Public License&n;     along with this program; if not, write to the Free Software&n;     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. &n;&n;     The Author may be reached as bir7@leland.stanford.edu or&n;     C/O Department of Mathematics; Stanford University; Stanford, CA 94305&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;netinet/in.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &quot;timer.h&quot;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;icmp.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
multiline_comment|/* #include &lt;signal.h&gt;*/
macro_line|#include &lt;linux/termios.h&gt; /* for ioctl&squot;s */
macro_line|#include &quot;../kern_sock.h&quot; /* for PRINTK */
DECL|macro|tmax
mdefine_line|#define tmax(a,b) (before ((a),(b)) ? (b) : (a))
DECL|macro|swap
mdefine_line|#define swap(a,b) {unsigned long c; c=a; a=b; b=c;}
r_extern
r_struct
id|proto
id|tcp_prot
suffix:semicolon
r_static
r_int
DECL|function|min
id|min
(paren
r_int
r_int
id|a
comma
r_int
r_int
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
OL
id|b
)paren
r_return
(paren
id|a
)paren
suffix:semicolon
r_return
(paren
id|b
)paren
suffix:semicolon
)brace
r_void
DECL|function|print_th
id|print_th
(paren
r_struct
id|tcp_header
op_star
id|th
)paren
(brace
r_int
r_char
op_star
id|ptr
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;tcp header:&bslash;n&quot;
)paren
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;  source=%d, dest=%d, seq =%d, ack_seq = %d&bslash;n&quot;
comma
id|net16
c_func
(paren
id|th-&gt;source
)paren
comma
id|net16
c_func
(paren
id|th-&gt;dest
)paren
comma
id|net32
c_func
(paren
id|th-&gt;seq
)paren
comma
id|net32
c_func
(paren
id|th-&gt;ack_seq
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;  fin=%d, syn=%d, rst=%d, psh=%d, ack=%d, urg=%d res1=%d res2=%d&bslash;n&quot;
comma
id|th-&gt;fin
comma
id|th-&gt;syn
comma
id|th-&gt;rst
comma
id|th-&gt;psh
comma
id|th-&gt;ack
comma
id|th-&gt;urg
comma
id|th-&gt;res1
comma
id|th-&gt;res2
)paren
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;  window = %d, check = %d urg_ptr = %d&bslash;n&quot;
comma
id|net16
c_func
(paren
id|th-&gt;window
)paren
comma
id|net16
c_func
(paren
id|th-&gt;check
)paren
comma
id|net16
c_func
(paren
id|th-&gt;urg_ptr
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;  doff = %d&bslash;n&quot;
comma
id|th-&gt;doff
)paren
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;options = %d %d %d %d&bslash;n&quot;
comma
id|ptr
(braket
l_int|0
)braket
comma
id|ptr
(braket
l_int|1
)braket
comma
id|ptr
(braket
l_int|2
)braket
comma
id|ptr
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* This routine grabs the first thing off of a rcv queue. */
r_static
r_struct
id|sk_buff
op_star
DECL|function|get_firstr
id|get_firstr
c_func
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|sk-&gt;rqueue
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
id|sk-&gt;rqueue
op_assign
id|skb-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rqueue
op_eq
id|skb
)paren
(brace
id|sk-&gt;rqueue
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;rqueue-&gt;prev
op_assign
id|skb-&gt;prev
suffix:semicolon
id|sk-&gt;rqueue-&gt;prev-&gt;next
op_assign
id|sk-&gt;rqueue
suffix:semicolon
)brace
r_return
(paren
id|skb
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|diff
id|diff
(paren
r_int
r_int
id|seq1
comma
r_int
r_int
id|seq2
)paren
(brace
r_int
id|d
suffix:semicolon
id|d
op_assign
id|seq1
op_minus
id|seq2
suffix:semicolon
r_if
c_cond
(paren
id|d
OG
l_int|0
)paren
r_return
(paren
id|d
)paren
suffix:semicolon
multiline_comment|/* I hope this returns what I want. */
r_return
(paren
op_complement
id|d
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* enter the time wait state. */
r_static
r_void
DECL|function|tcp_time_wait
id|tcp_time_wait
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sk-&gt;state
op_assign
id|TCP_TIME_WAIT
suffix:semicolon
id|sk-&gt;time_wait.len
op_assign
id|TCP_TIMEWAIT_LEN
suffix:semicolon
id|sk-&gt;timeout
op_assign
id|TIME_CLOSE
suffix:semicolon
id|reset_timer
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|tcp_retransmit
id|tcp_retransmit
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
id|all
)paren
(brace
r_if
c_cond
(paren
id|all
)paren
(brace
id|ip_retransmit
(paren
id|sk
comma
id|all
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sk-&gt;rtt
op_mul_assign
l_int|2
suffix:semicolon
multiline_comment|/* exponential back off. */
r_if
c_cond
(paren
id|sk-&gt;cong_window
OG
l_int|1
)paren
id|sk-&gt;cong_window
op_assign
id|sk-&gt;cong_window
op_div
l_int|2
suffix:semicolon
id|sk-&gt;exp_growth
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* do the actuall retransmit. */
id|ip_retransmit
(paren
id|sk
comma
id|all
)paren
suffix:semicolon
)brace
multiline_comment|/* this routine is called by the icmp module when it gets some&n;   sort of error condition.  If err &lt; 0 then the socket should&n;   be closed and the error returned to the user.  If err &gt; 0&n;   it&squot;s just the icmp type &lt;&lt; 8 | icmp code.  &n;   header points to the first 8 bytes of the tcp header.  We need&n;   to find the appropriate port. */
r_void
DECL|function|tcp_err
id|tcp_err
(paren
r_int
id|err
comma
r_int
r_char
op_star
id|header
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|saddr
comma
r_struct
id|ip_protocol
op_star
id|protocol
)paren
(brace
r_struct
id|tcp_header
op_star
id|th
suffix:semicolon
r_volatile
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|th
op_assign
(paren
r_struct
id|tcp_header
op_star
)paren
id|header
suffix:semicolon
id|sk
op_assign
id|get_sock
(paren
op_amp
id|tcp_prot
comma
id|net16
c_func
(paren
id|th-&gt;dest
)paren
comma
id|saddr
comma
id|th-&gt;source
comma
id|daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
l_int|0xff00
op_eq
(paren
id|ICMP_SOURCE_QUENCH
op_lshift
l_int|8
)paren
)paren
(brace
multiline_comment|/* for now we will just trigger a linear backoff. The slow start&n;&t;   code should cause a real backoff here. */
r_if
c_cond
(paren
id|sk-&gt;cong_window
OG
l_int|1
)paren
id|sk-&gt;cong_window
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sk-&gt;err
op_assign
id|icmp_err_convert
(braket
id|err
op_amp
l_int|0xff
)braket
dot
id|errno
suffix:semicolon
r_if
c_cond
(paren
id|icmp_err_convert
(braket
id|err
op_amp
l_int|0xff
)braket
dot
id|fatal
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
)paren
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|close
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|tcp_select
id|tcp_select
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
(brace
r_switch
c_cond
(paren
id|sel_type
)paren
(brace
r_case
id|SEL_IN
suffix:colon
id|select_wait
(paren
id|sk-&gt;sleep
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rqueue
op_ne
l_int|NULL
op_logical_and
(paren
id|between
(paren
id|sk-&gt;copied_seq
comma
id|sk-&gt;rqueue-&gt;next-&gt;h.th-&gt;seq
op_minus
l_int|1
comma
id|sk-&gt;rqueue-&gt;next-&gt;h.th-&gt;seq
op_plus
id|sk-&gt;rqueue-&gt;next-&gt;len
)paren
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_LISTEN
suffix:colon
r_case
id|TCP_ESTABLISHED
suffix:colon
r_case
id|TCP_SYN_SENT
suffix:colon
r_case
id|TCP_SYN_RECV
suffix:colon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_default
suffix:colon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_case
id|SEL_OUT
suffix:colon
id|select_wait
(paren
id|sk-&gt;sleep
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* hack so it will probably be able to write something&n;&t; if it says it&squot;s ok to write. */
r_if
c_cond
(paren
id|sk-&gt;prot
op_member_access_from_pointer
id|wspace
c_func
(paren
id|sk
)paren
op_ge
id|MIN_WRITE_SPACE
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|SEL_EX
suffix:colon
id|select_wait
c_func
(paren
id|sk-&gt;sleep
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT1
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT2
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_TIME_WAIT
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_LAST_ACK
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|tcp_ioctl
id|tcp_ioctl
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_default
suffix:colon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_case
id|TIOCINQ
suffix:colon
multiline_comment|/*      case FIONREAD:*/
(brace
r_int
r_int
id|amount
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|amount
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rqueue
op_ne
l_int|NULL
)paren
(brace
id|skb
op_assign
id|sk-&gt;rqueue-&gt;next
suffix:semicolon
multiline_comment|/* go until a push or until we are out of data. */
r_do
(brace
id|amount
op_add_assign
id|skb
op_member_access_from_pointer
id|len
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;psh
)paren
r_break
suffix:semicolon
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|skb
op_ne
id|sk-&gt;rqueue-&gt;next
)paren
suffix:semicolon
)brace
id|verify_area
(paren
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
id|put_fs_long
(paren
id|amount
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_case
id|SIOCATMARK
suffix:colon
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|answ
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* try to figure out if we need to read some urgent data. */
r_if
c_cond
(paren
id|sk-&gt;rqueue
op_ne
l_int|NULL
)paren
(brace
id|skb
op_assign
id|sk-&gt;rqueue-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;copied_seq
op_plus
l_int|1
op_eq
id|skb-&gt;h.th-&gt;seq
op_logical_and
id|skb-&gt;h.th-&gt;urg
)paren
id|answ
op_assign
l_int|1
suffix:semicolon
)brace
id|verify_area
(paren
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
id|put_fs_long
(paren
id|answ
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_case
id|TIOCOUTQ
suffix:colon
(brace
r_int
r_int
id|amount
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|amount
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wspace
c_func
(paren
id|sk
)paren
op_div
l_int|2
suffix:semicolon
id|verify_area
(paren
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
id|put_fs_long
(paren
id|amount
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* this routine computes a tcp checksum */
r_static
r_int
r_int
DECL|function|tcp_check
id|tcp_check
(paren
r_struct
id|tcp_header
op_star
id|th
comma
r_int
id|len
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
)paren
(brace
r_int
r_int
id|sum
suffix:semicolon
r_if
c_cond
(paren
id|saddr
op_eq
l_int|0
)paren
id|saddr
op_assign
id|MY_IP_ADDR
suffix:semicolon
id|print_th
(paren
id|th
)paren
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t addl %%ecx,%%ebx&bslash;n&quot;
l_string|&quot;&bslash;t adcl %%edx,%%ebx&bslash;n&quot;
l_string|&quot;&bslash;t adcl $0, %%ebx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|daddr
)paren
comma
l_string|&quot;c&quot;
(paren
id|saddr
)paren
comma
l_string|&quot;d&quot;
(paren
(paren
id|net16
c_func
(paren
id|len
)paren
op_lshift
l_int|16
)paren
op_plus
id|IPPROTO_TCP
op_star
l_int|256
)paren
suffix:colon
l_string|&quot;cx&quot;
comma
l_string|&quot;bx&quot;
comma
l_string|&quot;dx&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|3
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;&bslash;tclc&bslash;n&quot;
l_string|&quot;1:&bslash;n&quot;
l_string|&quot;&bslash;t lodsl&bslash;n&quot;
l_string|&quot;&bslash;t adcl %%eax, %%ebx&bslash;n&quot;
l_string|&quot;&bslash;t loop 1b&bslash;n&quot;
l_string|&quot;&bslash;t adcl $0, %%ebx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
comma
l_string|&quot;=S&quot;
(paren
id|th
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;c&quot;
(paren
id|len
op_div
l_int|4
)paren
comma
l_string|&quot;1&quot;
(paren
id|th
)paren
suffix:colon
l_string|&quot;ax&quot;
comma
l_string|&quot;cx&quot;
comma
l_string|&quot;bx&quot;
comma
l_string|&quot;si&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* convert from 32 bits to 16 bits. */
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t movl %%ebx, %%ecx&bslash;n&quot;
l_string|&quot;&bslash;t shrl $16,%%ecx&bslash;n&quot;
l_string|&quot;&bslash;t addw %%cx, %%bx&bslash;n&quot;
l_string|&quot;&bslash;t adcw $0, %%bx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;bx&quot;
comma
l_string|&quot;cx&quot;
)paren
suffix:semicolon
multiline_comment|/* check for an extra word. */
r_if
c_cond
(paren
(paren
id|len
op_amp
l_int|2
)paren
op_ne
l_int|0
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t lodsw&bslash;n&quot;
l_string|&quot;&bslash;t addw %%ax,%%bx&bslash;n&quot;
l_string|&quot;&bslash;t adcw $0, %%bx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
comma
l_string|&quot;=S&quot;
(paren
id|th
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;1&quot;
(paren
id|th
)paren
suffix:colon
l_string|&quot;si&quot;
comma
l_string|&quot;ax&quot;
comma
l_string|&quot;bx&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* now check for the extra byte. */
r_if
c_cond
(paren
(paren
id|len
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t lodsb&bslash;n&quot;
l_string|&quot;&bslash;t movb $0,%%ah&bslash;n&quot;
l_string|&quot;&bslash;t addw %%ax,%%bx&bslash;n&quot;
l_string|&quot;&bslash;t adcw $0, %%bx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;S&quot;
(paren
id|th
)paren
suffix:colon
l_string|&quot;si&quot;
comma
l_string|&quot;ax&quot;
comma
l_string|&quot;bx&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* we only want the bottom 16 bits, but we never cleared&n;      the top 16. */
r_return
(paren
(paren
op_complement
id|sum
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|tcp_send_check
id|tcp_send_check
(paren
r_struct
id|tcp_header
op_star
id|th
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
comma
r_int
id|len
comma
r_volatile
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|th-&gt;check
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_logical_and
id|sk-&gt;no_check
)paren
r_return
suffix:semicolon
id|th-&gt;check
op_assign
id|tcp_check
(paren
id|th
comma
id|len
comma
id|saddr
comma
id|daddr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* This routine sends an ack and also updates the window. */
r_static
r_void
DECL|function|tcp_send_ack
id|tcp_send_ack
(paren
r_int
r_int
id|sequence
comma
r_int
r_int
id|ack
comma
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_header
op_star
id|th
comma
r_int
r_int
id|daddr
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcp_header
op_star
id|t1
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tmp
suffix:semicolon
multiline_comment|/* we need to grab some memory, and put together an ack, and then&n;      put it into the queue to be sent. */
id|buff
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|MAX_ACK_SIZE
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* force it to send an ack. */
id|sk-&gt;ack_backlog
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;timeout
op_ne
id|TIME_WRITE
op_logical_and
id|sk-&gt;state
OL
id|TCP_CLOSING
)paren
(brace
id|sk-&gt;timeout
op_assign
id|TIME_WRITE
suffix:semicolon
id|sk-&gt;time_wait.len
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* got to do it quickly. */
id|reset_timer
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|buff-&gt;mem_addr
op_assign
id|buff
suffix:semicolon
id|buff-&gt;mem_len
op_assign
id|MAX_ACK_SIZE
suffix:semicolon
id|buff-&gt;len
op_assign
r_sizeof
(paren
r_struct
id|tcp_header
)paren
suffix:semicolon
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcp_header
op_star
)paren
(paren
id|buff
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* put in the ip_header and routing stuff. */
id|tmp
op_assign
id|sk-&gt;prot-&gt;build_header
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|MAX_ACK_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sk-&gt;prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|buff-&gt;mem_addr
comma
id|buff-&gt;mem_len
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buff-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcp_header
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|t1
op_plus
id|tmp
)paren
suffix:semicolon
id|memcpy
(paren
id|t1
comma
id|th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
multiline_comment|/* this should probably be removed. */
multiline_comment|/* swap the send and the receive. */
id|t1-&gt;dest
op_assign
id|th-&gt;source
suffix:semicolon
id|t1-&gt;source
op_assign
id|th-&gt;dest
suffix:semicolon
id|t1-&gt;seq
op_assign
id|net32
c_func
(paren
id|sequence
)paren
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;window
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
suffix:semicolon
id|t1-&gt;window
op_assign
id|net16
c_func
(paren
id|sk-&gt;window
)paren
suffix:semicolon
id|t1-&gt;res1
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;res2
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;syn
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;fin
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ack
op_eq
id|sk-&gt;acked_seq
)paren
(brace
id|sk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;bytes_rcv
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ack_timed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;send_head
op_eq
l_int|NULL
op_logical_and
id|sk-&gt;wfront
op_eq
l_int|NULL
)paren
(brace
id|delete_timer
c_func
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
id|sk-&gt;timeout
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|t1-&gt;ack_seq
op_assign
id|net32
c_func
(paren
id|ack
)paren
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
suffix:semicolon
id|tcp_send_check
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* this routine builds a generic tcp header. */
r_static
r_int
DECL|function|tcp_build_header
id|tcp_build_header
c_func
(paren
r_struct
id|tcp_header
op_star
id|th
comma
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
id|push
)paren
(brace
multiline_comment|/* want to get rid of this. */
id|memcpy
(paren
id|th
comma
(paren
r_void
op_star
)paren
op_amp
(paren
id|sk-&gt;dummy_th
)paren
comma
r_sizeof
(paren
op_star
id|th
)paren
)paren
suffix:semicolon
id|th-&gt;seq
op_assign
id|net32
c_func
(paren
id|sk-&gt;send_seq
)paren
suffix:semicolon
id|th-&gt;psh
op_assign
(paren
id|push
op_eq
l_int|0
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|th-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|th
)paren
op_div
l_int|4
suffix:semicolon
id|th-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|th-&gt;fin
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;bytes_rcv
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ack_timed
op_assign
l_int|0
suffix:semicolon
id|th-&gt;ack_seq
op_assign
id|net32
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|sk-&gt;window
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
suffix:semicolon
id|th-&gt;window
op_assign
id|net16
c_func
(paren
id|sk-&gt;window
)paren
suffix:semicolon
r_return
(paren
r_sizeof
(paren
op_star
id|th
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This routine copies from a user buffer into a socket, and starts&n;   the transmit system. */
r_static
r_int
DECL|function|tcp_write
id|tcp_write
c_func
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|from
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
)paren
(brace
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
r_int
id|copy
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_char
op_star
id|buff
suffix:semicolon
r_struct
id|proto
op_star
id|prot
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;in TCP_WRITE sk = %X:&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
id|print_sk
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* no one else will use this socket. */
id|prot
op_assign
id|sk-&gt;prot
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
multiline_comment|/* first thing we do is make sure that we are established. */
r_while
c_loop
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_SYN_SENT
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_SYN_RECV
)paren
(brace
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;keepopen
)paren
(brace
id|send_sig
(paren
id|SIGPIPE
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EINTR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copied
)paren
r_return
(paren
id|copied
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
r_return
(paren
op_minus
id|sk-&gt;err
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENOTCONN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nonblock
)paren
(brace
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
)brace
multiline_comment|/* now here is a race condition.&n;&t;     release_sock could cause the connection to&n;&t;     enter the established mode, if that is the&n;&t;     case, then we will block here for ever, because&n;&t;     we will have gotten our wakeup call before we&n;&t;     go to sleep. */
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
)paren
(brace
id|interruptible_sleep_on
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
(paren
id|copied
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* we also need to worry about the window.  The smallest we&n;&t; will send is about 200 bytes. */
id|copy
op_assign
id|min
(paren
id|sk-&gt;mtu
comma
id|diff
c_func
(paren
id|sk-&gt;window_seq
comma
id|sk-&gt;send_seq
)paren
)paren
suffix:semicolon
multiline_comment|/* redundent check here. */
r_if
c_cond
(paren
id|copy
template_param
id|sk-&gt;mtu
)paren
id|copy
op_assign
id|sk-&gt;mtu
suffix:semicolon
id|copy
op_assign
id|min
(paren
id|copy
comma
id|len
)paren
suffix:semicolon
id|skb
op_assign
id|prot-&gt;wmalloc
(paren
id|sk
comma
id|copy
op_plus
id|prot-&gt;max_header
op_plus
r_sizeof
(paren
op_star
id|skb
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* if we didn&squot;t get any memory, we need to sleep. */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|nonblock
op_logical_or
id|copied
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* here is another race condition. */
id|tmp
op_assign
id|sk-&gt;wmem_alloc
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* again we will try to avoid it. */
id|cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_le
id|sk-&gt;wmem_alloc
)paren
(brace
id|interruptible_sleep_on
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
(paren
id|copied
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|skb-&gt;mem_addr
op_assign
id|skb
suffix:semicolon
id|skb-&gt;mem_len
op_assign
id|copy
op_plus
id|prot-&gt;max_header
op_plus
r_sizeof
(paren
op_star
id|skb
)paren
suffix:semicolon
id|skb-&gt;len
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|buff
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* we need to optimize this.  Perhaps some hints here&n;&t;  would be good. */
id|tmp
op_assign
id|prot-&gt;build_header
(paren
id|skb
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|prot-&gt;wfree
(paren
id|sk
comma
id|skb-&gt;mem_addr
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|skb-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|buff
op_add_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tcp_build_header
c_func
(paren
(paren
r_struct
id|tcp_header
op_star
)paren
id|buff
comma
id|sk
comma
id|len
op_minus
id|copy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|prot-&gt;wfree
(paren
id|sk
comma
id|skb-&gt;mem_addr
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
id|tmp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_OOB
)paren
(brace
(paren
(paren
r_struct
id|tcp_header
op_star
)paren
id|buff
)paren
op_member_access_from_pointer
id|urg
op_assign
l_int|1
suffix:semicolon
(paren
(paren
r_struct
id|tcp_header
op_star
)paren
id|buff
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
id|copy
suffix:semicolon
)brace
id|skb-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|memcpy_fromfs
(paren
id|buff
op_plus
id|tmp
comma
id|from
comma
id|copy
)paren
suffix:semicolon
id|tcp_send_check
(paren
(paren
r_struct
id|tcp_header
op_star
)paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
id|copy
op_plus
r_sizeof
(paren
r_struct
id|tcp_header
)paren
comma
id|sk
)paren
suffix:semicolon
id|from
op_add_assign
id|copy
suffix:semicolon
id|copied
op_add_assign
id|copy
suffix:semicolon
id|len
op_sub_assign
id|copy
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|copy
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;send_seq
op_add_assign
id|copy
suffix:semicolon
id|skb-&gt;h.seq
op_assign
id|sk-&gt;send_seq
suffix:semicolon
r_if
c_cond
(paren
id|after
(paren
id|sk-&gt;send_seq
comma
id|sk-&gt;window_seq
)paren
op_logical_or
id|sk-&gt;packets_out
op_ge
id|sk-&gt;cong_window
)paren
(brace
id|PRINTK
(paren
l_string|&quot;sk-&gt;cong_window = %d, sk-&gt;packets_out = %d&bslash;n&quot;
comma
id|sk-&gt;cong_window
comma
id|sk-&gt;packets_out
)paren
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;sk-&gt;send_seq = %d, sk-&gt;window_seq = %d&bslash;n&quot;
comma
id|sk-&gt;send_seq
comma
id|sk-&gt;window_seq
)paren
suffix:semicolon
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;wback
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;wfront
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;wback-&gt;next
op_assign
id|skb
suffix:semicolon
)brace
id|sk-&gt;wback
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|prot-&gt;queue_xmit
(paren
id|sk
comma
id|dev
comma
id|skb
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
id|copied
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|tcp_read_wakeup
id|tcp_read_wakeup
c_func
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|tmp
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|tcp_header
op_star
id|t1
suffix:semicolon
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;ack_backlog
)paren
r_return
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;in tcp read wakeup&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* we need to put code here to prevent this routine from being called. */
multiline_comment|/* being called once in a while is ok, so only check if this is the&n;     second time in a row. */
multiline_comment|/* we need to grab some memory, and put together an ack, and then&n;     put it into the queue to be sent. */
id|buff
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|MAX_ACK_SIZE
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* try again real soon. */
id|sk-&gt;timeout
op_assign
id|TIME_WRITE
suffix:semicolon
id|sk-&gt;time_wait.len
op_assign
l_int|10
suffix:semicolon
id|reset_timer
c_func
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buff-&gt;mem_addr
op_assign
id|buff
suffix:semicolon
id|buff-&gt;mem_len
op_assign
id|MAX_ACK_SIZE
suffix:semicolon
id|buff-&gt;len
op_assign
r_sizeof
(paren
r_struct
id|tcp_header
)paren
suffix:semicolon
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
multiline_comment|/* put in the ip_header and routing stuff. */
id|tmp
op_assign
id|sk-&gt;prot-&gt;build_header
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|MAX_ACK_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sk-&gt;prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|buff-&gt;mem_addr
comma
id|buff-&gt;mem_len
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buff-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcp_header
op_star
)paren
(paren
(paren
r_char
op_star
)paren
(paren
id|buff
op_plus
l_int|1
)paren
op_plus
id|tmp
)paren
suffix:semicolon
id|memcpy
(paren
id|t1
comma
(paren
r_void
op_star
)paren
op_amp
id|sk-&gt;dummy_th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
id|t1-&gt;seq
op_assign
id|net32
c_func
(paren
id|sk-&gt;send_seq
)paren
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;res1
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;res2
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;syn
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;bytes_rcv
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;window
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
suffix:semicolon
id|t1-&gt;window
op_assign
id|net16
c_func
(paren
id|sk-&gt;window
)paren
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|net32
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
suffix:semicolon
id|tcp_send_check
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* This routine frees used buffers. */
multiline_comment|/* It should consider sending an ack to let the&n;   other end know we now have a bigger window. */
r_static
r_void
DECL|function|cleanup_rbuf
id|cleanup_rbuf
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|PRINTK
(paren
l_string|&quot;cleaning rbuf for sk=%X&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/* we have to loop through all the buffer headers, and &n;     try to free up all the space we can. */
r_while
c_loop
(paren
id|sk-&gt;rqueue
op_ne
l_int|NULL
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|sk-&gt;rqueue-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;used
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rqueue
op_eq
id|skb
)paren
(brace
id|sk-&gt;rqueue
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;next-&gt;prev
op_assign
id|skb-&gt;prev
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
multiline_comment|/* at this point we should send an ack if the difference in&n;      the window, and the amount of space is bigger than&n;      TCP_WINDOW_DIFF */
id|PRINTK
(paren
l_string|&quot;sk-&gt;window left = %d, sk-&gt;prot-&gt;rspace(sk)=%d&bslash;n&quot;
comma
id|sk-&gt;window
op_minus
id|sk-&gt;bytes_rcv
comma
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
OG
(paren
id|sk-&gt;window
op_minus
id|sk-&gt;bytes_rcv
op_plus
id|TCP_WINDOW_DIFF
)paren
)paren
op_logical_or
(paren
id|sk-&gt;window
op_minus
id|sk-&gt;bytes_rcv
OL
l_int|2
op_star
id|sk-&gt;mtu
)paren
)paren
(brace
multiline_comment|/* force it to send an ack. */
id|sk-&gt;ack_backlog
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;timeout
op_ne
id|TIME_WRITE
op_logical_and
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
)paren
(brace
id|sk-&gt;time_wait.len
op_assign
id|TCP_ACK_TIME
suffix:semicolon
id|sk-&gt;timeout
op_assign
id|TIME_WRITE
suffix:semicolon
id|reset_timer
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* handle reading urgent data. */
r_static
r_int
DECL|function|tcp_read_urg
id|tcp_read_urg
c_func
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|to
comma
r_int
id|len
comma
r_int
id|flags
)paren
(brace
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;tcp_read_urg(sk=%X, to=%X, len=%d, flags=%X)&bslash;n&quot;
comma
id|sk
comma
id|to
comma
id|len
comma
id|flags
)paren
suffix:semicolon
id|print_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|sk-&gt;urg
op_eq
l_int|0
op_logical_or
id|sk-&gt;rqueue
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* now at this point, we may have gotten some data. */
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
OG
id|TCP_CLOSING
)paren
(brace
r_if
c_cond
(paren
id|copied
)paren
r_return
(paren
id|copied
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENOTCONN
)paren
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;urg
op_eq
l_int|0
op_logical_or
id|sk-&gt;rqueue
op_eq
l_int|NULL
)paren
(brace
id|interruptible_sleep_on
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
(paren
id|copied
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* now we have some urgent data, we must find it.*/
r_for
c_loop
(paren
id|skb
op_assign
id|sk-&gt;rqueue-&gt;next
suffix:semicolon
id|skb-&gt;next
op_ne
id|sk-&gt;rqueue
suffix:semicolon
id|skb
op_assign
id|skb-&gt;next
)paren
(brace
r_int
id|offset
suffix:semicolon
r_int
id|amt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;h.th-&gt;urg
)paren
r_continue
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|amt
op_assign
id|min
c_func
(paren
id|skb-&gt;h.th-&gt;urg_ptr
comma
id|len
)paren
suffix:semicolon
id|verify_area
(paren
id|to
comma
id|amt
)paren
suffix:semicolon
id|memcpy_tofs
(paren
id|to
comma
(paren
r_int
r_char
op_star
)paren
(paren
id|skb-&gt;h.th
)paren
op_plus
id|skb-&gt;h.th-&gt;doff
op_star
l_int|4
op_plus
id|offset
comma
id|amt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
)paren
(brace
id|skb-&gt;urg_used
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;urg
op_decrement
suffix:semicolon
)brace
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
id|copied
op_add_assign
id|amt
suffix:semicolon
r_return
(paren
id|copied
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* This routine copies from a sock struct into the user buffer. */
r_static
r_int
DECL|function|tcp_read
id|tcp_read
c_func
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|to
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
)paren
(brace
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* will be used to say how much has been copied. */
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
r_int
id|used
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/* this error should be checked. */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
(paren
op_minus
id|ENOTCONN
)paren
suffix:semicolon
multiline_comment|/* will catch some errors. */
r_if
c_cond
(paren
id|sk-&gt;err
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
op_minus
id|sk-&gt;err
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/* urgent data needs to be handled specially. */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|MSG_OOB
)paren
)paren
r_return
(paren
id|tcp_read_urg
(paren
id|sk
comma
id|to
comma
id|len
comma
id|flags
)paren
)paren
suffix:semicolon
multiline_comment|/* so no-one else will use this socket. */
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rqueue
op_ne
l_int|NULL
)paren
id|skb
op_assign
id|sk-&gt;rqueue-&gt;next
suffix:semicolon
r_else
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;tcp_read (sk=%X, to=%X, len=%d, nonblock=%d, flags=%X)&bslash;n&quot;
comma
id|sk
comma
id|to
comma
id|len
comma
id|nonblock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|skb
op_eq
l_int|NULL
op_logical_or
id|before
(paren
id|sk-&gt;copied_seq
op_plus
l_int|1
comma
id|skb-&gt;h.th-&gt;seq
)paren
op_logical_or
id|skb-&gt;used
)paren
multiline_comment|/* skb-&gt;used just checks to see if we&squot;ve&n;&t;&t;&t;       gone all the way around. */
(brace
id|PRINTK
c_func
(paren
l_string|&quot;skb = %X:&bslash;n&quot;
comma
id|skb
)paren
suffix:semicolon
id|print_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|print_sk
(paren
id|sk
)paren
suffix:semicolon
id|cleanup_rbuf
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* now we may have some data waiting. */
id|PRINTK
(paren
l_string|&quot;tcp_read about to sleep. state = %d&bslash;n&quot;
comma
id|sk-&gt;state
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_TIME_WAIT
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
(paren
id|copied
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
r_return
(paren
op_minus
id|sk-&gt;err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;done
)paren
(brace
id|sk-&gt;done
op_assign
l_int|1
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
op_minus
id|ENOTCONN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nonblock
op_logical_or
(paren
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
op_logical_and
id|copied
)paren
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
(paren
id|copied
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;rqueue
op_eq
l_int|NULL
op_logical_or
id|before
(paren
id|sk-&gt;copied_seq
op_plus
l_int|1
comma
id|sk-&gt;rqueue-&gt;next-&gt;h.th-&gt;seq
)paren
)paren
(brace
id|interruptible_sleep_on
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|sti
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
(paren
id|copied
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;tcp_read woke up. &bslash;n&quot;
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rqueue
op_ne
l_int|NULL
)paren
id|skb
op_assign
id|sk-&gt;rqueue-&gt;next
suffix:semicolon
r_else
id|skb
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Copy anything from the current block that needs to go&n;&t;     into the user buffer. */
id|offset
op_assign
id|sk-&gt;copied_seq
op_plus
l_int|1
op_minus
id|skb-&gt;h.th-&gt;seq
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;syn
)paren
id|offset
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
id|skb-&gt;len
)paren
(brace
multiline_comment|/* if there is urgent data we must either return or skip&n;&t;&t; over it. */
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;urg
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;urg_used
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
r_break
suffix:semicolon
id|sk-&gt;copied_seq
op_add_assign
id|skb-&gt;h.th-&gt;urg_ptr
suffix:semicolon
id|offset
op_add_assign
id|skb-&gt;h.th-&gt;urg_ptr
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
id|skb-&gt;len
)paren
(brace
id|skb-&gt;used
op_assign
l_int|1
suffix:semicolon
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
id|used
op_assign
id|min
c_func
(paren
id|skb-&gt;len
op_minus
id|offset
comma
id|len
)paren
suffix:semicolon
id|verify_area
(paren
id|to
comma
id|used
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|to
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|skb-&gt;h.th
)paren
op_plus
id|skb-&gt;h.th-&gt;doff
op_star
l_int|4
op_plus
id|offset
comma
id|used
)paren
suffix:semicolon
id|copied
op_add_assign
id|used
suffix:semicolon
id|len
op_sub_assign
id|used
suffix:semicolon
id|to
op_add_assign
id|used
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
)paren
id|sk-&gt;copied_seq
op_add_assign
id|used
suffix:semicolon
multiline_comment|/* mark this data used if we are really reading it, and if&n;&t;&t; it doesn&squot;t contain any urgent data. And we have used all&n;&t;&t; the data. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
op_logical_and
(paren
op_logical_neg
id|skb-&gt;h.th-&gt;urg
op_logical_or
id|skb-&gt;urg_used
)paren
op_logical_and
(paren
id|used
op_plus
id|offset
op_ge
id|skb-&gt;len
)paren
)paren
id|skb-&gt;used
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* see if this is the end of a message or if the remaining data&n;&t;&t; is urgent. */
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;psh
op_logical_or
id|skb-&gt;h.th-&gt;urg
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* already used this data, must be a retransmit. */
(brace
id|skb-&gt;used
op_assign
l_int|1
suffix:semicolon
)brace
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
id|cleanup_rbuf
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
op_eq
l_int|0
op_logical_and
id|nonblock
)paren
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
r_return
(paren
id|copied
)paren
suffix:semicolon
)brace
multiline_comment|/* this routine will send a reset to the other tcp. */
r_static
r_void
DECL|function|tcp_reset
id|tcp_reset
c_func
(paren
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
comma
r_struct
id|tcp_header
op_star
id|th
comma
r_struct
id|proto
op_star
id|prot
comma
r_struct
id|options
op_star
id|opt
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
multiline_comment|/* we need to grab some memory, and put together a reset, and then&n;     put it into the queue to be sent. */
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcp_header
op_star
id|t1
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|buff
op_assign
id|prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
l_int|NULL
comma
id|MAX_RESET_SIZE
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;tcp_reset buff = %X&bslash;n&quot;
comma
id|buff
)paren
suffix:semicolon
id|buff-&gt;mem_addr
op_assign
id|buff
suffix:semicolon
id|buff-&gt;mem_len
op_assign
id|MAX_RESET_SIZE
suffix:semicolon
id|buff-&gt;len
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
suffix:semicolon
id|buff-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|buff-&gt;dev
op_assign
id|dev
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcp_header
op_star
)paren
(paren
id|buff
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* put in the ip_header and routing stuff. */
id|tmp
op_assign
id|prot-&gt;build_header
(paren
id|buff
comma
id|saddr
comma
id|daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|opt
comma
r_sizeof
(paren
r_struct
id|tcp_header
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|prot-&gt;wfree
(paren
l_int|NULL
comma
id|buff-&gt;mem_addr
comma
id|buff-&gt;mem_len
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|t1
op_assign
(paren
r_struct
id|tcp_header
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|t1
op_plus
id|tmp
)paren
suffix:semicolon
id|buff-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|memcpy
(paren
id|t1
comma
id|th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
multiline_comment|/* swap the send and the receive. */
id|t1-&gt;dest
op_assign
id|th-&gt;source
suffix:semicolon
id|t1-&gt;source
op_assign
id|th-&gt;dest
suffix:semicolon
id|t1-&gt;seq
op_assign
id|th-&gt;ack_seq
suffix:semicolon
multiline_comment|/* add one so it will be in&n;&t;&t;&t;    the right range.*/
id|t1-&gt;rst
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;syn
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;fin
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
suffix:semicolon
id|tcp_send_check
(paren
id|t1
comma
id|saddr
comma
id|daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
l_int|NULL
)paren
suffix:semicolon
id|prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
l_int|NULL
comma
id|dev
comma
id|buff
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* This routine handles a connection request.  This should make sure&n;   we haven&squot;t already responded. */
multiline_comment|/* Because of the way BSD works, we have to send a syn/ack now. This also&n; means it will be harder to close a socket which is listening. */
r_static
r_void
DECL|function|tcp_conn_request
id|tcp_conn_request
c_func
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|saddr
comma
r_struct
id|options
op_star
id|opt
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcp_header
op_star
id|t1
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_volatile
r_struct
id|sock
op_star
id|newsk
suffix:semicolon
r_struct
id|tcp_header
op_star
id|th
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;tcp_conn_request (sk = %X, skb = %X, daddr = %X, sadd4= %X, &bslash;n&quot;
l_string|&quot;                  opt = %X, dev = %X)&bslash;n&quot;
comma
id|sk
comma
id|skb
comma
id|daddr
comma
id|saddr
comma
id|opt
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* if the socket is dead, don&squot;t accept the connection. */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|wake_up
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTK
(paren
l_string|&quot;tcp_conn_request on dead socket&bslash;n&quot;
)paren
suffix:semicolon
id|tcp_reset
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
)paren
suffix:semicolon
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* we need to build a new sock struct. */
multiline_comment|/* It is sort of bad to have a socket without an inode attached to&n;     it, but the wake_up&squot;s will just wake up the listening socket,&n;     and if the listening socket is destroyed before this is taken&n;     off of the queue, this will take care of it. */
id|newsk
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newsk
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* just ignore the syn.  It will get retransmitted. */
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|PRINTK
(paren
l_string|&quot;newsk = %X&bslash;n&quot;
comma
id|newsk
)paren
suffix:semicolon
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|newsk
comma
(paren
r_void
op_star
)paren
id|sk
comma
r_sizeof
(paren
op_star
id|newsk
)paren
)paren
suffix:semicolon
id|newsk-&gt;wback
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;wfront
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;rqueue
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;send_head
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;send_tail
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;back_log
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;blog
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;intr
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;proc
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;done
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;pair
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;wmem_alloc
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;rmem_alloc
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;max_unacked
op_assign
id|MAX_WINDOW
op_minus
id|TCP_WINDOW_DIFF
suffix:semicolon
id|newsk-&gt;err
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;shutdown
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;acked_seq
op_assign
id|skb-&gt;h.th-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|newsk-&gt;fin_seq
op_assign
id|skb-&gt;h.th-&gt;seq
suffix:semicolon
id|newsk-&gt;copied_seq
op_assign
id|skb-&gt;h.th-&gt;seq
suffix:semicolon
id|newsk-&gt;state
op_assign
id|TCP_SYN_RECV
suffix:semicolon
id|newsk-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;send_seq
op_assign
id|timer_seq
op_star
id|SEQ_TICK
op_minus
id|seq_offset
suffix:semicolon
id|newsk-&gt;rcv_ack_seq
op_assign
id|newsk-&gt;send_seq
suffix:semicolon
id|newsk-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;destroy
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;time_wait.sk
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;time_wait.next
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;dummy_th.source
op_assign
id|skb-&gt;h.th-&gt;dest
suffix:semicolon
id|newsk-&gt;dummy_th.dest
op_assign
id|skb-&gt;h.th-&gt;source
suffix:semicolon
multiline_comment|/* swap these two, they are from our point of view. */
id|newsk-&gt;daddr
op_assign
id|saddr
suffix:semicolon
id|newsk-&gt;saddr
op_assign
id|daddr
suffix:semicolon
id|put_sock
(paren
id|newsk-&gt;num
comma
id|newsk
)paren
suffix:semicolon
id|newsk-&gt;dummy_th.res1
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.doff
op_assign
l_int|6
suffix:semicolon
id|newsk-&gt;dummy_th.fin
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.syn
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.rst
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.psh
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.ack
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.urg
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.res2
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;acked_seq
op_assign
id|skb-&gt;h.th-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|newsk-&gt;copied_seq
op_assign
id|skb-&gt;h.th-&gt;seq
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;doff
op_eq
l_int|5
)paren
(brace
id|newsk-&gt;mtu
op_assign
l_int|576
op_minus
id|HEADER_SIZE
suffix:semicolon
)brace
r_else
(brace
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
(braket
l_int|0
)braket
op_ne
l_int|2
op_logical_or
id|ptr
(braket
l_int|1
)braket
op_ne
l_int|4
)paren
(brace
id|newsk-&gt;mtu
op_assign
l_int|576
op_minus
id|HEADER_SIZE
suffix:semicolon
)brace
r_else
(brace
id|newsk-&gt;mtu
op_assign
id|min
(paren
id|ptr
(braket
l_int|2
)braket
op_star
l_int|256
op_plus
id|ptr
(braket
l_int|3
)braket
op_minus
id|HEADER_SIZE
comma
id|dev-&gt;mtu
op_minus
id|HEADER_SIZE
)paren
suffix:semicolon
)brace
)brace
id|print_sk
(paren
id|newsk
)paren
suffix:semicolon
id|buff
op_assign
id|newsk-&gt;prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|newsk
comma
id|MAX_SYN_SIZE
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|newsk-&gt;dead
op_assign
l_int|1
suffix:semicolon
id|release_sock
(paren
id|newsk
)paren
suffix:semicolon
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buff-&gt;mem_addr
op_assign
id|buff
suffix:semicolon
id|buff-&gt;mem_len
op_assign
id|MAX_SYN_SIZE
suffix:semicolon
id|buff-&gt;len
op_assign
r_sizeof
(paren
r_struct
id|tcp_header
)paren
op_plus
l_int|4
suffix:semicolon
id|buff-&gt;sk
op_assign
id|newsk
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcp_header
op_star
)paren
(paren
id|buff
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* put in the ip_header and routing stuff. */
id|tmp
op_assign
id|sk-&gt;prot-&gt;build_header
(paren
id|buff
comma
id|newsk-&gt;saddr
comma
id|newsk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
l_int|NULL
comma
id|MAX_SYN_SIZE
)paren
suffix:semicolon
multiline_comment|/* something went wrong. */
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sk-&gt;err
op_assign
id|tmp
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|newsk
comma
id|buff-&gt;mem_addr
comma
id|buff-&gt;mem_len
)paren
suffix:semicolon
id|newsk-&gt;dead
op_assign
l_int|1
suffix:semicolon
id|release_sock
(paren
id|newsk
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buff-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcp_header
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|t1
op_plus
id|tmp
)paren
suffix:semicolon
id|memcpy
(paren
id|t1
comma
id|skb-&gt;h.th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
id|buff-&gt;h.seq
op_assign
id|newsk-&gt;send_seq
suffix:semicolon
multiline_comment|/* swap the send and the receive. */
id|t1-&gt;dest
op_assign
id|skb-&gt;h.th-&gt;source
suffix:semicolon
id|t1-&gt;source
op_assign
id|newsk-&gt;dummy_th.source
suffix:semicolon
id|t1-&gt;seq
op_assign
id|net32
c_func
(paren
id|newsk-&gt;send_seq
op_increment
)paren
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|newsk-&gt;window
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|t1-&gt;window
op_assign
id|net16
c_func
(paren
id|newsk-&gt;window
)paren
suffix:semicolon
id|t1-&gt;res1
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;res2
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;syn
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|net32
c_func
(paren
id|skb-&gt;h.th-&gt;seq
op_plus
l_int|1
)paren
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
op_plus
l_int|1
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|t1
op_plus
l_int|1
)paren
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
l_int|2
suffix:semicolon
id|ptr
(braket
l_int|1
)braket
op_assign
l_int|4
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
(paren
(paren
id|dev-&gt;mtu
op_minus
id|HEADER_SIZE
)paren
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|ptr
(braket
l_int|3
)braket
op_assign
(paren
id|dev-&gt;mtu
op_minus
id|HEADER_SIZE
)paren
op_amp
l_int|0xff
suffix:semicolon
id|tcp_send_check
(paren
id|t1
comma
id|daddr
comma
id|saddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
op_plus
l_int|4
comma
id|newsk
)paren
suffix:semicolon
id|newsk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|newsk
comma
id|dev
comma
id|buff
comma
l_int|0
)paren
suffix:semicolon
id|newsk-&gt;time_wait.len
op_assign
id|TCP_CONNECT_TIME
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;newsk-&gt;time_wait.sk = %X&bslash;n&quot;
comma
id|newsk-&gt;time_wait.sk
)paren
suffix:semicolon
id|reset_timer
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|newsk-&gt;time_wait
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
id|newsk
suffix:semicolon
multiline_comment|/* charge the sock_buff to newsk. */
id|sk-&gt;rmem_alloc
op_sub_assign
id|skb-&gt;mem_len
suffix:semicolon
id|newsk-&gt;rmem_alloc
op_add_assign
id|skb-&gt;mem_len
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rqueue
op_eq
l_int|NULL
)paren
(brace
id|skb-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev
op_assign
id|skb
suffix:semicolon
id|sk-&gt;rqueue
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;next
op_assign
id|sk-&gt;rqueue
suffix:semicolon
id|skb-&gt;prev
op_assign
id|sk-&gt;rqueue-&gt;prev
suffix:semicolon
id|sk-&gt;rqueue-&gt;prev
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb
suffix:semicolon
)brace
id|release_sock
(paren
id|newsk
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|tcp_close
id|tcp_close
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeout
)paren
(brace
multiline_comment|/* we need to grab some memory, and put together a fin, and then&n;     put it into the queue to be sent. */
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_int
id|need_reset
op_assign
l_int|0
suffix:semicolon
r_struct
id|tcp_header
op_star
id|t1
comma
op_star
id|th
suffix:semicolon
r_struct
id|proto
op_star
id|prot
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;tcp_close ((struct sock *)%X, %d)&bslash;n&quot;
comma
id|sk
comma
id|timeout
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;keepopen
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|wake_up
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
multiline_comment|/* we need to flush the recv. buffs. */
r_if
c_cond
(paren
id|sk-&gt;rqueue
op_ne
l_int|NULL
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
id|skb
op_assign
id|sk-&gt;rqueue
suffix:semicolon
r_do
(brace
id|skb2
op_assign
id|skb-&gt;next
suffix:semicolon
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|skb
op_assign
id|skb2
suffix:semicolon
)brace
r_while
c_loop
(paren
id|skb
op_ne
id|sk-&gt;rqueue
)paren
suffix:semicolon
id|need_reset
op_assign
l_int|1
suffix:semicolon
)brace
id|sk-&gt;rqueue
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_FIN_WAIT1
suffix:colon
r_case
id|TCP_FIN_WAIT2
suffix:colon
r_case
id|TCP_LAST_ACK
suffix:colon
r_if
c_cond
(paren
id|timeout
)paren
id|tcp_time_wait
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|need_reset
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_TIME_WAIT
suffix:colon
r_if
c_cond
(paren
id|timeout
)paren
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|TCP_LISTEN
suffix:colon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|TCP_CLOSE
suffix:colon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|TCP_ESTABLISHED
suffix:colon
r_case
id|TCP_SYN_SENT
suffix:colon
r_case
id|TCP_SYN_RECV
suffix:colon
id|prot
op_assign
(paren
r_struct
id|proto
op_star
)paren
id|sk-&gt;prot
suffix:semicolon
id|th
op_assign
(paren
r_struct
id|tcp_header
op_star
)paren
op_amp
id|sk-&gt;dummy_th
suffix:semicolon
id|buff
op_assign
id|prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|MAX_FIN_SIZE
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* this will force it to try again later. */
id|sk-&gt;state
op_assign
id|TCP_ESTABLISHED
suffix:semicolon
id|sk-&gt;timeout
op_assign
id|TIME_CLOSE
suffix:semicolon
id|sk-&gt;time_wait.len
op_assign
l_int|100
suffix:semicolon
multiline_comment|/* wait a second. */
id|reset_timer
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buff-&gt;mem_addr
op_assign
id|buff
suffix:semicolon
id|buff-&gt;mem_len
op_assign
id|MAX_FIN_SIZE
suffix:semicolon
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|buff-&gt;len
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcp_header
op_star
)paren
(paren
id|buff
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* put in the ip_header and routing stuff. */
id|tmp
op_assign
id|prot-&gt;build_header
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
r_sizeof
(paren
r_struct
id|tcp_header
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|prot-&gt;wfree
(paren
id|sk
comma
id|buff-&gt;mem_addr
comma
id|buff-&gt;mem_len
)paren
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;Unable to build header for fin.&bslash;n&quot;
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|t1
op_assign
(paren
r_struct
id|tcp_header
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|t1
op_plus
id|tmp
)paren
suffix:semicolon
id|buff
op_member_access_from_pointer
id|len
op_add_assign
id|tmp
suffix:semicolon
id|buff-&gt;dev
op_assign
id|dev
suffix:semicolon
id|memcpy
(paren
id|t1
comma
id|th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
id|t1-&gt;seq
op_assign
id|net32
c_func
(paren
id|sk-&gt;send_seq
)paren
suffix:semicolon
id|sk-&gt;send_seq
op_increment
suffix:semicolon
id|buff-&gt;h.seq
op_assign
id|sk-&gt;send_seq
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* ack everything immediately from now on. */
id|sk-&gt;delay_acks
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|net32
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|t1-&gt;window
op_assign
id|net16
c_func
(paren
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|t1-&gt;fin
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;rst
op_assign
id|need_reset
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
suffix:semicolon
id|tcp_send_check
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;wfront
op_eq
l_int|NULL
)paren
(brace
id|prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;time_wait.len
op_assign
id|sk-&gt;rtt
suffix:semicolon
id|sk-&gt;timeout
op_assign
id|TIME_WRITE
suffix:semicolon
id|reset_timer
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
id|buff-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;wback
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;wfront
op_assign
id|buff
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;wback-&gt;next
op_assign
id|buff
suffix:semicolon
)brace
id|sk-&gt;wback
op_assign
id|buff
suffix:semicolon
)brace
id|sk-&gt;state
op_assign
id|TCP_FIN_WAIT1
suffix:semicolon
)brace
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* This routine takes stuff off of the write queue, and puts it in the&n;   xmit queue. */
r_static
r_void
DECL|function|tcp_write_xmit
id|tcp_write_xmit
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
id|sk-&gt;wfront
op_ne
l_int|NULL
op_logical_and
id|before
(paren
id|sk-&gt;wfront-&gt;h.seq
comma
id|sk-&gt;window_seq
)paren
op_logical_and
id|sk-&gt;packets_out
OL
id|sk-&gt;cong_window
)paren
(brace
id|skb
op_assign
id|sk-&gt;wfront
suffix:semicolon
id|sk-&gt;wfront
op_assign
id|skb-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;wfront
op_eq
l_int|NULL
)paren
id|sk-&gt;wback
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;prot-&gt;queue_xmit
(paren
id|sk
comma
id|skb-&gt;dev
comma
id|skb
comma
id|skb-&gt;free
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This routine deals with incoming acks, but not outgoing ones. */
r_static
r_int
DECL|function|tcp_ack
id|tcp_ack
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_header
op_star
id|th
comma
r_int
r_int
id|saddr
)paren
(brace
r_int
r_int
id|ack
suffix:semicolon
id|ack
op_assign
id|net32
c_func
(paren
id|th-&gt;ack_seq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|between
(paren
id|ack
comma
id|sk-&gt;rcv_ack_seq
comma
id|sk-&gt;send_seq
)paren
)paren
(brace
r_if
c_cond
(paren
id|after
(paren
id|ack
comma
id|sk-&gt;send_seq
)paren
op_logical_or
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;keepopen
)paren
id|reset_timer
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
id|sk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|sk-&gt;window_seq
op_assign
id|ack
op_plus
id|net16
c_func
(paren
id|th-&gt;window
)paren
suffix:semicolon
multiline_comment|/* we don&squot;t want too many packets out there. */
r_if
c_cond
(paren
id|sk-&gt;cong_window
OL
l_int|2048
op_logical_and
id|ack
op_ne
id|sk-&gt;rcv_ack_seq
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;exp_growth
)paren
id|sk-&gt;cong_window
op_mul_assign
l_int|2
suffix:semicolon
r_else
id|sk-&gt;cong_window
op_increment
suffix:semicolon
)brace
id|sk-&gt;rcv_ack_seq
op_assign
id|ack
suffix:semicolon
multiline_comment|/* see if we can take anything off of the retransmit queue. */
r_while
c_loop
(paren
id|sk-&gt;send_head
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|before
(paren
id|sk-&gt;send_head-&gt;h.seq
comma
id|ack
op_plus
l_int|1
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|oskb
suffix:semicolon
multiline_comment|/* we have one less packet out there. */
id|sk-&gt;packets_out
op_decrement
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|oskb
op_assign
id|sk-&gt;send_head
suffix:semicolon
multiline_comment|/* estimate the rtt. */
id|sk-&gt;rtt
op_add_assign
(paren
(paren
id|jiffies
op_minus
id|oskb-&gt;when
)paren
op_minus
id|sk-&gt;rtt
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rtt
OL
l_int|30
)paren
id|sk-&gt;rtt
op_assign
l_int|30
suffix:semicolon
id|sk-&gt;send_head
op_assign
id|oskb-&gt;link3
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;send_head
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;send_tail
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* we may need to remove this from the dev send list. */
r_if
c_cond
(paren
id|oskb-&gt;next
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|oskb-&gt;next
op_ne
id|oskb
)paren
(brace
id|oskb-&gt;next-&gt;prev
op_assign
id|oskb-&gt;prev
suffix:semicolon
id|oskb-&gt;prev-&gt;next
op_assign
id|oskb-&gt;next
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_NUMBUFFS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|oskb-&gt;dev-&gt;buffs
(braket
id|i
)braket
op_assign
id|oskb
)paren
(brace
id|oskb-&gt;dev-&gt;buffs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
id|free_skb
(paren
id|oskb
comma
id|FREE_WRITE
)paren
suffix:semicolon
multiline_comment|/* write. */
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|wake_up
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* at this point we need to check to see if we have anything&n;     which needs to be retransmiteed.  If we have failed to get&n;     some acks i.e. had to retransmit something, and we succeded, we&n;     should then attempt to retransmit everything right now. */
r_if
c_cond
(paren
id|sk-&gt;retransmits
op_logical_and
id|sk-&gt;send_head
op_ne
l_int|NULL
)paren
(brace
id|sk-&gt;prot-&gt;retransmit
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
)brace
id|sk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* maybe we can take some stuff off of the write queue, and put it onto&n;     the xmit queue. */
r_if
c_cond
(paren
id|sk-&gt;wfront
op_ne
l_int|NULL
op_logical_and
id|sk-&gt;packets_out
OL
id|sk-&gt;cong_window
)paren
(brace
r_if
c_cond
(paren
id|after
(paren
id|sk-&gt;window_seq
comma
id|sk-&gt;wfront-&gt;h.seq
)paren
)paren
(brace
id|tcp_write_xmit
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk-&gt;send_head
op_eq
l_int|NULL
op_logical_and
id|sk-&gt;ack_backlog
op_eq
l_int|0
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_TIME_WAIT
)paren
(brace
id|delete_timer
c_func
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
id|sk-&gt;timeout
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_TIME_WAIT
)paren
(brace
id|sk-&gt;time_wait.len
op_assign
id|TCP_TIMEWAIT_LEN
suffix:semicolon
id|sk-&gt;timeout
op_assign
id|TIME_CLOSE
suffix:semicolon
)brace
id|reset_timer
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* see if we are done. */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_TIME_WAIT
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;rcv_ack_seq
op_eq
id|sk-&gt;send_seq
op_logical_and
id|sk-&gt;acked_seq
op_eq
id|sk-&gt;fin_seq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|wake_up
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT1
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;rcv_ack_seq
op_eq
id|sk-&gt;send_seq
)paren
id|sk-&gt;state
op_assign
id|TCP_FIN_WAIT2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LAST_ACK
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;rcv_ack_seq
op_eq
id|sk-&gt;send_seq
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;acked_seq
op_ne
id|sk-&gt;fin_seq
)paren
(brace
id|tcp_time_wait
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|wake_up
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* This routine handles the data.  If there is room in the buffer, it&n;   will be have already been moved into it.  If there is no room,&n;   then we will just have to discard the packet. */
r_static
r_int
DECL|function|tcp_data
id|tcp_data
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb1
comma
op_star
id|skb2
suffix:semicolon
r_struct
id|tcp_header
op_star
id|th
suffix:semicolon
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
id|print_th
(paren
id|th
)paren
suffix:semicolon
id|skb-&gt;len
op_assign
id|len
op_minus
(paren
id|th-&gt;doff
op_star
l_int|4
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;tcp_data len = %d sk = %X:&bslash;n&quot;
comma
id|skb-&gt;len
comma
id|sk
)paren
suffix:semicolon
id|print_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;bytes_rcv
op_add_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
op_eq
l_int|0
op_logical_and
op_logical_neg
id|th-&gt;fin
op_logical_and
op_logical_neg
id|th-&gt;urg
op_logical_and
op_logical_neg
id|th-&gt;psh
)paren
(brace
multiline_comment|/* don&squot;t want to keep passing ack&squot;s back and fourth. */
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;ack
)paren
id|tcp_send_ack
(paren
id|sk-&gt;send_seq
comma
id|sk-&gt;acked_seq
comma
id|sk
comma
id|th
comma
id|saddr
)paren
suffix:semicolon
id|free_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
(brace
multiline_comment|/* just ack everything. */
id|sk-&gt;acked_seq
op_assign
id|th-&gt;seq
op_plus
id|skb-&gt;len
op_plus
id|th-&gt;syn
op_plus
id|th-&gt;fin
suffix:semicolon
id|tcp_send_ack
(paren
id|sk-&gt;send_seq
comma
id|sk-&gt;acked_seq
comma
id|sk
comma
id|skb-&gt;h.th
comma
id|saddr
)paren
suffix:semicolon
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_TIME_WAIT
op_logical_and
id|sk-&gt;acked_seq
op_eq
id|sk-&gt;fin_seq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|wake_up
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* now we have to walk the chain, and figure out where this one&n;     goes into it.  This is set up so that the last packet we received&n;     will be the first one we look at, that way if everything comes&n;     in order, there will be no performance loss, and if they come&n;     out of order we will be able to fit things in nicely. */
r_if
c_cond
(paren
id|sk-&gt;rqueue
op_eq
l_int|NULL
)paren
(brace
id|PRINTK
(paren
l_string|&quot;tcp_data: skb = %X:&bslash;n&quot;
comma
id|skb
)paren
suffix:semicolon
id|print_skb
(paren
id|skb
)paren
suffix:semicolon
id|sk-&gt;rqueue
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev
op_assign
id|skb
suffix:semicolon
id|skb1
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|PRINTK
(paren
l_string|&quot;tcp_data adding to chain sk = %X:&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
id|print_sk
(paren
id|sk
)paren
suffix:semicolon
r_for
c_loop
(paren
id|skb1
op_assign
id|sk-&gt;rqueue
suffix:semicolon
suffix:semicolon
id|skb1
op_assign
id|skb1-&gt;prev
)paren
(brace
id|PRINTK
(paren
l_string|&quot;skb1=%X&bslash;n&quot;
comma
id|skb1
)paren
suffix:semicolon
id|print_skb
c_func
(paren
id|skb1
)paren
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;skb1-&gt;h.th-&gt;seq = %d&bslash;n&quot;
comma
id|skb1-&gt;h.th-&gt;seq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|after
(paren
id|th-&gt;seq
op_plus
l_int|1
comma
id|skb1-&gt;h.th-&gt;seq
)paren
)paren
(brace
id|skb-&gt;prev
op_assign
id|skb1
suffix:semicolon
id|skb-&gt;next
op_assign
id|skb1-&gt;next
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb
suffix:semicolon
id|skb1-&gt;next
op_assign
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|skb1
op_eq
id|sk-&gt;rqueue
)paren
id|sk-&gt;rqueue
op_assign
id|skb
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb1-&gt;prev
op_eq
id|sk-&gt;rqueue
)paren
(brace
id|skb-&gt;next
op_assign
id|skb1
suffix:semicolon
id|skb-&gt;prev
op_assign
id|skb1-&gt;prev
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb1-&gt;prev
op_assign
id|skb
suffix:semicolon
id|skb1
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* so we know we might be able to ack stuff. */
r_break
suffix:semicolon
)brace
)brace
id|PRINTK
(paren
l_string|&quot;skb = %X:&bslash;n&quot;
comma
id|skb
)paren
suffix:semicolon
id|print_skb
(paren
id|skb
)paren
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;sk now equals:&bslash;n&quot;
)paren
suffix:semicolon
id|print_sk
(paren
id|sk
)paren
suffix:semicolon
)brace
id|th-&gt;ack_seq
op_assign
id|th-&gt;seq
op_plus
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;syn
)paren
id|th-&gt;ack_seq
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;fin
)paren
id|th-&gt;ack_seq
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|before
(paren
id|sk-&gt;acked_seq
comma
id|sk-&gt;copied_seq
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;*** tcp.c:tcp_data bug acked &lt; copied&bslash;n&quot;
)paren
suffix:semicolon
id|sk-&gt;acked_seq
op_assign
id|sk-&gt;copied_seq
suffix:semicolon
)brace
multiline_comment|/* now figure out if we can ack anything. */
r_if
c_cond
(paren
id|skb1
op_eq
l_int|NULL
op_logical_or
id|skb1-&gt;acked
op_logical_or
id|before
(paren
id|th-&gt;seq
comma
id|sk-&gt;acked_seq
op_plus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|before
(paren
id|th-&gt;seq
comma
id|sk-&gt;acked_seq
op_plus
l_int|1
)paren
)paren
(brace
id|sk-&gt;acked_seq
op_assign
id|th-&gt;ack_seq
suffix:semicolon
id|skb-&gt;acked
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|skb2
op_assign
id|skb-&gt;next
suffix:semicolon
id|skb2
op_ne
id|sk-&gt;rqueue-&gt;next
suffix:semicolon
id|skb2
op_assign
id|skb2-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|skb2-&gt;h.th-&gt;seq
comma
id|sk-&gt;acked_seq
op_plus
l_int|1
)paren
)paren
(brace
id|sk-&gt;acked_seq
op_assign
id|skb2-&gt;h.th-&gt;ack_seq
suffix:semicolon
id|skb2-&gt;acked
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* force an immediate ack. */
id|sk-&gt;ack_backlog
op_assign
id|sk-&gt;max_ack_backlog
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
multiline_comment|/* this also takes care of updating the window. */
multiline_comment|/* this if statement needs to be simplified. */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;delay_acks
op_logical_or
id|sk-&gt;ack_backlog
op_ge
id|sk-&gt;max_ack_backlog
op_logical_or
id|sk-&gt;window
template_param
id|sk-&gt;max_unacked
op_logical_or
id|th-&gt;fin
)paren
(brace
id|tcp_send_ack
(paren
id|sk-&gt;send_seq
comma
id|sk-&gt;acked_seq
comma
id|sk
comma
id|th
comma
id|saddr
)paren
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;ack_backlog
op_increment
suffix:semicolon
id|sk-&gt;time_wait.len
op_assign
id|TCP_ACK_TIME
suffix:semicolon
id|sk-&gt;timeout
op_assign
id|TIME_WRITE
suffix:semicolon
id|reset_timer
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* we missed a packet.  Send an ack to try to resync things. */
id|tcp_send_ack
(paren
id|sk-&gt;send_seq
comma
id|sk-&gt;acked_seq
comma
id|sk
comma
id|th
comma
id|saddr
)paren
suffix:semicolon
)brace
multiline_comment|/* now tell the user we may have some data. */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|wake_up
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTK
(paren
l_string|&quot;data received on dead socket. &bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
OG
id|TCP_CLOSING
op_logical_and
id|sk-&gt;acked_seq
op_eq
id|sk-&gt;fin_seq
)paren
(brace
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|tcp_urg
id|tcp_urg
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_header
op_star
id|th
comma
r_int
r_int
id|saddr
)paren
(brace
r_extern
r_int
id|kill_pg
(paren
r_int
id|pg
comma
r_int
id|sig
comma
r_int
id|priv
)paren
suffix:semicolon
r_extern
r_int
id|kill_proc
(paren
r_int
id|pid
comma
r_int
id|sig
comma
r_int
id|priv
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|wake_up
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;urginline
)paren
(brace
id|th-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|th-&gt;psh
op_assign
l_int|1
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|sk-&gt;urg
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;urg
)paren
(brace
multiline_comment|/* so if we get more urgent data, we don&squot;t &n;&t;     signal the user again. */
r_if
c_cond
(paren
id|sk-&gt;proc
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;proc
OG
l_int|0
)paren
(brace
id|kill_proc
(paren
id|sk-&gt;proc
comma
id|SIGURG
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|kill_pg
(paren
op_minus
id|sk-&gt;proc
comma
id|SIGURG
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* this deals with incoming fins. */
r_static
r_int
DECL|function|tcp_fin
id|tcp_fin
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_header
op_star
id|th
comma
r_int
r_int
id|saddr
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcp_header
op_star
id|t1
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;tcp_fin (sk=%X, th=%X, saddr=%X, dev=%X)&bslash;n&quot;
comma
id|sk
comma
id|th
comma
id|saddr
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|wake_up
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
multiline_comment|/* after sending the fin, we aren&squot;t allowed to write anymore. */
id|sk-&gt;shutdown
op_or_assign
id|SEND_SHUTDOWN
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_SYN_RECV
suffix:colon
r_case
id|TCP_SYN_SENT
suffix:colon
r_case
id|TCP_ESTABLISHED
suffix:colon
id|sk-&gt;state
op_assign
id|TCP_LAST_ACK
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_case
id|TCP_FIN_WAIT1
suffix:colon
r_case
id|TCP_TIME_WAIT
suffix:colon
id|sk-&gt;state
op_assign
id|TCP_LAST_ACK
suffix:semicolon
multiline_comment|/* start the timers. */
id|sk-&gt;time_wait.len
op_assign
id|TCP_TIMEWAIT_LEN
suffix:semicolon
id|sk-&gt;timeout
op_assign
id|TIME_CLOSE
suffix:semicolon
id|reset_timer
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|TCP_FIN_WAIT2
suffix:colon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* send an ack and our own fin. */
id|buff
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|MAX_ACK_SIZE
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* we will ignore the fin.  That way it will be sent again. */
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|buff-&gt;mem_addr
op_assign
id|buff
suffix:semicolon
id|buff-&gt;mem_len
op_assign
id|MAX_ACK_SIZE
suffix:semicolon
id|buff-&gt;len
op_assign
r_sizeof
(paren
r_struct
id|tcp_header
)paren
suffix:semicolon
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcp_header
op_star
)paren
(paren
id|buff
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* put in the ip_header and routing stuff. */
id|tmp
op_assign
id|sk-&gt;prot-&gt;build_header
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|MAX_ACK_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sk-&gt;prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|buff-&gt;mem_addr
comma
id|buff-&gt;mem_len
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|buff-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcp_header
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|t1
op_plus
id|tmp
)paren
suffix:semicolon
id|memcpy
(paren
id|t1
comma
id|th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
multiline_comment|/* swap the send and the receive. */
id|t1-&gt;dest
op_assign
id|th-&gt;source
suffix:semicolon
id|t1-&gt;source
op_assign
id|th-&gt;dest
suffix:semicolon
id|t1-&gt;seq
op_assign
id|net32
c_func
(paren
id|sk-&gt;send_seq
op_increment
)paren
suffix:semicolon
multiline_comment|/* contains the one that needs to be acked. */
id|sk-&gt;fin_seq
op_assign
id|th-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|buff-&gt;h.seq
op_assign
id|sk-&gt;send_seq
suffix:semicolon
id|t1-&gt;window
op_assign
id|net16
c_func
(paren
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|t1-&gt;res1
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;res2
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;syn
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;fin
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|net32
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
suffix:semicolon
id|tcp_send_check
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/* can&squot;t just queue this up.  It should go at the end of&n;     the write queue. */
r_if
c_cond
(paren
id|sk-&gt;wback
op_ne
l_int|NULL
)paren
(brace
id|buff-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;wback-&gt;next
op_assign
id|buff
suffix:semicolon
id|sk-&gt;wback
op_assign
id|buff
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;prot-&gt;queue_xmit
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* this will accept the next outstanding connection. */
r_static
r_volatile
r_struct
id|sock
op_star
DECL|function|tcp_accept
id|tcp_accept
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
)paren
(brace
r_volatile
r_struct
id|sock
op_star
id|newsk
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;tcp_accept(sk=%X, flags=%X)&bslash;n&quot;
comma
id|sk
comma
id|flags
)paren
suffix:semicolon
id|print_sk
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* we need to make sure that this socket is listening, and that&n;     it has something pending. */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_LISTEN
)paren
(brace
id|sk-&gt;err
op_assign
id|EINVAL
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* avoid the race. */
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|get_firstr
c_func
(paren
id|sk
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;err
op_assign
id|EAGAIN
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
id|interruptible_sleep_on
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;err
op_assign
id|ERESTARTSYS
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* now all we need to do is return skb-&gt;sk. */
id|newsk
op_assign
id|skb-&gt;sk
suffix:semicolon
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
id|newsk
)paren
suffix:semicolon
)brace
multiline_comment|/* this will initiate an outgoing connection. */
r_static
r_int
DECL|function|tcp_connect
id|tcp_connect
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr_in
op_star
id|usin
comma
r_int
id|addr_len
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|sockaddr_in
id|sin
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_struct
id|tcp_header
op_star
id|t1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_CLOSE
)paren
r_return
(paren
op_minus
id|EISCONN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr_len
OL
l_int|8
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|verify_area
(paren
id|usin
comma
id|addr_len
)paren
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|sin
comma
id|usin
comma
id|min
c_func
(paren
r_sizeof
(paren
id|sin
)paren
comma
id|addr_len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sin.sin_family
op_logical_and
id|sin.sin_family
op_ne
id|AF_INET
)paren
r_return
(paren
op_minus
id|EAFNOSUPPORT
)paren
suffix:semicolon
id|sk-&gt;daddr
op_assign
id|sin.sin_addr.s_addr
suffix:semicolon
id|sk-&gt;send_seq
op_assign
id|timer_seq
op_star
id|SEQ_TICK
op_minus
id|seq_offset
suffix:semicolon
id|sk-&gt;rcv_ack_seq
op_assign
id|sk-&gt;send_seq
op_minus
l_int|1
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;dummy_th.dest
op_assign
id|sin.sin_port
suffix:semicolon
id|buff
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|MAX_SYN_SIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
r_return
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|buff-&gt;mem_addr
op_assign
id|buff
suffix:semicolon
id|buff-&gt;mem_len
op_assign
id|MAX_SYN_SIZE
suffix:semicolon
id|buff-&gt;len
op_assign
l_int|24
suffix:semicolon
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcp_header
op_star
)paren
(paren
id|buff
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* put in the ip_header and routing stuff. */
multiline_comment|/* We need to build the routing stuff fromt the things saved&n;     in skb. */
id|tmp
op_assign
id|sk-&gt;prot-&gt;build_header
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
l_int|NULL
comma
id|MAX_SYN_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sk-&gt;prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|buff-&gt;mem_addr
comma
id|buff-&gt;mem_len
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENETUNREACH
)paren
suffix:semicolon
)brace
id|buff-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcp_header
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|t1
op_plus
id|tmp
)paren
suffix:semicolon
id|memcpy
(paren
id|t1
comma
(paren
r_void
op_star
)paren
op_amp
(paren
id|sk-&gt;dummy_th
)paren
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
id|t1-&gt;seq
op_assign
id|net32
c_func
(paren
id|sk-&gt;send_seq
op_increment
)paren
suffix:semicolon
id|buff-&gt;h.seq
op_assign
id|sk-&gt;send_seq
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;window
op_assign
l_int|2
suffix:semicolon
id|t1-&gt;res1
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;res2
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;syn
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;urg_ptr
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;doff
op_assign
l_int|6
suffix:semicolon
multiline_comment|/* put in the tcp options to say mtu. */
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|t1
op_plus
l_int|1
)paren
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
l_int|2
suffix:semicolon
id|ptr
(braket
l_int|1
)braket
op_assign
l_int|4
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
(paren
id|dev-&gt;mtu
op_minus
id|HEADER_SIZE
)paren
op_rshift
l_int|8
suffix:semicolon
id|ptr
(braket
l_int|3
)braket
op_assign
(paren
id|dev-&gt;mtu
op_minus
id|HEADER_SIZE
)paren
op_amp
l_int|0xff
suffix:semicolon
id|sk-&gt;mtu
op_assign
id|dev-&gt;mtu
op_minus
id|HEADER_SIZE
suffix:semicolon
id|tcp_send_check
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
r_sizeof
(paren
r_struct
id|tcp_header
)paren
op_plus
l_int|4
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/* this must go first otherwise a really quick response will&n;     get reset. */
id|sk-&gt;state
op_assign
id|TCP_SYN_SENT
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|0
)paren
suffix:semicolon
id|sk-&gt;time_wait.len
op_assign
id|TCP_CONNECT_TIME
suffix:semicolon
id|reset_timer
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
id|sk-&gt;retransmits
op_assign
id|TCP_RETR1
op_minus
id|TCP_SYN_RETRIES
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* this functions checks to see if the tcp header is actually&n;   acceptible. */
r_static
r_int
DECL|function|tcp_sequence
id|tcp_sequence
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_header
op_star
id|th
comma
r_int
id|len
comma
r_struct
id|options
op_star
id|opt
comma
r_int
r_int
id|saddr
)paren
(brace
multiline_comment|/* this isn&squot;t quite right.  sk-&gt;acked_seq could be more recent&n;      than sk-&gt;window.  This is however close enough.  We will accept&n;      slightly more packets than we should, but it should not cause&n;      problems unless someone is trying to forge packets. */
r_if
c_cond
(paren
id|between
c_func
(paren
id|th-&gt;seq
comma
id|sk-&gt;acked_seq
comma
id|sk-&gt;acked_seq
op_plus
id|sk-&gt;window
)paren
op_logical_or
id|between
c_func
(paren
id|th-&gt;seq
op_plus
id|len
op_minus
r_sizeof
(paren
op_star
id|th
)paren
comma
id|sk-&gt;acked_seq
op_plus
l_int|1
comma
id|sk-&gt;acked_seq
op_plus
id|sk-&gt;window
)paren
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* if it&squot;s too far ahead, send an ack to let the other end&n;     know what we expect. */
r_if
c_cond
(paren
id|after
(paren
id|th-&gt;seq
comma
id|sk-&gt;acked_seq
op_plus
id|sk-&gt;window
)paren
)paren
(brace
id|tcp_send_ack
(paren
id|sk-&gt;send_seq
comma
id|sk-&gt;acked_seq
comma
id|sk
comma
id|th
comma
id|saddr
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;rst
)paren
(brace
r_if
c_cond
(paren
id|len
op_ne
id|th-&gt;doff
op_star
l_int|4
op_logical_or
id|th-&gt;fin
op_logical_or
id|th-&gt;syn
)paren
(brace
id|sk-&gt;delay_acks
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* try to resync things. */
id|tcp_send_ack
(paren
id|net32
c_func
(paren
id|th-&gt;ack_seq
)paren
comma
id|sk-&gt;acked_seq
comma
id|sk
comma
id|th
comma
id|saddr
)paren
suffix:semicolon
)brace
multiline_comment|/* in case it&squot;s just a late ack, let it through */
r_if
c_cond
(paren
id|th-&gt;ack
op_logical_and
id|len
op_eq
id|th-&gt;doff
op_star
l_int|4
op_logical_and
id|after
(paren
id|th-&gt;seq
comma
id|sk-&gt;acked_seq
op_minus
l_int|4096
)paren
op_logical_and
op_logical_neg
id|th-&gt;fin
op_logical_and
op_logical_neg
id|th-&gt;syn
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* This deals with the tcp option.  It isn&squot;t very general yet. */
r_static
r_void
DECL|function|tcp_options
id|tcp_options
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_header
op_star
id|th
)paren
(brace
r_int
r_char
op_star
id|ptr
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
(braket
l_int|0
)braket
op_ne
l_int|2
op_logical_or
id|ptr
(braket
l_int|1
)braket
op_ne
l_int|4
)paren
(brace
id|sk-&gt;mtu
op_assign
id|min
(paren
id|sk-&gt;mtu
comma
l_int|576
op_minus
id|HEADER_SIZE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sk-&gt;mtu
op_assign
id|min
(paren
id|sk-&gt;mtu
comma
id|ptr
(braket
l_int|2
)braket
op_star
l_int|256
op_plus
id|ptr
(braket
l_int|3
)braket
op_minus
id|HEADER_SIZE
)paren
suffix:semicolon
)brace
r_int
DECL|function|tcp_rcv
id|tcp_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|options
op_star
id|opt
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|saddr
comma
r_int
id|redo
comma
r_struct
id|ip_protocol
op_star
id|protocol
)paren
(brace
r_struct
id|tcp_header
op_star
id|th
suffix:semicolon
r_volatile
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|printk
(paren
l_string|&quot;tcp.c: tcp_rcv skb = NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#if 0 /* it&squot;s ok for protocol to be NULL */
r_if
c_cond
(paren
op_logical_neg
id|protocol
)paren
(brace
id|printk
(paren
l_string|&quot;tcp.c: tcp_rcv protocol = NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|opt
)paren
multiline_comment|/* it&squot;s ok for opt to be NULL */
(brace
id|printk
(paren
l_string|&quot;tcp.c: tcp_rcv opt = NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|printk
(paren
l_string|&quot;tcp.c: tcp_rcv dev = NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
multiline_comment|/* find the socket. */
id|sk
op_assign
id|get_sock
c_func
(paren
op_amp
id|tcp_prot
comma
id|net16
c_func
(paren
id|th-&gt;dest
)paren
comma
id|saddr
comma
id|th-&gt;source
comma
id|daddr
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;&lt;&lt;&bslash;n&quot;
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;len = %d, redo = %d, skb=%X&bslash;n&quot;
comma
id|len
comma
id|redo
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
)paren
(brace
id|PRINTK
(paren
l_string|&quot;sk = %X:&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
id|print_sk
(paren
id|sk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|redo
)paren
(brace
r_if
c_cond
(paren
id|th-&gt;check
op_logical_and
id|tcp_check
(paren
id|th
comma
id|len
comma
id|saddr
comma
id|daddr
)paren
)paren
(brace
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|free_skb
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* we don&squot;t release the socket because it was never&n;&t;       marked in use. */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*See if we know about the socket. */
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;rst
)paren
id|tcp_reset
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
op_amp
id|tcp_prot
comma
id|opt
comma
id|dev
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|free_skb
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|skb-&gt;len
op_assign
id|len
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;acked
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;used
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;urg_used
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;saddr
op_assign
id|daddr
suffix:semicolon
id|skb-&gt;daddr
op_assign
id|saddr
suffix:semicolon
id|th-&gt;seq
op_assign
id|net32
c_func
(paren
id|th-&gt;seq
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* we may need to add it to the backlog here. */
r_if
c_cond
(paren
id|sk-&gt;inuse
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;back_log
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;back_log
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;next
op_assign
id|sk-&gt;back_log
suffix:semicolon
id|skb-&gt;prev
op_assign
id|sk-&gt;back_log-&gt;prev
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk
)paren
(brace
id|printk
(paren
l_string|&quot;tcp.c: tcp_rcv bug sk=NULL redo = 1&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;prot
)paren
(brace
id|printk
(paren
l_string|&quot;tcp.c: tcp_rcv sk-&gt;prot = NULL &bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* charge the memory to the socket. */
r_if
c_cond
(paren
id|sk-&gt;rmem_alloc
op_plus
id|skb-&gt;mem_len
op_ge
id|SK_RMEM_MAX
)paren
(brace
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|free_skb
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|sk-&gt;rmem_alloc
op_add_assign
id|skb-&gt;mem_len
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;About to do switch. &bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* now deal with it. */
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
multiline_comment|/* this should close the system down if it&squot;s waiting for an&n;&t;  ack that is never going to be sent. */
r_case
id|TCP_LAST_ACK
suffix:colon
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
id|sk-&gt;err
op_assign
id|ECONNRESET
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|wake_up
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_case
id|TCP_ESTABLISHED
suffix:colon
r_case
id|TCP_FIN_WAIT1
suffix:colon
r_case
id|TCP_FIN_WAIT2
suffix:colon
r_case
id|TCP_TIME_WAIT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tcp_sequence
(paren
id|sk
comma
id|th
comma
id|len
comma
id|opt
comma
id|saddr
)paren
)paren
(brace
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
id|sk-&gt;err
op_assign
id|ECONNRESET
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|wake_up
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt
op_logical_and
(paren
id|opt-&gt;security
op_ne
l_int|0
op_logical_or
id|opt-&gt;compartment
op_ne
l_int|0
op_logical_or
id|th-&gt;syn
)paren
)paren
(brace
id|sk-&gt;err
op_assign
id|ECONNRESET
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|tcp_reset
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|wake_up
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tcp_ack
(paren
id|sk
comma
id|th
comma
id|saddr
)paren
)paren
(brace
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|th-&gt;urg
)paren
(brace
r_if
c_cond
(paren
id|tcp_urg
(paren
id|sk
comma
id|th
comma
id|saddr
)paren
)paren
(brace
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tcp_data
(paren
id|skb
comma
id|sk
comma
id|saddr
comma
id|len
)paren
)paren
(brace
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;fin
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|tcp_fin
(paren
id|sk
comma
id|th
comma
id|saddr
comma
id|dev
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|TCP_CLOSE
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;dead
op_logical_or
id|sk-&gt;daddr
)paren
(brace
id|PRINTK
(paren
l_string|&quot;packet received for closed,dead socket&bslash;n&quot;
)paren
suffix:semicolon
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;rst
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;ack
)paren
id|th-&gt;ack_seq
op_assign
l_int|0
suffix:semicolon
id|tcp_reset
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
)paren
suffix:semicolon
)brace
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|TCP_LISTEN
suffix:colon
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
id|tcp_reset
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
)paren
suffix:semicolon
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;syn
)paren
(brace
multiline_comment|/*&t;  if (opt-&gt;security != 0 || opt-&gt;compartment != 0)&n;&t;    {&n;&t;      tcp_reset (daddr, saddr, th, prot, opt,dev);&n;&t;      release_sock(sk);&n;&t;      return (0);&n;&t;    } */
multiline_comment|/* now we just put the whole thing including the header&n;&t;     and saddr, and protocol pointer into the buffer.&n;&t;     We can&squot;t respond until the user tells us to accept&n;&t;     the connection. */
id|tcp_conn_request
(paren
id|sk
comma
id|skb
comma
id|daddr
comma
id|saddr
comma
id|opt
comma
id|dev
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|tcp_sequence
(paren
id|sk
comma
id|th
comma
id|len
comma
id|opt
comma
id|saddr
)paren
)paren
(brace
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_case
id|TCP_SYN_SENT
suffix:colon
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
id|sk-&gt;err
op_assign
id|ECONNREFUSED
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|wake_up
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*      if (opt-&gt;security != 0 || opt-&gt;compartment != 0 )&n;&t;{&n;&t;  sk-&gt;err = ECONNRESET;&n;&t;  sk-&gt;state = TCP_CLOSE;&n;&t;  tcp_reset (daddr, saddr,  th, sk-&gt;prot, opt, dev);&n;&t;  if (!sk-&gt;dead)&n;&t;  {&n;&t;  wake_up (sk-&gt;sleep);&n;&t;  }&n;&t;  free_skb (skb, FREE_READ);&n;&t;  release_sock(sk);&n;&t;  return (0);&n;&t;} */
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;ack
)paren
(brace
r_if
c_cond
(paren
id|th-&gt;syn
)paren
(brace
id|sk-&gt;state
op_assign
id|TCP_SYN_RECV
suffix:semicolon
)brace
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_SYN_SENT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tcp_ack
c_func
(paren
id|sk
comma
id|th
comma
id|saddr
)paren
)paren
(brace
id|tcp_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
)paren
suffix:semicolon
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* if the syn bit is also set, switch to tcp_syn_recv,&n;&t;     and then to established. */
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;syn
)paren
(brace
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* ack the syn and fall through. */
id|sk-&gt;acked_seq
op_assign
id|th-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|sk-&gt;fin_seq
op_assign
id|th-&gt;seq
suffix:semicolon
id|tcp_send_ack
(paren
id|sk-&gt;send_seq
comma
id|th-&gt;seq
op_plus
l_int|1
comma
id|sk
comma
id|th
comma
id|sk-&gt;daddr
)paren
suffix:semicolon
r_case
id|TCP_SYN_RECV
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tcp_ack
c_func
(paren
id|sk
comma
id|th
comma
id|saddr
)paren
)paren
(brace
id|tcp_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
)paren
suffix:semicolon
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|sk-&gt;state
op_assign
id|TCP_ESTABLISHED
suffix:semicolon
multiline_comment|/* now we need to finish filling out some of the tcp&n;&t;     header. */
multiline_comment|/* we need to check for mtu info. */
id|tcp_options
c_func
(paren
id|sk
comma
id|th
)paren
suffix:semicolon
id|sk-&gt;dummy_th.dest
op_assign
id|th-&gt;source
suffix:semicolon
id|sk-&gt;copied_seq
op_assign
id|sk-&gt;acked_seq
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|wake_up
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
multiline_comment|/* now process the rest like we were already in the established&n;&t;     state. */
r_if
c_cond
(paren
id|th-&gt;urg
)paren
r_if
c_cond
(paren
id|tcp_urg
(paren
id|sk
comma
id|th
comma
id|saddr
)paren
)paren
(brace
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tcp_data
(paren
id|skb
comma
id|sk
comma
id|saddr
comma
id|len
)paren
)paren
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;fin
)paren
id|tcp_fin
c_func
(paren
id|sk
comma
id|th
comma
id|saddr
comma
id|dev
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;urg
)paren
(brace
r_if
c_cond
(paren
id|tcp_urg
(paren
id|sk
comma
id|th
comma
id|saddr
)paren
)paren
(brace
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tcp_data
(paren
id|skb
comma
id|sk
comma
id|saddr
comma
id|len
)paren
)paren
(brace
id|free_skb
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;fin
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|tcp_fin
(paren
id|sk
comma
id|th
comma
id|saddr
comma
id|dev
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* this routine sends a packet with an out of date sequence number. It&n;   assumes the other end will try to ack it. */
r_static
r_void
DECL|function|tcp_write_wakeup
id|tcp_write_wakeup
c_func
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcp_header
op_star
id|t1
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_member_access_from_pointer
id|state
op_ne
id|TCP_ESTABLISHED
)paren
r_return
suffix:semicolon
id|buff
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|MAX_ACK_SIZE
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* no big loss. */
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|buff-&gt;mem_addr
op_assign
id|buff
suffix:semicolon
id|buff-&gt;mem_len
op_assign
id|MAX_ACK_SIZE
suffix:semicolon
id|buff-&gt;len
op_assign
r_sizeof
(paren
r_struct
id|tcp_header
)paren
suffix:semicolon
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;in tcp_write_wakeup&bslash;n&quot;
)paren
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcp_header
op_star
)paren
(paren
id|buff
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* put in the ip_header and routing stuff. */
id|tmp
op_assign
id|sk-&gt;prot-&gt;build_header
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|MAX_ACK_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sk-&gt;prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|buff-&gt;mem_addr
comma
id|buff-&gt;mem_len
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buff-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcp_header
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|t1
op_plus
id|tmp
)paren
suffix:semicolon
id|memcpy
(paren
id|t1
comma
(paren
r_void
op_star
)paren
op_amp
id|sk-&gt;dummy_th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
multiline_comment|/* use a previous sequence.  This should cause the other end&n;     to send an ack. */
id|t1-&gt;seq
op_assign
id|net32
c_func
(paren
id|sk-&gt;send_seq
op_minus
l_int|1
)paren
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;res1
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;res2
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;fin
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;syn
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|net32
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|t1-&gt;window
op_assign
id|net16
c_func
(paren
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
suffix:semicolon
id|tcp_send_check
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/* send it and free it.  This will prevent the timer from &n;     automatically being restarted. */
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|variable|tcp_prot
r_struct
id|proto
id|tcp_prot
op_assign
(brace
id|sock_wmalloc
comma
id|sock_rmalloc
comma
id|sock_wfree
comma
id|sock_rfree
comma
id|sock_rspace
comma
id|sock_wspace
comma
id|tcp_close
comma
id|tcp_read
comma
id|tcp_write
comma
l_int|NULL
comma
l_int|NULL
comma
id|ip_build_header
comma
id|tcp_connect
comma
id|tcp_accept
comma
id|ip_queue_xmit
comma
id|tcp_retransmit
comma
id|tcp_write_wakeup
comma
id|tcp_read_wakeup
comma
id|tcp_rcv
comma
id|tcp_select
comma
id|tcp_ioctl
comma
l_int|NULL
comma
l_int|128
comma
l_int|0
comma
(brace
l_int|NULL
comma
)brace
)brace
suffix:semicolon
eof
