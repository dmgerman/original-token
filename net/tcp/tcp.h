multiline_comment|/* tcp.h */
multiline_comment|/*&n;    Copyright (C) 1992  Ross Biro&n;&n;    This program is free software; you can redistribute it and/or modify&n;    it under the terms of the GNU General Public License as published by&n;    the Free Software Foundation; either version 2, or (at your option)&n;    any later version.&n;&n;    This program is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;    GNU General Public License for more details.&n;&n;    You should have received a copy of the GNU General Public License&n;    along with this program; if not, write to the Free Software&n;    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. &n;&n;    The Author may be reached as bir7@leland.stanford.edu or&n;    C/O Department of Mathematics; Stanford University; Stanford, CA 94305&n;*/
multiline_comment|/* $Id: tcp.h,v 0.8.4.1 1992/11/10 00:17:18 bir7 Exp $ */
multiline_comment|/* $Log: tcp.h,v $&n; * Revision 0.8.4.1  1992/11/10  00:17:18  bir7&n; * version change only.&n; *&n; * Revision 0.8.3.2  1992/11/10  00:14:47  bir7&n; * Changed malloc to kmalloc and added $i&b;Id$ and $Log: tcp.h,v $&n; * Revision 0.8.4.1  1992/11/10  00:17:18  bir7&n; * version change only.&n; *.&n; * */
macro_line|#ifndef _TCP_TCP_H
DECL|macro|_TCP_TCP_H
mdefine_line|#define _TCP_TCP_H
DECL|struct|tcp_header
r_struct
id|tcp_header
(brace
DECL|member|source
r_int
r_int
id|source
suffix:semicolon
DECL|member|dest
r_int
r_int
id|dest
suffix:semicolon
DECL|member|seq
r_int
r_int
id|seq
suffix:semicolon
DECL|member|ack_seq
r_int
r_int
id|ack_seq
suffix:semicolon
DECL|member|res1
DECL|member|doff
DECL|member|fin
DECL|member|syn
DECL|member|rst
DECL|member|psh
r_int
r_int
id|res1
suffix:colon
l_int|4
comma
id|doff
suffix:colon
l_int|4
comma
id|fin
suffix:colon
l_int|1
comma
id|syn
suffix:colon
l_int|1
comma
id|rst
suffix:colon
l_int|1
comma
id|psh
suffix:colon
l_int|1
comma
DECL|member|ack
DECL|member|urg
DECL|member|res2
id|ack
suffix:colon
l_int|1
comma
id|urg
suffix:colon
l_int|1
comma
id|res2
suffix:colon
l_int|2
suffix:semicolon
DECL|member|window
r_int
r_int
id|window
suffix:semicolon
DECL|member|check
r_int
r_int
id|check
suffix:semicolon
DECL|member|urg_ptr
r_int
r_int
id|urg_ptr
suffix:semicolon
)brace
suffix:semicolon
r_enum
(brace
DECL|enumerator|TCP_ESTABLISHED
id|TCP_ESTABLISHED
op_assign
l_int|1
comma
DECL|enumerator|TCP_SYN_SENT
id|TCP_SYN_SENT
comma
DECL|enumerator|TCP_SYN_RECV
id|TCP_SYN_RECV
comma
DECL|enumerator|TCP_CLOSING
id|TCP_CLOSING
comma
multiline_comment|/* not a valid state, just a seperator so we can use&n;&t;&t;  &lt; tcp_closing or &gt; tcp_closing for checks. */
DECL|enumerator|TCP_FIN_WAIT1
id|TCP_FIN_WAIT1
comma
DECL|enumerator|TCP_FIN_WAIT2
id|TCP_FIN_WAIT2
comma
DECL|enumerator|TCP_TIME_WAIT
id|TCP_TIME_WAIT
comma
DECL|enumerator|TCP_CLOSE
id|TCP_CLOSE
comma
DECL|enumerator|TCP_LAST_ACK
id|TCP_LAST_ACK
comma
DECL|enumerator|TCP_LISTEN
id|TCP_LISTEN
)brace
suffix:semicolon
DECL|macro|MAX_SYN_SIZE
mdefine_line|#define MAX_SYN_SIZE 44 + sizeof (struct sk_buff) + MAX_HEADER
DECL|macro|MAX_FIN_SIZE
mdefine_line|#define MAX_FIN_SIZE 40 + sizeof (struct sk_buff) + MAX_HEADER
DECL|macro|MAX_ACK_SIZE
mdefine_line|#define MAX_ACK_SIZE 40 + sizeof (struct sk_buff) + MAX_HEADER
DECL|macro|MAX_RESET_SIZE
mdefine_line|#define MAX_RESET_SIZE 40 + sizeof (struct sk_buff) + MAX_HEADER
DECL|macro|MAX_WINDOW
mdefine_line|#define MAX_WINDOW  12000
DECL|macro|MIN_WINDOW
mdefine_line|#define MIN_WINDOW   2048
DECL|macro|MAX_ACK_BACKLOG
mdefine_line|#define MAX_ACK_BACKLOG 2
DECL|macro|MIN_WRITE_SPACE
mdefine_line|#define MIN_WRITE_SPACE 2048
DECL|macro|TCP_WINDOW_DIFF
mdefine_line|#define TCP_WINDOW_DIFF 2048
DECL|macro|TCP_RETR1
mdefine_line|#define TCP_RETR1       7       /* this is howmany retries it does&n;&t;&t;&t;&t;   before it tries to figure out&n;&t;&t;&t;&t;   if the gateway is down. */
DECL|macro|TCP_RETR2
mdefine_line|#define TCP_RETR2      10&t;/* this should take between 3 and&n;&t;&t;&t;&t;   ten minutes ( 1024 * rtt). */
DECL|macro|TCP_TIMEOUT_LEN
mdefine_line|#define TCP_TIMEOUT_LEN 720000 /* should be about 2 hrs. */
DECL|macro|TCP_TIMEWAIT_LEN
mdefine_line|#define TCP_TIMEWAIT_LEN 6000 /* How long to wait to sucessfully &n;&t;&t;&t;&t; close the socket, about 60 seconds. */
DECL|macro|TCP_ACK_TIME
mdefine_line|#define TCP_ACK_TIME 35 /* time to delay before sending an ack. */
DECL|macro|TCP_DONE_TIME
mdefine_line|#define TCP_DONE_TIME 2500 /* maximum time to wait before actually destroying&n;&t;&t;&t;     a socket. */
DECL|macro|TCP_WRITE_TIME
mdefine_line|#define TCP_WRITE_TIME 100 /* initial time to wait for an ack,&n;&t;&t;&t;      after last transmit. */
DECL|macro|TCP_CONNECT_TIME
mdefine_line|#define TCP_CONNECT_TIME 200 /* time to retransmit first syn. */
DECL|macro|TCP_SYN_RETRIES
mdefine_line|#define TCP_SYN_RETRIES 30 /* number of times to retry openning a connection.&n;&t;&t;&t;      */
DECL|macro|TCP_NO_CHECK
mdefine_line|#define TCP_NO_CHECK 0 /* turn to one if you want the default to be no&n;&t;&t;&t;  checksum . */
r_void
id|print_th
(paren
r_struct
id|tcp_header
op_star
)paren
suffix:semicolon
DECL|macro|HEADER_SIZE
mdefine_line|#define HEADER_SIZE 100
multiline_comment|/* this next routines deal with comparing 32 bit unsigned ints and&n;    worry about wrap around. The general strategy is to do a normal&n;    compare so long as neither of the numbers is within 4k of wrapping.&n;    Otherwise we must check for the wrap. */
r_static
r_inline
r_int
DECL|function|before
id|before
(paren
r_int
r_int
id|seq1
comma
r_int
r_int
id|seq2
)paren
(brace
multiline_comment|/* this inequality is strict. */
r_if
c_cond
(paren
id|seq1
op_eq
id|seq2
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|seq1
OL
id|seq2
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|seq2
op_minus
(paren
r_int
r_int
)paren
id|seq1
OL
l_int|32767UL
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* now we know seq1 &gt; seq2.  So all we need to do is check to see&n;      if seq1 has wrapped. */
r_if
c_cond
(paren
id|seq2
template_param
(paren
l_int|0xffffffUL
op_minus
l_int|4096UL
)paren
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|after
id|after
(paren
r_int
r_int
id|seq1
comma
r_int
r_int
id|seq2
)paren
(brace
r_return
(paren
id|before
(paren
id|seq2
comma
id|seq1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* is s2&lt;=s1&lt;=s3 ? */
r_static
r_inline
r_int
DECL|function|between
id|between
(paren
r_int
r_int
id|seq1
comma
r_int
r_int
id|seq2
comma
r_int
r_int
id|seq3
)paren
(brace
r_return
(paren
id|after
(paren
id|seq1
op_plus
l_int|1
comma
id|seq2
)paren
op_logical_and
id|before
(paren
id|seq1
comma
id|seq3
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
