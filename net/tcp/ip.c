multiline_comment|/* ip.c */
multiline_comment|/*&n;    Copyright (C) 1992  Ross Biro&n;&n;    This program is free software; you can redistribute it and/or modify&n;    it under the terms of the GNU General Public License as published by&n;    the Free Software Foundation; either version 2, or (at your option)&n;    any later version.&n;&n;    This program is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;    GNU General Public License for more details.&n;&n;    You should have received a copy of the GNU General Public License&n;    along with this program; if not, write to the Free Software&n;    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. &n;&n;    The Author may be reached as bir7@leland.stanford.edu or&n;    C/O Department of Mathematics; Stanford University; Stanford, CA 94305&n;*/
multiline_comment|/* $Id: ip.c,v 0.8.4.10 1993/01/23 18:00:11 bir7 Exp $ */
multiline_comment|/* $Log: ip.c,v $&n; * Revision 0.8.4.10  1993/01/23  18:00:11  bir7&n; * added volatile keyword to many variables.&n; *&n; * Revision 0.8.4.9  1993/01/22  23:21:38  bir7&n; * Merged with 99 pl4&n; *&n; * Revision 0.8.4.8  1992/12/12  19:25:04  bir7&n; * Cleaned up Log messages.&n; *&n; * Revision 0.8.4.7  1992/12/06  23:29:59  bir7&n; * Changed retransmit to double rtt.&n; *&n; * Revision 0.8.4.6  1992/12/05  21:35:53  bir7&n; * fixed checking of wrong fragmentation bit.&n; *&n; * Revision 0.8.4.5  1992/12/03  19:52:20  bir7&n; * added paranoid queue checking&n; *&n; * Revision 0.8.4.4  1992/11/18  15:38:03  bir7&n; * Fixed bug in copying packet and checking packet type.&n; *&n; * Revision 0.8.4.3  1992/11/17  14:19:47  bir7&n; *&n; * Revision 0.8.4.2  1992/11/10  10:38:48  bir7&n; * Change free_s to kfree_s and accidently changed free_skb to kfree_skb.&n; *&n; * Revision 0.8.4.1  1992/11/10  00:17:18  bir7&n; * version change only.&n; *&n; * Revision 0.8.3.3  1992/11/10  00:14:47  bir7&n; * Changed malloc to kmalloc and added Id and Log&n; *&n; */
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;netinet/in.h&gt;
macro_line|#include &quot;timer.h&quot;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &quot;arp.h&quot;
macro_line|#include &quot;icmp.h&quot;
DECL|variable|ip_addr
r_int
r_int
id|ip_addr
(braket
id|MAX_IP_ADDRES
)braket
op_assign
initialization_block
suffix:semicolon
macro_line|#ifdef PRINTK
DECL|macro|PRINTK
macro_line|#undef PRINTK
macro_line|#endif
DECL|macro|IP_DEBUG
macro_line|#undef IP_DEBUG
macro_line|#ifdef IP_DEBUG
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x) printk x
macro_line|#else
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x) /**/
macro_line|#endif
DECL|variable|rt_base
r_static
r_struct
id|rtable
op_star
id|rt_base
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* used to base all the routing data. */
DECL|variable|ip_protos
r_volatile
r_struct
id|ip_protocol
op_star
id|ip_protos
(braket
id|MAX_IP_PROTOS
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|ip_ads
r_int
id|ip_ads
op_assign
l_int|0
suffix:semicolon
DECL|function|in_ntoa
r_static
r_char
op_star
id|in_ntoa
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_static
r_char
id|buf
(braket
l_int|100
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d.%d.%d.%d&quot;
comma
(paren
id|addr
op_amp
l_int|0xff
)paren
comma
(paren
(paren
id|addr
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
comma
(paren
(paren
id|addr
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
comma
(paren
(paren
id|addr
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_struct
id|ip_protocol
op_star
id|get_protocol
c_func
(paren
r_int
r_char
id|prot
)paren
(brace
r_int
r_char
id|hash
suffix:semicolon
r_struct
id|ip_protocol
op_star
id|p
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;get_protocol (%d)&bslash;n &quot;
comma
id|prot
)paren
)paren
suffix:semicolon
id|hash
op_assign
id|prot
op_amp
(paren
id|MAX_IP_PROTOS
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|ip_protos
(braket
id|hash
)braket
suffix:semicolon
id|p
op_ne
l_int|NULL
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;trying protocol %d&bslash;n&quot;
comma
id|p-&gt;protocol
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;protocol
op_eq
id|prot
)paren
r_return
(paren
id|p
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif
r_void
DECL|function|add_ip_protocol
id|add_ip_protocol
(paren
r_struct
id|ip_protocol
op_star
id|prot
)paren
(brace
r_int
r_char
id|hash
suffix:semicolon
r_struct
id|ip_protocol
op_star
id|p2
suffix:semicolon
id|hash
op_assign
id|prot-&gt;protocol
op_amp
(paren
id|MAX_IP_PROTOS
op_minus
l_int|1
)paren
suffix:semicolon
id|prot
op_member_access_from_pointer
id|next
op_assign
id|ip_protos
(braket
id|hash
)braket
suffix:semicolon
id|ip_protos
(braket
id|hash
)braket
op_assign
id|prot
suffix:semicolon
id|prot-&gt;copy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set the copy bit if we need to. */
r_for
c_loop
(paren
id|p2
op_assign
(paren
r_struct
id|ip_protocol
op_star
)paren
id|prot-&gt;next
suffix:semicolon
id|p2
op_ne
l_int|NULL
suffix:semicolon
id|p2
op_assign
(paren
r_struct
id|ip_protocol
op_star
)paren
id|p2-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p2-&gt;protocol
op_eq
id|prot-&gt;protocol
)paren
(brace
id|prot-&gt;copy
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_int
DECL|function|delete_ip_protocol
id|delete_ip_protocol
(paren
r_struct
id|ip_protocol
op_star
id|prot
)paren
(brace
r_struct
id|ip_protocol
op_star
id|p
suffix:semicolon
r_struct
id|ip_protocol
op_star
id|lp
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
id|hash
suffix:semicolon
id|hash
op_assign
id|prot-&gt;protocol
op_amp
(paren
id|MAX_IP_PROTOS
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prot
op_eq
id|ip_protos
(braket
id|hash
)braket
)paren
(brace
id|ip_protos
(braket
id|hash
)braket
op_assign
(paren
r_struct
id|ip_protocol
op_star
)paren
id|ip_protos
(braket
id|hash
)braket
op_member_access_from_pointer
id|next
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|p
op_assign
(paren
r_struct
id|ip_protocol
op_star
)paren
id|ip_protos
(braket
id|hash
)braket
suffix:semicolon
id|p
op_ne
l_int|NULL
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|ip_protocol
op_star
)paren
id|p-&gt;next
)paren
(brace
multiline_comment|/* we have to worry if the protocol being deleted is the&n;&t;   last one on the list, then we may need to reset someones&n;&t;   copied bit. */
r_if
c_cond
(paren
id|p-&gt;next
op_ne
l_int|NULL
op_logical_and
id|p-&gt;next
op_eq
id|prot
)paren
(brace
multiline_comment|/* if we are the last one with this protocol and&n;&t;&t;there is a previous one, reset its copy bit. */
r_if
c_cond
(paren
id|p-&gt;copy
op_eq
l_int|0
op_logical_and
id|lp
op_ne
l_int|NULL
)paren
id|lp-&gt;copy
op_assign
l_int|0
suffix:semicolon
id|p-&gt;next
op_assign
id|prot-&gt;next
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;next
op_ne
l_int|NULL
op_logical_and
id|p-&gt;next-&gt;protocol
op_eq
id|prot-&gt;protocol
)paren
(brace
id|lp
op_assign
id|p
suffix:semicolon
)brace
)brace
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* addr1 is the address which may or may not be broadcast etc.&n;   addr2 is the &quot;real addr.&quot; */
r_int
DECL|function|ip_addr_match
id|ip_addr_match
(paren
r_int
r_int
id|addr1
comma
r_int
r_int
id|addr2
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|addr1
op_eq
id|addr2
)paren
r_return
(paren
id|IS_MYADDR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
comma
id|addr1
op_rshift_assign
l_int|8
comma
id|addr2
op_rshift_assign
l_int|8
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr1
op_amp
l_int|0xff
)paren
op_ne
(paren
id|addr2
op_amp
l_int|0xff
)paren
)paren
(brace
multiline_comment|/* the only way this could be a match is for the rest of&n;&t;     addr1 to be 0. */
r_if
c_cond
(paren
id|addr1
op_ne
l_int|0
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
id|IS_BROADCAST
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|IS_MYADDR
)paren
suffix:semicolon
)brace
r_int
DECL|function|my_ip_addr
id|my_ip_addr
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IP_ADDRES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ip_addr
(braket
id|i
)braket
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|result
op_assign
id|ip_addr_match
(paren
id|addr
comma
id|ip_addr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* these two routines will do routining. */
r_static
r_void
DECL|function|strict_route
id|strict_route
c_func
(paren
r_struct
id|ip_header
op_star
id|iph
comma
r_struct
id|options
op_star
id|opt
)paren
(brace
)brace
r_static
r_void
DECL|function|loose_route
id|loose_route
c_func
(paren
r_struct
id|ip_header
op_star
id|iph
comma
r_struct
id|options
op_star
id|opt
)paren
(brace
)brace
r_void
DECL|function|print_rt
id|print_rt
c_func
(paren
r_struct
id|rtable
op_star
id|rt
)paren
(brace
macro_line|#ifdef IP_DEBUG
id|printk
c_func
(paren
l_string|&quot;RT: %06lx NXT=%06lx DEV=%06lx(%s) NET=%s &quot;
comma
(paren
r_int
)paren
id|rt
comma
(paren
r_int
)paren
id|rt-&gt;next
comma
(paren
r_int
)paren
id|rt-&gt;dev
comma
id|rt-&gt;dev-&gt;name
comma
id|in_ntoa
c_func
(paren
id|rt-&gt;net
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ROUTER=%s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|rt-&gt;router
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|print_ipprot
id|print_ipprot
(paren
r_struct
id|ip_protocol
op_star
id|ipprot
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;handler = %X, protocol = %d, copy=%d &bslash;n&quot;
comma
id|ipprot-&gt;handler
comma
id|ipprot-&gt;protocol
comma
id|ipprot-&gt;copy
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This assumes that address are all in net order. */
r_static
r_struct
id|device
op_star
DECL|function|ip_route
id|ip_route
c_func
(paren
r_struct
id|options
op_star
id|opt
comma
r_int
r_int
id|daddr
comma
r_int
r_int
op_star
id|raddr
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
multiline_comment|/* look through the routing table for some&n;     kind of match. */
r_for
c_loop
(paren
id|rt
op_assign
id|rt_base
suffix:semicolon
id|rt
op_ne
l_int|NULL
suffix:semicolon
id|rt
op_assign
id|rt-&gt;next
)paren
(brace
multiline_comment|/* see if we found one. */
r_if
c_cond
(paren
id|ip_addr_match
(paren
id|rt-&gt;net
comma
id|daddr
)paren
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;IP: %X via %s (%X)&bslash;n&quot;
comma
id|daddr
comma
id|rt-&gt;dev-&gt;name
comma
id|rt-&gt;router
)paren
)paren
suffix:semicolon
op_star
id|raddr
op_assign
id|rt-&gt;router
suffix:semicolon
r_return
(paren
id|rt-&gt;dev
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Remove all routing table entries for a device. */
r_void
DECL|function|del_devroute
id|del_devroute
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|rtable
op_star
id|r
comma
op_star
id|x
comma
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_assign
id|rt_base
)paren
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* nothing to remove! */
id|PRINTK
(paren
(paren
l_string|&quot;IFACE DOWN: clearing routing table for dev 0x%08lx (%s)&bslash;n&quot;
comma
(paren
r_int
)paren
id|dev
comma
id|dev-&gt;name
)paren
)paren
suffix:semicolon
id|p
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|r
op_ne
l_int|NULL
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;&gt;&gt; R=%06lx N=%06lx P=%06lx DEV=%06lx(%s) A=%s&bslash;n&quot;
comma
(paren
r_int
)paren
id|r
comma
(paren
r_int
)paren
id|r-&gt;next
comma
(paren
r_int
)paren
id|p
comma
(paren
r_int
)paren
id|r-&gt;dev
comma
id|r-&gt;dev-&gt;name
comma
id|in_ntoa
c_func
(paren
id|r-&gt;net
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;dev
op_eq
id|dev
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;&gt;&gt;&gt; MATCH: removing rt=%08lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|r
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
id|rt_base
op_assign
id|r-&gt;next
suffix:semicolon
r_else
id|p-&gt;next
op_assign
id|r-&gt;next
suffix:semicolon
id|x
op_assign
id|r-&gt;next
suffix:semicolon
id|kfree_s
c_func
(paren
id|r
comma
r_sizeof
(paren
op_star
id|r
)paren
)paren
suffix:semicolon
id|r
op_assign
id|x
suffix:semicolon
)brace
r_else
(brace
id|p
op_assign
id|r
suffix:semicolon
id|r
op_assign
id|r-&gt;next
suffix:semicolon
)brace
)brace
)brace
r_void
DECL|function|add_route
id|add_route
(paren
r_struct
id|rtable
op_star
id|rt
)paren
(brace
r_int
id|mask
suffix:semicolon
r_struct
id|rtable
op_star
id|r
suffix:semicolon
r_struct
id|rtable
op_star
id|r1
suffix:semicolon
id|print_rt
c_func
(paren
id|rt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt_base
op_eq
l_int|NULL
)paren
(brace
id|rt-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|rt_base
op_assign
id|rt
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* what we have to do is loop though this until we have found the&n;     first address which has the same generality as the one in rt.  Then&n;     we can put rt in after it. */
r_for
c_loop
(paren
id|mask
op_assign
l_int|0xff000000
suffix:semicolon
id|mask
op_ne
l_int|0xffffffff
suffix:semicolon
id|mask
op_assign
(paren
id|mask
op_rshift
l_int|8
)paren
op_or
id|mask
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
id|rt-&gt;net
)paren
(brace
id|mask
op_assign
id|mask
op_lshift
l_int|8
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|PRINTK
(paren
(paren
l_string|&quot;mask = %X&bslash;n&quot;
comma
id|mask
)paren
)paren
suffix:semicolon
id|r1
op_assign
id|rt_base
suffix:semicolon
r_for
c_loop
(paren
id|r
op_assign
id|rt_base
suffix:semicolon
id|r
op_ne
l_int|NULL
suffix:semicolon
id|r
op_assign
id|r-&gt;next
)paren
(brace
multiline_comment|/* see if we are getting a duplicate. */
r_if
c_cond
(paren
id|r-&gt;net
op_eq
id|rt-&gt;net
)paren
(brace
r_if
c_cond
(paren
id|r
op_eq
id|rt_base
)paren
(brace
id|rt-&gt;next
op_assign
id|r-&gt;next
suffix:semicolon
id|rt_base
op_assign
id|rt
suffix:semicolon
)brace
r_else
(brace
id|rt-&gt;next
op_assign
id|r-&gt;next
suffix:semicolon
id|r1-&gt;next
op_assign
id|rt
suffix:semicolon
)brace
id|kfree_s
(paren
id|r
comma
r_sizeof
(paren
op_star
id|r
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|r-&gt;net
op_amp
id|mask
)paren
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;adding before r=%X&bslash;n&quot;
comma
id|r
)paren
)paren
suffix:semicolon
id|print_rt
c_func
(paren
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
id|rt_base
)paren
(brace
id|rt-&gt;next
op_assign
id|rt_base
suffix:semicolon
id|rt_base
op_assign
id|rt
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rt-&gt;next
op_assign
id|r
suffix:semicolon
id|r1-&gt;next
op_assign
id|rt
suffix:semicolon
r_return
suffix:semicolon
)brace
id|r1
op_assign
id|r
suffix:semicolon
)brace
id|PRINTK
(paren
(paren
l_string|&quot;adding after r1=%X&bslash;n&quot;
comma
id|r1
)paren
)paren
suffix:semicolon
id|print_rt
c_func
(paren
id|r1
)paren
suffix:semicolon
multiline_comment|/* goes at the end. */
id|rt-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|r1-&gt;next
op_assign
id|rt
suffix:semicolon
)brace
r_int
DECL|function|ip_set_dev
id|ip_set_dev
(paren
r_struct
id|ip_config
op_star
id|u_ipc
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_struct
id|ip_config
id|ipc
suffix:semicolon
multiline_comment|/*  verify_area (VERIFY_WRITE, u_ipc, sizeof (ipc));*/
id|memcpy_fromfs
c_func
(paren
op_amp
id|ipc
comma
id|u_ipc
comma
r_sizeof
(paren
id|ipc
)paren
)paren
suffix:semicolon
id|ipc.name
(braket
id|MAX_IP_NAME
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|dev
op_assign
id|get_dev
(paren
id|ipc.name
)paren
suffix:semicolon
macro_line|#if 1 /* making this a 0 will let you remove an ip address from&n;&t; the list, which is useful under SLIP.  But it may not&n;&t; be compatible with older configs. */
id|ipc.destroy
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip_ads
op_ge
id|MAX_IP_ADDRES
op_logical_and
op_logical_neg
id|ipc.destroy
op_logical_and
id|ipc.paddr
op_ne
op_minus
l_int|1
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* see if we need to add a broadcast address. */
r_if
c_cond
(paren
id|ipc.net
op_ne
op_minus
l_int|1
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;new broadcast for %s: %08X&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ipc.net
)paren
)paren
suffix:semicolon
id|arp_add_broad
(paren
id|ipc.net
comma
id|dev
)paren
suffix:semicolon
id|rt
op_assign
id|kmalloc
(paren
r_sizeof
(paren
op_star
id|rt
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
r_return
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|rt-&gt;net
op_assign
id|ipc.net
suffix:semicolon
id|rt-&gt;dev
op_assign
id|dev
suffix:semicolon
id|rt-&gt;router
op_assign
l_int|0
suffix:semicolon
id|add_route
(paren
id|rt
)paren
suffix:semicolon
multiline_comment|/*     dev-&gt;net = ipc.net;*/
)brace
r_if
c_cond
(paren
id|ipc.router
op_ne
op_minus
l_int|1
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;new router for %s: %08X&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ipc.router
)paren
)paren
suffix:semicolon
id|rt
op_assign
id|kmalloc
(paren
r_sizeof
(paren
op_star
id|rt
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
r_return
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|rt-&gt;net
op_assign
l_int|0
suffix:semicolon
id|rt-&gt;dev
op_assign
id|dev
suffix:semicolon
id|rt-&gt;router
op_assign
id|ipc.router
suffix:semicolon
id|add_route
(paren
id|rt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;loopback
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;new loopback addr: %08X&bslash;n&quot;
comma
id|ipc.paddr
)paren
)paren
suffix:semicolon
id|rt
op_assign
id|kmalloc
(paren
r_sizeof
(paren
op_star
id|rt
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
r_return
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|rt-&gt;net
op_assign
id|ipc.paddr
suffix:semicolon
id|rt-&gt;dev
op_assign
id|dev
suffix:semicolon
id|rt-&gt;router
op_assign
l_int|0
suffix:semicolon
id|add_route
(paren
id|rt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ipc.destroy
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IP_ADDRES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ip_addr
(braket
id|i
)braket
op_eq
id|ipc.paddr
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_ne
id|MAX_IP_ADDRES
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;ip.c: Destroying Identity %8X, entry %d&bslash;n&quot;
comma
id|ipc.paddr
comma
id|i
)paren
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|ip_ads
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|MAX_IP_ADDRES
)paren
(brace
id|ip_addr
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|ip_addr
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|ip_addr
(braket
id|MAX_IP_ADDRES
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* FIX per FvK 92/11/15 */
multiline_comment|/* When &quot;downing&quot; an interface, this must be done with paddr = -1L. */
r_if
c_cond
(paren
id|ipc.paddr
op_ne
op_minus
l_int|1L
op_logical_and
op_logical_neg
id|ipc.destroy
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|my_ip_addr
(paren
id|ipc.paddr
)paren
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;new identity: %08X&bslash;n&quot;
comma
id|ipc.paddr
)paren
)paren
suffix:semicolon
id|ip_addr
(braket
id|ip_ads
op_increment
)braket
op_assign
id|ipc.paddr
suffix:semicolon
)brace
)brace
id|dev-&gt;up
op_assign
id|ipc.up
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;up
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;open
)paren
id|dev
op_member_access_from_pointer
id|open
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dev-&gt;stop
)paren
id|dev
op_member_access_from_pointer
id|stop
c_func
(paren
id|dev
)paren
suffix:semicolon
id|del_devroute
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* clear routing table for dev&t;*/
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* this routine will check to see if we have lost a gateway. */
r_void
DECL|function|ip_route_check
id|ip_route_check
(paren
r_int
r_int
id|daddr
)paren
(brace
)brace
macro_line|#if 0
multiline_comment|/* this routine puts the options at the end of an ip header. */
r_static
r_int
id|build_options
(paren
r_struct
id|ip_header
op_star
id|iph
comma
r_struct
id|options
op_star
id|opt
)paren
(brace
r_int
r_char
op_star
id|ptr
suffix:semicolon
multiline_comment|/* currently we don&squot;t support any options. */
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|iph
op_plus
l_int|1
)paren
suffix:semicolon
op_star
id|ptr
op_assign
l_int|0
suffix:semicolon
r_return
(paren
l_int|4
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* This routine builds the appropriate hardware/ip headers for&n;   the routine.  It assumes that if *prot != NULL then the&n;   protocol knows what it&squot;s doing, otherwise it uses the&n;   routing/arp tables to select a protocol struct. */
r_int
DECL|function|ip_build_header
id|ip_build_header
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
comma
r_struct
id|device
op_star
op_star
id|dev
comma
r_int
id|type
comma
r_struct
id|options
op_star
id|opt
comma
r_int
id|len
)paren
(brace
r_static
r_struct
id|options
id|optmem
suffix:semicolon
r_struct
id|ip_header
op_star
id|iph
suffix:semicolon
r_int
r_char
op_star
id|buff
suffix:semicolon
r_static
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|raddr
suffix:semicolon
multiline_comment|/* for the router. */
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|saddr
op_eq
l_int|0
)paren
id|saddr
op_assign
id|MY_IP_ADDR
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;ip_build_header (skb=%X, saddr=%X, daddr=%X, *dev=%X,&bslash;n&quot;
l_string|&quot;                 type=%d, opt=%X, len = %d)&bslash;n&quot;
comma
id|skb
comma
id|saddr
comma
id|daddr
comma
op_star
id|dev
comma
id|type
comma
id|opt
comma
id|len
)paren
)paren
suffix:semicolon
id|buff
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* see if we need to look up the device. */
r_if
c_cond
(paren
op_star
id|dev
op_eq
l_int|NULL
)paren
(brace
op_star
id|dev
op_assign
id|ip_route
c_func
(paren
op_amp
id|optmem
comma
id|daddr
comma
op_amp
id|raddr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|dev
op_eq
l_int|NULL
)paren
(brace
r_return
(paren
op_minus
id|ENETUNREACH
)paren
suffix:semicolon
)brace
id|opt
op_assign
op_amp
id|optmem
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we still need the address of the first hop. */
id|ip_route
(paren
op_amp
id|optmem
comma
id|daddr
comma
op_amp
id|raddr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raddr
op_eq
l_int|0
)paren
id|raddr
op_assign
id|daddr
suffix:semicolon
multiline_comment|/* now build the header. */
multiline_comment|/* we need to worry about routing in here.  daddr should&n;     really be the address of the next hop. */
multiline_comment|/* but raddr is . */
r_if
c_cond
(paren
(paren
op_star
id|dev
)paren
op_member_access_from_pointer
id|hard_header
)paren
(brace
id|tmp
op_assign
(paren
op_star
id|dev
)paren
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|buff
comma
op_star
id|dev
comma
id|ETHERTYPE_IP
comma
id|raddr
comma
id|saddr
comma
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
id|tmp
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|tmp
op_assign
op_minus
id|tmp
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
)brace
id|buff
op_add_assign
id|tmp
suffix:semicolon
id|len
op_sub_assign
id|tmp
suffix:semicolon
id|skb-&gt;dev
op_assign
op_star
id|dev
suffix:semicolon
multiline_comment|/* now build the ip header. */
id|iph
op_assign
(paren
r_struct
id|ip_header
op_star
)paren
id|buff
suffix:semicolon
id|iph-&gt;version
op_assign
l_int|4
suffix:semicolon
id|iph-&gt;tos
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;frag_off
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;ttl
op_assign
l_int|32
suffix:semicolon
id|iph-&gt;daddr
op_assign
id|daddr
suffix:semicolon
id|iph-&gt;saddr
op_assign
id|saddr
suffix:semicolon
id|iph-&gt;protocol
op_assign
id|type
suffix:semicolon
id|iph-&gt;ihl
op_assign
l_int|5
suffix:semicolon
id|iph-&gt;id
op_assign
id|net16
c_func
(paren
id|count
op_increment
)paren
suffix:semicolon
multiline_comment|/* build_options (iph, opt);*/
r_return
(paren
l_int|20
op_plus
id|tmp
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|do_options
id|do_options
c_func
(paren
r_struct
id|ip_header
op_star
id|iph
comma
r_struct
id|options
op_star
id|opt
)paren
(brace
r_int
r_char
op_star
id|buff
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_int
id|len
op_assign
r_sizeof
(paren
op_star
id|iph
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* zero  out the options. */
id|opt-&gt;record_route.route_size
op_assign
l_int|0
suffix:semicolon
id|opt-&gt;loose_route.route_size
op_assign
l_int|0
suffix:semicolon
id|opt-&gt;strict_route.route_size
op_assign
l_int|0
suffix:semicolon
id|opt-&gt;tstamp.ptr
op_assign
l_int|0
suffix:semicolon
id|opt-&gt;security
op_assign
l_int|0
suffix:semicolon
id|opt-&gt;compartment
op_assign
l_int|0
suffix:semicolon
id|opt-&gt;handling
op_assign
l_int|0
suffix:semicolon
id|opt-&gt;stream
op_assign
l_int|0
suffix:semicolon
id|opt-&gt;tcc
op_assign
l_int|0
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* advance the pointer to start at the options. */
id|buff
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|iph
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*now start the processing. */
r_while
c_loop
(paren
op_logical_neg
id|done
op_logical_and
id|len
OL
id|iph-&gt;ihl
op_star
l_int|4
)paren
(brace
r_switch
c_cond
(paren
op_star
id|buff
)paren
(brace
r_case
id|IPOPT_END
suffix:colon
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IPOPT_NOOP
suffix:colon
id|buff
op_increment
suffix:semicolon
id|len
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IPOPT_SEC
suffix:colon
id|buff
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|buff
op_ne
l_int|11
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
id|buff
op_increment
suffix:semicolon
id|opt-&gt;security
op_assign
id|net16
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|buff
)paren
suffix:semicolon
id|buff
op_add_assign
l_int|2
suffix:semicolon
id|opt-&gt;compartment
op_assign
id|net16
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|buff
)paren
suffix:semicolon
id|buff
op_add_assign
l_int|2
suffix:semicolon
id|opt
op_member_access_from_pointer
id|handling
op_assign
id|net16
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|buff
)paren
suffix:semicolon
id|buff
op_add_assign
l_int|2
suffix:semicolon
id|opt-&gt;tcc
op_assign
(paren
(paren
op_star
id|buff
)paren
op_lshift
l_int|16
)paren
op_plus
id|net16
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|buff
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|buff
op_add_assign
l_int|3
suffix:semicolon
id|len
op_add_assign
l_int|11
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IPOPT_LSRR
suffix:colon
id|buff
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|buff
op_minus
l_int|3
)paren
op_mod
l_int|4
op_ne
l_int|0
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
id|len
op_add_assign
op_star
id|buff
suffix:semicolon
id|opt-&gt;loose_route.route_size
op_assign
(paren
op_star
id|buff
op_minus
l_int|3
)paren
op_div
l_int|4
suffix:semicolon
id|buff
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|buff
op_mod
l_int|4
op_ne
l_int|0
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
id|opt-&gt;loose_route.pointer
op_assign
op_star
id|buff
op_div
l_int|4
op_minus
l_int|1
suffix:semicolon
id|buff
op_increment
suffix:semicolon
id|buff
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|opt-&gt;loose_route.route_size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|opt-&gt;loose_route.route
(braket
id|i
)braket
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|buff
suffix:semicolon
id|buff
op_add_assign
l_int|4
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IPOPT_SSRR
suffix:colon
id|buff
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|buff
op_minus
l_int|3
)paren
op_mod
l_int|4
op_ne
l_int|0
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
id|len
op_add_assign
op_star
id|buff
suffix:semicolon
id|opt-&gt;strict_route.route_size
op_assign
(paren
op_star
id|buff
op_minus
l_int|3
)paren
op_div
l_int|4
suffix:semicolon
id|buff
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|buff
op_mod
l_int|4
op_ne
l_int|0
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
id|opt-&gt;strict_route.pointer
op_assign
op_star
id|buff
op_div
l_int|4
op_minus
l_int|1
suffix:semicolon
id|buff
op_increment
suffix:semicolon
id|buff
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|opt-&gt;strict_route.route_size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|opt-&gt;strict_route.route
(braket
id|i
)braket
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|buff
suffix:semicolon
id|buff
op_add_assign
l_int|4
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IPOPT_RR
suffix:colon
id|buff
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|buff
op_minus
l_int|3
)paren
op_mod
l_int|4
op_ne
l_int|0
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
id|len
op_add_assign
op_star
id|buff
suffix:semicolon
id|opt-&gt;record_route.route_size
op_assign
(paren
op_star
id|buff
op_minus
l_int|3
)paren
op_div
l_int|4
suffix:semicolon
id|buff
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|buff
op_mod
l_int|4
op_ne
l_int|0
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
id|opt-&gt;record_route.pointer
op_assign
op_star
id|buff
op_div
l_int|4
op_minus
l_int|1
suffix:semicolon
id|buff
op_increment
suffix:semicolon
id|buff
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|opt-&gt;record_route.route_size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|opt-&gt;record_route.route
(braket
id|i
)braket
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|buff
suffix:semicolon
id|buff
op_add_assign
l_int|4
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IPOPT_SID
suffix:colon
id|len
op_add_assign
l_int|4
suffix:semicolon
id|buff
op_add_assign
l_int|2
suffix:semicolon
id|opt-&gt;stream
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|buff
suffix:semicolon
id|buff
op_add_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IPOPT_TIMESTAMP
suffix:colon
id|buff
op_increment
suffix:semicolon
id|len
op_add_assign
op_star
id|buff
suffix:semicolon
r_if
c_cond
(paren
op_star
id|buff
op_mod
l_int|4
op_ne
l_int|0
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
id|opt-&gt;tstamp.len
op_assign
op_star
id|buff
op_div
l_int|4
op_minus
l_int|1
suffix:semicolon
id|buff
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|buff
op_minus
l_int|1
)paren
op_mod
l_int|4
op_ne
l_int|0
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
id|opt-&gt;tstamp.ptr
op_assign
(paren
op_star
id|buff
op_minus
l_int|1
)paren
op_div
l_int|4
suffix:semicolon
id|buff
op_increment
suffix:semicolon
id|opt-&gt;tstamp.x.full_char
op_assign
op_star
id|buff
suffix:semicolon
id|buff
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|opt-&gt;tstamp.len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|opt-&gt;tstamp.data
(braket
id|i
)braket
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|buff
suffix:semicolon
id|buff
op_add_assign
l_int|4
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|opt-&gt;record_route.route_size
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|opt-&gt;strict_route.route_size
op_ne
l_int|0
)paren
(brace
id|memcpy
(paren
op_amp
(paren
id|opt-&gt;record_route
)paren
comma
op_amp
(paren
id|opt-&gt;strict_route
)paren
comma
r_sizeof
(paren
id|opt-&gt;record_route
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|opt-&gt;loose_route.route_size
op_ne
l_int|0
)paren
(brace
id|memcpy
(paren
op_amp
(paren
id|opt-&gt;record_route
)paren
comma
op_amp
(paren
id|opt-&gt;loose_route
)paren
comma
r_sizeof
(paren
id|opt-&gt;record_route
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|opt-&gt;strict_route.route_size
op_ne
l_int|0
op_logical_and
id|opt-&gt;strict_route.route_size
op_ne
id|opt-&gt;strict_route.pointer
)paren
(brace
id|strict_route
(paren
id|iph
comma
id|opt
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt-&gt;loose_route.route_size
op_ne
l_int|0
op_logical_and
id|opt-&gt;loose_route.route_size
op_ne
id|opt-&gt;loose_route.pointer
)paren
(brace
id|loose_route
(paren
id|iph
comma
id|opt
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* This routine does all the checksum computations that don&squot;t require&n;   anything special (like copying or special headers.) */
r_int
r_int
DECL|function|ip_compute_csum
id|ip_compute_csum
c_func
(paren
r_int
r_char
op_star
id|buff
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|sum
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|3
)paren
(brace
multiline_comment|/* do the first multiple of 4 bytes and convert to 16 bits. */
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t clc&bslash;n&quot;
l_string|&quot;1:&bslash;n&quot;
l_string|&quot;&bslash;t lodsl&bslash;n&quot;
l_string|&quot;&bslash;t adcl %%eax, %%ebx&bslash;n&quot;
l_string|&quot;&bslash;t loop 1b&bslash;n&quot;
l_string|&quot;&bslash;t adcl $0, %%ebx&bslash;n&quot;
l_string|&quot;&bslash;t movl %%ebx, %%eax&bslash;n&quot;
l_string|&quot;&bslash;t shrl $16, %%eax&bslash;n&quot;
l_string|&quot;&bslash;t addw %%ax, %%bx&bslash;n&quot;
l_string|&quot;&bslash;t adcw $0, %%bx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
comma
l_string|&quot;=S&quot;
(paren
id|buff
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;c&quot;
(paren
id|len
op_rshift
l_int|2
)paren
comma
l_string|&quot;1&quot;
(paren
id|buff
)paren
suffix:colon
l_string|&quot;ax&quot;
comma
l_string|&quot;cx&quot;
comma
l_string|&quot;si&quot;
comma
l_string|&quot;bx&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
op_amp
l_int|2
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t lodsw&bslash;n&quot;
l_string|&quot;&bslash;t addw %%ax, %%bx&bslash;n&quot;
l_string|&quot;&bslash;t adcw $0, %%bx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
comma
l_string|&quot;=S&quot;
(paren
id|buff
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;1&quot;
(paren
id|buff
)paren
suffix:colon
l_string|&quot;bx&quot;
comma
l_string|&quot;ax&quot;
comma
l_string|&quot;si&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
op_amp
l_int|1
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t lodsb&bslash;n&quot;
l_string|&quot;&bslash;t movb $0, %%ah&bslash;n&quot;
l_string|&quot;&bslash;t addw %%ax, %%bx&bslash;n&quot;
l_string|&quot;&bslash;t adcw $0, %%bx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
comma
l_string|&quot;=S&quot;
(paren
id|buff
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;1&quot;
(paren
id|buff
)paren
suffix:colon
l_string|&quot;bx&quot;
comma
l_string|&quot;ax&quot;
comma
l_string|&quot;si&quot;
)paren
suffix:semicolon
)brace
id|sum
op_assign
op_complement
id|sum
suffix:semicolon
r_return
(paren
id|sum
op_amp
l_int|0xffff
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|ip_csum
id|ip_csum
c_func
(paren
r_struct
id|ip_header
op_star
id|iph
)paren
(brace
r_if
c_cond
(paren
id|iph-&gt;check
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip_compute_csum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|iph
comma
id|iph-&gt;ihl
op_star
l_int|4
)paren
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ip_send_check
id|ip_send_check
c_func
(paren
r_struct
id|ip_header
op_star
id|iph
)paren
(brace
id|iph-&gt;check
op_assign
l_int|0
suffix:semicolon
id|iph-&gt;check
op_assign
id|ip_compute_csum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|iph
comma
id|iph-&gt;ihl
op_star
l_int|4
)paren
suffix:semicolon
)brace
r_int
DECL|function|ip_rcv
id|ip_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|ip_header
op_star
id|iph
suffix:semicolon
r_int
r_char
id|hash
suffix:semicolon
r_int
r_char
id|flag
op_assign
l_int|0
suffix:semicolon
r_static
r_struct
id|options
id|opt
suffix:semicolon
multiline_comment|/* since we don&squot;t use these yet, and they&n;&t;&t;&t;&t;take up stack space. */
r_struct
id|ip_protocol
op_star
id|ipprot
suffix:semicolon
id|iph
op_assign
id|skb-&gt;h.iph
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;&lt;&lt;&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|print_iph
c_func
(paren
id|iph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip_csum
(paren
id|iph
)paren
op_logical_or
id|do_options
(paren
id|iph
comma
op_amp
id|opt
)paren
op_logical_or
id|iph-&gt;version
op_ne
l_int|4
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;ip packet thrown out. &bslash;n&quot;
)paren
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* for now we will only deal with packets meant for us. */
r_if
c_cond
(paren
op_logical_neg
id|my_ip_addr
c_func
(paren
id|iph-&gt;daddr
)paren
)paren
(brace
id|PRINTK
c_func
(paren
(paren
l_string|&quot;&bslash;nIP: *** datagram routing not yet implemented ***&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;    SRC = %s   &quot;
comma
id|in_ntoa
c_func
(paren
id|iph-&gt;saddr
)paren
)paren
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;    DST = %s (ignored)&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|iph-&gt;daddr
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*      icmp_reply (skb, ICMP_DEST_UNREACH, ICMP_PROT_UNREACH, dev); */
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* deal with fragments.  or don&squot;t for now.*/
r_if
c_cond
(paren
(paren
id|iph-&gt;frag_off
op_amp
l_int|32
)paren
op_logical_or
(paren
id|net16
c_func
(paren
id|iph-&gt;frag_off
)paren
op_amp
l_int|0x1fff
)paren
)paren
(brace
multiline_comment|/* FIXME: this ^^^ used to be 64, as per bugfix */
id|printk
c_func
(paren
l_string|&quot;&bslash;nIP: *** datagram fragmentation not yet implemented ***&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    SRC = %s   &quot;
comma
id|in_ntoa
c_func
(paren
id|iph-&gt;saddr
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    DST = %s (ignored)&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|iph-&gt;daddr
)paren
)paren
suffix:semicolon
id|icmp_reply
(paren
id|skb
comma
id|ICMP_DEST_UNREACH
comma
id|ICMP_PROT_UNREACH
comma
id|dev
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|skb-&gt;h.raw
op_add_assign
id|iph-&gt;ihl
op_star
l_int|4
suffix:semicolon
id|hash
op_assign
id|iph-&gt;protocol
op_amp
(paren
id|MAX_IP_PROTOS
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ipprot
op_assign
(paren
r_struct
id|ip_protocol
op_star
)paren
id|ip_protos
(braket
id|hash
)braket
suffix:semicolon
id|ipprot
op_ne
l_int|NULL
suffix:semicolon
id|ipprot
op_assign
(paren
r_struct
id|ip_protocol
op_star
)paren
id|ipprot-&gt;next
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_if
c_cond
(paren
id|ipprot-&gt;protocol
op_ne
id|iph-&gt;protocol
)paren
r_continue
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;Using protocol = %X:&bslash;n&quot;
comma
id|ipprot
)paren
)paren
suffix:semicolon
id|print_ipprot
(paren
id|ipprot
)paren
suffix:semicolon
multiline_comment|/* pass it off to everyone who wants it. */
multiline_comment|/* we should check the return values here. */
multiline_comment|/* see if we need to make a copy of it.  This will&n;&t;  only be set if more than one protpocol wants it. &n;&t;  and then not for the last one. */
r_if
c_cond
(paren
id|ipprot-&gt;copy
)paren
(brace
id|skb2
op_assign
id|kmalloc
(paren
id|skb-&gt;mem_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb2
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|memcpy
(paren
id|skb2
comma
id|skb
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
id|skb2-&gt;mem_addr
op_assign
id|skb2
suffix:semicolon
id|skb2-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|skb2-&gt;h.raw
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|skb2
op_plus
(paren
r_int
r_int
)paren
id|skb-&gt;h.raw
op_minus
(paren
r_int
r_int
)paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb2
op_assign
id|skb
suffix:semicolon
)brace
id|flag
op_assign
l_int|1
suffix:semicolon
id|ipprot-&gt;handler
(paren
id|skb2
comma
id|dev
comma
op_amp
id|opt
comma
id|iph-&gt;daddr
comma
id|net16
c_func
(paren
id|iph-&gt;tot_len
)paren
op_minus
id|iph-&gt;ihl
op_star
l_int|4
comma
id|iph-&gt;saddr
comma
l_int|0
comma
id|ipprot
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
id|icmp_reply
(paren
id|skb
comma
id|ICMP_DEST_UNREACH
comma
id|ICMP_PROT_UNREACH
comma
id|dev
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|kfree_skb
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* queues a packet to be sent, and starts the transmitter if&n;   necessary.  if free = 1 then we free the block after transmit,&n;   otherwise we don&squot;t. */
multiline_comment|/* This routine also needs to put in the total length, and compute&n;   the checksum. */
r_void
DECL|function|ip_queue_xmit
id|ip_queue_xmit
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|free
)paren
(brace
r_struct
id|ip_header
op_star
id|iph
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
id|free
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;ip.c: ip_queue_xmit dev = NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb-&gt;free
op_assign
id|free
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;&gt;&gt;&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
suffix:semicolon
id|ptr
op_add_assign
id|dev-&gt;hard_header_len
suffix:semicolon
id|iph
op_assign
(paren
r_struct
id|ip_header
op_star
)paren
id|ptr
suffix:semicolon
id|iph-&gt;tot_len
op_assign
id|net16
c_func
(paren
id|skb-&gt;len
op_minus
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
id|ip_send_check
(paren
id|iph
)paren
suffix:semicolon
id|print_iph
c_func
(paren
id|iph
)paren
suffix:semicolon
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* see if this is the one&n;     trashing our queue. */
id|skb-&gt;magic
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|free
)paren
(brace
id|skb-&gt;link3
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;packets_out
op_increment
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;send_tail
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;send_tail
op_assign
id|skb
suffix:semicolon
id|sk-&gt;send_head
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;send_tail-&gt;link3
op_assign
id|skb
suffix:semicolon
id|sk-&gt;send_tail
op_assign
id|skb
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;time_wait.len
op_assign
id|sk-&gt;rtt
op_star
l_int|2
suffix:semicolon
id|sk-&gt;timeout
op_assign
id|TIME_WRITE
suffix:semicolon
id|reset_timer
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;up
)paren
(brace
r_if
c_cond
(paren
id|sk
op_ne
l_int|NULL
)paren
(brace
id|dev
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
id|sk-&gt;priority
)paren
suffix:semicolon
)brace
r_else
(brace
id|dev-&gt;queue_xmit
(paren
id|skb
comma
id|dev
comma
id|SOPRI_NORMAL
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|free
)paren
id|kfree_skb
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|ip_retransmit
id|ip_retransmit
(paren
r_volatile
r_struct
id|sock
op_star
id|sk
comma
r_int
id|all
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|proto
op_star
id|prot
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
id|prot
op_assign
id|sk-&gt;prot
suffix:semicolon
id|skb
op_assign
id|sk-&gt;send_head
suffix:semicolon
r_while
c_loop
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
multiline_comment|/* rebuild_header sees if the arp is done.  If not it sends a new&n;&t; arp, and if so it builds the header. */
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;arp
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;rebuild_header
(paren
(paren
r_struct
id|enet_header
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
comma
id|dev
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|all
)paren
r_break
suffix:semicolon
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|skb-&gt;link3
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;when
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;up
)paren
r_if
c_cond
(paren
id|sk
)paren
id|dev
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
id|sk-&gt;priority
)paren
suffix:semicolon
r_else
id|dev
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
id|SOPRI_NORMAL
)paren
suffix:semicolon
id|sk-&gt;retransmits
op_increment
suffix:semicolon
id|sk-&gt;prot-&gt;retransmits
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|all
)paren
r_break
suffix:semicolon
multiline_comment|/* this should cut it off before we send too&n;&t; many packets. */
r_if
c_cond
(paren
id|sk-&gt;retransmits
OG
id|sk-&gt;cong_window
)paren
r_break
suffix:semicolon
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|skb-&gt;link3
suffix:semicolon
)brace
multiline_comment|/* double the rtt time every time we retransmit. &n;     This will cause exponential back off on how&n;     hard we try to get through again.  Once we&n;     get through, the rtt will settle back down&n;     reasonably quickly. */
id|sk-&gt;rtt
op_mul_assign
l_int|2
suffix:semicolon
id|sk-&gt;time_wait.len
op_assign
id|sk-&gt;rtt
suffix:semicolon
id|sk-&gt;timeout
op_assign
id|TIME_WRITE
suffix:semicolon
id|reset_timer
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
)brace
r_void
DECL|function|print_iph
id|print_iph
(paren
r_struct
id|ip_header
op_star
id|ip
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;ip header:&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;  ihl = %d, version = %d, tos = %d, tot_len = %d&bslash;n&quot;
comma
id|ip-&gt;ihl
comma
id|ip-&gt;version
comma
id|ip-&gt;tos
comma
id|net16
c_func
(paren
id|ip-&gt;tot_len
)paren
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;  id = %x, ttl = %d, prot = %d, check=%x&bslash;n&quot;
comma
id|ip-&gt;id
comma
id|ip-&gt;ttl
comma
id|ip-&gt;protocol
comma
id|ip-&gt;check
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot; frag_off=%d&bslash;n&quot;
comma
id|ip-&gt;frag_off
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;  saddr = %X, daddr = %X&bslash;n&quot;
comma
id|ip-&gt;saddr
comma
id|ip-&gt;daddr
)paren
)paren
suffix:semicolon
)brace
eof
