multiline_comment|/* timer.c */
multiline_comment|/*&n;  Copyright (C) 1992  Ross Biro&n;  &n;  This program is free software; you can redistribute it and/or modify&n;  it under the terms of the GNU General Public License as published by&n;  the Free Software Foundation; either version 1, or (at your option)&n;  any later version.&n;  &n;  This program is distributed in the hope that it will be useful,&n;  but WITHOUT ANY WARRANTY; without even the implied warranty of&n;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;  GNU General Public License for more details.&n;  &n;  You should have received a copy of the GNU General Public License&n;  along with this program; if not, write to the Free Software&n;  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. &n;  &n;  The Author may be reached as bir7@leland.stanford.edu or&n;  C/O Department of Mathematics; Stanford University; Stanford, CA 94305&n;  */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;netinet/in.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &quot;timer.h&quot;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &quot;arp.h&quot;
macro_line|#include &quot;../kern_sock.h&quot;
DECL|variable|timer_base
r_static
r_struct
id|timer
op_star
id|timer_base
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|seq_offset
r_int
r_int
id|seq_offset
suffix:semicolon
r_void
DECL|function|delete_timer
id|delete_timer
(paren
r_struct
id|timer
op_star
id|t
)paren
(brace
r_struct
id|timer
op_star
id|tm
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;delete_timer (t=%X)&bslash;n&quot;
comma
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_base
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_eq
id|timer_base
)paren
(brace
id|timer_base
op_assign
id|t-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|timer_base
op_ne
l_int|NULL
)paren
(brace
id|timer_table
(braket
id|NET_TIMER
)braket
dot
id|expires
op_assign
id|timer_base-&gt;when
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|NET_TIMER
suffix:semicolon
)brace
r_else
(brace
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|NET_TIMER
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|tm
op_assign
id|timer_base
suffix:semicolon
id|tm-&gt;next
op_ne
l_int|NULL
suffix:semicolon
id|tm
op_assign
id|tm-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tm-&gt;next
op_eq
id|t
)paren
(brace
id|tm-&gt;next
op_assign
id|t-&gt;next
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|reset_timer
id|reset_timer
(paren
r_struct
id|timer
op_star
id|t
)paren
(brace
r_struct
id|timer
op_star
id|tm
suffix:semicolon
id|delete_timer
(paren
id|t
)paren
suffix:semicolon
id|t-&gt;when
op_assign
id|timer_seq
op_plus
id|t-&gt;len
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;reset_timer (t=%X) when = %d jiffies = %d&bslash;n&quot;
comma
id|t
comma
id|t-&gt;when
comma
id|jiffies
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;*** reset timer NULL timer&bslash;n&quot;
)paren
suffix:semicolon
id|__asm__
(paren
l_string|&quot;&bslash;t int $3&bslash;n&quot;
op_scope_resolution
)paren
suffix:semicolon
)brace
multiline_comment|/* first see if it goes at the beginning. */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_base
op_eq
l_int|NULL
)paren
(brace
id|t-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|timer_base
op_assign
id|t
suffix:semicolon
id|timer_table
(braket
id|NET_TIMER
)braket
dot
id|expires
op_assign
id|t-&gt;when
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|NET_TIMER
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|before
(paren
id|t-&gt;when
comma
id|timer_base-&gt;when
)paren
)paren
(brace
id|t-&gt;next
op_assign
id|timer_base
suffix:semicolon
id|timer_base
op_assign
id|t
suffix:semicolon
id|timer_table
(braket
id|NET_TIMER
)braket
dot
id|expires
op_assign
id|t-&gt;when
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|NET_TIMER
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|tm
op_assign
id|timer_base
suffix:semicolon
suffix:semicolon
id|tm
op_assign
id|tm-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tm-&gt;next
op_eq
l_int|NULL
op_logical_or
id|before
(paren
id|t-&gt;when
comma
id|tm-&gt;next-&gt;when
)paren
)paren
(brace
id|t-&gt;next
op_assign
id|tm-&gt;next
suffix:semicolon
id|tm-&gt;next
op_assign
id|t
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
r_void
DECL|function|net_timer
id|net_timer
(paren
r_void
)paren
(brace
r_volatile
r_struct
id|sock
op_star
id|sk
suffix:semicolon
multiline_comment|/* now we will only be called whenever we need to do something, but&n;      we must be sure to process all of the sockets that need it. */
r_while
c_loop
(paren
id|timer_base
op_ne
l_int|NULL
op_logical_and
id|after
(paren
id|timer_seq
op_plus
l_int|1
comma
id|timer_base-&gt;when
)paren
)paren
(brace
r_int
id|why
suffix:semicolon
id|sk
op_assign
id|timer_base-&gt;sk
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;inuse
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
(paren
l_string|&quot;net_timer: found sk=%X&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
id|why
op_assign
id|sk-&gt;timeout
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;keepopen
)paren
(brace
id|sk-&gt;time_wait.len
op_assign
id|TCP_TIMEOUT_LEN
suffix:semicolon
id|sk-&gt;timeout
op_assign
id|TIME_KEEPOPEN
suffix:semicolon
id|reset_timer
(paren
id|timer_base
)paren
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|delete_timer
c_func
(paren
id|timer_base
)paren
suffix:semicolon
)brace
multiline_comment|/* always see if we need to send an ack. */
r_if
c_cond
(paren
id|sk-&gt;ack_backlog
)paren
(brace
id|sk-&gt;prot
op_member_access_from_pointer
id|read_wakeup
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|wake_up
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
multiline_comment|/* now we need to figure out why the socket was on the timer. */
r_switch
c_cond
(paren
id|why
)paren
(brace
r_case
id|TIME_DONE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
op_logical_or
id|sk-&gt;state
op_ne
id|TCP_CLOSE
)paren
(brace
id|printk
(paren
l_string|&quot;non dead socket in time_done&bslash;n&quot;
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|destroy_sock
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_DESTROY
suffix:colon
multiline_comment|/* we&squot;ve waited for a while for all&n;&t;&t;&t;&t;  the memory assosiated with the&n;&t;&t;&t;&t;  socket to be freed.  We need to&n;&t;&t;&t;&t;  print an error message. */
id|PRINTK
(paren
l_string|&quot;possible memory leak.  sk = %X&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
id|print_sk
(paren
id|sk
)paren
suffix:semicolon
id|reset_timer
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_CLOSE
suffix:colon
multiline_comment|/* we&squot;ve waited long enough, close the&n;&t;&t;&t;&t;socket. */
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|delete_timer
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
multiline_comment|/* kill the arp entry &n;&t;&t;in case the hardware has changed. */
id|arp_destroy
(paren
id|sk-&gt;daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|wake_up
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_WRITE
suffix:colon
multiline_comment|/* try to retransmit. */
r_if
c_cond
(paren
id|sk-&gt;send_head
op_ne
l_int|NULL
)paren
(brace
id|sk-&gt;retransmits
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;retransmits
OG
id|TCP_RETR1
)paren
(brace
id|arp_destroy
(paren
id|sk-&gt;daddr
)paren
suffix:semicolon
id|ip_route_check
(paren
id|sk-&gt;daddr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;retransmits
OG
id|TCP_RETR2
)paren
(brace
id|sk-&gt;err
op_assign
id|ETIMEDOUT
suffix:semicolon
id|arp_destroy
(paren
id|sk-&gt;daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT1
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT2
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_LAST_ACK
)paren
(brace
id|sk-&gt;state
op_assign
id|TCP_TIME_WAIT
suffix:semicolon
id|sk-&gt;timeout
op_assign
id|TIME_CLOSE
suffix:semicolon
id|sk-&gt;time_wait.len
op_assign
id|TCP_TIMEWAIT_LEN
suffix:semicolon
id|reset_timer
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
multiline_comment|/* sk-&gt;state == ... */
(brace
id|sk-&gt;prot-&gt;close
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* sk-&gt;retransmites .. */
(brace
id|sk-&gt;prot-&gt;retransmit
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* if we have stuff which hasn&squot;t been written because the&n;&t;&t;window is too small, fall throught to TIME_KEEPOPEN */
r_if
c_cond
(paren
id|sk-&gt;wfront
op_eq
l_int|NULL
)paren
(brace
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* this basically assumes tcp here. */
multiline_comment|/* exponential fall back. */
id|sk-&gt;rtt
op_mul_assign
l_int|2
suffix:semicolon
id|sk-&gt;time_wait.len
op_assign
id|sk-&gt;rtt
op_star
l_int|2
suffix:semicolon
id|sk-&gt;timeout
op_assign
id|TIME_WRITE
suffix:semicolon
id|reset_timer
(paren
(paren
r_struct
id|timer
op_star
)paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
r_case
id|TIME_KEEPOPEN
suffix:colon
multiline_comment|/* send something to keep the&n;&t;&t;&t;&t;   connection open. */
id|sk-&gt;retransmits
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;retransmits
OG
id|TCP_RETR1
)paren
(brace
id|arp_destroy
(paren
id|sk-&gt;daddr
)paren
suffix:semicolon
id|ip_route_check
(paren
id|sk-&gt;daddr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;retransmits
OG
id|TCP_RETR2
)paren
(brace
id|arp_destroy
(paren
id|sk-&gt;daddr
)paren
suffix:semicolon
id|sk-&gt;err
op_assign
id|ETIMEDOUT
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT1
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT2
)paren
(brace
id|sk-&gt;state
op_assign
id|TCP_TIME_WAIT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|wake_up
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* sk-&gt;state == */
(brace
id|sk-&gt;prot-&gt;close
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_else
multiline_comment|/* sk-&gt;retransmits. */
(brace
r_if
c_cond
(paren
id|sk-&gt;prot-&gt;write_wakeup
op_ne
l_int|NULL
)paren
id|sk-&gt;prot
op_member_access_from_pointer
id|write_wakeup
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* switch */
)brace
multiline_comment|/* while (timer_base != ...  */
multiline_comment|/* Now we need to reset the timer. */
r_if
c_cond
(paren
id|timer_base
op_ne
l_int|NULL
)paren
(brace
id|timer_table
(braket
id|NET_TIMER
)braket
dot
id|expires
op_assign
id|timer_base-&gt;when
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|NET_TIMER
suffix:semicolon
)brace
)brace
eof
