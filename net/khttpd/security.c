multiline_comment|/*&n;&n;kHTTPd -- the next generation&n;&n;Permissions/Security functions&n;&n;*/
multiline_comment|/****************************************************************&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2, or (at your option)&n; *&t;any later version.&n; *&n; *&t;This program is distributed in the hope that it will be useful,&n; *&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *&t;GNU General Public License for more details.&n; *&n; *&t;You should have received a copy of the GNU General Public License&n; *&t;along with this program; if not, write to the Free Software&n; *&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; ****************************************************************/
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/un.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &quot;sysctl.h&quot;
macro_line|#include &quot;security.h&quot;
macro_line|#include &quot;prototypes.h&quot;
multiline_comment|/*&n;&n;The basic security function answers &quot;Userspace&quot; when any one of the following &n;conditions is met:&n;&n;1) The filename contains a &quot;?&quot; (this is before % decoding, all others are &n;                                after % decoding)&n;2) The filename doesn&squot;t start with a &quot;/&quot;                                &n;3) The file does not exist&n;4) The file does not have enough permissions &n;   (sysctl-configurable, default = worldreadble)&n;5) The file has any of the &quot;forbidden&quot; permissions &n;   (sysctl-configurable, default = execute, directory and sticky)&n;6) The filename contains a string as defined in the &quot;Dynamic&quot; list.&n;&n;*/
multiline_comment|/* Prototypes */
r_static
r_void
id|DecodeHexChars
c_func
(paren
r_char
op_star
id|URL
)paren
suffix:semicolon
DECL|variable|DynamicList
r_static
r_struct
id|DynamicString
op_star
id|DynamicList
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&n;The function &quot;OpenFileForSecurity&quot; returns either the &quot;struct file&quot; pointer&n;of the file, or NULL. NULL means &quot;let userspace handle it&quot;. &n;&n;*/
DECL|function|OpenFileForSecurity
r_struct
id|file
op_star
id|OpenFileForSecurity
c_func
(paren
r_char
op_star
id|Filename
)paren
(brace
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|DynamicString
op_star
id|List
suffix:semicolon
id|umode_t
id|permission
suffix:semicolon
id|EnterFunction
c_func
(paren
l_string|&quot;OpenFileForSecurity&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Filename
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|Filename
)paren
op_ge
l_int|256
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Sanity check */
multiline_comment|/* Rule no. 1  -- No &quot;?&quot; characters */
macro_line|#ifndef BENCHMARK&t;
r_if
c_cond
(paren
id|strchr
c_func
(paren
id|Filename
comma
l_char|&squot;?&squot;
)paren
op_ne
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Intermediate step: decode all %hex sequences */
id|DecodeHexChars
c_func
(paren
id|Filename
)paren
suffix:semicolon
multiline_comment|/* Rule no. 2  -- Must start with a &quot;/&quot; */
r_if
c_cond
(paren
id|Filename
(braket
l_int|0
)braket
op_ne
l_char|&squot;/&squot;
)paren
r_return
l_int|NULL
suffix:semicolon
macro_line|#endif
multiline_comment|/* Rule no. 3 -- Does the file exist ? */
id|filp
op_assign
id|filp_open
c_func
(paren
id|Filename
comma
id|O_RDONLY
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|filp
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
macro_line|#ifndef BENCHMARK&t;&t;
id|permission
op_assign
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_mode
suffix:semicolon
multiline_comment|/* Rule no. 4 : must have enough permissions */
r_if
c_cond
(paren
(paren
id|permission
op_amp
id|sysctl_khttpd_permreq
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|filp
op_ne
l_int|NULL
)paren
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
id|filp
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Rule no. 5 : cannot have &quot;forbidden&quot; permission */
r_if
c_cond
(paren
(paren
id|permission
op_amp
id|sysctl_khttpd_permforbid
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|filp
op_ne
l_int|NULL
)paren
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
id|filp
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Rule no. 6 : No string in DynamicList can be a&n;&t;&t;&t;substring of the filename */
id|List
op_assign
id|DynamicList
suffix:semicolon
r_while
c_loop
(paren
id|List
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|Filename
comma
id|List-&gt;value
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|filp
op_ne
l_int|NULL
)paren
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
id|filp
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|List
op_assign
id|List-&gt;Next
suffix:semicolon
)brace
macro_line|#endif&t;
id|LeaveFunction
c_func
(paren
l_string|&quot;OpenFileForSecurity - success&quot;
)paren
suffix:semicolon
r_return
id|filp
suffix:semicolon
)brace
multiline_comment|/* &n;&n;DecodeHexChars does the actual %HEX decoding, in place. &n;In place is possible because strings only get shorter by this.&n;&n;*/
DECL|function|DecodeHexChars
r_static
r_void
id|DecodeHexChars
c_func
(paren
r_char
op_star
id|URL
)paren
(brace
r_char
op_star
id|Source
comma
op_star
id|Dest
suffix:semicolon
r_int
id|val
comma
id|val2
suffix:semicolon
id|EnterFunction
c_func
(paren
l_string|&quot;DecodeHexChars&quot;
)paren
suffix:semicolon
id|Source
op_assign
id|strchr
c_func
(paren
id|URL
comma
l_char|&squot;%&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Source
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|Dest
op_assign
id|Source
suffix:semicolon
r_while
c_loop
(paren
op_star
id|Source
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_star
id|Source
op_eq
l_char|&squot;%&squot;
)paren
(brace
id|Source
op_increment
suffix:semicolon
id|val
op_assign
op_star
id|Source
suffix:semicolon
r_if
c_cond
(paren
id|val
OG
l_char|&squot;Z&squot;
)paren
id|val
op_sub_assign
l_int|0x20
suffix:semicolon
id|val
op_assign
id|val
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|val
OL
l_int|0
)paren
id|val
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
OG
l_int|9
)paren
id|val
op_sub_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|val
OG
l_int|15
)paren
id|val
op_assign
l_int|15
suffix:semicolon
id|Source
op_increment
suffix:semicolon
id|val2
op_assign
op_star
id|Source
suffix:semicolon
r_if
c_cond
(paren
id|val2
OG
l_char|&squot;Z&squot;
)paren
id|val2
op_sub_assign
l_int|0x20
suffix:semicolon
id|val2
op_assign
id|val2
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|val2
OL
l_int|0
)paren
id|val2
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val2
OG
l_int|9
)paren
id|val2
op_sub_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|val2
OG
l_int|15
)paren
id|val2
op_assign
l_int|15
suffix:semicolon
op_star
id|Dest
op_assign
id|val
op_star
l_int|16
op_plus
id|val2
suffix:semicolon
)brace
r_else
op_star
id|Dest
op_assign
op_star
id|Source
suffix:semicolon
id|Dest
op_increment
suffix:semicolon
id|Source
op_increment
suffix:semicolon
)brace
op_star
id|Dest
op_assign
l_int|0
suffix:semicolon
id|LeaveFunction
c_func
(paren
l_string|&quot;DecodeHexChars&quot;
)paren
suffix:semicolon
)brace
DECL|function|AddDynamicString
r_void
id|AddDynamicString
c_func
(paren
r_const
r_char
op_star
id|String
)paren
(brace
r_struct
id|DynamicString
op_star
id|Temp
suffix:semicolon
id|EnterFunction
c_func
(paren
l_string|&quot;AddDynamicString&quot;
)paren
suffix:semicolon
id|Temp
op_assign
(paren
r_struct
id|DynamicString
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|DynamicString
)paren
comma
(paren
r_int
)paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Temp
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|memset
c_func
(paren
id|Temp-&gt;value
comma
l_int|0
comma
r_sizeof
(paren
id|Temp-&gt;value
)paren
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|Temp-&gt;value
comma
id|String
comma
r_sizeof
(paren
id|Temp-&gt;value
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|Temp-&gt;Next
op_assign
id|DynamicList
suffix:semicolon
id|DynamicList
op_assign
id|Temp
suffix:semicolon
id|LeaveFunction
c_func
(paren
l_string|&quot;AddDynamicString&quot;
)paren
suffix:semicolon
)brace
DECL|function|GetSecureString
r_void
id|GetSecureString
c_func
(paren
r_char
op_star
id|String
)paren
(brace
r_struct
id|DynamicString
op_star
id|Temp
suffix:semicolon
r_int
id|max
suffix:semicolon
id|EnterFunction
c_func
(paren
l_string|&quot;GetSecureString&quot;
)paren
suffix:semicolon
op_star
id|String
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|String
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|String
comma
l_string|&quot;Dynamic strings are : -&quot;
comma
l_int|255
)paren
suffix:semicolon
id|Temp
op_assign
id|DynamicList
suffix:semicolon
r_while
c_loop
(paren
id|Temp
op_ne
l_int|NULL
)paren
(brace
id|max
op_assign
l_int|253
op_minus
id|strlen
c_func
(paren
id|String
)paren
op_minus
id|strlen
c_func
(paren
id|Temp-&gt;value
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|String
comma
id|Temp-&gt;value
comma
id|max
)paren
suffix:semicolon
id|max
op_assign
l_int|253
op_minus
id|strlen
c_func
(paren
id|String
)paren
op_minus
l_int|3
suffix:semicolon
id|strncat
c_func
(paren
id|String
comma
l_string|&quot;- -&quot;
comma
id|max
)paren
suffix:semicolon
id|Temp
op_assign
id|Temp-&gt;Next
suffix:semicolon
)brace
id|LeaveFunction
c_func
(paren
l_string|&quot;GetSecureString&quot;
)paren
suffix:semicolon
)brace
eof
