multiline_comment|/*&n;&n;kHTTPd -- the next generation&n;&n;Accept connections&n;&n;*/
multiline_comment|/****************************************************************&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2, or (at your option)&n; *&t;any later version.&n; *&n; *&t;This program is distributed in the hope that it will be useful,&n; *&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *&t;GNU General Public License for more details.&n; *&n; *&t;You should have received a copy of the GNU General Public License&n; *&t;along with this program; if not, write to the Free Software&n; *&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; ****************************************************************/
macro_line|#include &quot;structure.h&quot;
macro_line|#include &quot;prototypes.h&quot;
macro_line|#include &quot;sysctl.h&quot;
macro_line|#include &lt;linux/smp_lock.h&gt;
multiline_comment|/*&n;&n;Purpose:&n;&n;AcceptConnections puts all &quot;accepted&quot; connections in the &n;&quot;WaitForHeader&quot; queue.&n;&n;Return value:&n;&t;The number of accepted connections&n;*/
DECL|function|AcceptConnections
r_int
id|AcceptConnections
c_func
(paren
r_const
r_int
id|CPUNR
comma
r_struct
id|socket
op_star
id|Socket
)paren
(brace
r_struct
id|http_request
op_star
id|NewRequest
suffix:semicolon
r_struct
id|socket
op_star
id|NewSock
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|error
suffix:semicolon
id|EnterFunction
c_func
(paren
l_string|&quot;AcceptConnections&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ConnectCount
)paren
OG
id|sysctl_khttpd_maxconnect
)paren
(brace
id|LeaveFunction
c_func
(paren
l_string|&quot;AcceptConnections - to many active connections&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Socket
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t;   Quick test to see if there are connections on the queue.&n;&t;   This is cheaper than accept() itself because this saves us&n;&t;   the allocation of a new socket. (Which doesn&squot;t seem to be &n;&t;   used anyway)&n;&t;*/
r_if
c_cond
(paren
id|Socket-&gt;sk-&gt;tp_pinfo.af_tcp.accept_queue
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|error
op_ge
l_int|0
)paren
(brace
id|NewSock
op_assign
id|sock_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NewSock
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|NewSock-&gt;type
op_assign
id|Socket-&gt;type
suffix:semicolon
id|NewSock-&gt;ops
op_assign
id|Socket-&gt;ops
suffix:semicolon
id|error
op_assign
id|Socket-&gt;ops
op_member_access_from_pointer
id|accept
c_func
(paren
id|Socket
comma
id|NewSock
comma
id|O_NONBLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
id|sock_release
c_func
(paren
id|NewSock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|NewSock-&gt;sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
(brace
id|sock_release
c_func
(paren
id|NewSock
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Allocate a request-entry for the connection */
id|NewRequest
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|http_request
)paren
comma
(paren
r_int
)paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NewRequest
op_eq
l_int|NULL
)paren
(brace
id|Send50x
c_func
(paren
id|NewSock
)paren
suffix:semicolon
multiline_comment|/* Service not available. Try again later */
id|sock_release
c_func
(paren
id|NewSock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memset
c_func
(paren
id|NewRequest
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|http_request
)paren
)paren
suffix:semicolon
id|NewRequest-&gt;sock
op_assign
id|NewSock
suffix:semicolon
id|NewRequest-&gt;Next
op_assign
id|threadinfo
(braket
id|CPUNR
)braket
dot
id|WaitForHeaderQueue
suffix:semicolon
id|init_waitqueue_entry
c_func
(paren
op_amp
id|NewRequest-&gt;sleep
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|NewSock-&gt;sk-&gt;sleep
comma
op_amp
(paren
id|NewRequest-&gt;sleep
)paren
)paren
suffix:semicolon
id|threadinfo
(braket
id|CPUNR
)braket
dot
id|WaitForHeaderQueue
op_assign
id|NewRequest
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|ConnectCount
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
id|LeaveFunction
c_func
(paren
l_string|&quot;AcceptConnections&quot;
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
eof
