multiline_comment|/*********************************************************************&n; *                &n; * Filename:      irobex.c&n; * Version:       0.3&n; * Description:   Kernel side of the IrOBEX layer&n; * Status:        Experimental.&n; * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Created at:    Thu Jun 25 21:21:07 1998&n; * Modified at:   Sat Jan 16 22:18:03 1999&n; * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * &n; *     Copyright (c) 1998 Dag Brattli, All Rights Reserved.&n; *      &n; *     This program is free software; you can redistribute it and/or &n; *     modify it under the terms of the GNU General Public License as &n; *     published by the Free Software Foundation; either version 2 of &n; *     the License, or (at your option) any later version.&n; *  &n; *     Neither Dag Brattli nor University of Troms&#xfffd; admit liability nor&n; *     provide warranty for any of this software. This material is &n; *     provided &quot;AS-IS&quot; and at no charge.&n; *&n; ********************************************************************/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;net/irda/irttp.h&gt;
macro_line|#include &lt;net/irda/irias_object.h&gt;
macro_line|#include &lt;net/irda/iriap.h&gt;
macro_line|#include &lt;net/irda/irobex.h&gt;
multiline_comment|/*&n; *  Master structure, only one instance for now!!&n; */
DECL|variable|irobex
r_struct
id|irobex_cb
op_star
id|irobex
suffix:semicolon
DECL|variable|irobex_state
r_char
op_star
id|irobex_state
(braket
)braket
op_assign
(brace
l_string|&quot;OBEX_IDLE&quot;
comma
l_string|&quot;OBEX_DISCOVER&quot;
comma
l_string|&quot;OBEX_QUERY&quot;
comma
l_string|&quot;OBEX_CONN&quot;
comma
l_string|&quot;OBEX_DATA&quot;
comma
)brace
suffix:semicolon
r_static
r_int
id|irobex_dev_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|irobex_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|irobex_dev_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
id|ssize_t
id|irobex_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|noidea
)paren
suffix:semicolon
r_static
id|ssize_t
id|irobex_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|noidea
)paren
suffix:semicolon
r_static
id|loff_t
id|irobex_seek
c_func
(paren
r_struct
id|file
op_star
comma
id|loff_t
comma
r_int
)paren
suffix:semicolon
r_static
id|u_int
id|irobex_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
suffix:semicolon
r_static
r_int
id|irobex_fasync
c_func
(paren
r_int
comma
r_struct
id|file
op_star
comma
r_int
)paren
suffix:semicolon
DECL|variable|irobex_fops
r_static
r_struct
id|file_operations
id|irobex_fops
op_assign
(brace
id|irobex_seek
comma
multiline_comment|/* seek */
id|irobex_read
comma
id|irobex_write
comma
l_int|NULL
comma
multiline_comment|/* readdir */
id|irobex_poll
comma
multiline_comment|/* poll */
id|irobex_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|irobex_dev_open
comma
l_int|NULL
comma
id|irobex_dev_close
comma
l_int|NULL
comma
id|irobex_fasync
comma
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_static
r_int
id|irobex_proc_read
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|len
comma
r_int
id|unused
)paren
suffix:semicolon
r_extern
r_struct
id|proc_dir_entry
id|proc_irda
suffix:semicolon
DECL|variable|proc_irobex
r_struct
id|proc_dir_entry
id|proc_irobex
op_assign
(brace
l_int|0
comma
l_int|6
comma
l_string|&quot;irobex&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
op_amp
id|irobex_proc_read
comma
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Function irobex_init (dev)&n; *&n; *   Initializes the irobex control structure, and registers as a misc&n; *   device&n; *&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
id|irobex_init
c_func
(paren
r_void
)paren
)paren
(brace
r_struct
id|irobex_cb
op_star
id|self
suffix:semicolon
id|self
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irobex_cb
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|self
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|irobex_cb
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|self-&gt;devname
comma
l_string|&quot;irobex%d&quot;
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Just one instance for now */
id|self-&gt;magic
op_assign
id|IROBEX_MAGIC
suffix:semicolon
id|self-&gt;rx_flow
op_assign
id|self-&gt;tx_flow
op_assign
id|FLOW_START
suffix:semicolon
id|self-&gt;dev.minor
op_assign
id|MISC_DYNAMIC_MINOR
suffix:semicolon
id|self-&gt;dev.name
op_assign
l_string|&quot;irobex&quot;
suffix:semicolon
id|self-&gt;dev.fops
op_assign
op_amp
id|irobex_fops
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|self-&gt;rx_queue
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|self-&gt;watchdog_timer
)paren
suffix:semicolon
id|irobex
op_assign
id|self
suffix:semicolon
id|misc_register
c_func
(paren
op_amp
id|self-&gt;dev
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|proc_register
c_func
(paren
op_amp
id|proc_irda
comma
op_amp
id|proc_irobex
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
id|irlmp_register_layer
c_func
(paren
id|S_OBEX
comma
id|CLIENT
op_or
id|SERVER
comma
id|TRUE
comma
id|irobex_discovery_indication
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irobex_cleanup (void)&n; *&n; *     Removes the IrOBEX layer&n; *&n; */
macro_line|#ifdef MODULE
DECL|function|irobex_cleanup
r_void
id|irobex_cleanup
c_func
(paren
r_void
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|irobex_cb
op_star
id|self
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
id|irobex
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IROBEX_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Deregister client and server&n;&t; */
id|irlmp_unregister_layer
c_func
(paren
id|S_OBEX
comma
id|CLIENT
op_or
id|SERVER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;tsap
)paren
(brace
id|irttp_close_tsap
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
id|self-&gt;tsap
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Stop timers */
id|del_timer
c_func
(paren
op_amp
id|self-&gt;watchdog_timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Deallocate buffers&n;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;rx_queue
)paren
)paren
op_ne
l_int|NULL
)paren
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|proc_unregister
c_func
(paren
op_amp
id|proc_irda
comma
id|proc_irobex.low_ino
)paren
suffix:semicolon
macro_line|#endif
id|misc_deregister
c_func
(paren
op_amp
id|self-&gt;dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|self
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
multiline_comment|/*&n; * Function irobex_read (inode, file, buffer, count)&n; *&n; *    User process wants to read some data&n; *&n; */
DECL|function|irobex_read
r_static
id|ssize_t
id|irobex_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|noidea
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_struct
id|irobex_cb
op_star
id|self
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|self
op_assign
id|irobex
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
id|EIO
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IROBEX_MAGIC
comma
r_return
op_minus
id|EIO
suffix:semicolon
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;: count=%d, skb_len=%d, state=%s, eof=%d&bslash;n&quot;
comma
id|count
comma
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;rx_queue
)paren
comma
id|irobex_state
(braket
id|self-&gt;state
)braket
comma
id|self-&gt;eof
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;state
op_ne
id|OBEX_DATA
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), link not connected yet!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  If there is data to return, then we return it. If not, then we &n;&t; *  must check if we are still connected&n;&t; */
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;rx_queue
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Still connected?  */
r_if
c_cond
(paren
id|self-&gt;state
op_ne
id|OBEX_DATA
)paren
(brace
r_switch
c_cond
(paren
id|self-&gt;eof
)paren
(brace
r_case
id|LM_USER_REQUEST
suffix:colon
id|self-&gt;eof
op_assign
id|FALSE
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;read_irobex: returning 0&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LM_LAP_DISCONNECT
suffix:colon
id|self-&gt;eof
op_assign
id|FALSE
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LM_LAP_RESET
suffix:colon
id|self-&gt;eof
op_assign
id|FALSE
suffix:semicolon
id|ret
op_assign
op_minus
id|ECONNRESET
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|self-&gt;eof
op_assign
id|FALSE
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Return if user does not want to block */
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/* Go to sleep and wait for data!  */
id|interruptible_sleep_on
c_func
(paren
op_amp
id|self-&gt;read_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Ensure proper reaction to signals, and screen out &n;&t;&t; *  blocked signals (page 112. linux device drivers)&n;&t;&t; */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
op_logical_and
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;rx_queue
)paren
)paren
(brace
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;rx_queue
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Check if we have previously stopped IrTTP and we know&n;&t;&t; *  have more free space in our rx_queue. If so tell IrTTP&n;&t;&t; *  to start delivering frames again before our rx_queue gets&n;&t;&t; *  empty&n;&t;&t; */
r_if
c_cond
(paren
id|self-&gt;rx_flow
op_eq
id|FLOW_STOP
)paren
(brace
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;rx_queue
)paren
OL
id|LOW_THRESHOLD
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), Starting IrTTP&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;rx_flow
op_assign
id|FLOW_START
suffix:semicolon
id|irttp_flow_request
c_func
(paren
id|self-&gt;tsap
comma
id|FLOW_START
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*  &n;&t;&t; *  Is the request from the user less that the amount in the &n;&t;&t; *  current packet?  &n;&t;&t; */
r_if
c_cond
(paren
id|count
OL
id|skb-&gt;len
)paren
(brace
id|copy_to_user
c_func
(paren
id|buffer
op_plus
id|len
comma
id|skb-&gt;data
comma
id|count
)paren
suffix:semicolon
id|len
op_add_assign
id|count
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Remove copied data from skb and queue&n;&t;&t;&t; *  it for next read&n;&t;&t;&t; */
id|skb_pull
c_func
(paren
id|skb
comma
id|count
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|self-&gt;rx_queue
comma
id|skb
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_else
(brace
id|copy_to_user
c_func
(paren
id|buffer
op_plus
id|len
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|count
op_sub_assign
id|skb-&gt;len
suffix:semicolon
id|len
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irobex_write (inode, file, buffer, count)&n; *&n; *    User process wants to write to device&n; *&n; */
DECL|function|irobex_write
r_static
id|ssize_t
id|irobex_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|noidea
)paren
(brace
r_struct
id|irobex_cb
op_star
id|self
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|data_len
op_assign
l_int|0
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|self
op_assign
id|irobex
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
id|EIO
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IROBEX_MAGIC
comma
r_return
op_minus
id|EIO
suffix:semicolon
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;: count = %d&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  If we are not connected then we just give up!&n;&t; */
r_if
c_cond
(paren
id|self-&gt;state
op_ne
id|OBEX_DATA
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(): Not connected!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOLINK
suffix:semicolon
)brace
multiline_comment|/* Check if IrTTP is wants us to slow down */
r_if
c_cond
(paren
id|self-&gt;tx_flow
op_eq
id|FLOW_STOP
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), IrTTP wants us to slow down, going to sleep&bslash;n&quot;
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|self-&gt;write_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* Send data to TTP layer possibly as muliple packets */
r_while
c_loop
(paren
id|count
)paren
(brace
multiline_comment|/*&n;&t;&t; *  Check if request is larger than what fits inside a TTP&n;&t;&t; *  frame. In that case we must fragment the frame into &n;&t;&t; *  multiple TTP frames. IrOBEX should not care about message&n;&t;&t; *  boundaries.&n;&t;&t; */
r_if
c_cond
(paren
id|count
OL
(paren
id|self-&gt;irlap_data_size
op_minus
id|IROBEX_MAX_HEADER
)paren
)paren
id|data_len
op_assign
id|count
suffix:semicolon
r_else
id|data_len
op_assign
id|self-&gt;irlap_data_size
op_minus
id|IROBEX_MAX_HEADER
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), data_len=%d, header_len = %d&bslash;n&quot;
comma
id|data_len
comma
id|IROBEX_MAX_HEADER
)paren
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|data_len
op_plus
id|IROBEX_MAX_HEADER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irobex - couldn&squot;t allocate skbuff!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
id|IROBEX_MAX_HEADER
)paren
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|data_len
)paren
suffix:semicolon
id|copy_from_user
c_func
(paren
id|skb-&gt;data
comma
id|buffer
op_plus
id|len
comma
id|data_len
)paren
suffix:semicolon
id|len
op_add_assign
id|data_len
suffix:semicolon
id|count
op_sub_assign
id|data_len
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), skb-&gt;len=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|skb-&gt;len
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb-&gt;len
op_le
(paren
id|self-&gt;irlap_data_size
op_minus
id|IROBEX_MAX_HEADER
)paren
comma
r_return
id|len
suffix:semicolon
)paren
suffix:semicolon
id|irttp_data_request
c_func
(paren
id|self-&gt;tsap
comma
id|skb
)paren
suffix:semicolon
)brace
r_return
(paren
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irobex_poll (file, wait)&n; *&n; *    &n; *&n; */
DECL|function|irobex_poll
r_static
id|u_int
id|irobex_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Sorry not implemented yet!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* check out /usr/src/pcmcia/modules/ds.c for an example */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irobex_fasync (inode, filp, mode)&n; *&n; *    Implementation for SIGIO&n; *&n; */
DECL|function|irobex_fasync
r_static
r_int
id|irobex_fasync
c_func
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|on
)paren
(brace
r_struct
id|irobex_cb
op_star
id|self
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
id|irobex
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IROBEX_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_return
id|fasync_helper
c_func
(paren
id|fd
comma
id|filp
comma
id|on
comma
op_amp
id|self-&gt;async
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irobex_seek (inode, file, buffer, count)&n; *&n; *    Not implemented yet!&n; *&n; */
DECL|function|irobex_seek
r_static
id|loff_t
id|irobex_seek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|off
comma
r_int
id|whence
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Not implemented yet!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irobex_ioctl (inode, filp, cmd, arg)&n; *&n; *    Drivers IOCTL handler, used for connecting and disconnecting&n; *    irobex connections&n; *&n; */
DECL|function|irobex_ioctl
r_static
r_int
id|irobex_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|irobex_cb
op_star
id|self
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|size
op_assign
id|_IOC_SIZE
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
id|irobex
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENOTTY
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_assign
id|IROBEX_MAGIC
comma
r_return
op_minus
id|ENOTTY
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_IOC_TYPE
c_func
(paren
id|cmd
)paren
op_ne
id|IROBEX_IOC_MAGIC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|_IOC_NR
c_func
(paren
id|cmd
)paren
OG
id|IROBEX_IOC_MAXNR
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|_IOC_DIR
c_func
(paren
id|cmd
)paren
op_amp
id|_IOC_READ
)paren
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
id|size
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|_IOC_DIR
c_func
(paren
id|cmd
)paren
op_amp
id|_IOC_WRITE
)paren
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|IROBEX_IOCSCONNECT
suffix:colon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(): IROBEX_IOCSCONNECT!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Already connected? */
r_if
c_cond
(paren
id|self-&gt;state
op_eq
id|OBEX_DATA
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), already connected!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Timeout after 15 secs. */
id|irobex_start_watchdog_timer
c_func
(paren
id|self
comma
l_int|1000
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we have discovered a remote device we&n;&t;&t; * check if the discovery is still fresh. If not, we don&squot;t&n;&t;&t; * trust the address.&n;&t;&t; */
r_if
c_cond
(paren
id|self-&gt;daddr
op_logical_and
(paren
(paren
id|jiffies
op_minus
id|self-&gt;time_discovered
)paren
OG
l_int|500
)paren
)paren
id|self-&gt;daddr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Try to discover remote remote device if it has not been &n;&t;&t; * discovered yet. &n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;daddr
)paren
(brace
id|self-&gt;state
op_assign
id|OBEX_DISCOVER
suffix:semicolon
id|irlmp_discovery_request
c_func
(paren
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Wait for discovery to complete */
id|interruptible_sleep_on
c_func
(paren
op_amp
id|self-&gt;write_wait
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;watchdog_timer
)paren
suffix:semicolon
)brace
multiline_comment|/* Give up if we are unable to discover any remote devices */
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;daddr
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unable to discover any devices!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOTTY
suffix:semicolon
)brace
multiline_comment|/* Need to find remote destination TSAP selector? */
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;dtsap_sel
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;() : Quering remote IAS!&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;state
op_assign
id|OBEX_QUERY
suffix:semicolon
multiline_comment|/* Timeout after 5 secs. */
id|irobex_start_watchdog_timer
c_func
(paren
id|self
comma
l_int|500
)paren
suffix:semicolon
id|iriap_getvaluebyclass_request
c_func
(paren
id|self-&gt;daddr
comma
l_string|&quot;OBEX&quot;
comma
l_string|&quot;IrDA:TinyTP:LsapSel&quot;
comma
id|irobex_get_value_confirm
comma
id|self
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|self-&gt;write_wait
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;watchdog_timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;dtsap_sel
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unable to query remote LM-IAS!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOTTY
suffix:semicolon
)brace
id|self-&gt;state
op_assign
id|OBEX_CONN
suffix:semicolon
multiline_comment|/* Timeout after 5 secs. */
id|irobex_start_watchdog_timer
c_func
(paren
id|self
comma
l_int|500
)paren
suffix:semicolon
id|irttp_connect_request
c_func
(paren
id|self-&gt;tsap
comma
id|self-&gt;dtsap_sel
comma
id|self-&gt;daddr
comma
l_int|NULL
comma
id|SAR_DISABLE
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Go to sleep and wait for connection!  */
id|interruptible_sleep_on
c_func
(paren
op_amp
id|self-&gt;write_wait
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;watchdog_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;state
op_ne
id|OBEX_DATA
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unable to connect to remote device!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOTTY
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IROBEX_IOCSDISCONNECT
suffix:colon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(): IROBEX_IOCSDISCONNECT!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;state
op_ne
id|OBEX_DATA
)paren
r_return
l_int|0
suffix:semicolon
id|irttp_disconnect_request
c_func
(paren
id|self-&gt;tsap
comma
l_int|NULL
comma
id|P_NORMAL
)paren
suffix:semicolon
multiline_comment|/* Reset values for this instance */
id|self-&gt;state
op_assign
id|OBEX_IDLE
suffix:semicolon
id|self-&gt;eof
op_assign
id|LM_USER_REQUEST
suffix:semicolon
id|self-&gt;daddr
op_assign
l_int|0
suffix:semicolon
id|self-&gt;dtsap_sel
op_assign
l_int|0
suffix:semicolon
id|self-&gt;rx_flow
op_assign
id|FLOW_START
suffix:semicolon
id|self-&gt;tx_flow
op_assign
id|FLOW_START
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;read_wait
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irobex_dev_open (inode, file)&n; *&n; *    Device opened by user process&n; *&n; */
DECL|function|irobex_dev_open
r_static
r_int
id|irobex_dev_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|irobex_cb
op_star
id|self
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
id|irobex
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IROBEX_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;count
op_increment
)paren
(brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;open_irobex: count not zero; actual = %d&bslash;n&quot;
comma
id|self-&gt;count
)paren
suffix:semicolon
id|self-&gt;count
op_decrement
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|irobex_register_server
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Reset values for this instance */
id|self-&gt;state
op_assign
id|OBEX_IDLE
suffix:semicolon
id|self-&gt;eof
op_assign
id|FALSE
suffix:semicolon
id|self-&gt;daddr
op_assign
l_int|0
suffix:semicolon
id|self-&gt;dtsap_sel
op_assign
l_int|0
suffix:semicolon
id|self-&gt;rx_flow
op_assign
id|FLOW_START
suffix:semicolon
id|self-&gt;tx_flow
op_assign
id|FLOW_START
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|irobex_dev_close
r_static
r_int
id|irobex_dev_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|irobex_cb
op_star
id|self
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
id|irobex
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENODEV
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IROBEX_MAGIC
comma
r_return
op_minus
id|EBADR
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Deallocate buffers */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;rx_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;irobex_close: freeing SKB&bslash;n&quot;
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* Close TSAP is its still there */
r_if
c_cond
(paren
id|self-&gt;tsap
)paren
(brace
id|irttp_close_tsap
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
id|self-&gt;tsap
op_assign
l_int|NULL
suffix:semicolon
)brace
id|self-&gt;state
op_assign
id|OBEX_IDLE
suffix:semicolon
id|self-&gt;eof
op_assign
id|FALSE
suffix:semicolon
id|self-&gt;daddr
op_assign
l_int|0
suffix:semicolon
id|self-&gt;dtsap_sel
op_assign
l_int|0
suffix:semicolon
id|self-&gt;rx_flow
op_assign
id|FLOW_START
suffix:semicolon
id|self-&gt;tx_flow
op_assign
id|FLOW_START
suffix:semicolon
multiline_comment|/* Remove this filp from the asynchronously notified filp&squot;s */
id|irobex_fasync
c_func
(paren
op_minus
l_int|1
comma
id|file
comma
l_int|0
)paren
suffix:semicolon
id|self-&gt;count
op_decrement
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irobex_discovery_inication (daddr)&n; *&n; *    Remote device discovered, try query the remote IAS to see which&n; *    device it is, and which services it has.&n; *&n; */
DECL|function|irobex_discovery_indication
r_void
id|irobex_discovery_indication
c_func
(paren
id|DISCOVERY
op_star
id|discovery
)paren
(brace
r_struct
id|irobex_cb
op_star
id|self
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
id|irobex
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IROBEX_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Remember address and time if was discovered */
id|self-&gt;daddr
op_assign
id|discovery-&gt;daddr
suffix:semicolon
id|self-&gt;time_discovered
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Wake up process if its waiting for device to be discovered */
r_if
c_cond
(paren
id|self-&gt;state
op_eq
id|OBEX_DISCOVER
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;write_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irobex_disconnect_indication (handle, reason, priv)&n; *&n; *    Link has been disconnected&n; *&n; */
DECL|function|irobex_disconnect_indication
r_void
id|irobex_disconnect_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
id|LM_REASON
id|reason
comma
r_struct
id|sk_buff
op_star
id|userdata
)paren
(brace
r_struct
id|irobex_cb
op_star
id|self
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), reason=%d&bslash;n&quot;
comma
id|reason
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irobex_cb
op_star
)paren
id|instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IROBEX_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|self-&gt;state
op_assign
id|OBEX_IDLE
suffix:semicolon
id|self-&gt;eof
op_assign
id|reason
suffix:semicolon
id|self-&gt;daddr
op_assign
l_int|0
suffix:semicolon
id|self-&gt;dtsap_sel
op_assign
l_int|0
suffix:semicolon
id|self-&gt;rx_flow
op_assign
id|self-&gt;tx_flow
op_assign
id|FLOW_START
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;read_wait
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;write_wait
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), skb_queue_len=%d&bslash;n&quot;
comma
id|skb_queue_len
c_func
(paren
op_amp
id|irobex-&gt;rx_queue
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|userdata
)paren
id|dev_kfree_skb
c_func
(paren
id|userdata
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irobex_connect_confirm (instance, sap, qos, userdata)&n; *&n; *    Connection to peer IrOBEX layer established&n; *&n; */
DECL|function|irobex_connect_confirm
r_void
id|irobex_connect_confirm
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|qos_info
op_star
id|qos
comma
r_int
id|max_sdu_size
comma
r_struct
id|sk_buff
op_star
id|userdata
)paren
(brace
r_struct
id|irobex_cb
op_star
id|self
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irobex_cb
op_star
)paren
id|instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IROBEX_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|qos
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), IrLAP data size=%d&bslash;n&quot;
comma
id|qos-&gt;data_size.value
)paren
suffix:semicolon
id|self-&gt;irlap_data_size
op_assign
id|qos-&gt;data_size.value
suffix:semicolon
multiline_comment|/*&n;&t; *  Wake up any blocked process wanting to write. Finally this process&n;&t; *  can start writing since the connection is now open :-)&n;&t; */
r_if
c_cond
(paren
id|self-&gt;state
op_eq
id|OBEX_CONN
)paren
(brace
id|self-&gt;state
op_assign
id|OBEX_DATA
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;write_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|userdata
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|userdata
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irobex_connect_response (handle)&n; *&n; *    Accept incomming connection&n; *&n; */
DECL|function|irobex_connect_response
r_void
id|irobex_connect_response
c_func
(paren
r_struct
id|irobex_cb
op_star
id|self
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* &t;__u8 *frame; */
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IROBEX_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|self-&gt;state
op_assign
id|OBEX_DATA
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
l_int|64
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;() Could not allocate sk_buff!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Reserve space for MUX_CONTROL and LAP header */
id|skb_reserve
c_func
(paren
id|skb
comma
id|TTP_HEADER
op_plus
id|LMP_CONTROL_HEADER
op_plus
id|LAP_HEADER
)paren
suffix:semicolon
id|irttp_connect_response
c_func
(paren
id|self-&gt;tsap
comma
id|SAR_DISABLE
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irobex_connect_indication (handle, skb, priv)&n; *&n; *    Connection request from a remote device&n; *&n; */
DECL|function|irobex_connect_indication
r_void
id|irobex_connect_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|qos_info
op_star
id|qos
comma
r_int
id|max_sdu_size
comma
r_struct
id|sk_buff
op_star
id|userdata
)paren
(brace
r_struct
id|irmanager_event
id|mgr_event
suffix:semicolon
r_struct
id|irobex_cb
op_star
id|self
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irobex_cb
op_star
)paren
id|instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IROBEX_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|userdata
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|self-&gt;eof
op_assign
id|FALSE
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), skb_len = %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|userdata-&gt;len
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), IrLAP data size=%d&bslash;n&quot;
comma
id|qos-&gt;data_size.value
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|qos-&gt;data_size.value
op_ge
l_int|64
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|self-&gt;irlap_data_size
op_assign
id|qos-&gt;data_size.value
suffix:semicolon
multiline_comment|/* We just accept the connection */
id|irobex_connect_response
c_func
(paren
id|self
)paren
suffix:semicolon
macro_line|#if 1
id|mgr_event.event
op_assign
id|EVENT_IROBEX_START
suffix:semicolon
id|sprintf
c_func
(paren
id|mgr_event.devname
comma
l_string|&quot;%s&quot;
comma
id|self-&gt;devname
)paren
suffix:semicolon
id|irmanager_notify
c_func
(paren
op_amp
id|mgr_event
)paren
suffix:semicolon
macro_line|#endif
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;read_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|userdata
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|userdata
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irobex_data_indication (instance, sap, skb)&n; *&n; *    This function gets the data that is received on the data channel&n; *&n; */
DECL|function|irobex_data_indication
r_void
id|irobex_data_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|irobex_cb
op_star
id|self
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irobex_cb
op_star
)paren
id|instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IROBEX_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), len=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|skb-&gt;len
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|self-&gt;rx_queue
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Check if queues are beginning to get filled, and inform &n;&t; *  IrTTP to slow down if that is the case&n;&t; */
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;rx_queue
)paren
OG
id|HIGH_THRESHOLD
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), rx_queue is full, telling IrTTP to slow down&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;rx_flow
op_assign
id|FLOW_STOP
suffix:semicolon
id|irttp_flow_request
c_func
(paren
id|self-&gt;tsap
comma
id|FLOW_STOP
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Wake up process blocked on read or select&n;&t; */
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;read_wait
)paren
suffix:semicolon
multiline_comment|/* Send signal to asynchronous readers */
r_if
c_cond
(paren
id|self-&gt;async
)paren
id|kill_fasync
c_func
(paren
id|self-&gt;async
comma
id|SIGIO
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irobex_flow_indication (instance, sap, cmd)&n; *&n; *    &n; *&n; */
DECL|function|irobex_flow_indication
r_void
id|irobex_flow_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
id|LOCAL_FLOW
id|flow
)paren
(brace
r_struct
id|irobex_cb
op_star
id|self
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irobex_cb
op_star
)paren
id|instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IROBEX_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|flow
)paren
(brace
r_case
id|FLOW_STOP
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), IrTTP wants us to slow down&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;tx_flow
op_assign
id|flow
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLOW_START
suffix:colon
id|self-&gt;tx_flow
op_assign
id|flow
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), IrTTP wants us to start again&bslash;n&quot;
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;write_wait
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unknown flow command!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irobex_get_value_confirm (obj_id, value)&n; *&n; *    Got results from previous GetValueByClass request&n; *&n; */
DECL|function|irobex_get_value_confirm
r_void
id|irobex_get_value_confirm
c_func
(paren
id|__u16
id|obj_id
comma
r_struct
id|ias_value
op_star
id|value
comma
r_void
op_star
id|priv
)paren
(brace
r_struct
id|irobex_cb
op_star
id|self
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|priv
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irobex_cb
op_star
)paren
id|priv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self
op_logical_or
id|self-&gt;magic
op_ne
id|IROBEX_MAGIC
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irobex_get_value_confirm: bad magic!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|value-&gt;type
)paren
(brace
r_case
id|IAS_INTEGER
suffix:colon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;() int=%d&bslash;n&quot;
comma
id|value-&gt;t.integer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value-&gt;t.integer
op_ne
op_minus
l_int|1
)paren
(brace
id|self-&gt;dtsap_sel
op_assign
id|value-&gt;t.integer
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Got the remote TSAP, so wake up any processes&n;&t;&t;&t; *  blocking on write. We don&squot;t do the connect &n;&t;&t;&t; *  ourselves since we must make sure there is a &n;&t;&t;&t; *  process that wants to make a connection, so we&n;&t;&t;&t; *  just let that process do the connect itself&n;&t;&t;&t; */
r_if
c_cond
(paren
id|self-&gt;state
op_eq
id|OBEX_QUERY
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;write_wait
)paren
suffix:semicolon
)brace
r_else
id|self-&gt;dtsap_sel
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IAS_STRING
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), got string %s&bslash;n&quot;
comma
id|value-&gt;t.string
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IAS_OCT_SEQ
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), OCT_SEQ not implemented&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IAS_MISSING
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), MISSING not implemented&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), unknown type!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irobex_provider_confirm (dlsap)&n; *&n; *    IrOBEX provider is discovered. We can now establish connections&n; *    TODO: This function is currently not used!&n; */
DECL|function|irobex_provider_confirm
r_void
id|irobex_provider_confirm
c_func
(paren
r_struct
id|irobex_cb
op_star
id|self
comma
id|__u8
id|dlsap
)paren
(brace
multiline_comment|/* struct irobex_cb *self = irobex; */
r_struct
id|notify_t
id|notify
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IROBEX_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|notify.data_indication
op_assign
id|irobex_data_indication
suffix:semicolon
id|notify.connect_confirm
op_assign
id|irobex_connect_confirm
suffix:semicolon
id|notify.connect_indication
op_assign
id|irobex_connect_indication
suffix:semicolon
id|notify.flow_indication
op_assign
id|irobex_flow_indication
suffix:semicolon
id|notify.disconnect_indication
op_assign
id|irobex_disconnect_indication
suffix:semicolon
id|notify.instance
op_assign
id|self
suffix:semicolon
multiline_comment|/* Create TSAP&squot;s */
id|self-&gt;tsap
op_assign
id|irttp_open_tsap
c_func
(paren
id|LSAP_ANY
comma
id|DEFAULT_INITIAL_CREDIT
comma
op_amp
id|notify
)paren
suffix:semicolon
multiline_comment|/* &t;DEBUG( 0, &quot;OBEX allocated TSAP%d for data&bslash;n&quot;, self-&gt;handle); */
multiline_comment|/* irlan_do_event( IAS_PROVIDER_AVAIL, NULL, &amp;frame); */
)brace
multiline_comment|/*&n; * Function irobex_register_server(void)&n; *&n; *    Register server support so we can accept incomming connections. We&n; *    must register both a TSAP for control and data&n; * &n; */
DECL|function|irobex_register_server
r_void
id|irobex_register_server
c_func
(paren
r_struct
id|irobex_cb
op_star
id|self
)paren
(brace
r_struct
id|notify_t
id|notify
suffix:semicolon
r_struct
id|ias_object
op_star
id|obj
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IROBEX_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|irda_notify_init
c_func
(paren
op_amp
id|notify
)paren
suffix:semicolon
id|notify.connect_confirm
op_assign
id|irobex_connect_confirm
suffix:semicolon
id|notify.connect_indication
op_assign
id|irobex_connect_indication
suffix:semicolon
id|notify.disconnect_indication
op_assign
id|irobex_disconnect_indication
suffix:semicolon
id|notify.data_indication
op_assign
id|irobex_data_indication
suffix:semicolon
id|notify.flow_indication
op_assign
id|irobex_flow_indication
suffix:semicolon
id|notify.instance
op_assign
id|self
suffix:semicolon
id|strcpy
c_func
(paren
id|notify.name
comma
l_string|&quot;IrOBEX&quot;
)paren
suffix:semicolon
id|self-&gt;tsap
op_assign
id|irttp_open_tsap
c_func
(paren
id|TSAP_IROBEX
comma
id|DEFAULT_INITIAL_CREDIT
comma
op_amp
id|notify
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;tsap
op_eq
l_int|NULL
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unable to allocate TSAP!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* &n;&t; *  Register with LM-IAS&n;&t; */
id|obj
op_assign
id|irias_new_object
c_func
(paren
l_string|&quot;OBEX&quot;
comma
l_int|0x42343
)paren
suffix:semicolon
id|irias_add_integer_attrib
c_func
(paren
id|obj
comma
l_string|&quot;IrDA:TinyTP:LsapSel&quot;
comma
id|TSAP_IROBEX
)paren
suffix:semicolon
id|irias_insert_object
c_func
(paren
id|obj
)paren
suffix:semicolon
)brace
DECL|function|irobex_watchdog_timer_expired
r_void
id|irobex_watchdog_timer_expired
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|irobex_cb
op_star
id|self
op_assign
(paren
r_struct
id|irobex_cb
op_star
)paren
id|data
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IROBEX_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|self-&gt;state
)paren
(brace
r_case
id|OBEX_CONN
suffix:colon
multiline_comment|/* FALLTROUGH */
r_case
id|OBEX_DISCOVER
suffix:colon
multiline_comment|/* FALLTROUGH */
r_case
id|OBEX_QUERY
suffix:colon
multiline_comment|/* FALLTROUGH */
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;write_wait
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/*&n; * Function irobex_proc_read (buf, start, offset, len, unused)&n; *&n; *    Give some info to the /proc file system&n; */
DECL|function|irobex_proc_read
r_static
r_int
id|irobex_proc_read
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|len
comma
r_int
id|unused
)paren
(brace
r_struct
id|irobex_cb
op_star
id|self
suffix:semicolon
id|self
op_assign
id|irobex
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IROBEX_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;ifname: %s &quot;
comma
id|self-&gt;devname
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;state: %s &quot;
comma
id|irobex_state
(braket
id|self-&gt;state
)braket
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;EOF: %s&bslash;n&quot;
comma
id|self-&gt;eof
ques
c_cond
l_string|&quot;TRUE&quot;
suffix:colon
l_string|&quot;FALSE&quot;
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PROC_FS */
macro_line|#ifdef MODULE
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Dag Brattli &lt;dagb@cs.uit.no&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;The Linux IrOBEX module&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Function init_module (void)&n; *&n; *    Initialize the IrOBEX module, this function is called by the&n; *    modprobe(1) program.&n; */
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
id|irobex_init
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function cleanup_module (void)&n; *&n; *    Remove the IrOBEX module, this function is called by the rmmod(1)&n; *    program&n; */
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* &n;&t; *  No need to check MOD_IN_USE, as sys_delete_module() checks. &n;&t; */
multiline_comment|/* Free some memory */
id|irobex_cleanup
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
