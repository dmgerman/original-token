multiline_comment|/*********************************************************************&n; *                &n; * Filename:      irttp.c&n; * Version:       1.2&n; * Description:   Tiny Transport Protocol (TTP) implementation&n; * Status:        Stable&n; * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Created at:    Sun Aug 31 20:14:31 1997&n; * Modified at:   Wed Jan  5 11:31:27 2000&n; * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * &n; *     Copyright (c) 1998-2000 Dag Brattli &lt;dagb@cs.uit.no&gt;, &n; *     All Rights Reserved.&n; *     &n; *     This program is free software; you can redistribute it and/or &n; *     modify it under the terms of the GNU General Public License as &n; *     published by the Free Software Foundation; either version 2 of &n; *     the License, or (at your option) any later version.&n; *&n; *     Neither Dag Brattli nor University of Troms&#xfffd; admit liability nor&n; *     provide warranty for any of this software. This material is &n; *     provided &quot;AS-IS&quot; and at no charge.&n; *&n; ********************************************************************/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/irmod.h&gt;
macro_line|#include &lt;net/irda/irlap.h&gt;
macro_line|#include &lt;net/irda/irlmp.h&gt;
macro_line|#include &lt;net/irda/parameters.h&gt;
macro_line|#include &lt;net/irda/irttp.h&gt;
DECL|variable|irttp
r_static
r_struct
id|irttp_cb
op_star
id|irttp
op_assign
l_int|NULL
suffix:semicolon
r_static
r_void
id|__irttp_close_tsap
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
)paren
suffix:semicolon
r_static
r_int
id|irttp_data_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_int
id|irttp_udata_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_void
id|irttp_disconnect_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
id|LM_REASON
id|reason
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_static
r_void
id|irttp_connect_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|qos_info
op_star
id|qos
comma
id|__u32
id|max_sdu_size
comma
id|__u8
id|header_size
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_void
id|irttp_connect_confirm
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|qos_info
op_star
id|qos
comma
id|__u32
id|max_sdu_size
comma
id|__u8
id|header_size
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_void
id|irttp_run_tx_queue
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
)paren
suffix:semicolon
r_static
r_void
id|irttp_run_rx_queue
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
)paren
suffix:semicolon
r_static
r_void
id|irttp_flush_queues
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
)paren
suffix:semicolon
r_static
r_void
id|irttp_fragment_skb
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_void
id|irttp_start_todo_timer
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
comma
r_int
id|timeout
)paren
suffix:semicolon
r_static
r_struct
id|sk_buff
op_star
id|irttp_reassemble_skb
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
)paren
suffix:semicolon
r_static
r_int
id|irttp_param_max_sdu_size
c_func
(paren
r_void
op_star
id|instance
comma
id|irda_param_t
op_star
id|param
comma
r_int
id|get
)paren
suffix:semicolon
multiline_comment|/* Information for parsing parameters in IrTTP */
DECL|variable|pi_minor_call_table
r_static
id|pi_minor_info_t
id|pi_minor_call_table
(braket
)braket
op_assign
(brace
(brace
l_int|NULL
comma
l_int|0
)brace
comma
multiline_comment|/* 0x00 */
(brace
id|irttp_param_max_sdu_size
comma
id|PV_INTEGER
op_or
id|PV_BIG_ENDIAN
)brace
multiline_comment|/* 0x01 */
)brace
suffix:semicolon
DECL|variable|pi_major_call_table
r_static
id|pi_major_info_t
id|pi_major_call_table
(braket
)braket
op_assign
(brace
(brace
id|pi_minor_call_table
comma
l_int|2
)brace
)brace
suffix:semicolon
DECL|variable|param_info
r_static
id|pi_param_info_t
id|param_info
op_assign
(brace
id|pi_major_call_table
comma
l_int|1
comma
l_int|0x0f
comma
l_int|4
)brace
suffix:semicolon
multiline_comment|/*&n; * Function irttp_init (void)&n; *&n; *    Initialize the IrTTP layer. Called by module initialization code&n; *&n; */
DECL|function|irttp_init
r_int
id|__init
id|irttp_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Initialize the irttp structure. */
r_if
c_cond
(paren
id|irttp
op_eq
l_int|NULL
)paren
(brace
id|irttp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irttp_cb
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irttp
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|irttp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|irttp_cb
)paren
)paren
suffix:semicolon
id|irttp-&gt;magic
op_assign
id|TTP_MAGIC
suffix:semicolon
id|irttp-&gt;tsaps
op_assign
id|hashbin_new
c_func
(paren
id|HB_LOCAL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|irttp-&gt;tsaps
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), can&squot;t allocate IrTTP hashbin!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_cleanup (void)&n; *&n; *    Called by module destruction/cleanup code&n; *&n; */
macro_line|#ifdef MODULE
DECL|function|irttp_cleanup
r_void
id|irttp_cleanup
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Check for main structure */
id|ASSERT
c_func
(paren
id|irttp
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|irttp-&gt;magic
op_eq
id|TTP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Delete hashbin and close all TSAP instances in it&n;&t; */
id|hashbin_delete
c_func
(paren
id|irttp-&gt;tsaps
comma
(paren
id|FREE_FUNC
)paren
id|__irttp_close_tsap
)paren
suffix:semicolon
id|irttp-&gt;magic
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* De-allocate main structure */
id|kfree
c_func
(paren
id|irttp
)paren
suffix:semicolon
id|irttp
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Function irttp_open_tsap (stsap, notify)&n; *&n; *    Create TSAP connection endpoint,&n; */
DECL|function|irttp_open_tsap
r_struct
id|tsap_cb
op_star
id|irttp_open_tsap
c_func
(paren
id|__u8
id|stsap_sel
comma
r_int
id|credit
comma
id|notify_t
op_star
id|notify
)paren
(brace
r_struct
id|tsap_cb
op_star
id|self
suffix:semicolon
r_struct
id|lsap_cb
op_star
id|lsap
suffix:semicolon
id|notify_t
id|ttp_notify
suffix:semicolon
id|ASSERT
c_func
(paren
id|irttp
op_ne
l_int|NULL
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|irttp-&gt;magic
op_eq
id|TTP_MAGIC
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
id|self
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|tsap_cb
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self
op_eq
l_int|NULL
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), unable to kmalloc!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|self
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tsap_cb
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|self-&gt;lock
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|self-&gt;todo_timer
)paren
suffix:semicolon
multiline_comment|/* Initialize callbacks for IrLMP to use */
id|irda_notify_init
c_func
(paren
op_amp
id|ttp_notify
)paren
suffix:semicolon
id|ttp_notify.connect_confirm
op_assign
id|irttp_connect_confirm
suffix:semicolon
id|ttp_notify.connect_indication
op_assign
id|irttp_connect_indication
suffix:semicolon
id|ttp_notify.disconnect_indication
op_assign
id|irttp_disconnect_indication
suffix:semicolon
id|ttp_notify.data_indication
op_assign
id|irttp_data_indication
suffix:semicolon
id|ttp_notify.udata_indication
op_assign
id|irttp_udata_indication
suffix:semicolon
r_if
c_cond
(paren
id|notify-&gt;status_indication
op_ne
l_int|NULL
)paren
(brace
id|ttp_notify.status_indication
op_assign
id|irttp_status_indication
suffix:semicolon
)brace
id|ttp_notify.instance
op_assign
id|self
suffix:semicolon
id|strncpy
c_func
(paren
id|ttp_notify.name
comma
id|notify-&gt;name
comma
id|NOTIFY_MAX_NAME
)paren
suffix:semicolon
id|self-&gt;magic
op_assign
id|TTP_TSAP_MAGIC
suffix:semicolon
id|self-&gt;connected
op_assign
id|FALSE
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|self-&gt;rx_queue
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|self-&gt;tx_queue
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|self-&gt;rx_fragments
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Create LSAP at IrLMP layer&n;&t; */
id|lsap
op_assign
id|irlmp_open_lsap
c_func
(paren
id|stsap_sel
comma
op_amp
id|ttp_notify
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lsap
op_eq
l_int|NULL
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), unable to allocate LSAP!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  If user specified LSAP_ANY as source TSAP selector, then IrLMP&n;&t; *  will replace it with whatever source selector which is free, so&n;&t; *  the stsap_sel we have might not be valid anymore&n;&t; */
id|self-&gt;stsap_sel
op_assign
id|lsap-&gt;slsap_sel
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), stsap_sel=%02x&bslash;n&quot;
comma
id|self-&gt;stsap_sel
)paren
suffix:semicolon
id|self-&gt;notify
op_assign
op_star
id|notify
suffix:semicolon
id|self-&gt;lsap
op_assign
id|lsap
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|irttp-&gt;tsaps
comma
(paren
id|irda_queue_t
op_star
)paren
id|self
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|credit
OG
id|TTP_MAX_QUEUE
)paren
id|self-&gt;initial_credit
op_assign
id|TTP_MAX_QUEUE
suffix:semicolon
r_else
id|self-&gt;initial_credit
op_assign
id|credit
suffix:semicolon
r_return
id|self
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_close (handle)&n; *&n; *    Remove an instance of a TSAP. This function should only deal with the&n; *    deallocation of the TSAP, and resetting of the TSAPs values;&n; *&n; */
DECL|function|__irttp_close_tsap
r_static
r_void
id|__irttp_close_tsap
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
)paren
(brace
multiline_comment|/* First make sure we&squot;re connected. */
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|irttp_flush_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;todo_timer
)paren
suffix:semicolon
id|self-&gt;connected
op_assign
id|FALSE
suffix:semicolon
id|self-&gt;magic
op_assign
op_complement
id|TTP_TSAP_MAGIC
suffix:semicolon
id|kfree
c_func
(paren
id|self
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_close (self)&n; *&n; *    Remove TSAP from list of all TSAPs and then deallocate all resources&n; *    associated with this TSAP&n; *&n; */
DECL|function|irttp_close_tsap
r_int
id|irttp_close_tsap
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
)paren
(brace
r_struct
id|tsap_cb
op_star
id|tsap
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Make sure tsap has been disconnected */
r_if
c_cond
(paren
id|self-&gt;connected
)paren
(brace
multiline_comment|/* Check if disconnect is not pending */
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;disconnect_pend
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), TSAP still connected!&bslash;n&quot;
)paren
suffix:semicolon
id|irttp_disconnect_request
c_func
(paren
id|self
comma
l_int|NULL
comma
id|P_NORMAL
)paren
suffix:semicolon
)brace
id|self-&gt;close_pend
op_assign
id|TRUE
suffix:semicolon
id|irttp_start_todo_timer
c_func
(paren
id|self
comma
l_int|1
op_star
id|HZ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Will be back! */
)brace
id|tsap
op_assign
id|hashbin_remove
c_func
(paren
id|irttp-&gt;tsaps
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|tsap
op_eq
id|self
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Close corresponding LSAP */
r_if
c_cond
(paren
id|self-&gt;lsap
)paren
(brace
id|irlmp_close_lsap
c_func
(paren
id|self-&gt;lsap
)paren
suffix:semicolon
id|self-&gt;lsap
op_assign
l_int|NULL
suffix:semicolon
)brace
id|__irttp_close_tsap
c_func
(paren
id|self
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_udata_request (self, skb)&n; *&n; *    Send unreliable data on this TSAP&n; *&n; */
DECL|function|irttp_udata_request
r_int
id|irttp_udata_request
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Check that nothing bad happens */
r_if
c_cond
(paren
(paren
id|skb-&gt;len
op_eq
l_int|0
)paren
op_logical_or
(paren
op_logical_neg
id|self-&gt;connected
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), No data, or not connected&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|self-&gt;max_seg_size
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), UData is to large for IrLAP!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|irlmp_udata_request
c_func
(paren
id|self-&gt;lsap
comma
id|skb
)paren
suffix:semicolon
id|self-&gt;stats.tx_packets
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_data_request (handle, skb)&n; *&n; *    Queue frame for transmission. If SAR is enabled, fragement the frame &n; *    and queue the fragments for transmission&n; */
DECL|function|irttp_data_request
r_int
id|irttp_data_request
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|__u8
op_star
id|frame
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Check that nothing bad happens */
r_if
c_cond
(paren
(paren
id|skb-&gt;len
op_eq
l_int|0
)paren
op_logical_or
(paren
op_logical_neg
id|self-&gt;connected
)paren
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), No data, or not connected&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOTCONN
suffix:semicolon
)brace
multiline_comment|/*  &n;&t; *  Check if SAR is disabled, and the frame is larger than what fits&n;&t; *  inside an IrLAP frame&n;&t; */
r_if
c_cond
(paren
(paren
id|self-&gt;tx_max_sdu_size
op_eq
l_int|0
)paren
op_logical_and
(paren
id|skb-&gt;len
OG
id|self-&gt;max_seg_size
)paren
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), SAR disabled, and data is to large for IrLAP!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
)brace
multiline_comment|/* &n;&t; *  Check if SAR is enabled, and the frame is larger than the &n;&t; *  TxMaxSduSize &n;&t; */
r_if
c_cond
(paren
(paren
id|self-&gt;tx_max_sdu_size
op_ne
l_int|0
)paren
op_logical_and
(paren
id|self-&gt;tx_max_sdu_size
op_ne
id|TTP_SAR_UNBOUND
)paren
op_logical_and
(paren
id|skb-&gt;len
OG
id|self-&gt;tx_max_sdu_size
)paren
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), SAR enabled, &quot;
l_string|&quot;but data is larger than TxMaxSduSize!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
)brace
multiline_comment|/* &n;&t; *  Check if transmit queue is full&n;&t; */
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;tx_queue
)paren
op_ge
id|TTP_MAX_QUEUE
)paren
(brace
multiline_comment|/*&n;&t;&t; *  Give it a chance to empty itself&n;&t;&t; */
id|irttp_run_tx_queue
c_func
(paren
id|self
)paren
suffix:semicolon
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
multiline_comment|/* Queue frame, or queue frame segments */
r_if
c_cond
(paren
(paren
id|self-&gt;tx_max_sdu_size
op_eq
l_int|0
)paren
op_logical_or
(paren
id|skb-&gt;len
OL
id|self-&gt;max_seg_size
)paren
)paren
(brace
multiline_comment|/* Queue frame */
id|ASSERT
c_func
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
op_ge
id|TTP_HEADER
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|frame
op_assign
id|skb_push
c_func
(paren
id|skb
comma
id|TTP_HEADER
)paren
suffix:semicolon
id|frame
(braket
l_int|0
)braket
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* Clear more bit */
id|skb_queue_tail
c_func
(paren
op_amp
id|self-&gt;tx_queue
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; *  Fragment the frame, this function will also queue the&n;&t;&t; *  fragments, we don&squot;t care about the fact the the transmit&n;&t;&t; *  queue may be overfilled by all the segments for a little&n;&t;&t; *  while&n;&t;&t; */
id|irttp_fragment_skb
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if we can accept more data from client */
r_if
c_cond
(paren
(paren
op_logical_neg
id|self-&gt;tx_sdu_busy
)paren
op_logical_and
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;tx_queue
)paren
OG
id|TTP_HIGH_THRESHOLD
)paren
)paren
(brace
multiline_comment|/* Tx queue filling up, so stop client */
id|self-&gt;tx_sdu_busy
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;notify.flow_indication
)paren
(brace
id|self-&gt;notify
dot
id|flow_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
id|FLOW_STOP
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Try to make some progress */
id|irttp_run_tx_queue
c_func
(paren
id|self
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_run_tx_queue (self)&n; *&n; *    Transmit packets queued for transmission (if possible)&n; *&n; */
DECL|function|irttp_run_tx_queue
r_static
r_void
id|irttp_run_tx_queue
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|n
suffix:semicolon
r_if
c_cond
(paren
id|irda_lock
c_func
(paren
op_amp
id|self-&gt;tx_queue_lock
)paren
op_eq
id|FALSE
)paren
r_return
suffix:semicolon
multiline_comment|/* Try to send out frames as long as we have credits */
r_while
c_loop
(paren
(paren
id|self-&gt;send_credit
OG
l_int|0
)paren
op_logical_and
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;tx_queue
)paren
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t; * Make sure we don&squot;t flood IrLAP with frames just because&n;&t;&t; * the remote device has given us a lot of credits&n;&t;&t; */
r_if
c_cond
(paren
id|irlmp_get_lap_tx_queue_len
c_func
(paren
id|self-&gt;lsap
)paren
OG
id|LAP_MAX_QUEUE
)paren
(brace
multiline_comment|/* Re-queue packet */
id|skb_queue_head
c_func
(paren
op_amp
id|self-&gt;tx_queue
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* Try later. Would be better if IrLAP could notify us */
id|irttp_start_todo_timer
c_func
(paren
id|self
comma
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|10
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Since we can transmit and receive frames concurrently, &n;&t;&t; *  the code below is a critical region and we must assure that&n;&t;&t; *  nobody messes with the credits while we update them.&n;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|self-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|n
op_assign
id|self-&gt;avail_credit
suffix:semicolon
id|self-&gt;avail_credit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Only room for 127 credits in frame */
r_if
c_cond
(paren
id|n
OG
l_int|127
)paren
(brace
id|self-&gt;avail_credit
op_assign
id|n
op_minus
l_int|127
suffix:semicolon
id|n
op_assign
l_int|127
suffix:semicolon
)brace
id|self-&gt;remote_credit
op_add_assign
id|n
suffix:semicolon
id|self-&gt;send_credit
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|self-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; *  More bit must be set by the data_request() or fragment() &n;&t;&t; *  functions&n;&t;&t; */
id|skb-&gt;data
(braket
l_int|0
)braket
op_or_assign
(paren
id|n
op_amp
l_int|0x7f
)paren
suffix:semicolon
id|irlmp_data_request
c_func
(paren
id|self-&gt;lsap
comma
id|skb
)paren
suffix:semicolon
id|self-&gt;stats.tx_packets
op_increment
suffix:semicolon
multiline_comment|/* Check if we can accept more frames from client */
r_if
c_cond
(paren
(paren
id|self-&gt;tx_sdu_busy
)paren
op_logical_and
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;tx_queue
)paren
OL
id|TTP_LOW_THRESHOLD
)paren
)paren
(brace
id|self-&gt;tx_sdu_busy
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;notify.flow_indication
)paren
id|self-&gt;notify
dot
id|flow_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
id|FLOW_START
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Reset lock */
id|self-&gt;tx_queue_lock
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_give_credit (self)&n; *&n; *    Send a dataless flowdata TTP-PDU and give available credit to peer&n; *    TSAP&n; */
DECL|function|irttp_give_credit
r_void
id|irttp_give_credit
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
)paren
(brace
r_struct
id|sk_buff
op_star
id|tx_skb
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|n
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;() send=%d,avail=%d,remote=%d&bslash;n&quot;
comma
id|self-&gt;send_credit
comma
id|self-&gt;avail_credit
comma
id|self-&gt;remote_credit
)paren
suffix:semicolon
multiline_comment|/* Give credit to peer */
id|tx_skb
op_assign
id|dev_alloc_skb
c_func
(paren
l_int|64
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tx_skb
)paren
r_return
suffix:semicolon
multiline_comment|/* Reserve space for LMP, and LAP header */
id|skb_reserve
c_func
(paren
id|tx_skb
comma
id|self-&gt;max_header_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Since we can transmit and receive frames concurrently, &n;&t; *  the code below is a critical region and we must assure that&n;&t; *  nobody messes with the credits while we update them.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|self-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|n
op_assign
id|self-&gt;avail_credit
suffix:semicolon
id|self-&gt;avail_credit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Only space for 127 credits in frame */
r_if
c_cond
(paren
id|n
OG
l_int|127
)paren
(brace
id|self-&gt;avail_credit
op_assign
id|n
op_minus
l_int|127
suffix:semicolon
id|n
op_assign
l_int|127
suffix:semicolon
)brace
id|self-&gt;remote_credit
op_add_assign
id|n
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|self-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|skb_put
c_func
(paren
id|tx_skb
comma
l_int|1
)paren
suffix:semicolon
id|tx_skb-&gt;data
(braket
l_int|0
)braket
op_assign
(paren
id|__u8
)paren
(paren
id|n
op_amp
l_int|0x7f
)paren
suffix:semicolon
id|irlmp_data_request
c_func
(paren
id|self-&gt;lsap
comma
id|tx_skb
)paren
suffix:semicolon
id|self-&gt;stats.tx_packets
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_udata_indication (instance, sap, skb)&n; *&n; *    Received some unit-data (unreliable)&n; *&n; */
DECL|function|irttp_udata_indication
r_static
r_int
id|irttp_udata_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tsap_cb
op_star
id|self
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|tsap_cb
op_star
)paren
id|instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Just pass data to layer above */
r_if
c_cond
(paren
id|self-&gt;notify.udata_indication
)paren
id|self-&gt;notify
dot
id|udata_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
id|skb
)paren
suffix:semicolon
r_else
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|self-&gt;stats.rx_packets
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_data_indication (instance, sap, skb)&n; *&n; *    Receive segment from IrLMP. &n; *&n; */
DECL|function|irttp_data_indication
r_static
r_int
id|irttp_data_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tsap_cb
op_star
id|self
suffix:semicolon
r_int
id|n
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|tsap_cb
op_star
)paren
id|instance
suffix:semicolon
id|n
op_assign
id|skb-&gt;data
(braket
l_int|0
)braket
op_amp
l_int|0x7f
suffix:semicolon
multiline_comment|/* Extract the credits */
id|self-&gt;stats.rx_packets
op_increment
suffix:semicolon
multiline_comment|/* &n;&t; *  Data or dataless packet? Dataless frames contains only the &n;&t; *  TTP_HEADER. &n;&t; */
r_if
c_cond
(paren
id|skb-&gt;len
OG
l_int|1
)paren
(brace
multiline_comment|/* Deal with inbound credit */
id|self-&gt;send_credit
op_add_assign
id|n
suffix:semicolon
id|self-&gt;remote_credit
op_decrement
suffix:semicolon
multiline_comment|/* &n;&t;&t; *  We don&squot;t remove the TTP header, since we must preserve the&n;&t;&t; *  more bit, so the defragment routing knows what to do&n;&t;&t; */
id|skb_queue_tail
c_func
(paren
op_amp
id|self-&gt;rx_queue
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|self-&gt;send_credit
op_add_assign
id|n
suffix:semicolon
multiline_comment|/* Dataless flowdata TTP-PDU */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|irttp_run_rx_queue
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* &n;&t; *  Give avay some credits to peer? &n;&t; */
r_if
c_cond
(paren
(paren
id|skb_queue_empty
c_func
(paren
op_amp
id|self-&gt;tx_queue
)paren
)paren
op_logical_and
(paren
id|self-&gt;remote_credit
OL
id|TTP_LOW_THRESHOLD
)paren
op_logical_and
(paren
id|self-&gt;avail_credit
OG
l_int|0
)paren
)paren
(brace
multiline_comment|/* Schedule to start immediately after this thread */
id|irttp_start_todo_timer
c_func
(paren
id|self
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*irttp_give_credit(self);*/
)brace
multiline_comment|/* &n;&t; * If the peer device has given us some credits and we didn&squot;t have&n;         * anyone from before, the we need to shedule the tx queue?  &n;&t; */
r_if
c_cond
(paren
id|self-&gt;send_credit
op_eq
id|n
)paren
(brace
multiline_comment|/*irttp_run_tx_queue(self);*/
id|irttp_start_todo_timer
c_func
(paren
id|self
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_status_indication (self, reason)&n; *&n; *    Status_indication, just pass to the higher layer...&n; *&n; */
DECL|function|irttp_status_indication
r_void
id|irttp_status_indication
c_func
(paren
r_void
op_star
id|instance
comma
id|LINK_STATUS
id|link
comma
id|LOCK_STATUS
id|lock
)paren
(brace
r_struct
id|tsap_cb
op_star
id|self
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|tsap_cb
op_star
)paren
id|instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Inform service user if he has requested it&n;&t; */
r_if
c_cond
(paren
id|self-&gt;notify.status_indication
op_ne
l_int|NULL
)paren
id|self-&gt;notify
dot
id|status_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|link
comma
id|lock
)paren
suffix:semicolon
r_else
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), no handler&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_flow_request (self, command)&n; *&n; *    This funtion could be used by the upper layers to tell IrTTP to stop&n; *    delivering frames if the receive queues are starting to get full, or &n; *    to tell IrTTP to start delivering frames again.&n; */
DECL|function|irttp_flow_request
r_void
id|irttp_flow_request
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
comma
id|LOCAL_FLOW
id|flow
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|flow
)paren
(brace
r_case
id|FLOW_STOP
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), flow stop&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;rx_sdu_busy
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLOW_START
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), flow start&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;rx_sdu_busy
op_assign
id|FALSE
suffix:semicolon
id|irttp_run_rx_queue
c_func
(paren
id|self
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unknown flow command!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irttp_connect_request (self, dtsap_sel, daddr, qos)&n; *&n; *    Try to connect to remote destination TSAP selector&n; *&n; */
DECL|function|irttp_connect_request
r_int
id|irttp_connect_request
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
comma
id|__u8
id|dtsap_sel
comma
id|__u32
id|saddr
comma
id|__u32
id|daddr
comma
r_struct
id|qos_info
op_star
id|qos
comma
id|__u32
id|max_sdu_size
comma
r_struct
id|sk_buff
op_star
id|userdata
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|__u8
op_star
id|frame
suffix:semicolon
id|__u8
id|n
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), max_sdu_size=%d&bslash;n&quot;
comma
id|max_sdu_size
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
id|EBADR
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
op_minus
id|EBADR
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;connected
)paren
r_return
op_minus
id|EISCONN
suffix:semicolon
multiline_comment|/* Any userdata supplied? */
r_if
c_cond
(paren
id|userdata
op_eq
l_int|NULL
)paren
(brace
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
l_int|64
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Reserve space for MUX_CONTROL and LAP header */
id|skb_reserve
c_func
(paren
id|skb
comma
id|TTP_MAX_HEADER
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb
op_assign
id|userdata
suffix:semicolon
multiline_comment|/*  &n;&t;&t; *  Check that the client has reserved enough space for &n;&t;&t; *  headers&n;&t;&t; */
id|ASSERT
c_func
(paren
id|skb_headroom
c_func
(paren
id|userdata
)paren
op_ge
id|TTP_MAX_HEADER
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize connection parameters */
id|self-&gt;connected
op_assign
id|FALSE
suffix:semicolon
id|self-&gt;avail_credit
op_assign
l_int|0
suffix:semicolon
id|self-&gt;rx_max_sdu_size
op_assign
id|max_sdu_size
suffix:semicolon
id|self-&gt;rx_sdu_size
op_assign
l_int|0
suffix:semicolon
id|self-&gt;rx_sdu_busy
op_assign
id|FALSE
suffix:semicolon
id|self-&gt;dtsap_sel
op_assign
id|dtsap_sel
suffix:semicolon
id|n
op_assign
id|self-&gt;initial_credit
suffix:semicolon
id|self-&gt;remote_credit
op_assign
l_int|0
suffix:semicolon
id|self-&gt;send_credit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Give away max 127 credits for now&n;&t; */
r_if
c_cond
(paren
id|n
OG
l_int|127
)paren
(brace
id|self-&gt;avail_credit
op_assign
id|n
op_minus
l_int|127
suffix:semicolon
id|n
op_assign
l_int|127
suffix:semicolon
)brace
id|self-&gt;remote_credit
op_assign
id|n
suffix:semicolon
multiline_comment|/* SAR enabled? */
r_if
c_cond
(paren
id|max_sdu_size
OG
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
op_ge
(paren
id|TTP_MAX_HEADER
op_plus
id|TTP_SAR_HEADER
)paren
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Insert SAR parameters */
id|frame
op_assign
id|skb_push
c_func
(paren
id|skb
comma
id|TTP_HEADER
op_plus
id|TTP_SAR_HEADER
)paren
suffix:semicolon
id|frame
(braket
l_int|0
)braket
op_assign
id|TTP_PARAMETERS
op_or
id|n
suffix:semicolon
id|frame
(braket
l_int|1
)braket
op_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* Length */
id|frame
(braket
l_int|2
)braket
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* MaxSduSize */
id|frame
(braket
l_int|3
)braket
op_assign
l_int|0x02
suffix:semicolon
multiline_comment|/* Value length */
id|put_unaligned
c_func
(paren
id|cpu_to_be16
c_func
(paren
(paren
id|__u16
)paren
id|max_sdu_size
)paren
comma
(paren
id|__u16
op_star
)paren
(paren
id|frame
op_plus
l_int|4
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Insert plain TTP header */
id|frame
op_assign
id|skb_push
c_func
(paren
id|skb
comma
id|TTP_HEADER
)paren
suffix:semicolon
multiline_comment|/* Insert initial credit in frame */
id|frame
(braket
l_int|0
)braket
op_assign
id|n
op_amp
l_int|0x7f
suffix:semicolon
)brace
multiline_comment|/* Connect with IrLMP. No QoS parameters for now */
r_return
id|irlmp_connect_request
c_func
(paren
id|self-&gt;lsap
comma
id|dtsap_sel
comma
id|saddr
comma
id|daddr
comma
id|qos
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_connect_confirm (handle, qos, skb)&n; *&n; *    Sevice user confirms TSAP connection with peer. &n; *&n; */
DECL|function|irttp_connect_confirm
r_static
r_void
id|irttp_connect_confirm
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|qos_info
op_star
id|qos
comma
id|__u32
id|max_seg_size
comma
id|__u8
id|max_header_size
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tsap_cb
op_star
id|self
suffix:semicolon
r_int
id|parameters
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|__u8
id|plen
suffix:semicolon
id|__u8
id|n
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|tsap_cb
op_star
)paren
id|instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|self-&gt;max_seg_size
op_assign
id|max_seg_size
op_minus
id|TTP_HEADER
suffix:semicolon
id|self-&gt;max_header_size
op_assign
id|max_header_size
op_plus
id|TTP_HEADER
suffix:semicolon
multiline_comment|/*&n;&t; *  Check if we have got some QoS parameters back! This should be the&n;&t; *  negotiated QoS for the link.&n;&t; */
r_if
c_cond
(paren
id|qos
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;IrTTP, Negotiated BAUD_RATE: %02x&bslash;n&quot;
comma
id|qos-&gt;baud_rate.bits
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;IrTTP, Negotiated BAUD_RATE: %d bps.&bslash;n&quot;
comma
id|qos-&gt;baud_rate.value
)paren
suffix:semicolon
)brace
id|n
op_assign
id|skb-&gt;data
(braket
l_int|0
)braket
op_amp
l_int|0x7f
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), Initial send_credit=%d&bslash;n&quot;
comma
id|n
)paren
suffix:semicolon
id|self-&gt;send_credit
op_assign
id|n
suffix:semicolon
id|self-&gt;tx_max_sdu_size
op_assign
l_int|0
suffix:semicolon
id|self-&gt;connected
op_assign
id|TRUE
suffix:semicolon
id|parameters
op_assign
id|skb-&gt;data
(braket
l_int|0
)braket
op_amp
l_int|0x80
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb-&gt;len
op_ge
id|TTP_HEADER
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|TTP_HEADER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parameters
)paren
(brace
id|plen
op_assign
id|skb-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
id|ret
op_assign
id|irda_param_extract_all
c_func
(paren
id|self
comma
id|skb-&gt;data
op_plus
l_int|1
comma
id|IRDA_MIN
c_func
(paren
id|skb-&gt;len
op_minus
l_int|1
comma
id|plen
)paren
comma
op_amp
id|param_info
)paren
suffix:semicolon
multiline_comment|/* Any errors in the parameter list? */
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), error extracting parameters&bslash;n&quot;
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Do not accept this connection attempt */
r_return
suffix:semicolon
)brace
multiline_comment|/* Remove parameters */
id|skb_pull
c_func
(paren
id|skb
comma
id|IRDA_MIN
c_func
(paren
id|skb-&gt;len
comma
id|plen
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;() send=%d,avail=%d,remote=%d&bslash;n&quot;
comma
id|self-&gt;send_credit
comma
id|self-&gt;avail_credit
comma
id|self-&gt;remote_credit
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), MaxSduSize=%d&bslash;n&quot;
comma
id|self-&gt;tx_max_sdu_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;notify.connect_confirm
)paren
(brace
id|self-&gt;notify
dot
id|connect_confirm
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
id|qos
comma
id|self-&gt;tx_max_sdu_size
comma
id|self-&gt;max_header_size
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irttp_connect_indication (handle, skb)&n; *&n; *    Some other device is connecting to this TSAP&n; *&n; */
DECL|function|irttp_connect_indication
r_void
id|irttp_connect_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|qos_info
op_star
id|qos
comma
id|__u32
id|max_seg_size
comma
id|__u8
id|max_header_size
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tsap_cb
op_star
id|self
suffix:semicolon
r_struct
id|lsap_cb
op_star
id|lsap
suffix:semicolon
r_int
id|parameters
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|__u8
id|plen
suffix:semicolon
id|__u8
id|n
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|tsap_cb
op_star
)paren
id|instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|lsap
op_assign
(paren
r_struct
id|lsap_cb
op_star
)paren
id|sap
suffix:semicolon
id|self-&gt;max_seg_size
op_assign
id|max_seg_size
op_minus
id|TTP_HEADER
suffix:semicolon
suffix:semicolon
id|self-&gt;max_header_size
op_assign
id|max_header_size
op_plus
id|TTP_HEADER
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), TSAP sel=%02x&bslash;n&quot;
comma
id|self-&gt;stsap_sel
)paren
suffix:semicolon
multiline_comment|/* Need to update dtsap_sel if its equal to LSAP_ANY */
id|self-&gt;dtsap_sel
op_assign
id|lsap-&gt;dlsap_sel
suffix:semicolon
id|n
op_assign
id|skb-&gt;data
(braket
l_int|0
)braket
op_amp
l_int|0x7f
suffix:semicolon
id|self-&gt;send_credit
op_assign
id|n
suffix:semicolon
id|self-&gt;tx_max_sdu_size
op_assign
l_int|0
suffix:semicolon
id|parameters
op_assign
id|skb-&gt;data
(braket
l_int|0
)braket
op_amp
l_int|0x80
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb-&gt;len
op_ge
id|TTP_HEADER
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|TTP_HEADER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parameters
)paren
(brace
id|plen
op_assign
id|skb-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
id|ret
op_assign
id|irda_param_extract_all
c_func
(paren
id|self
comma
id|skb-&gt;data
op_plus
l_int|1
comma
id|IRDA_MIN
c_func
(paren
id|skb-&gt;len
op_minus
l_int|1
comma
id|plen
)paren
comma
op_amp
id|param_info
)paren
suffix:semicolon
multiline_comment|/* Any errors in the parameter list? */
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), error extracting parameters&bslash;n&quot;
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Do not accept this connection attempt */
r_return
suffix:semicolon
)brace
multiline_comment|/* Remove parameters */
id|skb_pull
c_func
(paren
id|skb
comma
id|IRDA_MIN
c_func
(paren
id|skb-&gt;len
comma
id|plen
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|self-&gt;notify.connect_indication
)paren
(brace
id|self-&gt;notify
dot
id|connect_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
id|qos
comma
id|self-&gt;tx_max_sdu_size
comma
id|self-&gt;max_header_size
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_connect_response (handle, userdata)&n; *&n; *    Service user is accepting the connection, just pass it down to&n; *    IrLMP!&n; * &n; */
DECL|function|irttp_connect_response
r_int
id|irttp_connect_response
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
comma
id|__u32
id|max_sdu_size
comma
r_struct
id|sk_buff
op_star
id|userdata
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|__u8
op_star
id|frame
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|__u8
id|n
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), Source TSAP selector=%02x&bslash;n&quot;
comma
id|self-&gt;stsap_sel
)paren
suffix:semicolon
multiline_comment|/* Any userdata supplied? */
r_if
c_cond
(paren
id|userdata
op_eq
l_int|NULL
)paren
(brace
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
l_int|64
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Reserve space for MUX_CONTROL and LAP header */
id|skb_reserve
c_func
(paren
id|skb
comma
id|TTP_MAX_HEADER
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb
op_assign
id|userdata
suffix:semicolon
multiline_comment|/*  &n;&t;&t; *  Check that the client has reserved enough space for &n;&t;&t; *  headers&n;&t;&t; */
id|ASSERT
c_func
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
op_ge
id|TTP_MAX_HEADER
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
)brace
id|self-&gt;avail_credit
op_assign
l_int|0
suffix:semicolon
id|self-&gt;remote_credit
op_assign
l_int|0
suffix:semicolon
id|self-&gt;rx_max_sdu_size
op_assign
id|max_sdu_size
suffix:semicolon
id|self-&gt;rx_sdu_size
op_assign
l_int|0
suffix:semicolon
id|self-&gt;rx_sdu_busy
op_assign
id|FALSE
suffix:semicolon
id|n
op_assign
id|self-&gt;initial_credit
suffix:semicolon
multiline_comment|/* Frame has only space for max 127 credits (7 bits) */
r_if
c_cond
(paren
id|n
OG
l_int|127
)paren
(brace
id|self-&gt;avail_credit
op_assign
id|n
op_minus
l_int|127
suffix:semicolon
id|n
op_assign
l_int|127
suffix:semicolon
)brace
id|self-&gt;remote_credit
op_assign
id|n
suffix:semicolon
id|self-&gt;connected
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* SAR enabled? */
r_if
c_cond
(paren
id|max_sdu_size
OG
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
op_ge
(paren
id|TTP_MAX_HEADER
op_plus
id|TTP_SAR_HEADER
)paren
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Insert TTP header with SAR parameters */
id|frame
op_assign
id|skb_push
c_func
(paren
id|skb
comma
id|TTP_HEADER
op_plus
id|TTP_SAR_HEADER
)paren
suffix:semicolon
id|frame
(braket
l_int|0
)braket
op_assign
id|TTP_PARAMETERS
op_or
id|n
suffix:semicolon
id|frame
(braket
l_int|1
)braket
op_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* Length */
multiline_comment|/* irda_param_insert(self, IRTTP_MAX_SDU_SIZE, frame+1,  */
multiline_comment|/* &t;&t;&t;&t;  TTP_SAR_HEADER, &amp;param_info) */
id|frame
(braket
l_int|2
)braket
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* MaxSduSize */
id|frame
(braket
l_int|3
)braket
op_assign
l_int|0x02
suffix:semicolon
multiline_comment|/* Value length */
id|put_unaligned
c_func
(paren
id|cpu_to_be16
c_func
(paren
(paren
id|__u16
)paren
id|max_sdu_size
)paren
comma
(paren
id|__u16
op_star
)paren
(paren
id|frame
op_plus
l_int|4
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Insert TTP header */
id|frame
op_assign
id|skb_push
c_func
(paren
id|skb
comma
id|TTP_HEADER
)paren
suffix:semicolon
id|frame
(braket
l_int|0
)braket
op_assign
id|n
op_amp
l_int|0x7f
suffix:semicolon
)brace
id|ret
op_assign
id|irlmp_connect_response
c_func
(paren
id|self-&gt;lsap
comma
id|skb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_dup (self, instance)&n; *&n; *    Duplicate TSAP, can be used by servers to confirm a connection on a&n; *    new TSAP so it can keep listening on the old one.&n; */
DECL|function|irttp_dup
r_struct
id|tsap_cb
op_star
id|irttp_dup
c_func
(paren
r_struct
id|tsap_cb
op_star
id|orig
comma
r_void
op_star
id|instance
)paren
(brace
r_struct
id|tsap_cb
op_star
r_new
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hashbin_find
c_func
(paren
id|irttp-&gt;tsaps
comma
(paren
r_int
)paren
id|orig
comma
l_int|NULL
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), unable to find TSAP&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_new
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|tsap_cb
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), unable to kmalloc&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Dup */
id|memcpy
c_func
(paren
r_new
comma
id|orig
comma
r_sizeof
(paren
r_struct
id|tsap_cb
)paren
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|notify.instance
op_assign
id|instance
suffix:semicolon
r_new
op_member_access_from_pointer
id|lsap
op_assign
id|irlmp_dup
c_func
(paren
id|orig-&gt;lsap
comma
r_new
)paren
suffix:semicolon
multiline_comment|/* Not everything should be copied */
id|init_timer
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|todo_timer
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|rx_queue
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|tx_queue
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|rx_fragments
)paren
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|irttp-&gt;tsaps
comma
(paren
id|irda_queue_t
op_star
)paren
r_new
comma
(paren
r_int
)paren
r_new
comma
l_int|NULL
)paren
suffix:semicolon
r_return
r_new
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_disconnect_request (self)&n; *&n; *    Close this connection please! If priority is high, the queued data &n; *    segments, if any, will be deallocated first&n; *&n; */
DECL|function|irttp_disconnect_request
r_int
id|irttp_disconnect_request
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|userdata
comma
r_int
id|priority
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Already disconnected? */
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;connected
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), already disconnected!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Disconnect already pending? */
r_if
c_cond
(paren
id|self-&gt;disconnect_pend
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), disconnect already pending&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|userdata
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|userdata
)paren
suffix:semicolon
)brace
multiline_comment|/* Try to make some progress */
id|irttp_run_rx_queue
c_func
(paren
id|self
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Check if there is still data segments in the transmit queue&n;&t; */
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;tx_queue
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|priority
op_eq
id|P_HIGH
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;High priority!!()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; *  No need to send the queued data, if we are &n;&t;&t;&t; *  disconnecting right now since the data will&n;&t;&t;&t; *  not have any usable connection to be sent on&n;&t;&t;&t; */
id|irttp_flush_queues
c_func
(paren
id|self
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|priority
op_eq
id|P_NORMAL
)paren
(brace
multiline_comment|/* &n;&t;&t;&t; *  Must delay disconnect til after all data segments&n;&t;&t;&t; *  have been sent an the tx_queue is empty&n;&t;&t;&t; */
r_if
c_cond
(paren
id|userdata
)paren
id|self-&gt;disconnect_skb
op_assign
id|userdata
suffix:semicolon
r_else
id|self-&gt;disconnect_skb
op_assign
l_int|NULL
suffix:semicolon
id|self-&gt;disconnect_pend
op_assign
id|TRUE
suffix:semicolon
id|irttp_run_tx_queue
c_func
(paren
id|self
)paren
suffix:semicolon
id|irttp_start_todo_timer
c_func
(paren
id|self
comma
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|1000
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Disconnecting ...&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;connected
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|userdata
)paren
(brace
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
l_int|64
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* &n;&t;&t; *  Reserve space for MUX and LAP header &n;&t;&t; */
id|skb_reserve
c_func
(paren
id|skb
comma
id|TTP_MAX_HEADER
)paren
suffix:semicolon
id|userdata
op_assign
id|skb
suffix:semicolon
)brace
id|ret
op_assign
id|irlmp_disconnect_request
c_func
(paren
id|self-&gt;lsap
comma
id|userdata
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_disconnect_indication (self, reason)&n; *&n; *    Disconnect indication, TSAP disconnected by peer?&n; *&n; */
DECL|function|irttp_disconnect_indication
r_void
id|irttp_disconnect_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
id|LM_REASON
id|reason
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tsap_cb
op_star
id|self
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|tsap_cb
op_star
)paren
id|instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|self-&gt;connected
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Check if client has already tried to close the TSAP */
r_if
c_cond
(paren
id|self-&gt;close_pend
)paren
(brace
id|irttp_close_tsap
c_func
(paren
id|self
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* No need to notify the client if has already tried to disconnect */
r_if
c_cond
(paren
id|self-&gt;disconnect_pend
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;notify.disconnect_indication
)paren
id|self-&gt;notify
dot
id|disconnect_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
id|reason
comma
id|skb
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|skb
)paren
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_do_data_indication (self, skb)&n; *&n; *    Try to deliver reassebled skb to layer above, and requeue it if that&n; *    for some reason should fail. We mark rx sdu as busy to apply back&n; *    pressure is necessary.&n; */
DECL|function|irttp_do_data_indication
r_void
id|irttp_do_data_indication
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|err
suffix:semicolon
multiline_comment|/* Check if client has already tried to close the TSAP */
r_if
c_cond
(paren
id|self-&gt;close_pend
op_logical_or
id|self-&gt;disconnect_pend
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|err
op_assign
id|self-&gt;notify
dot
id|data_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* Usually the layer above will notify that it&squot;s input queue is&n;&t; * starting to get filled by using the flow request, but this may&n;&t; * be difficult, so it can instead just refuse to eat it and just&n;&t; * give an error back &n;&t; */
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOMEM
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;() requeueing skb!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Make sure we take a break */
id|self-&gt;rx_sdu_busy
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Need to push the header in again */
id|skb_push
c_func
(paren
id|skb
comma
id|TTP_HEADER
)paren
suffix:semicolon
id|skb-&gt;data
(braket
l_int|0
)braket
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* Make sure MORE bit is cleared */
multiline_comment|/* Put skb back on queue */
id|skb_queue_head
c_func
(paren
op_amp
id|self-&gt;rx_queue
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irttp_run_rx_queue (self)&n; *&n; *     Check if we have any frames to be transmitted, or if we have any&n; *     available credit to give away.&n; */
DECL|function|irttp_run_rx_queue
r_void
id|irttp_run_rx_queue
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|more
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;() send=%d,avail=%d,remote=%d&bslash;n&quot;
comma
id|self-&gt;send_credit
comma
id|self-&gt;avail_credit
comma
id|self-&gt;remote_credit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irda_lock
c_func
(paren
op_amp
id|self-&gt;rx_queue_lock
)paren
op_eq
id|FALSE
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *  Reassemble all frames in receive queue and deliver them&n;&t; */
r_while
c_loop
(paren
op_logical_neg
id|self-&gt;rx_sdu_busy
op_logical_and
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;rx_queue
)paren
)paren
)paren
(brace
id|self-&gt;avail_credit
op_increment
suffix:semicolon
id|more
op_assign
id|skb-&gt;data
(braket
l_int|0
)braket
op_amp
l_int|0x80
suffix:semicolon
multiline_comment|/* Remove TTP header */
id|skb_pull
c_func
(paren
id|skb
comma
id|TTP_HEADER
)paren
suffix:semicolon
multiline_comment|/* Add the length of the remaining data */
id|self-&gt;rx_sdu_size
op_add_assign
id|skb-&gt;len
suffix:semicolon
multiline_comment|/*  &n;&t;&t; * If SAR is disabled, or user has requested no reassembly&n;&t;&t; * of received fragements then we just deliver them&n;&t;&t; * immediately. This can be requested by clients that&n;&t;&t; * implements byte streams without any message boundaries&n;&t;&t; */
r_if
c_cond
(paren
id|self-&gt;rx_max_sdu_size
op_eq
id|TTP_SAR_DISABLE
)paren
(brace
id|irttp_do_data_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|self-&gt;rx_sdu_size
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Check if this is a fragment, and not the last fragment */
r_if
c_cond
(paren
id|more
)paren
(brace
multiline_comment|/*  &n;&t;&t;&t; *  Queue the fragment if we still are within the &n;&t;&t;&t; *  limits of the maximum size of the rx_sdu&n;&t;&t;&t; */
r_if
c_cond
(paren
id|self-&gt;rx_sdu_size
op_le
id|self-&gt;rx_max_sdu_size
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), queueing frag&bslash;n&quot;
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|self-&gt;rx_fragments
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Free the part of the SDU that is too big */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  This is the last fragment, so time to reassemble!&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|self-&gt;rx_sdu_size
op_le
id|self-&gt;rx_max_sdu_size
)paren
op_logical_or
(paren
id|self-&gt;rx_max_sdu_size
op_eq
id|TTP_SAR_UNBOUND
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t; * A little optimizing. Only queue the fragment if&n;&t;&t;&t; * there are other fragments. Since if this is the&n;&t;&t;&t; * last and only fragment, there is no need to&n;&t;&t;&t; * reassemble :-) &n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|self-&gt;rx_fragments
)paren
)paren
(brace
id|skb_queue_tail
c_func
(paren
op_amp
id|self-&gt;rx_fragments
comma
id|skb
)paren
suffix:semicolon
id|skb
op_assign
id|irttp_reassemble_skb
c_func
(paren
id|self
)paren
suffix:semicolon
)brace
multiline_comment|/* Now we can deliver the reassembled skb */
id|irttp_do_data_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Truncated frame&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Free the part of the SDU that is too big */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Deliver only the valid but truncated part of SDU */
id|skb
op_assign
id|irttp_reassemble_skb
c_func
(paren
id|self
)paren
suffix:semicolon
id|irttp_do_data_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
)brace
id|self-&gt;rx_sdu_size
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Reset lock */
id|self-&gt;rx_queue_lock
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_flush_queues (self)&n; *&n; *     Flushes (removes all frames) in transitt-buffer (tx_list)&n; */
DECL|function|irttp_flush_queues
r_void
id|irttp_flush_queues
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Deallocate frames waiting to be sent */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;tx_queue
)paren
)paren
op_ne
l_int|NULL
)paren
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Deallocate received frames */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;rx_queue
)paren
)paren
op_ne
l_int|NULL
)paren
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Deallocate received fragments */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;rx_fragments
)paren
)paren
op_ne
l_int|NULL
)paren
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_reasseble (self)&n; *&n; *    Makes a new (continuous) skb of all the fragments in the fragment&n; *    queue&n; *&n; */
DECL|function|irttp_reassemble_skb
r_static
r_struct
id|sk_buff
op_star
id|irttp_reassemble_skb
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
comma
op_star
id|frag
suffix:semicolon
r_int
id|n
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fragment index */
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), self-&gt;rx_sdu_size=%d&bslash;n&quot;
comma
id|self-&gt;rx_sdu_size
)paren
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|TTP_HEADER
op_plus
id|self-&gt;rx_sdu_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* &n;&t; * Need to reserve space for TTP header in case this skb needs to &n;&t; * be requeued in case delivery failes&n;&t; */
id|skb_reserve
c_func
(paren
id|skb
comma
id|TTP_HEADER
)paren
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|self-&gt;rx_sdu_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Copy all fragments to a new buffer&n;&t; */
r_while
c_loop
(paren
(paren
id|frag
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;rx_fragments
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|memcpy
c_func
(paren
id|skb-&gt;data
op_plus
id|n
comma
id|frag-&gt;data
comma
id|frag-&gt;len
)paren
suffix:semicolon
id|n
op_add_assign
id|frag-&gt;len
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|frag
)paren
suffix:semicolon
)brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), frame len=%d&bslash;n&quot;
comma
id|n
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), rx_sdu_size=%d&bslash;n&quot;
comma
id|self-&gt;rx_sdu_size
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|n
op_le
id|self-&gt;rx_sdu_size
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Set the new length */
id|skb_trim
c_func
(paren
id|skb
comma
id|n
)paren
suffix:semicolon
id|self-&gt;rx_sdu_size
op_assign
l_int|0
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_fragment_skb (skb)&n; *&n; *    Fragments a frame and queues all the fragments for transmission&n; *&n; */
DECL|function|irttp_fragment_skb
r_static
r_void
id|irttp_fragment_skb
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sk_buff
op_star
id|frag
suffix:semicolon
id|__u8
op_star
id|frame
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Split frame into a number of segments&n;&t; */
r_while
c_loop
(paren
id|skb-&gt;len
OG
id|self-&gt;max_seg_size
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), fragmenting ...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Make new segment */
id|frag
op_assign
id|dev_alloc_skb
c_func
(paren
id|self-&gt;max_seg_size
op_plus
id|self-&gt;max_header_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|frag
)paren
r_return
suffix:semicolon
id|skb_reserve
c_func
(paren
id|frag
comma
id|self-&gt;max_header_size
)paren
suffix:semicolon
multiline_comment|/* Copy data from the original skb into this fragment. */
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|frag
comma
id|self-&gt;max_seg_size
)paren
comma
id|skb-&gt;data
comma
id|self-&gt;max_seg_size
)paren
suffix:semicolon
multiline_comment|/* Insert TTP header, with the more bit set */
id|frame
op_assign
id|skb_push
c_func
(paren
id|frag
comma
id|TTP_HEADER
)paren
suffix:semicolon
id|frame
(braket
l_int|0
)braket
op_assign
id|TTP_MORE
suffix:semicolon
multiline_comment|/* Hide the copied data from the original skb */
id|skb_pull
c_func
(paren
id|skb
comma
id|self-&gt;max_seg_size
)paren
suffix:semicolon
multiline_comment|/* Queue fragment */
id|skb_queue_tail
c_func
(paren
op_amp
id|self-&gt;tx_queue
comma
id|frag
)paren
suffix:semicolon
)brace
multiline_comment|/* Queue what is left of the original skb */
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), queuing last segment&bslash;n&quot;
)paren
suffix:semicolon
id|frame
op_assign
id|skb_push
c_func
(paren
id|skb
comma
id|TTP_HEADER
)paren
suffix:semicolon
id|frame
(braket
l_int|0
)braket
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* Clear more bit */
multiline_comment|/* Queue fragment */
id|skb_queue_tail
c_func
(paren
op_amp
id|self-&gt;tx_queue
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_param_max_sdu_size (self, param)&n; *&n; *    Handle the MaxSduSize parameter in the connect frames, this function&n; *    will be called both when this parameter needs to be inserted into, and&n; *    extracted from the connect frames&n; */
DECL|function|irttp_param_max_sdu_size
r_static
r_int
id|irttp_param_max_sdu_size
c_func
(paren
r_void
op_star
id|instance
comma
id|irda_param_t
op_star
id|param
comma
r_int
id|get
)paren
(brace
r_struct
id|tsap_cb
op_star
id|self
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|tsap_cb
op_star
)paren
id|instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get
)paren
id|param-&gt;pv.i
op_assign
id|self-&gt;tx_max_sdu_size
suffix:semicolon
r_else
id|self-&gt;tx_max_sdu_size
op_assign
id|param-&gt;pv.i
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), MaxSduSize=%d&bslash;n&quot;
comma
id|param-&gt;pv.i
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_todo_expired (data)&n; *&n; *    Todo timer has expired!&n; *&n; */
DECL|function|irttp_todo_expired
r_static
r_void
id|irttp_todo_expired
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|tsap_cb
op_star
id|self
op_assign
(paren
r_struct
id|tsap_cb
op_star
)paren
id|data
suffix:semicolon
multiline_comment|/* Check that we still exist */
r_if
c_cond
(paren
op_logical_neg
id|self
op_logical_or
id|self-&gt;magic
op_ne
id|TTP_TSAP_MAGIC
)paren
r_return
suffix:semicolon
id|irttp_run_rx_queue
c_func
(paren
id|self
)paren
suffix:semicolon
id|irttp_run_tx_queue
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/*  Give avay some credits to peer?  */
r_if
c_cond
(paren
(paren
id|self-&gt;remote_credit
OL
id|TTP_LOW_THRESHOLD
)paren
op_logical_and
(paren
id|self-&gt;avail_credit
OG
l_int|0
)paren
op_logical_and
(paren
id|skb_queue_empty
c_func
(paren
op_amp
id|self-&gt;tx_queue
)paren
)paren
)paren
(brace
id|irttp_give_credit
c_func
(paren
id|self
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if time for disconnect */
r_if
c_cond
(paren
id|self-&gt;disconnect_pend
)paren
(brace
multiline_comment|/* Check if it&squot;s possible to disconnect yet */
r_if
c_cond
(paren
id|skb_queue_empty
c_func
(paren
op_amp
id|self-&gt;tx_queue
)paren
)paren
(brace
multiline_comment|/* Make sure disconnect is not pending anymore */
id|self-&gt;disconnect_pend
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;disconnect_skb
)paren
(brace
id|irttp_disconnect_request
c_func
(paren
id|self
comma
id|self-&gt;disconnect_skb
comma
id|P_NORMAL
)paren
suffix:semicolon
id|self-&gt;disconnect_skb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
id|irttp_disconnect_request
c_func
(paren
id|self
comma
l_int|NULL
comma
id|P_NORMAL
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Try again later */
id|irttp_start_todo_timer
c_func
(paren
id|self
comma
l_int|1
op_star
id|HZ
)paren
suffix:semicolon
multiline_comment|/* No reason to try and close now */
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Check if it&squot;s closing time */
r_if
c_cond
(paren
id|self-&gt;close_pend
)paren
id|irttp_close_tsap
c_func
(paren
id|self
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irttp_start_todo_timer (self, timeout)&n; *&n; *    Start todo timer. &n; *&n; */
DECL|function|irttp_start_todo_timer
r_static
r_void
id|irttp_start_todo_timer
c_func
(paren
r_struct
id|tsap_cb
op_star
id|self
comma
r_int
id|timeout
)paren
(brace
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|TTP_TSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;todo_timer
)paren
suffix:semicolon
id|self-&gt;todo_timer.data
op_assign
(paren
r_int
r_int
)paren
id|self
suffix:semicolon
id|self-&gt;todo_timer.function
op_assign
op_amp
id|irttp_todo_expired
suffix:semicolon
id|self-&gt;todo_timer.expires
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|self-&gt;todo_timer
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/*&n; * Function irttp_proc_read (buf, start, offset, len, unused)&n; *&n; *    Give some info to the /proc file system&n; */
DECL|function|irttp_proc_read
r_int
id|irttp_proc_read
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|len
)paren
(brace
r_struct
id|tsap_cb
op_star
id|self
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|irttp
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|tsap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irttp-&gt;tsaps
)paren
suffix:semicolon
r_while
c_loop
(paren
id|self
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|self
op_logical_or
id|self-&gt;magic
op_ne
id|TTP_TSAP_MAGIC
)paren
r_return
id|len
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;TSAP %d, &quot;
comma
id|i
op_increment
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;stsap_sel: %02x, &quot;
comma
id|self-&gt;stsap_sel
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;dtsap_sel: %02x&bslash;n&quot;
comma
id|self-&gt;dtsap_sel
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;  connected: %s, &quot;
comma
id|self-&gt;connected
ques
c_cond
l_string|&quot;TRUE&quot;
suffix:colon
l_string|&quot;FALSE&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;avail credit: %d, &quot;
comma
id|self-&gt;avail_credit
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;remote credit: %d, &quot;
comma
id|self-&gt;remote_credit
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;send credit: %d&bslash;n&quot;
comma
id|self-&gt;send_credit
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;  tx packets: %d, &quot;
comma
id|self-&gt;stats.tx_packets
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;rx packets: %d, &quot;
comma
id|self-&gt;stats.rx_packets
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;tx_queue len: %d &quot;
comma
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;tx_queue
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;rx_queue len: %d&bslash;n&quot;
comma
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;rx_queue
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;  tx_sdu_busy: %s, &quot;
comma
id|self-&gt;tx_sdu_busy
ques
c_cond
l_string|&quot;TRUE&quot;
suffix:colon
l_string|&quot;FALSE&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;rx_sdu_busy: %s&bslash;n&quot;
comma
id|self-&gt;rx_sdu_busy
ques
c_cond
l_string|&quot;TRUE&quot;
suffix:colon
l_string|&quot;FALSE&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;  max_seg_size: %d, &quot;
comma
id|self-&gt;max_seg_size
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;tx_max_sdu_size: %d, &quot;
comma
id|self-&gt;tx_max_sdu_size
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;rx_max_sdu_size: %d&bslash;n&quot;
comma
id|self-&gt;rx_max_sdu_size
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;  Used by (%s)&bslash;n&quot;
comma
id|self-&gt;notify.name
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|tsap_cb
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irttp-&gt;tsaps
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif /* PROC_FS */
eof
