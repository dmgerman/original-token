multiline_comment|/*&n; *&t;IrNET protocol module : Synchronous PPP over an IrDA socket.&n; *&n; *&t;&t;Jean II - HPL `00 - &lt;jt@hpl.hp.com&gt;&n; *&n; * This file implement the PPP interface and /dev/irnet character device.&n; * The PPP interface hook to the ppp_generic module, handle all our&n; *&t;relationship to the PPP code in the kernel (and by extension to pppd),&n; *&t;and exchange PPP frames with this module (send/receive).&n; * The /dev/irnet device is used primarily for 2 functions :&n; *&t;1) as a stub for pppd (the ppp daemon), so that we can appropriately&n; *&t;generate PPP sessions (we pretend we are a tty).&n; *&t;2) as a control channel (write commands, read events)&n; */
macro_line|#include &quot;irnet_ppp.h&quot;&t;&t;/* Private header */
multiline_comment|/************************* CONTROL CHANNEL *************************/
multiline_comment|/*&n; * When a pppd instance is not active on /dev/irnet, it acts as a control&n; * channel.&n; * Writting allow to set up the IrDA destination of the IrNET channel,&n; * and any application may be read events happening in IrNET...&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Write is used to send a command to configure a IrNET channel&n; * before it is open by pppd. The syntax is : &quot;command argument&quot;&n; * Currently there is only two defined commands :&n; *&t;o name : set the requested IrDA nickname of the IrNET peer.&n; *&t;o addr : set the requested IrDA address of the IrNET peer.&n; * Note : the code is crude, but effective...&n; */
r_static
r_inline
id|ssize_t
DECL|function|irnet_ctrl_write
id|irnet_ctrl_write
c_func
(paren
id|irnet_socket
op_star
id|ap
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_char
id|command
(braket
l_int|5
op_plus
id|NICKNAME_MAX_LEN
op_plus
l_int|2
)braket
suffix:semicolon
r_int
id|length
op_assign
id|count
suffix:semicolon
id|DENTER
c_func
(paren
id|CTRL_TRACE
comma
l_string|&quot;(ap=0x%X, count=%d)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ap
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* Check for overflow... */
id|DABORT
c_func
(paren
id|count
OG
(paren
l_int|5
op_plus
id|NICKNAME_MAX_LEN
op_plus
l_int|1
)paren
comma
op_minus
id|ENOMEM
comma
id|CTRL_ERROR
comma
l_string|&quot;Too much data !!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Get the data in the driver */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|command
comma
id|buf
comma
id|count
)paren
)paren
(brace
id|DERROR
c_func
(paren
id|CTRL_ERROR
comma
l_string|&quot;Invalid user space pointer.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* Strip out &squot;&bslash;n&squot; if needed, and safe terminate the string */
r_if
c_cond
(paren
id|command
(braket
id|length
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|length
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|command
(braket
id|length
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|length
op_decrement
suffix:semicolon
)brace
id|command
(braket
id|length
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|DEBUG
c_func
(paren
id|CTRL_INFO
comma
l_string|&quot;Command received is ``%s&squot;&squot; (%d-%d).&bslash;n&quot;
comma
id|command
comma
id|length
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* Check if we recognised the command */
multiline_comment|/* First command : name */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|command
comma
l_string|&quot;name&quot;
comma
l_int|4
)paren
)paren
(brace
multiline_comment|/* Copy the name only if is included and not &quot;any&quot; */
r_if
c_cond
(paren
(paren
id|length
OG
l_int|5
)paren
op_logical_and
(paren
id|strcmp
c_func
(paren
id|command
op_plus
l_int|5
comma
l_string|&quot;any&quot;
)paren
)paren
)paren
(brace
multiline_comment|/* Copy the name for later reuse (including the &squot;/0&squot;) */
id|memcpy
c_func
(paren
id|ap-&gt;rname
comma
id|command
op_plus
l_int|5
comma
id|length
op_minus
l_int|5
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
id|ap-&gt;rname
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|DEXIT
c_func
(paren
id|CTRL_TRACE
comma
l_string|&quot; - rname = ``%s&squot;&squot;&bslash;n&quot;
comma
id|ap-&gt;rname
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* Second command : addr */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|command
comma
l_string|&quot;addr&quot;
comma
l_int|4
)paren
)paren
(brace
multiline_comment|/* Copy the address only if is included and not &quot;any&quot; */
r_if
c_cond
(paren
(paren
id|length
OG
l_int|5
)paren
op_logical_and
(paren
id|strcmp
c_func
(paren
id|command
op_plus
l_int|5
comma
l_string|&quot;any&quot;
)paren
)paren
)paren
(brace
r_char
op_star
id|endp
suffix:semicolon
id|__u32
id|daddr
suffix:semicolon
multiline_comment|/* Convert argument to a number (last arg is the base) */
id|daddr
op_assign
id|simple_strtoul
c_func
(paren
id|command
op_plus
l_int|5
comma
op_amp
id|endp
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Has it worked  ? (endp should be command + count) */
id|DABORT
c_func
(paren
id|endp
op_le
(paren
id|command
op_plus
l_int|5
)paren
comma
op_minus
id|EINVAL
comma
id|CTRL_ERROR
comma
l_string|&quot;Invalid address.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Save it */
id|ap-&gt;raddr
op_assign
id|daddr
suffix:semicolon
)brace
r_else
id|ap-&gt;raddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
id|DEXIT
c_func
(paren
id|CTRL_TRACE
comma
l_string|&quot; - raddr = %08x&bslash;n&quot;
comma
id|ap-&gt;raddr
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* Other possible command : connect N (number of retries) */
multiline_comment|/* Failed... */
id|DABORT
c_func
(paren
l_int|1
comma
op_minus
id|EINVAL
comma
id|CTRL_ERROR
comma
l_string|&quot;Not a recognised IrNET command.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef INITIAL_DISCOVERY
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_read_discovery_log (self)&n; *&n; *    Read the content on the discovery log&n; *&n; * This function dump the current content of the discovery log&n; * at the startup of the event channel.&n; * Return 1 if written on the control channel...&n; *&n; * State of the ap-&gt;disco_XXX variables :&n; *&t;at socket creation :&t;disco_index = 0 ; disco_number = 0&n; *&t;while reading :&t;&t;disco_index = X ; disco_number = Y&n; *&t;After reading :&t;&t;disco_index = Y ; disco_number = -1&n; */
r_static
r_inline
r_int
DECL|function|irnet_read_discovery_log
id|irnet_read_discovery_log
c_func
(paren
id|irnet_socket
op_star
id|ap
comma
r_char
op_star
id|event
)paren
(brace
r_int
id|done_event
op_assign
l_int|0
suffix:semicolon
id|DENTER
c_func
(paren
id|CTRL_TRACE
comma
l_string|&quot;(ap=0x%X, event=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ap
comma
(paren
r_int
r_int
)paren
id|event
)paren
suffix:semicolon
multiline_comment|/* Test if we have some work to do or we have already finished */
r_if
c_cond
(paren
id|ap-&gt;disco_number
op_eq
op_minus
l_int|1
)paren
(brace
id|DEBUG
c_func
(paren
id|CTRL_INFO
comma
l_string|&quot;Already done&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Test if it&squot;s the first time and therefore we need to get the log */
r_if
c_cond
(paren
id|ap-&gt;disco_index
op_eq
l_int|0
)paren
(brace
id|__u16
id|mask
op_assign
id|irlmp_service_to_hint
c_func
(paren
id|S_LAN
)paren
suffix:semicolon
multiline_comment|/* Ask IrLMP for the current discovery log */
id|ap-&gt;discoveries
op_assign
id|irlmp_get_discoveries
c_func
(paren
op_amp
id|ap-&gt;disco_number
comma
id|mask
)paren
suffix:semicolon
multiline_comment|/* Check if the we got some results */
r_if
c_cond
(paren
id|ap-&gt;discoveries
op_eq
l_int|NULL
)paren
(brace
id|ap-&gt;disco_number
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
id|CTRL_INFO
comma
l_string|&quot;Got the log (0x%X), size is %d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ap-&gt;discoveries
comma
id|ap-&gt;disco_number
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if we have more item to dump */
r_if
c_cond
(paren
id|ap-&gt;disco_index
OL
id|ap-&gt;disco_number
)paren
(brace
multiline_comment|/* Write an event */
id|sprintf
c_func
(paren
id|event
comma
l_string|&quot;Found %08x (%s)&bslash;n&quot;
comma
id|ap-&gt;discoveries
(braket
id|ap-&gt;disco_index
)braket
dot
id|daddr
comma
id|ap-&gt;discoveries
(braket
id|ap-&gt;disco_index
)braket
dot
id|info
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|CTRL_INFO
comma
l_string|&quot;Writing discovery %d : %s&bslash;n&quot;
comma
id|ap-&gt;disco_index
comma
id|ap-&gt;discoveries
(braket
id|ap-&gt;disco_index
)braket
dot
id|info
)paren
suffix:semicolon
multiline_comment|/* We have an event */
id|done_event
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Next discovery */
id|ap-&gt;disco_index
op_increment
suffix:semicolon
)brace
multiline_comment|/* Check if we have done the last item */
r_if
c_cond
(paren
id|ap-&gt;disco_index
op_ge
id|ap-&gt;disco_number
)paren
(brace
multiline_comment|/* No more items : remove the log and signal termination */
id|DEBUG
c_func
(paren
id|CTRL_INFO
comma
l_string|&quot;Cleaning up log (0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ap-&gt;discoveries
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;discoveries
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Cleanup our copy of the discovery log */
id|kfree
c_func
(paren
id|ap-&gt;discoveries
)paren
suffix:semicolon
id|ap-&gt;discoveries
op_assign
l_int|NULL
suffix:semicolon
)brace
id|ap-&gt;disco_number
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|done_event
suffix:semicolon
)brace
macro_line|#endif INITIAL_DISCOVERY
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Read is used to get IrNET events&n; */
r_static
r_inline
id|ssize_t
DECL|function|irnet_ctrl_read
id|irnet_ctrl_read
c_func
(paren
id|irnet_socket
op_star
id|ap
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_char
id|event
(braket
l_int|64
)braket
suffix:semicolon
multiline_comment|/* Max event is 61 char */
id|ssize_t
id|ret
op_assign
l_int|0
suffix:semicolon
id|DENTER
c_func
(paren
id|CTRL_TRACE
comma
l_string|&quot;(ap=0x%X, count=%d)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ap
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* Check if we can write an event out in one go */
id|DABORT
c_func
(paren
id|count
OL
r_sizeof
(paren
id|event
)paren
comma
op_minus
id|EOVERFLOW
comma
id|CTRL_ERROR
comma
l_string|&quot;Buffer to small.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef INITIAL_DISCOVERY
multiline_comment|/* Check if we have read the log */
r_if
c_cond
(paren
id|irnet_read_discovery_log
c_func
(paren
id|ap
comma
id|event
)paren
)paren
(brace
multiline_comment|/* We have an event !!! Copy it to the user */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|event
comma
id|strlen
c_func
(paren
id|event
)paren
)paren
)paren
(brace
id|DERROR
c_func
(paren
id|CTRL_ERROR
comma
l_string|&quot;Invalid user space pointer.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|DEXIT
c_func
(paren
id|CTRL_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|strlen
c_func
(paren
id|event
)paren
suffix:semicolon
)brace
macro_line|#endif INITIAL_DISCOVERY
multiline_comment|/* Put ourselves on the wait queue to be woken up */
id|add_wait_queue
c_func
(paren
op_amp
id|irnet_events.rwait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* If there is unread events */
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;event_index
op_ne
id|irnet_events.index
)paren
(brace
r_break
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_break
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Yield and wait to be woken up */
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|irnet_events.rwait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* Did we got it ? */
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
multiline_comment|/* No, return the error code */
id|DEXIT
c_func
(paren
id|CTRL_TRACE
comma
l_string|&quot; - ret %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Which event is it ? */
r_switch
c_cond
(paren
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|event
)paren
(brace
r_case
id|IRNET_DISCOVER
suffix:colon
id|sprintf
c_func
(paren
id|event
comma
l_string|&quot;Discovered %08x (%s)&bslash;n&quot;
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|addr
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRNET_EXPIRE
suffix:colon
id|sprintf
c_func
(paren
id|event
comma
l_string|&quot;Expired %08x (%s)&bslash;n&quot;
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|addr
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRNET_CONNECT_TO
suffix:colon
id|sprintf
c_func
(paren
id|event
comma
l_string|&quot;Connected to %08x (%s) on ppp%d&bslash;n&quot;
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|addr
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|name
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|unit
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRNET_CONNECT_FROM
suffix:colon
id|sprintf
c_func
(paren
id|event
comma
l_string|&quot;Connection from %08x (%s) on ppp%d&bslash;n&quot;
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|addr
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|name
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|unit
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRNET_REQUEST_FROM
suffix:colon
id|sprintf
c_func
(paren
id|event
comma
l_string|&quot;Request from %08x (%s)&bslash;n&quot;
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|addr
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRNET_NOANSWER_FROM
suffix:colon
id|sprintf
c_func
(paren
id|event
comma
l_string|&quot;No-answer from %08x (%s) on ppp%d&bslash;n&quot;
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|addr
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|name
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|unit
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRNET_BLOCKED_LINK
suffix:colon
id|sprintf
c_func
(paren
id|event
comma
l_string|&quot;Blocked link with %08x (%s) on ppp%d&bslash;n&quot;
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|addr
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|name
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|unit
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRNET_DISCONNECT_FROM
suffix:colon
id|sprintf
c_func
(paren
id|event
comma
l_string|&quot;Disconnection from %08x (%s) on ppp%d&bslash;n&quot;
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|addr
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|name
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|unit
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRNET_DISCONNECT_TO
suffix:colon
id|sprintf
c_func
(paren
id|event
comma
l_string|&quot;Disconnected to %08x (%s)&bslash;n&quot;
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|addr
comma
id|irnet_events.log
(braket
id|ap-&gt;event_index
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|sprintf
c_func
(paren
id|event
comma
l_string|&quot;Bug&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Increment our event index */
id|ap-&gt;event_index
op_assign
(paren
id|ap-&gt;event_index
op_plus
l_int|1
)paren
op_mod
id|IRNET_MAX_EVENTS
suffix:semicolon
id|DEBUG
c_func
(paren
id|CTRL_INFO
comma
l_string|&quot;Event is :%s&quot;
comma
id|event
)paren
suffix:semicolon
multiline_comment|/* Copy it to the user */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|event
comma
id|strlen
c_func
(paren
id|event
)paren
)paren
)paren
(brace
id|DERROR
c_func
(paren
id|CTRL_ERROR
comma
l_string|&quot;Invalid user space pointer.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|DEXIT
c_func
(paren
id|CTRL_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|strlen
c_func
(paren
id|event
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Poll : called when someone do a select on /dev/irnet.&n; * Just check if there are new events...&n; */
r_static
r_inline
r_int
r_int
DECL|function|irnet_ctrl_poll
id|irnet_ctrl_poll
c_func
(paren
id|irnet_socket
op_star
id|ap
comma
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
id|DENTER
c_func
(paren
id|CTRL_TRACE
comma
l_string|&quot;(ap=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ap
)paren
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|irnet_events.rwait
comma
id|wait
)paren
suffix:semicolon
id|mask
op_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
multiline_comment|/* If there is unread events */
r_if
c_cond
(paren
id|ap-&gt;event_index
op_ne
id|irnet_events.index
)paren
(brace
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
macro_line|#ifdef INITIAL_DISCOVERY
r_if
c_cond
(paren
id|ap-&gt;disco_number
op_ne
op_minus
l_int|1
)paren
(brace
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
macro_line|#endif INITIAL_DISCOVERY
id|DEXIT
c_func
(paren
id|CTRL_TRACE
comma
l_string|&quot; - mask=0x%X&bslash;n&quot;
comma
id|mask
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/*********************** FILESYSTEM CALLBACKS ***********************/
multiline_comment|/*&n; * Implement the usual open, read, write functions that will be called&n; * by the file system when some action is performed on /dev/irnet.&n; * Most of those actions will in fact be performed by &quot;pppd&quot; or&n; * the control channel, we just act as a redirector...&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Open : when somebody open /dev/irnet&n; * We basically create a new instance of irnet and initialise it.&n; */
r_static
r_int
DECL|function|dev_irnet_open
id|dev_irnet_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|irnet_socket
op_star
id|ap
suffix:semicolon
r_int
id|err
suffix:semicolon
id|DENTER
c_func
(paren
id|FS_TRACE
comma
l_string|&quot;(file=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|file
)paren
suffix:semicolon
macro_line|#ifdef SECURE_DEVIRNET
multiline_comment|/* This could (should?) be enforced by the permissions on /dev/irnet. */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
macro_line|#endif SECURE_DEVIRNET
multiline_comment|/* Allocate a private structure for this IrNET instance */
id|ap
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ap
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|DABORT
c_func
(paren
id|ap
op_eq
l_int|NULL
comma
op_minus
id|ENOMEM
comma
id|FS_ERROR
comma
l_string|&quot;Can&squot;t allocate struct irnet...&bslash;n&quot;
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/* initialize the irnet structure */
id|memset
c_func
(paren
id|ap
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ap
)paren
)paren
suffix:semicolon
id|ap-&gt;file
op_assign
id|file
suffix:semicolon
multiline_comment|/* PPP channel setup */
id|ap-&gt;ppp_open
op_assign
l_int|0
suffix:semicolon
id|ap-&gt;chan
dot
r_private
op_assign
id|ap
suffix:semicolon
multiline_comment|/* PPP parameters */
id|ap-&gt;mru
op_assign
id|PPP_MRU
suffix:semicolon
id|ap-&gt;xaccm
(braket
l_int|0
)braket
op_assign
op_complement
l_int|0U
suffix:semicolon
id|ap-&gt;xaccm
(braket
l_int|3
)braket
op_assign
l_int|0x60000000U
suffix:semicolon
id|ap-&gt;raccm
op_assign
op_complement
l_int|0U
suffix:semicolon
multiline_comment|/* Setup the IrDA part... */
id|err
op_assign
id|irda_irnet_create
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|DERROR
c_func
(paren
id|FS_ERROR
comma
l_string|&quot;Can&squot;t setup IrDA link...&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ap
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* For the control channel */
id|ap-&gt;event_index
op_assign
id|irnet_events.index
suffix:semicolon
multiline_comment|/* Cancel all past events */
multiline_comment|/* Put our stuff where we will be able to find it later */
id|file-&gt;private_data
op_assign
id|ap
suffix:semicolon
id|DEXIT
c_func
(paren
id|FS_TRACE
comma
l_string|&quot; - ap=0x%X&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ap
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Close : when somebody close /dev/irnet&n; * Destroy the instance of /dev/irnet&n; */
r_static
r_int
DECL|function|dev_irnet_close
id|dev_irnet_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|irnet_socket
op_star
id|ap
op_assign
(paren
r_struct
id|irnet_socket
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|DENTER
c_func
(paren
id|FS_TRACE
comma
l_string|&quot;(file=0x%X, ap=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|file
comma
(paren
r_int
r_int
)paren
id|ap
)paren
suffix:semicolon
id|DABORT
c_func
(paren
id|ap
op_eq
l_int|NULL
comma
l_int|0
comma
id|FS_ERROR
comma
l_string|&quot;ap is NULL !!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Detach ourselves */
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Close IrDA stuff */
id|irda_irnet_destroy
c_func
(paren
id|ap
)paren
suffix:semicolon
multiline_comment|/* Disconnect from the generic PPP layer if not already done */
r_if
c_cond
(paren
id|ap-&gt;ppp_open
)paren
(brace
id|DERROR
c_func
(paren
id|FS_ERROR
comma
l_string|&quot;Channel still registered - deregistering !&bslash;n&quot;
)paren
suffix:semicolon
id|ppp_unregister_channel
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
suffix:semicolon
id|ap-&gt;ppp_open
op_assign
l_int|0
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|ap
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|DEXIT
c_func
(paren
id|FS_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Write does nothing.&n; * (we receive packet from ppp_generic through ppp_irnet_send())&n; */
r_static
id|ssize_t
DECL|function|dev_irnet_write
id|dev_irnet_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|irnet_socket
op_star
id|ap
op_assign
(paren
r_struct
id|irnet_socket
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|DPASS
c_func
(paren
id|FS_TRACE
comma
l_string|&quot;(file=0x%X, ap=0x%X, count=%d)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|file
comma
(paren
r_int
r_int
)paren
id|ap
comma
id|count
)paren
suffix:semicolon
id|DABORT
c_func
(paren
id|ap
op_eq
l_int|NULL
comma
op_minus
id|ENXIO
comma
id|FS_ERROR
comma
l_string|&quot;ap is NULL !!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* If we are connected to ppp_generic, let it handle the job */
r_if
c_cond
(paren
id|ap-&gt;ppp_open
)paren
(brace
r_return
id|ppp_channel_write
c_func
(paren
op_amp
id|ap-&gt;chan
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
r_else
r_return
id|irnet_ctrl_write
c_func
(paren
id|ap
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Read doesn&squot;t do much either.&n; * (pppd poll us, but ultimately reads through /dev/ppp)&n; */
r_static
id|ssize_t
DECL|function|dev_irnet_read
id|dev_irnet_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|irnet_socket
op_star
id|ap
op_assign
(paren
r_struct
id|irnet_socket
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|DPASS
c_func
(paren
id|FS_TRACE
comma
l_string|&quot;(file=0x%X, ap=0x%X, count=%d)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|file
comma
(paren
r_int
r_int
)paren
id|ap
comma
id|count
)paren
suffix:semicolon
id|DABORT
c_func
(paren
id|ap
op_eq
l_int|NULL
comma
op_minus
id|ENXIO
comma
id|FS_ERROR
comma
l_string|&quot;ap is NULL !!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* If we are connected to ppp_generic, let it handle the job */
r_if
c_cond
(paren
id|ap-&gt;ppp_open
)paren
(brace
r_return
id|ppp_channel_read
c_func
(paren
op_amp
id|ap-&gt;chan
comma
id|file
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
r_else
r_return
id|irnet_ctrl_read
c_func
(paren
id|ap
comma
id|file
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Poll : called when someone do a select on /dev/irnet&n; */
r_static
r_int
r_int
DECL|function|dev_irnet_poll
id|dev_irnet_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
id|irnet_socket
op_star
id|ap
op_assign
(paren
r_struct
id|irnet_socket
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
id|DENTER
c_func
(paren
id|FS_TRACE
comma
l_string|&quot;(file=0x%X, ap=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|file
comma
(paren
r_int
r_int
)paren
id|ap
)paren
suffix:semicolon
id|mask
op_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
id|DABORT
c_func
(paren
id|ap
op_eq
l_int|NULL
comma
id|mask
comma
id|FS_ERROR
comma
l_string|&quot;ap is NULL !!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* If we are connected to ppp_generic, let it handle the job */
r_if
c_cond
(paren
id|ap-&gt;ppp_open
)paren
(brace
id|mask
op_or_assign
id|ppp_channel_poll
c_func
(paren
op_amp
id|ap-&gt;chan
comma
id|file
comma
id|wait
)paren
suffix:semicolon
)brace
r_else
id|mask
op_or_assign
id|irnet_ctrl_poll
c_func
(paren
id|ap
comma
id|file
comma
id|wait
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|FS_TRACE
comma
l_string|&quot; - mask=0x%X&bslash;n&quot;
comma
id|mask
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * IOCtl : Called when someone does some ioctls on /dev/irnet&n; * This is the way pppd configure us and control us while the PPP&n; * instance is active.&n; */
r_static
r_int
DECL|function|dev_irnet_ioctl
id|dev_irnet_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|irnet_socket
op_star
id|ap
op_assign
(paren
r_struct
id|irnet_socket
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|val
suffix:semicolon
id|DENTER
c_func
(paren
id|FS_TRACE
comma
l_string|&quot;(file=0x%X, ap=0x%X, cmd=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|file
comma
(paren
r_int
r_int
)paren
id|ap
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/* Basic checks... */
id|DASSERT
c_func
(paren
id|ap
op_ne
l_int|NULL
comma
op_minus
id|ENXIO
comma
id|PPP_ERROR
comma
l_string|&quot;ap is NULL...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef SECURE_DEVIRNET
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
macro_line|#endif SECURE_DEVIRNET
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/* Set discipline (should be N_SYNC_PPP or N_TTY) */
r_case
id|TIOCSETD
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|val
op_eq
id|N_SYNC_PPP
)paren
op_logical_or
(paren
id|val
op_eq
id|N_PPP
)paren
)paren
(brace
id|DEBUG
c_func
(paren
id|FS_INFO
comma
l_string|&quot;Entering PPP discipline.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* PPP channel setup */
id|ap-&gt;chan
dot
r_private
op_assign
id|ap
suffix:semicolon
id|ap-&gt;chan.ops
op_assign
op_amp
id|irnet_ppp_ops
suffix:semicolon
id|ap-&gt;chan.mtu
op_assign
id|PPP_MRU
suffix:semicolon
id|err
op_assign
id|ppp_register_channel
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Our ppp side is active */
id|ap-&gt;ppp_open
op_assign
l_int|1
suffix:semicolon
id|DEBUG
c_func
(paren
id|FS_INFO
comma
l_string|&quot;Trying to establish a connection.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Setup the IrDA link now - may fail... */
id|irda_irnet_connect
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
r_else
id|DERROR
c_func
(paren
id|FS_ERROR
comma
l_string|&quot;Can&squot;t setup PPP channel...&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* In theory, should be N_TTY */
id|DEBUG
c_func
(paren
id|FS_INFO
comma
l_string|&quot;Exiting PPP discipline.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Disconnect from the generic PPP layer */
r_if
c_cond
(paren
id|ap-&gt;ppp_open
)paren
(brace
id|ppp_unregister_channel
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
suffix:semicolon
)brace
r_else
id|DERROR
c_func
(paren
id|FS_ERROR
comma
l_string|&quot;Channel not registered !&bslash;n&quot;
)paren
suffix:semicolon
id|ap-&gt;ppp_open
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* Attach this PPP instance to the PPP driver (set it active) */
r_case
id|PPPIOCATTACH
suffix:colon
r_case
id|PPPIOCDETACH
suffix:colon
r_if
c_cond
(paren
id|ap-&gt;ppp_open
)paren
(brace
id|err
op_assign
id|ppp_channel_ioctl
c_func
(paren
op_amp
id|ap-&gt;chan
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
r_else
id|DERROR
c_func
(paren
id|FS_ERROR
comma
l_string|&quot;Channel not registered !&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Query PPP channel and unit number */
r_case
id|PPPIOCGCHAN
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;ppp_open
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ppp_channel_index
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
id|FS_INFO
comma
l_string|&quot;Query channel.&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGUNIT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;ppp_open
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ppp_unit_number
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
id|FS_INFO
comma
l_string|&quot;Query unit number.&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* All these ioctls can be passed both directly and from ppp_generic,&n;       * so we just deal with them in one place...&n;       */
r_case
id|PPPIOCGFLAGS
suffix:colon
r_case
id|PPPIOCSFLAGS
suffix:colon
r_case
id|PPPIOCGASYNCMAP
suffix:colon
r_case
id|PPPIOCSASYNCMAP
suffix:colon
r_case
id|PPPIOCGRASYNCMAP
suffix:colon
r_case
id|PPPIOCSRASYNCMAP
suffix:colon
r_case
id|PPPIOCGXASYNCMAP
suffix:colon
r_case
id|PPPIOCSXASYNCMAP
suffix:colon
r_case
id|PPPIOCGMRU
suffix:colon
r_case
id|PPPIOCSMRU
suffix:colon
id|DEBUG
c_func
(paren
id|FS_INFO
comma
l_string|&quot;Standard PPP ioctl.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_else
id|err
op_assign
id|ppp_irnet_ioctl
c_func
(paren
op_amp
id|ap-&gt;chan
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* TTY IOCTLs : Pretend that we are a tty, to keep pppd happy */
multiline_comment|/* Get termios */
r_case
id|TCGETS
suffix:colon
id|DEBUG
c_func
(paren
id|FS_INFO
comma
l_string|&quot;Get termios.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kernel_termios_to_user_termios
c_func
(paren
(paren
r_struct
id|termios
op_star
)paren
id|arg
comma
op_amp
id|ap-&gt;termios
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Set termios */
r_case
id|TCSETSF
suffix:colon
id|DEBUG
c_func
(paren
id|FS_INFO
comma
l_string|&quot;Set termios.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user_termios_to_kernel_termios
c_func
(paren
op_amp
id|ap-&gt;termios
comma
(paren
r_struct
id|termios
op_star
)paren
id|arg
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Set DTR/RTS */
r_case
id|TIOCMBIS
suffix:colon
r_case
id|TIOCMBIC
suffix:colon
multiline_comment|/* Set exclusive/non-exclusive mode */
r_case
id|TIOCEXCL
suffix:colon
r_case
id|TIOCNXCL
suffix:colon
id|DEBUG
c_func
(paren
id|FS_INFO
comma
l_string|&quot;TTY compatibility.&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCGETA
suffix:colon
id|DEBUG
c_func
(paren
id|FS_INFO
comma
l_string|&quot;TCGETA&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCFLSH
suffix:colon
id|DEBUG
c_func
(paren
id|FS_INFO
comma
l_string|&quot;TCFLSH&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Note : this will flush buffers in PPP, so it *must* be done&n;       * We should also worry that we don&squot;t accept junk here and that&n;       * we get rid of our own buffers */
macro_line|#ifdef FLUSH_TO_PPP
id|ppp_output_wakeup
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
suffix:semicolon
macro_line|#endif FLUSH_TO_PPP
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FIONREAD
suffix:colon
id|DEBUG
c_func
(paren
id|FS_INFO
comma
l_string|&quot;FIONREAD&bslash;n&quot;
)paren
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DERROR
c_func
(paren
id|FS_ERROR
comma
l_string|&quot;Unsupported ioctl (0x%X)&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
id|DEXIT
c_func
(paren
id|FS_TRACE
comma
l_string|&quot; - err = 0x%X&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/************************** PPP CALLBACKS **************************/
multiline_comment|/*&n; * This are the functions that the generic PPP driver in the kernel&n; * will call to communicate to us.&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Prepare the ppp frame for transmission over the IrDA socket.&n; * We make sure that the header space is enough, and we change ppp header&n; * according to flags passed by pppd.&n; * This is not a callback, but just a helper function used in ppp_irnet_send()&n; */
r_static
r_inline
r_struct
id|sk_buff
op_star
DECL|function|irnet_prepare_skb
id|irnet_prepare_skb
c_func
(paren
id|irnet_socket
op_star
id|ap
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
id|proto
suffix:semicolon
multiline_comment|/* PPP protocol */
r_int
id|islcp
suffix:semicolon
multiline_comment|/* Protocol == LCP */
r_int
id|needaddr
suffix:semicolon
multiline_comment|/* Need PPP address */
id|DENTER
c_func
(paren
id|PPP_TRACE
comma
l_string|&quot;(ap=0x%X, skb=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ap
comma
(paren
r_int
r_int
)paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Extract PPP protocol from the frame */
id|data
op_assign
id|skb-&gt;data
suffix:semicolon
id|proto
op_assign
(paren
id|data
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_plus
id|data
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* LCP packets with codes between 1 (configure-request)&n;   * and 7 (code-reject) must be sent as though no options&n;   * have been negotiated. */
id|islcp
op_assign
(paren
id|proto
op_eq
id|PPP_LCP
)paren
op_logical_and
(paren
l_int|1
op_le
id|data
(braket
l_int|2
)braket
)paren
op_logical_and
(paren
id|data
(braket
l_int|2
)braket
op_le
l_int|7
)paren
suffix:semicolon
multiline_comment|/* compress protocol field if option enabled */
r_if
c_cond
(paren
(paren
id|data
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
op_logical_and
(paren
id|ap-&gt;flags
op_amp
id|SC_COMP_PROT
)paren
op_logical_and
(paren
op_logical_neg
id|islcp
)paren
)paren
(brace
id|skb_pull
c_func
(paren
id|skb
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if we need address/control fields */
id|needaddr
op_assign
l_int|2
op_star
(paren
(paren
id|ap-&gt;flags
op_amp
id|SC_COMP_AC
)paren
op_eq
l_int|0
op_logical_or
id|islcp
)paren
suffix:semicolon
multiline_comment|/* Is the skb headroom large enough to contain all IrDA-headers? */
r_if
c_cond
(paren
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
OL
(paren
id|ap-&gt;max_header_size
op_plus
id|needaddr
)paren
)paren
op_logical_or
(paren
id|skb_shared
c_func
(paren
id|skb
)paren
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|new_skb
suffix:semicolon
id|DEBUG
c_func
(paren
id|PPP_INFO
comma
l_string|&quot;Reallocating skb&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Create a new skb */
id|new_skb
op_assign
id|skb_realloc_headroom
c_func
(paren
id|skb
comma
id|ap-&gt;max_header_size
op_plus
id|needaddr
)paren
suffix:semicolon
multiline_comment|/* We have to free the original skb anyway */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Did the realloc succeed ? */
id|DABORT
c_func
(paren
id|new_skb
op_eq
l_int|NULL
comma
l_int|NULL
comma
id|PPP_ERROR
comma
l_string|&quot;Could not realloc skb&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Use the new skb instead */
id|skb
op_assign
id|new_skb
suffix:semicolon
)brace
multiline_comment|/* prepend address/control fields if necessary */
r_if
c_cond
(paren
id|needaddr
)paren
(brace
id|skb_push
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
id|skb-&gt;data
(braket
l_int|0
)braket
op_assign
id|PPP_ALLSTATIONS
suffix:semicolon
id|skb-&gt;data
(braket
l_int|1
)braket
op_assign
id|PPP_UI
suffix:semicolon
)brace
id|DEXIT
c_func
(paren
id|PPP_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Send a packet to the peer over the IrTTP connection.&n; * Returns 1 iff the packet was accepted.&n; * Returns 0 iff packet was not consumed.&n; * If the packet was not accepted, we will call ppp_output_wakeup&n; * at some later time to reactivate flow control in ppp_generic.&n; */
r_static
r_int
DECL|function|ppp_irnet_send
id|ppp_irnet_send
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|irnet_socket
op_star
id|self
op_assign
(paren
r_struct
id|irnet_socket
op_star
)paren
id|chan
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|DENTER
c_func
(paren
id|PPP_TRACE
comma
l_string|&quot;(channel=0x%X, ap/self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|chan
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Check if things are somewhat valid... */
id|DASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
l_int|0
comma
id|PPP_ERROR
comma
l_string|&quot;Self is NULL !!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Check if we are connected */
r_if
c_cond
(paren
id|self-&gt;ttp_open
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef CONNECT_IN_SEND
multiline_comment|/* Let&squot;s try to connect one more time... */
multiline_comment|/* Note : we won&squot;t connect fully yet, but we should be ready for&n;       * next packet... */
multiline_comment|/* Note : we can&squot;t do that, we need to have a process context to&n;       * go through interruptible_sleep_on() in irnet_find_lsap_sel()&n;       * We need to find another way... */
id|irda_irnet_connect
c_func
(paren
id|self
)paren
suffix:semicolon
macro_line|#endif CONNECT_IN_SEND
id|DEBUG
c_func
(paren
id|PPP_INFO
comma
l_string|&quot;IrTTP not ready ! (%d-0x%X)&bslash;n&quot;
comma
id|self-&gt;ttp_open
comma
(paren
r_int
r_int
)paren
id|self-&gt;tsap
)paren
suffix:semicolon
multiline_comment|/* Note : we can either drop the packet or block the packet.&n;       *&n;       * Blocking the packet allow us a better connection time,&n;       * because by calling ppp_output_wakeup() we can have&n;       * ppp_generic resending the LCP request immediately to us,&n;       * rather than waiting for one of pppd periodic transmission of&n;       * LCP request.&n;       *&n;       * On the other hand, if we block all packet, all those periodic&n;       * transmissions of pppd accumulate in ppp_generic, creating a&n;       * backlog of LCP request. When we eventually connect later on,&n;       * we have to transmit all this backlog before we can connect&n;       * proper (if we don&squot;t timeout before).&n;       *&n;       * The current strategy is as follow :&n;       * While we are attempting to connect, we block packets to get&n;       * a better connection time.&n;       * If we fail to connect, we drain the queue and start dropping packets&n;       */
macro_line|#ifdef BLOCK_WHEN_CONNECT
multiline_comment|/* If we are attempting to connect */
r_if
c_cond
(paren
id|self-&gt;tsap
)paren
(brace
multiline_comment|/* Blocking packet, ppp_generic will retry later */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif BLOCK_WHEN_CONNECT
multiline_comment|/* Dropping packet, pppd will retry later */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Check if the queue can accept any packet, otherwise block */
r_if
c_cond
(paren
id|self-&gt;tx_flow
op_ne
id|FLOW_START
)paren
(brace
id|DRETURN
c_func
(paren
l_int|0
comma
id|PPP_INFO
comma
l_string|&quot;IrTTP queue full (%d skbs)...&bslash;n&quot;
comma
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;tsap-&gt;tx_queue
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Prepare ppp frame for transmission */
id|skb
op_assign
id|irnet_prepare_skb
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|DABORT
c_func
(paren
id|skb
op_eq
l_int|NULL
comma
l_int|1
comma
id|PPP_ERROR
comma
l_string|&quot;Prepare skb for Tx failed.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Send the packet to IrTTP */
id|ret
op_assign
id|irttp_data_request
c_func
(paren
id|self-&gt;tsap
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
multiline_comment|/*   &n;       * &gt; IrTTPs tx queue is full, so we just have to&n;       * &gt; drop the frame! You might think that we should&n;       * &gt; just return -1 and don&squot;t deallocate the frame,&n;       * &gt; but that is dangerous since it&squot;s possible that&n;       * &gt; we have replaced the original skb with a new&n;       * &gt; one with larger headroom, and that would really&n;       * &gt; confuse do_dev_queue_xmit() in dev.c! I have&n;       * &gt; tried :-) DB &n;       * Correction : we verify the flow control above (self-&gt;tx_flow),&n;       * so we come here only if IrTTP doesn&squot;t like the packet (empty,&n;       * too large, IrTTP not connected). In those rare cases, it&squot;s ok&n;       * to drop it, we don&squot;t want to see it here again...&n;       * Jean II&n;       */
id|DERROR
c_func
(paren
id|PPP_ERROR
comma
l_string|&quot;IrTTP doesn&squot;t like this packet !!! (0x%X)&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|DEXIT
c_func
(paren
id|PPP_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Packet has been consumed */
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Take care of the ioctls that ppp_generic doesn&squot;t want to deal with...&n; * Note : we are also called from dev_irnet_ioctl().&n; */
r_static
r_int
DECL|function|ppp_irnet_ioctl
id|ppp_irnet_ioctl
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|irnet_socket
op_star
id|ap
op_assign
(paren
r_struct
id|irnet_socket
op_star
)paren
id|chan
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|val
suffix:semicolon
id|u32
id|accm
(braket
l_int|8
)braket
suffix:semicolon
id|DENTER
c_func
(paren
id|PPP_TRACE
comma
l_string|&quot;(channel=0x%X, ap=0x%X, cmd=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|chan
comma
(paren
r_int
r_int
)paren
id|ap
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/* Basic checks... */
id|DASSERT
c_func
(paren
id|ap
op_ne
l_int|NULL
comma
op_minus
id|ENXIO
comma
id|PPP_ERROR
comma
l_string|&quot;ap is NULL...&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/* PPP flags */
r_case
id|PPPIOCGFLAGS
suffix:colon
id|val
op_assign
id|ap-&gt;flags
op_or
id|ap-&gt;rbits
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSFLAGS
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|ap-&gt;flags
op_assign
id|val
op_amp
op_complement
id|SC_RCV_BITS
suffix:semicolon
id|ap-&gt;rbits
op_assign
id|val
op_amp
id|SC_RCV_BITS
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Async map stuff - all dummy to please pppd */
r_case
id|PPPIOCGASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ap-&gt;xaccm
(braket
l_int|0
)braket
comma
(paren
id|u32
op_star
)paren
id|arg
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ap-&gt;xaccm
(braket
l_int|0
)braket
comma
(paren
id|u32
op_star
)paren
id|arg
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGRASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ap-&gt;raccm
comma
(paren
id|u32
op_star
)paren
id|arg
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSRASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ap-&gt;raccm
comma
(paren
id|u32
op_star
)paren
id|arg
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGXASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|ap-&gt;xaccm
comma
r_sizeof
(paren
id|ap-&gt;xaccm
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSXASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|accm
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|accm
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|accm
(braket
l_int|2
)braket
op_and_assign
op_complement
l_int|0x40000000U
suffix:semicolon
multiline_comment|/* can&squot;t escape 0x5e */
id|accm
(braket
l_int|3
)braket
op_or_assign
l_int|0x60000000U
suffix:semicolon
multiline_comment|/* must escape 0x7d, 0x7e */
id|memcpy
c_func
(paren
id|ap-&gt;xaccm
comma
id|accm
comma
r_sizeof
(paren
id|ap-&gt;xaccm
)paren
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Max PPP frame size */
r_case
id|PPPIOCGMRU
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ap-&gt;mru
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSMRU
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|val
OL
id|PPP_MRU
)paren
(brace
id|val
op_assign
id|PPP_MRU
suffix:semicolon
)brace
id|ap-&gt;mru
op_assign
id|val
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
id|PPP_INFO
comma
l_string|&quot;Unsupported ioctl (0x%X)&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
id|DEXIT
c_func
(paren
id|PPP_TRACE
comma
l_string|&quot; - err = 0x%X&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/************************** INITIALISATION **************************/
multiline_comment|/*&n; * Module initialisation and all that jazz...&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Hook our device callbacks in the filesystem, to connect our code&n; * to /dev/irnet&n; */
r_int
DECL|function|ppp_irnet_init
id|ppp_irnet_init
c_func
(paren
r_void
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|DENTER
c_func
(paren
id|MODULE_TRACE
comma
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Allocate ourselves as a minor in the misc range */
id|err
op_assign
id|misc_register
c_func
(paren
op_amp
id|irnet_misc_device
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|MODULE_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Cleanup at exit...&n; */
r_void
DECL|function|ppp_irnet_cleanup
id|ppp_irnet_cleanup
c_func
(paren
r_void
)paren
(brace
id|DENTER
c_func
(paren
id|MODULE_TRACE
comma
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* De-allocate /dev/irnet minor in misc range */
id|misc_deregister
c_func
(paren
op_amp
id|irnet_misc_device
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|MODULE_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Module main entry point&n; */
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
multiline_comment|/* Initialise both parts... */
id|err
op_assign
id|irda_irnet_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|err
op_assign
id|ppp_irnet_init
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Module exit&n; */
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|irda_irnet_cleanup
c_func
(paren
)paren
suffix:semicolon
r_return
id|ppp_irnet_cleanup
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
