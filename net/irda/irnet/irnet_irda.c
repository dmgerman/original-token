multiline_comment|/*&n; *&t;IrNET protocol module : Synchronous PPP over an IrDA socket.&n; *&n; *&t;&t;Jean II - HPL `00 - &lt;jt@hpl.hp.com&gt;&n; *&n; * This file implement the IRDA interface of IrNET.&n; * Basically, we sit on top of IrTTP. We set up IrTTP, IrIAS properly,&n; * and exchange frames with IrTTP.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &quot;irnet_irda.h&quot;&t;&t;/* Private header */
multiline_comment|/************************* CONTROL CHANNEL *************************/
multiline_comment|/*&n; * When ppp is not active, /dev/irnet act as a control channel.&n; * Writting allow to set up the IrDA destination of the IrNET channel,&n; * and any application may be read events happening on IrNET...&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Post an event to the control channel...&n; * Put the event in the log, and then wait all process blocked on read&n; * so they can read the log...&n; */
r_static
r_void
DECL|function|irnet_post_event
id|irnet_post_event
c_func
(paren
id|irnet_socket
op_star
id|ap
comma
id|irnet_event
id|event
comma
id|__u32
id|addr
comma
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* For spinlock */
r_int
id|index
suffix:semicolon
multiline_comment|/* In the log */
id|DENTER
c_func
(paren
id|CTRL_TRACE
comma
l_string|&quot;(ap=0x%X, event=%d, addr=%08x, name=``%s&squot;&squot;)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ap
comma
id|event
comma
id|addr
comma
id|name
)paren
suffix:semicolon
multiline_comment|/* Protect this section via spinlock.&n;   * Note : as we are the only event producer, we only need to exclude&n;   * ourself when touching the log, which is nice and easy.&n;   */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irnet_events.spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Copy the event in the log */
id|index
op_assign
id|irnet_events.index
suffix:semicolon
id|irnet_events.log
(braket
id|index
)braket
dot
id|event
op_assign
id|event
suffix:semicolon
id|irnet_events.log
(braket
id|index
)braket
dot
id|addr
op_assign
id|addr
suffix:semicolon
multiline_comment|/* Try to copy IrDA nickname */
r_if
c_cond
(paren
id|name
)paren
(brace
id|strcpy
c_func
(paren
id|irnet_events.log
(braket
id|index
)braket
dot
id|name
comma
id|name
)paren
suffix:semicolon
)brace
r_else
id|irnet_events.log
(braket
id|index
)braket
dot
id|name
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* Try to get ppp unit number */
r_if
c_cond
(paren
(paren
id|ap
op_ne
(paren
id|irnet_socket
op_star
)paren
l_int|NULL
)paren
op_logical_and
(paren
id|ap-&gt;ppp_open
)paren
)paren
(brace
id|irnet_events.log
(braket
id|index
)braket
dot
id|unit
op_assign
id|ppp_unit_number
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
suffix:semicolon
)brace
r_else
id|irnet_events.log
(braket
id|index
)braket
dot
id|unit
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Increment the index&n;   * Note that we increment the index only after the event is written,&n;   * to make sure that the readers don&squot;t get garbage... */
id|irnet_events.index
op_assign
(paren
id|index
op_plus
l_int|1
)paren
op_mod
id|IRNET_MAX_EVENTS
suffix:semicolon
id|DEBUG
c_func
(paren
id|CTRL_INFO
comma
l_string|&quot;New event index is %d&bslash;n&quot;
comma
id|irnet_events.index
)paren
suffix:semicolon
multiline_comment|/* Spin lock end */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irnet_events.spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Now : wake up everybody waiting for events... */
id|wake_up_interruptible_all
c_func
(paren
op_amp
id|irnet_events.rwait
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|CTRL_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/************************* IRDA SUBROUTINES *************************/
multiline_comment|/*&n; * These are a bunch of subroutines called from other functions&n; * down there, mostly common code or to improve readability...&n; *&n; * Note : we duplicate quite heavily some routines of af_irda.c,&n; * because our input structure (self) is quite different&n; * (struct irnet instead of struct irda_sock), which make sharing&n; * the same code impossible (at least, without templates).&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_open_tsap (self)&n; *&n; *    Open local Transport Service Access Point (TSAP)&n; *&n; * Create a IrTTP instance for us and set all the IrTTP callbacks.&n; */
r_static
r_inline
r_int
DECL|function|irnet_open_tsap
id|irnet_open_tsap
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
id|notify_t
id|notify
suffix:semicolon
multiline_comment|/* Callback structure */
id|DENTER
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
id|DABORT
c_func
(paren
id|self-&gt;tsap
op_ne
l_int|NULL
comma
op_minus
id|EBUSY
comma
id|IRDA_SR_ERROR
comma
l_string|&quot;Already busy !&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Initialize IrTTP callbacks to be used by the IrDA stack */
id|irda_notify_init
c_func
(paren
op_amp
id|notify
)paren
suffix:semicolon
id|notify.connect_confirm
op_assign
id|irnet_connect_confirm
suffix:semicolon
id|notify.connect_indication
op_assign
id|irnet_connect_indication
suffix:semicolon
id|notify.disconnect_indication
op_assign
id|irnet_disconnect_indication
suffix:semicolon
id|notify.data_indication
op_assign
id|irnet_data_indication
suffix:semicolon
multiline_comment|/*notify.udata_indication&t;= NULL;*/
id|notify.flow_indication
op_assign
id|irnet_flow_indication
suffix:semicolon
id|notify.status_indication
op_assign
id|irnet_status_indication
suffix:semicolon
id|notify.instance
op_assign
id|self
suffix:semicolon
id|strncpy
c_func
(paren
id|notify.name
comma
id|IRNET_NOTIFY_NAME
comma
id|NOTIFY_MAX_NAME
)paren
suffix:semicolon
multiline_comment|/* Open an IrTTP instance */
id|self-&gt;tsap
op_assign
id|irttp_open_tsap
c_func
(paren
id|LSAP_ANY
comma
id|DEFAULT_INITIAL_CREDIT
comma
op_amp
id|notify
)paren
suffix:semicolon
id|DABORT
c_func
(paren
id|self-&gt;tsap
op_eq
l_int|NULL
comma
op_minus
id|ENOMEM
comma
id|IRDA_SR_ERROR
comma
l_string|&quot;Unable to allocate TSAP !&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Remember which TSAP selector we actually got */
id|self-&gt;stsap_sel
op_assign
id|self-&gt;tsap-&gt;stsap_sel
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot; - tsap=0x%X, sel=0x%X&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self-&gt;tsap
comma
id|self-&gt;stsap_sel
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_find_lsap_sel (self)&n; *&n; *    Try to lookup LSAP selector in remote LM-IAS&n; *&n; * Basically, we start a IAP query, and then go to sleep. When the query&n; * return, irnet_getvalue_confirm will wake us up, and we can examine the&n; * result of the query...&n; * Note that in some case, the query fail even before we go to sleep,&n; * creating some races...&n; */
r_static
r_int
DECL|function|irnet_find_lsap_sel
id|irnet_find_lsap_sel
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
id|DENTER
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* This should not happen */
id|DABORT
c_func
(paren
id|self-&gt;iriap
comma
op_minus
id|EBUSY
comma
id|IRDA_SR_ERROR
comma
l_string|&quot;busy with a previous query.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Create an IAP instance, will be closed in irnet_getvalue_confirm() */
id|self-&gt;iriap
op_assign
id|iriap_open
c_func
(paren
id|LSAP_ANY
comma
id|IAS_CLIENT
comma
id|self
comma
id|irnet_getvalue_confirm
)paren
suffix:semicolon
multiline_comment|/* Treat unexpected signals as disconnect */
id|self-&gt;errno
op_assign
op_minus
id|EHOSTUNREACH
suffix:semicolon
multiline_comment|/* Query remote LM-IAS */
id|iriap_getvaluebyclass_request
c_func
(paren
id|self-&gt;iriap
comma
id|self-&gt;saddr
comma
id|self-&gt;daddr
comma
id|IRNET_SERVICE_NAME
comma
id|IRNET_IAS_VALUE
)paren
suffix:semicolon
multiline_comment|/* Wait for answer (if not already failed) */
r_if
c_cond
(paren
id|self-&gt;iriap
op_ne
l_int|NULL
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|self-&gt;query_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* Check what happened */
r_if
c_cond
(paren
id|self-&gt;errno
)paren
(brace
id|DEBUG
c_func
(paren
id|IRDA_SR_INFO
comma
l_string|&quot;IAS query failed! (%d)&bslash;n&quot;
comma
id|self-&gt;errno
)paren
suffix:semicolon
multiline_comment|/* Requested object/attribute doesn&squot;t exist */
r_if
c_cond
(paren
(paren
id|self-&gt;errno
op_eq
id|IAS_CLASS_UNKNOWN
)paren
op_logical_or
(paren
id|self-&gt;errno
op_eq
id|IAS_ATTRIB_UNKNOWN
)paren
)paren
(brace
r_return
(paren
op_minus
id|EADDRNOTAVAIL
)paren
suffix:semicolon
)brace
r_else
r_return
(paren
op_minus
id|EHOSTUNREACH
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the remote TSAP selector */
r_switch
c_cond
(paren
id|self-&gt;ias_result-&gt;type
)paren
(brace
r_case
id|IAS_INTEGER
suffix:colon
id|DEBUG
c_func
(paren
id|IRDA_SR_INFO
comma
l_string|&quot;result=%d&bslash;n&quot;
comma
id|self-&gt;ias_result-&gt;t.integer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;ias_result-&gt;t.integer
op_ne
op_minus
l_int|1
)paren
(brace
id|self-&gt;dtsap_sel
op_assign
id|self-&gt;ias_result-&gt;t.integer
suffix:semicolon
)brace
r_else
id|self-&gt;dtsap_sel
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|self-&gt;dtsap_sel
op_assign
l_int|0
suffix:semicolon
id|DERROR
c_func
(paren
id|IRDA_SR_ERROR
comma
l_string|&quot;bad type ! (0x%X)&bslash;n&quot;
comma
id|self-&gt;ias_result-&gt;type
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Cleanup */
r_if
c_cond
(paren
id|self-&gt;ias_result
)paren
(brace
id|irias_delete_value
c_func
(paren
id|self-&gt;ias_result
)paren
suffix:semicolon
)brace
id|DEXIT
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;dtsap_sel
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_discover_daddr_and_lsap_sel (self)&n; *&n; *    This try to find a device with the requested service.&n; *&n; * It basically look into the discovery log. For each address in the list,&n; * it queries the LM-IAS of the device to find if this device offer&n; * the requested service.&n; * If there is more than one node supporting the service, we complain&n; * to the user (it should move devices around).&n; * The, we set both the destination address and the lsap selector to point&n; * on the service on the unique device we have found.&n; *&n; * Note : this function fails if there is more than one device in range,&n; * because IrLMP doesn&squot;t disconnect the LAP when the last LSAP is closed.&n; * Moreover, we would need to wait the LAP disconnection...&n; */
r_static
r_inline
r_int
DECL|function|irnet_discover_daddr_and_lsap_sel
id|irnet_discover_daddr_and_lsap_sel
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
r_struct
id|irda_device_info
op_star
id|discoveries
suffix:semicolon
multiline_comment|/* Copy of the discovery log */
r_int
id|number
suffix:semicolon
multiline_comment|/* Number of nodes in the log */
r_int
id|i
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENETUNREACH
suffix:semicolon
id|__u32
id|daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
multiline_comment|/* Address we found the service on */
id|__u8
id|dtsap_sel
op_assign
l_int|0x0
suffix:semicolon
multiline_comment|/* TSAP associated with it */
id|DENTER
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Ask lmp for the current discovery log&n;   * Note : we have to use irlmp_get_discoveries(), as opposed&n;   * to play with the cachelog directly, because while we are&n;   * making our ias query, le log might change... */
id|discoveries
op_assign
id|irlmp_get_discoveries
c_func
(paren
op_amp
id|number
comma
id|self-&gt;mask
)paren
suffix:semicolon
multiline_comment|/* Check if the we got some results */
r_if
c_cond
(paren
id|discoveries
op_eq
l_int|NULL
)paren
id|DRETURN
c_func
(paren
op_minus
id|ENETUNREACH
comma
id|IRDA_SR_INFO
comma
l_string|&quot;Cachelog empty...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* &n;   * Now, check all discovered devices (if any), and connect&n;   * client only about the services that the client is&n;   * interested in...&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|number
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Try the address in the log */
id|self-&gt;daddr
op_assign
id|discoveries
(braket
id|i
)braket
dot
id|daddr
suffix:semicolon
id|self-&gt;saddr
op_assign
l_int|0x0
suffix:semicolon
id|DEBUG
c_func
(paren
id|IRDA_SR_INFO
comma
l_string|&quot;trying daddr = %08x&bslash;n&quot;
comma
id|self-&gt;daddr
)paren
suffix:semicolon
multiline_comment|/* Query remote LM-IAS for this service */
id|err
op_assign
id|irnet_find_lsap_sel
c_func
(paren
id|self
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|err
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* We found the requested service */
r_if
c_cond
(paren
id|daddr
op_ne
id|DEV_ADDR_ANY
)paren
(brace
id|DEBUG
c_func
(paren
id|IRDA_SR_INFO
comma
l_string|&quot;More than one device in range supports IrNET...&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* First time we found that one, save it ! */
id|daddr
op_assign
id|self-&gt;daddr
suffix:semicolon
id|dtsap_sel
op_assign
id|self-&gt;dtsap_sel
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
op_minus
id|EADDRNOTAVAIL
suffix:colon
multiline_comment|/* Requested service simply doesn&squot;t exist on this node */
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Something bad did happen :-( */
id|DERROR
c_func
(paren
id|IRDA_SR_ERROR
comma
l_string|&quot;unexpected IAS query failure&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
id|kfree
c_func
(paren
id|discoveries
)paren
suffix:semicolon
r_return
op_minus
id|EHOSTUNREACH
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Cleanup our copy of the discovery log */
id|kfree
c_func
(paren
id|discoveries
)paren
suffix:semicolon
multiline_comment|/* Check out what we found */
r_if
c_cond
(paren
id|daddr
op_eq
id|DEV_ADDR_ANY
)paren
(brace
id|self-&gt;daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SR_INFO
comma
l_string|&quot;cannot discover IrNET in any device !!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
)brace
multiline_comment|/* Revert back to discovered device &amp; service */
id|self-&gt;daddr
op_assign
id|daddr
suffix:semicolon
id|self-&gt;saddr
op_assign
l_int|0x0
suffix:semicolon
id|self-&gt;dtsap_sel
op_assign
id|dtsap_sel
suffix:semicolon
id|DEBUG
c_func
(paren
id|IRDA_SR_INFO
comma
l_string|&quot;discovered IrNET at address %08x&bslash;n&quot;
comma
id|self-&gt;daddr
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_dname_to_daddr (self)&n; *&n; *    Convert an IrDA nickname to a valid IrDA address&n; *&n; * It basically look into the discovery log until there is a match.&n; */
r_static
r_inline
r_int
DECL|function|irnet_dname_to_daddr
id|irnet_dname_to_daddr
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
r_struct
id|irda_device_info
op_star
id|discoveries
suffix:semicolon
multiline_comment|/* Copy of the discovery log */
r_int
id|number
suffix:semicolon
multiline_comment|/* Number of nodes in the log */
r_int
id|i
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Ask lmp for the current discovery log */
id|discoveries
op_assign
id|irlmp_get_discoveries
c_func
(paren
op_amp
id|number
comma
l_int|0xffff
)paren
suffix:semicolon
multiline_comment|/* Check if the we got some results */
r_if
c_cond
(paren
id|discoveries
op_eq
l_int|NULL
)paren
(brace
id|DRETURN
c_func
(paren
op_minus
id|ENETUNREACH
comma
id|IRDA_SR_INFO
comma
l_string|&quot;Cachelog empty...&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;   * Now, check all discovered devices (if any), and connect&n;   * client only about the services that the client is&n;   * interested in...&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|number
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Does the name match ? */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|discoveries
(braket
id|i
)braket
dot
id|info
comma
id|self-&gt;rname
comma
id|NICKNAME_MAX_LEN
)paren
)paren
(brace
multiline_comment|/* Yes !!! Get it.. */
id|self-&gt;daddr
op_assign
id|discoveries
(braket
id|i
)braket
dot
id|daddr
suffix:semicolon
id|DEBUG
c_func
(paren
id|IRDA_SR_INFO
comma
l_string|&quot;discovered device ``%s&squot;&squot; at address 0x%08x.&bslash;n&quot;
comma
id|self-&gt;rname
comma
id|self-&gt;daddr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|discoveries
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SR_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* No luck ! */
id|DEBUG
c_func
(paren
id|IRDA_SR_INFO
comma
l_string|&quot;cannot discover device ``%s&squot;&squot; !!!&bslash;n&quot;
comma
id|self-&gt;rname
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|discoveries
)paren
suffix:semicolon
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
)brace
multiline_comment|/************************* SOCKET ROUTINES *************************/
multiline_comment|/*&n; * This are the main operations on IrNET sockets, basically to create&n; * and destroy IrNET sockets. These are called from the PPP part...&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Create a IrNET instance : just initialise some parameters...&n; */
r_int
DECL|function|irda_irnet_create
id|irda_irnet_create
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
id|DENTER
c_func
(paren
id|IRDA_SOCK_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
id|self-&gt;magic
op_assign
id|IRNET_MAGIC
suffix:semicolon
multiline_comment|/* Paranoia */
id|init_waitqueue_head
c_func
(paren
op_amp
id|self-&gt;query_wait
)paren
suffix:semicolon
id|self-&gt;ttp_open
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Prevent higher layer from accessing IrTTP */
id|self-&gt;rname
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* May be set via control channel */
id|self-&gt;raddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
multiline_comment|/* May be set via control channel */
id|self-&gt;daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
multiline_comment|/* Until we get connected */
id|self-&gt;saddr
op_assign
l_int|0x0
suffix:semicolon
multiline_comment|/* so IrLMP assign us any link */
id|self-&gt;max_sdu_size_rx
op_assign
id|TTP_SAR_UNBOUND
suffix:semicolon
multiline_comment|/* Register as a client with IrLMP */
id|self-&gt;ckey
op_assign
id|irlmp_register_client
c_func
(paren
l_int|0
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef DISCOVERY_NOMASK
id|self-&gt;mask
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* For W2k compatibility */
macro_line|#else DISCOVERY_NOMASK
id|self-&gt;mask
op_assign
id|irlmp_service_to_hint
c_func
(paren
id|S_LAN
)paren
suffix:semicolon
macro_line|#endif DISCOVERY_NOMASK
id|self-&gt;tx_flow
op_assign
id|FLOW_START
suffix:semicolon
multiline_comment|/* Flow control from IrTTP */
id|DEXIT
c_func
(paren
id|IRDA_SOCK_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Connect to the other side :&n; *&t;o convert device name to an address&n; *&t;o find the socket number (dlsap)&n; *&t;o Establish the connection&n; */
r_int
DECL|function|irda_irnet_connect
id|irda_irnet_connect
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
r_int
id|err
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_SOCK_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Check if we have opened a local TSAP :&n;   * If we have already opened a TSAP, it means that either we are already&n;   * connected or in the process of doing so... */
r_if
c_cond
(paren
id|self-&gt;tsap
op_ne
l_int|NULL
)paren
(brace
id|DRETURN
c_func
(paren
op_minus
id|EBUSY
comma
id|IRDA_SOCK_INFO
comma
l_string|&quot;Already connecting...&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Insert ourselves in the hashbin so that the IrNET server can find us.&n;   * Notes : 4th arg is string of 32 char max and must be null terminated&n;   *&t;     When 4th arg is used (string), 3rd arg isn&squot;t (int)&n;   *&t;     Can&squot;t re-insert (MUST remove first) so check for that... */
r_if
c_cond
(paren
(paren
id|irnet_server.running
)paren
op_logical_and
(paren
id|self-&gt;q.q_next
op_eq
l_int|NULL
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irnet_server.spinlock
comma
id|flags
)paren
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|irnet_server.list
comma
(paren
id|irda_queue_t
op_star
)paren
id|self
comma
l_int|0
comma
id|self-&gt;rname
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irnet_server.spinlock
comma
id|flags
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|IRDA_SOCK_INFO
comma
l_string|&quot;Inserted ``%s&squot;&squot; in hashbin...&bslash;n&quot;
comma
id|self-&gt;rname
)paren
suffix:semicolon
)brace
multiline_comment|/* If we don&squot;t have anything (no address, no name) */
r_if
c_cond
(paren
(paren
id|self-&gt;raddr
op_eq
id|DEV_ADDR_ANY
)paren
op_logical_and
(paren
id|self-&gt;rname
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
)paren
(brace
multiline_comment|/* Try to find a suitable address */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|irnet_discover_daddr_and_lsap_sel
c_func
(paren
id|self
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|DRETURN
c_func
(paren
id|err
comma
id|IRDA_SOCK_INFO
comma
l_string|&quot;auto-connect failed!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* If we have only the name (no address), try to get an address */
r_if
c_cond
(paren
id|self-&gt;raddr
op_eq
id|DEV_ADDR_ANY
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|irnet_dname_to_daddr
c_func
(paren
id|self
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|DRETURN
c_func
(paren
id|err
comma
id|IRDA_SOCK_INFO
comma
l_string|&quot;name-connect failed!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* Use the requested destination address */
id|self-&gt;daddr
op_assign
id|self-&gt;raddr
suffix:semicolon
multiline_comment|/* Query remote LM-IAS to find LSAP selector */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|irnet_find_lsap_sel
c_func
(paren
id|self
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|DRETURN
c_func
(paren
id|err
comma
id|IRDA_SOCK_INFO
comma
l_string|&quot;connect failed!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|DEBUG
c_func
(paren
id|IRDA_SOCK_INFO
comma
l_string|&quot;daddr = %08x, lsap = %d, starting IrTTP connection&bslash;n&quot;
comma
id|self-&gt;daddr
comma
id|self-&gt;dtsap_sel
)paren
suffix:semicolon
multiline_comment|/* Open a local TSAP (an IrTTP instance) */
id|err
op_assign
id|irnet_open_tsap
c_func
(paren
id|self
)paren
suffix:semicolon
id|DABORT
c_func
(paren
id|err
op_ne
l_int|0
comma
id|err
comma
id|IRDA_SOCK_ERROR
comma
l_string|&quot;connect aborted!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Connect to remote device */
id|err
op_assign
id|irttp_connect_request
c_func
(paren
id|self-&gt;tsap
comma
id|self-&gt;dtsap_sel
comma
id|self-&gt;saddr
comma
id|self-&gt;daddr
comma
l_int|NULL
comma
id|self-&gt;max_sdu_size_rx
comma
l_int|NULL
)paren
suffix:semicolon
id|DABORT
c_func
(paren
id|err
op_ne
l_int|0
comma
id|err
comma
id|IRDA_SOCK_ERROR
comma
l_string|&quot;connect aborted!&bslash;n&quot;
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SOCK_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_irnet_destroy(self)&n; *&n; *    Destroy irnet instance&n; *&n; */
r_void
DECL|function|irda_irnet_destroy
id|irda_irnet_destroy
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
id|DENTER
c_func
(paren
id|IRDA_SOCK_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Remove ourselves from hashbin (if we are queued in hashbin)&n;   * Note : `irnet_server.running&squot; protect us from calls in hashbin_delete() */
r_if
c_cond
(paren
(paren
id|irnet_server.running
)paren
op_logical_and
(paren
id|self-&gt;q.q_next
op_ne
l_int|NULL
)paren
)paren
(brace
r_struct
id|irnet_socket
op_star
id|entry
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DEBUG
c_func
(paren
id|IRDA_SOCK_INFO
comma
l_string|&quot;Removing from hash..&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irnet_server.spinlock
comma
id|flags
)paren
suffix:semicolon
id|entry
op_assign
id|hashbin_remove_this
c_func
(paren
id|irnet_server.list
comma
(paren
id|irda_queue_t
op_star
)paren
id|self
)paren
suffix:semicolon
id|self-&gt;q.q_next
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irnet_server.spinlock
comma
id|flags
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|entry
op_eq
id|self
comma
comma
id|IRDA_SOCK_ERROR
comma
l_string|&quot;Can&squot;t remove from hash.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Unregister with IrLMP */
id|irlmp_unregister_client
c_func
(paren
id|self-&gt;ckey
)paren
suffix:semicolon
multiline_comment|/* Unregister with LM-IAS */
r_if
c_cond
(paren
id|self-&gt;iriap
)paren
(brace
id|iriap_close
c_func
(paren
id|self-&gt;iriap
)paren
suffix:semicolon
)brace
multiline_comment|/* Prevent higher layer from accessing IrTTP */
id|self-&gt;ttp_open
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Close our IrTTP connection */
r_if
c_cond
(paren
id|self-&gt;tsap
)paren
(brace
id|DEBUG
c_func
(paren
id|IRDA_SOCK_INFO
comma
l_string|&quot;Closing our TTP connection.&bslash;n&quot;
)paren
suffix:semicolon
id|irttp_disconnect_request
c_func
(paren
id|self-&gt;tsap
comma
l_int|NULL
comma
id|P_NORMAL
)paren
suffix:semicolon
id|irttp_close_tsap
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
id|self-&gt;tsap
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Note : as the disconnect comes from ppp_generic, the unit number&n;       * doesn&squot;t exist anymore when we post the event, so we need to pass&n;       * NULL as the first arg... */
id|irnet_post_event
c_func
(paren
l_int|NULL
comma
id|IRNET_DISCONNECT_TO
comma
id|self-&gt;daddr
comma
id|self-&gt;rname
)paren
suffix:semicolon
)brace
id|self-&gt;stsap_sel
op_assign
l_int|0
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SOCK_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/************************** SERVER SOCKET **************************/
multiline_comment|/*&n; * The IrNET service is composed of one server socket and a variable&n; * number of regular IrNET sockets. The server socket is supposed to&n; * handle incomming connections and redirect them to one IrNET sockets.&n; * It&squot;s a superset of the regular IrNET socket, but has a very distinct&n; * behaviour...&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_daddr_to_dname (self)&n; *&n; *    Convert an IrDA address to a IrDA nickname&n; *&n; * It basically look into the discovery log until there is a match.&n; */
r_static
r_inline
r_int
DECL|function|irnet_daddr_to_dname
id|irnet_daddr_to_dname
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
r_struct
id|irda_device_info
op_star
id|discoveries
suffix:semicolon
multiline_comment|/* Copy of the discovery log */
r_int
id|number
suffix:semicolon
multiline_comment|/* Number of nodes in the log */
r_int
id|i
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Ask lmp for the current discovery log */
id|discoveries
op_assign
id|irlmp_get_discoveries
c_func
(paren
op_amp
id|number
comma
l_int|0xffff
)paren
suffix:semicolon
multiline_comment|/* Check if the we got some results */
r_if
c_cond
(paren
id|discoveries
op_eq
l_int|NULL
)paren
id|DRETURN
c_func
(paren
op_minus
id|ENETUNREACH
comma
id|IRDA_SERV_INFO
comma
l_string|&quot;Cachelog empty...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Now, check all discovered devices (if any) */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|number
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Does the name match ? */
r_if
c_cond
(paren
id|discoveries
(braket
id|i
)braket
dot
id|daddr
op_eq
id|self-&gt;daddr
)paren
(brace
multiline_comment|/* Yes !!! Get it.. */
id|strncpy
c_func
(paren
id|self-&gt;rname
comma
id|discoveries
(braket
id|i
)braket
dot
id|info
comma
id|NICKNAME_MAX_LEN
)paren
suffix:semicolon
id|self-&gt;rname
(braket
id|NICKNAME_MAX_LEN
op_plus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|DEBUG
c_func
(paren
id|IRDA_SERV_INFO
comma
l_string|&quot;Device 0x%08x is in fact ``%s&squot;&squot;.&bslash;n&quot;
comma
id|self-&gt;daddr
comma
id|self-&gt;rname
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|discoveries
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* No luck ! */
id|DEXIT
c_func
(paren
id|IRDA_SERV_INFO
comma
l_string|&quot;: cannot discover device 0x%08x !!!&bslash;n&quot;
comma
id|self-&gt;daddr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|discoveries
)paren
suffix:semicolon
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_find_socket (self)&n; *&n; *    Find the correct IrNET socket&n; *&n; * Look into the list of IrNET sockets and finds one with the right&n; * properties...&n; */
r_static
r_inline
id|irnet_socket
op_star
DECL|function|irnet_find_socket
id|irnet_find_socket
c_func
(paren
id|irnet_socket
op_star
id|self
)paren
(brace
id|irnet_socket
op_star
r_new
op_assign
(paren
id|irnet_socket
op_star
)paren
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|err
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Get the address of the requester */
id|self-&gt;daddr
op_assign
id|irttp_get_daddr
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
multiline_comment|/* Try to get the IrDA nickname of the requester */
id|err
op_assign
id|irnet_daddr_to_dname
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Protect access to the instance list */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irnet_server.spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* So now, try to get an socket having specifically&n;   * requested that nickname */
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
(brace
r_new
op_assign
(paren
id|irnet_socket
op_star
)paren
id|hashbin_find
c_func
(paren
id|irnet_server.list
comma
l_int|0
comma
id|self-&gt;rname
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
)paren
(brace
id|DEBUG
c_func
(paren
id|IRDA_SERV_INFO
comma
l_string|&quot;Socket 0x%X matches rname ``%s&squot;&squot;.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
r_new
comma
r_new
op_member_access_from_pointer
id|rname
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* If no name matches, try to find an socket by the destination address */
multiline_comment|/* It can be either the requested destination address (set via the&n;   * control channel), or the current destination address if the&n;   * socket is in the middle of a connection request */
r_if
c_cond
(paren
r_new
op_eq
(paren
id|irnet_socket
op_star
)paren
l_int|NULL
)paren
(brace
r_new
op_assign
(paren
id|irnet_socket
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irnet_server.list
)paren
suffix:semicolon
r_while
c_loop
(paren
r_new
op_ne
(paren
id|irnet_socket
op_star
)paren
l_int|NULL
)paren
(brace
multiline_comment|/* Does it have the same address ? */
r_if
c_cond
(paren
(paren
r_new
op_member_access_from_pointer
id|raddr
op_eq
id|self-&gt;daddr
)paren
op_logical_or
(paren
r_new
op_member_access_from_pointer
id|daddr
op_eq
id|self-&gt;daddr
)paren
)paren
(brace
multiline_comment|/* Yes !!! Get it.. */
id|DEBUG
c_func
(paren
id|IRDA_SERV_INFO
comma
l_string|&quot;Socket 0x%X matches daddr %#08x.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
r_new
comma
id|self-&gt;daddr
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_new
op_assign
(paren
id|irnet_socket
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irnet_server.list
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* If we don&squot;t have any socket, get the first unconnected socket */
r_if
c_cond
(paren
r_new
op_eq
(paren
id|irnet_socket
op_star
)paren
l_int|NULL
)paren
(brace
r_new
op_assign
(paren
id|irnet_socket
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irnet_server.list
)paren
suffix:semicolon
r_while
c_loop
(paren
r_new
op_ne
(paren
id|irnet_socket
op_star
)paren
l_int|NULL
)paren
(brace
multiline_comment|/* Is it available ? */
r_if
c_cond
(paren
op_logical_neg
(paren
r_new
op_member_access_from_pointer
id|ttp_open
)paren
op_logical_and
(paren
r_new
op_member_access_from_pointer
id|raddr
op_eq
id|DEV_ADDR_ANY
)paren
op_logical_and
(paren
r_new
op_member_access_from_pointer
id|rname
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
op_logical_and
(paren
r_new
op_member_access_from_pointer
id|ppp_open
)paren
)paren
(brace
multiline_comment|/* Yes !!! Get it.. */
id|DEBUG
c_func
(paren
id|IRDA_SERV_INFO
comma
l_string|&quot;Socket 0x%X is free.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
r_new
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_new
op_assign
(paren
id|irnet_socket
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irnet_server.list
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Spin lock end */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irnet_server.spinlock
comma
id|flags
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot; - new = 0x%X&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
r_new
)paren
suffix:semicolon
r_return
r_new
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_connect_socket (self)&n; *&n; *    Connect an incomming connection to the socket&n; *&n; */
r_static
r_inline
r_int
DECL|function|irnet_connect_socket
id|irnet_connect_socket
c_func
(paren
id|irnet_socket
op_star
id|self
comma
id|irnet_socket
op_star
r_new
comma
r_struct
id|qos_info
op_star
id|qos
comma
id|__u32
id|max_sdu_size
comma
id|__u8
id|max_header_size
)paren
(brace
id|DENTER
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;(self=0x%X, new=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
comma
(paren
r_int
r_int
)paren
r_new
)paren
suffix:semicolon
multiline_comment|/* Now attach up the new socket */
r_new
op_member_access_from_pointer
id|tsap
op_assign
id|irttp_dup
c_func
(paren
id|self-&gt;tsap
comma
r_new
)paren
suffix:semicolon
id|DABORT
c_func
(paren
r_new
op_member_access_from_pointer
id|tsap
op_eq
l_int|NULL
comma
op_minus
l_int|1
comma
id|IRDA_SERV_ERROR
comma
l_string|&quot;dup failed!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Set up all the relevant parameters on the new socket */
r_new
op_member_access_from_pointer
id|stsap_sel
op_assign
r_new
op_member_access_from_pointer
id|tsap-&gt;stsap_sel
suffix:semicolon
r_new
op_member_access_from_pointer
id|dtsap_sel
op_assign
r_new
op_member_access_from_pointer
id|tsap-&gt;dtsap_sel
suffix:semicolon
r_new
op_member_access_from_pointer
id|saddr
op_assign
id|irttp_get_saddr
c_func
(paren
r_new
op_member_access_from_pointer
id|tsap
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|daddr
op_assign
id|irttp_get_daddr
c_func
(paren
r_new
op_member_access_from_pointer
id|tsap
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|max_header_size
op_assign
id|max_header_size
suffix:semicolon
r_new
op_member_access_from_pointer
id|max_sdu_size_tx
op_assign
id|max_sdu_size
suffix:semicolon
r_new
op_member_access_from_pointer
id|max_data_size
op_assign
id|max_sdu_size
suffix:semicolon
macro_line|#ifdef STREAM_COMPAT
multiline_comment|/* If we want to receive &quot;stream sockets&quot; */
r_if
c_cond
(paren
id|max_sdu_size
op_eq
l_int|0
)paren
(brace
r_new
op_member_access_from_pointer
id|max_data_size
op_assign
id|irttp_get_max_seg_size
c_func
(paren
r_new
op_member_access_from_pointer
id|tsap
)paren
suffix:semicolon
)brace
macro_line|#endif STREAM_COMPAT
multiline_comment|/* Clean up the original one to keep it in listen state */
id|self-&gt;tsap-&gt;dtsap_sel
op_assign
id|self-&gt;tsap-&gt;lsap-&gt;dlsap_sel
op_assign
id|LSAP_ANY
suffix:semicolon
id|self-&gt;tsap-&gt;lsap-&gt;lsap_state
op_assign
id|LSAP_DISCONNECTED
suffix:semicolon
multiline_comment|/* Send a connection response on the new socket */
id|irttp_connect_response
c_func
(paren
r_new
op_member_access_from_pointer
id|tsap
comma
r_new
op_member_access_from_pointer
id|max_sdu_size_rx
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Allow PPP to send its junk over the new socket... */
r_new
op_member_access_from_pointer
id|ttp_open
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONNECT_INDIC_KICK
multiline_comment|/* As currently we don&squot;t packets in ppp_irnet_send(), this is not needed...&n;   * Also, not doing it give IrDA a chance to finish the setup properly&n;   * before beeing swamped with packets... */
id|ppp_output_wakeup
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|chan
)paren
suffix:semicolon
macro_line|#endif CONNECT_INDIC_KICK
multiline_comment|/* Notify the control channel */
id|irnet_post_event
c_func
(paren
r_new
comma
id|IRNET_CONNECT_FROM
comma
r_new
op_member_access_from_pointer
id|daddr
comma
id|self-&gt;rname
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_disconnect_server (self)&n; *&n; *    Cleanup the server socket when the incomming connection abort&n; *&n; */
r_static
r_inline
r_void
DECL|function|irnet_disconnect_server
id|irnet_disconnect_server
c_func
(paren
id|irnet_socket
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|DENTER
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Put the received packet in the black hole */
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#ifdef FAIL_SEND_DISCONNECT
multiline_comment|/* Tell the other party we don&squot;t want to be connected */
multiline_comment|/* Hum... Is it the right thing to do ? And do we need to send&n;   * a connect response before ? It looks ok without this... */
id|irttp_disconnect_request
c_func
(paren
id|self-&gt;tsap
comma
l_int|NULL
comma
id|P_NORMAL
)paren
suffix:semicolon
macro_line|#endif FAIL_SEND_DISCONNECT
multiline_comment|/* Clean up the server to keep it in listen state */
id|self-&gt;tsap-&gt;dtsap_sel
op_assign
id|self-&gt;tsap-&gt;lsap-&gt;dlsap_sel
op_assign
id|LSAP_ANY
suffix:semicolon
id|self-&gt;tsap-&gt;lsap-&gt;lsap_state
op_assign
id|LSAP_DISCONNECTED
suffix:semicolon
multiline_comment|/* Notify the control channel */
id|irnet_post_event
c_func
(paren
l_int|NULL
comma
id|IRNET_REQUEST_FROM
comma
id|self-&gt;daddr
comma
id|self-&gt;rname
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_setup_server (self)&n; *&n; *    Create a IrTTP server and set it up...&n; *&n; * Register the IrLAN hint bit, create a IrTTP instance for us,&n; * set all the IrTTP callbacks and create an IrIAS entry...&n; */
r_static
r_inline
r_int
DECL|function|irnet_setup_server
id|irnet_setup_server
c_func
(paren
r_void
)paren
(brace
id|__u16
id|hints
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Initialise the regular socket part of the server */
id|irda_irnet_create
c_func
(paren
op_amp
id|irnet_server.s
)paren
suffix:semicolon
multiline_comment|/* Open a local TSAP (an IrTTP instance) for the server */
id|irnet_open_tsap
c_func
(paren
op_amp
id|irnet_server.s
)paren
suffix:semicolon
multiline_comment|/* PPP part setup */
id|irnet_server.s.ppp_open
op_assign
l_int|0
suffix:semicolon
id|irnet_server.s.chan
dot
r_private
op_assign
l_int|NULL
suffix:semicolon
id|irnet_server.s.file
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Get the hint bit corresponding to IrLAN */
multiline_comment|/* Note : we overload the IrLAN hint bit. As it is only a &quot;hint&quot;, and as&n;   * we provide roughly the same functionality as IrLAN, this is ok.&n;   * In fact, the situation is similar as JetSend overloading the Obex hint&n;   */
id|hints
op_assign
id|irlmp_service_to_hint
c_func
(paren
id|S_LAN
)paren
suffix:semicolon
macro_line|#ifdef ADVERTISE_HINT
multiline_comment|/* Register with IrLMP as a service (advertise our hint bit) */
id|irnet_server.skey
op_assign
id|irlmp_register_service
c_func
(paren
id|hints
)paren
suffix:semicolon
macro_line|#endif ADVERTISE_HINT
multiline_comment|/* Register with LM-IAS (so that people can connect to us) */
id|irnet_server.ias_obj
op_assign
id|irias_new_object
c_func
(paren
id|IRNET_SERVICE_NAME
comma
id|jiffies
)paren
suffix:semicolon
id|irias_add_integer_attrib
c_func
(paren
id|irnet_server.ias_obj
comma
id|IRNET_IAS_VALUE
comma
id|irnet_server.s.stsap_sel
comma
id|IAS_KERNEL_ATTR
)paren
suffix:semicolon
id|irias_insert_object
c_func
(paren
id|irnet_server.ias_obj
)paren
suffix:semicolon
macro_line|#ifdef DISCOVERY_EVENTS
multiline_comment|/* Tell IrLMP we want to be notified of newly discovered nodes */
id|irlmp_update_client
c_func
(paren
id|irnet_server.s.ckey
comma
id|hints
comma
id|irnet_discovery_indication
comma
id|irnet_expiry_indication
comma
(paren
r_void
op_star
)paren
op_amp
id|irnet_server.s
)paren
suffix:semicolon
macro_line|#endif
id|DEXIT
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot; - self=0x%X&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
op_amp
id|irnet_server.s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_destroy_server (self)&n; *&n; *    Destroy the IrTTP server...&n; *&n; * Reverse of the previous function...&n; */
r_static
r_inline
r_void
DECL|function|irnet_destroy_server
id|irnet_destroy_server
c_func
(paren
r_void
)paren
(brace
id|DENTER
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef ADVERTISE_HINT
multiline_comment|/* Unregister with IrLMP */
id|irlmp_unregister_service
c_func
(paren
id|irnet_server.skey
)paren
suffix:semicolon
macro_line|#endif ADVERTISE_HINT
multiline_comment|/* Unregister with LM-IAS */
r_if
c_cond
(paren
id|irnet_server.ias_obj
)paren
(brace
id|irias_delete_object
c_func
(paren
id|irnet_server.ias_obj
)paren
suffix:semicolon
)brace
multiline_comment|/* Cleanup the socket part */
id|irda_irnet_destroy
c_func
(paren
op_amp
id|irnet_server.s
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_SERV_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/************************ IRDA-TTP CALLBACKS ************************/
multiline_comment|/*&n; * When we create a IrTTP instance, we pass to it a set of callbacks&n; * that IrTTP will call in case of various events.&n; * We take care of those events here.&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_data_indication (instance, sap, skb)&n; *&n; *    Received some data from TinyTP. Just queue it on the receive queue&n; *&n; */
r_static
r_int
DECL|function|irnet_data_indication
id|irnet_data_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|irnet_socket
op_star
id|ap
op_assign
(paren
id|irnet_socket
op_star
)paren
id|instance
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
id|code
op_assign
l_int|0
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;(self/ap=0x%X, skb=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ap
comma
(paren
r_int
r_int
)paren
id|skb
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
l_int|0
comma
id|IRDA_CB_ERROR
comma
l_string|&quot;skb is NULL !!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Check is ppp is ready to receive our packet */
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;ppp_open
)paren
(brace
id|DERROR
c_func
(paren
id|IRDA_CB_ERROR
comma
l_string|&quot;PPP not ready, dropping packet...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* When we return error, TTP will need to requeue the skb and&n;       * will stop the sender. IrTTP will stall until we send it a&n;       * flow control request... */
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* strip address/control field if present */
id|p
op_assign
id|skb-&gt;data
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p
(braket
l_int|0
)braket
op_eq
id|PPP_ALLSTATIONS
)paren
op_logical_and
(paren
id|p
(braket
l_int|1
)braket
op_eq
id|PPP_UI
)paren
)paren
(brace
multiline_comment|/* chop off address/control */
r_if
c_cond
(paren
id|skb-&gt;len
OL
l_int|3
)paren
(brace
r_goto
id|err_exit
suffix:semicolon
)brace
id|p
op_assign
id|skb_pull
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* decompress protocol field if compressed */
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_amp
l_int|1
)paren
(brace
multiline_comment|/* protocol is compressed */
id|skb_push
c_func
(paren
id|skb
comma
l_int|1
)paren
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|skb-&gt;len
OL
l_int|2
)paren
(brace
r_goto
id|err_exit
suffix:semicolon
)brace
multiline_comment|/* pass to generic ppp layer */
multiline_comment|/* Note : how do I know if ppp can accept or not the packet ? This is&n;   * essential if I want to manage flow control smoothly... */
id|ppp_input
c_func
(paren
op_amp
id|ap-&gt;chan
comma
id|skb
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_exit
suffix:colon
id|DERROR
c_func
(paren
id|IRDA_CB_ERROR
comma
l_string|&quot;Packet too small, dropping...&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ppp_input_error
c_func
(paren
op_amp
id|ap-&gt;chan
comma
id|code
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Don&squot;t return an error code, only for flow control... */
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_disconnect_indication (instance, sap, reason, skb)&n; *&n; *    Connection has been closed. Chech reason to find out why&n; *&n; * Note : there are many cases where we come here :&n; *&t;o attempted to connect, timeout&n; *&t;o connected, link is broken, LAP has timeout&n; *&t;o connected, other side close the link&n; *&t;o connection request on the server no handled&n; */
r_static
r_void
DECL|function|irnet_disconnect_indication
id|irnet_disconnect_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
id|LM_REASON
id|reason
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|irnet_socket
op_star
id|self
op_assign
(paren
id|irnet_socket
op_star
)paren
id|instance
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
comma
id|IRDA_CB_ERROR
comma
l_string|&quot;Self is NULL !!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* If we were active, notify the control channel */
r_if
c_cond
(paren
id|self-&gt;ttp_open
)paren
(brace
id|irnet_post_event
c_func
(paren
id|self
comma
id|IRNET_DISCONNECT_FROM
comma
id|self-&gt;daddr
comma
id|self-&gt;rname
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* If we were trying to connect, notify the control channel */
r_if
c_cond
(paren
(paren
id|self-&gt;tsap
)paren
op_logical_and
(paren
id|self
op_ne
op_amp
id|irnet_server.s
)paren
)paren
(brace
id|irnet_post_event
c_func
(paren
id|self
comma
id|IRNET_NOANSWER_FROM
comma
id|self-&gt;daddr
comma
id|self-&gt;rname
)paren
suffix:semicolon
)brace
multiline_comment|/* Prevent higher layer from accessing IrTTP */
id|self-&gt;ttp_open
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Close our IrTTP connection */
r_if
c_cond
(paren
(paren
id|self-&gt;tsap
)paren
op_logical_and
(paren
id|self
op_ne
op_amp
id|irnet_server.s
)paren
)paren
(brace
id|DEBUG
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;Closing our TTP connection.&bslash;n&quot;
)paren
suffix:semicolon
id|irttp_disconnect_request
c_func
(paren
id|self-&gt;tsap
comma
l_int|NULL
comma
id|P_NORMAL
)paren
suffix:semicolon
id|irttp_close_tsap
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
id|self-&gt;tsap
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Flush (drain) ppp_generic Tx queue (most often we have blocked it) */
r_if
c_cond
(paren
id|self-&gt;ppp_open
)paren
(brace
id|ppp_output_wakeup
c_func
(paren
op_amp
id|self-&gt;chan
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Cleanup the socket in case we want to reconnect */
id|self-&gt;stsap_sel
op_assign
l_int|0
suffix:semicolon
id|self-&gt;daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
id|self-&gt;tx_flow
op_assign
id|FLOW_START
suffix:semicolon
multiline_comment|/* Note : what should we say to ppp ?&n;   * It seem the ppp_generic and pppd are happy that way and will eventually&n;   * timeout gracefully, so don&squot;t bother them... */
id|DEXIT
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_connect_confirm (instance, sap, qos, max_sdu_size, skb)&n; *&n; *    Connections has been confirmed by the remote device&n; *&n; */
r_static
r_void
DECL|function|irnet_connect_confirm
id|irnet_connect_confirm
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|qos_info
op_star
id|qos
comma
id|__u32
id|max_sdu_size
comma
id|__u8
id|max_header_size
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|irnet_socket
op_star
id|self
op_assign
(paren
id|irnet_socket
op_star
)paren
id|instance
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* How much header space do we need to reserve */
id|self-&gt;max_header_size
op_assign
id|max_header_size
suffix:semicolon
multiline_comment|/* IrTTP max SDU size in transmit direction */
id|self-&gt;max_sdu_size_tx
op_assign
id|max_sdu_size
suffix:semicolon
id|self-&gt;max_data_size
op_assign
id|max_sdu_size
suffix:semicolon
macro_line|#ifdef STREAM_COMPAT
r_if
c_cond
(paren
id|max_sdu_size
op_eq
l_int|0
)paren
(brace
id|self-&gt;max_data_size
op_assign
id|irttp_get_max_seg_size
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
)brace
macro_line|#endif STREAM_COMPAT
multiline_comment|/* At this point, IrLMP has assigned our source address */
id|self-&gt;saddr
op_assign
id|irttp_get_saddr
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
multiline_comment|/* Allow higher layer to access IrTTP */
id|self-&gt;ttp_open
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Give a kick in the ass of ppp_generic so that he sends us some data */
id|ppp_output_wakeup
c_func
(paren
op_amp
id|self-&gt;chan
)paren
suffix:semicolon
multiline_comment|/* Check size of received packet */
r_if
c_cond
(paren
id|skb-&gt;len
OG
l_int|0
)paren
(brace
macro_line|#ifdef PASS_CONNECT_PACKETS
id|DEBUG
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;Passing connect packet to PPP.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Try to pass it to PPP */
id|irnet_data_indication
c_func
(paren
id|instance
comma
id|sap
comma
id|skb
)paren
suffix:semicolon
macro_line|#else PASS_CONNECT_PACKETS
id|DERROR
c_func
(paren
id|IRDA_CB_ERROR
comma
l_string|&quot;Dropping non empty packet.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Note : will be optimised with other kfree... */
macro_line|#endif PASS_CONNECT_PACKETS
)brace
r_else
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Notify the control channel */
id|irnet_post_event
c_func
(paren
id|self
comma
id|IRNET_CONNECT_TO
comma
id|self-&gt;daddr
comma
id|self-&gt;rname
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_flow_indication (instance, sap, flow)&n; *&n; *    Used by TinyTP to tell us if it can accept more data or not&n; *&n; */
r_static
r_void
DECL|function|irnet_flow_indication
id|irnet_flow_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
id|LOCAL_FLOW
id|flow
)paren
(brace
id|irnet_socket
op_star
id|self
op_assign
(paren
id|irnet_socket
op_star
)paren
id|instance
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;(self=0x%X, flow=%d)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
comma
id|flow
)paren
suffix:semicolon
multiline_comment|/* Update our state */
id|self-&gt;tx_flow
op_assign
id|flow
suffix:semicolon
multiline_comment|/* Check what IrTTP want us to do... */
r_switch
c_cond
(paren
id|flow
)paren
(brace
r_case
id|FLOW_START
suffix:colon
id|DEBUG
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;IrTTP wants us to start again&bslash;n&quot;
)paren
suffix:semicolon
id|ppp_output_wakeup
c_func
(paren
op_amp
id|self-&gt;chan
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLOW_STOP
suffix:colon
id|DEBUG
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;IrTTP wants us to slow down&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;Unknown flow command!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|DEXIT
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_status_indication (instance, sap, reason, skb)&n; *&n; *    Link (IrLAP) status report.&n; *&n; */
r_static
r_void
DECL|function|irnet_status_indication
id|irnet_status_indication
c_func
(paren
r_void
op_star
id|instance
comma
id|LINK_STATUS
id|link
comma
id|LOCK_STATUS
id|lock
)paren
(brace
id|irnet_socket
op_star
id|self
op_assign
(paren
id|irnet_socket
op_star
)paren
id|instance
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
comma
id|IRDA_CB_ERROR
comma
l_string|&quot;Self is NULL !!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* We can only get this event if we are connected */
r_switch
c_cond
(paren
id|link
)paren
(brace
r_case
id|STATUS_NO_ACTIVITY
suffix:colon
id|irnet_post_event
c_func
(paren
id|self
comma
id|IRNET_BLOCKED_LINK
comma
id|self-&gt;daddr
comma
id|self-&gt;rname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;Unknown status...&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|DEXIT
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_connect_indication(instance, sap, qos, max_sdu_size, userdata)&n; *&n; *    Incomming connection&n; *&n; * In theory, this function is called only on the server socket.&n; * Some other node is attempting to connect to the IrNET service, and has&n; * sent a connection request on our server socket.&n; * We just redirect the connection to the relevant IrNET socket.&n; * &n; * Note : we also make sure that between 2 irnet nodes, there can&n; * exist only one irnet connection.&n; */
r_static
r_void
DECL|function|irnet_connect_indication
id|irnet_connect_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|qos_info
op_star
id|qos
comma
id|__u32
id|max_sdu_size
comma
id|__u8
id|max_header_size
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|irnet_socket
op_star
id|self
op_assign
op_amp
id|irnet_server.s
suffix:semicolon
id|irnet_socket
op_star
r_new
op_assign
(paren
id|irnet_socket
op_star
)paren
l_int|NULL
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|instance
op_eq
op_amp
id|irnet_server
comma
comma
id|IRDA_CB_ERROR
comma
l_string|&quot;Invalid instance (0x%X) !!!&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|instance
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|sap
op_eq
id|irnet_server.s.tsap
comma
comma
id|IRDA_CB_ERROR
comma
l_string|&quot;Invalid sap !!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Try to find the most appropriate IrNET socket */
r_new
op_assign
id|irnet_find_socket
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* After all this hard work, do we have an socket ? */
r_if
c_cond
(paren
r_new
op_eq
(paren
id|irnet_socket
op_star
)paren
l_int|NULL
)paren
(brace
id|DEXIT
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;: No socket waiting for this connection.&bslash;n&quot;
)paren
suffix:semicolon
id|irnet_disconnect_server
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Is the socket already busy ? */
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|ttp_open
)paren
(brace
id|DEXIT
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;: Socket already connected.&bslash;n&quot;
)paren
suffix:semicolon
id|irnet_disconnect_server
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Socket connecting */
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|tsap
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* The socket has sent a IrTTP connection request and is waiting for&n;       * a connection response (that may never come).&n;       * Now, the pain is that the socket has open a tsap and is waiting on it,&n;       * while the other end is trying to connect to it on another tsap.&n;       * Argh ! We will deal with that later...&n;       */
id|DERROR
c_func
(paren
id|IRDA_CB_ERROR
comma
l_string|&quot;Socket already connecting. Ouch !&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef ALLOW_SIMULT_CONNECT
multiline_comment|/* Close the connection the new socket was attempting.&n;       * WARNING : This need more testing ! */
id|irttp_close_tsap
c_func
(paren
r_new
op_member_access_from_pointer
id|tsap
)paren
suffix:semicolon
multiline_comment|/* Note : no return, fall through... */
macro_line|#else ALLOW_SIMULT_CONNECT
id|irnet_disconnect_server
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif ALLOW_SIMULT_CONNECT
)brace
multiline_comment|/* So : at this point, we have a socket, and it is idle. Good ! */
id|irnet_connect_socket
c_func
(paren
id|self
comma
r_new
comma
id|qos
comma
id|max_sdu_size
comma
id|max_header_size
)paren
suffix:semicolon
multiline_comment|/* Check size of received packet */
r_if
c_cond
(paren
id|skb-&gt;len
OG
l_int|0
)paren
(brace
macro_line|#ifdef PASS_CONNECT_PACKETS
id|DEBUG
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;Passing connect packet to PPP.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Try to pass it to PPP */
id|irnet_data_indication
c_func
(paren
r_new
comma
r_new
op_member_access_from_pointer
id|tsap
comma
id|skb
)paren
suffix:semicolon
macro_line|#else PASS_CONNECT_PACKETS
id|DERROR
c_func
(paren
id|IRDA_CB_ERROR
comma
l_string|&quot;Dropping non empty packet.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Note : will be optimised with other kfree... */
macro_line|#endif PASS_CONNECT_PACKETS
)brace
r_else
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_TCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/********************** IRDA-IAS/LMP CALLBACKS **********************/
multiline_comment|/*&n; * These are the callbacks called by other layers of the IrDA stack,&n; * mainly LMP for discovery and IAS for name queries.&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_getvalue_confirm (obj_id, value, priv)&n; *&n; *    Got answer from remote LM-IAS, just pass object to requester...&n; *&n; */
r_static
r_void
DECL|function|irnet_getvalue_confirm
id|irnet_getvalue_confirm
c_func
(paren
r_int
id|result
comma
id|__u16
id|obj_id
comma
r_struct
id|ias_value
op_star
id|value
comma
r_void
op_star
id|priv
)paren
(brace
id|irnet_socket
op_star
id|self
op_assign
(paren
id|irnet_socket
op_star
)paren
id|priv
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_OCB_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
comma
id|IRDA_CB_ERROR
comma
l_string|&quot;Self is NULL !!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* We probably don&squot;t need to make any more queries */
id|iriap_close
c_func
(paren
id|self-&gt;iriap
)paren
suffix:semicolon
id|self-&gt;iriap
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Check if request succeeded */
r_if
c_cond
(paren
id|result
op_ne
id|IAS_SUCCESS
)paren
(brace
id|DEBUG
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;IAS query failed! (%d)&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
id|self-&gt;errno
op_assign
id|result
suffix:semicolon
multiline_comment|/* We really need it later */
)brace
r_else
(brace
multiline_comment|/* Pass the object to the caller (so the caller must delete it) */
id|self-&gt;ias_result
op_assign
id|value
suffix:semicolon
id|self-&gt;errno
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Wake up any processes waiting for result */
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;query_wait
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_OCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef DISCOVERY_EVENTS
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_discovery_indication (discovery)&n; *&n; *    Got a discovery indication from IrLMP, post an event&n; *&n; * Note : IrLMP take care of matching the hint mask for us, we only&n; * check if it is a &quot;new&quot; node...&n; *&n; * As IrLMP filter on the IrLAN hint bit, we get both IrLAN and IrNET&n; * nodes, so it&squot;s only at connection time that we will know if the&n; * node support IrNET, IrLAN or both. The other solution is to check&n; * in IAS the PNP ids and service name.&n; * Note : even if a node support IrNET (or IrLAN), it&squot;s no guarantee&n; * that we will be able to connect to it, the node might already be&n; * busy...&n; *&n; * One last thing : in some case, this function will trigger duplicate&n; * discovery events. On the other hand, we should catch all&n; * discoveries properly (i.e. not miss one). Filtering duplicate here&n; * is to messy, so we leave that to user space...&n; */
r_static
r_void
DECL|function|irnet_discovery_indication
id|irnet_discovery_indication
c_func
(paren
id|discovery_t
op_star
id|discovery
comma
r_void
op_star
id|priv
)paren
(brace
id|irnet_socket
op_star
id|self
op_assign
op_amp
id|irnet_server.s
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_OCB_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|priv
op_eq
op_amp
id|irnet_server
comma
comma
id|IRDA_CB_ERROR
comma
l_string|&quot;Invalid instance (0x%X) !!!&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|priv
)paren
suffix:semicolon
multiline_comment|/* Check if node is discovered is a new one or an old one.&n;   * We check when how long ago this node was discovered, with a&n;   * coarse timeout (we may miss some discovery events or be delayed).&n;   */
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|discovery-&gt;first_timestamp
)paren
op_ge
(paren
id|sysctl_discovery_timeout
op_star
id|HZ
)paren
)paren
(brace
r_return
suffix:semicolon
multiline_comment|/* Too old, not interesting -&gt; goodbye */
)brace
id|DEBUG
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;Discovered new IrNET/IrLAN node %s...&bslash;n&quot;
comma
id|discovery-&gt;nickname
)paren
suffix:semicolon
multiline_comment|/* Notify the control channel */
id|irnet_post_event
c_func
(paren
l_int|NULL
comma
id|IRNET_DISCOVER
comma
id|discovery-&gt;daddr
comma
id|discovery-&gt;nickname
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_OCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_expiry_indication (expiry)&n; *&n; *    Got a expiry indication from IrLMP, post an event&n; *&n; * Note : IrLMP take care of matching the hint mask for us, we only&n; * check if it is a &quot;new&quot; node...&n; */
r_static
r_void
DECL|function|irnet_expiry_indication
id|irnet_expiry_indication
c_func
(paren
id|discovery_t
op_star
id|expiry
comma
r_void
op_star
id|priv
)paren
(brace
id|irnet_socket
op_star
id|self
op_assign
op_amp
id|irnet_server.s
suffix:semicolon
id|DENTER
c_func
(paren
id|IRDA_OCB_TRACE
comma
l_string|&quot;(self=0x%X)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|self
)paren
suffix:semicolon
id|DASSERT
c_func
(paren
id|priv
op_eq
op_amp
id|irnet_server
comma
comma
id|IRDA_CB_ERROR
comma
l_string|&quot;Invalid instance (0x%X) !!!&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|priv
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|IRDA_CB_INFO
comma
l_string|&quot;IrNET/IrLAN node %s expired...&bslash;n&quot;
comma
id|expiry-&gt;nickname
)paren
suffix:semicolon
multiline_comment|/* Notify the control channel */
id|irnet_post_event
c_func
(paren
l_int|NULL
comma
id|IRNET_EXPIRE
comma
id|expiry-&gt;daddr
comma
id|expiry-&gt;nickname
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|IRDA_OCB_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif DISCOVERY_EVENTS
multiline_comment|/*********************** PROC ENTRY CALLBACKS ***********************/
multiline_comment|/*&n; * We create a instance in the /proc filesystem, and here we take care&n; * of that...&n; */
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irnet_proc_read (buf, start, offset, len, unused)&n; *&n; *    Give some info to the /proc file system&n; */
r_static
r_int
DECL|function|irnet_proc_read
id|irnet_proc_read
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|len
)paren
(brace
id|irnet_socket
op_star
id|self
suffix:semicolon
r_char
op_star
id|state
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get the IrNET server information... */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;IrNET server - &quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;IrDA state: %s, &quot;
comma
(paren
id|irnet_server.running
ques
c_cond
l_string|&quot;running&quot;
suffix:colon
l_string|&quot;dead&quot;
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;stsap_sel: %02x, &quot;
comma
id|irnet_server.s.stsap_sel
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;dtsap_sel: %02x&bslash;n&quot;
comma
id|irnet_server.s.dtsap_sel
)paren
suffix:semicolon
multiline_comment|/* Do we need to continue ? */
r_if
c_cond
(paren
op_logical_neg
id|irnet_server.running
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* Protect access to the instance list */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irnet_server.spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Get the sockets one by one... */
id|self
op_assign
(paren
id|irnet_socket
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irnet_server.list
)paren
suffix:semicolon
r_while
c_loop
(paren
id|self
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Start printing info about the socket. */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;nIrNET socket %d - &quot;
comma
id|i
op_increment
)paren
suffix:semicolon
multiline_comment|/* First, get the requested configuration */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Requested IrDA name: &bslash;&quot;%s&bslash;&quot;, &quot;
comma
id|self-&gt;rname
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;addr: %08x&bslash;n&quot;
comma
id|self-&gt;raddr
)paren
suffix:semicolon
multiline_comment|/* Second, get all the PPP info */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&t;PPP state: %s&quot;
comma
(paren
id|self-&gt;ppp_open
ques
c_cond
l_string|&quot;registered&quot;
suffix:colon
l_string|&quot;unregistered&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;ppp_open
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;, unit: ppp%d&quot;
comma
id|ppp_unit_number
c_func
(paren
op_amp
id|self-&gt;chan
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;, channel: %d&quot;
comma
id|ppp_channel_index
c_func
(paren
op_amp
id|self-&gt;chan
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;, mru: %d&quot;
comma
id|self-&gt;mru
)paren
suffix:semicolon
multiline_comment|/* Maybe add self-&gt;flags ? Later... */
)brace
multiline_comment|/* Then, get all the IrDA specific info... */
r_if
c_cond
(paren
id|self-&gt;ttp_open
)paren
(brace
id|state
op_assign
l_string|&quot;connected&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|self-&gt;tsap
op_ne
l_int|NULL
)paren
(brace
id|state
op_assign
l_string|&quot;connecting&quot;
suffix:semicolon
)brace
r_else
id|state
op_assign
l_string|&quot;idle&quot;
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&t;IrDA state: %s, &quot;
comma
id|state
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;daddr: %08x, &quot;
comma
id|self-&gt;daddr
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;stsap_sel: %02x, &quot;
comma
id|self-&gt;stsap_sel
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;dtsap_sel: %02x&bslash;n&quot;
comma
id|self-&gt;dtsap_sel
)paren
suffix:semicolon
multiline_comment|/* Next socket, please... */
id|self
op_assign
(paren
id|irnet_socket
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irnet_server.list
)paren
suffix:semicolon
)brace
multiline_comment|/* Spin lock end */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irnet_server.spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif /* PROC_FS */
multiline_comment|/********************** CONFIGURATION/CLEANUP **********************/
multiline_comment|/*&n; * Initialisation and teardown of the IrDA part, called at module&n; * insertion and removal...&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Prepare the IrNET layer for operation...&n; */
r_int
DECL|function|irda_irnet_init
id|irda_irnet_init
c_func
(paren
r_void
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|DENTER
c_func
(paren
id|MODULE_TRACE
comma
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Pure paranoia - should be redundant */
id|memset
c_func
(paren
op_amp
id|irnet_server
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|irnet_root
)paren
)paren
suffix:semicolon
multiline_comment|/* Setup start of irnet instance list */
id|irnet_server.list
op_assign
id|hashbin_new
c_func
(paren
id|HB_LOCAL
)paren
suffix:semicolon
id|DABORT
c_func
(paren
id|irnet_server.list
op_eq
l_int|NULL
comma
op_minus
id|ENOMEM
comma
id|MODULE_ERROR
comma
l_string|&quot;Can&squot;t allocate hashbin!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Init spinlock for instance list */
id|spin_lock_init
c_func
(paren
op_amp
id|irnet_server.spinlock
)paren
suffix:semicolon
multiline_comment|/* Initialise control channel */
id|init_waitqueue_head
c_func
(paren
op_amp
id|irnet_events.rwait
)paren
suffix:semicolon
id|irnet_events.index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Init spinlock for event logging */
id|spin_lock_init
c_func
(paren
op_amp
id|irnet_events.spinlock
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/* Add a /proc file for irnet infos */
id|create_proc_info_entry
c_func
(paren
l_string|&quot;irnet&quot;
comma
l_int|0
comma
id|proc_irda
comma
id|irnet_proc_read
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
multiline_comment|/* Setup the IrNET server */
id|err
op_assign
id|irnet_setup_server
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
multiline_comment|/* We are no longer functional... */
id|irnet_server.running
op_assign
l_int|1
suffix:semicolon
)brace
id|DEXIT
c_func
(paren
id|MODULE_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Cleanup at exit...&n; */
r_void
DECL|function|irda_irnet_cleanup
id|irda_irnet_cleanup
c_func
(paren
r_void
)paren
(brace
id|DENTER
c_func
(paren
id|MODULE_TRACE
comma
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* We are no longer there... */
id|irnet_server.running
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/* Remove our /proc file */
id|remove_proc_entry
c_func
(paren
l_string|&quot;irnet&quot;
comma
id|proc_irda
)paren
suffix:semicolon
macro_line|#endif CONFIG_PROC_FS
multiline_comment|/* Remove our IrNET server from existence */
id|irnet_destroy_server
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Remove all instances of IrNET socket still present */
id|hashbin_delete
c_func
(paren
id|irnet_server.list
comma
(paren
id|FREE_FUNC
)paren
id|irda_irnet_destroy
)paren
suffix:semicolon
id|DEXIT
c_func
(paren
id|MODULE_TRACE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
eof
