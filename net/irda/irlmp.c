multiline_comment|/*********************************************************************&n; *                &n; * Filename:      irlmp.c&n; * Version:       1.0&n; * Description:   IrDA Link Management Protocol (LMP) layer                 &n; * Status:        Stable.&n; * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Created at:    Sun Aug 17 20:54:32 1997&n; * Modified at:   Wed Jan  5 11:26:03 2000&n; * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * &n; *     Copyright (c) 1998-2000 Dag Brattli &lt;dagb@cs.uit.no&gt;, &n; *     All Rights Reserved.&n; *     &n; *     This program is free software; you can redistribute it and/or &n; *     modify it under the terms of the GNU General Public License as &n; *     published by the Free Software Foundation; either version 2 of &n; *     the License, or (at your option) any later version.&n; *&n; *     Neither Dag Brattli nor University of Troms&#xfffd; admit liability nor&n; *     provide warranty for any of this software. This material is &n; *     provided &quot;AS-IS&quot; and at no charge.&n; *&n; ********************************************************************/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/irmod.h&gt;
macro_line|#include &lt;net/irda/timer.h&gt;
macro_line|#include &lt;net/irda/qos.h&gt;
macro_line|#include &lt;net/irda/irlap.h&gt;
macro_line|#include &lt;net/irda/iriap.h&gt;
macro_line|#include &lt;net/irda/irlmp.h&gt;
macro_line|#include &lt;net/irda/irlmp_frame.h&gt;
multiline_comment|/* Master structure */
DECL|variable|irlmp
r_struct
id|irlmp_cb
op_star
id|irlmp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* These can be altered by the sysctl interface */
DECL|variable|sysctl_discovery
r_int
id|sysctl_discovery
op_assign
l_int|0
suffix:semicolon
DECL|variable|sysctl_discovery_timeout
r_int
id|sysctl_discovery_timeout
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* 3 seconds by default */
DECL|variable|sysctl_discovery_slots
r_int
id|sysctl_discovery_slots
op_assign
l_int|6
suffix:semicolon
multiline_comment|/* 6 slots by default */
DECL|variable|sysctl_devname
r_char
id|sysctl_devname
(braket
l_int|65
)braket
suffix:semicolon
DECL|variable|lmp_reasons
r_char
op_star
id|lmp_reasons
(braket
)braket
op_assign
(brace
l_string|&quot;ERROR, NOT USED&quot;
comma
l_string|&quot;LM_USER_REQUEST&quot;
comma
l_string|&quot;LM_LAP_DISCONNECT&quot;
comma
l_string|&quot;LM_CONNECT_FAILURE&quot;
comma
l_string|&quot;LM_LAP_RESET&quot;
comma
l_string|&quot;LM_INIT_DISCONNECT&quot;
comma
l_string|&quot;ERROR, NOT USED&quot;
comma
)brace
suffix:semicolon
id|__u8
op_star
id|irlmp_hint_to_service
c_func
(paren
id|__u8
op_star
id|hint
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_int
id|irlmp_proc_read
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offst
comma
r_int
id|len
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Function irlmp_init (void)&n; *&n; *    Create (allocate) the main IrLMP structure&n; *&n; */
DECL|function|irlmp_init
r_int
id|__init
id|irlmp_init
c_func
(paren
r_void
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Initialize the irlmp structure. */
id|irlmp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irlmp_cb
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irlmp
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|irlmp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|irlmp_cb
)paren
)paren
suffix:semicolon
id|irlmp-&gt;magic
op_assign
id|LMP_MAGIC
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|irlmp-&gt;log_lock
)paren
suffix:semicolon
id|irlmp-&gt;clients
op_assign
id|hashbin_new
c_func
(paren
id|HB_GLOBAL
)paren
suffix:semicolon
id|irlmp-&gt;services
op_assign
id|hashbin_new
c_func
(paren
id|HB_GLOBAL
)paren
suffix:semicolon
id|irlmp-&gt;links
op_assign
id|hashbin_new
c_func
(paren
id|HB_GLOBAL
)paren
suffix:semicolon
id|irlmp-&gt;unconnected_lsaps
op_assign
id|hashbin_new
c_func
(paren
id|HB_GLOBAL
)paren
suffix:semicolon
id|irlmp-&gt;cachelog
op_assign
id|hashbin_new
c_func
(paren
id|HB_GLOBAL
)paren
suffix:semicolon
id|irlmp-&gt;free_lsap_sel
op_assign
l_int|0x10
suffix:semicolon
multiline_comment|/* Reserved 0x00-0x0f */
macro_line|#ifdef CONFIG_IRDA_CACHE_LAST_LSAP
id|irlmp-&gt;cache.valid
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif
id|strcpy
c_func
(paren
id|sysctl_devname
comma
l_string|&quot;Linux&quot;
)paren
suffix:semicolon
multiline_comment|/* Do discovery every 3 seconds */
id|init_timer
c_func
(paren
op_amp
id|irlmp-&gt;discovery_timer
)paren
suffix:semicolon
id|irlmp_start_discovery_timer
c_func
(paren
id|irlmp
comma
id|sysctl_discovery_timeout
op_star
id|HZ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_cleanup (void)&n; *&n; *    Remove IrLMP layer&n; *&n; */
DECL|function|irlmp_cleanup
r_void
id|irlmp_cleanup
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Check for main structure */
id|ASSERT
c_func
(paren
id|irlmp
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp-&gt;magic
op_eq
id|LMP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|irlmp-&gt;discovery_timer
)paren
suffix:semicolon
id|hashbin_delete
c_func
(paren
id|irlmp-&gt;links
comma
(paren
id|FREE_FUNC
)paren
id|kfree
)paren
suffix:semicolon
id|hashbin_delete
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
comma
(paren
id|FREE_FUNC
)paren
id|kfree
)paren
suffix:semicolon
id|hashbin_delete
c_func
(paren
id|irlmp-&gt;clients
comma
(paren
id|FREE_FUNC
)paren
id|kfree
)paren
suffix:semicolon
id|hashbin_delete
c_func
(paren
id|irlmp-&gt;services
comma
(paren
id|FREE_FUNC
)paren
id|kfree
)paren
suffix:semicolon
id|hashbin_delete
c_func
(paren
id|irlmp-&gt;cachelog
comma
(paren
id|FREE_FUNC
)paren
id|kfree
)paren
suffix:semicolon
multiline_comment|/* De-allocate main structure */
id|kfree
c_func
(paren
id|irlmp
)paren
suffix:semicolon
id|irlmp
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_open_lsap (slsap, notify)&n; *&n; *   Register with IrLMP and create a local LSAP,&n; *   returns handle to LSAP.&n; */
DECL|function|irlmp_open_lsap
r_struct
id|lsap_cb
op_star
id|irlmp_open_lsap
c_func
(paren
id|__u8
id|slsap_sel
comma
id|notify_t
op_star
id|notify
comma
id|__u8
id|pid
)paren
(brace
r_struct
id|lsap_cb
op_star
id|self
suffix:semicolon
id|ASSERT
c_func
(paren
id|notify
op_ne
l_int|NULL
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp
op_ne
l_int|NULL
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp-&gt;magic
op_eq
id|LMP_MAGIC
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*  Does the client care which Source LSAP selector it gets?  */
r_if
c_cond
(paren
id|slsap_sel
op_eq
id|LSAP_ANY
)paren
(brace
id|slsap_sel
op_assign
id|irlmp_find_free_slsap
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slsap_sel
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irlmp_slsap_inuse
c_func
(paren
id|slsap_sel
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Allocate new instance of a LSAP connection */
id|self
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|lsap_cb
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self
op_eq
l_int|NULL
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), can&squot;t allocate memory&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|self
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|lsap_cb
)paren
)paren
suffix:semicolon
id|self-&gt;magic
op_assign
id|LMP_LSAP_MAGIC
suffix:semicolon
id|self-&gt;slsap_sel
op_assign
id|slsap_sel
suffix:semicolon
multiline_comment|/* Fix connectionless LSAP&squot;s */
r_if
c_cond
(paren
id|slsap_sel
op_eq
id|LSAP_CONNLESS
)paren
(brace
macro_line|#ifdef CONFIG_IRDA_ULTRA
id|self-&gt;dlsap_sel
op_assign
id|LSAP_CONNLESS
suffix:semicolon
id|self-&gt;pid
op_assign
id|pid
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_ULTRA */
)brace
r_else
id|self-&gt;dlsap_sel
op_assign
id|LSAP_ANY
suffix:semicolon
id|self-&gt;connected
op_assign
id|FALSE
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|self-&gt;watchdog_timer
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|notify-&gt;instance
op_ne
l_int|NULL
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
id|self-&gt;notify
op_assign
op_star
id|notify
suffix:semicolon
id|irlmp_next_lsap_state
c_func
(paren
id|self
comma
id|LSAP_DISCONNECTED
)paren
suffix:semicolon
multiline_comment|/* Insert into queue of unconnected LSAPs */
id|hashbin_insert
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
comma
(paren
id|irda_queue_t
op_star
)paren
id|self
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|self
suffix:semicolon
)brace
multiline_comment|/*&n; * Function __irlmp_close_lsap (self)&n; *&n; *    Remove an instance of LSAP&n; */
DECL|function|__irlmp_close_lsap
r_static
r_void
id|__irlmp_close_lsap
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Set some of the variables to preset values&n;&t; */
id|self-&gt;magic
op_assign
l_int|0
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;watchdog_timer
)paren
suffix:semicolon
multiline_comment|/* Important! */
r_if
c_cond
(paren
id|self-&gt;conn_skb
)paren
id|dev_kfree_skb
c_func
(paren
id|self-&gt;conn_skb
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_CACHE_LAST_LSAP
id|ASSERT
c_func
(paren
id|irlmp
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|irlmp-&gt;cache.valid
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif
id|kfree
c_func
(paren
id|self
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_close_lsap (self)&n; *&n; *    Close and remove LSAP&n; *&n; */
DECL|function|irlmp_close_lsap
r_void
id|irlmp_close_lsap
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
)paren
(brace
r_struct
id|lap_cb
op_star
id|lap
suffix:semicolon
r_struct
id|lsap_cb
op_star
id|lsap
op_assign
l_int|NULL
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Find out if we should remove this LSAP from a link or from the&n;&t; *  list of unconnected lsaps (not associated with a link)&n;&t; */
id|lap
op_assign
id|self-&gt;lap
suffix:semicolon
r_if
c_cond
(paren
id|lap
)paren
(brace
id|ASSERT
c_func
(paren
id|lap-&gt;magic
op_eq
id|LMP_LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|lsap
op_assign
id|hashbin_remove
c_func
(paren
id|lap-&gt;lsaps
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if we found the LSAP! If not then try the unconnected lsaps */
r_if
c_cond
(paren
op_logical_neg
id|lsap
)paren
(brace
id|lsap
op_assign
id|hashbin_remove
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|lsap
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Looks like somebody has removed me already!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|__irlmp_close_lsap
c_func
(paren
id|self
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_register_irlap (saddr, notify)&n; *&n; *    Register IrLAP layer with IrLMP. There is possible to have multiple&n; *    instances of the IrLAP layer, each connected to different IrDA ports&n; *&n; */
DECL|function|irlmp_register_link
r_void
id|irlmp_register_link
c_func
(paren
r_struct
id|irlap_cb
op_star
id|irlap
comma
id|__u32
id|saddr
comma
id|notify_t
op_star
id|notify
)paren
(brace
r_struct
id|lap_cb
op_star
id|lap
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp-&gt;magic
op_eq
id|LMP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|notify
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate new instance of a LSAP connection&n;&t; */
id|lap
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|lap_cb
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lap
op_eq
l_int|NULL
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), unable to kmalloc&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|lap
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|lap_cb
)paren
)paren
suffix:semicolon
id|lap-&gt;irlap
op_assign
id|irlap
suffix:semicolon
id|lap-&gt;magic
op_assign
id|LMP_LAP_MAGIC
suffix:semicolon
id|lap-&gt;saddr
op_assign
id|saddr
suffix:semicolon
id|lap-&gt;daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
id|lap-&gt;lsaps
op_assign
id|hashbin_new
c_func
(paren
id|HB_GLOBAL
)paren
suffix:semicolon
id|irlmp_next_lap_state
c_func
(paren
id|lap
comma
id|LAP_STANDBY
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|lap-&gt;idle_timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Insert into queue of LMP links&n;&t; */
id|hashbin_insert
c_func
(paren
id|irlmp-&gt;links
comma
(paren
id|irda_queue_t
op_star
)paren
id|lap
comma
id|lap-&gt;saddr
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* &n;&t; *  We set only this variable so IrLAP can tell us on which link the&n;&t; *  different events happened on &n;&t; */
id|irda_notify_init
c_func
(paren
id|notify
)paren
suffix:semicolon
id|notify-&gt;instance
op_assign
id|lap
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_unregister_irlap (saddr)&n; *&n; *    IrLAP layer has been removed!&n; *&n; */
DECL|function|irlmp_unregister_link
r_void
id|irlmp_unregister_link
c_func
(paren
id|__u32
id|saddr
)paren
(brace
r_struct
id|lap_cb
op_star
id|link
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|link
op_assign
id|hashbin_remove
c_func
(paren
id|irlmp-&gt;links
comma
id|saddr
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link
)paren
(brace
id|ASSERT
c_func
(paren
id|link-&gt;magic
op_eq
id|LMP_LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Remove all discoveries discovered at this link */
id|irlmp_expire_discoveries
c_func
(paren
id|irlmp-&gt;cachelog
comma
id|link-&gt;saddr
comma
id|TRUE
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|link-&gt;idle_timer
)paren
suffix:semicolon
id|link-&gt;magic
op_assign
l_int|0
suffix:semicolon
id|kfree
c_func
(paren
id|link
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_connect_request (handle, dlsap, userdata)&n; *&n; *    Connect with a peer LSAP  &n; *&n; */
DECL|function|irlmp_connect_request
r_int
id|irlmp_connect_request
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
id|__u8
id|dlsap_sel
comma
id|__u32
id|saddr
comma
id|__u32
id|daddr
comma
r_struct
id|qos_info
op_star
id|qos
comma
r_struct
id|sk_buff
op_star
id|userdata
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|lap_cb
op_star
id|lap
suffix:semicolon
r_struct
id|lsap_cb
op_star
id|lsap
suffix:semicolon
id|discovery_t
op_star
id|discovery
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
id|EBADR
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
op_minus
id|EBADR
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), slsap_sel=%02x, dlsap_sel=%02x, saddr=%08x, daddr=%08x&bslash;n&quot;
comma
id|self-&gt;slsap_sel
comma
id|dlsap_sel
comma
id|saddr
comma
id|daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;connected
)paren
r_return
op_minus
id|EISCONN
suffix:semicolon
multiline_comment|/* Client must supply destination device address */
r_if
c_cond
(paren
op_logical_neg
id|daddr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Any userdata? */
r_if
c_cond
(paren
id|userdata
op_eq
l_int|NULL
)paren
(brace
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
l_int|64
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
id|LMP_MAX_HEADER
)paren
suffix:semicolon
)brace
r_else
id|skb
op_assign
id|userdata
suffix:semicolon
multiline_comment|/* Make room for MUX control header (3 bytes) */
id|ASSERT
c_func
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
op_ge
id|LMP_CONTROL_HEADER
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|skb_push
c_func
(paren
id|skb
comma
id|LMP_CONTROL_HEADER
)paren
suffix:semicolon
id|self-&gt;dlsap_sel
op_assign
id|dlsap_sel
suffix:semicolon
multiline_comment|/*  &n;&t; * Find the link to where we should try to connect since there may&n;&t; * be more than one IrDA port on this machine. If the client has&n;&t; * passed us the saddr (and already knows which link to use), then&n;&t; * we use that to find the link, if not then we have to look in the&n;&t; * discovery log and check if any of the links has discovered a&n;&t; * device with the given daddr &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|saddr
)paren
(brace
r_if
c_cond
(paren
id|daddr
op_ne
id|DEV_ADDR_ANY
)paren
id|discovery
op_assign
id|hashbin_find
c_func
(paren
id|irlmp-&gt;cachelog
comma
id|daddr
comma
l_int|NULL
)paren
suffix:semicolon
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), no daddr&bslash;n&quot;
)paren
suffix:semicolon
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;cachelog
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|discovery
)paren
(brace
id|saddr
op_assign
id|discovery-&gt;saddr
suffix:semicolon
id|daddr
op_assign
id|discovery-&gt;daddr
suffix:semicolon
)brace
)brace
id|lap
op_assign
id|hashbin_find
c_func
(paren
id|irlmp-&gt;links
comma
id|saddr
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lap
op_eq
l_int|NULL
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unable to find a usable link!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EHOSTUNREACH
suffix:semicolon
)brace
multiline_comment|/* Check if LAP is disconnected or already connected */
r_if
c_cond
(paren
id|lap-&gt;daddr
op_eq
id|DEV_ADDR_ANY
)paren
id|lap-&gt;daddr
op_assign
id|daddr
suffix:semicolon
r_else
r_if
c_cond
(paren
id|lap-&gt;daddr
op_ne
id|daddr
)paren
(brace
r_struct
id|lsap_cb
op_star
id|any_lsap
suffix:semicolon
multiline_comment|/* Check if some LSAPs are active on this LAP */
id|any_lsap
op_assign
(paren
r_struct
id|lsap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|lap-&gt;lsaps
)paren
suffix:semicolon
r_if
c_cond
(paren
id|any_lsap
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* No active connection, but LAP hasn&squot;t been&n;&t;&t;&t; * disconnected yet (waiting for timeout in LAP).&n;&t;&t;&t; * Maybe we could give LAP a bit of help in this case.&n;&t;&t;&t; */
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), sorry, but I&squot;m waiting for LAP to timeout!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* LAP is already connected to a different node, and LAP&n;&t;&t; * can only talk to one node at a time */
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), sorry, but link is busy!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|self-&gt;lap
op_assign
id|lap
suffix:semicolon
multiline_comment|/* &n;&t; *  Remove LSAP from list of unconnected LSAPs and insert it into the &n;&t; *  list of connected LSAPs for the particular link &n;&t; */
id|lsap
op_assign
id|hashbin_remove
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lsap
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lsap-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lsap-&gt;lap
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lsap-&gt;lap-&gt;magic
op_eq
id|LMP_LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|self-&gt;lap-&gt;lsaps
comma
(paren
id|irda_queue_t
op_star
)paren
id|self
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
id|self-&gt;connected
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t; *  User supplied qos specifications?&n;&t; */
r_if
c_cond
(paren
id|qos
)paren
id|self-&gt;qos
op_assign
op_star
id|qos
suffix:semicolon
id|irlmp_do_lsap_event
c_func
(paren
id|self
comma
id|LM_CONNECT_REQUEST
comma
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_connect_indication (self)&n; *&n; *    Incomming connection&n; *&n; */
DECL|function|irlmp_connect_indication
r_void
id|irlmp_connect_indication
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|max_seg_size
suffix:semicolon
r_int
id|lap_header_size
suffix:semicolon
r_int
id|max_header_size
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;lap
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), slsap_sel=%02x, dlsap_sel=%02x&bslash;n&quot;
comma
id|self-&gt;slsap_sel
comma
id|self-&gt;dlsap_sel
)paren
suffix:semicolon
id|self-&gt;qos
op_assign
op_star
id|self-&gt;lap-&gt;qos
suffix:semicolon
id|max_seg_size
op_assign
id|self-&gt;lap-&gt;qos-&gt;data_size.value
op_minus
id|LMP_HEADER
suffix:semicolon
id|lap_header_size
op_assign
id|IRLAP_GET_HEADER_SIZE
c_func
(paren
id|self-&gt;lap-&gt;irlap
)paren
suffix:semicolon
id|max_header_size
op_assign
id|LMP_HEADER
op_plus
id|lap_header_size
suffix:semicolon
multiline_comment|/* Hide LMP_CONTROL_HEADER header from layer above */
id|skb_pull
c_func
(paren
id|skb
comma
id|LMP_CONTROL_HEADER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;notify.connect_indication
)paren
id|self-&gt;notify
dot
id|connect_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
op_amp
id|self-&gt;qos
comma
id|max_seg_size
comma
id|max_header_size
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_connect_response (handle, userdata)&n; *&n; *    Service user is accepting connection&n; *&n; */
DECL|function|irlmp_connect_response
r_int
id|irlmp_connect_response
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|userdata
)paren
(brace
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|userdata
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|self-&gt;connected
op_assign
id|TRUE
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), slsap_sel=%02x, dlsap_sel=%02x&bslash;n&quot;
comma
id|self-&gt;slsap_sel
comma
id|self-&gt;dlsap_sel
)paren
suffix:semicolon
multiline_comment|/* Make room for MUX control header (3 bytes) */
id|ASSERT
c_func
(paren
id|skb_headroom
c_func
(paren
id|userdata
)paren
op_ge
id|LMP_CONTROL_HEADER
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|skb_push
c_func
(paren
id|userdata
comma
id|LMP_CONTROL_HEADER
)paren
suffix:semicolon
id|irlmp_do_lsap_event
c_func
(paren
id|self
comma
id|LM_CONNECT_RESPONSE
comma
id|userdata
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_connect_confirm (handle, skb)&n; *&n; *    LSAP connection confirmed peer device!&n; */
DECL|function|irlmp_connect_confirm
r_void
id|irlmp_connect_confirm
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|max_header_size
suffix:semicolon
r_int
id|lap_header_size
suffix:semicolon
r_int
id|max_seg_size
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;lap
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|self-&gt;qos
op_assign
op_star
id|self-&gt;lap-&gt;qos
suffix:semicolon
id|max_seg_size
op_assign
id|self-&gt;lap-&gt;qos-&gt;data_size.value
op_minus
id|LMP_HEADER
suffix:semicolon
id|lap_header_size
op_assign
id|IRLAP_GET_HEADER_SIZE
c_func
(paren
id|self-&gt;lap-&gt;irlap
)paren
suffix:semicolon
id|max_header_size
op_assign
id|LMP_HEADER
op_plus
id|lap_header_size
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), max_header_size=%d&bslash;n&quot;
comma
id|max_header_size
)paren
suffix:semicolon
multiline_comment|/* Hide LMP_CONTROL_HEADER header from layer above */
id|skb_pull
c_func
(paren
id|skb
comma
id|LMP_CONTROL_HEADER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;notify.connect_confirm
)paren
(brace
id|self-&gt;notify
dot
id|connect_confirm
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
op_amp
id|self-&gt;qos
comma
id|max_seg_size
comma
id|max_header_size
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_dup (orig, instance)&n; *&n; *    Duplicate LSAP, can be used by servers to confirm a connection on a&n; *    new LSAP so it can keep listening on the old one.&n; *&n; */
DECL|function|irlmp_dup
r_struct
id|lsap_cb
op_star
id|irlmp_dup
c_func
(paren
r_struct
id|lsap_cb
op_star
id|orig
comma
r_void
op_star
id|instance
)paren
(brace
r_struct
id|lsap_cb
op_star
r_new
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Only allowed to duplicate unconnected LSAP&squot;s */
r_if
c_cond
(paren
op_logical_neg
id|hashbin_find
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
comma
(paren
r_int
)paren
id|orig
comma
l_int|NULL
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), unable to find LSAP&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_new
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|lsap_cb
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), unable to kmalloc&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Dup */
id|memcpy
c_func
(paren
r_new
comma
id|orig
comma
r_sizeof
(paren
r_struct
id|lsap_cb
)paren
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|notify.instance
op_assign
id|instance
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|watchdog_timer
)paren
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
comma
(paren
id|irda_queue_t
op_star
)paren
r_new
comma
(paren
r_int
)paren
r_new
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Make sure that we invalidate the cache */
macro_line|#ifdef CONFIG_IRDA_CACHE_LAST_LSAP
id|irlmp-&gt;cache.valid
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_CACHE_LAST_LSAP */
r_return
r_new
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_disconnect_request (handle, userdata)&n; *&n; *    The service user is requesting disconnection, this will not remove the &n; *    LSAP, but only mark it as disconnected&n; */
DECL|function|irlmp_disconnect_request
r_int
id|irlmp_disconnect_request
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|userdata
)paren
(brace
r_struct
id|lsap_cb
op_star
id|lsap
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Already disconnected? */
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;connected
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), already disconnected!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|userdata
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;connected
op_eq
id|TRUE
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|skb_push
c_func
(paren
id|userdata
comma
id|LMP_CONTROL_HEADER
)paren
suffix:semicolon
multiline_comment|/* &n;&t; *  Do the event before the other stuff since we must know&n;&t; *  which lap layer that the frame should be transmitted on&n;&t; */
id|irlmp_do_lsap_event
c_func
(paren
id|self
comma
id|LM_DISCONNECT_REQUEST
comma
id|userdata
)paren
suffix:semicolon
multiline_comment|/* &n;&t; *  Remove LSAP from list of connected LSAPs for the particular link&n;&t; *  and insert it into the list of unconnected LSAPs&n;&t; */
id|ASSERT
c_func
(paren
id|self-&gt;lap
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;lap-&gt;magic
op_eq
id|LMP_LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;lap-&gt;lsaps
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|lsap
op_assign
id|hashbin_remove
c_func
(paren
id|self-&gt;lap-&gt;lsaps
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lsap
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lsap-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lsap
op_eq
id|self
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
comma
(paren
id|irda_queue_t
op_star
)paren
id|self
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Reset some values */
id|self-&gt;connected
op_assign
id|FALSE
suffix:semicolon
id|self-&gt;dlsap_sel
op_assign
id|LSAP_ANY
suffix:semicolon
id|self-&gt;lap
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_disconnect_indication (reason, userdata)&n; *&n; *    LSAP is being closed!&n; */
DECL|function|irlmp_disconnect_indication
r_void
id|irlmp_disconnect_indication
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
id|LM_REASON
id|reason
comma
r_struct
id|sk_buff
op_star
id|userdata
)paren
(brace
r_struct
id|lsap_cb
op_star
id|lsap
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), reason=%s&bslash;n&quot;
comma
id|lmp_reasons
(braket
id|reason
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;connected
op_eq
id|TRUE
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;(), slsap_sel=%02x, dlsap_sel=%02x&bslash;n&quot;
comma
id|self-&gt;slsap_sel
comma
id|self-&gt;dlsap_sel
)paren
suffix:semicolon
id|self-&gt;connected
op_assign
id|FALSE
suffix:semicolon
id|self-&gt;dlsap_sel
op_assign
id|LSAP_ANY
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_CACHE_LAST_LSAP
id|irlmp-&gt;cache.valid
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t; *  Remove association between this LSAP and the link it used &n;&t; */
id|ASSERT
c_func
(paren
id|self-&gt;lap
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;lap-&gt;lsaps
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|lsap
op_assign
id|hashbin_remove
c_func
(paren
id|self-&gt;lap-&gt;lsaps
comma
(paren
r_int
)paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lsap
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lsap
op_eq
id|self
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
comma
(paren
id|irda_queue_t
op_star
)paren
id|lsap
comma
(paren
r_int
)paren
id|lsap
comma
l_int|NULL
)paren
suffix:semicolon
id|self-&gt;lap
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *  Inform service user&n;&t; */
r_if
c_cond
(paren
id|self-&gt;notify.disconnect_indication
)paren
id|self-&gt;notify
dot
id|disconnect_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
id|reason
comma
id|userdata
)paren
suffix:semicolon
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), no handler&bslash;n&quot;
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|userdata
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_do_discovery (nslots)&n; *&n; *    Do some discovery on all links&n; *&n; */
DECL|function|irlmp_do_discovery
r_void
id|irlmp_do_discovery
c_func
(paren
r_int
id|nslots
)paren
(brace
r_struct
id|lap_cb
op_star
id|lap
suffix:semicolon
multiline_comment|/* Make sure the value is sane */
r_if
c_cond
(paren
(paren
id|nslots
op_ne
l_int|1
)paren
op_logical_and
(paren
id|nslots
op_ne
l_int|6
)paren
op_logical_and
(paren
id|nslots
op_ne
l_int|8
)paren
op_logical_and
(paren
id|nslots
op_ne
l_int|16
)paren
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), invalid value for number of slots!&bslash;n&quot;
)paren
suffix:semicolon
id|nslots
op_assign
id|sysctl_discovery_slots
op_assign
l_int|8
suffix:semicolon
)brace
multiline_comment|/* Construct new discovery info to be used by IrLAP, */
id|irlmp-&gt;discovery_cmd.hints.word
op_assign
id|irlmp-&gt;hints.word
suffix:semicolon
multiline_comment|/* &n;&t; *  Set character set for device name (we use ASCII), and &n;&t; *  copy device name. Remember to make room for a &bslash;0 at the &n;&t; *  end&n;&t; */
id|irlmp-&gt;discovery_cmd.charset
op_assign
id|CS_ASCII
suffix:semicolon
id|strncpy
c_func
(paren
id|irlmp-&gt;discovery_cmd.nickname
comma
id|sysctl_devname
comma
id|NICKNAME_MAX_LEN
)paren
suffix:semicolon
id|irlmp-&gt;discovery_cmd.name_len
op_assign
id|strlen
c_func
(paren
id|irlmp-&gt;discovery_cmd.nickname
)paren
suffix:semicolon
id|irlmp-&gt;discovery_cmd.nslots
op_assign
id|nslots
suffix:semicolon
multiline_comment|/*&n;&t; * Try to send discovery packets on all links&n;&t; */
id|lap
op_assign
(paren
r_struct
id|lap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;links
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lap
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|lap-&gt;magic
op_eq
id|LMP_LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lap-&gt;lap_state
op_eq
id|LAP_STANDBY
)paren
(brace
multiline_comment|/* Expire discoveries discovered on this link */
id|irlmp_expire_discoveries
c_func
(paren
id|irlmp-&gt;cachelog
comma
id|lap-&gt;saddr
comma
id|FALSE
)paren
suffix:semicolon
multiline_comment|/* Try to discover */
id|irlmp_do_lap_event
c_func
(paren
id|lap
comma
id|LM_LAP_DISCOVERY_REQUEST
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|lap
op_assign
(paren
r_struct
id|lap_cb
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irlmp-&gt;links
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_discovery_request (nslots)&n; *&n; *    Do a discovery of devices in front of the computer&n; *&n; */
DECL|function|irlmp_discovery_request
r_void
id|irlmp_discovery_request
c_func
(paren
r_int
id|nslots
)paren
(brace
multiline_comment|/* Check if user wants to override the default */
r_if
c_cond
(paren
id|nslots
op_eq
id|DISCOVERY_DEFAULT_SLOTS
)paren
id|nslots
op_assign
id|sysctl_discovery_slots
suffix:semicolon
multiline_comment|/* Return current cached discovery log */
id|irlmp_discovery_confirm
c_func
(paren
id|irlmp-&gt;cachelog
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Start a single discovery operation if discovery is not already&n;         * running &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sysctl_discovery
)paren
id|irlmp_do_discovery
c_func
(paren
id|nslots
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_get_discoveries (pn, mask)&n; *&n; *    Return the current discovery log&n; *&n; */
DECL|function|irlmp_get_discoveries
r_struct
id|irda_device_info
op_star
id|irlmp_get_discoveries
c_func
(paren
r_int
op_star
id|pn
comma
id|__u16
id|mask
)paren
(brace
multiline_comment|/* Return current cached discovery log */
r_return
id|irlmp_copy_discoveries
c_func
(paren
id|irlmp-&gt;cachelog
comma
id|pn
comma
id|mask
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * Function irlmp_check_services (discovery)&n; *&n; *    &n; *&n; */
r_void
id|irlmp_check_services
c_func
(paren
id|discovery_t
op_star
id|discovery
)paren
(brace
r_struct
id|irlmp_client
op_star
id|client
suffix:semicolon
id|__u8
op_star
id|service_log
suffix:semicolon
id|__u8
id|service
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;IrDA Discovered: %s&bslash;n&quot;
comma
id|discovery-&gt;info
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;    Services: &quot;
)paren
suffix:semicolon
id|service_log
op_assign
id|irlmp_hint_to_service
c_func
(paren
id|discovery-&gt;hints.byte
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|service_log
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *  Check all services on the device&n;&t; */
r_while
c_loop
(paren
(paren
id|service
op_assign
id|service_log
(braket
id|i
op_increment
)braket
)paren
op_ne
id|S_END
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;service=%02x&bslash;n&quot;
comma
id|service
)paren
suffix:semicolon
id|client
op_assign
id|hashbin_find
c_func
(paren
id|irlmp-&gt;registry
comma
id|service
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_logical_and
id|entry-&gt;discovery_callback
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;discovery_callback!&bslash;n&quot;
)paren
suffix:semicolon
id|entry
op_member_access_from_pointer
id|discovery_callback
c_func
(paren
id|discovery
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Don&squot;t notify about the ANY service */
r_if
c_cond
(paren
id|service
op_eq
id|S_ANY
)paren
r_continue
suffix:semicolon
multiline_comment|/*  &n;&t;&t;&t; * Found no clients for dealing with this service,&n;&t;&t;&t; */
)brace
)brace
id|kfree
c_func
(paren
id|service_log
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Function irlmp_notify_client (log)&n; *&n; *    Notify all about discovered devices&n; *&n; * Clients registered with IrLMP are :&n; *&t;o IrComm&n; *&t;o IrLAN&n; *&t;o Any socket (in any state - ouch, that may be a lot !)&n; * The client may have defined a callback to be notified in case of&n; * partial/selective discovery based on the hints that it passed to IrLMP.&n; */
r_static
r_inline
r_void
DECL|function|irlmp_notify_client
id|irlmp_notify_client
c_func
(paren
id|irlmp_client_t
op_star
id|client
comma
id|hashbin_t
op_star
id|log
)paren
(brace
id|discovery_t
op_star
id|discovery
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Check if client wants or not partial/selective log (optimisation) */
r_if
c_cond
(paren
op_logical_neg
id|client-&gt;disco_callback
)paren
r_return
suffix:semicolon
multiline_comment|/* &n;&t; * Now, check all discovered devices (if any), and notify client &n;&t; * only about the services that the client is interested in &n;&t; */
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|log
)paren
suffix:semicolon
r_while
c_loop
(paren
id|discovery
op_ne
l_int|NULL
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;discovery-&gt;daddr = 0x%08x&bslash;n&quot;
comma
id|discovery-&gt;daddr
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Any common hint bits? Remember to mask away the extension&n;&t;&t; * bits ;-)&n;&t;&t; */
r_if
c_cond
(paren
id|client-&gt;hint_mask
op_amp
id|discovery-&gt;hints.word
op_amp
l_int|0x7f7f
)paren
id|client
op_member_access_from_pointer
id|disco_callback
c_func
(paren
id|discovery
comma
id|client-&gt;priv
)paren
suffix:semicolon
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_discovery_confirm ( self, log)&n; *&n; *    Some device(s) answered to our discovery request! Check to see which&n; *    device it is, and give indication to the client(s)&n; * &n; */
DECL|function|irlmp_discovery_confirm
r_void
id|irlmp_discovery_confirm
c_func
(paren
id|hashbin_t
op_star
id|log
)paren
(brace
id|irlmp_client_t
op_star
id|client
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|log
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|HASHBIN_GET_SIZE
c_func
(paren
id|log
)paren
)paren
)paren
r_return
suffix:semicolon
id|client
op_assign
(paren
id|irlmp_client_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;clients
)paren
suffix:semicolon
r_while
c_loop
(paren
id|client
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Check if we should notify client */
id|irlmp_notify_client
c_func
(paren
id|client
comma
id|log
)paren
suffix:semicolon
id|client
op_assign
(paren
id|irlmp_client_t
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irlmp-&gt;clients
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_discovery_expiry (expiry)&n; *&n; *&t;This device is no longer been discovered, and therefore it is beeing&n; *&t;purged from the discovery log. Inform all clients who have&n; *&t;registered for this event...&n; * &n; *&t;Note : called exclusively from discovery.c&n; *&t;Note : as we are currently processing the log, the clients callback&n; *&t;should *NOT* attempt to touch the log now.&n; */
DECL|function|irlmp_discovery_expiry
r_void
id|irlmp_discovery_expiry
c_func
(paren
id|discovery_t
op_star
id|expiry
)paren
(brace
id|irlmp_client_t
op_star
id|client
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|expiry
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|client
op_assign
(paren
id|irlmp_client_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;clients
)paren
suffix:semicolon
r_while
c_loop
(paren
id|client
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Check if we should notify client */
r_if
c_cond
(paren
(paren
id|client-&gt;expir_callback
)paren
op_logical_and
(paren
id|client-&gt;hint_mask
op_amp
id|expiry-&gt;hints.word
op_amp
l_int|0x7f7f
)paren
)paren
id|client
op_member_access_from_pointer
id|expir_callback
c_func
(paren
id|expiry
comma
id|client-&gt;priv
)paren
suffix:semicolon
multiline_comment|/* Next client */
id|client
op_assign
(paren
id|irlmp_client_t
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irlmp-&gt;clients
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_get_discovery_response ()&n; *&n; *    Used by IrLAP to get the discovery info it needs when answering&n; *    discovery requests by other devices.&n; */
DECL|function|irlmp_get_discovery_response
id|discovery_t
op_star
id|irlmp_get_discovery_response
c_func
(paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp
op_ne
l_int|NULL
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
id|irlmp-&gt;discovery_rsp.hints.word
op_assign
id|irlmp-&gt;hints.word
suffix:semicolon
multiline_comment|/* &n;&t; *  Set character set for device name (we use ASCII), and &n;&t; *  copy device name. Remember to make room for a &bslash;0 at the &n;&t; *  end&n;&t; */
id|irlmp-&gt;discovery_rsp.charset
op_assign
id|CS_ASCII
suffix:semicolon
id|strncpy
c_func
(paren
id|irlmp-&gt;discovery_rsp.nickname
comma
id|sysctl_devname
comma
id|NICKNAME_MAX_LEN
)paren
suffix:semicolon
id|irlmp-&gt;discovery_rsp.name_len
op_assign
id|strlen
c_func
(paren
id|irlmp-&gt;discovery_rsp.nickname
)paren
suffix:semicolon
r_return
op_amp
id|irlmp-&gt;discovery_rsp
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_data_request (self, skb)&n; *&n; *    Send some data to peer device&n; *&n; */
DECL|function|irlmp_data_request
r_int
id|irlmp_data_request
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Make room for MUX header */
id|ASSERT
c_func
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
op_ge
id|LMP_HEADER
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|skb_push
c_func
(paren
id|skb
comma
id|LMP_HEADER
)paren
suffix:semicolon
r_return
id|irlmp_do_lsap_event
c_func
(paren
id|self
comma
id|LM_DATA_REQUEST
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_data_indication (handle, skb)&n; *&n; *    Got data from LAP layer so pass it up to upper layer&n; *&n; */
DECL|function|irlmp_data_indication
r_void
id|irlmp_data_indication
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* Hide LMP header from layer above */
id|skb_pull
c_func
(paren
id|skb
comma
id|LMP_HEADER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;notify.data_indication
)paren
id|self-&gt;notify
dot
id|data_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
id|skb
)paren
suffix:semicolon
r_else
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_udata_request (self, skb)&n; *&n; *    &n; *&n; */
DECL|function|irlmp_udata_request
r_int
id|irlmp_udata_request
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Make room for MUX header */
id|ASSERT
c_func
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
op_ge
id|LMP_HEADER
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|skb_push
c_func
(paren
id|skb
comma
id|LMP_HEADER
)paren
suffix:semicolon
r_return
id|irlmp_do_lsap_event
c_func
(paren
id|self
comma
id|LM_UDATA_REQUEST
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_udata_indication (self, skb)&n; *&n; *    Send unreliable data (but still within the connection)&n; *&n; */
DECL|function|irlmp_udata_indication
r_void
id|irlmp_udata_indication
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Hide LMP header from layer above */
id|skb_pull
c_func
(paren
id|skb
comma
id|LMP_HEADER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;notify.udata_indication
)paren
id|self-&gt;notify
dot
id|udata_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
id|skb
)paren
suffix:semicolon
r_else
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_connless_data_request (self, skb)&n; *&n; *    &n; *&n; */
macro_line|#ifdef CONFIG_IRDA_ULTRA
DECL|function|irlmp_connless_data_request
r_int
id|irlmp_connless_data_request
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sk_buff
op_star
id|clone_skb
suffix:semicolon
r_struct
id|lap_cb
op_star
id|lap
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Make room for MUX and PID header */
id|ASSERT
c_func
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
op_ge
id|LMP_HEADER
op_plus
id|LMP_PID_HEADER
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Insert protocol identifier */
id|skb_push
c_func
(paren
id|skb
comma
id|LMP_PID_HEADER
)paren
suffix:semicolon
id|skb-&gt;data
(braket
l_int|0
)braket
op_assign
id|self-&gt;pid
suffix:semicolon
multiline_comment|/* Connectionless sockets must use 0x70 */
id|skb_push
c_func
(paren
id|skb
comma
id|LMP_HEADER
)paren
suffix:semicolon
id|skb-&gt;data
(braket
l_int|0
)braket
op_assign
id|skb-&gt;data
(braket
l_int|1
)braket
op_assign
id|LSAP_CONNLESS
suffix:semicolon
multiline_comment|/* Try to send Connectionless  packets out on all links */
id|lap
op_assign
(paren
r_struct
id|lap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;links
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lap
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|lap-&gt;magic
op_eq
id|LMP_LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|clone_skb
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clone_skb
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|irlap_unitdata_request
c_func
(paren
id|lap-&gt;irlap
comma
id|clone_skb
)paren
suffix:semicolon
id|lap
op_assign
(paren
r_struct
id|lap_cb
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irlmp-&gt;links
)paren
suffix:semicolon
)brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IRDA_ULTRA */
multiline_comment|/*&n; * Function irlmp_connless_data_indication (self, skb)&n; *&n; *    Receive unreliable data outside any connection. Mostly used by Ultra&n; *&n; */
macro_line|#ifdef CONFIG_IRDA_ULTRA
DECL|function|irlmp_connless_data_indication
r_void
id|irlmp_connless_data_indication
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Hide LMP and PID header from layer above */
id|skb_pull
c_func
(paren
id|skb
comma
id|LMP_HEADER
op_plus
id|LMP_PID_HEADER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;notify.udata_indication
)paren
id|self-&gt;notify
dot
id|udata_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
id|skb
)paren
suffix:semicolon
r_else
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IRDA_ULTRA */
DECL|function|irlmp_status_request
r_void
id|irlmp_status_request
c_func
(paren
r_void
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Not implemented&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Propagate status indication from LAP to LSAPs (via LMP)&n; * This don&squot;t trigger any change of state in lap_cb, lmp_cb or lsap_cb,&n; * and the event is stateless, therefore we can bypass both state machines&n; * and send the event direct to the LSAP user.&n; * Jean II&n; */
DECL|function|irlmp_status_indication
r_void
id|irlmp_status_indication
c_func
(paren
r_struct
id|lap_cb
op_star
id|self
comma
id|LINK_STATUS
id|link
comma
id|LOCK_STATUS
id|lock
)paren
(brace
r_struct
id|lsap_cb
op_star
id|next
suffix:semicolon
r_struct
id|lsap_cb
op_star
id|curr
suffix:semicolon
multiline_comment|/* Send status_indication to all LSAPs using this link */
id|next
op_assign
(paren
r_struct
id|lsap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|self-&gt;lsaps
)paren
suffix:semicolon
r_while
c_loop
(paren
id|next
op_ne
l_int|NULL
)paren
(brace
id|curr
op_assign
id|next
suffix:semicolon
id|next
op_assign
(paren
r_struct
id|lsap_cb
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|self-&gt;lsaps
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|curr-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Inform service user if he has requested it&n;&t;&t; */
r_if
c_cond
(paren
id|curr-&gt;notify.status_indication
op_ne
l_int|NULL
)paren
id|curr-&gt;notify
dot
id|status_indication
c_func
(paren
id|curr-&gt;notify.instance
comma
id|link
comma
id|lock
)paren
suffix:semicolon
r_else
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), no handler&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_hint_to_service (hint)&n; *&n; *    Returns a list of all servics contained in the given hint bits. This&n; *    funtion assumes that the hint bits have the size of two bytes only&n; */
DECL|function|irlmp_hint_to_service
id|__u8
op_star
id|irlmp_hint_to_service
c_func
(paren
id|__u8
op_star
id|hint
)paren
(brace
id|__u8
op_star
id|service
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t; * Allocate array to store services in. 16 entries should be safe &n;&t; * since we currently only support 2 hint bytes&n;&t; */
id|service
op_assign
id|kmalloc
c_func
(paren
l_int|16
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|service
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unable to kmalloc!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|hint
(braket
l_int|0
)braket
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;&lt;None&gt;&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|service
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hint
(braket
l_int|0
)braket
op_amp
id|HINT_PNP
)paren
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;PnP Compatible &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hint
(braket
l_int|0
)braket
op_amp
id|HINT_PDA
)paren
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;PDA/Palmtop &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hint
(braket
l_int|0
)braket
op_amp
id|HINT_COMPUTER
)paren
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Computer &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hint
(braket
l_int|0
)braket
op_amp
id|HINT_PRINTER
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Printer &quot;
)paren
suffix:semicolon
id|service
(braket
id|i
op_increment
)braket
op_assign
id|S_PRINTER
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hint
(braket
l_int|0
)braket
op_amp
id|HINT_MODEM
)paren
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Modem &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hint
(braket
l_int|0
)braket
op_amp
id|HINT_FAX
)paren
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Fax &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hint
(braket
l_int|0
)braket
op_amp
id|HINT_LAN
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;LAN Access &quot;
)paren
suffix:semicolon
id|service
(braket
id|i
op_increment
)braket
op_assign
id|S_LAN
suffix:semicolon
)brace
multiline_comment|/* &n;&t; *  Test if extension byte exists. This byte will usually be&n;&t; *  there, but this is not really required by the standard.&n;&t; *  (IrLMP p. 29)&n;&t; */
r_if
c_cond
(paren
id|hint
(braket
l_int|0
)braket
op_amp
id|HINT_EXTENSION
)paren
(brace
r_if
c_cond
(paren
id|hint
(braket
l_int|1
)braket
op_amp
id|HINT_TELEPHONY
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Telephony &quot;
)paren
suffix:semicolon
id|service
(braket
id|i
op_increment
)braket
op_assign
id|S_TELEPHONY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hint
(braket
l_int|1
)braket
op_amp
id|HINT_FILE_SERVER
)paren
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;File Server &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hint
(braket
l_int|1
)braket
op_amp
id|HINT_COMM
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;IrCOMM &quot;
)paren
suffix:semicolon
id|service
(braket
id|i
op_increment
)braket
op_assign
id|S_COMM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hint
(braket
l_int|1
)braket
op_amp
id|HINT_OBEX
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;IrOBEX &quot;
)paren
suffix:semicolon
id|service
(braket
id|i
op_increment
)braket
op_assign
id|S_OBEX
suffix:semicolon
)brace
)brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* So that client can be notified about any discovery */
id|service
(braket
id|i
op_increment
)braket
op_assign
id|S_ANY
suffix:semicolon
id|service
(braket
id|i
)braket
op_assign
id|S_END
suffix:semicolon
r_return
id|service
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_service_to_hint (service)&n; *&n; *    Converts a service type, to a hint bit&n; *&n; *    Returns: a 16 bit hint value, with the service bit set&n; */
DECL|function|irlmp_service_to_hint
id|__u16
id|irlmp_service_to_hint
c_func
(paren
r_int
id|service
)paren
(brace
id|__u16_host_order
id|hint
suffix:semicolon
id|hint.word
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|service
)paren
(brace
r_case
id|S_PNP
suffix:colon
id|hint.byte
(braket
l_int|0
)braket
op_or_assign
id|HINT_PNP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_PDA
suffix:colon
id|hint.byte
(braket
l_int|0
)braket
op_or_assign
id|HINT_PDA
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_COMPUTER
suffix:colon
id|hint.byte
(braket
l_int|0
)braket
op_or_assign
id|HINT_COMPUTER
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_PRINTER
suffix:colon
id|hint.byte
(braket
l_int|0
)braket
op_or_assign
id|HINT_PRINTER
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_MODEM
suffix:colon
id|hint.byte
(braket
l_int|0
)braket
op_or_assign
id|HINT_PRINTER
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_LAN
suffix:colon
id|hint.byte
(braket
l_int|0
)braket
op_or_assign
id|HINT_LAN
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_COMM
suffix:colon
id|hint.byte
(braket
l_int|0
)braket
op_or_assign
id|HINT_EXTENSION
suffix:semicolon
id|hint.byte
(braket
l_int|1
)braket
op_or_assign
id|HINT_COMM
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_OBEX
suffix:colon
id|hint.byte
(braket
l_int|0
)braket
op_or_assign
id|HINT_EXTENSION
suffix:semicolon
id|hint.byte
(braket
l_int|1
)braket
op_or_assign
id|HINT_OBEX
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_TELEPHONY
suffix:colon
id|hint.byte
(braket
l_int|0
)braket
op_or_assign
id|HINT_EXTENSION
suffix:semicolon
id|hint.byte
(braket
l_int|1
)braket
op_or_assign
id|HINT_TELEPHONY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_ANY
suffix:colon
id|hint.word
op_assign
l_int|0xffff
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unknown service!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|hint.word
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_register_service (service)&n; *&n; *    Register local service with IrLMP&n; *&n; */
DECL|function|irlmp_register_service
id|__u32
id|irlmp_register_service
c_func
(paren
id|__u16
id|hints
)paren
(brace
id|irlmp_service_t
op_star
id|service
suffix:semicolon
id|__u32
id|handle
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), hints = %04x&bslash;n&quot;
comma
id|hints
)paren
suffix:semicolon
multiline_comment|/* Get a unique handle for this service */
id|get_random_bytes
c_func
(paren
op_amp
id|handle
comma
r_sizeof
(paren
id|handle
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|hashbin_find
c_func
(paren
id|irlmp-&gt;services
comma
id|handle
comma
l_int|NULL
)paren
op_logical_or
op_logical_neg
id|handle
)paren
id|get_random_bytes
c_func
(paren
op_amp
id|handle
comma
r_sizeof
(paren
id|handle
)paren
)paren
suffix:semicolon
id|irlmp-&gt;hints.word
op_or_assign
id|hints
suffix:semicolon
multiline_comment|/* Make a new registration */
id|service
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|irlmp_service_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|service
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unable to kmalloc!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|service-&gt;hints
op_assign
id|hints
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|irlmp-&gt;services
comma
(paren
id|irda_queue_t
op_star
)paren
id|service
comma
id|handle
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|handle
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_unregister_service (handle)&n; *&n; *    Unregister service with IrLMP. &n; *&n; *    Returns: 0 on success, -1 on error&n; */
DECL|function|irlmp_unregister_service
r_int
id|irlmp_unregister_service
c_func
(paren
id|__u32
id|handle
)paren
(brace
id|irlmp_service_t
op_star
id|service
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|service
op_assign
id|hashbin_find
c_func
(paren
id|irlmp-&gt;services
comma
id|handle
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|service
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unknown service!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|service
op_assign
id|hashbin_remove
c_func
(paren
id|irlmp-&gt;services
comma
id|handle
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|service
)paren
id|kfree
c_func
(paren
id|service
)paren
suffix:semicolon
multiline_comment|/* Remove old hint bits */
id|irlmp-&gt;hints.word
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Refresh current hint bits */
id|service
op_assign
(paren
id|irlmp_service_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;services
)paren
suffix:semicolon
r_while
c_loop
(paren
id|service
)paren
(brace
id|irlmp-&gt;hints.word
op_or_assign
id|service-&gt;hints
suffix:semicolon
id|service
op_assign
(paren
id|irlmp_service_t
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irlmp-&gt;services
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_register_client (hint_mask, callback1, callback2)&n; *&n; *    Register a local client with IrLMP&n; *&t;First callback is selective discovery (based on hints)&n; *&t;Second callback is for selective discovery expiries&n; *&n; *    Returns: handle &gt; 0 on success, 0 on error&n; */
DECL|function|irlmp_register_client
id|__u32
id|irlmp_register_client
c_func
(paren
id|__u16
id|hint_mask
comma
id|DISCOVERY_CALLBACK1
id|disco_clb
comma
id|DISCOVERY_CALLBACK1
id|expir_clb
comma
r_void
op_star
id|priv
)paren
(brace
id|irlmp_client_t
op_star
id|client
suffix:semicolon
id|__u32
id|handle
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Get a unique handle for this client */
id|get_random_bytes
c_func
(paren
op_amp
id|handle
comma
r_sizeof
(paren
id|handle
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|hashbin_find
c_func
(paren
id|irlmp-&gt;clients
comma
id|handle
comma
l_int|NULL
)paren
op_logical_or
op_logical_neg
id|handle
)paren
id|get_random_bytes
c_func
(paren
op_amp
id|handle
comma
r_sizeof
(paren
id|handle
)paren
)paren
suffix:semicolon
multiline_comment|/* Make a new registration */
id|client
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|irlmp_client_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|client
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unable to kmalloc!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Register the details */
id|client-&gt;hint_mask
op_assign
id|hint_mask
suffix:semicolon
id|client-&gt;disco_callback
op_assign
id|disco_clb
suffix:semicolon
id|client-&gt;expir_callback
op_assign
id|expir_clb
suffix:semicolon
id|client-&gt;priv
op_assign
id|priv
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|irlmp-&gt;clients
comma
(paren
id|irda_queue_t
op_star
)paren
id|client
comma
id|handle
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|handle
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_update_client (handle, hint_mask, callback1, callback2)&n; *&n; *    Updates specified client (handle) with possibly new hint_mask and&n; *    callback&n; *&n; *    Returns: 0 on success, -1 on error&n; */
DECL|function|irlmp_update_client
r_int
id|irlmp_update_client
c_func
(paren
id|__u32
id|handle
comma
id|__u16
id|hint_mask
comma
id|DISCOVERY_CALLBACK1
id|disco_clb
comma
id|DISCOVERY_CALLBACK1
id|expir_clb
comma
r_void
op_star
id|priv
)paren
(brace
id|irlmp_client_t
op_star
id|client
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|client
op_assign
id|hashbin_find
c_func
(paren
id|irlmp-&gt;clients
comma
id|handle
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|client
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unknown client!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|client-&gt;hint_mask
op_assign
id|hint_mask
suffix:semicolon
id|client-&gt;disco_callback
op_assign
id|disco_clb
suffix:semicolon
id|client-&gt;expir_callback
op_assign
id|expir_clb
suffix:semicolon
id|client-&gt;priv
op_assign
id|priv
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_unregister_client (handle)&n; *&n; *    Returns: 0 on success, -1 on error&n; *&n; */
DECL|function|irlmp_unregister_client
r_int
id|irlmp_unregister_client
c_func
(paren
id|__u32
id|handle
)paren
(brace
r_struct
id|irlmp_client
op_star
id|client
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|client
op_assign
id|hashbin_find
c_func
(paren
id|irlmp-&gt;clients
comma
id|handle
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|client
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unknown client!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), removing client!&bslash;n&quot;
)paren
suffix:semicolon
id|client
op_assign
id|hashbin_remove
c_func
(paren
id|irlmp-&gt;clients
comma
id|handle
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|client
)paren
id|kfree
c_func
(paren
id|client
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_slsap_inuse (slsap)&n; *&n; *    Check if the given source LSAP selector is in use&n; */
DECL|function|irlmp_slsap_inuse
r_int
id|irlmp_slsap_inuse
c_func
(paren
id|__u8
id|slsap_sel
)paren
(brace
r_struct
id|lsap_cb
op_star
id|self
suffix:semicolon
r_struct
id|lap_cb
op_star
id|lap
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp
op_ne
l_int|NULL
comma
r_return
id|TRUE
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp-&gt;magic
op_eq
id|LMP_MAGIC
comma
r_return
id|TRUE
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|slsap_sel
op_ne
id|LSAP_ANY
comma
r_return
id|TRUE
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_ULTRA
multiline_comment|/* Accept all bindings to the connectionless LSAP */
r_if
c_cond
(paren
id|slsap_sel
op_eq
id|LSAP_CONNLESS
)paren
r_return
id|FALSE
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_ULTRA */
multiline_comment|/* Valid values are between 0 and 127 */
r_if
c_cond
(paren
id|slsap_sel
OG
id|LSAP_MAX
)paren
r_return
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t; *  Check if slsap is already in use. To do this we have to loop over&n;&t; *  every IrLAP connection and check every LSAP assosiated with each&n;&t; *  the connection.&n;&t; */
id|lap
op_assign
(paren
r_struct
id|lap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;links
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lap
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|lap-&gt;magic
op_eq
id|LMP_LAP_MAGIC
comma
r_return
id|TRUE
suffix:semicolon
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|lsap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|lap-&gt;lsaps
)paren
suffix:semicolon
r_while
c_loop
(paren
id|self
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
id|TRUE
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|self-&gt;slsap_sel
op_eq
id|slsap_sel
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Source LSAP selector=%02x in use&bslash;n&quot;
comma
id|self-&gt;slsap_sel
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
id|self
op_assign
(paren
r_struct
id|lsap_cb
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|lap-&gt;lsaps
)paren
suffix:semicolon
)brace
id|lap
op_assign
(paren
r_struct
id|lap_cb
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irlmp-&gt;links
)paren
suffix:semicolon
)brace
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_find_free_slsap ()&n; *&n; *    Find a free source LSAP to use. This function is called if the service&n; *    user has requested a source LSAP equal to LM_ANY&n; */
DECL|function|irlmp_find_free_slsap
id|__u8
id|irlmp_find_free_slsap
c_func
(paren
r_void
)paren
(brace
id|__u8
id|lsap_sel
suffix:semicolon
r_int
id|wrapped
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp-&gt;magic
op_eq
id|LMP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|lsap_sel
op_assign
id|irlmp-&gt;free_lsap_sel
op_increment
suffix:semicolon
multiline_comment|/* Check if the new free lsap is really free */
r_while
c_loop
(paren
id|irlmp_slsap_inuse
c_func
(paren
id|irlmp-&gt;free_lsap_sel
)paren
)paren
(brace
id|irlmp-&gt;free_lsap_sel
op_increment
suffix:semicolon
multiline_comment|/* Check if we need to wraparound (0x70-0x7f are reserved) */
r_if
c_cond
(paren
id|irlmp-&gt;free_lsap_sel
OG
id|LSAP_MAX
)paren
(brace
id|irlmp-&gt;free_lsap_sel
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* Make sure we terminate the loop */
r_if
c_cond
(paren
id|wrapped
op_increment
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), next free lsap_sel=%02x&bslash;n&quot;
comma
id|lsap_sel
)paren
suffix:semicolon
r_return
id|lsap_sel
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_convert_lap_reason (lap_reason)&n; *&n; *    Converts IrLAP disconnect reason codes to IrLMP disconnect reason&n; *    codes&n; *&n; */
DECL|function|irlmp_convert_lap_reason
id|LM_REASON
id|irlmp_convert_lap_reason
c_func
(paren
id|LAP_REASON
id|lap_reason
)paren
(brace
r_int
id|reason
op_assign
id|LM_LAP_DISCONNECT
suffix:semicolon
r_switch
c_cond
(paren
id|lap_reason
)paren
(brace
r_case
id|LAP_DISC_INDICATION
suffix:colon
multiline_comment|/* Received a disconnect request from peer */
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), LAP_DISC_INDICATION&bslash;n&quot;
)paren
suffix:semicolon
id|reason
op_assign
id|LM_USER_REQUEST
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LAP_NO_RESPONSE
suffix:colon
multiline_comment|/* To many retransmits without response */
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), LAP_NO_RESPONSE&bslash;n&quot;
)paren
suffix:semicolon
id|reason
op_assign
id|LM_LAP_DISCONNECT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LAP_RESET_INDICATION
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), LAP_RESET_INDICATION&bslash;n&quot;
)paren
suffix:semicolon
id|reason
op_assign
id|LM_LAP_RESET
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LAP_FOUND_NONE
suffix:colon
r_case
id|LAP_MEDIA_BUSY
suffix:colon
r_case
id|LAP_PRIMARY_CONFLICT
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), LAP_FOUND_NONE, LAP_MEDIA_BUSY or LAP_PRIMARY_CONFLICT&bslash;n&quot;
)paren
suffix:semicolon
id|reason
op_assign
id|LM_CONNECT_FAILURE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unknow IrLAP disconnect reason %d!&bslash;n&quot;
comma
id|lap_reason
)paren
suffix:semicolon
id|reason
op_assign
id|LM_LAP_DISCONNECT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|reason
suffix:semicolon
)brace
DECL|function|irlmp_get_saddr
id|__u32
id|irlmp_get_saddr
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
)paren
(brace
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;lap
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
r_return
id|self-&gt;lap-&gt;saddr
suffix:semicolon
)brace
DECL|function|irlmp_get_daddr
id|__u32
id|irlmp_get_daddr
c_func
(paren
r_struct
id|lsap_cb
op_star
id|self
)paren
(brace
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;lap
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
r_return
id|self-&gt;lap-&gt;daddr
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/*&n; * Function irlmp_proc_read (buf, start, offset, len, unused)&n; *&n; *    Give some info to the /proc file system&n; *&n; */
DECL|function|irlmp_proc_read
r_int
id|irlmp_proc_read
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|len
)paren
(brace
r_struct
id|lsap_cb
op_star
id|self
suffix:semicolon
r_struct
id|lap_cb
op_star
id|lap
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ASSERT
c_func
(paren
id|irlmp
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Unconnected LSAPs:&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|lsap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
)paren
suffix:semicolon
r_while
c_loop
(paren
id|self
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;lsap state: %s, &quot;
comma
id|irlsap_state
(braket
id|self-&gt;lsap_state
)braket
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;slsap_sel: %#02x, dlsap_sel: %#02x, &quot;
comma
id|self-&gt;slsap_sel
comma
id|self-&gt;dlsap_sel
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;(%s)&quot;
comma
id|self-&gt;notify.name
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|lsap_cb
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irlmp-&gt;unconnected_lsaps
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;nRegistred Link Layers:&bslash;n&quot;
)paren
suffix:semicolon
id|lap
op_assign
(paren
r_struct
id|lap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlmp-&gt;links
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lap
op_ne
l_int|NULL
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;lap state: %s, &quot;
comma
id|irlmp_state
(braket
id|lap-&gt;lap_state
)braket
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;saddr: %#08x, daddr: %#08x, &quot;
comma
id|lap-&gt;saddr
comma
id|lap-&gt;daddr
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;refcount: %d&quot;
comma
id|lap-&gt;refcount
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;nConnected LSAPs:&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|lsap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|lap-&gt;lsaps
)paren
suffix:semicolon
r_while
c_loop
(paren
id|self
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LMP_LSAP_MAGIC
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;lsap state: %s, &quot;
comma
id|irlsap_state
(braket
id|self-&gt;lsap_state
)braket
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;slsap_sel: %#02x, dlsap_sel: %#02x, &quot;
comma
id|self-&gt;slsap_sel
comma
id|self-&gt;dlsap_sel
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;(%s)&quot;
comma
id|self-&gt;notify.name
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|lsap_cb
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|lap-&gt;lsaps
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|lap
op_assign
(paren
r_struct
id|lap_cb
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irlmp-&gt;links
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif /* PROC_FS */
eof
