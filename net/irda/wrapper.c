multiline_comment|/*********************************************************************&n; *                &n; * Filename:      wrapper.c&n; * Version:       1.2&n; * Description:   IrDA SIR async wrapper layer&n; * Status:        Stable&n; * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Created at:    Mon Aug  4 20:40:53 1997&n; * Modified at:   Fri Jan 28 13:21:09 2000&n; * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Modified at:   Fri May 28  3:11 CST 1999&n; * Modified by:   Horst von Brand &lt;vonbrand@sleipnir.valparaiso.cl&gt;&n; * &n; *     Copyright (c) 1998-2000 Dag Brattli &lt;dagb@cs.uit.no&gt;, &n; *     All Rights Reserved.&n; *     &n; *     This program is free software; you can redistribute it and/or &n; *     modify it under the terms of the GNU General Public License as &n; *     published by the Free Software Foundation; either version 2 of &n; *     the License, or (at your option) any later version.&n; *&n; *     Neither Dag Brattli nor University of Troms&#xfffd; admit liability nor&n; *     provide warranty for any of this software. This material is &n; *     provided &quot;AS-IS&quot; and at no charge.&n; *&n; ********************************************************************/
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/wrapper.h&gt;
macro_line|#include &lt;net/irda/irtty.h&gt;
macro_line|#include &lt;net/irda/crc.h&gt;
macro_line|#include &lt;net/irda/irlap.h&gt;
macro_line|#include &lt;net/irda/irlap_frame.h&gt;
macro_line|#include &lt;net/irda/irda_device.h&gt;
r_static
r_inline
r_int
id|stuff_byte
c_func
(paren
id|__u8
id|byte
comma
id|__u8
op_star
id|buf
)paren
suffix:semicolon
r_static
r_void
id|state_outside_frame
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device_stats
op_star
id|stats
comma
id|iobuff_t
op_star
id|rx_buff
comma
id|__u8
id|byte
)paren
suffix:semicolon
r_static
r_void
id|state_begin_frame
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device_stats
op_star
id|stats
comma
id|iobuff_t
op_star
id|rx_buff
comma
id|__u8
id|byte
)paren
suffix:semicolon
r_static
r_void
id|state_link_escape
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device_stats
op_star
id|stats
comma
id|iobuff_t
op_star
id|rx_buff
comma
id|__u8
id|byte
)paren
suffix:semicolon
r_static
r_void
id|state_inside_frame
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device_stats
op_star
id|stats
comma
id|iobuff_t
op_star
id|rx_buff
comma
id|__u8
id|byte
)paren
suffix:semicolon
DECL|variable|state
r_static
r_void
(paren
op_star
id|state
(braket
)braket
)paren
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device_stats
op_star
id|stats
comma
id|iobuff_t
op_star
id|rx_buff
comma
id|__u8
id|byte
)paren
op_assign
(brace
id|state_outside_frame
comma
id|state_begin_frame
comma
id|state_link_escape
comma
id|state_inside_frame
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Function async_wrap (skb, *tx_buff, buffsize)&n; *&n; *    Makes a new buffer with wrapping and stuffing, should check that &n; *    we don&squot;t get tx buffer overflow.&n; */
DECL|function|async_wrap_skb
r_int
id|async_wrap_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
id|__u8
op_star
id|tx_buff
comma
r_int
id|buffsize
)paren
(brace
r_struct
id|irda_skb_cb
op_star
id|cb
op_assign
(paren
r_struct
id|irda_skb_cb
op_star
)paren
id|skb-&gt;cb
suffix:semicolon
r_int
id|xbofs
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|n
suffix:semicolon
r_union
(brace
id|__u16
id|value
suffix:semicolon
id|__u8
id|bytes
(braket
l_int|2
)braket
suffix:semicolon
)brace
id|fcs
suffix:semicolon
multiline_comment|/* Initialize variables */
id|fcs.value
op_assign
id|INIT_FCS
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Send  XBOF&squot;s for required min. turn time and for the negotiated&n;&t; *  additional XBOFS&n;&t; */
r_if
c_cond
(paren
id|cb-&gt;magic
op_ne
id|LAP_MAGIC
)paren
(brace
multiline_comment|/* &n;&t;&t; * This will happen for all frames sent from user-space.&n;&t;&t; * Nothing to worry about, but we set the default number of &n;&t;&t; * BOF&squot;s&n;&t;&t; */
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), wrong magic in skb!&bslash;n&quot;
)paren
suffix:semicolon
id|xbofs
op_assign
l_int|10
suffix:semicolon
)brace
r_else
id|xbofs
op_assign
id|cb-&gt;xbofs
op_plus
id|cb-&gt;xbofs_delay
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), xbofs=%d&bslash;n&quot;
comma
id|xbofs
)paren
suffix:semicolon
multiline_comment|/* Check that we never use more than 115 + 48 xbofs */
r_if
c_cond
(paren
id|xbofs
OG
l_int|163
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), too many xbofs (%d)&bslash;n&quot;
comma
id|xbofs
)paren
suffix:semicolon
id|xbofs
op_assign
l_int|163
suffix:semicolon
)brace
id|memset
c_func
(paren
id|tx_buff
op_plus
id|n
comma
id|XBOF
comma
id|xbofs
)paren
suffix:semicolon
id|n
op_add_assign
id|xbofs
suffix:semicolon
multiline_comment|/* Start of packet character BOF */
id|tx_buff
(braket
id|n
op_increment
)braket
op_assign
id|BOF
suffix:semicolon
multiline_comment|/* Insert frame and calc CRC */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb-&gt;len
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *  Check for the possibility of tx buffer overflow. We use&n;&t;&t; *  bufsize-5 since the maximum number of bytes that can be &n;&t;&t; *  transmitted after this point is 5.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|n
OL
(paren
id|buffsize
op_minus
l_int|5
)paren
comma
r_return
id|n
suffix:semicolon
)paren
suffix:semicolon
id|n
op_add_assign
id|stuff_byte
c_func
(paren
id|skb-&gt;data
(braket
id|i
)braket
comma
id|tx_buff
op_plus
id|n
)paren
suffix:semicolon
id|fcs.value
op_assign
id|irda_fcs
c_func
(paren
id|fcs.value
comma
id|skb-&gt;data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Insert CRC in little endian format (LSB first) */
id|fcs.value
op_assign
op_complement
id|fcs.value
suffix:semicolon
macro_line|#ifdef __LITTLE_ENDIAN
id|n
op_add_assign
id|stuff_byte
c_func
(paren
id|fcs.bytes
(braket
l_int|0
)braket
comma
id|tx_buff
op_plus
id|n
)paren
suffix:semicolon
id|n
op_add_assign
id|stuff_byte
c_func
(paren
id|fcs.bytes
(braket
l_int|1
)braket
comma
id|tx_buff
op_plus
id|n
)paren
suffix:semicolon
macro_line|#else ifdef __BIG_ENDIAN
id|n
op_add_assign
id|stuff_byte
c_func
(paren
id|fcs.bytes
(braket
l_int|1
)braket
comma
id|tx_buff
op_plus
id|n
)paren
suffix:semicolon
id|n
op_add_assign
id|stuff_byte
c_func
(paren
id|fcs.bytes
(braket
l_int|0
)braket
comma
id|tx_buff
op_plus
id|n
)paren
suffix:semicolon
macro_line|#endif
id|tx_buff
(braket
id|n
op_increment
)braket
op_assign
id|EOF
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; * Function stuff_byte (byte, buf)&n; *&n; *    Byte stuff one single byte and put the result in buffer pointed to by&n; *    buf. The buffer must at all times be able to have two bytes inserted.&n; * &n; */
DECL|function|stuff_byte
r_static
r_inline
r_int
id|stuff_byte
c_func
(paren
id|__u8
id|byte
comma
id|__u8
op_star
id|buf
)paren
(brace
r_switch
c_cond
(paren
id|byte
)paren
(brace
r_case
id|BOF
suffix:colon
multiline_comment|/* FALLTHROUGH */
r_case
id|EOF
suffix:colon
multiline_comment|/* FALLTHROUGH */
r_case
id|CE
suffix:colon
multiline_comment|/* Insert transparently coded */
id|buf
(braket
l_int|0
)braket
op_assign
id|CE
suffix:semicolon
multiline_comment|/* Send link escape */
id|buf
(braket
l_int|1
)braket
op_assign
id|byte
op_xor
id|IRDA_TRANS
suffix:semicolon
multiline_comment|/* Complement bit 5 */
r_return
l_int|2
suffix:semicolon
multiline_comment|/* break; */
r_default
suffix:colon
multiline_comment|/* Non-special value, no transparency required */
id|buf
(braket
l_int|0
)braket
op_assign
id|byte
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* break; */
)brace
)brace
multiline_comment|/*&n; * Function async_bump (buf, len, stats)&n; *&n; *    Got a frame, make a copy of it, and pass it up the stack! We can try&n; *    to inline it since it&squot;s only called from state_inside_frame&n; */
DECL|function|async_bump
r_inline
r_void
id|async_bump
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device_stats
op_star
id|stats
comma
id|__u8
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|len
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|stats-&gt;rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Align IP header to 20 bytes */
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Copy data without CRC */
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|len
op_minus
l_int|2
)paren
comma
id|buf
comma
id|len
op_minus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Feed it to IrLAP layer */
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IRDA
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|stats-&gt;rx_packets
op_increment
suffix:semicolon
id|stats-&gt;rx_bytes
op_add_assign
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Function async_unwrap_char (dev, rx_buff, byte)&n; *&n; *    Parse and de-stuff frame received from the IrDA-port&n; *&n; */
DECL|function|async_unwrap_char
r_inline
r_void
id|async_unwrap_char
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device_stats
op_star
id|stats
comma
id|iobuff_t
op_star
id|rx_buff
comma
id|__u8
id|byte
)paren
(brace
(paren
op_star
id|state
(braket
id|rx_buff-&gt;state
)braket
)paren
(paren
id|dev
comma
id|stats
comma
id|rx_buff
comma
id|byte
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function state_outside_frame (dev, rx_buff, byte)&n; *&n; *    Not receiving any frame (or just bogus data)&n; *&n; */
DECL|function|state_outside_frame
r_static
r_void
id|state_outside_frame
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device_stats
op_star
id|stats
comma
id|iobuff_t
op_star
id|rx_buff
comma
id|__u8
id|byte
)paren
(brace
r_switch
c_cond
(paren
id|byte
)paren
(brace
r_case
id|BOF
suffix:colon
id|rx_buff-&gt;state
op_assign
id|BEGIN_FRAME
suffix:semicolon
id|rx_buff-&gt;in_frame
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XBOF
suffix:colon
multiline_comment|/* idev-&gt;xbofs++; */
r_break
suffix:semicolon
r_case
id|EOF
suffix:colon
id|irda_device_set_media_busy
c_func
(paren
id|dev
comma
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|irda_device_set_media_busy
c_func
(paren
id|dev
comma
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function state_begin_frame (idev, byte)&n; *&n; *    Begin of frame detected&n; *&n; */
DECL|function|state_begin_frame
r_static
r_void
id|state_begin_frame
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device_stats
op_star
id|stats
comma
id|iobuff_t
op_star
id|rx_buff
comma
id|__u8
id|byte
)paren
(brace
multiline_comment|/* Time to initialize receive buffer */
id|rx_buff-&gt;data
op_assign
id|rx_buff-&gt;head
suffix:semicolon
id|rx_buff-&gt;len
op_assign
l_int|0
suffix:semicolon
id|rx_buff-&gt;fcs
op_assign
id|INIT_FCS
suffix:semicolon
r_switch
c_cond
(paren
id|byte
)paren
(brace
r_case
id|BOF
suffix:colon
multiline_comment|/* Continue */
r_break
suffix:semicolon
r_case
id|CE
suffix:colon
multiline_comment|/* Stuffed byte */
id|rx_buff-&gt;state
op_assign
id|LINK_ESCAPE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EOF
suffix:colon
multiline_comment|/* Abort frame */
id|rx_buff-&gt;state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), abort frame&bslash;n&quot;
)paren
suffix:semicolon
id|stats-&gt;rx_errors
op_increment
suffix:semicolon
id|stats-&gt;rx_frame_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|rx_buff-&gt;data
(braket
id|rx_buff-&gt;len
op_increment
)braket
op_assign
id|byte
suffix:semicolon
id|rx_buff-&gt;fcs
op_assign
id|irda_fcs
c_func
(paren
id|rx_buff-&gt;fcs
comma
id|byte
)paren
suffix:semicolon
id|rx_buff-&gt;state
op_assign
id|INSIDE_FRAME
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function state_link_escape (dev, byte)&n; *&n; *    Found link escape character&n; *&n; */
DECL|function|state_link_escape
r_static
r_void
id|state_link_escape
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device_stats
op_star
id|stats
comma
id|iobuff_t
op_star
id|rx_buff
comma
id|__u8
id|byte
)paren
(brace
r_switch
c_cond
(paren
id|byte
)paren
(brace
r_case
id|BOF
suffix:colon
multiline_comment|/* New frame? */
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Discarding incomplete frame&bslash;n&quot;
)paren
suffix:semicolon
id|rx_buff-&gt;state
op_assign
id|BEGIN_FRAME
suffix:semicolon
id|irda_device_set_media_busy
c_func
(paren
id|dev
comma
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CE
suffix:colon
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), state not defined&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EOF
suffix:colon
multiline_comment|/* Abort frame */
id|rx_buff-&gt;state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* &n;&t;&t; *  Stuffed char, complement bit 5 of byte &n;&t;&t; *  following CE, IrLAP p.114 &n;&t;&t; */
id|byte
op_xor_assign
id|IRDA_TRANS
suffix:semicolon
r_if
c_cond
(paren
id|rx_buff-&gt;len
OL
id|rx_buff-&gt;truesize
)paren
(brace
id|rx_buff-&gt;data
(braket
id|rx_buff-&gt;len
op_increment
)braket
op_assign
id|byte
suffix:semicolon
id|rx_buff-&gt;fcs
op_assign
id|irda_fcs
c_func
(paren
id|rx_buff-&gt;fcs
comma
id|byte
)paren
suffix:semicolon
id|rx_buff-&gt;state
op_assign
id|INSIDE_FRAME
suffix:semicolon
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), rx buffer overflow&bslash;n&quot;
)paren
suffix:semicolon
id|rx_buff-&gt;state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function state_inside_frame (dev, byte)&n; *&n; *    Handle bytes received within a frame&n; *&n; */
DECL|function|state_inside_frame
r_static
r_void
id|state_inside_frame
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device_stats
op_star
id|stats
comma
id|iobuff_t
op_star
id|rx_buff
comma
id|__u8
id|byte
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|byte
)paren
(brace
r_case
id|BOF
suffix:colon
multiline_comment|/* New frame? */
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Discarding incomplete frame&bslash;n&quot;
)paren
suffix:semicolon
id|rx_buff-&gt;state
op_assign
id|BEGIN_FRAME
suffix:semicolon
id|irda_device_set_media_busy
c_func
(paren
id|dev
comma
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CE
suffix:colon
multiline_comment|/* Stuffed char */
id|rx_buff-&gt;state
op_assign
id|LINK_ESCAPE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EOF
suffix:colon
multiline_comment|/* End of frame */
id|rx_buff-&gt;state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
id|rx_buff-&gt;in_frame
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Test FCS and signal success if the frame is good */
r_if
c_cond
(paren
id|rx_buff-&gt;fcs
op_eq
id|GOOD_FCS
)paren
(brace
multiline_comment|/* Deliver frame */
id|async_bump
c_func
(paren
id|dev
comma
id|stats
comma
id|rx_buff-&gt;data
comma
id|rx_buff-&gt;len
)paren
suffix:semicolon
id|ret
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Wrong CRC, discard frame!  */
id|irda_device_set_media_busy
c_func
(paren
id|dev
comma
id|TRUE
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), crc error&bslash;n&quot;
)paren
suffix:semicolon
id|stats-&gt;rx_errors
op_increment
suffix:semicolon
id|stats-&gt;rx_crc_errors
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* Must be the next byte of the frame */
r_if
c_cond
(paren
id|rx_buff-&gt;len
OL
id|rx_buff-&gt;truesize
)paren
(brace
id|rx_buff-&gt;data
(braket
id|rx_buff-&gt;len
op_increment
)braket
op_assign
id|byte
suffix:semicolon
id|rx_buff-&gt;fcs
op_assign
id|irda_fcs
c_func
(paren
id|rx_buff-&gt;fcs
comma
id|byte
)paren
suffix:semicolon
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Rx buffer overflow, aborting&bslash;n&quot;
)paren
suffix:semicolon
id|rx_buff-&gt;state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
eof
