multiline_comment|/*********************************************************************&n; *                &n; * Filename:      wrapper.c&n; * Version:       1.0&n; * Description:   SIR wrapper layer&n; * Status:        Experimental.&n; * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Created at:    Mon Aug  4 20:40:53 1997&n; * Modified at:   Tue Feb 16 17:27:23 1999&n; * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * &n; *     Copyright (c) 1998 Dag Brattli &lt;dagb@cs.uit.no&gt;, &n; *     All Rights Reserved.&n; *     &n; *     This program is free software; you can redistribute it and/or &n; *     modify it under the terms of the GNU General Public License as &n; *     published by the Free Software Foundation; either version 2 of &n; *     the License, or (at your option) any later version.&n; *&n; *     Neither Dag Brattli nor University of Troms&#xfffd; admit liability nor&n; *     provide warranty for any of this software. This material is &n; *     provided &quot;AS-IS&quot; and at no charge.&n; *&n; ********************************************************************/
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/wrapper.h&gt;
macro_line|#include &lt;net/irda/irtty.h&gt;
macro_line|#include &lt;net/irda/crc.h&gt;
macro_line|#include &lt;net/irda/irlap.h&gt;
macro_line|#include &lt;net/irda/irlap_frame.h&gt;
macro_line|#include &lt;net/irda/irda_device.h&gt;
DECL|macro|MIN_LENGTH
mdefine_line|#define MIN_LENGTH 14
r_inline
r_static
r_int
id|stuff_byte
c_func
(paren
id|__u8
id|byte
comma
id|__u8
op_star
id|buf
)paren
suffix:semicolon
multiline_comment|/*&n; * Function async_wrap (skb, *tx_buff)&n; *&n; *    Makes a new buffer with wrapping and stuffing, should check that &n; *    we don&squot;t get tx buffer overflow.&n; */
DECL|function|async_wrap_skb
r_int
id|async_wrap_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
id|__u8
op_star
id|tx_buff
comma
r_int
id|buffsize
)paren
(brace
id|__u8
id|byte
suffix:semicolon
r_int
id|i
comma
id|n
suffix:semicolon
r_int
id|xbofs
suffix:semicolon
r_union
(brace
id|__u16
id|value
suffix:semicolon
id|__u8
id|bytes
(braket
l_int|2
)braket
suffix:semicolon
)brace
id|fcs
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Initialize variables */
id|fcs.value
op_assign
id|INIT_FCS
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OG
l_int|2048
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;Warning size=%d of sk_buff to big!&bslash;n&quot;
comma
(paren
r_int
)paren
id|skb-&gt;len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Send  XBOF&squot;s for required min. turn time and for the negotiated&n;&t; *  additional XBOFS&n;&t; */
id|xbofs
op_assign
(paren
(paren
r_struct
id|irlap_skb_cb
op_star
)paren
(paren
id|skb-&gt;cb
)paren
)paren
op_member_access_from_pointer
id|xbofs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|xbofs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tx_buff
(braket
id|n
op_increment
)braket
op_assign
id|XBOF
suffix:semicolon
)brace
multiline_comment|/* Start of packet character BOF */
id|tx_buff
(braket
id|n
op_increment
)braket
op_assign
id|BOF
suffix:semicolon
multiline_comment|/* Insert frame and calc CRC */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb-&gt;len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|byte
op_assign
id|skb-&gt;data
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Check for the possibility of tx buffer overflow. We use&n;&t;&t; *  bufsize-5 since the maximum number of bytes that can be &n;&t;&t; *  transmitted after this point is 5.&n;&t;&t; */
r_if
c_cond
(paren
id|n
OG
id|buffsize
op_minus
l_int|5
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;IrDA Wrapper: TX-buffer overflow!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
id|n
op_add_assign
id|stuff_byte
c_func
(paren
id|byte
comma
id|tx_buff
op_plus
id|n
)paren
suffix:semicolon
id|fcs.value
op_assign
id|IR_FCS
c_func
(paren
id|fcs.value
comma
id|byte
)paren
suffix:semicolon
)brace
multiline_comment|/* Insert CRC in little endian format (LSB first) */
id|fcs.value
op_assign
op_complement
id|fcs.value
suffix:semicolon
macro_line|#ifdef __LITTLE_ENDIAN
id|n
op_add_assign
id|stuff_byte
c_func
(paren
id|fcs.bytes
(braket
l_int|0
)braket
comma
id|tx_buff
op_plus
id|n
)paren
suffix:semicolon
id|n
op_add_assign
id|stuff_byte
c_func
(paren
id|fcs.bytes
(braket
l_int|1
)braket
comma
id|tx_buff
op_plus
id|n
)paren
suffix:semicolon
macro_line|#else ifdef __BIG_ENDIAN
id|n
op_add_assign
id|stuff_byte
c_func
(paren
id|fcs.bytes
(braket
l_int|1
)braket
comma
id|tx_buff
op_plus
id|n
)paren
suffix:semicolon
id|n
op_add_assign
id|stuff_byte
c_func
(paren
id|fcs.bytes
(braket
l_int|0
)braket
comma
id|tx_buff
op_plus
id|n
)paren
suffix:semicolon
macro_line|#endif
id|tx_buff
(braket
id|n
op_increment
)braket
op_assign
id|EOF
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; * Function async_bump (idev)&n; *&n; *    Got a frame, make a copy of it, and pass it up the stack!&n; *&n; */
DECL|function|async_bump
r_static
r_inline
r_void
id|async_bump
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
comma
id|__u8
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|len
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|idev-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*  Align to 20 bytes */
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|len
op_minus
l_int|2
OG
l_int|0
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Copy data without CRC */
id|skb_put
c_func
(paren
id|skb
comma
id|len
op_minus
l_int|2
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb-&gt;data
comma
id|buf
comma
id|len
op_minus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* &n;&t; *  Feed it to IrLAP layer &n;&t; */
multiline_comment|/* memcpy(skb_put(skb,count), ax-&gt;rbuff, count); */
id|skb-&gt;dev
op_assign
op_amp
id|idev-&gt;netdev
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IRDA
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|idev-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|idev-&gt;stats.rx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
)brace
multiline_comment|/*&n; * Function async_unwrap (skb)&n; *&n; *    Parse and de-stuff frame received from the IR-port&n; *&n; */
DECL|function|async_unwrap_char
r_void
id|async_unwrap_char
c_func
(paren
r_struct
id|irda_device
op_star
id|idev
comma
id|__u8
id|byte
)paren
(brace
multiline_comment|/* State machine for receiving frames */
r_switch
c_cond
(paren
id|idev-&gt;rx_buff.state
)paren
(brace
r_case
id|OUTSIDE_FRAME
suffix:colon
r_switch
c_cond
(paren
id|byte
)paren
(brace
r_case
id|BOF
suffix:colon
id|idev-&gt;rx_buff.state
op_assign
id|BEGIN_FRAME
suffix:semicolon
id|idev-&gt;rx_buff.in_frame
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XBOF
suffix:colon
id|idev-&gt;xbofs
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EOF
suffix:colon
id|irda_device_set_media_busy
c_func
(paren
id|idev
comma
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BEGIN_FRAME
suffix:colon
r_switch
c_cond
(paren
id|byte
)paren
(brace
r_case
id|BOF
suffix:colon
multiline_comment|/* Continue */
r_break
suffix:semicolon
r_case
id|CE
suffix:colon
multiline_comment|/* Stuffed byte */
id|idev-&gt;rx_buff.state
op_assign
id|LINK_ESCAPE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EOF
suffix:colon
multiline_comment|/* Abort frame */
id|idev-&gt;rx_buff.state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
id|idev-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|idev-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Got first byte of frame */
id|idev-&gt;rx_buff.data
(braket
id|idev-&gt;rx_buff.len
op_increment
)braket
op_assign
id|byte
suffix:semicolon
id|idev-&gt;rx_buff.fcs
op_assign
id|IR_FCS
c_func
(paren
id|INIT_FCS
comma
id|byte
)paren
suffix:semicolon
id|idev-&gt;rx_buff.state
op_assign
id|INSIDE_FRAME
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|LINK_ESCAPE
suffix:colon
r_switch
c_cond
(paren
id|byte
)paren
(brace
r_case
id|BOF
suffix:colon
multiline_comment|/* New frame? */
id|idev-&gt;rx_buff.state
op_assign
id|BEGIN_FRAME
suffix:semicolon
id|idev-&gt;rx_buff.len
op_assign
l_int|0
suffix:semicolon
id|irda_device_set_media_busy
c_func
(paren
id|idev
comma
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CE
suffix:colon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;WARNING: State not defined&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EOF
suffix:colon
multiline_comment|/* Abort frame */
id|idev-&gt;rx_buff.state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
id|idev-&gt;rx_buff.len
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* &n;&t;&t;&t; *  Stuffed char, complement bit 5 of byte &n;&t;&t;&t; *  following CE, IrLAP p.114 &n;&t;&t;&t; */
id|byte
op_xor_assign
id|IR_TRANS
suffix:semicolon
r_if
c_cond
(paren
id|idev-&gt;rx_buff.len
OL
id|idev-&gt;rx_buff.truesize
)paren
(brace
id|idev-&gt;rx_buff.data
(braket
id|idev-&gt;rx_buff.len
op_increment
)braket
op_assign
id|byte
suffix:semicolon
id|idev-&gt;rx_buff.fcs
op_assign
id|IR_FCS
c_func
(paren
id|idev-&gt;rx_buff.fcs
comma
id|byte
)paren
suffix:semicolon
id|idev-&gt;rx_buff.state
op_assign
id|INSIDE_FRAME
suffix:semicolon
)brace
r_else
(brace
id|DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Rx buffer overflow, aborting&bslash;n&quot;
)paren
suffix:semicolon
id|idev-&gt;rx_buff.state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
id|idev-&gt;rx_buff.len
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|INSIDE_FRAME
suffix:colon
r_switch
c_cond
(paren
id|byte
)paren
(brace
r_case
id|BOF
suffix:colon
multiline_comment|/* New frame? */
id|idev-&gt;rx_buff.state
op_assign
id|BEGIN_FRAME
suffix:semicolon
id|idev-&gt;rx_buff.len
op_assign
l_int|0
suffix:semicolon
id|irda_device_set_media_busy
c_func
(paren
id|idev
comma
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CE
suffix:colon
multiline_comment|/* Stuffed char */
id|idev-&gt;rx_buff.state
op_assign
id|LINK_ESCAPE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EOF
suffix:colon
multiline_comment|/* End of frame */
id|idev-&gt;rx_buff.state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
id|idev-&gt;rx_buff.in_frame
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; *  Test FCS and deliver frame if it&squot;s good&n;&t;&t;&t; */
r_if
c_cond
(paren
id|idev-&gt;rx_buff.fcs
op_eq
id|GOOD_FCS
)paren
(brace
id|async_bump
c_func
(paren
id|idev
comma
id|idev-&gt;rx_buff.data
comma
id|idev-&gt;rx_buff.len
)paren
suffix:semicolon
id|idev-&gt;rx_buff.len
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Wrong CRC, discard frame!  */
id|irda_device_set_media_busy
c_func
(paren
id|idev
comma
id|TRUE
)paren
suffix:semicolon
id|idev-&gt;rx_buff.len
op_assign
l_int|0
suffix:semicolon
id|idev-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|idev-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* Next byte of frame */
r_if
c_cond
(paren
id|idev-&gt;rx_buff.len
OL
id|idev-&gt;rx_buff.truesize
)paren
(brace
id|idev-&gt;rx_buff.data
(braket
id|idev-&gt;rx_buff.len
op_increment
)braket
op_assign
id|byte
suffix:semicolon
id|idev-&gt;rx_buff.fcs
op_assign
id|IR_FCS
c_func
(paren
id|idev-&gt;rx_buff.fcs
comma
id|byte
)paren
suffix:semicolon
)brace
r_else
(brace
id|DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Rx buffer overflow, aborting&bslash;n&quot;
)paren
suffix:semicolon
id|idev-&gt;rx_buff.state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
id|idev-&gt;rx_buff.len
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function stuff_byte (byte, buf)&n; *&n; *    Byte stuff one single byte and put the result in buffer pointed to by&n; *    buf. The buffer must at all times be able to have two bytes inserted.&n; * &n; */
DECL|function|stuff_byte
r_inline
r_static
r_int
id|stuff_byte
c_func
(paren
id|__u8
id|byte
comma
id|__u8
op_star
id|buf
)paren
(brace
r_switch
c_cond
(paren
id|byte
)paren
(brace
r_case
id|BOF
suffix:colon
multiline_comment|/* FALLTHROUGH */
r_case
id|EOF
suffix:colon
multiline_comment|/* FALLTHROUGH */
r_case
id|CE
suffix:colon
multiline_comment|/* Insert transparently coded */
id|buf
(braket
l_int|0
)braket
op_assign
id|CE
suffix:semicolon
multiline_comment|/* Send link escape */
id|buf
(braket
l_int|1
)braket
op_assign
id|byte
op_xor
id|IR_TRANS
suffix:semicolon
multiline_comment|/* Complement bit 5 */
r_return
l_int|2
suffix:semicolon
multiline_comment|/* break; */
r_default
suffix:colon
multiline_comment|/* Non-special value, no transparency required */
id|buf
(braket
l_int|0
)braket
op_assign
id|byte
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* break; */
)brace
)brace
eof
