multiline_comment|/*********************************************************************&n; *                &n; * Filename:      irlap.c&n; * Version:       1.0&n; * Description:   IrLAP implementation for Linux&n; * Status:        Stable&n; * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Created at:    Mon Aug  4 20:40:53 1997&n; * Modified at:   Tue Dec 14 09:26:44 1999&n; * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * &n; *     Copyright (c) 1998-1999 Dag Brattli, All Rights Reserved.&n; *     &n; *     This program is free software; you can redistribute it and/or &n; *     modify it under the terms of the GNU General Public License as &n; *     published by the Free Software Foundation; either version 2 of &n; *     the License, or (at your option) any later version.&n; * &n; *     This program is distributed in the hope that it will be useful,&n; *     but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the&n; *     GNU General Public License for more details.&n; * &n; *     You should have received a copy of the GNU General Public License &n; *     along with this program; if not, write to the Free Software &n; *     Foundation, Inc., 59 Temple Place, Suite 330, Boston, &n; *     MA 02111-1307 USA&n; *     &n; ********************************************************************/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/irda_device.h&gt;
macro_line|#include &lt;net/irda/irqueue.h&gt;
macro_line|#include &lt;net/irda/irlmp.h&gt;
macro_line|#include &lt;net/irda/irlmp_frame.h&gt;
macro_line|#include &lt;net/irda/irlap_frame.h&gt;
macro_line|#include &lt;net/irda/irlap.h&gt;
macro_line|#include &lt;net/irda/timer.h&gt;
macro_line|#include &lt;net/irda/qos.h&gt;
macro_line|#include &lt;net/irda/irlap_comp.h&gt;
DECL|variable|irlap
id|hashbin_t
op_star
id|irlap
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|sysctl_slot_timeout
r_int
id|sysctl_slot_timeout
op_assign
id|SLOT_TIMEOUT
op_star
l_int|1000
op_div
id|HZ
suffix:semicolon
r_static
r_void
id|__irlap_close
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
)paren
suffix:semicolon
DECL|variable|lap_reasons
r_static
r_char
op_star
id|lap_reasons
(braket
)braket
op_assign
(brace
l_string|&quot;ERROR, NOT USED&quot;
comma
l_string|&quot;LAP_DISC_INDICATION&quot;
comma
l_string|&quot;LAP_NO_RESPONSE&quot;
comma
l_string|&quot;LAP_RESET_INDICATION&quot;
comma
l_string|&quot;LAP_FOUND_NONE&quot;
comma
l_string|&quot;LAP_MEDIA_BUSY&quot;
comma
l_string|&quot;LAP_PRIMARY_CONFLICT&quot;
comma
l_string|&quot;ERROR, NOT USED&quot;
comma
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_int
id|irlap_proc_read
c_func
(paren
r_char
op_star
comma
r_char
op_star
op_star
comma
id|off_t
comma
r_int
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
DECL|function|irlap_init
r_int
id|__init
id|irlap_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Allocate master array */
id|irlap
op_assign
id|hashbin_new
c_func
(paren
id|HB_LOCAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irlap
op_eq
l_int|NULL
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), can&squot;t allocate irlap hashbin!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
id|irlap_compressors
op_assign
id|hashbin_new
c_func
(paren
id|HB_LOCAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irlap_compressors
op_eq
l_int|NULL
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), can&squot;t allocate compressors hashbin!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|irlap_cleanup
r_void
id|irlap_cleanup
c_func
(paren
r_void
)paren
(brace
id|ASSERT
c_func
(paren
id|irlap
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|hashbin_delete
c_func
(paren
id|irlap
comma
(paren
id|FREE_FUNC
)paren
id|__irlap_close
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
id|hashbin_delete
c_func
(paren
id|irlap_compressors
comma
(paren
id|FREE_FUNC
)paren
id|kfree
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Function irlap_open (driver)&n; *&n; *    Initialize IrLAP layer&n; *&n; */
DECL|function|irlap_open
r_struct
id|irlap_cb
op_star
id|irlap_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|qos_info
op_star
id|qos
)paren
(brace
r_struct
id|irlap_cb
op_star
id|self
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Initialize the irlap structure. */
id|self
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irlap_cb
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|self
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|irlap_cb
)paren
)paren
suffix:semicolon
id|self-&gt;magic
op_assign
id|LAP_MAGIC
suffix:semicolon
multiline_comment|/* Make a binding between the layers */
id|self-&gt;netdev
op_assign
id|dev
suffix:semicolon
id|self-&gt;qos_dev
op_assign
id|qos
suffix:semicolon
multiline_comment|/* FIXME: should we get our own field? */
id|dev-&gt;atalk_ptr
op_assign
id|self
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_OFFLINE
)paren
suffix:semicolon
multiline_comment|/* Initialize transmit queue */
id|skb_queue_head_init
c_func
(paren
op_amp
id|self-&gt;txq
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|self-&gt;txq_ultra
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|self-&gt;wx_list
)paren
suffix:semicolon
multiline_comment|/* My unique IrLAP device address! */
id|get_random_bytes
c_func
(paren
op_amp
id|self-&gt;saddr
comma
r_sizeof
(paren
id|self-&gt;saddr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
op_amp
id|self-&gt;saddr
comma
l_int|4
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|self-&gt;slot_timer
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|self-&gt;query_timer
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|self-&gt;discovery_timer
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|self-&gt;poll_timer
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|self-&gt;backoff_timer
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|self-&gt;media_busy_timer
)paren
suffix:semicolon
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
id|self-&gt;N3
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* # connections attemts to try before giving up */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|irlap
comma
(paren
id|irda_queue_t
op_star
)paren
id|self
comma
id|self-&gt;saddr
comma
l_int|NULL
)paren
suffix:semicolon
id|irlmp_register_link
c_func
(paren
id|self
comma
id|self-&gt;saddr
comma
op_amp
id|self-&gt;notify
)paren
suffix:semicolon
r_return
id|self
suffix:semicolon
)brace
multiline_comment|/*&n; * Function __irlap_close (self)&n; *&n; *    Remove IrLAP and all allocated memory. Stop any pending timers.&n; *&n; */
DECL|function|__irlap_close
r_static
r_void
id|__irlap_close
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
)paren
(brace
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Stop timers */
id|del_timer
c_func
(paren
op_amp
id|self-&gt;slot_timer
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;query_timer
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;discovery_timer
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;poll_timer
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;backoff_timer
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;media_busy_timer
)paren
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|self-&gt;magic
op_assign
l_int|0
suffix:semicolon
id|kfree
c_func
(paren
id|self
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_close (self)&n; *&n; *    Remove IrLAP instance&n; *&n; */
DECL|function|irlap_close
r_void
id|irlap_close
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
)paren
(brace
r_struct
id|irlap_cb
op_star
id|lap
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
id|irlmp_unregister_link
c_func
(paren
id|self-&gt;saddr
)paren
suffix:semicolon
id|self-&gt;notify.instance
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Be sure that we manage to remove ourself from the hash */
id|lap
op_assign
id|hashbin_remove
c_func
(paren
id|irlap
comma
id|self-&gt;saddr
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lap
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Didn&squot;t find myself!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|__irlap_close
c_func
(paren
id|lap
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_connect_indication (self, skb)&n; *&n; *    Another device is attempting to make a connection&n; *&n; */
DECL|function|irlap_connect_indication
r_void
id|irlap_connect_indication
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|irlap_init_qos_capabilities
c_func
(paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* No user QoS! */
id|skb_get
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*LEVEL4*/
id|irlmp_link_connect_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|self-&gt;saddr
comma
id|self-&gt;daddr
comma
op_amp
id|self-&gt;qos_tx
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_connect_response (self, skb)&n; *&n; *    Service user has accepted incomming connection&n; *&n; */
DECL|function|irlap_connect_response
r_void
id|irlap_connect_response
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_do_event
c_func
(paren
id|self
comma
id|CONNECT_RESPONSE
comma
id|skb
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_connect_request (self, daddr, qos_user, sniff)&n; *&n; *    Request connection with another device, sniffing is not implemented &n; *    yet.&n; *&n; */
DECL|function|irlap_connect_request
r_void
id|irlap_connect_request
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|__u32
id|daddr
comma
r_struct
id|qos_info
op_star
id|qos_user
comma
r_int
id|sniff
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;(), daddr=0x%08x&bslash;n&quot;
comma
id|daddr
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|self-&gt;daddr
op_assign
id|daddr
suffix:semicolon
multiline_comment|/*&n;&t; *  If the service user specifies QoS values for this connection, &n;&t; *  then use them&n;&t; */
id|irlap_init_qos_capabilities
c_func
(paren
id|self
comma
id|qos_user
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|self-&gt;state
op_eq
id|LAP_NDM
)paren
op_logical_and
op_logical_neg
id|self-&gt;media_busy
)paren
id|irlap_do_event
c_func
(paren
id|self
comma
id|CONNECT_REQUEST
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_else
id|self-&gt;connect_pending
op_assign
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_connect_confirm (self, skb)&n; *&n; *    Connection request has been accepted&n; *&n; */
DECL|function|irlap_connect_confirm
r_void
id|irlap_connect_confirm
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|skb_get
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*LEVEL4*/
id|irlmp_link_connect_confirm
c_func
(paren
id|self-&gt;notify.instance
comma
op_amp
id|self-&gt;qos_tx
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_data_indication (self, skb)&n; *&n; *    Received data frames from IR-port, so we just pass them up to &n; *    IrLMP for further processing&n; *&n; */
DECL|function|irlap_data_indication
r_void
id|irlap_data_indication
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|unreliable
)paren
(brace
multiline_comment|/* Hide LAP header from IrLMP layer */
id|skb_pull
c_func
(paren
id|skb
comma
id|LAP_ADDR_HEADER
op_plus
id|LAP_CTRL_HEADER
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
r_if
c_cond
(paren
id|self-&gt;qos_tx.compression.value
)paren
(brace
id|skb_get
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*LEVEL4*/
id|skb
op_assign
id|irlap_decompress_frame
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Decompress error!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif
id|skb_get
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*LEVEL4*/
id|irlmp_link_data_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|skb
comma
id|unreliable
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_data_request (self, skb)&n; *&n; *    Queue data for transmission, must wait until XMIT state&n; *&n; */
DECL|function|irlap_data_request
r_void
id|irlap_data_request
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|unreliable
)paren
(brace
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
r_if
c_cond
(paren
id|self-&gt;qos_tx.compression.value
)paren
(brace
id|skb
op_assign
id|irlap_compress_frame
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Compress error!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif
id|ASSERT
c_func
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
op_ge
(paren
id|LAP_ADDR_HEADER
op_plus
id|LAP_CTRL_HEADER
)paren
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|skb_push
c_func
(paren
id|skb
comma
id|LAP_ADDR_HEADER
op_plus
id|LAP_CTRL_HEADER
)paren
suffix:semicolon
multiline_comment|/*  &n;&t; *  Must set frame format now so that the rest of the code knows &n;&t; *  if its dealing with an I or an UI frame&n;&t; */
r_if
c_cond
(paren
id|unreliable
)paren
id|skb-&gt;data
(braket
l_int|1
)braket
op_assign
id|UI_FRAME
suffix:semicolon
r_else
id|skb-&gt;data
(braket
l_int|1
)braket
op_assign
id|I_FRAME
suffix:semicolon
multiline_comment|/* &n;&t; *  Send event if this frame only if we are in the right state &n;&t; *  FIXME: udata should be sent first! (skb_queue_head?)&n;&t; */
r_if
c_cond
(paren
(paren
id|self-&gt;state
op_eq
id|LAP_XMIT_P
)paren
op_logical_or
(paren
id|self-&gt;state
op_eq
id|LAP_XMIT_S
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *  Check if the transmit queue contains some unsent frames,&n;&t;&t; *  and if so, make sure they are sent first&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|self-&gt;txq
)paren
)paren
(brace
id|skb_queue_tail
c_func
(paren
op_amp
id|self-&gt;txq
comma
id|skb
)paren
suffix:semicolon
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;txq
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
)brace
id|irlap_do_event
c_func
(paren
id|self
comma
id|SEND_I_CMD
comma
id|skb
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
id|skb_queue_tail
c_func
(paren
op_amp
id|self-&gt;txq
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_unitdata_request (self, skb)&n; *&n; *    Send Ultra data. This is data that must be sent outside any connection&n; *&n; */
macro_line|#ifdef CONFIG_IRDA_ULTRA
DECL|function|irlap_unitdata_request
r_void
id|irlap_unitdata_request
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
op_ge
(paren
id|LAP_ADDR_HEADER
op_plus
id|LAP_CTRL_HEADER
)paren
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|skb_push
c_func
(paren
id|skb
comma
id|LAP_ADDR_HEADER
op_plus
id|LAP_CTRL_HEADER
)paren
suffix:semicolon
id|skb-&gt;data
(braket
l_int|0
)braket
op_assign
id|CBROADCAST
suffix:semicolon
id|skb-&gt;data
(braket
l_int|1
)braket
op_assign
id|UI_FRAME
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|self-&gt;txq_ultra
comma
id|skb
)paren
suffix:semicolon
id|irlap_do_event
c_func
(paren
id|self
comma
id|SEND_UI_FRAME
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif /*CONFIG_IRDA_ULTRA */
multiline_comment|/*&n; * Function irlap_udata_indication (self, skb)&n; *&n; *    Receive Ultra data. This is data that is received outside any connection&n; *&n; */
macro_line|#ifdef CONFIG_IRDA_ULTRA
DECL|function|irlap_unitdata_indication
r_void
id|irlap_unitdata_indication
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Hide LAP header from IrLMP layer */
id|skb_pull
c_func
(paren
id|skb
comma
id|LAP_ADDR_HEADER
op_plus
id|LAP_CTRL_HEADER
)paren
suffix:semicolon
id|skb_get
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*LEVEL4*/
id|irlmp_link_unitdata_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|skb
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IRDA_ULTRA */
multiline_comment|/*&n; * Function irlap_disconnect_request (void)&n; *&n; *    Request to disconnect connection by service user&n; */
DECL|function|irlap_disconnect_request
r_void
id|irlap_disconnect_request
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t disconnect until all data frames are successfully sent */
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;txq
)paren
OG
l_int|0
)paren
(brace
id|self-&gt;disconnect_pending
op_assign
id|TRUE
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check if we are in the right state for disconnecting */
r_switch
c_cond
(paren
id|self-&gt;state
)paren
(brace
r_case
id|LAP_XMIT_P
suffix:colon
multiline_comment|/* FALLTROUGH */
r_case
id|LAP_XMIT_S
suffix:colon
multiline_comment|/* FALLTROUGH */
r_case
id|LAP_CONN
suffix:colon
multiline_comment|/* FALLTROUGH */
r_case
id|LAP_RESET_WAIT
suffix:colon
multiline_comment|/* FALLTROUGH */
r_case
id|LAP_RESET_CHECK
suffix:colon
id|irlap_do_event
c_func
(paren
id|self
comma
id|DISCONNECT_REQUEST
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), disconnect pending!&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;disconnect_pending
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlap_disconnect_indication (void)&n; *&n; *    Disconnect request from other device&n; *&n; */
DECL|function|irlap_disconnect_indication
r_void
id|irlap_disconnect_indication
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|LAP_REASON
id|reason
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), reason=%s&bslash;n&quot;
comma
id|lap_reasons
(braket
id|reason
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
id|irda_free_compression
c_func
(paren
id|self
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Flush queues */
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|reason
)paren
(brace
r_case
id|LAP_RESET_INDICATION
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Sending reset request!&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_do_event
c_func
(paren
id|self
comma
id|RESET_REQUEST
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LAP_NO_RESPONSE
suffix:colon
multiline_comment|/* FALLTROUGH */
r_case
id|LAP_DISC_INDICATION
suffix:colon
multiline_comment|/* FALLTROUGH */
r_case
id|LAP_FOUND_NONE
suffix:colon
multiline_comment|/* FALLTROUGH */
r_case
id|LAP_MEDIA_BUSY
suffix:colon
id|irlmp_link_disconnect_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|self
comma
id|reason
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), Unknown reason %d&bslash;n&quot;
comma
id|reason
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlap_discovery_request (gen_addr_bit)&n; *&n; *    Start one single discovery operation.&n; *&n; */
DECL|function|irlap_discovery_request
r_void
id|irlap_discovery_request
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|discovery_t
op_star
id|discovery
)paren
(brace
r_struct
id|irlap_info
id|info
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|discovery
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), nslots = %d&bslash;n&quot;
comma
id|discovery-&gt;nslots
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|discovery-&gt;nslots
op_eq
l_int|1
)paren
op_logical_or
(paren
id|discovery-&gt;nslots
op_eq
l_int|6
)paren
op_logical_or
(paren
id|discovery-&gt;nslots
op_eq
l_int|8
)paren
op_logical_or
(paren
id|discovery-&gt;nslots
op_eq
l_int|16
)paren
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Discovery is only possible in NDM mode */
r_if
c_cond
(paren
id|self-&gt;state
op_ne
id|LAP_NDM
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), discovery only possible in NDM mode&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_discovery_confirm
c_func
(paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check if last discovery request finished in time */
r_if
c_cond
(paren
id|self-&gt;discovery_log
op_ne
l_int|NULL
)paren
(brace
id|hashbin_delete
c_func
(paren
id|self-&gt;discovery_log
comma
(paren
id|FREE_FUNC
)paren
id|kfree
)paren
suffix:semicolon
id|self-&gt;discovery_log
op_assign
l_int|NULL
suffix:semicolon
)brace
id|self-&gt;discovery_log
op_assign
id|hashbin_new
c_func
(paren
id|HB_LOCAL
)paren
suffix:semicolon
id|info.S
op_assign
id|discovery-&gt;nslots
suffix:semicolon
multiline_comment|/* Number of slots */
id|info.s
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Current slot */
id|self-&gt;discovery_cmd
op_assign
id|discovery
suffix:semicolon
id|info.discovery
op_assign
id|discovery
suffix:semicolon
multiline_comment|/* Check if the slot timeout is within limits */
r_if
c_cond
(paren
id|sysctl_slot_timeout
OL
l_int|20
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), to low value for slot timeout!&bslash;n&quot;
)paren
suffix:semicolon
id|sysctl_slot_timeout
op_assign
l_int|20
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Highest value is actually 8, but we allow higher since&n;&t; * some devices seems to require it.&n;&t; */
r_if
c_cond
(paren
id|sysctl_slot_timeout
OG
l_int|160
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), to high value for slot timeout!&bslash;n&quot;
)paren
suffix:semicolon
id|sysctl_slot_timeout
op_assign
l_int|160
suffix:semicolon
)brace
id|self-&gt;slot_timeout
op_assign
id|sysctl_slot_timeout
op_star
id|HZ
op_div
l_int|1000
suffix:semicolon
id|irlap_do_event
c_func
(paren
id|self
comma
id|DISCOVERY_REQUEST
comma
l_int|NULL
comma
op_amp
id|info
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_discovery_confirm (log)&n; *&n; *    A device has been discovered in front of this station, we&n; *    report directly to LMP.&n; */
DECL|function|irlap_discovery_confirm
r_void
id|irlap_discovery_confirm
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|hashbin_t
op_star
id|discovery_log
)paren
(brace
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;notify.instance
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Check for successful discovery, since we are then allowed to clear &n;&t; * the media busy condition (irlap p.94). This should allow us to make &n;&t; * connection attempts much easier.&n;&t; */
r_if
c_cond
(paren
id|discovery_log
op_logical_and
id|HASHBIN_GET_SIZE
c_func
(paren
id|discovery_log
)paren
OG
l_int|0
)paren
id|irda_device_set_media_busy
c_func
(paren
id|self-&gt;netdev
comma
id|FALSE
)paren
suffix:semicolon
multiline_comment|/* Inform IrLMP */
id|irlmp_link_discovery_confirm
c_func
(paren
id|self-&gt;notify.instance
comma
id|discovery_log
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_discovery_indication (log)&n; *&n; *    Somebody is trying to discover us!&n; *&n; */
DECL|function|irlap_discovery_indication
r_void
id|irlap_discovery_indication
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|discovery_t
op_star
id|discovery
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|discovery
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;notify.instance
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|irlmp_link_discovery_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|discovery
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_status_indication (quality_of_link)&n; *&n; *    &n; *&n; */
DECL|function|irlap_status_indication
r_void
id|irlap_status_indication
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
r_int
id|quality_of_link
)paren
(brace
r_switch
c_cond
(paren
id|quality_of_link
)paren
(brace
r_case
id|STATUS_NO_ACTIVITY
suffix:colon
id|MESSAGE
c_func
(paren
l_string|&quot;IrLAP, no activity on link!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STATUS_NOISY
suffix:colon
id|MESSAGE
c_func
(paren
l_string|&quot;IrLAP, noisy link!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|irlmp_status_indication
c_func
(paren
id|self-&gt;notify.instance
comma
id|quality_of_link
comma
id|LOCK_NO_CHANGE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_reset_indication (void)&n; *&n; *    &n; *&n; */
DECL|function|irlap_reset_indication
r_void
id|irlap_reset_indication
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;state
op_eq
id|LAP_RESET_WAIT
)paren
id|irlap_do_event
c_func
(paren
id|self
comma
id|RESET_REQUEST
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_else
id|irlap_do_event
c_func
(paren
id|self
comma
id|RESET_RESPONSE
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_reset_confirm (void)&n; *&n; *    &n; *&n; */
DECL|function|irlap_reset_confirm
r_void
id|irlap_reset_confirm
c_func
(paren
r_void
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_generate_rand_time_slot (S, s)&n; *&n; *    Generate a random time slot between s and S-1 where&n; *    S = Number of slots (0 -&gt; S-1)&n; *    s = Current slot&n; */
DECL|function|irlap_generate_rand_time_slot
r_int
id|irlap_generate_rand_time_slot
c_func
(paren
r_int
id|S
comma
r_int
id|s
)paren
(brace
r_static
r_int
id|rand
suffix:semicolon
r_int
id|slot
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|S
op_minus
id|s
)paren
OG
l_int|0
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|rand
op_add_assign
id|jiffies
suffix:semicolon
id|rand
op_xor_assign
(paren
id|rand
op_lshift
l_int|12
)paren
suffix:semicolon
id|rand
op_xor_assign
(paren
id|rand
op_rshift
l_int|20
)paren
suffix:semicolon
id|slot
op_assign
id|s
op_plus
id|rand
op_mod
(paren
id|S
op_minus
id|s
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|slot
op_ge
id|s
)paren
op_logical_or
(paren
id|slot
OL
id|S
)paren
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
r_return
id|slot
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_update_nr_received (nr)&n; *&n; *    Remove all acknowledged frames in current window queue. This code is &n; *    not intuitive and you should not try to change it. If you think it&n; *    contains bugs, please mail a patch to the author instead.&n; */
DECL|function|irlap_update_nr_received
r_void
id|irlap_update_nr_received
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
r_int
id|nr
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;         * Remove all the ack-ed frames from the window queue.&n;         */
multiline_comment|/* &n;&t; *  Optimize for the common case. It is most likely that the receiver&n;&t; *  will acknowledge all the frames we have sent! So in that case we&n;&t; *  delete all frames stored in window.&n;&t; */
r_if
c_cond
(paren
id|nr
op_eq
id|self-&gt;vs
)paren
(brace
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;wx_list
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* The last acked frame is the next to send minus one */
id|self-&gt;va
op_assign
id|nr
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Remove all acknowledged frames in current window */
r_while
c_loop
(paren
(paren
id|skb_peek
c_func
(paren
op_amp
id|self-&gt;wx_list
)paren
op_ne
l_int|NULL
)paren
op_logical_and
(paren
(paren
(paren
id|self-&gt;va
op_plus
l_int|1
)paren
op_mod
l_int|8
)paren
op_ne
id|nr
)paren
)paren
(brace
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;wx_list
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|self-&gt;va
op_assign
(paren
id|self-&gt;va
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Advance window */
id|self-&gt;window
op_assign
id|self-&gt;window_size
op_minus
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;wx_list
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_validate_ns_received (ns)&n; *&n; *    Validate the next to send (ns) field from received frame.&n; */
DECL|function|irlap_validate_ns_received
r_int
id|irlap_validate_ns_received
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
r_int
id|ns
)paren
(brace
multiline_comment|/*  ns as expected?  */
r_if
c_cond
(paren
id|ns
op_eq
id|self-&gt;vr
)paren
r_return
id|NS_EXPECTED
suffix:semicolon
multiline_comment|/*&n;&t; *  Stations are allowed to treat invalid NS as unexpected NS&n;&t; *  IrLAP, Recv ... with-invalid-Ns. p. 84&n;&t; */
r_return
id|NS_UNEXPECTED
suffix:semicolon
multiline_comment|/* return NR_INVALID; */
)brace
multiline_comment|/*&n; * Function irlap_validate_nr_received (nr)&n; *&n; *    Validate the next to receive (nr) field from received frame.&n; *&n; */
DECL|function|irlap_validate_nr_received
r_int
id|irlap_validate_nr_received
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
r_int
id|nr
)paren
(brace
multiline_comment|/*  nr as expected?  */
r_if
c_cond
(paren
id|nr
op_eq
id|self-&gt;vs
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), expected!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|NR_EXPECTED
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  unexpected nr? (but within current window), first we check if the &n;&t; *  ns numbers of the frames in the current window wrap.&n;&t; */
r_if
c_cond
(paren
id|self-&gt;va
OL
id|self-&gt;vs
)paren
(brace
r_if
c_cond
(paren
(paren
id|nr
op_ge
id|self-&gt;va
)paren
op_logical_and
(paren
id|nr
op_le
id|self-&gt;vs
)paren
)paren
r_return
id|NR_UNEXPECTED
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|nr
op_ge
id|self-&gt;va
)paren
op_logical_or
(paren
id|nr
op_le
id|self-&gt;vs
)paren
)paren
r_return
id|NR_UNEXPECTED
suffix:semicolon
)brace
multiline_comment|/* Invalid nr!  */
r_return
id|NR_INVALID
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_initiate_connection_state ()&n; *&n; *    Initialize the connection state parameters&n; *&n; */
DECL|function|irlap_initiate_connection_state
r_void
id|irlap_initiate_connection_state
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Next to send and next to receive */
id|self-&gt;vs
op_assign
id|self-&gt;vr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Last frame which got acked (0 - 1) % 8 */
id|self-&gt;va
op_assign
l_int|7
suffix:semicolon
id|self-&gt;window
op_assign
l_int|1
suffix:semicolon
id|self-&gt;remote_busy
op_assign
id|FALSE
suffix:semicolon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_wait_min_turn_around (self, qos)&n; *&n; *    Wait negotiated minimum turn around time, this function actually sets&n; *    the number of BOS&squot;s that must be sent before the next transmitted&n; *    frame in order to delay for the specified amount of time. This is&n; *    done to avoid using timers, and the forbidden udelay!&n; */
DECL|function|irlap_wait_min_turn_around
r_void
id|irlap_wait_min_turn_around
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
r_struct
id|qos_info
op_star
id|qos
)paren
(brace
id|__u32
id|min_turn_time
suffix:semicolon
id|__u32
id|speed
suffix:semicolon
multiline_comment|/* Get QoS values.  */
id|speed
op_assign
id|qos-&gt;baud_rate.value
suffix:semicolon
id|min_turn_time
op_assign
id|qos-&gt;min_turn_time.value
suffix:semicolon
multiline_comment|/* No need to calculate XBOFs for speeds over 115200 bps */
r_if
c_cond
(paren
id|speed
OG
l_int|115200
)paren
(brace
id|self-&gt;mtt_required
op_assign
id|min_turn_time
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*  &n;&t; *  Send additional BOF&squot;s for the next frame for the requested&n;&t; *  min turn time, so now we must calculate how many chars (XBOF&squot;s) we &n;&t; *  must send for the requested time period (min turn time)&n;&t; */
id|self-&gt;xbofs_delay
op_assign
id|irlap_min_turn_time_in_bytes
c_func
(paren
id|speed
comma
id|min_turn_time
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_flush_all_queues (void)&n; *&n; *    Flush all queues&n; *&n; */
DECL|function|irlap_flush_all_queues
r_void
id|irlap_flush_all_queues
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Free transmission queue */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;txq
)paren
)paren
op_ne
l_int|NULL
)paren
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;txq_ultra
)paren
)paren
op_ne
l_int|NULL
)paren
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Free sliding window buffered packets */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;wx_list
)paren
)paren
op_ne
l_int|NULL
)paren
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_RECYCLE_RR
r_if
c_cond
(paren
id|self-&gt;recycle_rr_skb
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|self-&gt;recycle_rr_skb
)paren
suffix:semicolon
id|self-&gt;recycle_rr_skb
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * Function irlap_setspeed (self, speed)&n; *&n; *    Change the speed of the IrDA port&n; *&n; */
DECL|function|irlap_change_speed
r_void
id|irlap_change_speed
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|__u32
id|speed
comma
r_int
id|now
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), setting speed to %d&bslash;n&quot;
comma
id|speed
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|self-&gt;speed
op_assign
id|speed
suffix:semicolon
multiline_comment|/* Change speed now, or just piggyback speed on frames */
r_if
c_cond
(paren
id|now
)paren
(brace
multiline_comment|/* Send down empty frame to trigger speed change */
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|irlap_queue_xmit
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
DECL|function|irlap_init_comp_qos_capabilities
r_void
id|irlap_init_comp_qos_capabilities
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
)paren
(brace
r_struct
id|irda_compressor
op_star
id|comp
suffix:semicolon
id|__u8
id|mask
suffix:semicolon
multiline_comment|/* Current bit tested */
r_int
id|i
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* &n;&t; *  Find out which compressors we support. We do this be checking that&n;&t; *  the corresponding compressor for each bit set in the QoS bits has &n;&t; *  actually been loaded. Ths is sort of hairy code but that is what &n;&t; *  you get when you do a little bit flicking :-)&n;&t; */
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), comp bits 0x%02x&bslash;n&quot;
comma
id|self-&gt;qos_rx.compression.bits
)paren
suffix:semicolon
id|mask
op_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* Start with testing MSB */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), testing bit %d&bslash;n&quot;
comma
l_int|8
op_minus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;qos_rx.compression.bits
op_amp
id|mask
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), bit %d is set by defalt&bslash;n&quot;
comma
l_int|8
op_minus
id|i
)paren
suffix:semicolon
id|comp
op_assign
id|hashbin_find
c_func
(paren
id|irlap_compressors
comma
id|compressions
(braket
id|msb_index
c_func
(paren
id|mask
)paren
)braket
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|comp
)paren
(brace
multiline_comment|/* Protocol not supported, so clear the bit */
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), Compression &quot;
l_string|&quot;protocol %d has not been loaded!&bslash;n&quot;
comma
id|compressions
(braket
id|msb_index
c_func
(paren
id|mask
)paren
)braket
)paren
suffix:semicolon
id|self-&gt;qos_rx.compression.bits
op_and_assign
op_complement
id|mask
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), comp bits 0x%02x&bslash;n&quot;
comma
id|self-&gt;qos_rx.compression.bits
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Try the next bit */
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#endif&t;
multiline_comment|/*&n; * Function irlap_init_qos_capabilities (self, qos)&n; *&n; *    Initialize QoS for this IrLAP session, What we do is to compute the&n; *    intersection of the QoS capabilities for the user, driver and for&n; *    IrLAP itself. Normally, IrLAP will not specify any values, but it can&n; *    be used to restrict certain values.&n; */
DECL|function|irlap_init_qos_capabilities
r_void
id|irlap_init_qos_capabilities
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
r_struct
id|qos_info
op_star
id|qos_user
)paren
(brace
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;netdev
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Start out with the maximum QoS support possible */
id|irda_init_max_qos_capabilies
c_func
(paren
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
id|irlap_init_comp_qos_capabilities
c_func
(paren
id|self
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Apply drivers QoS capabilities */
id|irda_qos_compute_intersection
c_func
(paren
op_amp
id|self-&gt;qos_rx
comma
id|self-&gt;qos_dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Check for user supplied QoS parameters. The service user is only &n;&t; *  allowed to supply these values. We check each parameter since the&n;&t; *  user may not have set all of them.&n;&t; */
r_if
c_cond
(paren
id|qos_user
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Found user specified QoS!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qos_user-&gt;baud_rate.bits
)paren
id|self-&gt;qos_rx.baud_rate.bits
op_and_assign
id|qos_user-&gt;baud_rate.bits
suffix:semicolon
r_if
c_cond
(paren
id|qos_user-&gt;max_turn_time.bits
)paren
id|self-&gt;qos_rx.max_turn_time.bits
op_and_assign
id|qos_user-&gt;max_turn_time.bits
suffix:semicolon
r_if
c_cond
(paren
id|qos_user-&gt;data_size.bits
)paren
id|self-&gt;qos_rx.data_size.bits
op_and_assign
id|qos_user-&gt;data_size.bits
suffix:semicolon
r_if
c_cond
(paren
id|qos_user-&gt;link_disc_time.bits
)paren
id|self-&gt;qos_rx.link_disc_time.bits
op_and_assign
id|qos_user-&gt;link_disc_time.bits
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
id|self-&gt;qos_rx.compression.bits
op_and_assign
id|qos_user-&gt;compression.bits
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Use 500ms in IrLAP for now */
id|self-&gt;qos_rx.max_turn_time.bits
op_and_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* Set data size */
multiline_comment|/*self-&gt;qos_rx.data_size.bits &amp;= 0x03;*/
multiline_comment|/* Set disconnect time -&gt; done properly in qos.c */
multiline_comment|/*self-&gt;qos_rx.link_disc_time.bits &amp;= 0x07;*/
id|irda_qos_bits_to_value
c_func
(paren
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_apply_default_connection_parameters (void)&n; *&n; *    Use the default connection and transmission parameters&n; * &n; */
DECL|function|irlap_apply_default_connection_parameters
r_void
id|irlap_apply_default_connection_parameters
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|irlap_change_speed
c_func
(paren
id|self
comma
l_int|9600
comma
id|TRUE
)paren
suffix:semicolon
multiline_comment|/* Set mbusy when going to NDM state */
id|irda_device_set_media_busy
c_func
(paren
id|self-&gt;netdev
comma
id|TRUE
)paren
suffix:semicolon
multiline_comment|/* Default value in NDM */
id|self-&gt;bofs_count
op_assign
l_int|12
suffix:semicolon
multiline_comment|/* &n;&t; * Generate random connection address for this session, which must&n;&t; * be 7 bits wide and different from 0x00 and 0xfe &n;&t; */
r_while
c_loop
(paren
(paren
id|self-&gt;caddr
op_eq
l_int|0x00
)paren
op_logical_or
(paren
id|self-&gt;caddr
op_eq
l_int|0xfe
)paren
)paren
(brace
id|get_random_bytes
c_func
(paren
op_amp
id|self-&gt;caddr
comma
r_sizeof
(paren
id|self-&gt;caddr
)paren
)paren
suffix:semicolon
id|self-&gt;caddr
op_and_assign
l_int|0xfe
suffix:semicolon
)brace
multiline_comment|/* Use default values until connection has been negitiated */
id|self-&gt;slot_timeout
op_assign
id|sysctl_slot_timeout
suffix:semicolon
id|self-&gt;final_timeout
op_assign
id|FINAL_TIMEOUT
suffix:semicolon
id|self-&gt;poll_timeout
op_assign
id|POLL_TIMEOUT
suffix:semicolon
id|self-&gt;wd_timeout
op_assign
id|WD_TIMEOUT
suffix:semicolon
multiline_comment|/* Set some default values */
id|self-&gt;qos_tx.baud_rate.value
op_assign
l_int|9600
suffix:semicolon
id|self-&gt;qos_rx.baud_rate.value
op_assign
l_int|9600
suffix:semicolon
id|self-&gt;qos_tx.max_turn_time.value
op_assign
l_int|0
suffix:semicolon
id|self-&gt;qos_rx.max_turn_time.value
op_assign
l_int|0
suffix:semicolon
id|self-&gt;qos_tx.min_turn_time.value
op_assign
l_int|0
suffix:semicolon
id|self-&gt;qos_rx.min_turn_time.value
op_assign
l_int|0
suffix:semicolon
id|self-&gt;qos_tx.data_size.value
op_assign
l_int|64
suffix:semicolon
id|self-&gt;qos_rx.data_size.value
op_assign
l_int|64
suffix:semicolon
id|self-&gt;qos_tx.window_size.value
op_assign
l_int|1
suffix:semicolon
id|self-&gt;qos_rx.window_size.value
op_assign
l_int|1
suffix:semicolon
id|self-&gt;qos_tx.additional_bofs.value
op_assign
l_int|12
suffix:semicolon
id|self-&gt;qos_rx.additional_bofs.value
op_assign
l_int|12
suffix:semicolon
id|self-&gt;qos_tx.link_disc_time.value
op_assign
l_int|0
suffix:semicolon
id|self-&gt;qos_rx.link_disc_time.value
op_assign
l_int|0
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|self-&gt;disconnect_pending
op_assign
id|FALSE
suffix:semicolon
id|self-&gt;connect_pending
op_assign
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_apply_connection_parameters (qos)&n; *&n; *    Initialize IrLAP with the negotiated QoS values&n; *&n; */
DECL|function|irlap_apply_connection_parameters
r_void
id|irlap_apply_connection_parameters
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|irlap_change_speed
c_func
(paren
id|self
comma
id|self-&gt;qos_tx.baud_rate.value
comma
id|FALSE
)paren
suffix:semicolon
id|self-&gt;window_size
op_assign
id|self-&gt;qos_tx.window_size.value
suffix:semicolon
id|self-&gt;window
op_assign
id|self-&gt;qos_tx.window_size.value
suffix:semicolon
id|self-&gt;bofs_count
op_assign
id|self-&gt;qos_tx.additional_bofs.value
suffix:semicolon
multiline_comment|/*&n;&t; *  Calculate how many bytes it is possible to transmit before the&n;&t; *  link must be turned around&n;&t; */
id|self-&gt;line_capacity
op_assign
id|irlap_max_line_capacity
c_func
(paren
id|self-&gt;qos_tx.baud_rate.value
comma
id|self-&gt;qos_tx.max_turn_time.value
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Set N1 to 0 if Link Disconnect/Threshold Time = 3 and set it to &n;&t; *  3 seconds otherwise. See page 71 in IrLAP for more details.&n;&t; *  TODO: these values should be calculated from the final timer&n;         *  as well&n;&t; */
id|ASSERT
c_func
(paren
id|self-&gt;qos_tx.max_turn_time.value
op_ne
l_int|0
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;qos_tx.link_disc_time.value
op_eq
l_int|3
)paren
multiline_comment|/* &n;&t;&t; * If we set N1 to 0, it will trigger immediately, which is&n;&t;&t; * not what we want. What we really want is to disable it,&n;&t;&t; * Jean II &n;&t;&t; */
id|self-&gt;N1
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Disable */
r_else
id|self-&gt;N1
op_assign
l_int|3000
op_div
id|self-&gt;qos_tx.max_turn_time.value
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Setting N1 = %d&bslash;n&quot;
comma
id|self-&gt;N1
)paren
suffix:semicolon
id|self-&gt;N2
op_assign
id|self-&gt;qos_tx.link_disc_time.value
op_star
l_int|1000
op_div
id|self-&gt;qos_tx.max_turn_time.value
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Setting N2 = %d&bslash;n&quot;
comma
id|self-&gt;N2
)paren
suffix:semicolon
multiline_comment|/* &n;&t; *  Initialize timeout values, some of the rules are listed on &n;&t; *  page 92 in IrLAP.&n;&t; */
id|self-&gt;poll_timeout
op_assign
id|self-&gt;qos_tx.max_turn_time.value
op_star
id|HZ
op_div
l_int|1000
suffix:semicolon
id|self-&gt;wd_timeout
op_assign
id|self-&gt;poll_timeout
op_star
l_int|2
suffix:semicolon
multiline_comment|/* &n;&t; * Be careful to keep our promises to the peer device about how long&n;&t; * time it can keep the pf bit. So here we must use the rx_qos value&n;&t; */
id|self-&gt;final_timeout
op_assign
id|self-&gt;qos_rx.max_turn_time.value
op_star
id|HZ
op_div
l_int|1000
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
r_if
c_cond
(paren
id|self-&gt;qos_tx.compression.value
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Initializing compression&bslash;n&quot;
)paren
suffix:semicolon
id|irda_set_compression
c_func
(paren
id|self
comma
id|self-&gt;qos_tx.compression.value
)paren
suffix:semicolon
id|irlap_compressor_init
c_func
(paren
id|self
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * Function irlap_set_local_busy (self, status)&n; *&n; *    &n; *&n; */
DECL|function|irlap_set_local_busy
r_void
id|irlap_set_local_busy
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
r_int
id|status
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;local_busy
op_assign
id|status
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), local busy ON&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), local busy OFF&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/*&n; * Function irlap_proc_read (buf, start, offset, len, unused)&n; *&n; *    Give some info to the /proc file system&n; *&n; */
DECL|function|irlap_proc_read
r_int
id|irlap_proc_read
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|len
)paren
(brace
r_struct
id|irlap_cb
op_star
id|self
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irlap_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|irlap
)paren
suffix:semicolon
r_while
c_loop
(paren
id|self
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENODEV
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
id|EBADR
suffix:semicolon
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;irlap%d &quot;
comma
id|i
op_increment
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;state: %s&bslash;n&quot;
comma
id|irlap_state
(braket
id|self-&gt;state
)braket
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;  caddr: %#02x, &quot;
comma
id|self-&gt;caddr
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;saddr: %#08x, &quot;
comma
id|self-&gt;saddr
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;daddr: %#08x&bslash;n&quot;
comma
id|self-&gt;daddr
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;  win size: %d, &quot;
comma
id|self-&gt;window_size
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;win: %d, &quot;
comma
id|self-&gt;window
)paren
suffix:semicolon
macro_line|#if CONFIG_IRDA_DYNAMIC_WINDOW
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;line capacity: %d, &quot;
comma
id|self-&gt;line_capacity
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;bytes left: %d&bslash;n&quot;
comma
id|self-&gt;bytes_left
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_DYNAMIC_WINDOW */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;  tx queue len: %d &quot;
comma
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;txq
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;win queue len: %d &quot;
comma
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;wx_list
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;rbusy: %s&quot;
comma
id|self-&gt;remote_busy
ques
c_cond
l_string|&quot;TRUE&quot;
suffix:colon
l_string|&quot;FALSE&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot; mbusy: %s&bslash;n&quot;
comma
id|self-&gt;media_busy
ques
c_cond
l_string|&quot;TRUE&quot;
suffix:colon
l_string|&quot;FALSE&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;  retrans: %d &quot;
comma
id|self-&gt;retry_count
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;vs: %d &quot;
comma
id|self-&gt;vs
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;vr: %d &quot;
comma
id|self-&gt;vr
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;va: %d&bslash;n&quot;
comma
id|self-&gt;va
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;  qos&bslash;tbps&bslash;tmaxtt&bslash;tdsize&bslash;twinsize&bslash;taddbofs&bslash;tmintt&bslash;tldisc&bslash;tcomp&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;  tx&bslash;t%d&bslash;t&quot;
comma
id|self-&gt;qos_tx.baud_rate.value
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%d&bslash;t&quot;
comma
id|self-&gt;qos_tx.max_turn_time.value
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%d&bslash;t&quot;
comma
id|self-&gt;qos_tx.data_size.value
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%d&bslash;t&quot;
comma
id|self-&gt;qos_tx.window_size.value
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%d&bslash;t&quot;
comma
id|self-&gt;qos_tx.additional_bofs.value
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%d&bslash;t&quot;
comma
id|self-&gt;qos_tx.min_turn_time.value
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%d&bslash;t&quot;
comma
id|self-&gt;qos_tx.link_disc_time.value
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%d&quot;
comma
id|self-&gt;qos_tx.compression.value
)paren
suffix:semicolon
macro_line|#endif
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;  rx&bslash;t%d&bslash;t&quot;
comma
id|self-&gt;qos_rx.baud_rate.value
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%d&bslash;t&quot;
comma
id|self-&gt;qos_rx.max_turn_time.value
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%d&bslash;t&quot;
comma
id|self-&gt;qos_rx.data_size.value
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%d&bslash;t&quot;
comma
id|self-&gt;qos_rx.window_size.value
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%d&bslash;t&quot;
comma
id|self-&gt;qos_rx.additional_bofs.value
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%d&bslash;t&quot;
comma
id|self-&gt;qos_rx.min_turn_time.value
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%d&bslash;t&quot;
comma
id|self-&gt;qos_rx.link_disc_time.value
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%d&quot;
comma
id|self-&gt;qos_rx.compression.value
)paren
suffix:semicolon
macro_line|#endif
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irlap_cb
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|irlap
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PROC_FS */
eof
