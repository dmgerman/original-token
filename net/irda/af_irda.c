multiline_comment|/*********************************************************************&n; *                &n; * Filename:      af_irda.c&n; * Version:       0.9&n; * Description:   IrDA sockets implementation&n; * Status:        Stable&n; * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Created at:    Sun May 31 10:12:43 1998&n; * Modified at:   Sat Dec 25 21:10:23 1999&n; * Modified by:   Dag Brattli &lt;dag@brattli.net&gt;&n; * Sources:       af_netroom.c, af_ax25.c, af_rose.c, af_x25.c etc.&n; * &n; *     Copyright (c) 1999 Dag Brattli &lt;dagb@cs.uit.no&gt;&n; *     Copyright (c) 1999 Jean Tourrilhes &lt;jt@hpl.hp.com&gt;&n; *     All Rights Reserved.&n; *&n; *     This program is free software; you can redistribute it and/or &n; *     modify it under the terms of the GNU General Public License as &n; *     published by the Free Software Foundation; either version 2 of &n; *     the License, or (at your option) any later version.&n; * &n; *     This program is distributed in the hope that it will be useful,&n; *     but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the&n; *     GNU General Public License for more details.&n; * &n; *     You should have received a copy of the GNU General Public License &n; *     along with this program; if not, write to the Free Software &n; *     Foundation, Inc., 59 Temple Place, Suite 330, Boston, &n; *     MA 02111-1307 USA&n; *&n; *     Linux-IrDA now supports four different types of IrDA sockets:&n; *&n; *     o SOCK_STREAM:    TinyTP connections with SAR disabled. The&n; *                       max SDU size is 0 for conn. of this type&n; *     o SOCK_SEQPACKET: TinyTP connections with SAR enabled. TTP may &n; *                       fragment the messages, but will preserve&n; *                       the message boundaries&n; *     o SOCK_DGRAM:     IRDAPROTO_UNITDATA: TinyTP connections with Unitdata &n; *                       (unreliable) transfers&n; *                       IRDAPROTO_ULTRA: Connectionless and unreliable data&n; *     &n; ********************************************************************/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/irda.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/iriap.h&gt;
macro_line|#include &lt;net/irda/irias_object.h&gt;
macro_line|#include &lt;net/irda/irlmp.h&gt;
macro_line|#include &lt;net/irda/irttp.h&gt;
macro_line|#include &lt;net/irda/discovery.h&gt;
r_extern
r_int
id|irda_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|irda_cleanup
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|irlap_driver_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
comma
r_struct
id|net_device
op_star
comma
r_struct
id|packet_type
op_star
)paren
suffix:semicolon
r_static
r_int
id|irda_create
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|protocol
)paren
suffix:semicolon
DECL|variable|irda_stream_ops
r_static
r_struct
id|proto_ops
id|irda_stream_ops
suffix:semicolon
DECL|variable|irda_seqpacket_ops
r_static
r_struct
id|proto_ops
id|irda_seqpacket_ops
suffix:semicolon
DECL|variable|irda_dgram_ops
r_static
r_struct
id|proto_ops
id|irda_dgram_ops
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_ULTRA
DECL|variable|irda_ultra_ops
r_static
r_struct
id|proto_ops
id|irda_ultra_ops
suffix:semicolon
DECL|macro|ULTRA_MAX_DATA
mdefine_line|#define ULTRA_MAX_DATA 382
macro_line|#endif /* CONFIG_IRDA_ULTRA */
DECL|macro|IRDA_MAX_HEADER
mdefine_line|#define IRDA_MAX_HEADER (TTP_MAX_HEADER)
macro_line|#ifdef CONFIG_IRDA_DEBUG
DECL|variable|irda_debug
id|__u32
id|irda_debug
op_assign
id|IRDA_DEBUG_LEVEL
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Function irda_data_indication (instance, sap, skb)&n; *&n; *    Received some data from TinyTP. Just queue it on the receive queue&n; *&n; */
DECL|function|irda_data_indication
r_static
r_int
id|irda_data_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_int
id|err
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irda_sock
op_star
)paren
id|instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|sk
op_assign
id|self-&gt;sk
suffix:semicolon
id|ASSERT
c_func
(paren
id|sk
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|err
op_assign
id|sock_queue_rcv_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), error: no more mem!&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;rx_flow
op_assign
id|FLOW_STOP
suffix:semicolon
multiline_comment|/* When we return error, TTP will need to requeue the skb */
r_return
id|err
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_disconnect_indication (instance, sap, reason, skb)&n; *&n; *    Connection has been closed. Check reason to find out why&n; *&n; */
DECL|function|irda_disconnect_indication
r_static
r_void
id|irda_disconnect_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
id|LM_REASON
id|reason
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irda_sock
op_star
)paren
id|instance
suffix:semicolon
id|sk
op_assign
id|self-&gt;sk
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|sk-&gt;err
op_assign
id|ECONNRESET
suffix:semicolon
id|sk-&gt;shutdown
op_or_assign
id|SEND_SHUTDOWN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;dead
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Close our TSAP.&n;&t; * If we leave it open, IrLMP put it back into the list of&n;&t; * unconnected LSAPs. The problem is that any incomming request&n;&t; * can then be matched to this socket (and it will be, because&n;&t; * it is at the head of the list). This would prevent any&n;&t; * listening socket waiting on the same TSAP to get those requests.&n;&t; * Some apps forget to close sockets, or hang to it a bit too long,&n;&t; * so we may stay in this dead state long enough to be noticed...&n;&t; * Note : all socket function do check sk-&gt;state, so we are safe...&n;&t; * Jean II&n;&t; */
id|irttp_close_tsap
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
id|self-&gt;tsap
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Note : once we are there, there is not much you want to do&n;&t; * with the socket anymore, apart from closing it.&n;&t; * For example, bind() and connect() won&squot;t reset sk-&gt;err,&n;&t; * sk-&gt;shutdown and sk-&gt;dead to valid values...&n;&t; * Jean II&n;&t; */
)brace
multiline_comment|/*&n; * Function irda_connect_confirm (instance, sap, qos, max_sdu_size, skb)&n; *&n; *    Connections has been confirmed by the remote device&n; *&n; */
DECL|function|irda_connect_confirm
r_static
r_void
id|irda_connect_confirm
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|qos_info
op_star
id|qos
comma
id|__u32
id|max_sdu_size
comma
id|__u8
id|max_header_size
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irda_sock
op_star
)paren
id|instance
suffix:semicolon
id|sk
op_assign
id|self-&gt;sk
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* How much header space do we need to reserve */
id|self-&gt;max_header_size
op_assign
id|max_header_size
suffix:semicolon
multiline_comment|/* IrTTP max SDU size in transmit direction */
id|self-&gt;max_sdu_size_tx
op_assign
id|max_sdu_size
suffix:semicolon
multiline_comment|/* Find out what the largest chunk of data that we can transmit is */
r_switch
c_cond
(paren
id|sk-&gt;type
)paren
(brace
r_case
id|SOCK_STREAM
suffix:colon
r_if
c_cond
(paren
id|max_sdu_size
op_ne
l_int|0
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), max_sdu_size must be 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|self-&gt;max_data_size
op_assign
id|irttp_get_max_seg_size
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOCK_SEQPACKET
suffix:colon
r_if
c_cond
(paren
id|max_sdu_size
op_eq
l_int|0
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), max_sdu_size cannot be 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|self-&gt;max_data_size
op_assign
id|max_sdu_size
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|self-&gt;max_data_size
op_assign
id|irttp_get_max_seg_size
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
)brace
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), max_data_size=%d&bslash;n&quot;
comma
id|self-&gt;max_data_size
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|self-&gt;qos_tx
comma
id|qos
comma
r_sizeof
(paren
r_struct
id|qos_info
)paren
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* We are now connected! */
id|sk-&gt;state
op_assign
id|TCP_ESTABLISHED
suffix:semicolon
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_connect_indication(instance, sap, qos, max_sdu_size, userdata)&n; *&n; *    Incomming connection&n; *&n; */
DECL|function|irda_connect_indication
r_static
r_void
id|irda_connect_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|qos_info
op_star
id|qos
comma
id|__u32
id|max_sdu_size
comma
id|__u8
id|max_header_size
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irda_sock
op_star
)paren
id|instance
suffix:semicolon
id|sk
op_assign
id|self-&gt;sk
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* How much header space do we need to reserve */
id|self-&gt;max_header_size
op_assign
id|max_header_size
suffix:semicolon
multiline_comment|/* IrTTP max SDU size in transmit direction */
id|self-&gt;max_sdu_size_tx
op_assign
id|max_sdu_size
suffix:semicolon
multiline_comment|/* Find out what the largest chunk of data that we can transmit is */
r_switch
c_cond
(paren
id|sk-&gt;type
)paren
(brace
r_case
id|SOCK_STREAM
suffix:colon
r_if
c_cond
(paren
id|max_sdu_size
op_ne
l_int|0
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), max_sdu_size must be 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|self-&gt;max_data_size
op_assign
id|irttp_get_max_seg_size
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOCK_SEQPACKET
suffix:colon
r_if
c_cond
(paren
id|max_sdu_size
op_eq
l_int|0
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), max_sdu_size cannot be 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|self-&gt;max_data_size
op_assign
id|max_sdu_size
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|self-&gt;max_data_size
op_assign
id|irttp_get_max_seg_size
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
)brace
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), max_data_size=%d&bslash;n&quot;
comma
id|self-&gt;max_data_size
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|self-&gt;qos_tx
comma
id|qos
comma
r_sizeof
(paren
r_struct
id|qos_info
)paren
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_connect_response (handle)&n; *&n; *    Accept incomming connection&n; *&n; */
DECL|function|irda_connect_response
r_void
id|irda_connect_response
c_func
(paren
r_struct
id|irda_sock
op_star
id|self
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
l_int|64
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;() Unable to allocate sk_buff!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Reserve space for MUX_CONTROL and LAP header */
id|skb_reserve
c_func
(paren
id|skb
comma
id|IRDA_MAX_HEADER
)paren
suffix:semicolon
id|irttp_connect_response
c_func
(paren
id|self-&gt;tsap
comma
id|self-&gt;max_sdu_size_rx
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_flow_indication (instance, sap, flow)&n; *&n; *    Used by TinyTP to tell us if it can accept more data or not&n; *&n; */
DECL|function|irda_flow_indication
r_static
r_void
id|irda_flow_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
id|LOCAL_FLOW
id|flow
)paren
(brace
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irda_sock
op_star
)paren
id|instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|sk
op_assign
id|self-&gt;sk
suffix:semicolon
id|ASSERT
c_func
(paren
id|sk
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|flow
)paren
(brace
r_case
id|FLOW_STOP
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), IrTTP wants us to slow down&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;tx_flow
op_assign
id|flow
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLOW_START
suffix:colon
id|self-&gt;tx_flow
op_assign
id|flow
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), IrTTP wants us to start again&bslash;n&quot;
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unknown flow command!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Unknown flow command, better stop */
id|self-&gt;tx_flow
op_assign
id|flow
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irda_getvalue_confirm (obj_id, value, priv)&n; *&n; *    Got answer from remote LM-IAS, just pass object to requester...&n; *&n; * Note : duplicate from above, but we need our own version that&n; * doesn&squot;t touch the dtsap_sel and save the full value structure...&n; */
DECL|function|irda_getvalue_confirm
r_static
r_void
id|irda_getvalue_confirm
c_func
(paren
r_int
id|result
comma
id|__u16
id|obj_id
comma
r_struct
id|ias_value
op_star
id|value
comma
r_void
op_star
id|priv
)paren
(brace
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irda_sock
op_star
)paren
id|priv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), lost myself!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* We probably don&squot;t need to make any more queries */
id|iriap_close
c_func
(paren
id|self-&gt;iriap
)paren
suffix:semicolon
id|self-&gt;iriap
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Check if request succeeded */
r_if
c_cond
(paren
id|result
op_ne
id|IAS_SUCCESS
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), IAS query failed! (%d)&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
id|self-&gt;errno
op_assign
id|result
suffix:semicolon
multiline_comment|/* We really need it later */
multiline_comment|/* Wake up any processes waiting for result */
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;query_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Pass the object to the caller (so the caller must delete it) */
id|self-&gt;ias_result
op_assign
id|value
suffix:semicolon
id|self-&gt;errno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Wake up any processes waiting for result */
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;query_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_selective_discovery_indication (discovery)&n; *&n; *    Got a selective discovery indication from IrLMP.&n; *&n; * IrLMP is telling us that this node is matching our hint bit&n; * filter. Check if it&squot;s a newly discovered node (or if node changed its&n; * hint bits), and then wake up any process waiting for answer...&n; */
DECL|function|irda_selective_discovery_indication
r_static
r_void
id|irda_selective_discovery_indication
c_func
(paren
id|discovery_t
op_star
id|discovery
comma
r_void
op_star
id|priv
)paren
(brace
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irda_sock
op_star
)paren
id|priv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), lost myself!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check if node is discovered is a new one or an old one.&n;&t; * We check when how long ago this node was discovered, with a&n;&t; * coarse timeout (we may miss some discovery events or be delayed).&n;&t; * Note : by doing this test here, we avoid waking up a process ;-)&n;&t; */
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|discovery-&gt;first_timestamp
)paren
OG
(paren
id|sysctl_discovery_timeout
op_star
id|HZ
)paren
)paren
(brace
r_return
suffix:semicolon
multiline_comment|/* Too old, not interesting -&gt; goodbye */
)brace
multiline_comment|/* Pass parameter to the caller */
id|self-&gt;cachediscovery
op_assign
id|discovery
suffix:semicolon
multiline_comment|/* Wake up process if its waiting for device to be discovered */
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;query_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_discovery_timeout (priv)&n; *&n; *    Timeout in the selective discovery process&n; *&n; * We were waiting for a node to be discovered, but nothing has come up&n; * so far. Wake up the user and tell him that we failed...&n; */
DECL|function|irda_discovery_timeout
r_static
r_void
id|irda_discovery_timeout
c_func
(paren
id|u_long
id|priv
)paren
(brace
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irda_sock
op_star
)paren
id|priv
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Nothing for the caller */
id|self-&gt;cachelog
op_assign
l_int|NULL
suffix:semicolon
id|self-&gt;cachediscovery
op_assign
l_int|NULL
suffix:semicolon
id|self-&gt;errno
op_assign
op_minus
id|ETIME
suffix:semicolon
multiline_comment|/* Wake up process if its still waiting... */
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;query_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_open_tsap (self)&n; *&n; *    Open local Transport Service Access Point (TSAP)&n; *&n; */
DECL|function|irda_open_tsap
r_static
r_int
id|irda_open_tsap
c_func
(paren
r_struct
id|irda_sock
op_star
id|self
comma
id|__u8
id|tsap_sel
comma
r_char
op_star
id|name
)paren
(brace
id|notify_t
id|notify
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;tsap
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), busy!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* Initialize callbacks to be used by the IrDA stack */
id|irda_notify_init
c_func
(paren
op_amp
id|notify
)paren
suffix:semicolon
id|notify.connect_confirm
op_assign
id|irda_connect_confirm
suffix:semicolon
id|notify.connect_indication
op_assign
id|irda_connect_indication
suffix:semicolon
id|notify.disconnect_indication
op_assign
id|irda_disconnect_indication
suffix:semicolon
id|notify.data_indication
op_assign
id|irda_data_indication
suffix:semicolon
id|notify.udata_indication
op_assign
id|irda_data_indication
suffix:semicolon
id|notify.flow_indication
op_assign
id|irda_flow_indication
suffix:semicolon
id|notify.instance
op_assign
id|self
suffix:semicolon
id|strncpy
c_func
(paren
id|notify.name
comma
id|name
comma
id|NOTIFY_MAX_NAME
)paren
suffix:semicolon
id|self-&gt;tsap
op_assign
id|irttp_open_tsap
c_func
(paren
id|tsap_sel
comma
id|DEFAULT_INITIAL_CREDIT
comma
op_amp
id|notify
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;tsap
op_eq
l_int|NULL
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unable to allocate TSAP!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Remember which TSAP selector we actually got */
id|self-&gt;stsap_sel
op_assign
id|self-&gt;tsap-&gt;stsap_sel
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_open_lsap (self)&n; *&n; *    Open local Link Service Access Point (LSAP). Used for opening Ultra&n; *    sockets&n; */
macro_line|#ifdef CONFIG_IRDA_ULTRA
DECL|function|irda_open_lsap
r_static
r_int
id|irda_open_lsap
c_func
(paren
r_struct
id|irda_sock
op_star
id|self
comma
r_int
id|pid
)paren
(brace
id|notify_t
id|notify
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;lsap
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), busy!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* Initialize callbacks to be used by the IrDA stack */
id|irda_notify_init
c_func
(paren
op_amp
id|notify
)paren
suffix:semicolon
id|notify.udata_indication
op_assign
id|irda_data_indication
suffix:semicolon
id|notify.instance
op_assign
id|self
suffix:semicolon
id|strncpy
c_func
(paren
id|notify.name
comma
l_string|&quot;Ultra&quot;
comma
id|NOTIFY_MAX_NAME
)paren
suffix:semicolon
id|self-&gt;lsap
op_assign
id|irlmp_open_lsap
c_func
(paren
id|LSAP_CONNLESS
comma
op_amp
id|notify
comma
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;lsap
op_eq
l_int|NULL
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unable to allocate LSAP!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IRDA_ULTRA */
multiline_comment|/*&n; * Function irda_find_lsap_sel (self, name)&n; *&n; *    Try to lookup LSAP selector in remote LM-IAS&n; *&n; * Basically, we start a IAP query, and then go to sleep. When the query&n; * return, irda_getvalue_confirm will wake us up, and we can examine the&n; * result of the query...&n; * Note that in some case, the query fail even before we go to sleep,&n; * creating some races...&n; */
DECL|function|irda_find_lsap_sel
r_static
r_int
id|irda_find_lsap_sel
c_func
(paren
r_struct
id|irda_sock
op_star
id|self
comma
r_char
op_star
id|name
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), name=%s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;iriap
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), busy with a previous query&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|self-&gt;iriap
op_assign
id|iriap_open
c_func
(paren
id|LSAP_ANY
comma
id|IAS_CLIENT
comma
id|self
comma
id|irda_getvalue_confirm
)paren
suffix:semicolon
multiline_comment|/* Treat unexpected signals as disconnect */
id|self-&gt;errno
op_assign
op_minus
id|EHOSTUNREACH
suffix:semicolon
multiline_comment|/* Query remote LM-IAS */
id|iriap_getvaluebyclass_request
c_func
(paren
id|self-&gt;iriap
comma
id|self-&gt;saddr
comma
id|self-&gt;daddr
comma
id|name
comma
l_string|&quot;IrDA:TinyTP:LsapSel&quot;
)paren
suffix:semicolon
multiline_comment|/* Wait for answer (if not already failed) */
r_if
c_cond
(paren
id|self-&gt;iriap
op_ne
l_int|NULL
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|self-&gt;query_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* Check what happened */
r_if
c_cond
(paren
id|self-&gt;errno
)paren
(brace
multiline_comment|/* Requested object/attribute doesn&squot;t exist */
r_if
c_cond
(paren
(paren
id|self-&gt;errno
op_eq
id|IAS_CLASS_UNKNOWN
)paren
op_logical_or
(paren
id|self-&gt;errno
op_eq
id|IAS_ATTRIB_UNKNOWN
)paren
)paren
(brace
r_return
(paren
op_minus
id|EADDRNOTAVAIL
)paren
suffix:semicolon
)brace
r_else
r_return
(paren
op_minus
id|EHOSTUNREACH
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the remote TSAP selector */
r_switch
c_cond
(paren
id|self-&gt;ias_result-&gt;type
)paren
(brace
r_case
id|IAS_INTEGER
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;() int=%d&bslash;n&quot;
comma
id|self-&gt;ias_result-&gt;t.integer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;ias_result-&gt;t.integer
op_ne
op_minus
l_int|1
)paren
id|self-&gt;dtsap_sel
op_assign
id|self-&gt;ias_result-&gt;t.integer
suffix:semicolon
r_else
id|self-&gt;dtsap_sel
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|self-&gt;dtsap_sel
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), bad type!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|self-&gt;ias_result
)paren
id|irias_delete_value
c_func
(paren
id|self-&gt;ias_result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;dtsap_sel
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_discover_daddr_and_lsap_sel (self, name)&n; *&n; *    This try to find a device with the requested service.&n; *&n; * It basically look into the discovery log. For each address in the list,&n; * it queries the LM-IAS of the device to find if this device offer&n; * the requested service.&n; * If there is more than one node supporting the service, we complain&n; * to the user (it should move devices around).&n; * The, we set both the destination address and the lsap selector to point&n; * on the service on the unique device we have found.&n; *&n; * Note : this function fails if there is more than one device in range,&n; * because IrLMP doesn&squot;t disconnect the LAP when the last LSAP is closed.&n; * Moreover, we would need to wait the LAP disconnection...&n; */
DECL|function|irda_discover_daddr_and_lsap_sel
r_static
r_int
id|irda_discover_daddr_and_lsap_sel
c_func
(paren
r_struct
id|irda_sock
op_star
id|self
comma
r_char
op_star
id|name
)paren
(brace
r_struct
id|irda_device_info
op_star
id|discoveries
suffix:semicolon
multiline_comment|/* Copy of the discovery log */
r_int
id|number
suffix:semicolon
multiline_comment|/* Number of nodes in the log */
r_int
id|i
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENETUNREACH
suffix:semicolon
id|__u32
id|daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
multiline_comment|/* Address we found the service on */
id|__u8
id|dtsap_sel
op_assign
l_int|0x0
suffix:semicolon
multiline_comment|/* TSAP associated with it */
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), name=%s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Ask lmp for the current discovery log&n;&t; * Note : we have to use irlmp_get_discoveries(), as opposed&n;&t; * to play with the cachelog directly, because while we are&n;&t; * making our ias query, le log might change... */
id|discoveries
op_assign
id|irlmp_get_discoveries
c_func
(paren
op_amp
id|number
comma
id|self-&gt;mask
)paren
suffix:semicolon
multiline_comment|/* Check if the we got some results */
r_if
c_cond
(paren
id|discoveries
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
multiline_comment|/* No nodes discovered */
multiline_comment|/* &n;&t; * Now, check all discovered devices (if any), and connect&n;&t; * client only about the services that the client is&n;&t; * interested in...&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|number
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Try the address in the log */
id|self-&gt;daddr
op_assign
id|discoveries
(braket
id|i
)braket
dot
id|daddr
suffix:semicolon
id|self-&gt;saddr
op_assign
l_int|0x0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), trying daddr = %08x&bslash;n&quot;
comma
id|self-&gt;daddr
)paren
suffix:semicolon
multiline_comment|/* Query remote LM-IAS for this service */
id|err
op_assign
id|irda_find_lsap_sel
c_func
(paren
id|self
comma
id|name
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|err
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* We found the requested service */
r_if
c_cond
(paren
id|daddr
op_ne
id|DEV_ADDR_ANY
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), discovered service &squot;&squot;%s&squot;&squot; in two different devices !!!&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|self-&gt;daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
id|kfree
c_func
(paren
id|discoveries
)paren
suffix:semicolon
r_return
op_minus
id|ENOTUNIQ
suffix:semicolon
)brace
multiline_comment|/* First time we found that one, save it ! */
id|daddr
op_assign
id|self-&gt;daddr
suffix:semicolon
id|dtsap_sel
op_assign
id|self-&gt;dtsap_sel
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EADDRNOTAVAIL
suffix:colon
multiline_comment|/* Requested service simply doesn&squot;t exist on this node */
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Something bad did happen :-( */
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), unexpected IAS query failure&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
id|kfree
c_func
(paren
id|discoveries
)paren
suffix:semicolon
r_return
op_minus
id|EHOSTUNREACH
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Cleanup our copy of the discovery log */
id|kfree
c_func
(paren
id|discoveries
)paren
suffix:semicolon
multiline_comment|/* Check out what we found */
r_if
c_cond
(paren
id|daddr
op_eq
id|DEV_ADDR_ANY
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), cannot discover service &squot;&squot;%s&squot;&squot; in any device !!!&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|self-&gt;daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
)brace
multiline_comment|/* Revert back to discovered device &amp; service */
id|self-&gt;daddr
op_assign
id|daddr
suffix:semicolon
id|self-&gt;saddr
op_assign
l_int|0x0
suffix:semicolon
id|self-&gt;dtsap_sel
op_assign
id|dtsap_sel
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), discovered requested service &squot;&squot;%s&squot;&squot; at address %08x&bslash;n&quot;
comma
id|name
comma
id|self-&gt;daddr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_getname (sock, uaddr, uaddr_len, peer)&n; *&n; *    Return the our own, or peers socket address (sockaddr_irda)&n; *&n; */
DECL|function|irda_getname
r_static
r_int
id|irda_getname
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
op_star
id|uaddr_len
comma
r_int
id|peer
)paren
(brace
r_struct
id|sockaddr_irda
id|saddr
suffix:semicolon
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|irda_sock
op_star
id|self
op_assign
id|sk-&gt;protinfo.irda
suffix:semicolon
r_if
c_cond
(paren
id|peer
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
id|saddr.sir_family
op_assign
id|AF_IRDA
suffix:semicolon
id|saddr.sir_lsap_sel
op_assign
id|self-&gt;dtsap_sel
suffix:semicolon
id|saddr.sir_addr
op_assign
id|self-&gt;daddr
suffix:semicolon
)brace
r_else
(brace
id|saddr.sir_family
op_assign
id|AF_IRDA
suffix:semicolon
id|saddr.sir_lsap_sel
op_assign
id|self-&gt;stsap_sel
suffix:semicolon
id|saddr.sir_addr
op_assign
id|self-&gt;saddr
suffix:semicolon
)brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), tsap_sel = %#x&bslash;n&quot;
comma
id|saddr.sir_lsap_sel
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), addr = %08x&bslash;n&quot;
comma
id|saddr.sir_addr
)paren
suffix:semicolon
multiline_comment|/* uaddr_len come to us uninitialised */
op_star
id|uaddr_len
op_assign
r_sizeof
(paren
r_struct
id|sockaddr_irda
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|uaddr
comma
op_amp
id|saddr
comma
op_star
id|uaddr_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_listen (sock, backlog)&n; *&n; *    Just move to the listen state&n; *&n; */
DECL|function|irda_listen
r_static
r_int
id|irda_listen
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|backlog
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sk-&gt;type
op_ne
id|SOCK_STREAM
)paren
op_logical_and
(paren
id|sk-&gt;type
op_ne
id|SOCK_SEQPACKET
)paren
op_logical_and
(paren
id|sk-&gt;type
op_ne
id|SOCK_DGRAM
)paren
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_LISTEN
)paren
(brace
id|sk-&gt;max_ack_backlog
op_assign
id|backlog
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_LISTEN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_bind (sock, uaddr, addr_len)&n; *&n; *    Used by servers to register their well known TSAP&n; *&n; */
DECL|function|irda_bind
r_static
r_int
id|irda_bind
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|sockaddr_irda
op_star
id|addr
op_assign
(paren
r_struct
id|sockaddr_irda
op_star
)paren
id|uaddr
suffix:semicolon
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
id|__u16
id|hints
op_assign
l_int|0
suffix:semicolon
r_int
id|err
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
id|sk-&gt;protinfo.irda
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr_len
op_ne
r_sizeof
(paren
r_struct
id|sockaddr_irda
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_ULTRA
multiline_comment|/* Special care for Ultra sockets */
r_if
c_cond
(paren
(paren
id|sk-&gt;type
op_eq
id|SOCK_DGRAM
)paren
op_logical_and
(paren
id|sk-&gt;protocol
op_eq
id|IRDAPROTO_ULTRA
)paren
)paren
(brace
id|self-&gt;pid
op_assign
id|addr-&gt;sir_lsap_sel
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;pid
op_amp
l_int|0x80
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), extension in PID not supp!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
id|err
op_assign
id|irda_open_lsap
c_func
(paren
id|self
comma
id|self-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|self-&gt;max_data_size
op_assign
id|ULTRA_MAX_DATA
op_minus
id|LMP_PID_HEADER
suffix:semicolon
id|self-&gt;max_header_size
op_assign
id|IRDA_MAX_HEADER
op_plus
id|LMP_PID_HEADER
suffix:semicolon
multiline_comment|/* Pretend we are connected */
id|sock-&gt;state
op_assign
id|SS_CONNECTED
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_ESTABLISHED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IRDA_ULTRA */
id|err
op_assign
id|irda_open_tsap
c_func
(paren
id|self
comma
id|addr-&gt;sir_lsap_sel
comma
id|addr-&gt;sir_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/*  Register with LM-IAS */
id|self-&gt;ias_obj
op_assign
id|irias_new_object
c_func
(paren
id|addr-&gt;sir_name
comma
id|jiffies
)paren
suffix:semicolon
id|irias_add_integer_attrib
c_func
(paren
id|self-&gt;ias_obj
comma
l_string|&quot;IrDA:TinyTP:LsapSel&quot;
comma
id|self-&gt;stsap_sel
comma
id|IAS_KERNEL_ATTR
)paren
suffix:semicolon
id|irias_insert_object
c_func
(paren
id|self-&gt;ias_obj
)paren
suffix:semicolon
macro_line|#if 1 /* Will be removed in near future */
multiline_comment|/* Fill in some default hint bits values */
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|addr-&gt;sir_name
comma
l_string|&quot;OBEX&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
id|hints
op_assign
id|irlmp_service_to_hint
c_func
(paren
id|S_OBEX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hints
)paren
id|self-&gt;skey
op_assign
id|irlmp_register_service
c_func
(paren
id|hints
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_accept (sock, newsock, flags)&n; *&n; *    Wait for incomming connection&n; *&n; */
DECL|function|irda_accept
r_static
r_int
id|irda_accept
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|socket
op_star
id|newsock
comma
r_int
id|flags
)paren
(brace
r_struct
id|irda_sock
op_star
id|self
comma
op_star
r_new
suffix:semicolon
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|sock
op_star
id|newsk
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|err
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
id|sk-&gt;protinfo.irda
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|err
op_assign
id|irda_create
c_func
(paren
id|newsock
comma
id|sk-&gt;protocol
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|sock-&gt;state
op_ne
id|SS_UNCONNECTED
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sk
op_assign
id|sock-&gt;sk
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sk-&gt;type
op_ne
id|SOCK_STREAM
)paren
op_logical_and
(paren
id|sk-&gt;type
op_ne
id|SOCK_SEQPACKET
)paren
op_logical_and
(paren
id|sk-&gt;type
op_ne
id|SOCK_DGRAM
)paren
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_LISTEN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;The read queue this time is holding sockets ready to use&n;&t; *&t;hooked into the SABM we saved&n;&t; */
r_do
(brace
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|O_NONBLOCK
)paren
r_return
op_minus
id|EWOULDBLOCK
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|skb
op_eq
l_int|NULL
)paren
suffix:semicolon
id|newsk
op_assign
id|newsock-&gt;sk
suffix:semicolon
id|newsk-&gt;state
op_assign
id|TCP_ESTABLISHED
suffix:semicolon
r_new
op_assign
id|newsk-&gt;protinfo.irda
suffix:semicolon
id|ASSERT
c_func
(paren
r_new
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Now attach up the new socket */
r_new
op_member_access_from_pointer
id|tsap
op_assign
id|irttp_dup
c_func
(paren
id|self-&gt;tsap
comma
r_new
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
op_member_access_from_pointer
id|tsap
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), dup failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_new
op_member_access_from_pointer
id|stsap_sel
op_assign
r_new
op_member_access_from_pointer
id|tsap-&gt;stsap_sel
suffix:semicolon
r_new
op_member_access_from_pointer
id|dtsap_sel
op_assign
r_new
op_member_access_from_pointer
id|tsap-&gt;dtsap_sel
suffix:semicolon
r_new
op_member_access_from_pointer
id|saddr
op_assign
id|irttp_get_saddr
c_func
(paren
r_new
op_member_access_from_pointer
id|tsap
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|daddr
op_assign
id|irttp_get_daddr
c_func
(paren
r_new
op_member_access_from_pointer
id|tsap
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|max_sdu_size_tx
op_assign
id|self-&gt;max_sdu_size_tx
suffix:semicolon
r_new
op_member_access_from_pointer
id|max_sdu_size_rx
op_assign
id|self-&gt;max_sdu_size_rx
suffix:semicolon
r_new
op_member_access_from_pointer
id|max_data_size
op_assign
id|self-&gt;max_data_size
suffix:semicolon
r_new
op_member_access_from_pointer
id|max_header_size
op_assign
id|self-&gt;max_header_size
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|qos_tx
comma
op_amp
id|self-&gt;qos_tx
comma
r_sizeof
(paren
r_struct
id|qos_info
)paren
)paren
suffix:semicolon
multiline_comment|/* Clean up the original one to keep it in listen state */
id|self-&gt;tsap-&gt;dtsap_sel
op_assign
id|self-&gt;tsap-&gt;lsap-&gt;dlsap_sel
op_assign
id|LSAP_ANY
suffix:semicolon
id|self-&gt;tsap-&gt;lsap-&gt;lsap_state
op_assign
id|LSAP_DISCONNECTED
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|sk-&gt;ack_backlog
op_decrement
suffix:semicolon
id|newsock-&gt;state
op_assign
id|SS_CONNECTED
suffix:semicolon
id|irda_connect_response
c_func
(paren
r_new
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_connect (sock, uaddr, addr_len, flags)&n; *&n; *    Connect to a IrDA device&n; *&n; * The main difference with a &quot;standard&quot; connect is that with IrDA we need&n; * to resolve the service name into a TSAP selector (in TCP, port number&n; * doesn&squot;t have to be resolved).&n; * Because of this service name resoltion, we can offer &quot;auto-connect&quot;,&n; * where we connect to a service without specifying a destination address.&n; *&n; * Note : by consulting &quot;errno&quot;, the user space caller may learn the cause&n; * of the failure. Most of them are visible in the function, others may come&n; * from subroutines called and are listed here :&n; *&t;o EBUSY : already processing a connect&n; *&t;o EHOSTUNREACH : bad addr-&gt;sir_addr argument&n; *&t;o EADDRNOTAVAIL : bad addr-&gt;sir_name argument&n; *&t;o ENOTUNIQ : more than one node has addr-&gt;sir_name (auto-connect)&n; *&t;o ENETUNREACH : no node found on the network (auto-connect)&n; */
DECL|function|irda_connect
r_static
r_int
id|irda_connect
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
comma
r_int
id|flags
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|sockaddr_irda
op_star
id|addr
op_assign
(paren
r_struct
id|sockaddr_irda
op_star
)paren
id|uaddr
suffix:semicolon
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
r_int
id|err
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
id|sk-&gt;protinfo.irda
suffix:semicolon
multiline_comment|/* Don&squot;t allow connect for Ultra sockets */
r_if
c_cond
(paren
(paren
id|sk-&gt;type
op_eq
id|SOCK_DGRAM
)paren
op_logical_and
(paren
id|sk-&gt;protocol
op_eq
id|IRDAPROTO_ULTRA
)paren
)paren
r_return
op_minus
id|ESOCKTNOSUPPORT
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
op_logical_and
id|sock-&gt;state
op_eq
id|SS_CONNECTING
)paren
(brace
id|sock-&gt;state
op_assign
id|SS_CONNECTED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Connect completed during a ERESTARTSYS event */
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
op_logical_and
id|sock-&gt;state
op_eq
id|SS_CONNECTING
)paren
(brace
id|sock-&gt;state
op_assign
id|SS_UNCONNECTED
suffix:semicolon
r_return
op_minus
id|ECONNREFUSED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
)paren
r_return
op_minus
id|EISCONN
suffix:semicolon
multiline_comment|/* No reconnect on a seqpacket socket */
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|sock-&gt;state
op_assign
id|SS_UNCONNECTED
suffix:semicolon
r_if
c_cond
(paren
id|addr_len
op_ne
r_sizeof
(paren
r_struct
id|sockaddr_irda
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Check if user supplied any destination device address */
r_if
c_cond
(paren
(paren
op_logical_neg
id|addr-&gt;sir_addr
)paren
op_logical_or
(paren
id|addr-&gt;sir_addr
op_eq
id|DEV_ADDR_ANY
)paren
)paren
(brace
multiline_comment|/* Try to find one suitable */
id|err
op_assign
id|irda_discover_daddr_and_lsap_sel
c_func
(paren
id|self
comma
id|addr-&gt;sir_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), auto-connect failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Use the one provided by the user */
id|self-&gt;daddr
op_assign
id|addr-&gt;sir_addr
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), daddr = %08x&bslash;n&quot;
comma
id|self-&gt;daddr
)paren
suffix:semicolon
multiline_comment|/* Query remote LM-IAS */
id|err
op_assign
id|irda_find_lsap_sel
c_func
(paren
id|self
comma
id|addr-&gt;sir_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), connect failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
multiline_comment|/* Check if we have opened a local TSAP */
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;tsap
)paren
id|irda_open_tsap
c_func
(paren
id|self
comma
id|LSAP_ANY
comma
id|addr-&gt;sir_name
)paren
suffix:semicolon
multiline_comment|/* Move to connecting socket, start sending Connect Requests */
id|sock-&gt;state
op_assign
id|SS_CONNECTING
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_SYN_SENT
suffix:semicolon
multiline_comment|/* Connect to remote device */
id|err
op_assign
id|irttp_connect_request
c_func
(paren
id|self-&gt;tsap
comma
id|self-&gt;dtsap_sel
comma
id|self-&gt;saddr
comma
id|self-&gt;daddr
comma
l_int|NULL
comma
id|self-&gt;max_sdu_size_rx
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), connect failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Now the loop */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
(paren
id|flags
op_amp
id|O_NONBLOCK
)paren
)paren
r_return
op_minus
id|EINPROGRESS
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* To avoid races on the sleep */
multiline_comment|/* A Connect Ack with Choke or timeout or failed routing will go to&n;&t; * closed.  */
r_while
c_loop
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|sock-&gt;state
op_assign
id|SS_UNCONNECTED
suffix:semicolon
r_return
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Always set at this point */
)brace
id|sock-&gt;state
op_assign
id|SS_CONNECTED
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* At this point, IrLMP has assigned our source address */
id|self-&gt;saddr
op_assign
id|irttp_get_saddr
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_create (sock, protocol)&n; *&n; *    Create IrDA socket&n; *&n; */
DECL|function|irda_create
r_static
r_int
id|irda_create
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|protocol
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Check for valid socket type */
r_switch
c_cond
(paren
id|sock-&gt;type
)paren
(brace
r_case
id|SOCK_STREAM
suffix:colon
multiline_comment|/* For TTP connections with SAR disabled */
r_case
id|SOCK_SEQPACKET
suffix:colon
multiline_comment|/* For TTP connections with SAR enabled */
r_case
id|SOCK_DGRAM
suffix:colon
multiline_comment|/* For TTP Unitdata or LMP Ultra transfers */
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ESOCKTNOSUPPORT
suffix:semicolon
)brace
multiline_comment|/* Allocate socket */
r_if
c_cond
(paren
(paren
id|sk
op_assign
id|sk_alloc
c_func
(paren
id|PF_IRDA
comma
id|GFP_ATOMIC
comma
l_int|1
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|self
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irda_sock
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|self
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|irda_sock
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|self-&gt;query_wait
)paren
suffix:semicolon
id|self-&gt;sk
op_assign
id|sk
suffix:semicolon
id|sk-&gt;protinfo.irda
op_assign
id|self
suffix:semicolon
id|sock_init_data
c_func
(paren
id|sock
comma
id|sk
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sock-&gt;type
)paren
(brace
r_case
id|SOCK_STREAM
suffix:colon
id|sock-&gt;ops
op_assign
op_amp
id|irda_stream_ops
suffix:semicolon
id|self-&gt;max_sdu_size_rx
op_assign
id|TTP_SAR_DISABLE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOCK_SEQPACKET
suffix:colon
id|sock-&gt;ops
op_assign
op_amp
id|irda_seqpacket_ops
suffix:semicolon
id|self-&gt;max_sdu_size_rx
op_assign
id|TTP_SAR_UNBOUND
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOCK_DGRAM
suffix:colon
r_switch
c_cond
(paren
id|protocol
)paren
(brace
macro_line|#ifdef CONFIG_IRDA_ULTRA
r_case
id|IRDAPROTO_ULTRA
suffix:colon
id|sock-&gt;ops
op_assign
op_amp
id|irda_ultra_ops
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_ULTRA */
r_case
id|IRDAPROTO_UNITDATA
suffix:colon
id|sock-&gt;ops
op_assign
op_amp
id|irda_dgram_ops
suffix:semicolon
multiline_comment|/* We let Unitdata conn. be like seqpack conn. */
id|self-&gt;max_sdu_size_rx
op_assign
id|TTP_SAR_UNBOUND
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), protocol not supported!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ESOCKTNOSUPPORT
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ESOCKTNOSUPPORT
suffix:semicolon
)brace
id|sk-&gt;protocol
op_assign
id|protocol
suffix:semicolon
multiline_comment|/* Register as a client with IrLMP */
id|self-&gt;ckey
op_assign
id|irlmp_register_client
c_func
(paren
l_int|0
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|self-&gt;mask
op_assign
l_int|0xffff
suffix:semicolon
id|self-&gt;rx_flow
op_assign
id|self-&gt;tx_flow
op_assign
id|FLOW_START
suffix:semicolon
id|self-&gt;nslots
op_assign
id|DISCOVERY_DEFAULT_SLOTS
suffix:semicolon
id|self-&gt;daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
multiline_comment|/* Until we get connected */
id|self-&gt;saddr
op_assign
l_int|0x0
suffix:semicolon
multiline_comment|/* so IrLMP assign us any link */
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_destroy_socket (self)&n; *&n; *    Destroy socket&n; *&n; */
DECL|function|irda_destroy_socket
r_void
id|irda_destroy_socket
c_func
(paren
r_struct
id|irda_sock
op_star
id|self
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Unregister with IrLMP */
id|irlmp_unregister_client
c_func
(paren
id|self-&gt;ckey
)paren
suffix:semicolon
id|irlmp_unregister_service
c_func
(paren
id|self-&gt;skey
)paren
suffix:semicolon
multiline_comment|/* Unregister with LM-IAS */
r_if
c_cond
(paren
id|self-&gt;ias_obj
)paren
(brace
id|irias_delete_object
c_func
(paren
id|self-&gt;ias_obj
)paren
suffix:semicolon
id|self-&gt;ias_obj
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|self-&gt;iriap
)paren
(brace
id|iriap_close
c_func
(paren
id|self-&gt;iriap
)paren
suffix:semicolon
id|self-&gt;iriap
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|self-&gt;tsap
)paren
(brace
id|irttp_disconnect_request
c_func
(paren
id|self-&gt;tsap
comma
l_int|NULL
comma
id|P_NORMAL
)paren
suffix:semicolon
id|irttp_close_tsap
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
id|self-&gt;tsap
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IRDA_ULTRA
r_if
c_cond
(paren
id|self-&gt;lsap
)paren
(brace
id|irlmp_close_lsap
c_func
(paren
id|self-&gt;lsap
)paren
suffix:semicolon
id|self-&gt;lsap
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IRDA_ULTRA */
id|kfree
c_func
(paren
id|self
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_release (sock)&n; *&n; *    &n; *&n; */
DECL|function|irda_release
r_static
r_int
id|irda_release
c_func
(paren
r_struct
id|socket
op_star
id|sock
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|sk-&gt;shutdown
op_or_assign
id|SEND_SHUTDOWN
suffix:semicolon
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;dead
op_assign
l_int|1
suffix:semicolon
id|irda_destroy_socket
c_func
(paren
id|sk-&gt;protinfo.irda
)paren
suffix:semicolon
id|sock-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;socket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Not used, but we should do this. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_sendmsg (sock, msg, len, scm)&n; *&n; *    Send message down to TinyTP. This function is used for both STREAM and&n; *    SEQPACK services. This is possible since it forces the client to &n; *    fragment the message if necessary&n; */
DECL|function|irda_sendmsg
r_static
r_int
id|irda_sendmsg
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_struct
id|scm_cookie
op_star
id|scm
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_char
op_star
id|asmptr
suffix:semicolon
r_int
id|err
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), len=%d&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Note : socket.c set MSG_EOR on SEQPACKET sockets */
r_if
c_cond
(paren
id|msg-&gt;msg_flags
op_amp
op_complement
(paren
id|MSG_DONTWAIT
op_or
id|MSG_EOR
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
(brace
id|send_sig
c_func
(paren
id|SIGPIPE
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
id|self
op_assign
id|sk-&gt;protinfo.irda
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Check if IrTTP is wants us to slow down */
r_while
c_loop
(paren
id|self-&gt;tx_flow
op_eq
id|FLOW_STOP
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), IrTTP is busy, going to sleep!&bslash;n&quot;
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
multiline_comment|/* Check if we are still connected */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
)brace
multiline_comment|/* Check that we don&squot;t send out to big frames */
r_if
c_cond
(paren
id|len
OG
id|self-&gt;max_data_size
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), Chopping frame from %d to %d bytes!&bslash;n&quot;
comma
id|len
comma
id|self-&gt;max_data_size
)paren
suffix:semicolon
id|len
op_assign
id|self-&gt;max_data_size
suffix:semicolon
)brace
id|skb
op_assign
id|sock_alloc_send_skb
c_func
(paren
id|sk
comma
id|len
op_plus
id|self-&gt;max_header_size
comma
l_int|0
comma
id|msg-&gt;msg_flags
op_amp
id|MSG_DONTWAIT
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
op_minus
id|ENOBUFS
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
id|self-&gt;max_header_size
)paren
suffix:semicolon
id|asmptr
op_assign
id|skb-&gt;h.raw
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
id|memcpy_fromiovec
c_func
(paren
id|asmptr
comma
id|msg-&gt;msg_iov
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Just send the message to TinyTP, and let it deal with possible &n;&t; * errors. No need to duplicate all that here&n;&t; */
id|err
op_assign
id|irttp_data_request
c_func
(paren
id|self-&gt;tsap
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), err=%d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Tell client how much data we actually sent */
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_recvmsg_dgram (sock, msg, size, flags, scm)&n; *&n; *    Try to receive message and copy it to user. The frame is discarded&n; *    after being read, regardless of how much the user actually read&n; */
DECL|function|irda_recvmsg_dgram
r_static
r_int
id|irda_recvmsg_dgram
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|size
comma
r_int
id|flags
comma
r_struct
id|scm_cookie
op_star
id|scm
)paren
(brace
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|copied
comma
id|err
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
id|sk-&gt;protinfo.irda
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|skb
op_assign
id|skb_recv_datagram
c_func
(paren
id|sk
comma
id|flags
op_amp
op_complement
id|MSG_DONTWAIT
comma
id|flags
op_amp
id|MSG_DONTWAIT
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
id|err
suffix:semicolon
id|skb-&gt;h.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|copied
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|copied
OG
id|size
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), Received truncated frame (%d &lt; %d)!&bslash;n&quot;
comma
id|copied
comma
id|size
)paren
suffix:semicolon
id|copied
op_assign
id|size
suffix:semicolon
id|msg-&gt;msg_flags
op_or_assign
id|MSG_TRUNC
suffix:semicolon
)brace
id|skb_copy_datagram_iovec
c_func
(paren
id|skb
comma
l_int|0
comma
id|msg-&gt;msg_iov
comma
id|copied
)paren
suffix:semicolon
id|skb_free_datagram
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Check if we have previously stopped IrTTP and we know&n;&t; *  have more free space in our rx_queue. If so tell IrTTP&n;&t; *  to start delivering frames again before our rx_queue gets&n;&t; *  empty&n;&t; */
r_if
c_cond
(paren
id|self-&gt;rx_flow
op_eq
id|FLOW_STOP
)paren
(brace
r_if
c_cond
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
op_lshift
l_int|2
)paren
op_le
id|sk-&gt;rcvbuf
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), Starting IrTTP&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;rx_flow
op_assign
id|FLOW_START
suffix:semicolon
id|irttp_flow_request
c_func
(paren
id|self-&gt;tsap
comma
id|FLOW_START
)paren
suffix:semicolon
)brace
)brace
r_return
id|copied
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_data_wait (sk)&n; *&n; *    Sleep until data has arrive. But check for races..&n; *&n; */
DECL|function|irda_data_wait
r_static
r_void
id|irda_data_wait
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|SOCK_ASYNC_WAITDATA
comma
op_amp
id|sk-&gt;socket-&gt;flags
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|SOCK_ASYNC_WAITDATA
comma
op_amp
id|sk-&gt;socket-&gt;flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irda_recvmsg_stream (sock, msg, size, flags, scm)&n; *&n; *    &n; *&n; */
DECL|function|irda_recvmsg_stream
r_static
r_int
id|irda_recvmsg_stream
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|size
comma
r_int
id|flags
comma
r_struct
id|scm_cookie
op_star
id|scm
)paren
(brace
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_int
id|noblock
op_assign
id|flags
op_amp
id|MSG_DONTWAIT
suffix:semicolon
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
r_int
id|target
op_assign
l_int|1
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
id|sk-&gt;protinfo.irda
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sock-&gt;flags
op_amp
id|__SO_ACCEPTCON
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_OOB
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_WAITALL
)paren
id|target
op_assign
id|size
suffix:semicolon
id|msg-&gt;msg_namelen
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_int
id|chunk
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|copied
op_ge
id|target
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;POSIX 1003.1g mandates this order.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;err
)paren
(brace
r_return
id|sock_error
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|noblock
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|irda_data_wait
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|chunk
op_assign
id|min
c_func
(paren
id|skb-&gt;len
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcpy_toiovec
c_func
(paren
id|msg-&gt;msg_iov
comma
id|skb-&gt;data
comma
id|chunk
)paren
)paren
(brace
id|skb_queue_head
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
op_eq
l_int|0
)paren
id|copied
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|copied
op_add_assign
id|chunk
suffix:semicolon
id|size
op_sub_assign
id|chunk
suffix:semicolon
multiline_comment|/* Mark read part of skb as used */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
)paren
(brace
id|skb_pull
c_func
(paren
id|skb
comma
id|chunk
)paren
suffix:semicolon
multiline_comment|/* put the skb back if we didn&squot;t use it up.. */
r_if
c_cond
(paren
id|skb-&gt;len
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), back on q!&bslash;n&quot;
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;() questionable!?&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* put message back and return */
id|skb_queue_head
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Check if we have previously stopped IrTTP and we know&n;&t; *  have more free space in our rx_queue. If so tell IrTTP&n;&t; *  to start delivering frames again before our rx_queue gets&n;&t; *  empty&n;&t; */
r_if
c_cond
(paren
id|self-&gt;rx_flow
op_eq
id|FLOW_STOP
)paren
(brace
r_if
c_cond
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
op_lshift
l_int|2
)paren
op_le
id|sk-&gt;rcvbuf
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), Starting IrTTP&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;rx_flow
op_assign
id|FLOW_START
suffix:semicolon
id|irttp_flow_request
c_func
(paren
id|self-&gt;tsap
comma
id|FLOW_START
)paren
suffix:semicolon
)brace
)brace
r_return
id|copied
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_sendmsg_dgram (sock, msg, len, scm)&n; *&n; *    Send message down to TinyTP for the unreliable sequenced&n; *    packet service...&n; *&n; */
DECL|function|irda_sendmsg_dgram
r_static
r_int
id|irda_sendmsg_dgram
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_struct
id|scm_cookie
op_star
id|scm
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_char
op_star
id|asmptr
suffix:semicolon
r_int
id|err
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), len=%d&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;msg_flags
op_amp
op_complement
id|MSG_DONTWAIT
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
(brace
id|send_sig
c_func
(paren
id|SIGPIPE
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
id|self
op_assign
id|sk-&gt;protinfo.irda
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*  &n;&t; * Check that we don&squot;t send out to big frames. This is an unreliable &n;&t; * service, so we have no fragmentation and no coalescence &n;&t; */
r_if
c_cond
(paren
id|len
OG
id|self-&gt;max_data_size
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Warning to much data! &quot;
l_string|&quot;Chopping frame from %d to %d bytes!&bslash;n&quot;
comma
id|len
comma
id|self-&gt;max_data_size
)paren
suffix:semicolon
id|len
op_assign
id|self-&gt;max_data_size
suffix:semicolon
)brace
id|skb
op_assign
id|sock_alloc_send_skb
c_func
(paren
id|sk
comma
id|len
op_plus
id|self-&gt;max_header_size
comma
l_int|0
comma
id|msg-&gt;msg_flags
op_amp
id|MSG_DONTWAIT
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
op_minus
id|ENOBUFS
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
id|self-&gt;max_header_size
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), appending user data&bslash;n&quot;
)paren
suffix:semicolon
id|asmptr
op_assign
id|skb-&gt;h.raw
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
id|memcpy_fromiovec
c_func
(paren
id|asmptr
comma
id|msg-&gt;msg_iov
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Just send the message to TinyTP, and let it deal with possible &n;&t; * errors. No need to duplicate all that here&n;&t; */
id|err
op_assign
id|irttp_udata_request
c_func
(paren
id|self-&gt;tsap
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), err=%d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_sendmsg_ultra (sock, msg, len, scm)&n; *&n; *    Send message down to IrLMP for the unreliable Ultra&n; *    packet service...&n; */
macro_line|#ifdef CONFIG_IRDA_ULTRA
DECL|function|irda_sendmsg_ultra
r_static
r_int
id|irda_sendmsg_ultra
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_struct
id|scm_cookie
op_star
id|scm
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_char
op_star
id|asmptr
suffix:semicolon
r_int
id|err
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), len=%d&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;msg_flags
op_amp
op_complement
id|MSG_DONTWAIT
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
(brace
id|send_sig
c_func
(paren
id|SIGPIPE
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
id|self
op_assign
id|sk-&gt;protinfo.irda
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*  &n;&t; * Check that we don&squot;t send out to big frames. This is an unreliable &n;&t; * service, so we have no fragmentation and no coalescence &n;&t; */
r_if
c_cond
(paren
id|len
OG
id|self-&gt;max_data_size
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Warning to much data! &quot;
l_string|&quot;Chopping frame from %d to %d bytes!&bslash;n&quot;
comma
id|len
comma
id|self-&gt;max_data_size
)paren
suffix:semicolon
id|len
op_assign
id|self-&gt;max_data_size
suffix:semicolon
)brace
id|skb
op_assign
id|sock_alloc_send_skb
c_func
(paren
id|sk
comma
id|len
op_plus
id|self-&gt;max_header_size
comma
l_int|0
comma
id|msg-&gt;msg_flags
op_amp
id|MSG_DONTWAIT
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
op_minus
id|ENOBUFS
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
id|self-&gt;max_header_size
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), appending user data&bslash;n&quot;
)paren
suffix:semicolon
id|asmptr
op_assign
id|skb-&gt;h.raw
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
id|memcpy_fromiovec
c_func
(paren
id|asmptr
comma
id|msg-&gt;msg_iov
comma
id|len
)paren
suffix:semicolon
id|err
op_assign
id|irlmp_connless_data_request
c_func
(paren
id|self-&gt;lsap
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), err=%d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IRDA_ULTRA */
multiline_comment|/*&n; * Function irda_shutdown (sk, how)&n; *&n; *    &n; *&n; */
DECL|function|irda_shutdown
r_static
r_int
id|irda_shutdown
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|how
)paren
(brace
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|self
op_assign
id|sk-&gt;protinfo.irda
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|sk-&gt;shutdown
op_or_assign
id|SEND_SHUTDOWN
suffix:semicolon
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;iriap
)paren
(brace
id|iriap_close
c_func
(paren
id|self-&gt;iriap
)paren
suffix:semicolon
id|self-&gt;iriap
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|self-&gt;tsap
)paren
(brace
id|irttp_disconnect_request
c_func
(paren
id|self-&gt;tsap
comma
l_int|NULL
comma
id|P_NORMAL
)paren
suffix:semicolon
id|irttp_close_tsap
c_func
(paren
id|self-&gt;tsap
)paren
suffix:semicolon
id|self-&gt;tsap
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* A few cleanup so the socket look as good as new... */
id|self-&gt;rx_flow
op_assign
id|self-&gt;tx_flow
op_assign
id|FLOW_START
suffix:semicolon
multiline_comment|/* needed ??? */
id|self-&gt;daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
multiline_comment|/* Until we get re-connected */
id|self-&gt;saddr
op_assign
l_int|0x0
suffix:semicolon
multiline_comment|/* so IrLMP assign us any link */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_poll (file, sock, wait)&n; *&n; *    &n; *&n; */
DECL|function|irda_poll
r_static
r_int
r_int
id|irda_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|socket
op_star
id|sock
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
id|sk-&gt;sleep
comma
id|wait
)paren
suffix:semicolon
id|mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* exceptional events? */
r_if
c_cond
(paren
id|sk-&gt;err
)paren
id|mask
op_or_assign
id|POLLERR
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
multiline_comment|/* readable? */
r_if
c_cond
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Socket is readable&bslash;n&quot;
)paren
suffix:semicolon
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
multiline_comment|/* Connection-based need to check for termination and startup */
r_if
c_cond
(paren
id|sk-&gt;type
op_eq
id|SOCK_STREAM
op_logical_and
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
multiline_comment|/*&n;&t; * we set writable also when the other side has shut down the&n;&t; * connection. This prevents stuck sockets.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;sndbuf
op_minus
(paren
r_int
)paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
op_ge
id|SOCK_MIN_WRITE_SPACE
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
op_or
id|POLLWRBAND
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_ioctl (sock, cmd, arg)&n; *&n; *    &n; *&n; */
DECL|function|irda_ioctl
r_static
r_int
id|irda_ioctl
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), cmd=%#x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCOUTQ
suffix:colon
(brace
r_int
id|amount
suffix:semicolon
id|amount
op_assign
id|sk-&gt;sndbuf
op_minus
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amount
OL
l_int|0
)paren
id|amount
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|amount
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|TIOCINQ
suffix:colon
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|amount
op_assign
l_int|0L
suffix:semicolon
multiline_comment|/* These two are safe on a single CPU system as only user tasks fiddle here */
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_ne
l_int|NULL
)paren
id|amount
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|amount
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|SIOCGSTAMP
suffix:colon
r_if
c_cond
(paren
id|sk
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;stamp.tv_sec
op_eq
l_int|0
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|sk-&gt;stamp
comma
r_sizeof
(paren
r_struct
id|timeval
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|SIOCGIFADDR
suffix:colon
r_case
id|SIOCSIFADDR
suffix:colon
r_case
id|SIOCGIFDSTADDR
suffix:colon
r_case
id|SIOCSIFDSTADDR
suffix:colon
r_case
id|SIOCGIFBRDADDR
suffix:colon
r_case
id|SIOCSIFBRDADDR
suffix:colon
r_case
id|SIOCGIFNETMASK
suffix:colon
r_case
id|SIOCSIFNETMASK
suffix:colon
r_case
id|SIOCGIFMETRIC
suffix:colon
r_case
id|SIOCSIFMETRIC
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), doing device ioctl!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|dev_ioctl
c_func
(paren
id|cmd
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
multiline_comment|/*NOTREACHED*/
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_setsockopt (sock, level, optname, optval, optlen)&n; *&n; *    Set some options for the socket&n; *&n; */
DECL|function|irda_setsockopt
r_static
r_int
id|irda_setsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
r_struct
id|irda_ias_set
id|ias_opt
suffix:semicolon
r_struct
id|ias_object
op_star
id|ias_obj
suffix:semicolon
r_struct
id|ias_attrib
op_star
id|ias_attr
suffix:semicolon
multiline_comment|/* Attribute in IAS object */
r_int
id|opt
suffix:semicolon
id|self
op_assign
id|sk-&gt;protinfo.irda
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_ne
id|SOL_IRLMP
)paren
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|IRLMP_IAS_SET
suffix:colon
multiline_comment|/* The user want to add an attribute to an existing IAS object&n;&t;&t; * (in the IAS database) or to create a new object with this&n;&t;&t; * attribute.&n;&t;&t; * We first query IAS to know if the object exist, and then&n;&t;&t; * create the right attribute...&n;&t;&t; */
r_if
c_cond
(paren
id|optlen
op_ne
r_sizeof
(paren
r_struct
id|irda_ias_set
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Copy query to the driver. */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ias_opt
comma
(paren
r_char
op_star
)paren
id|optval
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Find the object we target */
id|ias_obj
op_assign
id|irias_find_object
c_func
(paren
id|ias_opt.irda_class_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ias_obj
op_eq
(paren
r_struct
id|ias_object
op_star
)paren
l_int|NULL
)paren
(brace
multiline_comment|/* Create a new object */
id|ias_obj
op_assign
id|irias_new_object
c_func
(paren
id|ias_opt.irda_class_name
comma
id|jiffies
)paren
suffix:semicolon
)brace
multiline_comment|/* Do we have it already ? */
r_if
c_cond
(paren
id|irias_find_attrib
c_func
(paren
id|ias_obj
comma
id|ias_opt.irda_attrib_name
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Look at the type */
r_switch
c_cond
(paren
id|ias_opt.irda_attrib_type
)paren
(brace
r_case
id|IAS_INTEGER
suffix:colon
multiline_comment|/* Add an integer attribute */
id|irias_add_integer_attrib
c_func
(paren
id|ias_obj
comma
id|ias_opt.irda_attrib_name
comma
id|ias_opt.attribute.irda_attrib_int
comma
id|IAS_USER_ATTR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IAS_OCT_SEQ
suffix:colon
multiline_comment|/* Check length */
r_if
c_cond
(paren
id|ias_opt.attribute.irda_attrib_octet_seq.len
OG
id|IAS_MAX_OCTET_STRING
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Add an octet sequence attribute */
id|irias_add_octseq_attrib
c_func
(paren
id|ias_obj
comma
id|ias_opt.irda_attrib_name
comma
id|ias_opt.attribute.irda_attrib_octet_seq.octet_seq
comma
id|ias_opt.attribute.irda_attrib_octet_seq.len
comma
id|IAS_USER_ATTR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IAS_STRING
suffix:colon
multiline_comment|/* Should check charset &amp; co */
multiline_comment|/* Check length */
r_if
c_cond
(paren
id|ias_opt.attribute.irda_attrib_string.len
OG
id|IAS_MAX_STRING
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* NULL terminate the string (avoid troubles) */
id|ias_opt.attribute.irda_attrib_string.string
(braket
id|ias_opt.attribute.irda_attrib_string.len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* Add a string attribute */
id|irias_add_string_attrib
c_func
(paren
id|ias_obj
comma
id|ias_opt.irda_attrib_name
comma
id|ias_opt.attribute.irda_attrib_string.string
comma
id|IAS_USER_ATTR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|irias_insert_object
c_func
(paren
id|ias_obj
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRLMP_IAS_DEL
suffix:colon
multiline_comment|/* The user want to delete an object from our local IAS&n;&t;&t; * database. We just need to query the IAS, check is the&n;&t;&t; * object is not owned by the kernel and delete it.&n;&t;&t; */
r_if
c_cond
(paren
id|optlen
op_ne
r_sizeof
(paren
r_struct
id|irda_ias_set
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Copy query to the driver. */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ias_opt
comma
(paren
r_char
op_star
)paren
id|optval
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Find the object we target */
id|ias_obj
op_assign
id|irias_find_object
c_func
(paren
id|ias_opt.irda_class_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ias_obj
op_eq
(paren
r_struct
id|ias_object
op_star
)paren
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Find the attribute (in the object) we target */
id|ias_attr
op_assign
id|irias_find_attrib
c_func
(paren
id|ias_obj
comma
id|ias_opt.irda_attrib_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ias_attr
op_eq
(paren
r_struct
id|ias_attrib
op_star
)paren
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Check is the user space own the object */
r_if
c_cond
(paren
id|ias_attr-&gt;value-&gt;owner
op_ne
id|IAS_USER_ATTR
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), attempting to delete a kernel attribute&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
multiline_comment|/* Remove the attribute (and maybe the object) */
id|irias_delete_attrib
c_func
(paren
id|ias_obj
comma
id|ias_attr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRLMP_MAX_SDU_SIZE
suffix:colon
r_if
c_cond
(paren
id|optlen
OL
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|opt
comma
(paren
r_int
op_star
)paren
id|optval
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Only possible for a seqpacket service (TTP with SAR) */
r_if
c_cond
(paren
id|sk-&gt;type
op_ne
id|SOCK_SEQPACKET
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), setting max_sdu_size = %d&bslash;n&quot;
comma
id|opt
)paren
suffix:semicolon
id|self-&gt;max_sdu_size_rx
op_assign
id|opt
suffix:semicolon
)brace
r_else
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), not allowed to set MAXSDUSIZE for this &quot;
l_string|&quot;socket type!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IRLMP_HINTS_SET
suffix:colon
r_if
c_cond
(paren
id|optlen
OL
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|opt
comma
(paren
r_int
op_star
)paren
id|optval
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Unregister any old registration */
r_if
c_cond
(paren
id|self-&gt;skey
)paren
id|irlmp_unregister_service
c_func
(paren
id|self-&gt;skey
)paren
suffix:semicolon
id|self-&gt;skey
op_assign
id|irlmp_register_service
c_func
(paren
(paren
id|__u16
)paren
id|opt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRLMP_HINT_MASK_SET
suffix:colon
multiline_comment|/* As opposed to the previous case which set the hint bits&n;&t;&t; * that we advertise, this one set the filter we use when&n;&t;&t; * making a discovery (nodes which don&squot;t match any hint&n;&t;&t; * bit in the mask are not reported).&n;&t;&t; */
r_if
c_cond
(paren
id|optlen
OL
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|opt
comma
(paren
r_int
op_star
)paren
id|optval
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Set the new hint mask */
id|self-&gt;mask
op_assign
(paren
id|__u16
)paren
id|opt
suffix:semicolon
multiline_comment|/* Mask out extension bits */
id|self-&gt;mask
op_and_assign
l_int|0x7f7f
suffix:semicolon
multiline_comment|/* Check if no bits */
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;mask
)paren
(brace
id|self-&gt;mask
op_assign
l_int|0xFFFF
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_extract_ias_value(ias_opt, ias_value)&n; *&n; *    Translate internal IAS value structure to the user space representation&n; *&n; * The external representation of IAS values, as we exchange them with&n; * user space program is quite different from the internal representation,&n; * as stored in the IAS database (because we need a flat structure for&n; * crossing kernel boundary).&n; * This function transform the former in the latter. We also check&n; * that the value type is valid.&n; */
DECL|function|irda_extract_ias_value
r_static
r_int
id|irda_extract_ias_value
c_func
(paren
r_struct
id|irda_ias_set
op_star
id|ias_opt
comma
r_struct
id|ias_value
op_star
id|ias_value
)paren
(brace
multiline_comment|/* Look at the type */
r_switch
c_cond
(paren
id|ias_value-&gt;type
)paren
(brace
r_case
id|IAS_INTEGER
suffix:colon
multiline_comment|/* Copy the integer */
id|ias_opt-&gt;attribute.irda_attrib_int
op_assign
id|ias_value-&gt;t.integer
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IAS_OCT_SEQ
suffix:colon
multiline_comment|/* Set length */
id|ias_opt-&gt;attribute.irda_attrib_octet_seq.len
op_assign
id|ias_value-&gt;len
suffix:semicolon
multiline_comment|/* Copy over */
id|memcpy
c_func
(paren
id|ias_opt-&gt;attribute.irda_attrib_octet_seq.octet_seq
comma
id|ias_value-&gt;t.oct_seq
comma
id|ias_value-&gt;len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IAS_STRING
suffix:colon
multiline_comment|/* Set length */
id|ias_opt-&gt;attribute.irda_attrib_string.len
op_assign
id|ias_value-&gt;len
suffix:semicolon
id|ias_opt-&gt;attribute.irda_attrib_string.charset
op_assign
id|ias_value-&gt;charset
suffix:semicolon
multiline_comment|/* Copy over */
id|memcpy
c_func
(paren
id|ias_opt-&gt;attribute.irda_attrib_string.string
comma
id|ias_value-&gt;t.string
comma
id|ias_value-&gt;len
)paren
suffix:semicolon
multiline_comment|/* NULL terminate the string (avoid troubles) */
id|ias_opt-&gt;attribute.irda_attrib_string.string
(braket
id|ias_value-&gt;len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IAS_MISSING
suffix:colon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Copy type over */
id|ias_opt-&gt;irda_attrib_type
op_assign
id|ias_value-&gt;type
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_getsockopt (sock, level, optname, optval, optlen)&n; *&n; *    &n; *&n; */
DECL|function|irda_getsockopt
r_static
r_int
id|irda_getsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_struct
id|irda_sock
op_star
id|self
suffix:semicolon
r_struct
id|irda_device_list
id|list
suffix:semicolon
r_struct
id|irda_device_info
op_star
id|discoveries
suffix:semicolon
r_struct
id|irda_ias_set
id|ias_opt
suffix:semicolon
multiline_comment|/* IAS get/query params */
r_struct
id|ias_object
op_star
id|ias_obj
suffix:semicolon
multiline_comment|/* Object in IAS */
r_struct
id|ias_attrib
op_star
id|ias_attr
suffix:semicolon
multiline_comment|/* Attribute in IAS object */
r_int
id|daddr
op_assign
id|DEV_ADDR_ANY
suffix:semicolon
multiline_comment|/* Dest address for IAS queries */
r_int
id|val
op_assign
l_int|0
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|offset
comma
id|total
suffix:semicolon
id|self
op_assign
id|sk-&gt;protinfo.irda
suffix:semicolon
r_if
c_cond
(paren
id|level
op_ne
id|SOL_IRLMP
)paren
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|IRLMP_ENUMDEVICES
suffix:colon
multiline_comment|/* Ask lmp for the current discovery log */
id|discoveries
op_assign
id|irlmp_get_discoveries
c_func
(paren
op_amp
id|list.len
comma
id|self-&gt;mask
)paren
suffix:semicolon
multiline_comment|/* Check if the we got some results */
r_if
c_cond
(paren
id|discoveries
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/* Didn&squot;t find any devices */
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Write total list length back to client */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|list
comma
r_sizeof
(paren
r_struct
id|irda_device_list
)paren
op_minus
r_sizeof
(paren
r_struct
id|irda_device_info
)paren
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Offset to first device entry */
id|offset
op_assign
r_sizeof
(paren
r_struct
id|irda_device_list
)paren
op_minus
r_sizeof
(paren
r_struct
id|irda_device_info
)paren
suffix:semicolon
multiline_comment|/* Copy the list itself */
id|total
op_assign
id|offset
op_plus
(paren
id|list.len
op_star
r_sizeof
(paren
r_struct
id|irda_device_info
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|total
OG
id|len
)paren
id|total
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
op_plus
id|offset
comma
id|discoveries
comma
id|total
op_minus
id|offset
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Write total number of bytes used back to client */
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|total
comma
id|optlen
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Free up our buffer */
id|kfree
c_func
(paren
id|discoveries
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRLMP_MAX_SDU_SIZE
suffix:colon
id|val
op_assign
id|self-&gt;max_data_size
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
r_int
)paren
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|len
comma
id|optlen
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|optval
comma
op_amp
id|val
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRLMP_IAS_GET
suffix:colon
multiline_comment|/* The user want an object from our local IAS database.&n;&t;&t; * We just need to query the IAS and return the value&n;&t;&t; * that we found */
multiline_comment|/* Check that the user has allocated the right space for us */
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|ias_opt
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Copy query to the driver. */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|ias_opt
comma
(paren
r_char
op_star
)paren
id|optval
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Find the object we target */
id|ias_obj
op_assign
id|irias_find_object
c_func
(paren
id|ias_opt.irda_class_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ias_obj
op_eq
(paren
r_struct
id|ias_object
op_star
)paren
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Find the attribute (in the object) we target */
id|ias_attr
op_assign
id|irias_find_attrib
c_func
(paren
id|ias_obj
comma
id|ias_opt.irda_attrib_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ias_attr
op_eq
(paren
r_struct
id|ias_attrib
op_star
)paren
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Translate from internal to user structure */
id|err
op_assign
id|irda_extract_ias_value
c_func
(paren
op_amp
id|ias_opt
comma
id|ias_attr-&gt;value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Copy reply to the user */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|optval
comma
(paren
r_char
op_star
)paren
op_amp
id|ias_opt
comma
r_sizeof
(paren
id|ias_opt
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Note : don&squot;t need to put optlen, we checked it */
r_break
suffix:semicolon
r_case
id|IRLMP_IAS_QUERY
suffix:colon
multiline_comment|/* The user want an object from a remote IAS database.&n;&t;&t; * We need to use IAP to query the remote database and&n;&t;&t; * then wait for the answer to come back. */
multiline_comment|/* Check that the user has allocated the right space for us */
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
id|ias_opt
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Copy query to the driver. */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|ias_opt
comma
(paren
r_char
op_star
)paren
id|optval
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* At this point, there are two cases...&n;&t;&t; * 1) the socket is connected - that&squot;s the easy case, we&n;&t;&t; *&t;just query the device we are connected to...&n;&t;&t; * 2) the socket is not connected - the user doesn&squot;t want&n;&t;&t; *&t;to connect and/or may not have a valid service name&n;&t;&t; *&t;(so can&squot;t create a fake connection). In this case,&n;&t;&t; *&t;we assume that the user pass us a valid destination&n;&t;&t; *&t;address in the requesting structure...&n;&t;&t; */
r_if
c_cond
(paren
id|self-&gt;daddr
op_ne
id|DEV_ADDR_ANY
)paren
(brace
multiline_comment|/* We are connected - reuse known daddr */
id|daddr
op_assign
id|self-&gt;daddr
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We are not connected, we must specify a valid&n;&t;&t;&t; * destination address */
id|daddr
op_assign
id|ias_opt.daddr
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|daddr
)paren
op_logical_or
(paren
id|daddr
op_eq
id|DEV_ADDR_ANY
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/* Check that we can proceed with IAP */
r_if
c_cond
(paren
id|self-&gt;iriap
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), busy with a previous query&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|self-&gt;iriap
op_assign
id|iriap_open
c_func
(paren
id|LSAP_ANY
comma
id|IAS_CLIENT
comma
id|self
comma
id|irda_getvalue_confirm
)paren
suffix:semicolon
multiline_comment|/* Treat unexpected signals as disconnect */
id|self-&gt;errno
op_assign
op_minus
id|EHOSTUNREACH
suffix:semicolon
multiline_comment|/* Query remote LM-IAS */
id|iriap_getvaluebyclass_request
c_func
(paren
id|self-&gt;iriap
comma
id|self-&gt;saddr
comma
id|daddr
comma
id|ias_opt.irda_class_name
comma
id|ias_opt.irda_attrib_name
)paren
suffix:semicolon
multiline_comment|/* Wait for answer (if not already failed) */
r_if
c_cond
(paren
id|self-&gt;iriap
op_ne
l_int|NULL
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|self-&gt;query_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* Check what happened */
r_if
c_cond
(paren
id|self-&gt;errno
)paren
(brace
multiline_comment|/* Requested object/attribute doesn&squot;t exist */
r_if
c_cond
(paren
(paren
id|self-&gt;errno
op_eq
id|IAS_CLASS_UNKNOWN
)paren
op_logical_or
(paren
id|self-&gt;errno
op_eq
id|IAS_ATTRIB_UNKNOWN
)paren
)paren
(brace
r_return
(paren
op_minus
id|EADDRNOTAVAIL
)paren
suffix:semicolon
)brace
r_else
r_return
(paren
op_minus
id|EHOSTUNREACH
)paren
suffix:semicolon
)brace
multiline_comment|/* Translate from internal to user structure */
id|err
op_assign
id|irda_extract_ias_value
c_func
(paren
op_amp
id|ias_opt
comma
id|self-&gt;ias_result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;ias_result
)paren
id|irias_delete_value
c_func
(paren
id|self-&gt;ias_result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* Copy reply to the user */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|optval
comma
(paren
r_char
op_star
)paren
op_amp
id|ias_opt
comma
r_sizeof
(paren
id|ias_opt
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Note : don&squot;t need to put optlen, we checked it */
r_break
suffix:semicolon
r_case
id|IRLMP_WAITDEVICE
suffix:colon
multiline_comment|/* This function is just another way of seeing life ;-)&n;&t;&t; * IRLMP_ENUMDEVICES assumes that you have a static network,&n;&t;&t; * and that you just want to pick one of the devices present.&n;&t;&t; * On the other hand, in here we assume that no device is&n;&t;&t; * present and that at some point in the future a device will&n;&t;&t; * come into range. When this device arrive, we just wake&n;&t;&t; * up the caller, so that he has time to connect to it before&n;&t;&t; * the device goes away...&n;&t;&t; * Note : once the node has been discovered for more than a&n;&t;&t; * few second, it won&squot;t trigger this function, unless it&n;&t;&t; * goes away and come back changes its hint bits (so we&n;&t;&t; * might call it IRLMP_WAITNEWDEVICE).&n;&t;&t; */
multiline_comment|/* Check that the user is passing us an int */
r_if
c_cond
(paren
id|len
op_ne
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Get timeout in ms (max time we block the caller) */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|optval
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Tell IrLMP we want to be notified */
id|irlmp_update_client
c_func
(paren
id|self-&gt;ckey
comma
id|self-&gt;mask
comma
id|irda_selective_discovery_indication
comma
l_int|NULL
comma
(paren
r_void
op_star
)paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Do some discovery (and also return cached results) */
id|irlmp_discovery_request
c_func
(paren
id|self-&gt;nslots
)paren
suffix:semicolon
multiline_comment|/* Wait until a node is discovered */
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;cachediscovery
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), nothing discovered yet, going to sleep...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Set watchdog timer to expire in &lt;val&gt; ms. */
id|self-&gt;watchdog.function
op_assign
id|irda_discovery_timeout
suffix:semicolon
id|self-&gt;watchdog.data
op_assign
(paren
r_int
r_int
)paren
id|self
suffix:semicolon
id|self-&gt;watchdog.expires
op_assign
id|jiffies
op_plus
(paren
id|val
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
(paren
id|self-&gt;watchdog
)paren
)paren
suffix:semicolon
multiline_comment|/* Wait for IR-LMP to call us back */
id|interruptible_sleep_on
c_func
(paren
op_amp
id|self-&gt;query_wait
)paren
suffix:semicolon
multiline_comment|/* If watchdog is still activated, kill it! */
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
(paren
id|self-&gt;watchdog
)paren
)paren
)paren
(brace
id|del_timer
c_func
(paren
op_amp
(paren
id|self-&gt;watchdog
)paren
)paren
suffix:semicolon
)brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), ...waking up !&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), found immediately !&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Tell IrLMP that we have been notified */
id|irlmp_update_client
c_func
(paren
id|self-&gt;ckey
comma
id|self-&gt;mask
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Check if the we got some results */
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;cachediscovery
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/* Didn&squot;t find any devices */
multiline_comment|/* Cleanup */
id|self-&gt;cachediscovery
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Note : We don&squot;t return anything to the user.&n;&t;&t; * We could return the device that triggered the wake up,&n;&t;&t; * but it&squot;s probably better to force the user to query&n;&t;&t; * the whole discovery log and let him pick one device...&n;&t;&t; */
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|irda_family_ops
r_static
r_struct
id|net_proto_family
id|irda_family_ops
op_assign
(brace
id|PF_IRDA
comma
id|irda_create
)brace
suffix:semicolon
DECL|variable|irda_stream_ops
r_static
r_struct
id|proto_ops
id|SOCKOPS_WRAPPED
c_func
(paren
id|irda_stream_ops
)paren
op_assign
(brace
id|family
suffix:colon
id|PF_IRDA
comma
id|release
suffix:colon
id|irda_release
comma
id|bind
suffix:colon
id|irda_bind
comma
id|connect
suffix:colon
id|irda_connect
comma
id|socketpair
suffix:colon
id|sock_no_socketpair
comma
id|accept
suffix:colon
id|irda_accept
comma
id|getname
suffix:colon
id|irda_getname
comma
id|poll
suffix:colon
id|irda_poll
comma
id|ioctl
suffix:colon
id|irda_ioctl
comma
id|listen
suffix:colon
id|irda_listen
comma
id|shutdown
suffix:colon
id|irda_shutdown
comma
id|setsockopt
suffix:colon
id|irda_setsockopt
comma
id|getsockopt
suffix:colon
id|irda_getsockopt
comma
id|sendmsg
suffix:colon
id|irda_sendmsg
comma
id|recvmsg
suffix:colon
id|irda_recvmsg_stream
comma
id|mmap
suffix:colon
id|sock_no_mmap
comma
)brace
suffix:semicolon
DECL|variable|irda_seqpacket_ops
r_static
r_struct
id|proto_ops
id|SOCKOPS_WRAPPED
c_func
(paren
id|irda_seqpacket_ops
)paren
op_assign
(brace
id|family
suffix:colon
id|PF_IRDA
comma
id|release
suffix:colon
id|irda_release
comma
id|bind
suffix:colon
id|irda_bind
comma
id|connect
suffix:colon
id|irda_connect
comma
id|socketpair
suffix:colon
id|sock_no_socketpair
comma
id|accept
suffix:colon
id|irda_accept
comma
id|getname
suffix:colon
id|irda_getname
comma
id|poll
suffix:colon
id|datagram_poll
comma
id|ioctl
suffix:colon
id|irda_ioctl
comma
id|listen
suffix:colon
id|irda_listen
comma
id|shutdown
suffix:colon
id|irda_shutdown
comma
id|setsockopt
suffix:colon
id|irda_setsockopt
comma
id|getsockopt
suffix:colon
id|irda_getsockopt
comma
id|sendmsg
suffix:colon
id|irda_sendmsg
comma
id|recvmsg
suffix:colon
id|irda_recvmsg_dgram
comma
id|mmap
suffix:colon
id|sock_no_mmap
comma
)brace
suffix:semicolon
DECL|variable|irda_dgram_ops
r_static
r_struct
id|proto_ops
id|SOCKOPS_WRAPPED
c_func
(paren
id|irda_dgram_ops
)paren
op_assign
(brace
id|family
suffix:colon
id|PF_IRDA
comma
id|release
suffix:colon
id|irda_release
comma
id|bind
suffix:colon
id|irda_bind
comma
id|connect
suffix:colon
id|irda_connect
comma
id|socketpair
suffix:colon
id|sock_no_socketpair
comma
id|accept
suffix:colon
id|irda_accept
comma
id|getname
suffix:colon
id|irda_getname
comma
id|poll
suffix:colon
id|datagram_poll
comma
id|ioctl
suffix:colon
id|irda_ioctl
comma
id|listen
suffix:colon
id|irda_listen
comma
id|shutdown
suffix:colon
id|irda_shutdown
comma
id|setsockopt
suffix:colon
id|irda_setsockopt
comma
id|getsockopt
suffix:colon
id|irda_getsockopt
comma
id|sendmsg
suffix:colon
id|irda_sendmsg_dgram
comma
id|recvmsg
suffix:colon
id|irda_recvmsg_dgram
comma
id|mmap
suffix:colon
id|sock_no_mmap
comma
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_ULTRA
DECL|variable|irda_ultra_ops
r_static
r_struct
id|proto_ops
id|SOCKOPS_WRAPPED
c_func
(paren
id|irda_ultra_ops
)paren
op_assign
(brace
id|family
suffix:colon
id|PF_IRDA
comma
id|release
suffix:colon
id|irda_release
comma
id|bind
suffix:colon
id|irda_bind
comma
id|connect
suffix:colon
id|sock_no_connect
comma
id|socketpair
suffix:colon
id|sock_no_socketpair
comma
id|accept
suffix:colon
id|sock_no_accept
comma
id|getname
suffix:colon
id|irda_getname
comma
id|poll
suffix:colon
id|datagram_poll
comma
id|ioctl
suffix:colon
id|irda_ioctl
comma
id|listen
suffix:colon
id|sock_no_listen
comma
id|shutdown
suffix:colon
id|irda_shutdown
comma
id|setsockopt
suffix:colon
id|irda_setsockopt
comma
id|getsockopt
suffix:colon
id|irda_getsockopt
comma
id|sendmsg
suffix:colon
id|irda_sendmsg_ultra
comma
id|recvmsg
suffix:colon
id|irda_recvmsg_dgram
comma
id|mmap
suffix:colon
id|sock_no_mmap
comma
)brace
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_ULTRA */
macro_line|#include &lt;linux/smp_lock.h&gt;
id|SOCKOPS_WRAP
c_func
(paren
id|irda_stream
comma
id|PF_IRDA
)paren
suffix:semicolon
id|SOCKOPS_WRAP
c_func
(paren
id|irda_seqpacket
comma
id|PF_IRDA
)paren
suffix:semicolon
id|SOCKOPS_WRAP
c_func
(paren
id|irda_dgram
comma
id|PF_IRDA
)paren
suffix:semicolon
multiline_comment|/*&n; * Function irda_device_event (this, event, ptr)&n; *&n; *    Called when a device is taken up or down&n; *&n; */
DECL|function|irda_device_event
r_static
r_int
id|irda_device_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|event
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|ptr
suffix:semicolon
multiline_comment|/* Reject non IrDA devices */
r_if
c_cond
(paren
id|dev-&gt;type
op_ne
id|ARPHRD_IRDA
)paren
r_return
id|NOTIFY_DONE
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|NETDEV_UP
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;(), NETDEV_UP&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* irda_dev_device_up(dev); */
r_break
suffix:semicolon
r_case
id|NETDEV_DOWN
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;(), NETDEV_DOWN&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* irda_kill_by_device(dev); */
multiline_comment|/* irda_rt_device_down(dev); */
multiline_comment|/* irda_dev_device_down(dev); */
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|variable|irda_packet_type
r_static
r_struct
id|packet_type
id|irda_packet_type
op_assign
(brace
l_int|0
comma
multiline_comment|/* MUTTER ntohs(ETH_P_IRDA),*/
l_int|NULL
comma
id|irlap_driver_rcv
comma
l_int|NULL
comma
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|irda_dev_notifier
r_static
r_struct
id|notifier_block
id|irda_dev_notifier
op_assign
(brace
id|irda_device_event
comma
l_int|NULL
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * Function irda_proc_modcount (inode, fill)&n; *&n; *    Use by the proc file system functions to prevent the irda module&n; *    being removed while the use is standing in the net/irda directory&n; */
DECL|function|irda_proc_modcount
r_void
id|irda_proc_modcount
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|fill
)paren
(brace
macro_line|#ifdef MODULE
macro_line|#ifdef CONFIG_PROC_FS
r_if
c_cond
(paren
id|fill
)paren
id|MOD_INC_USE_COUNT
suffix:semicolon
r_else
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
macro_line|#endif /* MODULE */
)brace
multiline_comment|/*&n; * Function irda_proto_init (pro)&n; *&n; *    Initialize IrDA protocol layer&n; *&n; */
DECL|function|irda_proto_init
r_int
id|__init
id|irda_proto_init
c_func
(paren
r_void
)paren
(brace
id|sock_register
c_func
(paren
op_amp
id|irda_family_ops
)paren
suffix:semicolon
id|irda_packet_type.type
op_assign
id|htons
c_func
(paren
id|ETH_P_IRDA
)paren
suffix:semicolon
id|dev_add_pack
c_func
(paren
op_amp
id|irda_packet_type
)paren
suffix:semicolon
id|register_netdevice_notifier
c_func
(paren
op_amp
id|irda_dev_notifier
)paren
suffix:semicolon
id|irda_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef MODULE
id|irda_device_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Called by init/main.c when non-modular */
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_proto_cleanup (void)&n; *&n; *    Remove IrDA protocol layer&n; *&n; */
macro_line|#ifdef MODULE
DECL|function|irda_proto_cleanup
r_void
id|irda_proto_cleanup
c_func
(paren
r_void
)paren
(brace
id|irda_packet_type.type
op_assign
id|htons
c_func
(paren
id|ETH_P_IRDA
)paren
suffix:semicolon
id|dev_remove_pack
c_func
(paren
op_amp
id|irda_packet_type
)paren
suffix:semicolon
id|unregister_netdevice_notifier
c_func
(paren
op_amp
id|irda_dev_notifier
)paren
suffix:semicolon
id|sock_unregister
c_func
(paren
id|PF_IRDA
)paren
suffix:semicolon
id|irda_cleanup
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|variable|irda_proto_init
id|module_init
c_func
(paren
id|irda_proto_init
)paren
suffix:semicolon
DECL|variable|irda_proto_cleanup
id|module_exit
c_func
(paren
id|irda_proto_cleanup
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Dag Brattli &lt;dagb@cs.uit.no&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;The Linux IrDA Protocol Subsystem&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irda_debug
comma
l_string|&quot;1l&quot;
)paren
suffix:semicolon
macro_line|#endif /* MODULE */
eof
