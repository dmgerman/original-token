multiline_comment|/*********************************************************************&n; *                &n; * Filename:      irlap_event.c&n; * Version:       0.9&n; * Description:   IrLAP state machine implementation&n; * Status:        Experimental.&n; * Author:        Dag Brattli &lt;dag@brattli.net&gt;&n; * Created at:    Sat Aug 16 00:59:29 1997&n; * Modified at:   Sat Dec 25 21:07:57 1999&n; * Modified by:   Dag Brattli &lt;dag@brattli.net&gt;&n; * &n; *     Copyright (c) 1998-2000 Dag Brattli &lt;dag@brattli.net&gt;,&n; *     Copyright (c) 1998      Thomas Davis &lt;ratbert@radiks.net&gt;&n; *     All Rights Reserved.&n; *     &n; *     This program is free software; you can redistribute it and/or &n; *     modify it under the terms of the GNU General Public License as &n; *     published by the Free Software Foundation; either version 2 of &n; *     the License, or (at your option) any later version.&n; *&n; *     Neither Dag Brattli nor University of Troms&#xfffd; admit liability nor&n; *     provide warranty for any of this software. This material is &n; *     provided &quot;AS-IS&quot; and at no charge.&n; *&n; ********************************************************************/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/irlap_event.h&gt;
macro_line|#include &lt;net/irda/timer.h&gt;
macro_line|#include &lt;net/irda/irlap.h&gt;
macro_line|#include &lt;net/irda/irlap_frame.h&gt;
macro_line|#include &lt;net/irda/qos.h&gt;
macro_line|#include &lt;net/irda/parameters.h&gt;
macro_line|#include &lt;net/irda/irda_device.h&gt;
macro_line|#if CONFIG_IRDA_FAST_RR
DECL|variable|sysctl_fast_poll_increase
r_int
id|sysctl_fast_poll_increase
op_assign
l_int|50
suffix:semicolon
macro_line|#endif
r_static
r_int
id|irlap_state_ndm
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_query
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_reply
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_conn
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_setup
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_offline
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_xmit_p
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_pclose
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_nrm_p
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_reset_wait
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_reset
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_nrm_s
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_xmit_s
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_sclose
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_reset_check
c_func
(paren
r_struct
id|irlap_cb
op_star
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
comma
r_struct
id|irlap_info
op_star
)paren
suffix:semicolon
DECL|variable|irlap_event
r_static
r_const
r_char
op_star
id|irlap_event
(braket
)braket
op_assign
(brace
l_string|&quot;DISCOVERY_REQUEST&quot;
comma
l_string|&quot;CONNECT_REQUEST&quot;
comma
l_string|&quot;CONNECT_RESPONSE&quot;
comma
l_string|&quot;DISCONNECT_REQUEST&quot;
comma
l_string|&quot;DATA_REQUEST&quot;
comma
l_string|&quot;RESET_REQUEST&quot;
comma
l_string|&quot;RESET_RESPONSE&quot;
comma
l_string|&quot;SEND_I_CMD&quot;
comma
l_string|&quot;SEND_UI_FRAME&quot;
comma
l_string|&quot;RECV_DISCOVERY_XID_CMD&quot;
comma
l_string|&quot;RECV_DISCOVERY_XID_RSP&quot;
comma
l_string|&quot;RECV_SNRM_CMD&quot;
comma
l_string|&quot;RECV_TEST_CMD&quot;
comma
l_string|&quot;RECV_TEST_RSP&quot;
comma
l_string|&quot;RECV_UA_RSP&quot;
comma
l_string|&quot;RECV_DM_RSP&quot;
comma
l_string|&quot;RECV_RD_RSP&quot;
comma
l_string|&quot;RECV_I_CMD&quot;
comma
l_string|&quot;RECV_I_RSP&quot;
comma
l_string|&quot;RECV_UI_FRAME&quot;
comma
l_string|&quot;RECV_FRMR_RSP&quot;
comma
l_string|&quot;RECV_RR_CMD&quot;
comma
l_string|&quot;RECV_RR_RSP&quot;
comma
l_string|&quot;RECV_RNR_CMD&quot;
comma
l_string|&quot;RECV_RNR_RSP&quot;
comma
l_string|&quot;RECV_REJ_CMD&quot;
comma
l_string|&quot;RECV_REJ_RSP&quot;
comma
l_string|&quot;RECV_SREJ_CMD&quot;
comma
l_string|&quot;RECV_SREJ_RSP&quot;
comma
l_string|&quot;RECV_DISC_CMD&quot;
comma
l_string|&quot;SLOT_TIMER_EXPIRED&quot;
comma
l_string|&quot;QUERY_TIMER_EXPIRED&quot;
comma
l_string|&quot;FINAL_TIMER_EXPIRED&quot;
comma
l_string|&quot;POLL_TIMER_EXPIRED&quot;
comma
l_string|&quot;DISCOVERY_TIMER_EXPIRED&quot;
comma
l_string|&quot;WD_TIMER_EXPIRED&quot;
comma
l_string|&quot;BACKOFF_TIMER_EXPIRED&quot;
comma
)brace
suffix:semicolon
DECL|variable|irlap_state
r_const
r_char
op_star
id|irlap_state
(braket
)braket
op_assign
(brace
l_string|&quot;LAP_NDM&quot;
comma
l_string|&quot;LAP_QUERY&quot;
comma
l_string|&quot;LAP_REPLY&quot;
comma
l_string|&quot;LAP_CONN&quot;
comma
l_string|&quot;LAP_SETUP&quot;
comma
l_string|&quot;LAP_OFFLINE&quot;
comma
l_string|&quot;LAP_XMIT_P&quot;
comma
l_string|&quot;LAP_PCLOSE&quot;
comma
l_string|&quot;LAP_NRM_P&quot;
comma
l_string|&quot;LAP_RESET_WAIT&quot;
comma
l_string|&quot;LAP_RESET&quot;
comma
l_string|&quot;LAP_NRM_S&quot;
comma
l_string|&quot;LAP_XMIT_S&quot;
comma
l_string|&quot;LAP_SCLOSE&quot;
comma
l_string|&quot;LAP_RESET_CHECK&quot;
comma
)brace
suffix:semicolon
DECL|variable|state
r_static
r_int
(paren
op_star
id|state
(braket
)braket
)paren
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
op_assign
(brace
id|irlap_state_ndm
comma
id|irlap_state_query
comma
id|irlap_state_reply
comma
id|irlap_state_conn
comma
id|irlap_state_setup
comma
id|irlap_state_offline
comma
id|irlap_state_xmit_p
comma
id|irlap_state_pclose
comma
id|irlap_state_nrm_p
comma
id|irlap_state_reset_wait
comma
id|irlap_state_reset
comma
id|irlap_state_nrm_s
comma
id|irlap_state_xmit_s
comma
id|irlap_state_sclose
comma
id|irlap_state_reset_check
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Function irda_poll_timer_expired (data)&n; *&n; *    Poll timer has expired. Normally we must now send a RR frame to the&n; *    remote device&n; */
DECL|function|irlap_poll_timer_expired
r_static
r_void
id|irlap_poll_timer_expired
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|irlap_cb
op_star
id|self
op_assign
(paren
r_struct
id|irlap_cb
op_star
)paren
id|data
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|irlap_do_event
c_func
(paren
id|self
comma
id|POLL_TIMER_EXPIRED
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|irlap_start_poll_timer
r_void
id|irlap_start_poll_timer
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
r_int
id|timeout
)paren
(brace
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_FAST_RR
multiline_comment|/* &n;&t; * Send out the RR frames faster if our own transmit queue is empty, or&n;&t; * if the peer is busy. The effect is a much faster conversation&n;&t; */
r_if
c_cond
(paren
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;txq
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|self-&gt;remote_busy
)paren
)paren
(brace
r_if
c_cond
(paren
id|self-&gt;fast_RR
op_eq
id|TRUE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  Assert that the fast poll timer has not reached the&n;&t;&t;&t; *  normal poll timer yet&n;&t;&t;&t; */
r_if
c_cond
(paren
id|self-&gt;fast_RR_timeout
OL
id|timeout
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *  FIXME: this should be a more configurable&n;&t;&t;&t;&t; *         function&n;&t;&t;&t;&t; */
id|self-&gt;fast_RR_timeout
op_add_assign
(paren
id|sysctl_fast_poll_increase
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* Use this fast(er) timeout instead */
id|timeout
op_assign
id|self-&gt;fast_RR_timeout
suffix:semicolon
)brace
)brace
r_else
(brace
id|self-&gt;fast_RR
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Start with just 0 ms */
id|self-&gt;fast_RR_timeout
op_assign
l_int|0
suffix:semicolon
id|timeout
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
id|self-&gt;fast_RR
op_assign
id|FALSE
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;(), timeout=%d (%ld)&bslash;n&quot;
comma
id|timeout
comma
id|jiffies
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_FAST_RR */
r_if
c_cond
(paren
id|timeout
op_eq
l_int|0
)paren
id|irlap_do_event
c_func
(paren
id|self
comma
id|POLL_TIMER_EXPIRED
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_else
id|irda_start_timer
c_func
(paren
op_amp
id|self-&gt;poll_timer
comma
id|timeout
comma
id|self
comma
id|irlap_poll_timer_expired
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_do_event (event, skb, info)&n; *&n; *    Rushes through the state machine without any delay. If state == XMIT&n; *    then send queued data frames. &n; */
DECL|function|irlap_do_event
r_void
id|irlap_do_event
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self
op_logical_or
id|self-&gt;magic
op_ne
id|LAP_MAGIC
)paren
r_return
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;(), event = %s, state = %s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
comma
id|irlap_state
(braket
id|self-&gt;state
)braket
)paren
suffix:semicolon
id|ret
op_assign
(paren
op_star
id|state
(braket
id|self-&gt;state
)braket
)paren
(paren
id|self
comma
id|event
comma
id|skb
comma
id|info
)paren
suffix:semicolon
multiline_comment|/* &n;&t; *  Check if there are any pending events that needs to be executed&n;&t; */
r_switch
c_cond
(paren
id|self-&gt;state
)paren
(brace
r_case
id|LAP_XMIT_P
suffix:colon
multiline_comment|/* FALLTHROUGH */
r_case
id|LAP_XMIT_S
suffix:colon
multiline_comment|/* &n;&t;&t; * Check if there are any queued data frames, and do not&n;&t;&t; * try to disconnect link if we send any data frames, since&n;&t;&t; * that will change the state away form XMIT&n;&t;&t; */
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;txq
)paren
)paren
(brace
multiline_comment|/* Try to send away all queued data frames */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;txq
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|ret
op_assign
(paren
op_star
id|state
(braket
id|self-&gt;state
)braket
)paren
(paren
id|self
comma
id|SEND_I_CMD
comma
id|skb
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EPROTO
)paren
r_break
suffix:semicolon
multiline_comment|/* Try again later! */
)brace
)brace
r_else
r_if
c_cond
(paren
id|self-&gt;disconnect_pending
)paren
(brace
id|self-&gt;disconnect_pending
op_assign
id|FALSE
suffix:semicolon
id|ret
op_assign
(paren
op_star
id|state
(braket
id|self-&gt;state
)braket
)paren
(paren
id|self
comma
id|DISCONNECT_REQUEST
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|LAP_NDM
suffix:colon
multiline_comment|/* Check if we should try to connect */
r_if
c_cond
(paren
(paren
id|self-&gt;connect_pending
)paren
op_logical_and
op_logical_neg
id|self-&gt;media_busy
)paren
(brace
id|self-&gt;connect_pending
op_assign
id|FALSE
suffix:semicolon
id|ret
op_assign
(paren
op_star
id|state
(braket
id|self-&gt;state
)braket
)paren
(paren
id|self
comma
id|CONNECT_REQUEST
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* &t;case LAP_CONN: */
multiline_comment|/* &t;case LAP_RESET_WAIT: */
multiline_comment|/* &t;case LAP_RESET_CHECK: */
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlap_next_state (self, state)&n; *&n; *    Switches state and provides debug information&n; *&n; */
DECL|function|irlap_next_state
r_void
id|irlap_next_state
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_STATE
id|state
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|self
op_logical_or
id|self-&gt;magic
op_ne
id|LAP_MAGIC
)paren
r_return
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;next LAP state = %s&bslash;n&quot;
comma
id|irlap_state
(braket
id|state
)braket
)paren
suffix:semicolon
id|self-&gt;state
op_assign
id|state
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_DYNAMIC_WINDOW
multiline_comment|/*&n;&t; *  If we are swithing away from a XMIT state then we are allowed to &n;&t; *  transmit a maximum number of bytes again when we enter the XMIT &n;&t; *  state again. Since its possible to &quot;switch&quot; from XMIT to XMIT,&n;&t; *  we cannot do this when swithing into the XMIT state :-)&n;&t; */
r_if
c_cond
(paren
(paren
id|state
op_ne
id|LAP_XMIT_P
)paren
op_logical_and
(paren
id|state
op_ne
id|LAP_XMIT_S
)paren
)paren
id|self-&gt;bytes_left
op_assign
id|self-&gt;line_capacity
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_DYNAMIC_WINDOW */
macro_line|#ifdef CONFIG_IRDA_ULTRA
multiline_comment|/* Send any pending Ultra frames if any */
multiline_comment|/* The higher layers may have sent a few Ultra frames while we&n;&t; * were doing discovery (either query or reply). Those frames&n;&t; * have been queued, but were never sent. It is now time to&n;&t; * send them...&n;&t; * Jean II */
r_if
c_cond
(paren
(paren
id|state
op_eq
id|LAP_NDM
)paren
op_logical_and
(paren
op_logical_neg
id|skb_queue_empty
c_func
(paren
op_amp
id|self-&gt;txq_ultra
)paren
)paren
)paren
multiline_comment|/* Force us to listen 500 ms before sending Ultra */
id|irda_device_set_media_busy
c_func
(paren
id|self-&gt;netdev
comma
id|TRUE
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_ULTRA */
)brace
multiline_comment|/*&n; * Function irlap_state_ndm (event, skb, frame)&n; *&n; *    NDM (Normal Disconnected Mode) state&n; *&n; */
DECL|function|irlap_state_ndm
r_static
r_int
id|irlap_state_ndm
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
id|discovery_t
op_star
id|discovery_rsp
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|CONNECT_REQUEST
suffix:colon
id|ASSERT
c_func
(paren
id|self-&gt;netdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;media_busy
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), CONNECT_REQUEST: media busy!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_MEDIA_BUSY
)paren
suffix:semicolon
)brace
r_else
(brace
id|irlap_send_snrm_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
multiline_comment|/* Start Final-bit timer */
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_SETUP
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_SNRM_CMD
suffix:colon
multiline_comment|/* Check if the frame contains and I field */
r_if
c_cond
(paren
id|info
)paren
(brace
id|self-&gt;daddr
op_assign
id|info-&gt;daddr
suffix:semicolon
id|self-&gt;caddr
op_assign
id|info-&gt;caddr
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_CONN
)paren
suffix:semicolon
id|irlap_connect_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), SNRM frame does not &quot;
l_string|&quot;contain an I field!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DISCOVERY_REQUEST
suffix:colon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;media_busy
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), media busy!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* irlap-&gt;log.condition = MEDIA_BUSY; */
multiline_comment|/* This will make IrLMP try again */
id|irlap_discovery_confirm
c_func
(paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|self-&gt;S
op_assign
id|info-&gt;S
suffix:semicolon
id|self-&gt;s
op_assign
id|info-&gt;s
suffix:semicolon
id|irlap_send_discovery_xid_frame
c_func
(paren
id|self
comma
id|info-&gt;S
comma
id|info-&gt;s
comma
id|TRUE
comma
id|info-&gt;discovery
)paren
suffix:semicolon
id|self-&gt;frame_sent
op_assign
id|FALSE
suffix:semicolon
id|self-&gt;s
op_increment
suffix:semicolon
id|irlap_start_slot_timer
c_func
(paren
id|self
comma
id|self-&gt;slot_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_QUERY
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_DISCOVERY_XID_CMD
suffix:colon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Assert that this is not the final slot */
r_if
c_cond
(paren
id|info-&gt;s
op_le
id|info-&gt;S
)paren
(brace
id|self-&gt;slot
op_assign
id|irlap_generate_rand_time_slot
c_func
(paren
id|info-&gt;S
comma
id|info-&gt;s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;slot
op_eq
id|info-&gt;s
)paren
(brace
id|discovery_rsp
op_assign
id|irlmp_get_discovery_response
c_func
(paren
)paren
suffix:semicolon
id|discovery_rsp-&gt;daddr
op_assign
id|info-&gt;daddr
suffix:semicolon
id|irlap_send_discovery_xid_frame
c_func
(paren
id|self
comma
id|info-&gt;S
comma
id|self-&gt;slot
comma
id|FALSE
comma
id|discovery_rsp
)paren
suffix:semicolon
id|self-&gt;frame_sent
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
id|self-&gt;frame_sent
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; * Remember to multiply the query timeout value with &n;&t;&t;&t; * the number of slots used&n;&t;&t;&t; */
id|irlap_start_query_timer
c_func
(paren
id|self
comma
id|QUERY_TIMEOUT
op_star
id|info-&gt;S
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_REPLY
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This is the final slot. How is it possible ?&n;&t;&t; * This would happen is both discoveries are just slightly&n;&t;&t; * offset (if they are in sync, all packets are lost).&n;&t;&t; * Most often, all the discovery requests will be received&n;&t;&t; * in QUERY state (see my comment there), except for the&n;&t;&t; * last frame that will come here.&n;&t;&t; * The big trouble when it happen is that active discovery&n;&t;&t; * doesn&squot;t happen, because nobody answer the discoveries&n;&t;&t; * frame of the other guy, so the log shows up empty.&n;&t;&t; * What should we do ?&n;&t;&t; * Not much. It&squot;s too late to answer those discovery frames,&n;&t;&t; * so we just pass the info to IrLMP who will put it in the&n;&t;&t; * log (and post an event).&n;&t;&t; * Jean II&n;&t;&t; */
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Receiving final discovery request, missed the discovery slots :-(&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Last discovery request -&gt; in the log */
id|irlap_discovery_indication
c_func
(paren
id|self
comma
id|info-&gt;discovery
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_ULTRA
r_case
id|SEND_UI_FRAME
suffix:colon
multiline_comment|/* Only allowed to repeat an operation twice */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
(paren
id|i
OL
l_int|2
)paren
op_logical_and
(paren
id|self-&gt;media_busy
op_eq
id|FALSE
)paren
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;txq_ultra
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|irlap_send_ui_frame
c_func
(paren
id|self
comma
id|skb
comma
id|CBROADCAST
comma
id|CMD_FRAME
)paren
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|2
)paren
(brace
multiline_comment|/* Force us to listen 500 ms again */
id|irda_device_set_media_busy
c_func
(paren
id|self-&gt;netdev
comma
id|TRUE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_UI_FRAME
suffix:colon
multiline_comment|/* Only accept broadcast frames in NDM mode */
r_if
c_cond
(paren
id|info-&gt;caddr
op_ne
id|CBROADCAST
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), not a broadcast frame!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|irlap_unitdata_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_ULTRA */
r_case
id|RECV_TEST_CMD
suffix:colon
multiline_comment|/* Remove test frame header */
id|skb_pull
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|test_frame
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Send response. This skb will not be sent out again, and&n;&t;&t; * will only be used to send out the same info as the cmd&n;&t;&t; */
id|irlap_send_test_frame
c_func
(paren
id|self
comma
id|CBROADCAST
comma
id|info-&gt;daddr
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_TEST_RSP
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;() not implemented!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_query (event, skb, info)&n; *&n; *    QUERY state&n; *&n; */
DECL|function|irlap_state_query
r_static
r_int
id|irlap_state_query
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RECV_DISCOVERY_XID_RSP
suffix:colon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|info-&gt;discovery
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), daddr=%08x&bslash;n&quot;
comma
id|info-&gt;discovery-&gt;daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;discovery_log
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), discovery log is gone! &quot;
l_string|&quot;maybe the discovery timeout has been set to &quot;
l_string|&quot;short?&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hashbin_insert
c_func
(paren
id|self-&gt;discovery_log
comma
(paren
id|irda_queue_t
op_star
)paren
id|info-&gt;discovery
comma
id|info-&gt;discovery-&gt;daddr
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Keep state */
multiline_comment|/* irlap_next_state(self, LAP_QUERY);  */
r_break
suffix:semicolon
r_case
id|RECV_DISCOVERY_XID_CMD
suffix:colon
multiline_comment|/* Yes, it is possible to receive those frames in this mode.&n;&t;&t; * Note that most often the last discovery request won&squot;t&n;&t;&t; * occur here but in NDM state (see my comment there).&n;&t;&t; * What should we do ?&n;&t;&t; * Not much. We are currently performing our own discovery,&n;&t;&t; * therefore we can&squot;t answer those frames. We don&squot;t want&n;&t;&t; * to change state either. We just pass the info to&n;&t;&t; * IrLMP who will put it in the log (and post an event).&n;&t;&t; * Jean II&n;&t;&t; */
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Receiving discovery request (s = %d) while performing discovery :-(&bslash;n&quot;
comma
id|info-&gt;s
)paren
suffix:semicolon
multiline_comment|/* Last discovery request ? */
r_if
c_cond
(paren
id|info-&gt;s
op_eq
l_int|0xff
)paren
id|irlap_discovery_indication
c_func
(paren
id|self
comma
id|info-&gt;discovery
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SLOT_TIMER_EXPIRED
suffix:colon
multiline_comment|/*&n;&t;&t; * Wait a little longer if we detect an incomming frame. This&n;&t;&t; * is not mentioned in the spec, but is a good thing to do, &n;&t;&t; * since we want to work even with devices that violate the&n;&t;&t; * timing requirements.&n;&t;&t; */
r_if
c_cond
(paren
id|irda_device_is_receiving
c_func
(paren
id|self-&gt;netdev
)paren
op_logical_and
op_logical_neg
id|self-&gt;add_wait
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), device is slow to answer, &quot;
l_string|&quot;waiting some more!&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_start_slot_timer
c_func
(paren
id|self
comma
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|10
)paren
)paren
suffix:semicolon
id|self-&gt;add_wait
op_assign
id|TRUE
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|self-&gt;add_wait
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;s
OL
id|self-&gt;S
)paren
(brace
id|irlap_send_discovery_xid_frame
c_func
(paren
id|self
comma
id|self-&gt;S
comma
id|self-&gt;s
comma
id|TRUE
comma
id|self-&gt;discovery_cmd
)paren
suffix:semicolon
id|self-&gt;s
op_increment
suffix:semicolon
id|irlap_start_slot_timer
c_func
(paren
id|self
comma
id|self-&gt;slot_timeout
)paren
suffix:semicolon
multiline_comment|/* Keep state */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_QUERY
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This is the final slot! */
id|irlap_send_discovery_xid_frame
c_func
(paren
id|self
comma
id|self-&gt;S
comma
l_int|0xff
comma
id|TRUE
comma
id|self-&gt;discovery_cmd
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  We are now finished with the discovery procedure, &n;&t;&t;&t; *  so now we must return the results&n;&t;&t;&t; */
id|irlap_discovery_confirm
c_func
(paren
id|self
comma
id|self-&gt;discovery_log
)paren
suffix:semicolon
multiline_comment|/* IrLMP should now have taken care of the log */
id|self-&gt;discovery_log
op_assign
l_int|NULL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_reply (self, event, skb, info)&n; *&n; *    REPLY, we have received a XID discovery frame from a device and we&n; *    are waiting for the right time slot to send a response XID frame&n; * &n; */
DECL|function|irlap_state_reply
r_static
r_int
id|irlap_state_reply
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
id|discovery_t
op_star
id|discovery_rsp
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|QUERY_TIMER_EXPIRED
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), QUERY_TIMER_EXPIRED &lt;%ld&gt;&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_DISCOVERY_XID_CMD
suffix:colon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Last frame? */
r_if
c_cond
(paren
id|info-&gt;s
op_eq
l_int|0xff
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;query_timer
)paren
suffix:semicolon
multiline_comment|/* info-&gt;log.condition = REMOTE; */
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_discovery_indication
c_func
(paren
id|self
comma
id|info-&gt;discovery
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|info-&gt;s
op_ge
id|self-&gt;slot
)paren
op_logical_and
(paren
op_logical_neg
id|self-&gt;frame_sent
)paren
)paren
(brace
id|discovery_rsp
op_assign
id|irlmp_get_discovery_response
c_func
(paren
)paren
suffix:semicolon
id|discovery_rsp-&gt;daddr
op_assign
id|info-&gt;daddr
suffix:semicolon
id|irlap_send_discovery_xid_frame
c_func
(paren
id|self
comma
id|info-&gt;S
comma
id|self-&gt;slot
comma
id|FALSE
comma
id|discovery_rsp
)paren
suffix:semicolon
id|self-&gt;frame_sent
op_assign
id|TRUE
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_REPLY
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %d, %s&bslash;n&quot;
comma
id|event
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_conn (event, skb, info)&n; *&n; *    CONN, we have received a SNRM command and is waiting for the upper&n; *    layer to accept or refuse connection &n; *&n; */
DECL|function|irlap_state_conn
r_static
r_int
id|irlap_state_conn
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), event=%s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|CONNECT_RESPONSE
suffix:colon
id|skb_pull
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|snrm_frame
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;netdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|irlap_qos_negotiate
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_initiate_connection_state
c_func
(paren
id|self
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* &n;&t;&t; * We are allowed to send two frames, but this may increase&n;&t;&t; * the connect latency, so lets not do it for now.&n;&t;&t; */
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t;&t; * Applying the parameters now will make sure we change speed&n;&t;&t; * after we have sent the next frame&n;&t;&t; */
id|irlap_apply_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Sending this frame will force a speed change after it has&n;&t;&t; * been sent&n;&t;&t; */
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  The WD-timer could be set to the duration of the P-timer &n;&t;&t; *  for this case, but it is recommended to use twice the &n;&t;&t; *  value (note 3 IrLAP p. 60). &n;&t;&t; */
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_DISCOVERY_XID_CMD
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;(), event RECV_DISCOVER_XID_CMD!&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DISCONNECT_REQUEST
suffix:colon
id|irlap_send_dm_frame
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_CONN
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %d, %s&bslash;n&quot;
comma
id|event
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_setup (event, skb, frame)&n; *&n; *    SETUP state, The local layer has transmitted a SNRM command frame to&n; *    a remote peer layer and is awaiting a reply .&n; *&n; */
DECL|function|irlap_state_setup
r_static
r_int
id|irlap_state_setup
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|FINAL_TIMER_EXPIRED
suffix:colon
r_if
c_cond
(paren
id|self-&gt;retry_count
OL
id|self-&gt;N3
)paren
(brace
multiline_comment|/* &n; *  Perform random backoff, Wait a random number of time units, minimum &n; *  duration half the time taken to transmitt a SNRM frame, maximum duration &n; *  1.5 times the time taken to transmit a SNRM frame. So this time should &n; *  between 15 msecs and 45 msecs.&n; */
id|irlap_start_backoff_timer
c_func
(paren
id|self
comma
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|20
op_plus
(paren
id|jiffies
op_mod
l_int|30
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_FOUND_NONE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BACKOFF_TIMER_EXPIRED
suffix:colon
id|irlap_send_snrm_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_SNRM_CMD
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), SNRM battle!&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  The device with the largest device address wins the battle&n;&t;&t; *  (both have sent a SNRM command!)&n;&t;&t; */
r_if
c_cond
(paren
id|info
op_logical_and
(paren
id|info-&gt;daddr
OG
id|self-&gt;saddr
)paren
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_initiate_connection_state
c_func
(paren
id|self
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;netdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|snrm_frame
)paren
)paren
suffix:semicolon
id|irlap_qos_negotiate
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
id|irlap_apply_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
id|irlap_connect_confirm
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; *  The WD-timer could be set to the duration of the&n;&t;&t;&t; *  P-timer for this case, but it is recommended&n;&t;&t;&t; *  to use twice the value (note 3 IrLAP p. 60).  &n;&t;&t;&t; */
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We just ignore the other device! */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_SETUP
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_UA_RSP
suffix:colon
multiline_comment|/* Stop F-timer */
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
multiline_comment|/* Initiate connection state */
id|irlap_initiate_connection_state
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Negotiate connection parameters */
id|ASSERT
c_func
(paren
id|skb-&gt;len
OG
l_int|10
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
r_sizeof
(paren
r_struct
id|ua_frame
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;netdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|irlap_qos_negotiate
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_apply_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This frame will actually force the speed change */
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
op_div
l_int|2
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
id|irlap_connect_confirm
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_DM_RSP
suffix:colon
multiline_comment|/* FALLTHROUGH */
r_case
id|RECV_DISC_CMD
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %d, %s&bslash;n&quot;
comma
id|event
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_offline (self, event, skb, info)&n; *&n; *    OFFLINE state, not used for now!&n; *&n; */
DECL|function|irlap_state_offline
r_static
r_int
id|irlap_state_offline
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_xmit_p (self, event, skb, info)&n; * &n; *    XMIT, Only the primary station has right to transmit, and we&n; *    therefore do not expect to receive any transmissions from other&n; *    stations.&n; * &n; */
DECL|function|irlap_state_xmit_p
r_static
r_int
id|irlap_state_xmit_p
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|SEND_I_CMD
suffix:colon
multiline_comment|/*&n;&t;&t; *  Only send frame if send-window &gt; 0.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|self-&gt;window
OG
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|self-&gt;remote_busy
)paren
)paren
(brace
macro_line|#ifdef CONFIG_IRDA_DYNAMIC_WINDOW
multiline_comment|/*&n;&t;&t;&t; *  Test if we have transmitted more bytes over the &n;&t;&t;&t; *  link than its possible to do with the current &n;&t;&t;&t; *  speed and turn-around-time.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|self-&gt;bytes_left
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), Not allowed to transmit more &quot;
l_string|&quot;bytes!&bslash;n&quot;
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|self-&gt;txq
comma
id|skb_get
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *  We should switch state to LAP_NRM_P, but&n;&t;&t;&t;&t; *  that is not possible since we must be sure&n;&t;&t;&t;&t; *  that we poll the other side. Since we have&n;&t;&t;&t;&t; *  used up our time, the poll timer should&n;&t;&t;&t;&t; *  trigger anyway now, so we just wait for it&n;&t;&t;&t;&t; *  DB&n;&t;&t;&t;&t; */
r_return
op_minus
id|EPROTO
suffix:semicolon
)brace
id|self-&gt;bytes_left
op_sub_assign
id|skb-&gt;len
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_DYNAMIC_WINDOW */
multiline_comment|/*&n;&t;&t;&t; *  Send data with poll bit cleared only if window &gt; 1&n;&t;&t;&t; *  and there is more frames after this one to be sent&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|self-&gt;window
OG
l_int|1
)paren
op_logical_and
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;txq
)paren
OG
l_int|0
)paren
(brace
id|irlap_send_data_primary
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_P
)paren
suffix:semicolon
)brace
r_else
(brace
id|irlap_send_data_primary_poll
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Make sure state machine does not try to send&n;&t;&t;&t;&t; * any more frames &n;&t;&t;&t;&t; */
id|ret
op_assign
op_minus
id|EPROTO
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IRDA_FAST_RR
multiline_comment|/* Peer may want to reply immediately */
id|self-&gt;fast_RR
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_FAST_RR */
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), Unable to send! remote busy?&bslash;n&quot;
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|self-&gt;txq
comma
id|skb_get
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  The next ret is important, because it tells &n;&t;&t;&t; *  irlap_next_state _not_ to deliver more frames&n;&t;&t;&t; */
id|ret
op_assign
op_minus
id|EPROTO
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|POLL_TIMER_EXPIRED
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;(), POLL_TIMER_EXPIRED (%ld)&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DISCONNECT_REQUEST
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;poll_timer
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_disc_frame
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_PCLOSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_pclose (event, skb, info)&n; *&n; *    PCLOSE state&n; */
DECL|function|irlap_state_pclose
r_static
r_int
id|irlap_state_pclose
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RECV_UA_RSP
suffix:colon
multiline_comment|/* FALLTHROUGH */
r_case
id|RECV_DM_RSP
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FINAL_TIMER_EXPIRED
suffix:colon
r_if
c_cond
(paren
id|self-&gt;retry_count
OL
id|self-&gt;N3
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_disc_frame
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
multiline_comment|/* Keep state */
)brace
r_else
(brace
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/*  Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_NO_RESPONSE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %d&bslash;n&quot;
comma
id|event
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_nrm_p (self, event, skb, info)&n; *&n; *   NRM_P (Normal Response Mode as Primary), The primary station has given&n; *   permissions to a secondary station to transmit IrLAP resonse frames&n; *   (by sending a frame with the P bit set). The primary station will not&n; *   transmit any frames and is expecting to receive frames only from the&n; *   secondary to which transmission permissions has been given.&n; */
DECL|function|irlap_state_nrm_p
r_static
r_int
id|irlap_state_nrm_p
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|ns_status
suffix:semicolon
r_int
id|nr_status
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RECV_I_RSP
suffix:colon
multiline_comment|/* Optimize for the common case */
multiline_comment|/* FIXME: must check for remote_busy below */
macro_line|#ifdef CONFIG_IRDA_FAST_RR
multiline_comment|/* &n;&t;&t; *  Reset the fast_RR so we can use the fast RR code with&n;&t;&t; *  full speed the next time since peer may have more frames&n;&t;&t; *  to transmitt&n;&t;&t; */
id|self-&gt;fast_RR
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_FAST_RR */
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ns_status
op_assign
id|irlap_validate_ns_received
c_func
(paren
id|self
comma
id|info-&gt;ns
)paren
suffix:semicolon
id|nr_status
op_assign
id|irlap_validate_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; *  Check for expected I(nformation) frame&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_EXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_EXPECTED
)paren
)paren
(brace
multiline_comment|/*  poll bit cleared?  */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Keep state, do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|FALSE
)paren
suffix:semicolon
)brace
r_else
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/*  &n;&t;&t;&t;&t; *  Got expected NR, so reset the&n;&t;&t;&t;&t; *  retry_count. This is not done by IrLAP,&n;&t;&t;&t;&t; *  which is strange!  &n;&t;&t;&t;&t; */
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|TRUE
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Important to switch state before calling&n;&t;&t;&t;&t; * upper layers&n;&t;&t;&t;&t; */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_P
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|FALSE
)paren
suffix:semicolon
multiline_comment|/* This is the last frame */
id|irlap_start_poll_timer
c_func
(paren
id|self
comma
id|self-&gt;poll_timeout
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Unexpected next to send (Ns) */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_UNEXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_EXPECTED
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *  Wait until the last frame before doing &n;&t;&t;&t;&t; *  anything&n;&t;&t;&t;&t; */
multiline_comment|/* Keep state */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), missing or duplicate frame!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|FALSE
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; *  Unexpected next to receive (Nr) &n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_EXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_UNEXPECTED
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pf
)paren
(brace
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/* Resend rejected frames */
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|FALSE
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
multiline_comment|/* Keep state, do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|FALSE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &n;&t;&t;&t;&t; *  Do not resend frames until the last&n;&t;&t;&t;&t; *  frame has arrived from the other&n;&t;&t;&t;&t; *  device. This is not documented in&n;&t;&t;&t;&t; *  IrLAP!!  &n;&t;&t;&t;&t; */
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Keep state, do not move this line!*/
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|FALSE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Unexpected next to send (Ns) and next to receive (Nr)&n;&t;&t; *  Not documented by IrLAP!&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_UNEXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_UNEXPECTED
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), unexpected nr and ns!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pf
)paren
(brace
multiline_comment|/* Resend rejected frames */
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
multiline_comment|/* Give peer some time to retransmit! */
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
multiline_comment|/* Keep state, do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Update Nr received */
multiline_comment|/* irlap_update_nr_received( info-&gt;nr); */
id|self-&gt;ack_required
op_assign
id|FALSE
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Invalid NR or NS&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|nr_status
op_eq
id|NR_INVALID
)paren
op_logical_or
(paren
id|ns_status
op_eq
id|NS_INVALID
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pf
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET_WAIT
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_RESET_INDICATION
)paren
suffix:semicolon
id|self-&gt;xmitflag
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_RESET_INDICATION
)paren
suffix:semicolon
id|self-&gt;xmitflag
op_assign
id|FALSE
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Not implemented!&bslash;n&quot;
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), event=%s, ns_status=%d, nr_status=%d&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
comma
id|ns_status
comma
id|nr_status
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_UI_FRAME
suffix:colon
multiline_comment|/* Poll bit cleared? */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|TRUE
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
)brace
r_else
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|TRUE
)paren
suffix:semicolon
id|printk
c_func
(paren
id|__FUNCTION__
l_string|&quot;(): RECV_UI_FRAME: next state %s&bslash;n&quot;
comma
id|irlap_state
(braket
id|self-&gt;state
)braket
)paren
suffix:semicolon
id|irlap_start_poll_timer
c_func
(paren
id|self
comma
id|self-&gt;poll_timeout
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_RR_RSP
suffix:colon
multiline_comment|/*  &n;&t;&t; *  If you get a RR, the remote isn&squot;t busy anymore, &n;&t;&t; *  no matter what the NR &n;&t;&t; */
id|self-&gt;remote_busy
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* &n;&t;&t; *  Nr as expected? &n;&t;&t; */
id|ret
op_assign
id|irlap_validate_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|NR_EXPECTED
)paren
(brace
multiline_comment|/* Stop final timer */
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Got expected NR, so reset the retry_count. This &n;&t;&t;&t; *  is not done by the IrLAP standard , which is &n;&t;&t;&t; *  strange! DB.&n;&t;&t;&t; */
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_P
)paren
suffix:semicolon
multiline_comment|/* Start poll timer */
id|irlap_start_poll_timer
c_func
(paren
id|self
comma
id|self-&gt;poll_timeout
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ret
op_eq
id|NR_UNEXPECTED
)paren
(brace
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; *  Unexpected nr! &n;&t;&t;&t; */
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;RECV_RR_FRAME: Retrans:%d, nr=%d, va=%d, &quot;
l_string|&quot;vs=%d, vr=%d&bslash;n&quot;
comma
id|self-&gt;retry_count
comma
id|info-&gt;nr
comma
id|self-&gt;va
comma
id|self-&gt;vs
comma
id|self-&gt;vr
)paren
suffix:semicolon
multiline_comment|/* Resend rejected frames */
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ret
op_eq
id|NR_INVALID
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Received RR with &quot;
l_string|&quot;invalid nr !&bslash;n&quot;
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET_WAIT
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_RESET_INDICATION
)paren
suffix:semicolon
id|self-&gt;xmitflag
op_assign
id|TRUE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_RNR_RSP
suffix:colon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Stop final timer */
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|self-&gt;remote_busy
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_P
)paren
suffix:semicolon
multiline_comment|/* Start poll timer */
id|irlap_start_poll_timer
c_func
(paren
id|self
comma
id|self-&gt;poll_timeout
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_FRMR_RSP
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|self-&gt;xmitflag
op_assign
id|TRUE
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET_WAIT
)paren
suffix:semicolon
id|irlap_reset_indication
c_func
(paren
id|self
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FINAL_TIMER_EXPIRED
suffix:colon
multiline_comment|/* &n;&t;&t; *  We are allowed to wait for additional 300 ms if&n;&t;&t; *  final timer expires when we are in the middle&n;&t;&t; *  of receiving a frame (page 45, IrLAP). Check that&n;&t;&t; *  we only do this once for each frame.&n;&t;&t; */
r_if
c_cond
(paren
id|irda_device_is_receiving
c_func
(paren
id|self-&gt;netdev
)paren
op_logical_and
op_logical_neg
id|self-&gt;add_wait
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;FINAL_TIMER_EXPIRED when receiving a &quot;
l_string|&quot;frame! Waiting a little bit more!&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|300
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Don&squot;t allow this to happen one more time in a row, &n;&t;&t;&t; *  or else we can get a pretty tight loop here if &n;&t;&t;&t; *  if we only receive half a frame. DB.&n;&t;&t;&t; */
id|self-&gt;add_wait
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|self-&gt;add_wait
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|self-&gt;retry_count
OL
id|self-&gt;N2
)paren
op_logical_and
(paren
id|self-&gt;retry_count
op_ne
id|self-&gt;N1
)paren
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irlap_state_nrm_p: FINAL_TIMER_EXPIRED:&quot;
l_string|&quot; retry_count=%d&bslash;n&quot;
comma
id|self-&gt;retry_count
)paren
suffix:semicolon
multiline_comment|/* Keep state */
)brace
r_else
r_if
c_cond
(paren
id|self-&gt;retry_count
op_eq
id|self-&gt;N1
)paren
(brace
id|irlap_status_indication
c_func
(paren
id|self
comma
id|STATUS_NO_ACTIVITY
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;retry count = N1; retry_count=%d&bslash;n&quot;
comma
id|self-&gt;retry_count
)paren
suffix:semicolon
multiline_comment|/* Keep state */
)brace
r_else
r_if
c_cond
(paren
id|self-&gt;retry_count
op_ge
id|self-&gt;N2
)paren
(brace
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_NO_RESPONSE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_REJ_RSP
suffix:colon
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;remote_busy
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
)brace
r_else
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_SREJ_RSP
suffix:colon
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;remote_busy
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
)brace
r_else
id|irlap_resend_rejected_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_RD_RSP
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), RECV_RD_RSP&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_PCLOSE
)paren
suffix:semicolon
id|irlap_send_disc_frame
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_reset_wait (event, skb, info)&n; *&n; *    We have informed the service user of a reset condition, and is&n; *    awaiting reset of disconnect request.&n; *&n; */
DECL|function|irlap_state_reset_wait
r_static
r_int
id|irlap_state_reset_wait
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;(), event = %s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RESET_REQUEST
suffix:colon
r_if
c_cond
(paren
id|self-&gt;xmitflag
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_snrm_frame
c_func
(paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET
)paren
suffix:semicolon
)brace
r_else
(brace
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DISCONNECT_REQUEST
suffix:colon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_disc_frame
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_PCLOSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_reset (self, event, skb, info)&n; *&n; *    We have sent a SNRM reset command to the peer layer, and is awaiting&n; *    reply.&n; *&n; */
DECL|function|irlap_state_reset
r_static
r_int
id|irlap_state_reset
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;(), event = %s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RECV_DISC_CMD
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_NO_RESPONSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_UA_RSP
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
multiline_comment|/* Initiate connection state */
id|irlap_initiate_connection_state
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_reset_confirm
c_func
(paren
)paren
suffix:semicolon
id|self-&gt;remote_busy
op_assign
id|FALSE
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_P
)paren
suffix:semicolon
id|irlap_start_poll_timer
c_func
(paren
id|self
comma
id|self-&gt;poll_timeout
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FINAL_TIMER_EXPIRED
suffix:colon
r_if
c_cond
(paren
id|self-&gt;retry_count
OL
l_int|3
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;netdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|irlap_send_snrm_frame
c_func
(paren
id|self
comma
id|self-&gt;qos_dev
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
multiline_comment|/* Experimental!! */
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|self-&gt;retry_count
op_ge
id|self-&gt;N3
)paren
(brace
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_NO_RESPONSE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_SNRM_CMD
suffix:colon
multiline_comment|/* &n;&t;&t; * SNRM frame is not allowed to contain an I-field in this &n;&t;&t; * state&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;(), RECV_SNRM_CMD&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_initiate_connection_state
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
id|irlap_reset_confirm
c_func
(paren
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), SNRM frame contained an I field!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_xmit_s (event, skb, info)&n; * &n; *   XMIT_S, The secondary station has been given the right to transmit,&n; *   and we therefor do not expect to receive any transmissions from other&n; *   stations.  &n; */
DECL|function|irlap_state_xmit_s
r_static
r_int
id|irlap_state_xmit_s
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), event=%s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENODEV
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
id|EBADR
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|SEND_I_CMD
suffix:colon
multiline_comment|/*&n;&t;&t; *  Send frame only if send window &gt; 1&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|self-&gt;window
OG
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|self-&gt;remote_busy
)paren
)paren
(brace
macro_line|#ifdef CONFIG_IRDA_DYNAMIC_WINDOW
multiline_comment|/*&n;&t;&t;&t; *  Test if we have transmitted more bytes over the &n;&t;&t;&t; *  link than its possible to do with the current &n;&t;&t;&t; *  speed and turn-around-time.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|self-&gt;bytes_left
)paren
(brace
id|skb_queue_head
c_func
(paren
op_amp
id|self-&gt;txq
comma
id|skb_get
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *  Switch to NRM_S, this is only possible&n;&t;&t;&t;&t; *  when we are in secondary mode, since we &n;&t;&t;&t;&t; *  must be sure that we don&squot;t miss any RR&n;&t;&t;&t;&t; *  frames&n;&t;&t;&t;&t; */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
r_return
op_minus
id|EPROTO
suffix:semicolon
multiline_comment|/* Try again later */
)brace
id|self-&gt;bytes_left
op_sub_assign
id|skb-&gt;len
suffix:semicolon
macro_line|#endif /* CONFIG_IRDA_DYNAMIC_WINDOW */
multiline_comment|/*&n;&t;&t;&t; *  Send data with final bit cleared only if window &gt; 1&n;&t;&t;&t; *  and there is more frames to be sent&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|self-&gt;window
OG
l_int|1
)paren
op_logical_and
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;txq
)paren
OG
l_int|0
)paren
(brace
id|irlap_send_data_secondary
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_S
)paren
suffix:semicolon
)brace
r_else
(brace
id|irlap_send_data_secondary_final
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Make sure state machine does not try to send&n;&t;&t;&t;&t; * any more frames &n;&t;&t;&t;&t; */
id|ret
op_assign
op_minus
id|EPROTO
suffix:semicolon
)brace
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), Unable to send!&bslash;n&quot;
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|self-&gt;txq
comma
id|skb_get
c_func
(paren
id|skb
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPROTO
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DISCONNECT_REQUEST
suffix:colon
id|irlap_send_rd_frame
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_SCLOSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_nrm_s (event, skb, info)&n; *&n; *    NRM_S (Normal Response Mode as Secondary) state, in this state we are &n; *    expecting to receive frames from the primary station&n; *&n; */
DECL|function|irlap_state_nrm_s
r_static
r_int
id|irlap_state_nrm_s
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ns_status
suffix:semicolon
r_int
id|nr_status
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), event=%s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RECV_I_CMD
suffix:colon
multiline_comment|/* Optimize for the common case */
multiline_comment|/* FIXME: must check for remote_busy below */
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), event=%s nr=%d, vs=%d, ns=%d, &quot;
l_string|&quot;vr=%d, pf=%d&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
comma
id|info-&gt;nr
comma
id|self-&gt;vs
comma
id|info-&gt;ns
comma
id|self-&gt;vr
comma
id|info-&gt;pf
)paren
suffix:semicolon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|ns_status
op_assign
id|irlap_validate_ns_received
c_func
(paren
id|self
comma
id|info-&gt;ns
)paren
suffix:semicolon
id|nr_status
op_assign
id|irlap_validate_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; *  Check for expected I(nformation) frame&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_EXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_EXPECTED
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t; *  poll bit cleared?&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *  Starting WD-timer here is optional, but&n;&t;&t;&t;&t; *  not recommended. Note 6 IrLAP p. 83&n;&t;&t;&t;&t; */
macro_line|#if 0
id|irda_start_timer
c_func
(paren
id|WD_TIMER
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Keep state, do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|FALSE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; *  We should wait before sending RR, and&n;&t;&t;&t;&t; *  also before changing to XMIT_S&n;&t;&t;&t;&t; *  state. (note 1, IrLAP p. 82) &n;&t;&t;&t;&t; */
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
multiline_comment|/*  &n;&t;&t;&t;&t; * Give higher layers a chance to&n;&t;&t;&t;&t; * immediately reply with some data before&n;&t;&t;&t;&t; * we decide if we should send a RR frame&n;&t;&t;&t;&t; * or not&n;&t;&t;&t;&t; */
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|FALSE
)paren
suffix:semicolon
multiline_comment|/* Any pending data requests?  */
r_if
c_cond
(paren
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;txq
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|self-&gt;window
OG
l_int|0
)paren
)paren
(brace
id|self-&gt;ack_required
op_assign
id|TRUE
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_S
)paren
suffix:semicolon
)brace
r_else
(brace
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|RSP_FRAME
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
multiline_comment|/* Keep the state */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; *  Check for Unexpected next to send (Ns)&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_UNEXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_EXPECTED
)paren
)paren
(brace
multiline_comment|/* Unexpected next to send, with final bit cleared */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; *  Unexpected Next to Receive(NR) ?&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_EXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_UNEXPECTED
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pf
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;RECV_I_RSP: frame(s) lost&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/* Resend rejected frames */
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|RSP_FRAME
)paren
suffix:semicolon
multiline_comment|/* Keep state, do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|FALSE
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *  This is not documented in IrLAP!! Unexpected NR&n;&t;&t;&t; *  with poll bit cleared&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/* Keep state, do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|FALSE
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
id|NR_INVALID
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;NRM_S, NR_INVALID not implemented!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
id|NS_INVALID
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;NRM_S, NS_INVALID not implemented!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_UI_FRAME
suffix:colon
multiline_comment|/* &n;&t;&t; *  poll bit cleared?&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|TRUE
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
multiline_comment|/* Keep state */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; *  Any pending data requests?&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;txq
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|self-&gt;window
OG
l_int|0
)paren
op_logical_and
op_logical_neg
id|self-&gt;remote_busy
)paren
(brace
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|TRUE
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_S
)paren
suffix:semicolon
)brace
r_else
(brace
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
comma
id|TRUE
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|RSP_FRAME
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|FALSE
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
multiline_comment|/* Keep the state */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|RECV_RR_CMD
suffix:colon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t;&t; *  Nr as expected? &n;&t;&t; */
id|nr_status
op_assign
id|irlap_validate_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_status
op_eq
id|NR_EXPECTED
)paren
(brace
r_if
c_cond
(paren
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;txq
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|self-&gt;window
OG
l_int|0
)paren
)paren
(brace
id|self-&gt;remote_busy
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_S
)paren
suffix:semicolon
)brace
r_else
(brace
id|self-&gt;remote_busy
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|RSP_FRAME
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|nr_status
op_eq
id|NR_UNEXPECTED
)paren
(brace
id|self-&gt;remote_busy
op_assign
id|FALSE
suffix:semicolon
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|RSP_FRAME
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
multiline_comment|/* Keep state */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), invalid nr not implemented!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_SNRM_CMD
suffix:colon
multiline_comment|/* SNRM frame is not allowed to contain an I-field */
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), received SNRM cmd&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET_CHECK
)paren
suffix:semicolon
id|irlap_reset_indication
c_func
(paren
id|self
)paren
suffix:semicolon
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), SNRM frame contained an I-field!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_REJ_CMD
suffix:colon
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;remote_busy
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
)brace
r_else
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_SREJ_CMD
suffix:colon
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;remote_busy
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
)brace
r_else
id|irlap_resend_rejected_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WD_TIMER_EXPIRED
suffix:colon
multiline_comment|/*&n;&t;&t; *  Wait until retry_count * n matches negotiated threshold/&n;&t;&t; *  disconnect time (note 2 in IrLAP p. 82)&n;&t;&t; *&n;&t;&t; * Note : self-&gt;wd_timeout = (self-&gt;poll_timeout * 2),&n;&t;&t; *   and self-&gt;final_timeout == self-&gt;poll_timeout,&n;&t;&t; *   which explain why we use (self-&gt;retry_count * 2) here !!!&n;&t;&t; * Jean II&n;&t;&t; */
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), retry_count = %d&bslash;n&quot;
comma
id|self-&gt;retry_count
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|self-&gt;retry_count
op_star
l_int|2
)paren
OL
id|self-&gt;N2
)paren
op_logical_and
(paren
(paren
id|self-&gt;retry_count
op_star
l_int|2
)paren
op_ne
id|self-&gt;N1
)paren
)paren
(brace
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|self-&gt;retry_count
op_star
l_int|2
)paren
op_eq
id|self-&gt;N1
)paren
(brace
id|irlap_status_indication
c_func
(paren
id|self
comma
id|STATUS_NO_ACTIVITY
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|self-&gt;retry_count
op_star
l_int|2
)paren
op_ge
id|self-&gt;N2
)paren
(brace
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_NO_RESPONSE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_DISC_CMD
suffix:colon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_DISCOVERY_XID_CMD
suffix:colon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|RSP_FRAME
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|TRUE
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_TEST_CMD
suffix:colon
multiline_comment|/* Remove test frame header (only LAP header in NRM) */
id|skb_pull
c_func
(paren
id|skb
comma
id|LAP_ADDR_HEADER
op_plus
id|LAP_CTRL_HEADER
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
multiline_comment|/* Send response (info will be copied) */
id|irlap_send_test_frame
c_func
(paren
id|self
comma
id|self-&gt;caddr
comma
id|info-&gt;daddr
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %d, (%s)&bslash;n&quot;
comma
id|event
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_sclose (self, event, skb, info)&n; *&n; *    &n; *&n; */
DECL|function|irlap_state_sclose
r_static
r_int
id|irlap_state_sclose
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENODEV
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
id|EBADR
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RECV_DISC_CMD
suffix:colon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_DM_RSP
suffix:colon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WD_TIMER_EXPIRED
suffix:colon
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %d, (%s)&bslash;n&quot;
comma
id|event
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|irlap_state_reset_check
r_static
r_int
id|irlap_state_reset_check
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), event=%s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENODEV
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
id|EBADR
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RESET_RESPONSE
suffix:colon
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
id|irlap_initiate_connection_state
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|WD_TIMEOUT
)paren
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DISCONNECT_REQUEST
suffix:colon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rd_frame
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|WD_TIMEOUT
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_SCLOSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %d, (%s)&bslash;n&quot;
comma
id|event
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
eof
