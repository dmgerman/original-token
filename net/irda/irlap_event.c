multiline_comment|/*********************************************************************&n; *                &n; * Filename:      irlap_event.c&n; * Version:       0.1&n; * Description:   IrLAP state machine implementation&n; * Status:        Experimental.&n; * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Created at:    Sat Aug 16 00:59:29 1997&n; * Modified at:   Tue Jan 19 22:58:45 1999&n; * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * &n; *     Copyright (c) 1998 Dag Brattli &lt;dagb@cs.uit.no&gt;,&n; *                        Thomas Davis &lt;ratbert@radiks.net&gt;&n; *     All Rights Reserved.&n; *     &n; *     This program is free software; you can redistribute it and/or &n; *     modify it under the terms of the GNU General Public License as &n; *     published by the Free Software Foundation; either version 2 of &n; *     the License, or (at your option) any later version.&n; *&n; *     Neither Dag Brattli nor University of Troms&#xfffd; admit liability nor&n; *     provide warranty for any of this software. This material is &n; *     provided &quot;AS-IS&quot; and at no charge.&n; *&n; ********************************************************************/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/irlap_event.h&gt;
macro_line|#include &lt;net/irda/timer.h&gt;
macro_line|#include &lt;net/irda/irlap.h&gt;
macro_line|#include &lt;net/irda/irlap_frame.h&gt;
macro_line|#include &lt;net/irda/qos.h&gt;
macro_line|#include &lt;net/irda/irda_device.h&gt;
r_static
r_int
id|irlap_state_ndm
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_query
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_reply
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_conn
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_setup
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_offline
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_xmit_p
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_pclose
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_nrm_p
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_reset_wait
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_reset
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_nrm_s
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_xmit_s
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_sclose
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|irlap_state_reset_check
c_func
(paren
r_struct
id|irlap_cb
op_star
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
comma
r_struct
id|irlap_info
op_star
)paren
suffix:semicolon
DECL|variable|irlap_event
r_static
r_char
op_star
id|irlap_event
(braket
)braket
op_assign
(brace
l_string|&quot;DISCOVERY_REQUEST&quot;
comma
l_string|&quot;CONNECT_REQUEST&quot;
comma
l_string|&quot;CONNECT_RESPONSE&quot;
comma
l_string|&quot;DISCONNECT_REQUEST&quot;
comma
l_string|&quot;DATA_REQUEST&quot;
comma
l_string|&quot;RESET_REQUEST&quot;
comma
l_string|&quot;RESET_RESPONSE&quot;
comma
l_string|&quot;SEND_I_CMD&quot;
comma
l_string|&quot;RECV_DISCOVERY_XID_CMD&quot;
comma
l_string|&quot;RECV_DISCOVERY_XID_RSP&quot;
comma
l_string|&quot;RECV_SNRM_CMD&quot;
comma
l_string|&quot;RECV_TEST_CMD&quot;
comma
l_string|&quot;RECV_UA_RSP&quot;
comma
l_string|&quot;RECV_DM_RSP&quot;
comma
l_string|&quot;RECV_I_CMD&quot;
comma
l_string|&quot;RECV_I_RSP&quot;
comma
l_string|&quot;RECV_UI_FRAME&quot;
comma
l_string|&quot;RECV_FRMR_RSP&quot;
comma
l_string|&quot;RECV_RR_CMD&quot;
comma
l_string|&quot;RECV_RR_RSP&quot;
comma
l_string|&quot;RECV_RNR_FRAME&quot;
comma
l_string|&quot;RECV_DISC_FRAME&quot;
comma
l_string|&quot;SLOT_TIMER_EXPIRED&quot;
comma
l_string|&quot;QUERY_TIMER_EXPIRED&quot;
comma
l_string|&quot;FINAL_TIMER_EXPIRED&quot;
comma
l_string|&quot;POLL_TIMER_EXPIRED&quot;
comma
l_string|&quot;DISCOVERY_TIMER_EXPIRED&quot;
comma
l_string|&quot;WD_TIMER_EXPIRED&quot;
comma
l_string|&quot;BACKOFF_TIMER_EXPIRED&quot;
comma
)brace
suffix:semicolon
DECL|variable|irlap_state
r_char
op_star
id|irlap_state
(braket
)braket
op_assign
(brace
l_string|&quot;LAP_NDM&quot;
comma
l_string|&quot;LAP_QUERY&quot;
comma
l_string|&quot;LAP_REPLY&quot;
comma
l_string|&quot;LAP_CONN&quot;
comma
l_string|&quot;LAP_SETUP&quot;
comma
l_string|&quot;LAP_OFFLINE&quot;
comma
l_string|&quot;LAP_XMIT_P&quot;
comma
l_string|&quot;LAP_PCLOSE&quot;
comma
l_string|&quot;LAP_NRM_P&quot;
comma
l_string|&quot;LAP_RESET_WAIT&quot;
comma
l_string|&quot;LAP_RESET&quot;
comma
l_string|&quot;LAP_NRM_S&quot;
comma
l_string|&quot;LAP_XMIT_S&quot;
comma
l_string|&quot;LAP_SCLOSE&quot;
comma
l_string|&quot;LAP_RESET_CHECK&quot;
comma
)brace
suffix:semicolon
DECL|variable|state
r_static
r_int
(paren
op_star
id|state
(braket
)braket
)paren
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
op_assign
(brace
id|irlap_state_ndm
comma
id|irlap_state_query
comma
id|irlap_state_reply
comma
id|irlap_state_conn
comma
id|irlap_state_setup
comma
id|irlap_state_offline
comma
id|irlap_state_xmit_p
comma
id|irlap_state_pclose
comma
id|irlap_state_nrm_p
comma
id|irlap_state_reset_wait
comma
id|irlap_state_reset
comma
id|irlap_state_nrm_s
comma
id|irlap_state_xmit_s
comma
id|irlap_state_sclose
comma
id|irlap_state_reset_check
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Function irda_poll_timer_expired (data)&n; *&n; *    &n; *&n; */
DECL|function|irlap_poll_timer_expired
r_static
r_void
id|irlap_poll_timer_expired
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|irlap_cb
op_star
id|self
op_assign
(paren
r_struct
id|irlap_cb
op_star
)paren
id|data
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|irlap_do_event
c_func
(paren
id|self
comma
id|POLL_TIMER_EXPIRED
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|irlap_start_poll_timer
r_void
id|irlap_start_poll_timer
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
r_int
id|timeout
)paren
(brace
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_FAST_RR
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;tx_list
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|self-&gt;fast_RR
op_eq
id|TRUE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  Assert that the fast poll timer has not reached the&n;&t;&t;&t; *  normal poll timer yet&n;&t;&t;&t; */
r_if
c_cond
(paren
id|self-&gt;fast_RR_timeout
OL
id|timeout
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *  FIXME: this should be a more configurable&n;&t;&t;&t;&t; *         function&n;&t;&t;&t;&t; */
id|self-&gt;fast_RR_timeout
op_add_assign
l_int|15
suffix:semicolon
multiline_comment|/* Use this fast(er) timeout instead */
id|timeout
op_assign
id|self-&gt;fast_RR_timeout
suffix:semicolon
)brace
)brace
r_else
(brace
id|self-&gt;fast_RR
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Start with just 1 ms */
id|self-&gt;fast_RR_timeout
op_assign
l_int|1
suffix:semicolon
id|timeout
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
id|self-&gt;fast_RR
op_assign
id|FALSE
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), Timeout=%d&bslash;n&quot;
comma
id|timeout
)paren
suffix:semicolon
macro_line|#endif
id|irda_start_timer
c_func
(paren
op_amp
id|self-&gt;poll_timer
comma
id|timeout
comma
(paren
r_int
r_int
)paren
id|self
comma
id|irlap_poll_timer_expired
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_do_event (event, skb, info)&n; *&n; *    Rushes through the state machine without any delay. If state = XMIT&n; *    then send queued data frames. &n; */
DECL|function|irlap_do_event
r_void
id|irlap_do_event
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|iter
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self
op_logical_or
id|self-&gt;magic
op_ne
id|LAP_MAGIC
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irlap_do_event: bad pointer *self&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irlap_do_event: event = %s, state = %s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
comma
id|irlap_state
(braket
id|self-&gt;state
)braket
)paren
suffix:semicolon
multiline_comment|/* &n;&t; *  Do event, this implementation does not deal with pending events. &n;&t; *  This is because I don&squot;t see the need for this. DB&n;&t; */
id|ret
op_assign
(paren
op_star
id|state
(braket
id|self-&gt;state
)braket
)paren
(paren
id|self
comma
id|event
comma
id|skb
comma
id|info
)paren
suffix:semicolon
multiline_comment|/* &n;&t; *  Check if we have switched to XMIT state? If so, send queued data &n;&t; *  frames if any, if -1 is returned it means that we are not allowed &n;&t; *  to send any more frames.  &n;&t; */
r_while
c_loop
(paren
(paren
id|self-&gt;state
op_eq
id|LAP_XMIT_P
)paren
op_logical_or
(paren
id|self-&gt;state
op_eq
id|LAP_XMIT_S
)paren
)paren
(brace
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;tx_list
)paren
OG
l_int|0
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|self-&gt;tx_list
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;** Sending queued data frames&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
(paren
op_star
id|state
(braket
id|self-&gt;state
)braket
)paren
(paren
id|self
comma
id|SEND_I_CMD
comma
id|skb
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EPROTO
)paren
r_return
suffix:semicolon
multiline_comment|/* Try again later! */
)brace
r_else
r_return
suffix:semicolon
multiline_comment|/* Just in case :-) */
r_if
c_cond
(paren
id|iter
op_increment
OG
l_int|100
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), *** breaking!! ***&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Function irlap_next_state (self, state)&n; *&n; *    Switches state and provides debug information&n; *&n; */
DECL|function|irlap_next_state
r_void
id|irlap_next_state
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_STATE
id|state
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|self
op_logical_or
id|self-&gt;magic
op_ne
id|LAP_MAGIC
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irlap_next_state: I have lost myself!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;next LAP state = %s&bslash;n&quot;
comma
id|irlap_state
(braket
id|state
)braket
)paren
suffix:semicolon
id|self-&gt;state
op_assign
id|state
suffix:semicolon
multiline_comment|/*&n;&t; *  If we are swithing away from a XMIT state then we are allowed to &n;&t; *  transmit a maximum number of bytes again when we enter the XMIT &n;&t; *  state again. Since its possible to &quot;switch&quot; from XMIT to XMIT and&n;&t; *  we cannot do this when swithing into the XMIT state :-)&n;&t; */
r_if
c_cond
(paren
(paren
id|state
op_ne
id|LAP_XMIT_P
)paren
op_logical_and
(paren
id|state
op_ne
id|LAP_XMIT_S
)paren
)paren
id|self-&gt;bytes_left
op_assign
id|self-&gt;window_bytes
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_ndm (event, skb, frame)&n; *&n; *    NDM (Normal Disconnected Mode) state&n; *&n; */
DECL|function|irlap_state_ndm
r_static
r_int
id|irlap_state_ndm
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
id|DISCOVERY
op_star
id|discovery_rsp
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|CONNECT_REQUEST
suffix:colon
id|ASSERT
c_func
(paren
id|self-&gt;irdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irda_device_is_media_busy
c_func
(paren
id|self-&gt;irdev
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), CONNECT_REQUEST: media busy!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_MEDIA_BUSY
)paren
suffix:semicolon
)brace
r_else
(brace
id|irlap_send_snrm_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
multiline_comment|/* Start Final-bit timer */
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_SETUP
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_SNRM_CMD
suffix:colon
id|self-&gt;daddr
op_assign
id|info-&gt;daddr
suffix:semicolon
id|self-&gt;caddr
op_assign
id|info-&gt;caddr
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_CONN
)paren
suffix:semicolon
id|irlap_connect_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DISCOVERY_REQUEST
suffix:colon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irda_device_is_media_busy
c_func
(paren
id|self-&gt;irdev
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irlap_discovery_request: media busy!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* irlap-&gt;log.condition = MEDIA_BUSY; */
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
multiline_comment|/* This will make IrLMP try again */
id|irlap_discovery_confirm
c_func
(paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|self-&gt;S
op_assign
id|info-&gt;S
suffix:semicolon
id|self-&gt;s
op_assign
id|info-&gt;s
suffix:semicolon
id|irlap_send_discovery_xid_frame
c_func
(paren
id|self
comma
id|info-&gt;S
comma
id|info-&gt;s
comma
id|TRUE
comma
id|info-&gt;discovery
)paren
suffix:semicolon
id|self-&gt;s
op_increment
suffix:semicolon
id|irlap_start_slot_timer
c_func
(paren
id|self
comma
id|SLOT_TIMEOUT
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_QUERY
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_DISCOVERY_XID_CMD
suffix:colon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Assert that this is not the final slot */
r_if
c_cond
(paren
id|info-&gt;s
op_le
id|info-&gt;S
)paren
(brace
id|self-&gt;daddr
op_assign
id|info-&gt;daddr
suffix:semicolon
id|self-&gt;slot
op_assign
id|irlap_generate_rand_time_slot
c_func
(paren
id|info-&gt;S
comma
id|info-&gt;s
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;XID_CMD: S=%d, s=%d, slot %d&bslash;n&quot;
comma
id|info-&gt;S
comma
id|info-&gt;s
comma
id|self-&gt;slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;slot
op_eq
id|info-&gt;s
)paren
(brace
id|discovery_rsp
op_assign
id|irlmp_get_discovery_response
c_func
(paren
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Sending XID rsp 1&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_send_discovery_xid_frame
c_func
(paren
id|self
comma
id|info-&gt;S
comma
id|self-&gt;slot
comma
id|FALSE
comma
id|discovery_rsp
)paren
suffix:semicolon
id|self-&gt;frame_sent
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
id|self-&gt;frame_sent
op_assign
id|FALSE
suffix:semicolon
id|irlap_start_query_timer
c_func
(paren
id|self
comma
id|QUERY_TIMEOUT
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_REPLY
)paren
suffix:semicolon
)brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* &t;DEBUG( 0, &quot;irlap_state_ndm: Unknown event&quot;); */
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_query (event, skb, info)&n; *&n; *    QUERY state&n; *&n; */
DECL|function|irlap_state_query
r_static
r_int
id|irlap_state_query
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RECV_DISCOVERY_XID_RSP
suffix:colon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|info-&gt;discovery
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), daddr=%08x&bslash;n&quot;
comma
id|info-&gt;discovery-&gt;daddr
)paren
suffix:semicolon
id|hashbin_insert
c_func
(paren
id|self-&gt;discovery_log
comma
(paren
id|QUEUE
op_star
)paren
id|info-&gt;discovery
comma
id|info-&gt;discovery-&gt;daddr
comma
l_int|NULL
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Keep state */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_QUERY
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SLOT_TIMER_EXPIRED
suffix:colon
r_if
c_cond
(paren
id|self-&gt;s
OL
id|self-&gt;S
)paren
(brace
id|irlap_send_discovery_xid_frame
c_func
(paren
id|self
comma
id|self-&gt;S
comma
id|self-&gt;s
comma
id|TRUE
comma
id|self-&gt;discovery_cmd
)paren
suffix:semicolon
id|self-&gt;s
op_increment
suffix:semicolon
id|irlap_start_slot_timer
c_func
(paren
id|self
comma
id|SLOT_TIMEOUT
)paren
suffix:semicolon
multiline_comment|/* Keep state */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_QUERY
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This is the final slot! */
id|irlap_send_discovery_xid_frame
c_func
(paren
id|self
comma
id|self-&gt;S
comma
l_int|0xff
comma
id|TRUE
comma
id|self-&gt;discovery_cmd
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  We are now finished with the discovery procedure, &n;&t;&t;&t; *  so now we must return the results&n;&t;&t;&t; */
id|irlap_discovery_confirm
c_func
(paren
id|self
comma
id|self-&gt;discovery_log
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %d, %s&bslash;n&quot;
comma
id|event
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_reply (self, event, skb, info)&n; *&n; *    REPLY, we have received a XID discovery frame from a device and we&n; *    are waiting for the right time slot to send a response XID frame&n; * &n; */
DECL|function|irlap_state_reply
r_static
r_int
id|irlap_state_reply
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
id|DISCOVERY
op_star
id|discovery_rsp
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|QUERY_TIMER_EXPIRED
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), QUERY_TIMER_EXPIRED &lt;%ld&gt;&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_DISCOVERY_XID_CMD
suffix:colon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Last frame?&n;&t;&t; */
r_if
c_cond
(paren
id|info-&gt;s
op_eq
l_int|0xff
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;query_timer
)paren
suffix:semicolon
multiline_comment|/* info-&gt;log.condition = REMOTE; */
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_discovery_indication
c_func
(paren
id|self
comma
id|info-&gt;discovery
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|info-&gt;s
op_ge
id|self-&gt;slot
)paren
op_logical_and
(paren
op_logical_neg
id|self-&gt;frame_sent
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Sending XID rsp 2, s=%d&bslash;n&quot;
comma
id|info-&gt;s
)paren
suffix:semicolon
id|discovery_rsp
op_assign
id|irlmp_get_discovery_response
c_func
(paren
)paren
suffix:semicolon
id|irlap_send_discovery_xid_frame
c_func
(paren
id|self
comma
id|info-&gt;S
comma
id|self-&gt;slot
comma
id|FALSE
comma
id|discovery_rsp
)paren
suffix:semicolon
id|self-&gt;frame_sent
op_assign
id|TRUE
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_REPLY
)paren
suffix:semicolon
)brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %d, %s&bslash;n&quot;
comma
id|event
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_conn (event, skb, info)&n; *&n; *    CONN, we have received a SNRM command and is waiting for the upper&n; *    layer to accept or refuse connection &n; *&n; */
DECL|function|irlap_state_conn
r_static
r_int
id|irlap_state_conn
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), event=%s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|CONNECT_RESPONSE
suffix:colon
id|skb_pull
c_func
(paren
id|skb
comma
l_int|11
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;irdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|irda_qos_negotiate
c_func
(paren
op_amp
id|self-&gt;qos_rx
comma
op_amp
id|self-&gt;qos_tx
comma
id|skb
)paren
suffix:semicolon
id|irlap_initiate_connection_state
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We are allowed to send two frames!&n;&t;&t; */
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
id|irlap_apply_connection_parameters
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  The WD-timer could be set to the duration of the P-timer &n;&t;&t; *  for this case, but it is recommomended to use twice the &n;&t;&t; *  value (note 3 IrLAP p. 60). &n;&t;&t; */
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_SNRM_CMD
suffix:colon
id|DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;(), event RECV_SNRM_CMD!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if 0
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|RECV_DISCOVERY_XID_CMD
suffix:colon
id|DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;(), event RECV_DISCOVER_XID_CMD!&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DISCONNECT_REQUEST
suffix:colon
id|irlap_send_dm_frame
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_CONN
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %d, %s&bslash;n&quot;
comma
id|event
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_setup (event, skb, frame)&n; *&n; *    SETUP state, The local layer has transmitted a SNRM command frame to&n; *    a remote peer layer and is awaiting a reply .&n; *&n; */
DECL|function|irlap_state_setup
r_static
r_int
id|irlap_state_setup
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|FINAL_TIMER_EXPIRED
suffix:colon
r_if
c_cond
(paren
id|self-&gt;retry_count
OL
id|self-&gt;N3
)paren
(brace
multiline_comment|/* &n; *  Perform random backoff, Wait a random number of time units, minimum &n; *  duration half the time taken to transmitt a SNRM frame, maximum duration &n; *  1.5 times the time taken to transmit a SNRM frame. So this time should &n; *  between 15 msecs and 45 msecs.&n; */
id|irlap_start_backoff_timer
c_func
(paren
id|self
comma
l_int|2
op_plus
(paren
id|jiffies
op_mod
l_int|3
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_FOUND_NONE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BACKOFF_TIMER_EXPIRED
suffix:colon
id|irlap_send_snrm_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_SNRM_CMD
suffix:colon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), SNRM battle!&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  The device with the largest device address wins the battle&n;&t;&t; *  (both have sent a SNRM command!)&n;&t;&t; */
r_if
c_cond
(paren
id|info-&gt;daddr
OG
id|self-&gt;saddr
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_initiate_connection_state
c_func
(paren
id|self
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;irdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|irda_qos_negotiate
c_func
(paren
op_amp
id|self-&gt;qos_rx
comma
op_amp
id|self-&gt;qos_tx
comma
id|skb
)paren
suffix:semicolon
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
id|irlap_apply_connection_parameters
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_connect_confirm
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; *  The WD-timer could be set to the duration of the&n;&t;&t;&t; *  P-timer for this case, but it is recommomended&n;&t;&t;&t; *  to use twice the value (note 3 IrLAP p. 60).  &n;&t;&t;&t; */
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We just ignore the other device! */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_SETUP
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_UA_RSP
suffix:colon
multiline_comment|/* Stop F-timer */
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
multiline_comment|/* Initiate connection state */
id|irlap_initiate_connection_state
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Negotiate connection parameters */
id|ASSERT
c_func
(paren
id|skb-&gt;len
OG
l_int|10
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
l_int|10
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;irdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|irda_qos_negotiate
c_func
(paren
op_amp
id|self-&gt;qos_rx
comma
op_amp
id|self-&gt;qos_tx
comma
id|skb
)paren
suffix:semicolon
id|irlap_apply_connection_parameters
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
op_div
l_int|2
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
id|irlap_connect_confirm
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_DISC_FRAME
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* DM handled in irlap_frame.c, irlap_input() */
r_default
suffix:colon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irlap_state_setup: Unknown event&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_offline (self, event, skb, info)&n; *&n; *    OFFLINE state, not used for now!&n; *&n; */
DECL|function|irlap_state_offline
r_static
r_int
id|irlap_state_offline
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_xmit_p (self, event, skb, info)&n; * &n; *    XMIT, Only the primary station has right to transmit, and we therefor&n; *    do not expect to receive any transmissions from other stations.  &n; *&n; */
DECL|function|irlap_state_xmit_p
r_static
r_int
id|irlap_state_xmit_p
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENODEV
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
id|EBADR
suffix:semicolon
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), event=%s, vs=%d, vr=%d&quot;
comma
id|irlap_event
(braket
id|event
)braket
comma
id|self-&gt;vs
comma
id|self-&gt;vr
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|SEND_I_CMD
suffix:colon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), Window=%d&bslash;n&quot;
comma
id|self-&gt;window
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Only send frame if send-window &gt; 0.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|self-&gt;window
OG
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|self-&gt;remote_busy
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  Test if we have transmitted more bytes over the &n;&t;&t;&t; *  link than its possible to do with the current &n;&t;&t;&t; *  speed and turn-around-time.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|skb-&gt;len
op_plus
id|self-&gt;bofs_count
)paren
OG
id|self-&gt;bytes_left
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), Not allowed to &quot;
l_string|&quot;transmit more bytes!&bslash;n&quot;
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|self-&gt;tx_list
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *  We should switch state to LAP_NRM_P, but&n;&t;&t;&t;&t; *  that is not possible since we must be sure&n;&t;&t;&t;&t; *  that we poll the other side. Since we have&n;&t;&t;&t;&t; *  used up our time, the poll timer should&n;&t;&t;&t;&t; *  trigger anyway now,so we just wait for it&n;&t;&t;&t;&t; *  DB&n;&t;&t;&t;&t; */
r_return
op_minus
id|EPROTO
suffix:semicolon
)brace
id|self-&gt;bytes_left
op_sub_assign
(paren
id|skb-&gt;len
op_plus
id|self-&gt;bofs_count
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Send data with poll bit cleared only if window &gt; 1&n;&t;&t;&t; *  and there is more frames after this one to be sent&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|self-&gt;window
OG
l_int|1
)paren
op_logical_and
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;tx_list
)paren
OG
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), window &gt; 1&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_send_data_primary
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_P
)paren
suffix:semicolon
)brace
r_else
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), window &lt;= 1&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_send_data_primary_poll
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IRDA_FAST_RR
multiline_comment|/* Peer may want to reply immediately */
id|self-&gt;fast_RR
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), Unable to send! remote busy?&bslash;n&quot;
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|self-&gt;tx_list
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  The next ret is important, because it tells &n;&t;&t;&t; *  irlap_next_state _not_ to deliver more frames&n;&t;&t;&t; */
id|ret
op_assign
op_minus
id|EPROTO
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DISCONNECT_REQUEST
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;poll_timer
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_disc_frame
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_PCLOSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|POLL_TIMER_EXPIRED
suffix:colon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* DEBUG( 0, &quot;irlap_state_xmit: Unknown event&quot;); */
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_pclose (event, skb, info)&n; *&n; *    PCLOSE state&n; */
DECL|function|irlap_state_pclose
r_static
r_int
id|irlap_state_pclose
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RECV_UA_RSP
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FINAL_TIMER_EXPIRED
suffix:colon
r_if
c_cond
(paren
id|self-&gt;retry_count
OL
id|self-&gt;N3
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_disc_frame
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
multiline_comment|/* Keep state */
)brace
r_else
(brace
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; *  Always switch state before calling upper layers &n;&t;&t;&t; */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_NO_RESPONSE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %d&bslash;n&quot;
comma
id|event
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_nrm_p (self, event, skb, info)&n; *&n; *   NRM_P (Normal Response Mode as Primary), The primary station has given&n; *   permissions to a secondary station to transmit IrLAP resonse frames&n; *   (by sending a frame with the P bit set). The primary station will not&n; *   transmit any frames and is expecting to receive frames only from the&n; *   secondary to which transmission permissions has been given.&n; */
DECL|function|irlap_state_nrm_p
r_static
r_int
id|irlap_state_nrm_p
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|ns_status
suffix:semicolon
r_int
id|nr_status
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RECV_RR_RSP
suffix:colon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), RECV_RR_FRAME: &quot;
l_string|&quot;Retrans:%d, nr=%d, va=%d, vs=%d, vr=%d&bslash;n&quot;
comma
id|self-&gt;retry_count
comma
id|info-&gt;nr
comma
id|self-&gt;va
comma
id|self-&gt;vs
comma
id|self-&gt;vr
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*  &n;&t;&t; *  If you get a RR, the remote isn&squot;t busy anymore, &n;&t;&t; *  no matter what the NR &n;&t;&t; */
id|self-&gt;remote_busy
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* &n;&t;&t; *  Nr as expected? &n;&t;&t; */
id|ret
op_assign
id|irlap_validate_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|NR_EXPECTED
)paren
(brace
multiline_comment|/* Stop final timer */
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Got expected NR, so reset the retry_count. This &n;&t;&t;&t; *  is not done by the IrLAP standard , which is &n;&t;&t;&t; *  strange! DB.&n;&t;&t;&t; */
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
multiline_comment|/* Start poll timer */
id|irlap_start_poll_timer
c_func
(paren
id|self
comma
id|self-&gt;poll_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_P
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ret
op_eq
id|NR_UNEXPECTED
)paren
(brace
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; *  Unexpected nr! &n;&t;&t;&t; */
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;RECV_RR_FRAME: Retrans:%d, nr=%d, va=%d, &quot;
l_string|&quot;vs=%d, vr=%d&bslash;n&quot;
comma
id|self-&gt;retry_count
comma
id|info-&gt;nr
comma
id|self-&gt;va
comma
id|self-&gt;vs
comma
id|self-&gt;vr
)paren
suffix:semicolon
multiline_comment|/* Resend rejected frames */
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Start only if not running, DB&n;&t;&t;&t; *  TODO: Should this one be here?&n;&t;&t;&t; */
multiline_comment|/* if ( !self-&gt;final_timer.prev) */
multiline_comment|/* &t;&t;&t;&t;irda_start_timer( FINAL_TIMER, self-&gt;final_timeout);  */
multiline_comment|/* Keep state */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ret
op_eq
id|NR_INVALID
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irlap_state_nrm_p: received RR with &quot;
l_string|&quot;invalid nr !&bslash;n&quot;
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET_WAIT
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_RESET_INDICATION
)paren
suffix:semicolon
id|self-&gt;xmitflag
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb
)paren
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_RNR_FRAME
suffix:colon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irlap_state_nrm_p: RECV_RNR_FRAME: Retrans:%d, &quot;
l_string|&quot;nr=%d, va=%d, vs=%d, vr=%d&bslash;n&quot;
comma
id|self-&gt;retry_count
comma
id|info-&gt;nr
comma
id|self-&gt;va
comma
id|self-&gt;vs
comma
id|self-&gt;vr
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Stop final timer */
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|self-&gt;remote_busy
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/* Start poll timer */
id|irlap_start_poll_timer
c_func
(paren
id|self
comma
id|self-&gt;poll_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_P
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_I_RSP
suffix:colon
multiline_comment|/* FIXME: must check for remote_busy below */
macro_line|#ifdef CONFIG_IRDA_FAST_RR
multiline_comment|/* &n;&t;&t; *  Reset the fast_RR so we can use the fast RR code with&n;&t;&t; *  full speed the next time since peer may have more frames&n;&t;&t; *  to transmitt&n;&t;&t; */
id|self-&gt;fast_RR
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|info
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ns_status
op_assign
id|irlap_validate_ns_received
c_func
(paren
id|self
comma
id|info-&gt;ns
)paren
suffix:semicolon
id|nr_status
op_assign
id|irlap_validate_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; *  Check for expected I(nformation) frame&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_EXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_EXPECTED
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t; *  poll bit cleared?&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Keep state, do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/*  &n;&t;&t;&t;&t; *  Got expected NR, so reset the&n;&t;&t;&t;&t; *  retry_count. This is not done by IrLAP,&n;&t;&t;&t;&t; *  which is strange!  &n;&t;&t;&t;&t; */
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* This is the last frame */
id|irlap_start_poll_timer
c_func
(paren
id|self
comma
id|self-&gt;poll_timeout
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
multiline_comment|/* Do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_P
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Unexpected next to send (Ns)&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_UNEXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_EXPECTED
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *  Wait until the last frame before doing &n;&t;&t;&t;&t; *  anything&n;&t;&t;&t;&t; */
multiline_comment|/* Keep state */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
)brace
r_else
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), missing or duplicate frame!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|FALSE
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
)brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; *  Unexpected next to receive (Nr) &n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_EXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_UNEXPECTED
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pf
)paren
(brace
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/* Resend rejected frames */
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|FALSE
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
multiline_comment|/* Keep state, do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &n;&t;&t;&t;&t; *  Do not resend frames until the last&n;&t;&t;&t;&t; *  frame has arrived from the other&n;&t;&t;&t;&t; *  device. This is not documented in&n;&t;&t;&t;&t; *  IrLAP!!  &n;&t;&t;&t;&t; */
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Keep state, do not move this line!*/
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Unexpected next to send (Ns) and next to receive (Nr)&n;&t;&t; *  Not documented by IrLAP!&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_UNEXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_UNEXPECTED
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;IrLAP: unexpected nr and ns!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pf
)paren
(brace
multiline_comment|/* Resend rejected frames */
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
multiline_comment|/* Give peer some time to retransmit! */
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
multiline_comment|/* Keep state, do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Update Nr received */
multiline_comment|/* irlap_update_nr_received( info-&gt;nr); */
id|self-&gt;ack_required
op_assign
id|FALSE
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Invalid NR or NS&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|nr_status
op_eq
id|NR_INVALID
)paren
op_logical_or
(paren
id|ns_status
op_eq
id|NS_INVALID
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pf
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET_WAIT
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_RESET_INDICATION
)paren
suffix:semicolon
id|self-&gt;xmitflag
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_RESET_INDICATION
)paren
suffix:semicolon
id|self-&gt;xmitflag
op_assign
id|FALSE
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irlap_state_nrm_p: Not implemented!&bslash;n&quot;
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;event=%s, ns_status=%d, nr_status=%d&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
comma
id|ns_status
comma
id|nr_status
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_UI_FRAME
suffix:colon
multiline_comment|/*  poll bit cleared?  */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|irlap_unit_data_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_P
)paren
suffix:semicolon
)brace
r_else
(brace
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_unit_data_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_start_poll_timer
c_func
(paren
id|self
comma
id|self-&gt;poll_timeout
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_FRMR_RSP
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|self-&gt;xmitflag
op_assign
id|TRUE
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET_WAIT
)paren
suffix:semicolon
id|irlap_reset_indication
c_func
(paren
id|self
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FINAL_TIMER_EXPIRED
suffix:colon
multiline_comment|/* &n;&t;&t; *  We are allowed to wait for additional 300 ms if&n;&t;&t; *  final timer expires when we are in the middle&n;&t;&t; *  of receiving a frame (page 45, IrLAP). Check that&n;&t;&t; *  we only do this once for each frame.&n;&t;&t; */
r_if
c_cond
(paren
id|irda_device_is_receiving
c_func
(paren
id|self-&gt;irdev
)paren
op_logical_and
op_logical_neg
id|self-&gt;add_wait
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;FINAL_TIMER_EXPIRED when receiving a &quot;
l_string|&quot;frame! Waiting a little bit more!&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
l_int|30
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Don&squot;t allow this to happen one more time in a row, &n;&t;&t;&t; *  or else we can get a pretty tight loop here if &n;&t;&t;&t; *  if we only receive half a frame. DB.&n;&t;&t;&t; */
id|self-&gt;add_wait
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|self-&gt;add_wait
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|self-&gt;retry_count
OL
id|self-&gt;N2
)paren
op_logical_and
(paren
id|self-&gt;retry_count
op_ne
id|self-&gt;N1
)paren
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irlap_state_nrm_p: FINAL_TIMER_EXPIRED:&quot;
l_string|&quot; retry_count=%d&bslash;n&quot;
comma
id|self-&gt;retry_count
)paren
suffix:semicolon
multiline_comment|/* Keep state */
)brace
r_else
r_if
c_cond
(paren
id|self-&gt;retry_count
op_eq
id|self-&gt;N1
)paren
(brace
id|irlap_status_indication
c_func
(paren
id|STATUS_NO_ACTIVITY
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;retry count = N1; retry_count=%d&bslash;n&quot;
comma
id|self-&gt;retry_count
)paren
suffix:semicolon
multiline_comment|/* Keep state */
)brace
r_else
r_if
c_cond
(paren
id|self-&gt;retry_count
op_ge
id|self-&gt;N2
)paren
(brace
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_NO_RESPONSE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_DISC_FRAME
suffix:colon
multiline_comment|/* FIXME: Check how this is in the standard! */
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), RECV_DISC_FRAME()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
multiline_comment|/* del_timer( &amp;self-&gt;poll_timer); */
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* DEBUG( 0, &quot;irlap_state_nrm_p: Unknown event&quot;); */
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_reset_wait (event, skb, info)&n; *&n; *    We have informed the service user of a reset condition, and is&n; *    awaiting reset of disconnect request.&n; *&n; */
DECL|function|irlap_state_reset_wait
r_int
id|irlap_state_reset_wait
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;(), event = %s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RESET_REQUEST
suffix:colon
r_if
c_cond
(paren
id|self-&gt;xmitflag
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_snrm_frame
c_func
(paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET
)paren
suffix:semicolon
)brace
r_else
(brace
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DISCONNECT_REQUEST
suffix:colon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_disc_frame
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_PCLOSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_reset (self, event, skb, info)&n; *&n; *    We have sent a SNRM reset command to the peer layer, and is awaiting&n; *    reply.&n; *&n; */
DECL|function|irlap_state_reset
r_int
id|irlap_state_reset
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;(), event = %s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RECV_DISC_FRAME
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_NO_RESPONSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_UA_RSP
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
multiline_comment|/* Initiate connection state */
id|irlap_initiate_connection_state
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_reset_confirm
c_func
(paren
)paren
suffix:semicolon
id|self-&gt;remote_busy
op_assign
id|FALSE
suffix:semicolon
id|irlap_start_poll_timer
c_func
(paren
id|self
comma
id|self-&gt;poll_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_P
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FINAL_TIMER_EXPIRED
suffix:colon
r_if
c_cond
(paren
id|self-&gt;retry_count
OL
l_int|3
)paren
(brace
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;irdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|irlap_send_snrm_frame
c_func
(paren
id|self
comma
id|irda_device_get_qos
c_func
(paren
id|self-&gt;irdev
)paren
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
multiline_comment|/* Experimental!! */
id|irlap_start_final_timer
c_func
(paren
id|self
comma
id|self-&gt;final_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|self-&gt;retry_count
op_ge
id|self-&gt;N3
)paren
(brace
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_NO_RESPONSE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_SNRM_CMD
suffix:colon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;lap_reset: RECV_SNRM_CMD&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_initiate_connection_state
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
id|irlap_reset_confirm
c_func
(paren
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_xmit_s (event, skb, info)&n; * &n; *   XMIT_S, The secondary station has been given the right to transmit,&n; *   and we therefor do not expect to receive any transmissions from other&n; *   stations.  &n; */
DECL|function|irlap_state_xmit_s
r_static
r_int
id|irlap_state_xmit_s
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), event=%s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENODEV
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
id|EBADR
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|SEND_I_CMD
suffix:colon
multiline_comment|/*&n;&t;&t; *  Send frame only if send window &gt; 1&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|self-&gt;window
OG
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|self-&gt;remote_busy
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  Test if we have transmitted more bytes over the &n;&t;&t;&t; *  link than its possible to do with the current &n;&t;&t;&t; *  speed and turn-around-time.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|skb-&gt;len
op_plus
id|self-&gt;bofs_count
)paren
OG
id|self-&gt;bytes_left
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;IrDA: Not allowed to transmit more bytes!&bslash;n&quot;
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|self-&gt;tx_list
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *  Switch to NRM_S, this is only possible&n;&t;&t;&t;&t; *  when we are in secondary mode, since we &n;&t;&t;&t;&t; *  must be sure that we don&squot;t miss any RR&n;&t;&t;&t;&t; *  frames&n;&t;&t;&t;&t; */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
r_return
op_minus
id|EPROTO
suffix:semicolon
multiline_comment|/* Try again later */
)brace
id|self-&gt;bytes_left
op_sub_assign
(paren
id|skb-&gt;len
op_plus
id|self-&gt;bofs_count
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Send data with final bit cleared only if window &gt; 1&n;&t;&t;&t; *  and there is more frames to be sent&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|self-&gt;window
OG
l_int|1
)paren
op_logical_and
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;tx_list
)paren
OG
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), window &gt; 1&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_send_data_secondary
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_S
)paren
suffix:semicolon
)brace
r_else
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;(), window &lt;= 1&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_send_data_secondary_final
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unable to send!&bslash;n&quot;
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|self-&gt;tx_list
comma
id|skb
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPROTO
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_nrm_s (event, skb, info)&n; *&n; *    NRM_S (Normal Response Mode as Secondary) state, in this state we are &n; *    expecting to receive frames from the primary station&n; *&n; */
DECL|function|irlap_state_nrm_s
r_static
r_int
id|irlap_state_nrm_s
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|ns_status
suffix:semicolon
r_int
id|nr_status
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), event=%s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RECV_RR_CMD
suffix:colon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t;&t; *  Nr as expected? &n;&t;&t; */
id|nr_status
op_assign
id|irlap_validate_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_status
op_eq
id|NR_EXPECTED
)paren
(brace
r_if
c_cond
(paren
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;tx_list
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|self-&gt;window
OG
l_int|0
)paren
)paren
(brace
id|self-&gt;remote_busy
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_S
)paren
suffix:semicolon
)brace
r_else
(brace
id|self-&gt;remote_busy
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|RSP_FRAME
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|nr_status
op_eq
id|NR_UNEXPECTED
)paren
(brace
id|self-&gt;remote_busy
op_assign
id|FALSE
suffix:semicolon
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|RSP_FRAME
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
multiline_comment|/* Keep state */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
)brace
r_else
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), &quot;
l_string|&quot;invalid nr not implemented!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb
)paren
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_I_CMD
suffix:colon
multiline_comment|/* FIXME: must check for remote_busy below */
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), event=%s nr=%d, vs=%d, ns=%d, &quot;
l_string|&quot;vr=%d, pf=%d&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
comma
id|info-&gt;nr
comma
id|self-&gt;vs
comma
id|info-&gt;ns
comma
id|self-&gt;vr
comma
id|info-&gt;pf
)paren
suffix:semicolon
id|self-&gt;retry_count
op_assign
l_int|0
suffix:semicolon
id|ns_status
op_assign
id|irlap_validate_ns_received
c_func
(paren
id|self
comma
id|info-&gt;ns
)paren
suffix:semicolon
id|nr_status
op_assign
id|irlap_validate_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; *  Check for expected I(nformation) frame&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_EXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_EXPECTED
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t; *  poll bit cleared?&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *  Starting WD-timer here is optional, but&n;&t;&t;&t;&t; *  not recommended. Note 6 IrLAP p. 83&n;&t;&t;&t;&t; */
multiline_comment|/* irda_start_timer( WD_TIMER, self-&gt;wd_timeout); */
multiline_comment|/* Keep state, do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; *  We should wait before sending RR, and&n;&t;&t;&t;&t; *  also before changing to XMIT_S&n;&t;&t;&t;&t; *  state. (note 1, IrLAP p. 82) &n;&t;&t;&t;&t; */
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *  Any pending data requests?&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;tx_list
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|self-&gt;window
OG
l_int|0
)paren
)paren
(brace
id|self-&gt;ack_required
op_assign
id|TRUE
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_S
)paren
suffix:semicolon
)brace
r_else
(brace
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|RSP_FRAME
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
multiline_comment|/* Keep the state */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
)brace
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; *  Check for Unexpected next to send (Ns)&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_UNEXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_EXPECTED
)paren
)paren
(brace
multiline_comment|/* Unexpected next to send, with final bit cleared */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|CMD_FRAME
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
)brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; *  Unexpected Next to Receive(NR) ?&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns_status
op_eq
id|NS_EXPECTED
)paren
op_logical_and
(paren
id|nr_status
op_eq
id|NR_UNEXPECTED
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pf
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;RECV_I_RSP: frame(s) lost&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/* Resend rejected frames */
id|irlap_resend_rejected_frames
c_func
(paren
id|self
comma
id|RSP_FRAME
)paren
suffix:semicolon
multiline_comment|/* Keep state, do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *  This is not documented in IrLAP!! Unexpected NR&n;&t;&t;&t; *  with poll bit cleared&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|self-&gt;vr
op_assign
(paren
id|self-&gt;vr
op_plus
l_int|1
)paren
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* Update Nr received */
id|irlap_update_nr_received
c_func
(paren
id|self
comma
id|info-&gt;nr
)paren
suffix:semicolon
multiline_comment|/* Keep state, do not move this line */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
id|irlap_data_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ret
op_eq
id|NR_INVALID
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;NRM_S, NR_INVALID not implemented!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
id|NS_INVALID
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;NRM_S, NS_INVALID not implemented!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_UI_FRAME
suffix:colon
multiline_comment|/* &n;&t;&t; *  poll bit cleared?&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pf
)paren
(brace
id|irlap_unit_data_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
multiline_comment|/* Keep state */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; *  Any pending data requests?&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|self-&gt;tx_list
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|self-&gt;window
OG
l_int|0
)paren
op_logical_and
op_logical_neg
id|self-&gt;remote_busy
)paren
(brace
id|irlap_unit_data_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_XMIT_S
)paren
suffix:semicolon
)brace
r_else
(brace
id|irlap_unit_data_indication
c_func
(paren
id|self
comma
id|skb
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|self
comma
id|RSP_FRAME
)paren
suffix:semicolon
id|self-&gt;ack_required
op_assign
id|FALSE
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
multiline_comment|/* Keep the state */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|RECV_SNRM_CMD
suffix:colon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irlap_state_nrm_s: received SNRM cmd&bslash;n&quot;
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_RESET_CHECK
)paren
suffix:semicolon
id|irlap_reset_indication
c_func
(paren
id|self
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WD_TIMER_EXPIRED
suffix:colon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;WD_TIMER_EXPIRED: %ld&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Wait until retry_count * n matches negotiated threshold/&n;&t;&t; *  disconnect time (note 2 in IrLAP p. 82)&n;&t;&t; */
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;retry_count = %d&bslash;n&quot;
comma
id|self-&gt;retry_count
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|self-&gt;retry_count
OL
(paren
id|self-&gt;N2
op_div
l_int|2
)paren
)paren
op_logical_and
(paren
id|self-&gt;retry_count
op_ne
id|self-&gt;N1
op_div
l_int|2
)paren
)paren
(brace
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|self-&gt;retry_count
op_eq
(paren
id|self-&gt;N1
op_div
l_int|2
)paren
)paren
(brace
id|irlap_status_indication
c_func
(paren
id|STATUS_NO_ACTIVITY
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|self-&gt;retry_count
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|self-&gt;retry_count
op_ge
id|self-&gt;N2
op_div
l_int|2
)paren
(brace
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_NO_RESPONSE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RECV_DISC_FRAME
suffix:colon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
l_int|NULL
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;wd_timer
)paren
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECV_DISCOVERY_XID_CMD
suffix:colon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;irlap_state_nrm_s: got event RECV_DISCOVER_XID_CMD!&bslash;n&quot;
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;final_timer
)paren
suffix:semicolon
id|irlap_apply_default_connection_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Always switch state before calling upper layers */
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NDM
)paren
suffix:semicolon
id|irlap_disconnect_indication
c_func
(paren
id|self
comma
id|LAP_DISC_INDICATION
)paren
suffix:semicolon
macro_line|#if 0
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_session
)paren
suffix:semicolon
id|irlap_send_rr_frame
c_func
(paren
id|RSP_FRAME
)paren
suffix:semicolon
id|irda_start_timer
c_func
(paren
id|WD_TIMER
comma
id|self-&gt;wd_timeout
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %d, (%s)&bslash;n&quot;
comma
id|event
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlap_state_sclose (self, event, skb, info)&n; *&n; *    &n; *&n; */
DECL|function|irlap_state_sclose
r_static
r_int
id|irlap_state_sclose
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Not implemented!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|irlap_state_reset_check
r_static
r_int
id|irlap_state_reset_check
c_func
(paren
r_struct
id|irlap_cb
op_star
id|self
comma
id|IRLAP_EVENT
id|event
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|irlap_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), event=%s&bslash;n&quot;
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENODEV
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|LAP_MAGIC
comma
r_return
op_minus
id|EBADR
suffix:semicolon
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|RESET_RESPONSE
suffix:colon
id|irlap_send_ua_response_frame
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_rx
)paren
suffix:semicolon
id|irlap_initiate_connection_state
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|WD_TIMEOUT
)paren
suffix:semicolon
id|irlap_flush_all_queues
c_func
(paren
id|self
)paren
suffix:semicolon
id|irlap_next_state
c_func
(paren
id|self
comma
id|LAP_NRM_S
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DISCONNECT_REQUEST
suffix:colon
id|irlap_wait_min_turn_around
c_func
(paren
id|self
comma
op_amp
id|self-&gt;qos_tx
)paren
suffix:semicolon
multiline_comment|/* irlap_send_rd_frame(self); */
id|irlap_start_wd_timer
c_func
(paren
id|self
comma
id|WD_TIMEOUT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unknown event %d, (%s)&bslash;n&quot;
comma
id|event
comma
id|irlap_event
(braket
id|event
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
eof
