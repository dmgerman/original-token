multiline_comment|/*********************************************************************&n; *                &n; * Filename:      discovery.c&n; * Version:       0.1&n; * Description:   Routines for handling discoveries at the IrLMP layer&n; * Status:        Experimental.&n; * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Created at:    Tue Apr  6 15:33:50 1999&n; * Modified at:   Sat Oct  9 17:11:31 1999&n; * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Modified at:   Fri May 28  3:11 CST 1999&n; * Modified by:   Horst von Brand &lt;vonbrand@sleipnir.valparaiso.cl&gt;&n; * &n; *     Copyright (c) 1999 Dag Brattli, All Rights Reserved.&n; *     &n; *     This program is free software; you can redistribute it and/or &n; *     modify it under the terms of the GNU General Public License as &n; *     published by the Free Software Foundation; either version 2 of &n; *     the License, or (at your option) any later version.&n; * &n; *     This program is distributed in the hope that it will be useful,&n; *     but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the&n; *     GNU General Public License for more details.&n; * &n; *     You should have received a copy of the GNU General Public License &n; *     along with this program; if not, write to the Free Software &n; *     Foundation, Inc., 59 Temple Place, Suite 330, Boston, &n; *     MA 02111-1307 USA&n; *     &n; ********************************************************************/
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/irlmp.h&gt;
macro_line|#include &lt;net/irda/discovery.h&gt;
multiline_comment|/*&n; * Function irlmp_add_discovery (cachelog, discovery)&n; *&n; *    Add a new discovery to the cachelog, and remove any old discoveries&n; *    from the same device&n; *&n; * Note : we try to preserve the time this device was *first* discovered&n; * (as opposed to the time of last discovery used for cleanup). This is&n; * used by clients waiting for discovery events to tell if the device&n; * discovered is &quot;new&quot; or just the same old one. They can&squot;t rely there&n; * on a binary flag (new/old), because not all discovery events are&n; * propagated to them, and they might not always listen, so they would&n; * miss some new devices popping up...&n; * Jean II&n; */
DECL|function|irlmp_add_discovery
r_void
id|irlmp_add_discovery
c_func
(paren
id|hashbin_t
op_star
id|cachelog
comma
id|discovery_t
op_star
r_new
)paren
(brace
id|discovery_t
op_star
id|discovery
comma
op_star
id|node
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Set time of first discovery if node is new (see below) */
r_new
op_member_access_from_pointer
id|first_timestamp
op_assign
r_new
op_member_access_from_pointer
id|timestamp
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irlmp-&gt;log_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Remove all discoveries of devices that has previously been &n;&t; * discovered on the same link with the same name (info), or the &n;&t; * same daddr. We do this since some devices (mostly PDAs) change&n;&t; * their device address between every discovery.&n;&t; */
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|cachelog
)paren
suffix:semicolon
r_while
c_loop
(paren
id|discovery
op_ne
l_int|NULL
)paren
(brace
id|node
op_assign
id|discovery
suffix:semicolon
multiline_comment|/* Be sure to stay one item ahead */
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|cachelog
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|node-&gt;saddr
op_eq
r_new
op_member_access_from_pointer
id|saddr
)paren
op_logical_and
(paren
(paren
id|node-&gt;daddr
op_eq
r_new
op_member_access_from_pointer
id|daddr
)paren
op_logical_or
(paren
id|strcmp
c_func
(paren
id|node-&gt;nickname
comma
r_new
op_member_access_from_pointer
id|nickname
)paren
op_eq
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/* This discovery is a previous discovery &n;&t;&t;&t; * from the same device, so just remove it&n;&t;&t;&t; */
id|hashbin_remove_this
c_func
(paren
id|cachelog
comma
(paren
id|irda_queue_t
op_star
)paren
id|node
)paren
suffix:semicolon
multiline_comment|/* Check if hints bits have changed */
r_if
c_cond
(paren
id|node-&gt;hints.word
op_eq
r_new
op_member_access_from_pointer
id|hints.word
)paren
(brace
multiline_comment|/* Set time of first discovery for this node */
r_new
op_member_access_from_pointer
id|first_timestamp
op_assign
id|node-&gt;first_timestamp
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|node
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Insert the new and updated version */
id|hashbin_insert
c_func
(paren
id|cachelog
comma
(paren
id|irda_queue_t
op_star
)paren
r_new
comma
r_new
op_member_access_from_pointer
id|daddr
comma
l_int|NULL
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irlmp-&gt;log_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_add_discovery_log (cachelog, log)&n; *&n; *    Merge a disovery log into the cachlog.&n; *&n; */
DECL|function|irlmp_add_discovery_log
r_void
id|irlmp_add_discovery_log
c_func
(paren
id|hashbin_t
op_star
id|cachelog
comma
id|hashbin_t
op_star
id|log
)paren
(brace
id|discovery_t
op_star
id|discovery
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  If log is missing this means that IrLAP was unable to perform the&n;&t; *  discovery, so restart discovery again with just the half timeout&n;&t; *  of the normal one.&n;&t; */
r_if
c_cond
(paren
id|log
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* irlmp_start_discovery_timer(irlmp, 150); */
r_return
suffix:semicolon
)brace
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_remove_first
c_func
(paren
id|log
)paren
suffix:semicolon
r_while
c_loop
(paren
id|discovery
op_ne
l_int|NULL
)paren
(brace
id|irlmp_add_discovery
c_func
(paren
id|cachelog
comma
id|discovery
)paren
suffix:semicolon
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_remove_first
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
multiline_comment|/* Delete the now empty log */
id|hashbin_delete
c_func
(paren
id|log
comma
(paren
id|FREE_FUNC
)paren
id|kfree
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_expire_discoveries (log, saddr, force)&n; *&n; *    Go through all discoveries and expire all that has stayed to long&n; *&n; * Note : this assume that IrLAP won&squot;t change its saddr, which&n; * currently is a valid assumption...&n; */
DECL|function|irlmp_expire_discoveries
r_void
id|irlmp_expire_discoveries
c_func
(paren
id|hashbin_t
op_star
id|log
comma
id|__u32
id|saddr
comma
r_int
id|force
)paren
(brace
id|discovery_t
op_star
id|discovery
comma
op_star
id|curr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irlmp-&gt;log_lock
comma
id|flags
)paren
suffix:semicolon
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|log
)paren
suffix:semicolon
r_while
c_loop
(paren
id|discovery
op_ne
l_int|NULL
)paren
(brace
id|curr
op_assign
id|discovery
suffix:semicolon
multiline_comment|/* Be sure to be one item ahead */
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* Test if it&squot;s time to expire this discovery */
r_if
c_cond
(paren
(paren
id|curr-&gt;saddr
op_eq
id|saddr
)paren
op_logical_and
(paren
id|force
op_logical_or
(paren
(paren
id|jiffies
op_minus
id|curr-&gt;timestamp
)paren
OG
id|DISCOVERY_EXPIRE_TIMEOUT
)paren
)paren
)paren
(brace
multiline_comment|/* Tell IrLMP and registered clients about it */
id|irlmp_discovery_expiry
c_func
(paren
id|curr
)paren
suffix:semicolon
multiline_comment|/* Remove it from the log */
id|curr
op_assign
id|hashbin_remove_this
c_func
(paren
id|log
comma
(paren
id|irda_queue_t
op_star
)paren
id|curr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curr
)paren
id|kfree
c_func
(paren
id|curr
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irlmp-&gt;log_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_dump_discoveries (log)&n; *&n; *    Print out all discoveries in log&n; *&n; */
DECL|function|irlmp_dump_discoveries
r_void
id|irlmp_dump_discoveries
c_func
(paren
id|hashbin_t
op_star
id|log
)paren
(brace
id|discovery_t
op_star
id|discovery
suffix:semicolon
id|ASSERT
c_func
(paren
id|log
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|log
)paren
suffix:semicolon
r_while
c_loop
(paren
id|discovery
op_ne
l_int|NULL
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;Discovery:&bslash;n&quot;
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;  daddr=%08x&bslash;n&quot;
comma
id|discovery-&gt;daddr
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;  saddr=%08x&bslash;n&quot;
comma
id|discovery-&gt;saddr
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;  nickname=%s&bslash;n&quot;
comma
id|discovery-&gt;nickname
)paren
suffix:semicolon
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irlmp_copy_discoveries (log, pn, mask)&n; *&n; *    Copy all discoveries in a buffer&n; *&n; * This function implement a safe way for lmp clients to access the&n; * discovery log. The basic problem is that we don&squot;t want the log&n; * to change (add/remove) while the client is reading it. If the&n; * lmp client manipulate directly the hashbin, he is sure to get&n; * into troubles...&n; * The idea is that we copy all the current discovery log in a buffer&n; * which is specific to the client and pass this copy to him. As we&n; * do this operation with the spinlock grabbed, we are safe...&n; * Note : we don&squot;t want those clients to grab the spinlock, because&n; * we have no control on how long they will hold it...&n; * Note : we choose to copy the log in &quot;struct irda_device_info&quot; to&n; * save space...&n; * Note : the client must kfree himself() the log...&n; * Jean II&n; */
DECL|function|irlmp_copy_discoveries
r_struct
id|irda_device_info
op_star
id|irlmp_copy_discoveries
c_func
(paren
id|hashbin_t
op_star
id|log
comma
r_int
op_star
id|pn
comma
id|__u16
id|mask
)paren
(brace
id|discovery_t
op_star
id|discovery
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|irda_device_info
op_star
id|buffer
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|n
suffix:semicolon
id|ASSERT
c_func
(paren
id|pn
op_ne
l_int|NULL
comma
r_return
l_int|NULL
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Check if log is empty */
r_if
c_cond
(paren
id|log
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Save spin lock - spinlock should be discovery specific */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irlmp-&gt;log_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Create the client specific buffer */
id|n
op_assign
id|HASHBIN_GET_SIZE
c_func
(paren
id|log
)paren
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|n
op_star
r_sizeof
(paren
r_struct
id|irda_device_info
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irlmp-&gt;log_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|log
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|discovery
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|i
OL
id|n
)paren
)paren
(brace
multiline_comment|/* Mask out the ones we don&squot;t want */
r_if
c_cond
(paren
id|discovery-&gt;hints.word
op_amp
id|mask
)paren
(brace
multiline_comment|/* Copy discovery information */
id|buffer
(braket
id|i
)braket
dot
id|saddr
op_assign
id|discovery-&gt;saddr
suffix:semicolon
id|buffer
(braket
id|i
)braket
dot
id|daddr
op_assign
id|discovery-&gt;daddr
suffix:semicolon
id|buffer
(braket
id|i
)braket
dot
id|charset
op_assign
id|discovery-&gt;charset
suffix:semicolon
id|buffer
(braket
id|i
)braket
dot
id|hints
(braket
l_int|0
)braket
op_assign
id|discovery-&gt;hints.byte
(braket
l_int|0
)braket
suffix:semicolon
id|buffer
(braket
id|i
)braket
dot
id|hints
(braket
l_int|1
)braket
op_assign
id|discovery-&gt;hints.byte
(braket
l_int|1
)braket
suffix:semicolon
id|strncpy
c_func
(paren
id|buffer
(braket
id|i
)braket
dot
id|info
comma
id|discovery-&gt;nickname
comma
id|NICKNAME_MAX_LEN
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irlmp-&gt;log_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Get the actual number of device in the buffer and return */
op_star
id|pn
op_assign
id|i
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irlmp_find_device (name, saddr)&n; *&n; *    Look through the discovery log at each of the links and try to find &n; *    the device with the given name. Return daddr and saddr. If saddr is&n; *    specified, that look at that particular link only (not impl).&n; */
DECL|function|irlmp_find_device
id|__u32
id|irlmp_find_device
c_func
(paren
id|hashbin_t
op_star
id|cachelog
comma
r_char
op_star
id|name
comma
id|__u32
op_star
id|saddr
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|discovery_t
op_star
id|d
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irlmp-&gt;log_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Look at all discoveries for that link */
id|d
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|cachelog
)paren
suffix:semicolon
r_while
c_loop
(paren
id|d
op_ne
l_int|NULL
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Discovery:&bslash;n&quot;
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;  daddr=%08x&bslash;n&quot;
comma
id|d-&gt;daddr
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;  nickname=%s&bslash;n&quot;
comma
id|d-&gt;nickname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|name
comma
id|d-&gt;nickname
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|saddr
op_assign
id|d-&gt;saddr
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irlmp-&gt;log_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|d-&gt;daddr
suffix:semicolon
)brace
id|d
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|cachelog
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irlmp-&gt;log_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function proc_discovery_read (buf, start, offset, len, unused)&n; *&n; *    Print discovery information in /proc file system&n; *&n; */
DECL|function|discovery_proc_read
r_int
id|discovery_proc_read
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|unused
)paren
(brace
id|discovery_t
op_star
id|discovery
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|hashbin_t
op_star
id|cachelog
op_assign
id|irlmp_get_cachelog
c_func
(paren
)paren
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|irlmp
)paren
r_return
id|len
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;IrLMP: Discovery log:&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irlmp-&gt;log_lock
comma
id|flags
)paren
suffix:semicolon
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|cachelog
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|discovery
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|len
OL
id|length
)paren
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;nickname: %s,&quot;
comma
id|discovery-&gt;nickname
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot; hint: 0x%02x%02x&quot;
comma
id|discovery-&gt;hints.byte
(braket
l_int|0
)braket
comma
id|discovery-&gt;hints.byte
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|discovery-&gt;hints.byte
(braket
l_int|0
)braket
op_amp
id|HINT_PNP
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;PnP Compatible &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;hints.byte
(braket
l_int|0
)braket
op_amp
id|HINT_PDA
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;PDA/Palmtop &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;hints.byte
(braket
l_int|0
)braket
op_amp
id|HINT_COMPUTER
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Computer &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;hints.byte
(braket
l_int|0
)braket
op_amp
id|HINT_PRINTER
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Printer &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;hints.byte
(braket
l_int|0
)braket
op_amp
id|HINT_MODEM
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Modem &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;hints.byte
(braket
l_int|0
)braket
op_amp
id|HINT_FAX
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Fax &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;hints.byte
(braket
l_int|0
)braket
op_amp
id|HINT_LAN
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;LAN Access &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;hints.byte
(braket
l_int|1
)braket
op_amp
id|HINT_TELEPHONY
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Telephony &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;hints.byte
(braket
l_int|1
)braket
op_amp
id|HINT_FILE_SERVER
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;File Server &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;hints.byte
(braket
l_int|1
)braket
op_amp
id|HINT_COMM
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;IrCOMM &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discovery-&gt;hints.byte
(braket
l_int|1
)braket
op_amp
id|HINT_OBEX
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;IrOBEX &quot;
)paren
suffix:semicolon
macro_line|#endif&t;&t;
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;, saddr: 0x%08x&quot;
comma
id|discovery-&gt;saddr
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;, daddr: 0x%08x&bslash;n&quot;
comma
id|discovery-&gt;daddr
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|discovery
op_assign
(paren
id|discovery_t
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|cachelog
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irlmp-&gt;log_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
eof
