multiline_comment|/*********************************************************************&n; *                &n; * Filename:      qos.c&n; * Version:       0.1&n; * Description:   IrLAP QoS negotiation&n; * Status:        Experimental.&n; * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Created at:    Tue Sep  9 00:00:26 1997&n; * Modified at:   Sat Dec 12 12:21:42 1998&n; * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * &n; *     Copyright (c) 1998 Dag Brattli &lt;dagb@cs.uit.no&gt;, All Rights Reserved.&n; *     &n; *     This program is free software; you can redistribute it and/or &n; *     modify it under the terms of the GNU General Public License as &n; *     published by the Free Software Foundation; either version 2 of &n; *     the License, or (at your option) any later version.&n; *&n; *     Neither Dag Brattli nor University of Troms&#xfffd; admit liability nor&n; *     provide warranty for any of this software. This material is &n; *     provided &quot;AS-IS&quot; and at no charge.&n; *&n; ********************************************************************/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/qos.h&gt;
macro_line|#include &lt;net/irda/irlap.h&gt;
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
macro_line|#include &lt;net/irda/irlap_comp.h&gt;
macro_line|#include &quot;../../drivers/net/zlib.h&quot;
DECL|macro|CI_BZIP2
mdefine_line|#define CI_BZIP2  27 /* Random pick */
macro_line|#endif
DECL|variable|min_turn_time
r_int
id|min_turn_time
(braket
)braket
op_assign
(brace
l_int|10000
comma
l_int|5000
comma
l_int|1000
comma
l_int|500
comma
l_int|100
comma
l_int|50
comma
l_int|10
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|baud_rates
r_int
id|baud_rates
(braket
)braket
op_assign
(brace
l_int|2400
comma
l_int|9600
comma
l_int|19200
comma
l_int|38400
comma
l_int|57600
comma
l_int|115200
comma
l_int|576000
comma
l_int|1152000
comma
l_int|4000000
)brace
suffix:semicolon
DECL|variable|data_size
r_int
id|data_size
(braket
)braket
op_assign
(brace
l_int|64
comma
l_int|128
comma
l_int|256
comma
l_int|512
comma
l_int|1024
comma
l_int|2048
)brace
suffix:semicolon
DECL|variable|add_bofs
r_int
id|add_bofs
(braket
)braket
op_assign
(brace
l_int|48
comma
l_int|24
comma
l_int|12
comma
l_int|5
comma
l_int|3
comma
l_int|2
comma
l_int|1
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|max_turn_time
r_int
id|max_turn_time
(braket
)braket
op_assign
(brace
l_int|500
comma
l_int|250
comma
l_int|100
comma
l_int|50
)brace
suffix:semicolon
DECL|variable|link_disc_time
r_int
id|link_disc_time
(braket
)braket
op_assign
(brace
l_int|3
comma
l_int|8
comma
l_int|12
comma
l_int|16
comma
l_int|20
comma
l_int|25
comma
l_int|30
comma
l_int|40
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
DECL|variable|compression
r_int
id|compression
(braket
)braket
op_assign
(brace
id|CI_BZIP2
comma
id|CI_DEFLATE
comma
id|CI_DEFLATE_DRAFT
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Function irda_qos_compute_intersection (qos, new)&n; *&n; *    Compute the intersection of the old QoS capabilites with new ones&n; *&n; */
DECL|function|irda_qos_compute_intersection
r_void
id|irda_qos_compute_intersection
c_func
(paren
r_struct
id|qos_info
op_star
id|qos
comma
r_struct
id|qos_info
op_star
r_new
)paren
(brace
id|ASSERT
c_func
(paren
id|qos
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
r_new
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Apply */
id|qos-&gt;baud_rate.bits
op_and_assign
r_new
op_member_access_from_pointer
id|baud_rate.bits
suffix:semicolon
id|qos-&gt;window_size.bits
op_and_assign
r_new
op_member_access_from_pointer
id|window_size.bits
suffix:semicolon
id|qos-&gt;min_turn_time.bits
op_and_assign
r_new
op_member_access_from_pointer
id|min_turn_time.bits
suffix:semicolon
id|qos-&gt;max_turn_time.bits
op_and_assign
r_new
op_member_access_from_pointer
id|max_turn_time.bits
suffix:semicolon
id|qos-&gt;data_size.bits
op_and_assign
r_new
op_member_access_from_pointer
id|data_size.bits
suffix:semicolon
id|qos-&gt;link_disc_time.bits
op_and_assign
r_new
op_member_access_from_pointer
id|link_disc_time.bits
suffix:semicolon
id|qos-&gt;additional_bofs.bits
op_and_assign
r_new
op_member_access_from_pointer
id|additional_bofs.bits
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
id|qos-&gt;compression.bits
op_and_assign
r_new
op_member_access_from_pointer
id|compression.bits
suffix:semicolon
macro_line|#endif
id|irda_qos_bits_to_value
c_func
(paren
id|qos
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_init_max_qos_capabilies (qos)&n; *&n; *    The purpose of this function is for layers and drivers to be able to&n; *    set the maximum QoS possible and then &quot;and in&quot; their own limitations&n; * &n; */
DECL|function|irda_init_max_qos_capabilies
r_void
id|irda_init_max_qos_capabilies
c_func
(paren
r_struct
id|qos_info
op_star
id|qos
)paren
(brace
multiline_comment|/* &n;&t; *  These are the maximum supported values as specified on pages&n;&t; *  39-43 in IrLAP&n;&t; */
multiline_comment|/* LSB is first byte, MSB is second byte */
id|qos-&gt;baud_rate.bits
op_assign
l_int|0x01ff
suffix:semicolon
id|qos-&gt;window_size.bits
op_assign
l_int|0x7f
suffix:semicolon
id|qos-&gt;min_turn_time.bits
op_assign
l_int|0xff
suffix:semicolon
id|qos-&gt;max_turn_time.bits
op_assign
l_int|0x0f
suffix:semicolon
id|qos-&gt;data_size.bits
op_assign
l_int|0x3f
suffix:semicolon
id|qos-&gt;link_disc_time.bits
op_assign
l_int|0xff
suffix:semicolon
id|qos-&gt;additional_bofs.bits
op_assign
l_int|0xff
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_COMPRESSION&t;
id|qos-&gt;compression.bits
op_assign
l_int|0x03
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Function irlap_negotiate (qos_device, qos_session, skb)&n; *&n; *    Negotiate QoS values, not really that much negotiation :-)&n; *    We just set the QoS capabilities for the peer station&n; *&n; */
DECL|function|irda_qos_negotiate
r_void
id|irda_qos_negotiate
c_func
(paren
r_struct
id|qos_info
op_star
id|qos_rx
comma
r_struct
id|qos_info
op_star
id|qos_tx
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|n
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
r_int
id|comp_seen
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif
id|__u8
id|length
suffix:semicolon
id|__u8
op_star
id|frame
suffix:semicolon
id|__u8
id|final_byte
suffix:semicolon
id|__u8
id|code
suffix:semicolon
id|__u8
id|byte
suffix:semicolon
id|__u16
id|final_word
suffix:semicolon
id|__u16_host_order
id|word
suffix:semicolon
id|ASSERT
c_func
(paren
id|qos_tx
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|qos_rx
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|frame
op_assign
id|skb-&gt;data
suffix:semicolon
r_while
c_loop
(paren
id|n
OL
id|skb-&gt;len
op_minus
l_int|2
)paren
(brace
id|code
op_assign
id|frame
(braket
id|n
op_increment
)braket
suffix:semicolon
multiline_comment|/* Length */
id|length
op_assign
id|frame
(braket
id|n
op_increment
)braket
suffix:semicolon
multiline_comment|/*  &n;&t;&t; *  Get the value, since baud_rate may need two bytes, we&n;&t;&t; *  Just use word size all the time&n;&t;&t; */
r_switch
c_cond
(paren
id|length
)paren
(brace
r_case
l_int|1
suffix:colon
id|byte
op_assign
id|frame
(braket
id|n
op_increment
)braket
suffix:semicolon
id|word.word
op_assign
id|byte
suffix:semicolon
multiline_comment|/* To make things a little easier */
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
macro_line|#ifdef __LITTLE_ENDIAN
id|word.byte
(braket
l_int|0
)braket
op_assign
id|frame
(braket
id|n
op_increment
)braket
suffix:semicolon
id|word.byte
(braket
l_int|1
)braket
op_assign
id|frame
(braket
id|n
op_increment
)braket
suffix:semicolon
macro_line|#else ifdef __BIG_ENDIAN
id|word.byte
(braket
l_int|1
)braket
op_assign
id|frame
(braket
id|n
op_increment
)braket
suffix:semicolon
id|word.byte
(braket
l_int|0
)braket
op_assign
id|frame
(braket
id|n
op_increment
)braket
suffix:semicolon
macro_line|#endif
id|byte
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;Error&bslash;n&quot;
)paren
suffix:semicolon
id|word.word
op_assign
id|byte
op_assign
l_int|0
suffix:semicolon
id|n
op_add_assign
id|length
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|code
)paren
(brace
r_case
id|PI_BAUD_RATE
suffix:colon
multiline_comment|/* &n;&t;&t;&t; *  Stations must agree on baud rate, so calculate&n;                         *  intersection &n;&t;&t;&t; */
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Requested BAUD_RATE: 0x%04x&bslash;n&quot;
comma
id|word.word
)paren
suffix:semicolon
id|final_word
op_assign
id|word.word
op_amp
id|qos_rx-&gt;baud_rate.bits
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Final BAUD_RATE: 0x%04x&bslash;n&quot;
comma
id|final_word
)paren
suffix:semicolon
id|qos_tx-&gt;baud_rate.bits
op_assign
id|final_word
suffix:semicolon
id|qos_rx-&gt;baud_rate.bits
op_assign
id|final_word
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PI_MAX_TURN_TIME
suffix:colon
multiline_comment|/*&n;&t;&t;&t; *  Negotiated independently for each station&n;&t;&t;&t; */
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;MAX_TURN_TIME: %02x&bslash;n&quot;
comma
id|byte
)paren
suffix:semicolon
id|qos_tx-&gt;max_turn_time.bits
op_assign
id|byte
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PI_DATA_SIZE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; *  Negotiated independently for each station&n;&t;&t;&t; */
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;DATA_SIZE: %02x&bslash;n&quot;
comma
id|byte
)paren
suffix:semicolon
id|qos_tx-&gt;data_size.bits
op_assign
id|byte
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PI_WINDOW_SIZE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; *  Negotiated independently for each station&n;&t;&t;&t; */
id|qos_tx-&gt;window_size.bits
op_assign
id|byte
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PI_ADD_BOFS
suffix:colon
multiline_comment|/*&n;&t;&t;&t; *  Negotiated independently for each station&n;&t;&t;&t; */
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;ADD_BOFS: %02x&bslash;n&quot;
comma
id|byte
)paren
suffix:semicolon
id|qos_tx-&gt;additional_bofs.bits
op_assign
id|byte
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PI_MIN_TURN_TIME
suffix:colon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;MIN_TURN_TIME: %02x&bslash;n&quot;
comma
id|byte
)paren
suffix:semicolon
id|qos_tx-&gt;min_turn_time.bits
op_assign
id|byte
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PI_LINK_DISC
suffix:colon
multiline_comment|/*  &n;&t;&t;&t; *  Stations must agree on link disconnect/threshold &n;&t;&t;&t; *  time.&n;&t;&t;&t; */
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;LINK_DISC: %02x&bslash;n&quot;
comma
id|byte
)paren
suffix:semicolon
id|final_byte
op_assign
id|byte
op_amp
id|qos_rx-&gt;link_disc_time.bits
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Final LINK_DISC: %02x&bslash;n&quot;
comma
id|final_byte
)paren
suffix:semicolon
id|qos_tx-&gt;link_disc_time.bits
op_assign
id|final_byte
suffix:semicolon
id|qos_rx-&gt;link_disc_time.bits
op_assign
id|final_byte
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
r_case
id|PI_COMPRESSION
suffix:colon
id|final_byte
op_assign
id|byte
op_amp
id|qos_rx-&gt;compression.bits
suffix:semicolon
id|qos_rx-&gt;compression.bits
op_assign
id|byte
suffix:semicolon
id|qos_tx-&gt;compression.bits
op_assign
id|byte
suffix:semicolon
id|comp_seen
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unknown value&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
r_if
c_cond
(paren
op_logical_neg
id|comp_seen
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), Compression not seen!&bslash;n&quot;
)paren
suffix:semicolon
id|qos_tx-&gt;compression.bits
op_assign
l_int|0x00
suffix:semicolon
id|qos_rx-&gt;compression.bits
op_assign
l_int|0x00
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Convert the negotiated bits to values */
id|irda_qos_bits_to_value
c_func
(paren
id|qos_tx
)paren
suffix:semicolon
id|irda_qos_bits_to_value
c_func
(paren
id|qos_rx
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Setting BAUD_RATE to %d bps.&bslash;n&quot;
comma
id|qos_tx-&gt;baud_rate.value
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Setting DATA_SIZE to %d bytes&bslash;n&quot;
comma
id|qos_tx-&gt;data_size.value
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Setting WINDOW_SIZE to %d&bslash;n&quot;
comma
id|qos_tx-&gt;window_size.value
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Setting XBOFS to %d&bslash;n&quot;
comma
id|qos_tx-&gt;additional_bofs.value
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Setting MAX_TURN_TIME to %d ms.&bslash;n&quot;
comma
id|qos_tx-&gt;max_turn_time.value
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Setting MIN_TURN_TIME to %d usecs.&bslash;n&quot;
comma
id|qos_tx-&gt;min_turn_time.value
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Setting LINK_DISC to %d secs.&bslash;n&quot;
comma
id|qos_tx-&gt;link_disc_time.value
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;Setting COMPRESSION to %d&bslash;n&quot;
comma
id|qos_tx-&gt;compression.value
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Function irlap_insert_negotiation_params (qos, fp)&n; *&n; *    Insert QoS negotiaion pararameters into frame&n; *&n; */
DECL|function|irda_insert_qos_negotiation_params
r_int
id|irda_insert_qos_negotiation_params
c_func
(paren
r_struct
id|qos_info
op_star
id|qos
comma
id|__u8
op_star
id|frame
)paren
(brace
r_int
id|n
suffix:semicolon
id|__u16_host_order
id|word
suffix:semicolon
id|ASSERT
c_func
(paren
id|qos
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|frame
op_ne
l_int|NULL
comma
r_return
l_int|0
suffix:semicolon
)paren
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set baud rate */
r_if
c_cond
(paren
id|qos-&gt;baud_rate.bits
OL
l_int|256
)paren
(brace
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|PI_BAUD_RATE
suffix:semicolon
id|frame
(braket
id|n
op_increment
)braket
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* length 1 */
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|qos-&gt;baud_rate.bits
suffix:semicolon
)brace
r_else
(brace
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|PI_BAUD_RATE
suffix:semicolon
id|frame
(braket
id|n
op_increment
)braket
op_assign
l_int|0x02
suffix:semicolon
multiline_comment|/* length 2 */
multiline_comment|/* &n;&t;&t; *  qos-&gt;baud_rate.bits is in host byte order, so make sure&n;&t;&t; *  we transmit it in little endian format &n;&t;&t; */
id|word.word
op_assign
id|qos-&gt;baud_rate.bits
suffix:semicolon
macro_line|#ifdef __LITTLE_ENDIAN
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|word.byte
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* LSB */
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|word.byte
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* MSB */
macro_line|#else ifdef __BIG_ENDIAN
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|word.byte
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* LSB */
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|word.byte
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* MSB */
macro_line|#endif
)brace
multiline_comment|/* Set Maximum Turn Around Time */
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|PI_MAX_TURN_TIME
suffix:semicolon
id|frame
(braket
id|n
op_increment
)braket
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* length 1 */
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|qos-&gt;max_turn_time.bits
suffix:semicolon
multiline_comment|/* Set data size */
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|PI_DATA_SIZE
suffix:semicolon
id|frame
(braket
id|n
op_increment
)braket
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* length 1 */
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|qos-&gt;data_size.bits
suffix:semicolon
multiline_comment|/* Set window size */
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|PI_WINDOW_SIZE
suffix:semicolon
id|frame
(braket
id|n
op_increment
)braket
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* length 1 */
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|qos-&gt;window_size.bits
suffix:semicolon
multiline_comment|/* Set additional BOFs */
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|PI_ADD_BOFS
suffix:semicolon
id|frame
(braket
id|n
op_increment
)braket
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* length 1 */
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|qos-&gt;additional_bofs.bits
suffix:semicolon
multiline_comment|/* Set minimum turn around time */
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|PI_MIN_TURN_TIME
suffix:semicolon
id|frame
(braket
id|n
op_increment
)braket
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* length 1 */
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|qos-&gt;min_turn_time.bits
suffix:semicolon
multiline_comment|/* Set Link Disconnect/Threshold Time */
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|PI_LINK_DISC
suffix:semicolon
id|frame
(braket
id|n
op_increment
)braket
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* length 1 */
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|qos-&gt;link_disc_time.bits
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
multiline_comment|/* Set compression bits*/
r_if
c_cond
(paren
id|qos-&gt;compression.bits
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;(), inserting compresion bits&bslash;n&quot;
)paren
suffix:semicolon
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|PI_COMPRESSION
suffix:semicolon
id|frame
(braket
id|n
op_increment
)braket
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* length 1 */
id|frame
(braket
id|n
op_increment
)braket
op_assign
id|qos-&gt;compression.bits
suffix:semicolon
)brace
macro_line|#endif
r_return
id|n
suffix:semicolon
)brace
DECL|function|byte_value
r_int
id|byte_value
c_func
(paren
id|__u8
id|byte
comma
r_int
op_star
id|array
)paren
(brace
r_int
id|index
suffix:semicolon
id|ASSERT
c_func
(paren
id|array
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|index
op_assign
id|msb_index
c_func
(paren
id|byte
)paren
suffix:semicolon
r_return
id|index_value
c_func
(paren
id|index
comma
id|array
)paren
suffix:semicolon
)brace
multiline_comment|/* __u8 value_byte( int value, int *array) */
multiline_comment|/* { */
multiline_comment|/* &t;int index; */
multiline_comment|/* &t;__u8 byte; */
multiline_comment|/* &t;index = value_index( value, array); */
multiline_comment|/* &t;byte =  */
multiline_comment|/* } */
multiline_comment|/*&n; * Function msb_index (word)&n; *&n; *    Returns index to most significant bit (MSB) in word&n; *&n; */
DECL|function|msb_index
r_int
id|msb_index
(paren
id|__u16
id|word
)paren
(brace
id|__u16
id|msb
op_assign
l_int|0x8000
suffix:semicolon
r_int
id|index
op_assign
l_int|15
suffix:semicolon
multiline_comment|/* Current MSB */
r_while
c_loop
(paren
id|msb
)paren
(brace
r_if
c_cond
(paren
id|word
op_amp
id|msb
)paren
r_break
suffix:semicolon
multiline_comment|/* Found it! */
id|msb
op_rshift_assign
l_int|1
suffix:semicolon
id|index
op_decrement
suffix:semicolon
)brace
r_return
id|index
suffix:semicolon
)brace
multiline_comment|/*&n; * Function value_index (value, array)&n; *&n; *    Returns the index to the value in the specified array&n; */
DECL|function|value_index
r_int
id|value_index
c_func
(paren
r_int
id|value
comma
r_int
op_star
id|array
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|array
(braket
id|i
)braket
op_eq
id|value
)paren
r_break
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * Function index_value (index, array)&n; *&n; *    Returns value to index in array, easy!&n; *&n; */
DECL|function|index_value
r_int
id|index_value
c_func
(paren
r_int
id|index
comma
r_int
op_star
id|array
)paren
(brace
r_return
id|array
(braket
id|index
)braket
suffix:semicolon
)brace
DECL|function|irda_qos_bits_to_value
r_void
id|irda_qos_bits_to_value
c_func
(paren
r_struct
id|qos_info
op_star
id|qos
)paren
(brace
r_int
id|index
suffix:semicolon
id|ASSERT
c_func
(paren
id|qos
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|index
op_assign
id|msb_index
c_func
(paren
id|qos-&gt;baud_rate.bits
)paren
suffix:semicolon
id|qos-&gt;baud_rate.value
op_assign
id|baud_rates
(braket
id|index
)braket
suffix:semicolon
id|index
op_assign
id|msb_index
c_func
(paren
id|qos-&gt;data_size.bits
)paren
suffix:semicolon
id|qos-&gt;data_size.value
op_assign
id|data_size
(braket
id|index
)braket
suffix:semicolon
id|index
op_assign
id|msb_index
c_func
(paren
id|qos-&gt;window_size.bits
)paren
suffix:semicolon
id|qos-&gt;window_size.value
op_assign
id|index
op_plus
l_int|1
suffix:semicolon
id|index
op_assign
id|msb_index
c_func
(paren
id|qos-&gt;min_turn_time.bits
)paren
suffix:semicolon
id|qos-&gt;min_turn_time.value
op_assign
id|min_turn_time
(braket
id|index
)braket
suffix:semicolon
id|index
op_assign
id|msb_index
c_func
(paren
id|qos-&gt;max_turn_time.bits
)paren
suffix:semicolon
id|qos-&gt;max_turn_time.value
op_assign
id|max_turn_time
(braket
id|index
)braket
suffix:semicolon
id|index
op_assign
id|msb_index
c_func
(paren
id|qos-&gt;link_disc_time.bits
)paren
suffix:semicolon
id|qos-&gt;link_disc_time.value
op_assign
id|link_disc_time
(braket
id|index
)braket
suffix:semicolon
id|index
op_assign
id|msb_index
c_func
(paren
id|qos-&gt;additional_bofs.bits
)paren
suffix:semicolon
id|qos-&gt;additional_bofs.value
op_assign
id|add_bofs
(braket
id|index
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_IRDA_COMPRESSION
id|index
op_assign
id|msb_index
c_func
(paren
id|qos-&gt;compression.bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
l_int|0
)paren
id|qos-&gt;compression.value
op_assign
id|compression
(braket
id|index
)braket
suffix:semicolon
r_else
id|qos-&gt;compression.value
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
eof
