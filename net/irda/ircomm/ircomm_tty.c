multiline_comment|/*********************************************************************&n; *                &n; * Filename:      ircomm_tty.c&n; * Version:       1.0&n; * Description:   IrCOMM serial TTY driver&n; * Status:        Experimental.&n; * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Created at:    Sun Jun  6 21:00:56 1999&n; * Modified at:   Wed Feb 23 00:09:02 2000&n; * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;&n; * Sources:       serial.c and previous IrCOMM work by Takahide Higuchi&n; * &n; *     Copyright (c) 1999-2000 Dag Brattli, All Rights Reserved.&n; *     &n; *     This program is free software; you can redistribute it and/or &n; *     modify it under the terms of the GNU General Public License as &n; *     published by the Free Software Foundation; either version 2 of &n; *     the License, or (at your option) any later version.&n; * &n; *     This program is distributed in the hope that it will be useful,&n; *     but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the&n; *     GNU General Public License for more details.&n; * &n; *     You should have received a copy of the GNU General Public License &n; *     along with this program; if not, write to the Free Software &n; *     Foundation, Inc., 59 Temple Place, Suite 330, Boston, &n; *     MA 02111-1307 USA&n; *     &n; ********************************************************************/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/termios.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/irmod.h&gt;
macro_line|#include &lt;net/irda/ircomm_core.h&gt;
macro_line|#include &lt;net/irda/ircomm_param.h&gt;
macro_line|#include &lt;net/irda/ircomm_tty_attach.h&gt;
macro_line|#include &lt;net/irda/ircomm_tty.h&gt;
r_static
r_int
id|ircomm_tty_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|ircomm_tty_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_int
id|ircomm_tty_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_int
id|ircomm_tty_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|ircomm_tty_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|ircomm_tty_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|ircomm_tty_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|ircomm_tty_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|ircomm_tty_send_xchar
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_char
id|ch
)paren
suffix:semicolon
r_static
r_void
id|ircomm_tty_wait_until_sent
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|timeout
)paren
suffix:semicolon
r_static
r_void
id|ircomm_tty_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|ircomm_tty_do_softint
c_func
(paren
r_void
op_star
id|private_
)paren
suffix:semicolon
r_static
r_void
id|ircomm_tty_shutdown
c_func
(paren
r_struct
id|ircomm_tty_cb
op_star
id|self
)paren
suffix:semicolon
r_static
r_int
id|ircomm_tty_data_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_int
id|ircomm_tty_control_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_void
id|ircomm_tty_flow_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
id|LOCAL_FLOW
id|cmd
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_static
r_int
id|ircomm_tty_read_proc
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|len
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|unused
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
DECL|variable|driver
r_static
r_struct
id|tty_driver
id|driver
suffix:semicolon
DECL|variable|ircomm_tty_refcount
r_static
r_int
id|ircomm_tty_refcount
suffix:semicolon
multiline_comment|/* If we manage several devices */
DECL|variable|ircomm_tty_table
r_static
r_struct
id|tty_struct
op_star
id|ircomm_tty_table
(braket
id|NR_PTYS
)braket
suffix:semicolon
DECL|variable|ircomm_tty_termios
r_static
r_struct
id|termios
op_star
id|ircomm_tty_termios
(braket
id|NR_PTYS
)braket
suffix:semicolon
DECL|variable|ircomm_tty_termios_locked
r_static
r_struct
id|termios
op_star
id|ircomm_tty_termios_locked
(braket
id|NR_PTYS
)braket
suffix:semicolon
DECL|variable|ircomm_tty
id|hashbin_t
op_star
id|ircomm_tty
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * Function ircomm_tty_init()&n; *&n; *    Init IrCOMM TTY layer/driver&n; *&n; */
DECL|function|ircomm_tty_init
r_int
id|__init
id|ircomm_tty_init
c_func
(paren
r_void
)paren
(brace
id|ircomm_tty
op_assign
id|hashbin_new
c_func
(paren
id|HB_LOCAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ircomm_tty
op_eq
l_int|NULL
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), can&squot;t allocate hashbin!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|driver
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_driver
)paren
)paren
suffix:semicolon
id|driver.magic
op_assign
id|TTY_DRIVER_MAGIC
suffix:semicolon
id|driver.driver_name
op_assign
l_string|&quot;ircomm&quot;
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_FS
id|driver.name
op_assign
l_string|&quot;ircomm%d&quot;
suffix:semicolon
macro_line|#else
id|driver.name
op_assign
l_string|&quot;ircomm&quot;
suffix:semicolon
macro_line|#endif
id|driver.major
op_assign
id|IRCOMM_TTY_MAJOR
suffix:semicolon
id|driver.minor_start
op_assign
id|IRCOMM_TTY_MINOR
suffix:semicolon
id|driver.num
op_assign
id|IRCOMM_TTY_PORTS
suffix:semicolon
id|driver.type
op_assign
id|TTY_DRIVER_TYPE_SERIAL
suffix:semicolon
id|driver.subtype
op_assign
id|SERIAL_TYPE_NORMAL
suffix:semicolon
id|driver.init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|driver.init_termios.c_cflag
op_assign
id|B9600
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
op_or
id|CLOCAL
suffix:semicolon
id|driver.flags
op_assign
id|TTY_DRIVER_REAL_RAW
suffix:semicolon
id|driver.refcount
op_assign
op_amp
id|ircomm_tty_refcount
suffix:semicolon
id|driver.table
op_assign
id|ircomm_tty_table
suffix:semicolon
id|driver.termios
op_assign
id|ircomm_tty_termios
suffix:semicolon
id|driver.termios_locked
op_assign
id|ircomm_tty_termios_locked
suffix:semicolon
id|driver.open
op_assign
id|ircomm_tty_open
suffix:semicolon
id|driver.close
op_assign
id|ircomm_tty_close
suffix:semicolon
id|driver.write
op_assign
id|ircomm_tty_write
suffix:semicolon
id|driver.write_room
op_assign
id|ircomm_tty_write_room
suffix:semicolon
id|driver.chars_in_buffer
op_assign
id|ircomm_tty_chars_in_buffer
suffix:semicolon
id|driver.flush_buffer
op_assign
id|ircomm_tty_flush_buffer
suffix:semicolon
id|driver.ioctl
op_assign
id|ircomm_tty_ioctl
suffix:semicolon
id|driver.throttle
op_assign
id|ircomm_tty_throttle
suffix:semicolon
id|driver.unthrottle
op_assign
id|ircomm_tty_unthrottle
suffix:semicolon
id|driver.send_xchar
op_assign
id|ircomm_tty_send_xchar
suffix:semicolon
id|driver.set_termios
op_assign
id|ircomm_tty_set_termios
suffix:semicolon
id|driver.stop
op_assign
id|ircomm_tty_stop
suffix:semicolon
id|driver.start
op_assign
id|ircomm_tty_start
suffix:semicolon
id|driver.hangup
op_assign
id|ircomm_tty_hangup
suffix:semicolon
id|driver.wait_until_sent
op_assign
id|ircomm_tty_wait_until_sent
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|driver.read_proc
op_assign
id|ircomm_tty_read_proc
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
op_amp
id|driver
)paren
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;Couldn&squot;t register serial driver&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|__ircomm_tty_cleanup
r_static
r_void
id|__ircomm_tty_cleanup
c_func
(paren
r_struct
id|ircomm_tty_cb
op_star
id|self
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRCOMM_TTY_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ircomm_tty_shutdown
c_func
(paren
id|self
)paren
suffix:semicolon
id|self-&gt;magic
op_assign
l_int|0
suffix:semicolon
id|kfree
c_func
(paren
id|self
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_tty_cleanup ()&n; *&n; *    Remove IrCOMM TTY layer/driver&n; *&n; */
DECL|function|ircomm_tty_cleanup
r_void
id|ircomm_tty_cleanup
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|tty_unregister_driver
c_func
(paren
op_amp
id|driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), failed to unregister driver&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|hashbin_delete
c_func
(paren
id|ircomm_tty
comma
(paren
id|FREE_FUNC
)paren
id|__ircomm_tty_cleanup
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
multiline_comment|/*&n; * Function ircomm_startup (self)&n; *&n; *    &n; *&n; */
DECL|function|ircomm_tty_startup
r_static
r_int
id|ircomm_tty_startup
c_func
(paren
r_struct
id|ircomm_tty_cb
op_star
id|self
)paren
(brace
id|notify_t
id|notify
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRCOMM_TTY_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Already open */
r_if
c_cond
(paren
id|self-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), already open so break out!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Register with IrCOMM */
id|irda_notify_init
c_func
(paren
op_amp
id|notify
)paren
suffix:semicolon
multiline_comment|/* These callbacks we must handle ourselves */
id|notify.data_indication
op_assign
id|ircomm_tty_data_indication
suffix:semicolon
id|notify.udata_indication
op_assign
id|ircomm_tty_control_indication
suffix:semicolon
id|notify.flow_indication
op_assign
id|ircomm_tty_flow_indication
suffix:semicolon
multiline_comment|/* Use the ircomm_tty interface for these ones */
id|notify.disconnect_indication
op_assign
id|ircomm_tty_disconnect_indication
suffix:semicolon
id|notify.connect_confirm
op_assign
id|ircomm_tty_connect_confirm
suffix:semicolon
id|notify.connect_indication
op_assign
id|ircomm_tty_connect_indication
suffix:semicolon
id|strncpy
c_func
(paren
id|notify.name
comma
l_string|&quot;ircomm_tty&quot;
comma
id|NOTIFY_MAX_NAME
)paren
suffix:semicolon
id|notify.instance
op_assign
id|self
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;ircomm
)paren
(brace
id|self-&gt;ircomm
op_assign
id|ircomm_open
c_func
(paren
op_amp
id|notify
comma
id|self-&gt;service_type
comma
id|self-&gt;line
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;ircomm
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|self-&gt;slsap_sel
op_assign
id|self-&gt;ircomm-&gt;slsap_sel
suffix:semicolon
multiline_comment|/* Connect IrCOMM link with remote device */
id|ret
op_assign
id|ircomm_tty_attach_cable
c_func
(paren
id|self
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), error attaching cable!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|self-&gt;flags
op_or_assign
id|ASYNC_INITIALIZED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_block_til_ready (self, filp)&n; *&n; *    &n; *&n; */
DECL|function|ircomm_tty_block_til_ready
r_static
r_int
id|ircomm_tty_block_til_ready
c_func
(paren
r_struct
id|ircomm_tty_cb
op_star
id|self
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|do_clocal
op_assign
l_int|0
comma
id|extra_count
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|tty
op_assign
id|self-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|SERIAL_TYPE_CALLOUT
)paren
(brace
multiline_comment|/* this is a callout device */
multiline_comment|/* just verify that normal device is not in use */
r_if
c_cond
(paren
id|self-&gt;flags
op_amp
id|ASYNC_NORMAL_ACTIVE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|self-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|self-&gt;flags
op_amp
id|ASYNC_SESSION_LOCKOUT
)paren
op_logical_and
(paren
id|self-&gt;session
op_ne
id|current-&gt;session
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|self-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|self-&gt;flags
op_amp
id|ASYNC_PGRP_LOCKOUT
)paren
op_logical_and
(paren
id|self-&gt;pgrp
op_ne
id|current-&gt;pgrp
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|self-&gt;flags
op_or_assign
id|ASYNC_CALLOUT_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If non-blocking mode is set, or the port is not enabled,&n;&t; * then make the check up front and then exit.&n;&t; */
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
op_logical_or
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
(brace
multiline_comment|/* nonblock mode is set or port is not enabled */
multiline_comment|/* just verify that callout device is not active */
r_if
c_cond
(paren
id|self-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|self-&gt;flags
op_or_assign
id|ASYNC_NORMAL_ACTIVE
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), O_NONBLOCK requested!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|self-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
(brace
r_if
c_cond
(paren
id|self-&gt;normal_termios.c_cflag
op_amp
id|CLOCAL
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), doing CLOCAL!&bslash;n&quot;
)paren
suffix:semicolon
id|do_clocal
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), doing CLOCAL!&bslash;n&quot;
)paren
suffix:semicolon
id|do_clocal
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Wait for carrier detect and the line to become&n;&t; * free (i.e., not in use by the callout).  While we are in&n;&t; * this loop, self-&gt;open_count is dropped by one, so that&n;&t; * mgsl_close() knows when to free things.  We restore it upon&n;&t; * exit, either normal or abnormal.&n;&t; */
id|retval
op_assign
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|self-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;%s(%d):block_til_ready before block on %s open_count=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|tty-&gt;driver.name
comma
id|self-&gt;open_count
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
id|extra_count
op_assign
l_int|1
suffix:semicolon
id|self-&gt;open_count
op_decrement
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|self-&gt;blocked_open
op_increment
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|self-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CBAUD
)paren
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|self-&gt;settings.dte
op_or_assign
id|IRCOMM_RTS
op_plus
id|IRCOMM_DTR
suffix:semicolon
id|ircomm_param_request
c_func
(paren
id|self
comma
id|IRCOMM_DTE
comma
id|TRUE
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
op_logical_or
op_logical_neg
(paren
id|self-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
)paren
(brace
id|retval
op_assign
(paren
id|self-&gt;flags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
ques
c_cond
op_minus
id|EAGAIN
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*  &n;&t;&t; * Check if link is ready now. Even if CLOCAL is&n;&t;&t; * specified, we cannot return before the IrCOMM link is&n;&t;&t; * ready &n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|self-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
op_logical_neg
(paren
id|self-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
op_logical_and
(paren
id|do_clocal
op_logical_or
(paren
id|self-&gt;settings.dce
op_amp
id|IRCOMM_CD
)paren
)paren
op_logical_and
id|self-&gt;state
op_eq
id|IRCOMM_TTY_READY
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(%d):block_til_ready blocking on %s open_count=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|tty-&gt;driver.name
comma
id|self-&gt;open_count
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|self-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|extra_count
)paren
id|self-&gt;open_count
op_increment
suffix:semicolon
id|self-&gt;blocked_open
op_decrement
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;%s(%d):block_til_ready after blocking on %s open_count=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|tty-&gt;driver.name
comma
id|self-&gt;open_count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|self-&gt;flags
op_or_assign
id|ASYNC_NORMAL_ACTIVE
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_tty_open (tty, filp)&n; *&n; *    This routine is called when a particular tty device is opened. This&n; *    routine is mandatory; if this routine is not filled in, the attempted&n; *    open will fail with ENODEV.&n; */
DECL|function|ircomm_tty_open
r_static
r_int
id|ircomm_tty_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|ircomm_tty_cb
op_star
id|self
suffix:semicolon
r_int
id|line
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|line
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|tty-&gt;driver.minor_start
suffix:semicolon
r_if
c_cond
(paren
(paren
id|line
OL
l_int|0
)paren
op_logical_or
(paren
id|line
op_ge
id|IRCOMM_TTY_PORTS
)paren
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Check if instance already exists */
id|self
op_assign
id|hashbin_find
c_func
(paren
id|ircomm_tty
comma
id|line
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self
)paren
(brace
multiline_comment|/* No, so make new instance */
id|self
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ircomm_tty_cb
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self
op_eq
l_int|NULL
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), kmalloc failed!&bslash;n&quot;
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|self
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ircomm_tty_cb
)paren
)paren
suffix:semicolon
id|self-&gt;magic
op_assign
id|IRCOMM_TTY_MAGIC
suffix:semicolon
id|self-&gt;flow
op_assign
id|FLOW_STOP
suffix:semicolon
id|self-&gt;line
op_assign
id|line
suffix:semicolon
id|self-&gt;tqueue.routine
op_assign
id|ircomm_tty_do_softint
suffix:semicolon
id|self-&gt;tqueue.data
op_assign
id|self
suffix:semicolon
id|self-&gt;max_header_size
op_assign
l_int|5
suffix:semicolon
id|self-&gt;max_data_size
op_assign
l_int|64
op_minus
id|self-&gt;max_header_size
suffix:semicolon
id|self-&gt;close_delay
op_assign
l_int|5
op_star
id|HZ
op_div
l_int|10
suffix:semicolon
id|self-&gt;closing_wait
op_assign
l_int|30
op_star
id|HZ
suffix:semicolon
multiline_comment|/* Init some important stuff */
id|init_timer
c_func
(paren
op_amp
id|self-&gt;watchdog_timer
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|self-&gt;open_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|self-&gt;close_wait
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Force TTY into raw mode by default which is usually what&n;&t;&t; * we want for IrCOMM and IrLPT. This way applications will&n;&t;&t; * not have to twiddle with printcap etc.  &n;&t;&t; */
id|tty-&gt;termios-&gt;c_iflag
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;termios-&gt;c_oflag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Insert into hash */
id|hashbin_insert
c_func
(paren
id|ircomm_tty
comma
(paren
id|irda_queue_t
op_star
)paren
id|self
comma
id|line
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|self-&gt;open_count
op_increment
suffix:semicolon
id|tty-&gt;driver_data
op_assign
id|self
suffix:semicolon
id|self-&gt;tty
op_assign
id|tty
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), %s%d, count = %d&bslash;n&quot;
comma
id|tty-&gt;driver.name
comma
id|self-&gt;line
comma
id|self-&gt;open_count
)paren
suffix:semicolon
multiline_comment|/* Not really used by us, but lets do it anyway */
id|self-&gt;tty-&gt;low_latency
op_assign
(paren
id|self-&gt;flags
op_amp
id|ASYNC_LOW_LATENCY
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If the port is the middle of closing, bail out now&n;&t; */
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
op_logical_or
(paren
id|self-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
)paren
(brace
r_if
c_cond
(paren
id|self-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
id|interruptible_sleep_on
c_func
(paren
op_amp
id|self-&gt;close_wait
)paren
suffix:semicolon
multiline_comment|/* MOD_DEC_USE_COUNT; &quot;info-&gt;tty&quot; will cause this? */
macro_line|#ifdef SERIAL_DO_RESTART
r_return
(paren
(paren
id|self-&gt;flags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
ques
c_cond
op_minus
id|EAGAIN
suffix:colon
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
macro_line|#else
r_return
op_minus
id|EAGAIN
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Check if this is a &quot;normal&quot; ircomm device, or an irlpt device */
r_if
c_cond
(paren
id|line
OL
l_int|0x10
)paren
(brace
id|self-&gt;service_type
op_assign
id|IRCOMM_3_WIRE
op_or
id|IRCOMM_9_WIRE
suffix:semicolon
id|self-&gt;settings.service_type
op_assign
id|IRCOMM_9_WIRE
suffix:semicolon
multiline_comment|/* Default */
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), IrCOMM device&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), IrLPT device&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;service_type
op_assign
id|IRCOMM_3_WIRE_RAW
suffix:semicolon
id|self-&gt;settings.service_type
op_assign
id|IRCOMM_3_WIRE_RAW
suffix:semicolon
multiline_comment|/* Default */
)brace
id|ret
op_assign
id|ircomm_tty_startup
c_func
(paren
id|self
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|ret
op_assign
id|ircomm_tty_block_til_ready
c_func
(paren
id|self
comma
id|filp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/* MOD_DEC_USE_COUNT; &quot;info-&gt;tty&quot; will cause this? */
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), returning after block_til_ready with %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|self-&gt;session
op_assign
id|current-&gt;session
suffix:semicolon
id|self-&gt;pgrp
op_assign
id|current-&gt;pgrp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_tty_close (tty, filp)&n; *&n; *    This routine is called when a particular tty device is closed.&n; *&n; */
DECL|function|ircomm_tty_close
r_static
r_void
id|ircomm_tty_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|ircomm_tty_cb
op_star
id|self
op_assign
(paren
r_struct
id|ircomm_tty_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), returning 1&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRCOMM_TTY_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|self-&gt;open_count
op_ne
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Uh, oh.  tty-&gt;count is 1, which means that the tty&n;&t;&t; * structure will be freed.  state-&gt;count should always&n;&t;&t; * be one in these conditions.  If it&squot;s greater than&n;&t;&t; * one, we&squot;ve got real problems, since it means the&n;&t;&t; * serial port won&squot;t be shutdown.&n;&t;&t; */
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), bad serial port count; &quot;
l_string|&quot;tty-&gt;count is 1, state-&gt;count is %d&bslash;n&quot;
comma
id|self-&gt;open_count
)paren
suffix:semicolon
id|self-&gt;open_count
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|self-&gt;open_count
OL
l_int|0
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), bad serial port count for ttys%d: %d&bslash;n&quot;
comma
id|self-&gt;line
comma
id|self-&gt;open_count
)paren
suffix:semicolon
id|self-&gt;open_count
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|self-&gt;open_count
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), open count &gt; 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|self-&gt;flags
op_or_assign
id|ASYNC_CLOSING
suffix:semicolon
multiline_comment|/*&n;&t; * Now we wait for the transmit buffer to clear; and we notify &n;&t; * the line discipline to only process XON/XOFF characters.&n;&t; */
id|tty-&gt;closing
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;closing_wait
op_ne
id|ASYNC_CLOSING_WAIT_NONE
)paren
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
id|self-&gt;closing_wait
)paren
suffix:semicolon
id|ircomm_tty_shutdown
c_func
(paren
id|self
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;closing
op_assign
l_int|0
suffix:semicolon
id|self-&gt;tty
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;blocked_open
)paren
(brace
r_if
c_cond
(paren
id|self-&gt;close_delay
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|self-&gt;close_delay
)paren
suffix:semicolon
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;open_wait
)paren
suffix:semicolon
)brace
id|self-&gt;flags
op_and_assign
op_complement
(paren
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_CALLOUT_ACTIVE
op_or
id|ASYNC_CLOSING
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;close_wait
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_tty_flush_buffer (tty)&n; *&n; *    &n; *&n; */
DECL|function|ircomm_tty_flush_buffer
r_static
r_void
id|ircomm_tty_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|ircomm_tty_cb
op_star
id|self
op_assign
(paren
r_struct
id|ircomm_tty_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRCOMM_TTY_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Let do_softint() do this to avoid race condition with &n;&t; * do_softint() ;-) &n;&t; */
id|queue_task
c_func
(paren
op_amp
id|self-&gt;tqueue
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_tty_do_softint (private_)&n; *&n; *    We use this routine to give the write wakeup to the user at at a&n; *    safe time (as fast as possible after write have completed). This &n; *    can be compared to the Tx interrupt.&n; */
DECL|function|ircomm_tty_do_softint
r_static
r_void
id|ircomm_tty_do_softint
c_func
(paren
r_void
op_star
id|private_
)paren
(brace
r_struct
id|ircomm_tty_cb
op_star
id|self
op_assign
(paren
r_struct
id|ircomm_tty_cb
op_star
)paren
id|private_
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
comma
op_star
id|ctrl_skb
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self
op_logical_or
id|self-&gt;magic
op_ne
id|IRCOMM_TTY_MAGIC
)paren
r_return
suffix:semicolon
id|tty
op_assign
id|self-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
multiline_comment|/* Unlink control buffer */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ctrl_skb
op_assign
id|self-&gt;ctrl_skb
suffix:semicolon
id|self-&gt;ctrl_skb
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Flush control buffer if any */
r_if
c_cond
(paren
id|ctrl_skb
op_logical_and
id|self-&gt;flow
op_eq
id|FLOW_START
)paren
id|ircomm_control_request
c_func
(paren
id|self-&gt;ircomm
comma
id|ctrl_skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;hw_stopped
)paren
r_return
suffix:semicolon
multiline_comment|/* Unlink transmit buffer */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb
op_assign
id|self-&gt;tx_skb
suffix:semicolon
id|self-&gt;tx_skb
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Flush transmit buffer if any */
r_if
c_cond
(paren
id|skb
)paren
id|ircomm_tty_do_event
c_func
(paren
id|self
comma
id|IRCOMM_TTY_DATA_REQUEST
comma
id|skb
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Check if user (still) wants to be waken up */
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(brace
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_tty_write (tty, from_user, buf, count)&n; *&n; *    This routine is called by the kernel to write a series of characters&n; *    to the tty device. The characters may come from user space or kernel&n; *    space. This routine will return the number of characters actually&n; *    accepted for writing. This routine is mandatory.&n; */
DECL|function|ircomm_tty_write
r_static
r_int
id|ircomm_tty_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|ircomm_tty_cb
op_star
id|self
op_assign
(paren
r_struct
id|ircomm_tty_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|tailroom
op_assign
l_int|0
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|size
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), count=%d, hw_stopped=%d&bslash;n&quot;
comma
id|count
comma
id|tty-&gt;hw_stopped
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRCOMM_TTY_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Fetch current transmit buffer */
id|skb
op_assign
id|self-&gt;tx_skb
suffix:semicolon
multiline_comment|/*  &n;&t; * Send out all the data we get, possibly as multiple fragmented&n;&t; * frames, but this will only happen if the data is larger than the&n;&t; * max data size. The normal case however is just the opposite, and&n;&t; * this function may be called multiple times, and will then actually&n;&t; * defragment the data and send it out as one packet as soon as &n;&t; * possible, but at a safer point in time&n;&t; */
r_while
c_loop
(paren
id|count
)paren
(brace
id|size
op_assign
id|count
suffix:semicolon
multiline_comment|/* Adjust data size to the max data size */
r_if
c_cond
(paren
id|size
OG
id|self-&gt;max_data_size
)paren
id|size
op_assign
id|self-&gt;max_data_size
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Do we already have a buffer ready for transmit, or do&n;&t;&t; * we need to allocate a new frame &n;&t;&t; */
r_if
c_cond
(paren
id|skb
)paren
(brace
multiline_comment|/* &n;&t;&t;&t; * Any room for more data at the end of the current &n;&t;&t;&t; * transmit buffer? Cannot use skb_tailroom, since&n;&t;&t;&t; * dev_alloc_skb gives us a larger skb than we &n;&t;&t;&t; * requested&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|tailroom
op_assign
(paren
id|self-&gt;max_data_size
op_minus
id|skb-&gt;len
)paren
)paren
OG
l_int|0
)paren
(brace
multiline_comment|/* Adjust data to tailroom */
r_if
c_cond
(paren
id|size
OG
id|tailroom
)paren
id|size
op_assign
id|tailroom
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &n;&t;&t;&t;&t; * Current transmit frame is full, so break &n;&t;&t;&t;&t; * out, so we can send it as soon as possible&n;&t;&t;&t;&t; */
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Prepare a full sized frame */
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|self-&gt;max_data_size
op_plus
id|self-&gt;max_header_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
id|self-&gt;max_header_size
)paren
suffix:semicolon
id|self-&gt;tx_skb
op_assign
id|skb
suffix:semicolon
)brace
multiline_comment|/* Copy data */
r_if
c_cond
(paren
id|from_user
)paren
id|copy_from_user
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|size
)paren
comma
id|buf
op_plus
id|len
comma
id|size
)paren
suffix:semicolon
r_else
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|size
)paren
comma
id|buf
op_plus
id|len
comma
id|size
)paren
suffix:semicolon
id|count
op_sub_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*     &n;&t; * Schedule a new thread which will transmit the frame as soon&n;&t; * as possible, but at a safe point in time. We do this so the&n;&t; * &quot;user&quot; can give us data multiple times, as PPP does (because of&n;&t; * its 256 byte tx buffer). We will then defragment and send out&n;&t; * all this data as one single packet.  &n;&t; */
id|queue_task
c_func
(paren
op_amp
id|self-&gt;tqueue
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_tty_write_room (tty)&n; *&n; *    This routine returns the numbers of characters the tty driver will&n; *    accept for queuing to be written. This number is subject to change as&n; *    output buffers get emptied, or if the output flow control is acted.&n; */
DECL|function|ircomm_tty_write_room
r_static
r_int
id|ircomm_tty_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|ircomm_tty_cb
op_star
id|self
op_assign
(paren
r_struct
id|ircomm_tty_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRCOMM_TTY_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Check if we are allowed to transmit any data */
r_if
c_cond
(paren
id|tty-&gt;hw_stopped
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;tx_skb
)paren
id|ret
op_assign
id|self-&gt;max_data_size
op_minus
id|self-&gt;tx_skb-&gt;len
suffix:semicolon
r_else
id|ret
op_assign
id|self-&gt;max_data_size
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), ret=%d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_tty_wait_until_sent (tty, timeout)&n; *&n; *    This routine waits until the device has written out all of the&n; *    characters in its transmitter FIFO.&n; */
DECL|function|ircomm_tty_wait_until_sent
r_static
r_void
id|ircomm_tty_wait_until_sent
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|timeout
)paren
(brace
r_struct
id|ircomm_tty_cb
op_star
id|self
op_assign
(paren
r_struct
id|ircomm_tty_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|orig_jiffies
comma
id|poll_time
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRCOMM_TTY_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|orig_jiffies
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Set poll time to 200 ms */
id|poll_time
op_assign
id|IRDA_MIN
c_func
(paren
id|timeout
comma
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|200
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|self-&gt;tx_skb
op_logical_and
id|self-&gt;tx_skb-&gt;len
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|poll_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|timeout
op_logical_and
id|time_after
c_func
(paren
id|jiffies
comma
id|orig_jiffies
op_plus
id|timeout
)paren
)paren
r_break
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_tty_throttle (tty)&n; *&n; *    This routine notifies the tty driver that input buffers for the line&n; *    discipline are close to full, and it should somehow signal that no&n; *    more characters should be sent to the tty.  &n; */
DECL|function|ircomm_tty_throttle
r_static
r_void
id|ircomm_tty_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|ircomm_tty_cb
op_star
id|self
op_assign
(paren
r_struct
id|ircomm_tty_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRCOMM_TTY_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Software flow control? */
r_if
c_cond
(paren
id|I_IXOFF
c_func
(paren
id|tty
)paren
)paren
id|ircomm_tty_send_xchar
c_func
(paren
id|tty
comma
id|STOP_CHAR
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
multiline_comment|/* Hardware flow control? */
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
(brace
id|self-&gt;settings.dte
op_and_assign
op_complement
id|IRCOMM_RTS
suffix:semicolon
id|self-&gt;settings.dte
op_or_assign
id|IRCOMM_DELTA_RTS
suffix:semicolon
id|ircomm_param_request
c_func
(paren
id|self
comma
id|IRCOMM_DTE
comma
id|TRUE
)paren
suffix:semicolon
)brace
id|ircomm_flow_request
c_func
(paren
id|self-&gt;ircomm
comma
id|FLOW_STOP
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_tty_unthrottle (tty)&n; *&n; *    This routine notifies the tty drivers that it should signals that&n; *    characters can now be sent to the tty without fear of overrunning the&n; *    input buffers of the line disciplines.&n; */
DECL|function|ircomm_tty_unthrottle
r_static
r_void
id|ircomm_tty_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|ircomm_tty_cb
op_star
id|self
op_assign
(paren
r_struct
id|ircomm_tty_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRCOMM_TTY_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Using software flow control? */
r_if
c_cond
(paren
id|I_IXOFF
c_func
(paren
id|tty
)paren
)paren
(brace
id|ircomm_tty_send_xchar
c_func
(paren
id|tty
comma
id|START_CHAR
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Using hardware flow control? */
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
(brace
id|self-&gt;settings.dte
op_or_assign
(paren
id|IRCOMM_RTS
op_or
id|IRCOMM_DELTA_RTS
)paren
suffix:semicolon
id|ircomm_param_request
c_func
(paren
id|self
comma
id|IRCOMM_DTE
comma
id|TRUE
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), FLOW_START&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ircomm_flow_request
c_func
(paren
id|self-&gt;ircomm
comma
id|FLOW_START
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_tty_chars_in_buffer (tty)&n; *&n; *    Indicates if there are any data in the buffer&n; *&n; */
DECL|function|ircomm_tty_chars_in_buffer
r_static
r_int
id|ircomm_tty_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|ircomm_tty_cb
op_star
id|self
op_assign
(paren
r_struct
id|ircomm_tty_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRCOMM_TTY_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;tx_skb
)paren
id|len
op_assign
id|self-&gt;tx_skb-&gt;len
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|ircomm_tty_shutdown
r_static
r_void
id|ircomm_tty_shutdown
c_func
(paren
r_struct
id|ircomm_tty_cb
op_star
id|self
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRCOMM_TTY_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|self-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|self-&gt;watchdog_timer
)paren
suffix:semicolon
multiline_comment|/* Free parameter buffer */
r_if
c_cond
(paren
id|self-&gt;ctrl_skb
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|self-&gt;ctrl_skb
)paren
suffix:semicolon
id|self-&gt;ctrl_skb
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Free transmit buffer */
r_if
c_cond
(paren
id|self-&gt;tx_skb
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|self-&gt;tx_skb
)paren
suffix:semicolon
id|self-&gt;tx_skb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|ircomm_tty_detach_cable
c_func
(paren
id|self
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;ircomm
)paren
(brace
id|ircomm_close
c_func
(paren
id|self-&gt;ircomm
)paren
suffix:semicolon
id|self-&gt;ircomm
op_assign
l_int|NULL
suffix:semicolon
)brace
id|self-&gt;flags
op_and_assign
op_complement
id|ASYNC_INITIALIZED
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_tty_hangup (tty)&n; *&n; *    This routine notifies the tty driver that it should hangup the tty&n; *    device.&n; * &n; */
DECL|function|ircomm_tty_hangup
r_static
r_void
id|ircomm_tty_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|ircomm_tty_cb
op_star
id|self
op_assign
(paren
r_struct
id|ircomm_tty_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRCOMM_TTY_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
multiline_comment|/* ircomm_tty_flush_buffer(tty); */
id|ircomm_tty_shutdown
c_func
(paren
id|self
)paren
suffix:semicolon
id|self-&gt;flags
op_and_assign
op_complement
(paren
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_CALLOUT_ACTIVE
)paren
suffix:semicolon
id|self-&gt;tty
op_assign
l_int|0
suffix:semicolon
id|self-&gt;open_count
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;open_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_tty_send_xchar (tty, ch)&n; *&n; *    This routine is used to send a high-priority XON/XOFF character to&n; *    the device.&n; */
DECL|function|ircomm_tty_send_xchar
r_static
r_void
id|ircomm_tty_send_xchar
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_char
id|ch
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), not impl&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_tty_start (tty)&n; *&n; *    This routine notifies the tty driver that it resume sending&n; *    characters to the tty device.  &n; */
DECL|function|ircomm_tty_start
r_void
id|ircomm_tty_start
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|ircomm_tty_cb
op_star
id|self
op_assign
(paren
r_struct
id|ircomm_tty_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|ircomm_flow_request
c_func
(paren
id|self-&gt;ircomm
comma
id|FLOW_START
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_tty_stop (tty)&n; *&n; *     This routine notifies the tty driver that it should stop outputting&n; *     characters to the tty device. &n; */
DECL|function|ircomm_tty_stop
r_void
id|ircomm_tty_stop
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|ircomm_tty_cb
op_star
id|self
op_assign
(paren
r_struct
id|ircomm_tty_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRCOMM_TTY_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ircomm_flow_request
c_func
(paren
id|self-&gt;ircomm
comma
id|FLOW_STOP
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_check_modem_status (self)&n; *&n; *    Check for any changes in the DCE&squot;s line settings. This function should&n; *    be called whenever the dce parameter settings changes, to update the&n; *    flow control settings and other things&n; */
DECL|function|ircomm_tty_check_modem_status
r_void
id|ircomm_tty_check_modem_status
c_func
(paren
r_struct
id|ircomm_tty_cb
op_star
id|self
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
id|status
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRCOMM_TTY_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|tty
op_assign
id|self-&gt;tty
suffix:semicolon
id|status
op_assign
id|self-&gt;settings.dce
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|IRCOMM_DCE_DELTA_ANY
)paren
(brace
multiline_comment|/*wake_up_interruptible(&amp;self-&gt;delta_msr_wait);*/
)brace
r_if
c_cond
(paren
(paren
id|self-&gt;flags
op_amp
id|ASYNC_CHECK_CD
)paren
op_logical_and
(paren
id|status
op_amp
id|IRCOMM_DELTA_CD
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), ircomm%d CD now %s...&bslash;n&quot;
comma
id|self-&gt;line
comma
(paren
id|status
op_amp
id|IRCOMM_CD
)paren
ques
c_cond
l_string|&quot;on&quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|IRCOMM_CD
)paren
(brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;open_wait
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|self-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|self-&gt;flags
op_amp
id|ASYNC_CALLOUT_NOHUP
)paren
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), Doing serial hangup..&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty
)paren
id|tty_hangup
c_func
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/* Hangup will remote the tty, so better break out */
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|self-&gt;flags
op_amp
id|ASYNC_CTS_FLOW
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;hw_stopped
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
id|IRCOMM_CTS
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), CTS tx start...&bslash;n&quot;
)paren
suffix:semicolon
id|tty-&gt;hw_stopped
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Wake up processes blocked on open */
id|wake_up_interruptible
c_func
(paren
op_amp
id|self-&gt;open_wait
)paren
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|self-&gt;tqueue
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|IRCOMM_CTS
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), CTS tx stop...&bslash;n&quot;
)paren
suffix:semicolon
id|tty-&gt;hw_stopped
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * Function ircomm_tty_data_indication (instance, sap, skb)&n; *&n; *    Handle incomming data, and deliver it to the line discipline&n; *&n; */
DECL|function|ircomm_tty_data_indication
r_static
r_int
id|ircomm_tty_data_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|ircomm_tty_cb
op_star
id|self
op_assign
(paren
r_struct
id|ircomm_tty_cb
op_star
)paren
id|instance
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRCOMM_TTY_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;tty
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), no tty!&bslash;n&quot;
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * If we receive data when hardware is stopped then something is wrong.&n;&t; * We try to poll the peers line settings to check if we are up todate.&n;&t; * Devices like WinCE can do this, and since they don&squot;t send any &n;&t; * params, we can just as well declare the hardware for running.&n;&t; */
r_if
c_cond
(paren
id|self-&gt;tty-&gt;hw_stopped
op_logical_and
(paren
id|self-&gt;flow
op_eq
id|FLOW_START
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), polling for line settings!&bslash;n&quot;
)paren
suffix:semicolon
id|ircomm_param_request
c_func
(paren
id|self
comma
id|IRCOMM_POLL
comma
id|TRUE
)paren
suffix:semicolon
multiline_comment|/* We can just as well declare the hardware for running */
id|ircomm_tty_send_initial_parameters
c_func
(paren
id|self
)paren
suffix:semicolon
id|ircomm_tty_link_established
c_func
(paren
id|self
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Just give it over to the line discipline. There is no need to&n;&t; * involve the flip buffers, since we are not running in an interrupt &n;&t; * handler&n;&t; */
id|self-&gt;tty-&gt;ldisc
dot
id|receive_buf
c_func
(paren
id|self-&gt;tty
comma
id|skb-&gt;data
comma
l_int|NULL
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_tty_control_indication (instance, sap, skb)&n; *&n; *    Parse all incomming parameters (easy!)&n; *&n; */
DECL|function|ircomm_tty_control_indication
r_static
r_int
id|ircomm_tty_control_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|ircomm_tty_cb
op_star
id|self
op_assign
(paren
r_struct
id|ircomm_tty_cb
op_star
)paren
id|instance
suffix:semicolon
r_int
id|clen
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRCOMM_TTY_MAGIC
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|clen
op_assign
id|skb-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
id|irda_param_extract_all
c_func
(paren
id|self
comma
id|skb-&gt;data
op_plus
l_int|1
comma
id|IRDA_MIN
c_func
(paren
id|skb-&gt;len
op_minus
l_int|1
comma
id|clen
)paren
comma
op_amp
id|ircomm_param_info
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_tty_flow_indication (instance, sap, cmd)&n; *&n; *    This function is called by IrTTP when it wants us to slow down the&n; *    transmission of data. We just mark the hardware as stopped, and wait&n; *    for IrTTP to notify us that things are OK again.&n; */
DECL|function|ircomm_tty_flow_indication
r_static
r_void
id|ircomm_tty_flow_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
id|LOCAL_FLOW
id|cmd
)paren
(brace
r_struct
id|ircomm_tty_cb
op_star
id|self
op_assign
(paren
r_struct
id|ircomm_tty_cb
op_star
)paren
id|instance
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;magic
op_eq
id|IRCOMM_TTY_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|tty
op_assign
id|self-&gt;tty
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FLOW_START
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), hw start!&bslash;n&quot;
)paren
suffix:semicolon
id|tty-&gt;hw_stopped
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ircomm_tty_do_softint will take care of the rest */
id|queue_task
c_func
(paren
op_amp
id|self-&gt;tqueue
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* If we get here, something is very wrong, better stop */
r_case
id|FLOW_STOP
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), hw stopped!&bslash;n&quot;
)paren
suffix:semicolon
id|tty-&gt;hw_stopped
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|self-&gt;flow
op_assign
id|cmd
suffix:semicolon
)brace
DECL|function|ircomm_tty_line_info
r_static
r_int
id|ircomm_tty_line_info
c_func
(paren
r_struct
id|ircomm_tty_cb
op_star
id|self
comma
r_char
op_star
id|buf
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;State: %s&bslash;n&quot;
comma
id|ircomm_tty_state
(braket
id|self-&gt;state
)braket
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;Service type: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;service_type
op_amp
id|IRCOMM_9_WIRE
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;9_WIRE&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|self-&gt;service_type
op_amp
id|IRCOMM_3_WIRE
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;3_WIRE&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|self-&gt;service_type
op_amp
id|IRCOMM_3_WIRE_RAW
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;3_WIRE_RAW&quot;
)paren
suffix:semicolon
r_else
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;No common service type!&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;Port name: %s&bslash;n&quot;
comma
id|self-&gt;settings.port_name
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;DTE status: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;settings.dte
op_amp
id|IRCOMM_RTS
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;RTS|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;settings.dte
op_amp
id|IRCOMM_DTR
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;DTR|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;settings.dte
)paren
id|ret
op_decrement
suffix:semicolon
multiline_comment|/* remove the last | */
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;DCE status: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;settings.dce
op_amp
id|IRCOMM_CTS
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;CTS|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;settings.dce
op_amp
id|IRCOMM_DSR
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;DSR|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;settings.dce
op_amp
id|IRCOMM_CD
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;CD|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;settings.dce
op_amp
id|IRCOMM_RI
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;RI|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;settings.dce
)paren
id|ret
op_decrement
suffix:semicolon
multiline_comment|/* remove the last | */
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;Configuration: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;settings.null_modem
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;DTE &lt;-&gt; DCE&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;DTE &lt;-&gt; DTE (null modem emulation)&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;Data rate: %d&bslash;n&quot;
comma
id|self-&gt;settings.data_rate
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;Flow control: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;settings.flow_control
op_amp
id|IRCOMM_XON_XOFF_IN
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;XON_XOFF_IN|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;settings.flow_control
op_amp
id|IRCOMM_XON_XOFF_OUT
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;XON_XOFF_OUT|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;settings.flow_control
op_amp
id|IRCOMM_RTS_CTS_IN
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;RTS_CTS_IN|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;settings.flow_control
op_amp
id|IRCOMM_RTS_CTS_OUT
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;RTS_CTS_OUT|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;settings.flow_control
op_amp
id|IRCOMM_DSR_DTR_IN
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;DSR_DTR_IN|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;settings.flow_control
op_amp
id|IRCOMM_DSR_DTR_OUT
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;DSR_DTR_OUT|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;settings.flow_control
op_amp
id|IRCOMM_ENQ_ACK_IN
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;ENQ_ACK_IN|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;settings.flow_control
op_amp
id|IRCOMM_ENQ_ACK_OUT
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;ENQ_ACK_OUT|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;settings.flow_control
)paren
id|ret
op_decrement
suffix:semicolon
multiline_comment|/* remove the last | */
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;Flags: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;flags
op_amp
id|ASYNC_CTS_FLOW
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;ASYNC_CTS_FLOW|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;flags
op_amp
id|ASYNC_CHECK_CD
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;ASYNC_CHECK_CD|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;ASYNC_INITIALIZED|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;flags
op_amp
id|ASYNC_LOW_LATENCY
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;ASYNC_LOW_LATENCY|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;ASYNC_CLOSING|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;flags
op_amp
id|ASYNC_NORMAL_ACTIVE
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;ASYNC_NORMAL_ACTIVE|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;ASYNC_CALLOUT_ACTIVE|&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;flags
)paren
id|ret
op_decrement
suffix:semicolon
multiline_comment|/* remove the last | */
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;Role: %s&bslash;n&quot;
comma
id|self-&gt;client
ques
c_cond
l_string|&quot;client&quot;
suffix:colon
l_string|&quot;server&quot;
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;Open count: %d&bslash;n&quot;
comma
id|self-&gt;open_count
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;Max data size: %d&bslash;n&quot;
comma
id|self-&gt;max_data_size
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;Max header size: %d&bslash;n&quot;
comma
id|self-&gt;max_header_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;tty
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;Hardware: %s&bslash;n&quot;
comma
id|self-&gt;tty-&gt;hw_stopped
ques
c_cond
l_string|&quot;Stopped&quot;
suffix:colon
l_string|&quot;Running&quot;
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Function ircomm_tty_read_proc (buf, start, offset, len, eof, unused)&n; *&n; *    &n; *&n; */
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|ircomm_tty_read_proc
r_static
r_int
id|ircomm_tty_read_proc
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|len
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|unused
)paren
(brace
r_struct
id|ircomm_tty_cb
op_star
id|self
suffix:semicolon
r_int
id|count
op_assign
l_int|0
comma
id|l
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|ircomm_tty_cb
op_star
)paren
id|hashbin_get_first
c_func
(paren
id|ircomm_tty
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|self
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|count
OL
l_int|4000
)paren
)paren
(brace
r_if
c_cond
(paren
id|self-&gt;magic
op_ne
id|IRCOMM_TTY_MAGIC
)paren
r_return
l_int|0
suffix:semicolon
id|l
op_assign
id|ircomm_tty_line_info
c_func
(paren
id|self
comma
id|buf
op_plus
id|count
)paren
suffix:semicolon
id|count
op_add_assign
id|l
suffix:semicolon
r_if
c_cond
(paren
id|count
op_plus
id|begin
OG
id|offset
op_plus
id|len
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
id|count
op_plus
id|begin
OL
id|offset
)paren
(brace
id|begin
op_add_assign
id|count
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
)brace
id|self
op_assign
(paren
r_struct
id|ircomm_tty_cb
op_star
)paren
id|hashbin_get_next
c_func
(paren
id|ircomm_tty
)paren
suffix:semicolon
)brace
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|offset
op_ge
id|count
op_plus
id|begin
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|start
op_assign
id|buf
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
r_return
(paren
(paren
id|len
OL
id|begin
op_plus
id|count
op_minus
id|offset
)paren
ques
c_cond
id|len
suffix:colon
id|begin
op_plus
id|count
op_minus
id|offset
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PROC_FS */
macro_line|#ifdef MODULE
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Dag Brattli &lt;dagb@cs.uit.no&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;IrCOMM serial TTY driver&quot;
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|ircomm_tty_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|ircomm_tty_cleanup
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
