multiline_comment|/*********************************************************************&n; *                &n; * Filename:      irvtd_driver.c&n; * Version:       &n; * Description:   An implementation of &quot;port emulation entity&quot; of IrCOMM&n; * Status:        Experimental.&n; * Author:        Takahide Higuchi &lt;thiguchi@pluto.dti.ne.jp&gt;&n; * Source:        serial.c by Linus Torvalds&n; *                isdn_tty.c by Fritz Elfert&n; *&n; *     Copyright (c) 1998, Takahide Higuchi, &lt;thiguchi@pluto.dti.ne.jp&gt;,&n; *     All Rights Reserved.&n; *&n; *     This program is free software; you can redistribute it and/or&n; *     modify it under the terms of the GNU General Public License as&n; *     published by the Free Software Foundation; either version 2 of&n; *     the License, or (at your option) any later version.&n; *&n; *     I, Takahide Higuchi, provide no warranty for any of this software.&n; *     This material is provided &quot;AS-IS&quot; and at no charge.&n; *&n; ********************************************************************/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/termios.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/irttp.h&gt;
macro_line|#include &lt;net/irda/irvtd.h&gt;
macro_line|#include &lt;net/irda/irvtd_driver.h&gt;
macro_line|#ifndef MIN
DECL|macro|MIN
mdefine_line|#define MIN(a,b)        ((a) &lt; (b) ? (a) : (b))
macro_line|#endif
DECL|macro|DO_RESTART
mdefine_line|#define DO_RESTART
DECL|macro|RELEVANT_IFLAG
mdefine_line|#define RELEVANT_IFLAG(iflag) (iflag &amp; (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
DECL|variable|irvtd_ttyname
r_static
r_char
op_star
id|irvtd_ttyname
op_assign
l_string|&quot;irnine&quot;
suffix:semicolon
DECL|variable|irvtd_drv
DECL|variable|irvtd_callout_driver
r_struct
id|tty_driver
id|irvtd_drv
comma
id|irvtd_callout_driver
suffix:semicolon
DECL|variable|irvtd_table
r_struct
id|tty_struct
op_star
id|irvtd_table
(braket
id|COMM_MAX_TTY
)braket
suffix:semicolon
DECL|variable|irvtd_termios
r_struct
id|termios
op_star
id|irvtd_termios
(braket
id|COMM_MAX_TTY
)braket
suffix:semicolon
DECL|variable|irvtd_termios_locked
r_struct
id|termios
op_star
id|irvtd_termios_locked
(braket
id|COMM_MAX_TTY
)braket
suffix:semicolon
DECL|variable|ircomm_vsd_refcount
r_static
r_int
id|ircomm_vsd_refcount
suffix:semicolon
r_extern
r_struct
id|ircomm_cb
op_star
op_star
id|ircomm
suffix:semicolon
r_extern
r_struct
id|irvtd_cb
op_star
op_star
id|irvtd
suffix:semicolon
multiline_comment|/*&n; * prototypes&n; */
r_int
id|irvtd_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_void
id|irvtd_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_int
id|irvtd_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_void
id|irvtd_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
suffix:semicolon
r_int
id|irvtd_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_int
id|irvtd_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_int
id|irvtd_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_void
id|irvtd_set_termios
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old
)paren
suffix:semicolon
r_void
id|irvtd_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_void
id|irvtd_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_void
id|irvtd_stop
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_void
id|irvtd_start
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_void
id|irvtd_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_void
id|irvtd_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|flush_txbuff
c_func
(paren
r_struct
id|irvtd_cb
op_star
id|info
)paren
suffix:semicolon
r_static
r_void
id|change_speed
c_func
(paren
r_struct
id|irvtd_cb
op_star
id|driver
)paren
suffix:semicolon
r_static
r_void
id|irvtd_write_to_tty
c_func
(paren
r_void
op_star
id|instance
)paren
suffix:semicolon
r_static
r_void
id|irvtd_break
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|break_state
)paren
suffix:semicolon
r_static
r_void
id|irvtd_send_xchar
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_char
id|ch
)paren
suffix:semicolon
macro_line|#if 0
r_static
r_char
op_star
id|rcsid
op_assign
l_string|&quot;$Id: irvtd_driver.c,v 1.13 1998/12/06 10:09:07 takahide Exp $&quot;
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Function ircomm_register_device(void) &n; *   we register &quot;port emulation entity&quot;(see IrCOMM specification) here&n; *   as a tty device.&n; *   it will be called when you insmod.&n; *   ( This function derives from linux/drivers/char/serial.c )&n; */
DECL|function|irvtd_register_ttydriver
r_int
(def_block
id|irvtd_register_ttydriver
c_func
(paren
r_void
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;--&gt;irvtd_register_ttydriver&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* setup virtual serial port device */
multiline_comment|/* Initialize the tty_driver structure ,which is defined in &n;&t;   tty_driver.h */
id|memset
c_func
(paren
op_amp
id|irvtd_drv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_driver
)paren
)paren
suffix:semicolon
id|irvtd_drv.magic
op_assign
id|IRVTD_MAGIC
suffix:semicolon
id|irvtd_drv.name
op_assign
id|irvtd_ttyname
suffix:semicolon
id|irvtd_drv.major
op_assign
id|IRCOMM_MAJOR
suffix:semicolon
id|irvtd_drv.minor_start
op_assign
id|IRVTD_MINOR
suffix:semicolon
id|irvtd_drv.num
op_assign
id|COMM_MAX_TTY
suffix:semicolon
id|irvtd_drv.type
op_assign
id|TTY_DRIVER_TYPE_SERIAL
suffix:semicolon
multiline_comment|/* see tty_driver.h */
id|irvtd_drv.subtype
op_assign
id|IRVTD_TYPE_NORMAL
suffix:semicolon
multiline_comment|/* private type */
multiline_comment|/*&n;&t; * see drivers/char/tty_io.c and termios(3)&n;&t; */
id|irvtd_drv.init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|irvtd_drv.init_termios.c_cflag
op_assign
id|B9600
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
op_or
id|CLOCAL
suffix:semicolon
id|irvtd_drv.flags
op_assign
id|TTY_DRIVER_REAL_RAW
suffix:semicolon
multiline_comment|/* see tty_driver.h */
id|irvtd_drv.refcount
op_assign
op_amp
id|ircomm_vsd_refcount
suffix:semicolon
multiline_comment|/* pointer to the tty data structures */
id|irvtd_drv.table
op_assign
id|irvtd_table
suffix:semicolon
id|irvtd_drv.termios
op_assign
id|irvtd_termios
suffix:semicolon
id|irvtd_drv.termios_locked
op_assign
id|irvtd_termios_locked
suffix:semicolon
multiline_comment|/*&n;         * Interface table from the kernel(tty driver) to the ircomm&n;         * layer&n;         */
id|irvtd_drv.open
op_assign
id|irvtd_open
suffix:semicolon
id|irvtd_drv.close
op_assign
id|irvtd_close
suffix:semicolon
id|irvtd_drv.write
op_assign
id|irvtd_write
suffix:semicolon
id|irvtd_drv.put_char
op_assign
id|irvtd_put_char
suffix:semicolon
id|irvtd_drv.flush_chars
op_assign
id|irvtd_flush_chars
suffix:semicolon
id|irvtd_drv.write_room
op_assign
id|irvtd_write_room
suffix:semicolon
id|irvtd_drv.chars_in_buffer
op_assign
id|irvtd_chars_in_buffer
suffix:semicolon
id|irvtd_drv.flush_buffer
op_assign
id|irvtd_flush_buffer
suffix:semicolon
id|irvtd_drv.ioctl
op_assign
id|irvtd_ioctl
suffix:semicolon
id|irvtd_drv.throttle
op_assign
id|irvtd_throttle
suffix:semicolon
id|irvtd_drv.unthrottle
op_assign
id|irvtd_unthrottle
suffix:semicolon
id|irvtd_drv.set_termios
op_assign
id|irvtd_set_termios
suffix:semicolon
id|irvtd_drv.stop
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*  irvtd_stop; */
id|irvtd_drv.start
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* irvtd_start; */
id|irvtd_drv.hangup
op_assign
id|irvtd_hangup
suffix:semicolon
id|irvtd_drv.send_xchar
op_assign
id|irvtd_send_xchar
suffix:semicolon
id|irvtd_drv.break_ctl
op_assign
id|irvtd_break
suffix:semicolon
id|irvtd_drv.read_proc
op_assign
l_int|NULL
suffix:semicolon
id|irvtd_drv.wait_until_sent
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;         * The callout device is just like normal device except for&n;         * minor number and the subtype.&n;         */
multiline_comment|/* What is difference between callout device and normal device? */
multiline_comment|/* My system dosen&squot;t have /dev/cua??, so we don&squot;t need it? :{| */
id|irvtd_callout_driver
op_assign
id|irvtd_drv
suffix:semicolon
id|irvtd_callout_driver.name
op_assign
l_string|&quot;irninecua&quot;
suffix:semicolon
id|irvtd_callout_driver.minor_start
op_assign
id|IRVTD_CALLOUT_MINOR
suffix:semicolon
id|irvtd_callout_driver.subtype
op_assign
id|IRVTD_TYPE_CALLOUT
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
op_amp
id|irvtd_drv
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;IrCOMM:Couldn&squot;t register tty driver&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
op_amp
id|irvtd_callout_driver
)paren
)paren
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;IrCOMM:Couldn&squot;t register callout tty driver&bslash;n&quot;
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irvtd_register_ttydriver: done.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Function irvtd_unregister_device(void) &n; *   it will be called when you rmmod&n; */
DECL|function|irvtd_unregister_ttydriver
r_void
(def_block
id|irvtd_unregister_ttydriver
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;--&gt; irvtd_unregister_device&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* unregister tty device   */
id|err
op_assign
id|tty_unregister_driver
c_func
(paren
op_amp
id|irvtd_drv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
l_string|&quot;IrCOMM: failed to unregister vtd driver(%d)&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
id|err
op_assign
id|tty_unregister_driver
c_func
(paren
op_amp
id|irvtd_callout_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
l_string|&quot;IrCOMM: failed to unregister vtd_callout driver(%d)&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irvtd_unregister_device --&gt;&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * ----------------------------------------------------------------------&n; * Routines for Virtual tty driver&n; *&n; *   most of infomation is descrived in linux/tty_driver.h, but&n; *   a function ircomm_receive() derives from receive_chars() which is&n; *   in 2.0.30 kernel (driver/char/serial.c).&n; *   if you want to understand them, please see related kernel source &n; *   (and my comments :).&n; * ----------------------------------------------------------------------&n; */
multiline_comment|/*&n; * ----------------------------------------------------------------------&n; * ircomm_receive_data()&n; *&n; * like interrupt handler in the serial.c,we receive data when &n; * ircomm_data_indication comes&n; * ----------------------------------------------------------------------&n; */
multiline_comment|/* &n; * irvtd_write_to_tty&n; * send incoming/queued data to tty&n; */
DECL|function|irvtd_write_to_tty
r_static
r_void
(def_block
id|irvtd_write_to_tty
c_func
(paren
r_void
op_star
id|instance
)paren
(brace
r_int
id|status
comma
id|c
comma
id|flag
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|irvtd_cb
op_star
id|driver
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|instance
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|driver-&gt;tty
suffix:semicolon
multiline_comment|/* does instance still exist ? should be checked */
id|ASSERT
c_func
(paren
id|driver-&gt;magic
op_eq
id|IRVTD_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;rx_disable
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;rx_disable is true:do_nothing..&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|driver-&gt;rxbuff
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|skb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* there&squot;s nothing */
id|IS_SKB
c_func
(paren
id|skb
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
macro_line|#ifdef IRVTD_DEBUG_RX
id|printk
c_func
(paren
l_string|&quot;received data:&quot;
)paren
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb-&gt;len
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|skb-&gt;data
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|status
op_assign
id|driver-&gt;comm-&gt;peer_line_status
op_amp
id|driver-&gt;read_status_mask
suffix:semicolon
multiline_comment|/* &n;&t; * FIXME: we must do ircomm_parse_ctrl() here, instead of &n;&t; * ircomm_common.c!! &n;&t; */
multiline_comment|/* &n;&t; * if there are too many errors which make a character ignored,&n;&t; * drop characters&n;&t; */
r_if
c_cond
(paren
id|status
op_amp
id|driver-&gt;ignore_status_mask
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;:some error:ignore characters.&bslash;n&quot;
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|c
op_assign
id|MIN
c_func
(paren
id|skb-&gt;len
comma
(paren
id|TTY_FLIPBUF_SIZE
op_minus
id|tty-&gt;flip.count
)paren
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;skb_len=%d, tty-&gt;flip.count=%d &bslash;n&quot;
comma
(paren
r_int
)paren
id|skb-&gt;len
comma
id|tty-&gt;flip.count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;comm-&gt;peer_break_signal
)paren
(brace
id|driver-&gt;comm-&gt;peer_break_signal
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;handling break....&bslash;n&quot;
)paren
suffix:semicolon
id|flag
op_assign
id|TTY_BREAK
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_SAK
)paren
multiline_comment|/*&n;&t;&t;&t; * do_SAK() seems to be an implementation of the &n;&t;&t;&t; * idea called &quot;Secure Attention Key&quot;,&n;&t;&t;&t; * which seems to be discribed in &quot;Orange book&quot;.&n;&t;&t;&t; * (which is published by U.S.military!!?? ,&n;&t;&t;&t; * see source of do_SAK())&n;&t;&t;&t; *&n;&t;&t;&t; * but what kind of security do we need &n;&t;&t;&t; * when we use infrared communication??? :p)&n;&t;&t;&t; */
id|do_SAK
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|LSR_PE
)paren
id|flag
op_assign
id|TTY_PARITY
suffix:semicolon
r_else
r_if
c_cond
(paren
id|status
op_amp
id|LSR_FE
)paren
id|flag
op_assign
id|TTY_FRAME
suffix:semicolon
r_else
r_if
c_cond
(paren
id|status
op_amp
id|LSR_OE
)paren
id|flag
op_assign
id|TTY_OVERRUN
suffix:semicolon
r_else
id|flag
op_assign
id|TTY_NORMAL
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;writing %d chars to tty&bslash;n&quot;
comma
id|c
)paren
suffix:semicolon
id|memset
c_func
(paren
id|tty-&gt;flip.flag_buf_ptr
comma
id|flag
comma
id|c
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tty-&gt;flip.char_buf_ptr
comma
id|skb-&gt;data
comma
id|c
)paren
suffix:semicolon
id|tty-&gt;flip.flag_buf_ptr
op_add_assign
id|c
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_add_assign
id|c
suffix:semicolon
id|tty-&gt;flip.count
op_add_assign
id|c
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|c
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;len
op_eq
l_int|0
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* queue rest of data again */
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;:retrying frame!&bslash;n&quot;
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|driver-&gt;rxbuff
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * in order to optimize this routine, these two tasks should be&n;&t; * queued in following order&n;&t; * ( see run_task_queue() and queue_task() in tqueue.h&n;&t; */
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|driver-&gt;rxbuff
)paren
)paren
(brace
multiline_comment|/* let me try again! */
id|queue_task
c_func
(paren
op_amp
id|driver-&gt;rx_tqueue
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
)paren
(brace
multiline_comment|/* read your buffer! */
id|queue_task
c_func
(paren
op_amp
id|tty-&gt;flip.tqueue
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|driver-&gt;rxbuff
)paren
OL
id|IRVTD_RX_QUEUE_LOW
op_logical_and
id|driver-&gt;ttp_stoprx
)paren
(brace
id|irttp_flow_request
c_func
(paren
id|driver-&gt;comm-&gt;tsap
comma
id|FLOW_START
)paren
suffix:semicolon
id|driver-&gt;ttp_stoprx
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)def_block
DECL|function|irvtd_receive_data
r_void
(def_block
id|irvtd_receive_data
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|irvtd_cb
op_star
id|driver
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|driver
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|driver-&gt;magic
op_eq
id|IRVTD_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* queue incoming data and make bottom half handler ready */
id|skb_queue_tail
c_func
(paren
op_amp
id|driver-&gt;rxbuff
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|driver-&gt;rxbuff
)paren
op_eq
l_int|1
)paren
(brace
id|irvtd_write_to_tty
c_func
(paren
id|driver
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|driver-&gt;rxbuff
)paren
OG
id|IRVTD_RX_QUEUE_HIGH
)paren
(brace
id|irttp_flow_request
c_func
(paren
id|driver-&gt;comm-&gt;tsap
comma
id|FLOW_STOP
)paren
suffix:semicolon
id|driver-&gt;ttp_stoprx
op_assign
l_int|1
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
)def_block
macro_line|#if 0
r_void
(def_block
id|irvtd_receive_data
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|flag
comma
id|status
suffix:semicolon
id|__u8
id|c
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_struct
id|irvtd_cb
op_star
id|driver
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|driver
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|driver-&gt;magic
op_eq
id|IRVTD_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;rx_disable
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;rx_disable is true:do nothing&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|tty
op_assign
id|driver-&gt;tty
suffix:semicolon
id|status
op_assign
id|driver-&gt;comm-&gt;peer_line_status
op_amp
id|driver-&gt;read_status_mask
suffix:semicolon
id|c
op_assign
id|MIN
c_func
(paren
id|skb-&gt;len
comma
(paren
id|TTY_FLIPBUF_SIZE
op_minus
id|tty-&gt;flip.count
)paren
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;skb_len=%d, tty-&gt;flip.count=%d &bslash;n&quot;
comma
(paren
r_int
)paren
id|skb-&gt;len
comma
id|tty-&gt;flip.count
)paren
suffix:semicolon
macro_line|#ifdef IRVTD_DEBUG_RX
id|printk
c_func
(paren
l_string|&quot;received data:&quot;
)paren
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb-&gt;len
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|skb-&gt;data
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* &n;&t; * if there are too many errors which make a character ignored,&n;&t; * drop characters&n;&t; */
r_if
c_cond
(paren
id|status
op_amp
id|driver-&gt;ignore_status_mask
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;I/O error:ignore characters.&bslash;n&quot;
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver-&gt;comm-&gt;peer_break_signal
)paren
(brace
id|driver-&gt;comm-&gt;peer_break_signal
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;handling break....&bslash;n&quot;
)paren
suffix:semicolon
id|flag
op_assign
id|TTY_BREAK
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_SAK
)paren
multiline_comment|/*&n;&t;&t;&t; * do_SAK() seems to be an implementation of the &n;&t;&t;&t; * idea called &quot;Secure Attention Key&quot;,&n;&t;&t;&t; * which seems to be discribed in &quot;Orange book&quot;.&n;&t;&t;&t; * (which is published by U.S.military!!?? )&n;&t;&t;&t; * see source of do_SAK() but what is &quot;Orange book&quot;!?&n;&t;&t;&t; */
id|do_SAK
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|LSR_PE
)paren
id|flag
op_assign
id|TTY_PARITY
suffix:semicolon
r_else
r_if
c_cond
(paren
id|status
op_amp
id|LSR_FE
)paren
id|flag
op_assign
id|TTY_FRAME
suffix:semicolon
r_else
r_if
c_cond
(paren
id|status
op_amp
id|LSR_OE
)paren
id|flag
op_assign
id|TTY_OVERRUN
suffix:semicolon
r_else
id|flag
op_assign
id|TTY_NORMAL
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;writing %d chars to tty&bslash;n&quot;
comma
id|c
)paren
suffix:semicolon
id|memset
c_func
(paren
id|tty-&gt;flip.flag_buf_ptr
comma
id|flag
comma
id|c
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tty-&gt;flip.char_buf_ptr
comma
id|skb-&gt;data
comma
id|c
)paren
suffix:semicolon
id|tty-&gt;flip.flag_buf_ptr
op_add_assign
id|c
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_add_assign
id|c
suffix:semicolon
id|tty-&gt;flip.count
op_add_assign
id|c
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|c
)paren
suffix:semicolon
id|queue_task_irq_off
c_func
(paren
op_amp
id|tty-&gt;flip.tqueue
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;len
OG
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;:dropping frame!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
id|__FUNCTION__
l_string|&quot;:done&bslash;n&quot;
)paren
suffix:semicolon
)brace
)def_block
macro_line|#endif
multiline_comment|/*&n; * ----------------------------------------------------------------------&n; * indication/confirmation handlers:&n; * they will be registerd in irvtd_startup() to know that we&n; * discovered (or we are discovered by) remote device.&n; * ----------------------------------------------------------------------&n; */
multiline_comment|/* this function is called whed ircomm_attach_cable succeed */
DECL|function|irvtd_attached
r_void
(def_block
id|irvtd_attached
c_func
(paren
r_struct
id|ircomm_cb
op_star
id|comm
)paren
(brace
id|ASSERT
c_func
(paren
id|comm
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|comm-&gt;magic
op_eq
id|IRCOMM_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_attached:sending connect_request&quot;
l_string|&quot; for servicetype(%d)..&bslash;n&quot;
comma
id|comm-&gt;servicetype
)paren
suffix:semicolon
id|ircomm_connect_request
c_func
(paren
id|comm
comma
id|SAR_DISABLE
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * irvtd_connect_confirm()&n; *  ircomm_connect_request which we have send have succeed!&n; */
DECL|function|irvtd_connect_confirm
r_void
(def_block
id|irvtd_connect_confirm
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|qos_info
op_star
id|qos
comma
r_int
id|max_sdu_size
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|irvtd_cb
op_star
id|driver
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|driver
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|driver-&gt;magic
op_eq
id|IRVTD_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * sending initial control parameters here&n;&t; *&n;&t; * TODO: it must be done in ircomm_connect_request()&n;&t; */
macro_line|#if 1
r_if
c_cond
(paren
id|driver-&gt;comm-&gt;servicetype
op_eq
id|THREE_WIRE_RAW
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* do nothing */
id|ircomm_append_ctrl
c_func
(paren
id|driver-&gt;comm
comma
id|SERVICETYPE
)paren
suffix:semicolon
multiline_comment|/* ircomm_append_ctrl(self, DATA_RATE); */
id|ircomm_append_ctrl
c_func
(paren
id|driver-&gt;comm
comma
id|DATA_FORMAT
)paren
suffix:semicolon
id|ircomm_append_ctrl
c_func
(paren
id|driver-&gt;comm
comma
id|FLOW_CONTROL
)paren
suffix:semicolon
id|ircomm_append_ctrl
c_func
(paren
id|driver-&gt;comm
comma
id|XON_XOFF_CHAR
)paren
suffix:semicolon
multiline_comment|/* ircomm_append_ctrl(driver-&gt;comm, ENQ_ACK_CHAR); */
r_switch
c_cond
(paren
id|driver-&gt;comm-&gt;servicetype
)paren
(brace
r_case
id|CENTRONICS
suffix:colon
r_break
suffix:semicolon
r_case
id|NINE_WIRE
suffix:colon
id|ircomm_append_ctrl
c_func
(paren
id|driver-&gt;comm
comma
id|DTELINE_STATE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
id|ircomm_control_request
c_func
(paren
id|driver-&gt;comm
)paren
suffix:semicolon
macro_line|#endif
id|wake_up_interruptible
c_func
(paren
op_amp
id|driver-&gt;open_wait
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * irvtd_connect_indication()&n; *  we are discovered and being requested to connect by remote device !&n; */
DECL|function|irvtd_connect_indication
r_void
id|irvtd_connect_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
r_struct
id|qos_info
op_star
id|qos
comma
r_int
id|max_sdu_size
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|irvtd_cb
op_star
id|driver
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|instance
suffix:semicolon
r_struct
id|ircomm_cb
op_star
id|comm
op_assign
(paren
r_struct
id|ircomm_cb
op_star
)paren
id|sap
suffix:semicolon
id|ASSERT
c_func
(paren
id|driver
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|driver-&gt;magic
op_eq
id|IRVTD_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|comm
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|comm-&gt;magic
op_eq
id|IRCOMM_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irvtd_connect_indication:sending connect_response...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*TODO: connect_response should send initialcontrolparameters! TH*/
id|ircomm_connect_response
c_func
(paren
id|comm
comma
l_int|NULL
comma
id|SAR_DISABLE
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|driver-&gt;open_wait
)paren
suffix:semicolon
)brace
DECL|function|irvtd_disconnect_indication
r_void
(def_block
id|irvtd_disconnect_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
id|LM_REASON
id|reason
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|irvtd_cb
op_star
id|driver
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|instance
suffix:semicolon
id|ASSERT
c_func
(paren
id|driver
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|driver-&gt;tty
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|driver-&gt;magic
op_eq
id|IRVTD_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irvtd_disconnect_indication:&bslash;n&quot;
)paren
suffix:semicolon
id|tty_hangup
c_func
(paren
id|driver-&gt;tty
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * irvtd_control_indication&n; *&n; */
DECL|function|irvtd_control_indication
r_void
(def_block
id|irvtd_control_indication
c_func
(paren
r_void
op_star
id|instance
comma
r_void
op_star
id|sap
comma
id|LOCAL_FLOW
id|flow
)paren
(brace
r_struct
id|irvtd_cb
op_star
id|driver
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|instance
suffix:semicolon
id|__u8
id|pi
suffix:semicolon
multiline_comment|/* instruction of control channel */
id|ASSERT
c_func
(paren
id|driver
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|driver-&gt;magic
op_eq
id|IRVTD_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_control_indication:&bslash;n&quot;
)paren
suffix:semicolon
id|pi
op_assign
id|driver-&gt;comm-&gt;pi
suffix:semicolon
r_switch
c_cond
(paren
id|pi
)paren
(brace
r_case
id|DCELINE_STATE
suffix:colon
id|driver-&gt;msr
op_assign
id|driver-&gt;comm-&gt;peer_dce
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;msr
op_amp
(paren
id|DELTA_CTS
op_or
id|DELTA_DSR
op_or
id|DELTA_RI
op_or
id|DELTA_DCD
)paren
)paren
(brace
r_if
c_cond
(paren
id|driver-&gt;msr
op_amp
id|DELTA_CTS
)paren
(brace
id|driver-&gt;icount.cts
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver-&gt;msr
op_amp
id|DELTA_DSR
)paren
(brace
id|driver-&gt;icount.dsr
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver-&gt;msr
op_amp
id|DELTA_RI
)paren
(brace
id|driver-&gt;icount.rng
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver-&gt;msr
op_amp
id|DELTA_DCD
)paren
(brace
id|driver-&gt;icount.dcd
op_increment
suffix:semicolon
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|driver-&gt;delta_msr_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_CHECK_CD
)paren
op_logical_and
(paren
id|driver-&gt;msr
op_amp
id|DELTA_DCD
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;CD now %s...&bslash;n&quot;
comma
(paren
id|driver-&gt;msr
op_amp
id|MSR_DCD
)paren
ques
c_cond
l_string|&quot;on&quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;msr
op_amp
id|DELTA_DCD
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|driver-&gt;open_wait
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_CALLOUT_NOHUP
)paren
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_control_indication:hangup..&bslash;n&quot;
)paren
suffix:semicolon
id|tty_hangup
c_func
(paren
id|driver-&gt;tty
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|driver-&gt;comm-&gt;flow_ctrl
op_amp
id|USE_CTS
)paren
(brace
r_if
c_cond
(paren
id|driver-&gt;tty-&gt;hw_stopped
)paren
(brace
r_if
c_cond
(paren
id|driver-&gt;msr
op_amp
id|MSR_CTS
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;CTS tx start...&bslash;n&quot;
)paren
suffix:semicolon
id|driver-&gt;cts_stoptx
op_assign
l_int|0
suffix:semicolon
id|driver-&gt;tty-&gt;hw_stopped
op_assign
id|driver-&gt;ttp_stoptx
suffix:semicolon
multiline_comment|/*  &n;&t;&t;&t;&t; * replacement of &n;&t;&t;&t;&t; * rs_sched_event(info, RS_EVENT_WRITE_WAKEUP)&n;&t;&t;&t;&t; * in serial.c&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|driver-&gt;tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|driver-&gt;tty-&gt;ldisc.write_wakeup
)paren
(paren
id|driver-&gt;tty-&gt;ldisc.write_wakeup
)paren
(paren
id|driver-&gt;tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|driver-&gt;tty-&gt;write_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver-&gt;msr
op_amp
id|MSR_CTS
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;CTS tx stop...&quot;
)paren
suffix:semicolon
id|driver-&gt;cts_stoptx
op_assign
l_int|1
suffix:semicolon
id|driver-&gt;tty-&gt;hw_stopped
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* &t;&t;&t;&t;driver-&gt;IER &amp;= ~UART_IER_THRI; */
multiline_comment|/* &t;&t;&t;&t;serial_out(info, UART_IER, info-&gt;IER); */
)brace
)brace
)brace
r_break
suffix:semicolon
r_case
id|TX_READY
suffix:colon
id|driver-&gt;ttp_stoptx
op_assign
l_int|0
suffix:semicolon
id|driver-&gt;tty-&gt;hw_stopped
op_assign
id|driver-&gt;cts_stoptx
suffix:semicolon
multiline_comment|/* &n;&t;&t; * driver-&gt;tty-&gt;write_wait will keep asleep if&n;&t;&t; * our txbuff is not empty.&n;&t;&t; * so if we can really send a packet now,&n;&t;&t; * send it and then wake it up.&n;&t;&t; */
r_if
c_cond
(paren
id|driver-&gt;cts_stoptx
)paren
(brace
r_break
suffix:semicolon
)brace
id|flush_txbuff
c_func
(paren
id|driver
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|driver-&gt;tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|driver-&gt;tty-&gt;ldisc.write_wakeup
)paren
(paren
id|driver-&gt;tty-&gt;ldisc.write_wakeup
)paren
(paren
id|driver-&gt;tty
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TX_BUSY
suffix:colon
id|driver-&gt;ttp_stoptx
op_assign
id|driver-&gt;tty-&gt;hw_stopped
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd:unknown control..&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)def_block
multiline_comment|/*&n; * ----------------------------------------------------------------------&n; * irvtd_open() and friends&n; *&n; * &n; * ----------------------------------------------------------------------&n; */
DECL|function|irvtd_block_til_ready
r_static
r_int
id|irvtd_block_til_ready
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
comma
r_struct
id|irvtd_cb
op_star
id|driver
)paren
(brace
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|do_clocal
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If the device is in the middle of being closed, then block&n;&t; * (sleep) until it&squot;s done, and (when being woke up)then try again.&n;&t; */
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
op_logical_or
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_CLOSING
)paren
)paren
(brace
r_if
c_cond
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_CLOSING
)paren
id|interruptible_sleep_on
c_func
(paren
op_amp
id|driver-&gt;close_wait
)paren
suffix:semicolon
macro_line|#ifdef DO_RESTART
r_if
c_cond
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_HUP_NOTIFY
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_else
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
macro_line|#else
r_return
op_minus
id|EAGAIN
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t; * If this is a callout device, then just make sure the normal&n;&t; * device isn&squot;t being used.&n;&t; */
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|IRVTD_TYPE_CALLOUT
)paren
(brace
r_if
c_cond
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_NORMAL_ACTIVE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_SESSION_LOCKOUT
)paren
op_logical_and
(paren
id|driver-&gt;session
op_ne
id|current-&gt;session
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_PGRP_LOCKOUT
)paren
op_logical_and
(paren
id|driver-&gt;pgrp
op_ne
id|current-&gt;pgrp
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|driver-&gt;flags
op_or_assign
id|IRVTD_ASYNC_CALLOUT_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If non-blocking mode is set, or the port is not enabled,&n;&t; * then make the check up front and then exit.&n;&t; */
r_if
c_cond
(paren
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
op_logical_or
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_CALLOUT_ACTIVE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|driver-&gt;flags
op_or_assign
id|IRVTD_ASYNC_NORMAL_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_CALLOUT_ACTIVE
)paren
(brace
r_if
c_cond
(paren
id|driver-&gt;normal_termios.c_cflag
op_amp
id|CLOCAL
)paren
id|do_clocal
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
id|do_clocal
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We wait until ircomm_connect_request() succeed or&n;&t; *   ircomm_connect_indication comes&n;&t; *&n;&t; * This is what is written in serial.c:&n;&t; * &quot;Block waiting for the carrier detect and the line to become&n;&t; * free (i.e., not in use by the callout).  While we are in&n;&t; * this loop, driver-&gt;count is dropped by one, so that&n;&t; * rs_close() knows when to free things.  We restore it upon&n;&t; * exit, either normal or abnormal.&quot;&n;&t; */
id|retval
op_assign
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|driver-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;block_til_ready before block: line%d, count = %d&bslash;n&quot;
comma
id|driver-&gt;line
comma
id|driver-&gt;count
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
id|driver-&gt;count
op_decrement
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|driver-&gt;blocked_open
op_increment
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|driver-&gt;comm-&gt;state
op_eq
id|COMM_CONN
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t; * signal DTR and RTS&n;&t;&t; */
id|driver-&gt;comm-&gt;dte
op_assign
id|driver-&gt;mcr
op_or_assign
(paren
id|MCR_DTR
op_or
id|MCR_RTS
op_or
id|DELTA_DTR
op_or
id|DELTA_RTS
)paren
suffix:semicolon
id|ircomm_append_ctrl
c_func
(paren
id|driver-&gt;comm
comma
id|DTELINE_STATE
)paren
suffix:semicolon
id|ircomm_control_request
c_func
(paren
id|driver-&gt;comm
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
op_logical_or
op_logical_neg
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_INITIALIZED
)paren
)paren
(brace
macro_line|#ifdef DO_RESTART
r_if
c_cond
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_HUP_NOTIFY
)paren
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_else
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
macro_line|#else
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * if clocal == 0 or received DCD or state become CONN,then break&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
op_logical_neg
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_CLOSING
)paren
op_logical_and
(paren
id|driver-&gt;comm-&gt;state
op_eq
id|COMM_CONN
)paren
op_logical_and
(paren
id|do_clocal
op_logical_or
(paren
id|driver-&gt;msr
op_amp
id|MSR_DCD
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef IRVTD_DEBUG_OPEN
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;block_til_ready blocking:&quot;
l_string|&quot; ttys%d, count = %d&bslash;n&quot;
comma
id|driver-&gt;line
comma
id|driver-&gt;count
)paren
suffix:semicolon
macro_line|#endif
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|driver-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
id|driver-&gt;count
op_increment
suffix:semicolon
id|driver-&gt;blocked_open
op_decrement
suffix:semicolon
macro_line|#ifdef IRVTD_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;block_til_ready after blocking: ttys%d, count = %d&bslash;n&quot;
comma
id|driver-&gt;line
comma
id|driver-&gt;count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|driver-&gt;flags
op_or_assign
id|IRVTD_ASYNC_NORMAL_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|change_speed
r_static
r_void
(def_block
id|change_speed
c_func
(paren
r_struct
id|irvtd_cb
op_star
id|driver
)paren
(brace
r_int
id|cflag
comma
id|cval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver-&gt;tty
op_logical_or
op_logical_neg
id|driver-&gt;tty-&gt;termios
op_logical_or
op_logical_neg
id|driver-&gt;comm
)paren
r_return
suffix:semicolon
id|cflag
op_assign
id|driver-&gt;tty-&gt;termios-&gt;c_cflag
suffix:semicolon
multiline_comment|/*&n;&t; * change baud rate here. but not implemented now&n;&t; */
multiline_comment|/* &n;&t; * byte size and parity&n;&t; */
r_switch
c_cond
(paren
id|cflag
op_amp
id|CSIZE
)paren
(brace
r_case
id|CS5
suffix:colon
id|cval
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS6
suffix:colon
id|cval
op_assign
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS7
suffix:colon
id|cval
op_assign
l_int|0x02
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS8
suffix:colon
id|cval
op_assign
l_int|0x03
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|cval
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* too keep GCC shut... */
)brace
r_if
c_cond
(paren
id|cflag
op_amp
id|CSTOPB
)paren
(brace
multiline_comment|/* use 2 stop bit mode */
id|cval
op_or_assign
l_int|0x04
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cflag
op_amp
id|PARENB
)paren
id|cval
op_or_assign
l_int|0x08
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cflag
op_amp
id|PARODD
)paren
)paren
id|cval
op_or_assign
l_int|0x10
suffix:semicolon
multiline_comment|/* CTS flow control flag and modem status interrupts */
r_if
c_cond
(paren
id|cflag
op_amp
id|CRTSCTS
)paren
id|driver-&gt;comm-&gt;flow_ctrl
op_or_assign
id|USE_CTS
suffix:semicolon
r_else
id|driver-&gt;comm-&gt;flow_ctrl
op_or_assign
op_complement
id|USE_CTS
suffix:semicolon
r_if
c_cond
(paren
id|cflag
op_amp
id|CLOCAL
)paren
id|driver-&gt;flags
op_and_assign
op_complement
id|IRVTD_ASYNC_CHECK_CD
suffix:semicolon
r_else
id|driver-&gt;flags
op_or_assign
id|IRVTD_ASYNC_CHECK_CD
suffix:semicolon
multiline_comment|/*&n;&t; * Set up parity check flag&n;&t; */
id|driver-&gt;read_status_mask
op_assign
id|LSR_OE
suffix:semicolon
r_if
c_cond
(paren
id|I_INPCK
c_func
(paren
id|driver-&gt;tty
)paren
)paren
id|driver-&gt;read_status_mask
op_or_assign
id|LSR_FE
op_or
id|LSR_PE
suffix:semicolon
r_if
c_cond
(paren
id|I_BRKINT
c_func
(paren
id|driver-&gt;tty
)paren
op_logical_or
id|I_PARMRK
c_func
(paren
id|driver-&gt;tty
)paren
)paren
id|driver-&gt;read_status_mask
op_or_assign
id|LSR_BI
suffix:semicolon
id|driver-&gt;ignore_status_mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|I_IGNBRK
c_func
(paren
id|driver-&gt;tty
)paren
)paren
(brace
id|driver-&gt;ignore_status_mask
op_or_assign
id|LSR_BI
suffix:semicolon
id|driver-&gt;read_status_mask
op_or_assign
id|LSR_BI
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we&squot;re ignore parity and break indicators, ignore &n;&t;&t; * overruns too.  (For real raw support).&n;&t;&t; */
r_if
c_cond
(paren
id|I_IGNPAR
c_func
(paren
id|driver-&gt;tty
)paren
)paren
(brace
id|driver-&gt;ignore_status_mask
op_or_assign
id|LSR_OE
op_or
"&bslash;"
id|LSR_PE
op_or
id|LSR_FE
suffix:semicolon
id|driver-&gt;read_status_mask
op_or_assign
id|LSR_OE
op_or
"&bslash;"
id|LSR_PE
op_or
id|LSR_FE
suffix:semicolon
)brace
)brace
id|driver-&gt;comm-&gt;data_format
op_assign
id|cval
suffix:semicolon
id|ircomm_append_ctrl
c_func
(paren
id|driver-&gt;comm
comma
id|DATA_FORMAT
)paren
suffix:semicolon
id|ircomm_append_ctrl
c_func
(paren
id|driver-&gt;comm
comma
id|FLOW_CONTROL
)paren
suffix:semicolon
id|ircomm_control_request
c_func
(paren
id|driver-&gt;comm
)paren
suffix:semicolon
multiline_comment|/* output to IrCOMM here*/
)brace
)def_block
DECL|function|irvtd_startup
r_static
r_int
(def_block
id|irvtd_startup
c_func
(paren
r_struct
id|irvtd_cb
op_star
id|driver
)paren
(brace
r_struct
id|notify_t
id|irvtd_notify
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irvtd_startup:&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize our tx/rx buffer&n;&t; */
r_if
c_cond
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_INITIALIZED
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|skb_queue_head_init
c_func
(paren
op_amp
id|driver-&gt;rxbuff
)paren
suffix:semicolon
id|driver-&gt;rx_tqueue.data
op_assign
id|driver
suffix:semicolon
id|driver-&gt;rx_tqueue.routine
op_assign
id|irvtd_write_to_tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver-&gt;txbuff
)paren
(brace
id|driver-&gt;txbuff
op_assign
id|dev_alloc_skb
c_func
(paren
id|COMM_DEFAULT_DATA_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver-&gt;txbuff
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_open():alloc_skb failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|driver-&gt;txbuff
comma
id|COMM_HEADER_SIZE
)paren
suffix:semicolon
)brace
id|irda_notify_init
c_func
(paren
op_amp
id|irvtd_notify
)paren
suffix:semicolon
id|irvtd_notify.data_indication
op_assign
id|irvtd_receive_data
suffix:semicolon
id|irvtd_notify.connect_confirm
op_assign
id|irvtd_connect_confirm
suffix:semicolon
id|irvtd_notify.connect_indication
op_assign
id|irvtd_connect_indication
suffix:semicolon
id|irvtd_notify.disconnect_indication
op_assign
id|irvtd_disconnect_indication
suffix:semicolon
id|irvtd_notify.flow_indication
op_assign
id|irvtd_control_indication
suffix:semicolon
id|irvtd_notify.instance
op_assign
id|driver
suffix:semicolon
id|strncpy
c_func
(paren
id|irvtd_notify.name
comma
l_string|&quot;irvtd&quot;
comma
id|NOTIFY_MAX_NAME
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * register ourself as a service user of IrCOMM&n;&t; *&t;   TODO: other servicetype(i.e. 3wire,3wireraw) &n;&t; */
id|driver-&gt;comm
op_assign
id|ircomm_attach_cable
c_func
(paren
id|NINE_WIRE
comma
id|irvtd_notify
comma
id|irvtd_attached
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;comm
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * TODO:we have to initialize control-channel here!&n;&t; *   i.e.set something into RTS,CTS and so on....&n;&t; */
r_if
c_cond
(paren
id|driver-&gt;tty
)paren
id|clear_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|driver-&gt;tty-&gt;flags
)paren
suffix:semicolon
id|change_speed
c_func
(paren
id|driver
)paren
suffix:semicolon
id|driver-&gt;flags
op_or_assign
id|IRVTD_ASYNC_INITIALIZED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)def_block
DECL|function|irvtd_open
r_int
(def_block
id|irvtd_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|irvtd_cb
op_star
id|driver
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|line
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irvtd_open():&bslash;n&quot;
)paren
suffix:semicolon
id|line
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|tty-&gt;driver.minor_start
suffix:semicolon
r_if
c_cond
(paren
(paren
id|line
OL
l_int|0
)paren
op_logical_or
(paren
id|line
op_ge
id|COMM_MAX_TTY
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|driver
op_assign
id|irvtd
(braket
id|line
)braket
suffix:semicolon
id|driver-&gt;line
op_assign
id|line
suffix:semicolon
id|driver-&gt;count
op_increment
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_open : %s%d count %d&bslash;n&quot;
comma
id|tty-&gt;driver.name
comma
id|line
comma
id|driver-&gt;count
)paren
suffix:semicolon
id|tty-&gt;driver_data
op_assign
id|driver
suffix:semicolon
id|driver-&gt;tty
op_assign
id|tty
suffix:semicolon
multiline_comment|/* &n;&t; * start up discovering process and ircomm_layer &n;&t; */
id|retval
op_assign
id|irvtd_startup
c_func
(paren
id|driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|retval
op_assign
id|irvtd_block_til_ready
c_func
(paren
id|tty
comma
id|filp
comma
id|driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_open returning after block_til_ready with %d&bslash;n&quot;
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|driver-&gt;count
op_eq
l_int|1
)paren
op_logical_and
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_SPLIT_TERMIOS
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|IRVTD_TYPE_NORMAL
)paren
(brace
op_star
id|tty-&gt;termios
op_assign
id|driver-&gt;normal_termios
suffix:semicolon
)brace
r_else
op_star
id|tty-&gt;termios
op_assign
id|driver-&gt;callout_termios
suffix:semicolon
id|change_speed
c_func
(paren
id|driver
)paren
suffix:semicolon
)brace
id|driver-&gt;session
op_assign
id|current-&gt;session
suffix:semicolon
id|driver-&gt;pgrp
op_assign
id|current-&gt;pgrp
suffix:semicolon
id|driver-&gt;rx_disable
op_assign
l_int|0
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * ----------------------------------------------------------------------&n; * irvtd_close() and friends&n; *&n; * most of this function is stolen from serial.c&n; * ----------------------------------------------------------------------&n; */
DECL|function|irvtd_shutdown
r_static
r_void
id|irvtd_shutdown
c_func
(paren
r_struct
id|irvtd_cb
op_star
id|driver
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_INITIALIZED
)paren
)paren
r_return
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irvtd_shutdown:&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This comment is written in serial.c:&n;&t; *&n;&t; * clear delta_msr_wait queue to avoid mem leaks: we may free the irq&n;&t; * here so the queue might never be waken up&n;&t; */
id|wake_up_interruptible
c_func
(paren
op_amp
id|driver-&gt;delta_msr_wait
)paren
suffix:semicolon
multiline_comment|/* clear DTR and RTS */
r_if
c_cond
(paren
op_logical_neg
id|driver-&gt;tty
op_logical_or
(paren
id|driver-&gt;tty-&gt;termios-&gt;c_cflag
op_amp
id|HUPCL
)paren
)paren
id|driver-&gt;mcr
op_and_assign
op_complement
(paren
id|MCR_DTR
op_or
id|MCR_RTS
)paren
suffix:semicolon
id|driver-&gt;comm-&gt;dte
op_assign
id|driver-&gt;mcr
suffix:semicolon
id|ircomm_append_ctrl
c_func
(paren
id|driver-&gt;comm
comma
id|DTELINE_STATE
)paren
suffix:semicolon
id|ircomm_control_request
c_func
(paren
id|driver-&gt;comm
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Disable interrupts */
r_if
c_cond
(paren
id|driver-&gt;tty
)paren
id|set_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|driver-&gt;tty-&gt;flags
)paren
suffix:semicolon
id|ircomm_detach_cable
c_func
(paren
id|driver-&gt;comm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Free the transmit buffer here &n;&t; */
r_if
c_cond
(paren
id|driver-&gt;txbuff
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|driver-&gt;txbuff
)paren
suffix:semicolon
multiline_comment|/* is it OK?*/
id|driver-&gt;txbuff
op_assign
l_int|NULL
suffix:semicolon
)brace
id|driver-&gt;flags
op_and_assign
op_complement
id|IRVTD_ASYNC_INITIALIZED
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|irvtd_close
r_void
(def_block
id|irvtd_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|irvtd_cb
op_star
id|driver
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|line
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_close:refc(%d)&bslash;n&quot;
comma
id|ircomm_vsd_refcount
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|driver
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|driver-&gt;magic
op_eq
id|IRVTD_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * tty_hung_up_p() is defined as &n;&t; *   &quot; return(filp-&gt;f_op == &amp;hung_up_tty_fops); &quot;&n;&t; *&t; see driver/char/tty_io.c&n;&t; */
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|line
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|tty-&gt;driver.minor_start
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_close : %s%d count %d&bslash;n&quot;
comma
id|tty-&gt;driver.name
comma
id|line
comma
id|driver-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|driver-&gt;count
op_ne
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Uh, oh.  tty-&gt;count is 1, which means that the tty&n;&t;&t; * structure will be freed.  Driver-&gt;count should always&n;&t;&t; * be one in these conditions.  If it&squot;s greater than&n;&t;&t; * one, we&squot;ve got real problems, since it means the&n;&t;&t; * ircomm service layer won&squot;t be shutdown.&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;irvtd_close: bad serial port count;&quot;
l_string|&quot;tty-&gt;count is 1, but driver-&gt;count is %d&bslash;n&quot;
comma
id|driver-&gt;count
)paren
suffix:semicolon
id|driver-&gt;count
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|driver-&gt;count
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;irvtd_close: bad count for line%d: %d&bslash;n&quot;
comma
id|line
comma
id|driver-&gt;count
)paren
suffix:semicolon
id|driver-&gt;count
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver-&gt;count
)paren
(brace
multiline_comment|/* do nothing */
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|driver-&gt;flags
op_or_assign
id|IRVTD_ASYNC_CLOSING
suffix:semicolon
multiline_comment|/*&n;&t; * Save the termios structure, since this port may have&n;&t; * separate termios for callout and dialin.&n;&t; */
r_if
c_cond
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_NORMAL_ACTIVE
)paren
id|driver-&gt;normal_termios
op_assign
op_star
id|tty-&gt;termios
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;flags
op_amp
id|IRVTD_ASYNC_CALLOUT_ACTIVE
)paren
id|driver-&gt;callout_termios
op_assign
op_star
id|tty-&gt;termios
suffix:semicolon
multiline_comment|/*&n;&t; * Now we wait for the transmit buffer to clear; and we notify &n;&t; * the line discipline to only process XON/XOFF characters.&n;&t; */
id|tty-&gt;closing
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;closing_wait
op_ne
id|IRVTD_ASYNC_CLOSING_WAIT_NONE
)paren
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
id|driver-&gt;closing_wait
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Now we stop accepting input.&n;&t; */
id|driver-&gt;rx_disable
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* &n;&t; * Now we flush our buffer.., and shutdown ircomm service layer&n;&t; */
multiline_comment|/* drop our tx/rx buffer */
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_while
c_loop
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|driver-&gt;rxbuff
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|driver-&gt;rxbuff
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* drop users buffer? */
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;closing
op_assign
l_int|0
suffix:semicolon
id|driver-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * ad-hoc coding:&n;&t; * we wait 2 sec before ircomm_detach_cable so that &n;&t; * irttp will send all contents of its queue&n;&t; */
macro_line|#if 0
r_if
c_cond
(paren
id|driver-&gt;blocked_open
)paren
(brace
r_if
c_cond
(paren
id|driver-&gt;close_delay
)paren
(brace
macro_line|#endif
multiline_comment|/* kill time */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|driver-&gt;close_delay
op_plus
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
macro_line|#if 0
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|driver-&gt;open_wait
)paren
suffix:semicolon
)brace
macro_line|#endif
id|driver-&gt;flags
op_and_assign
op_complement
(paren
id|IRVTD_ASYNC_NORMAL_ACTIVE
op_or
id|IRVTD_ASYNC_CALLOUT_ACTIVE
op_or
id|IRVTD_ASYNC_CLOSING
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|driver-&gt;close_wait
)paren
suffix:semicolon
id|irvtd_shutdown
c_func
(paren
id|driver
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irvtd_close:done:refc(%d)&bslash;n&quot;
comma
id|ircomm_vsd_refcount
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * ----------------------------------------------------------------------&n; * irvtd_write() and friends&n; * This routine will be called when something data are passed from&n; * kernel or user.&n; *&n; * NOTE:I have stolen copy_from_user() from 2.0.30 kernel(linux/isdnif.h)&n; * to access user space of memory carefully. Thanks a lot!:)&n; * ----------------------------------------------------------------------&n; */
DECL|function|irvtd_write
r_int
(def_block
id|irvtd_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|irvtd_cb
op_star
id|driver
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|c
op_assign
l_int|0
suffix:semicolon
r_int
id|wrote
op_assign
l_int|0
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
id|__u8
op_star
id|frame
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irvtd_write():&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
op_logical_or
op_logical_neg
id|driver-&gt;txbuff
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|skb
op_assign
id|driver-&gt;txbuff
suffix:semicolon
id|c
op_assign
id|MIN
c_func
(paren
id|count
comma
(paren
id|skb_tailroom
c_func
(paren
id|skb
)paren
op_minus
id|COMM_HEADER_SIZE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_le
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* write to the frame */
id|frame
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
(brace
id|copy_from_user
c_func
(paren
id|frame
comma
id|buf
comma
id|c
)paren
suffix:semicolon
)brace
r_else
id|memcpy
c_func
(paren
id|frame
comma
id|buf
comma
id|c
)paren
suffix:semicolon
multiline_comment|/* flush the frame */
id|irvtd_flush_chars
c_func
(paren
id|tty
)paren
suffix:semicolon
id|wrote
op_add_assign
id|c
suffix:semicolon
id|count
op_sub_assign
id|c
suffix:semicolon
)brace
r_return
(paren
id|wrote
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * ----------------------------------------------------------------------&n; * irvtd_put_char()&n; * This routine is called by the kernel to pass a single character.&n; * If we exausted our buffer,we can ignore the character!&n; * ----------------------------------------------------------------------&n; */
DECL|function|irvtd_put_char
r_void
(def_block
id|irvtd_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
(brace
id|__u8
op_star
id|frame
suffix:semicolon
r_struct
id|irvtd_cb
op_star
id|driver
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|driver-&gt;txbuff
suffix:semicolon
id|ASSERT
c_func
(paren
id|tty-&gt;driver_data
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irvtd_put_char:&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver-&gt;txbuff
)paren
(brace
r_return
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irvtd_put_char(0x%02x) skb_len(%d) MAX(%d):&bslash;n&quot;
comma
(paren
r_int
)paren
id|ch
comma
(paren
r_int
)paren
id|skb-&gt;len
comma
id|driver-&gt;comm-&gt;maxsdusize
op_minus
id|COMM_HEADER_SIZE
)paren
suffix:semicolon
multiline_comment|/* append a character  */
id|frame
op_assign
id|skb_put
c_func
(paren
id|skb
comma
l_int|1
)paren
suffix:semicolon
id|frame
(braket
l_int|0
)braket
op_assign
id|ch
suffix:semicolon
r_return
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * ----------------------------------------------------------------------&n; * irvtd_flush_chars() and friend&n; * This routine will be called after a series of characters was written using &n; * irvtd_put_char().We have to send them down to IrCOMM.&n; * ----------------------------------------------------------------------&n; */
DECL|function|flush_txbuff
r_static
r_void
(def_block
id|flush_txbuff
c_func
(paren
r_struct
id|irvtd_cb
op_star
id|driver
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|driver-&gt;txbuff
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|driver-&gt;tty
suffix:semicolon
id|ASSERT
c_func
(paren
id|tty
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
macro_line|#ifdef IRVTD_DEBUG_TX
id|printk
c_func
(paren
l_string|&quot;flush_txbuff:&quot;
)paren
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb-&gt;len
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
id|skb-&gt;data
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#else
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;flush_txbuff:count(%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|skb-&gt;len
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* add &quot;clen&quot; field */
id|skb_push
c_func
(paren
id|skb
comma
l_int|1
)paren
suffix:semicolon
id|skb-&gt;data
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* without control channel */
id|ircomm_data_request
c_func
(paren
id|driver-&gt;comm
comma
id|driver-&gt;txbuff
)paren
suffix:semicolon
multiline_comment|/* allocate new frame */
id|skb
op_assign
id|driver-&gt;txbuff
op_assign
id|dev_alloc_skb
c_func
(paren
id|driver-&gt;comm-&gt;max_txbuff_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;flush_txbuff():alloc_skb failed!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb_reserve
c_func
(paren
id|skb
comma
id|COMM_HEADER_SIZE
)paren
suffix:semicolon
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|driver-&gt;tty-&gt;write_wait
)paren
suffix:semicolon
)brace
)def_block
DECL|function|irvtd_flush_chars
r_void
(def_block
id|irvtd_flush_chars
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|irvtd_cb
op_star
id|driver
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver
op_logical_or
id|driver-&gt;magic
op_ne
id|IRVTD_MAGIC
op_logical_or
op_logical_neg
id|driver-&gt;txbuff
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_flush_chars:null structure:ignore&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irvtd_flush_chars():&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tty-&gt;hw_stopped
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irvtd_flush_chars:hw_stopped:sleep..&bslash;n&quot;
)paren
suffix:semicolon
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irvtd_flush_chars:waken up!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver-&gt;txbuff-&gt;len
)paren
(brace
r_return
suffix:semicolon
)brace
)brace
id|flush_txbuff
c_func
(paren
id|driver
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * ----------------------------------------------------------------------&n; * irvtd_write_room()&n; * This routine returns the room that our buffer has now.&n; *&n; * NOTE: &n; * driver/char/n_tty.c drops a character(s) when this routine returns 0,&n; * and then linux will be frozen after a few minutes :(    why? bug?&n; * ( I found this on linux-2.0.33 )&n; * So this routine flushes a buffer if there is few room,     TH&n; * ----------------------------------------------------------------------&n; */
DECL|function|irvtd_write_room
r_int
(def_block
id|irvtd_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
(paren
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|tty-&gt;driver_data
)paren
op_member_access_from_pointer
id|txbuff
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_write_room:NULL skb&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ret
op_assign
id|skb_tailroom
c_func
(paren
id|skb
)paren
op_minus
id|COMM_HEADER_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_write_room:error:room is %d!&quot;
comma
id|ret
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irvtd_write_room:&bslash;n&quot;
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;retval(%d)&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
multiline_comment|/* flush buffer automatically to avoid kernel freeze :&lt; */
r_if
c_cond
(paren
id|ret
OL
l_int|8
)paren
(brace
multiline_comment|/* why 8? there&squot;s no reason :) */
id|irvtd_flush_chars
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * ----------------------------------------------------------------------&n; * irvtd_chars_in_buffer()&n; * This function returns how many characters which have not been sent yet &n; * are still in buffer.&n; * ----------------------------------------------------------------------&n; */
DECL|function|irvtd_chars_in_buffer
r_int
(def_block
id|irvtd_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
(paren
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|tty-&gt;driver_data
)paren
op_member_access_from_pointer
id|txbuff
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irvtd_chars_in_buffer()&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;irvtd_chars_in_buffer:NULL skb&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
(paren
id|skb-&gt;len
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * ----------------------------------------------------------------------&n; * irvtd_break()&n; * routine which turns the break handling on or off&n; * ----------------------------------------------------------------------&n; */
DECL|function|irvtd_break
r_static
r_void
(def_block
id|irvtd_break
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|break_state
)paren
(brace
r_struct
id|irvtd_cb
op_star
id|driver
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|tty-&gt;driver_data
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|driver-&gt;magic
op_eq
id|IRVTD_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|break_state
op_eq
op_minus
l_int|1
)paren
(brace
id|driver-&gt;comm-&gt;break_signal
op_assign
l_int|0x01
suffix:semicolon
id|ircomm_append_ctrl
c_func
(paren
id|driver-&gt;comm
comma
id|BREAK_SIGNAL
)paren
suffix:semicolon
id|ircomm_control_request
c_func
(paren
id|driver-&gt;comm
)paren
suffix:semicolon
)brace
r_else
(brace
id|driver-&gt;comm-&gt;break_signal
op_assign
l_int|0x00
suffix:semicolon
id|ircomm_append_ctrl
c_func
(paren
id|driver-&gt;comm
comma
id|BREAK_SIGNAL
)paren
suffix:semicolon
id|ircomm_control_request
c_func
(paren
id|driver-&gt;comm
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * ----------------------------------------------------------------------&n; * irvtd_ioctl() and friends&n; * This routine allows us to implement device-specific ioctl&squot;s.&n; * If passed ioctl number (i.e.cmd) is unknown one, we should return &n; * ENOIOCTLCMD.&n; *&n; * TODO: we can&squot;t use setserial on IrCOMM because some ioctls are not implemented.&n; * we should add some ioctls and make some tool which is resemble to setserial.&n; * ----------------------------------------------------------------------&n; */
DECL|function|get_modem_info
r_static
r_int
id|get_modem_info
c_func
(paren
r_struct
id|irvtd_cb
op_star
id|driver
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_int
r_int
id|result
suffix:semicolon
id|result
op_assign
(paren
(paren
id|driver-&gt;mcr
op_amp
id|MCR_RTS
)paren
ques
c_cond
id|TIOCM_RTS
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|driver-&gt;mcr
op_amp
id|MCR_DTR
)paren
ques
c_cond
id|TIOCM_DTR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|driver-&gt;msr
op_amp
id|DELTA_DCD
)paren
ques
c_cond
id|TIOCM_CAR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|driver-&gt;msr
op_amp
id|DELTA_RI
)paren
ques
c_cond
id|TIOCM_RNG
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|driver-&gt;msr
op_amp
id|DELTA_DSR
)paren
ques
c_cond
id|TIOCM_DSR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|driver-&gt;msr
op_amp
id|DELTA_CTS
)paren
ques
c_cond
id|TIOCM_CTS
suffix:colon
l_int|0
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|result
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_modem_info
r_static
r_int
id|set_modem_info
c_func
(paren
r_struct
id|irvtd_cb
op_star
id|driver
comma
r_int
r_int
id|cmd
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
r_int
id|arg
suffix:semicolon
id|error
op_assign
id|get_user
c_func
(paren
id|arg
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCMBIS
suffix:colon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_RTS
)paren
id|driver-&gt;mcr
op_or_assign
id|MCR_RTS
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_DTR
)paren
id|driver-&gt;mcr
op_or_assign
id|MCR_DTR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMBIC
suffix:colon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_RTS
)paren
id|driver-&gt;mcr
op_and_assign
op_complement
id|MCR_RTS
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_DTR
)paren
id|driver-&gt;mcr
op_and_assign
op_complement
id|MCR_DTR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMSET
suffix:colon
id|driver-&gt;mcr
op_assign
(paren
(paren
id|driver-&gt;mcr
op_amp
op_complement
(paren
id|MCR_RTS
op_or
id|MCR_DTR
)paren
)paren
op_or
(paren
(paren
id|arg
op_amp
id|TIOCM_RTS
)paren
ques
c_cond
id|MCR_RTS
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|arg
op_amp
id|TIOCM_DTR
)paren
ques
c_cond
id|MCR_DTR
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|driver-&gt;comm-&gt;dte
op_assign
id|driver-&gt;mcr
suffix:semicolon
id|ircomm_append_ctrl
c_func
(paren
id|driver-&gt;comm
comma
id|DTELINE_STATE
)paren
suffix:semicolon
id|ircomm_control_request
c_func
(paren
id|driver-&gt;comm
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|irvtd_ioctl
r_int
(def_block
id|irvtd_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|irvtd_cb
op_star
id|driver
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|icounter_struct
id|cnow
suffix:semicolon
r_struct
id|icounter_struct
op_star
id|p_cuser
suffix:semicolon
multiline_comment|/* user space */
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irvtd_ioctl:requested ioctl(0x%08x)&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#ifdef IRVTD_DEBUG_IOCTL
(brace
multiline_comment|/* kill time so that debug messages will come slowly  */
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|4
suffix:semicolon
multiline_comment|/*0.25sec*/
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|cmd
op_ne
id|TIOCGSERIAL
)paren
op_logical_and
(paren
id|cmd
op_ne
id|TIOCSSERIAL
)paren
op_logical_and
(paren
id|cmd
op_ne
id|TIOCSERCONFIG
)paren
op_logical_and
(paren
id|cmd
op_ne
id|TIOCSERGSTRUCT
)paren
op_logical_and
(paren
id|cmd
op_ne
id|TIOCMIWAIT
)paren
op_logical_and
(paren
id|cmd
op_ne
id|TIOCGICOUNT
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_ioctl:I/O error...&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCMGET
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
id|get_modem_info
c_func
(paren
id|driver
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|TIOCMBIS
suffix:colon
r_case
id|TIOCMBIC
suffix:colon
r_case
id|TIOCMSET
suffix:colon
r_return
id|set_modem_info
c_func
(paren
id|driver
comma
id|cmd
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t; * we wouldn&squot;t implement them since we don&squot;t use serial_struct&n;&t; */
r_case
id|TIOCGSERIAL
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|serial_struct
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
id|irvtd_get_serial_info
c_func
(paren
id|driver
comma
(paren
r_struct
id|serial_struct
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|TIOCSSERIAL
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|serial_struct
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
id|irvtd_set_serial_info
c_func
(paren
id|driver
comma
(paren
r_struct
id|serial_struct
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|TIOCSERGETLSR
suffix:colon
multiline_comment|/* Get line status register */
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_else
r_return
id|get_lsr_info
c_func
(paren
id|driver
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
macro_line|#endif&t;&t;
multiline_comment|/*&n; *  I think we don&squot;t need them&n; */
multiline_comment|/* &t;case TIOCSERCONFIG: */
multiline_comment|/*&n; * They cannot be implemented because we don&squot;t use async_struct &n; * which is defined in serial.h&n; */
multiline_comment|/* &t;case TIOCSERGSTRUCT: */
multiline_comment|/* &t;&t;error = verify_area(VERIFY_WRITE, (void *) arg, */
multiline_comment|/* &t;&t;&t;&t;    sizeof(struct async_struct)); */
multiline_comment|/* &t;&t;if (error) */
multiline_comment|/* &t;&t;&t;return error; */
multiline_comment|/* &t;&t;memcpy_tofs((struct async_struct *) arg, */
multiline_comment|/* &t;&t;&t;    driver, sizeof(struct async_struct)); */
multiline_comment|/* &t;&t;return 0; */
multiline_comment|/* &t;case TIOCSERGETMULTI: */
multiline_comment|/* &t;&t;error = verify_area(VERIFY_WRITE, (void *) arg, */
multiline_comment|/* &t;&t;&t;&t;    sizeof(struct serial_multiport_struct)); */
multiline_comment|/* &t;&t;if (error) */
multiline_comment|/* &t;&t;&t;return error; */
multiline_comment|/* &t;&t;return get_multiport_struct(driver, */
multiline_comment|/* &t;&t;&t;&t;&t;    (struct serial_multiport_struct *) arg); */
multiline_comment|/* &t;case TIOCSERSETMULTI: */
multiline_comment|/* &t;&t;error = verify_area(VERIFY_READ, (void *) arg, */
multiline_comment|/* &t;&t;&t;&t;    sizeof(struct serial_multiport_struct)); */
multiline_comment|/* &t;&t;if (error) */
multiline_comment|/* &t;&t;&t;return error; */
multiline_comment|/* &t;&t;return set_multiport_struct(driver, */
multiline_comment|/* &t;&t;&t;&t;&t;    (struct serial_multiport_struct *) arg); */
multiline_comment|/*&n;&t;&t; * Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS)&n;&t;&t; * to change&n;&t;&t; * - mask passed in arg for lines of interest&n; &t;&t; *   (use |&squot;ed TIOCM_RNG/DSR/CD/CTS for masking)&n;&t;&t; * Caller should use TIOCGICOUNT to see which one it was&n;&t;&t; */
r_case
id|TIOCMIWAIT
suffix:colon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|driver-&gt;delta_msr_wait
)paren
suffix:semicolon
multiline_comment|/* see if a signal did it */
multiline_comment|/* &t;&t;&t;if (current-&gt;signal &amp; ~current-&gt;blocked) */
multiline_comment|/* &t;&t;&t;&t;return -ERESTARTSYS; */
r_if
c_cond
(paren
(paren
(paren
id|arg
op_amp
id|TIOCM_RNG
)paren
op_logical_and
(paren
id|driver-&gt;msr
op_amp
id|DELTA_RI
)paren
)paren
op_logical_or
(paren
(paren
id|arg
op_amp
id|TIOCM_DSR
)paren
op_logical_and
(paren
id|driver-&gt;msr
op_amp
id|DELTA_DSR
)paren
)paren
op_logical_or
(paren
(paren
id|arg
op_amp
id|TIOCM_CD
)paren
op_logical_and
(paren
id|driver-&gt;msr
op_amp
id|DELTA_DCD
)paren
)paren
op_logical_or
(paren
(paren
id|arg
op_amp
id|TIOCM_CTS
)paren
op_logical_and
(paren
id|driver-&gt;msr
op_amp
id|DELTA_CTS
)paren
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* NOTREACHED */
r_case
id|TIOCGICOUNT
suffix:colon
multiline_comment|/* &n;&t;&t; * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)&n;&t;&t; * Return: write counters to the user passed counter struct&n;&t;&t; * NB: both 1-&gt;0 and 0-&gt;1 transitions are counted except for&n;&t;&t; *     RI where only 0-&gt;1 is counted.&n;&t;&t; */
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|icounter_struct
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|cnow
op_assign
id|driver-&gt;icount
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|p_cuser
op_assign
(paren
r_struct
id|icounter_struct
op_star
)paren
id|arg
suffix:semicolon
id|put_user
c_func
(paren
id|cnow.cts
comma
op_amp
id|p_cuser-&gt;cts
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|cnow.dsr
comma
op_amp
id|p_cuser-&gt;dsr
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|cnow.rng
comma
op_amp
id|p_cuser-&gt;rng
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|cnow.dcd
comma
op_amp
id|p_cuser-&gt;dcd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCGSERIAL
suffix:colon
r_case
id|TIOCSSERIAL
suffix:colon
r_case
id|TIOCSERGETLSR
suffix:colon
r_case
id|TIOCSERCONFIG
suffix:colon
r_case
id|TIOCSERGWILD
suffix:colon
r_case
id|TIOCSERSWILD
suffix:colon
r_case
id|TIOCSERGSTRUCT
suffix:colon
r_case
id|TIOCSERGETMULTI
suffix:colon
r_case
id|TIOCSERSETMULTI
suffix:colon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_ioctl:sorry, ioctl(0x%08x)is not implemented&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
multiline_comment|/* ioctls which are imcompatible with serial.c */
r_case
id|TCSETS
suffix:colon
r_case
id|TCGETS
suffix:colon
r_case
id|TCFLSH
suffix:colon
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
multiline_comment|/* ioctls which we must not touch */
)brace
r_return
l_int|0
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * ----------------------------------------------------------------------&n; * irvtd_set_termios()&n; * This is called when termios is changed.&n; * If things that changed is significant for us,(i.e. changing baud rate etc.)&n; * send something to peer device.&n; * ----------------------------------------------------------------------&n; */
DECL|function|irvtd_set_termios
r_void
(def_block
id|irvtd_set_termios
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
r_struct
id|irvtd_cb
op_star
id|driver
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|ASSERT
c_func
(paren
id|driver
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|driver-&gt;magic
op_eq
id|IRVTD_MAGIC
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_set_termios:&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;termios-&gt;c_cflag
op_eq
id|old_termios-&gt;c_cflag
)paren
op_logical_and
(paren
id|RELEVANT_IFLAG
c_func
(paren
id|tty-&gt;termios-&gt;c_iflag
)paren
op_eq
id|RELEVANT_IFLAG
c_func
(paren
id|old_termios-&gt;c_iflag
)paren
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|change_speed
c_func
(paren
id|driver
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
op_logical_and
op_logical_neg
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
)paren
(brace
id|tty-&gt;hw_stopped
op_assign
id|driver-&gt;ttp_stoptx
suffix:semicolon
multiline_comment|/* irvtd_start(tty); */
multiline_comment|/* we don&squot;t need this */
)brace
)brace
)def_block
multiline_comment|/*&n; * ----------------------------------------------------------------------&n; * irvtd_throttle,irvtd_unthrottle&n; *   These routines will be called when we have to pause sending up data to tty.&n; *   We use RTS virtual signal when servicetype is NINE_WIRE&n; * ----------------------------------------------------------------------&n; */
DECL|function|irvtd_send_xchar
r_static
r_void
(def_block
id|irvtd_send_xchar
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_char
id|ch
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;():&bslash;n&quot;
)paren
suffix:semicolon
id|irvtd_put_char
c_func
(paren
id|tty
comma
id|ch
)paren
suffix:semicolon
)brace
)def_block
DECL|function|irvtd_throttle
r_void
(def_block
id|irvtd_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|irvtd_cb
op_star
id|driver
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_throttle:&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|I_IXOFF
c_func
(paren
id|tty
)paren
)paren
id|irvtd_put_char
c_func
(paren
id|tty
comma
id|STOP_CHAR
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
id|driver-&gt;mcr
op_and_assign
op_complement
id|MCR_RTS
suffix:semicolon
id|driver-&gt;mcr
op_or_assign
id|DELTA_RTS
suffix:semicolon
id|driver-&gt;comm-&gt;dte
op_assign
id|driver-&gt;mcr
suffix:semicolon
id|ircomm_append_ctrl
c_func
(paren
id|driver-&gt;comm
comma
id|DTELINE_STATE
)paren
suffix:semicolon
id|ircomm_control_request
c_func
(paren
id|driver-&gt;comm
)paren
suffix:semicolon
id|irttp_flow_request
c_func
(paren
id|driver-&gt;comm-&gt;tsap
comma
id|FLOW_STOP
)paren
suffix:semicolon
)brace
)def_block
DECL|function|irvtd_unthrottle
r_void
(def_block
id|irvtd_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|irvtd_cb
op_star
id|driver
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_unthrottle:&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|I_IXOFF
c_func
(paren
id|tty
)paren
)paren
id|irvtd_put_char
c_func
(paren
id|tty
comma
id|START_CHAR
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
id|driver-&gt;mcr
op_or_assign
(paren
id|MCR_RTS
op_or
id|DELTA_RTS
)paren
suffix:semicolon
id|driver-&gt;comm-&gt;dte
op_assign
id|driver-&gt;mcr
suffix:semicolon
id|ircomm_append_ctrl
c_func
(paren
id|driver-&gt;comm
comma
id|DTELINE_STATE
)paren
suffix:semicolon
id|ircomm_control_request
c_func
(paren
id|driver-&gt;comm
)paren
suffix:semicolon
id|irttp_flow_request
c_func
(paren
id|driver-&gt;comm-&gt;tsap
comma
id|FLOW_START
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * ------------------------------------------------------------&n; * irvtd_stop() and irvtd_start()&n; *&n; * This routines are called before setting or resetting tty-&gt;stopped.&n; * They enable or disable an interrupt which means &quot;transmitter-is-ready&quot;&n; * in serial.c, but  I think these routine are not necessary for us. &n; * ------------------------------------------------------------&n; */
macro_line|#if 0
(def_block
id|irvtd_stop
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_stop()&bslash;n&quot;
)paren
suffix:semicolon
r_struct
id|irvtd_cb
op_star
id|info
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_start():not implemented!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)def_block
(def_block
id|irvtd_start
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|irvtd_cb
op_star
id|info
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_start():not_implemented!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)def_block
macro_line|#endif
multiline_comment|/*&n; * ------------------------------------------------------------&n; * irvtd_hangup()&n; * This routine notifies that tty layer have got HUP signal&n; * Is this routine right ? :{|&n; * ------------------------------------------------------------&n; */
DECL|function|irvtd_hangup
r_void
(def_block
id|irvtd_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|irvtd_cb
op_star
id|info
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;irvtd_hangup()&bslash;n&quot;
)paren
suffix:semicolon
id|irvtd_flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|irvtd_shutdown
c_func
(paren
id|info
)paren
suffix:semicolon
id|info-&gt;count
op_assign
l_int|0
suffix:semicolon
id|info-&gt;flags
op_and_assign
op_complement
(paren
id|IRVTD_ASYNC_NORMAL_ACTIVE
op_or
id|IRVTD_ASYNC_CALLOUT_ACTIVE
)paren
suffix:semicolon
id|info-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
)brace
)def_block
DECL|function|irvtd_flush_buffer
r_void
(def_block
id|irvtd_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|irvtd_cb
op_star
id|driver
op_assign
(paren
r_struct
id|irvtd_cb
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|driver-&gt;txbuff
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;irvtd_flush_buffer:%d chars are gone..&bslash;n&quot;
comma
(paren
r_int
)paren
id|skb-&gt;len
)paren
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* write_wait is a wait queue of tty_wait_until_sent().&n;&t; * see tty_io.c of kernel &n;&t; */
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
)def_block
eof
