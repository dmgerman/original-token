multiline_comment|/*&n; *&t;NET3:&t;802.2 LLC supervisor for the netbeui protocols. &n; *&n; *&t;The basic aim is to provide a self managing link layer supervisor&n; *&t;for netbeui. It creates and destroys the 802.2 virtual connections&n; *&t;as needed, and copes with the various races when a link goes down&n; *&t;just as its requested etc.&n; *&n; *&t;The upper layers are presented with the notion of an nb_link which&n; *&t;is a potentially shared object that represents a logical path &n; *&t;between two hosts. Each nb_link has usage counts and users can&n; *&t;treat it as if its their own.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/datalink.h&gt;
macro_line|#include &lt;net/p8022.h&gt;
macro_line|#include &lt;net/psnap.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/llc.h&gt;
macro_line|#include &lt;net/netbeui.h&gt;
multiline_comment|/*&n; *&t;When this routine is called the netbeui layer has decided to&n; *&t;drop the link. There is a tiny risk that we might reuse the&n; *&t;link after we decide. Thus before we blast the link into little&n; *&t;tiny pieces we must check....&n; */
DECL|function|netbeui_do_destroy
r_static
r_void
id|netbeui_do_destroy
c_func
(paren
r_struct
id|nb_link
op_star
id|nb
)paren
(brace
multiline_comment|/*&n;&t; *&t;Are we wanted again. Bring it back. Sigh, wish people&n;&t; *&t;would make up their minds 8)&n;&t; */
r_if
c_cond
(paren
id|nb-&gt;users
OG
l_int|0
)paren
(brace
id|nb-&gt;state
op_assign
id|NETBEUI_CONNWAIT
suffix:semicolon
id|llc_connect_request
c_func
(paren
op_amp
id|nb-&gt;llc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Blam.... into oblivion it goes&n;&t; */
id|llc_unregister
c_func
(paren
op_amp
id|nb-&gt;llc
)paren
suffix:semicolon
id|netbeui_free_link
c_func
(paren
id|nb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Handle netbeui events. Basically that means keep it up when it&n; *&t;should be up, down when it should be down and handle all the data.&n; */
DECL|function|netbeui_event
r_static
r_void
id|netbeui_event
c_func
(paren
id|llcptr
id|llc
)paren
(brace
r_struct
id|nb_link
op_star
id|nb
op_assign
(paren
r_struct
id|nb_link
op_star
)paren
id|llc
suffix:semicolon
multiline_comment|/*&n;&t; *&t;See what has occured&n;&t; */
multiline_comment|/*&n;&t; *&t;Connect completion confirmation&n;&t; */
r_if
c_cond
(paren
id|llc-&gt;llc_callbacks
op_amp
id|LLC_CONN_CONFIRM
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Link up if desired. Otherwise try frantically&n;&t;&t; *&t;to close it.&n;&t;&t; */
r_if
c_cond
(paren
id|nb-&gt;state
op_ne
id|NETBEUI_DEADWAIT
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Wake pending writers&n;&t;&t;&t; */
id|nb-&gt;state
op_assign
id|NETBEUI_OPEN
suffix:semicolon
id|netbeui_wakeup
c_func
(paren
id|nb
)paren
suffix:semicolon
)brace
r_else
id|llc_disconnect_request
c_func
(paren
id|llc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Data is passed to the upper netbeui layer&n;&t; */
r_if
c_cond
(paren
id|llc-&gt;llc_callbacks
op_amp
id|LLC_DATA_INDIC
)paren
(brace
id|netbeu_rcv_stream
c_func
(paren
id|llc
comma
id|llc-&gt;inc_skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Frame free is controlled by our stream processor&n;&t;&t; */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;We got disconnected&n;&t; */
r_if
c_cond
(paren
id|llc-&gt;llc_callbacks
op_amp
id|LLC_DISC_INDICATION
)paren
(brace
r_if
c_cond
(paren
id|nb-&gt;state
op_eq
id|NETBEUI_DEADWAIT
)paren
(brace
id|netbeui_do_destroy
c_func
(paren
id|nb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nb-&gt;state
op_eq
id|NETBEUI_DISCWAIT
)paren
(brace
id|llc_connect_request
c_func
(paren
id|llc
)paren
suffix:semicolon
id|nb-&gt;state
op_assign
id|NETBEUI_CONNWAIT
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Miscellaneous burps&n;&t; */
r_if
c_cond
(paren
id|llc-&gt;llc_callbacks
op_amp
(paren
id|LLC_RESET_INDIC_LOC
op_or
id|LLC_RESET_INDIC_REM
op_or
id|LLC_RST_CONFIRM
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Reset. &n;&t;&t; *&t;Q: Is tearing the link down the right answer ?&n;&t;&t; *&n;&t;&t; *&t;For now we just carry on&n;&t;&t; */
)brace
multiline_comment|/*&n;&t; *&t;Track link busy status&n;&t; */
r_if
c_cond
(paren
id|llc-&gt;llc_callbacks
op_amp
id|LLC_REMOTE_BUSY
)paren
(brace
id|nb-&gt;busy
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Send no more for a bit */
r_if
c_cond
(paren
id|llc-&gt;llc_callbacks
op_amp
id|LLC_REMOTE_NOTBUSY
)paren
(brace
multiline_comment|/* Coming unbusy may wake sending threads */
id|nb-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|netbeui_wakeup
c_func
(paren
id|nb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;UI frames are passed to the upper netbeui layer.&n;&t; */
r_if
c_cond
(paren
id|llc-&gt;llc_callbacks
op_amp
id|LLC_UI_DATA
)paren
(brace
id|netbeui_rcv_dgram
c_func
(paren
id|llc
comma
id|llc-&gt;inc_skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* We ignore TST, XID, FRMR stuff */
multiline_comment|/* FIXME: We need to free frames here once I fix the callback! */
r_if
c_cond
(paren
id|llc-&gt;inc_skb
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Netbeui has created a new logical link. As a result we will&n; *&t;need to find or create a suitable 802.2 LLC session and join&n; *&t;it.&n; */
DECL|function|netbeui_create_channel
r_struct
id|nb_link
op_star
id|netbeui_create_channel
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u8
op_star
id|remote_mac
comma
r_int
id|pri
)paren
(brace
r_struct
id|nb_link
op_star
id|nb
op_assign
id|netbeui_find_channel
c_func
(paren
id|dev
comma
id|remote_mac
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nb
)paren
(brace
r_if
c_cond
(paren
id|nb-&gt;state
op_eq
id|NETBEUI_DEADWAIT
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;We had commenced a final shutdown. We&n;&t;&t;&t; *&t;cannot abort that (we sent the packet) but&n;&t;&t;&t; *&t;we can shift the mode to DISCWAIT. That will&n;&t;&t;&t; *&t;cause the disconnect event to bounce us&n;&t;&t;&t; *&t;back into connected state.&n;&t;&t;&t; */
id|nb-&gt;state
op_eq
id|NETBEUI_DISCWAIT
suffix:semicolon
)brace
id|nb-&gt;users
op_increment
suffix:semicolon
r_return
id|nb
suffix:semicolon
)brace
id|nb
op_assign
id|netbeui_alloc_link
c_func
(paren
id|pri
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nb
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Internal book keeping&n;&t; */
id|nb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|nb-&gt;users
op_assign
l_int|1
suffix:semicolon
id|nb-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|nb-&gt;wakeup
op_assign
l_int|NULL
suffix:semicolon
id|nb-&gt;state
op_assign
id|NETBEUI_CONNWAIT
suffix:semicolon
id|memcpy
c_func
(paren
id|nb-&gt;remote_mac
comma
id|remote_mac
comma
id|ETH_ALEN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now try and attach an LLC.&n;&t; */
r_if
c_cond
(paren
id|register_cl2llc_client
c_func
(paren
op_amp
id|nb-&gt;llc
comma
id|dev-&gt;name
comma
id|netbeui_event
comma
id|remote_mac
comma
id|NETBEUI_SAP
comma
id|NETBEUI_SAP
)paren
OL
l_int|0
)paren
(brace
id|netbeui_free_link
c_func
(paren
id|nb
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Commence connection establishment.&n;&t; */
id|llc_connect_request
c_func
(paren
op_amp
id|nb-&gt;llc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Done&n;&t; */
id|nb-&gt;next
op_assign
id|nb_link_list
suffix:semicolon
id|nb_link_list
op_assign
id|nb
suffix:semicolon
r_return
id|nb
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;A logical netbeui channel has died. If the channel has no&n; *&t;further users we commence shutdown.&n; */
DECL|function|netbeui_delete_channel
r_int
id|netbeui_delete_channel
c_func
(paren
r_struct
id|nb_link
op_star
id|nb
)paren
(brace
id|nb-&gt;users
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t; *&t;FIXME: Must remove ourselves from the nb_link chain when&n;&t; *&t;we add that bit&n;&t; */
r_if
c_cond
(paren
id|nb-&gt;users
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Ensure we drop soon. The disconnect confirm will let&n;&t; *&t;us fix the deletion. If someone wants the link at&n;&t; *&t;the wrong moment nothing bad will occur. The create&n;&t; *&t;or the do_destroy will sort it.&n;&t; */
id|nb-&gt;state
op_assign
id|NETBEUI_DEADWAIT
suffix:semicolon
id|llc_disconnect_request
c_func
(paren
id|lp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
