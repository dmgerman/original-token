multiline_comment|/*&n; * NET3:&t;Garbage Collector For AF_UNIX sockets&n; *&n; * Garbage Collector:&n; *&t;Copyright (C) Barak A. Pearlmutter.&n; *&t;Released under the GPL version 2 or later.&n; *&n; * Chopped about by Alan Cox 22/3/96 to make it fit the AF_UNIX socket problem.&n; * If it doesn&squot;t work blame me, it worked when Barak sent it.&n; *&n; * Assumptions:&n; *&n; *  - object w/ a bit&n; *  - free list&n; *&n; * Current optimizations:&n; *&n; *  - explicit stack instead of recursion&n; *  - tail recurse on first born instead of immediate push/pop&n; *  - we gather the stuff that should not be killed into tree&n; *    and stack is just a path from root to the current pointer.&n; *&n; *  Future optimizations:&n; *&n; *  - don&squot;t just push entire root set; process in place&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License&n; *&t;as published by the Free Software Foundation; either version&n; *&t;2 of the License, or (at your option) any later version.&n; *&n; *  Fixes:&n; *&t;Alan Cox&t;07 Sept&t;1997&t;Vmalloc internal stack as needed.&n; *&t;&t;&t;&t;&t;Cope with changing max_files.&n; *&t;Al Viro&t;&t;11 Oct 1998&n; *&t;&t;Graph may have cycles. That is, we can send the descriptor&n; *&t;&t;of foo to bar and vice versa. Current code chokes on that.&n; *&t;&t;Fix: move SCM_RIGHTS ones into the separate list and then&n; *&t;&t;skb_free() them all instead of doing explicit fput&squot;s.&n; *&t;&t;Another problem: since fput() may block somebody may&n; *&t;&t;create a new unix_socket when we are in the middle of sweep&n; *&t;&t;phase. Fix: revert the logic wrt MARKED. Mark everything&n; *&t;&t;upon the beginning and unmark non-junk ones.&n; *&n; *&t;&t;[12 Oct 1998] AAARGH! New code purges all SCM_RIGHTS&n; *&t;&t;sent to connect()&squot;ed but still not accept()&squot;ed sockets.&n; *&t;&t;Fixed. Old code had slightly different problem here:&n; *&t;&t;extra fput() in situation when we passed the descriptor via&n; *&t;&t;such socket and closed it (descriptor). That would happen on&n; *&t;&t;each unix_gc() until the accept(). Since the struct file in&n; *&t;&t;question would go to the free list and might be reused...&n; *&t;&t;That might be the reason of random oopses on filp_close()&n; *&t;&t;in unrelated processes.&n; *&n; *&t;AV&t;&t;28 Feb 1999&n; *&t;&t;Kill the explicit allocation of stack. Now we keep the tree&n; *&t;&t;with root in dummy + pointer (gc_current) to one of the nodes.&n; *&t;&t;Stack is represented as path from gc_current to dummy. Unmark&n; *&t;&t;now means &quot;add to tree&quot;. Push == &quot;make it a son of gc_current&quot;.&n; *&t;&t;Pop == &quot;move gc_current to parent&quot;. We keep only pointers to&n; *&t;&t;parents (-&gt;gc_tree).&n; *&t;AV&t;&t;1 Mar 1999&n; *&t;&t;Damn. Added missing check for -&gt;dead in listen queues scanning.&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/un.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/af_unix.h&gt;
macro_line|#include &lt;net/scm.h&gt;
multiline_comment|/* Internal data structures and random procedures: */
DECL|macro|GC_HEAD
mdefine_line|#define GC_HEAD&t;&t;((unix_socket *)(-1))
DECL|macro|GC_ORPHAN
mdefine_line|#define GC_ORPHAN&t;((unix_socket *)(-3))
DECL|variable|gc_current
r_static
id|unix_socket
op_star
id|gc_current
op_assign
id|GC_HEAD
suffix:semicolon
multiline_comment|/* stack of objects to mark */
DECL|variable|unix_tot_inflight
id|atomic_t
id|unix_tot_inflight
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|function|unix_get_socket
r_extern
r_inline
id|unix_socket
op_star
id|unix_get_socket
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
id|unix_socket
op_star
id|u_sock
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Socket ?&n;&t; */
r_if
c_cond
(paren
id|inode-&gt;i_sock
)paren
(brace
r_struct
id|socket
op_star
id|sock
op_assign
op_amp
id|inode-&gt;u.socket_i
suffix:semicolon
r_struct
id|sock
op_star
id|s
op_assign
id|sock-&gt;sk
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;PF_UNIX ?&n;&t;&t; */
r_if
c_cond
(paren
id|s
op_logical_and
id|sock-&gt;ops
op_logical_and
id|sock-&gt;ops-&gt;family
op_eq
id|PF_UNIX
)paren
id|u_sock
op_assign
id|s
suffix:semicolon
)brace
r_return
id|u_sock
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Keep the number of times in flight count for the file&n; *&t;descriptor if it is for an AF_UNIX socket.&n; */
DECL|function|unix_inflight
r_void
id|unix_inflight
c_func
(paren
r_struct
id|file
op_star
id|fp
)paren
(brace
id|unix_socket
op_star
id|s
op_assign
id|unix_get_socket
c_func
(paren
id|fp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|s-&gt;protinfo.af_unix.inflight
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|unix_tot_inflight
)paren
suffix:semicolon
)brace
)brace
DECL|function|unix_notinflight
r_void
id|unix_notinflight
c_func
(paren
r_struct
id|file
op_star
id|fp
)paren
(brace
id|unix_socket
op_star
id|s
op_assign
id|unix_get_socket
c_func
(paren
id|fp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|s-&gt;protinfo.af_unix.inflight
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|unix_tot_inflight
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Garbage Collector Support Functions&n; */
DECL|function|pop_stack
r_extern
r_inline
id|unix_socket
op_star
id|pop_stack
c_func
(paren
r_void
)paren
(brace
id|unix_socket
op_star
id|p
op_assign
id|gc_current
suffix:semicolon
id|gc_current
op_assign
id|p-&gt;protinfo.af_unix.gc_tree
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|empty_stack
r_extern
r_inline
r_int
id|empty_stack
c_func
(paren
r_void
)paren
(brace
r_return
id|gc_current
op_eq
id|GC_HEAD
suffix:semicolon
)brace
DECL|function|maybe_unmark_and_push
r_extern
r_inline
r_void
id|maybe_unmark_and_push
c_func
(paren
id|unix_socket
op_star
id|x
)paren
(brace
r_if
c_cond
(paren
id|x-&gt;protinfo.af_unix.gc_tree
op_ne
id|GC_ORPHAN
)paren
r_return
suffix:semicolon
id|sock_hold
c_func
(paren
id|x
)paren
suffix:semicolon
id|x-&gt;protinfo.af_unix.gc_tree
op_assign
id|gc_current
suffix:semicolon
id|gc_current
op_assign
id|x
suffix:semicolon
)brace
multiline_comment|/* The external entry point: unix_gc() */
DECL|function|unix_gc
r_void
id|unix_gc
c_func
(paren
r_void
)paren
(brace
r_static
id|DECLARE_MUTEX
c_func
(paren
id|unix_gc_sem
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|unix_socket
op_star
id|s
suffix:semicolon
r_struct
id|sk_buff_head
id|hitlist
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Avoid a recursive GC.&n;&t; */
r_if
c_cond
(paren
id|down_trylock
c_func
(paren
op_amp
id|unix_gc_sem
)paren
)paren
r_return
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|unix_table_lock
)paren
suffix:semicolon
id|forall_unix_sockets
c_func
(paren
id|i
comma
id|s
)paren
(brace
id|s-&gt;protinfo.af_unix.gc_tree
op_assign
id|GC_ORPHAN
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Everything is now marked &n;&t; */
multiline_comment|/* Invariant to be maintained:&n;&t;&t;- everything unmarked is either:&n;&t;&t;-- (a) on the stack, or&n;&t;&t;-- (b) has all of its children unmarked&n;&t;&t;- everything on the stack is always unmarked&n;&t;&t;- nothing is ever pushed onto the stack twice, because:&n;&t;&t;-- nothing previously unmarked is ever pushed on the stack&n;&t; */
multiline_comment|/*&n;&t; *&t;Push root set&n;&t; */
id|forall_unix_sockets
c_func
(paren
id|i
comma
id|s
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;If all instances of the descriptor are not&n;&t;&t; *&t;in flight we are in use.&n;&t;&t; */
r_if
c_cond
(paren
id|s-&gt;socket
op_logical_and
id|s-&gt;socket-&gt;file
op_logical_and
id|file_count
c_func
(paren
id|s-&gt;socket-&gt;file
)paren
OG
id|atomic_read
c_func
(paren
op_amp
id|s-&gt;protinfo.af_unix.inflight
)paren
)paren
(brace
id|maybe_unmark_and_push
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Mark phase &n;&t; */
r_while
c_loop
(paren
op_logical_neg
id|empty_stack
c_func
(paren
)paren
)paren
(brace
id|unix_socket
op_star
id|x
op_assign
id|pop_stack
c_func
(paren
)paren
suffix:semicolon
id|unix_socket
op_star
id|sk
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|x-&gt;receive_queue.lock
)paren
suffix:semicolon
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|x-&gt;receive_queue
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Loop through all but first born &n;&t;&t; */
r_while
c_loop
(paren
id|skb
op_logical_and
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|x-&gt;receive_queue
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Do we have file descriptors ?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|UNIXCB
c_func
(paren
id|skb
)paren
dot
id|fp
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Process the descriptors of this socket&n;&t;&t;&t;&t; */
r_int
id|nfd
op_assign
id|UNIXCB
c_func
(paren
id|skb
)paren
dot
id|fp-&gt;count
suffix:semicolon
r_struct
id|file
op_star
op_star
id|fp
op_assign
id|UNIXCB
c_func
(paren
id|skb
)paren
dot
id|fp-&gt;fp
suffix:semicolon
r_while
c_loop
(paren
id|nfd
op_decrement
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;Get the socket the fd matches if&n;&t;&t;&t;&t;&t; *&t;it indeed does so&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|sk
op_assign
id|unix_get_socket
c_func
(paren
op_star
id|fp
op_increment
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|maybe_unmark_and_push
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* We have to scan not-yet-accepted ones too */
r_if
c_cond
(paren
id|x-&gt;state
op_eq
id|TCP_LISTEN
)paren
(brace
id|maybe_unmark_and_push
c_func
(paren
id|skb-&gt;sk
)paren
suffix:semicolon
)brace
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|x-&gt;receive_queue.lock
)paren
suffix:semicolon
id|sock_put
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
id|skb_queue_head_init
c_func
(paren
op_amp
id|hitlist
)paren
suffix:semicolon
id|forall_unix_sockets
c_func
(paren
id|i
comma
id|s
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;protinfo.af_unix.gc_tree
op_eq
id|GC_ORPHAN
)paren
(brace
r_struct
id|sk_buff
op_star
id|nextsk
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|s-&gt;receive_queue.lock
)paren
suffix:semicolon
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|s-&gt;receive_queue
)paren
suffix:semicolon
r_while
c_loop
(paren
id|skb
op_logical_and
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|s-&gt;receive_queue
)paren
(brace
id|nextsk
op_assign
id|skb-&gt;next
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Do we have file descriptors ?&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|UNIXCB
c_func
(paren
id|skb
)paren
dot
id|fp
)paren
(brace
id|__skb_unlink
c_func
(paren
id|skb
comma
id|skb-&gt;list
)paren
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
op_amp
id|hitlist
comma
id|skb
)paren
suffix:semicolon
)brace
id|skb
op_assign
id|nextsk
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|s-&gt;receive_queue.lock
)paren
suffix:semicolon
)brace
id|s-&gt;protinfo.af_unix.gc_tree
op_assign
id|GC_ORPHAN
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|unix_table_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Here we are. Hitlist is filled. Die.&n;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
op_amp
id|hitlist
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|unix_gc_sem
)paren
suffix:semicolon
)brace
eof
