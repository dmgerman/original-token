multiline_comment|/*&n; * NET3:&t;Garbage Collector For AF_UNIX sockets&n; *&n; * Garbage Collector:&n; *&t;Copyright (C) Barak A. Pearlmutter.&n; *&t;Released under the GPL version 2 or later.&n; *&n; * Chopped about by Alan Cox 22/3/96 to make it fit the AF_UNIX socket problem.&n; * If it doesn&squot;t work blame me, it worked when Barak sent it.&n; *&n; * Assumptions:&n; *&n; *  - object w/ a bit&n; *  - free list&n; *&n; * Current optimizations:&n; *&n; *  - explicit stack instead of recursion&n; *  - tail recurse on first born instead of immediate push/pop&n; *&n; *  Future optimizations:&n; *&n; *  - don&squot;t just push entire root set; process in place&n; *  - use linked list for internal stack&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License&n; *&t;as published by the Free Software Foundation; either version&n; *&t;2 of the License, or (at your option) any later version.&n; *&n; *  Fixes:&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/un.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/termios.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/tcp.h&gt;
macro_line|#include &lt;net/af_unix.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
multiline_comment|/* Internal data structures and random procedures: */
DECL|macro|MAX_STACK
mdefine_line|#define MAX_STACK 1000&t;&t;/* Maximum depth of tree (about 1 page) */
DECL|variable|stack
r_static
id|unix_socket
op_star
op_star
id|stack
suffix:semicolon
multiline_comment|/* stack of objects to mark */
DECL|variable|in_stack
r_static
r_int
id|in_stack
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* first free entry in stack */
DECL|function|unix_get_socket
r_extern
r_inline
id|unix_socket
op_star
id|unix_get_socket
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
id|unix_socket
op_star
id|u_sock
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|filp-&gt;f_inode
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Socket ?&n;&t; */
r_if
c_cond
(paren
id|inode
op_logical_and
id|inode-&gt;i_sock
)paren
(brace
r_struct
id|socket
op_star
id|s
op_assign
op_amp
id|inode-&gt;u.socket_i
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;AF_UNIX ?&n;&t;&t; */
r_if
c_cond
(paren
id|s-&gt;ops
op_eq
op_amp
id|unix_proto_ops
)paren
id|u_sock
op_assign
id|s-&gt;data
suffix:semicolon
)brace
r_return
id|u_sock
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Keep the number of times in flight count for the file&n; *&t;descriptor if it is for an AF_UNIX socket.&n; */
DECL|function|unix_inflight
r_void
id|unix_inflight
c_func
(paren
r_struct
id|file
op_star
id|fp
)paren
(brace
id|unix_socket
op_star
id|s
op_assign
id|unix_get_socket
c_func
(paren
id|fp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
)paren
(brace
id|s-&gt;protinfo.af_unix.inflight
op_increment
suffix:semicolon
)brace
)brace
DECL|function|unix_notinflight
r_void
id|unix_notinflight
c_func
(paren
r_struct
id|file
op_star
id|fp
)paren
(brace
id|unix_socket
op_star
id|s
op_assign
id|unix_get_socket
c_func
(paren
id|fp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
)paren
(brace
id|s-&gt;protinfo.af_unix.inflight
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Garbage Collector Support Functions&n; */
DECL|function|push_stack
r_extern
r_inline
r_void
id|push_stack
c_func
(paren
id|unix_socket
op_star
id|x
)paren
(brace
r_if
c_cond
(paren
id|in_stack
op_eq
id|MAX_STACK
)paren
id|panic
c_func
(paren
l_string|&quot;can&squot;t push onto full stack&quot;
)paren
suffix:semicolon
id|stack
(braket
id|in_stack
op_increment
)braket
op_assign
id|x
suffix:semicolon
)brace
DECL|function|pop_stack
r_extern
r_inline
id|unix_socket
op_star
id|pop_stack
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|in_stack
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;can&squot;t pop empty gc stack&quot;
)paren
suffix:semicolon
r_return
id|stack
(braket
op_decrement
id|in_stack
)braket
suffix:semicolon
)brace
DECL|function|empty_stack
r_extern
r_inline
r_int
id|empty_stack
c_func
(paren
r_void
)paren
(brace
r_return
id|in_stack
op_eq
l_int|0
suffix:semicolon
)brace
DECL|function|maybe_mark_and_push
r_extern
r_inline
r_void
id|maybe_mark_and_push
c_func
(paren
id|unix_socket
op_star
id|x
)paren
(brace
r_if
c_cond
(paren
id|x-&gt;protinfo.af_unix.marksweep
op_amp
id|MARKED
)paren
r_return
suffix:semicolon
id|x-&gt;protinfo.af_unix.marksweep
op_or_assign
id|MARKED
suffix:semicolon
id|push_stack
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
multiline_comment|/* The external entry point: unix_gc() */
DECL|function|unix_gc
r_void
id|unix_gc
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|in_unix_gc
op_assign
l_int|0
suffix:semicolon
id|unix_socket
op_star
id|s
suffix:semicolon
id|unix_socket
op_star
id|next
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Avoid a recursive GC.&n;&t; */
r_if
c_cond
(paren
id|in_unix_gc
)paren
(brace
r_return
suffix:semicolon
)brace
id|in_unix_gc
op_assign
l_int|1
suffix:semicolon
id|stack
op_assign
(paren
id|unix_socket
op_star
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Assume everything is now unmarked &n;&t; */
multiline_comment|/* Invariant to be maintained:&n;&t;&t;- everything marked is either:&n;&t;&t;-- (a) on the stack, or&n;&t;&t;-- (b) has all of its children marked&n;&t;&t;- everything on the stack is always marked&n;&t;&t;- nothing is ever pushed onto the stack twice, because:&n;&t;&t;-- nothing previously marked is ever pushed on the stack&n;&t; */
multiline_comment|/*&n;&t; *&t;Push root set&n;&t; */
r_for
c_loop
(paren
id|s
op_assign
id|unix_socket_list
suffix:semicolon
id|s
op_ne
l_int|NULL
suffix:semicolon
id|s
op_assign
id|s-&gt;next
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;If all instances of the descriptor are not&n;&t;&t; *&t;in flight we are in use.&n;&t;&t; */
r_if
c_cond
(paren
id|s-&gt;socket
op_logical_and
id|s-&gt;socket-&gt;file
op_logical_and
id|s-&gt;socket-&gt;file-&gt;f_count
OG
id|s-&gt;protinfo.af_unix.inflight
)paren
(brace
id|maybe_mark_and_push
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Mark phase &n;&t; */
r_while
c_loop
(paren
op_logical_neg
id|empty_stack
c_func
(paren
)paren
)paren
(brace
id|unix_socket
op_star
id|x
op_assign
id|pop_stack
c_func
(paren
)paren
suffix:semicolon
id|unix_socket
op_star
id|f
op_assign
l_int|NULL
comma
op_star
id|sk
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|tail
suffix:colon
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|x-&gt;receive_queue
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Loop through all but first born &n;&t;&t; */
r_while
c_loop
(paren
id|skb
op_logical_and
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|x-&gt;receive_queue
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Do we have file descriptors ?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;h.filp
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Process the descriptors of this socket&n;&t;&t;&t;&t; */
r_int
id|nfd
op_assign
op_star
(paren
r_int
op_star
)paren
id|skb-&gt;h.filp
suffix:semicolon
r_struct
id|file
op_star
op_star
id|fp
op_assign
(paren
r_struct
id|file
op_star
op_star
)paren
(paren
id|skb-&gt;h.filp
op_plus
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nfd
op_decrement
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;Get the socket the fd matches if&n;&t;&t;&t;&t;&t; *&t;it indeed does so&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|sk
op_assign
id|unix_get_socket
c_func
(paren
op_star
id|fp
op_increment
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; *&t;Remember the first, mark the&n;&t;&t;&t;&t;&t;&t; *&t;rest.&n;&t;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|f
op_eq
l_int|NULL
)paren
(brace
id|f
op_assign
id|sk
suffix:semicolon
)brace
r_else
id|maybe_mark_and_push
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
)brace
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Handle first born specially &n;&t;&t; */
r_if
c_cond
(paren
id|f
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|f-&gt;protinfo.af_unix.marksweep
op_amp
id|MARKED
)paren
)paren
(brace
id|f-&gt;protinfo.af_unix.marksweep
op_or_assign
id|MARKED
suffix:semicolon
id|x
op_assign
id|f
suffix:semicolon
id|f
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|tail
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; *&t;Sweep phase.  NOTE: this part dominates the time complexity &n;&t; */
r_for
c_loop
(paren
id|s
op_assign
id|unix_socket_list
suffix:semicolon
id|s
op_ne
l_int|NULL
suffix:semicolon
id|s
op_assign
id|next
)paren
(brace
id|next
op_assign
id|s-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|s-&gt;protinfo.af_unix.marksweep
op_amp
id|MARKED
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;We exist only in the passing tree of sockets&n;&t;&t;&t; *&t;that is no longer connected to active descriptors&n;&t;&t;&t; *&t;Time to die..&n;&t;&t;&t; *&n;&t;&t;&t; *&t;Subtle item: We will correctly sweep out the&n;&t;&t;&t; *&t;socket that has just been closed by the user.&n;&t;&t;&t; *&t;We must not close this as we are in the middle&n;&t;&t;&t; *&t;of its close at this moment. Skip that file&n;&t;&t;&t; *&t;using f_count==0 to spot it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|s-&gt;socket
op_logical_and
id|s-&gt;socket-&gt;file
op_logical_and
id|s-&gt;socket-&gt;file-&gt;f_count
)paren
(brace
id|close_fp
c_func
(paren
id|s-&gt;socket-&gt;file
)paren
suffix:semicolon
)brace
)brace
r_else
id|s-&gt;protinfo.af_unix.marksweep
op_and_assign
op_complement
id|MARKED
suffix:semicolon
multiline_comment|/* unmark everything for next collection */
)brace
id|in_unix_gc
op_assign
l_int|0
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
)paren
id|stack
)paren
suffix:semicolon
)brace
eof
