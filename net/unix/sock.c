multiline_comment|/*&n; * UNIX&t;&t;An implementation of the AF_UNIX network domain for the&n; *&t;&t;LINUX operating system.  UNIX is implemented using the&n; *&t;&t;BSD Socket interface as the means of communication with&n; *&t;&t;the user level.&n; *&n; * Version:&t;@(#)sock.c&t;1.0.5&t;05/25/93&n; *&n; * Authors:&t;Orest Zborowski, &lt;obz@Kodak.COM&gt;&n; *&t;&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;Verify Area&n; *&t;&t;NET2E Team&t;:&t;Page fault locks&n; *&t;Dmitry Gorodchanin&t;:&t;/proc locking&n; *&n; * To Do:&n; *&t;Some nice person is looking into Unix sockets done properly. NET3&n; *&t;will replace all of this and include datagram sockets and socket&n; *&t;options - so please stop asking me for them 8-)&n; *&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or(at your option) any later version.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/un.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/termios.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &quot;unix.h&quot;
multiline_comment|/*&n; *&t;Because these have the address in them they casually waste an extra 8K of kernel data&n; *&t;space that need not be wasted.&n; */
DECL|variable|unix_datas
r_struct
id|unix_proto_data
id|unix_datas
(braket
id|NSOCKETS
)braket
suffix:semicolon
r_static
r_int
id|unix_proto_create
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|protocol
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_dup
c_func
(paren
r_struct
id|socket
op_star
id|newsock
comma
r_struct
id|socket
op_star
id|oldsock
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_release
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|socket
op_star
id|peer
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_bind
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|umyaddr
comma
r_int
id|sockaddr_len
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_connect
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|uservaddr
comma
r_int
id|sockaddr_len
comma
r_int
id|flags
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_socketpair
c_func
(paren
r_struct
id|socket
op_star
id|sock1
comma
r_struct
id|socket
op_star
id|sock2
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_accept
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|socket
op_star
id|newsock
comma
r_int
id|flags
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_getname
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|usockaddr
comma
r_int
op_star
id|usockaddr_len
comma
r_int
id|peer
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_read
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_char
op_star
id|ubuf
comma
r_int
id|size
comma
r_int
id|nonblock
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_write
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_char
op_star
id|ubuf
comma
r_int
id|size
comma
r_int
id|nonblock
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_select
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_ioctl
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_listen
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|backlog
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_send
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_void
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_recv
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_void
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_sendto
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_void
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
comma
r_struct
id|sockaddr
op_star
id|addr
comma
r_int
id|addr_len
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_recvfrom
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_void
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
comma
r_struct
id|sockaddr
op_star
id|addr
comma
r_int
op_star
id|addr_len
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_shutdown
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|how
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_setsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
suffix:semicolon
r_static
r_int
id|unix_proto_getsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
suffix:semicolon
DECL|function|min
r_static
r_inline
r_int
id|min
c_func
(paren
r_int
id|a
comma
r_int
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
OL
id|b
)paren
r_return
id|a
suffix:semicolon
r_return
id|b
suffix:semicolon
)brace
multiline_comment|/* Support routines doing anti page fault locking &n; * FvK &amp; Matt Dillon (borrowed From NET2E3)&n; */
multiline_comment|/*&n; * Locking for unix-domain sockets.  We don&squot;t use the socket structure&squot;s&n; * wait queue because it is allowed to &squot;go away&squot; outside of our control,&n; * whereas unix_proto_data structures stick around.&n; */
DECL|function|unix_lock
r_static
r_void
id|unix_lock
c_func
(paren
r_struct
id|unix_proto_data
op_star
id|upd
)paren
(brace
r_while
c_loop
(paren
id|upd-&gt;lock_flag
)paren
id|sleep_on
c_func
(paren
op_amp
id|upd-&gt;wait
)paren
suffix:semicolon
id|upd-&gt;lock_flag
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|unix_unlock
r_static
r_void
id|unix_unlock
c_func
(paren
r_struct
id|unix_proto_data
op_star
id|upd
)paren
(brace
id|upd-&gt;lock_flag
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|upd-&gt;wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;We don&squot;t have to do anything. &n; */
DECL|function|unix_proto_listen
r_static
r_int
id|unix_proto_listen
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|backlog
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Until the new NET3 Unix code is done we have no options.&n; */
DECL|function|unix_proto_setsockopt
r_static
r_int
id|unix_proto_setsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
DECL|function|unix_proto_getsockopt
r_static
r_int
id|unix_proto_getsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;SendTo() doesn&squot;t matter as we also have no Datagram support!&n; */
DECL|function|unix_proto_sendto
r_static
r_int
id|unix_proto_sendto
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_void
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
comma
r_struct
id|sockaddr
op_star
id|addr
comma
r_int
id|addr_len
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
DECL|function|unix_proto_recvfrom
r_static
r_int
id|unix_proto_recvfrom
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_void
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
comma
r_struct
id|sockaddr
op_star
id|addr
comma
r_int
op_star
id|addr_len
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;You can&squot;t shutdown a unix domain socket.&n; */
DECL|function|unix_proto_shutdown
r_static
r_int
id|unix_proto_shutdown
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|how
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send data to a unix socket.&n; */
DECL|function|unix_proto_send
r_static
r_int
id|unix_proto_send
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_void
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
id|flags
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|unix_proto_write
c_func
(paren
id|sock
comma
(paren
r_char
op_star
)paren
id|buff
comma
id|len
comma
id|nonblock
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Receive data. This version of AF_UNIX also lacks MSG_PEEK 8(&n; */
DECL|function|unix_proto_recv
r_static
r_int
id|unix_proto_recv
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_void
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
id|flags
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|unix_proto_read
c_func
(paren
id|sock
comma
(paren
r_char
op_star
)paren
id|buff
comma
id|len
comma
id|nonblock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Given an address and an inode go find a unix control structure&n; */
r_static
r_struct
id|unix_proto_data
op_star
DECL|function|unix_data_lookup
id|unix_data_lookup
c_func
(paren
r_struct
id|sockaddr_un
op_star
id|sockun
comma
r_int
id|sockaddr_len
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|unix_proto_data
op_star
id|upd
suffix:semicolon
r_for
c_loop
(paren
id|upd
op_assign
id|unix_datas
suffix:semicolon
id|upd
op_le
id|last_unix_data
suffix:semicolon
op_increment
id|upd
)paren
(brace
r_if
c_cond
(paren
id|upd-&gt;refcnt
OG
l_int|0
op_logical_and
id|upd-&gt;socket
op_logical_and
id|upd-&gt;socket-&gt;state
op_eq
id|SS_UNCONNECTED
op_logical_and
id|upd-&gt;sockaddr_un.sun_family
op_eq
id|sockun-&gt;sun_family
op_logical_and
id|upd-&gt;inode
op_eq
id|inode
)paren
r_return
id|upd
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;We allocate a page of data for the socket. This is woefully inadequate and helps cause vast&n; *&t;amounts of excess task switching and blocking when transferring stuff like bitmaps via X.&n; *&t;It doesn&squot;t help this problem that the Linux scheduler is desperately in need of a major &n; *&t;rewrite. Somewhere near 16K would be better maybe 32.&n; */
r_static
r_struct
id|unix_proto_data
op_star
DECL|function|unix_data_alloc
id|unix_data_alloc
c_func
(paren
r_void
)paren
(brace
r_struct
id|unix_proto_data
op_star
id|upd
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|upd
op_assign
id|unix_datas
suffix:semicolon
id|upd
op_le
id|last_unix_data
suffix:semicolon
op_increment
id|upd
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|upd-&gt;refcnt
)paren
(brace
id|upd-&gt;refcnt
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* unix domain socket not yet initialised - bgm */
id|sti
c_func
(paren
)paren
suffix:semicolon
id|upd-&gt;socket
op_assign
l_int|NULL
suffix:semicolon
id|upd-&gt;sockaddr_len
op_assign
l_int|0
suffix:semicolon
id|upd-&gt;sockaddr_un.sun_family
op_assign
l_int|0
suffix:semicolon
id|upd-&gt;buf
op_assign
l_int|NULL
suffix:semicolon
id|upd-&gt;bp_head
op_assign
id|upd-&gt;bp_tail
op_assign
l_int|0
suffix:semicolon
id|upd-&gt;inode
op_assign
l_int|NULL
suffix:semicolon
id|upd-&gt;peerupd
op_assign
l_int|NULL
suffix:semicolon
r_return
id|upd
suffix:semicolon
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The data area is owned by all its users. Thus we need to track owners&n; *&t;carefully and not free data at the wrong moment. These look like they need&n; *&t;interrupt protection but they don&squot;t because no interrupt ever fiddles with&n; *&t;these counts. With an SMP Linux you&squot;ll need to protect these!&n; */
DECL|function|unix_data_ref
r_static
r_inline
r_void
id|unix_data_ref
c_func
(paren
r_struct
id|unix_proto_data
op_star
id|upd
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|upd
)paren
(brace
r_return
suffix:semicolon
)brace
op_increment
id|upd-&gt;refcnt
suffix:semicolon
)brace
DECL|function|unix_data_deref
r_static
r_void
id|unix_data_deref
c_func
(paren
r_struct
id|unix_proto_data
op_star
id|upd
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|upd
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|upd-&gt;refcnt
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|upd-&gt;buf
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|upd-&gt;buf
)paren
suffix:semicolon
id|upd-&gt;buf
op_assign
l_int|NULL
suffix:semicolon
id|upd-&gt;bp_head
op_assign
id|upd-&gt;bp_tail
op_assign
l_int|0
suffix:semicolon
)brace
)brace
op_decrement
id|upd-&gt;refcnt
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Upon a create, we allocate an empty protocol data,&n; *&t;and grab a page to buffer writes.&n; */
DECL|function|unix_proto_create
r_static
r_int
id|unix_proto_create
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|protocol
)paren
(brace
r_struct
id|unix_proto_data
op_star
id|upd
suffix:semicolon
multiline_comment|/*&n;&t; *&t;No funny SOCK_RAW stuff&n;&t; */
r_if
c_cond
(paren
id|protocol
op_ne
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|upd
op_assign
id|unix_data_alloc
c_func
(paren
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;UNIX: create: can&squot;t allocate buffer&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|upd-&gt;buf
op_assign
(paren
r_char
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_USER
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;UNIX: create: can&squot;t get page!&bslash;n&quot;
)paren
suffix:semicolon
id|unix_data_deref
c_func
(paren
id|upd
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|upd-&gt;protocol
op_assign
id|protocol
suffix:semicolon
id|upd-&gt;socket
op_assign
id|sock
suffix:semicolon
id|UN_DATA
c_func
(paren
id|sock
)paren
op_assign
id|upd
suffix:semicolon
id|upd-&gt;refcnt
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Now its complete - bgm */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Duplicate a socket.&n; */
DECL|function|unix_proto_dup
r_static
r_int
id|unix_proto_dup
c_func
(paren
r_struct
id|socket
op_star
id|newsock
comma
r_struct
id|socket
op_star
id|oldsock
)paren
(brace
r_struct
id|unix_proto_data
op_star
id|upd
op_assign
id|UN_DATA
c_func
(paren
id|oldsock
)paren
suffix:semicolon
r_return
id|unix_proto_create
c_func
(paren
id|newsock
comma
id|upd-&gt;protocol
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Release a Unix domain socket.&n; */
DECL|function|unix_proto_release
r_static
r_int
id|unix_proto_release
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|socket
op_star
id|peer
)paren
(brace
r_struct
id|unix_proto_data
op_star
id|upd
op_assign
id|UN_DATA
c_func
(paren
id|sock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|upd
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|upd-&gt;socket
op_ne
id|sock
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;UNIX: release: socket link mismatch!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|upd-&gt;inode
)paren
(brace
id|iput
c_func
(paren
id|upd-&gt;inode
)paren
suffix:semicolon
id|upd-&gt;inode
op_assign
l_int|NULL
suffix:semicolon
)brace
id|UN_DATA
c_func
(paren
id|sock
)paren
op_assign
l_int|NULL
suffix:semicolon
id|upd-&gt;socket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|upd-&gt;peerupd
)paren
id|unix_data_deref
c_func
(paren
id|upd-&gt;peerupd
)paren
suffix:semicolon
id|unix_data_deref
c_func
(paren
id|upd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Bind a name to a socket.&n; *&t;This is where much of the work is done: we allocate a fresh page for&n; *&t;the buffer, grab the appropriate inode and set things up.&n; *&n; *&t;FIXME: what should we do if an address is already bound?&n; *&t;  Here we return EINVAL, but it may be necessary to re-bind.&n; *&t;  I think thats what BSD does in the case of datagram sockets...&n; */
DECL|function|unix_proto_bind
r_static
r_int
id|unix_proto_bind
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|umyaddr
comma
r_int
id|sockaddr_len
)paren
(brace
r_char
id|fname
(braket
id|UNIX_PATH_MAX
op_plus
l_int|1
)braket
suffix:semicolon
r_struct
id|unix_proto_data
op_star
id|upd
op_assign
id|UN_DATA
c_func
(paren
id|sock
)paren
suffix:semicolon
r_int
r_int
id|old_fs
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|sockaddr_len
op_le
id|UN_PATH_OFFSET
op_logical_or
id|sockaddr_len
OG
r_sizeof
(paren
r_struct
id|sockaddr_un
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|upd-&gt;sockaddr_len
op_logical_or
id|upd-&gt;inode
)paren
(brace
multiline_comment|/*printk(&quot;UNIX: bind: already bound!&bslash;n&quot;);*/
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|upd-&gt;sockaddr_un
comma
id|umyaddr
comma
id|sockaddr_len
)paren
suffix:semicolon
id|upd-&gt;sockaddr_un.sun_path
(braket
id|sockaddr_len
op_minus
id|UN_PATH_OFFSET
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|upd-&gt;sockaddr_un.sun_family
op_ne
id|AF_UNIX
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|fname
comma
id|upd-&gt;sockaddr_un.sun_path
comma
id|sockaddr_len
op_minus
id|UN_PATH_OFFSET
)paren
suffix:semicolon
id|fname
(braket
id|sockaddr_len
op_minus
id|UN_PATH_OFFSET
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
id|i
op_assign
id|do_mknod
c_func
(paren
id|fname
comma
id|S_IFSOCK
op_or
id|S_IRWXUGO
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
id|i
op_assign
id|open_namei
c_func
(paren
id|fname
comma
l_int|0
comma
id|S_IFSOCK
comma
op_amp
id|upd-&gt;inode
comma
l_int|NULL
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|old_fs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
multiline_comment|/*&t;&t;printk(&quot;UNIX: bind: can&squot;t open socket %s&bslash;n&quot;, fname);*/
r_if
c_cond
(paren
id|i
op_eq
op_minus
id|EEXIST
)paren
(brace
id|i
op_assign
op_minus
id|EADDRINUSE
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
id|upd-&gt;sockaddr_len
op_assign
id|sockaddr_len
suffix:semicolon
multiline_comment|/* now its legal */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Perform a connection. we can only connect to unix sockets&n; *&t;(I can&squot;t for the life of me find an application where that&n; *&t;wouldn&squot;t be the case!)&n; */
DECL|function|unix_proto_connect
r_static
r_int
id|unix_proto_connect
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|uservaddr
comma
r_int
id|sockaddr_len
comma
r_int
id|flags
)paren
(brace
r_char
id|fname
(braket
r_sizeof
(paren
(paren
(paren
r_struct
id|sockaddr_un
op_star
)paren
l_int|0
)paren
op_member_access_from_pointer
id|sun_path
)paren
op_plus
l_int|1
)braket
suffix:semicolon
r_struct
id|sockaddr_un
id|sockun
suffix:semicolon
r_struct
id|unix_proto_data
op_star
id|serv_upd
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
r_int
id|old_fs
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|sockaddr_len
op_le
id|UN_PATH_OFFSET
op_logical_or
id|sockaddr_len
OG
r_sizeof
(paren
r_struct
id|sockaddr_un
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sock-&gt;state
op_eq
id|SS_CONNECTING
)paren
r_return
op_minus
id|EINPROGRESS
suffix:semicolon
r_if
c_cond
(paren
id|sock-&gt;state
op_eq
id|SS_CONNECTED
)paren
r_return
op_minus
id|EISCONN
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|sockun
comma
id|uservaddr
comma
id|sockaddr_len
)paren
suffix:semicolon
id|sockun.sun_path
(braket
id|sockaddr_len
op_minus
id|UN_PATH_OFFSET
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|sockun.sun_family
op_ne
id|AF_UNIX
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to open the name in the filesystem - this is how we&n; * identify ourselves and our server. Note that we don&squot;t&n; * hold onto the inode that long, just enough to find our&n; * server. When we&squot;re connected, we mooch off the server.&n; */
id|memcpy
c_func
(paren
id|fname
comma
id|sockun.sun_path
comma
id|sockaddr_len
op_minus
id|UN_PATH_OFFSET
)paren
suffix:semicolon
id|fname
(braket
id|sockaddr_len
op_minus
id|UN_PATH_OFFSET
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
id|i
op_assign
id|open_namei
c_func
(paren
id|fname
comma
l_int|0
comma
id|S_IFSOCK
comma
op_amp
id|inode
comma
l_int|NULL
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|old_fs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
id|serv_upd
op_assign
id|unix_data_lookup
c_func
(paren
op_amp
id|sockun
comma
id|sockaddr_len
comma
id|inode
)paren
suffix:semicolon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serv_upd
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|i
op_assign
id|sock_awaitconn
c_func
(paren
id|sock
comma
id|serv_upd-&gt;socket
comma
id|flags
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sock-&gt;conn
)paren
(brace
id|unix_data_ref
c_func
(paren
id|UN_DATA
c_func
(paren
id|sock-&gt;conn
)paren
)paren
suffix:semicolon
id|UN_DATA
c_func
(paren
id|sock
)paren
op_member_access_from_pointer
id|peerupd
op_assign
id|UN_DATA
c_func
(paren
id|sock-&gt;conn
)paren
suffix:semicolon
multiline_comment|/* ref server */
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;To do a socketpair, we just connect the two datas, easy!&n; *&t;Since we always wait on the socket inode, they&squot;re no contention&n; *&t;for a wait area, and deadlock prevention in the case of a process&n; *&t;writing to itself is, ignored, in true unix fashion!&n; */
DECL|function|unix_proto_socketpair
r_static
r_int
id|unix_proto_socketpair
c_func
(paren
r_struct
id|socket
op_star
id|sock1
comma
r_struct
id|socket
op_star
id|sock2
)paren
(brace
r_struct
id|unix_proto_data
op_star
id|upd1
op_assign
id|UN_DATA
c_func
(paren
id|sock1
)paren
comma
op_star
id|upd2
op_assign
id|UN_DATA
c_func
(paren
id|sock2
)paren
suffix:semicolon
id|unix_data_ref
c_func
(paren
id|upd1
)paren
suffix:semicolon
id|unix_data_ref
c_func
(paren
id|upd2
)paren
suffix:semicolon
id|upd1-&gt;peerupd
op_assign
id|upd2
suffix:semicolon
id|upd2-&gt;peerupd
op_assign
id|upd1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;On accept, we ref the peer&squot;s data for safe writes. &n; */
DECL|function|unix_proto_accept
r_static
r_int
id|unix_proto_accept
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|socket
op_star
id|newsock
comma
r_int
id|flags
)paren
(brace
r_struct
id|socket
op_star
id|clientsock
suffix:semicolon
multiline_comment|/*&n; * If there aren&squot;t any sockets awaiting connection,&n; * then wait for one, unless nonblocking.&n; */
r_while
c_loop
(paren
op_logical_neg
(paren
id|clientsock
op_assign
id|sock-&gt;iconn
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|O_NONBLOCK
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|sock-&gt;flags
op_or_assign
id|SO_WAITDATA
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
id|sock-&gt;wait
)paren
suffix:semicolon
id|sock-&gt;flags
op_and_assign
op_complement
id|SO_WAITDATA
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Great. Finish the connection relative to server and client,&n; * wake up the client and return the new fd to the server.&n; */
id|sock-&gt;iconn
op_assign
id|clientsock-&gt;next
suffix:semicolon
id|clientsock-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|newsock-&gt;conn
op_assign
id|clientsock
suffix:semicolon
id|clientsock-&gt;conn
op_assign
id|newsock
suffix:semicolon
id|clientsock-&gt;state
op_assign
id|SS_CONNECTED
suffix:semicolon
id|newsock-&gt;state
op_assign
id|SS_CONNECTED
suffix:semicolon
id|unix_data_ref
c_func
(paren
id|UN_DATA
c_func
(paren
id|clientsock
)paren
)paren
suffix:semicolon
id|UN_DATA
c_func
(paren
id|newsock
)paren
op_member_access_from_pointer
id|peerupd
op_assign
id|UN_DATA
c_func
(paren
id|clientsock
)paren
suffix:semicolon
id|UN_DATA
c_func
(paren
id|newsock
)paren
op_member_access_from_pointer
id|sockaddr_un
op_assign
id|UN_DATA
c_func
(paren
id|sock
)paren
op_member_access_from_pointer
id|sockaddr_un
suffix:semicolon
id|UN_DATA
c_func
(paren
id|newsock
)paren
op_member_access_from_pointer
id|sockaddr_len
op_assign
id|UN_DATA
c_func
(paren
id|sock
)paren
op_member_access_from_pointer
id|sockaddr_len
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
id|clientsock-&gt;wait
)paren
suffix:semicolon
id|sock_wake_async
c_func
(paren
id|clientsock
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Gets the current name or the name of the connected socket. &n; */
DECL|function|unix_proto_getname
r_static
r_int
id|unix_proto_getname
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|usockaddr
comma
r_int
op_star
id|usockaddr_len
comma
r_int
id|peer
)paren
(brace
r_struct
id|unix_proto_data
op_star
id|upd
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|peer
)paren
(brace
r_if
c_cond
(paren
id|sock-&gt;state
op_ne
id|SS_CONNECTED
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|upd
op_assign
id|UN_DATA
c_func
(paren
id|sock-&gt;conn
)paren
suffix:semicolon
)brace
r_else
id|upd
op_assign
id|UN_DATA
c_func
(paren
id|sock
)paren
suffix:semicolon
id|len
op_assign
id|upd-&gt;sockaddr_len
suffix:semicolon
id|memcpy
c_func
(paren
id|usockaddr
comma
op_amp
id|upd-&gt;sockaddr_un
comma
id|len
)paren
suffix:semicolon
op_star
id|usockaddr_len
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;We read from our own buf. &n; */
DECL|function|unix_proto_read
r_static
r_int
id|unix_proto_read
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_char
op_star
id|ubuf
comma
r_int
id|size
comma
r_int
id|nonblock
)paren
(brace
r_struct
id|unix_proto_data
op_star
id|upd
suffix:semicolon
r_int
id|todo
comma
id|avail
suffix:semicolon
r_if
c_cond
(paren
(paren
id|todo
op_assign
id|size
)paren
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|upd
op_assign
id|UN_DATA
c_func
(paren
id|sock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|avail
op_assign
id|UN_BUF_AVAIL
c_func
(paren
id|upd
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|sock-&gt;state
op_ne
id|SS_CONNECTED
)paren
(brace
r_return
(paren
id|sock-&gt;state
op_eq
id|SS_DISCONNECTING
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nonblock
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|sock-&gt;flags
op_or_assign
id|SO_WAITDATA
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
id|sock-&gt;wait
)paren
suffix:semicolon
id|sock-&gt;flags
op_and_assign
op_complement
id|SO_WAITDATA
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Copy from the read buffer into the user&squot;s buffer,&n; *&t;watching for wraparound. Then we wake up the writer.&n; */
id|unix_lock
c_func
(paren
id|upd
)paren
suffix:semicolon
r_do
(brace
r_int
id|part
comma
id|cando
suffix:semicolon
r_if
c_cond
(paren
id|avail
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;UNIX: read: AVAIL IS NEGATIVE!!!&bslash;n&quot;
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cando
op_assign
id|todo
)paren
OG
id|avail
)paren
id|cando
op_assign
id|avail
suffix:semicolon
r_if
c_cond
(paren
id|cando
OG
(paren
id|part
op_assign
id|BUF_SIZE
op_minus
id|upd-&gt;bp_tail
)paren
)paren
id|cando
op_assign
id|part
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|ubuf
comma
id|upd-&gt;buf
op_plus
id|upd-&gt;bp_tail
comma
id|cando
)paren
suffix:semicolon
id|upd-&gt;bp_tail
op_assign
(paren
id|upd-&gt;bp_tail
op_plus
id|cando
)paren
op_amp
(paren
id|BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|ubuf
op_add_assign
id|cando
suffix:semicolon
id|todo
op_sub_assign
id|cando
suffix:semicolon
r_if
c_cond
(paren
id|sock-&gt;state
op_eq
id|SS_CONNECTED
)paren
(brace
id|wake_up_interruptible
c_func
(paren
id|sock-&gt;conn-&gt;wait
)paren
suffix:semicolon
id|sock_wake_async
c_func
(paren
id|sock-&gt;conn
comma
l_int|2
)paren
suffix:semicolon
)brace
id|avail
op_assign
id|UN_BUF_AVAIL
c_func
(paren
id|upd
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|todo
op_logical_and
id|avail
)paren
(brace
suffix:semicolon
)brace
id|unix_unlock
c_func
(paren
id|upd
)paren
suffix:semicolon
r_return
id|size
op_minus
id|todo
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;We write to our peer&squot;s buf. When we connected we ref&squot;d this&n; *&t;peer so we are safe that the buffer remains, even after the&n; *&t;peer has disconnected, which we check other ways.&n; */
DECL|function|unix_proto_write
r_static
r_int
id|unix_proto_write
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_char
op_star
id|ubuf
comma
r_int
id|size
comma
r_int
id|nonblock
)paren
(brace
r_struct
id|unix_proto_data
op_star
id|pupd
suffix:semicolon
r_int
id|todo
comma
id|space
suffix:semicolon
r_if
c_cond
(paren
(paren
id|todo
op_assign
id|size
)paren
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sock-&gt;state
op_ne
id|SS_CONNECTED
)paren
(brace
r_if
c_cond
(paren
id|sock-&gt;state
op_eq
id|SS_DISCONNECTING
)paren
(brace
id|send_sig
c_func
(paren
id|SIGPIPE
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|pupd
op_assign
id|UN_DATA
c_func
(paren
id|sock
)paren
op_member_access_from_pointer
id|peerupd
suffix:semicolon
multiline_comment|/* safer than sock-&gt;conn */
r_while
c_loop
(paren
op_logical_neg
(paren
id|space
op_assign
id|UN_BUF_SPACE
c_func
(paren
id|pupd
)paren
)paren
)paren
(brace
id|sock-&gt;flags
op_or_assign
id|SO_NOSPACE
suffix:semicolon
r_if
c_cond
(paren
id|nonblock
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|sock-&gt;flags
op_and_assign
op_complement
id|SO_NOSPACE
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
id|sock-&gt;wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sock-&gt;state
op_eq
id|SS_DISCONNECTING
)paren
(brace
id|send_sig
c_func
(paren
id|SIGPIPE
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Copy from the user&squot;s buffer to the write buffer,&n; *&t;watching for wraparound. Then we wake up the reader.&n; */
id|unix_lock
c_func
(paren
id|pupd
)paren
suffix:semicolon
r_do
(brace
r_int
id|part
comma
id|cando
suffix:semicolon
r_if
c_cond
(paren
id|space
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;UNIX: write: SPACE IS NEGATIVE!!!&bslash;n&quot;
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;We may become disconnected inside this loop, so watch&n;&t;&t; *&t;for it (peerupd is safe until we close).&n;&t;&t; */
r_if
c_cond
(paren
id|sock-&gt;state
op_eq
id|SS_DISCONNECTING
)paren
(brace
id|send_sig
c_func
(paren
id|SIGPIPE
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
id|unix_unlock
c_func
(paren
id|pupd
)paren
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cando
op_assign
id|todo
)paren
OG
id|space
)paren
id|cando
op_assign
id|space
suffix:semicolon
r_if
c_cond
(paren
id|cando
OG
(paren
id|part
op_assign
id|BUF_SIZE
op_minus
id|pupd-&gt;bp_head
)paren
)paren
id|cando
op_assign
id|part
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
id|pupd-&gt;buf
op_plus
id|pupd-&gt;bp_head
comma
id|ubuf
comma
id|cando
)paren
suffix:semicolon
id|pupd-&gt;bp_head
op_assign
(paren
id|pupd-&gt;bp_head
op_plus
id|cando
)paren
op_amp
(paren
id|BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|ubuf
op_add_assign
id|cando
suffix:semicolon
id|todo
op_sub_assign
id|cando
suffix:semicolon
r_if
c_cond
(paren
id|sock-&gt;state
op_eq
id|SS_CONNECTED
)paren
(brace
id|wake_up_interruptible
c_func
(paren
id|sock-&gt;conn-&gt;wait
)paren
suffix:semicolon
id|sock_wake_async
c_func
(paren
id|sock-&gt;conn
comma
l_int|1
)paren
suffix:semicolon
)brace
id|space
op_assign
id|UN_BUF_SPACE
c_func
(paren
id|pupd
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|todo
op_logical_and
id|space
)paren
(brace
suffix:semicolon
)brace
id|unix_unlock
c_func
(paren
id|pupd
)paren
suffix:semicolon
r_return
id|size
op_minus
id|todo
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Select on a unix domain socket.&n; */
DECL|function|unix_proto_select
r_static
r_int
id|unix_proto_select
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
(brace
r_struct
id|unix_proto_data
op_star
id|upd
comma
op_star
id|peerupd
suffix:semicolon
multiline_comment|/* &n;&t; *&t;Handle server sockets specially.&n;&t; */
r_if
c_cond
(paren
id|sock-&gt;flags
op_amp
id|SO_ACCEPTCON
)paren
(brace
r_if
c_cond
(paren
id|sel_type
op_eq
id|SEL_IN
)paren
(brace
r_if
c_cond
(paren
id|sock-&gt;iconn
)paren
r_return
l_int|1
suffix:semicolon
id|select_wait
c_func
(paren
id|sock-&gt;wait
comma
id|wait
)paren
suffix:semicolon
r_return
id|sock-&gt;iconn
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
id|select_wait
c_func
(paren
id|sock-&gt;wait
comma
id|wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sel_type
op_eq
id|SEL_IN
)paren
(brace
id|upd
op_assign
id|UN_DATA
c_func
(paren
id|sock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UN_BUF_AVAIL
c_func
(paren
id|upd
)paren
)paren
multiline_comment|/* even if disconnected */
r_return
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sock-&gt;state
op_ne
id|SS_CONNECTED
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|select_wait
c_func
(paren
id|sock-&gt;wait
comma
id|wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sel_type
op_eq
id|SEL_OUT
)paren
(brace
r_if
c_cond
(paren
id|sock-&gt;state
op_ne
id|SS_CONNECTED
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|peerupd
op_assign
id|UN_DATA
c_func
(paren
id|sock-&gt;conn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UN_BUF_SPACE
c_func
(paren
id|peerupd
)paren
OG
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|select_wait
c_func
(paren
id|sock-&gt;wait
comma
id|wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Exceptions - SEL_EX &n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;ioctl() calls sent to an AF_UNIX socket&n; */
DECL|function|unix_proto_ioctl
r_static
r_int
id|unix_proto_ioctl
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|unix_proto_data
op_star
id|upd
comma
op_star
id|peerupd
suffix:semicolon
r_int
id|er
suffix:semicolon
id|upd
op_assign
id|UN_DATA
c_func
(paren
id|sock
)paren
suffix:semicolon
id|peerupd
op_assign
(paren
id|sock-&gt;state
op_eq
id|SS_CONNECTED
)paren
ques
c_cond
id|UN_DATA
c_func
(paren
id|sock-&gt;conn
)paren
suffix:colon
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCINQ
suffix:colon
r_if
c_cond
(paren
id|sock-&gt;flags
op_amp
id|SO_ACCEPTCON
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|er
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|er
)paren
(brace
r_return
id|er
suffix:semicolon
)brace
r_if
c_cond
(paren
id|UN_BUF_AVAIL
c_func
(paren
id|upd
)paren
op_logical_or
id|peerupd
)paren
id|put_fs_long
c_func
(paren
id|UN_BUF_AVAIL
c_func
(paren
id|upd
)paren
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_else
id|put_fs_long
c_func
(paren
l_int|0
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCOUTQ
suffix:colon
r_if
c_cond
(paren
id|sock-&gt;flags
op_amp
id|SO_ACCEPTCON
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|er
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|er
)paren
(brace
r_return
id|er
suffix:semicolon
)brace
r_if
c_cond
(paren
id|peerupd
)paren
id|put_fs_long
c_func
(paren
id|UN_BUF_SPACE
c_func
(paren
id|peerupd
)paren
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_else
id|put_fs_long
c_func
(paren
l_int|0
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|unix_proto_ops
r_static
r_struct
id|proto_ops
id|unix_proto_ops
op_assign
(brace
id|AF_UNIX
comma
id|unix_proto_create
comma
id|unix_proto_dup
comma
id|unix_proto_release
comma
id|unix_proto_bind
comma
id|unix_proto_connect
comma
id|unix_proto_socketpair
comma
id|unix_proto_accept
comma
id|unix_proto_getname
comma
id|unix_proto_read
comma
id|unix_proto_write
comma
id|unix_proto_select
comma
id|unix_proto_ioctl
comma
id|unix_proto_listen
comma
id|unix_proto_send
comma
id|unix_proto_recv
comma
id|unix_proto_sendto
comma
id|unix_proto_recvfrom
comma
id|unix_proto_shutdown
comma
id|unix_proto_setsockopt
comma
id|unix_proto_getsockopt
comma
l_int|NULL
multiline_comment|/* unix_proto_fcntl&t;*/
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Initialise the Unix domain protocol.&n; */
DECL|function|unix_proto_init
r_void
id|unix_proto_init
c_func
(paren
r_struct
id|net_proto
op_star
id|pro
)paren
(brace
r_struct
id|unix_proto_data
op_star
id|upd
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Tell SOCKET that we are alive... &n;&t; */
(paren
r_void
)paren
id|sock_register
c_func
(paren
id|unix_proto_ops.family
comma
op_amp
id|unix_proto_ops
)paren
suffix:semicolon
r_for
c_loop
(paren
id|upd
op_assign
id|unix_datas
suffix:semicolon
id|upd
op_le
id|last_unix_data
suffix:semicolon
op_increment
id|upd
)paren
(brace
id|upd-&gt;refcnt
op_assign
l_int|0
suffix:semicolon
)brace
)brace
eof
