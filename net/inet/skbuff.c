multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;A saner implementation of the skbuff stuff scattered everywhere&n; *&t;&t;in the old NET2D code.&n; *&n; *&t;Authors:&t;Alan Cox &lt;iiitac@pyr.swan.ac.uk&gt;&n; *&n; *&t;Fixes:&n; *&t;&t;Alan Cox&t;:&t;Tracks memory and number of buffers for kernel memory report&n; *&t;&t;&t;&t;&t;and memory leak hunting.&n; *&t;&t;Alan Cox&t;:&t;More generic kfree handler&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &quot;inet.h&quot;
macro_line|#include &quot;dev.h&quot;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;arp.h&quot;
macro_line|#include &quot;route.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &quot;udp.h&quot;
macro_line|#include &quot;skbuff.h&quot;
macro_line|#include &quot;sock.h&quot;
multiline_comment|/* Socket buffer operations. Ideally much of this list swap stuff ought to be using&n;   exch instructions on the 386, and CAS/CAS2 on a 68K. This is the boring generic&n;   slow C version. No doubt when Linus sees this comment he&squot;ll do horrible things&n;   to this code 8-)&n;*/
multiline_comment|/*&n; *&t;Resource tracking variables&n; */
DECL|variable|net_memory
r_volatile
r_int
r_int
id|net_memory
op_assign
l_int|0
suffix:semicolon
DECL|variable|net_skbcount
r_volatile
r_int
r_int
id|net_skbcount
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; *&t;Debugging paranoia. Can go later when this crud stack works&n; */
DECL|function|skb_check
r_void
id|skb_check
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|line
comma
r_char
op_star
id|file
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;magic_debug_cookie
op_eq
id|SK_FREED_SKB
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;File: %s Line %d, found a freed skb lurking in the undergrowth!&bslash;n&quot;
comma
id|file
comma
id|line
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;skb=%p, real size=%ld, claimed size=%ld, magic=%d, list=%p, free=%d&bslash;n&quot;
comma
id|skb
comma
id|skb-&gt;truesize
comma
id|skb-&gt;mem_len
comma
id|skb-&gt;magic
comma
id|skb-&gt;list
comma
id|skb-&gt;free
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;magic_debug_cookie
op_ne
id|SK_GOOD_SKB
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;File: %s Line %d, passed a non skb!&bslash;n&quot;
comma
id|file
comma
id|line
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;skb=%p, real size=%ld, claimed size=%ld, magic=%d, list=%p, free=%d&bslash;n&quot;
comma
id|skb
comma
id|skb-&gt;truesize
comma
id|skb-&gt;mem_len
comma
id|skb-&gt;magic
comma
id|skb-&gt;list
comma
id|skb-&gt;free
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;mem_len
op_ne
id|skb-&gt;truesize
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;File: %s Line %d, Dubious size setting!&bslash;n&quot;
comma
id|file
comma
id|line
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;skb=%p, real size=%ld, claimed size=%ld, magic=%d, list=%p&bslash;n&quot;
comma
id|skb
comma
id|skb-&gt;truesize
comma
id|skb-&gt;mem_len
comma
id|skb-&gt;magic
comma
id|skb-&gt;list
)paren
suffix:semicolon
)brace
multiline_comment|/* Guess it might be acceptable then */
)brace
multiline_comment|/*&n; *&t;Insert an sk_buff at the start of a list.&n; */
DECL|function|skb_queue_head
r_void
id|skb_queue_head
c_func
(paren
r_struct
id|sk_buff
op_star
r_volatile
op_star
id|list
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|IS_SKB
c_func
(paren
id|newsk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newsk-&gt;list
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Suspicious queue head: sk_buff on list!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|newsk-&gt;list
op_assign
id|list
suffix:semicolon
id|newsk-&gt;next
op_assign
op_star
id|list
suffix:semicolon
r_if
c_cond
(paren
op_star
id|list
)paren
(brace
id|newsk-&gt;prev
op_assign
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|prev
suffix:semicolon
)brace
r_else
id|newsk-&gt;prev
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;prev-&gt;next
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;next-&gt;prev
op_assign
id|newsk
suffix:semicolon
id|IS_SKB
c_func
(paren
id|newsk-&gt;prev
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|newsk-&gt;next
)paren
suffix:semicolon
op_star
id|list
op_assign
id|newsk
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Insert an sk_buff at the end of a list.&n; */
DECL|function|skb_queue_tail
r_void
id|skb_queue_tail
c_func
(paren
r_struct
id|sk_buff
op_star
r_volatile
op_star
id|list
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|newsk-&gt;list
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Suspicious queue tail: sk_buff on list!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|IS_SKB
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|newsk-&gt;list
op_assign
id|list
suffix:semicolon
r_if
c_cond
(paren
op_star
id|list
)paren
(brace
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|prev-&gt;next
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;prev
op_assign
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|prev
suffix:semicolon
id|newsk-&gt;next
op_assign
op_star
id|list
suffix:semicolon
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|prev
op_assign
id|newsk
suffix:semicolon
)brace
r_else
(brace
id|newsk-&gt;next
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;prev
op_assign
id|newsk
suffix:semicolon
op_star
id|list
op_assign
id|newsk
suffix:semicolon
)brace
id|IS_SKB
c_func
(paren
id|newsk-&gt;prev
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|newsk-&gt;next
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Remove an sk_buff from a list. This routine is also interrupt safe&n; *&t;so you can grab read and free buffers as another process adds them.&n; */
DECL|function|skb_dequeue
r_struct
id|sk_buff
op_star
id|skb_dequeue
c_func
(paren
r_struct
id|sk_buff
op_star
r_volatile
op_star
id|list
)paren
(brace
r_int
id|flags
suffix:semicolon
r_struct
id|sk_buff
op_star
id|result
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|list
op_eq
l_int|NULL
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|result
op_assign
op_star
id|list
suffix:semicolon
r_if
c_cond
(paren
id|result-&gt;next
op_eq
id|result
)paren
(brace
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|result-&gt;next-&gt;prev
op_assign
id|result-&gt;prev
suffix:semicolon
id|result-&gt;prev-&gt;next
op_assign
id|result-&gt;next
suffix:semicolon
op_star
id|list
op_assign
id|result-&gt;next
suffix:semicolon
)brace
id|IS_SKB
c_func
(paren
id|result
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result-&gt;list
op_ne
id|list
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Dequeued packet has invalid list pointer&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|result-&gt;list
op_assign
l_int|0
suffix:semicolon
id|result-&gt;next
op_assign
l_int|0
suffix:semicolon
id|result-&gt;prev
op_assign
l_int|0
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Insert a packet before another one in a list.&n; */
DECL|function|skb_insert
r_void
id|skb_insert
c_func
(paren
r_struct
id|sk_buff
op_star
id|old
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|IS_SKB
c_func
(paren
id|old
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|newsk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old-&gt;list
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;insert before unlisted item!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newsk-&gt;list
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;inserted item is already on a list.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|newsk-&gt;list
op_assign
id|old-&gt;list
suffix:semicolon
id|newsk-&gt;next
op_assign
id|old
suffix:semicolon
id|newsk-&gt;prev
op_assign
id|old-&gt;prev
suffix:semicolon
id|newsk-&gt;next-&gt;prev
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;prev-&gt;next
op_assign
id|newsk
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Place a packet after a given packet in a list.&n; */
DECL|function|skb_append
r_void
id|skb_append
c_func
(paren
r_struct
id|sk_buff
op_star
id|old
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|IS_SKB
c_func
(paren
id|old
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|newsk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old-&gt;list
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;append before unlisted item!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newsk-&gt;list
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;append item is already on a list.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|newsk-&gt;list
op_assign
id|old-&gt;list
suffix:semicolon
id|newsk-&gt;prev
op_assign
id|old
suffix:semicolon
id|newsk-&gt;next
op_assign
id|old-&gt;next
suffix:semicolon
id|newsk-&gt;next-&gt;prev
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;prev-&gt;next
op_assign
id|newsk
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Remove an sk_buff from its list. Works even without knowing the list it&n; *&t;is sitting on, which can be handy at times. It also means that THE LIST&n; *&t;MUST EXIST when you unlink. Thus a list must have its contents unlinked&n; *&t;_FIRST_.&n; */
DECL|function|skb_unlink
r_void
id|skb_unlink
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;list
)paren
(brace
id|skb-&gt;next-&gt;prev
op_assign
id|skb-&gt;prev
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_star
id|skb-&gt;list
op_eq
id|skb
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;next
op_eq
id|skb
)paren
(brace
op_star
id|skb-&gt;list
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
op_star
id|skb-&gt;list
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
id|skb-&gt;next
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;prev
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;list
op_assign
l_int|0
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;An skbuff list has had its head reassigned. Move all the list&n; *&t;pointers. Must be called with ints off during the whole head&n; *&t;shifting&n; */
DECL|function|skb_new_list_head
r_void
id|skb_new_list_head
c_func
(paren
r_struct
id|sk_buff
op_star
r_volatile
op_star
id|list
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|skb_peek
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
r_do
(brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb-&gt;list
op_assign
id|list
suffix:semicolon
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|skb
op_ne
op_star
id|list
)paren
(brace
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; *&t;Peek an sk_buff. Unlike most other operations you _MUST_&n; *&t;be careful with this one. A peek leaves the buffer on the&n; *&t;list and someone else may run off with it. For an interrupt&n; *&t;type system cli() peek the buffer copy the data and sti();&n; */
DECL|function|skb_peek
r_struct
id|sk_buff
op_star
id|skb_peek
c_func
(paren
r_struct
id|sk_buff
op_star
r_volatile
op_star
id|list
)paren
(brace
r_return
op_star
id|list
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get a clone of an sk_buff. This is the safe way to peek at&n; *&t;a socket queue without accidents. Its a bit long but most&n; *&t;of it acutally ends up as tiny bits of inline assembler&n; *&t;anyway. Only the memcpy of upto 4K with ints off is not&n; *&t;as nice as I&squot;d like.&n; */
DECL|function|skb_peek_copy
r_struct
id|sk_buff
op_star
id|skb_peek_copy
c_func
(paren
r_struct
id|sk_buff
op_star
r_volatile
op_star
id|list
)paren
(brace
r_struct
id|sk_buff
op_star
id|orig
comma
op_star
id|newsk
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
multiline_comment|/* Now for some games to avoid races */
r_do
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|orig
op_assign
id|skb_peek
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|orig
op_eq
l_int|NULL
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|IS_SKB
c_func
(paren
id|orig
)paren
suffix:semicolon
id|len
op_assign
id|orig-&gt;truesize
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|newsk
op_assign
id|alloc_skb
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* May sleep */
r_if
c_cond
(paren
id|newsk
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Oh dear... not to worry */
r_return
l_int|NULL
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
id|list
)paren
op_ne
id|orig
)paren
multiline_comment|/* List changed go around another time */
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|newsk-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;free
op_assign
l_int|1
suffix:semicolon
id|newsk-&gt;mem_addr
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;mem_len
op_assign
id|len
suffix:semicolon
id|kfree_skb
c_func
(paren
id|newsk
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|IS_SKB
c_func
(paren
id|orig
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|newsk
comma
id|orig
comma
id|len
)paren
suffix:semicolon
id|newsk-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;magic
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;mem_addr
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;h.raw
op_add_assign
(paren
(paren
r_char
op_star
)paren
id|newsk
op_minus
(paren
r_char
op_star
)paren
id|orig
)paren
suffix:semicolon
id|newsk-&gt;link3
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;free
op_assign
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|0
)paren
(brace
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|newsk
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Free an sk_buff. This still knows about things it should&n; *&t;not need to like protocols and sockets.&n; */
DECL|function|kfree_skb
r_void
id|kfree_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|rw
)paren
(brace
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kfree_skb: skb = NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;lock
)paren
(brace
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Free when unlocked */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;free
op_eq
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: kfree_skb passed an skb that nobody set the free flag on!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;list
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: kfree_skb passed an skb still on a list.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|skb-&gt;magic
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;sk
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;sk-&gt;prot
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|rw
)paren
id|skb-&gt;sk-&gt;prot
op_member_access_from_pointer
id|rfree
c_func
(paren
id|skb-&gt;sk
comma
id|skb-&gt;mem_addr
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
r_else
id|skb-&gt;sk-&gt;prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|skb-&gt;sk
comma
id|skb-&gt;mem_addr
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Non INET - default wmalloc/rmalloc handler */
r_if
c_cond
(paren
id|rw
)paren
id|skb-&gt;sk-&gt;rmem_alloc
op_sub_assign
id|skb-&gt;mem_len
suffix:semicolon
r_else
id|skb-&gt;sk-&gt;wmem_alloc
op_sub_assign
id|skb-&gt;mem_len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;sk-&gt;dead
)paren
(brace
id|wake_up_interruptible
c_func
(paren
id|skb-&gt;sk-&gt;sleep
)paren
suffix:semicolon
)brace
id|kfree_skbmem
c_func
(paren
id|skb-&gt;mem_addr
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
)brace
)brace
r_else
id|kfree_skbmem
c_func
(paren
id|skb-&gt;mem_addr
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Allocate a new skbuff. We do this ourselves so we can fill in a few &squot;private&squot;&n; *&t;fields and also do memory statistics to find all the [BEEP] leaks.&n; */
DECL|function|alloc_skb
r_struct
id|sk_buff
op_star
id|alloc_skb
c_func
(paren
r_int
r_int
id|size
comma
r_int
id|priority
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_extern
r_int
r_int
id|intr_count
suffix:semicolon
r_if
c_cond
(paren
id|intr_count
op_logical_and
id|priority
op_ne
id|GFP_ATOMIC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;alloc_skb called nonatomically from interrupt %08lx&bslash;n&quot;
comma
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|size
)paren
(braket
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|priority
op_assign
id|GFP_ATOMIC
suffix:semicolon
)brace
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|skb-&gt;free
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Invalid so we pick up forgetful users */
id|skb-&gt;list
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Not on a list */
id|skb-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;truesize
op_assign
id|size
suffix:semicolon
id|skb-&gt;mem_len
op_assign
id|size
suffix:semicolon
id|skb-&gt;mem_addr
op_assign
id|skb
suffix:semicolon
id|skb-&gt;fraglist
op_assign
l_int|NULL
suffix:semicolon
id|net_memory
op_add_assign
id|size
suffix:semicolon
id|net_skbcount
op_increment
suffix:semicolon
id|skb-&gt;magic_debug_cookie
op_assign
id|SK_GOOD_SKB
suffix:semicolon
id|skb-&gt;users
op_assign
l_int|0
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Free an skbuff by memory&n; */
DECL|function|kfree_skbmem
r_void
id|kfree_skbmem
c_func
(paren
r_void
op_star
id|mem
comma
r_int
id|size
)paren
(brace
r_struct
id|sk_buff
op_star
id|x
op_assign
id|mem
suffix:semicolon
id|IS_SKB
c_func
(paren
id|x
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;magic_debug_cookie
op_eq
id|SK_GOOD_SKB
)paren
(brace
id|x-&gt;magic_debug_cookie
op_assign
id|SK_FREED_SKB
suffix:semicolon
id|kfree_s
c_func
(paren
id|mem
comma
id|size
)paren
suffix:semicolon
id|net_skbcount
op_decrement
suffix:semicolon
id|net_memory
op_sub_assign
id|size
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Skbuff device locking&n; */
DECL|function|skb_kept_by_device
r_void
id|skb_kept_by_device
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|skb-&gt;lock
op_increment
suffix:semicolon
)brace
DECL|function|skb_device_release
r_void
id|skb_device_release
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|mode
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|skb-&gt;lock
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;free
op_eq
l_int|1
)paren
id|kfree_skb
c_func
(paren
id|skb
comma
id|mode
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|skb_device_locked
r_int
id|skb_device_locked
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;lock
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
