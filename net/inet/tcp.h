multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Definitions for the TCP module.&n; *&n; * Version:&t;@(#)tcp.h&t;1.0.5&t;05/23/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#ifndef _TCP_H
DECL|macro|_TCP_H
mdefine_line|#define _TCP_H
macro_line|#include &lt;linux/tcp.h&gt;
DECL|macro|MAX_SYN_SIZE
mdefine_line|#define MAX_SYN_SIZE&t;44 + sizeof (struct sk_buff) + MAX_HEADER
DECL|macro|MAX_FIN_SIZE
mdefine_line|#define MAX_FIN_SIZE&t;40 + sizeof (struct sk_buff) + MAX_HEADER
DECL|macro|MAX_ACK_SIZE
mdefine_line|#define MAX_ACK_SIZE&t;40 + sizeof (struct sk_buff) + MAX_HEADER
DECL|macro|MAX_RESET_SIZE
mdefine_line|#define MAX_RESET_SIZE&t;40 + sizeof (struct sk_buff) + MAX_HEADER
DECL|macro|MAX_WINDOW
mdefine_line|#define MAX_WINDOW&t;4096
DECL|macro|MIN_WINDOW
mdefine_line|#define MIN_WINDOW&t;2048
DECL|macro|MAX_ACK_BACKLOG
mdefine_line|#define MAX_ACK_BACKLOG&t;2
DECL|macro|MIN_WRITE_SPACE
mdefine_line|#define MIN_WRITE_SPACE&t;2048
DECL|macro|TCP_WINDOW_DIFF
mdefine_line|#define TCP_WINDOW_DIFF&t;2048
DECL|macro|TCP_RETR1
mdefine_line|#define TCP_RETR1&t;7&t;/*&n;&t;&t;&t;&t; * This is howmany retries it does before it&n;&t;&t;&t;&t; * tries to figure out if the gateway is&n;&t;&t;&t;&t; * down.&n;&t;&t;&t;&t; */
DECL|macro|TCP_RETR2
mdefine_line|#define TCP_RETR2&t;15&t;/*&n;&t;&t;&t;&t; * This should take at least&n;&t;&t;&t;&t; * 90 minutes to time out.&n;&t;&t;&t;&t; */
DECL|macro|TCP_TIMEOUT_LEN
mdefine_line|#define TCP_TIMEOUT_LEN&t;720000&t;/* should be about 2 hrs&t;&t;*/
DECL|macro|TCP_TIMEWAIT_LEN
mdefine_line|#define TCP_TIMEWAIT_LEN 1000&t;/* how long to wait to sucessfully &n;&t;&t;&t;&t; * close the socket, about 60 seconds&t;*/
DECL|macro|TCP_ACK_TIME
mdefine_line|#define TCP_ACK_TIME&t;30000&t;/* time to delay before sending an ACK&t;*/
DECL|macro|TCP_DONE_TIME
mdefine_line|#define TCP_DONE_TIME&t;250&t;/* maximum time to wait before actually&n;&t;&t;&t;&t; * destroying a socket&t;&t;&t;*/
DECL|macro|TCP_WRITE_TIME
mdefine_line|#define TCP_WRITE_TIME&t;30000&t;/* initial time to wait for an ACK,&n;&t;&t;&t;         * after last transmit&t;&t;&t;*/
DECL|macro|TCP_CONNECT_TIME
mdefine_line|#define TCP_CONNECT_TIME 2000&t;/* time to retransmit first SYN&t;&t;*/
DECL|macro|TCP_SYN_RETRIES
mdefine_line|#define TCP_SYN_RETRIES&t;5&t;/* number of times to retry openning a&n;&t;&t;&t;&t; * connection &t;&t;&t;&t;*/
DECL|macro|TCP_PROBEWAIT_LEN
mdefine_line|#define TCP_PROBEWAIT_LEN 100&t;/* time to wait between probes when&n;&t;&t;&t;&t; * I&squot;ve got something to write and&n;&t;&t;&t;&t; * there is no window&t;&t;&t;*/
DECL|macro|TCP_NO_CHECK
mdefine_line|#define TCP_NO_CHECK&t;0&t;/* turn to one if you want the default&n;&t;&t;&t;&t; * to be no checksum&t;&t;&t;*/
DECL|macro|TCP_WRITE_QUEUE_MAGIC
mdefine_line|#define TCP_WRITE_QUEUE_MAGIC 0xa5f23477
multiline_comment|/*&n; * The next routines deal with comparing 32 bit unsigned ints&n; * and worry about wraparound. The general strategy is to do a&n; * normal compare so long as neither of the numbers is within&n; * 4K of wrapping.  Otherwise we must check for the wrap.&n; */
r_static
r_inline
r_int
DECL|function|before
id|before
(paren
r_int
r_int
id|seq1
comma
r_int
r_int
id|seq2
)paren
(brace
multiline_comment|/* this inequality is strict. */
r_if
c_cond
(paren
id|seq1
op_eq
id|seq2
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|seq1
OL
id|seq2
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|seq2
op_minus
(paren
r_int
r_int
)paren
id|seq1
OL
l_int|65536UL
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Now we know seq1 &gt; seq2.  So all we need to do is check&n;   * to see if seq1 has wrapped.&n;   */
r_if
c_cond
(paren
id|seq2
template_param
(paren
l_int|0xffffffffUL
op_minus
l_int|8192UL
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|after
id|after
c_func
(paren
r_int
r_int
id|seq1
comma
r_int
r_int
id|seq2
)paren
(brace
r_return
id|before
c_func
(paren
id|seq2
comma
id|seq1
)paren
suffix:semicolon
)brace
multiline_comment|/* is s2&lt;=s1&lt;=s3 ? */
r_static
r_inline
r_int
DECL|function|between
id|between
c_func
(paren
r_int
r_int
id|seq1
comma
r_int
r_int
id|seq2
comma
r_int
r_int
id|seq3
)paren
(brace
r_return
id|after
c_func
(paren
id|seq1
op_plus
l_int|1
comma
id|seq2
)paren
op_logical_and
id|before
c_func
(paren
id|seq1
comma
id|seq3
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * List all states of a TCP socket that can be viewed as a &quot;connected&quot;&n; * state.  This now includes TCP_SYN_RECV, although I am not yet fully&n; * convinced that this is the solution for the &squot;getpeername(2)&squot;&n; * problem. Thanks to Stephen A. Wood &lt;saw@cebaf.gov&gt;  -FvK&n; */
r_static
r_inline
r_const
r_int
DECL|function|tcp_connected
id|tcp_connected
c_func
(paren
r_const
r_int
id|state
)paren
(brace
r_return
id|state
op_eq
id|TCP_ESTABLISHED
op_logical_or
id|state
op_eq
id|TCP_CLOSE_WAIT
op_logical_or
id|state
op_eq
id|TCP_FIN_WAIT1
op_logical_or
id|state
op_eq
id|TCP_FIN_WAIT2
op_logical_or
id|state
op_eq
id|TCP_SYN_RECV
suffix:semicolon
)brace
r_extern
r_struct
id|proto
id|tcp_prot
suffix:semicolon
r_extern
r_void
id|print_th
c_func
(paren
r_struct
id|tcphdr
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_err
c_func
(paren
r_int
id|err
comma
r_int
r_char
op_star
id|header
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|saddr
comma
r_struct
id|inet_protocol
op_star
id|protocol
)paren
suffix:semicolon
r_extern
r_void
id|tcp_shutdown
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
)paren
suffix:semicolon
r_extern
r_int
id|tcp_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|options
op_star
id|opt
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|saddr
comma
r_int
id|redo
comma
r_struct
id|inet_protocol
op_star
id|protocol
)paren
suffix:semicolon
r_extern
r_int
id|tcp_ioctl
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
macro_line|#endif&t;/* _TCP_H */
eof
