multiline_comment|/*&n; * &t;NET3&t;Protocol independant device support routines.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; *&t;Derived from the non IP parts of dev.c 1.0.19&n; * &t;&t;Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&n; *&t;Additional Authors:&n; *&t;&t;Florian la Roche &lt;rzsfl@rz.uni-sb.de&gt;&n; *&t;&t;Alan Cox &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;David Hinds &lt;dhinds@allegro.stanford.edu&gt;&n; *&n; *&t;Changes:&n; *&t;&t;Alan Cox&t;:&t;device private ioctl copies fields back.&n; *&t;&t;Alan Cox&t;:&t;Transmit queue code does relevant stunts to&n; *&t;&t;&t;&t;&t;keep the queue safe.&n; *&n; *&t;Cleaned up and recommented by Alan Cox 2nd April 1994. I hope to have&n; *&t;the rest as well commented in the end.&n; */
multiline_comment|/*&n; *&t;A lot of these includes will be going walkies very soon &n; */
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;route.h&quot;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &quot;arp.h&quot;
multiline_comment|/*&n; *&t;The list of packet types we will receive (as opposed to discard)&n; *&t;and the routines to invoke.&n; */
DECL|variable|ptype_base
r_struct
id|packet_type
op_star
id|ptype_base
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; *&t;Device drivers call our routines to queue packets here. We empty the&n; *&t;queue in the bottom half handler.&n; */
DECL|variable|backlog
r_static
r_struct
id|sk_buff_head
id|backlog
op_assign
(brace
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|backlog
comma
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|backlog
macro_line|#ifdef CONFIG_SKB_CHECK
comma
id|SK_HEAD_SKB
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* &n; *&t;We don&squot;t overdo the queue or we will thrash memory badly.&n; */
DECL|variable|backlog_size
r_static
r_int
id|backlog_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; *&t;The number of sockets open for &squot;all&squot; protocol use. We have to&n; *&t;know this to copy a buffer the correct number of times.&n; */
DECL|variable|dev_nit
r_static
r_int
id|dev_nit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; *&t;Return the lesser of the two values. &n; */
DECL|function|min
r_static
id|__inline__
r_int
r_int
id|min
c_func
(paren
r_int
r_int
id|a
comma
r_int
r_int
id|b
)paren
(brace
r_return
(paren
id|a
OL
id|b
)paren
ques
c_cond
id|a
suffix:colon
id|b
suffix:semicolon
)brace
multiline_comment|/******************************************************************************************&n;&n;&t;&t;Protocol management and registration routines&n;&n;*******************************************************************************************/
multiline_comment|/*&n; *&t;Add a protocol ID to the list.&n; */
DECL|function|dev_add_pack
r_void
id|dev_add_pack
c_func
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|packet_type
op_star
id|p1
suffix:semicolon
id|pt-&gt;next
op_assign
id|ptype_base
suffix:semicolon
multiline_comment|/* &n;&t; *&t;Don&squot;t use copy counts on ETH_P_ALL. Instead keep a global&n; &t; *&t;count of number of these and use it and pt-&gt;copy to decide&n;&t; *&t;copies &n;&t; */
id|pt-&gt;copy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Assume we will not be copying the buffer before &n;&t;&t;&t; * this routine gets it&n;&t;&t;&t; */
r_if
c_cond
(paren
id|pt-&gt;type
op_eq
id|htons
c_func
(paren
id|ETH_P_ALL
)paren
)paren
(brace
id|dev_nit
op_increment
suffix:semicolon
)brace
multiline_comment|/* I&squot;d like a /dev/nit too one day 8) */
r_else
(brace
multiline_comment|/*&n;  &t;&t; *&t;See if we need to copy it - that is another process also&n;  &t;&t; *&t;wishes to receive this type of packet.&n;  &t;&t; */
r_for
c_loop
(paren
id|p1
op_assign
id|ptype_base
suffix:semicolon
id|p1
op_ne
l_int|NULL
suffix:semicolon
id|p1
op_assign
id|p1-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p1-&gt;type
op_eq
id|pt-&gt;type
)paren
(brace
id|pt-&gt;copy
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* We will need to copy */
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;   *&t;NIT taps must go at the end or net_bh will leak!&n;   */
r_if
c_cond
(paren
id|pt-&gt;type
op_eq
id|htons
c_func
(paren
id|ETH_P_ALL
)paren
)paren
(brace
id|pt-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ptype_base
op_eq
l_int|NULL
)paren
(brace
id|ptype_base
op_assign
id|pt
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &n;&t;&t;&t; *&t;Move to the end of the list&n;&t;&t;&t; */
r_for
c_loop
(paren
id|p1
op_assign
id|ptype_base
suffix:semicolon
id|p1-&gt;next
op_ne
l_int|NULL
suffix:semicolon
id|p1
op_assign
id|p1-&gt;next
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;Hook on the end&n;&t;&t;&t; */
id|p1-&gt;next
op_assign
id|pt
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/*&n; *&t;It goes on the start &n; */
id|ptype_base
op_assign
id|pt
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Remove a protocol ID from the list.&n; */
DECL|function|dev_remove_pack
r_void
id|dev_remove_pack
c_func
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|packet_type
op_star
id|lpt
comma
op_star
id|pt1
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Keep the count of nit (Network Interface Tap) sockets correct.&n;&t; */
r_if
c_cond
(paren
id|pt-&gt;type
op_eq
id|htons
c_func
(paren
id|ETH_P_ALL
)paren
)paren
id|dev_nit
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If we are first, just unhook us.&n;&t; */
r_if
c_cond
(paren
id|pt
op_eq
id|ptype_base
)paren
(brace
id|ptype_base
op_assign
id|pt-&gt;next
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lpt
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This is harder. What we do is to walk the list of sockets &n;&t; *&t;for this type. We unhook the entry, and if there is a previous&n;&t; *&t;entry that is copying _and_ we are not copying, (ie we are the&n;&t; *&t;last entry for this type) then the previous one is set to&n;&t; *&t;non-copying as it is now the last.&n;&t; */
r_for
c_loop
(paren
id|pt1
op_assign
id|ptype_base
suffix:semicolon
id|pt1-&gt;next
op_ne
l_int|NULL
suffix:semicolon
id|pt1
op_assign
id|pt1-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|pt1-&gt;next
op_eq
id|pt
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pt-&gt;copy
op_logical_and
id|lpt
)paren
id|lpt-&gt;copy
op_assign
l_int|0
suffix:semicolon
id|pt1-&gt;next
op_assign
id|pt-&gt;next
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pt1-&gt;next-&gt;type
op_eq
id|pt-&gt;type
op_logical_and
id|pt-&gt;type
op_ne
id|htons
c_func
(paren
id|ETH_P_ALL
)paren
)paren
id|lpt
op_assign
id|pt1-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/*****************************************************************************************&n;&n;&t;&t;&t;    Device Inteface Subroutines&n;&n;******************************************************************************************/
multiline_comment|/* &n; *&t;Find an interface by name.&n; */
DECL|function|dev_get
r_struct
id|device
op_star
id|dev_get
c_func
(paren
r_char
op_star
id|name
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|dev-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
r_return
id|dev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Prepare an interface for use. &n; */
DECL|function|dev_open
r_int
id|dev_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Call device private open method&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;open
)paren
id|ret
op_assign
id|dev
op_member_access_from_pointer
id|open
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If it went open OK then set the flags&n;&t; */
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|dev-&gt;flags
op_or_assign
(paren
id|IFF_UP
op_or
id|IFF_RUNNING
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Completely shutdown an interface.&n; *&n; *&t;WARNING: Both because of the way the upper layers work (that can be fixed)&n; *&t;and because of races during a close (that can&squot;t be fixed any other way)&n; *&t;a device may be given things to transmit EVEN WHEN IT IS DOWN. The driver&n; *&t;MUST cope with this (eg by freeing and dumping the frame).&n; */
DECL|function|dev_close
r_int
id|dev_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
multiline_comment|/*&n;&t; *&t;Only close a device if it is up.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;flags
op_ne
l_int|0
)paren
(brace
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Call the device specific close. This cannot fail.&n;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;stop
)paren
id|dev
op_member_access_from_pointer
id|stop
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Delete the route to the device.&n;&t;&t; */
macro_line|#ifdef CONFIG_INET&t;&t; 
id|ip_rt_flush
c_func
(paren
id|dev
)paren
suffix:semicolon
id|arp_device_down
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif&t;&t;
macro_line|#ifdef CONFIG_IPX
id|ipxrtr_device_down
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif&t;
multiline_comment|/*&n;&t;&t; *&t;Blank the IP addresses&n;&t;&t; */
id|dev-&gt;pa_addr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_dstaddr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_brdaddr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Purge any queued packets when we down the link &n;&t;&t; */
r_while
c_loop
(paren
id|ct
OL
id|DEV_NUMBUFFS
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|dev-&gt;buffs
(braket
id|ct
)braket
)paren
)paren
op_ne
l_int|NULL
)paren
r_if
c_cond
(paren
id|skb-&gt;free
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
id|ct
op_increment
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send (or queue for sending) a packet. &n; *&n; *&t;IMPORTANT: When this is called to resend frames. The caller MUST&n; *&t;already have locked the sk_buff. Apart from that we do the&n; *&t;rest of the magic.&n; */
DECL|function|dev_queue_xmit
r_void
id|dev_queue_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_int
id|pri
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|where
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* used to say if the packet should go&t;*/
multiline_comment|/* at the front or the back of the&t;*/
multiline_comment|/* queue - front is a retranmsit try&t;*/
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;dev.c: dev_queue_xmit: dev = NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pri
op_ge
l_int|0
op_logical_and
op_logical_neg
id|skb_device_locked
c_func
(paren
id|skb
)paren
)paren
(brace
id|skb_device_lock
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* Shove a lock on the frame */
macro_line|#ifdef CONFIG_SLAVE_BALANCING
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;slave
op_ne
l_int|NULL
op_logical_and
id|dev-&gt;slave-&gt;pkt_queue
OL
id|dev-&gt;pkt_queue
op_logical_and
(paren
id|dev-&gt;slave-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
(brace
id|dev
op_assign
id|dev-&gt;slave
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#endif&t;&t;
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This just eliminates some race conditions, but not all... &n;&t; */
r_if
c_cond
(paren
id|skb-&gt;next
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Make sure we haven&squot;t missed an interrupt. &n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;dev_queue_xmit: worked around a missed interrupt&bslash;n&quot;
)paren
suffix:semicolon
id|dev
op_member_access_from_pointer
id|hard_start_xmit
c_func
(paren
l_int|NULL
comma
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Negative priority is used to flag a frame that is being pulled from the&n;&t; *&t;queue front as a retransmit attempt. It therefore goes back on the queue&n;&t; *&t;start on a failure.&n;&t; */
r_if
c_cond
(paren
id|pri
OL
l_int|0
)paren
(brace
id|pri
op_assign
op_minus
id|pri
op_minus
l_int|1
suffix:semicolon
id|where
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pri
op_ge
id|DEV_NUMBUFFS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bad priority in dev_queue_xmit.&bslash;n&quot;
)paren
suffix:semicolon
id|pri
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If the address has not been resolved. Call the device header rebuilder.&n;&t; *&t;This can cover all protocols and technically not just ARP either.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;arp
op_logical_and
id|dev
op_member_access_from_pointer
id|rebuild_header
c_func
(paren
id|skb-&gt;data
comma
id|dev
comma
id|skb-&gt;raddr
comma
id|skb
)paren
)paren
(brace
id|skb_device_unlock
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* It&squot;s now safely on the arp queue */
r_return
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|where
)paren
(brace
macro_line|#ifdef CONFIG_SLAVE_BALANCING&t;
id|skb-&gt;in_dev_queue
op_assign
l_int|1
suffix:semicolon
macro_line|#endif&t;&t;
id|skb_queue_tail
c_func
(paren
id|dev-&gt;buffs
op_plus
id|pri
comma
id|skb
)paren
suffix:semicolon
id|skb_device_unlock
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Buffer is on the device queue and can be freed safely */
id|skb
op_assign
id|skb_dequeue
c_func
(paren
id|dev-&gt;buffs
op_plus
id|pri
)paren
suffix:semicolon
id|skb_device_lock
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* New buffer needs locking down */
macro_line|#ifdef CONFIG_SLAVE_BALANCING&t;&t;
id|skb-&gt;in_dev_queue
op_assign
l_int|0
suffix:semicolon
macro_line|#endif&t;&t;
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|hard_start_xmit
c_func
(paren
id|skb
comma
id|dev
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Packet is now solely the responsibility of the driver&n;&t;&t; */
macro_line|#ifdef CONFIG_SLAVE_BALANCING&t;
id|dev-&gt;pkt_queue
op_decrement
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Transmission failed, put skb back into a list. Once on the list its safe and&n;&t; *&t;no longer device locked (it can be freed safely from the device queue)&n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SLAVE_BALANCING
id|skb-&gt;in_dev_queue
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;pkt_queue
op_increment
suffix:semicolon
macro_line|#endif&t;&t;
id|skb_device_unlock
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
id|dev-&gt;buffs
op_plus
id|pri
comma
id|skb
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Receive a packet from a device driver and queue it for the upper&n; *&t;(protocol) levels.  It always succeeds. This is the recommended &n; *&t;interface to use.&n; */
DECL|function|netif_rx
r_void
id|netif_rx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_static
r_int
id|dropping
op_assign
l_int|0
suffix:semicolon
r_extern
r_struct
id|timeval
id|xtime
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Any received buffers are un-owned and should be discarded&n;&t; *&t;when freed. These will be updated later as the frames get&n;&t; *&t;owners.&n;&t; */
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;stamp.tv_sec
op_eq
l_int|0
)paren
(brace
id|skb-&gt;stamp
op_assign
id|xtime
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Check that we aren&squot;t oevrdoing things.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|backlog_size
)paren
id|dropping
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|backlog_size
OG
l_int|100
)paren
id|dropping
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dropping
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Add it to the &quot;backlog&quot; queue. &n;&t; */
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|backlog
comma
id|skb
)paren
suffix:semicolon
id|backlog_size
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If any packet arrived, mark it for processing after the&n;&t; *&t;hardware interrupt returns.&n;&t; */
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The old interface to fetch a packet from a device driver.&n; *&t;This function is the base level entry point for all drivers that&n; *&t;want to send a packet to the upper (protocol) levels.  It takes&n; *&t;care of de-multiplexing the packet to the various modules based&n; *&t;on their protocol ID.&n; *&n; *&t;Return values:&t;1 &lt;- exit I can&squot;t do any more&n; *&t;&t;&t;0 &lt;- feed me more (i.e. &quot;done&quot;, &quot;OK&quot;). &n; *&n; *&t;This function is OBSOLETE and should not be used by any new&n; *&t;device.&n; */
DECL|function|dev_rint
r_int
id|dev_rint
c_func
(paren
r_int
r_char
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|flags
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_static
r_int
id|dropping
op_assign
l_int|0
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|to
suffix:semicolon
r_int
id|amount
comma
id|left
suffix:semicolon
r_int
id|len2
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
op_logical_or
id|buff
op_eq
l_int|NULL
op_logical_or
id|len
op_le
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|IN_SKBUFF
)paren
(brace
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|buff
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dropping
)paren
(brace
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|backlog
)paren
op_ne
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;INET: dev_rint: no longer dropping packets.&bslash;n&quot;
)paren
suffix:semicolon
id|dropping
op_assign
l_int|0
suffix:semicolon
)brace
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;dev_rint: packet dropped on %s (no memory) !&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|dropping
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; *&t;First we copy the packet into a buffer, and save it for later. We&n;&t;&t; *&t;in effect handle the incoming data as if it were from a circular buffer&n;&t;&t; */
id|to
op_assign
id|skb-&gt;data
suffix:semicolon
id|left
op_assign
id|len
suffix:semicolon
id|len2
op_assign
id|len
suffix:semicolon
r_while
c_loop
(paren
id|len2
OG
l_int|0
)paren
(brace
id|amount
op_assign
id|min
c_func
(paren
id|len2
comma
(paren
r_int
r_int
)paren
id|dev-&gt;rmem_end
op_minus
(paren
r_int
r_int
)paren
id|buff
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|to
comma
id|buff
comma
id|amount
)paren
suffix:semicolon
id|len2
op_sub_assign
id|amount
suffix:semicolon
id|left
op_sub_assign
id|amount
suffix:semicolon
id|buff
op_add_assign
id|amount
suffix:semicolon
id|to
op_add_assign
id|amount
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|buff
op_eq
id|dev-&gt;rmem_end
)paren
id|buff
op_assign
(paren
r_int
r_char
op_star
)paren
id|dev-&gt;rmem_start
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Tag the frame and kick it to the proper receive routine&n;&t; */
id|skb-&gt;len
op_assign
id|len
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;OK, all done. &n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine causes all interfaces to try to send some data. &n; */
DECL|function|dev_transmit
r_void
id|dev_transmit
c_func
(paren
r_void
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_ne
l_int|0
op_logical_and
op_logical_neg
id|dev-&gt;tbusy
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Kick the device&n;&t;&t;&t; */
id|dev_tint
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**********************************************************************************&n;&n;&t;&t;&t;Receive Queue Processor&n;&t;&t;&t;&n;***********************************************************************************/
multiline_comment|/*&n; *&t;This is a single non-rentrant routine which takes the received packet&n; *&t;queue and throws it at the networking layers in the hope that something&n; *&t;useful will emerge.&n; */
DECL|variable|in_bh
r_volatile
r_char
id|in_bh
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Non-rentrant remember */
DECL|function|in_net_bh
r_int
id|in_net_bh
c_func
(paren
)paren
multiline_comment|/* Used by timer.c */
(brace
r_return
id|in_bh
op_eq
l_int|0
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;When we are called the queue is ready to grab, the interrupts are&n; *&t;on and hardware can interrupt and queue to the receive queue a we&n; *&t;run with no problems.&n; *&t;This is run as a bottom half after an interrupt handler that does&n; *&t;mark_bh(NET_BH);&n; */
DECL|function|net_bh
r_void
id|net_bh
c_func
(paren
r_void
op_star
id|tmp
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|packet_type
op_star
id|ptype
suffix:semicolon
r_int
r_int
id|type
suffix:semicolon
r_int
r_char
id|flag
op_assign
l_int|0
suffix:semicolon
r_int
id|nitcount
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Atomically check and mark our BUSY state. &n;&t; */
r_if
c_cond
(paren
id|set_bit
c_func
(paren
l_int|1
comma
(paren
r_void
op_star
)paren
op_amp
id|in_bh
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Can we send anything now? We want to clear the&n;&t; *&t;decks for any more sends that get done as we&n;&t; *&t;process the input.&n;&t; */
id|dev_transmit
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Any data left to process. This may occur because a&n;&t; *&t;mark_bh() is done after we empty the queue including&n;&t; *&t;that from the device which does a mark_bh() just after&n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;While the queue is not empty&n;&t; */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|backlog
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;We have a packet. Therefore the queue has shrunk&n;&t;&t; */
id|backlog_size
op_decrement
suffix:semicolon
id|nitcount
op_assign
id|dev_nit
suffix:semicolon
id|flag
op_assign
l_int|0
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;*&t;Bump the pointer to the next structure.&n;&t;&t;*&t;This assumes that the basic &squot;skb&squot; pointer points to&n;&t;&t;*&t;the MAC header, if any (as indicated by its &quot;length&quot;&n;&t;&t;*&t;field).  Take care now!&n;&t;&t;*/
id|skb-&gt;h.raw
op_assign
id|skb-&gt;data
op_plus
id|skb-&gt;dev-&gt;hard_header_len
suffix:semicolon
id|skb-&gt;len
op_sub_assign
id|skb-&gt;dev-&gt;hard_header_len
suffix:semicolon
multiline_comment|/*&n;&t;&t;* &t;Fetch the packet protocol ID.  This is also quite ugly, as&n;&t;&t;* &t;it depends on the protocol driver (the interface itself) to&n;&t;&t;* &t;know what the type is, or where to get it from.  The Ethernet&n;&t;&t;* &t;interfaces fetch the ID from the two bytes in the Ethernet MAC&n;&t;&t;*&t;header (the h_proto field in struct ethhdr), but other drivers&n;&t;&t;*&t;may either use the ethernet ID&squot;s or extra ones that do not&n;&t;&t;*&t;clash (eg ETH_P_AX25). We could set this before we queue the&n;&t;&t;*&t;frame. In fact I may change this when I have time.&n;&t;&t;*/
id|type
op_assign
id|skb-&gt;dev
op_member_access_from_pointer
id|type_trans
c_func
(paren
id|skb
comma
id|skb-&gt;dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;We got a packet ID.  Now loop over the &quot;known protocols&quot;&n;&t;&t; *&t;table (which is actually a linked list, but this will&n;&t;&t; *&t;change soon if I get my way- FvK), and forward the packet&n;&t;&t; *&t;to anyone who wants it.&n;&t;&t; *&n;&t;&t; *&t;[FvK didn&squot;t get his way but he is right this ought to be&n;&t;&t; *&t;hashed so we typically get a single hit. The speed cost&n;&t;&t; *&t;here is minimal but no doubt adds up at the 4,000+ pkts/second&n;&t;&t; *&t;rate we can hit flat out]&n;&t;&t; */
r_for
c_loop
(paren
id|ptype
op_assign
id|ptype_base
suffix:semicolon
id|ptype
op_ne
l_int|NULL
suffix:semicolon
id|ptype
op_assign
id|ptype-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ptype-&gt;type
op_eq
id|type
op_logical_or
id|ptype-&gt;type
op_eq
id|htons
c_func
(paren
id|ETH_P_ALL
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_if
c_cond
(paren
id|ptype-&gt;type
op_eq
id|htons
c_func
(paren
id|ETH_P_ALL
)paren
)paren
id|nitcount
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ptype-&gt;copy
op_logical_or
id|nitcount
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;copy if we need to&n;&t;&t;&t;&t;&t; */
macro_line|#ifdef OLD
id|skb2
op_assign
id|alloc_skb
c_func
(paren
id|skb-&gt;len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb2
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|memcpy
c_func
(paren
id|skb2
comma
id|skb
comma
id|skb2-&gt;mem_len
)paren
suffix:semicolon
id|skb2-&gt;mem_addr
op_assign
id|skb2
suffix:semicolon
id|skb2-&gt;h.raw
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|skb2
op_plus
(paren
r_int
r_int
)paren
id|skb-&gt;h.raw
op_minus
(paren
r_int
r_int
)paren
id|skb
)paren
suffix:semicolon
id|skb2-&gt;free
op_assign
l_int|1
suffix:semicolon
macro_line|#else
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb2
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;
)brace
r_else
(brace
id|skb2
op_assign
id|skb
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Protocol located. &n;&t;&t;&t;&t; */
id|flag
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Kick the protocol handler. This should be fast&n;&t;&t;&t;&t; *&t;and efficient code.&n;&t;&t;&t;&t; */
id|ptype
op_member_access_from_pointer
id|func
c_func
(paren
id|skb2
comma
id|skb-&gt;dev
comma
id|ptype
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* End of protocol list loop */
multiline_comment|/*&n;&t;&t; * &t;Has an unknown packet has been received ?&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Again, see if we can transmit anything now. &n;&t;&t; */
id|dev_transmit
c_func
(paren
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* End of queue loop */
multiline_comment|/*&n;  &t; *&t;We have emptied the queue&n;  &t; */
id|in_bh
op_assign
l_int|0
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;One last output flush.&n;&t; */
id|dev_transmit
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This routine is called when an device driver (i.e. an&n; *&t;interface) is ready to transmit a packet.&n; */
DECL|function|dev_tint
r_void
id|dev_tint
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Work the queues in priority order&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_NUMBUFFS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Pull packets from the queue&n;&t;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|dev-&gt;buffs
(braket
id|i
)braket
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Stop anyone freeing the buffer while we retransmit it&n;&t;&t;&t; */
id|skb_device_lock
c_func
(paren
id|skb
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Feed them to the output stage and if it fails&n;&t;&t;&t; *&t;indicate they re-queue at the front.&n;&t;&t;&t; */
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
op_minus
id|i
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;If we can take no more then stop here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
r_return
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Perform a SIOCGIFCONF call. This structure will change&n; *&t;size shortly, and there is nothing I can do about it.&n; *&t;Thus we will need a &squot;compatibility mode&squot;.&n; */
DECL|function|dev_ifconf
r_static
r_int
id|dev_ifconf
c_func
(paren
r_char
op_star
id|arg
)paren
(brace
r_struct
id|ifconf
id|ifc
suffix:semicolon
r_struct
id|ifreq
id|ifr
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_char
op_star
id|pos
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fetch the caller&squot;s info block. &n;&t; */
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifconf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|ifc
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifconf
)paren
)paren
suffix:semicolon
id|len
op_assign
id|ifc.ifc_len
suffix:semicolon
id|pos
op_assign
id|ifc.ifc_buf
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We now walk the device list filling each active device&n;&t; *&t;into the array.&n;&t; */
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|pos
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Loop over the interfaces, and write an info block for each. &n;&t; */
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
(brace
multiline_comment|/* Downed devices don&squot;t count */
r_continue
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|ifr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|ifr.ifr_name
comma
id|dev-&gt;name
)paren
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_addr.s_addr
op_assign
id|dev-&gt;pa_addr
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Write this block to the caller&squot;s space. &n;&t;&t; */
id|memcpy_tofs
c_func
(paren
id|pos
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|pos
op_add_assign
r_sizeof
(paren
r_struct
id|ifreq
)paren
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
r_struct
id|ifreq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Have we run out of space here ?&n;&t;&t; */
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;All done.  Write the updated control block back to the caller. &n;&t; */
id|ifc.ifc_len
op_assign
(paren
id|pos
op_minus
id|ifc.ifc_buf
)paren
suffix:semicolon
id|ifc.ifc_req
op_assign
(paren
r_struct
id|ifreq
op_star
)paren
id|ifc.ifc_buf
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifc
comma
r_sizeof
(paren
r_struct
id|ifconf
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Report how much was filled in&n;&t; */
r_return
id|pos
op_minus
id|arg
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is invoked by the /proc filesystem handler to display a device&n; *&t;in detail.&n; */
DECL|function|sprintf_stats
r_static
r_int
id|sprintf_stats
c_func
(paren
r_char
op_star
id|buffer
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|enet_statistics
op_star
id|stats
op_assign
(paren
id|dev-&gt;get_stats
ques
c_cond
id|dev
op_member_access_from_pointer
id|get_stats
c_func
(paren
id|dev
)paren
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|stats
)paren
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%6s:%7d %4d %4d %4d %4d %8d %4d %4d %4d %5d %4d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|stats-&gt;rx_packets
comma
id|stats-&gt;rx_errors
comma
id|stats-&gt;rx_dropped
op_plus
id|stats-&gt;rx_missed_errors
comma
id|stats-&gt;rx_fifo_errors
comma
id|stats-&gt;rx_length_errors
op_plus
id|stats-&gt;rx_over_errors
op_plus
id|stats-&gt;rx_crc_errors
op_plus
id|stats-&gt;rx_frame_errors
comma
id|stats-&gt;tx_packets
comma
id|stats-&gt;tx_errors
comma
id|stats-&gt;tx_dropped
comma
id|stats-&gt;tx_fifo_errors
comma
id|stats-&gt;collisions
comma
id|stats-&gt;tx_carrier_errors
op_plus
id|stats-&gt;tx_aborted_errors
op_plus
id|stats-&gt;tx_window_errors
op_plus
id|stats-&gt;tx_heartbeat_errors
)paren
suffix:semicolon
r_else
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%6s: No statistics available.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Called from the PROCfs module. This now uses the new arbitary sized /proc/net interface&n; *&t;to create /proc/net/dev&n; */
DECL|function|dev_get_info
r_int
id|dev_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|size
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;Inter-|   Receive                  |  Transmit&bslash;n&quot;
l_string|&quot; face |packets errs drop fifo frame|packets errs drop fifo colls carrier&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
id|size
op_assign
id|sprintf_stats
c_func
(paren
id|buffer
op_plus
id|len
comma
id|dev
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start slop */
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
multiline_comment|/* Ending slop */
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This checks bitmasks for the ioctl calls for devices.&n; */
DECL|function|bad_mask
r_static
r_inline
r_int
id|bad_mask
c_func
(paren
r_int
r_int
id|mask
comma
r_int
r_int
id|addr
)paren
(brace
r_if
c_cond
(paren
id|addr
op_amp
(paren
id|mask
op_assign
op_complement
id|mask
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|mask
op_assign
id|ntohl
c_func
(paren
id|mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
(paren
id|mask
op_plus
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Perform the SIOCxIFxxx calls. &n; *&n; *&t;The socket layer has seen an ioctl the address family thinks is&n; *&t;for the device. At this point we get invoked to make a decision&n; */
DECL|function|dev_ifsioc
r_static
r_int
id|dev_ifsioc
c_func
(paren
r_void
op_star
id|arg
comma
r_int
r_int
id|getset
)paren
(brace
r_struct
id|ifreq
id|ifr
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fetch the caller&squot;s info block into kernel space&n;&t; */
r_int
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|ifr
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;See which interface the caller is talking about. &n;&t; */
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|dev_get
c_func
(paren
id|ifr.ifr_name
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_switch
c_cond
(paren
id|getset
)paren
(brace
r_case
id|SIOCGIFFLAGS
suffix:colon
multiline_comment|/* Get interface flags */
id|ifr.ifr_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFFLAGS
suffix:colon
multiline_comment|/* Set interface flags */
(brace
r_int
id|old_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
macro_line|#ifdef CONFIG_SLAVE_BALANCING&t;&t;&t;&t;
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_SLAVE
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;&t;
id|dev-&gt;flags
op_assign
id|ifr.ifr_flags
op_amp
(paren
id|IFF_UP
op_or
id|IFF_BROADCAST
op_or
id|IFF_DEBUG
op_or
id|IFF_LOOPBACK
op_or
id|IFF_POINTOPOINT
op_or
id|IFF_NOTRAILERS
op_or
id|IFF_RUNNING
op_or
id|IFF_NOARP
op_or
id|IFF_PROMISC
op_or
id|IFF_ALLMULTI
op_or
id|IFF_SLAVE
op_or
id|IFF_MASTER
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SLAVE_BALANCING&t;&t;&t;&t;
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_MASTER
)paren
op_logical_and
id|dev-&gt;slave
)paren
(brace
id|dev-&gt;slave-&gt;flags
op_and_assign
op_complement
id|IFF_SLAVE
suffix:semicolon
id|dev-&gt;slave
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Has promiscuous mode been turned off&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|old_flags
op_amp
id|IFF_PROMISC
)paren
op_logical_and
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
op_eq
l_int|0
)paren
)paren
id|dev
op_member_access_from_pointer
id|set_multicast_list
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; &t; *&t;Has it been turned on&n;&t;&t;&t; &t; */
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
op_logical_and
(paren
(paren
id|old_flags
op_amp
id|IFF_PROMISC
)paren
op_eq
l_int|0
)paren
)paren
id|dev
op_member_access_from_pointer
id|set_multicast_list
c_func
(paren
id|dev
comma
op_minus
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;  &t; *&t;Have we downed the interface&n;&t;&t;&t;  &t; */
r_if
c_cond
(paren
(paren
id|old_flags
op_amp
id|IFF_UP
)paren
op_logical_and
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|ret
op_assign
id|dev_close
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;Have we upped the interface &n;&t;&t;&t;&t;&t; */
id|ret
op_assign
(paren
op_logical_neg
(paren
id|old_flags
op_amp
id|IFF_UP
)paren
op_logical_and
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
ques
c_cond
id|dev_open
c_func
(paren
id|dev
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; *&t;Check the flags.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|dev-&gt;flags
op_and_assign
op_complement
id|IFF_UP
suffix:semicolon
)brace
multiline_comment|/* Didnt open so down the if */
)brace
)brace
r_break
suffix:semicolon
r_case
id|SIOCGIFADDR
suffix:colon
multiline_comment|/* Get interface address (and family) */
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_addr.s_addr
op_assign
id|dev-&gt;pa_addr
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_port
op_assign
l_int|0
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFADDR
suffix:colon
multiline_comment|/* Set interface address (and family) */
id|dev-&gt;pa_addr
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_addr.s_addr
suffix:semicolon
id|dev-&gt;family
op_assign
id|ifr.ifr_addr.sa_family
suffix:semicolon
macro_line|#ifdef CONFIG_INET&t;
multiline_comment|/* This is naughty. When net-032e comes out It wants moving into the net032&n;&t;&t;&t;   code not the kernel. Till then it can sit here (SIGH) */
id|dev-&gt;pa_mask
op_assign
id|ip_get_mask
c_func
(paren
id|dev-&gt;pa_addr
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;
id|dev-&gt;pa_brdaddr
op_assign
id|dev-&gt;pa_addr
op_or
op_complement
id|dev-&gt;pa_mask
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFBRDADDR
suffix:colon
multiline_comment|/* Get the broadcast address */
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_broadaddr.sin_addr.s_addr
op_assign
id|dev-&gt;pa_brdaddr
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_broadaddr.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_broadaddr.sin_port
op_assign
l_int|0
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFBRDADDR
suffix:colon
multiline_comment|/* Set the broadcast address */
id|dev-&gt;pa_brdaddr
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_broadaddr.sin_addr.s_addr
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFDSTADDR
suffix:colon
multiline_comment|/* Get the destination address (for point-to-point links) */
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_dstaddr.sin_addr.s_addr
op_assign
id|dev-&gt;pa_dstaddr
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_broadaddr.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_broadaddr.sin_port
op_assign
l_int|0
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFDSTADDR
suffix:colon
multiline_comment|/* Set the destination address (for point-to-point links) */
id|dev-&gt;pa_dstaddr
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_dstaddr.sin_addr.s_addr
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFNETMASK
suffix:colon
multiline_comment|/* Get the netmask for the interface */
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_netmask.sin_addr.s_addr
op_assign
id|dev-&gt;pa_mask
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_netmask.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_netmask.sin_port
op_assign
l_int|0
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFNETMASK
suffix:colon
multiline_comment|/* Set the netmask for the interface */
(brace
r_int
r_int
id|mask
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_netmask.sin_addr.s_addr
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;The mask we set must be legal.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|bad_mask
c_func
(paren
id|mask
comma
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|dev-&gt;pa_mask
op_assign
id|mask
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIOCGIFMETRIC
suffix:colon
multiline_comment|/* Get the metric on the inteface (currently unused) */
id|ifr.ifr_metric
op_assign
id|dev-&gt;metric
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFMETRIC
suffix:colon
multiline_comment|/* Set the metric on the interface (currently unused) */
id|dev-&gt;metric
op_assign
id|ifr.ifr_metric
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFMTU
suffix:colon
multiline_comment|/* Get the MTU of a device */
id|ifr.ifr_mtu
op_assign
id|dev-&gt;mtu
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFMTU
suffix:colon
multiline_comment|/* Set the MTU of a device */
multiline_comment|/*&n;&t;&t;&t; *&t;MTU must be positive and under the page size problem&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ifr.ifr_mtu
l_int|3800
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev-&gt;mtu
op_assign
id|ifr.ifr_mtu
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFMEM
suffix:colon
multiline_comment|/* Get the per device memory space. We can add this but currently&n;&t;&t;&t;&t;&t;   do not support it */
id|printk
c_func
(paren
l_string|&quot;NET: ioctl(SIOCGIFMEM, 0x%08X)&bslash;n&quot;
comma
(paren
r_int
)paren
id|arg
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFMEM
suffix:colon
multiline_comment|/* Set the per device memory buffer space. Not applicable in our case */
id|printk
c_func
(paren
l_string|&quot;NET: ioctl(SIOCSIFMEM, 0x%08X)&bslash;n&quot;
comma
(paren
r_int
)paren
id|arg
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OLD_SIOCGIFHWADDR
suffix:colon
multiline_comment|/* Get the hardware address. This will change and SIFHWADDR will be added */
id|memcpy
c_func
(paren
id|ifr.old_ifr_hwaddr
comma
id|dev-&gt;dev_addr
comma
id|MAX_ADDR_LEN
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFHWADDR
suffix:colon
id|memcpy
c_func
(paren
id|ifr.ifr_hwaddr.sa_data
comma
id|dev-&gt;dev_addr
comma
id|MAX_ADDR_LEN
)paren
suffix:semicolon
id|ifr.ifr_hwaddr.sa_family
op_assign
id|dev-&gt;type
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFHWADDR
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_mac_address
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ifr.ifr_hwaddr.sa_family
op_ne
id|dev-&gt;type
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ret
op_assign
id|dev
op_member_access_from_pointer
id|set_mac_address
c_func
(paren
id|dev
comma
id|ifr.ifr_hwaddr.sa_data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCDEVPRIVATE
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;do_ioctl
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
id|ret
op_assign
id|dev
op_member_access_from_pointer
id|do_ioctl
c_func
(paren
id|dev
comma
op_amp
id|ifr
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFMAP
suffix:colon
id|ifr.ifr_map.mem_start
op_assign
id|dev-&gt;mem_start
suffix:semicolon
id|ifr.ifr_map.mem_end
op_assign
id|dev-&gt;mem_end
suffix:semicolon
id|ifr.ifr_map.base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|ifr.ifr_map.irq
op_assign
id|dev-&gt;irq
suffix:semicolon
id|ifr.ifr_map.dma
op_assign
id|dev-&gt;dma
suffix:semicolon
id|ifr.ifr_map.port
op_assign
id|dev-&gt;if_port
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFMAP
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;set_config
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_return
id|dev
op_member_access_from_pointer
id|set_config
c_func
(paren
id|dev
comma
op_amp
id|ifr.ifr_map
)paren
suffix:semicolon
r_case
id|SIOCGIFSLAVE
suffix:colon
macro_line|#ifdef CONFIG_SLAVE_BALANCING&t;&t;
r_if
c_cond
(paren
id|dev-&gt;slave
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|ifr.ifr_name
comma
id|dev-&gt;name
comma
r_sizeof
(paren
id|ifr.ifr_name
)paren
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#else
r_return
op_minus
id|ENOENT
suffix:semicolon
macro_line|#endif&t;&t;&t;
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_SLAVE_BALANCING&t;&t;&t;
r_case
id|SIOCSIFSLAVE
suffix:colon
(brace
multiline_comment|/*&n;&t;&t; *&t;Fun game. Get the device up and the flags right without&n;&t;&t; *&t;letting some scummy user confuse us.&n;&t;&t; */
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|device
op_star
id|slave
op_assign
id|dev_get
c_func
(paren
id|ifr.ifr_slave
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|slave-&gt;flags
op_amp
(paren
id|IFF_UP
op_or
id|IFF_RUNNING
)paren
)paren
op_ne
(paren
id|IFF_UP
op_or
id|IFF_RUNNING
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_SLAVE
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;slave
op_ne
l_int|NULL
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|slave-&gt;flags
op_amp
id|IFF_SLAVE
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|dev-&gt;slave
op_assign
id|slave
suffix:semicolon
id|slave-&gt;flags
op_or_assign
id|IFF_SLAVE
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|IFF_MASTER
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#endif&t;&t;&t;
multiline_comment|/*&n;&t;&t; *&t;Unknown ioctl&n;&t;&t; */
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This function handles all &quot;interface&quot;-type I/O control requests. The actual&n; *&t;&squot;doing&squot; part of this is dev_ifsioc above.&n; */
DECL|function|dev_ioctl
r_int
id|dev_ioctl
c_func
(paren
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;The old old setup ioctl. Even its name and this entry will soon be&n;&t;&t; *&t;just so much ionization on a backup tape.&n;&t;&t; */
r_case
id|SIOCGIFCONF
suffix:colon
(paren
r_void
)paren
id|dev_ifconf
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Ioctl calls that can be done by all.&n;&t;&t; */
r_case
id|SIOCGIFFLAGS
suffix:colon
r_case
id|SIOCGIFADDR
suffix:colon
r_case
id|SIOCGIFDSTADDR
suffix:colon
r_case
id|SIOCGIFBRDADDR
suffix:colon
r_case
id|SIOCGIFNETMASK
suffix:colon
r_case
id|SIOCGIFMETRIC
suffix:colon
r_case
id|SIOCGIFMTU
suffix:colon
r_case
id|SIOCGIFMEM
suffix:colon
r_case
id|SIOCGIFHWADDR
suffix:colon
r_case
id|SIOCSIFHWADDR
suffix:colon
r_case
id|OLD_SIOCGIFHWADDR
suffix:colon
r_case
id|SIOCGIFSLAVE
suffix:colon
r_case
id|SIOCGIFMAP
suffix:colon
r_return
id|dev_ifsioc
c_func
(paren
id|arg
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Ioctl calls requiring the power of a superuser&n;&t;&t; */
r_case
id|SIOCSIFFLAGS
suffix:colon
r_case
id|SIOCSIFADDR
suffix:colon
r_case
id|SIOCSIFDSTADDR
suffix:colon
r_case
id|SIOCSIFBRDADDR
suffix:colon
r_case
id|SIOCSIFNETMASK
suffix:colon
r_case
id|SIOCSIFMETRIC
suffix:colon
r_case
id|SIOCSIFMTU
suffix:colon
r_case
id|SIOCSIFMEM
suffix:colon
r_case
id|SIOCSIFMAP
suffix:colon
r_case
id|SIOCSIFSLAVE
suffix:colon
r_case
id|SIOCDEVPRIVATE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_return
id|dev_ifsioc
c_func
(paren
id|arg
comma
id|cmd
)paren
suffix:semicolon
r_case
id|SIOCSIFLINK
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Unknown ioctl.&n;&t;&t; */
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Initialize the DEV module. At boot time this walks the device list and&n; *&t;unhooks any devices that fail to initialise (normally hardware not &n; *&t;present) and leaves us with a valid list of present and active devices.&n; *&n; *&t;The PCMICA code may need to change this a little, and add a pair&n; *&t;of register_inet_device() unregister_inet_device() calls. This will be&n; *&t;needed for ethernet as modules support.&n; */
DECL|function|dev_init
r_void
id|dev_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|device
op_star
id|dev
comma
op_star
id|dev2
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Add the devices.&n;&t; *&t;If the call to dev-&gt;init fails, the dev is removed&n;&t; *&t;from the chain disconnecting the device until the&n;&t; *&t;next reboot.&n;&t; */
id|dev2
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;init
op_logical_and
id|dev
op_member_access_from_pointer
id|init
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;It failed to come up. Unhook it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|dev2
op_eq
l_int|NULL
)paren
id|dev_base
op_assign
id|dev-&gt;next
suffix:semicolon
r_else
id|dev2-&gt;next
op_assign
id|dev-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|dev2
op_assign
id|dev
suffix:semicolon
)brace
)brace
)brace
eof
