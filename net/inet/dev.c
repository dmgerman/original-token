multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Interface (streams) handling functions.&n; *&n; * Version:&t;@(#)dev.c&t;1.0.19&t;05/31/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; * &n; * Fixes:&t;&n; *&t;&t;Alan Cox:&t;check_addr returns a value for a wrong subnet&n; *&t;&t;&t;&t;ie not us but don&squot;t forward this!&n; *&t;&t;Alan Cox:&t;block timer if the inet_bh handler is running&n; *&t;&t;Alan Cox:&t;generic queue code added. A lot neater now&n; *&t;&t;C.E.Hawkins:&t;SIOCGIFCONF only reports &squot;upped&squot; interfaces&n; *&t;&t;C.E.Hawkins:&t;IFF_PROMISC support&n; *&t;&t;Alan Cox:&t;Supports Donald Beckers new hardware &n; *&t;&t;&t;&t;multicast layer, but not yet multicast lists.&n; *&t;&t;Alan Cox:&t;ip_addr_match problems with class A/B nets.&n; *&t;&t;C.E.Hawkins&t;IP 0.0.0.0 and also same net route fix. [FIXME: Ought to cause ICMP_REDIRECT]&n; *&t;&t;Alan Cox:&t;Removed bogus subnet check now the subnet code&n; *&t;&t;&t;&t;a) actually works for all A/B nets&n; *&t;&t;&t;&t;b) doesn&squot;t forward off the same interface.&n; *&t;&t;Alan Cox:&t;Multiple extra protocols&n; *&t;&t;Alan Cox:&t;Fixed ifconfig up of dud device setting the up flag&n; *&t;&t;Alan Cox:&t;Fixed verify_area errors&n; *&t;&t;Alan Cox:&t;Removed IP_SET_DEV as per Fred&squot;s comment. I hope this doesn&squot;t give&n; *&t;&t;&t;&t;anything away 8)&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &quot;inet.h&quot;
macro_line|#include &quot;dev.h&quot;
macro_line|#include &quot;eth.h&quot;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;route.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &quot;skbuff.h&quot;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &quot;arp.h&quot;
macro_line|#ifdef CONFIG_AX25
macro_line|#include &quot;ax25.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_IPX
DECL|variable|ipx_8023_type
r_static
r_struct
id|packet_type
id|ipx_8023_type
op_assign
(brace
id|NET16
c_func
(paren
id|ETH_P_802_3
)paren
comma
l_int|0
comma
id|ipx_rcv
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|ipx_packet_type
r_static
r_struct
id|packet_type
id|ipx_packet_type
op_assign
(brace
id|NET16
c_func
(paren
id|ETH_P_IPX
)paren
comma
l_int|0
comma
id|ipx_rcv
comma
l_int|NULL
comma
op_amp
id|ipx_8023_type
)brace
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_AX25
DECL|variable|ax25_packet_type
r_static
r_struct
id|packet_type
id|ax25_packet_type
op_assign
(brace
id|NET16
c_func
(paren
id|ETH_P_AX25
)paren
comma
l_int|0
comma
id|ax25_rcv
comma
l_int|NULL
comma
macro_line|#ifdef CONFIG_IPX
op_amp
id|ipx_packet_type
macro_line|#else
l_int|NULL
macro_line|#endif
)brace
suffix:semicolon
macro_line|#endif
DECL|variable|arp_packet_type
r_static
r_struct
id|packet_type
id|arp_packet_type
op_assign
(brace
id|NET16
c_func
(paren
id|ETH_P_ARP
)paren
comma
l_int|0
comma
multiline_comment|/* copy */
id|arp_rcv
comma
l_int|NULL
comma
macro_line|#ifdef CONFIG_IPX
macro_line|#ifndef CONFIG_AX25
op_amp
id|ipx_packet_type
macro_line|#else
op_amp
id|ax25_packet_type
macro_line|#endif
macro_line|#else
l_int|NULL
multiline_comment|/* next */
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|ip_packet_type
r_static
r_struct
id|packet_type
id|ip_packet_type
op_assign
(brace
id|NET16
c_func
(paren
id|ETH_P_IP
)paren
comma
l_int|0
comma
multiline_comment|/* copy */
id|ip_rcv
comma
l_int|NULL
comma
op_amp
id|arp_packet_type
)brace
suffix:semicolon
DECL|variable|ptype_base
r_struct
id|packet_type
op_star
id|ptype_base
op_assign
op_amp
id|ip_packet_type
suffix:semicolon
DECL|variable|backlog
r_static
r_struct
id|sk_buff
op_star
r_volatile
id|backlog
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|ip_bcast
r_static
r_int
r_int
id|ip_bcast
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Return the lesser of the two values. */
r_static
r_int
r_int
DECL|function|min
id|min
c_func
(paren
r_int
r_int
id|a
comma
r_int
r_int
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
OL
id|b
)paren
r_return
id|a
suffix:semicolon
r_return
id|b
suffix:semicolon
)brace
multiline_comment|/* Determine a default network mask, based on the IP address. */
r_static
r_int
r_int
DECL|function|get_mask
id|get_mask
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_int
r_int
id|dst
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_eq
l_int|0L
)paren
r_return
l_int|0L
suffix:semicolon
multiline_comment|/* special case */
id|dst
op_assign
id|ntohl
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSA
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSA_NET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSB
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSB_NET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSC
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSC_NET
)paren
suffix:semicolon
multiline_comment|/* Something else, probably a subnet. */
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|ip_addr_match
id|ip_addr_match
c_func
(paren
r_int
r_int
id|me
comma
r_int
r_int
id|him
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;ip_addr_match(%s, &quot;
comma
id|in_ntoa
c_func
(paren
id|me
)paren
)paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;%s)&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|him
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|me
op_eq
id|him
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
comma
id|me
op_rshift_assign
l_int|8
comma
id|him
op_rshift_assign
l_int|8
comma
id|mask
op_rshift_assign
l_int|8
)paren
(brace
r_if
c_cond
(paren
(paren
id|me
op_amp
l_int|0xFF
)paren
op_ne
(paren
id|him
op_amp
l_int|0xFF
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The only way this could be a match is for&n;&t;&t; * the rest of addr1 to be 0 or 255.&n;&t;&t; */
r_if
c_cond
(paren
id|me
op_ne
l_int|0
op_logical_and
id|me
op_ne
id|mask
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Check the address for our address, broadcasts, etc. */
r_int
DECL|function|chk_addr
id|chk_addr
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_int
r_int
id|dst
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;chk_addr(%s) --&gt; &quot;
comma
id|in_ntoa
c_func
(paren
id|addr
)paren
)paren
)paren
suffix:semicolon
id|dst
op_assign
id|ntohl
c_func
(paren
id|addr
)paren
suffix:semicolon
multiline_comment|/* Accept both `all ones&squot; and `all zeros&squot; as BROADCAST. */
r_if
c_cond
(paren
id|dst
op_eq
id|INADDR_ANY
op_logical_or
id|dst
op_eq
id|INADDR_BROADCAST
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;BROADCAST&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|IS_BROADCAST
suffix:semicolon
)brace
multiline_comment|/* Accept all of the `loopback&squot; class A net. */
r_if
c_cond
(paren
(paren
id|dst
op_amp
id|IN_CLASSA_NET
)paren
op_eq
l_int|0x7F000000L
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;LOOPBACK&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We force `loopback&squot; to be equal to MY_ADDR.&n;&t; */
r_return
id|IS_MYADDR
suffix:semicolon
multiline_comment|/* return(IS_LOOPBACK); */
)brace
multiline_comment|/* OK, now check the interface addresses. */
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;pa_addr
op_eq
l_int|0
)paren
multiline_comment|/* || (dev-&gt;flags&amp;IFF_PROMISC)*/
)paren
r_return
id|IS_MYADDR
suffix:semicolon
multiline_comment|/* Is it the exact IP address? */
r_if
c_cond
(paren
id|addr
op_eq
id|dev-&gt;pa_addr
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;MYADDR&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|IS_MYADDR
suffix:semicolon
)brace
multiline_comment|/* Nope. Check for a subnetwork broadcast. */
r_if
c_cond
(paren
(paren
id|addr
op_amp
id|dev-&gt;pa_mask
)paren
op_eq
(paren
id|dev-&gt;pa_addr
op_amp
id|dev-&gt;pa_mask
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr
op_amp
op_complement
id|dev-&gt;pa_mask
)paren
op_eq
l_int|0
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;SUBBROADCAST-0&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|IS_BROADCAST
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|addr
op_amp
op_complement
id|dev-&gt;pa_mask
)paren
op_or
id|dev-&gt;pa_mask
)paren
op_eq
id|INADDR_BROADCAST
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;SUBBROADCAST-1&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|IS_BROADCAST
suffix:semicolon
)brace
)brace
multiline_comment|/* Nope. Check for Network broadcast. */
r_if
c_cond
(paren
id|IN_CLASSA
c_func
(paren
id|dst
)paren
)paren
(brace
r_if
c_cond
(paren
id|addr
op_eq
(paren
id|dev-&gt;pa_addr
op_or
l_int|0xffffff00
)paren
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;CLASS A BROADCAST-1&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|IS_BROADCAST
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|IN_CLASSB
c_func
(paren
id|dst
)paren
)paren
(brace
r_if
c_cond
(paren
id|addr
op_eq
(paren
id|dev-&gt;pa_addr
op_or
l_int|0xffff0000
)paren
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;CLASS B BROADCAST-1&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|IS_BROADCAST
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* IN_CLASSC */
r_if
c_cond
(paren
id|addr
op_eq
(paren
id|dev-&gt;pa_addr
op_or
l_int|0xff000000
)paren
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;CLASS C BROADCAST-1&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|IS_BROADCAST
suffix:semicolon
)brace
)brace
)brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;NONE&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* no match at all */
)brace
multiline_comment|/*&n; * Retrieve our own address.&n; * Because the loopback address (127.0.0.1) is already recognized&n; * automatically, we can use the loopback interface&squot;s address as&n; * our &quot;primary&quot; interface.  This is the addressed used by IP et&n; * al when it doesn&squot;t know which address to use (i.e. it does not&n; * yet know from or to which interface to go...).&n; */
r_int
r_int
DECL|function|my_addr
id|my_addr
c_func
(paren
r_void
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
r_return
id|dev-&gt;pa_addr
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Add a protocol ID to the list.  This will change soon. */
r_void
DECL|function|dev_add_pack
id|dev_add_pack
c_func
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|packet_type
op_star
id|p1
suffix:semicolon
id|pt-&gt;next
op_assign
id|ptype_base
suffix:semicolon
multiline_comment|/* See if we need to copy it. */
r_for
c_loop
(paren
id|p1
op_assign
id|ptype_base
suffix:semicolon
id|p1
op_ne
l_int|NULL
suffix:semicolon
id|p1
op_assign
id|p1-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p1-&gt;type
op_eq
id|pt-&gt;type
)paren
(brace
id|pt-&gt;copy
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|ptype_base
op_assign
id|pt
suffix:semicolon
)brace
multiline_comment|/* Remove a protocol ID from the list.  This will change soon. */
r_void
DECL|function|dev_remove_pack
id|dev_remove_pack
c_func
(paren
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|packet_type
op_star
id|lpt
comma
op_star
id|pt1
suffix:semicolon
r_if
c_cond
(paren
id|pt
op_eq
id|ptype_base
)paren
(brace
id|ptype_base
op_assign
id|pt-&gt;next
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lpt
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|pt1
op_assign
id|ptype_base
suffix:semicolon
id|pt1-&gt;next
op_ne
l_int|NULL
suffix:semicolon
id|pt1
op_assign
id|pt1-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|pt1-&gt;next
op_eq
id|pt
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pt-&gt;copy
op_logical_and
id|lpt
)paren
id|lpt-&gt;copy
op_assign
l_int|0
suffix:semicolon
id|pt1-&gt;next
op_assign
id|pt-&gt;next
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pt1-&gt;next
op_member_access_from_pointer
id|type
op_eq
id|pt
op_member_access_from_pointer
id|type
)paren
(brace
id|lpt
op_assign
id|pt1-&gt;next
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Find an interface in the list. This will change soon. */
r_struct
id|device
op_star
DECL|function|dev_get
id|dev_get
c_func
(paren
r_char
op_star
id|name
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|dev-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
r_return
id|dev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Find an interface that can handle addresses for a certain address. */
DECL|function|dev_check
r_struct
id|device
op_star
id|dev_check
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_POINTOPOINT
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_ne
id|dev-&gt;pa_dstaddr
)paren
r_continue
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_POINTOPOINT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;pa_mask
op_amp
(paren
id|addr
op_xor
id|dev-&gt;pa_addr
)paren
)paren
r_continue
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Prepare an interface for use. */
r_int
DECL|function|dev_open
id|dev_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;open
)paren
id|ret
op_assign
id|dev
op_member_access_from_pointer
id|open
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|dev-&gt;flags
op_or_assign
(paren
id|IFF_UP
op_or
id|IFF_RUNNING
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Completely shutdown an interface. */
r_int
DECL|function|dev_close
id|dev_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_ne
l_int|0
)paren
(brace
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;stop
)paren
id|dev
op_member_access_from_pointer
id|stop
c_func
(paren
id|dev
)paren
suffix:semicolon
id|rt_flush
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;pa_addr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_dstaddr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_brdaddr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Purge any queued packets when we down the link */
r_while
c_loop
(paren
id|ct
OL
id|DEV_NUMBUFFS
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|dev-&gt;buffs
(braket
id|ct
)braket
)paren
)paren
op_ne
l_int|NULL
)paren
r_if
c_cond
(paren
id|skb-&gt;free
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
id|ct
op_increment
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Send (or queue for sending) a packet. */
r_void
DECL|function|dev_queue_xmit
id|dev_queue_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_int
id|pri
)paren
(brace
r_int
id|where
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* used to say if the packet should go&t;*/
multiline_comment|/* at the front or the back of the&t;*/
multiline_comment|/* queue.&t;&t;&t;&t;*/
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;dev_queue_xmit(skb=%X, dev=%X, pri = %d)&bslash;n&quot;
comma
id|skb
comma
id|dev
comma
id|pri
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;dev.c: dev_queue_xmit: dev = NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;next
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Make sure we haven&squot;t missed an interrupt. */
id|dev
op_member_access_from_pointer
id|hard_start_xmit
c_func
(paren
l_int|NULL
comma
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pri
OL
l_int|0
)paren
(brace
id|pri
op_assign
op_minus
id|pri
op_minus
l_int|1
suffix:semicolon
id|where
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pri
op_ge
id|DEV_NUMBUFFS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bad priority in dev_queue_xmit.&bslash;n&quot;
)paren
suffix:semicolon
id|pri
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|hard_start_xmit
c_func
(paren
id|skb
comma
id|dev
)paren
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Put skb into a bidirectional circular linked list. */
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;dev_queue_xmit dev-&gt;buffs[%d]=%X&bslash;n&quot;
comma
id|pri
comma
id|dev-&gt;buffs
(braket
id|pri
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/* Interrupts should already be cleared by hard_start_xmit. */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb-&gt;magic
op_assign
id|DEV_QUEUE_MAGIC
suffix:semicolon
r_if
c_cond
(paren
id|where
)paren
(brace
id|skb_queue_head
c_func
(paren
op_amp
id|dev-&gt;buffs
(braket
id|pri
)braket
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
id|skb_queue_tail
c_func
(paren
op_amp
id|dev-&gt;buffs
(braket
id|pri
)braket
comma
id|skb
)paren
suffix:semicolon
id|skb-&gt;magic
op_assign
id|DEV_QUEUE_MAGIC
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Receive a packet from a device driver and queue it for the upper&n; * (protocol) levels.  It always succeeds.&n; */
r_void
DECL|function|netif_rx
id|netif_rx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* Set any necessary flags. */
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* and add it to the &quot;backlog&quot; queue. */
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|backlog
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* If any packet arrived, mark it for processing. */
r_if
c_cond
(paren
id|backlog
op_ne
l_int|NULL
)paren
id|mark_bh
c_func
(paren
id|INET_BH
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * The old interface to fetch a packet from a device driver.&n; * This function is the base level entry point for all drivers that&n; * want to send a packet to the upper (protocol) levels.  It takes&n; * care of de-multiplexing the packet to the various modules based&n; * on their protocol ID.&n; *&n; * Return values:&t;1 &lt;- exit I can&squot;t do any more&n; *&t;&t;&t;0 &lt;- feed me more (i.e. &quot;done&quot;, &quot;OK&quot;). &n; */
r_int
DECL|function|dev_rint
id|dev_rint
c_func
(paren
r_int
r_char
op_star
id|buff
comma
r_int
id|len
comma
r_int
id|flags
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_static
r_int
id|dropping
op_assign
l_int|0
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|to
suffix:semicolon
r_int
id|amount
comma
id|left
suffix:semicolon
r_int
id|len2
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
op_logical_or
id|buff
op_eq
l_int|NULL
op_logical_or
id|len
op_le
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|IN_SKBUFF
)paren
(brace
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|buff
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dropping
)paren
(brace
r_if
c_cond
(paren
id|backlog
op_ne
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;INET: dev_rint: no longer dropping packets.&bslash;n&quot;
)paren
suffix:semicolon
id|dropping
op_assign
l_int|0
suffix:semicolon
)brace
id|skb
op_assign
id|alloc_skb
c_func
(paren
r_sizeof
(paren
op_star
id|skb
)paren
op_plus
id|len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;dev_rint: packet dropped on %s (no memory) !&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|dropping
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|skb-&gt;mem_len
op_assign
r_sizeof
(paren
op_star
id|skb
)paren
op_plus
id|len
suffix:semicolon
id|skb-&gt;mem_addr
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|skb
suffix:semicolon
multiline_comment|/* First we copy the packet into a buffer, and save it for later. */
id|to
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
suffix:semicolon
id|left
op_assign
id|len
suffix:semicolon
id|len2
op_assign
id|len
suffix:semicolon
r_while
c_loop
(paren
id|len2
OG
l_int|0
)paren
(brace
id|amount
op_assign
id|min
c_func
(paren
id|len2
comma
(paren
r_int
r_int
)paren
id|dev-&gt;rmem_end
op_minus
(paren
r_int
r_int
)paren
id|buff
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|to
comma
id|buff
comma
id|amount
)paren
suffix:semicolon
id|len2
op_sub_assign
id|amount
suffix:semicolon
id|left
op_sub_assign
id|amount
suffix:semicolon
id|buff
op_add_assign
id|amount
suffix:semicolon
id|to
op_add_assign
id|amount
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|buff
op_eq
id|dev-&gt;rmem_end
)paren
id|buff
op_assign
(paren
r_int
r_char
op_star
)paren
id|dev-&gt;rmem_start
suffix:semicolon
)brace
)brace
id|skb-&gt;len
op_assign
id|len
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* OK, all done. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This routine causes all interfaces to try to send some data. */
r_void
DECL|function|dev_transmit
id|dev_transmit
c_func
(paren
r_void
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;tbusy
)paren
(brace
id|dev_tint
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|variable|in_bh
r_static
r_volatile
r_char
id|in_bh
op_assign
l_int|0
suffix:semicolon
DECL|function|in_inet_bh
r_int
id|in_inet_bh
c_func
(paren
)paren
multiline_comment|/* Used by timer.c */
(brace
r_return
id|in_bh
op_eq
l_int|0
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * This function gets called periodically, to see if we can&n; * process any data that came in from some interface.&n; *&n; */
r_void
DECL|function|inet_bh
id|inet_bh
c_func
(paren
r_void
op_star
id|tmp
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|packet_type
op_star
id|ptype
suffix:semicolon
r_int
r_int
id|type
suffix:semicolon
r_int
r_char
id|flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Atomically check and mark our BUSY state. */
r_if
c_cond
(paren
id|set_bit
c_func
(paren
l_int|1
comma
(paren
r_void
op_star
)paren
op_amp
id|in_bh
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Can we send anything now? */
id|dev_transmit
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Any data left to process? */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|backlog
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|flag
op_assign
l_int|0
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;* Bump the pointer to the next structure.&n;&t;* This assumes that the basic &squot;skb&squot; pointer points to&n;&t;* the MAC header, if any (as indicated by its &quot;length&quot;&n;&t;* field).  Take care now!&n;&t;*/
id|skb-&gt;h.raw
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
op_plus
id|skb-&gt;dev-&gt;hard_header_len
suffix:semicolon
id|skb-&gt;len
op_sub_assign
id|skb-&gt;dev-&gt;hard_header_len
suffix:semicolon
multiline_comment|/*&n;&t;* Fetch the packet protocol ID.  This is also quite ugly, as&n;&t;* it depends on the protocol driver (the interface itself) to&n;&t;* know what the type is, or where to get it from.  The Ethernet&n;&t;* interfaces fetch the ID from the two bytes in the Ethernet MAC&n;&t;* header (the h_proto field in struct ethhdr), but drivers like&n;&t;* SLIP and PLIP have no alternative but to force the type to be&n;&t;* IP or something like that.  Sigh- FvK&n;&t;* FIXME: Ethernet drivers need potty training in 802.3 packets -AC&n;&t;*/
id|type
op_assign
id|skb-&gt;dev
op_member_access_from_pointer
id|type_trans
c_func
(paren
id|skb
comma
id|skb-&gt;dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We got a packet ID.  Now loop over the &quot;known protocols&quot;&n;&t; * table (which is actually a linked list, but this will&n;&t; * change soon if I get my way- FvK), and forward the packet&n;&t; * to anyone who wants it.&n;&t; */
r_for
c_loop
(paren
id|ptype
op_assign
id|ptype_base
suffix:semicolon
id|ptype
op_ne
l_int|NULL
suffix:semicolon
id|ptype
op_assign
id|ptype-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ptype-&gt;type
op_eq
id|type
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_if
c_cond
(paren
id|ptype-&gt;copy
)paren
(brace
multiline_comment|/* copy if we need to&t;*/
id|skb2
op_assign
id|alloc_skb
c_func
(paren
id|skb-&gt;mem_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb2
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|memcpy
c_func
(paren
id|skb2
comma
(paren
r_const
r_void
op_star
)paren
id|skb
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
id|skb2-&gt;mem_addr
op_assign
id|skb2
suffix:semicolon
id|skb2-&gt;h.raw
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|skb2
op_plus
(paren
r_int
r_int
)paren
id|skb-&gt;h.raw
op_minus
(paren
r_int
r_int
)paren
id|skb
)paren
suffix:semicolon
id|skb2-&gt;free
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|skb2
op_assign
id|skb
suffix:semicolon
)brace
multiline_comment|/* This used to be in the &squot;else&squot; part, but then&n;&t;&t;&t; * we don&squot;t have this flag set when we get a&n;&t;&t;&t; * protocol that *does* require copying... -FvK&n;&t;&t;&t; */
id|flag
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Kick the protocol handler. */
id|ptype
op_member_access_from_pointer
id|func
c_func
(paren
id|skb2
comma
id|skb-&gt;dev
comma
id|ptype
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * That&squot;s odd.  We got an unknown packet.  Who&squot;s using&n;&t; * stuff like Novell or Amoeba on this network??&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;INET: unknown packet type 0x%04X (ignored)&bslash;n&quot;
comma
id|type
)paren
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
multiline_comment|/* Again, see if we can transmit anything now. */
id|dev_transmit
c_func
(paren
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|in_bh
op_assign
l_int|0
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|dev_transmit
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called when an device driver (i.e. an&n; * interface) is * ready to transmit a packet.&n; */
DECL|function|dev_tint
r_void
id|dev_tint
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_NUMBUFFS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|dev-&gt;buffs
(braket
id|i
)braket
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|skb-&gt;magic
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|dev
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
op_minus
id|i
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Perform a SIOCGIFCONF call. */
r_static
r_int
DECL|function|dev_ifconf
id|dev_ifconf
c_func
(paren
r_char
op_star
id|arg
)paren
(brace
r_struct
id|ifconf
id|ifc
suffix:semicolon
r_struct
id|ifreq
id|ifr
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_char
op_star
id|pos
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/* Fetch the caller&squot;s info block. */
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifconf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|ifc
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifconf
)paren
)paren
suffix:semicolon
id|len
op_assign
id|ifc.ifc_len
suffix:semicolon
id|pos
op_assign
id|ifc.ifc_buf
suffix:semicolon
multiline_comment|/* Loop over the interfaces, and write an info block for each. */
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|ifr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|ifr.ifr_name
comma
id|dev-&gt;name
)paren
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_addr.s_addr
op_assign
id|dev-&gt;pa_addr
suffix:semicolon
multiline_comment|/* Write this block to the caller&squot;s space. */
id|memcpy_tofs
c_func
(paren
id|pos
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|pos
op_add_assign
r_sizeof
(paren
r_struct
id|ifreq
)paren
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
r_struct
id|ifreq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* All done.  Write the updated control block back to the caller. */
id|ifc.ifc_len
op_assign
(paren
id|pos
op_minus
id|ifc.ifc_buf
)paren
suffix:semicolon
id|ifc.ifc_req
op_assign
(paren
r_struct
id|ifreq
op_star
)paren
id|ifc.ifc_buf
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifc
comma
r_sizeof
(paren
r_struct
id|ifconf
)paren
)paren
suffix:semicolon
r_return
id|pos
op_minus
id|arg
suffix:semicolon
)brace
multiline_comment|/* Print device statistics. */
DECL|function|sprintf_stats
r_char
op_star
id|sprintf_stats
c_func
(paren
r_char
op_star
id|buffer
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_char
op_star
id|pos
op_assign
id|buffer
suffix:semicolon
r_struct
id|enet_statistics
op_star
id|stats
op_assign
(paren
id|dev-&gt;get_stats
ques
c_cond
id|dev
op_member_access_from_pointer
id|get_stats
c_func
(paren
id|dev
)paren
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stats
)paren
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|pos
comma
l_string|&quot;%6s:%7d %4d %4d %4d %4d %8d %4d %4d %4d %5d %4d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|stats-&gt;rx_packets
comma
id|stats-&gt;rx_errors
comma
id|stats-&gt;rx_dropped
op_plus
id|stats-&gt;rx_missed_errors
comma
id|stats-&gt;rx_fifo_errors
comma
id|stats-&gt;rx_length_errors
op_plus
id|stats-&gt;rx_over_errors
op_plus
id|stats-&gt;rx_crc_errors
op_plus
id|stats-&gt;rx_frame_errors
comma
id|stats-&gt;tx_packets
comma
id|stats-&gt;tx_errors
comma
id|stats-&gt;tx_dropped
comma
id|stats-&gt;tx_fifo_errors
comma
id|stats-&gt;collisions
comma
id|stats-&gt;tx_carrier_errors
op_plus
id|stats-&gt;tx_aborted_errors
op_plus
id|stats-&gt;tx_window_errors
op_plus
id|stats-&gt;tx_heartbeat_errors
)paren
suffix:semicolon
r_else
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|pos
comma
l_string|&quot;%6s: No statistics available.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
id|pos
suffix:semicolon
)brace
multiline_comment|/* Called from the PROCfs module. */
r_int
DECL|function|dev_get_info
id|dev_get_info
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_char
op_star
id|pos
op_assign
id|buffer
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|pos
comma
l_string|&quot;Inter-|   Receive                  |  Transmit&bslash;n&quot;
l_string|&quot; face |packets errs drop fifo frame|packets errs drop fifo colls carrier&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
id|pos
op_assign
id|sprintf_stats
c_func
(paren
id|pos
comma
id|dev
)paren
suffix:semicolon
)brace
r_return
id|pos
op_minus
id|buffer
suffix:semicolon
)brace
DECL|function|bad_mask
r_static
r_inline
r_int
id|bad_mask
c_func
(paren
r_int
r_int
id|mask
comma
r_int
r_int
id|addr
)paren
(brace
r_if
c_cond
(paren
id|addr
op_amp
(paren
id|mask
op_assign
op_complement
id|mask
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|mask
op_assign
id|ntohl
c_func
(paren
id|mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
(paren
id|mask
op_plus
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Perform the SIOCxIFxxx calls. */
r_static
r_int
DECL|function|dev_ifsioc
id|dev_ifsioc
c_func
(paren
r_void
op_star
id|arg
comma
r_int
r_int
id|getset
)paren
(brace
r_struct
id|ifreq
id|ifr
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Fetch the caller&squot;s info block. */
r_int
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|ifr
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
multiline_comment|/* See which interface the caller is talking about. */
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|dev_get
c_func
(paren
id|ifr.ifr_name
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|getset
)paren
(brace
r_case
id|SIOCGIFFLAGS
suffix:colon
id|ifr.ifr_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFFLAGS
suffix:colon
(brace
r_int
id|old_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
id|dev-&gt;flags
op_assign
id|ifr.ifr_flags
op_amp
(paren
id|IFF_UP
op_or
id|IFF_BROADCAST
op_or
id|IFF_DEBUG
op_or
id|IFF_LOOPBACK
op_or
id|IFF_POINTOPOINT
op_or
id|IFF_NOTRAILERS
op_or
id|IFF_RUNNING
op_or
id|IFF_NOARP
op_or
id|IFF_PROMISC
op_or
id|IFF_ALLMULTI
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|old_flags
op_amp
id|IFF_PROMISC
)paren
op_logical_and
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
op_eq
l_int|0
)paren
)paren
id|dev
op_member_access_from_pointer
id|set_multicast_list
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
op_logical_and
(paren
(paren
id|old_flags
op_amp
id|IFF_PROMISC
)paren
op_eq
l_int|0
)paren
)paren
id|dev
op_member_access_from_pointer
id|set_multicast_list
c_func
(paren
id|dev
comma
op_minus
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|old_flags
op_amp
id|IFF_UP
)paren
op_logical_and
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|ret
op_assign
id|dev_close
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
(paren
op_logical_neg
(paren
id|old_flags
op_amp
id|IFF_UP
)paren
op_logical_and
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
ques
c_cond
id|dev_open
c_func
(paren
id|dev
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|dev-&gt;flags
op_and_assign
op_complement
id|IFF_UP
suffix:semicolon
)brace
multiline_comment|/* Didnt open so down the if */
)brace
)brace
r_break
suffix:semicolon
r_case
id|SIOCGIFADDR
suffix:colon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_addr.s_addr
op_assign
id|dev-&gt;pa_addr
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_port
op_assign
l_int|0
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFADDR
suffix:colon
id|dev-&gt;pa_addr
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_addr.sin_addr.s_addr
suffix:semicolon
id|dev-&gt;family
op_assign
id|ifr.ifr_addr.sa_family
suffix:semicolon
id|dev-&gt;pa_mask
op_assign
id|get_mask
c_func
(paren
id|dev-&gt;pa_addr
)paren
suffix:semicolon
id|dev-&gt;pa_brdaddr
op_assign
id|dev-&gt;pa_addr
op_or
op_complement
id|dev-&gt;pa_mask
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFBRDADDR
suffix:colon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_broadaddr.sin_addr.s_addr
op_assign
id|dev-&gt;pa_brdaddr
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_broadaddr.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_broadaddr.sin_port
op_assign
l_int|0
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFBRDADDR
suffix:colon
id|dev-&gt;pa_brdaddr
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_broadaddr.sin_addr.s_addr
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFDSTADDR
suffix:colon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_dstaddr.sin_addr.s_addr
op_assign
id|dev-&gt;pa_dstaddr
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_broadaddr.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_broadaddr.sin_port
op_assign
l_int|0
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFDSTADDR
suffix:colon
id|dev-&gt;pa_dstaddr
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_dstaddr.sin_addr.s_addr
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFNETMASK
suffix:colon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_netmask.sin_addr.s_addr
op_assign
id|dev-&gt;pa_mask
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_netmask.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_netmask.sin_port
op_assign
l_int|0
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFNETMASK
suffix:colon
(brace
r_int
r_int
id|mask
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|ifr.ifr_netmask.sin_addr.s_addr
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|bad_mask
c_func
(paren
id|mask
comma
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|dev-&gt;pa_mask
op_assign
id|mask
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|SIOCGIFMETRIC
suffix:colon
id|ifr.ifr_metric
op_assign
id|dev-&gt;metric
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFMETRIC
suffix:colon
id|dev-&gt;metric
op_assign
id|ifr.ifr_metric
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFMTU
suffix:colon
id|ifr.ifr_mtu
op_assign
id|dev-&gt;mtu
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFMTU
suffix:colon
id|dev-&gt;mtu
op_assign
id|ifr.ifr_mtu
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFMEM
suffix:colon
id|printk
c_func
(paren
l_string|&quot;NET: ioctl(SIOCGIFMEM, 0x%08X)&bslash;n&quot;
comma
(paren
r_int
)paren
id|arg
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFMEM
suffix:colon
id|printk
c_func
(paren
l_string|&quot;NET: ioctl(SIOCSIFMEM, 0x%08X)&bslash;n&quot;
comma
(paren
r_int
)paren
id|arg
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFHWADDR
suffix:colon
id|memcpy
c_func
(paren
id|ifr.ifr_hwaddr
comma
id|dev-&gt;dev_addr
comma
id|MAX_ADDR_LEN
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|ifr
comma
r_sizeof
(paren
r_struct
id|ifreq
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* This function handles all &quot;interface&quot;-type I/O control requests. */
r_int
DECL|function|dev_ioctl
id|dev_ioctl
c_func
(paren
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|iflink
id|iflink
suffix:semicolon
r_struct
id|ddi_device
op_star
id|dev
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|IP_SET_DEV
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Your network configuration program needs upgrading.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|SIOCGIFCONF
suffix:colon
(paren
r_void
)paren
id|dev_ifconf
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFFLAGS
suffix:colon
r_case
id|SIOCSIFFLAGS
suffix:colon
r_case
id|SIOCGIFADDR
suffix:colon
r_case
id|SIOCSIFADDR
suffix:colon
r_case
id|SIOCGIFDSTADDR
suffix:colon
r_case
id|SIOCSIFDSTADDR
suffix:colon
r_case
id|SIOCGIFBRDADDR
suffix:colon
r_case
id|SIOCSIFBRDADDR
suffix:colon
r_case
id|SIOCGIFNETMASK
suffix:colon
r_case
id|SIOCSIFNETMASK
suffix:colon
r_case
id|SIOCGIFMETRIC
suffix:colon
r_case
id|SIOCSIFMETRIC
suffix:colon
r_case
id|SIOCGIFMTU
suffix:colon
r_case
id|SIOCSIFMTU
suffix:colon
r_case
id|SIOCGIFMEM
suffix:colon
r_case
id|SIOCSIFMEM
suffix:colon
r_case
id|SIOCGIFHWADDR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|ret
op_assign
id|dev_ifsioc
c_func
(paren
id|arg
comma
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFLINK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|iflink
comma
id|arg
comma
r_sizeof
(paren
id|iflink
)paren
)paren
suffix:semicolon
id|dev
op_assign
id|ddi_map
c_func
(paren
id|iflink.id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Now allocate an interface and connect it. */
id|printk
c_func
(paren
l_string|&quot;AF_INET: DDI &bslash;&quot;%s&bslash;&quot; linked to stream &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|iflink.stream
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Initialize the DEV module. */
r_void
DECL|function|dev_init
id|dev_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|device
op_star
id|dev
comma
op_star
id|dev2
suffix:semicolon
multiline_comment|/* Add the devices.&n;   * If the call to dev-&gt;init fails, the dev is removed&n;   * from the chain disconnecting the device until the&n;   * next reboot.&n;   */
id|dev2
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;init
op_logical_and
id|dev
op_member_access_from_pointer
id|init
c_func
(paren
id|dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|dev2
op_eq
l_int|NULL
)paren
id|dev_base
op_assign
id|dev-&gt;next
suffix:semicolon
r_else
id|dev2-&gt;next
op_assign
id|dev-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|dev2
op_assign
id|dev
suffix:semicolon
)brace
)brace
multiline_comment|/* Set up some IP addresses. */
id|ip_bcast
op_assign
id|in_aton
c_func
(paren
l_string|&quot;255.255.255.255&quot;
)paren
suffix:semicolon
)brace
eof
