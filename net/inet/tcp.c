multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Implementation of the Transmission Control Protocol(TCP).&n; *&n; * Version:&t;@(#)tcp.c&t;1.0.16&t;05/25/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&t;&t;Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;&n; *&t;&t;Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&n; * Fixes:&t;&n; *&t;&t;Alan Cox&t;:&t;Numerous verify_area() calls&n; *&t;&t;Alan Cox&t;:&t;Set the ACK bit on a reset&n; *&t;&t;Alan Cox&t;:&t;Stopped it crashing if it closed while sk-&gt;inuse=1&n; *&t;&t;&t;&t;&t;and was trying to connect (tcp_err()).&n; *&t;&t;Alan Cox&t;:&t;All icmp error handling was broken&n; *&t;&t;&t;&t;&t;pointers passed where wrong and the&n; *&t;&t;&t;&t;&t;socket was looked up backwards. Nobody&n; *&t;&t;&t;&t;&t;tested any icmp error code obviously.&n; *&t;&t;Alan Cox&t;:&t;tcp_err() now handled properly. It wakes people&n; *&t;&t;&t;&t;&t;on errors. select behaves and the icmp error race&n; *&t;&t;&t;&t;&t;has gone by moving it into sock.c&n; *&t;&t;Alan Cox&t;:&t;tcp_reset() fixed to work for everything not just&n; *&t;&t;&t;&t;&t;packets for unknown sockets.&n; *&t;&t;Alan Cox&t;:&t;tcp option processing.&n; *&t;&t;Alan Cox&t;:&t;Reset tweaked (still not 100%) [Had syn rule wrong]&n; *&t;&t;Herp Rosmanith  :&t;More reset fixes&n; *&t;&t;Alan Cox&t;:&t;No longer acks invalid rst frames. Acking&n; *&t;&t;&t;&t;&t;any kind of RST is right out.&n; *&t;&t;Alan Cox&t;:&t;Sets an ignore me flag on an rst receive&n; *&t;&t;&t;&t;&t;otherwise odd bits of prattle escape still&n; *&t;&t;Alan Cox&t;:&t;Fixed another acking RST frame bug. Should stop&n; *&t;&t;&t;&t;&t;LAN workplace lockups.&n; *&t;&t;Alan Cox&t;: &t;Some tidyups using the new skb list facilities&n; *&t;&t;Alan Cox&t;:&t;sk-&gt;keepopen now seems to work&n; *&t;&t;Alan Cox&t;:&t;Pulls options out correctly on accepts&n; *&t;&t;Alan Cox&t;:&t;Fixed assorted sk-&gt;rqueue-&gt;next errors&n; *&t;&t;Alan Cox&t;:&t;PSH doesn&squot;t end a TCP read. Switched a bit to skb ops.&n; *&t;&t;Alan Cox&t;:&t;Tidied tcp_data to avoid a potential nasty.&n; *&t;&t;Alan Cox&t;:&t;Added some beter commenting, as the tcp is hard to follow&n; *&t;&t;Alan Cox&t;:&t;Removed incorrect check for 20 * psh&n; *&t;Michael O&squot;Reilly&t;:&t;ack &lt; copied bug fix.&n; *&t;Johannes Stille&t;&t;:&t;Misc tcp fixes (not all in yet).&n; *&t;&t;Alan Cox&t;:&t;FIN with no memory -&gt; CRASH&n; *&t;&t;Alan Cox&t;:&t;Added socket option proto entries. Also added awareness of them to accept.&n; *&t;&t;Alan Cox&t;:&t;Added TCP options (SOL_TCP)&n; *&t;&t;Alan Cox&t;:&t;Switched wakeup calls to callbacks, so the kernel can layer network sockets.&n; *&t;&t;Alan Cox&t;:&t;Use ip_tos/ip_ttl settings.&n; *&t;&t;Alan Cox&t;:&t;Handle FIN (more) properly (we hope).&n; *&t;&t;Alan Cox&t;:&t;RST frames sent on unsynchronised state ack error/&n; *&t;&t;Alan Cox&t;:&t;Put in missing check for SYN bit.&n; *&t;&t;Alan Cox&t;:&t;Added tcp_select_window() aka NET2E &n; *&t;&t;&t;&t;&t;window non shrink trick.&n; *&t;&t;Alan Cox&t;:&t;Added a couple of small NET2E timer fixes&n; *&t;&t;Charles Hedrick :&t;TCP fixes&n; *&t;&t;Toomas Tamm&t;:&t;TCP window fixes&n; *&t;&t;Alan Cox&t;:&t;Small URG fix to rlogin ^C ack fight&n; *&t;&t;Charles Hedrick&t;:&t;Rewrote most of it to actually work&n; *&t;&t;Linus&t;&t;:&t;Rewrote tcp_read() and URG handling&n; *&t;&t;&t;&t;&t;completely&n; *&t;&t;Gerhard Koerting:&t;Fixed some missing timer handling&n; *&n; *&n; * To Fix:&n; *&t;&t;&t;Possibly a problem with accept(). BSD accept never fails after&n; *&t;&t;it causes a select. Linux can - given the official select semantics I&n; *&t;&t;feel that _really_ its the BSD network programs that are bust (notably&n; *&t;&t;inetd, which hangs occasionally because of this).&n; *&t;&t;&t;Protocol closedown badly messed up.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or(at your option) any later version.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/termios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &quot;snmp.h&quot;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;icmp.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
DECL|macro|SEQ_TICK
mdefine_line|#define SEQ_TICK 3
DECL|variable|seq_offset
r_int
r_int
id|seq_offset
suffix:semicolon
DECL|variable|tcp_statistics
r_struct
id|tcp_mib
id|tcp_statistics
suffix:semicolon
DECL|macro|SUBNETSARELOCAL
mdefine_line|#define SUBNETSARELOCAL
r_static
id|__inline__
r_int
DECL|function|min
id|min
c_func
(paren
r_int
r_int
id|a
comma
r_int
r_int
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
OL
id|b
)paren
r_return
id|a
suffix:semicolon
r_return
id|b
suffix:semicolon
)brace
DECL|function|__print_th
r_static
r_void
id|__print_th
c_func
(paren
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
r_int
r_char
op_star
id|ptr
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TCP header:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    source=%d, dest=%d, seq =%ld, ack_seq = %ld&bslash;n&quot;
comma
id|ntohs
c_func
(paren
id|th-&gt;source
)paren
comma
id|ntohs
c_func
(paren
id|th-&gt;dest
)paren
comma
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
comma
id|ntohl
c_func
(paren
id|th-&gt;ack_seq
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    fin=%d, syn=%d, rst=%d, psh=%d, ack=%d, urg=%d res1=%d res2=%d&bslash;n&quot;
comma
id|th-&gt;fin
comma
id|th-&gt;syn
comma
id|th-&gt;rst
comma
id|th-&gt;psh
comma
id|th-&gt;ack
comma
id|th-&gt;urg
comma
id|th-&gt;res1
comma
id|th-&gt;res2
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    window = %d, check = %d urg_ptr = %d&bslash;n&quot;
comma
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
comma
id|ntohs
c_func
(paren
id|th-&gt;check
)paren
comma
id|ntohs
c_func
(paren
id|th-&gt;urg_ptr
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    doff = %d&bslash;n&quot;
comma
id|th-&gt;doff
)paren
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    options = %d %d %d %d&bslash;n&quot;
comma
id|ptr
(braket
l_int|0
)braket
comma
id|ptr
(braket
l_int|1
)braket
comma
id|ptr
(braket
l_int|2
)braket
comma
id|ptr
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
DECL|function|print_th
r_static
r_inline
r_void
id|print_th
c_func
(paren
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
r_if
c_cond
(paren
id|inet_debug
op_eq
id|DBG_TCP
)paren
id|__print_th
c_func
(paren
id|th
)paren
suffix:semicolon
)brace
multiline_comment|/* This routine picks a TCP windows for a socket based on&n;   the following constraints&n;   &n;   1. The window can never be shrunk once it is offered (RFC 793)&n;   2. We limit memory per socket&n;   &n;   For now we use NET2E3&squot;s heuristic of offering half the memory&n;   we have handy. All is not as bad as this seems however because&n;   of two things. Firstly we will bin packets even within the window&n;   in order to get the data we are waiting for into the memory limit.&n;   Secondly we bin common duplicate forms at receive time&n;&n;   Better heuristics welcome&n;*/
DECL|function|tcp_select_window
r_static
r_int
id|tcp_select_window
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|new_window
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n; * two things are going on here.  First, we don&squot;t ever offer a&n; * window less than min(sk-&gt;mss, MAX_WINDOW/2).  This is the&n; * receiver side of SWS as specified in RFC1122.&n; * Second, we always give them at least the window they&n; * had before, in order to avoid retracting window.  This&n; * is technically allowed, but RFC1122 advises against it and&n; * in practice it causes trouble.&n; */
r_if
c_cond
(paren
id|new_window
OL
id|min
c_func
(paren
id|sk-&gt;mss
comma
id|MAX_WINDOW
op_div
l_int|2
)paren
op_logical_or
id|new_window
OL
id|sk-&gt;window
)paren
r_return
id|sk-&gt;window
suffix:semicolon
r_return
id|new_window
suffix:semicolon
)brace
multiline_comment|/* Enter the time wait state. */
DECL|function|tcp_time_wait
r_static
r_void
id|tcp_time_wait
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sk-&gt;state
op_assign
id|TCP_TIME_WAIT
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;A timer event has trigger a tcp retransmit timeout. The&n; *&t;socket xmit queue is ready and set up to send. Because&n; *&t;the ack receive code keeps the queue straight we do&n; *&t;nothing clever here.&n; */
r_static
r_void
DECL|function|tcp_retransmit
id|tcp_retransmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|all
)paren
(brace
r_if
c_cond
(paren
id|all
)paren
(brace
id|ip_retransmit
c_func
(paren
id|sk
comma
id|all
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sk-&gt;ssthresh
op_assign
id|sk-&gt;cong_window
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/* remember window where we lost */
multiline_comment|/* sk-&gt;ssthresh in theory can be zero.  I guess that&squot;s OK */
id|sk-&gt;cong_count
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;cong_window
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Do the actual retransmit. */
id|ip_retransmit
c_func
(paren
id|sk
comma
id|all
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called by the ICMP module when it gets some&n; * sort of error condition.  If err &lt; 0 then the socket should&n; * be closed and the error returned to the user.  If err &gt; 0&n; * it&squot;s just the icmp type &lt;&lt; 8 | icmp code.  After adjustment&n; * header points to the first 8 bytes of the tcp header.  We need&n; * to find the appropriate port.&n; */
r_void
DECL|function|tcp_err
id|tcp_err
c_func
(paren
r_int
id|err
comma
r_int
r_char
op_star
id|header
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|saddr
comma
r_struct
id|inet_protocol
op_star
id|protocol
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_struct
id|iphdr
op_star
id|iph
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
id|header
suffix:semicolon
id|header
op_add_assign
l_int|4
op_star
id|iph-&gt;ihl
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;TCP: tcp_err(%d, hdr=%X, daddr=%X saddr=%X, protocol=%X)&bslash;n&quot;
comma
id|err
comma
id|header
comma
id|daddr
comma
id|saddr
comma
id|protocol
)paren
)paren
suffix:semicolon
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|header
suffix:semicolon
id|sk
op_assign
id|get_sock
c_func
(paren
op_amp
id|tcp_prot
comma
id|th-&gt;source
multiline_comment|/*dest*/
comma
id|daddr
comma
id|th-&gt;dest
multiline_comment|/*source*/
comma
id|saddr
)paren
suffix:semicolon
id|print_th
c_func
(paren
id|th
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|sk-&gt;err
op_assign
op_minus
id|err
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_amp
l_int|0xff00
)paren
op_eq
(paren
id|ICMP_SOURCE_QUENCH
op_lshift
l_int|8
)paren
)paren
(brace
multiline_comment|/*&n;&t; * FIXME:&n;&t; * For now we will just trigger a linear backoff.&n;&t; * The slow start code should cause a real backoff here.&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;cong_window
OG
l_int|4
)paren
id|sk-&gt;cong_window
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;TCP: icmp_err got error&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sk-&gt;err
op_assign
id|icmp_err_convert
(braket
id|err
op_amp
l_int|0xff
)braket
dot
id|errno
suffix:semicolon
multiline_comment|/*&n;   * If we&squot;ve already connected we will keep trying&n;   * until we time out, or the user gives up.&n;   */
r_if
c_cond
(paren
id|icmp_err_convert
(braket
id|err
op_amp
l_int|0xff
)braket
dot
id|fatal
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
)paren
(brace
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|sk
op_member_access_from_pointer
id|error_report
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Wake people up to see the error (see connect in sock.c) */
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Walk down the receive queue counting readable data until we hit the end or we find a gap&n; *&t;in the received data queue (ie a frame missing that needs sending to us)&n; */
r_static
r_int
DECL|function|tcp_readable
id|tcp_readable
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
r_int
id|counted
suffix:semicolon
r_int
r_int
id|amount
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|sum
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_readable(sk=%X)&bslash;n&quot;
comma
id|sk
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_logical_and
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tcp_readable: %p - &quot;
comma
id|sk
)paren
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
op_logical_or
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_logical_and
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;empty&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|counted
op_assign
id|sk-&gt;copied_seq
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Where we are at the moment */
id|amount
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do until a push or until we are out of data. */
r_do
(brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|counted
comma
id|skb-&gt;h.th-&gt;seq
)paren
)paren
multiline_comment|/* Found a hole so stops here */
r_break
suffix:semicolon
id|sum
op_assign
id|skb-&gt;len
op_minus
(paren
id|counted
op_minus
id|skb-&gt;h.th-&gt;seq
)paren
suffix:semicolon
multiline_comment|/* Length - header but start from where we are up to (avoid overlaps) */
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;syn
)paren
id|sum
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sum
op_ge
l_int|0
)paren
(brace
multiline_comment|/* Add it up, move on */
id|amount
op_add_assign
id|sum
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;syn
)paren
id|amount
op_decrement
suffix:semicolon
id|counted
op_add_assign
id|sum
suffix:semicolon
)brace
r_if
c_cond
(paren
id|amount
op_logical_and
id|skb-&gt;h.th-&gt;psh
)paren
r_break
suffix:semicolon
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;receive_queue
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|amount
op_logical_and
op_logical_neg
id|sk-&gt;urginline
op_logical_and
id|sk-&gt;urg_data
op_logical_and
(paren
id|sk-&gt;urg_seq
op_minus
id|sk-&gt;copied_seq
)paren
op_le
(paren
id|counted
op_minus
id|sk-&gt;copied_seq
)paren
)paren
id|amount
op_decrement
suffix:semicolon
multiline_comment|/* don&squot;t count urg data */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp readable returning %d bytes&bslash;n&quot;
comma
id|amount
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;got %lu bytes.&bslash;n&quot;
comma
id|amount
)paren
suffix:semicolon
)brace
r_return
id|amount
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Wait for a TCP event. Note the oddity with SEL_IN and reading. The&n; *&t;listening socket has a receive queue of sockets to accept.&n; */
r_static
r_int
DECL|function|tcp_select
id|tcp_select
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_select(sk=%X, sel_type = %d, wait = %X)&bslash;n&quot;
comma
id|sk
comma
id|sel_type
comma
id|wait
)paren
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|sel_type
)paren
(brace
r_case
id|SEL_IN
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;select in&quot;
)paren
suffix:semicolon
)brace
id|select_wait
c_func
(paren
id|sk-&gt;sleep
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;-select out&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
op_logical_or
id|tcp_readable
c_func
(paren
id|sk
)paren
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;-select ok data&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sk-&gt;err
op_ne
l_int|0
)paren
multiline_comment|/* Receiver error */
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;-select ok error&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;-select ok down&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;-select fail&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|SEL_OUT
suffix:colon
id|select_wait
c_func
(paren
id|sk-&gt;sleep
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;write select on shutdown socket.&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: should this return an error? */
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * FIXME:&n;&t;&t; * Hack so it will probably be able to write&n;&t;&t; * something if it says it&squot;s ok to write.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;prot
op_member_access_from_pointer
id|wspace
c_func
(paren
id|sk
)paren
op_ge
id|sk-&gt;mss
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* This should cause connect to work ok. */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_RECV
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_select: sleeping on write sk-&gt;wmem_alloc = %d, &quot;
l_string|&quot;sk-&gt;packets_out = %d&bslash;n&quot;
l_string|&quot;sk-&gt;write_seq = %u, sk-&gt;window_seq=%u&bslash;n&quot;
comma
id|sk-&gt;wmem_alloc
comma
id|sk-&gt;packets_out
comma
id|sk-&gt;write_seq
comma
id|sk-&gt;window_seq
)paren
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SEL_EX
suffix:colon
id|select_wait
c_func
(paren
id|sk-&gt;sleep
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;err
op_logical_or
id|sk-&gt;urg_data
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|tcp_ioctl
id|tcp_ioctl
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_ioctl(sk=%X, cmd = %d, arg=%X)&bslash;n&quot;
comma
id|sk
comma
id|cmd
comma
id|arg
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|DDIOCSDBG
suffix:colon
r_return
id|dbg_ioctl
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|DBG_TCP
)paren
suffix:semicolon
r_case
id|TIOCINQ
suffix:colon
macro_line|#ifdef FIXME&t;/* FIXME: */
r_case
id|FIONREAD
suffix:colon
macro_line|#endif
(brace
r_int
r_int
id|amount
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|amount
op_assign
id|tcp_readable
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;returning %d&bslash;n&quot;
comma
id|amount
)paren
)paren
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_fs_long
c_func
(paren
id|amount
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|SIOCATMARK
suffix:colon
(brace
r_int
id|answ
op_assign
id|sk-&gt;urg_data
op_logical_and
id|sk-&gt;urg_seq
op_eq
id|sk-&gt;copied_seq
op_plus
l_int|1
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|put_fs_long
c_func
(paren
id|answ
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|TIOCOUTQ
suffix:colon
(brace
r_int
r_int
id|amount
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|amount
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wspace
c_func
(paren
id|sk
)paren
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_fs_long
c_func
(paren
id|amount
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/* This routine computes a TCP checksum. */
r_int
r_int
DECL|function|tcp_check
id|tcp_check
c_func
(paren
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
)paren
(brace
r_int
r_int
id|sum
suffix:semicolon
r_if
c_cond
(paren
id|saddr
op_eq
l_int|0
)paren
id|saddr
op_assign
id|ip_my_addr
c_func
(paren
)paren
suffix:semicolon
id|print_th
c_func
(paren
id|th
)paren
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t addl %%ecx,%%ebx&bslash;n&quot;
l_string|&quot;&bslash;t adcl %%edx,%%ebx&bslash;n&quot;
l_string|&quot;&bslash;t adcl $0, %%ebx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|daddr
)paren
comma
l_string|&quot;c&quot;
(paren
id|saddr
)paren
comma
l_string|&quot;d&quot;
(paren
(paren
id|ntohs
c_func
(paren
id|len
)paren
op_lshift
l_int|16
)paren
op_plus
id|IPPROTO_TCP
op_star
l_int|256
)paren
suffix:colon
l_string|&quot;cx&quot;
comma
l_string|&quot;bx&quot;
comma
l_string|&quot;dx&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|3
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;&bslash;tclc&bslash;n&quot;
l_string|&quot;1:&bslash;n&quot;
l_string|&quot;&bslash;t lodsl&bslash;n&quot;
l_string|&quot;&bslash;t adcl %%eax, %%ebx&bslash;n&quot;
l_string|&quot;&bslash;t loop 1b&bslash;n&quot;
l_string|&quot;&bslash;t adcl $0, %%ebx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
comma
l_string|&quot;=S&quot;
(paren
id|th
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;c&quot;
(paren
id|len
op_div
l_int|4
)paren
comma
l_string|&quot;1&quot;
(paren
id|th
)paren
suffix:colon
l_string|&quot;ax&quot;
comma
l_string|&quot;cx&quot;
comma
l_string|&quot;bx&quot;
comma
l_string|&quot;si&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Convert from 32 bits to 16 bits. */
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t movl %%ebx, %%ecx&bslash;n&quot;
l_string|&quot;&bslash;t shrl $16,%%ecx&bslash;n&quot;
l_string|&quot;&bslash;t addw %%cx, %%bx&bslash;n&quot;
l_string|&quot;&bslash;t adcw $0, %%bx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;bx&quot;
comma
l_string|&quot;cx&quot;
)paren
suffix:semicolon
multiline_comment|/* Check for an extra word. */
r_if
c_cond
(paren
(paren
id|len
op_amp
l_int|2
)paren
op_ne
l_int|0
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t lodsw&bslash;n&quot;
l_string|&quot;&bslash;t addw %%ax,%%bx&bslash;n&quot;
l_string|&quot;&bslash;t adcw $0, %%bx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
comma
l_string|&quot;=S&quot;
(paren
id|th
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;1&quot;
(paren
id|th
)paren
suffix:colon
l_string|&quot;si&quot;
comma
l_string|&quot;ax&quot;
comma
l_string|&quot;bx&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Now check for the extra byte. */
r_if
c_cond
(paren
(paren
id|len
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;&bslash;t lodsb&bslash;n&quot;
l_string|&quot;&bslash;t movb $0,%%ah&bslash;n&quot;
l_string|&quot;&bslash;t addw %%ax,%%bx&bslash;n&quot;
l_string|&quot;&bslash;t adcw $0, %%bx&bslash;n&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;S&quot;
(paren
id|th
)paren
suffix:colon
l_string|&quot;si&quot;
comma
l_string|&quot;ax&quot;
comma
l_string|&quot;bx&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* We only want the bottom 16 bits, but we never cleared the top 16. */
r_return
(paren
op_complement
id|sum
)paren
op_amp
l_int|0xffff
suffix:semicolon
)brace
DECL|function|tcp_send_check
r_void
id|tcp_send_check
c_func
(paren
r_struct
id|tcphdr
op_star
id|th
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
comma
r_int
id|len
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|th-&gt;check
op_assign
l_int|0
suffix:semicolon
id|th-&gt;check
op_assign
id|tcp_check
c_func
(paren
id|th
comma
id|len
comma
id|saddr
comma
id|daddr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|tcp_send_skb
r_static
r_void
id|tcp_send_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|size
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
multiline_comment|/* length of packet (not counting length of pre-tcp headers) */
id|size
op_assign
id|skb-&gt;len
op_minus
(paren
(paren
r_int
r_char
op_star
)paren
id|th
op_minus
id|skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/* sanity check it.. */
r_if
c_cond
(paren
id|size
template_param
id|skb-&gt;len
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tcp_send_skb: bad skb (skb = %p, data = %p, th = %p, len = %lu)&bslash;n&quot;
comma
id|skb
comma
id|skb-&gt;data
comma
id|th
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If we have queued a header size packet.. */
r_if
c_cond
(paren
id|size
op_eq
r_sizeof
(paren
r_struct
id|tcphdr
)paren
)paren
(brace
multiline_comment|/* If its got a syn or fin its notionally included in the size..*/
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;syn
op_logical_and
op_logical_neg
id|th-&gt;fin
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tcp_send_skb: attempt to queue a bogon.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
multiline_comment|/* We need to complete and send the packet. */
id|tcp_send_check
c_func
(paren
id|th
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
id|size
comma
id|sk
)paren
suffix:semicolon
id|skb-&gt;h.seq
op_assign
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
op_plus
id|size
op_minus
l_int|4
op_star
id|th-&gt;doff
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|skb-&gt;h.seq
comma
id|sk-&gt;window_seq
)paren
op_logical_or
(paren
id|sk-&gt;retransmits
op_logical_and
id|sk-&gt;timeout
op_eq
id|TIME_WRITE
)paren
op_logical_or
id|sk-&gt;packets_out
op_ge
id|sk-&gt;cong_window
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;sk-&gt;cong_window = %d, sk-&gt;packets_out = %d&bslash;n&quot;
comma
id|sk-&gt;cong_window
comma
id|sk-&gt;packets_out
)paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;sk-&gt;write_seq = %d, sk-&gt;window_seq = %d&bslash;n&quot;
comma
id|sk-&gt;write_seq
comma
id|sk-&gt;window_seq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tcp_send_partial: next != NULL&bslash;n&quot;
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|before
c_func
(paren
id|sk-&gt;window_seq
comma
id|sk-&gt;write_queue.next-&gt;h.seq
)paren
op_logical_and
id|sk-&gt;send_head
op_eq
l_int|NULL
op_logical_and
id|sk-&gt;ack_backlog
op_eq
l_int|0
)paren
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;sent_seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|skb-&gt;dev
comma
id|skb
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
DECL|function|tcp_dequeue_partial
r_struct
id|sk_buff
op_star
id|tcp_dequeue_partial
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb
op_assign
id|sk-&gt;partial
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
id|sk-&gt;partial
op_assign
l_int|NULL
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;partial_timer
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
DECL|function|tcp_send_partial
r_static
r_void
id|tcp_send_partial
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|tcp_dequeue_partial
c_func
(paren
id|sk
)paren
)paren
op_ne
l_int|NULL
)paren
id|tcp_send_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
DECL|function|tcp_enqueue_partial
r_void
id|tcp_enqueue_partial
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|tmp
op_assign
id|sk-&gt;partial
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;partial_timer
)paren
suffix:semicolon
id|sk-&gt;partial
op_assign
id|skb
suffix:semicolon
id|sk-&gt;partial_timer.expires
op_assign
id|HZ
suffix:semicolon
id|sk-&gt;partial_timer.function
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|tcp_send_partial
suffix:semicolon
id|sk-&gt;partial_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;partial_timer
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
id|tcp_send_skb
c_func
(paren
id|sk
comma
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/* This routine sends an ack and also updates the window. */
r_static
r_void
DECL|function|tcp_send_ack
id|tcp_send_ack
c_func
(paren
r_int
r_int
id|sequence
comma
r_int
r_int
id|ack
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
r_int
id|daddr
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* We have been reset, we may not send again */
multiline_comment|/*&n;   * We need to grab some memory, and put together an ack,&n;   * and then put it into the queue to be sent.&n;   */
id|buff
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|MAX_ACK_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Force it to send an ack. */
id|sk-&gt;ack_backlog
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;timeout
op_ne
id|TIME_WRITE
op_logical_and
id|tcp_connected
c_func
(paren
id|sk-&gt;state
)paren
)paren
(brace
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
l_int|10
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inet_debug
op_eq
id|DBG_SLIP
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;rtcp_ack: malloc failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buff-&gt;len
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|buff-&gt;data
suffix:semicolon
multiline_comment|/* Put in the IP header and routing stuff. */
id|tmp
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|MAX_ACK_SIZE
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|buff-&gt;mem_addr
comma
id|buff-&gt;mem_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inet_debug
op_eq
id|DBG_SLIP
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;rtcp_ack: build_header failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buff-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|t1
op_plus
id|tmp
)paren
suffix:semicolon
multiline_comment|/* FIXME: */
id|memcpy
c_func
(paren
id|t1
comma
id|th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
multiline_comment|/* this should probably be removed */
multiline_comment|/* swap the send and the receive. */
id|t1-&gt;dest
op_assign
id|th-&gt;source
suffix:semicolon
id|t1-&gt;source
op_assign
id|th-&gt;dest
suffix:semicolon
id|t1-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|sequence
)paren
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;window
op_assign
id|tcp_select_window
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*sk-&gt;prot-&gt;rspace(sk);*/
id|t1-&gt;window
op_assign
id|ntohs
c_func
(paren
id|sk-&gt;window
)paren
suffix:semicolon
id|t1-&gt;res1
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;res2
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;syn
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;fin
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ack
op_eq
id|sk-&gt;acked_seq
)paren
(brace
id|sk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;bytes_rcv
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ack_timed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;send_head
op_eq
l_int|NULL
op_logical_and
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_eq
l_int|NULL
op_logical_and
id|sk-&gt;timeout
op_eq
id|TIME_WRITE
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;keepopen
)paren
(brace
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_KEEPOPEN
comma
id|TCP_TIMEOUT_LEN
)paren
suffix:semicolon
)brace
r_else
id|delete_timer
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
id|t1-&gt;ack_seq
op_assign
id|ntohl
c_func
(paren
id|ack
)paren
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;rtcp_ack: seq %lx ack %lx&bslash;n&quot;
comma
id|sequence
comma
id|ack
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* This routine builds a generic TCP header. */
r_static
r_int
DECL|function|tcp_build_header
id|tcp_build_header
c_func
(paren
r_struct
id|tcphdr
op_star
id|th
comma
r_struct
id|sock
op_star
id|sk
comma
r_int
id|push
)paren
(brace
multiline_comment|/* FIXME: want to get rid of this. */
id|memcpy
c_func
(paren
id|th
comma
(paren
r_void
op_star
)paren
op_amp
(paren
id|sk-&gt;dummy_th
)paren
comma
r_sizeof
(paren
op_star
id|th
)paren
)paren
suffix:semicolon
id|th-&gt;seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;write_seq
)paren
suffix:semicolon
id|th-&gt;psh
op_assign
(paren
id|push
op_eq
l_int|0
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|th-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|th
)paren
op_div
l_int|4
suffix:semicolon
id|th-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|th-&gt;fin
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;bytes_rcv
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ack_timed
op_assign
l_int|0
suffix:semicolon
id|th-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|sk-&gt;window
op_assign
id|tcp_select_window
c_func
(paren
id|sk
)paren
multiline_comment|/*sk-&gt;prot-&gt;rspace(sk)*/
suffix:semicolon
id|th-&gt;window
op_assign
id|htons
c_func
(paren
id|sk-&gt;window
)paren
suffix:semicolon
r_return
r_sizeof
(paren
op_star
id|th
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine copies from a user buffer into a socket,&n; * and starts the transmit system.&n; */
r_static
r_int
DECL|function|tcp_write
id|tcp_write
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|from
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
)paren
(brace
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
r_int
id|copy
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|sk_buff
op_star
id|send_tmp
suffix:semicolon
r_int
r_char
op_star
id|buff
suffix:semicolon
r_struct
id|proto
op_star
id|prot
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_write(sk=%X, from=%X, len=%d, nonblock=%d, flags=%X)&bslash;n&quot;
comma
id|sk
comma
id|from
comma
id|len
comma
id|nonblock
comma
id|flags
)paren
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|prot
op_assign
id|sk-&gt;prot
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;err
)paren
(brace
multiline_comment|/* Stop on an error */
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
id|tmp
op_assign
op_minus
id|sk-&gt;err
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
multiline_comment|/* First thing we do is make sure that we are established. */
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;err
op_assign
id|EPIPE
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
multiline_comment|/* Wait for a connection to finish. */
r_while
c_loop
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_CLOSE_WAIT
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;err
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
id|tmp
op_assign
op_minus
id|sk-&gt;err
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_SYN_SENT
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_SYN_RECV
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_write: return 1&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
(brace
id|tmp
op_assign
op_minus
id|sk-&gt;err
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;keepopen
)paren
(brace
id|send_sig
c_func
(paren
id|SIGPIPE
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nonblock
op_logical_or
id|copied
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_write: return 2&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_CLOSE_WAIT
op_logical_and
id|sk-&gt;err
op_eq
l_int|0
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_write: return 3&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The following code can result in copy &lt;= if sk-&gt;mss is ever&n; * decreased.  It shouldn&squot;t be.  sk-&gt;mss is min(sk-&gt;mtu, sk-&gt;max_window).&n; * sk-&gt;mtu is constant once SYN processing is finished.  I.e. we&n; * had better not get here until we&squot;ve seen his SYN and at least one&n; * valid ack.  (The SYN sets sk-&gt;mtu and the ack sets sk-&gt;max_window.)&n; * But ESTABLISHED should guarantee that.  sk-&gt;max_window is by definition&n; * non-decreasing.  Note that any ioctl to set user_mss must be done&n; * before the exchange of SYN&squot;s.  If the initial ack from the other&n; * end has a window of 0, max_window and thus mss will both be 0.&n; */
multiline_comment|/* Now we need to check if we have a half built packet. */
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|tcp_dequeue_partial
c_func
(paren
id|sk
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|hdrlen
suffix:semicolon
multiline_comment|/* IP header + TCP header */
id|hdrlen
op_assign
(paren
(paren
r_int
r_int
)paren
id|skb-&gt;h.th
op_minus
(paren
r_int
r_int
)paren
id|skb-&gt;data
)paren
op_plus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
multiline_comment|/* Add more stuff to the end of skb-&gt;len */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_OOB
)paren
)paren
(brace
id|copy
op_assign
id|min
c_func
(paren
id|sk-&gt;mss
op_minus
(paren
id|skb-&gt;len
op_minus
id|hdrlen
)paren
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* FIXME: this is really a bug. */
r_if
c_cond
(paren
id|copy
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TCP: **bug**: &bslash;&quot;copy&bslash;&quot; &lt;= 0!!&bslash;n&quot;
)paren
suffix:semicolon
id|copy
op_assign
l_int|0
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
id|skb-&gt;data
op_plus
id|skb-&gt;len
comma
id|from
comma
id|copy
)paren
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|copy
suffix:semicolon
id|from
op_add_assign
id|copy
suffix:semicolon
id|copied
op_add_assign
id|copy
suffix:semicolon
id|len
op_sub_assign
id|copy
suffix:semicolon
id|sk-&gt;write_seq
op_add_assign
id|copy
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|skb-&gt;len
op_minus
id|hdrlen
)paren
op_ge
id|sk-&gt;mss
op_logical_or
(paren
id|flags
op_amp
id|MSG_OOB
)paren
op_logical_or
op_logical_neg
id|sk-&gt;packets_out
)paren
id|tcp_send_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_else
id|tcp_enqueue_partial
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We also need to worry about the window.&n; &t; * If window &lt; 1/2 the maximum window we&squot;ve seen from this&n; &t; *   host, don&squot;t use it.  This is sender side&n; &t; *   silly window prevention, as specified in RFC1122.&n; &t; *   (Note that this is diffferent than earlier versions of&n; &t; *   SWS prevention, e.g. RFC813.).  What we actually do is &n;&t; *   use the whole MSS.  Since the results in the right&n;&t; *   edge of the packet being outside the window, it will&n;&t; *   be queued for later rather than sent.&n;&t; */
id|copy
op_assign
id|sk-&gt;window_seq
op_minus
id|sk-&gt;write_seq
suffix:semicolon
r_if
c_cond
(paren
id|copy
op_le
l_int|0
op_logical_or
id|copy
template_param
id|sk-&gt;mss
)paren
id|copy
op_assign
id|sk-&gt;mss
suffix:semicolon
r_if
c_cond
(paren
id|copy
OG
id|len
)paren
id|copy
op_assign
id|len
suffix:semicolon
multiline_comment|/* We should really check the window here also. */
id|send_tmp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|copy
OL
id|sk-&gt;mss
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|MSG_OOB
)paren
)paren
(brace
multiline_comment|/* We will release the socket incase we sleep here. */
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* NB: following must be mtu, because mss can be increased.&n;&t;   * mss is always &lt;= mtu */
id|skb
op_assign
id|prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|sk-&gt;mtu
op_plus
l_int|128
op_plus
id|prot-&gt;max_header
comma
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|send_tmp
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We will release the socket incase we sleep here. */
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|skb
op_assign
id|prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|copy
op_plus
id|prot-&gt;max_header
comma
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If we didn&squot;t get any memory, we need to sleep. */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|nonblock
multiline_comment|/* || copied */
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_write: return 4&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* FIXME: here is another race condition. */
id|tmp
op_assign
id|sk-&gt;wmem_alloc
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Again we will try to avoid it. */
r_if
c_cond
(paren
id|tmp
op_le
id|sk-&gt;wmem_alloc
op_logical_and
(paren
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_CLOSE_WAIT
)paren
op_logical_and
id|sk-&gt;err
op_eq
l_int|0
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_write: return 5&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|skb-&gt;len
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|0
suffix:semicolon
id|buff
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: we need to optimize this.&n;&t; * Perhaps some hints here would be good.&n;&t; */
id|tmp
op_assign
id|prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|skb
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|skb-&gt;mem_len
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|skb-&gt;mem_addr
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_write: return 6&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
id|skb-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|buff
op_add_assign
id|tmp
suffix:semicolon
id|skb-&gt;h.th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|buff
suffix:semicolon
id|tmp
op_assign
id|tcp_build_header
c_func
(paren
(paren
r_struct
id|tcphdr
op_star
)paren
id|buff
comma
id|sk
comma
id|len
op_minus
id|copy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|skb-&gt;mem_addr
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_write: return 7&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_return
id|copied
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_OOB
)paren
(brace
(paren
(paren
r_struct
id|tcphdr
op_star
)paren
id|buff
)paren
op_member_access_from_pointer
id|urg
op_assign
l_int|1
suffix:semicolon
(paren
(paren
r_struct
id|tcphdr
op_star
)paren
id|buff
)paren
op_member_access_from_pointer
id|urg_ptr
op_assign
id|ntohs
c_func
(paren
id|copy
)paren
suffix:semicolon
)brace
id|skb-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
id|buff
op_plus
id|tmp
comma
id|from
comma
id|copy
)paren
suffix:semicolon
id|from
op_add_assign
id|copy
suffix:semicolon
id|copied
op_add_assign
id|copy
suffix:semicolon
id|len
op_sub_assign
id|copy
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|copy
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;write_seq
op_add_assign
id|copy
suffix:semicolon
r_if
c_cond
(paren
id|send_tmp
op_ne
l_int|NULL
op_logical_and
id|sk-&gt;packets_out
)paren
(brace
id|tcp_enqueue_partial
c_func
(paren
id|send_tmp
comma
id|sk
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|tcp_send_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
)brace
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; *&t;Nagles rule. Turn Nagle off with TCP_NODELAY for highly&n; *&t;interactive fast network servers. It&squot;s meant to be on and&n; *&t;it really improves the throughput though not the echo time&n; *&t;on my slow slip link - Alan&n; */
multiline_comment|/* Avoid possible race on send_tmp - c/o Johannes Stille */
r_if
c_cond
(paren
id|sk-&gt;partial
op_logical_and
(paren
(paren
op_logical_neg
id|sk-&gt;packets_out
)paren
multiline_comment|/* If not nagling we can send on the before case too.. */
op_logical_or
(paren
id|sk-&gt;nonagle
op_logical_and
id|before
c_func
(paren
id|sk-&gt;write_seq
comma
id|sk-&gt;window_seq
)paren
)paren
)paren
)paren
(brace
id|tcp_send_partial
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* -- */
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_write: return 8&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|copied
suffix:semicolon
)brace
r_static
r_int
DECL|function|tcp_sendto
id|tcp_sendto
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|from
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
comma
r_struct
id|sockaddr_in
op_star
id|addr
comma
r_int
id|addr_len
)paren
(brace
r_struct
id|sockaddr_in
id|sin
suffix:semicolon
r_if
c_cond
(paren
id|addr_len
OL
r_sizeof
(paren
id|sin
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|sin
comma
id|addr
comma
r_sizeof
(paren
id|sin
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sin.sin_family
op_logical_and
id|sin.sin_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sin.sin_port
op_ne
id|sk-&gt;dummy_th.dest
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sin.sin_addr.s_addr
op_ne
id|sk-&gt;daddr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|tcp_write
c_func
(paren
id|sk
comma
id|from
comma
id|len
comma
id|nonblock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|tcp_read_wakeup
id|tcp_read_wakeup
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|tmp
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;in tcp read wakeup&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;ack_backlog
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;   * FIXME: we need to put code here to prevent this routine from&n;   * being called.  Being called once in a while is ok, so only check&n;   * if this is the second time in a row.&n;   */
multiline_comment|/*&n;   * We need to grab some memory, and put together an ack,&n;   * and then put it into the queue to be sent.&n;   */
id|buff
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|MAX_ACK_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Try again real soon. */
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
l_int|10
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buff-&gt;len
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
multiline_comment|/* Put in the IP header and routing stuff. */
id|tmp
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|MAX_ACK_SIZE
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|buff-&gt;mem_addr
comma
id|buff-&gt;mem_len
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buff-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
(paren
id|buff-&gt;data
op_plus
id|tmp
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
(paren
r_void
op_star
)paren
op_amp
id|sk-&gt;dummy_th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
id|t1-&gt;seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;sent_seq
)paren
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;res1
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;res2
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;syn
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;bytes_rcv
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;window
op_assign
id|tcp_select_window
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*sk-&gt;prot-&gt;rspace(sk);*/
id|t1-&gt;window
op_assign
id|ntohs
c_func
(paren
id|sk-&gt;window
)paren
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|ntohl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|1
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * FIXME:&n; * This routine frees used buffers.&n; * It should consider sending an ACK to let the&n; * other end know we now have a bigger window.&n; */
r_static
r_void
DECL|function|cleanup_rbuf
id|cleanup_rbuf
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|left
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cleaning rbuf for sk=%p&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|left
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;   * We have to loop through all the buffer headers,&n;   * and try to free up all the space we can.&n;   */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;used
)paren
r_break
suffix:semicolon
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;   * FIXME:&n;   * At this point we should send an ack if the difference&n;   * in the window, and the amount of space is bigger than&n;   * TCP_WINDOW_DIFF.&n;   */
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;sk-&gt;window left = %d, sk-&gt;prot-&gt;rspace(sk)=%d&bslash;n&quot;
comma
id|sk-&gt;window
op_minus
id|sk-&gt;bytes_rcv
comma
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sk-&gt;rspace = %lu, was %d&bslash;n&quot;
comma
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
comma
id|left
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
op_ne
id|left
)paren
(brace
multiline_comment|/*&n;&t; * This area has caused the most trouble.  The current strategy&n;&t; * is to simply do nothing if the other end has room to send at&n;&t; * least 3 full packets, because the ack from those will auto-&n;&t; * matically update the window.  If the other end doesn&squot;t think&n;&t; * we have much space left, but we have room for atleast 1 more&n;&t; * complete packet than it thinks we do, we will send an ack&n;&t; * immediatedly.  Otherwise we will wait up to .5 seconds in case&n;&t; * the user reads some more.&n;&t; */
id|sk-&gt;ack_backlog
op_increment
suffix:semicolon
multiline_comment|/*&n; * It&squot;s unclear whether to use sk-&gt;mtu or sk-&gt;mss here.  They differ only&n; * if the other end is offering a window smaller than the agreed on MSS&n; * (called sk-&gt;mtu here).  In theory there&squot;s no connection between send&n; * and receive, and so no reason to think that they&squot;re going to send&n; * small packets.  For the moment I&squot;m using the hack of reducing the mss&n; * only on the send side, so I&squot;m putting mtu here.&n; */
r_if
c_cond
(paren
(paren
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
OG
(paren
id|sk-&gt;window
op_minus
id|sk-&gt;bytes_rcv
op_plus
id|sk-&gt;mtu
)paren
)paren
)paren
(brace
multiline_comment|/* Send an ack right now. */
id|tcp_read_wakeup
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Force it to send an ack soon. */
r_int
id|was_active
op_assign
id|del_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|was_active
op_logical_or
id|TCP_ACK_TIME
OL
id|sk-&gt;timer.expires
)paren
(brace
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|TCP_ACK_TIME
)paren
suffix:semicolon
)brace
r_else
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Handle reading urgent data. */
r_static
r_int
DECL|function|tcp_read_urg
id|tcp_read_urg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|nonblock
comma
r_int
r_char
op_star
id|to
comma
r_int
id|len
comma
r_int
id|flags
)paren
(brace
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;urginline
op_logical_or
op_logical_neg
id|sk-&gt;urg_data
op_logical_or
id|sk-&gt;urg_data
op_eq
id|URG_READ
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;urg_data
op_amp
id|URG_VALID
)paren
(brace
r_char
id|c
op_assign
id|sk-&gt;urg_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
)paren
id|sk-&gt;urg_data
op_assign
id|URG_READ
suffix:semicolon
id|put_fs_byte
c_func
(paren
id|c
comma
id|to
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;err
)paren
(brace
r_int
id|tmp
op_assign
op_minus
id|sk-&gt;err
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
op_logical_or
id|sk-&gt;done
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;done
)paren
(brace
id|sk-&gt;done
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENOTCONN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
(brace
id|sk-&gt;done
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nonblock
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sk-&gt;urg_data
op_amp
id|URG_NOTYET
)paren
op_logical_and
id|sk-&gt;err
op_eq
l_int|0
op_logical_and
op_logical_neg
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This routine copies from a sock struct into the user buffer. */
DECL|function|tcp_read
r_static
r_int
id|tcp_read
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|to
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
)paren
(brace
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|peek_seq
suffix:semicolon
r_int
r_int
op_star
id|seq
suffix:semicolon
r_int
r_int
id|used
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|to
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* This error should be checked. */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
multiline_comment|/* Urgent data needs to be handled specially. */
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_OOB
)paren
r_return
id|tcp_read_urg
c_func
(paren
id|sk
comma
id|nonblock
comma
id|to
comma
id|len
comma
id|flags
)paren
suffix:semicolon
id|peek_seq
op_assign
id|sk-&gt;copied_seq
suffix:semicolon
id|seq
op_assign
op_amp
id|sk-&gt;copied_seq
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
id|seq
op_assign
op_amp
id|peek_seq
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
multiline_comment|/*&n;&t;&t; * are we at urgent data? Stop if we have read anything.&n;&t;&t; */
r_if
c_cond
(paren
id|copied
op_logical_and
id|sk-&gt;urg_data
op_logical_and
id|sk-&gt;urg_seq
op_eq
l_int|1
op_plus
op_star
id|seq
)paren
r_break
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|before
c_func
(paren
l_int|1
op_plus
op_star
id|seq
comma
id|skb-&gt;h.th-&gt;seq
)paren
)paren
r_break
suffix:semicolon
id|offset
op_assign
l_int|1
op_plus
op_star
id|seq
op_minus
id|skb-&gt;h.th-&gt;seq
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;syn
)paren
id|offset
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
id|skb-&gt;len
)paren
r_goto
id|found_ok_skb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
)paren
id|skb-&gt;used
op_assign
l_int|1
suffix:semicolon
id|skb
op_assign
id|skb-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|skb
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;err
)paren
(brace
id|copied
op_assign
op_minus
id|sk-&gt;err
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;done
)paren
(brace
id|sk-&gt;done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|copied
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
(brace
id|sk-&gt;done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nonblock
)paren
(brace
id|copied
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cleanup_rbuf
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|copied
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_continue
suffix:semicolon
id|found_ok_skb
suffix:colon
multiline_comment|/* Ok so how much can we use ? */
id|used
op_assign
id|skb-&gt;len
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|used
)paren
id|used
op_assign
id|len
suffix:semicolon
multiline_comment|/* do we have urgent data here? */
r_if
c_cond
(paren
id|sk-&gt;urg_data
)paren
(brace
r_int
r_int
id|urg_offset
op_assign
id|sk-&gt;urg_seq
op_minus
(paren
l_int|1
op_plus
op_star
id|seq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urg_offset
OL
id|used
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|urg_offset
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;urginline
)paren
(brace
op_increment
op_star
id|seq
suffix:semicolon
id|offset
op_increment
suffix:semicolon
id|used
op_decrement
suffix:semicolon
)brace
)brace
r_else
id|used
op_assign
id|urg_offset
suffix:semicolon
)brace
)brace
multiline_comment|/* Copy it */
id|memcpy_tofs
c_func
(paren
id|to
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|skb-&gt;h.th
)paren
op_plus
id|skb-&gt;h.th-&gt;doff
op_star
l_int|4
op_plus
id|offset
comma
id|used
)paren
suffix:semicolon
id|copied
op_add_assign
id|used
suffix:semicolon
id|len
op_sub_assign
id|used
suffix:semicolon
id|to
op_add_assign
id|used
suffix:semicolon
op_star
id|seq
op_add_assign
id|used
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|sk-&gt;copied_seq
op_plus
l_int|1
comma
id|sk-&gt;urg_seq
)paren
)paren
id|sk-&gt;urg_data
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MSG_PEEK
)paren
op_logical_and
(paren
id|used
op_plus
id|offset
op_ge
id|skb-&gt;len
)paren
)paren
id|skb-&gt;used
op_assign
l_int|1
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
id|sk-&gt;sleep
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
multiline_comment|/* Clean up data we have read: This will do ACK frames */
id|cleanup_rbuf
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_read: returning %d&bslash;n&quot;
comma
id|copied
)paren
)paren
suffix:semicolon
r_return
id|copied
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a FIN without closing the connection.&n; * Not called at interrupt time.&n; */
r_void
DECL|function|tcp_shutdown
id|tcp_shutdown
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
comma
op_star
id|th
suffix:semicolon
r_struct
id|proto
op_star
id|prot
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;   * We need to grab some memory, and put together a FIN,&n;   * and then put it into the queue to be sent.&n;   * FIXME:&n;   *&t;Tim MacKenzie(tym@dibbler.cs.monash.edu.au) 4 Dec &squot;92.&n;   *&t;Most of this is guesswork, so maybe it will work...&n;   */
multiline_comment|/* If we&squot;ve already sent a FIN, return. */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT1
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT2
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|how
op_amp
id|SEND_SHUTDOWN
)paren
)paren
r_return
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Clear out any half completed packets. */
r_if
c_cond
(paren
id|sk-&gt;partial
)paren
id|tcp_send_partial
c_func
(paren
id|sk
)paren
suffix:semicolon
id|prot
op_assign
(paren
r_struct
id|proto
op_star
)paren
id|sk-&gt;prot
suffix:semicolon
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
op_amp
id|sk-&gt;dummy_th
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* incase the malloc sleeps. */
id|buff
op_assign
id|prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|MAX_RESET_SIZE
comma
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_shutdown_send buff = %X&bslash;n&quot;
comma
id|buff
)paren
)paren
suffix:semicolon
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|buff-&gt;len
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|buff-&gt;data
suffix:semicolon
multiline_comment|/* Put in the IP header and routing stuff. */
id|tmp
op_assign
id|prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
multiline_comment|/* Finish anyway, treat this as a send that got lost. */
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|buff-&gt;mem_addr
comma
id|buff-&gt;mem_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
)paren
(brace
id|sk-&gt;state
op_assign
id|TCP_FIN_WAIT1
suffix:semicolon
)brace
r_else
id|sk-&gt;state
op_assign
id|TCP_FIN_WAIT2
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;Unable to build header for fin.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|t1
op_plus
id|tmp
)paren
suffix:semicolon
id|buff-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|buff-&gt;dev
op_assign
id|dev
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
id|th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
id|t1-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|sk-&gt;write_seq
)paren
suffix:semicolon
id|sk-&gt;write_seq
op_increment
suffix:semicolon
id|buff-&gt;h.seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|ntohl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|t1-&gt;window
op_assign
id|ntohs
c_func
(paren
id|sk-&gt;window
op_assign
id|tcp_select_window
c_func
(paren
id|sk
)paren
multiline_comment|/*sk-&gt;prot-&gt;rspace(sk)*/
)paren
suffix:semicolon
id|t1-&gt;fin
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n;   * Can&squot;t just queue this up.&n;   * It should go at the end of the write queue.&n;   */
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_ne
l_int|NULL
)paren
(brace
id|buff-&gt;free
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buff-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tcp_shutdown: next != NULL&bslash;n&quot;
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|buff
)paren
suffix:semicolon
)brace
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|buff
)paren
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;sent_seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
)paren
id|sk-&gt;state
op_assign
id|TCP_FIN_WAIT1
suffix:semicolon
r_else
id|sk-&gt;state
op_assign
id|TCP_FIN_WAIT2
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|tcp_recvfrom
id|tcp_recvfrom
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_char
op_star
id|to
comma
r_int
id|to_len
comma
r_int
id|nonblock
comma
r_int
id|flags
comma
r_struct
id|sockaddr_in
op_star
id|addr
comma
r_int
op_star
id|addr_len
)paren
(brace
r_struct
id|sockaddr_in
id|sin
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* Have to check these first unlike the old code. If &n;     we check them after we lose data on an error&n;     which is wrong */
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|addr_len
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|len
op_assign
id|get_fs_long
c_func
(paren
id|addr_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
r_sizeof
(paren
id|sin
)paren
)paren
(brace
id|len
op_assign
r_sizeof
(paren
id|sin
)paren
suffix:semicolon
)brace
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|addr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|result
op_assign
id|tcp_read
c_func
(paren
id|sk
comma
id|to
comma
id|to_len
comma
id|nonblock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
id|sin.sin_family
op_assign
id|AF_INET
suffix:semicolon
id|sin.sin_port
op_assign
id|sk-&gt;dummy_th.dest
suffix:semicolon
id|sin.sin_addr.s_addr
op_assign
id|sk-&gt;daddr
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|addr
comma
op_amp
id|sin
comma
id|len
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|len
comma
id|addr_len
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* This routine will send an RST to the other tcp. */
r_static
r_void
DECL|function|tcp_reset
id|tcp_reset
c_func
(paren
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_struct
id|proto
op_star
id|prot
comma
r_struct
id|options
op_star
id|opt
comma
r_struct
id|device
op_star
id|dev
comma
r_int
id|tos
comma
r_int
id|ttl
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_struct
id|device
op_star
id|ndev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;   * We need to grab some memory, and put together an RST,&n;   * and then put it into the queue to be sent.&n;   */
id|buff
op_assign
id|prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
l_int|NULL
comma
id|MAX_RESET_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_reset buff = %X&bslash;n&quot;
comma
id|buff
)paren
)paren
suffix:semicolon
id|buff-&gt;len
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
suffix:semicolon
id|buff-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|buff-&gt;dev
op_assign
id|dev
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|buff-&gt;data
suffix:semicolon
multiline_comment|/* Put in the IP header and routing stuff. */
id|tmp
op_assign
id|prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|saddr
comma
id|daddr
comma
op_amp
id|ndev
comma
id|IPPROTO_TCP
comma
id|opt
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
comma
id|tos
comma
id|ttl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|prot
op_member_access_from_pointer
id|wfree
c_func
(paren
l_int|NULL
comma
id|buff-&gt;mem_addr
comma
id|buff-&gt;mem_len
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|t1
op_plus
id|tmp
)paren
suffix:semicolon
id|buff-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
id|th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
multiline_comment|/* Swap the send and the receive. */
id|t1-&gt;dest
op_assign
id|th-&gt;source
suffix:semicolon
id|t1-&gt;source
op_assign
id|th-&gt;dest
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;window
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
id|t1-&gt;ack
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;seq
op_assign
id|th-&gt;ack_seq
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;syn
)paren
(brace
id|t1-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|th-&gt;seq
)paren
suffix:semicolon
)brace
r_else
id|t1-&gt;ack_seq
op_assign
id|htonl
c_func
(paren
id|th-&gt;seq
op_plus
l_int|1
)paren
suffix:semicolon
id|t1-&gt;seq
op_assign
l_int|0
suffix:semicolon
)brace
id|t1-&gt;syn
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;fin
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|saddr
comma
id|daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
l_int|NULL
)paren
suffix:semicolon
id|prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
l_int|NULL
comma
id|dev
comma
id|buff
comma
l_int|1
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Look for tcp options. Parses everything but only knows about MSS.&n; *      This routine is always called with the packet containing the SYN.&n; *      However it may also be called with the ack to the SYN.  So you&n; *      can&squot;t assume this is always the SYN.  It&squot;s always called after&n; *      we have set up sk-&gt;mtu to our own MTU.&n; */
r_static
r_void
DECL|function|tcp_options
id|tcp_options
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|length
op_assign
(paren
id|th-&gt;doff
op_star
l_int|4
)paren
op_minus
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
r_int
id|mss_seen
op_assign
l_int|0
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|th
op_plus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|length
OG
l_int|0
)paren
(brace
r_int
id|opcode
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_int
id|opsize
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|TCPOPT_EOL
suffix:colon
r_return
suffix:semicolon
r_case
id|TCPOPT_NOP
suffix:colon
id|length
op_sub_assign
l_int|2
suffix:semicolon
r_continue
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|opsize
op_le
l_int|2
)paren
(brace
multiline_comment|/* Avoid silly options looping forever */
r_return
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|TCPOPT_MSS
suffix:colon
r_if
c_cond
(paren
id|opsize
op_eq
l_int|4
op_logical_and
id|th-&gt;syn
)paren
(brace
id|sk-&gt;mtu
op_assign
id|min
c_func
(paren
id|sk-&gt;mtu
comma
id|ntohs
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|ptr
)paren
)paren
suffix:semicolon
id|mss_seen
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* Add other options here as people feel the urge to implement stuff like large windows */
)brace
id|ptr
op_add_assign
id|opsize
op_minus
l_int|2
suffix:semicolon
id|length
op_sub_assign
id|opsize
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|th-&gt;syn
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mss_seen
)paren
id|sk-&gt;mtu
op_assign
id|min
c_func
(paren
id|sk-&gt;mtu
comma
l_int|536
)paren
suffix:semicolon
multiline_comment|/* default MSS if none sent */
)brace
id|sk-&gt;mss
op_assign
id|min
c_func
(paren
id|sk-&gt;max_window
comma
id|sk-&gt;mtu
)paren
suffix:semicolon
)brace
DECL|function|default_mask
r_static
r_inline
r_int
r_int
id|default_mask
c_func
(paren
r_int
r_int
id|dst
)paren
(brace
id|dst
op_assign
id|ntohl
c_func
(paren
id|dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSA
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSA_NET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSB
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSB_NET
)paren
suffix:semicolon
r_return
id|htonl
c_func
(paren
id|IN_CLASSC_NET
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine handles a connection request.&n; * It should make sure we haven&squot;t already responded.&n; * Because of the way BSD works, we have to send a syn/ack now.&n; * This also means it will be harder to close a socket which is&n; * listening.&n; */
r_static
r_void
DECL|function|tcp_conn_request
id|tcp_conn_request
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|saddr
comma
r_struct
id|options
op_star
id|opt
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_struct
id|sock
op_star
id|newsk
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|device
op_star
id|ndev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_conn_request(sk = %X, skb = %X, daddr = %X, sadd4= %X, &bslash;n&quot;
l_string|&quot;                  opt = %X, dev = %X)&bslash;n&quot;
comma
id|sk
comma
id|skb
comma
id|daddr
comma
id|saddr
comma
id|opt
comma
id|dev
)paren
)paren
suffix:semicolon
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
multiline_comment|/* If the socket is dead, don&squot;t accept the connection. */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_conn_request on dead socket&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|tcp_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;   * Make sure we can accept more.  This will prevent a&n;   * flurry of syns from eating up all our memory.&n;   */
r_if
c_cond
(paren
id|sk-&gt;ack_backlog
op_ge
id|sk-&gt;max_ack_backlog
)paren
(brace
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;   * We need to build a new sock struct.&n;   * It is sort of bad to have a socket without an inode attached&n;   * to it, but the wake_up&squot;s will just wake up the listening socket,&n;   * and if the listening socket is destroyed before this is taken&n;   * off of the queue, this will take care of it.&n;   */
id|newsk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sock
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newsk
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* just ignore the syn.  It will get retransmitted. */
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;newsk = %X&bslash;n&quot;
comma
id|newsk
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|newsk
comma
id|sk
comma
r_sizeof
(paren
op_star
id|newsk
)paren
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|newsk-&gt;write_queue
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|newsk-&gt;receive_queue
)paren
suffix:semicolon
id|newsk-&gt;send_head
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;send_tail
op_assign
l_int|NULL
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|newsk-&gt;back_log
)paren
suffix:semicolon
id|newsk-&gt;rtt
op_assign
id|TCP_CONNECT_TIME
op_lshift
l_int|3
suffix:semicolon
id|newsk-&gt;rto
op_assign
id|TCP_CONNECT_TIME
suffix:semicolon
id|newsk-&gt;mdev
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;max_window
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;cong_window
op_assign
l_int|1
suffix:semicolon
id|newsk-&gt;cong_count
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;ssthresh
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;backoff
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;blog
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;intr
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;proc
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;done
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;partial
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;pair
op_assign
l_int|NULL
suffix:semicolon
id|newsk-&gt;wmem_alloc
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;rmem_alloc
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;max_unacked
op_assign
id|MAX_WINDOW
op_minus
id|TCP_WINDOW_DIFF
suffix:semicolon
id|newsk-&gt;err
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;shutdown
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;acked_seq
op_assign
id|skb-&gt;h.th-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|newsk-&gt;fin_seq
op_assign
id|skb-&gt;h.th-&gt;seq
suffix:semicolon
id|newsk-&gt;copied_seq
op_assign
id|skb-&gt;h.th-&gt;seq
suffix:semicolon
id|newsk-&gt;state
op_assign
id|TCP_SYN_RECV
suffix:semicolon
id|newsk-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;write_seq
op_assign
id|jiffies
op_star
id|SEQ_TICK
op_minus
id|seq_offset
suffix:semicolon
id|newsk-&gt;window_seq
op_assign
id|newsk-&gt;write_seq
suffix:semicolon
id|newsk-&gt;rcv_ack_seq
op_assign
id|newsk-&gt;write_seq
suffix:semicolon
id|newsk-&gt;urg_data
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;destroy
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|newsk
suffix:semicolon
id|newsk-&gt;timer.function
op_assign
op_amp
id|net_timer
suffix:semicolon
id|newsk-&gt;dummy_th.source
op_assign
id|skb-&gt;h.th-&gt;dest
suffix:semicolon
id|newsk-&gt;dummy_th.dest
op_assign
id|skb-&gt;h.th-&gt;source
suffix:semicolon
multiline_comment|/* Swap these two, they are from our point of view. */
id|newsk-&gt;daddr
op_assign
id|saddr
suffix:semicolon
id|newsk-&gt;saddr
op_assign
id|daddr
suffix:semicolon
id|put_sock
c_func
(paren
id|newsk-&gt;num
comma
id|newsk
)paren
suffix:semicolon
id|newsk-&gt;dummy_th.res1
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.doff
op_assign
l_int|6
suffix:semicolon
id|newsk-&gt;dummy_th.fin
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.syn
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.rst
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.psh
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.ack
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.urg
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;dummy_th.res2
op_assign
l_int|0
suffix:semicolon
id|newsk-&gt;acked_seq
op_assign
id|skb-&gt;h.th-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|newsk-&gt;copied_seq
op_assign
id|skb-&gt;h.th-&gt;seq
suffix:semicolon
multiline_comment|/* Grab the ttl and tos values and use them */
id|newsk-&gt;ip_ttl
op_assign
id|sk-&gt;ip_ttl
suffix:semicolon
id|newsk-&gt;ip_tos
op_assign
id|skb-&gt;ip_hdr-&gt;tos
suffix:semicolon
multiline_comment|/* use 512 or whatever user asked for */
multiline_comment|/* note use of sk-&gt;user_mss, since user has no direct access to newsk */
r_if
c_cond
(paren
id|sk-&gt;user_mss
)paren
id|newsk-&gt;mtu
op_assign
id|sk-&gt;user_mss
suffix:semicolon
r_else
(brace
macro_line|#ifdef SUBNETSARELOCAL
r_if
c_cond
(paren
(paren
id|saddr
op_xor
id|daddr
)paren
op_amp
id|default_mask
c_func
(paren
id|saddr
)paren
)paren
macro_line|#else
r_if
c_cond
(paren
(paren
id|saddr
op_xor
id|daddr
)paren
op_amp
id|dev-&gt;pa_mask
)paren
macro_line|#endif
id|newsk-&gt;mtu
op_assign
l_int|576
op_minus
id|HEADER_SIZE
suffix:semicolon
r_else
id|newsk-&gt;mtu
op_assign
id|MAX_WINDOW
suffix:semicolon
)brace
multiline_comment|/* but not bigger than device MTU */
id|newsk-&gt;mtu
op_assign
id|min
c_func
(paren
id|newsk-&gt;mtu
comma
id|dev-&gt;mtu
op_minus
id|HEADER_SIZE
)paren
suffix:semicolon
multiline_comment|/* this will min with what arrived in the packet */
id|tcp_options
c_func
(paren
id|newsk
comma
id|skb-&gt;h.th
)paren
suffix:semicolon
id|buff
op_assign
id|newsk-&gt;prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|newsk
comma
id|MAX_SYN_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|newsk-&gt;dead
op_assign
l_int|1
suffix:semicolon
id|release_sock
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buff-&gt;len
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
l_int|4
suffix:semicolon
id|buff-&gt;sk
op_assign
id|newsk
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|buff-&gt;data
suffix:semicolon
multiline_comment|/* Put in the IP header and routing stuff. */
id|tmp
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|newsk-&gt;saddr
comma
id|newsk-&gt;daddr
comma
op_amp
id|ndev
comma
id|IPPROTO_TCP
comma
l_int|NULL
comma
id|MAX_SYN_SIZE
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
multiline_comment|/* Something went wrong. */
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sk-&gt;err
op_assign
id|tmp
suffix:semicolon
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|kfree_skb
c_func
(paren
id|buff
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|newsk-&gt;dead
op_assign
l_int|1
suffix:semicolon
id|release_sock
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buff-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|t1
op_plus
id|tmp
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
id|skb-&gt;h.th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
id|buff-&gt;h.seq
op_assign
id|newsk-&gt;write_seq
suffix:semicolon
multiline_comment|/* Swap the send and the receive. */
id|t1-&gt;dest
op_assign
id|skb-&gt;h.th-&gt;source
suffix:semicolon
id|t1-&gt;source
op_assign
id|newsk-&gt;dummy_th.source
suffix:semicolon
id|t1-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|newsk-&gt;write_seq
op_increment
)paren
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|newsk-&gt;window
op_assign
id|tcp_select_window
c_func
(paren
id|newsk
)paren
suffix:semicolon
multiline_comment|/*newsk-&gt;prot-&gt;rspace(newsk);*/
id|newsk-&gt;sent_seq
op_assign
id|newsk-&gt;write_seq
suffix:semicolon
id|t1-&gt;window
op_assign
id|ntohs
c_func
(paren
id|newsk-&gt;window
)paren
suffix:semicolon
id|t1-&gt;res1
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;res2
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;syn
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|ntohl
c_func
(paren
id|skb-&gt;h.th-&gt;seq
op_plus
l_int|1
)paren
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
op_plus
l_int|1
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|t1
op_plus
l_int|1
)paren
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
l_int|2
suffix:semicolon
id|ptr
(braket
l_int|1
)braket
op_assign
l_int|4
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
(paren
(paren
id|newsk-&gt;mtu
)paren
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|ptr
(braket
l_int|3
)braket
op_assign
(paren
id|newsk-&gt;mtu
)paren
op_amp
l_int|0xff
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|daddr
comma
id|saddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
op_plus
l_int|4
comma
id|newsk
)paren
suffix:semicolon
id|newsk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|newsk
comma
id|dev
comma
id|buff
comma
l_int|0
)paren
suffix:semicolon
id|reset_timer
c_func
(paren
id|newsk
comma
id|TIME_WRITE
multiline_comment|/* -1 ? FIXME ??? */
comma
id|TCP_CONNECT_TIME
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
id|newsk
suffix:semicolon
multiline_comment|/* Charge the sock_buff to newsk. */
id|sk-&gt;rmem_alloc
op_sub_assign
id|skb-&gt;mem_len
suffix:semicolon
id|newsk-&gt;rmem_alloc
op_add_assign
id|skb-&gt;mem_len
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
id|sk-&gt;ack_backlog
op_increment
suffix:semicolon
id|release_sock
c_func
(paren
id|newsk
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
)brace
r_static
r_void
DECL|function|tcp_close
id|tcp_close
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeout
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_int
id|need_reset
op_assign
l_int|0
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
comma
op_star
id|th
suffix:semicolon
r_struct
id|proto
op_star
id|prot
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tmp
suffix:semicolon
multiline_comment|/*&n;   * We need to grab some memory, and put together a FIN,&n;   * and then put it into the queue to be sent.&n;   */
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_close((struct sock *)%X, %d)&bslash;n&quot;
comma
id|sk
comma
id|timeout
)paren
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;keepopen
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* We need to flush the recv. buffs. */
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Clean rcv queue&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;len
OG
l_int|0
op_logical_and
id|after
c_func
(paren
id|skb-&gt;h.th-&gt;seq
op_plus
id|skb-&gt;len
op_plus
l_int|1
comma
id|sk-&gt;copied_seq
)paren
)paren
(brace
id|need_reset
op_assign
l_int|1
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cleaned.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Get rid off any half-completed packets. */
r_if
c_cond
(paren
id|sk-&gt;partial
)paren
(brace
id|tcp_send_partial
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_FIN_WAIT1
suffix:colon
r_case
id|TCP_FIN_WAIT2
suffix:colon
r_case
id|TCP_LAST_ACK
suffix:colon
multiline_comment|/* start a timer. */
multiline_comment|/* original code was 4 * sk-&gt;rtt.  In converting to the&n;&t;&t; * new rtt representation, we can&squot;t quite use that.&n;&t;&t; * it seems to make most sense to  use the backed off value&n;&t;&t; */
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
l_int|4
op_star
id|sk-&gt;rto
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
)paren
id|tcp_time_wait
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* break causes a double release - messy */
r_case
id|TCP_TIME_WAIT
suffix:colon
r_if
c_cond
(paren
id|timeout
)paren
(brace
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|TCP_LISTEN
suffix:colon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|TCP_CLOSE
suffix:colon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|TCP_CLOSE_WAIT
suffix:colon
r_case
id|TCP_ESTABLISHED
suffix:colon
r_case
id|TCP_SYN_SENT
suffix:colon
r_case
id|TCP_SYN_RECV
suffix:colon
id|prot
op_assign
(paren
r_struct
id|proto
op_star
)paren
id|sk-&gt;prot
suffix:semicolon
id|th
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
op_amp
id|sk-&gt;dummy_th
suffix:semicolon
id|buff
op_assign
id|prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|MAX_FIN_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* This will force it to try again later. */
multiline_comment|/* Or it would have if someone released the socket&n;&t;&t;&t;   first. Anyway it might work now */
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_CLOSE_WAIT
)paren
id|sk-&gt;state
op_assign
id|TCP_ESTABLISHED
suffix:semicolon
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
l_int|100
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|buff-&gt;len
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|buff-&gt;data
suffix:semicolon
multiline_comment|/* Put in the IP header and routing stuff. */
id|tmp
op_assign
id|prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|buff
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
)paren
(brace
id|sk-&gt;state
op_assign
id|TCP_FIN_WAIT1
suffix:semicolon
)brace
r_else
id|sk-&gt;state
op_assign
id|TCP_FIN_WAIT2
suffix:semicolon
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
l_int|4
op_star
id|sk-&gt;rto
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
)paren
(brace
id|tcp_time_wait
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;Unable to build header for fin.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|t1
op_plus
id|tmp
)paren
suffix:semicolon
id|buff-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|buff-&gt;dev
op_assign
id|dev
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
id|th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
id|t1-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|sk-&gt;write_seq
)paren
suffix:semicolon
id|sk-&gt;write_seq
op_increment
suffix:semicolon
id|buff-&gt;h.seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Ack everything immediately from now on. */
id|sk-&gt;delay_acks
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|ntohl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|t1-&gt;window
op_assign
id|ntohs
c_func
(paren
id|sk-&gt;window
op_assign
id|tcp_select_window
c_func
(paren
id|sk
)paren
multiline_comment|/*sk-&gt;prot-&gt;rspace(sk)*/
)paren
suffix:semicolon
id|t1-&gt;fin
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;rst
op_assign
id|need_reset
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|sk
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;sent_seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tcp_close: next != NULL&bslash;n&quot;
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|buff
)paren
suffix:semicolon
)brace
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|buff
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE_WAIT
)paren
(brace
id|sk-&gt;state
op_assign
id|TCP_FIN_WAIT2
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;state
op_assign
id|TCP_FIN_WAIT1
suffix:semicolon
)brace
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine takes stuff off of the write queue,&n; * and puts it in the xmit queue.&n; */
r_static
r_void
DECL|function|tcp_write_xmit
id|tcp_write_xmit
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_write_xmit(sk=%X)&bslash;n&quot;
comma
id|sk
)paren
)paren
suffix:semicolon
multiline_comment|/* The bytes will have to remain here. In time closedown will&n;     empty the write queue and all will be happy */
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
op_ne
l_int|NULL
op_logical_and
id|before
c_func
(paren
id|skb-&gt;h.seq
comma
id|sk-&gt;window_seq
op_plus
l_int|1
)paren
op_logical_and
(paren
id|sk-&gt;retransmits
op_eq
l_int|0
op_logical_or
id|sk-&gt;timeout
op_ne
id|TIME_WRITE
op_logical_or
id|before
c_func
(paren
id|skb-&gt;h.seq
comma
id|sk-&gt;rcv_ack_seq
op_plus
l_int|1
)paren
)paren
op_logical_and
id|sk-&gt;packets_out
OL
id|sk-&gt;cong_window
)paren
(brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;Sending a packet.&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* See if we really need to send the packet. */
r_if
c_cond
(paren
id|before
c_func
(paren
id|skb-&gt;h.seq
comma
id|sk-&gt;rcv_ack_seq
op_plus
l_int|1
)paren
)paren
(brace
id|sk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;sent_seq
op_assign
id|skb-&gt;h.seq
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|skb-&gt;dev
comma
id|skb
comma
id|skb-&gt;free
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * This routine sorts the send list, and resets the&n; * sk-&gt;send_head and sk-&gt;send_tail pointers.&n; */
r_void
DECL|function|sort_send
id|sort_send
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
comma
op_star
id|skb2
comma
op_star
id|skb3
suffix:semicolon
r_for
c_loop
(paren
id|skb
op_assign
id|sk-&gt;send_head
suffix:semicolon
id|skb
op_ne
l_int|NULL
suffix:semicolon
id|skb
op_assign
id|skb2
)paren
(brace
id|skb2
op_assign
id|skb-&gt;link3
suffix:semicolon
r_if
c_cond
(paren
id|list
op_eq
l_int|NULL
op_logical_or
id|before
(paren
id|skb2-&gt;h.seq
comma
id|list-&gt;h.seq
)paren
)paren
(brace
id|skb-&gt;link3
op_assign
id|list
suffix:semicolon
id|sk-&gt;send_tail
op_assign
id|skb
suffix:semicolon
id|list
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|skb3
op_assign
id|list
suffix:semicolon
suffix:semicolon
id|skb3
op_assign
id|skb3-&gt;link3
)paren
(brace
r_if
c_cond
(paren
id|skb3-&gt;link3
op_eq
l_int|NULL
op_logical_or
id|before
c_func
(paren
id|skb-&gt;h.seq
comma
id|skb3-&gt;link3-&gt;h.seq
)paren
)paren
(brace
id|skb-&gt;link3
op_assign
id|skb3-&gt;link3
suffix:semicolon
id|skb3-&gt;link3
op_assign
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;link3
op_eq
l_int|NULL
)paren
id|sk-&gt;send_tail
op_assign
id|skb
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
id|sk-&gt;send_head
op_assign
id|list
suffix:semicolon
)brace
multiline_comment|/* This routine deals with incoming acks, but not outgoing ones. */
r_static
r_int
DECL|function|tcp_ack
id|tcp_ack
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
r_int
id|saddr
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|ack
suffix:semicolon
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;   * 1 - there was data in packet as well as ack or new data is sent or &n;   *     in shutdown state&n;   * 2 - data from retransmit queue was acked and removed&n;   * 4 - window shrunk or data from retransmit queue was acked and removed&n;   */
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Dead, cant ack any more so why bother */
id|ack
op_assign
id|ntohl
c_func
(paren
id|th-&gt;ack_seq
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_ack ack=%d, window=%d, &quot;
l_string|&quot;sk-&gt;rcv_ack_seq=%d, sk-&gt;window_seq = %d&bslash;n&quot;
comma
id|ack
comma
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
comma
id|sk-&gt;rcv_ack_seq
comma
id|sk-&gt;window_seq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
OG
id|sk-&gt;max_window
)paren
(brace
id|sk-&gt;max_window
op_assign
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
suffix:semicolon
id|sk-&gt;mss
op_assign
id|min
c_func
(paren
id|sk-&gt;max_window
comma
id|sk-&gt;mtu
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;retransmits
op_logical_and
id|sk-&gt;timeout
op_eq
id|TIME_KEEPOPEN
)paren
id|sk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not quite clear why the +1 and -1 here, and why not +1 in next line */
r_if
c_cond
(paren
id|after
c_func
(paren
id|ack
comma
id|sk-&gt;sent_seq
op_plus
l_int|1
)paren
op_logical_or
id|before
c_func
(paren
id|ack
comma
id|sk-&gt;rcv_ack_seq
op_minus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|after
c_func
(paren
id|ack
comma
id|sk-&gt;sent_seq
)paren
op_logical_or
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_CLOSE_WAIT
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;keepopen
)paren
(brace
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_KEEPOPEN
comma
id|TCP_TIMEOUT_LEN
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
op_ne
id|th-&gt;doff
op_star
l_int|4
)paren
id|flag
op_or_assign
l_int|1
suffix:semicolon
multiline_comment|/* See if our window has been shrunk. */
r_if
c_cond
(paren
id|after
c_func
(paren
id|sk-&gt;window_seq
comma
id|ack
op_plus
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t; * We may need to move packets from the send queue&n;&t; * to the write queue, if the window has been shrunk on us.&n;&t; * The RFC says you are not allowed to shrink your window&n;&t; * like this, but if the other end does, you must be able&n;&t; * to deal with it.&n;&t; */
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_struct
id|sk_buff
op_star
id|wskb
op_assign
l_int|NULL
suffix:semicolon
id|skb2
op_assign
id|sk-&gt;send_head
suffix:semicolon
id|sk-&gt;send_head
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;send_tail
op_assign
l_int|NULL
suffix:semicolon
id|flag
op_or_assign
l_int|4
suffix:semicolon
id|sk-&gt;window_seq
op_assign
id|ack
op_plus
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|skb2
op_ne
l_int|NULL
)paren
(brace
id|skb
op_assign
id|skb2
suffix:semicolon
id|skb2
op_assign
id|skb-&gt;link3
suffix:semicolon
id|skb-&gt;link3
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|skb-&gt;h.seq
comma
id|sk-&gt;window_seq
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;packets_out
OG
l_int|0
)paren
id|sk-&gt;packets_out
op_decrement
suffix:semicolon
multiline_comment|/* We may need to remove this from the dev send list. */
r_if
c_cond
(paren
id|skb-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* Now add it to the write_queue. */
r_if
c_cond
(paren
id|wskb
op_eq
l_int|NULL
)paren
id|skb_queue_head
c_func
(paren
op_amp
id|sk-&gt;write_queue
comma
id|skb
)paren
suffix:semicolon
r_else
id|skb_append
c_func
(paren
id|wskb
comma
id|skb
)paren
suffix:semicolon
id|wskb
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk-&gt;send_head
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;send_head
op_assign
id|skb
suffix:semicolon
id|sk-&gt;send_tail
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;send_tail-&gt;link3
op_assign
id|skb
suffix:semicolon
id|sk-&gt;send_tail
op_assign
id|skb
suffix:semicolon
)brace
id|skb-&gt;link3
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;send_tail
op_eq
l_int|NULL
op_logical_or
id|sk-&gt;send_head
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;send_head
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;send_tail
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;packets_out
op_assign
l_int|0
suffix:semicolon
)brace
id|sk-&gt;window_seq
op_assign
id|ack
op_plus
id|ntohs
c_func
(paren
id|th-&gt;window
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t want too many packets out there. */
r_if
c_cond
(paren
id|sk-&gt;timeout
op_eq
id|TIME_WRITE
op_logical_and
id|sk-&gt;cong_window
OL
l_int|2048
op_logical_and
id|after
c_func
(paren
id|ack
comma
id|sk-&gt;rcv_ack_seq
)paren
)paren
(brace
multiline_comment|/* &n; * This is Jacobson&squot;s slow start and congestion avoidance. &n; * SIGCOMM &squot;88, p. 328.  Because we keep cong_window in integral&n; * mss&squot;s, we can&squot;t do cwnd += 1 / cwnd.  Instead, maintain a &n; * counter and increment it once every cwnd times.  It&squot;s possible&n; * that this should be done only if sk-&gt;retransmits == 0.  I&squot;m&n; * interpreting &quot;new data is acked&quot; as including data that has&n; * been retransmitted but is just now being acked.&n; */
r_if
c_cond
(paren
id|sk-&gt;cong_window
OL
id|sk-&gt;ssthresh
)paren
multiline_comment|/* in &quot;safe&quot; area, increase */
id|sk-&gt;cong_window
op_increment
suffix:semicolon
r_else
(brace
multiline_comment|/* in dangerous area, increase slowly.  In theory this is&n;&t;     sk-&gt;cong_window += 1 / sk-&gt;cong_window&n;&t;   */
r_if
c_cond
(paren
id|sk-&gt;cong_count
op_ge
id|sk-&gt;cong_window
)paren
(brace
id|sk-&gt;cong_window
op_increment
suffix:semicolon
id|sk-&gt;cong_count
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|sk-&gt;cong_count
op_increment
suffix:semicolon
)brace
)brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_ack: Updating rcv ack sequence.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sk-&gt;rcv_ack_seq
op_assign
id|ack
suffix:semicolon
multiline_comment|/*&n;   * if this ack opens up a zero window, clear backoff.  It was&n;   * being used to time the probes, and is probably far higher than&n;   * it needs to be for normal retransmission&n;   */
r_if
c_cond
(paren
id|sk-&gt;timeout
op_eq
id|TIME_PROBE0
)paren
(brace
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_ne
l_int|NULL
op_logical_and
multiline_comment|/* should always be non-null */
op_logical_neg
id|before
(paren
id|sk-&gt;window_seq
comma
id|sk-&gt;write_queue.next-&gt;h.seq
)paren
)paren
(brace
id|sk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;backoff
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* recompute rto from rtt.  this eliminates any backoff */
id|sk-&gt;rto
op_assign
(paren
(paren
id|sk-&gt;rtt
op_rshift
l_int|2
)paren
op_plus
id|sk-&gt;mdev
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rto
OG
l_int|120
op_star
id|HZ
)paren
id|sk-&gt;rto
op_assign
l_int|120
op_star
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rto
OL
l_int|1
op_star
id|HZ
)paren
id|sk-&gt;rto
op_assign
l_int|1
op_star
id|HZ
suffix:semicolon
)brace
)brace
multiline_comment|/* See if we can take anything off of the retransmit queue. */
r_while
c_loop
(paren
id|sk-&gt;send_head
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Check for a bug. */
r_if
c_cond
(paren
id|sk-&gt;send_head-&gt;link3
op_logical_and
id|after
c_func
(paren
id|sk-&gt;send_head-&gt;h.seq
comma
id|sk-&gt;send_head-&gt;link3-&gt;h.seq
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;INET: tcp.c: *** bug send_list out of order.&bslash;n&quot;
)paren
suffix:semicolon
id|sort_send
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|sk-&gt;send_head-&gt;h.seq
comma
id|ack
op_plus
l_int|1
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|oskb
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;retransmits
)paren
(brace
multiline_comment|/* we were retransmitting.  don&squot;t count this in RTT est */
id|flag
op_or_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t;&t;   * even though we&squot;ve gotten an ack, we&squot;re still&n;&t;&t;   * retransmitting as long as we&squot;re sending from&n;&t;&t;   * the retransmit queue.  Keeping retransmits non-zero&n;&t;&t;   * prevents us from getting new data interspersed with&n;&t;&t;   * retransmissions.&n;&t;&t;   */
r_if
c_cond
(paren
id|sk-&gt;send_head-&gt;link3
)paren
id|sk-&gt;retransmits
op_assign
l_int|1
suffix:semicolon
r_else
id|sk-&gt;retransmits
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Note that we only reset backoff and rto in the&n;&t;&t; * rtt recomputation code.  And that doesn&squot;t happen&n;&t;&t; * if there were retransmissions in effect.  So the&n;&t;&t; * first new packet after the retransmissions is&n;&t;&t; * sent with the backoff still in effect.  Not until&n;&t;&t; * we get an ack from a non-retransmitted packet do&n;&t;&t; * we reset the backoff and rto.  This allows us to deal&n;&t;&t; * with a situation where the network delay has increased&n;&t;&t; * suddenly.  I.e. Karn&squot;s algorithm. (SIGCOMM &squot;87, p5.)&n;&t;&t; */
multiline_comment|/* We have one less packet out there. */
r_if
c_cond
(paren
id|sk-&gt;packets_out
OG
l_int|0
)paren
id|sk-&gt;packets_out
op_decrement
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;skb=%X skb-&gt;h.seq = %d acked ack=%d&bslash;n&quot;
comma
id|sk-&gt;send_head
comma
id|sk-&gt;send_head-&gt;h.seq
comma
id|ack
)paren
)paren
suffix:semicolon
multiline_comment|/* Wake up the process, it can probably write more. */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
id|oskb
op_assign
id|sk-&gt;send_head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flag
op_amp
l_int|2
)paren
)paren
(brace
r_int
id|m
suffix:semicolon
multiline_comment|/* The following amusing code comes from Jacobson&squot;s&n;&t;&t;   * article in SIGCOMM &squot;88.  Note that rtt and mdev&n;&t;&t;   * are scaled versions of rtt and mean deviation.&n;&t;&t;   * This is designed to be as fast as possible &n;&t;&t;   * m stands for &quot;measurement&quot;.&n;&t;&t;   */
id|m
op_assign
id|jiffies
op_minus
id|oskb-&gt;when
suffix:semicolon
multiline_comment|/* RTT */
id|m
op_sub_assign
(paren
id|sk-&gt;rtt
op_rshift
l_int|3
)paren
suffix:semicolon
multiline_comment|/* m is now error in rtt est */
id|sk-&gt;rtt
op_add_assign
id|m
suffix:semicolon
multiline_comment|/* rtt = 7/8 rtt + 1/8 new */
r_if
c_cond
(paren
id|m
OL
l_int|0
)paren
id|m
op_assign
op_minus
id|m
suffix:semicolon
multiline_comment|/* m is now abs(error) */
id|m
op_sub_assign
(paren
id|sk-&gt;mdev
op_rshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* similar update on mdev */
id|sk-&gt;mdev
op_add_assign
id|m
suffix:semicolon
multiline_comment|/* mdev = 3/4 mdev + 1/4 new */
multiline_comment|/* now update timeout.  Note that this removes any backoff */
id|sk-&gt;rto
op_assign
(paren
(paren
id|sk-&gt;rtt
op_rshift
l_int|2
)paren
op_plus
id|sk-&gt;mdev
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rto
OG
l_int|120
op_star
id|HZ
)paren
id|sk-&gt;rto
op_assign
l_int|120
op_star
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rto
OL
l_int|1
op_star
id|HZ
)paren
id|sk-&gt;rto
op_assign
l_int|1
op_star
id|HZ
suffix:semicolon
id|sk-&gt;backoff
op_assign
l_int|0
suffix:semicolon
)brace
id|flag
op_or_assign
(paren
l_int|2
op_or
l_int|4
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|oskb
op_assign
id|sk-&gt;send_head
suffix:semicolon
id|IS_SKB
c_func
(paren
id|oskb
)paren
suffix:semicolon
id|sk-&gt;send_head
op_assign
id|oskb-&gt;link3
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;send_head
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;send_tail
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* We may need to remove this from the dev send list. */
r_if
c_cond
(paren
id|oskb-&gt;next
)paren
id|skb_unlink
c_func
(paren
id|oskb
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|oskb
comma
id|FREE_WRITE
)paren
suffix:semicolon
multiline_comment|/* write. */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Maybe we can take some stuff off of the write queue,&n;   * and put it onto the xmit queue.&n;   */
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|after
(paren
id|sk-&gt;window_seq
op_plus
l_int|1
comma
id|sk-&gt;write_queue.next-&gt;h.seq
)paren
op_logical_and
(paren
id|sk-&gt;retransmits
op_eq
l_int|0
op_logical_or
id|sk-&gt;timeout
op_ne
id|TIME_WRITE
op_logical_or
id|before
c_func
(paren
id|sk-&gt;write_queue.next-&gt;h.seq
comma
id|sk-&gt;rcv_ack_seq
op_plus
l_int|1
)paren
)paren
op_logical_and
id|sk-&gt;packets_out
OL
id|sk-&gt;cong_window
)paren
(brace
id|flag
op_or_assign
l_int|1
suffix:semicolon
id|tcp_write_xmit
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|before
c_func
(paren
id|sk-&gt;window_seq
comma
id|sk-&gt;write_queue.next-&gt;h.seq
)paren
op_logical_and
id|sk-&gt;send_head
op_eq
l_int|NULL
op_logical_and
id|sk-&gt;ack_backlog
op_eq
l_int|0
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_TIME_WAIT
)paren
(brace
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk-&gt;send_head
op_eq
l_int|NULL
op_logical_and
id|sk-&gt;ack_backlog
op_eq
l_int|0
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_TIME_WAIT
op_logical_and
op_logical_neg
id|sk-&gt;keepopen
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;Nothing to do, going to sleep.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;keepopen
)paren
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_KEEPOPEN
comma
id|TCP_TIMEOUT_LEN
)paren
suffix:semicolon
r_else
id|delete_timer
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
(paren
r_int
r_char
)paren
id|sk-&gt;keepopen
)paren
(brace
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_TIME_WAIT
)paren
(brace
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|sk-&gt;packets_out
op_eq
l_int|0
op_logical_and
id|sk-&gt;partial
op_ne
l_int|NULL
op_logical_and
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
op_eq
l_int|NULL
op_logical_and
id|sk-&gt;send_head
op_eq
l_int|NULL
)paren
(brace
id|flag
op_or_assign
l_int|1
suffix:semicolon
id|tcp_send_partial
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* See if we are done. */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_TIME_WAIT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rcv_ack_seq
op_eq
id|sk-&gt;write_seq
op_logical_and
id|sk-&gt;acked_seq
op_eq
id|sk-&gt;fin_seq
)paren
(brace
id|flag
op_or_assign
l_int|1
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_LAST_ACK
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rcv_ack_seq
op_eq
id|sk-&gt;write_seq
)paren
(brace
id|flag
op_or_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;acked_seq
op_ne
id|sk-&gt;fin_seq
)paren
(brace
id|tcp_time_wait
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_ack closing socket - %X&bslash;n&quot;
comma
id|sk
)paren
)paren
suffix:semicolon
id|tcp_send_ack
c_func
(paren
id|sk-&gt;sent_seq
comma
id|sk-&gt;acked_seq
comma
id|sk
comma
id|th
comma
id|sk-&gt;daddr
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * I make no guarantees about the first clause in the following&n; * test, i.e. &quot;(!flag) || (flag&amp;4)&quot;.  I&squot;m not entirely sure under&n; * what conditions &quot;!flag&quot; would be true.  However I think the rest&n; * of the conditions would prevent that from causing any&n; * unnecessary retransmission. &n; *   Clearly if the first packet has expired it should be &n; * retransmitted.  The other alternative, &quot;flag&amp;2 &amp;&amp; retransmits&quot;, is&n; * harder to explain:  You have to look carefully at how and when the&n; * timer is set and with what timeout.  The most recent transmission always&n; * sets the timer.  So in general if the most recent thing has timed&n; * out, everything before it has as well.  So we want to go ahead and&n; * retransmit some more.  If we didn&squot;t explicitly test for this&n; * condition with &quot;flag&amp;2 &amp;&amp; retransmits&quot;, chances are &quot;when + rto &lt; jiffies&quot;&n; * would not be true.  If you look at the pattern of timing, you can&n; * show that rto is increased fast enough that the next packet would&n; * almost never be retransmitted immediately.  Then you&squot;d end up&n; * waiting for a timeout to send each packet on the retranmission&n; * queue.  With my implementation of the Karn sampling algorithm,&n; * the timeout would double each time.  The net result is that it would&n; * take a hideous amount of time to recover from a single dropped packet.&n; * It&squot;s possible that there should also be a test for TIME_WRITE, but&n; * I think as long as &quot;send_head != NULL&quot; and &quot;retransmit&quot; is on, we&squot;ve&n; * got to be in real retransmission mode.&n; *   Note that ip_do_retransmit is called with all==1.  Setting cong_window&n; * back to 1 at the timeout will cause us to send 1, then 2, etc. packets.&n; * As long as no further losses occur, this seems reasonable.&n; */
r_if
c_cond
(paren
(paren
(paren
op_logical_neg
id|flag
)paren
op_logical_or
(paren
id|flag
op_amp
l_int|4
)paren
)paren
op_logical_and
id|sk-&gt;send_head
op_ne
l_int|NULL
op_logical_and
(paren
(paren
(paren
id|flag
op_amp
l_int|2
)paren
op_logical_and
id|sk-&gt;retransmits
)paren
op_logical_or
(paren
id|sk-&gt;send_head-&gt;when
op_plus
id|sk-&gt;rto
OL
id|jiffies
)paren
)paren
)paren
(brace
id|ip_do_retransmit
c_func
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|sk-&gt;rto
)paren
suffix:semicolon
)brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;leaving tcp_ack&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine handles the data.  If there is room in the buffer,&n; * it will be have already been moved into it.  If there is no&n; * room, then we will just have to discard the packet.&n; */
r_static
r_int
DECL|function|tcp_data
id|tcp_data
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb1
comma
op_star
id|skb2
suffix:semicolon
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_int
id|dup_dumped
op_assign
l_int|0
suffix:semicolon
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
id|print_th
c_func
(paren
id|th
)paren
suffix:semicolon
id|skb-&gt;len
op_assign
id|len
op_minus
(paren
id|th-&gt;doff
op_star
l_int|4
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_data len = %d sk = %X:&bslash;n&quot;
comma
id|skb-&gt;len
comma
id|sk
)paren
)paren
suffix:semicolon
id|sk-&gt;bytes_rcv
op_add_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
op_eq
l_int|0
op_logical_and
op_logical_neg
id|th-&gt;fin
op_logical_and
op_logical_neg
id|th-&gt;urg
op_logical_and
op_logical_neg
id|th-&gt;psh
)paren
(brace
multiline_comment|/* Don&squot;t want to keep passing ack&squot;s back and forth. */
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;ack
)paren
id|tcp_send_ack
c_func
(paren
id|sk-&gt;sent_seq
comma
id|sk-&gt;acked_seq
comma
id|sk
comma
id|th
comma
id|saddr
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|RCV_SHUTDOWN
)paren
(brace
id|sk-&gt;acked_seq
op_assign
id|th-&gt;seq
op_plus
id|skb-&gt;len
op_plus
id|th-&gt;syn
op_plus
id|th-&gt;fin
suffix:semicolon
id|tcp_reset
c_func
(paren
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
id|skb-&gt;h.th
comma
id|sk-&gt;prot
comma
l_int|NULL
comma
id|skb-&gt;dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
id|tcp_statistics.TcpEstabResets
op_increment
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|sk-&gt;err
op_assign
id|EPIPE
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_data: closing socket - %X&bslash;n&quot;
comma
id|sk
)paren
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;   * Now we have to walk the chain, and figure out where this one&n;   * goes into it.  This is set up so that the last packet we received&n;   * will be the first one we look at, that way if everything comes&n;   * in order, there will be no performance loss, and if they come&n;   * out of order we will be able to fit things in nicely.&n;   */
multiline_comment|/* This should start at the last one, and then go around forwards. */
r_if
c_cond
(paren
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
op_eq
l_int|NULL
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_data: skb = %X:&bslash;n&quot;
comma
id|skb
)paren
)paren
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
id|skb1
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_data adding to chain sk = %X:&bslash;n&quot;
comma
id|sk
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|skb1
op_assign
id|sk-&gt;receive_queue.prev
suffix:semicolon
suffix:semicolon
id|skb1
op_assign
id|skb1-&gt;prev
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;skb1=%p :&quot;
comma
id|skb1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;skb1-&gt;h.th-&gt;seq = %ld: &quot;
comma
id|skb1-&gt;h.th-&gt;seq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;skb-&gt;h.th-&gt;seq = %ld&bslash;n&quot;
comma
id|skb-&gt;h.th-&gt;seq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;copied_seq = %ld acked_seq = %ld&bslash;n&quot;
comma
id|sk-&gt;copied_seq
comma
id|sk-&gt;acked_seq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;seq
op_eq
id|skb1-&gt;h.th-&gt;seq
op_logical_and
id|skb-&gt;len
op_ge
id|skb1-&gt;len
)paren
(brace
id|skb_append
c_func
(paren
id|skb1
comma
id|skb
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|skb1
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb1
comma
id|FREE_READ
)paren
suffix:semicolon
id|dup_dumped
op_assign
l_int|1
suffix:semicolon
id|skb1
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|after
c_func
(paren
id|th-&gt;seq
op_plus
l_int|1
comma
id|skb1-&gt;h.th-&gt;seq
)paren
)paren
(brace
id|skb_append
c_func
(paren
id|skb1
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb1
op_eq
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
(brace
id|skb_queue_head
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;skb = %X:&bslash;n&quot;
comma
id|skb
)paren
)paren
suffix:semicolon
)brace
id|th-&gt;ack_seq
op_assign
id|th-&gt;seq
op_plus
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;syn
)paren
id|th-&gt;ack_seq
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;fin
)paren
id|th-&gt;ack_seq
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|before
c_func
(paren
id|sk-&gt;acked_seq
comma
id|sk-&gt;copied_seq
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;*** tcp.c:tcp_data bug acked &lt; copied&bslash;n&quot;
)paren
suffix:semicolon
id|sk-&gt;acked_seq
op_assign
id|sk-&gt;copied_seq
suffix:semicolon
)brace
multiline_comment|/* Now figure out if we can ack anything. */
r_if
c_cond
(paren
(paren
op_logical_neg
id|dup_dumped
op_logical_and
(paren
id|skb1
op_eq
l_int|NULL
op_logical_or
id|skb1-&gt;acked
)paren
)paren
op_logical_or
id|before
c_func
(paren
id|th-&gt;seq
comma
id|sk-&gt;acked_seq
op_plus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|th-&gt;seq
comma
id|sk-&gt;acked_seq
op_plus
l_int|1
)paren
)paren
(brace
r_int
id|newwindow
suffix:semicolon
r_if
c_cond
(paren
id|after
c_func
(paren
id|th-&gt;ack_seq
comma
id|sk-&gt;acked_seq
)paren
)paren
(brace
id|newwindow
op_assign
id|sk-&gt;window
op_minus
(paren
id|th-&gt;ack_seq
op_minus
id|sk-&gt;acked_seq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newwindow
OL
l_int|0
)paren
id|newwindow
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;window
op_assign
id|newwindow
suffix:semicolon
id|sk-&gt;acked_seq
op_assign
id|th-&gt;ack_seq
suffix:semicolon
)brace
id|skb-&gt;acked
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* When we ack the fin, we turn on the RCV_SHUTDOWN flag. */
r_if
c_cond
(paren
id|skb-&gt;h.th-&gt;fin
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_or_assign
id|RCV_SHUTDOWN
suffix:semicolon
)brace
r_for
c_loop
(paren
id|skb2
op_assign
id|skb-&gt;next
suffix:semicolon
id|skb2
op_ne
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;receive_queue
suffix:semicolon
id|skb2
op_assign
id|skb2-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|skb2-&gt;h.th-&gt;seq
comma
id|sk-&gt;acked_seq
op_plus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|after
c_func
(paren
id|skb2-&gt;h.th-&gt;ack_seq
comma
id|sk-&gt;acked_seq
)paren
)paren
(brace
id|newwindow
op_assign
id|sk-&gt;window
op_minus
(paren
id|skb2-&gt;h.th-&gt;ack_seq
op_minus
id|sk-&gt;acked_seq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newwindow
OL
l_int|0
)paren
id|newwindow
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;window
op_assign
id|newwindow
suffix:semicolon
id|sk-&gt;acked_seq
op_assign
id|skb2-&gt;h.th-&gt;ack_seq
suffix:semicolon
)brace
id|skb2-&gt;acked
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * When we ack the fin, we turn on&n;&t;&t;&t;&t; * the RCV_SHUTDOWN flag.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|skb2-&gt;h.th-&gt;fin
)paren
(brace
id|sk-&gt;shutdown
op_or_assign
id|RCV_SHUTDOWN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* Force an immediate ack. */
id|sk-&gt;ack_backlog
op_assign
id|sk-&gt;max_ack_backlog
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * This also takes care of updating the window.&n;&t;&t; * This if statement needs to be simplified.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;delay_acks
op_logical_or
id|sk-&gt;ack_backlog
op_ge
id|sk-&gt;max_ack_backlog
op_logical_or
id|sk-&gt;bytes_rcv
OG
id|sk-&gt;max_unacked
op_logical_or
id|th-&gt;fin
)paren
(brace
multiline_comment|/*&t;&t;&t;tcp_send_ack(sk-&gt;sent_seq, sk-&gt;acked_seq,sk,th, saddr); */
)brace
r_else
(brace
id|sk-&gt;ack_backlog
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Ack queued.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|TCP_ACK_TIME
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;   * If we&squot;ve missed a packet, send an ack.&n;   * Also start a timer to send another.&n;   */
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;acked
)paren
(brace
multiline_comment|/*&n;&t; * This is important.  If we don&squot;t have much room left,&n;&t; * we need to throw out a few packets so we have a good&n;&t; * window.  Note that mtu is used, not mss, because mss is really&n;&t; * for the send side.  He could be sending us stuff as large as mtu.&n;&t; */
r_while
c_loop
(paren
id|sk-&gt;prot
op_member_access_from_pointer
id|rspace
c_func
(paren
id|sk
)paren
OL
id|sk-&gt;mtu
)paren
(brace
id|skb1
op_assign
id|skb_peek
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb1
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;INET: tcp.c:tcp_data memory leak detected.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t throw out something that has been acked. */
r_if
c_cond
(paren
id|skb1-&gt;acked
)paren
(brace
r_break
suffix:semicolon
)brace
id|skb_unlink
c_func
(paren
id|skb1
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb1
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
id|tcp_send_ack
c_func
(paren
id|sk-&gt;sent_seq
comma
id|sk-&gt;acked_seq
comma
id|sk
comma
id|th
comma
id|saddr
)paren
suffix:semicolon
id|sk-&gt;ack_backlog
op_increment
suffix:semicolon
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|TCP_ACK_TIME
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We missed a packet.  Send an ack to try to resync things. */
id|tcp_send_ack
c_func
(paren
id|sk-&gt;sent_seq
comma
id|sk-&gt;acked_seq
comma
id|sk
comma
id|th
comma
id|saddr
)paren
suffix:semicolon
)brace
multiline_comment|/* Now tell the user we may have some data. */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Data wakeup.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;data received on dead socket.&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT2
op_logical_and
id|sk-&gt;acked_seq
op_eq
id|sk-&gt;fin_seq
op_logical_and
id|sk-&gt;rcv_ack_seq
op_eq
id|sk-&gt;write_seq
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_data: entering last_ack state sk = %X&bslash;n&quot;
comma
id|sk
)paren
)paren
suffix:semicolon
multiline_comment|/*&t;tcp_send_ack(sk-&gt;sent_seq, sk-&gt;acked_seq, sk, th, saddr); */
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_LAST_ACK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tcp_check_urg
r_static
r_void
id|tcp_check_urg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
)paren
(brace
r_int
r_int
id|ptr
op_assign
id|ntohs
c_func
(paren
id|th-&gt;urg_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
id|ptr
op_decrement
suffix:semicolon
id|ptr
op_add_assign
id|th-&gt;seq
suffix:semicolon
multiline_comment|/* ignore urgent data that we&squot;ve already seen and read */
r_if
c_cond
(paren
id|after
c_func
(paren
id|sk-&gt;copied_seq
op_plus
l_int|1
comma
id|ptr
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* do we already have a newer (or duplicate) urgent pointer? */
r_if
c_cond
(paren
id|sk-&gt;urg_data
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|ptr
comma
id|sk-&gt;urg_seq
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* tell the world about our new urgent pointer */
r_if
c_cond
(paren
id|sk-&gt;proc
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;proc
OG
l_int|0
)paren
(brace
id|kill_proc
c_func
(paren
id|sk-&gt;proc
comma
id|SIGURG
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|kill_pg
c_func
(paren
op_minus
id|sk-&gt;proc
comma
id|SIGURG
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|sk-&gt;urg_data
op_assign
id|URG_NOTYET
suffix:semicolon
id|sk-&gt;urg_seq
op_assign
id|ptr
suffix:semicolon
)brace
DECL|function|tcp_urg
r_static
r_inline
r_int
id|tcp_urg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|ptr
suffix:semicolon
multiline_comment|/* check if we get a new urgent pointer */
r_if
c_cond
(paren
id|th-&gt;urg
)paren
id|tcp_check_urg
c_func
(paren
id|sk
comma
id|th
)paren
suffix:semicolon
multiline_comment|/* do we wait for any urgent data? */
r_if
c_cond
(paren
id|sk-&gt;urg_data
op_ne
id|URG_NOTYET
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* is the urgent pointer pointing into this packet? */
id|ptr
op_assign
id|sk-&gt;urg_seq
op_minus
id|th-&gt;seq
op_plus
id|th-&gt;doff
op_star
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_ge
id|len
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* ok, got the correct packet, update info */
id|sk-&gt;urg_data
op_assign
id|URG_VALID
op_or
op_star
(paren
id|ptr
op_plus
(paren
r_int
r_char
op_star
)paren
id|th
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This deals with incoming fins. &squot;Linus at 9 O&squot;clock&squot; 8-) */
r_static
r_int
DECL|function|tcp_fin
id|tcp_fin
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
r_int
id|saddr
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_fin(sk=%X, th=%X, saddr=%X, dev=%X)&bslash;n&quot;
comma
id|sk
comma
id|th
comma
id|saddr
comma
id|dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_SYN_RECV
suffix:colon
r_case
id|TCP_SYN_SENT
suffix:colon
r_case
id|TCP_ESTABLISHED
suffix:colon
multiline_comment|/* Contains the one that needs to be acked */
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEOUT_LEN
)paren
suffix:semicolon
id|sk-&gt;fin_seq
op_assign
id|th-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|tcp_statistics.TcpCurrEstab
op_decrement
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE_WAIT
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;rst
)paren
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE_WAIT
suffix:colon
r_case
id|TCP_FIN_WAIT2
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* we got a retransmit of the fin. */
r_case
id|TCP_FIN_WAIT1
suffix:colon
multiline_comment|/* Contains the one that needs to be acked */
id|sk-&gt;fin_seq
op_assign
id|th-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_FIN_WAIT2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_case
id|TCP_TIME_WAIT
suffix:colon
id|sk-&gt;state
op_assign
id|TCP_LAST_ACK
suffix:semicolon
multiline_comment|/* Start the timers. */
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sk-&gt;ack_backlog
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This will accept the next outstanding connection. */
r_static
r_struct
id|sock
op_star
DECL|function|tcp_accept
id|tcp_accept
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
)paren
(brace
r_struct
id|sock
op_star
id|newsk
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_accept(sk=%X, flags=%X, addr=%s)&bslash;n&quot;
comma
id|sk
comma
id|flags
comma
id|in_ntoa
c_func
(paren
id|sk-&gt;saddr
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;   * We need to make sure that this socket is listening,&n;   * and that it has something pending.&n;   */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_LISTEN
)paren
(brace
id|sk-&gt;err
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* avoid the race. */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;receive_queue
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;err
op_assign
id|EAGAIN
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;err
op_assign
id|ERESTARTSYS
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Now all we need to do is return skb-&gt;sk. */
id|newsk
op_assign
id|skb-&gt;sk
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|sk-&gt;ack_backlog
op_decrement
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|newsk
suffix:semicolon
)brace
multiline_comment|/* This will initiate an outgoing connection. */
r_static
r_int
DECL|function|tcp_connect
id|tcp_connect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr_in
op_star
id|usin
comma
r_int
id|addr_len
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|sockaddr_in
id|sin
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_CLOSE
)paren
r_return
op_minus
id|EISCONN
suffix:semicolon
r_if
c_cond
(paren
id|addr_len
OL
l_int|8
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|usin
comma
id|addr_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|sin
comma
id|usin
comma
id|min
c_func
(paren
r_sizeof
(paren
id|sin
)paren
comma
id|addr_len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sin.sin_family
op_logical_and
id|sin.sin_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;TCP connect daddr=%s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|sin.sin_addr.s_addr
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t want a TCP connection going to a broadcast address */
r_if
c_cond
(paren
id|ip_chk_addr
c_func
(paren
id|sin.sin_addr.s_addr
)paren
op_eq
id|IS_BROADCAST
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;TCP connection to broadcast address not allowed&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
)brace
multiline_comment|/* Connect back to the same socket: Blows up so disallow it */
r_if
c_cond
(paren
id|sk-&gt;saddr
op_eq
id|sin.sin_addr.s_addr
op_logical_and
id|sk-&gt;num
op_eq
id|ntohs
c_func
(paren
id|sin.sin_port
)paren
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;daddr
op_assign
id|sin.sin_addr.s_addr
suffix:semicolon
id|sk-&gt;write_seq
op_assign
id|jiffies
op_star
id|SEQ_TICK
op_minus
id|seq_offset
suffix:semicolon
id|sk-&gt;window_seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|sk-&gt;rcv_ack_seq
op_assign
id|sk-&gt;write_seq
op_minus
l_int|1
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;dummy_th.dest
op_assign
id|sin.sin_port
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|buff
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|MAX_SYN_SIZE
comma
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|buff-&gt;len
op_assign
l_int|24
suffix:semicolon
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|buff-&gt;data
suffix:semicolon
multiline_comment|/* Put in the IP header and routing stuff. */
multiline_comment|/* We need to build the routing stuff fromt the things saved in skb. */
id|tmp
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
l_int|NULL
comma
id|MAX_SYN_SIZE
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sk-&gt;prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|buff-&gt;mem_addr
comma
id|buff-&gt;mem_len
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
)brace
id|buff-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|t1
op_plus
id|tmp
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
(paren
r_void
op_star
)paren
op_amp
(paren
id|sk-&gt;dummy_th
)paren
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
id|t1-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|sk-&gt;write_seq
op_increment
)paren
suffix:semicolon
id|sk-&gt;sent_seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|buff-&gt;h.seq
op_assign
id|sk-&gt;write_seq
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;window
op_assign
l_int|2
suffix:semicolon
id|t1-&gt;res1
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;res2
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;syn
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;urg_ptr
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;doff
op_assign
l_int|6
suffix:semicolon
multiline_comment|/* use 512 or whatever user asked for */
r_if
c_cond
(paren
id|sk-&gt;user_mss
)paren
id|sk-&gt;mtu
op_assign
id|sk-&gt;user_mss
suffix:semicolon
r_else
(brace
macro_line|#ifdef SUBNETSARELOCAL
r_if
c_cond
(paren
(paren
id|sk-&gt;saddr
op_xor
id|sk-&gt;daddr
)paren
op_amp
id|default_mask
c_func
(paren
id|sk-&gt;saddr
)paren
)paren
macro_line|#else
r_if
c_cond
(paren
(paren
id|sk-&gt;saddr
op_xor
id|sk-&gt;daddr
)paren
op_amp
id|dev-&gt;pa_mask
)paren
macro_line|#endif
id|sk-&gt;mtu
op_assign
l_int|576
op_minus
id|HEADER_SIZE
suffix:semicolon
r_else
id|sk-&gt;mtu
op_assign
id|MAX_WINDOW
suffix:semicolon
)brace
multiline_comment|/* but not bigger than device MTU */
id|sk-&gt;mtu
op_assign
id|min
c_func
(paren
id|sk-&gt;mtu
comma
id|dev-&gt;mtu
op_minus
id|HEADER_SIZE
)paren
suffix:semicolon
multiline_comment|/* Put in the TCP options to say MTU. */
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|t1
op_plus
l_int|1
)paren
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
l_int|2
suffix:semicolon
id|ptr
(braket
l_int|1
)braket
op_assign
l_int|4
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
(paren
id|sk-&gt;mtu
)paren
op_rshift
l_int|8
suffix:semicolon
id|ptr
(braket
l_int|3
)braket
op_assign
(paren
id|sk-&gt;mtu
)paren
op_amp
l_int|0xff
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
r_sizeof
(paren
r_struct
id|tcphdr
)paren
op_plus
l_int|4
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/* This must go first otherwise a really quick response will get reset. */
id|sk-&gt;state
op_assign
id|TCP_SYN_SENT
suffix:semicolon
id|sk-&gt;rtt
op_assign
id|TCP_CONNECT_TIME
suffix:semicolon
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_WRITE
comma
id|TCP_CONNECT_TIME
)paren
suffix:semicolon
multiline_comment|/* Timer for repeating the SYN until an answer */
id|sk-&gt;retransmits
op_assign
id|TCP_RETR2
op_minus
id|TCP_SYN_RETRIES
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|0
)paren
suffix:semicolon
id|tcp_statistics.TcpActiveOpens
op_increment
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This functions checks to see if the tcp header is actually acceptable. */
r_static
r_int
DECL|function|tcp_sequence
id|tcp_sequence
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
comma
r_struct
id|options
op_star
id|opt
comma
r_int
r_int
id|saddr
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_int
id|next_seq
suffix:semicolon
id|next_seq
op_assign
id|len
op_minus
l_int|4
op_star
id|th-&gt;doff
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;fin
)paren
id|next_seq
op_increment
suffix:semicolon
multiline_comment|/* if we have a zero window, we can&squot;t have any data in the packet.. */
r_if
c_cond
(paren
id|next_seq
op_logical_and
op_logical_neg
id|sk-&gt;window
)paren
r_goto
id|ignore_it
suffix:semicolon
id|next_seq
op_add_assign
id|th-&gt;seq
suffix:semicolon
multiline_comment|/*&n;&t; * This isn&squot;t quite right.  sk-&gt;acked_seq could be more recent&n;&t; * than sk-&gt;window.  This is however close enough.  We will accept&n;&t; * slightly more packets than we should, but it should not cause&n;&t; * problems unless someone is trying to forge packets.&n;&t; */
multiline_comment|/* have we already seen all of this packet? */
r_if
c_cond
(paren
op_logical_neg
id|after
c_func
(paren
id|next_seq
op_plus
l_int|1
comma
id|sk-&gt;acked_seq
)paren
)paren
r_goto
id|ignore_it
suffix:semicolon
multiline_comment|/* or does it start beyond the window? */
r_if
c_cond
(paren
op_logical_neg
id|before
c_func
(paren
id|th-&gt;seq
comma
id|sk-&gt;acked_seq
op_plus
id|sk-&gt;window
op_plus
l_int|1
)paren
)paren
r_goto
id|ignore_it
suffix:semicolon
multiline_comment|/* ok, at least part of this packet would seem interesting.. */
r_return
l_int|1
suffix:semicolon
id|ignore_it
suffix:colon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp_sequence: rejecting packet.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;rst
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Send a reset if we get something not ours and we are&n;&t; *&t;unsynchronized. Note: We don&squot;t do anything to our end. We&n;&t; *&t;are just killing the bogus remote connection then we will&n;&t; *&t;connect again and it will work (with luck).&n;&t; */
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_SYN_RECV
)paren
(brace
id|tcp_reset
c_func
(paren
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
id|th
comma
id|sk-&gt;prot
comma
l_int|NULL
comma
id|dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Try to resync things. */
id|tcp_send_ack
c_func
(paren
id|sk-&gt;sent_seq
comma
id|sk-&gt;acked_seq
comma
id|sk
comma
id|th
comma
id|saddr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|tcp_rcv
id|tcp_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|options
op_star
id|opt
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|saddr
comma
r_int
id|redo
comma
r_struct
id|inet_protocol
op_star
id|protocol
)paren
(brace
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp.c: tcp_rcv skb = NULL&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp.c: tcp_rcv dev = NULL&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|tcp_statistics.TcpInSegs
op_increment
suffix:semicolon
id|th
op_assign
id|skb-&gt;h.th
suffix:semicolon
multiline_comment|/* Find the socket. */
id|sk
op_assign
id|get_sock
c_func
(paren
op_amp
id|tcp_prot
comma
id|th-&gt;dest
comma
id|saddr
comma
id|th-&gt;source
comma
id|daddr
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;&lt;&lt;&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;len = %d, redo = %d, skb=%X&bslash;n&quot;
comma
id|len
comma
id|redo
comma
id|skb
)paren
)paren
suffix:semicolon
multiline_comment|/* If this socket has got a reset its to all intents and purposes &n;     really dead */
r_if
c_cond
(paren
id|sk
op_ne
l_int|NULL
op_logical_and
id|sk-&gt;zapped
)paren
id|sk
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sk
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;sk = %X:&bslash;n&quot;
comma
id|sk
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|redo
)paren
(brace
r_if
c_cond
(paren
id|tcp_check
c_func
(paren
id|th
comma
id|len
comma
id|saddr
comma
id|daddr
)paren
)paren
(brace
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;packet dropped with bad checksum.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inet_debug
op_eq
id|DBG_SLIP
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;rtcp_rcv: bad checksum&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We don&squot;t release the socket because it was&n;&t;&t; * never marked in use.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
id|th-&gt;seq
op_assign
id|ntohl
c_func
(paren
id|th-&gt;seq
)paren
suffix:semicolon
multiline_comment|/* See if we know about the socket. */
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;rst
)paren
id|tcp_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
op_amp
id|tcp_prot
comma
id|opt
comma
id|dev
comma
id|skb-&gt;ip_hdr-&gt;tos
comma
l_int|255
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|skb-&gt;len
op_assign
id|len
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;acked
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;used
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;saddr
op_assign
id|daddr
suffix:semicolon
id|skb-&gt;daddr
op_assign
id|saddr
suffix:semicolon
multiline_comment|/* We may need to add it to the backlog here. */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;inuse
)paren
(brace
id|skb_queue_head
c_func
(paren
op_amp
id|sk-&gt;back_log
comma
id|skb
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp.c: tcp_rcv bug sk=NULL redo = 1&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;prot
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;tcp.c: tcp_rcv sk-&gt;prot = NULL &bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Charge the memory to the socket. */
r_if
c_cond
(paren
id|sk-&gt;rmem_alloc
op_plus
id|skb-&gt;mem_len
op_ge
id|sk-&gt;rcvbuf
)paren
(brace
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;dropping packet due to lack of buffer space.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sk-&gt;rmem_alloc
op_add_assign
id|skb-&gt;mem_len
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;About to do switch.&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Now deal with it. */
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
multiline_comment|/*&n;&t; * This should close the system down if it&squot;s waiting&n;&t; * for an ack that is never going to be sent.&n;&t; */
r_case
id|TCP_LAST_ACK
suffix:colon
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
id|sk-&gt;zapped
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;err
op_assign
id|ECONNRESET
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|TCP_ESTABLISHED
suffix:colon
r_case
id|TCP_CLOSE_WAIT
suffix:colon
r_case
id|TCP_FIN_WAIT1
suffix:colon
r_case
id|TCP_FIN_WAIT2
suffix:colon
r_case
id|TCP_TIME_WAIT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tcp_sequence
c_func
(paren
id|sk
comma
id|th
comma
id|len
comma
id|opt
comma
id|saddr
comma
id|dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|inet_debug
op_eq
id|DBG_SLIP
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;rtcp_rcv: not in seq&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
id|tcp_statistics.TcpEstabResets
op_increment
suffix:semicolon
id|tcp_statistics.TcpCurrEstab
op_decrement
suffix:semicolon
id|sk-&gt;zapped
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* This means the thing should really be closed. */
id|sk-&gt;err
op_assign
id|ECONNRESET
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_CLOSE_WAIT
)paren
(brace
id|sk-&gt;err
op_assign
id|EPIPE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * A reset with a fin just means that&n;&t;&t;&t; * the data was not all read.&n;&t;&t;&t; */
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;syn
)paren
(brace
id|tcp_statistics.TcpCurrEstab
op_decrement
suffix:semicolon
id|tcp_statistics.TcpEstabResets
op_increment
suffix:semicolon
id|sk-&gt;err
op_assign
id|ECONNRESET
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|tcp_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;ack
op_logical_and
op_logical_neg
id|tcp_ack
c_func
(paren
id|sk
comma
id|th
comma
id|saddr
comma
id|len
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tcp_urg
c_func
(paren
id|sk
comma
id|th
comma
id|saddr
comma
id|len
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tcp_data
c_func
(paren
id|skb
comma
id|sk
comma
id|saddr
comma
id|len
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Moved: you must do data then fin bit */
r_if
c_cond
(paren
id|th-&gt;fin
op_logical_and
id|tcp_fin
c_func
(paren
id|sk
comma
id|th
comma
id|saddr
comma
id|dev
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TCP_CLOSE
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;dead
op_logical_or
id|sk-&gt;daddr
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;packet received for closed,dead socket&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;rst
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;ack
)paren
id|th-&gt;ack_seq
op_assign
l_int|0
suffix:semicolon
id|tcp_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TCP_LISTEN
suffix:colon
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;ack
)paren
(brace
id|tcp_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;syn
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Now we just put the whole thing including&n;&t;&t;&t; * the header and saddr, and protocol pointer&n;&t;&t;&t; * into the buffer.  We can&squot;t respond until the&n;&t;&t;&t; * user tells us to accept the connection.&n;&t;&t;&t; */
id|tcp_conn_request
c_func
(paren
id|sk
comma
id|skb
comma
id|daddr
comma
id|saddr
comma
id|opt
comma
id|dev
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TCP_SYN_RECV
suffix:colon
r_if
c_cond
(paren
id|th-&gt;syn
)paren
(brace
multiline_comment|/* Probably a retransmitted syn */
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|tcp_sequence
c_func
(paren
id|sk
comma
id|th
comma
id|len
comma
id|opt
comma
id|saddr
comma
id|dev
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|TCP_SYN_SENT
suffix:colon
r_if
c_cond
(paren
id|th-&gt;rst
)paren
(brace
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|sk-&gt;err
op_assign
id|ECONNREFUSED
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|sk-&gt;zapped
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;ack
)paren
(brace
r_if
c_cond
(paren
id|th-&gt;syn
)paren
(brace
id|sk-&gt;state
op_assign
id|TCP_SYN_RECV
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_SYN_SENT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tcp_ack
c_func
(paren
id|sk
comma
id|th
comma
id|saddr
comma
id|len
)paren
)paren
(brace
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|tcp_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * If the syn bit is also set, switch to&n;&t;&t;&t;&t; * tcp_syn_recv, and then to established.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;syn
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Ack the syn and fall through. */
id|sk-&gt;acked_seq
op_assign
id|th-&gt;seq
op_plus
l_int|1
suffix:semicolon
id|sk-&gt;fin_seq
op_assign
id|th-&gt;seq
suffix:semicolon
id|tcp_send_ack
c_func
(paren
id|sk-&gt;sent_seq
comma
id|th-&gt;seq
op_plus
l_int|1
comma
id|sk
comma
id|th
comma
id|sk-&gt;daddr
)paren
suffix:semicolon
r_case
id|TCP_SYN_RECV
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tcp_ack
c_func
(paren
id|sk
comma
id|th
comma
id|saddr
comma
id|len
)paren
)paren
(brace
id|tcp_statistics.TcpAttemptFails
op_increment
suffix:semicolon
id|tcp_reset
c_func
(paren
id|daddr
comma
id|saddr
comma
id|th
comma
id|sk-&gt;prot
comma
id|opt
comma
id|dev
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|tcp_statistics.TcpCurrEstab
op_increment
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_ESTABLISHED
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Now we need to finish filling out&n;&t;&t;&t;&t; * some of the tcp header.&n;&t;&t;&t;&t; */
multiline_comment|/* We need to check for mtu info. */
id|tcp_options
c_func
(paren
id|sk
comma
id|th
)paren
suffix:semicolon
id|sk-&gt;dummy_th.dest
op_assign
id|th-&gt;source
suffix:semicolon
id|sk-&gt;copied_seq
op_assign
id|sk-&gt;acked_seq
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * We&squot;ve already processed his first&n;&t;&t;&t;&t; * ack.  In just about all cases that&n;&t;&t;&t;&t; * will have set max_window.  This is&n;&t;&t;&t;&t; * to protect us against the possibility&n;&t;&t;&t;&t; * that the initial window he sent was 0.&n;&t;&t;&t;&t; * This must occur after tcp_options, which&n;&t;&t;&t;&t; * sets sk-&gt;mtu.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;max_window
op_eq
l_int|0
)paren
(brace
id|sk-&gt;max_window
op_assign
l_int|32
suffix:semicolon
id|sk-&gt;mss
op_assign
id|min
c_func
(paren
id|sk-&gt;max_window
comma
id|sk-&gt;mtu
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Now process the rest like we were&n;&t;&t;&t;&t; * already in the established state.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|th-&gt;urg
)paren
(brace
r_if
c_cond
(paren
id|tcp_urg
c_func
(paren
id|sk
comma
id|th
comma
id|saddr
comma
id|len
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tcp_data
c_func
(paren
id|skb
comma
id|sk
comma
id|saddr
comma
id|len
)paren
)paren
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;fin
)paren
id|tcp_fin
c_func
(paren
id|sk
comma
id|th
comma
id|saddr
comma
id|dev
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;urg
)paren
(brace
r_if
c_cond
(paren
id|tcp_urg
c_func
(paren
id|sk
comma
id|th
comma
id|saddr
comma
id|len
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tcp_data
c_func
(paren
id|skb
comma
id|sk
comma
id|saddr
comma
id|len
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;fin
)paren
(brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|tcp_fin
c_func
(paren
id|sk
comma
id|th
comma
id|saddr
comma
id|dev
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;  * This routine sends a packet with an out of date sequence&n;  * number. It assumes the other end will try to ack it.&n;  */
r_static
r_void
DECL|function|tcp_write_wakeup
id|tcp_write_wakeup
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|buff
suffix:semicolon
r_struct
id|tcphdr
op_star
id|t1
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
r_return
suffix:semicolon
multiline_comment|/* Afer a valid reset we can send no more */
r_if
c_cond
(paren
id|sk
op_member_access_from_pointer
id|state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_CLOSE_WAIT
op_logical_and
id|sk
op_member_access_from_pointer
id|state
op_ne
id|TCP_FIN_WAIT1
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_FIN_WAIT2
)paren
r_return
suffix:semicolon
id|buff
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|wmalloc
c_func
(paren
id|sk
comma
id|MAX_ACK_SIZE
comma
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|buff-&gt;len
op_assign
r_sizeof
(paren
r_struct
id|tcphdr
)paren
suffix:semicolon
id|buff-&gt;free
op_assign
l_int|1
suffix:semicolon
id|buff-&gt;sk
op_assign
id|sk
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TCP
comma
l_string|&quot;in tcp_write_wakeup&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
id|buff-&gt;data
suffix:semicolon
multiline_comment|/* Put in the IP header and routing stuff. */
id|tmp
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|build_header
c_func
(paren
id|buff
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
op_amp
id|dev
comma
id|IPPROTO_TCP
comma
id|sk-&gt;opt
comma
id|MAX_ACK_SIZE
comma
id|sk-&gt;ip_tos
comma
id|sk-&gt;ip_ttl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|sk-&gt;prot
op_member_access_from_pointer
id|wfree
c_func
(paren
id|sk
comma
id|buff-&gt;mem_addr
comma
id|buff-&gt;mem_len
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buff-&gt;len
op_add_assign
id|tmp
suffix:semicolon
id|t1
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|t1
op_plus
id|tmp
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|t1
comma
(paren
r_void
op_star
)paren
op_amp
id|sk-&gt;dummy_th
comma
r_sizeof
(paren
op_star
id|t1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;   * Use a previous sequence.&n;   * This should cause the other end to send an ack.&n;   */
id|t1-&gt;seq
op_assign
id|htonl
c_func
(paren
id|sk-&gt;sent_seq
op_minus
l_int|1
)paren
suffix:semicolon
id|t1-&gt;ack
op_assign
l_int|1
suffix:semicolon
id|t1-&gt;res1
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;res2
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;rst
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;psh
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;fin
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;syn
op_assign
l_int|0
suffix:semicolon
id|t1-&gt;ack_seq
op_assign
id|ntohl
c_func
(paren
id|sk-&gt;acked_seq
)paren
suffix:semicolon
id|t1-&gt;window
op_assign
id|ntohs
c_func
(paren
id|tcp_select_window
c_func
(paren
id|sk
)paren
multiline_comment|/*sk-&gt;prot-&gt;rspace(sk)*/
)paren
suffix:semicolon
id|t1-&gt;doff
op_assign
r_sizeof
(paren
op_star
id|t1
)paren
op_div
l_int|4
suffix:semicolon
id|tcp_send_check
c_func
(paren
id|t1
comma
id|sk-&gt;saddr
comma
id|sk-&gt;daddr
comma
r_sizeof
(paren
op_star
id|t1
)paren
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/* Send it and free it.&n;   * This will prevent the timer from automatically being restarted.&n;  */
id|sk-&gt;prot
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|sk
comma
id|dev
comma
id|buff
comma
l_int|1
)paren
suffix:semicolon
id|tcp_statistics.TcpOutSegs
op_increment
suffix:semicolon
)brace
r_void
DECL|function|tcp_send_probe0
id|tcp_send_probe0
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;zapped
)paren
r_return
suffix:semicolon
multiline_comment|/* Afer a valid reset we can send no more */
id|tcp_write_wakeup
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;backoff
op_increment
suffix:semicolon
id|sk-&gt;rto
op_assign
id|min
c_func
(paren
id|sk-&gt;rto
op_lshift
l_int|1
comma
l_int|120
op_star
id|HZ
)paren
suffix:semicolon
id|reset_timer
(paren
id|sk
comma
id|TIME_PROBE0
comma
id|sk-&gt;rto
)paren
suffix:semicolon
id|sk-&gt;retransmits
op_increment
suffix:semicolon
id|sk-&gt;prot-&gt;retransmits
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Socket option code for TCP. &n; */
DECL|function|tcp_setsockopt
r_int
id|tcp_setsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_int
id|val
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
id|level
op_ne
id|SOL_TCP
)paren
(brace
r_return
id|ip_setsockopt
c_func
(paren
id|sk
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|optval
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|optval
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|val
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|optval
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|TCP_MAXSEG
suffix:colon
multiline_comment|/*&t;&t;&t;if(val&lt;200||val&gt;2048 || val&gt;sk-&gt;mtu) */
multiline_comment|/*&n; * values greater than interface MTU won&squot;t take effect.  however at&n; * the point when this call is done we typically don&squot;t yet know&n; * which interface is going to be used&n; */
r_if
c_cond
(paren
id|val
id|MAX_WINDOW
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|sk-&gt;user_mss
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TCP_NODELAY
suffix:colon
id|sk-&gt;nonagle
op_assign
(paren
id|val
op_eq
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
)brace
)brace
DECL|function|tcp_getsockopt
r_int
id|tcp_getsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
r_int
id|val
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
id|level
op_ne
id|SOL_TCP
)paren
(brace
r_return
id|ip_getsockopt
c_func
(paren
id|sk
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|TCP_MAXSEG
suffix:colon
id|val
op_assign
id|sk-&gt;user_mss
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_NODELAY
suffix:colon
id|val
op_assign
id|sk-&gt;nonagle
suffix:semicolon
multiline_comment|/* Until Johannes stuff is in */
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
)brace
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|optlen
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_fs_long
c_func
(paren
r_sizeof
(paren
r_int
)paren
comma
(paren
r_int
r_int
op_star
)paren
id|optlen
)paren
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|optval
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_fs_long
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|optval
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|tcp_prot
r_struct
id|proto
id|tcp_prot
op_assign
(brace
id|sock_wmalloc
comma
id|sock_rmalloc
comma
id|sock_wfree
comma
id|sock_rfree
comma
id|sock_rspace
comma
id|sock_wspace
comma
id|tcp_close
comma
id|tcp_read
comma
id|tcp_write
comma
id|tcp_sendto
comma
id|tcp_recvfrom
comma
id|ip_build_header
comma
id|tcp_connect
comma
id|tcp_accept
comma
id|ip_queue_xmit
comma
id|tcp_retransmit
comma
id|tcp_write_wakeup
comma
id|tcp_read_wakeup
comma
id|tcp_rcv
comma
id|tcp_select
comma
id|tcp_ioctl
comma
l_int|NULL
comma
id|tcp_shutdown
comma
id|tcp_setsockopt
comma
id|tcp_getsockopt
comma
l_int|128
comma
l_int|0
comma
(brace
l_int|NULL
comma
)brace
comma
l_string|&quot;TCP&quot;
)brace
suffix:semicolon
eof
