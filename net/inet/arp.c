multiline_comment|/* linux/net/inet/arp.c&n; *&n; * Copyright (C) 1994 by Florian  La Roche&n; *&n; * This module implements the Address Resolution Protocol ARP (RFC 826),&n; * which is used to convert IP addresses (or in the future maybe other&n; * high-level addresses into a low-level hardware address (like an Ethernet&n; * address).&n; *&n; * FIXME:&n; *&t;Experiment with better retransmit timers&n; *&t;Clean up the timer deletions&n; *&t;If you create a proxy entry set your interface address to the address&n; *&t;and then delete it, proxies may get out of sync with reality - check this&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; *&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;Removed the ethernet assumptions in Florian&squot;s code&n; *&t;&t;Alan Cox&t;:&t;Fixed some small errors in the ARP logic&n; *&t;&t;Alan Cox&t;:&t;Allow &gt;4K in /proc&n; *&t;&t;Alan Cox&t;:&t;Make ARP add its own protocol entry&n; *&n; *              Ross Martin     :       Rewrote arp_rcv() and arp_get_info()&n; *&t;&t;Stephen Henson&t;:&t;Add AX25 support to arp_get_info()&n; *&t;&t;Alan Cox&t;:&t;Drop data when a device is downed.&n; *&t;&t;Alan Cox&t;:&t;Use init_timer()&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;route.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &quot;arp.h&quot;
macro_line|#ifdef CONFIG_AX25
macro_line|#include &quot;ax25.h&quot;
macro_line|#endif
multiline_comment|/*&n; *&t;This structure defines the ARP mapping cache. As long as we make changes&n; *&t;in this structure, we keep interrupts of. But normally we can copy the&n; *&t;hardware address and the device pointer in a local variable and then make&n; *&t;any &quot;long calls&quot; to send a packet out.&n; */
DECL|struct|arp_table
r_struct
id|arp_table
(brace
DECL|member|next
r_struct
id|arp_table
op_star
id|next
suffix:semicolon
multiline_comment|/* Linked entry list &t;&t;*/
DECL|member|last_used
r_int
r_int
id|last_used
suffix:semicolon
multiline_comment|/* For expiry &t;&t;&t;*/
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Control status &t;&t;*/
DECL|member|ip
r_int
r_int
id|ip
suffix:semicolon
multiline_comment|/* ip address of entry &t;&t;*/
DECL|member|ha
r_int
r_char
id|ha
(braket
id|MAX_ADDR_LEN
)braket
suffix:semicolon
multiline_comment|/* Hardware address&t;&t;*/
DECL|member|hlen
r_int
r_char
id|hlen
suffix:semicolon
multiline_comment|/* Length of hardware address &t;*/
DECL|member|htype
r_int
r_int
id|htype
suffix:semicolon
multiline_comment|/* Type of hardware in use&t;*/
DECL|member|dev
r_struct
id|device
op_star
id|dev
suffix:semicolon
multiline_comment|/* Device the entry is tied to &t;*/
multiline_comment|/*&n;&t; *&t;The following entries are only used for unresolved hw addresses.&n;&t; */
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* expire timer &t;&t;*/
DECL|member|retries
r_int
id|retries
suffix:semicolon
multiline_comment|/* remaining retries&t; &t;*/
DECL|member|skb
r_struct
id|sk_buff_head
id|skb
suffix:semicolon
multiline_comment|/* list of queued packets &t;*/
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;This structure defines an ethernet arp header.&n; */
DECL|struct|arphdr
r_struct
id|arphdr
(brace
DECL|member|ar_hrd
r_int
r_int
id|ar_hrd
suffix:semicolon
multiline_comment|/* format of hardware address&t;*/
DECL|member|ar_pro
r_int
r_int
id|ar_pro
suffix:semicolon
multiline_comment|/* format of protocol address&t;*/
DECL|member|ar_hln
r_int
r_char
id|ar_hln
suffix:semicolon
multiline_comment|/* length of hardware address&t;*/
DECL|member|ar_pln
r_int
r_char
id|ar_pln
suffix:semicolon
multiline_comment|/* length of protocol address&t;*/
DECL|member|ar_op
r_int
r_int
id|ar_op
suffix:semicolon
multiline_comment|/* ARP opcode (command)&t;&t;*/
macro_line|#if 0
multiline_comment|/*&n;&t;  *&t; Ethernet looks like this : This bit is variable sized however...&n;&t;  */
r_int
r_char
id|ar_sha
(braket
id|ETH_ALEN
)braket
suffix:semicolon
multiline_comment|/* sender hardware address&t;*/
r_int
r_char
id|ar_sip
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* sender IP address&t;&t;*/
r_int
r_char
id|ar_tha
(braket
id|ETH_ALEN
)braket
suffix:semicolon
multiline_comment|/* target hardware address&t;*/
r_int
r_char
id|ar_tip
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* target IP address&t;&t;*/
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Configurable Parameters (don&squot;t touch unless you know what you are doing&n; */
multiline_comment|/*&n; *&t;If an arp request is send, ARP_RES_TIME is the timeout value until the&n; *&t;next request is send.&n; */
DECL|macro|ARP_RES_TIME
mdefine_line|#define ARP_RES_TIME&t;&t;(250*(HZ/10))
multiline_comment|/*&n; *&t;The number of times an arp request is send, until the host is&n; *&t;considered unreachable.&n; */
DECL|macro|ARP_MAX_TRIES
mdefine_line|#define ARP_MAX_TRIES&t;&t;3
multiline_comment|/*&n; *&t;After that time, an unused entry is deleted from the arp table.&n; */
DECL|macro|ARP_TIMEOUT
mdefine_line|#define ARP_TIMEOUT&t;&t;(600*HZ)
multiline_comment|/*&n; *&t;How often is the function &squot;arp_check_retries&squot; called.&n; *&t;An entry is invalidated in the time between ARP_TIMEOUT and&n; *&t;(ARP_TIMEOUT+ARP_CHECK_INTERVAL).&n; */
DECL|macro|ARP_CHECK_INTERVAL
mdefine_line|#define ARP_CHECK_INTERVAL&t;(60 * HZ)
r_static
r_void
id|arp_check_expire
(paren
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* Forward declaration. */
DECL|variable|arp_timer
r_static
r_struct
id|timer_list
id|arp_timer
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
id|ARP_CHECK_INTERVAL
comma
l_int|0L
comma
op_amp
id|arp_check_expire
)brace
suffix:semicolon
multiline_comment|/*&n; * &t;The size of the hash table. Must be a power of two.&n; * &t;Maybe we should remove hashing in the future for arp and concentrate&n; * &t;on Patrick Schaaf&squot;s Host-Cache-Lookup...&n; */
DECL|macro|ARP_TABLE_SIZE
mdefine_line|#define ARP_TABLE_SIZE  16
DECL|variable|arp_tables
r_struct
id|arp_table
op_star
id|arp_tables
(braket
id|ARP_TABLE_SIZE
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;The last bits in the IP address are used for the cache lookup.&n; */
DECL|macro|HASH
mdefine_line|#define HASH(paddr) &t;&t;(htonl(paddr) &amp; (ARP_TABLE_SIZE - 1))
multiline_comment|/*&n; *&t;Number of proxy arp entries. This is normally zero and we use it to do&n; *&t;some optimizing for normal uses.&n; */
DECL|variable|proxies
r_static
r_int
id|proxies
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; *&t;Check if there are too old entries and remove them. If the ATF_PERM&n; *&t;flag is set, they are always left in the arp cache (permanent entry).&n; *&t;Note: Only fully resolved entries, which don&squot;t have any packets in&n; *&t;the queue, can be deleted, since ARP_TIMEOUT is much greater than&n; *&t;ARP_MAX_TRIES*ARP_RES_TIME.&n; */
DECL|function|arp_check_expire
r_static
r_void
id|arp_check_expire
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARP_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|arp_table
op_star
op_star
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
op_star
id|pentry
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|now
op_minus
id|entry-&gt;last_used
)paren
OG
id|ARP_TIMEOUT
op_logical_and
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_PERM
)paren
)paren
(brace
op_star
id|pentry
op_assign
id|entry-&gt;next
suffix:semicolon
multiline_comment|/* remove from list */
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|ATF_PUBL
)paren
id|proxies
op_decrement
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
multiline_comment|/* Paranoia */
id|kfree_s
c_func
(paren
id|entry
comma
r_sizeof
(paren
r_struct
id|arp_table
)paren
)paren
suffix:semicolon
)brace
r_else
id|pentry
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
multiline_comment|/* go to next entry */
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Set the timer again.&n;&t; */
id|del_timer
c_func
(paren
op_amp
id|arp_timer
)paren
suffix:semicolon
id|arp_timer.expires
op_assign
id|ARP_CHECK_INTERVAL
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|arp_timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Release all linked skb&squot;s and the memory for this entry.&n; */
DECL|function|arp_release_entry
r_static
r_void
id|arp_release_entry
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|ATF_PUBL
)paren
id|proxies
op_decrement
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Release the list of `skb&squot; pointers. */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|skb_device_lock
c_func
(paren
id|skb
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|entry
comma
r_sizeof
(paren
r_struct
id|arp_table
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Purge a device from the ARP queue&n; */
DECL|function|arp_device_down
r_void
id|arp_device_down
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This is a bit OTT - maybe we need some arp semaphores instead.&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARP_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|arp_table
op_star
op_star
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
op_star
id|pentry
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;dev
op_eq
id|dev
)paren
(brace
op_star
id|pentry
op_assign
id|entry-&gt;next
suffix:semicolon
multiline_comment|/* remove from list */
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|ATF_PUBL
)paren
id|proxies
op_decrement
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
multiline_comment|/* Paranoia */
id|kfree_s
c_func
(paren
id|entry
comma
r_sizeof
(paren
r_struct
id|arp_table
)paren
)paren
suffix:semicolon
)brace
r_else
id|pentry
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
multiline_comment|/* go to next entry */
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Create and send an arp packet. If (dest_hw == NULL), we create a broadcast&n; *&t;message.&n; */
DECL|function|arp_send
r_void
id|arp_send
c_func
(paren
r_int
id|type
comma
r_int
id|ptype
comma
r_int
r_int
id|dest_ip
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|src_ip
comma
r_int
r_char
op_star
id|dest_hw
comma
r_int
r_char
op_star
id|src_hw
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|arphdr
op_star
id|arp
suffix:semicolon
r_int
r_char
op_star
id|arp_ptr
suffix:semicolon
multiline_comment|/*&n;&t; *&t;No arp on this interface.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_NOARP
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Allocate a buffer&n;&t; */
id|skb
op_assign
id|alloc_skb
c_func
(paren
r_sizeof
(paren
r_struct
id|arphdr
)paren
op_plus
l_int|2
op_star
(paren
id|dev-&gt;addr_len
op_plus
l_int|4
)paren
op_plus
id|dev-&gt;hard_header_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ARP: no memory to send an arp packet&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb-&gt;len
op_assign
r_sizeof
(paren
r_struct
id|arphdr
)paren
op_plus
id|dev-&gt;hard_header_len
op_plus
l_int|2
op_star
(paren
id|dev-&gt;addr_len
op_plus
l_int|4
)paren
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fill the device header for the ARP frame&n;&t; */
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
id|skb-&gt;data
comma
id|dev
comma
id|ptype
comma
id|dest_hw
ques
c_cond
id|dest_hw
suffix:colon
id|dev-&gt;broadcast
comma
id|src_hw
ques
c_cond
id|src_hw
suffix:colon
l_int|NULL
comma
id|skb-&gt;len
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* Fill out the arp protocol part. */
id|arp
op_assign
(paren
r_struct
id|arphdr
op_star
)paren
(paren
id|skb-&gt;data
op_plus
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
id|arp-&gt;ar_hrd
op_assign
id|htons
c_func
(paren
id|dev-&gt;type
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_AX25
id|arp-&gt;ar_pro
op_assign
(paren
id|dev-&gt;type
op_ne
id|ARPHRD_AX25
)paren
ques
c_cond
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:colon
id|htons
c_func
(paren
id|AX25_P_IP
)paren
suffix:semicolon
macro_line|#else
id|arp-&gt;ar_pro
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
macro_line|#endif
id|arp-&gt;ar_hln
op_assign
id|dev-&gt;addr_len
suffix:semicolon
id|arp-&gt;ar_pln
op_assign
l_int|4
suffix:semicolon
id|arp-&gt;ar_op
op_assign
id|htons
c_func
(paren
id|type
)paren
suffix:semicolon
id|arp_ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|arp
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|arp_ptr
comma
id|src_hw
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
id|arp_ptr
comma
op_amp
id|src_ip
comma
l_int|4
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|dest_hw
op_ne
l_int|NULL
)paren
id|memcpy
c_func
(paren
id|arp_ptr
comma
id|dest_hw
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_else
id|memset
c_func
(paren
id|arp_ptr
comma
l_int|0
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
id|arp_ptr
comma
op_amp
id|dest_ip
comma
l_int|4
)paren
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This function is called, if an entry is not resolved in ARP_RES_TIME.&n; *&t;Either resend a request, or give it up and free the entry.&n; */
DECL|function|arp_expire_request
r_static
r_void
id|arp_expire_request
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
op_assign
(paren
r_struct
id|arp_table
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|arp_table
op_star
op_star
id|pentry
suffix:semicolon
r_int
r_int
id|hash
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Since all timeouts are handled with interrupts enabled, there is a&n;&t; *&t;small chance, that this entry has just been resolved by an incoming&n;&t; *&t;packet. This is the only race condition, but it is handled...&n;&t; */
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|entry-&gt;retries
OG
l_int|0
)paren
(brace
r_int
r_int
id|ip
op_assign
id|entry-&gt;ip
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
id|entry-&gt;dev
suffix:semicolon
multiline_comment|/* Set new timer. */
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;timer.expires
op_assign
id|ARP_RES_TIME
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|ip
comma
id|dev
comma
id|dev-&gt;pa_addr
comma
l_int|NULL
comma
id|dev-&gt;dev_addr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Arp request timed out. Delete entry and all waiting packets.&n;&t; *&t;If we give each entry a pointer to itself, we don&squot;t have to&n;&t; *&t;loop through everything again. Maybe hash is good enough, but&n;&t; *&t;I will look at it later.&n;&t; */
id|hash
op_assign
id|HASH
c_func
(paren
id|entry-&gt;ip
)paren
suffix:semicolon
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pentry
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_star
id|pentry
op_eq
id|entry
)paren
(brace
op_star
id|pentry
op_assign
id|entry-&gt;next
suffix:semicolon
multiline_comment|/* delete from linked list */
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|arp_release_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pentry
op_assign
op_amp
(paren
op_star
id|pentry
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Possible ARP queue corruption.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We should never arrive here.&n;&t; */
)brace
multiline_comment|/*&n; *&t;This will try to retransmit everything on the queue.&n; */
DECL|function|arp_send_q
r_static
r_void
id|arp_send_q
c_func
(paren
r_struct
id|arp_table
op_star
id|entry
comma
r_int
r_char
op_star
id|hw_dest
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Empty the entire queue, building its data up ready to send&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arp_send_q: incomplete entry for %s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|entry-&gt;ip
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb_device_lock
c_func
(paren
id|skb
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;dev
op_member_access_from_pointer
id|rebuild_header
c_func
(paren
id|skb-&gt;data
comma
id|skb-&gt;dev
comma
id|skb-&gt;raddr
comma
id|skb
)paren
)paren
(brace
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;sk
op_eq
l_int|NULL
)paren
(brace
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|dev_queue_xmit
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
id|skb-&gt;sk-&gt;priority
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This routine is only ever called when &squot;entry&squot; is&n;&t;&t;&t;   complete. Thus this can&squot;t fail. */
id|printk
c_func
(paren
l_string|&quot;arp_send_q: The impossible occurred. Please notify Alan.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;arp_send_q: active entity %s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|entry-&gt;ip
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;arp_send_q: failed to find %s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|skb-&gt;raddr
)paren
)paren
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Delete an ARP mapping entry in the cache.&n; */
DECL|function|arp_destroy
r_void
id|arp_destroy
c_func
(paren
r_int
r_int
id|ip_addr
comma
r_int
id|force
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|arp_table
op_star
op_star
id|pentry
suffix:semicolon
r_int
r_int
id|hash
op_assign
id|HASH
c_func
(paren
id|ip_addr
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|pentry
op_assign
op_amp
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
op_star
id|pentry
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|ip_addr
)paren
(brace
r_if
c_cond
(paren
(paren
id|entry-&gt;flags
op_amp
id|ATF_PERM
)paren
op_logical_and
op_logical_neg
id|force
)paren
r_return
suffix:semicolon
op_star
id|pentry
op_assign
id|entry-&gt;next
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|arp_release_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pentry
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Receive an arp request by the device layer. Maybe I rewrite it, to&n; *&t;use the incoming packet for the reply. The time for the current&n; *&t;&quot;overhead&quot; isn&squot;t that high...&n; */
DECL|function|arp_rcv
r_int
id|arp_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
multiline_comment|/*&n; *&t;We shouldn&squot;t use this type conversion. Check later.&n; */
r_struct
id|arphdr
op_star
id|arp
op_assign
(paren
r_struct
id|arphdr
op_star
)paren
id|skb-&gt;h.raw
suffix:semicolon
r_int
r_char
op_star
id|arp_ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|arp
op_plus
l_int|1
)paren
suffix:semicolon
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|arp_table
op_star
id|proxy_entry
suffix:semicolon
r_int
id|addr_hint
comma
id|hlen
comma
id|htype
suffix:semicolon
r_int
r_int
id|hash
comma
id|dest_hash
suffix:semicolon
r_int
r_char
id|ha
(braket
id|MAX_ADDR_LEN
)braket
suffix:semicolon
multiline_comment|/* So we can enable ints again. */
r_int
id|sip
comma
id|tip
suffix:semicolon
r_int
r_char
op_star
id|sha
comma
op_star
id|tha
suffix:semicolon
multiline_comment|/*&n; *&t;The hardware length of the packet should match the hardware length&n; *&t;of the device.  Similarly, the hardware types should match.  The&n; *&t;device should be ARP-able.  Also, if pln is not 4, then the lookup&n; *&t;is not from an IP number.  We can&squot;t currently handle this, so toss&n; *&t;it. &n; */
r_if
c_cond
(paren
id|arp-&gt;ar_hln
op_ne
id|dev-&gt;addr_len
op_logical_or
id|dev-&gt;type
op_ne
id|ntohs
c_func
(paren
id|arp-&gt;ar_hrd
)paren
op_logical_or
id|dev-&gt;flags
op_amp
id|IFF_NOARP
op_logical_or
id|arp-&gt;ar_pln
op_ne
l_int|4
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Another test.&n; *&t;The logic here is that the protocol being looked up by arp should &n; *&t;match the protocol the device speaks.  If it doesn&squot;t, there is a&n; *&t;problem, so toss the packet.&n; */
r_switch
c_cond
(paren
id|dev-&gt;type
)paren
(brace
macro_line|#ifdef CONFIG_AX25
r_case
id|ARPHRD_AX25
suffix:colon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|AX25_P_IP
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#endif
r_case
id|ARPHRD_ETHER
suffix:colon
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ARP: dev-&gt;type mangled!&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Extract fields&n; */
id|hlen
op_assign
id|dev-&gt;addr_len
suffix:semicolon
id|htype
op_assign
id|dev-&gt;type
suffix:semicolon
id|sha
op_assign
id|arp_ptr
suffix:semicolon
id|arp_ptr
op_add_assign
id|hlen
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|sip
comma
id|arp_ptr
comma
l_int|4
)paren
suffix:semicolon
id|arp_ptr
op_add_assign
l_int|4
suffix:semicolon
id|tha
op_assign
id|arp_ptr
suffix:semicolon
id|arp_ptr
op_add_assign
id|hlen
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|tip
comma
id|arp_ptr
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* &n; *&t;Check for bad requests for 127.0.0.1.  If this is one such, delete it.&n; */
r_if
c_cond
(paren
id|tip
op_eq
id|INADDR_LOOPBACK
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Process entry.  The idea here is we want to send a reply if it is a&n; *  request for us or if it is a request for someone else that we hold&n; *  a proxy for.  We want to add an entry to our cache if it is a reply&n; *  to us or if it is a request for our address.  &n; *  (The assumption for this last is that if someone is requesting our &n; *  address, they are probably intending to talk to us, so it saves time &n; *  if we cache their address.  Their address is also probably not in &n; *  our cache, since ours is not in their cache.)&n; * &n; *  Putting this another way, we only care about replies if they are to&n; *  us, in which case we add them to the cache.  For requests, we care&n; *  about those for us and those for our proxies.  We reply to both,&n; *  and in the case of requests for us we add the requester to the arp &n; *  cache.&n; */
id|addr_hint
op_assign
id|ip_chk_addr
c_func
(paren
id|tip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arp-&gt;ar_op
op_eq
id|htons
c_func
(paren
id|ARPOP_REPLY
)paren
)paren
(brace
r_if
c_cond
(paren
id|addr_hint
op_ne
id|IS_MYADDR
)paren
(brace
multiline_comment|/* &n; *&t;Replies to other machines get tossed. &n; */
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Fall through to code below that adds sender to cache. &n; */
)brace
r_else
(brace
multiline_comment|/* &n; * &t;It is now an arp request &n; */
r_if
c_cond
(paren
id|addr_hint
op_ne
id|IS_MYADDR
)paren
(brace
multiline_comment|/*&n; * &t;To get in here, it is a request for someone else.  We need to&n; * &t;check if that someone else is one of our proxies.  If it isn&squot;t,&n; * &t;we can toss it.&n; */
r_if
c_cond
(paren
id|proxies
op_eq
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dest_hash
op_assign
id|HASH
c_func
(paren
id|tip
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|proxy_entry
op_assign
id|arp_tables
(braket
id|dest_hash
)braket
suffix:semicolon
id|proxy_entry
suffix:semicolon
id|proxy_entry
op_assign
id|proxy_entry-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|proxy_entry-&gt;ip
op_eq
id|tip
op_logical_and
id|proxy_entry-&gt;htype
op_eq
id|htype
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|proxy_entry
op_logical_and
(paren
id|proxy_entry-&gt;flags
op_amp
id|ATF_PUBL
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|ha
comma
id|proxy_entry-&gt;ha
comma
id|hlen
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|arp_send
c_func
(paren
id|ARPOP_REPLY
comma
id|ETH_P_ARP
comma
id|sip
comma
id|dev
comma
id|tip
comma
id|sha
comma
id|ha
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n; * &t;To get here, it must be an arp request for us.  We need to reply.&n; */
id|arp_send
c_func
(paren
id|ARPOP_REPLY
comma
id|ETH_P_ARP
comma
id|sip
comma
id|dev
comma
id|tip
comma
id|sha
comma
id|dev-&gt;dev_addr
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Now all replies are handled.  Next, anything that falls through to here&n; * needs to be added to the arp cache, or have its entry updated if it is &n; * there.&n; */
id|hash
op_assign
id|HASH
c_func
(paren
id|sip
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|entry
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|sip
op_logical_and
id|entry-&gt;htype
op_eq
id|htype
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry
)paren
(brace
multiline_comment|/*&n; *&t;Entry found; update it.&n; */
id|memcpy
c_func
(paren
id|entry-&gt;ha
comma
id|sha
comma
id|hlen
)paren
suffix:semicolon
id|entry-&gt;hlen
op_assign
id|hlen
suffix:semicolon
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
)paren
(brace
multiline_comment|/*&n; *&t;This entry was incomplete.  Delete the retransmit timer&n; *&t;and switch to complete status.&n; */
id|del_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;flags
op_or_assign
id|ATF_COM
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* &n; *&t;Send out waiting packets. We might have problems, if someone is &n; *&t;manually removing entries right now -- entry might become invalid &n; *&t;underneath us.&n; */
id|arp_send_q
c_func
(paren
id|entry
comma
id|sha
)paren
suffix:semicolon
)brace
r_else
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n; * &t;No entry found.  Need to add a new entry to the arp table.&n; */
id|entry
op_assign
(paren
r_struct
id|arp_table
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arp_table
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ARP: no memory for new arp entry&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|entry-&gt;ip
op_assign
id|sip
suffix:semicolon
id|entry-&gt;hlen
op_assign
id|hlen
suffix:semicolon
id|entry-&gt;htype
op_assign
id|htype
suffix:semicolon
id|entry-&gt;flags
op_assign
id|ATF_COM
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|entry-&gt;ha
comma
id|sha
comma
id|hlen
)paren
suffix:semicolon
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|entry-&gt;dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
suffix:semicolon
id|entry-&gt;next
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|arp_tables
(braket
id|hash
)braket
op_assign
id|entry
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Replies have been sent, and entries have been added.  All done.&n; */
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Find an arp mapping in the cache. If not found, post a request.&n; */
DECL|function|arp_find
r_int
id|arp_find
c_func
(paren
r_int
r_char
op_star
id|haddr
comma
r_int
r_int
id|paddr
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|saddr
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_int
r_int
id|hash
suffix:semicolon
r_switch
c_cond
(paren
id|ip_chk_addr
c_func
(paren
id|paddr
)paren
)paren
(brace
r_case
id|IS_MYADDR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ARP: arp called for own IP address&bslash;n&quot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|haddr
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|IS_BROADCAST
suffix:colon
id|memcpy
c_func
(paren
id|haddr
comma
id|dev-&gt;broadcast
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|hash
op_assign
id|HASH
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Find an entry&n;&t; */
r_for
c_loop
(paren
id|entry
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|paddr
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_ne
l_int|NULL
)paren
multiline_comment|/* It exists */
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|ATF_COM
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;A request was already send, but no reply yet. Thus&n;&t;&t;&t; *&t;queue the packet with the previous attempt&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
id|skb_queue_tail
c_func
(paren
op_amp
id|entry-&gt;skb
comma
id|skb
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Update the record&n;&t;&t; */
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|memcpy
c_func
(paren
id|haddr
comma
id|entry-&gt;ha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Create a new unresolved entry.&n;&t; */
id|entry
op_assign
(paren
r_struct
id|arp_table
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arp_table
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_ne
l_int|NULL
)paren
(brace
id|entry-&gt;ip
op_assign
id|paddr
suffix:semicolon
id|entry-&gt;hlen
op_assign
id|dev-&gt;addr_len
suffix:semicolon
id|entry-&gt;htype
op_assign
id|dev-&gt;type
suffix:semicolon
id|entry-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|entry-&gt;ha
comma
l_int|0
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|entry-&gt;dev
op_assign
id|dev
suffix:semicolon
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;timer.function
op_assign
id|arp_expire_request
suffix:semicolon
id|entry-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|entry
suffix:semicolon
id|entry-&gt;timer.expires
op_assign
id|ARP_RES_TIME
suffix:semicolon
id|entry-&gt;next
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|arp_tables
(braket
id|hash
)braket
op_assign
id|entry
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;retries
op_assign
id|ARP_MAX_TRIES
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
id|skb_queue_tail
c_func
(paren
op_amp
id|entry-&gt;skb
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
op_logical_and
id|skb-&gt;free
)paren
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If we didn&squot;t find an entry, we will try to send an ARP packet.&n;&t; */
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|paddr
comma
id|dev
comma
id|saddr
comma
l_int|NULL
comma
id|dev-&gt;dev_addr
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Write the contents of the ARP cache to a PROCfs file.&n; */
DECL|macro|HBUFFERLEN
mdefine_line|#define HBUFFERLEN 30
DECL|function|arp_get_info
r_int
id|arp_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|size
suffix:semicolon
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_char
id|hbuffer
(braket
id|HBUFFERLEN
)braket
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_const
r_char
id|hexbuf
(braket
)braket
op_assign
l_string|&quot;0123456789ABCDEF&quot;
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;IP address       HW type     Flags       HW address&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARP_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|entry
op_assign
id|arp_tables
(braket
id|i
)braket
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
(brace
multiline_comment|/*&n; *&t;Convert hardware address to XX:XX:XX:XX ... form.&n; */
macro_line|#ifdef CONFIG_AX25
r_if
c_cond
(paren
id|entry-&gt;htype
op_eq
id|ARPHRD_AX25
)paren
(brace
id|strcpy
c_func
(paren
id|hbuffer
comma
id|ax2asc
c_func
(paren
(paren
id|ax25_address
op_star
)paren
id|entry-&gt;ha
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#endif
r_for
c_loop
(paren
id|k
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|HBUFFERLEN
op_minus
l_int|3
op_logical_and
id|j
OL
id|entry-&gt;hlen
suffix:semicolon
id|j
op_increment
)paren
(brace
id|hbuffer
(braket
id|k
op_increment
)braket
op_assign
id|hexbuf
(braket
(paren
id|entry-&gt;ha
(braket
id|j
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|15
)braket
suffix:semicolon
id|hbuffer
(braket
id|k
op_increment
)braket
op_assign
id|hexbuf
(braket
id|entry-&gt;ha
(braket
id|j
)braket
op_amp
l_int|15
)braket
suffix:semicolon
id|hbuffer
(braket
id|k
op_increment
)braket
op_assign
l_char|&squot;:&squot;
suffix:semicolon
)brace
id|hbuffer
(braket
op_decrement
id|k
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_AX25
)brace
macro_line|#endif
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%-17s0x%-10x0x%-10x%s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|entry-&gt;ip
)paren
comma
(paren
r_int
r_int
)paren
id|entry-&gt;htype
comma
id|entry-&gt;flags
comma
id|hbuffer
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start slop */
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
multiline_comment|/* Ending slop */
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This will find an entry in the ARP table by looking at the IP address.&n; *&t;Be careful, interrupts are turned off on exit!!!&n; */
DECL|function|arp_lookup
r_static
r_struct
id|arp_table
op_star
id|arp_lookup
c_func
(paren
r_int
r_int
id|paddr
)paren
(brace
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_int
r_int
id|hash
op_assign
id|HASH
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|paddr
)paren
r_break
suffix:semicolon
r_return
id|entry
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Set (create) an ARP cache entry.&n; */
DECL|function|arp_req_set
r_static
r_int
id|arp_req_set
c_func
(paren
r_struct
id|arpreq
op_star
id|req
)paren
(brace
r_struct
id|arpreq
id|r
suffix:semicolon
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|si
suffix:semicolon
r_int
id|htype
comma
id|hlen
suffix:semicolon
r_int
r_int
id|ip
comma
id|hash
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|r
comma
id|req
comma
r_sizeof
(paren
id|r
)paren
)paren
suffix:semicolon
multiline_comment|/* We only understand about IP addresses... */
r_if
c_cond
(paren
id|r.arp_pa.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EPFNOSUPPORT
suffix:semicolon
multiline_comment|/*&n;&t; * Find out about the hardware type.&n;&t; * We have to be compatible with BSD UNIX, so we have to&n;&t; * assume that a &quot;not set&quot; value (i.e. 0) means Ethernet.&n;&t; */
r_switch
c_cond
(paren
id|r.arp_ha.sa_family
)paren
(brace
r_case
id|ARPHRD_ETHER
suffix:colon
id|htype
op_assign
id|ARPHRD_ETHER
suffix:semicolon
id|hlen
op_assign
id|ETH_ALEN
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_AX25
r_case
id|ARPHRD_AX25
suffix:colon
id|htype
op_assign
id|ARPHRD_AX25
suffix:semicolon
id|hlen
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|EPFNOSUPPORT
suffix:semicolon
)brace
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r.arp_pa
suffix:semicolon
id|ip
op_assign
id|si-&gt;sin_addr.s_addr
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ARP: SETARP: requested PA is 0.0.0.0 !&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Is it reachable directly ?&n;&t; */
id|rt
op_assign
id|ip_rt_route
c_func
(paren
id|ip
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Is there an existing entry for this address?&n;&t; */
id|hash
op_assign
id|HASH
c_func
(paren
id|ip
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Find the entry&n;&t; */
r_for
c_loop
(paren
id|entry
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
r_if
c_cond
(paren
id|entry-&gt;ip
op_eq
id|ip
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Do we need to create a new entry&n;&t; */
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
(brace
id|entry
op_assign
(paren
r_struct
id|arp_table
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arp_table
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|entry-&gt;ip
op_assign
id|ip
suffix:semicolon
id|entry-&gt;hlen
op_assign
id|hlen
suffix:semicolon
id|entry-&gt;htype
op_assign
id|htype
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|entry-&gt;timer
)paren
suffix:semicolon
id|entry-&gt;next
op_assign
id|arp_tables
(braket
id|hash
)braket
suffix:semicolon
id|arp_tables
(braket
id|hash
)braket
op_assign
id|entry
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|entry-&gt;skb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|ATF_PUBL
)paren
id|proxies
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We now have a pointer to an ARP entry.  Update it!&n;&t; */
id|memcpy
c_func
(paren
op_amp
id|entry-&gt;ha
comma
op_amp
id|r.arp_ha.sa_data
comma
id|hlen
)paren
suffix:semicolon
id|entry-&gt;last_used
op_assign
id|jiffies
suffix:semicolon
id|entry-&gt;flags
op_assign
id|r.arp_flags
op_or
id|ATF_COM
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|ATF_PUBL
)paren
id|proxies
op_increment
suffix:semicolon
id|entry-&gt;dev
op_assign
id|rt-&gt;rt_dev
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get an ARP cache entry.&n; */
DECL|function|arp_req_get
r_static
r_int
id|arp_req_get
c_func
(paren
r_struct
id|arpreq
op_star
id|req
)paren
(brace
r_struct
id|arpreq
id|r
suffix:semicolon
r_struct
id|arp_table
op_star
id|entry
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|si
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We only understand about IP addresses...&n;&t; */
id|memcpy_fromfs
c_func
(paren
op_amp
id|r
comma
id|req
comma
r_sizeof
(paren
id|r
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r.arp_pa.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EPFNOSUPPORT
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Is there an existing entry for this address?&n;&t; */
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r.arp_pa
suffix:semicolon
id|entry
op_assign
id|arp_lookup
c_func
(paren
id|si-&gt;sin_addr.s_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;We found it; copy into structure.&n;&t; */
id|memcpy
c_func
(paren
id|r.arp_ha.sa_data
comma
op_amp
id|entry-&gt;ha
comma
id|entry-&gt;hlen
)paren
suffix:semicolon
id|r.arp_ha.sa_family
op_assign
id|entry-&gt;htype
suffix:semicolon
id|r.arp_flags
op_assign
id|entry-&gt;flags
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Copy the information back&n;&t; */
id|memcpy_tofs
c_func
(paren
id|req
comma
op_amp
id|r
comma
r_sizeof
(paren
id|r
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Handle an ARP layer I/O control request.&n; */
DECL|function|arp_ioctl
r_int
id|arp_ioctl
c_func
(paren
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|arpreq
id|r
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|si
suffix:semicolon
r_int
id|err
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCDARP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|r
comma
id|arg
comma
r_sizeof
(paren
id|r
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r.arp_pa.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EPFNOSUPPORT
suffix:semicolon
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r.arp_pa
suffix:semicolon
id|arp_destroy
c_func
(paren
id|si-&gt;sin_addr.s_addr
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCGARP
suffix:colon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
r_return
id|arp_req_get
c_func
(paren
(paren
r_struct
id|arpreq
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SIOCSARP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|arpreq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
r_return
id|arp_req_set
c_func
(paren
(paren
r_struct
id|arpreq
op_star
)paren
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*NOTREACHED*/
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Called once on startup.&n; */
DECL|variable|arp_packet_type
r_static
r_struct
id|packet_type
id|arp_packet_type
op_assign
(brace
l_int|0
comma
multiline_comment|/* Should be: __constant_htons(ETH_P_ARP) - but this _doesn&squot;t_ come out constant! */
l_int|0
comma
multiline_comment|/* copy */
id|arp_rcv
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|arp_init
r_void
id|arp_init
(paren
r_void
)paren
(brace
multiline_comment|/* Register the packet type */
id|arp_packet_type.type
op_assign
id|htons
c_func
(paren
id|ETH_P_ARP
)paren
suffix:semicolon
id|dev_add_pack
c_func
(paren
op_amp
id|arp_packet_type
)paren
suffix:semicolon
multiline_comment|/* Start with the regular checks for expired arp entries. */
id|add_timer
c_func
(paren
op_amp
id|arp_timer
)paren
suffix:semicolon
)brace
eof
