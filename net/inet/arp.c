multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;This file implements the Address Resolution Protocol (ARP),&n; *&t;&t;which is used by TCP/IP to map the IP addresses from a host&n; *&t;&t;to a low-level hardware address (like an Ethernet address)&n; *&t;&t;which it can use to talk to that host.&n; *&n; * NOTE:&t;This module will be rewritten completely in the near future,&n; *&t;&t;because I want it to become a multi-address-family address&n; *&t;&t;resolver, like it should be.  It will be put in a separate&n; *&t;&t;directory under &squot;net&squot;, being a protocol of its own. -FvK&n; *&n; * Version:&t;@(#)arp.c&t;1.0.15&t;05/25/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Stephen A. Wood, &lt;saw@hallc1.cebaf.gov&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@pvv.unit.no&gt;&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &quot;inet.h&quot;
macro_line|#include &quot;timer.h&quot;
macro_line|#include &quot;dev.h&quot;
macro_line|#include &quot;eth.h&quot;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;route.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &quot;skbuff.h&quot;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &quot;arp.h&quot;
DECL|macro|ARP_MAX_TRIES
mdefine_line|#define ARP_MAX_TRIES&t;3
r_static
r_char
op_star
id|unk_print
c_func
(paren
r_int
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_char
op_star
id|eth_aprint
c_func
(paren
r_int
r_char
op_star
comma
r_int
)paren
suffix:semicolon
DECL|variable|arp_cmds
r_static
r_char
op_star
id|arp_cmds
(braket
)braket
op_assign
(brace
l_string|&quot;0x%04X&quot;
comma
l_string|&quot;REQUEST&quot;
comma
l_string|&quot;REPLY&quot;
comma
l_string|&quot;REVERSE REQUEST&quot;
comma
l_string|&quot;REVERSE REPLY&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|macro|ARP_MAX_CMDS
mdefine_line|#define&t;ARP_MAX_CMDS&t;(sizeof(arp_cmds) / sizeof(arp_cmds[0]))
r_static
r_struct
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|print
r_char
op_star
(paren
op_star
id|print
)paren
(paren
r_int
r_char
op_star
id|ptr
comma
r_int
id|len
)paren
suffix:semicolon
DECL|variable|arp_types
)brace
id|arp_types
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;0x%04X&quot;
comma
id|unk_print
)brace
comma
(brace
l_string|&quot;10 Mbps Ethernet&quot;
comma
id|eth_aprint
)brace
comma
(brace
l_string|&quot;3 Mbps Ethernet&quot;
comma
id|eth_aprint
)brace
comma
(brace
l_string|&quot;AX.25&quot;
comma
id|unk_print
)brace
comma
(brace
l_string|&quot;Pronet&quot;
comma
id|unk_print
)brace
comma
(brace
l_string|&quot;Chaos&quot;
comma
id|unk_print
)brace
comma
(brace
l_string|&quot;IEEE 802.2 Ethernet (?)&quot;
comma
id|eth_aprint
)brace
comma
(brace
l_string|&quot;Arcnet&quot;
comma
id|unk_print
)brace
comma
(brace
l_string|&quot;AppleTalk&quot;
comma
id|unk_print
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|macro|ARP_MAX_TYPE
mdefine_line|#define&t;ARP_MAX_TYPE&t;(sizeof(arp_types) / sizeof(arp_types[0]))
DECL|variable|arp_table
r_struct
id|arp_table
op_star
id|arp_table
(braket
id|ARP_TABLE_SIZE
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|arp_q
r_struct
id|sk_buff
op_star
id|arp_q
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Dump the ADDRESS bytes of an unknown hardware type. */
r_static
r_char
op_star
DECL|function|unk_print
id|unk_print
c_func
(paren
r_int
r_char
op_star
id|ptr
comma
r_int
id|len
)paren
(brace
r_static
r_char
id|buff
(braket
l_int|32
)braket
suffix:semicolon
r_char
op_star
id|bufp
op_assign
id|buff
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|bufp
op_add_assign
id|sprintf
c_func
(paren
id|bufp
comma
l_string|&quot;%02X &quot;
comma
(paren
op_star
id|ptr
op_increment
op_amp
l_int|0377
)paren
)paren
suffix:semicolon
r_return
id|buff
suffix:semicolon
)brace
multiline_comment|/* Dump the ADDRESS bytes of an Ethernet hardware type. */
r_static
r_char
op_star
DECL|function|eth_aprint
id|eth_aprint
c_func
(paren
r_int
r_char
op_star
id|ptr
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_ne
id|ETH_ALEN
)paren
r_return
l_string|&quot;&quot;
suffix:semicolon
r_return
id|eth_print
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
multiline_comment|/* Dump an ARP packet. Not complete yet for non-Ethernet packets. */
r_static
r_void
DECL|function|arp_print
id|arp_print
c_func
(paren
r_struct
id|arphdr
op_star
id|arp
)paren
(brace
r_int
id|len
comma
id|idx
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|inet_debug
op_ne
id|DBG_ARP
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ARP: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arp
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(null)&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Print the opcode name. */
id|len
op_assign
id|htons
c_func
(paren
id|arp-&gt;ar_op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|ARP_MAX_CMDS
)paren
id|idx
op_assign
id|len
suffix:semicolon
r_else
id|idx
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;op &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|arp_cmds
(braket
id|idx
)braket
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Print the ARP header. */
id|len
op_assign
id|htons
c_func
(paren
id|arp-&gt;ar_hrd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|ARP_MAX_TYPE
)paren
id|idx
op_assign
id|len
suffix:semicolon
r_else
id|idx
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   hrd = &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|arp_types
(braket
id|idx
)braket
dot
id|name
comma
id|len
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   pro = 0x%04X&bslash;n&quot;
comma
id|htons
c_func
(paren
id|arp-&gt;ar_pro
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   hlen = %d plen = %d&bslash;n&quot;
comma
id|arp-&gt;ar_hln
comma
id|arp-&gt;ar_pln
)paren
suffix:semicolon
multiline_comment|/*&n;   * Print the variable data.&n;   * When ARP gets redone (after the formal introduction of NET-2),&n;   * this part will be redone.  ARP will then be a multi-family address&n;   * resolver, and the code below will be made more general. -FvK&n;   */
id|ptr
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|arp-&gt;ar_op
)paren
op_plus
r_sizeof
(paren
id|u_short
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   sender HA = %s &quot;
comma
id|arp_types
(braket
id|idx
)braket
dot
id|print
c_func
(paren
id|ptr
comma
id|arp-&gt;ar_hln
)paren
)paren
suffix:semicolon
id|ptr
op_add_assign
id|arp-&gt;ar_hln
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  PA = %s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|ptr
)paren
)paren
suffix:semicolon
id|ptr
op_add_assign
id|arp-&gt;ar_pln
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   target HA = %s &quot;
comma
id|arp_types
(braket
id|idx
)braket
dot
id|print
c_func
(paren
id|ptr
comma
id|arp-&gt;ar_hln
)paren
)paren
suffix:semicolon
id|ptr
op_add_assign
id|arp-&gt;ar_hln
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  PA = %s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|ptr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This will try to retransmit everything on the queue. */
r_static
r_void
DECL|function|arp_send_q
id|arp_send_q
c_func
(paren
r_void
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|sk_buff
op_star
id|next
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|next
op_assign
id|arp_q
suffix:semicolon
id|arp_q
op_assign
l_int|NULL
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|next
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;magic
op_ne
id|ARP_QUEUE_MAGIC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ARP: *** Bug: skb with bad magic %X: squashing queue&bslash;n&quot;
comma
id|skb-&gt;magic
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Extra consistency check. */
r_if
c_cond
(paren
id|skb-&gt;next
op_eq
l_int|NULL
macro_line|#ifdef CONFIG_MAX_16M
op_logical_or
(paren
(paren
r_int
r_int
)paren
(paren
id|skb-&gt;next
)paren
OG
l_int|16
op_star
l_int|1024
op_star
l_int|1024
)paren
macro_line|#endif
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ARP: *** Bug: bad skb-&gt;next, squashing queue&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* First remove skb from the queue. */
id|next
op_assign
id|skb-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|next
op_ne
id|skb
)paren
(brace
id|skb-&gt;prev-&gt;next
op_assign
id|next
suffix:semicolon
id|next-&gt;prev
op_assign
id|skb-&gt;prev
suffix:semicolon
)brace
r_else
(brace
id|next
op_assign
l_int|NULL
suffix:semicolon
)brace
id|skb-&gt;magic
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Decrement the &squot;tries&squot; counter. */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb-&gt;tries
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;tries
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Grmpf.&n;&t;&t; * We have tried ARP_MAX_TRIES to resolve the IP address&n;&t;&t; * from this datagram.  This means that the machine does&n;&t;&t; * not listen to our ARP requests.  Perhaps someone tur-&n;&t;&t; * ned off the thing?&n;&t;&t; * In any case, trying further is useless.  So, we kill&n;&t;&t; * this packet from the queue.  (grinnik) -FvK&n;&t;&t; */
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Can we now complete this packet? */
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;dev
op_member_access_from_pointer
id|rebuild_header
c_func
(paren
id|skb
op_plus
l_int|1
comma
id|skb-&gt;dev
)paren
)paren
(brace
multiline_comment|/* Yes, so send it out. */
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;dev
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Alas.  Re-queue it... */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb-&gt;magic
op_assign
id|ARP_QUEUE_MAGIC
suffix:semicolon
r_if
c_cond
(paren
id|arp_q
op_eq
l_int|NULL
)paren
(brace
id|skb-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev
op_assign
id|skb
suffix:semicolon
id|arp_q
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;next
op_assign
id|arp_q
suffix:semicolon
id|skb-&gt;prev
op_assign
id|arp_q-&gt;prev
suffix:semicolon
id|arp_q-&gt;prev-&gt;next
op_assign
id|skb
suffix:semicolon
id|arp_q-&gt;prev
op_assign
id|skb
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Create and send our response to an ARP request. */
r_static
r_int
DECL|function|arp_response
id|arp_response
c_func
(paren
r_struct
id|arphdr
op_star
id|arp1
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arphdr
op_star
id|arp2
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|src
comma
id|dst
suffix:semicolon
r_int
r_char
op_star
id|ptr1
comma
op_star
id|ptr2
suffix:semicolon
r_int
id|hlen
suffix:semicolon
multiline_comment|/* Get some mem and initialize it for the return trip. */
id|skb
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sk_buff
)paren
op_plus
r_sizeof
(paren
r_struct
id|arphdr
)paren
op_plus
(paren
l_int|2
op_star
id|arp1-&gt;ar_hln
)paren
op_plus
(paren
l_int|2
op_star
id|arp1-&gt;ar_pln
)paren
op_plus
id|dev-&gt;hard_header_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ARP: no memory available for ARP REPLY!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Decode the source (REQUEST) message. */
id|ptr1
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|arp1-&gt;ar_op
)paren
op_plus
r_sizeof
(paren
id|u_short
)paren
suffix:semicolon
id|src
op_assign
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|ptr1
op_plus
id|arp1-&gt;ar_hln
)paren
)paren
suffix:semicolon
id|dst
op_assign
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|ptr1
op_plus
(paren
id|arp1-&gt;ar_hln
op_star
l_int|2
)paren
op_plus
id|arp1-&gt;ar_pln
)paren
)paren
suffix:semicolon
id|skb-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;mem_addr
op_assign
id|skb
suffix:semicolon
id|skb-&gt;len
op_assign
r_sizeof
(paren
r_struct
id|arphdr
)paren
op_plus
(paren
l_int|2
op_star
id|arp1-&gt;ar_hln
)paren
op_plus
(paren
l_int|2
op_star
id|arp1-&gt;ar_pln
)paren
op_plus
id|dev-&gt;hard_header_len
suffix:semicolon
id|skb-&gt;mem_len
op_assign
r_sizeof
(paren
r_struct
id|sk_buff
)paren
op_plus
id|skb-&gt;len
suffix:semicolon
id|hlen
op_assign
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
comma
id|dev
comma
id|ETH_P_ARP
comma
id|src
comma
id|dst
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hlen
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ARP: cannot create HW frame header for REPLY !&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;   * Fill in the ARP REPLY packet.&n;   * This looks ugly, but we have to deal with the variable-length&n;   * ARP packets and such.  It is not as bad as it looks- FvK&n;   */
id|arp2
op_assign
(paren
r_struct
id|arphdr
op_star
)paren
(paren
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
op_plus
id|hlen
)paren
suffix:semicolon
id|ptr2
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|arp2-&gt;ar_op
)paren
op_plus
r_sizeof
(paren
id|u_short
)paren
suffix:semicolon
id|arp2-&gt;ar_hrd
op_assign
id|arp1-&gt;ar_hrd
suffix:semicolon
id|arp2-&gt;ar_pro
op_assign
id|arp1-&gt;ar_pro
suffix:semicolon
id|arp2-&gt;ar_hln
op_assign
id|arp1-&gt;ar_hln
suffix:semicolon
id|arp2-&gt;ar_pln
op_assign
id|arp1-&gt;ar_pln
suffix:semicolon
id|arp2-&gt;ar_op
op_assign
id|htons
c_func
(paren
id|ARPOP_REPLY
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr2
comma
id|dev-&gt;dev_addr
comma
id|arp2-&gt;ar_hln
)paren
suffix:semicolon
id|ptr2
op_add_assign
id|arp2-&gt;ar_hln
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr2
comma
id|ptr1
op_plus
(paren
id|arp1-&gt;ar_hln
op_star
l_int|2
)paren
op_plus
id|arp1-&gt;ar_pln
comma
id|arp2-&gt;ar_pln
)paren
suffix:semicolon
id|ptr2
op_add_assign
id|arp2-&gt;ar_pln
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr2
comma
id|ptr1
comma
id|arp2-&gt;ar_hln
)paren
suffix:semicolon
id|ptr2
op_add_assign
id|arp2-&gt;ar_hln
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr2
comma
id|ptr1
op_plus
id|arp1-&gt;ar_hln
comma
id|arp2-&gt;ar_pln
)paren
suffix:semicolon
id|skb-&gt;free
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;&gt;&gt;&quot;
)paren
)paren
suffix:semicolon
id|arp_print
c_func
(paren
id|arp2
)paren
suffix:semicolon
multiline_comment|/* Queue the packet for transmission. */
id|dev
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This will find an entry in the ARP table by looking at the IP address. */
r_static
r_struct
id|arp_table
op_star
DECL|function|arp_lookup
id|arp_lookup
c_func
(paren
r_int
r_int
id|paddr
)paren
(brace
r_struct
id|arp_table
op_star
id|apt
suffix:semicolon
r_int
r_int
id|hash
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;ARP: lookup(%s)&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|paddr
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t want to ARP ourselves. */
r_if
c_cond
(paren
id|chk_addr
c_func
(paren
id|paddr
)paren
op_eq
id|IS_MYADDR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ARP: ARPing my own IP address %s !&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|paddr
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Loop through the table for the desired address. */
id|hash
op_assign
id|htonl
c_func
(paren
id|paddr
)paren
op_amp
(paren
id|ARP_TABLE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|apt
op_assign
id|arp_table
(braket
id|hash
)braket
suffix:semicolon
r_while
c_loop
(paren
id|apt
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|apt-&gt;ip
op_eq
id|paddr
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|apt
suffix:semicolon
)brace
id|apt
op_assign
id|apt-&gt;next
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Delete an ARP mapping entry in the cache. */
r_void
DECL|function|arp_destroy
id|arp_destroy
c_func
(paren
r_int
r_int
id|paddr
)paren
(brace
r_struct
id|arp_table
op_star
id|apt
suffix:semicolon
r_struct
id|arp_table
op_star
op_star
id|lapt
suffix:semicolon
r_int
r_int
id|hash
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;ARP: destroy(%s)&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|paddr
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* We cannot destroy our own ARP entry. */
r_if
c_cond
(paren
id|chk_addr
c_func
(paren
id|paddr
)paren
op_eq
id|IS_MYADDR
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;ARP: Destroying my own IP address %s !&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|paddr
)paren
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|hash
op_assign
id|htonl
c_func
(paren
id|paddr
)paren
op_amp
(paren
id|ARP_TABLE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|lapt
op_assign
op_amp
id|arp_table
(braket
id|hash
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|apt
op_assign
op_star
id|lapt
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|apt-&gt;ip
op_eq
id|paddr
)paren
(brace
op_star
id|lapt
op_assign
id|apt-&gt;next
suffix:semicolon
id|kfree_s
c_func
(paren
id|apt
comma
r_sizeof
(paren
r_struct
id|arp_table
)paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lapt
op_assign
op_amp
id|apt-&gt;next
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Create an ARP entry.  The caller should check for duplicates! */
r_static
r_struct
id|arp_table
op_star
DECL|function|arp_create
id|arp_create
c_func
(paren
r_int
r_int
id|paddr
comma
r_int
r_char
op_star
id|addr
comma
r_int
id|hlen
comma
r_int
id|htype
)paren
(brace
r_struct
id|arp_table
op_star
id|apt
suffix:semicolon
r_int
r_int
id|hash
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;ARP: create(%s, &quot;
comma
id|in_ntoa
c_func
(paren
id|paddr
)paren
)paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;%s, &quot;
comma
id|eth_print
c_func
(paren
id|addr
)paren
)paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;%d, %d)&bslash;n&quot;
comma
id|hlen
comma
id|htype
)paren
)paren
suffix:semicolon
id|apt
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|arp_table
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|apt
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ARP: no memory available for new ARP entry!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Fill in the allocated ARP cache entry. */
id|hash
op_assign
id|htonl
c_func
(paren
id|paddr
)paren
op_amp
(paren
id|ARP_TABLE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|apt-&gt;ip
op_assign
id|paddr
suffix:semicolon
id|apt-&gt;hlen
op_assign
id|hlen
suffix:semicolon
id|apt-&gt;htype
op_assign
id|htype
suffix:semicolon
id|apt-&gt;flags
op_assign
(paren
id|ATF_INUSE
op_or
id|ATF_COM
)paren
suffix:semicolon
multiline_comment|/* USED and COMPLETED entry */
id|memcpy
c_func
(paren
id|apt-&gt;ha
comma
id|addr
comma
id|hlen
)paren
suffix:semicolon
id|apt-&gt;last_used
op_assign
id|timer_seq
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|apt-&gt;next
op_assign
id|arp_table
(braket
id|hash
)braket
suffix:semicolon
id|arp_table
(braket
id|hash
)braket
op_assign
id|apt
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|apt
suffix:semicolon
)brace
multiline_comment|/*&n; * An ARP REQUEST packet has arrived.&n; * We try to be smart here, and fetch the data of the sender of the&n; * packet- we might need it later, so fetching it now can save us a&n; * broadcast later.&n; * Then, if the packet was meant for us (i.e. the TARGET address was&n; * one of our own IP addresses), we set up and send out an ARP REPLY&n; * packet to the sender.&n; */
r_int
DECL|function|arp_rcv
id|arp_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|arphdr
op_star
id|arp
suffix:semicolon
r_struct
id|arp_table
op_star
id|tbl
suffix:semicolon
r_int
r_int
id|src
comma
id|dst
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;&lt;&lt;&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|arp
op_assign
id|skb-&gt;h.arp
suffix:semicolon
id|arp_print
c_func
(paren
id|arp
)paren
suffix:semicolon
multiline_comment|/* If this test doesn&squot;t pass, something fishy is going on. */
r_if
c_cond
(paren
id|arp-&gt;ar_hln
op_ne
id|dev-&gt;addr_len
op_logical_or
id|dev-&gt;type
op_ne
id|NET16
c_func
(paren
id|arp-&gt;ar_hrd
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ARP: Bad packet received on device &bslash;&quot;%s&bslash;&quot; !&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* For now we will only deal with IP addresses. */
r_if
c_cond
(paren
id|arp-&gt;ar_pro
op_ne
id|NET16
c_func
(paren
id|ETH_P_IP
)paren
op_logical_or
id|arp-&gt;ar_pln
op_ne
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|arp-&gt;ar_op
op_ne
id|NET16
c_func
(paren
id|ARPOP_REQUEST
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;ARP: Non-IP request on device &bslash;&quot;%s&bslash;&quot; !&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;   * As said before, we try to be smart by using the&n;   * info already present in the packet: the sender&squot;s&n;   * IP and hardware address.&n;   */
id|ptr
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|arp-&gt;ar_op
)paren
op_plus
r_sizeof
(paren
id|u_short
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|src
comma
id|ptr
op_plus
id|arp-&gt;ar_hln
comma
id|arp-&gt;ar_pln
)paren
suffix:semicolon
id|tbl
op_assign
id|arp_lookup
c_func
(paren
id|src
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbl
op_ne
l_int|NULL
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;ARP: udating entry for %s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|src
)paren
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tbl-&gt;ha
comma
id|ptr
comma
id|arp-&gt;ar_hln
)paren
suffix:semicolon
id|tbl-&gt;hlen
op_assign
id|arp-&gt;ar_hln
suffix:semicolon
id|tbl-&gt;flags
op_or_assign
id|ATF_COM
suffix:semicolon
id|tbl-&gt;last_used
op_assign
id|timer_seq
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
op_amp
id|dst
comma
id|ptr
op_plus
(paren
id|arp-&gt;ar_hln
op_star
l_int|2
)paren
op_plus
id|arp-&gt;ar_pln
comma
id|arp-&gt;ar_pln
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chk_addr
c_func
(paren
id|dst
)paren
op_ne
id|IS_MYADDR
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|tbl
op_assign
id|arp_create
c_func
(paren
id|src
comma
id|ptr
comma
id|arp-&gt;ar_hln
comma
id|arp-&gt;ar_hrd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbl
op_eq
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;   * Since we updated the ARP cache, we might have enough&n;   * information to send out some previously queued IP&n;   * datagrams....&n;   */
id|arp_send_q
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;   * OK, we used that part of the info.  Now check if the&n;   * request was an ARP REQUEST for one of our own addresses...&n;   */
r_if
c_cond
(paren
id|arp-&gt;ar_op
op_ne
id|NET16
c_func
(paren
id|ARPOP_REQUEST
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|dst
comma
id|ptr
op_plus
(paren
id|arp-&gt;ar_hln
op_star
l_int|2
)paren
op_plus
id|arp-&gt;ar_pln
comma
id|arp-&gt;ar_pln
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chk_addr
c_func
(paren
id|dst
)paren
op_ne
id|IS_MYADDR
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;ARP: request was not for me!&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;   * Yes, it is for us.&n;   * Allocate, fill in and send an ARP REPLY packet.&n;   */
id|ret
op_assign
id|arp_response
c_func
(paren
id|arp
comma
id|dev
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Create and send an ARP REQUEST packet. */
r_void
DECL|function|arp_send
id|arp_send
c_func
(paren
r_int
r_int
id|paddr
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|saddr
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|arphdr
op_star
id|arp
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;ARP: send(paddr=%s, &quot;
comma
id|in_ntoa
c_func
(paren
id|paddr
)paren
)paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;dev=%s, &quot;
comma
id|dev-&gt;name
)paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;saddr=%s)&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|saddr
)paren
)paren
)paren
suffix:semicolon
id|skb
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sk_buff
)paren
op_plus
r_sizeof
(paren
r_struct
id|arphdr
)paren
op_plus
(paren
l_int|2
op_star
id|dev-&gt;addr_len
)paren
op_plus
(paren
l_int|2
op_star
l_int|4
multiline_comment|/* arp-&gt;plen */
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ARP: No memory available for REQUEST %s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|paddr
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Fill in the request. */
id|skb-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;mem_addr
op_assign
id|skb
suffix:semicolon
id|skb-&gt;len
op_assign
r_sizeof
(paren
r_struct
id|arphdr
)paren
op_plus
id|dev-&gt;hard_header_len
op_plus
(paren
l_int|2
op_star
id|dev-&gt;addr_len
)paren
op_plus
l_int|8
suffix:semicolon
id|skb-&gt;mem_len
op_assign
r_sizeof
(paren
r_struct
id|sk_buff
)paren
op_plus
id|skb-&gt;len
suffix:semicolon
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|tmp
op_assign
id|dev
op_member_access_from_pointer
id|hard_header
c_func
(paren
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
comma
id|dev
comma
id|ETH_P_ARP
comma
l_int|0
comma
id|saddr
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|kfree_s
c_func
(paren
id|skb-&gt;mem_addr
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|arp
op_assign
(paren
r_struct
id|arphdr
op_star
)paren
(paren
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
op_plus
id|tmp
)paren
suffix:semicolon
id|arp-&gt;ar_hrd
op_assign
id|htons
c_func
(paren
id|dev-&gt;type
)paren
suffix:semicolon
id|arp-&gt;ar_pro
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
id|arp-&gt;ar_hln
op_assign
id|dev-&gt;addr_len
suffix:semicolon
id|arp-&gt;ar_pln
op_assign
l_int|4
suffix:semicolon
id|arp-&gt;ar_op
op_assign
id|htons
c_func
(paren
id|ARPOP_REQUEST
)paren
suffix:semicolon
id|ptr
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|arp-&gt;ar_op
)paren
op_plus
r_sizeof
(paren
id|u_short
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
comma
id|dev-&gt;dev_addr
comma
id|arp-&gt;ar_hln
)paren
suffix:semicolon
id|ptr
op_add_assign
id|arp-&gt;ar_hln
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
comma
op_amp
id|saddr
comma
id|arp-&gt;ar_pln
)paren
suffix:semicolon
id|ptr
op_add_assign
id|arp-&gt;ar_pln
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
comma
id|dev-&gt;broadcast
comma
id|arp-&gt;ar_hln
)paren
suffix:semicolon
id|ptr
op_add_assign
id|arp-&gt;ar_hln
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
comma
op_amp
id|paddr
comma
id|arp-&gt;ar_pln
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;&gt;&gt;&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|arp_print
c_func
(paren
id|arp
)paren
suffix:semicolon
id|dev
op_member_access_from_pointer
id|queue_xmit
c_func
(paren
id|skb
comma
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Find an ARP mapping in the cache. If not found, post a REQUEST. */
r_int
DECL|function|arp_find
id|arp_find
c_func
(paren
r_int
r_char
op_star
id|haddr
comma
r_int
r_int
id|paddr
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|saddr
)paren
(brace
r_struct
id|arp_table
op_star
id|apt
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;ARP: find(haddr=%s, &quot;
comma
id|eth_print
c_func
(paren
id|haddr
)paren
)paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;paddr=%s, &quot;
comma
id|in_ntoa
c_func
(paren
id|paddr
)paren
)paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;dev=%s, saddr=%s)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|in_ntoa
c_func
(paren
id|saddr
)paren
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|chk_addr
c_func
(paren
id|paddr
)paren
)paren
(brace
r_case
id|IS_MYADDR
suffix:colon
id|memcpy
c_func
(paren
id|haddr
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|IS_BROADCAST
suffix:colon
id|memcpy
c_func
(paren
id|haddr
comma
id|dev-&gt;broadcast
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|apt
op_assign
id|arp_lookup
c_func
(paren
id|paddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|apt
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t; * Make sure it&squot;s not too old. If it is too old, we will&n;&t; * just pretend we did not find it, and then arp_send will&n;&t; * verify the address for us.&n;&t; */
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|apt-&gt;flags
op_amp
id|ATF_PERM
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|before
c_func
(paren
id|apt-&gt;last_used
comma
id|timer_seq
op_plus
id|ARP_TIMEOUT
)paren
op_logical_and
id|apt-&gt;hlen
op_ne
l_int|0
)paren
)paren
(brace
id|apt-&gt;last_used
op_assign
id|timer_seq
suffix:semicolon
id|memcpy
c_func
(paren
id|haddr
comma
id|apt-&gt;ha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;ARP: find: found expired entry for %s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|apt-&gt;ip
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * This assume haddr are at least 4 bytes.&n;   * If this isn&squot;t true we can use a lookup table, one for every dev.&n;   * NOTE: this bit of code still looks fishy to me- FvK&n;   */
op_star
(paren
r_int
r_int
op_star
)paren
id|haddr
op_assign
id|paddr
suffix:semicolon
multiline_comment|/* If we didn&squot;t find an entry, we will try to send an ARP packet. */
id|arp_send
c_func
(paren
id|paddr
comma
id|dev
comma
id|saddr
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Add an entry to the ARP cache.  Check for dupes! */
r_void
DECL|function|arp_add
id|arp_add
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_char
op_star
id|haddr
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arp_table
op_star
id|apt
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;ARP: add(%s, &quot;
comma
id|in_ntoa
c_func
(paren
id|addr
)paren
)paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;%s, &quot;
comma
id|eth_print
c_func
(paren
id|haddr
)paren
)paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;%d, %d)&bslash;n&quot;
comma
id|dev-&gt;hard_header_len
comma
id|dev-&gt;type
)paren
)paren
suffix:semicolon
multiline_comment|/* This is probably a good check... */
r_if
c_cond
(paren
id|addr
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ARP: add: will not add entry for 0.0.0.0 !&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* First see if the address is already in the table. */
id|apt
op_assign
id|arp_lookup
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|apt
op_ne
l_int|NULL
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_ARP
comma
l_string|&quot;ARP: updating entry for %s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|addr
)paren
)paren
)paren
suffix:semicolon
id|apt-&gt;last_used
op_assign
id|timer_seq
suffix:semicolon
id|memcpy
c_func
(paren
id|apt-&gt;ha
comma
id|haddr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|arp_create
c_func
(paren
id|addr
comma
id|haddr
comma
id|dev-&gt;addr_len
comma
id|dev-&gt;type
)paren
suffix:semicolon
)brace
multiline_comment|/* Create an ARP entry for a device&squot;s broadcast address. */
r_void
DECL|function|arp_add_broad
id|arp_add_broad
c_func
(paren
r_int
r_int
id|addr
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|arp_table
op_star
id|apt
suffix:semicolon
id|arp_add
c_func
(paren
id|addr
comma
id|dev-&gt;broadcast
comma
id|dev
)paren
suffix:semicolon
id|apt
op_assign
id|arp_lookup
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|apt
op_ne
l_int|NULL
)paren
(brace
id|apt-&gt;flags
op_or_assign
id|ATF_PERM
suffix:semicolon
)brace
)brace
multiline_comment|/* Queue an IP packet, while waiting for the ARP reply packet. */
r_void
DECL|function|arp_queue
id|arp_queue
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb-&gt;tries
op_assign
id|ARP_MAX_TRIES
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ARP: arp_queue skb already on queue magic=%X.&bslash;n&quot;
comma
id|skb-&gt;magic
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arp_q
op_eq
l_int|NULL
)paren
(brace
id|arp_q
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;next
op_assign
id|arp_q
suffix:semicolon
id|skb-&gt;prev
op_assign
id|arp_q-&gt;prev
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb
suffix:semicolon
)brace
id|skb-&gt;magic
op_assign
id|ARP_QUEUE_MAGIC
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write the contents of the ARP cache to a PROCfs file.&n; * This is not by long perfect, as the internal ARP table doesn&squot;t&n; * have all the info we would like to have.  Oh well, it works for&n; * now, eh? - FvK&n; * Also note, that due to space limits, we cannot generate more than&n; * 4Kbyte worth of data.  This usually is enough, but I have seen&n; * machines die from under me because of a *very* large ARP cache.&n; * This can be simply tested by doing:&n; *&n; *&t;# ping 255.255.255.255&n; *&t;# arp -a&n; *&n; * Perhaps we should redo PROCfs to handle larger buffers?  Michael?&n; */
r_int
DECL|function|arp_get_info
id|arp_get_info
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_struct
id|arpreq
op_star
id|req
suffix:semicolon
r_struct
id|arp_table
op_star
id|apt
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
op_star
id|pos
suffix:semicolon
multiline_comment|/* Loop over the ARP table and copy structures to the buffer. */
id|pos
op_assign
id|buffer
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARP_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|apt
op_assign
id|arp_table
(braket
id|i
)braket
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|apt
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|pos
OL
(paren
id|buffer
op_plus
l_int|4000
)paren
)paren
(brace
id|req
op_assign
(paren
r_struct
id|arpreq
op_star
)paren
id|pos
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|req
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|arpreq
)paren
)paren
suffix:semicolon
id|req-&gt;arp_pa.sa_family
op_assign
id|AF_INET
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|req-&gt;arp_pa.sa_data
comma
(paren
r_char
op_star
)paren
op_amp
id|apt-&gt;ip
comma
l_int|4
)paren
suffix:semicolon
id|req-&gt;arp_ha.sa_family
op_assign
id|apt-&gt;htype
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|req-&gt;arp_ha.sa_data
comma
(paren
r_char
op_star
)paren
op_amp
id|apt-&gt;ha
comma
id|apt-&gt;hlen
)paren
suffix:semicolon
)brace
id|pos
op_add_assign
r_sizeof
(paren
r_struct
id|arpreq
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|apt
op_assign
id|apt-&gt;next
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|pos
op_minus
id|buffer
suffix:semicolon
)brace
multiline_comment|/* Set (create) an ARP cache entry. */
r_static
r_int
DECL|function|arp_req_set
id|arp_req_set
c_func
(paren
r_struct
id|arpreq
op_star
id|req
)paren
(brace
r_struct
id|arpreq
id|r
suffix:semicolon
r_struct
id|arp_table
op_star
id|apt
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|si
suffix:semicolon
r_int
id|htype
comma
id|hlen
suffix:semicolon
multiline_comment|/* We only understand about IP addresses... */
id|memcpy_fromfs
c_func
(paren
op_amp
id|r
comma
id|req
comma
r_sizeof
(paren
id|r
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r.arp_pa.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EPFNOSUPPORT
suffix:semicolon
multiline_comment|/*&n;   * Find out about the hardware type.&n;   * We have to be compatible with BSD UNIX, so we have to&n;   * assume that a &quot;not set&quot; value (i.e. 0) means Ethernet.&n;   */
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r.arp_pa
suffix:semicolon
r_switch
c_cond
(paren
id|r.arp_ha.sa_family
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
id|ARPHRD_ETHER
suffix:colon
id|htype
op_assign
id|ARPHRD_ETHER
suffix:semicolon
id|hlen
op_assign
id|ETH_ALEN
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EPFNOSUPPORT
suffix:semicolon
)brace
multiline_comment|/* Is there an existing entry for this address? */
r_if
c_cond
(paren
id|si-&gt;sin_addr.s_addr
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ARP: SETARP: requested PA is 0.0.0.0 !&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|apt
op_assign
id|arp_lookup
c_func
(paren
id|si-&gt;sin_addr.s_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|apt
op_eq
l_int|NULL
)paren
(brace
id|apt
op_assign
id|arp_create
c_func
(paren
id|si-&gt;sin_addr.s_addr
comma
id|r.arp_ha.sa_data
comma
id|hlen
comma
id|htype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|apt
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* We now have a pointer to an ARP entry.  Update it! */
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|apt-&gt;ha
comma
(paren
r_char
op_star
)paren
op_amp
id|r.arp_ha.sa_data
comma
id|hlen
)paren
suffix:semicolon
id|apt-&gt;last_used
op_assign
id|timer_seq
suffix:semicolon
id|apt-&gt;flags
op_assign
id|r.arp_flags
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get an ARP cache entry. */
r_static
r_int
DECL|function|arp_req_get
id|arp_req_get
c_func
(paren
r_struct
id|arpreq
op_star
id|req
)paren
(brace
r_struct
id|arpreq
id|r
suffix:semicolon
r_struct
id|arp_table
op_star
id|apt
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|si
suffix:semicolon
multiline_comment|/* We only understand about IP addresses... */
id|memcpy_fromfs
c_func
(paren
op_amp
id|r
comma
id|req
comma
r_sizeof
(paren
id|r
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r.arp_pa.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EPFNOSUPPORT
suffix:semicolon
multiline_comment|/* Is there an existing entry for this address? */
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r.arp_pa
suffix:semicolon
id|apt
op_assign
id|arp_lookup
c_func
(paren
id|si-&gt;sin_addr.s_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|apt
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* We found it; copy into structure. */
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|r.arp_ha.sa_data
comma
(paren
r_char
op_star
)paren
op_amp
id|apt-&gt;ha
comma
id|apt-&gt;hlen
)paren
suffix:semicolon
id|r.arp_ha.sa_family
op_assign
id|apt-&gt;htype
suffix:semicolon
multiline_comment|/* Copy the information back */
id|memcpy_tofs
c_func
(paren
id|req
comma
op_amp
id|r
comma
r_sizeof
(paren
id|r
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Delete an ARP cache entry. */
r_static
r_int
DECL|function|arp_req_del
id|arp_req_del
c_func
(paren
r_struct
id|arpreq
op_star
id|req
)paren
(brace
r_struct
id|arpreq
id|r
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|si
suffix:semicolon
multiline_comment|/* We only understand about IP addresses... */
id|memcpy_fromfs
c_func
(paren
op_amp
id|r
comma
id|req
comma
r_sizeof
(paren
id|r
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r.arp_pa.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EPFNOSUPPORT
suffix:semicolon
id|si
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r.arp_pa
suffix:semicolon
id|arp_destroy
c_func
(paren
id|si-&gt;sin_addr.s_addr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Handle an ARP layer I/O control request. */
r_int
DECL|function|arp_ioctl
id|arp_ioctl
c_func
(paren
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|DDIOCSDBG
suffix:colon
r_return
id|dbg_ioctl
c_func
(paren
id|arg
comma
id|DBG_ARP
)paren
suffix:semicolon
r_case
id|SIOCDARP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_return
id|arp_req_del
c_func
(paren
(paren
r_struct
id|arpreq
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SIOCGARP
suffix:colon
r_return
id|arp_req_get
c_func
(paren
(paren
r_struct
id|arpreq
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SIOCSARP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_return
id|arp_req_set
c_func
(paren
(paren
r_struct
id|arpreq
op_star
)paren
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*NOTREACHED*/
r_return
l_int|0
suffix:semicolon
)brace
eof
