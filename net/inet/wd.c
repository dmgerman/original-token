multiline_comment|/* wd.c: A WD80x3 ethernet driver for linux. */
multiline_comment|/*&n;    Written 1993 by Donald Becker.&n;    Copyright 1993 United States Government as represented by the&n;    Director, National Security Agency.  This software may be used and&n;    distributed according to the terms of the GNU Public License,&n;    incorporated herein by reference.&n;    &n;    This is a driver for the WD8003 and WD8013 ethercards.&n;&n;    The Author may be reached as becker@super.org or&n;    C/O Supercomputing Research Ctr., 17100 Science Dr., Bowie MD 20715&n;&n;    Thanks to Russ Nelson (nelson@crnwyr.com) for loaning me a WD8013.&n;*/
DECL|variable|version
r_static
r_char
op_star
id|version
op_assign
l_string|&quot;wd.c:v0.99-10 5/28/93 Donald Becker (becker@super.org)&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;memory.h&gt;
macro_line|#include &quot;dev.h&quot;
macro_line|#include &quot;8390.h&quot;
r_extern
r_void
id|NS8390_init
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|startp
)paren
suffix:semicolon
r_extern
r_int
id|ei_debug
suffix:semicolon
r_extern
r_struct
id|sigaction
id|ei_sigaction
suffix:semicolon
r_int
id|wdprobe
c_func
(paren
r_int
id|ioaddr
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_int
id|wdprobe1
c_func
(paren
r_int
id|ioaddr
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|wd_reset_8390
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|wd_block_input
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|count
comma
r_char
op_star
id|buf
comma
r_int
id|ring_offset
)paren
suffix:semicolon
r_static
r_void
id|wd_block_output
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|count
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_const
id|start_page
)paren
suffix:semicolon
r_static
r_int
id|wd_close_card
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
"&f;"
DECL|macro|WD_START_PG
mdefine_line|#define WD_START_PG&t;0x00&t;/* First page of TX buffer */
DECL|macro|WD03_STOP_PG
mdefine_line|#define WD03_STOP_PG&t;0x20&t;/* Last page +1 of RX ring */
DECL|macro|WD13_STOP_PG
mdefine_line|#define WD13_STOP_PG&t;0x40&t;/* Last page +1 of RX ring */
DECL|macro|WD_CMDREG
mdefine_line|#define WD_CMDREG&t;0&t;/* Offset to ASIC command register. */
DECL|macro|WD_RESET
mdefine_line|#define  WD_RESET&t;0x80&t;/* Board reset, in WD_CMDREG. */
DECL|macro|WD_MEMENB
mdefine_line|#define  WD_MEMENB&t;0x40&t;/* Enable the shared memory. */
DECL|macro|WD_CMDREG5
mdefine_line|#define WD_CMDREG5&t;5&t;/* Offset to 16-bit-only ASIC register 5. */
DECL|macro|ISA16
mdefine_line|#define  ISA16&t;&t;0x80&t;/* Enable 16 bit access from the ISA bus. */
DECL|macro|NIC16
mdefine_line|#define  NIC16&t;&t;0x40&t;/* Enable 16 bit access from the 8390. */
DECL|macro|WD_NIC_OFFSET
mdefine_line|#define WD_NIC_OFFSET&t;16&t;/* Offset to the 8390 NIC from the base_addr. */
"&f;"
multiline_comment|/*  Probe for the WD8003 and WD8013.  These cards have the station&n;    address PROM at I/O ports &lt;base&gt;+8 to &lt;base&gt;+13, with a checksum&n;    following. A Soundblaster can have the same checksum as an WDethercard,&n;    so we have an extra exclusionary check for it.&n;&n;    The wdprobe1() routine initializes the card and fills the&n;    station address field. */
DECL|function|wdprobe
r_int
id|wdprobe
c_func
(paren
r_int
id|ioaddr
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
op_star
id|port
comma
id|ports
(braket
)braket
op_assign
(brace
l_int|0x300
comma
l_int|0x280
comma
l_int|0x380
comma
l_int|0x240
comma
l_int|0
)brace
suffix:semicolon
r_if
c_cond
(paren
id|ioaddr
OG
l_int|0x100
)paren
r_return
id|wdprobe1
c_func
(paren
id|ioaddr
comma
id|dev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
op_amp
id|ports
(braket
l_int|0
)braket
suffix:semicolon
op_star
id|port
suffix:semicolon
id|port
op_increment
)paren
r_if
c_cond
(paren
id|inb
c_func
(paren
op_star
id|port
op_plus
l_int|8
)paren
op_ne
l_int|0xff
op_logical_and
id|inb
c_func
(paren
op_star
id|port
op_plus
l_int|9
)paren
op_ne
l_int|0xff
multiline_comment|/* Extra check to avoid soundcard. */
op_logical_and
id|wdprobe1
c_func
(paren
op_star
id|port
comma
id|dev
)paren
)paren
r_return
op_star
id|port
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|wdprobe1
r_int
id|wdprobe1
c_func
(paren
r_int
id|ioaddr
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
op_star
id|station_addr
op_assign
id|dev-&gt;dev_addr
suffix:semicolon
r_int
id|checksum
op_assign
l_int|0
suffix:semicolon
r_int
id|ancient
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* An old card without config registers. */
macro_line|#if defined(EI_DEBUG) &amp;&amp; EI_DEBUG &gt; 2
id|printk
c_func
(paren
l_string|&quot;WD80x3 ethercard at %#3x:&quot;
comma
id|ioaddr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %2.2X&quot;
comma
id|inb
c_func
(paren
id|ioaddr
op_plus
id|i
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;WD80x3 ethercard at %#3x:&quot;
comma
id|ioaddr
op_plus
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|33
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %2.2X&quot;
comma
id|inb
c_func
(paren
id|ioaddr
op_plus
id|i
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;WD80x3 ethercard probe at %#3x:&quot;
comma
id|ioaddr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|inval
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|8
op_plus
id|i
)paren
suffix:semicolon
id|checksum
op_add_assign
id|inval
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|6
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2X&quot;
comma
(paren
id|station_addr
(braket
id|i
)braket
op_assign
id|inval
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|checksum
op_amp
l_int|0xff
)paren
op_ne
l_int|0xFF
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; not found (%#2.2x).&bslash;n&quot;
comma
id|checksum
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ei_status.name
op_assign
l_string|&quot;WD8003&quot;
suffix:semicolon
id|ei_status.word16
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The following PureData probe code was contributed by&n;     Mike Jagdis &lt;jaggy@purplet.demon.co.uk&gt;. */
multiline_comment|/* Puredata seem to do software configuration differently from&n;   * others so we have to check for them.&n;   */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|0
)paren
op_eq
l_char|&squot;P&squot;
op_logical_and
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|1
)paren
op_eq
l_char|&squot;D&squot;
)paren
(brace
id|ei_status.name
op_assign
l_string|&quot;PDI8023&quot;
suffix:semicolon
multiline_comment|/* We can also check whether it is an 8 bit (-8), 16 bit (-16)&n;       * or dumb (Toshiba) card. The Toshiba version doesn&squot;t support&n;       * anything except jumper configuration.&n;       */
r_switch
c_cond
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|2
)paren
)paren
(brace
r_case
l_int|0x03
suffix:colon
id|ei_status.word16
op_assign
l_int|0
suffix:semicolon
id|ei_status.name
op_assign
l_string|&quot;PDI8023-8&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x05
suffix:colon
multiline_comment|/* Not sure really... */
id|ei_status.word16
op_assign
l_int|0
suffix:semicolon
id|ei_status.name
op_assign
l_string|&quot;PDUC8023&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0a
suffix:colon
id|ei_status.word16
op_assign
l_int|1
suffix:semicolon
id|ei_status.name
op_assign
l_string|&quot;PDI8023-16&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Either 0x01 (dumb) or they&squot;ve released a new version. */
id|ei_status.word16
op_assign
l_int|0
suffix:semicolon
id|ei_status.name
op_assign
l_string|&quot;PDI8023&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dev-&gt;mem_start
op_assign
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|5
)paren
op_amp
l_int|0x1c
)paren
op_plus
l_int|0xc0
)paren
op_lshift
l_int|12
suffix:semicolon
id|dev-&gt;irq
op_assign
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|5
)paren
op_rshift
l_int|5
)paren
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|7
)paren
id|dev-&gt;irq
op_assign
l_int|10
suffix:semicolon
r_else
id|dev-&gt;irq
op_increment
suffix:semicolon
)brace
multiline_comment|/* End of PureData probe */
multiline_comment|/* This method of checking for a 16-bit board is borrowed from the&n;     we.c driver.  A simpler method is just to look in ASIC reg. 0x03.&n;     I&squot;m comparing the two method in alpha test to make certain they&n;     return the same result. */
macro_line|#ifndef FORCE_8BIT&t;&t;/* Same define as we.c. */
multiline_comment|/* Check for 16 bit board - it doesn&squot;t have register 0/8 aliasing.&n;     Do NOT check i&gt;=6 here -- it hangs some old 8003 boards! */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|i
)paren
op_ne
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|8
op_plus
id|i
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
l_int|6
)paren
(brace
id|ancient
op_assign
l_int|1
suffix:semicolon
id|ei_status.name
op_assign
l_string|&quot;WD8003-old&quot;
suffix:semicolon
)brace
r_else
(brace
r_int
id|tmp
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* fiddle with 16bit bit */
id|outb
c_func
(paren
id|tmp
op_xor
l_int|0x01
comma
id|ioaddr
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* attempt to clear 16bit bit */
r_if
c_cond
(paren
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|1
)paren
op_amp
l_int|0x01
)paren
op_eq
l_int|0x01
)paren
multiline_comment|/* A 16 bit card */
op_logical_and
(paren
id|tmp
op_amp
l_int|0x01
)paren
op_eq
l_int|0x01
)paren
(brace
multiline_comment|/* In a 16 slot. */
r_int
id|asic_reg5
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|WD_CMDREG5
)paren
suffix:semicolon
multiline_comment|/* Magic to set ASIC to word-wide mode. */
id|outb
c_func
(paren
id|ISA16
op_or
id|NIC16
op_or
(paren
id|asic_reg5
op_amp
l_int|0x1f
)paren
comma
id|ioaddr
op_plus
id|WD_CMDREG5
)paren
suffix:semicolon
id|outb
c_func
(paren
id|tmp
comma
id|ioaddr
op_plus
l_int|1
)paren
suffix:semicolon
id|ei_status.name
op_assign
l_string|&quot;WD8013&quot;
suffix:semicolon
id|ei_status.word16
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* We have a 16bit board here! */
)brace
id|outb
c_func
(paren
id|tmp
comma
id|ioaddr
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Restore original reg1 value. */
)brace
macro_line|#endif /* not FORCE_8BIT */
macro_line|#ifndef final_version
r_if
c_cond
(paren
op_logical_neg
id|ancient
op_logical_and
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|1
)paren
op_amp
l_int|0x01
)paren
op_ne
(paren
id|ei_status.word16
op_amp
l_int|0x01
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;nWD80?3: Bus width conflict, %d (probe) != %d (reg report).&quot;
comma
id|ei_status.word16
ques
c_cond
l_int|16
suffix:colon
l_int|8
comma
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|1
)paren
op_amp
l_int|0x01
)paren
ques
c_cond
l_int|16
suffix:colon
l_int|8
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(WD_SHMEM) &amp;&amp; WD_SHMEM &gt; 0x80000
multiline_comment|/* Allow an override.  */
id|dev-&gt;mem_start
op_assign
id|WD_SHMEM
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|dev-&gt;mem_start
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Sanity and old 8003 check */
r_int
id|reg0
op_assign
id|inb
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg0
op_eq
l_int|0xff
)paren
(brace
multiline_comment|/* Future plan: this could check a few likely locations first. */
id|dev-&gt;mem_start
op_assign
l_int|0xd0000
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; assigning address %#x&quot;
comma
id|dev-&gt;mem_start
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|high_addr_bits
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|WD_CMDREG5
)paren
op_amp
l_int|0x1f
suffix:semicolon
multiline_comment|/* Some boards don&squot;t have the register 5 -- it returns 0xff. */
r_if
c_cond
(paren
id|high_addr_bits
op_eq
l_int|0x1f
op_logical_or
id|ei_status.word16
op_eq
l_int|0
)paren
id|high_addr_bits
op_assign
l_int|0x01
suffix:semicolon
id|dev-&gt;mem_start
op_assign
(paren
(paren
id|reg0
op_amp
l_int|0x3f
)paren
op_lshift
l_int|13
)paren
op_plus
(paren
id|high_addr_bits
op_lshift
l_int|19
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* The 8390 isn&squot;t at the base address -- the ASIC regs are there! */
id|dev-&gt;base_addr
op_assign
id|ioaddr
op_plus
id|WD_NIC_OFFSET
suffix:semicolon
id|ei_status.tx_start_page
op_assign
id|WD_START_PG
suffix:semicolon
id|ei_status.rx_start_page
op_assign
id|WD_START_PG
op_plus
id|TX_PAGES
suffix:semicolon
id|ei_status.stop_page
op_assign
id|ei_status.word16
ques
c_cond
id|WD13_STOP_PG
suffix:colon
id|WD03_STOP_PG
suffix:semicolon
id|dev-&gt;rmem_start
op_assign
id|dev-&gt;mem_start
op_plus
id|TX_PAGES
op_star
l_int|256
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|dev-&gt;rmem_end
op_assign
id|dev-&gt;mem_start
op_plus
(paren
id|ei_status.stop_page
op_minus
id|WD_START_PG
)paren
op_star
l_int|256
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
)paren
(brace
r_int
id|irqmap
(braket
)braket
op_assign
(brace
l_int|9
comma
l_int|3
comma
l_int|5
comma
l_int|7
comma
l_int|10
comma
l_int|11
comma
l_int|15
comma
l_int|4
)brace
suffix:semicolon
r_int
id|reg1
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|1
)paren
suffix:semicolon
r_int
id|reg4
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg1
op_eq
l_int|0xff
)paren
(brace
multiline_comment|/* Ack!! No way to read the IRQ! */
id|dev-&gt;irq
op_assign
id|ei_status.word16
ques
c_cond
l_int|10
suffix:colon
l_int|5
suffix:semicolon
)brace
r_else
id|dev-&gt;irq
op_assign
id|irqmap
(braket
(paren
(paren
id|reg4
op_rshift
l_int|5
)paren
op_amp
l_int|0x03
)paren
op_plus
(paren
id|reg1
op_amp
l_int|0x04
)paren
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|2
)paren
multiline_comment|/* Fixup for users that don&squot;t know that IRQ 2 is really IRQ 9,&n;&t; or don&squot;t know which one to set. */
id|dev-&gt;irq
op_assign
l_int|9
suffix:semicolon
multiline_comment|/* Snarf the interrupt now.  There&squot;s no point in waiting since we cannot&n;     share and the board will usually be enabled. */
(brace
r_int
id|irqval
op_assign
id|irqaction
(paren
id|dev-&gt;irq
comma
op_amp
id|ei_sigaction
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqval
)paren
(brace
id|printk
(paren
l_string|&quot; unable to get IRQ %d (irqval=%d).&bslash;n&quot;
comma
id|dev-&gt;irq
comma
id|irqval
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n%s: %s using IRQ %d with shared memory at %#x-%#x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ei_status.name
comma
id|dev-&gt;irq
comma
id|dev-&gt;mem_start
comma
id|dev-&gt;mem_end
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
macro_line|#if defined(EI_DEBUG) &amp;&amp; EI_DEBUG &gt; 2
id|printk
c_func
(paren
l_string|&quot;%s: Address read from register is %#x, setting address %#x&bslash;n&quot;
comma
id|ei_status.name
comma
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|WD_CMDREG5
)paren
op_amp
l_int|0x1f
)paren
op_lshift
l_int|19
)paren
op_plus
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
)paren
op_amp
l_int|0x3f
)paren
op_lshift
l_int|13
)paren
comma
id|dev-&gt;mem_start
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Map in the shared memory. Always set register 0 last to remain&n;     compatible with very old boards. */
r_if
c_cond
(paren
id|ei_status.word16
)paren
id|outb
c_func
(paren
id|ISA16
op_or
id|NIC16
op_or
(paren
(paren
id|dev-&gt;mem_start
op_rshift
l_int|19
)paren
op_amp
l_int|0x1f
)paren
comma
id|ioaddr
op_plus
id|WD_CMDREG5
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
(paren
(paren
id|dev-&gt;mem_start
op_rshift
l_int|13
)paren
op_amp
l_int|0x3f
)paren
op_or
id|WD_MEMENB
)paren
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* WD_CMDREG */
id|ei_status.reset_8390
op_assign
op_amp
id|wd_reset_8390
suffix:semicolon
id|ei_status.block_input
op_assign
op_amp
id|wd_block_input
suffix:semicolon
id|ei_status.block_output
op_assign
op_amp
id|wd_block_output
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|wd_close_card
suffix:semicolon
id|NS8390_init
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_return
id|dev-&gt;base_addr
suffix:semicolon
)brace
r_static
r_void
DECL|function|wd_reset_8390
id|wd_reset_8390
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|wd_cmd_port
op_assign
id|dev-&gt;base_addr
op_minus
id|WD_NIC_OFFSET
suffix:semicolon
multiline_comment|/* WD_CMDREG */
r_int
id|reset_start_time
op_assign
id|jiffies
suffix:semicolon
id|outb
c_func
(paren
id|WD_RESET
comma
id|wd_cmd_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;resetting the WD80x3 t=%d...&quot;
comma
id|jiffies
)paren
suffix:semicolon
id|ei_status.txing
op_assign
l_int|0
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* We shouldn&squot;t use the boguscount for timing, but this hasn&squot;t been&n;       checked yet, and you could hang your machine if jiffies break... */
(brace
r_int
id|boguscount
op_assign
l_int|150000
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
op_minus
id|reset_start_time
OL
l_int|2
)paren
r_if
c_cond
(paren
id|boguscount
op_decrement
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;jiffy failure (t=%d)...&quot;
comma
id|jiffies
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Set up the ASIC registers, just in case something changed them. */
r_if
c_cond
(paren
id|ei_status.word16
)paren
id|outb
c_func
(paren
id|NIC16
op_or
(paren
(paren
id|dev-&gt;mem_start
op_rshift
l_int|19
)paren
op_amp
l_int|0x1f
)paren
comma
id|wd_cmd_port
op_plus
id|WD_CMDREG5
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
(paren
(paren
id|dev-&gt;mem_start
op_rshift
l_int|13
)paren
op_amp
l_int|0x3f
)paren
op_or
id|WD_MEMENB
)paren
comma
id|wd_cmd_port
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|EN0_ISR
)paren
op_amp
id|ENISR_RESET
)paren
op_eq
l_int|0
)paren
r_if
c_cond
(paren
id|jiffies
op_minus
id|reset_start_time
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: wd_reset_8390() did not complete.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#if defined(EI_DEBUG) &amp;&amp; EI_DEBUG &gt; 2
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nWD80x3 ethercard at %#3x:&quot;
comma
id|wd_cmd_port
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %2.2X&quot;
comma
id|inb
c_func
(paren
id|wd_cmd_port
op_plus
id|i
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nWD80x3 ethercard at %#3x:&quot;
comma
id|wd_cmd_port
op_plus
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|33
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %2.2X&quot;
comma
id|inb
c_func
(paren
id|wd_cmd_port
op_plus
id|i
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/* Block input and output are easy on shared memory ethercards, and trivial&n;   on the Western digital card where there is no choice of how to do it. */
r_static
r_int
DECL|function|wd_block_input
id|wd_block_input
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|count
comma
r_char
op_star
id|buf
comma
r_int
id|ring_offset
)paren
(brace
r_void
op_star
id|xfer_start
op_assign
(paren
r_void
op_star
)paren
(paren
id|dev-&gt;mem_start
op_plus
id|ring_offset
op_minus
(paren
id|WD_START_PG
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
macro_line|#if !defined(WD_no_mapout)
r_int
id|wd_cmdreg
op_assign
id|dev-&gt;base_addr
op_minus
id|WD_NIC_OFFSET
suffix:semicolon
multiline_comment|/* WD_CMDREG */
r_int
id|reg5_val
op_assign
(paren
(paren
id|dev-&gt;mem_start
op_rshift
l_int|19
)paren
op_amp
l_int|0x1f
)paren
op_or
id|NIC16
suffix:semicolon
multiline_comment|/* Map in the shared memory. */
r_if
c_cond
(paren
id|ei_status.word16
)paren
id|outb
c_func
(paren
id|ISA16
op_or
id|reg5_val
comma
id|wd_cmdreg
op_plus
id|WD_CMDREG5
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
(paren
(paren
id|dev-&gt;mem_start
op_rshift
l_int|13
)paren
op_amp
l_int|0x3f
)paren
op_or
id|WD_MEMENB
)paren
comma
id|wd_cmdreg
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|xfer_start
op_plus
id|count
OG
(paren
r_void
op_star
)paren
id|dev-&gt;rmem_end
)paren
(brace
multiline_comment|/* We must wrap the input move. */
r_int
id|semi_count
op_assign
(paren
r_void
op_star
)paren
id|dev-&gt;rmem_end
op_minus
id|xfer_start
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|xfer_start
comma
id|semi_count
)paren
suffix:semicolon
id|count
op_sub_assign
id|semi_count
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
op_plus
id|semi_count
comma
(paren
r_char
op_star
)paren
id|dev-&gt;rmem_start
comma
id|count
)paren
suffix:semicolon
r_return
id|dev-&gt;rmem_start
op_plus
id|count
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|buf
comma
id|xfer_start
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
OG
l_int|4
)paren
(brace
r_int
r_int
op_star
id|board
op_assign
id|xfer_start
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: wd8013 block_input(cnt=%d offset=%3x addr=%#x) = %2x %2x %2x...&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|count
comma
id|ring_offset
comma
id|xfer_start
comma
id|board
(braket
op_minus
l_int|1
)braket
comma
id|board
(braket
l_int|0
)braket
comma
id|board
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
macro_line|#if !defined(WD_no_mapout)
multiline_comment|/* Turn off 16 bit access so that reboot works. */
r_if
c_cond
(paren
id|ei_status.word16
)paren
id|outb
c_func
(paren
id|reg5_val
comma
id|wd_cmdreg
op_plus
id|WD_CMDREG5
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ring_offset
op_plus
id|count
suffix:semicolon
)brace
multiline_comment|/* This could only be outputting to the transmit buffer.  The&n;   ping-pong transmit setup doesn&squot;t work with this yet. */
r_static
r_void
DECL|function|wd_block_output
id|wd_block_output
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|count
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|start_page
)paren
(brace
r_int
r_char
op_star
id|shmem
op_assign
(paren
r_void
op_star
)paren
id|dev-&gt;mem_start
op_plus
(paren
(paren
id|start_page
op_minus
id|WD_START_PG
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
macro_line|#if !defined(WD_no_mapout)
r_int
id|wd_cmdreg
op_assign
id|dev-&gt;base_addr
op_minus
id|WD_NIC_OFFSET
suffix:semicolon
multiline_comment|/* WD_CMDREG */
r_int
id|reg5_val
op_assign
(paren
(paren
id|dev-&gt;mem_start
op_rshift
l_int|19
)paren
op_amp
l_int|0x1f
)paren
op_or
id|NIC16
suffix:semicolon
multiline_comment|/* Map in the shared memory. */
r_if
c_cond
(paren
id|ei_status.word16
)paren
id|outb
c_func
(paren
id|ISA16
op_or
id|reg5_val
comma
id|wd_cmdreg
op_plus
id|WD_CMDREG5
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
(paren
(paren
id|dev-&gt;mem_start
op_rshift
l_int|13
)paren
op_amp
l_int|0x3f
)paren
op_or
id|WD_MEMENB
)paren
comma
id|wd_cmdreg
)paren
suffix:semicolon
macro_line|#endif
id|memcpy
c_func
(paren
id|shmem
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
l_string|&quot;%s: wd80*3 block_output(addr=%#x cnt=%d) -&gt; %2x=%2x %2x=%2x %d...&bslash;n&quot;
comma
id|shmem
comma
id|count
comma
id|shmem
(braket
l_int|23
)braket
comma
id|buf
(braket
l_int|23
)braket
comma
id|shmem
(braket
l_int|24
)braket
comma
id|buf
(braket
l_int|24
)braket
comma
id|memcmp
c_func
(paren
id|shmem
comma
id|buf
comma
id|count
)paren
)paren
suffix:semicolon
macro_line|#if !defined(WD_no_mapout)
multiline_comment|/* Turn off 16 bit access so that reboot works. */
r_if
c_cond
(paren
id|ei_status.word16
)paren
id|outb
c_func
(paren
id|reg5_val
comma
id|wd_cmdreg
op_plus
id|WD_CMDREG5
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* This function resets the ethercard if something screws up. */
r_static
r_int
DECL|function|wd_close_card
id|wd_close_card
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|wd_cmdreg
op_assign
id|dev-&gt;base_addr
op_minus
id|WD_NIC_OFFSET
suffix:semicolon
multiline_comment|/* WD_CMDREG */
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Shutting down ethercard.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|NS8390_init
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Turn off 16-bit shared memory so reboot works. */
id|outb
c_func
(paren
(paren
(paren
id|dev-&gt;mem_start
op_rshift
l_int|19
)paren
op_amp
l_int|0x1f
)paren
op_or
id|NIC16
comma
id|wd_cmdreg
op_plus
id|WD_CMDREG5
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
(paren
(paren
id|dev-&gt;mem_start
op_rshift
l_int|13
)paren
op_amp
l_int|0x3f
)paren
)paren
comma
id|wd_cmdreg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -DKERNEL -Wall -O6 -fomit-frame-pointer -I/usr/src/linux/net/tcp -c wd.c&quot;&n; *  version-control: t&n; *  kept-new-versions: 5&n; * End:&n; */
eof
