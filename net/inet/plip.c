multiline_comment|/* plip.c: A parallel port &quot;network&quot; driver for linux. */
multiline_comment|/*&n;    Written 1993 by Donald Becker.  This is unreleased software.&n;    &n;    This is parallel port packet pusher.  It&squot;s actually more general&n;    than the &quot;IP&quot; in its name suggests -- but &squot;plip&squot; is just such a&n;    great name!&n;&n;    The Author may be reached as becker@super.org or&n;    C/O Supercomputing Research Ctr., 17100 Science Dr., Bowie MD 20715&n;*/
DECL|variable|version
r_static
r_char
op_star
id|version
op_assign
l_string|&quot;plip.c:v0.04 Mar 19 1993 Donald Becker (becker@super.org)&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/config.h&gt;
multiline_comment|/*&n;  Sources:&n;&t;Ideas and protocols came from Russ Nelson&squot;s (nelson@crynwr.com)&n;&t;&quot;parallel.asm&quot; parallel port packet driver.&n;  The &quot;Crynwr&quot; parallel port standard specifies the following protocol:&n;   send header nibble &squot;8&squot;&n;   count-low octet&n;   count-high octet&n;   ... data octets&n;   checksum octet&n;Each octet is sent as &lt;wait for rx. &squot;1&squot;&gt; &lt;send 0x10+(octet&amp;0x0F)&gt;&n;&t;&t;&t;&lt;wait for rx. &squot;0&squot;&gt; &lt;send 0x00+((octet&gt;&gt;4)&amp;0x0F)&gt;&n;The cable used is a de facto standard parallel null cable -- sold as&n;a &quot;LapLink&quot; cable by various places.  You&squot;ll need a 10-conductor cable to&n;make one yourself.  The wiring is:&n;    INIT&t;16 - 16&t;&t;SLCTIN&t;17 - 17&n;    GROUND&t;25 - 25&n;    D0-&gt;ERROR&t;2 - 15&t;&t;15 - 2&n;    D1-&gt;SLCT&t;3 - 13&t;&t;13 - 3&n;    D2-&gt;PAPOUT&t;4 - 12&t;&t;12 - 4&n;    D3-&gt;ACK&t;5 - 10&t;&t;10 - 5&n;    D4-&gt;BUSY&t;6 - 11&t;&t;11 - 6&n;  Do not connect the other pins.  They are&n;    D5,D6,D7 are 7,8,9&n;    STROBE is 1, FEED is 14&n;    extra grounds are 18,19,20,21,22,23,24&n;*/
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &quot;dev.h&quot;
macro_line|#include &quot;eth.h&quot;
macro_line|#include &quot;timer.h&quot;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &quot;skbuff.h&quot;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &quot;arp.h&quot;
multiline_comment|/* use 0 for production, 1 for verification, &gt;2 for debug */
macro_line|#ifndef PLIP_DEBUG
DECL|macro|PLIP_DEBUG
mdefine_line|#define PLIP_DEBUG 9
macro_line|#endif
DECL|variable|plip_debug
r_static
r_int
r_int
id|plip_debug
op_assign
id|PLIP_DEBUG
suffix:semicolon
multiline_comment|/* The map from IRQ number (as passed to the interrupt handler) to&n;   &squot;struct device&squot;. */
r_extern
r_struct
id|device
op_star
id|irq2dev_map
(braket
l_int|16
)braket
suffix:semicolon
DECL|macro|PAR_DATA
mdefine_line|#define PAR_DATA&t;0
DECL|macro|PAR_STATUS
mdefine_line|#define PAR_STATUS&t;1
DECL|macro|PAR_CONTROL
mdefine_line|#define PAR_CONTROL&t;2
multiline_comment|/* Common network statistics -- these will be in *.h someday. */
DECL|struct|netstats
r_struct
id|netstats
(brace
DECL|member|tx_packets
r_int
id|tx_packets
suffix:semicolon
DECL|member|rx_packets
r_int
id|rx_packets
suffix:semicolon
DECL|member|tx_errors
r_int
id|tx_errors
suffix:semicolon
DECL|member|rx_errors
r_int
id|rx_errors
suffix:semicolon
DECL|member|missed_packets
r_int
id|missed_packets
suffix:semicolon
DECL|member|soft_tx_errors
r_int
id|soft_tx_errors
suffix:semicolon
DECL|member|soft_rx_errors
r_int
id|soft_rx_errors
suffix:semicolon
DECL|member|soft_trx_err_bits
r_int
id|soft_trx_err_bits
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|localstats
r_static
r_struct
id|netstats
op_star
id|localstats
suffix:semicolon
multiline_comment|/* Index to functions, as function prototypes. */
r_extern
r_int
id|plip_probe
c_func
(paren
r_int
id|ioaddr
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Put in the device structure. */
r_static
r_int
id|plip_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|plip_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|plip_tx_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Routines used internally. */
multiline_comment|/* Dispatch from interrupts. */
r_static
r_void
id|plip_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
suffix:semicolon
r_static
r_int
id|plip_write
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|length
)paren
suffix:semicolon
"&f;"
r_int
DECL|function|plip_init
id|plip_init
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Alpha testers must have the version number to report bugs. */
r_if
c_cond
(paren
id|plip_debug
OG
l_int|1
)paren
(brace
r_static
r_int
id|version_shown
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|version_shown
)paren
id|printk
c_func
(paren
id|version
)paren
comma
id|version_shown
op_increment
suffix:semicolon
)brace
multiline_comment|/* We don&squot;t actually probe for anything here, although we might&n;       someday check to see if there&squot;s bi-directional port at&n;       dev-&gt;base_addr. */
multiline_comment|/* Initialize the device structure. */
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|netstats
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|netstats
)paren
)paren
suffix:semicolon
id|localstats
op_assign
(paren
r_struct
id|netstats
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_NUMBUFFS
suffix:semicolon
id|i
op_increment
)paren
id|dev-&gt;buffs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;hard_header
op_assign
id|eth_header
suffix:semicolon
id|dev-&gt;add_arp
op_assign
id|eth_add_arp
suffix:semicolon
id|dev-&gt;queue_xmit
op_assign
id|dev_queue_xmit
suffix:semicolon
id|dev-&gt;rebuild_header
op_assign
id|eth_rebuild_header
suffix:semicolon
id|dev-&gt;type_trans
op_assign
id|eth_type_trans
suffix:semicolon
id|dev-&gt;open
op_assign
op_amp
id|plip_open
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|plip_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|plip_tx_packet
suffix:semicolon
multiline_comment|/* These are ethernet specific. */
id|dev-&gt;type
op_assign
id|ARPHRD_ETHER
suffix:semicolon
id|dev-&gt;hard_header_len
op_assign
id|ETH_HLEN
suffix:semicolon
id|dev-&gt;mtu
op_assign
l_int|1500
suffix:semicolon
multiline_comment|/* eth_mtu */
id|dev-&gt;addr_len
op_assign
id|ETH_ALEN
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;addr_len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;broadcast
(braket
id|i
)braket
op_assign
l_int|0xff
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|i
suffix:semicolon
multiline_comment|/* The physical address is 0:1:2:3:4:5! */
)brace
multiline_comment|/* New-style flags. */
id|dev-&gt;flags
op_assign
id|IFF_BROADCAST
suffix:semicolon
id|dev-&gt;family
op_assign
id|AF_INET
suffix:semicolon
id|dev-&gt;pa_addr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_brdaddr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_mask
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_alen
op_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: using parallel port at %#3x, IRQ %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Open/initialize the board.  This is called (in the current kernel)&n;   sometime after booting when the &squot;config &lt;dev-&gt;name&gt;&squot; program is&n;   run.&n;&n;   This routine gets exclusive access to the parallel port by allocating&n;   its IRQ line.&n;   */
r_static
r_int
DECL|function|plip_open
id|plip_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|0
)paren
id|dev-&gt;irq
op_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|plip_interrupt
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|plip_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;%s: couldn&squot;t get the IRQ.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
id|EAGAIN
suffix:semicolon
)brace
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
id|dev
suffix:semicolon
id|outb
c_func
(paren
l_int|0x10
comma
id|dev-&gt;base_addr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
multiline_comment|/* Enable the rx interrupt. */
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Transmit busy...  */
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The inverse routine to plip_open(). */
r_static
r_int
DECL|function|plip_close
id|plip_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
l_int|NULL
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
multiline_comment|/* Release the interrupt. */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|plip_tx_packet
id|plip_tx_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ret_val
suffix:semicolon
multiline_comment|/* If some higher layer thinks we&squot;ve missed an tx-done interrupt&n;       we are passed NULL. Caution: dev_tint() handles the cli()/sti()&n;       itself. */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|dev_tint
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Pretend we are an ethernet and fill in the header.  This could use&n;       a simplified routine someday. */
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;arp
op_logical_and
id|dev
op_member_access_from_pointer
id|rebuild_header
c_func
(paren
id|skb
op_plus
l_int|1
comma
id|dev
)paren
)paren
(brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|arp_queue
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|ret_val
op_assign
id|plip_write
c_func
(paren
id|dev
comma
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;free
)paren
id|kfree_skb
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
(paren
id|INET_BH
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
"&f;"
DECL|function|get_byte
r_static
r_inline
r_int
id|get_byte
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_char
id|val
suffix:semicolon
r_int
r_char
id|low_nibble
suffix:semicolon
r_int
id|boguscount
op_assign
l_int|1500
suffix:semicolon
r_do
(brace
id|val
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|val
op_amp
l_int|0x80
)paren
op_logical_and
op_decrement
id|boguscount
OG
l_int|0
)paren
suffix:semicolon
id|low_nibble
op_assign
(paren
id|val
op_rshift
l_int|3
)paren
op_amp
l_int|0x0f
suffix:semicolon
r_if
c_cond
(paren
id|plip_debug
OG
l_int|8
)paren
id|printk
c_func
(paren
l_string|&quot;%1x&quot;
comma
id|low_nibble
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x10
comma
id|dev-&gt;base_addr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
r_do
(brace
id|val
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|val
op_amp
l_int|0x80
)paren
op_logical_and
op_decrement
id|boguscount
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|plip_debug
OG
l_int|8
)paren
id|printk
c_func
(paren
l_string|&quot;%1x %s&quot;
comma
id|low_nibble
comma
id|boguscount
op_le
l_int|0
ques
c_cond
l_string|&quot;timeout&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|dev-&gt;base_addr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
r_return
id|low_nibble
op_or
(paren
(paren
id|val
op_lshift
l_int|1
)paren
op_amp
l_int|0xf0
)paren
suffix:semicolon
)brace
multiline_comment|/* The typical workload of the driver:&n;   Handle the parallel port interrupts. */
r_static
r_void
DECL|function|plip_interrupt
id|plip_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
(brace
r_int
id|irq
op_assign
op_minus
(paren
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
id|reg_ptr
)paren
op_member_access_from_pointer
id|orig_eax
op_plus
l_int|2
)paren
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
id|irq2dev_map
(braket
id|irq
)braket
suffix:semicolon
r_int
id|boguscount
op_assign
l_int|1500
suffix:semicolon
r_int
id|length
suffix:semicolon
r_int
id|sksize
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;plip_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev-&gt;interrupt
op_assign
l_int|1
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|dev-&gt;base_addr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
multiline_comment|/* Disable the rx interrupt. */
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Allow other interrupts. */
r_if
c_cond
(paren
id|plip_debug
op_ge
l_int|4
)paren
id|printk
c_func
(paren
l_string|&quot;%s: interrupt.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|localstats
op_assign
(paren
r_struct
id|netstats
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Receive the packet here. */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
op_ne
l_int|0xc7
)paren
(brace
id|localstats-&gt;rx_errors
op_increment
suffix:semicolon
multiline_comment|/* No interrupt! */
r_if
c_cond
(paren
id|plip_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
l_string|&quot;%s: No interrupt (status=%#02x)!&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|1
comma
id|dev-&gt;base_addr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
multiline_comment|/* Ack: &squot;Ready&squot; */
id|length
op_assign
id|get_byte
c_func
(paren
id|dev
)paren
suffix:semicolon
id|length
op_or_assign
(paren
id|get_byte
c_func
(paren
id|dev
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
id|dev-&gt;mtu
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Bogus packet size %d, dropping it.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|length
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|boguscount
op_assign
id|length
op_lshift
l_int|5
suffix:semicolon
id|sksize
op_assign
r_sizeof
(paren
r_struct
id|sk_buff
)paren
op_plus
id|length
suffix:semicolon
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|kmalloc
c_func
(paren
id|sksize
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|plip_debug
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Couldn&squot;t allocate a sk_buff of size %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|sksize
)paren
suffix:semicolon
id|localstats-&gt;rx_errors
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;mem_len
op_assign
id|sksize
suffix:semicolon
id|skb-&gt;mem_addr
op_assign
id|skb
suffix:semicolon
(brace
multiline_comment|/* &squot;skb+1&squot; points to the start of sk_buff data area. */
r_int
r_char
op_star
id|buf
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
suffix:semicolon
r_int
id|checksum
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|length
op_decrement
)paren
(brace
r_int
r_char
id|new_byte
op_assign
id|get_byte
c_func
(paren
id|dev
)paren
suffix:semicolon
id|checksum
op_add_assign
id|new_byte
comma
op_star
id|buf
op_increment
op_assign
id|new_byte
suffix:semicolon
)brace
r_if
c_cond
(paren
id|checksum
op_ne
id|get_byte
c_func
(paren
id|dev
)paren
)paren
id|localstats-&gt;soft_rx_errors
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dev_rint
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|skb
comma
id|length
comma
id|IN_SKBUFF
comma
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: receive buffers full.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|localstats-&gt;rx_errors
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Wait for the remote end to reset. */
r_while
c_loop
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
op_ne
l_int|0x87
)paren
r_if
c_cond
(paren
id|boguscount
op_decrement
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|dev-&gt;base_addr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x10
comma
id|dev-&gt;base_addr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
multiline_comment|/* Enable the rx interrupt. */
id|localstats-&gt;rx_packets
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
"&f;"
DECL|function|send_byte
r_static
r_inline
r_int
id|send_byte
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
r_char
id|val
)paren
(brace
r_int
id|boguscount
op_assign
l_int|1500
suffix:semicolon
r_if
c_cond
(paren
id|plip_debug
OG
l_int|8
)paren
id|printk
c_func
(paren
l_string|&quot;send(%02x) &quot;
comma
id|val
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x10
op_or
id|val
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
op_amp
l_int|0x80
)paren
r_if
c_cond
(paren
op_decrement
id|boguscount
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|outb
c_func
(paren
id|val
op_rshift
l_int|4
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
op_amp
l_int|0x80
)paren
op_eq
l_int|0
)paren
r_if
c_cond
(paren
op_decrement
id|boguscount
op_le
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|plip_debug
OG
l_int|4
op_logical_and
id|boguscount
op_le
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;timeout&quot;
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|plip_write
id|plip_write
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|length
)paren
(brace
r_int
id|timeout
op_assign
l_int|1000
suffix:semicolon
multiline_comment|/* Approx 1 ms. */
r_char
id|checksum
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|plip_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%s: plip_write(%d) %02x %02x %02x %02x %02x...&quot;
comma
id|dev-&gt;name
comma
id|length
comma
id|buf
(braket
l_int|0
)braket
comma
id|buf
(braket
l_int|1
)braket
comma
id|buf
(braket
l_int|2
)braket
comma
id|buf
(braket
l_int|3
)braket
comma
id|buf
(braket
l_int|4
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
id|dev-&gt;mtu
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: packet too big, %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|length
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* This starts the packet protocol by triggering a remote IRQ. */
id|outb
c_func
(paren
l_int|0x00
comma
id|dev-&gt;base_addr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
multiline_comment|/* Disable my rx interrupt. */
id|outb
c_func
(paren
l_int|0x08
comma
id|dev-&gt;base_addr
op_plus
id|PAR_DATA
)paren
suffix:semicolon
multiline_comment|/* Trigger remote rx interrupt. */
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|PAR_STATUS
)paren
op_amp
l_int|0x08
)paren
op_eq
l_int|0
)paren
r_if
c_cond
(paren
op_decrement
id|timeout
OL
l_int|0
)paren
(brace
id|outb
c_func
(paren
l_int|0x00
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
id|localstats-&gt;tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|plip_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Connect failed during send_packet() (length=%d).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* We failed to send the packet.  To emulate the ethernet we&n;&t;       should pretent the send worked fine, but we don&squot;t right now. */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Failed to send the packet! */
)brace
id|send_byte
c_func
(paren
id|dev
comma
id|length
)paren
suffix:semicolon
id|send_byte
c_func
(paren
id|dev
comma
id|length
op_rshift
l_int|8
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|length
suffix:semicolon
id|i
op_increment
)paren
id|checksum
op_add_assign
id|buf
(braket
id|i
)braket
comma
id|send_byte
c_func
(paren
id|dev
comma
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|send_byte
c_func
(paren
id|dev
comma
id|checksum
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x10
comma
id|dev-&gt;base_addr
op_plus
id|PAR_CONTROL
)paren
suffix:semicolon
multiline_comment|/* Enable the rx interrupt. */
id|localstats-&gt;tx_packets
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|plip_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;plip_write(%d) done.&bslash;n&quot;
comma
id|length
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -DKERNEL -Wall -O6 -fomit-frame-pointer -I/usr/src/linux/net/tcp -c plip.c&quot;&n; *  version-control: t&n; *  kept-new-versions: 5&n; * End:&n; */
eof
