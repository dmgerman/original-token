multiline_comment|/*&n; *&t;NET3&t;IP device support routines.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; *&t;Derived from the IP parts of dev.c 1.0.19&n; * &t;&t;Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; *&n; *&t;Additional Authors:&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; */
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;route.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &quot;arp.h&quot;
multiline_comment|/* &n; *&t;Determine a default network mask, based on the IP address. &n; */
DECL|function|ip_get_mask
r_int
r_int
id|ip_get_mask
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_int
r_int
id|dst
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_eq
l_int|0L
)paren
r_return
l_int|0L
suffix:semicolon
multiline_comment|/* special case */
id|dst
op_assign
id|ntohl
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSA
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSA_NET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSB
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSB_NET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSC
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSC_NET
)paren
suffix:semicolon
multiline_comment|/*&n;  &t; *&t;Something else, probably a multicast. &n;  &t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Check the address for our address, broadcasts, etc. &n; *&n; *&t;I intend to fix this to at the very least cache the last&n; *&t;resolved entry.&n; */
DECL|function|ip_chk_addr
r_int
id|ip_chk_addr
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
multiline_comment|/* &n;&t; *&t;Accept both `all ones&squot; and `all zeros&squot; as BROADCAST. &n;&t; *&t;(Support old BSD in other words). This old BSD &n;&t; *&t;support will go very soon as it messes other things&n;&t; *&t;up.&n;&t; *&t;Also accept `loopback broadcast&squot; as BROADCAST.&n;&t; */
r_if
c_cond
(paren
id|addr
op_eq
id|INADDR_ANY
op_logical_or
id|addr
op_eq
id|INADDR_BROADCAST
op_logical_or
id|addr
op_eq
id|htonl
c_func
(paren
l_int|0x7FFFFFFFL
)paren
)paren
r_return
id|IS_BROADCAST
suffix:semicolon
id|mask
op_assign
id|ip_get_mask
c_func
(paren
id|addr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Accept all of the `loopback&squot; class A net. &n;&t; */
r_if
c_cond
(paren
(paren
id|addr
op_amp
id|mask
)paren
op_eq
id|htonl
c_func
(paren
l_int|0x7F000000L
)paren
)paren
r_return
id|IS_MYADDR
suffix:semicolon
multiline_comment|/*&n;&t; *&t;OK, now check the interface addresses. &n;&t; */
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;If the protocol address of the device is 0 this is special&n;&t;&t; *&t;and means we are address hunting (eg bootp).&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|dev-&gt;pa_addr
op_eq
l_int|0
)paren
multiline_comment|/* || (dev-&gt;flags&amp;IFF_PROMISC)*/
)paren
r_return
id|IS_MYADDR
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Is it the exact IP address? &n;&t;&t; */
r_if
c_cond
(paren
id|addr
op_eq
id|dev-&gt;pa_addr
)paren
r_return
id|IS_MYADDR
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Is it our broadcast address? &n;&t;&t; */
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_BROADCAST
)paren
op_logical_and
id|addr
op_eq
id|dev-&gt;pa_brdaddr
)paren
r_return
id|IS_BROADCAST
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Nope. Check for a subnetwork broadcast. &n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|addr
op_xor
id|dev-&gt;pa_addr
)paren
op_amp
id|dev-&gt;pa_mask
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr
op_amp
op_complement
id|dev-&gt;pa_mask
)paren
op_eq
l_int|0
)paren
r_return
id|IS_BROADCAST
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_amp
op_complement
id|dev-&gt;pa_mask
)paren
op_eq
op_complement
id|dev-&gt;pa_mask
)paren
r_return
id|IS_BROADCAST
suffix:semicolon
)brace
multiline_comment|/*&n;&t; &t; *&t;Nope. Check for Network broadcast. &n;&t; &t; */
r_if
c_cond
(paren
(paren
(paren
id|addr
op_xor
id|dev-&gt;pa_addr
)paren
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr
op_amp
op_complement
id|mask
)paren
op_eq
l_int|0
)paren
r_return
id|IS_BROADCAST
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_amp
op_complement
id|mask
)paren
op_eq
op_complement
id|mask
)paren
r_return
id|IS_BROADCAST
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|IN_MULTICAST
c_func
(paren
id|ntohl
c_func
(paren
id|addr
)paren
)paren
)paren
(brace
r_return
id|IS_MULTICAST
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* no match at all */
)brace
multiline_comment|/*&n; *&t;Retrieve our own address.&n; *&n; *&t;Because the loopback address (127.0.0.1) is already recognized&n; *&t;automatically, we can use the loopback interface&squot;s address as&n; *&t;our &quot;primary&quot; interface.  This is the address used by IP et&n; *&t;al when it doesn&squot;t know which address to use (i.e. it does not&n; *&t;yet know from or to which interface to go...).&n; */
DECL|function|ip_my_addr
r_int
r_int
id|ip_my_addr
c_func
(paren
r_void
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
r_return
id|dev-&gt;pa_addr
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Find an interface that can handle addresses for a certain address. &n; *&n; *&t;This needs optimising, since its relatively trivial to collapse&n; *&t;the two loops into one.&n; */
DECL|function|ip_dev_check
r_struct
id|device
op_star
id|ip_dev_check
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_POINTOPOINT
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_ne
id|dev-&gt;pa_dstaddr
)paren
r_continue
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_POINTOPOINT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;pa_mask
op_amp
(paren
id|addr
op_xor
id|dev-&gt;pa_addr
)paren
)paren
r_continue
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
eof
