multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Interface (streams) handling functions.&n; *&n; * Version:&t;@(#)dev.c&t;1.28&t;20/12/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;&n; * &n; * Fixes:&t;&n; *&t;&t;Alan Cox:&t;check_addr returns a value for a wrong subnet&n; *&t;&t;&t;&t;ie not us but don&squot;t forward this!&n; *&t;&t;Alan Cox:&t;block timer if the inet_bh handler is running&n; *&t;&t;Alan Cox:&t;generic queue code added. A lot neater now&n; *&t;&t;C.E.Hawkins:&t;SIOCGIFCONF only reports &squot;upped&squot; interfaces&n; *&t;&t;C.E.Hawkins:&t;IFF_PROMISC support&n; *&t;&t;Alan Cox:&t;Supports Donald Beckers new hardware &n; *&t;&t;&t;&t;multicast layer, but not yet multicast lists.&n; *&t;&t;Alan Cox:&t;ip_addr_match problems with class A/B nets.&n; *&t;&t;C.E.Hawkins&t;IP 0.0.0.0 and also same net route fix. [FIXME: Ought to cause ICMP_REDIRECT]&n; *&t;&t;Alan Cox:&t;Removed bogus subnet check now the subnet code&n; *&t;&t;&t;&t;a) actually works for all A/B nets&n; *&t;&t;&t;&t;b) doesn&squot;t forward off the same interface.&n; *&t;&t;Alan Cox:&t;Multiple extra protocols&n; *&t;&t;Alan Cox:&t;A Couple more escaped verify_area calls die&n; *&t;&t;Alan Cox:&t;IP_SET_DEV is gone (forever) as per Fred&squot;s comment.&n; *&t;&t;Alan Cox:&t;Grand tidy up ready for the big day.&n; *&t;&t;Alan Cox:&t;Handles dev_open errors correctly.&n; *&t;&t;Alan Cox:&t;IP and generic parts split&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &quot;inet.h&quot;
macro_line|#include &quot;devinet.h&quot;
macro_line|#include &quot;eth.h&quot;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;route.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &quot;skbuff.h&quot;
multiline_comment|/* &n; *&t;Determine a default network mask, based on the IP address.&n; */
DECL|function|ip_get_mask
r_int
r_int
id|ip_get_mask
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_int
r_int
id|dst
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_eq
l_int|0L
)paren
r_return
l_int|0L
suffix:semicolon
multiline_comment|/* special case */
id|dst
op_assign
id|ntohl
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSA
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSA_NET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSB
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSB_NET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSC
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSC_NET
)paren
suffix:semicolon
multiline_comment|/* Something else, probably a subnet. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;See if a pair of addresses match.&n; */
DECL|function|ip_addr_match
r_int
id|ip_addr_match
c_func
(paren
r_int
r_int
id|me
comma
r_int
r_int
id|him
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;ip_addr_match(%s, &quot;
comma
id|in_ntoa
c_func
(paren
id|me
)paren
)paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;%s)&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|him
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Fast path for 99.9% of cases */
r_if
c_cond
(paren
id|me
op_eq
id|him
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
comma
id|me
op_rshift_assign
l_int|8
comma
id|him
op_rshift_assign
l_int|8
comma
id|mask
op_rshift_assign
l_int|8
)paren
(brace
r_if
c_cond
(paren
(paren
id|me
op_amp
l_int|0xFF
)paren
op_ne
(paren
id|him
op_amp
l_int|0xFF
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The only way this could be a match is for&n;&t;&t;&t; * the rest of addr1 to be 0 or 255.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|me
op_ne
l_int|0
op_logical_and
id|me
op_ne
id|mask
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Check the address for our address, broadcasts, etc. &n; *&n; *&t;This routine is used a lot, and in many time critical&n; *&t;places. It&squot;s already _TOO_ slow so be careful how you&n; *&t;alter it.&n; */
DECL|function|chk_addr
r_int
id|chk_addr
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_int
r_int
id|dst
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;chk_addr(%s) --&gt; &quot;
comma
id|in_ntoa
c_func
(paren
id|addr
)paren
)paren
)paren
suffix:semicolon
id|dst
op_assign
id|ntohl
c_func
(paren
id|addr
)paren
suffix:semicolon
multiline_comment|/*&n;  &t; * Accept both `all ones&squot; and `all zeros&squot; as BROADCAST. &n;  &t; * All 0&squot;s is the old BSD broadcast.&n;  &t; */
r_if
c_cond
(paren
id|dst
op_eq
id|INADDR_ANY
op_logical_or
id|dst
op_eq
id|INADDR_BROADCAST
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;BROADCAST&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|IS_BROADCAST
suffix:semicolon
)brace
multiline_comment|/* Accept all of the `loopback&squot; class A net. */
r_if
c_cond
(paren
(paren
id|dst
op_amp
id|IN_CLASSA_NET
)paren
op_eq
l_int|0x7F000000L
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;LOOPBACK&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We force `loopback&squot; to be equal to MY_ADDR.&n;&t;&t; */
r_return
id|IS_MYADDR
suffix:semicolon
multiline_comment|/* return(IS_LOOPBACK); */
)brace
multiline_comment|/* OK, now check the interface addresses. */
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;pa_addr
op_eq
l_int|0
)paren
multiline_comment|/* || (dev-&gt;flags&amp;IFF_PROMISC)*/
)paren
r_return
id|IS_MYADDR
suffix:semicolon
multiline_comment|/* Is it the exact IP address? */
r_if
c_cond
(paren
id|addr
op_eq
id|dev-&gt;pa_addr
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;MYADDR&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|IS_MYADDR
suffix:semicolon
)brace
multiline_comment|/* Nope. Check for a subnetwork broadcast. */
r_if
c_cond
(paren
(paren
id|addr
op_amp
id|dev-&gt;pa_mask
)paren
op_eq
(paren
id|dev-&gt;pa_addr
op_amp
id|dev-&gt;pa_mask
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr
op_amp
op_complement
id|dev-&gt;pa_mask
)paren
op_eq
l_int|0
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;SUBBROADCAST-0&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|IS_BROADCAST
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|addr
op_amp
op_complement
id|dev-&gt;pa_mask
)paren
op_or
id|dev-&gt;pa_mask
)paren
op_eq
id|INADDR_BROADCAST
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;SUBBROADCAST-1&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|IS_BROADCAST
suffix:semicolon
)brace
)brace
multiline_comment|/* Nope. Check for Network broadcast. */
r_if
c_cond
(paren
id|IN_CLASSA
c_func
(paren
id|dst
)paren
)paren
(brace
r_if
c_cond
(paren
id|addr
op_eq
(paren
id|dev-&gt;pa_addr
op_or
l_int|0xffffff00
)paren
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;CLASS A BROADCAST-1&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|IS_BROADCAST
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|IN_CLASSB
c_func
(paren
id|dst
)paren
)paren
(brace
r_if
c_cond
(paren
id|addr
op_eq
(paren
id|dev-&gt;pa_addr
op_or
l_int|0xffff0000
)paren
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;CLASS B BROADCAST-1&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|IS_BROADCAST
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* IN_CLASSC */
r_if
c_cond
(paren
id|addr
op_eq
(paren
id|dev-&gt;pa_addr
op_or
l_int|0xff000000
)paren
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;CLASS C BROADCAST-1&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|IS_BROADCAST
suffix:semicolon
)brace
)brace
)brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_DEV
comma
l_string|&quot;NONE&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* no match at all */
)brace
multiline_comment|/*&n; * Retrieve our own address.&n; * Because the loopback address (127.0.0.1) is already recognized&n; * automatically, we can use the loopback interface&squot;s address as&n; * our &quot;primary&quot; interface.  This is the addressed used by IP et&n; * al when it doesn&squot;t know which address to use (i.e. it does not&n; * yet know from or to which interface to go...).&n; */
DECL|function|my_addr
r_int
r_int
id|my_addr
c_func
(paren
r_void
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
r_return
id|dev-&gt;pa_addr
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Find an interface that can handle addresses for a certain address. &n; */
DECL|function|dev_check
r_struct
id|device
op_star
id|dev_check
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
op_logical_and
(paren
id|dev-&gt;flags
op_amp
id|IFF_POINTOPOINT
)paren
op_logical_and
(paren
id|addr
op_eq
id|dev-&gt;pa_dstaddr
)paren
)paren
r_return
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
op_logical_and
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_POINTOPOINT
)paren
op_logical_and
(paren
id|dev-&gt;flags
op_amp
id|IFF_LOOPBACK
ques
c_cond
(paren
id|addr
op_eq
id|dev-&gt;pa_addr
)paren
suffix:colon
(paren
id|dev-&gt;pa_mask
op_amp
id|addr
)paren
op_eq
(paren
id|dev-&gt;pa_addr
op_amp
id|dev-&gt;pa_mask
)paren
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* no need to check broadcast addresses */
r_return
id|dev
suffix:semicolon
)brace
eof
