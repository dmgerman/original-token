multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;ROUTE - implementation of the IP router.&n; *&n; * Version:&t;@(#)route.c&t;1.0.14&t;05/31/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;Verify area fixes.&n; *&t;&t;Alan Cox&t;:&t;cli() protects routing changes&n; *&t;&t;Rui Oliveira&t;:&t;ICMP routing table updates&n; *&t;&t;(rco@di.uminho.pt)&t;Routing table insertion and update&n; *&t;&t;Linus Torvalds&t;:&t;Rewrote bits to be sensible&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &quot;inet.h&quot;
macro_line|#include &quot;dev.h&quot;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;route.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &quot;skbuff.h&quot;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &quot;arp.h&quot;
macro_line|#include &quot;icmp.h&quot;
DECL|variable|rt_base
r_static
r_struct
id|rtable
op_star
id|rt_base
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|rt_loopback
r_static
r_struct
id|rtable
op_star
id|rt_loopback
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Dump the contents of a routing table entry. */
r_static
r_void
DECL|function|rt_print
id|rt_print
c_func
(paren
r_struct
id|rtable
op_star
id|rt
)paren
(brace
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
op_logical_or
id|inet_debug
op_ne
id|DBG_RT
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RT: %06lx NXT=%06lx FLAGS=0x%02x&bslash;n&quot;
comma
(paren
r_int
)paren
id|rt
comma
(paren
r_int
)paren
id|rt-&gt;rt_next
comma
id|rt-&gt;rt_flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    TARGET=%s &quot;
comma
id|in_ntoa
c_func
(paren
id|rt-&gt;rt_dst
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;GW=%s &quot;
comma
id|in_ntoa
c_func
(paren
id|rt-&gt;rt_gateway
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    DEV=%s USE=%ld REF=%d&bslash;n&quot;
comma
(paren
id|rt-&gt;rt_dev
op_eq
l_int|NULL
)paren
ques
c_cond
l_string|&quot;NONE&quot;
suffix:colon
id|rt-&gt;rt_dev-&gt;name
comma
id|rt-&gt;rt_use
comma
id|rt-&gt;rt_refcnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a routing table entry.&n; */
DECL|function|rt_del
r_static
r_void
id|rt_del
c_func
(paren
r_int
r_int
id|dst
)paren
(brace
r_struct
id|rtable
op_star
id|r
comma
op_star
op_star
id|rp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_RT
comma
l_string|&quot;RT: flushing for dst %s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|dst
)paren
)paren
)paren
suffix:semicolon
id|rp
op_assign
op_amp
id|rt_base
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|r
op_assign
op_star
id|rp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|r-&gt;rt_dst
op_ne
id|dst
)paren
(brace
id|rp
op_assign
op_amp
id|r-&gt;rt_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
op_star
id|rp
op_assign
id|r-&gt;rt_next
suffix:semicolon
r_if
c_cond
(paren
id|rt_loopback
op_eq
id|r
)paren
id|rt_loopback
op_assign
l_int|NULL
suffix:semicolon
id|kfree_s
c_func
(paren
id|r
comma
r_sizeof
(paren
r_struct
id|rtable
)paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove all routing table entries for a device.&n; */
DECL|function|rt_flush
r_void
id|rt_flush
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|rtable
op_star
id|r
suffix:semicolon
r_struct
id|rtable
op_star
op_star
id|rp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_RT
comma
l_string|&quot;RT: flushing for dev 0x%08lx (%s)&bslash;n&quot;
comma
(paren
r_int
)paren
id|dev
comma
id|dev-&gt;name
)paren
)paren
suffix:semicolon
id|rp
op_assign
op_amp
id|rt_base
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|r
op_assign
op_star
id|rp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|r-&gt;rt_dev
op_ne
id|dev
)paren
(brace
id|rp
op_assign
op_amp
id|r-&gt;rt_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
op_star
id|rp
op_assign
id|r-&gt;rt_next
suffix:semicolon
r_if
c_cond
(paren
id|rt_loopback
op_eq
id|r
)paren
id|rt_loopback
op_assign
l_int|NULL
suffix:semicolon
id|kfree_s
c_func
(paren
id|r
comma
r_sizeof
(paren
r_struct
id|rtable
)paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Used by &squot;rt_add()&squot; when we can&squot;t get the netmask any other way..&n; *&n; * If the lower byte or two are zero, we guess the mask based on the&n; * number of zero 8-bit net numbers, otherwise we use the &quot;default&quot;&n; * masks judging by the destination address and our device netmask.&n; */
DECL|function|default_mask
r_static
r_inline
r_int
r_int
id|default_mask
c_func
(paren
r_int
r_int
id|dst
)paren
(brace
id|dst
op_assign
id|ntohl
c_func
(paren
id|dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSA
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSA_NET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_CLASSB
c_func
(paren
id|dst
)paren
)paren
r_return
id|htonl
c_func
(paren
id|IN_CLASSB_NET
)paren
suffix:semicolon
r_return
id|htonl
c_func
(paren
id|IN_CLASSC_NET
)paren
suffix:semicolon
)brace
DECL|function|guess_mask
r_static
r_int
r_int
id|guess_mask
c_func
(paren
r_int
r_int
id|dst
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dst
)paren
r_return
l_int|0
suffix:semicolon
id|mask
op_assign
id|default_mask
c_func
(paren
id|dst
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dst
op_xor
id|dev-&gt;pa_addr
)paren
op_amp
id|mask
)paren
r_return
id|mask
suffix:semicolon
r_return
id|dev-&gt;pa_mask
suffix:semicolon
)brace
DECL|function|get_gw_dev
r_static
r_inline
r_struct
id|device
op_star
id|get_gw_dev
c_func
(paren
r_int
r_int
id|gw
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_for
c_loop
(paren
id|rt
op_assign
id|rt_base
suffix:semicolon
suffix:semicolon
id|rt
op_assign
id|rt-&gt;rt_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rt
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|gw
op_xor
id|rt-&gt;rt_dst
)paren
op_amp
id|rt-&gt;rt_mask
)paren
r_continue
suffix:semicolon
multiline_comment|/* gateways behind gateways are a no-no */
r_if
c_cond
(paren
id|rt-&gt;rt_flags
op_amp
id|RTF_GATEWAY
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|rt-&gt;rt_dev
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * rewrote rt_add(), as the old one was weird. Linus&n; */
DECL|function|rt_add
r_void
id|rt_add
c_func
(paren
r_int
id|flags
comma
r_int
r_int
id|dst
comma
r_int
r_int
id|mask
comma
r_int
r_int
id|gw
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|rtable
op_star
id|r
comma
op_star
id|rt
suffix:semicolon
r_struct
id|rtable
op_star
op_star
id|rp
suffix:semicolon
r_int
r_int
id|cpuflags
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|RTF_HOST
)paren
(brace
id|mask
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|mask
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|dst
op_xor
id|dev-&gt;pa_addr
)paren
op_amp
id|dev-&gt;pa_mask
)paren
)paren
(brace
id|mask
op_assign
id|dev-&gt;pa_mask
suffix:semicolon
id|flags
op_and_assign
op_complement
id|RTF_GATEWAY
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|RTF_DYNAMIC
)paren
(brace
multiline_comment|/*printk(&quot;Dynamic route to my own net rejected&bslash;n&quot;);*/
r_return
suffix:semicolon
)brace
)brace
r_else
id|mask
op_assign
id|guess_mask
c_func
(paren
id|dst
comma
id|dev
)paren
suffix:semicolon
id|dst
op_and_assign
id|mask
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gw
op_eq
id|dev-&gt;pa_addr
)paren
id|flags
op_and_assign
op_complement
id|RTF_GATEWAY
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|RTF_GATEWAY
)paren
(brace
multiline_comment|/* don&squot;t try to add a gateway we can&squot;t reach.. */
r_if
c_cond
(paren
id|dev
op_ne
id|get_gw_dev
c_func
(paren
id|gw
)paren
)paren
r_return
suffix:semicolon
id|flags
op_or_assign
id|RTF_GATEWAY
suffix:semicolon
)brace
r_else
id|gw
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Allocate an entry. */
id|rt
op_assign
(paren
r_struct
id|rtable
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|rtable
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_RT
comma
l_string|&quot;RT: no memory for new route!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|rt
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|rtable
)paren
)paren
suffix:semicolon
id|rt-&gt;rt_flags
op_assign
id|flags
op_or
id|RTF_UP
suffix:semicolon
id|rt-&gt;rt_dst
op_assign
id|dst
suffix:semicolon
id|rt-&gt;rt_dev
op_assign
id|dev
suffix:semicolon
id|rt-&gt;rt_gateway
op_assign
id|gw
suffix:semicolon
id|rt-&gt;rt_mask
op_assign
id|mask
suffix:semicolon
id|rt-&gt;rt_mtu
op_assign
id|dev-&gt;mtu
suffix:semicolon
id|rt_print
c_func
(paren
id|rt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * What we have to do is loop though this until we have&n;&t; * found the first address which has a higher generality than&n;&t; * the one in rt.  Then we can put rt in right before it.&n;&t; */
id|save_flags
c_func
(paren
id|cpuflags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* remove old route if we are getting a duplicate. */
id|rp
op_assign
op_amp
id|rt_base
suffix:semicolon
r_while
c_loop
(paren
(paren
id|r
op_assign
op_star
id|rp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|r-&gt;rt_dst
op_ne
id|dst
)paren
(brace
id|rp
op_assign
op_amp
id|r-&gt;rt_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
op_star
id|rp
op_assign
id|r-&gt;rt_next
suffix:semicolon
r_if
c_cond
(paren
id|rt_loopback
op_eq
id|r
)paren
id|rt_loopback
op_assign
l_int|NULL
suffix:semicolon
id|kfree_s
c_func
(paren
id|r
comma
r_sizeof
(paren
r_struct
id|rtable
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* add the new route */
id|rp
op_assign
op_amp
id|rt_base
suffix:semicolon
r_while
c_loop
(paren
(paren
id|r
op_assign
op_star
id|rp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|r-&gt;rt_mask
op_amp
id|mask
)paren
op_ne
id|mask
)paren
r_break
suffix:semicolon
id|rp
op_assign
op_amp
id|r-&gt;rt_next
suffix:semicolon
)brace
id|rt-&gt;rt_next
op_assign
id|r
suffix:semicolon
op_star
id|rp
op_assign
id|rt
suffix:semicolon
r_if
c_cond
(paren
id|rt-&gt;rt_dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
id|rt_loopback
op_assign
id|rt
suffix:semicolon
id|restore_flags
c_func
(paren
id|cpuflags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|bad_mask
r_static
r_inline
r_int
id|bad_mask
c_func
(paren
r_int
r_int
id|mask
comma
r_int
r_int
id|addr
)paren
(brace
r_if
c_cond
(paren
id|addr
op_amp
(paren
id|mask
op_assign
op_complement
id|mask
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|mask
op_assign
id|ntohl
c_func
(paren
id|mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
(paren
id|mask
op_plus
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|rt_new
r_static
r_int
id|rt_new
c_func
(paren
r_struct
id|rtentry
op_star
id|r
)paren
(brace
r_int
id|err
suffix:semicolon
r_char
op_star
id|devname
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
comma
id|daddr
comma
id|mask
comma
id|gw
suffix:semicolon
r_if
c_cond
(paren
(paren
id|devname
op_assign
id|r-&gt;rt_dev
)paren
op_ne
l_int|NULL
)paren
(brace
id|err
op_assign
id|getname
c_func
(paren
id|devname
comma
op_amp
id|devname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|dev
op_assign
id|dev_get
c_func
(paren
id|devname
)paren
suffix:semicolon
id|putname
c_func
(paren
id|devname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r-&gt;rt_dst.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
id|flags
op_assign
id|r-&gt;rt_flags
suffix:semicolon
id|daddr
op_assign
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_dst
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
suffix:semicolon
id|mask
op_assign
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_genmask
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
suffix:semicolon
id|gw
op_assign
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_gateway
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
suffix:semicolon
r_if
c_cond
(paren
id|bad_mask
c_func
(paren
id|mask
comma
id|daddr
)paren
)paren
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|RTF_HOST
)paren
id|mask
op_assign
l_int|0xffffffff
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mask
op_logical_and
id|r-&gt;rt_genmask.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|RTF_GATEWAY
)paren
(brace
r_if
c_cond
(paren
id|r-&gt;rt_gateway.sa_family
op_ne
id|AF_INET
)paren
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
id|dev
op_assign
id|get_gw_dev
c_func
(paren
id|gw
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
id|dev
op_assign
id|dev_check
c_func
(paren
id|daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
id|rt_add
c_func
(paren
id|flags
comma
id|daddr
comma
id|mask
comma
id|gw
comma
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|rt_kill
r_static
r_int
id|rt_kill
c_func
(paren
r_struct
id|rtentry
op_star
id|r
)paren
(brace
r_struct
id|sockaddr_in
op_star
id|trg
suffix:semicolon
id|trg
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_dst
suffix:semicolon
id|rt_del
c_func
(paren
id|trg-&gt;sin_addr.s_addr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Called from the PROCfs module. */
r_int
DECL|function|rt_get_info
id|rt_get_info
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_struct
id|rtable
op_star
id|r
suffix:semicolon
r_char
op_star
id|pos
suffix:semicolon
id|pos
op_assign
id|buffer
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|pos
comma
l_string|&quot;Iface&bslash;tDestination&bslash;tGateway &bslash;tFlags&bslash;tRefCnt&bslash;tUse&bslash;tMetric&bslash;tMask&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* This isn&squot;t quite right -- r-&gt;rt_dst is a struct! */
r_for
c_loop
(paren
id|r
op_assign
id|rt_base
suffix:semicolon
id|r
op_ne
l_int|NULL
suffix:semicolon
id|r
op_assign
id|r-&gt;rt_next
)paren
(brace
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|pos
comma
l_string|&quot;%s&bslash;t%08lX&bslash;t%08lX&bslash;t%02X&bslash;t%d&bslash;t%lu&bslash;t%d&bslash;t%08lX&bslash;n&quot;
comma
id|r-&gt;rt_dev-&gt;name
comma
id|r-&gt;rt_dst
comma
id|r-&gt;rt_gateway
comma
id|r-&gt;rt_flags
comma
id|r-&gt;rt_refcnt
comma
id|r-&gt;rt_use
comma
id|r-&gt;rt_metric
comma
id|r-&gt;rt_mask
)paren
suffix:semicolon
)brace
r_return
id|pos
op_minus
id|buffer
suffix:semicolon
)brace
multiline_comment|/*&n; * This is hackish, but results in better code. Use &quot;-S&quot; to see why.&n; */
DECL|macro|early_out
mdefine_line|#define early_out ({ goto no_route; 1; })
DECL|function|rt_route
r_struct
id|rtable
op_star
id|rt_route
c_func
(paren
r_int
r_int
id|daddr
comma
r_struct
id|options
op_star
id|opt
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_for
c_loop
(paren
id|rt
op_assign
id|rt_base
suffix:semicolon
id|rt
op_ne
l_int|NULL
op_logical_or
id|early_out
suffix:semicolon
id|rt
op_assign
id|rt-&gt;rt_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|rt-&gt;rt_dst
op_xor
id|daddr
)paren
op_amp
id|rt-&gt;rt_mask
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* broadcast addresses can be special cases.. */
r_if
c_cond
(paren
(paren
id|rt-&gt;rt_dev-&gt;flags
op_amp
id|IFF_BROADCAST
)paren
op_logical_and
id|rt-&gt;rt_dev-&gt;pa_brdaddr
op_eq
id|daddr
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|daddr
op_eq
id|rt-&gt;rt_dev-&gt;pa_addr
)paren
(brace
r_if
c_cond
(paren
(paren
id|rt
op_assign
id|rt_loopback
)paren
op_eq
l_int|NULL
)paren
r_goto
id|no_route
suffix:semicolon
)brace
id|rt-&gt;rt_use
op_increment
suffix:semicolon
r_return
id|rt
suffix:semicolon
id|no_route
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|get_old_rtent
r_static
r_int
id|get_old_rtent
c_func
(paren
r_struct
id|old_rtentry
op_star
id|src
comma
r_struct
id|rtentry
op_star
id|rt
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|old_rtentry
id|tmp
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|src
comma
r_sizeof
(paren
op_star
id|src
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|tmp
comma
id|src
comma
r_sizeof
(paren
op_star
id|src
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|rt
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|rt
)paren
)paren
suffix:semicolon
id|rt-&gt;rt_dst
op_assign
id|tmp.rt_dst
suffix:semicolon
id|rt-&gt;rt_gateway
op_assign
id|tmp.rt_gateway
suffix:semicolon
id|rt-&gt;rt_genmask.sa_family
op_assign
id|AF_INET
suffix:semicolon
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|rt-&gt;rt_genmask
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
op_assign
id|tmp.rt_genmask
suffix:semicolon
id|rt-&gt;rt_flags
op_assign
id|tmp.rt_flags
suffix:semicolon
id|rt-&gt;rt_dev
op_assign
id|tmp.rt_dev
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|rt_ioctl
r_int
id|rt_ioctl
c_func
(paren
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|rtentry
id|rt
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|DDIOCSDBG
suffix:colon
r_return
id|dbg_ioctl
c_func
(paren
id|arg
comma
id|DBG_RT
)paren
suffix:semicolon
r_case
id|SIOCADDRTOLD
suffix:colon
r_case
id|SIOCDELRTOLD
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|err
op_assign
id|get_old_rtent
c_func
(paren
(paren
r_struct
id|old_rtentry
op_star
)paren
id|arg
comma
op_amp
id|rt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_return
(paren
id|cmd
op_eq
id|SIOCDELRTOLD
)paren
ques
c_cond
id|rt_kill
c_func
(paren
op_amp
id|rt
)paren
suffix:colon
id|rt_new
c_func
(paren
op_amp
id|rt
)paren
suffix:semicolon
r_case
id|SIOCADDRT
suffix:colon
r_case
id|SIOCDELRT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|rtentry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|rt
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|rtentry
)paren
)paren
suffix:semicolon
r_return
(paren
id|cmd
op_eq
id|SIOCDELRT
)paren
ques
c_cond
id|rt_kill
c_func
(paren
op_amp
id|rt
)paren
suffix:colon
id|rt_new
c_func
(paren
op_amp
id|rt
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
eof
