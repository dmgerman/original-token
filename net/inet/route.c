multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;ROUTE - implementation of the IP router.&n; *&n; * Version:&t;@(#)route.c&t;1.0.14&t;05/31/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &quot;inet.h&quot;
macro_line|#include &quot;timer.h&quot;
macro_line|#include &quot;dev.h&quot;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;route.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &quot;skbuff.h&quot;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &quot;arp.h&quot;
macro_line|#include &quot;icmp.h&quot;
DECL|variable|rt_base
r_static
r_struct
id|rtable
op_star
id|rt_base
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Dump the contents of a routing table entry. */
r_static
r_void
DECL|function|rt_print
id|rt_print
c_func
(paren
r_struct
id|rtable
op_star
id|rt
)paren
(brace
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
op_logical_or
id|inet_debug
op_ne
id|DBG_RT
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RT: %06lx NXT=%06lx FLAGS=0x%02lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|rt
comma
(paren
r_int
)paren
id|rt-&gt;rt_next
comma
id|rt-&gt;rt_flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    TARGET=%s &quot;
comma
id|in_ntoa
c_func
(paren
id|rt-&gt;rt_dst
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;GW=%s &quot;
comma
id|in_ntoa
c_func
(paren
id|rt-&gt;rt_gateway
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    DEV=%s USE=%ld REF=%ld&bslash;n&quot;
comma
(paren
id|rt-&gt;rt_dev
op_eq
l_int|NULL
)paren
ques
c_cond
l_string|&quot;NONE&quot;
suffix:colon
id|rt-&gt;rt_dev-&gt;name
comma
id|rt-&gt;rt_use
comma
id|rt-&gt;rt_refcnt
)paren
suffix:semicolon
)brace
multiline_comment|/* Remove a routing table entry. */
r_static
r_void
DECL|function|rt_del
id|rt_del
c_func
(paren
r_int
r_int
id|dst
)paren
(brace
r_struct
id|rtable
op_star
id|r
comma
op_star
id|x
comma
op_star
id|p
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_RT
comma
l_string|&quot;RT: flushing for dst %s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|dst
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_assign
id|rt_base
)paren
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|p
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|r
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|r-&gt;rt_dst
op_eq
id|dst
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
id|rt_base
op_assign
id|r-&gt;rt_next
suffix:semicolon
r_else
id|p-&gt;rt_next
op_assign
id|r-&gt;rt_next
suffix:semicolon
id|x
op_assign
id|r-&gt;rt_next
suffix:semicolon
id|kfree_s
c_func
(paren
id|r
comma
r_sizeof
(paren
r_struct
id|rtable
)paren
)paren
suffix:semicolon
id|r
op_assign
id|x
suffix:semicolon
)brace
r_else
(brace
id|p
op_assign
id|r
suffix:semicolon
id|r
op_assign
id|r-&gt;rt_next
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Remove all routing table entries for a device. */
r_void
DECL|function|rt_flush
id|rt_flush
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|rtable
op_star
id|r
comma
op_star
id|x
comma
op_star
id|p
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_RT
comma
l_string|&quot;RT: flushing for dev 0x%08lx (%s)&bslash;n&quot;
comma
(paren
r_int
)paren
id|dev
comma
id|dev-&gt;name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_assign
id|rt_base
)paren
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|p
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|r
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|r-&gt;rt_dev
op_eq
id|dev
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
id|rt_base
op_assign
id|r-&gt;rt_next
suffix:semicolon
r_else
id|p-&gt;rt_next
op_assign
id|r-&gt;rt_next
suffix:semicolon
id|x
op_assign
id|r-&gt;rt_next
suffix:semicolon
id|kfree_s
c_func
(paren
id|r
comma
r_sizeof
(paren
r_struct
id|rtable
)paren
)paren
suffix:semicolon
id|r
op_assign
id|x
suffix:semicolon
)brace
r_else
(brace
id|p
op_assign
id|r
suffix:semicolon
id|r
op_assign
id|r-&gt;rt_next
suffix:semicolon
)brace
)brace
)brace
r_void
DECL|function|rt_add
id|rt_add
c_func
(paren
r_int
id|flags
comma
r_int
r_int
id|dst
comma
r_int
r_int
id|gw
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|rtable
op_star
id|r
comma
op_star
id|r1
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_int
id|mask
suffix:semicolon
multiline_comment|/* Allocate an entry. */
id|rt
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|rtable
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt
op_eq
l_int|NULL
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_RT
comma
l_string|&quot;RT: no memory for new route!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Fill in the fields. */
id|memset
c_func
(paren
id|rt
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|rtable
)paren
)paren
suffix:semicolon
id|rt-&gt;rt_flags
op_assign
(paren
id|flags
op_or
id|RTF_UP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gw
op_ne
l_int|0
)paren
id|rt-&gt;rt_flags
op_or_assign
id|RTF_GATEWAY
suffix:semicolon
id|rt-&gt;rt_dev
op_assign
id|dev
suffix:semicolon
id|rt-&gt;rt_gateway
op_assign
id|gw
suffix:semicolon
multiline_comment|/*&n;   * If this is coming from an ICMP redirect message, truncate&n;   * the TARGET if we are creating an entry for a NETWORK. Use&n;   * an Internet class C network mask.  Yuck :-(&n;   */
r_if
c_cond
(paren
id|flags
op_amp
id|RTF_DYNAMIC
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|RTF_HOST
)paren
id|rt-&gt;rt_dst
op_assign
id|dst
suffix:semicolon
r_else
id|rt-&gt;rt_dst
op_assign
(paren
id|dst
op_amp
id|htonl
c_func
(paren
id|IN_CLASSC_NET
)paren
)paren
suffix:semicolon
)brace
r_else
id|rt-&gt;rt_dst
op_assign
id|dst
suffix:semicolon
id|rt_print
c_func
(paren
id|rt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rt_base
op_eq
l_int|NULL
)paren
(brace
id|rt-&gt;rt_next
op_assign
l_int|NULL
suffix:semicolon
id|rt_base
op_assign
id|rt
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;   * What we have to do is loop though this until we have&n;   * found the first address which has the same generality&n;   * as the one in rt.  Then we can put rt in after it.&n;   */
r_for
c_loop
(paren
id|mask
op_assign
l_int|0xff000000
suffix:semicolon
id|mask
op_ne
l_int|0xffffffff
suffix:semicolon
id|mask
op_assign
(paren
id|mask
op_rshift
l_int|8
)paren
op_or
id|mask
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
id|dst
)paren
(brace
id|mask
op_assign
id|mask
op_lshift
l_int|8
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_RT
comma
l_string|&quot;RT: mask = %X&bslash;n&quot;
comma
id|mask
)paren
)paren
suffix:semicolon
id|r1
op_assign
id|rt_base
suffix:semicolon
multiline_comment|/* See if we are getting a duplicate. */
r_for
c_loop
(paren
id|r
op_assign
id|rt_base
suffix:semicolon
id|r
op_ne
l_int|NULL
suffix:semicolon
id|r
op_assign
id|r-&gt;rt_next
)paren
(brace
r_if
c_cond
(paren
id|r-&gt;rt_dst
op_eq
id|dst
)paren
(brace
r_if
c_cond
(paren
id|r
op_eq
id|rt_base
)paren
(brace
id|rt-&gt;rt_next
op_assign
id|r-&gt;rt_next
suffix:semicolon
id|rt_base
op_assign
id|rt
suffix:semicolon
)brace
r_else
(brace
id|rt-&gt;rt_next
op_assign
id|r-&gt;rt_next
suffix:semicolon
id|r1-&gt;rt_next
op_assign
id|rt
suffix:semicolon
)brace
id|kfree_s
c_func
(paren
id|r
comma
r_sizeof
(paren
r_struct
id|rtable
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|r-&gt;rt_dst
op_amp
id|mask
)paren
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_RT
comma
l_string|&quot;RT: adding before r=%X&bslash;n&quot;
comma
id|r
)paren
)paren
suffix:semicolon
id|rt_print
c_func
(paren
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
id|rt_base
)paren
(brace
id|rt-&gt;rt_next
op_assign
id|rt_base
suffix:semicolon
id|rt_base
op_assign
id|rt
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rt-&gt;rt_next
op_assign
id|r
suffix:semicolon
id|r1-&gt;rt_next
op_assign
id|rt
suffix:semicolon
r_return
suffix:semicolon
)brace
id|r1
op_assign
id|r
suffix:semicolon
)brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_RT
comma
l_string|&quot;RT: adding after r1=%X&bslash;n&quot;
comma
id|r1
)paren
)paren
suffix:semicolon
id|rt_print
c_func
(paren
id|r1
)paren
suffix:semicolon
multiline_comment|/* Goes at the end. */
id|rt-&gt;rt_next
op_assign
l_int|NULL
suffix:semicolon
id|r1-&gt;rt_next
op_assign
id|rt
suffix:semicolon
)brace
r_static
r_int
DECL|function|rt_new
id|rt_new
c_func
(paren
r_struct
id|rtentry
op_star
id|r
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r-&gt;rt_dst.sa_family
op_ne
id|AF_INET
)paren
op_logical_or
(paren
id|r-&gt;rt_gateway.sa_family
op_ne
id|AF_INET
)paren
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_RT
comma
l_string|&quot;RT: We only know about AF_INET !&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EAFNOSUPPORT
suffix:semicolon
)brace
multiline_comment|/*&n;   * I admit that the following bits of code were &quot;inspired&quot; by&n;   * the Berkeley UNIX system source code.  I could think of no&n;   * other way to find out how to make it compatible with it (I&n;   * want this to be compatible to get &quot;routed&quot; up and running).&n;   * -FvK&n;   */
multiline_comment|/* If we have a &squot;gateway&squot; route here, check the correct address. */
r_if
c_cond
(paren
id|r-&gt;rt_flags
op_amp
id|RTF_GATEWAY
)paren
(brace
id|dev
op_assign
id|dev_check
c_func
(paren
l_int|0
comma
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_gateway
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|dev
op_assign
id|dev_check
c_func
(paren
l_int|1
comma
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_gateway
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Aii.  We are using an indirect route.  Check the already&n;&t; * existing routing table for an entry.&n;&t; */
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|rt
op_assign
id|rt_base
suffix:semicolon
id|rt
op_ne
l_int|NULL
suffix:semicolon
id|rt
op_assign
id|rt-&gt;rt_next
)paren
(brace
r_if
c_cond
(paren
(paren
id|rt-&gt;rt_dev-&gt;flags
op_amp
id|IFF_UP
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ip_addr_match
c_func
(paren
id|rt-&gt;rt_dst
comma
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_gateway
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
)paren
)paren
(brace
id|dev
op_assign
id|rt-&gt;rt_dev
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip_addr_match
c_func
(paren
id|rt-&gt;rt_dev-&gt;pa_brdaddr
comma
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_gateway
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
)paren
)paren
(brace
id|dev
op_assign
id|rt-&gt;rt_dev
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
id|dev
op_assign
id|dev_check
c_func
(paren
l_int|0
comma
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_dst
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|dev
op_assign
id|dev_check
c_func
(paren
l_int|1
comma
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_dst
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Aii.  We are using an indirect route.  Check the already&n;&t; * existing routing table for an entry.&n;&t; */
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|rt
op_assign
id|rt_base
suffix:semicolon
id|rt
op_ne
l_int|NULL
suffix:semicolon
id|rt
op_assign
id|rt-&gt;rt_next
)paren
(brace
r_if
c_cond
(paren
(paren
id|rt-&gt;rt_dev-&gt;flags
op_amp
id|IFF_UP
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ip_addr_match
c_func
(paren
id|rt-&gt;rt_dst
comma
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_dst
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
)paren
)paren
(brace
id|dev
op_assign
id|rt-&gt;rt_dev
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip_addr_match
c_func
(paren
id|rt-&gt;rt_dev-&gt;pa_brdaddr
comma
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_dst
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
)paren
)paren
(brace
id|dev
op_assign
id|rt-&gt;rt_dev
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_RT
comma
l_string|&quot;RT: dev for %s gw &quot;
comma
id|in_ntoa
c_func
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_dst.sin_addr.s_addr
)paren
)paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_RT
comma
l_string|&quot;%s (0x%04X) is 0x%X (%s)&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_gateway.sin_addr.s_addr
)paren
comma
id|r-&gt;rt_flags
comma
id|dev
comma
(paren
id|dev
op_eq
l_int|NULL
)paren
ques
c_cond
l_string|&quot;NONE&quot;
suffix:colon
id|dev-&gt;name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENETUNREACH
suffix:semicolon
id|rt_add
c_func
(paren
id|r-&gt;rt_flags
comma
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_dst.sin_addr.s_addr
comma
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_gateway.sin_addr.s_addr
comma
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|rt_kill
id|rt_kill
c_func
(paren
r_struct
id|rtentry
op_star
id|r
)paren
(brace
r_struct
id|sockaddr_in
op_star
id|trg
suffix:semicolon
id|trg
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|r-&gt;rt_dst
suffix:semicolon
id|rt_del
c_func
(paren
id|trg-&gt;sin_addr.s_addr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Called from the PROCfs module. */
r_int
DECL|function|rt_get_info
id|rt_get_info
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_struct
id|rtable
op_star
id|r
suffix:semicolon
r_char
op_star
id|pos
suffix:semicolon
id|pos
op_assign
id|buffer
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|pos
comma
l_string|&quot;Iface&bslash;tDestination&bslash;tGateway &bslash;tFlags&bslash;tRefCnt&bslash;tUse&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|r
op_assign
id|rt_base
suffix:semicolon
id|r
op_ne
l_int|NULL
suffix:semicolon
id|r
op_assign
id|r-&gt;rt_next
)paren
(brace
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|pos
comma
l_string|&quot;%s&bslash;t%08X&bslash;t%08X&bslash;t%02X&bslash;t%d&bslash;t%d&bslash;n&quot;
comma
id|r-&gt;rt_dev-&gt;name
comma
id|r-&gt;rt_dst
comma
id|r-&gt;rt_gateway
comma
id|r-&gt;rt_flags
comma
id|r-&gt;rt_refcnt
comma
id|r-&gt;rt_use
)paren
suffix:semicolon
)brace
r_return
id|pos
op_minus
id|buffer
suffix:semicolon
)brace
r_struct
id|rtable
op_star
DECL|function|rt_route
id|rt_route
c_func
(paren
r_int
r_int
id|daddr
comma
r_struct
id|options
op_star
id|opt
)paren
(brace
r_struct
id|rtable
op_star
id|rt
suffix:semicolon
multiline_comment|/*&n;   * This is a hack, I think. -FvK&n;   */
r_if
c_cond
(paren
id|chk_addr
c_func
(paren
id|daddr
)paren
op_eq
id|IS_MYADDR
)paren
id|daddr
op_assign
id|my_addr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;   * Loop over the IP routing table to find a route suitable&n;   * for this packet.  Note that we really should have a look&n;   * at the IP options to see if we have been given a hint as&n;   * to what kind of path we should use... -FvK&n;   */
r_for
c_loop
(paren
id|rt
op_assign
id|rt_base
suffix:semicolon
id|rt
op_ne
l_int|NULL
suffix:semicolon
id|rt
op_assign
id|rt-&gt;rt_next
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_RT
comma
l_string|&quot;RT: %s via &quot;
comma
id|in_ntoa
c_func
(paren
id|daddr
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip_addr_match
c_func
(paren
id|rt-&gt;rt_dst
comma
id|daddr
)paren
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_RT
comma
l_string|&quot;%s (%s)&bslash;n&quot;
comma
id|rt-&gt;rt_dev-&gt;name
comma
id|in_ntoa
c_func
(paren
id|rt-&gt;rt_gateway
)paren
)paren
)paren
suffix:semicolon
id|rt-&gt;rt_use
op_increment
suffix:semicolon
r_return
id|rt
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip_addr_match
c_func
(paren
id|rt-&gt;rt_dev-&gt;pa_brdaddr
comma
id|daddr
)paren
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_RT
comma
l_string|&quot;%s (BCAST %s)&bslash;n&quot;
comma
id|rt-&gt;rt_dev-&gt;name
comma
id|in_ntoa
c_func
(paren
id|rt-&gt;rt_dev-&gt;pa_brdaddr
)paren
)paren
)paren
suffix:semicolon
id|rt-&gt;rt_use
op_increment
suffix:semicolon
r_return
id|rt
suffix:semicolon
)brace
)brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_RT
comma
l_string|&quot;NONE&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
suffix:semicolon
r_int
DECL|function|rt_ioctl
id|rt_ioctl
c_func
(paren
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|rtentry
id|rt
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|DDIOCSDBG
suffix:colon
id|ret
op_assign
id|dbg_ioctl
c_func
(paren
id|arg
comma
id|DBG_RT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCADDRT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|rtentry
)paren
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|rt
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|rtentry
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|rt_new
c_func
(paren
op_amp
id|rt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCDELRT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|rtentry
)paren
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|rt
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|rtentry
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|rt_kill
c_func
(paren
op_amp
id|rt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
eof
