multiline_comment|/*&n; *&t;d_link.c&n; *&n; *&t;Portions (C) Copyright 1993 by Bjorn Ekwall&n; *&t;The Author may be reached as bj0rn@blox.se&n; *&n; *&t;Linux driver for the D-Link Ethernet pocket adapter.&n; *&t;Based on sources from linux 0.99pl5&n; *&t;and on a sample network driver core for linux.&n; *&n; *&t;Sample driver written 1993 by Donald Becker &lt;becker@super.org&gt;&n; *&t;C/O Supercomputing Research Ctr., 17100 Science Dr., Bowie MD 20715&n; *&n; *&t;compile-command:&n; *&t;&quot;gcc -DKERNEL -Wall -O6 -fomit-frame-pointer -c d_link.c&quot;&n; */
multiline_comment|/*************************************************************&n; * If you have trouble reading/writing to the adapter,&n; * uncomment the following &quot;#define&quot;:&n;#define REALLY_SLOW_IO&n; */
multiline_comment|/* $Id: d_link.c,v 0.21 1993/06/02 19:41:00 waltje Exp $ */
multiline_comment|/* $Log: d_link.c,v $&n; * Revision 0.21  1993/06/02  19:41:00 waltje&n; * Applied multi-IRQ fix from Bjorn Ekwall and increaded version&n; * number to 0.21.&n; *&n; * Revision 0.20  1993/03/26  11:43:53  root&n; * Changed version number to indicate &quot;alpha+&quot; (almost beta :-)&n; *&n; * Revision 0.16  1993/03/26  11:26:46  root&n; * Last ALPHA-minus version.&n; * REALLY_SLOW_IO choice included (at line 20)&n; * SLOW_DOWN_IO added anyway in convenience macros/functions&n; * Test of D_LINK_FIFO included (not completely debugged)&n; *&n; * Revision 0.15  1993/03/24  14:00:49  root&n; * Modified the interrupt handling considerably.&n; * (The .asm source had me fooled in how it _really_ works :-)&n; *&n; * Revision 0.14  1993/03/21  01:57:25  root&n; * Modified the interrupthandler for more robustness (hopefully :-)&n; *&n; * Revision 0.13  1993/03/19  11:45:09  root&n; * Re-write of ALPHA release using Don Beckers skeleton (still works, kind of ...:-)&n; *&n; * Revision 0.12  1993/03/16  13:22:21  root&n; * working ALPHA-release&n; *&n; */
DECL|variable|version
r_static
r_char
op_star
id|version
op_assign
l_string|&quot;d_link.c: $Revision: 0.21 $,  Bjorn Ekwall (bj0rn@blox.se)&bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n; *&t;Based on adapter information gathered from DE600.ASM by D-Link Inc.,&n; *&t;as included on disk C in the v.2.11 of PC/TCP from FTP Software.&n; *&n; *&t;For DE600.asm:&n; *&t;&t;Portions (C) Copyright 1990 D-Link, Inc.&n; *&t;&t;Copyright, 1988-1992, Russell Nelson, Crynwr Software&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2, or (at your option)&n; *&t;any later version.&n; *&n; *&t;This program is distributed in the hope that it will be useful,&n; *&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *&t;GNU General Public License for more details.&n; *&n; *&t;You should have received a copy of the GNU General Public License&n; *&t;along with this program; if not, write to the Free Software&n; *&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. &n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;netinet/in.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &quot;inet.h&quot;
macro_line|#include &quot;dev.h&quot;
macro_line|#include &quot;eth.h&quot;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;route.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &quot;skbuff.h&quot;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &quot;arp.h&quot;
multiline_comment|/* use 0 for production, 1 for verification, &gt;2 for debug */
macro_line|#ifndef D_LINK_DEBUG
DECL|macro|D_LINK_DEBUG
mdefine_line|#define D_LINK_DEBUG 0
macro_line|#endif
DECL|variable|d_link_debug
r_static
r_int
r_int
id|d_link_debug
op_assign
id|D_LINK_DEBUG
suffix:semicolon
macro_line|#ifdef D_LINK_DEBUG
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x) if (d_link_debug &gt;= 2) printk x
macro_line|#else
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x) /**/
macro_line|#endif
multiline_comment|/**************************************************&n; *                                                *&n; * Definition of D-Link Ethernet Pocket adapter   *&n; *                                                *&n; **************************************************/
multiline_comment|/*&n; * D-Link Ethernet pocket adapter ports&n; */
DECL|macro|DATA_PORT
mdefine_line|#define DATA_PORT&t;(dev-&gt;base_addr + 0)
DECL|macro|STATUS_PORT
mdefine_line|#define STATUS_PORT&t;(dev-&gt;base_addr + 1)
DECL|macro|COMMAND_PORT
mdefine_line|#define COMMAND_PORT&t;(dev-&gt;base_addr + 2)
multiline_comment|/*&n; * D-Link COMMAND_PORT commands&n; */
DECL|macro|SELECT_NIC
mdefine_line|#define SELECT_NIC&t;0x04 /* select Network Interface Card */
DECL|macro|SELECT_PRN
mdefine_line|#define SELECT_PRN&t;0x1c /* select Printer */
DECL|macro|NML_PRN
mdefine_line|#define NML_PRN&t;&t;0xec /* normal Printer situation */
DECL|macro|IRQEN
mdefine_line|#define IRQEN&t;&t;0x10 /* enable IRQ line */
multiline_comment|/*&n; * D-Link STATUS_PORT&n; */
DECL|macro|TX_INTR
mdefine_line|#define TX_INTR&t;&t;0x88
DECL|macro|RX_INTR
mdefine_line|#define RX_INTR&t;&t;0x40
DECL|macro|OTHER_INTR
mdefine_line|#define OTHER_INTR&t;0x00 /* dummy, always false */
multiline_comment|/*&n; * D-Link DATA_PORT commands&n; * command in low 4 bits&n; * data in high 4 bits&n; * select current data nibble with HI_NIBBLE bit&n; */
DECL|macro|WRITE_DATA
mdefine_line|#define WRITE_DATA&t;0x00 /* write memory */
DECL|macro|READ_DATA
mdefine_line|#define READ_DATA&t;0x01 /* read memory */
DECL|macro|STATUS
mdefine_line|#define STATUS&t;&t;0x02 /* read  status register */
DECL|macro|COMMAND
mdefine_line|#define COMMAND&t;&t;0x03 /* write command register (see COMMAND below) */
DECL|macro|NULL_COMMAND
mdefine_line|#define NULL_COMMAND&t;0x04 /* null command */
DECL|macro|RX_LEN
mdefine_line|#define RX_LEN&t;&t;0x05 /* read  received packet length */
DECL|macro|TX_ADDR
mdefine_line|#define TX_ADDR&t;&t;0x06 /* set adapter transmit memory address */
DECL|macro|RW_ADDR
mdefine_line|#define RW_ADDR&t;&t;0x07 /* set adapter read/write memory address */
DECL|macro|HI_NIBBLE
mdefine_line|#define HI_NIBBLE&t;0x08 /* read/write the high nibble of data,&n;&t;&t;&t;&t;or-ed with rest of command */
multiline_comment|/*&n; * command register, (I don&squot;t know all about these bits...)&n; * accessed through DATA_PORT with low bits = COMMAND&n; */
DECL|macro|RX_ALL
mdefine_line|#define RX_ALL&t;&t;0x01 /* bit 0,1 = 01 */
DECL|macro|RX_BP
mdefine_line|#define RX_BP&t;&t;0x02 /* bit 0,1 = 10 */
DECL|macro|RX_MBP
mdefine_line|#define RX_MBP&t;&t;0x03 /* bit 0,1 = 11 */
DECL|macro|TX_ENABLE
mdefine_line|#define TX_ENABLE&t;0x04 /* bit 2 */
DECL|macro|RX_ENABLE
mdefine_line|#define RX_ENABLE&t;0x08 /* bit 3 */
DECL|macro|RESET
mdefine_line|#define RESET&t;&t;0x80 /* set bit 7 high */
DECL|macro|STOP_RESET
mdefine_line|#define STOP_RESET&t;0x00 /* set bit 7 low */
multiline_comment|/*&n; * data to command register&n; * (high 4 bits in write to DATA_PORT)&n; */
DECL|macro|RX_PAGE2_SELECT
mdefine_line|#define RX_PAGE2_SELECT&t;0x10 /* bit 4, only 2 pages to select */
DECL|macro|RX_BASE_PAGE
mdefine_line|#define RX_BASE_PAGE&t;0x20 /* bit 5, always set when specifying RX_ADDR */
DECL|macro|FLIP_IRQ
mdefine_line|#define FLIP_IRQ&t;0x40 /* bit 6 */
multiline_comment|/* Convenience definition, transmitter page 2 */
DECL|macro|TX_PAGE2_SELECT
mdefine_line|#define TX_PAGE2_SELECT&t;0x02
multiline_comment|/*&n; * D-Link adapter internal memory:&n; *&n; * 0-2K 1:st transmit page (send from pointer up to 2K)&n; * 2-4K&t;2:nd transmit page (send from pointer up to 4K)&n; *&n; * 4-6K 1:st receive page (data from 4K upwards)&n; * 6-8K 2:nd receive page (data from 6K upwards)&n; *&n; * 8K+&t;Adapter ROM (contains magic code and last 3 bytes of Ethernet address)&n; */
DECL|macro|MEM_2K
mdefine_line|#define MEM_2K&t;&t;0x0800 /* 2048 */
DECL|macro|MEM_4K
mdefine_line|#define MEM_4K&t;&t;0x1000 /* 4096 */
DECL|macro|NODE_ADDRESS
mdefine_line|#define NODE_ADDRESS&t;0x2000 /* 8192 */
DECL|macro|RUNT
mdefine_line|#define RUNT 64 /*56*/ /* Too small Ethernet packet */
multiline_comment|/**************************************************&n; *                                                *&n; *             End of definition                  *&n; *                                                *&n; **************************************************/
multiline_comment|/* Common network statistics -- these will be in *.h someday. */
DECL|struct|netstats
r_struct
id|netstats
(brace
DECL|member|tx_packets
r_int
id|tx_packets
suffix:semicolon
DECL|member|rx_packets
r_int
id|rx_packets
suffix:semicolon
DECL|member|tx_errors
r_int
id|tx_errors
suffix:semicolon
DECL|member|rx_errors
r_int
id|rx_errors
suffix:semicolon
DECL|member|missed_packets
r_int
id|missed_packets
suffix:semicolon
DECL|member|soft_tx_errors
r_int
id|soft_tx_errors
suffix:semicolon
DECL|member|soft_rx_errors
r_int
id|soft_rx_errors
suffix:semicolon
DECL|member|soft_trx_err_bits
r_int
id|soft_trx_err_bits
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|localstats
r_static
r_struct
id|netstats
op_star
id|localstats
suffix:semicolon
multiline_comment|/*&n; * Index to functions, as function prototypes.&n; */
multiline_comment|/* Routines used internally. (See &quot;convenience macros&quot; also) */
r_static
r_int
id|d_link_read_status
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
r_char
id|d_link_read_byte
c_func
(paren
r_int
id|type
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Put in the device structure. */
r_static
r_int
id|d_link_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|d_link_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|d_link_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Dispatch from interrupts. */
r_static
r_void
id|d_link_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
suffix:semicolon
r_static
r_void
id|d_link_tx_intr
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|d_link_rx_intr
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Initialization */
r_int
id|d_link_init
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|adapter_init
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|startp
)paren
suffix:semicolon
multiline_comment|/* Passed to sigaction() to register the interrupt handler. */
DECL|variable|d_link_sigaction
r_static
r_struct
id|sigaction
id|d_link_sigaction
op_assign
(brace
op_amp
id|d_link_interrupt
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * D-Link driver variables:&n; */
DECL|variable|rx_page
r_static
r_volatile
r_int
id|rx_page
op_assign
l_int|0
suffix:semicolon
DECL|variable|realdev
r_static
r_struct
id|device
op_star
id|realdev
suffix:semicolon
macro_line|#ifdef D_LINK_FIFO
DECL|variable|free_tx_page
r_static
r_volatile
r_int
id|free_tx_page
op_assign
l_int|0x03
suffix:semicolon
multiline_comment|/* 2 pages = 0000 0011 */
DECL|variable|busy_tx_page
r_static
r_volatile
r_int
r_int
id|busy_tx_page
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* 2 pages = 0000 0000 */
DECL|variable|transmit_next_from
r_static
r_volatile
r_int
id|transmit_next_from
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Convenience macros/functions for D-Link adapter&n; *&n; * If you are having trouble reading/writing correctly,&n; * try to uncomment the line &quot;#define REALLY_SLOW_IO&quot; (near line 20)&n; */
DECL|macro|select_prn
mdefine_line|#define select_prn() &bslash;&n;&t;outb_p(SELECT_PRN, COMMAND_PORT)
DECL|macro|select_nic
mdefine_line|#define select_nic() &bslash;&n;&t;outb_p(SELECT_NIC, COMMAND_PORT)
DECL|macro|d_link_put_byte
mdefine_line|#define d_link_put_byte(data) &bslash;&n;&t;outb_p(((data) &lt;&lt; 4)   | WRITE_DATA            , DATA_PORT); &bslash;&n;&t;outb_p(((data) &amp; 0xf0) | WRITE_DATA | HI_NIBBLE, DATA_PORT)
multiline_comment|/*&n; * The first two outb_p()&squot;s below could perhaps be deleted if there&n; * would be more delay in the last two. Not certain about it yet...&n; */
DECL|macro|d_link_put_command
mdefine_line|#define d_link_put_command(cmd) &bslash;&n;&t;outb_p(( rx_page        &lt;&lt; 4)   | COMMAND            , DATA_PORT); &bslash;&n;&t;outb_p(( rx_page        &amp; 0xf0) | COMMAND | HI_NIBBLE, DATA_PORT); &bslash;&n;&t;outb_p(((rx_page | cmd) &lt;&lt; 4)   | COMMAND            , DATA_PORT); &bslash;&n;&t;outb_p(((rx_page | cmd) &amp; 0xf0) | COMMAND | HI_NIBBLE, DATA_PORT)
DECL|macro|d_link_setup_address
mdefine_line|#define d_link_setup_address(addr,type) &bslash;&n;&t;outb_p((((addr) &lt;&lt; 4) &amp; 0xf0) | type            , DATA_PORT); &bslash;&n;&t;outb_p(( (addr)       &amp; 0xf0) | type | HI_NIBBLE, DATA_PORT); &bslash;&n;&t;outb_p((((addr) &gt;&gt; 4) &amp; 0xf0) | type            , DATA_PORT); &bslash;&n;&t;outb_p((((addr) &gt;&gt; 8) &amp; 0xf0) | type | HI_NIBBLE, DATA_PORT)
r_static
r_int
DECL|function|d_link_read_status
id|d_link_read_status
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|status
suffix:semicolon
id|select_nic
c_func
(paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|STATUS
comma
id|DATA_PORT
)paren
suffix:semicolon
id|SLOW_DOWN_IO
suffix:semicolon
multiline_comment|/* See comment line 20 */
id|status
op_assign
id|inb_p
c_func
(paren
id|STATUS_PORT
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|NULL_COMMAND
comma
id|DATA_PORT
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|NULL_COMMAND
op_or
id|HI_NIBBLE
comma
id|DATA_PORT
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
r_static
r_int
r_char
DECL|function|d_link_read_byte
id|d_link_read_byte
c_func
(paren
r_int
id|type
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
multiline_comment|/* dev used by macros */
r_int
r_char
id|lo
suffix:semicolon
id|outb_p
c_func
(paren
(paren
id|type
)paren
comma
id|DATA_PORT
)paren
suffix:semicolon
id|SLOW_DOWN_IO
suffix:semicolon
multiline_comment|/* See comment line 20 */
id|lo
op_assign
id|inb_p
c_func
(paren
id|STATUS_PORT
)paren
suffix:semicolon
id|outb_p
c_func
(paren
(paren
id|type
)paren
op_or
id|HI_NIBBLE
comma
id|DATA_PORT
)paren
suffix:semicolon
id|SLOW_DOWN_IO
suffix:semicolon
multiline_comment|/* See comment line 20 */
r_return
(paren
(paren
id|lo
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)paren
op_or
(paren
id|inb_p
c_func
(paren
id|STATUS_PORT
)paren
op_amp
l_int|0xf0
)paren
suffix:semicolon
)brace
macro_line|#ifdef D_LINK_FIFO
multiline_comment|/* Handle a &quot;fifo&quot; in an int (= busy_tx_page) */
DECL|macro|AT_FIFO_OUTPUT
macro_line|# define AT_FIFO_OUTPUT (busy_tx_page &amp; 0x0f)
DECL|macro|ANY_QUEUED_IN_FIFO
macro_line|# define ANY_QUEUED_IN_FIFO (busy_tx_page &amp; 0xf0)
DECL|macro|PULL_FROM_FIFO
macro_line|# define PULL_FROM_FIFO&t;{ busy_tx_page &gt;&gt;= 4;}
DECL|macro|PUSH_INTO_FIFO
macro_line|# define PUSH_INTO_FIFO(page) { &bslash;&n;&t;if (busy_tx_page)&t;/* there already is a transmit in progress */ &bslash;&n;&t;&t;busy_tx_page |= (page &lt;&lt; 4); &bslash;&n;&t;else &bslash;&n;&t;&t;busy_tx_page = page; &bslash;&n;&t;}
macro_line|#endif
"&f;"
multiline_comment|/*&n; * Open/initialize the board.  This is called (in the current kernel)&n; * sometime after booting when the &squot;config &lt;dev-&gt;name&gt;&squot; program is run.&n; *&n; * This routine should set everything up anew at each open, even&n; * registers that &quot;should&quot; only need to be set once at boot, so that&n; * there is a non-reboot way to recover if something goes wrong.&n; */
r_static
r_int
DECL|function|d_link_open
id|d_link_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|adapter_init
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Transmit busy...  */
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The inverse routine to d_link_open().&n; */
r_static
r_int
DECL|function|d_link_close
id|d_link_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
id|adapter_init
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|irqaction
c_func
(paren
id|dev-&gt;irq
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy a buffer to the adapter transmit page memory.&n; * Start sending.&n; */
r_static
r_int
DECL|function|d_link_start_xmit
id|d_link_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_static
r_int
id|tx_page
op_assign
l_int|0
suffix:semicolon
r_int
id|transmit_from
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|tickssofar
suffix:semicolon
r_int
r_char
op_star
id|buffer
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If some higher layer thinks we&squot;ve missed a&n;&t; * tx-done interrupt * we are passed NULL.&n;&t; * Caution: dev_tint() handles the cli()/sti() itself.&n;&t; */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|dev_tint
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* For ethernet, fill in the header (hardware addresses) with an arp. */
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;arp
op_logical_and
id|dev
op_member_access_from_pointer
id|rebuild_header
c_func
(paren
id|skb
op_plus
l_int|1
comma
id|dev
)paren
)paren
(brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|arp_queue
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef D_LINK_FIFO
r_if
c_cond
(paren
id|free_tx_page
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Do timeouts, to avoid hangs. */
macro_line|#else
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
(brace
multiline_comment|/* Do timeouts, to avoid hangs. */
macro_line|#endif
id|tickssofar
op_assign
id|jiffies
op_minus
id|dev-&gt;trans_start
suffix:semicolon
r_if
c_cond
(paren
id|tickssofar
OL
l_int|5
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* else */
id|printk
c_func
(paren
l_string|&quot;%s: transmit timed out (%d), %s?&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|tickssofar
comma
l_string|&quot;network cable problem&quot;
)paren
suffix:semicolon
multiline_comment|/* Try to restart the adapter. */
multiline_comment|/* Maybe in next release... :-)&n;&t;&t;adapter_init(dev, 1);&n;&t;&t;*/
)brace
multiline_comment|/* Start real output */
id|PRINTK
c_func
(paren
(paren
l_string|&quot;d_link_start_xmit:len=%d&bslash;n&quot;
comma
id|skb-&gt;len
)paren
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|select_nic
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef D_LINK_FIFO
multiline_comment|/* magic code selects the least significant bit in free_tx_page */
id|tx_page
op_assign
id|free_tx_page
op_amp
(paren
op_minus
id|free_tx_page
)paren
suffix:semicolon
id|free_tx_page
op_and_assign
op_complement
id|tx_page
suffix:semicolon
id|dev-&gt;tbusy
op_assign
op_logical_neg
id|free_tx_page
suffix:semicolon
multiline_comment|/* any more free pages? */
id|PUSH_INTO_FIFO
c_func
(paren
id|tx_page
)paren
suffix:semicolon
macro_line|#else
id|tx_page
op_xor_assign
id|TX_PAGE2_SELECT
suffix:semicolon
multiline_comment|/* Flip page, only 2 pages */
macro_line|#endif
r_if
c_cond
(paren
(paren
id|len
op_assign
id|skb-&gt;len
)paren
OL
id|RUNT
)paren
multiline_comment|/*&amp;&amp; Hmm...? */
id|len
op_assign
id|RUNT
suffix:semicolon
r_if
c_cond
(paren
id|tx_page
op_amp
id|TX_PAGE2_SELECT
)paren
id|transmit_from
op_assign
id|MEM_4K
op_minus
id|len
suffix:semicolon
r_else
id|transmit_from
op_assign
id|MEM_2K
op_minus
id|len
suffix:semicolon
id|d_link_setup_address
c_func
(paren
id|transmit_from
comma
id|RW_ADDR
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|len
OG
l_int|0
suffix:semicolon
op_decrement
id|len
comma
op_increment
id|buffer
)paren
(brace
id|d_link_put_byte
c_func
(paren
op_star
id|buffer
)paren
suffix:semicolon
multiline_comment|/* macro! watch out for side effects! */
)brace
macro_line|#ifdef D_LINK_FIFO
r_if
c_cond
(paren
id|ANY_QUEUED_IN_FIFO
op_eq
l_int|0
)paren
(brace
multiline_comment|/* there is no transmit in progress */
id|d_link_setup_address
c_func
(paren
id|transmit_from
comma
id|TX_ADDR
)paren
suffix:semicolon
id|d_link_put_command
c_func
(paren
id|TX_ENABLE
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
r_else
(brace
id|transmit_next_from
op_assign
id|transmit_from
suffix:semicolon
)brace
macro_line|#else
id|d_link_setup_address
c_func
(paren
id|transmit_from
comma
id|TX_ADDR
)paren
suffix:semicolon
id|d_link_put_command
c_func
(paren
id|TX_ENABLE
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
macro_line|#endif
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* interrupts back on */
r_if
c_cond
(paren
id|skb-&gt;free
)paren
(brace
id|kfree_skb
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * The typical workload of the driver:&n; * Handle the network interface interrupts.&n; */
r_static
r_void
DECL|function|d_link_interrupt
id|d_link_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
(brace
r_int
id|irq
op_assign
op_minus
(paren
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
id|reg_ptr
)paren
op_member_access_from_pointer
id|orig_eax
op_plus
l_int|2
)paren
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
id|realdev
suffix:semicolon
r_int
id|interrupts
suffix:semicolon
multiline_comment|/* Get corresponding device */
multiline_comment|/*&n;&t;for (dev = dev_base; dev != NULL; dev = dev-&gt;next) {&n;&t;&t;if (dev-&gt;irq == irq)&n;&t;&t;&t;break;&n;&t;}&n;*/
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;d_link_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;start
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
multiline_comment|/*&amp;&amp; bogus interrupt at boot!?!?!? */
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Allow other interrupts. */
id|localstats
op_assign
(paren
r_struct
id|netstats
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|interrupts
op_assign
id|d_link_read_status
c_func
(paren
id|dev
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;d_link_interrupt (%2.2X)&bslash;n&quot;
comma
id|interrupts
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Interrupts have been observed to be:&n;&t; *&n;&t; * Value&t;My interpretation&n;&t; * -----&t;-----------------&n;&t; * 0x47&t;&t;Normal receive interrupt&n;&t; * 0x4F&t;&t;Receive AND transmit interrupt simultaneously&n;&t; * 0x87&t;&t;Normal transmit interrupt (? I treat it as such...)&n;&t; * 0x8F&t;&t;Normal transmit interrupt&n;&t; */
multiline_comment|/*&n;&t; * Take care of TX interrupts first, in case there is an extra&n;         * page to transmit (keep the adapter busy while we work).&n;&t; */
r_if
c_cond
(paren
id|interrupts
op_amp
id|TX_INTR
)paren
(brace
multiline_comment|/* 1xxx 1xxx */
id|d_link_tx_intr
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|interrupts
op_amp
id|RX_INTR
)paren
(brace
multiline_comment|/* x1xx xxxx */
id|d_link_rx_intr
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* I&squot;m not sure if there are any other interrupts from D-Link... */
r_if
c_cond
(paren
id|d_link_debug
op_logical_and
(paren
id|interrupts
op_amp
id|OTHER_INTR
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unknown interrupt %#2x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|interrupts
)paren
suffix:semicolon
)brace
multiline_comment|/* Check comment near line 20! */
r_if
c_cond
(paren
(paren
id|interrupts
op_ne
l_int|0x47
)paren
op_logical_and
(paren
id|interrupts
op_ne
l_int|0x87
)paren
op_logical_and
(paren
id|interrupts
op_ne
l_int|0x4F
)paren
op_logical_and
(paren
id|interrupts
op_ne
l_int|0x8F
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;Strange d_link_interrupt: &lt;%2.2X&gt;&bslash;n&quot;
comma
id|interrupts
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Enable adapter interrupts */
id|select_prn
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Do internal handshake: Transmitter done (of this page).&n; * Also handle the case of a pending transmit page.&n; */
r_static
r_void
DECL|function|d_link_tx_intr
id|d_link_tx_intr
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|localstats-&gt;tx_packets
op_increment
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef D_LINK_FIFO
id|free_tx_page
op_or_assign
id|AT_FIFO_OUTPUT
suffix:semicolon
id|PULL_FROM_FIFO
suffix:semicolon
r_if
c_cond
(paren
id|AT_FIFO_OUTPUT
op_ne
l_int|0
)paren
(brace
multiline_comment|/* more in queue! */
id|d_link_setup_address
c_func
(paren
id|transmit_next_from
comma
id|TX_ADDR
)paren
suffix:semicolon
id|d_link_put_command
c_func
(paren
id|TX_ENABLE
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
macro_line|#endif
id|mark_bh
c_func
(paren
id|INET_BH
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We have a good packet(s), get it/them out of the buffers.&n; */
r_static
r_void
DECL|function|d_link_rx_intr
id|d_link_rx_intr
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
id|sksize
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
multiline_comment|/* Get size of received packet */
multiline_comment|/* Ignore trailing 4 CRC-bytes */
id|size
op_assign
id|d_link_read_byte
c_func
(paren
id|RX_LEN
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* low byte */
id|size
op_assign
id|size
op_plus
(paren
id|d_link_read_byte
c_func
(paren
id|RX_LEN
comma
id|dev
)paren
op_lshift
l_int|8
)paren
op_minus
l_int|4
suffix:semicolon
multiline_comment|/* Tell adapter where to store next incoming packet, enable receiver */
id|rx_page
op_xor_assign
id|RX_PAGE2_SELECT
suffix:semicolon
multiline_comment|/* Flip bit, only 2 pages */
id|d_link_put_command
c_func
(paren
id|RX_ENABLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
multiline_comment|/* Read all the frames? */
r_return
suffix:semicolon
multiline_comment|/* Done for now */
r_if
c_cond
(paren
(paren
id|size
template_param
l_int|1535
)paren
op_logical_and
id|d_link_debug
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Bogus packet size %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|size
)paren
suffix:semicolon
id|sksize
op_assign
r_sizeof
(paren
r_struct
id|sk_buff
)paren
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|kmalloc
c_func
(paren
id|sksize
comma
id|GFP_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|d_link_debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Couldn&squot;t allocate a sk_buff of size %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|sksize
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* else */
id|skb-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;mem_len
op_assign
id|sksize
suffix:semicolon
id|skb-&gt;mem_addr
op_assign
id|skb
suffix:semicolon
multiline_comment|/* &squot;skb + 1&squot; points to the start of sk_buff data area. */
id|buffer
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|skb
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Get packet */
multiline_comment|/* Tell adapter from where we want to read this packet */
r_if
c_cond
(paren
id|rx_page
op_amp
id|RX_PAGE2_SELECT
)paren
(brace
id|d_link_setup_address
c_func
(paren
id|MEM_4K
comma
id|RW_ADDR
)paren
suffix:semicolon
)brace
r_else
(brace
id|d_link_setup_address
c_func
(paren
id|MEM_4K
op_plus
id|MEM_2K
comma
id|RW_ADDR
)paren
suffix:semicolon
)brace
multiline_comment|/* copy the packet into the buffer */
r_for
c_loop
(paren
id|i
op_assign
id|size
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
(brace
op_star
id|buffer
op_increment
op_assign
id|d_link_read_byte
c_func
(paren
id|READ_DATA
comma
id|dev
)paren
suffix:semicolon
)brace
id|localstats-&gt;rx_packets
op_increment
suffix:semicolon
multiline_comment|/* count all receives */
r_if
c_cond
(paren
id|dev_rint
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|skb
comma
id|size
comma
id|IN_SKBUFF
comma
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: receive buffers full.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If any worth-while packets have been received, dev_rint()&n;&t; * has done a mark_bh(INET_BH) for us and will work on them&n;&t; * when we get to the bottom-half routine.&n;&t; */
r_return
suffix:semicolon
)brace
r_int
DECL|function|d_link_init
id|d_link_init
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: D-Link pocket adapter&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Alpha testers must have the version number to report bugs. */
r_if
c_cond
(paren
id|d_link_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
multiline_comment|/* probe for adapter */
id|rx_page
op_assign
l_int|0
suffix:semicolon
(paren
r_void
)paren
id|d_link_read_status
c_func
(paren
id|dev
)paren
suffix:semicolon
id|d_link_put_command
c_func
(paren
id|RESET
)paren
suffix:semicolon
id|d_link_put_command
c_func
(paren
id|STOP_RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d_link_read_status
c_func
(paren
id|dev
)paren
op_amp
l_int|0xf0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;: probe failed at %#3x.&bslash;n&quot;
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Maybe we found one,&n;&t; * have to check if it is a D-Link adapter...&n;&t; */
multiline_comment|/* Get the adapter ethernet address from the ROM */
id|d_link_setup_address
c_func
(paren
id|NODE_ADDRESS
comma
id|RW_ADDR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|d_link_read_byte
c_func
(paren
id|READ_DATA
comma
id|dev
)paren
suffix:semicolon
id|dev-&gt;broadcast
(braket
id|i
)braket
op_assign
l_int|0xff
suffix:semicolon
)brace
multiline_comment|/* Check magic code */
r_if
c_cond
(paren
(paren
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
op_eq
l_int|0xde
)paren
op_logical_and
(paren
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
op_eq
l_int|0x15
)paren
)paren
(brace
multiline_comment|/* OK, install real address */
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
op_assign
l_int|0x00
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
op_assign
l_int|0x80
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
op_assign
l_int|0xc8
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|3
)braket
op_and_assign
l_int|0x0f
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|3
)braket
op_or_assign
l_int|0x70
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, not found in printer port!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Initialize the device structure. */
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|netstats
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|netstats
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_NUMBUFFS
suffix:semicolon
id|i
op_increment
)paren
id|dev-&gt;buffs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;hard_header
op_assign
id|eth_header
suffix:semicolon
id|dev-&gt;add_arp
op_assign
id|eth_add_arp
suffix:semicolon
id|dev-&gt;queue_xmit
op_assign
id|dev_queue_xmit
suffix:semicolon
id|dev-&gt;rebuild_header
op_assign
id|eth_rebuild_header
suffix:semicolon
id|dev-&gt;type_trans
op_assign
id|eth_type_trans
suffix:semicolon
id|dev-&gt;open
op_assign
op_amp
id|d_link_open
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|d_link_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|d_link_start_xmit
suffix:semicolon
multiline_comment|/* These are ethernet specific. */
id|dev-&gt;type
op_assign
id|ARPHRD_ETHER
suffix:semicolon
id|dev-&gt;hard_header_len
op_assign
id|ETH_HLEN
suffix:semicolon
id|dev-&gt;mtu
op_assign
l_int|1500
suffix:semicolon
multiline_comment|/* eth_mtu */
id|dev-&gt;addr_len
op_assign
id|ETH_ALEN
suffix:semicolon
multiline_comment|/* New-style flags. */
id|dev-&gt;flags
op_assign
id|IFF_BROADCAST
suffix:semicolon
id|dev-&gt;family
op_assign
id|AF_INET
suffix:semicolon
id|dev-&gt;pa_addr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_brdaddr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_mask
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_alen
op_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqaction
(paren
id|dev-&gt;irq
comma
op_amp
id|d_link_sigaction
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;: unable to get IRQ %d&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;, Ethernet Address: %2.2X&quot;
comma
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;:%2.2X&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|adapter_init
id|adapter_init
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|startp
)paren
(brace
r_int
id|i
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* no interrupts yet, please */
id|select_nic
c_func
(paren
)paren
suffix:semicolon
id|rx_page
op_assign
l_int|0
suffix:semicolon
id|d_link_put_command
c_func
(paren
id|RESET
)paren
suffix:semicolon
id|d_link_put_command
c_func
(paren
id|STOP_RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|startp
)paren
(brace
id|irqaction
(paren
id|dev-&gt;irq
comma
op_amp
id|d_link_sigaction
)paren
suffix:semicolon
id|realdev
op_assign
id|dev
suffix:semicolon
macro_line|#ifdef D_LINK_FIFO
id|free_tx_page
op_assign
l_int|0x03
suffix:semicolon
multiline_comment|/* 2 pages = 0000 0011 */
id|busy_tx_page
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* 2 pages = 0000 0000 */
macro_line|#endif
multiline_comment|/* set the ether address. */
id|d_link_setup_address
c_func
(paren
id|NODE_ADDRESS
comma
id|RW_ADDR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|d_link_put_byte
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* where to start saving incoming packets */
id|rx_page
op_assign
l_int|0
op_or
id|RX_BP
op_or
id|RX_BASE_PAGE
suffix:semicolon
id|d_link_setup_address
c_func
(paren
id|MEM_4K
comma
id|RW_ADDR
)paren
suffix:semicolon
multiline_comment|/* Enable receiver */
id|d_link_put_command
c_func
(paren
id|RX_ENABLE
)paren
suffix:semicolon
)brace
r_else
id|d_link_put_command
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|select_prn
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
eof
