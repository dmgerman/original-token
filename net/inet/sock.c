multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;SOCK - AF_INET protocol family socket handler.&n; *&n; * Version:&t;@(#)sock.c&t;1.0.17&t;06/02/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;: &t;Numerous verify_area() problems&n; *&t;&t;Alan Cox&t;:&t;Connecting on a connecting socket&n; *&t;&t;&t;&t;&t;now returns an error for tcp.&n; *&t;&t;Alan Cox&t;:&t;sock-&gt;protocol is set correctly.&n; *&t;&t;&t;&t;&t;and is not sometimes left as 0.&n; *&t;&t;Alan Cox&t;:&t;connect handles icmp errors on a&n; *&t;&t;&t;&t;&t;connect properly. Unfortunately there&n; *&t;&t;&t;&t;&t;is a restart syscall nasty there. I&n; *&t;&t;&t;&t;&t;can&squot;t match BSD without hacking the C&n; *&t;&t;&t;&t;&t;library. Ideas urgently sought!&n; *&t;&t;Alan Cox&t;:&t;Disallow bind() to addresses that are&n; *&t;&t;&t;&t;&t;not ours - especially broadcast ones!!&n; *&t;&t;Alan Cox&t;:&t;Socket 1024 _IS_ ok for users. (fencepost)&n; *&t;&t;Alan Cox&t;:&t;sock_wfree/sock_rfree don&squot;t destroy sockets,&n; *&t;&t;&t;&t;&t;instead they leave that for the DESTROY timer.&n; *&t;&t;Alan Cox&t;:&t;Clean up error flag in accept&n; *&t;&t;Alan Cox&t;:&t;TCP ack handling is buggy, the DESTROY timer&n; *&t;&t;&t;&t;&t;was buggy. Put a remove_sock() in the handler&n; *&t;&t;&t;&t;&t;for memory when we hit 0. Also altered the timer&n; *&t;&t;&t;&t;&t;code. The ACK stuff can wait and needs major &n; *&t;&t;&t;&t;&t;TCP layer surgery.&n; *&t;&t;Alan Cox&t;:&t;Fixed TCP ack bug, removed remove sock&n; *&t;&t;&t;&t;&t;and fixed timer/inet_bh race.&n; *&t;&t;Alan Cox&t;:&t;Added zapped flag for TCP&n; *&t;&t;Alan Cox&t;:&t;Move kfree_skb into skbuff.c and tidied up surplus code&n; *&t;&t;Alan Cox&t;:&t;for new sk_buff allocations wmalloc/rmalloc now call alloc_skb&n; *&t;&t;Alan Cox&t;:&t;kfree_s calls now are kfree_skbmem so we can track skb resources&n; *&t;&t;Alan Cox&t;:&t;Supports socket option broadcast now as does udp. Packet and raw need fixing.&n; *&t;&t;Alan Cox&t;:&t;Added RCVBUF,SNDBUF size setting. It suddenely occured to me how easy it was so...&n; *&t;&t;Rick Sladkey&t;:&t;Relaxed UDP rules for matching packets.&n; *&t;&t;C.E.Hawkins&t;:&t;IFF_PROMISC/SIOCGHWADDR support&n; *&t;Pauline Middelink&t;:&t;Pidentd support&n; *&t;&t;Alan Cox&t;:&t;Fixed connect() taking signals I think.&n; *&t;&t;Alan Cox&t;:&t;SO_LINGER supported&n; *&t;&t;Alan Cox&t;:&t;Error reporting fixes&n; *&t;&t;Anonymous&t;:&t;inet_create tidied up (sk-&gt;reuse setting)&n; *&t;&t;Alan Cox&t;:&t;inet sockets don&squot;t set sk-&gt;type!&n; *&t;&t;Alan Cox&t;:&t;Split socket option code&n; *&t;&t;Alan Cox&t;:&t;Callbacks&n; *&t;&t;Alan Cox&t;:&t;Nagle flag for Charles &amp; Johannes stuff&n; *&n; * To Fix:&n; *&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &quot;inet.h&quot;
macro_line|#include &quot;dev.h&quot;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;arp.h&quot;
macro_line|#include &quot;route.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &quot;udp.h&quot;
macro_line|#include &quot;skbuff.h&quot;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &quot;raw.h&quot;
macro_line|#include &quot;icmp.h&quot;
DECL|variable|inet_debug
r_int
id|inet_debug
op_assign
id|DBG_OFF
suffix:semicolon
multiline_comment|/* INET module debug flag&t;*/
DECL|macro|min
mdefine_line|#define min(a,b)&t;((a)&lt;(b)?(a):(b))
r_extern
r_struct
id|proto
id|packet_prot
suffix:semicolon
r_void
DECL|function|print_sk
id|print_sk
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;  print_sk(NULL)&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  wmem_alloc = %lu&bslash;n&quot;
comma
id|sk-&gt;wmem_alloc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  rmem_alloc = %lu&bslash;n&quot;
comma
id|sk-&gt;rmem_alloc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  send_head = %p&bslash;n&quot;
comma
id|sk-&gt;send_head
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  state = %d&bslash;n&quot;
comma
id|sk-&gt;state
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  wback = %p, rqueue = %p&bslash;n&quot;
comma
id|sk-&gt;wback
comma
id|sk-&gt;rqueue
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  wfront = %p&bslash;n&quot;
comma
id|sk-&gt;wfront
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  daddr = %lX, saddr = %lX&bslash;n&quot;
comma
id|sk-&gt;daddr
comma
id|sk-&gt;saddr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  num = %d&quot;
comma
id|sk-&gt;num
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; next = %p&bslash;n&quot;
comma
id|sk-&gt;next
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  send_seq = %ld, acked_seq = %ld, copied_seq = %ld&bslash;n&quot;
comma
id|sk-&gt;send_seq
comma
id|sk-&gt;acked_seq
comma
id|sk-&gt;copied_seq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  rcv_ack_seq = %ld, window_seq = %ld, fin_seq = %ld&bslash;n&quot;
comma
id|sk-&gt;rcv_ack_seq
comma
id|sk-&gt;window_seq
comma
id|sk-&gt;fin_seq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  prot = %p&bslash;n&quot;
comma
id|sk-&gt;prot
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  pair = %p, back_log = %p&bslash;n&quot;
comma
id|sk-&gt;pair
comma
id|sk-&gt;back_log
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  inuse = %d , blog = %d&bslash;n&quot;
comma
id|sk-&gt;inuse
comma
id|sk-&gt;blog
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  dead = %d delay_acks=%d&bslash;n&quot;
comma
id|sk-&gt;dead
comma
id|sk-&gt;delay_acks
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  retransmits = %ld, timeout = %d&bslash;n&quot;
comma
id|sk-&gt;retransmits
comma
id|sk-&gt;timeout
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  cong_window = %d, packets_out = %d&bslash;n&quot;
comma
id|sk-&gt;cong_window
comma
id|sk-&gt;packets_out
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  urg = %d shutdown=%d&bslash;n&quot;
comma
id|sk-&gt;urg
comma
id|sk-&gt;shutdown
)paren
suffix:semicolon
)brace
r_void
DECL|function|print_skb
id|print_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;  print_skb(NULL)&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  prev = %p, next = %p&bslash;n&quot;
comma
id|skb-&gt;prev
comma
id|skb-&gt;next
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  sk = %p link3 = %p&bslash;n&quot;
comma
id|skb-&gt;sk
comma
id|skb-&gt;link3
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  mem_addr = %p, mem_len = %lu&bslash;n&quot;
comma
id|skb-&gt;mem_addr
comma
id|skb-&gt;mem_len
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  used = %d free = %d&bslash;n&quot;
comma
id|skb-&gt;used
comma
id|skb-&gt;free
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|sk_inuse
id|sk_inuse
c_func
(paren
r_struct
id|proto
op_star
id|prot
comma
r_int
id|num
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_for
c_loop
(paren
id|sk
op_assign
id|prot-&gt;sock_array
(braket
id|num
op_amp
(paren
id|SOCK_ARRAY_SIZE
op_minus
l_int|1
)paren
)braket
suffix:semicolon
id|sk
op_ne
l_int|NULL
suffix:semicolon
id|sk
op_assign
id|sk-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
id|num
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
r_int
DECL|function|get_new_socknum
id|get_new_socknum
c_func
(paren
r_struct
id|proto
op_star
id|prot
comma
r_int
r_int
id|base
)paren
(brace
r_static
r_int
id|start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;   * Used to cycle through the port numbers so the&n;   * chances of a confused connection drop.&n;   */
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|best
op_assign
l_int|0
suffix:semicolon
r_int
id|size
op_assign
l_int|32767
suffix:semicolon
multiline_comment|/* a big num. */
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|0
)paren
id|base
op_assign
id|PROT_SOCK
op_plus
l_int|1
op_plus
(paren
id|start
op_mod
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_le
id|PROT_SOCK
)paren
(brace
id|base
op_add_assign
id|PROT_SOCK
op_plus
(paren
id|start
op_mod
l_int|1024
)paren
suffix:semicolon
)brace
multiline_comment|/* Now look through the entire array and try to find an empty ptr. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SOCK_ARRAY_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|j
op_assign
l_int|0
suffix:semicolon
id|sk
op_assign
id|prot-&gt;sock_array
(braket
(paren
id|i
op_plus
id|base
op_plus
l_int|1
)paren
op_amp
(paren
id|SOCK_ARRAY_SIZE
op_minus
l_int|1
)paren
)braket
suffix:semicolon
r_while
c_loop
(paren
id|sk
op_ne
l_int|NULL
)paren
(brace
id|sk
op_assign
id|sk-&gt;next
suffix:semicolon
id|j
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
op_eq
l_int|0
)paren
(brace
id|start
op_assign
(paren
id|i
op_plus
l_int|1
op_plus
id|start
)paren
op_mod
l_int|1024
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;get_new_socknum returning %d, start = %d&bslash;n&quot;
comma
id|i
op_plus
id|base
op_plus
l_int|1
comma
id|start
)paren
)paren
suffix:semicolon
r_return
id|i
op_plus
id|base
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
OL
id|size
)paren
(brace
id|best
op_assign
id|i
suffix:semicolon
id|size
op_assign
id|j
suffix:semicolon
)brace
)brace
multiline_comment|/* Now make sure the one we want is not in use. */
r_while
c_loop
(paren
id|sk_inuse
c_func
(paren
id|prot
comma
id|base
op_plus
id|best
op_plus
l_int|1
)paren
)paren
(brace
id|best
op_add_assign
id|SOCK_ARRAY_SIZE
suffix:semicolon
)brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;get_new_socknum returning %d, start = %d&bslash;n&quot;
comma
id|best
op_plus
id|base
op_plus
l_int|1
comma
id|start
)paren
)paren
suffix:semicolon
r_return
id|best
op_plus
id|base
op_plus
l_int|1
suffix:semicolon
)brace
r_void
DECL|function|put_sock
id|put_sock
c_func
(paren
r_int
r_int
id|num
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sock
op_star
id|sk1
suffix:semicolon
r_struct
id|sock
op_star
id|sk2
suffix:semicolon
r_int
id|mask
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;put_sock(num = %d, sk = %X&bslash;n&quot;
comma
id|num
comma
id|sk
)paren
)paren
suffix:semicolon
id|sk-&gt;num
op_assign
id|num
suffix:semicolon
id|sk-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|num
op_assign
id|num
op_amp
(paren
id|SOCK_ARRAY_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* We can&squot;t have an interupt re-enter here. */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;prot-&gt;sock_array
(braket
id|num
)braket
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;prot-&gt;sock_array
(braket
id|num
)braket
op_assign
id|sk
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mask
op_assign
l_int|0xff000000
suffix:semicolon
id|mask
op_ne
l_int|0xffffffff
suffix:semicolon
id|mask
op_assign
(paren
id|mask
op_rshift
l_int|8
)paren
op_or
id|mask
)paren
(brace
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|sk-&gt;saddr
)paren
op_logical_and
(paren
id|mask
op_amp
id|sk-&gt;saddr
)paren
op_ne
(paren
id|mask
op_amp
l_int|0xffffffff
)paren
)paren
(brace
id|mask
op_assign
id|mask
op_lshift
l_int|8
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;mask = %X&bslash;n&quot;
comma
id|mask
)paren
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|sk1
op_assign
id|sk-&gt;prot-&gt;sock_array
(braket
id|num
)braket
suffix:semicolon
r_for
c_loop
(paren
id|sk2
op_assign
id|sk1
suffix:semicolon
id|sk2
op_ne
l_int|NULL
suffix:semicolon
id|sk2
op_assign
id|sk2-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|sk2-&gt;saddr
op_amp
id|mask
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk2
op_eq
id|sk1
)paren
(brace
id|sk-&gt;next
op_assign
id|sk-&gt;prot-&gt;sock_array
(braket
id|num
)braket
suffix:semicolon
id|sk-&gt;prot-&gt;sock_array
(braket
id|num
)braket
op_assign
id|sk
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sk-&gt;next
op_assign
id|sk2
suffix:semicolon
id|sk1-&gt;next
op_assign
id|sk
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sk1
op_assign
id|sk2
suffix:semicolon
)brace
multiline_comment|/* Goes at the end. */
id|sk-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|sk1-&gt;next
op_assign
id|sk
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|remove_sock
id|remove_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk1
)paren
(brace
r_struct
id|sock
op_star
id|sk2
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;remove_sock(sk1=%X)&bslash;n&quot;
comma
id|sk1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sock.c: remove_sock: sk1 == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sk1-&gt;prot
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sock.c: remove_sock: sk1-&gt;prot == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* We can&squot;t have this changing out from under us. */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|sk2
op_assign
id|sk1-&gt;prot-&gt;sock_array
(braket
id|sk1-&gt;num
op_amp
(paren
id|SOCK_ARRAY_SIZE
op_minus
l_int|1
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|sk2
op_eq
id|sk1
)paren
(brace
id|sk1-&gt;prot-&gt;sock_array
(braket
id|sk1-&gt;num
op_amp
(paren
id|SOCK_ARRAY_SIZE
op_minus
l_int|1
)paren
)braket
op_assign
id|sk1-&gt;next
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|sk2
op_logical_and
id|sk2-&gt;next
op_ne
id|sk1
)paren
(brace
id|sk2
op_assign
id|sk2-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk2
)paren
(brace
id|sk2-&gt;next
op_assign
id|sk1-&gt;next
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk1-&gt;num
op_ne
l_int|0
)paren
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;remove_sock: sock not found.&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|destroy_sock
id|destroy_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;destroying socket %X&bslash;n&quot;
comma
id|sk
)paren
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* just to be safe. */
multiline_comment|/* Incase it&squot;s sleeping somewhere. */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
id|remove_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Now we can no longer get new packets. */
id|delete_timer
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;send_tmp
op_ne
l_int|NULL
)paren
(brace
id|IS_SKB
c_func
(paren
id|sk-&gt;send_tmp
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|sk-&gt;send_tmp
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
multiline_comment|/* Cleanup up the write buffer. */
r_for
c_loop
(paren
id|skb
op_assign
id|sk-&gt;wfront
suffix:semicolon
id|skb
op_ne
l_int|NULL
suffix:semicolon
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
id|skb2
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|skb-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;magic
op_ne
id|TCP_WRITE_QUEUE_MAGIC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sock.c:destroy_sock write queue with bad magic(%X)&bslash;n&quot;
comma
id|skb-&gt;magic
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|skb
op_assign
id|skb2
suffix:semicolon
)brace
id|sk-&gt;wfront
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;wback
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;rqueue
op_ne
l_int|NULL
)paren
(brace
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;rqueue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * This will take care of closing sockets that were&n;&t;&t; * listening and didn&squot;t accept everything.&n;&t;&t; */
r_if
c_cond
(paren
id|skb-&gt;sk
op_ne
l_int|NULL
op_logical_and
id|skb-&gt;sk
op_ne
id|sk
)paren
(brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb-&gt;sk-&gt;dead
op_assign
l_int|1
suffix:semicolon
id|skb-&gt;sk-&gt;prot
op_member_access_from_pointer
id|close
c_func
(paren
id|skb-&gt;sk
comma
l_int|0
)paren
suffix:semicolon
)brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
)brace
id|sk-&gt;rqueue
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Now we need to clean up the send head. */
r_for
c_loop
(paren
id|skb
op_assign
id|sk-&gt;send_head
suffix:semicolon
id|skb
op_ne
l_int|NULL
suffix:semicolon
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We need to remove skb from the transmit queue,&n;&t;&t; * or maybe the arp queue.&n;&t;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* see if it&squot;s in a transmit queue. */
multiline_comment|/* this can be simplified quite a bit.  Look */
multiline_comment|/* at tcp.c:tcp_ack to see how. */
r_if
c_cond
(paren
id|skb-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|IS_SKB
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb_unlink
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|skb2
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|skb-&gt;link3
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|skb
op_assign
id|skb2
suffix:semicolon
)brace
id|sk-&gt;send_head
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* And now the backlog. */
r_if
c_cond
(paren
id|sk-&gt;back_log
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* this should never happen. */
id|printk
c_func
(paren
l_string|&quot;cleaning back_log. &bslash;n&quot;
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|sk-&gt;back_log
suffix:semicolon
r_do
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
id|skb2
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|skb-&gt;next
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|skb
op_assign
id|skb2
suffix:semicolon
)brace
r_while
c_loop
(paren
id|skb
op_ne
id|sk-&gt;back_log
)paren
(brace
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
id|sk-&gt;back_log
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Now if it has a half accepted/ closed socket. */
r_if
c_cond
(paren
id|sk-&gt;pair
)paren
(brace
id|sk-&gt;pair-&gt;dead
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;pair-&gt;prot
op_member_access_from_pointer
id|close
c_func
(paren
id|sk-&gt;pair
comma
l_int|0
)paren
suffix:semicolon
id|sk-&gt;pair
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;   * Now if everything is gone we can free the socket&n;   * structure, otherwise we need to keep it around until&n;   * everything is gone.&n;   */
r_if
c_cond
(paren
id|sk-&gt;rmem_alloc
op_eq
l_int|0
op_logical_and
id|sk-&gt;wmem_alloc
op_eq
l_int|0
)paren
(brace
id|kfree_s
c_func
(paren
(paren
r_void
op_star
)paren
id|sk
comma
r_sizeof
(paren
op_star
id|sk
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* this should never happen. */
multiline_comment|/* actually it can if an ack has just been sent. */
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;possible memory leak in socket = %X&bslash;n&quot;
comma
id|sk
)paren
)paren
suffix:semicolon
id|sk-&gt;destroy
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|0
suffix:semicolon
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_DESTROY
comma
id|SOCK_DESTROY_TIME
)paren
suffix:semicolon
)brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;leaving destroy_sock&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|inet_fcntl
id|inet_fcntl
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sock-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: sock-&gt;data = NULL: %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|F_SETOWN
suffix:colon
multiline_comment|/*&n;&t;&t; * This is a little restrictive, but it&squot;s the only&n;&t;&t; * way to make sure that you can&squot;t send a sigurg to&n;&t;&t; * another process.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
op_logical_and
id|current-&gt;pgrp
op_ne
op_minus
id|arg
op_logical_and
id|current-&gt;pid
op_ne
id|arg
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|sk-&gt;proc
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|F_GETOWN
suffix:colon
r_return
id|sk-&gt;proc
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Set socket options on an inet socket.&n; */
DECL|function|inet_setsockopt
r_static
r_int
id|inet_setsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sock-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
id|SOL_SOCKET
)paren
r_return
id|sock_setsockopt
c_func
(paren
id|sk
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;prot-&gt;setsockopt
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_else
r_return
id|sk-&gt;prot
op_member_access_from_pointer
id|setsockopt
c_func
(paren
id|sk
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
)brace
DECL|function|inet_getsockopt
r_static
r_int
id|inet_getsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
id|SOL_SOCKET
)paren
r_return
id|sock_getsockopt
c_func
(paren
id|sk
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;prot-&gt;getsockopt
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_else
r_return
id|sk-&gt;prot
op_member_access_from_pointer
id|getsockopt
c_func
(paren
id|sk
comma
id|level
comma
id|optname
comma
id|optval
comma
id|optlen
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is meant for all protocols to use and covers goings on&n; *&t;at the socket level. Everything here is generic.&n; */
DECL|function|sock_setsockopt
r_int
id|sock_setsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
r_int
id|val
suffix:semicolon
r_int
id|err
suffix:semicolon
r_struct
id|linger
id|ling
suffix:semicolon
r_if
c_cond
(paren
id|optval
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|optval
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|val
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|optval
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|SO_TYPE
suffix:colon
r_case
id|SO_ERROR
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
r_case
id|SO_DEBUG
suffix:colon
id|sk-&gt;debug
op_assign
id|val
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SO_DONTROUTE
suffix:colon
multiline_comment|/* Still to be implemented */
r_return
l_int|0
suffix:semicolon
r_case
id|SO_BROADCAST
suffix:colon
id|sk-&gt;broadcast
op_assign
id|val
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SO_SNDBUF
suffix:colon
r_if
c_cond
(paren
id|val
OG
l_int|32767
)paren
(brace
id|val
op_assign
l_int|32767
suffix:semicolon
)brace
r_if
c_cond
(paren
id|val
OL
l_int|256
)paren
(brace
id|val
op_assign
l_int|256
suffix:semicolon
)brace
id|sk-&gt;sndbuf
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SO_LINGER
suffix:colon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|optval
comma
r_sizeof
(paren
id|ling
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|ling
comma
id|optval
comma
r_sizeof
(paren
id|ling
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ling.l_onoff
op_eq
l_int|0
)paren
(brace
id|sk-&gt;linger
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;lingertime
op_assign
id|ling.l_linger
suffix:semicolon
id|sk-&gt;linger
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SO_RCVBUF
suffix:colon
r_if
c_cond
(paren
id|val
OG
l_int|32767
)paren
(brace
id|val
op_assign
l_int|32767
suffix:semicolon
)brace
r_if
c_cond
(paren
id|val
OL
l_int|256
)paren
(brace
id|val
op_assign
l_int|256
suffix:semicolon
)brace
id|sk-&gt;rcvbuf
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SO_REUSEADDR
suffix:colon
r_if
c_cond
(paren
id|val
)paren
id|sk-&gt;reuse
op_assign
l_int|1
suffix:semicolon
r_else
id|sk-&gt;reuse
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SO_KEEPALIVE
suffix:colon
r_if
c_cond
(paren
id|val
)paren
id|sk-&gt;keepopen
op_assign
l_int|1
suffix:semicolon
r_else
id|sk-&gt;keepopen
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SO_OOBINLINE
suffix:colon
r_if
c_cond
(paren
id|val
)paren
id|sk-&gt;urginline
op_assign
l_int|1
suffix:semicolon
r_else
id|sk-&gt;urginline
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SO_NO_CHECK
suffix:colon
r_if
c_cond
(paren
id|val
)paren
id|sk-&gt;no_check
op_assign
l_int|1
suffix:semicolon
r_else
id|sk-&gt;no_check
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SO_PRIORITY
suffix:colon
r_if
c_cond
(paren
id|val
op_ge
l_int|0
op_logical_and
id|val
OL
id|DEV_NUMBUFFS
)paren
(brace
id|sk-&gt;priority
op_assign
id|val
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
)brace
)brace
DECL|function|sock_getsockopt
r_int
id|sock_getsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
(brace
r_int
id|val
suffix:semicolon
r_int
id|err
suffix:semicolon
r_struct
id|linger
id|ling
suffix:semicolon
r_switch
c_cond
(paren
id|optname
)paren
(brace
r_case
id|SO_DEBUG
suffix:colon
id|val
op_assign
id|sk-&gt;debug
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_DONTROUTE
suffix:colon
multiline_comment|/* One last option to implement */
id|val
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_BROADCAST
suffix:colon
id|val
op_assign
id|sk-&gt;broadcast
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_LINGER
suffix:colon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|optval
comma
r_sizeof
(paren
id|ling
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|optlen
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_fs_long
c_func
(paren
r_sizeof
(paren
id|ling
)paren
comma
(paren
r_int
r_int
op_star
)paren
id|optlen
)paren
suffix:semicolon
id|ling.l_onoff
op_assign
id|sk-&gt;linger
suffix:semicolon
id|ling.l_linger
op_assign
id|sk-&gt;lingertime
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|optval
comma
op_amp
id|ling
comma
r_sizeof
(paren
id|ling
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SO_SNDBUF
suffix:colon
id|val
op_assign
id|sk-&gt;sndbuf
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_RCVBUF
suffix:colon
id|val
op_assign
id|sk-&gt;rcvbuf
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_REUSEADDR
suffix:colon
id|val
op_assign
id|sk-&gt;reuse
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_KEEPALIVE
suffix:colon
id|val
op_assign
id|sk-&gt;keepopen
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_TYPE
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;prot
op_eq
op_amp
id|tcp_prot
)paren
id|val
op_assign
id|SOCK_STREAM
suffix:semicolon
r_else
id|val
op_assign
id|SOCK_DGRAM
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_ERROR
suffix:colon
id|val
op_assign
id|sk-&gt;err
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_OOBINLINE
suffix:colon
id|val
op_assign
id|sk-&gt;urginline
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_NO_CHECK
suffix:colon
id|val
op_assign
id|sk-&gt;no_check
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SO_PRIORITY
suffix:colon
id|val
op_assign
id|sk-&gt;priority
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
)brace
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|optlen
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_fs_long
c_func
(paren
r_sizeof
(paren
r_int
)paren
comma
(paren
r_int
r_int
op_star
)paren
id|optlen
)paren
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|optval
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_fs_long
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|optval
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|inet_listen
id|inet_listen
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|backlog
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sock-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: sock-&gt;data = NULL: %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We may need to bind the socket. */
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
l_int|0
)paren
(brace
id|sk-&gt;num
op_assign
id|get_new_socknum
c_func
(paren
id|sk-&gt;prot
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
l_int|0
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|put_sock
c_func
(paren
id|sk-&gt;num
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;dummy_th.source
op_assign
id|ntohs
c_func
(paren
id|sk-&gt;num
)paren
suffix:semicolon
)brace
multiline_comment|/* We might as well re use these. */
id|sk-&gt;max_ack_backlog
op_assign
id|backlog
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_LISTEN
)paren
(brace
id|sk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_LISTEN
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Default callbacks for user INET sockets. These just wake up&n; *&t;the user owning the socket.&n; */
DECL|function|def_callback1
r_static
r_void
id|def_callback1
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|wake_up
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
)brace
DECL|function|def_callback2
r_static
r_void
id|def_callback2
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|wake_up
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|inet_create
id|inet_create
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|protocol
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_struct
id|proto
op_star
id|prot
suffix:semicolon
r_int
id|err
suffix:semicolon
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|sk
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|sk-&gt;num
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;reuse
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|sock-&gt;type
)paren
(brace
r_case
id|SOCK_STREAM
suffix:colon
r_case
id|SOCK_SEQPACKET
suffix:colon
r_if
c_cond
(paren
id|protocol
op_logical_and
id|protocol
op_ne
id|IPPROTO_TCP
)paren
(brace
id|kfree_s
c_func
(paren
(paren
r_void
op_star
)paren
id|sk
comma
r_sizeof
(paren
op_star
id|sk
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EPROTONOSUPPORT
suffix:semicolon
)brace
id|protocol
op_assign
id|IPPROTO_TCP
suffix:semicolon
id|sk-&gt;no_check
op_assign
id|TCP_NO_CHECK
suffix:semicolon
id|prot
op_assign
op_amp
id|tcp_prot
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOCK_DGRAM
suffix:colon
r_if
c_cond
(paren
id|protocol
op_logical_and
id|protocol
op_ne
id|IPPROTO_UDP
)paren
(brace
id|kfree_s
c_func
(paren
(paren
r_void
op_star
)paren
id|sk
comma
r_sizeof
(paren
op_star
id|sk
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EPROTONOSUPPORT
suffix:semicolon
)brace
id|protocol
op_assign
id|IPPROTO_UDP
suffix:semicolon
id|sk-&gt;no_check
op_assign
id|UDP_NO_CHECK
suffix:semicolon
id|prot
op_assign
op_amp
id|udp_prot
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOCK_RAW
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
id|kfree_s
c_func
(paren
(paren
r_void
op_star
)paren
id|sk
comma
r_sizeof
(paren
op_star
id|sk
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|protocol
)paren
(brace
id|kfree_s
c_func
(paren
(paren
r_void
op_star
)paren
id|sk
comma
r_sizeof
(paren
op_star
id|sk
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EPROTONOSUPPORT
suffix:semicolon
)brace
id|prot
op_assign
op_amp
id|raw_prot
suffix:semicolon
id|sk-&gt;reuse
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;no_check
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Doesn&squot;t matter no checksum is&n;&t;&t;&t;&t;&t; * preformed anyway.&n;&t;&t;&t;&t;&t; */
id|sk-&gt;num
op_assign
id|protocol
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOCK_PACKET
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
id|kfree_s
c_func
(paren
(paren
r_void
op_star
)paren
id|sk
comma
r_sizeof
(paren
op_star
id|sk
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|protocol
)paren
(brace
id|kfree_s
c_func
(paren
(paren
r_void
op_star
)paren
id|sk
comma
r_sizeof
(paren
op_star
id|sk
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EPROTONOSUPPORT
suffix:semicolon
)brace
id|prot
op_assign
op_amp
id|packet_prot
suffix:semicolon
id|sk-&gt;reuse
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;no_check
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Doesn&squot;t matter no checksum is&n;&t;&t;&t;&t;&t; * preformed anyway.&n;&t;&t;&t;&t;&t; */
id|sk-&gt;num
op_assign
id|protocol
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|kfree_s
c_func
(paren
(paren
r_void
op_star
)paren
id|sk
comma
r_sizeof
(paren
op_star
id|sk
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ESOCKTNOSUPPORT
suffix:semicolon
)brace
id|sk-&gt;socket
op_assign
id|sock
suffix:semicolon
macro_line|#ifdef CONFIG_TCP_NAGLE_OFF
id|sk-&gt;nonagle
op_assign
l_int|1
suffix:semicolon
macro_line|#else    
id|sk-&gt;nonagle
op_assign
l_int|0
suffix:semicolon
macro_line|#endif  
id|sk-&gt;type
op_assign
id|sock-&gt;type
suffix:semicolon
id|sk-&gt;protocol
op_assign
id|protocol
suffix:semicolon
id|sk-&gt;wmem_alloc
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;rmem_alloc
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;sndbuf
op_assign
id|SK_WMEM_MAX
suffix:semicolon
id|sk-&gt;rcvbuf
op_assign
id|SK_RMEM_MAX
suffix:semicolon
id|sk-&gt;pair
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;opt
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;send_seq
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;acked_seq
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;copied_seq
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;fin_seq
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;proc
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;rtt
op_assign
id|TCP_WRITE_TIME
suffix:semicolon
id|sk-&gt;mdev
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;backoff
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;packets_out
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;cong_window
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* start with only sending one packet at a time. */
id|sk-&gt;exp_growth
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* if set cong_window grow exponentially every time&n;&t;&t;&t;  we get an ack. */
id|sk-&gt;urginline
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;intr
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;linger
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;destroy
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;priority
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;shutdown
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;urg
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;keepopen
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;zapped
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;done
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ack_backlog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;window
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;bytes_rcv
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|sk-&gt;dead
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ack_timed
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;send_tmp
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;mss
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we will try not to send any packets smaller than this. */
id|sk-&gt;debug
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* this is how many unacked bytes we will accept for this socket.  */
id|sk-&gt;max_unacked
op_assign
l_int|2048
suffix:semicolon
multiline_comment|/* needs to be at most 2 full packets. */
multiline_comment|/* how many packets we should send before forcing an ack. &n;     if this is set to zero it is the same as sk-&gt;delay_acks = 0 */
id|sk-&gt;max_ack_backlog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;delay_acks
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;wback
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;wfront
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;rqueue
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;mtu
op_assign
l_int|576
suffix:semicolon
id|sk-&gt;prot
op_assign
id|prot
suffix:semicolon
id|sk-&gt;sleep
op_assign
id|sock-&gt;wait
suffix:semicolon
id|sk-&gt;daddr
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;saddr
op_assign
id|my_addr
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;pair
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;send_tail
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;send_head
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;broadcast
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|sk
suffix:semicolon
id|sk-&gt;timer.function
op_assign
op_amp
id|net_timer
suffix:semicolon
id|sk-&gt;back_log
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;blog
op_assign
l_int|0
suffix:semicolon
id|sock-&gt;data
op_assign
(paren
r_void
op_star
)paren
id|sk
suffix:semicolon
id|sk-&gt;dummy_th.doff
op_assign
r_sizeof
(paren
id|sk-&gt;dummy_th
)paren
op_div
l_int|4
suffix:semicolon
id|sk-&gt;dummy_th.res1
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;dummy_th.res2
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;dummy_th.urg_ptr
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;dummy_th.fin
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;dummy_th.syn
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;dummy_th.rst
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;dummy_th.psh
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;dummy_th.ack
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;dummy_th.urg
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;dummy_th.dest
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ip_tos
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;ip_ttl
op_assign
l_int|64
suffix:semicolon
id|sk-&gt;state_change
op_assign
id|def_callback1
suffix:semicolon
id|sk-&gt;data_ready
op_assign
id|def_callback2
suffix:semicolon
id|sk-&gt;write_space
op_assign
id|def_callback1
suffix:semicolon
id|sk-&gt;error_report
op_assign
id|def_callback1
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;num
)paren
(brace
multiline_comment|/*&n;&t; * It assumes that any protocol which allows&n;&t; * the user to assign a number at socket&n;&t; * creation time automatically&n;&t; * shares.&n;&t; */
id|put_sock
c_func
(paren
id|sk-&gt;num
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;dummy_th.source
op_assign
id|ntohs
c_func
(paren
id|sk-&gt;num
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;prot-&gt;init
)paren
(brace
id|err
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|init
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|0
)paren
(brace
id|destroy_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|inet_dup
id|inet_dup
c_func
(paren
r_struct
id|socket
op_star
id|newsock
comma
r_struct
id|socket
op_star
id|oldsock
)paren
(brace
r_return
id|inet_create
c_func
(paren
id|newsock
comma
(paren
(paren
r_struct
id|sock
op_star
)paren
(paren
id|oldsock-&gt;data
)paren
)paren
op_member_access_from_pointer
id|protocol
)paren
suffix:semicolon
)brace
multiline_comment|/* The peer socket should always be NULL. */
r_static
r_int
DECL|function|inet_release
id|inet_release
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|socket
op_star
id|peer
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sock-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;inet_release(sock = %X, peer = %X)&bslash;n&quot;
comma
id|sock
comma
id|peer
)paren
)paren
suffix:semicolon
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Start closing the connection.  This may take a while. */
multiline_comment|/*&n;   * If linger is set, we don&squot;t return until the close&n;   * is complete.  Other wise we return immediately. The&n;   * actually closing is done the same either way.&n;   */
r_if
c_cond
(paren
id|sk-&gt;linger
op_eq
l_int|0
)paren
(brace
id|sk-&gt;prot
op_member_access_from_pointer
id|close
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
id|sk-&gt;dead
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;sk-&gt;linger set.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|close
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;lingertime
)paren
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|HZ
op_star
id|sk-&gt;lingertime
suffix:semicolon
r_while
c_loop
(paren
id|sk-&gt;state
op_ne
id|TCP_CLOSE
op_logical_and
id|current-&gt;timeout
OG
l_int|0
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;dead
op_assign
l_int|1
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* This will destroy it. */
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sock-&gt;data
op_assign
l_int|NULL
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;inet_release returning&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this needs to be changed to dissallow&n;   the rebinding of sockets.   What error&n;   should it return? */
r_static
r_int
DECL|function|inet_bind
id|inet_bind
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
)paren
(brace
r_struct
id|sockaddr_in
id|addr
suffix:semicolon
r_struct
id|sock
op_star
id|sk
comma
op_star
id|sk2
suffix:semicolon
r_int
r_int
id|snum
suffix:semicolon
r_int
id|err
suffix:semicolon
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sock-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: sock-&gt;data = NULL: %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* check this error. */
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_CLOSE
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;num
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|uaddr
comma
id|addr_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|addr
comma
id|uaddr
comma
id|min
c_func
(paren
r_sizeof
(paren
id|addr
)paren
comma
id|addr_len
)paren
)paren
suffix:semicolon
id|snum
op_assign
id|ntohs
c_func
(paren
id|addr.sin_port
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;bind sk =%X to port = %d&bslash;n&quot;
comma
id|sk
comma
id|snum
)paren
)paren
suffix:semicolon
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sock-&gt;data
suffix:semicolon
multiline_comment|/*&n;   * We can&squot;t just leave the socket bound wherever it is, it might&n;   * be bound to a privileged port. However, since there seems to&n;   * be a bug here, we will leave it if the port is not privileged.&n;   */
r_if
c_cond
(paren
id|snum
op_eq
l_int|0
)paren
(brace
id|snum
op_assign
id|get_new_socknum
c_func
(paren
id|sk-&gt;prot
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|snum
OL
id|PROT_SOCK
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|addr.sin_addr.s_addr
op_ne
l_int|0
op_logical_and
id|chk_addr
c_func
(paren
id|addr.sin_addr.s_addr
)paren
op_ne
id|IS_MYADDR
)paren
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
multiline_comment|/* Source address MUST be ours! */
r_if
c_cond
(paren
id|chk_addr
c_func
(paren
id|addr.sin_addr.s_addr
)paren
op_logical_or
id|addr.sin_addr.s_addr
op_eq
l_int|0
)paren
id|sk-&gt;saddr
op_assign
id|addr.sin_addr.s_addr
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;sock_array[%d] = %X:&bslash;n&quot;
comma
id|snum
op_amp
(paren
id|SOCK_ARRAY_SIZE
op_minus
l_int|1
)paren
comma
id|sk-&gt;prot-&gt;sock_array
(braket
id|snum
op_amp
(paren
id|SOCK_ARRAY_SIZE
op_minus
l_int|1
)paren
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/* Make sure we are allowed to bind here. */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outside_loop
suffix:colon
r_for
c_loop
(paren
id|sk2
op_assign
id|sk-&gt;prot-&gt;sock_array
(braket
id|snum
op_amp
(paren
id|SOCK_ARRAY_SIZE
op_minus
l_int|1
)paren
)braket
suffix:semicolon
id|sk2
op_ne
l_int|NULL
suffix:semicolon
id|sk2
op_assign
id|sk2-&gt;next
)paren
(brace
macro_line|#if &t;1&t;/* should be below! */
r_if
c_cond
(paren
id|sk2-&gt;num
op_ne
id|snum
)paren
r_continue
suffix:semicolon
multiline_comment|/*&t;if (sk2-&gt;saddr != sk-&gt;saddr) continue; */
macro_line|#endif
r_if
c_cond
(paren
id|sk2-&gt;dead
)paren
(brace
id|destroy_sock
c_func
(paren
id|sk2
)paren
suffix:semicolon
r_goto
id|outside_loop
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;reuse
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EADDRINUSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk2-&gt;num
op_ne
id|snum
)paren
r_continue
suffix:semicolon
multiline_comment|/* more than one */
r_if
c_cond
(paren
id|sk2-&gt;saddr
op_ne
id|sk-&gt;saddr
)paren
r_continue
suffix:semicolon
multiline_comment|/* socket per slot ! -FB */
r_if
c_cond
(paren
op_logical_neg
id|sk2-&gt;reuse
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EADDRINUSE
suffix:semicolon
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|remove_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|put_sock
c_func
(paren
id|snum
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;dummy_th.source
op_assign
id|ntohs
c_func
(paren
id|sk-&gt;num
)paren
suffix:semicolon
id|sk-&gt;daddr
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;dummy_th.dest
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|inet_connect
id|inet_connect
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
comma
r_int
id|flags
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_int
id|err
suffix:semicolon
id|sock-&gt;conn
op_assign
l_int|NULL
suffix:semicolon
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sock-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: sock-&gt;data = NULL: %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sock-&gt;state
op_eq
id|SS_CONNECTING
op_logical_and
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
)paren
(brace
id|sock-&gt;state
op_assign
id|SS_CONNECTED
suffix:semicolon
multiline_comment|/* Connection completing after a connect/EINPROGRESS/select/connect */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Rock and roll */
)brace
r_if
c_cond
(paren
id|sock-&gt;state
op_eq
id|SS_CONNECTING
op_logical_and
id|sk-&gt;protocol
op_eq
id|IPPROTO_TCP
op_logical_and
(paren
id|flags
op_amp
id|O_NONBLOCK
)paren
)paren
r_return
op_minus
id|EALREADY
suffix:semicolon
multiline_comment|/* Connecting is currently in progress */
r_if
c_cond
(paren
id|sock-&gt;state
op_ne
id|SS_CONNECTING
)paren
(brace
multiline_comment|/* We may need to bind the socket. */
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
l_int|0
)paren
(brace
id|sk-&gt;num
op_assign
id|get_new_socknum
c_func
(paren
id|sk-&gt;prot
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
l_int|0
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|put_sock
c_func
(paren
id|sk-&gt;num
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;dummy_th.source
op_assign
id|htons
c_func
(paren
id|sk-&gt;num
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;prot-&gt;connect
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
id|err
op_assign
id|sk-&gt;prot
op_member_access_from_pointer
id|connect
c_func
(paren
id|sk
comma
(paren
r_struct
id|sockaddr_in
op_star
)paren
id|uaddr
comma
id|addr_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|sock-&gt;state
op_assign
id|SS_CONNECTING
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
(paren
id|flags
op_amp
id|O_NONBLOCK
)paren
)paren
r_return
op_minus
id|EINPROGRESS
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* avoid the race condition */
r_while
c_loop
(paren
id|sk-&gt;state
op_eq
id|TCP_SYN_SENT
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_SYN_RECV
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
multiline_comment|/* This fixes a nasty in the tcp/ip code. There is a hideous hassle with&n;&t;   icmp error packets wanting to close a tcp or udp socket. */
r_if
c_cond
(paren
id|sk-&gt;err
op_logical_and
id|sk-&gt;protocol
op_eq
id|IPPROTO_TCP
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|sock-&gt;state
op_assign
id|SS_UNCONNECTED
suffix:semicolon
id|err
op_assign
op_minus
id|sk-&gt;err
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_return
id|err
suffix:semicolon
multiline_comment|/* set by tcp_err() */
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|sock-&gt;state
op_assign
id|SS_CONNECTED
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;err
)paren
(brace
id|sock-&gt;state
op_assign
id|SS_UNCONNECTED
suffix:semicolon
id|err
op_assign
id|sk-&gt;err
suffix:semicolon
id|sk-&gt;err
op_assign
l_int|0
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|inet_socketpair
id|inet_socketpair
c_func
(paren
r_struct
id|socket
op_star
id|sock1
comma
r_struct
id|socket
op_star
id|sock2
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_static
r_int
DECL|function|inet_accept
id|inet_accept
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|socket
op_star
id|newsock
comma
r_int
id|flags
)paren
(brace
r_struct
id|sock
op_star
id|sk1
comma
op_star
id|sk2
suffix:semicolon
r_int
id|err
suffix:semicolon
id|sk1
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sock-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|sk1
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: sock-&gt;data = NULL: %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;   * We&squot;ve been passed an extra socket.&n;   * We need to free it up because the tcp module creates&n;   * it&squot;s own when it accepts one.&n;   */
r_if
c_cond
(paren
id|newsock-&gt;data
)paren
id|kfree_s
c_func
(paren
id|newsock-&gt;data
comma
r_sizeof
(paren
r_struct
id|sock
)paren
)paren
suffix:semicolon
id|newsock-&gt;data
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sk1-&gt;prot-&gt;accept
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* Restore the state if we have been interrupted, and then returned. */
r_if
c_cond
(paren
id|sk1-&gt;pair
op_ne
l_int|NULL
)paren
(brace
id|sk2
op_assign
id|sk1-&gt;pair
suffix:semicolon
id|sk1-&gt;pair
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|sk2
op_assign
id|sk1-&gt;prot
op_member_access_from_pointer
id|accept
c_func
(paren
id|sk1
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk2
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|sk1-&gt;err
op_le
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;Warning sock.c:sk1-&gt;err &lt;= 0.  Returning non-error.&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
id|sk1-&gt;err
suffix:semicolon
id|sk1-&gt;err
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|err
suffix:semicolon
)brace
)brace
id|newsock-&gt;data
op_assign
(paren
r_void
op_star
)paren
id|sk2
suffix:semicolon
id|sk2-&gt;sleep
op_assign
id|newsock-&gt;wait
suffix:semicolon
id|newsock-&gt;conn
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|O_NONBLOCK
)paren
r_return
l_int|0
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* avoid the race. */
r_while
c_loop
(paren
id|sk2-&gt;state
op_eq
id|TCP_SYN_RECV
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
id|sk2-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|sk1-&gt;pair
op_assign
id|sk2
suffix:semicolon
id|sk2-&gt;sleep
op_assign
l_int|NULL
suffix:semicolon
id|newsock-&gt;data
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk2-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk2-&gt;err
OG
l_int|0
)paren
(brace
id|err
op_assign
op_minus
id|sk2-&gt;err
suffix:semicolon
id|sk2-&gt;err
op_assign
l_int|0
suffix:semicolon
id|destroy_sock
c_func
(paren
id|sk2
)paren
suffix:semicolon
id|newsock-&gt;data
op_assign
l_int|NULL
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|newsock-&gt;state
op_assign
id|SS_CONNECTED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|inet_getname
id|inet_getname
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
op_star
id|uaddr_len
comma
r_int
id|peer
)paren
(brace
r_struct
id|sockaddr_in
id|sin
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|uaddr_len
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|len
op_assign
id|get_fs_long
c_func
(paren
id|uaddr_len
)paren
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|uaddr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Check this error. */
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
id|sin
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|sin.sin_family
op_assign
id|AF_INET
suffix:semicolon
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sock-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: sock-&gt;data = NULL: %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|peer
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tcp_connected
c_func
(paren
id|sk-&gt;state
)paren
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
id|sin.sin_port
op_assign
id|sk-&gt;dummy_th.dest
suffix:semicolon
id|sin.sin_addr.s_addr
op_assign
id|sk-&gt;daddr
suffix:semicolon
)brace
r_else
(brace
id|sin.sin_port
op_assign
id|sk-&gt;dummy_th.source
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;saddr
op_eq
l_int|0
)paren
id|sin.sin_addr.s_addr
op_assign
id|my_addr
c_func
(paren
)paren
suffix:semicolon
r_else
id|sin.sin_addr.s_addr
op_assign
id|sk-&gt;saddr
suffix:semicolon
)brace
id|len
op_assign
r_sizeof
(paren
id|sin
)paren
suffix:semicolon
multiline_comment|/*  verify_area(VERIFY_WRITE, uaddr, len); NOW DONE ABOVE */
id|memcpy_tofs
c_func
(paren
id|uaddr
comma
op_amp
id|sin
comma
r_sizeof
(paren
id|sin
)paren
)paren
suffix:semicolon
multiline_comment|/*  verify_area(VERIFY_WRITE, uaddr_len, sizeof(len)); NOW DONE ABOVE */
id|put_fs_long
c_func
(paren
id|len
comma
id|uaddr_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|inet_read
id|inet_read
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_char
op_star
id|ubuf
comma
r_int
id|size
comma
r_int
id|noblock
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sock-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: sock-&gt;data = NULL: %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We may need to bind the socket. */
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
l_int|0
)paren
(brace
id|sk-&gt;num
op_assign
id|get_new_socknum
c_func
(paren
id|sk-&gt;prot
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
l_int|0
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|put_sock
c_func
(paren
id|sk-&gt;num
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;dummy_th.source
op_assign
id|ntohs
c_func
(paren
id|sk-&gt;num
)paren
suffix:semicolon
)brace
r_return
id|sk-&gt;prot
op_member_access_from_pointer
id|read
c_func
(paren
id|sk
comma
(paren
r_int
r_char
op_star
)paren
id|ubuf
comma
id|size
comma
id|noblock
comma
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|inet_recv
id|inet_recv
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_void
op_star
id|ubuf
comma
r_int
id|size
comma
r_int
id|noblock
comma
r_int
id|flags
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sock-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: sock-&gt;data = NULL: %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We may need to bind the socket. */
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
l_int|0
)paren
(brace
id|sk-&gt;num
op_assign
id|get_new_socknum
c_func
(paren
id|sk-&gt;prot
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
l_int|0
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|put_sock
c_func
(paren
id|sk-&gt;num
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;dummy_th.source
op_assign
id|ntohs
c_func
(paren
id|sk-&gt;num
)paren
suffix:semicolon
)brace
r_return
id|sk-&gt;prot
op_member_access_from_pointer
id|read
c_func
(paren
id|sk
comma
(paren
r_int
r_char
op_star
)paren
id|ubuf
comma
id|size
comma
id|noblock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|inet_write
id|inet_write
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_char
op_star
id|ubuf
comma
r_int
id|size
comma
r_int
id|noblock
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sock-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: sock-&gt;data = NULL: %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
(brace
id|send_sig
c_func
(paren
id|SIGPIPE
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
multiline_comment|/* We may need to bind the socket. */
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
l_int|0
)paren
(brace
id|sk-&gt;num
op_assign
id|get_new_socknum
c_func
(paren
id|sk-&gt;prot
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
l_int|0
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|put_sock
c_func
(paren
id|sk-&gt;num
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;dummy_th.source
op_assign
id|ntohs
c_func
(paren
id|sk-&gt;num
)paren
suffix:semicolon
)brace
r_return
id|sk-&gt;prot
op_member_access_from_pointer
id|write
c_func
(paren
id|sk
comma
(paren
r_int
r_char
op_star
)paren
id|ubuf
comma
id|size
comma
id|noblock
comma
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|inet_send
id|inet_send
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_void
op_star
id|ubuf
comma
r_int
id|size
comma
r_int
id|noblock
comma
r_int
id|flags
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sock-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: sock-&gt;data = NULL: %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
(brace
id|send_sig
c_func
(paren
id|SIGPIPE
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
multiline_comment|/* We may need to bind the socket. */
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
l_int|0
)paren
(brace
id|sk-&gt;num
op_assign
id|get_new_socknum
c_func
(paren
id|sk-&gt;prot
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
l_int|0
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|put_sock
c_func
(paren
id|sk-&gt;num
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;dummy_th.source
op_assign
id|ntohs
c_func
(paren
id|sk-&gt;num
)paren
suffix:semicolon
)brace
r_return
id|sk-&gt;prot
op_member_access_from_pointer
id|write
c_func
(paren
id|sk
comma
(paren
r_int
r_char
op_star
)paren
id|ubuf
comma
id|size
comma
id|noblock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|inet_sendto
id|inet_sendto
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_void
op_star
id|ubuf
comma
r_int
id|size
comma
r_int
id|noblock
comma
r_int
id|flags
comma
r_struct
id|sockaddr
op_star
id|sin
comma
r_int
id|addr_len
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sock-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: sock-&gt;data = NULL: %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
(brace
id|send_sig
c_func
(paren
id|SIGPIPE
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;prot-&gt;sendto
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* We may need to bind the socket. */
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
l_int|0
)paren
(brace
id|sk-&gt;num
op_assign
id|get_new_socknum
c_func
(paren
id|sk-&gt;prot
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
l_int|0
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|put_sock
c_func
(paren
id|sk-&gt;num
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;dummy_th.source
op_assign
id|ntohs
c_func
(paren
id|sk-&gt;num
)paren
suffix:semicolon
)brace
r_return
id|sk-&gt;prot
op_member_access_from_pointer
id|sendto
c_func
(paren
id|sk
comma
(paren
r_int
r_char
op_star
)paren
id|ubuf
comma
id|size
comma
id|noblock
comma
id|flags
comma
(paren
r_struct
id|sockaddr_in
op_star
)paren
id|sin
comma
id|addr_len
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|inet_recvfrom
id|inet_recvfrom
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_void
op_star
id|ubuf
comma
r_int
id|size
comma
r_int
id|noblock
comma
r_int
id|flags
comma
r_struct
id|sockaddr
op_star
id|sin
comma
r_int
op_star
id|addr_len
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sock-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: sock-&gt;data = NULL: %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;prot-&gt;recvfrom
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* We may need to bind the socket. */
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
l_int|0
)paren
(brace
id|sk-&gt;num
op_assign
id|get_new_socknum
c_func
(paren
id|sk-&gt;prot
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;num
op_eq
l_int|0
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|put_sock
c_func
(paren
id|sk-&gt;num
comma
id|sk
)paren
suffix:semicolon
id|sk-&gt;dummy_th.source
op_assign
id|ntohs
c_func
(paren
id|sk-&gt;num
)paren
suffix:semicolon
)brace
r_return
id|sk-&gt;prot
op_member_access_from_pointer
id|recvfrom
c_func
(paren
id|sk
comma
(paren
r_int
r_char
op_star
)paren
id|ubuf
comma
id|size
comma
id|noblock
comma
id|flags
comma
(paren
r_struct
id|sockaddr_in
op_star
)paren
id|sin
comma
id|addr_len
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|inet_shutdown
id|inet_shutdown
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|how
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
multiline_comment|/*&n;   * This should really check to make sure&n;   * the socket is a TCP socket.&n;   */
id|how
op_increment
suffix:semicolon
multiline_comment|/* maps 0-&gt;1 has the advantage of making bit 1 rcvs and&n;&t;&t;       1-&gt;2 bit 2 snds.&n;&t;&t;       2-&gt;3 */
r_if
c_cond
(paren
id|how
op_amp
op_complement
id|SHUTDOWN_MASK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sock-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: sock-&gt;data = NULL: %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sock-&gt;state
op_eq
id|SS_CONNECTING
op_logical_and
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
)paren
id|sock-&gt;state
op_assign
id|SS_CONNECTED
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_connected
c_func
(paren
id|sk-&gt;state
)paren
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
id|sk-&gt;shutdown
op_or_assign
id|how
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;prot-&gt;shutdown
)paren
id|sk-&gt;prot
op_member_access_from_pointer
id|shutdown
c_func
(paren
id|sk
comma
id|how
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|inet_select
id|inet_select
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sock-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: sock-&gt;data = NULL: %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;prot-&gt;select
op_eq
l_int|NULL
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;select on non-selectable socket.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|sk-&gt;prot
op_member_access_from_pointer
id|select
c_func
(paren
id|sk
comma
id|sel_type
comma
id|wait
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|inet_ioctl
id|inet_ioctl
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_int
id|err
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;INET: in inet_ioctl&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sk
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sock
op_logical_and
(paren
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|sock-&gt;data
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;AF_INET: Warning: sock-&gt;data = NULL: %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FIOSETOWN
suffix:colon
r_case
id|SIOCSPGRP
suffix:colon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk
)paren
id|sk-&gt;proc
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FIOGETOWN
suffix:colon
r_case
id|SIOCGPGRP
suffix:colon
r_if
c_cond
(paren
id|sk
)paren
(brace
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|put_fs_long
c_func
(paren
id|sk-&gt;proc
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
macro_line|#if 0&t;/* FIXME: */
r_case
id|SIOCATMARK
suffix:colon
id|printk
c_func
(paren
l_string|&quot;AF_INET: ioctl(SIOCATMARK, 0x%08X)&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
r_case
id|DDIOCSDBG
suffix:colon
r_return
id|dbg_ioctl
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|DBG_INET
)paren
suffix:semicolon
r_case
id|SIOCADDRT
suffix:colon
r_case
id|SIOCDELRT
suffix:colon
r_return
id|rt_ioctl
c_func
(paren
id|cmd
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SIOCDARP
suffix:colon
r_case
id|SIOCGARP
suffix:colon
r_case
id|SIOCSARP
suffix:colon
r_return
id|arp_ioctl
c_func
(paren
id|cmd
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|IP_SET_DEV
suffix:colon
r_case
id|SIOCGIFCONF
suffix:colon
r_case
id|SIOCGIFFLAGS
suffix:colon
r_case
id|SIOCSIFFLAGS
suffix:colon
r_case
id|SIOCGIFADDR
suffix:colon
r_case
id|SIOCSIFADDR
suffix:colon
r_case
id|SIOCGIFDSTADDR
suffix:colon
r_case
id|SIOCSIFDSTADDR
suffix:colon
r_case
id|SIOCGIFBRDADDR
suffix:colon
r_case
id|SIOCSIFBRDADDR
suffix:colon
r_case
id|SIOCGIFNETMASK
suffix:colon
r_case
id|SIOCSIFNETMASK
suffix:colon
r_case
id|SIOCGIFMETRIC
suffix:colon
r_case
id|SIOCSIFMETRIC
suffix:colon
r_case
id|SIOCGIFMEM
suffix:colon
r_case
id|SIOCSIFMEM
suffix:colon
r_case
id|SIOCGIFMTU
suffix:colon
r_case
id|SIOCSIFMTU
suffix:colon
r_case
id|SIOCSIFLINK
suffix:colon
r_case
id|SIOCGIFHWADDR
suffix:colon
r_return
id|dev_ioctl
c_func
(paren
id|cmd
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|sk
op_logical_or
op_logical_neg
id|sk-&gt;prot-&gt;ioctl
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|sk-&gt;prot
op_member_access_from_pointer
id|ioctl
c_func
(paren
id|sk
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
multiline_comment|/*NOTREACHED*/
r_return
l_int|0
suffix:semicolon
)brace
r_struct
id|sk_buff
op_star
DECL|function|sock_wmalloc
id|sock_wmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
id|force
comma
r_int
id|priority
)paren
(brace
r_if
c_cond
(paren
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;wmem_alloc
op_plus
id|size
OL
id|sk-&gt;sndbuf
op_logical_or
id|force
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;wmem_alloc
op_add_assign
id|size
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|alloc_skb
c_func
(paren
id|size
comma
id|priority
)paren
suffix:semicolon
)brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;sock_wmalloc(%X,%d,%d,%d) returning NULL&bslash;n&quot;
comma
id|sk
comma
id|size
comma
id|force
comma
id|priority
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|alloc_skb
c_func
(paren
id|size
comma
id|priority
)paren
suffix:semicolon
)brace
r_struct
id|sk_buff
op_star
DECL|function|sock_rmalloc
id|sock_rmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
id|force
comma
r_int
id|priority
)paren
(brace
r_if
c_cond
(paren
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;rmem_alloc
op_plus
id|size
OL
id|sk-&gt;rcvbuf
op_logical_or
id|force
)paren
(brace
r_void
op_star
id|c
op_assign
id|alloc_skb
c_func
(paren
id|size
comma
id|priority
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
id|sk-&gt;rmem_alloc
op_add_assign
id|size
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;sock_rmalloc(%X,%d,%d,%d) returning NULL&bslash;n&quot;
comma
id|sk
comma
id|size
comma
id|force
comma
id|priority
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|alloc_skb
c_func
(paren
id|size
comma
id|priority
)paren
suffix:semicolon
)brace
r_int
r_int
DECL|function|sock_rspace
id|sock_rspace
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|amt
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;rmem_alloc
op_ge
id|sk-&gt;rcvbuf
op_minus
l_int|2
op_star
id|MIN_WINDOW
)paren
r_return
l_int|0
suffix:semicolon
id|amt
op_assign
id|min
c_func
(paren
(paren
id|sk-&gt;rcvbuf
op_minus
id|sk-&gt;rmem_alloc
)paren
op_div
l_int|2
op_minus
id|MIN_WINDOW
comma
id|MAX_WINDOW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amt
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|amt
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
r_int
DECL|function|sock_wspace
id|sock_wspace
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;wmem_alloc
op_ge
id|sk-&gt;sndbuf
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|sk-&gt;sndbuf
op_minus
id|sk-&gt;wmem_alloc
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|sock_wfree
id|sock_wfree
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_void
op_star
id|mem
comma
r_int
r_int
id|size
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;sock_wfree(sk=%X, mem=%X, size=%d)&bslash;n&quot;
comma
id|sk
comma
id|mem
comma
id|size
)paren
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|mem
)paren
suffix:semicolon
id|kfree_skbmem
c_func
(paren
id|mem
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
)paren
(brace
id|sk-&gt;wmem_alloc
op_sub_assign
id|size
suffix:semicolon
multiline_comment|/* In case it might be waiting for more memory. */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|write_space
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;destroy
op_logical_and
id|sk-&gt;wmem_alloc
op_eq
l_int|0
op_logical_and
id|sk-&gt;rmem_alloc
op_eq
l_int|0
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;recovered lost memory, sock = %X&bslash;n&quot;
comma
id|sk
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
)brace
r_void
DECL|function|sock_rfree
id|sock_rfree
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_void
op_star
id|mem
comma
r_int
r_int
id|size
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;sock_rfree(sk=%X, mem=%X, size=%d)&bslash;n&quot;
comma
id|sk
comma
id|mem
comma
id|size
)paren
)paren
suffix:semicolon
id|IS_SKB
c_func
(paren
id|mem
)paren
suffix:semicolon
id|kfree_skbmem
c_func
(paren
id|mem
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk
)paren
(brace
id|sk-&gt;rmem_alloc
op_sub_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;destroy
op_logical_and
id|sk-&gt;wmem_alloc
op_eq
l_int|0
op_logical_and
id|sk-&gt;rmem_alloc
op_eq
l_int|0
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;recovered lot memory, sock = %X&bslash;n&quot;
comma
id|sk
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * This routine must find a socket given a TCP or UDP header.&n; * Everyhting is assumed to be in net order.&n; */
DECL|function|get_sock
r_struct
id|sock
op_star
id|get_sock
c_func
(paren
r_struct
id|proto
op_star
id|prot
comma
r_int
r_int
id|num
comma
r_int
r_int
id|raddr
comma
r_int
r_int
id|rnum
comma
r_int
r_int
id|laddr
)paren
(brace
r_struct
id|sock
op_star
id|s
suffix:semicolon
r_int
r_int
id|hnum
suffix:semicolon
id|hnum
op_assign
id|ntohs
c_func
(paren
id|num
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;get_sock(prot=%X, num=%d, raddr=%X, rnum=%d, laddr=%X)&bslash;n&quot;
comma
id|prot
comma
id|num
comma
id|raddr
comma
id|rnum
comma
id|laddr
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;   * SOCK_ARRAY_SIZE must be a power of two.  This will work better&n;   * than a prime unless 3 or more sockets end up using the same&n;   * array entry.  This should not be a problem because most&n;   * well known sockets don&squot;t overlap that much, and for&n;   * the other ones, we can just be careful about picking our&n;   * socket number when we choose an arbitrary one.&n;   */
r_for
c_loop
(paren
id|s
op_assign
id|prot-&gt;sock_array
(braket
id|hnum
op_amp
(paren
id|SOCK_ARRAY_SIZE
op_minus
l_int|1
)paren
)braket
suffix:semicolon
id|s
op_ne
l_int|NULL
suffix:semicolon
id|s
op_assign
id|s-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;num
op_ne
id|hnum
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dead
op_logical_and
(paren
id|s-&gt;state
op_eq
id|TCP_CLOSE
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prot
op_eq
op_amp
id|udp_prot
)paren
(brace
r_return
id|s
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip_addr_match
c_func
(paren
id|s-&gt;daddr
comma
id|raddr
)paren
op_eq
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;dummy_th.dest
op_ne
id|rnum
op_logical_and
id|s-&gt;dummy_th.dest
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ip_addr_match
c_func
(paren
id|s-&gt;saddr
comma
id|laddr
)paren
op_eq
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
r_return
id|s
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|release_sock
r_void
id|release_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sk
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sock.c: release_sock sk == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;prot
)paren
(brace
multiline_comment|/*&t;printk(&quot;sock.c: release_sock sk-&gt;prot == NULL&bslash;n&quot;); */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;blog
)paren
r_return
suffix:semicolon
multiline_comment|/* See if we have any packets built up. */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|sk-&gt;back_log
op_ne
l_int|NULL
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|sk-&gt;blog
op_assign
l_int|1
suffix:semicolon
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|sk-&gt;back_log
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;release_sock: skb = %X:&bslash;n&quot;
comma
id|skb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;next
op_ne
id|skb
)paren
(brace
id|sk-&gt;back_log
op_assign
id|skb-&gt;next
suffix:semicolon
id|skb-&gt;prev-&gt;next
op_assign
id|skb-&gt;next
suffix:semicolon
id|skb-&gt;next-&gt;prev
op_assign
id|skb-&gt;prev
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;back_log
op_assign
l_int|NULL
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_INET
comma
l_string|&quot;sk-&gt;back_log = %X&bslash;n&quot;
comma
id|sk-&gt;back_log
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;prot-&gt;rcv
)paren
id|sk-&gt;prot
op_member_access_from_pointer
id|rcv
c_func
(paren
id|skb
comma
id|skb-&gt;dev
comma
id|sk-&gt;opt
comma
id|skb-&gt;saddr
comma
id|skb-&gt;len
comma
id|skb-&gt;daddr
comma
l_int|1
comma
multiline_comment|/* Only used for/by raw sockets. */
(paren
r_struct
id|inet_protocol
op_star
)paren
id|sk-&gt;pair
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|sk-&gt;blog
op_assign
l_int|0
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|0
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;dead
op_logical_and
id|sk-&gt;state
op_eq
id|TCP_CLOSE
)paren
(brace
multiline_comment|/* Should be about 2 rtt&squot;s */
id|reset_timer
c_func
(paren
id|sk
comma
id|TIME_DONE
comma
id|min
c_func
(paren
id|sk-&gt;rtt
op_star
l_int|2
comma
id|TCP_DONE_TIME
)paren
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|inet_fioctl
id|inet_fioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|minor
comma
id|ret
suffix:semicolon
multiline_comment|/* Extract the minor number on which we work. */
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ne
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* Now dispatch on the minor device. */
r_switch
c_cond
(paren
id|minor
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* INET */
id|ret
op_assign
id|inet_ioctl
c_func
(paren
l_int|NULL
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* IP */
id|ret
op_assign
id|ip_ioctl
c_func
(paren
l_int|NULL
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* ICMP */
id|ret
op_assign
id|icmp_ioctl
c_func
(paren
l_int|NULL
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* TCP */
id|ret
op_assign
id|tcp_ioctl
c_func
(paren
l_int|NULL
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* UDP */
id|ret
op_assign
id|udp_ioctl
c_func
(paren
l_int|NULL
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|inet_fops
r_static
r_struct
id|file_operations
id|inet_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* LSEEK&t;*/
l_int|NULL
comma
multiline_comment|/* READ&t;&t;*/
l_int|NULL
comma
multiline_comment|/* WRITE&t;*/
l_int|NULL
comma
multiline_comment|/* READDIR&t;*/
l_int|NULL
comma
multiline_comment|/* SELECT&t;*/
id|inet_fioctl
comma
multiline_comment|/* IOCTL&t;*/
l_int|NULL
comma
multiline_comment|/* MMAP&t;&t;*/
l_int|NULL
comma
multiline_comment|/* OPEN&t;&t;*/
l_int|NULL
multiline_comment|/* CLOSE&t;*/
)brace
suffix:semicolon
DECL|variable|inet_proto_ops
r_static
r_struct
id|proto_ops
id|inet_proto_ops
op_assign
(brace
id|AF_INET
comma
id|inet_create
comma
id|inet_dup
comma
id|inet_release
comma
id|inet_bind
comma
id|inet_connect
comma
id|inet_socketpair
comma
id|inet_accept
comma
id|inet_getname
comma
id|inet_read
comma
id|inet_write
comma
id|inet_select
comma
id|inet_ioctl
comma
id|inet_listen
comma
id|inet_send
comma
id|inet_recv
comma
id|inet_sendto
comma
id|inet_recvfrom
comma
id|inet_shutdown
comma
id|inet_setsockopt
comma
id|inet_getsockopt
comma
id|inet_fcntl
comma
)brace
suffix:semicolon
r_extern
r_int
r_int
id|seq_offset
suffix:semicolon
multiline_comment|/* Called by ddi.c on kernel startup.  */
DECL|function|inet_proto_init
r_void
id|inet_proto_init
c_func
(paren
r_struct
id|ddi_proto
op_star
id|pro
)paren
(brace
r_struct
id|inet_protocol
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Swansea University Computer Society Net2Debugged [1.27]&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Set up our UNIX VFS major device. */
r_if
c_cond
(paren
id|register_chrdev
c_func
(paren
id|AF_INET_MAJOR
comma
l_string|&quot;af_inet&quot;
comma
op_amp
id|inet_fops
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: cannot register major device %d!&bslash;n&quot;
comma
id|pro-&gt;name
comma
id|AF_INET_MAJOR
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Tell SOCKET that we are alive... */
(paren
r_void
)paren
id|sock_register
c_func
(paren
id|inet_proto_ops.family
comma
op_amp
id|inet_proto_ops
)paren
suffix:semicolon
id|seq_offset
op_assign
id|CURRENT_TIME
op_star
l_int|250
suffix:semicolon
multiline_comment|/* Add all the protocols. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SOCK_ARRAY_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tcp_prot.sock_array
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|udp_prot.sock_array
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|raw_prot.sock_array
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;IP Protocols: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|inet_protocol_base
suffix:semicolon
id|p
op_ne
l_int|NULL
suffix:semicolon
)paren
(brace
r_struct
id|inet_protocol
op_star
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
r_struct
id|inet_protocol
op_star
)paren
id|p-&gt;next
suffix:semicolon
id|inet_add_protocol
c_func
(paren
id|p
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s%s&quot;
comma
id|p-&gt;name
comma
id|tmp
ques
c_cond
l_string|&quot;, &quot;
suffix:colon
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|p
op_assign
id|tmp
suffix:semicolon
)brace
multiline_comment|/* Initialize the DEV module. */
id|dev_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Initialize the &quot;Buffer Head&quot; pointers. */
id|bh_base
(braket
id|INET_BH
)braket
dot
id|routine
op_assign
id|inet_bh
suffix:semicolon
)brace
eof
