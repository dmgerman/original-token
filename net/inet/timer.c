multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;TIMER - implementation of software timers.&n; *&n; * Version:&t;@(#)timer.c&t;1.0.7&t;05/25/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Fred Baumgarten, &lt;dc6iq@insu1.etec.uni-karlsruhe.de&gt;&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &quot;inet.h&quot;
macro_line|#include &quot;timer.h&quot;
macro_line|#include &quot;dev.h&quot;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &quot;skbuff.h&quot;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &quot;arp.h&quot;
DECL|variable|timer_base
r_struct
id|timer
op_star
id|timer_base
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|seq_offset
r_int
r_int
id|seq_offset
suffix:semicolon
r_void
DECL|function|delete_timer
id|delete_timer
c_func
(paren
r_struct
id|timer
op_star
id|t
)paren
(brace
r_struct
id|timer
op_star
id|tm
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TMR
comma
l_string|&quot;delete_timer(t=%X)&bslash;n&quot;
comma
id|t
)paren
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_base
op_eq
l_int|NULL
op_logical_or
id|t
op_eq
l_int|NULL
)paren
(brace
id|t-&gt;running
op_assign
l_int|9
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|t
op_eq
id|timer_base
)paren
(brace
id|timer_base
op_assign
id|t-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|timer_base
op_ne
l_int|NULL
)paren
(brace
id|timer_table
(braket
id|NET_TIMER
)braket
dot
id|expires
op_assign
id|timer_base-&gt;when
suffix:semicolon
id|timer_active
op_or_assign
(paren
l_int|1
op_lshift
id|NET_TIMER
)paren
suffix:semicolon
)brace
r_else
(brace
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|NET_TIMER
)paren
suffix:semicolon
)brace
id|t-&gt;running
op_assign
l_int|0
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|tm
op_assign
id|timer_base
suffix:semicolon
r_while
c_loop
(paren
id|tm
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|tm-&gt;next
op_eq
id|t
)paren
(brace
id|tm-&gt;next
op_assign
id|t-&gt;next
suffix:semicolon
id|t-&gt;running
op_assign
l_int|0
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|tm
op_assign
id|tm-&gt;next
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|t-&gt;running
op_assign
l_int|9
suffix:semicolon
)brace
r_void
DECL|function|reset_timer
id|reset_timer
c_func
(paren
r_struct
id|timer
op_star
id|t
)paren
(brace
r_struct
id|timer
op_star
id|tm
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TMR
comma
l_string|&quot;reset_timer(t=%X) when = %d jiffies = %d&bslash;n&quot;
comma
id|t
comma
id|t-&gt;when
comma
id|jiffies
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;*** reset timer NULL timer&bslash;n&quot;
)paren
suffix:semicolon
id|__asm__
(paren
l_string|&quot;&bslash;t int $3&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|t-&gt;running
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TMR
comma
l_string|&quot;t-&gt;running has value of %d, len %d&bslash;n&quot;
comma
id|t-&gt;running
comma
id|t-&gt;len
)paren
)paren
suffix:semicolon
)brace
id|t-&gt;running
op_assign
l_int|1
suffix:semicolon
id|delete_timer
c_func
(paren
id|t
)paren
suffix:semicolon
multiline_comment|/* here is another race condition ! */
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* what about a new reset_timer while being&bslash; */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|t-&gt;running
op_eq
l_int|0
)paren
op_logical_or
(paren
id|t-&gt;running
op_eq
l_int|9
)paren
)paren
)paren
(brace
multiline_comment|/* about to install on old one ? -FB */
id|printk
c_func
(paren
l_string|&quot;reset_timer(): t-&gt;running after delete_timer: %d !&bslash;n&quot;
comma
id|t-&gt;running
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|t-&gt;running
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|t-&gt;len
OL
l_int|0
)paren
multiline_comment|/* prevent close to infinite timers. THEY _DO_ */
id|t-&gt;len
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* happen (negative values ?) - don&squot;t ask me why ! -FB */
id|delete_timer
c_func
(paren
id|t
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|t-&gt;when
op_assign
id|timer_seq
op_plus
id|t-&gt;len
suffix:semicolon
multiline_comment|/* First see if it goes at the beginning. */
r_if
c_cond
(paren
id|timer_base
op_eq
l_int|NULL
)paren
(brace
id|t-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|timer_base
op_assign
id|t
suffix:semicolon
id|timer_table
(braket
id|NET_TIMER
)braket
dot
id|expires
op_assign
id|timer_base-&gt;when
suffix:semicolon
id|timer_active
op_or_assign
(paren
l_int|1
op_lshift
id|NET_TIMER
)paren
suffix:semicolon
id|t-&gt;running
op_assign
l_int|3
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|before
c_func
(paren
id|t-&gt;when
comma
id|timer_base-&gt;when
)paren
)paren
(brace
id|t-&gt;next
op_assign
id|timer_base
suffix:semicolon
id|timer_base
op_assign
id|t
suffix:semicolon
id|timer_table
(braket
id|NET_TIMER
)braket
dot
id|expires
op_assign
id|timer_base-&gt;when
suffix:semicolon
id|timer_active
op_or_assign
(paren
l_int|1
op_lshift
id|NET_TIMER
)paren
suffix:semicolon
id|t-&gt;running
op_assign
l_int|4
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|tm
op_assign
id|timer_base
suffix:semicolon
r_while
c_loop
(paren
id|tm
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|tm-&gt;next
op_eq
l_int|NULL
op_logical_or
id|t-&gt;when
OL
id|tm-&gt;next-&gt;when
)paren
(brace
id|t-&gt;next
op_assign
id|tm-&gt;next
suffix:semicolon
id|tm-&gt;next
op_assign
id|t
suffix:semicolon
id|timer_table
(braket
id|NET_TIMER
)braket
dot
id|expires
op_assign
id|timer_base-&gt;when
suffix:semicolon
id|timer_active
op_or_assign
(paren
l_int|1
op_lshift
id|NET_TIMER
)paren
suffix:semicolon
id|t-&gt;running
op_assign
l_int|5
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|tm
op_assign
id|tm-&gt;next
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Now we will only be called whenever we need to do&n; * something, but we must be sure to process all of the&n; * sockets that need it.&n; */
r_void
DECL|function|net_timer
id|net_timer
c_func
(paren
r_void
)paren
(brace
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_struct
id|timer
op_star
id|tm
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* a timer might expire and a new one with */
multiline_comment|/* earlier expiration could be inserted before -FB */
id|tm
op_assign
id|timer_base
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tm
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|jiffies
op_ge
id|tm-&gt;when
)paren
)paren
(brace
r_int
id|why
suffix:semicolon
id|sk
op_assign
id|tm-&gt;sk
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;inuse
)paren
(brace
r_break
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|why
op_assign
id|sk-&gt;timeout
suffix:semicolon
id|DPRINTF
c_func
(paren
(paren
id|DBG_TMR
comma
l_string|&quot;net_timer: found sk=%X why = %d&bslash;n&quot;
comma
id|sk
comma
id|why
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;keepopen
)paren
(brace
id|sk-&gt;time_wait.len
op_assign
id|TCP_TIMEOUT_LEN
suffix:semicolon
id|sk-&gt;timeout
op_assign
id|TIME_KEEPOPEN
suffix:semicolon
id|reset_timer
c_func
(paren
id|tm
)paren
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|delete_timer
c_func
(paren
id|tm
)paren
suffix:semicolon
)brace
multiline_comment|/* Always see if we need to send an ack. */
r_if
c_cond
(paren
id|sk-&gt;ack_backlog
)paren
(brace
id|sk-&gt;prot
op_member_access_from_pointer
id|read_wakeup
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|wake_up
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
multiline_comment|/* Now we need to figure out why the socket was on the timer. */
r_switch
c_cond
(paren
id|why
)paren
(brace
r_case
id|TIME_DONE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
op_logical_or
id|sk-&gt;state
op_ne
id|TCP_CLOSE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;non dead socket in time_done&bslash;n&quot;
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|destroy_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_DESTROY
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * We&squot;ve waited for a while for all the memory&n;&t;&t;&t; * assosiated with the socket to be freed.  We&n;&t;&t;&t; * need to print an error message.&n;&t;&t;&t; */
id|DPRINTF
c_func
(paren
(paren
id|DBG_TMR
comma
l_string|&quot;possible memory leak.  sk = %X&bslash;n&quot;
comma
id|sk
)paren
)paren
suffix:semicolon
id|destroy_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;inuse
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_CLOSE
suffix:colon
multiline_comment|/* We&squot;ve waited long enough, close the socket. */
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|delete_timer
c_func
(paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Kill the ARP entry in case the hardware&n;&t;&t;&t; * has changed.&n;&t;&t;&t; */
id|arp_destroy
c_func
(paren
id|sk-&gt;daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|wake_up
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|sk-&gt;time_wait.len
op_assign
id|TCP_DONE_TIME
suffix:semicolon
id|sk-&gt;timeout
op_assign
id|TIME_DESTROY
suffix:semicolon
id|reset_timer
(paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_WRITE
suffix:colon
multiline_comment|/* try to retransmit. */
multiline_comment|/*&n;&t;&t;&t; * It could be we got here because we&n;&t;&t;&t; * needed to send an ack.  So we need&n;&t;&t;&t; * to check for that.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;send_head
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|jiffies
OL
(paren
id|sk-&gt;send_head-&gt;when
op_plus
id|backoff
c_func
(paren
id|sk-&gt;backoff
)paren
op_star
(paren
l_int|2
op_star
id|sk-&gt;mdev
op_plus
id|sk-&gt;rtt
)paren
)paren
)paren
(brace
multiline_comment|/* printk(&quot;timer: not yet&bslash;n&quot;); */
id|sk-&gt;time_wait.len
op_assign
(paren
id|sk-&gt;send_head-&gt;when
op_plus
id|backoff
c_func
(paren
id|sk-&gt;backoff
)paren
op_star
(paren
l_int|2
op_star
id|sk-&gt;mdev
op_plus
id|sk-&gt;rtt
)paren
)paren
op_minus
id|jiffies
suffix:semicolon
id|sk-&gt;timeout
op_assign
id|TIME_WRITE
suffix:semicolon
id|reset_timer
c_func
(paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* printk(&quot;timer: seq %d retrans %d out %d cong %d&bslash;n&quot;, sk-&gt;send_head-&gt;h.seq,&n;       sk-&gt;retransmits, sk-&gt;packets_out, sk-&gt;cong_window); */
id|DPRINTF
c_func
(paren
(paren
id|DBG_TMR
comma
l_string|&quot;retransmitting.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|retransmit
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;retransmits
op_ne
l_int|0
op_logical_and
(paren
id|sk-&gt;retransmits
op_amp
l_int|7
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;retransmits
OG
id|TCP_RETR1
)paren
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TMR
comma
l_string|&quot;timer.c TIME_WRITE time-out 1&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|arp_destroy
c_func
(paren
id|sk-&gt;daddr
)paren
suffix:semicolon
id|ip_route_check
c_func
(paren
id|sk-&gt;daddr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;retransmits
OG
id|TCP_RETR2
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TMR
comma
l_string|&quot;timer.c TIME_WRITE time-out 2&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sk-&gt;err
op_assign
id|ETIMEDOUT
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT1
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT2
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_LAST_ACK
)paren
(brace
id|sk-&gt;state
op_assign
id|TCP_TIME_WAIT
suffix:semicolon
id|sk-&gt;timeout
op_assign
id|TIME_CLOSE
suffix:semicolon
id|sk-&gt;time_wait.len
op_assign
id|TCP_TIMEWAIT_LEN
suffix:semicolon
id|reset_timer
c_func
(paren
op_amp
id|sk-&gt;time_wait
)paren
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;prot
op_member_access_from_pointer
id|close
c_func
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_KEEPOPEN
suffix:colon
multiline_comment|/* Send something to keep the connection open. */
r_if
c_cond
(paren
id|sk-&gt;prot-&gt;write_wakeup
op_ne
l_int|NULL
)paren
id|sk-&gt;prot
op_member_access_from_pointer
id|write_wakeup
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;retransmits
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_eq
id|SHUTDOWN_MASK
)paren
(brace
id|sk-&gt;prot
op_member_access_from_pointer
id|close
c_func
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;retransmits
op_ne
l_int|0
op_logical_and
(paren
id|sk-&gt;retransmits
op_amp
l_int|7
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;retransmits
OG
id|TCP_RETR1
)paren
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TMR
comma
l_string|&quot;timer.c TIME_KEEPOPEN time-out 1&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|arp_destroy
c_func
(paren
id|sk-&gt;daddr
)paren
suffix:semicolon
id|ip_route_check
c_func
(paren
id|sk-&gt;daddr
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;retransmits
OG
id|TCP_RETR2
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
id|DBG_TMR
comma
l_string|&quot;timer.c TIME_KEEPOPEN time-out 2&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|arp_destroy
(paren
id|sk-&gt;daddr
)paren
suffix:semicolon
id|sk-&gt;err
op_assign
id|ETIMEDOUT
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT1
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT2
)paren
(brace
id|sk-&gt;state
op_assign
id|TCP_TIME_WAIT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|wake_up
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;prot-&gt;close
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;net timer expired - reason unknown, sk=%08X&bslash;n&quot;
comma
(paren
r_int
)paren
id|sk
)paren
suffix:semicolon
id|release_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|tm
op_assign
id|timer_base
suffix:semicolon
)brace
multiline_comment|/* Now we need to reset the timer. */
r_if
c_cond
(paren
id|timer_base
op_ne
l_int|NULL
)paren
(brace
id|timer_table
(braket
id|NET_TIMER
)braket
dot
id|expires
op_assign
id|timer_base-&gt;when
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|NET_TIMER
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
eof
