multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;TIMER - implementation of software timers for IP.&n; *&n; * Version:&t;@(#)timer.c&t;1.0.7&t;05/25/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Fred Baumgarten, &lt;dc6iq@insu1.etec.uni-karlsruhe.de&gt;&n; *&t;&t;Florian La Roche, &lt;flla@stud.uni-sb.de&gt;&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;To avoid destroying a wait queue as we use it&n; *&t;&t;&t;&t;&t;we defer destruction until the destroy timer goes&n; *&t;&t;&t;&t;&t;off.&n; *&t;&t;Alan Cox&t;:&t;Destroy socket doesn&squot;t write a status value to the&n; *&t;&t;&t;&t;&t;socket buffer _AFTER_ freeing it! Also sock ensures&n; *&t;&t;&t;&t;&t;the socket will get removed BEFORE this is called&n; *&t;&t;&t;&t;&t;otherwise if the timer TIME_DESTROY occurs inside&n; *&t;&t;&t;&t;&t;of inet_bh() with this socket being handled it goes&n; *&t;&t;&t;&t;&t;BOOM! Have to stop timer going off if net_bh is&n; *&t;&t;&t;&t;&t;active or the destroy causes crashes.&n; *&t;&t;Alan Cox&t;:&t;Cleaned up unused code.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &quot;ip.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;tcp.h&quot;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &quot;sock.h&quot;
macro_line|#include &quot;arp.h&quot;
DECL|function|delete_timer
r_void
id|delete_timer
(paren
r_struct
id|sock
op_star
id|t
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|t-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|del_timer
(paren
op_amp
id|t-&gt;timer
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|reset_timer
r_void
id|reset_timer
(paren
r_struct
id|sock
op_star
id|t
comma
r_int
id|timeout
comma
r_int
r_int
id|len
)paren
(brace
id|delete_timer
(paren
id|t
)paren
suffix:semicolon
id|t-&gt;timeout
op_assign
id|timeout
suffix:semicolon
macro_line|#if 1
multiline_comment|/* FIXME: ??? */
r_if
c_cond
(paren
(paren
r_int
)paren
id|len
OL
l_int|0
)paren
multiline_comment|/* prevent close to infinite timers. THEY _DO_ */
id|len
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* happen (negative values ?) - don&squot;t ask me why ! -FB */
macro_line|#endif
id|t-&gt;timer.expires
op_assign
id|len
suffix:semicolon
id|add_timer
(paren
op_amp
id|t-&gt;timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Now we will only be called whenever we need to do&n; *&t;something, but we must be sure to process all of the&n; *&t;sockets that need it.&n; */
DECL|function|net_timer
r_void
id|net_timer
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|data
suffix:semicolon
r_int
id|why
op_assign
id|sk-&gt;timeout
suffix:semicolon
multiline_comment|/* &n;&t; * only process if socket is not in use&n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;inuse
op_logical_or
id|in_bh
)paren
(brace
id|sk-&gt;timer.expires
op_assign
l_int|10
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sk-&gt;timer
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sk-&gt;inuse
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Always see if we need to send an ack. */
r_if
c_cond
(paren
id|sk-&gt;ack_backlog
op_logical_and
op_logical_neg
id|sk-&gt;zapped
)paren
(brace
id|sk-&gt;prot-&gt;read_wakeup
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Now we need to figure out why the socket was on the timer. */
r_switch
c_cond
(paren
id|why
)paren
(brace
r_case
id|TIME_DONE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
op_logical_or
id|sk-&gt;state
op_ne
id|TCP_CLOSE
)paren
(brace
id|printk
(paren
l_string|&quot;non dead socket in time_done&bslash;n&quot;
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|destroy_sock
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_DESTROY
suffix:colon
multiline_comment|/*&n;&t;&t; *&t;We&squot;ve waited for a while for all the memory associated with&n;&t;&t; *&t;the socket to be freed.&n;&t;&t; */
r_if
c_cond
(paren
id|sk-&gt;wmem_alloc
op_ne
l_int|0
op_logical_or
id|sk-&gt;rmem_alloc
op_ne
l_int|0
)paren
(brace
id|sk-&gt;wmem_alloc
op_increment
suffix:semicolon
multiline_comment|/* So it DOESN&squot;T go away */
id|destroy_sock
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;wmem_alloc
op_decrement
suffix:semicolon
multiline_comment|/* Might now have hit 0 - fall through and do it again if so */
id|sk-&gt;inuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This will be ok, the destroy won&squot;t totally work */
)brace
r_if
c_cond
(paren
id|sk-&gt;wmem_alloc
op_eq
l_int|0
op_logical_and
id|sk-&gt;rmem_alloc
op_eq
l_int|0
)paren
(brace
id|destroy_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* Socket gone, DON&squot;T update sk-&gt;inuse! */
r_break
suffix:semicolon
r_case
id|TIME_CLOSE
suffix:colon
multiline_comment|/* We&squot;ve waited long enough, close the socket. */
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
id|delete_timer
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* Kill the ARP entry in case the hardware has changed. */
id|arp_destroy
(paren
id|sk-&gt;daddr
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
id|reset_timer
(paren
id|sk
comma
id|TIME_DESTROY
comma
id|TCP_DONE_TIME
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if 0
r_case
id|TIME_PROBE0
suffix:colon
id|tcp_send_probe0
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_WRITE
suffix:colon
multiline_comment|/* try to retransmit. */
multiline_comment|/* It could be we got here because we needed to send an ack.&n;&t;&t;&t; * So we need to check for that.&n;&t;&t;&t; */
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|skb
op_assign
id|sk-&gt;send_head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|jiffies
OL
id|skb-&gt;when
op_plus
id|sk-&gt;rto
)paren
(brace
id|reset_timer
(paren
id|sk
comma
id|TIME_WRITE
comma
id|skb-&gt;when
op_plus
id|sk-&gt;rto
op_minus
id|jiffies
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* printk(&quot;timer: seq %d retrans %d out %d cong %d&bslash;n&quot;, sk-&gt;send_head-&gt;h.seq,&n;&t;&t;&t;&t;&t;sk-&gt;retransmits, sk-&gt;packets_out, sk-&gt;cong_window); */
id|sk-&gt;prot-&gt;retransmit
(paren
id|sk
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;retransmits
op_logical_and
op_logical_neg
(paren
id|sk-&gt;retransmits
op_amp
l_int|7
)paren
)paren
op_logical_or
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;retransmits
OG
id|TCP_RETR1
)paren
)paren
(brace
id|arp_destroy
(paren
id|sk-&gt;daddr
comma
l_int|0
)paren
suffix:semicolon
id|ip_route_check
(paren
id|sk-&gt;daddr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;retransmits
OG
id|TCP_RETR2
)paren
(brace
id|sk-&gt;err
op_assign
id|ETIMEDOUT
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT1
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT2
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_CLOSING
)paren
(brace
id|sk-&gt;state
op_assign
id|TCP_TIME_WAIT
suffix:semicolon
id|reset_timer
(paren
id|sk
comma
id|TIME_CLOSE
comma
id|TCP_TIMEWAIT_LEN
)paren
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;prot-&gt;close
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|TIME_KEEPOPEN
suffix:colon
multiline_comment|/* &n;&t;&t;&t; * this reset_timer() call is a hack, this is not&n;&t;&t;&t; * how KEEPOPEN is supposed to work.&n;&t;&t;&t; */
id|reset_timer
(paren
id|sk
comma
id|TIME_KEEPOPEN
comma
id|TCP_TIMEOUT_LEN
)paren
suffix:semicolon
multiline_comment|/* Send something to keep the connection open. */
r_if
c_cond
(paren
id|sk-&gt;prot-&gt;write_wakeup
)paren
id|sk-&gt;prot-&gt;write_wakeup
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;retransmits
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;shutdown
op_eq
id|SHUTDOWN_MASK
)paren
(brace
id|sk-&gt;prot-&gt;close
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
id|sk-&gt;state
op_assign
id|TCP_CLOSE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sk-&gt;state
op_eq
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;retransmits
op_logical_and
op_logical_neg
(paren
id|sk-&gt;retransmits
op_amp
l_int|7
)paren
)paren
op_logical_or
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;retransmits
OG
id|TCP_RETR1
)paren
)paren
(brace
id|arp_destroy
(paren
id|sk-&gt;daddr
comma
l_int|0
)paren
suffix:semicolon
id|ip_route_check
(paren
id|sk-&gt;daddr
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;state
op_ne
id|TCP_ESTABLISHED
op_logical_and
id|sk-&gt;retransmits
OG
id|TCP_RETR2
)paren
(brace
id|arp_destroy
(paren
id|sk-&gt;daddr
comma
l_int|0
)paren
suffix:semicolon
id|sk-&gt;err
op_assign
id|ETIMEDOUT
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT1
op_logical_or
id|sk-&gt;state
op_eq
id|TCP_FIN_WAIT2
)paren
(brace
id|sk-&gt;state
op_assign
id|TCP_TIME_WAIT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;prot-&gt;close
(paren
id|sk
comma
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|printk
(paren
l_string|&quot;net_timer: timer expired - reason %d is unknown&bslash;n&quot;
comma
id|why
)paren
suffix:semicolon
id|release_sock
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
eof
