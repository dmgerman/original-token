multiline_comment|/*&n; * NET&t;&t;An implementation of the IEEE 802.2 LLC protocol for the&n; *&t;&t;LINUX operating system.  LLC is implemented as a set of &n; *&t;&t;state machines and callbacks for higher networking layers.&n; *&n; *&t;&t;Small utilities, Linux timer handling.&n; *&n; *&t;&t;Written by Tim Alpaerts, Tim_Alpaerts@toyota-motor-europe.com&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; *&n; *&t;Changes&n; *&t;&t;Alan Cox&t;:&t;Chainsawed into Linux form.&n; *&t;&t;&t;&t;&t;Added llc_ function name prefixes.&n; *&t;&t;&t;&t;&t;Fixed bug in stop/start timer.&n; *&t;&t;&t;&t;&t;Added llc_cancel_timers for closing&n; *&t;&t;&t;&t;&t;&t;down an llc&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;net/llc_frame.h&gt;
macro_line|#include &lt;net/llc.h&gt;
DECL|function|llc_decode_frametype
r_int
id|llc_decode_frametype
c_func
(paren
id|frameptr
id|fr
)paren
(brace
r_if
c_cond
(paren
id|IS_UFRAME
c_func
(paren
id|fr
)paren
)paren
(brace
multiline_comment|/* unnumbered cmd/rsp */
r_switch
c_cond
(paren
id|fr-&gt;u_mm.mm
op_amp
l_int|0x3B
)paren
(brace
r_case
l_int|0x1B
suffix:colon
r_return
id|SABME_CMD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x10
suffix:colon
r_return
id|DISC_CMD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x18
suffix:colon
r_return
id|UA_RSP
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x03
suffix:colon
r_return
id|DM_RSP
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x21
suffix:colon
r_return
id|FRMR_RSP
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x00
suffix:colon
r_return
id|UI_CMD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x2B
suffix:colon
r_if
c_cond
(paren
id|IS_RSP
c_func
(paren
id|fr
)paren
)paren
r_return
id|XID_RSP
suffix:semicolon
r_else
r_return
id|XID_CMD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x38
suffix:colon
r_if
c_cond
(paren
id|IS_RSP
c_func
(paren
id|fr
)paren
)paren
r_return
id|TEST_RSP
suffix:semicolon
r_else
r_return
id|TEST_CMD
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|BAD_FRAME
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|IS_SFRAME
c_func
(paren
id|fr
)paren
)paren
(brace
multiline_comment|/* supervisory cmd/rsp */
r_switch
c_cond
(paren
id|fr-&gt;s_hdr.ss
)paren
(brace
r_case
l_int|0x00
suffix:colon
r_if
c_cond
(paren
id|IS_RSP
c_func
(paren
id|fr
)paren
)paren
r_return
id|RR_RSP
suffix:semicolon
r_else
r_return
id|RR_CMD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x02
suffix:colon
r_if
c_cond
(paren
id|IS_RSP
c_func
(paren
id|fr
)paren
)paren
r_return
id|REJ_RSP
suffix:semicolon
r_else
r_return
id|REJ_CMD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
r_if
c_cond
(paren
id|IS_RSP
c_func
(paren
id|fr
)paren
)paren
r_return
id|RNR_RSP
suffix:semicolon
r_else
r_return
id|RNR_CMD
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|BAD_FRAME
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* information xfer */
r_if
c_cond
(paren
id|IS_RSP
c_func
(paren
id|fr
)paren
)paren
r_return
id|I_RSP
suffix:semicolon
r_else
r_return
id|I_CMD
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Validate_seq_nos will check N(S) and N(R) to see if they are&n; *&t;invalid or unexpected.&n; *&t;&quot;unexpected&quot; is explained on p44 Send State Variable.&n; *&t;The return value is:&n; *&t;&t;4 * invalid N(R) +&n; *&t;&t;2 * invalid N(S) +&n; *&t;&t;1 * unexpected N(S)&n; */
DECL|function|llc_validate_seq_nos
r_int
id|llc_validate_seq_nos
c_func
(paren
id|llcptr
id|lp
comma
id|frameptr
id|fr
)paren
(brace
r_int
id|res
suffix:semicolon
multiline_comment|/*&n;&t; *&t;A U-frame is always good &n;&t; */
r_if
c_cond
(paren
id|IS_UFRAME
c_func
(paren
id|fr
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;For S- and I-frames check N(R): &n;&t; */
r_if
c_cond
(paren
id|fr-&gt;i_hdr.nr
op_eq
id|lp-&gt;vs
)paren
(brace
multiline_comment|/* if N(R) = V(S)  */
id|res
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* N(R) is good */
)brace
r_else
(brace
multiline_comment|/* lp-&gt;k = transmit window size */
r_if
c_cond
(paren
id|lp-&gt;vs
op_ge
id|lp-&gt;k
)paren
(brace
multiline_comment|/* if window not wrapped around 127 */
r_if
c_cond
(paren
(paren
id|fr-&gt;i_hdr.nr
OL
id|lp-&gt;vs
)paren
op_logical_and
(paren
id|fr-&gt;i_hdr.nr
OG
(paren
id|lp-&gt;vs
op_minus
id|lp-&gt;k
)paren
)paren
)paren
id|res
op_assign
l_int|0
suffix:semicolon
r_else
id|res
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* N(R) invalid */
)brace
r_else
(brace
multiline_comment|/* window wraps around 127 */
r_if
c_cond
(paren
(paren
id|fr-&gt;i_hdr.nr
OL
id|lp-&gt;vs
)paren
op_logical_or
(paren
id|fr-&gt;i_hdr.nr
OG
(paren
l_int|128
op_plus
id|lp-&gt;vs
op_minus
id|lp-&gt;k
)paren
)paren
)paren
id|res
op_assign
l_int|0
suffix:semicolon
r_else
id|res
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* N(R) invalid */
)brace
)brace
multiline_comment|/*&n;&t; *&t;For an I-frame, must check N(S) also:  &n;&t; */
r_if
c_cond
(paren
id|IS_IFRAME
c_func
(paren
id|fr
)paren
)paren
(brace
r_if
c_cond
(paren
id|fr-&gt;i_hdr.ns
op_eq
id|lp-&gt;vr
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* N(S) good */
r_if
c_cond
(paren
id|lp-&gt;vr
op_ge
id|lp-&gt;rw
)paren
(brace
multiline_comment|/* if receive window not wrapped */
r_if
c_cond
(paren
(paren
id|fr-&gt;i_hdr.ns
OL
id|lp-&gt;vr
)paren
op_logical_and
(paren
id|fr-&gt;i_hdr.ns
OG
(paren
id|lp-&gt;vr
op_minus
id|lp-&gt;k
)paren
)paren
)paren
id|res
op_assign
id|res
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* N(S) unexpected */
r_else
id|res
op_assign
id|res
op_plus
l_int|2
suffix:semicolon
multiline_comment|/* N(S) invalid */
)brace
r_else
(brace
multiline_comment|/* Window wraps around 127 */
r_if
c_cond
(paren
(paren
id|fr-&gt;i_hdr.ns
OL
id|lp-&gt;vr
)paren
op_logical_or
(paren
id|fr-&gt;i_hdr.ns
OG
(paren
l_int|128
op_plus
id|lp-&gt;vr
op_minus
id|lp-&gt;k
)paren
)paren
)paren
id|res
op_assign
id|res
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* N(S) unexpected */
r_else
id|res
op_assign
id|res
op_plus
l_int|2
suffix:semicolon
multiline_comment|/* N(S) invalid */
)brace
)brace
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* **************** timer management routines ********************* */
DECL|function|llc_p_timer_expired
r_static
r_void
id|llc_p_timer_expired
c_func
(paren
r_int
r_int
id|ulp
)paren
(brace
id|llc_timer_expired
c_func
(paren
(paren
id|llcptr
)paren
id|ulp
comma
id|P_TIMER
)paren
suffix:semicolon
)brace
DECL|function|llc_rej_timer_expired
r_static
r_void
id|llc_rej_timer_expired
c_func
(paren
r_int
r_int
id|ulp
)paren
(brace
id|llc_timer_expired
c_func
(paren
(paren
id|llcptr
)paren
id|ulp
comma
id|REJ_TIMER
)paren
suffix:semicolon
)brace
DECL|function|llc_ack_timer_expired
r_static
r_void
id|llc_ack_timer_expired
c_func
(paren
r_int
r_int
id|ulp
)paren
(brace
id|llc_timer_expired
c_func
(paren
(paren
id|llcptr
)paren
id|ulp
comma
id|ACK_TIMER
)paren
suffix:semicolon
)brace
DECL|function|llc_busy_timer_expired
r_static
r_void
id|llc_busy_timer_expired
c_func
(paren
r_int
r_int
id|ulp
)paren
(brace
id|llc_timer_expired
c_func
(paren
(paren
id|llcptr
)paren
id|ulp
comma
id|BUSY_TIMER
)paren
suffix:semicolon
)brace
multiline_comment|/* exp_fcn is an array holding the 4 entry points of the&n;   timer expiry routines above.&n;   It is required to keep start_timer() generic.&n;   Thank you cdecl.&n; */
DECL|variable|exp_fcn
r_static
r_void
(paren
op_star
id|exp_fcn
(braket
)braket
)paren
(paren
r_int
r_int
)paren
op_assign
(brace
id|llc_p_timer_expired
comma
id|llc_rej_timer_expired
comma
id|llc_ack_timer_expired
comma
id|llc_busy_timer_expired
)brace
suffix:semicolon
DECL|function|llc_start_timer
r_void
id|llc_start_timer
c_func
(paren
id|llcptr
id|lp
comma
r_int
id|t
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;timer_state
(braket
id|t
)braket
op_eq
id|TIMER_IDLE
)paren
(brace
id|lp-&gt;tl
(braket
id|t
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
id|lp-&gt;timer_interval
(braket
id|t
)braket
suffix:semicolon
id|lp-&gt;tl
(braket
id|t
)braket
dot
id|data
op_assign
(paren
r_int
r_int
)paren
id|lp
suffix:semicolon
id|lp-&gt;tl
(braket
id|t
)braket
dot
id|function
op_assign
id|exp_fcn
(braket
id|t
)braket
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|lp-&gt;tl
(braket
id|t
)braket
)paren
suffix:semicolon
id|lp-&gt;timer_state
(braket
id|t
)braket
op_assign
id|TIMER_RUNNING
suffix:semicolon
)brace
)brace
DECL|function|llc_stop_timer
r_void
id|llc_stop_timer
c_func
(paren
id|llcptr
id|lp
comma
r_int
id|t
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;timer_state
(braket
id|t
)braket
op_eq
id|TIMER_RUNNING
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|lp-&gt;tl
(braket
id|t
)braket
)paren
suffix:semicolon
id|lp-&gt;timer_state
(braket
id|t
)braket
op_assign
id|TIMER_IDLE
suffix:semicolon
)brace
)brace
DECL|function|llc_cancel_timers
r_void
id|llc_cancel_timers
c_func
(paren
id|llcptr
id|lp
)paren
(brace
id|llc_stop_timer
c_func
(paren
id|lp
comma
id|P_TIMER
)paren
suffix:semicolon
id|llc_stop_timer
c_func
(paren
id|lp
comma
id|REJ_TIMER
)paren
suffix:semicolon
id|llc_stop_timer
c_func
(paren
id|lp
comma
id|ACK_TIMER
)paren
suffix:semicolon
id|llc_stop_timer
c_func
(paren
id|lp
comma
id|BUSY_TIMER
)paren
suffix:semicolon
)brace
eof
