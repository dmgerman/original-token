multiline_comment|/*&n; * linux/net/sunrpc/svcauth_des.c&n; *&n; * Server-side AUTH_DES handling.&n; * &n; * Copyright (C) 1996, 1997 Olaf Kirch &lt;okir@monad.swb.de&gt;&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/sunrpc/types.h&gt;
macro_line|#include &lt;linux/sunrpc/xdr.h&gt;
macro_line|#include &lt;linux/sunrpc/svcauth.h&gt;
macro_line|#include &lt;linux/sunrpc/svcsock.h&gt;
DECL|macro|RPCDBG_FACILITY
mdefine_line|#define RPCDBG_FACILITY&t;RPCDBG_AUTH
multiline_comment|/*&n; * DES cedential cache.&n; * The cache is indexed by fullname/key to allow for multiple sessions&n; * by the same user from different hosts.&n; * It would be tempting to use the client&squot;s IP address rather than the&n; * conversation key as an index, but that could become problematic for&n; * multi-homed hosts that distribute traffic across their interfaces.&n; */
DECL|struct|des_cred
r_struct
id|des_cred
(brace
DECL|member|dc_next
r_struct
id|des_cred
op_star
id|dc_next
suffix:semicolon
DECL|member|dc_fullname
r_char
op_star
id|dc_fullname
suffix:semicolon
DECL|member|dc_nickname
id|u32
id|dc_nickname
suffix:semicolon
DECL|member|dc_key
id|des_cblock
id|dc_key
suffix:semicolon
multiline_comment|/* conversation key */
DECL|member|dc_xkey
id|des_cblock
id|dc_xkey
suffix:semicolon
multiline_comment|/* encrypted conv. key */
DECL|member|dc_keysched
id|des_key_schedule
id|dc_keysched
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|ADN_FULLNAME
mdefine_line|#define ADN_FULLNAME&t;&t;0
DECL|macro|ADN_NICKNAME
mdefine_line|#define ADN_NICKNAME&t;&t;1
multiline_comment|/*&n; * The default slack allowed when checking for replayed credentials&n; * (in milliseconds).&n; */
DECL|macro|DES_REPLAY_SLACK
mdefine_line|#define DES_REPLAY_SLACK&t;2000
multiline_comment|/*&n; * Make sure we don&squot;t place more than one call to the key server at&n; * a time.&n; */
DECL|variable|in_keycall
r_static
r_int
id|in_keycall
op_assign
l_int|0
suffix:semicolon
DECL|macro|FAIL
mdefine_line|#define FAIL(err) &bslash;&n;&t;{ if (data) put_cred(data);&t;&t;&t;&bslash;&n;&t;  *authp = rpc_autherr_##err;&t;&t;&t;&bslash;&n;&t;  return;&t;&t;&t;&t;&t;&bslash;&n;&t;}
r_void
DECL|function|svcauth_des
id|svcauth_des
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
id|u32
op_star
id|statp
comma
id|u32
op_star
id|authp
)paren
(brace
r_struct
id|svc_buf
op_star
id|argp
op_assign
op_amp
id|rqstp-&gt;rq_argbuf
suffix:semicolon
r_struct
id|svc_buf
op_star
id|resp
op_assign
op_amp
id|rqstp-&gt;rq_resbuf
suffix:semicolon
r_struct
id|svc_cred
op_star
id|cred
op_assign
op_amp
id|rqstp-&gt;rq_cred
suffix:semicolon
r_struct
id|des_cred
op_star
id|data
op_assign
l_int|NULL
suffix:semicolon
id|u32
id|cryptkey
(braket
l_int|2
)braket
suffix:semicolon
id|u32
id|cryptbuf
(braket
l_int|4
)braket
suffix:semicolon
id|u32
op_star
id|p
op_assign
id|argp-&gt;buf
suffix:semicolon
r_int
id|len
op_assign
id|argp-&gt;len
comma
id|slen
comma
id|i
suffix:semicolon
op_star
id|authp
op_assign
id|rpc_auth_ok
suffix:semicolon
r_if
c_cond
(paren
(paren
id|argp-&gt;len
op_sub_assign
l_int|3
)paren
OL
l_int|0
)paren
(brace
op_star
id|statp
op_assign
id|rpc_garbage_args
suffix:semicolon
r_return
suffix:semicolon
)brace
id|p
op_increment
suffix:semicolon
multiline_comment|/* skip length field */
id|namekind
op_assign
id|ntohl
c_func
(paren
op_star
id|p
op_increment
)paren
suffix:semicolon
multiline_comment|/* fullname/nickname */
multiline_comment|/* Get the credentials */
r_if
c_cond
(paren
id|namekind
op_eq
id|ADN_NICKNAME
)paren
(brace
multiline_comment|/* If we can&squot;t find the cached session key, initiate a&n;&t;&t; * new session. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|data
op_assign
id|get_cred_bynick
c_func
(paren
op_star
id|p
op_increment
)paren
)paren
)paren
id|FAIL
c_func
(paren
id|rejectedcred
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|namekind
op_eq
id|ADN_FULLNAME
)paren
(brace
id|p
op_assign
id|xdr_decode_string
c_func
(paren
id|p
comma
op_amp
id|fullname
comma
op_amp
id|len
comma
id|RPC_MAXNETNAMELEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
id|FAIL
c_func
(paren
id|badcred
)paren
suffix:semicolon
id|cryptkey
(braket
l_int|0
)braket
op_assign
op_star
id|p
op_increment
suffix:semicolon
multiline_comment|/* get the encrypted key */
id|cryptkey
(braket
l_int|1
)braket
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|cryptbuf
(braket
l_int|2
)braket
op_assign
op_star
id|p
op_increment
suffix:semicolon
multiline_comment|/* get the encrypted window */
)brace
r_else
(brace
id|FAIL
c_func
(paren
id|badcred
)paren
suffix:semicolon
)brace
multiline_comment|/* If we&squot;re just updating the key, silently discard the request. */
r_if
c_cond
(paren
id|data
op_logical_and
id|data-&gt;dc_locked
)paren
(brace
op_star
id|authp
op_assign
id|rpc_autherr_dropit
suffix:semicolon
id|_put_cred
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/* release but don&squot;t unlock */
r_return
suffix:semicolon
)brace
multiline_comment|/* Get the verifier flavor and length */
r_if
c_cond
(paren
id|ntohl
c_func
(paren
op_star
id|p
op_increment
)paren
op_ne
id|RPC_AUTH_DES
op_logical_and
id|ntohl
c_func
(paren
op_star
id|p
op_increment
)paren
op_ne
l_int|12
)paren
id|FAIL
c_func
(paren
id|badverf
)paren
suffix:semicolon
id|cryptbuf
(braket
l_int|0
)braket
op_assign
op_star
id|p
op_increment
suffix:semicolon
multiline_comment|/* encrypted time stamp */
id|cryptbuf
(braket
l_int|1
)braket
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|cryptbuf
(braket
l_int|3
)braket
op_assign
op_star
id|p
op_increment
suffix:semicolon
multiline_comment|/* 0 or window - 1 */
r_if
c_cond
(paren
id|namekind
op_eq
id|ADN_NICKNAME
)paren
(brace
id|status
op_assign
id|des_ecb_encrypt
c_func
(paren
(paren
id|des_block
op_star
)paren
id|cryptbuf
comma
(paren
id|des_block
op_star
)paren
id|cryptbuf
comma
id|data-&gt;dc_keysched
comma
id|DES_DECRYPT
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We first have to decrypt the new session key and&n;&t;&t; * fill in the UNIX creds. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|data
op_assign
id|get_cred_byname
c_func
(paren
id|rqstp
comma
id|authp
comma
id|fullname
comma
id|cryptkey
)paren
)paren
)paren
r_return
suffix:semicolon
id|status
op_assign
id|des_cbc_encrypt
c_func
(paren
(paren
id|des_cblock
op_star
)paren
id|cryptbuf
comma
(paren
id|des_cblock
op_star
)paren
id|cryptbuf
comma
l_int|16
comma
id|data-&gt;dc_keysched
comma
(paren
id|des_cblock
op_star
)paren
op_amp
id|ivec
comma
id|DES_DECRYPT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;svcauth_des: DES decryption failed (status %d)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|FAIL
c_func
(paren
id|badverf
)paren
suffix:semicolon
)brace
multiline_comment|/* Now check the whole lot */
r_if
c_cond
(paren
id|namekind
op_eq
id|ADN_FULLNAME
)paren
(brace
r_int
r_int
id|winverf
suffix:semicolon
id|data-&gt;dc_window
op_assign
id|ntohl
c_func
(paren
id|cryptbuf
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|winverf
op_assign
id|ntohl
c_func
(paren
id|cryptbuf
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|window
op_ne
id|winverf
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;svcauth_des: bad window verifier!&bslash;n&quot;
)paren
suffix:semicolon
id|FAIL
c_func
(paren
id|badverf
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* XDR the decrypted timestamp */
id|cryptbuf
(braket
l_int|0
)braket
op_assign
id|ntohl
c_func
(paren
id|cryptbuf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|cryptbuf
(braket
l_int|1
)braket
op_assign
id|ntohl
c_func
(paren
id|cryptbuf
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cryptbuf
(braket
l_int|1
)braket
OG
l_int|1000000
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;svcauth_des: bad usec value %u&bslash;n&quot;
comma
id|cryptbuf
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|namekind
op_eq
id|ADN_NICKNAME
)paren
id|FAIL
c_func
(paren
id|rejectedverf
)paren
suffix:semicolon
id|FAIL
c_func
(paren
id|badverf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for replayed credentials. We must allow for reordering&n;&t; * of requests by the network, and the OS scheduler, hence we&n;&t; * cannot expect timestamps to be increasing monotonically.&n;&t; * This opens a small security hole, therefore the replay_slack&n;&t; * value shouldn&squot;t be too large.&n;&t; */
r_if
c_cond
(paren
(paren
id|delta
op_assign
id|cryptbuf
(braket
l_int|0
)braket
op_minus
id|data-&gt;dc_timestamp
(braket
l_int|0
)braket
)paren
op_le
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|delta
)paren
(brace
r_case
op_minus
l_int|1
suffix:colon
id|delta
op_assign
op_minus
l_int|1000000
suffix:semicolon
r_case
l_int|0
suffix:colon
id|delta
op_add_assign
id|cryptbuf
(braket
l_int|1
)braket
op_minus
id|data-&gt;dc_timestamp
(braket
l_int|1
)braket
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|delta
op_assign
op_minus
l_int|1000000
suffix:semicolon
)brace
r_if
c_cond
(paren
id|delta
OL
id|DES_REPLAY_SLACK
)paren
id|FAIL
c_func
(paren
id|rejectedverf
)paren
suffix:semicolon
macro_line|#ifdef STRICT_REPLAY_CHECKS
multiline_comment|/* TODO: compare time stamp to last five timestamps cached&n;&t;&t; * and reject (drop?) request if a match is found. */
macro_line|#endif
)brace
id|now
op_assign
id|xtime
suffix:semicolon
id|now.tv_secs
op_sub_assign
id|data-&gt;dc_window
suffix:semicolon
r_if
c_cond
(paren
id|now.tv_secs
OL
id|cryptbuf
(braket
l_int|0
)braket
op_logical_or
(paren
id|now.tv_secs
op_eq
id|cryptbuf
(braket
l_int|0
)braket
op_logical_and
id|now.tv_usec
OL
id|cryptbuf
(braket
l_int|1
)braket
)paren
)paren
id|FAIL
c_func
(paren
id|rejectedverf
)paren
suffix:semicolon
multiline_comment|/* Okay, we&squot;re done. Update the lot */
r_if
c_cond
(paren
id|namekind
op_eq
id|ADN_FULLNAME
)paren
id|data-&gt;dc_valid
op_assign
l_int|1
suffix:semicolon
id|data-&gt;dc_timestamp
(braket
l_int|0
)braket
op_assign
id|cryptbuf
(braket
l_int|0
)braket
suffix:semicolon
id|data-&gt;dc_timestamp
(braket
l_int|1
)braket
op_assign
id|cryptbuf
(braket
l_int|1
)braket
suffix:semicolon
id|put_cred
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
suffix:semicolon
id|garbage
suffix:colon
op_star
id|statp
op_assign
id|rpc_garbage_args
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Call the keyserver to obtain the decrypted conversation key and&n; * UNIX creds. We use a Linux-specific keycall extension that does&n; * both things in one go.&n; */
r_static
r_struct
id|des_cred
op_star
DECL|function|get_cred_byname
id|get_cred_byname
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
id|u32
op_star
id|authp
comma
r_char
op_star
id|fullname
comma
id|u32
op_star
id|cryptkey
)paren
(brace
r_static
r_int
id|in_keycall
op_assign
l_int|0
suffix:semicolon
r_struct
id|des_cred
op_star
id|cred
suffix:semicolon
r_if
c_cond
(paren
id|in_keycall
)paren
(brace
op_star
id|authp
op_assign
id|rpc_autherr_dropit
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|in_keycall
op_assign
l_int|1
suffix:semicolon
id|in_keycall
op_assign
l_int|0
suffix:semicolon
r_return
id|cred
suffix:semicolon
)brace
eof
