multiline_comment|/*&n; *  linux/net/sunrpc/xprt.c&n; *&n; *  This is a generic RPC call interface supporting congestion avoidance,&n; *  and asynchronous calls.&n; *&n; *  The interface works like this:&n; *&n; *  -&t;When a process places a call, it allocates a request slot if&n; *&t;one is available. Otherwise, it sleeps on the backlog queue&n; *&t;(xprt_reserve).&n; *  -&t;Next, the caller puts together the RPC message, stuffs it into&n; *&t;the request struct, and calls xprt_call().&n; *  -&t;xprt_call transmits the message and installs the caller on the&n; *&t;socket&squot;s wait list. At the same time, it installs a timer that&n; *&t;is run after the packet&squot;s timeout has expired.&n; *  -&t;When a packet arrives, the data_ready handler walks the list of&n; *&t;pending requests for that socket. If a matching XID is found, the&n; *&t;caller is woken up, and the timer removed.&n; *  -&t;When no reply arrives within the timeout interval, the timer is&n; *&t;fired by the kernel and runs xprt_timer(). It either adjusts the&n; *&t;timeout values (minor timeout) or wakes up the caller with a status&n; *&t;of -ETIMEDOUT.&n; *  -&t;When the caller receives a notification from RPC that a reply arrived,&n; *&t;it should release the RPC slot, and process the reply.&n; *&t;If the call timed out, it may choose to retry the operation by&n; *&t;adjusting the initial timeout value, and simply calling rpc_call&n; *&t;again.&n; *&n; *  Support for async RPC is done through a set of RPC-specific scheduling&n; *  primitives that `transparently&squot; work for processes as well as async&n; *  tasks that rely on callbacks.&n; *&n; *  Copyright (C) 1995-1997, Olaf Kirch &lt;okir@monad.swb.de&gt;&n; *&n; *  TCP callback races fixes (C) 1998 Red Hat Software &lt;alan@redhat.com&gt;&n; *  TCP send fixes (C) 1998 Red Hat Software &lt;alan@redhat.com&gt;&n; *  TCP NFS related read + write fixes&n; *   (C) 1999 Dave Airlie, University of Limerick, Ireland &lt;airlied@linux.ie&gt;&n; *&n; *  Rewrite of larges part of the code in order to stabilize TCP stuff.&n; *  Fix behaviour when socket buffer is full.&n; *   (C) 1999 Trond Myklebust &lt;trond.myklebust@fys.uio.no&gt;&n; */
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/capability.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/udp.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/sunrpc/clnt.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;net/udp.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/* Following value should be &gt; 32k + RPC overhead */
DECL|macro|XPRT_MIN_WRITE_SPACE
mdefine_line|#define XPRT_MIN_WRITE_SPACE (35000 + SOCK_MIN_WRITE_SPACE)
r_extern
id|spinlock_t
id|rpc_queue_lock
suffix:semicolon
multiline_comment|/*&n; * Local variables&n; */
multiline_comment|/* Spinlock for critical sections in the code. */
DECL|variable|xprt_sock_lock
id|spinlock_t
id|xprt_sock_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|xprt_lock
id|spinlock_t
id|xprt_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
macro_line|#ifdef RPC_DEBUG
DECL|macro|RPC_DEBUG_DATA
macro_line|# undef  RPC_DEBUG_DATA
DECL|macro|RPCDBG_FACILITY
macro_line|# define RPCDBG_FACILITY&t;RPCDBG_XPRT
macro_line|#endif
macro_line|#ifndef MAX
DECL|macro|MAX
macro_line|# define MAX(a, b)&t;((a) &gt; (b)? (a) : (b))
DECL|macro|MIN
macro_line|# define MIN(a, b)&t;((a) &lt; (b)? (a) : (b))
macro_line|#endif
multiline_comment|/*&n; * Local functions&n; */
r_static
r_void
id|xprt_request_init
c_func
(paren
r_struct
id|rpc_task
op_star
comma
r_struct
id|rpc_xprt
op_star
)paren
suffix:semicolon
r_static
r_void
id|do_xprt_transmit
c_func
(paren
r_struct
id|rpc_task
op_star
)paren
suffix:semicolon
r_static
r_void
id|xprt_reserve_status
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
suffix:semicolon
r_static
r_void
id|xprt_disconnect
c_func
(paren
r_struct
id|rpc_xprt
op_star
)paren
suffix:semicolon
r_static
r_void
id|xprt_reconn_status
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
suffix:semicolon
r_static
r_struct
id|socket
op_star
id|xprt_create_socket
c_func
(paren
r_int
comma
r_struct
id|rpc_timeout
op_star
)paren
suffix:semicolon
r_static
r_int
id|xprt_bind_socket
c_func
(paren
r_struct
id|rpc_xprt
op_star
comma
r_struct
id|socket
op_star
)paren
suffix:semicolon
r_static
r_void
id|xprt_remove_pending
c_func
(paren
r_struct
id|rpc_xprt
op_star
)paren
suffix:semicolon
macro_line|#ifdef RPC_DEBUG_DATA
multiline_comment|/*&n; * Print the buffer contents (first 128 bytes only--just enough for&n; * diropres return).&n; */
r_static
r_void
DECL|function|xprt_pktdump
id|xprt_pktdump
c_func
(paren
r_char
op_star
id|msg
comma
id|u32
op_star
id|packet
comma
r_int
r_int
id|count
)paren
(brace
id|u8
op_star
id|buf
op_assign
(paren
id|u8
op_star
)paren
id|packet
suffix:semicolon
r_int
id|j
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      %s&bslash;n&quot;
comma
id|msg
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|count
op_logical_and
id|j
OL
l_int|128
suffix:semicolon
id|j
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|j
op_amp
l_int|31
)paren
)paren
(brace
r_if
c_cond
(paren
id|j
)paren
id|dprintk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;0x%04x &quot;
comma
id|j
)paren
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;%02x%02x%02x%02x &quot;
comma
id|buf
(braket
id|j
)braket
comma
id|buf
(braket
id|j
op_plus
l_int|1
)braket
comma
id|buf
(braket
id|j
op_plus
l_int|2
)braket
comma
id|buf
(braket
id|j
op_plus
l_int|3
)braket
)paren
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#else
r_static
r_inline
r_void
DECL|function|xprt_pktdump
id|xprt_pktdump
c_func
(paren
r_char
op_star
id|msg
comma
id|u32
op_star
id|packet
comma
r_int
r_int
id|count
)paren
(brace
multiline_comment|/* NOP */
)brace
macro_line|#endif
multiline_comment|/*&n; * Look up RPC transport given an INET socket&n; */
r_static
r_inline
r_struct
id|rpc_xprt
op_star
DECL|function|xprt_from_sock
id|xprt_from_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
(paren
r_struct
id|rpc_xprt
op_star
)paren
id|sk-&gt;user_data
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Adjust the iovec to move on &squot;n&squot; bytes&n; */
r_extern
r_inline
r_void
DECL|function|xprt_move_iov
id|xprt_move_iov
c_func
(paren
r_struct
id|msghdr
op_star
id|msg
comma
r_struct
id|iovec
op_star
id|niv
comma
r_int
id|amount
)paren
(brace
r_struct
id|iovec
op_star
id|iv
op_assign
id|msg-&gt;msg_iov
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Eat any sent iovecs&n;&t; */
r_while
c_loop
(paren
id|iv-&gt;iov_len
op_le
id|amount
)paren
(brace
id|amount
op_sub_assign
id|iv-&gt;iov_len
suffix:semicolon
id|iv
op_increment
suffix:semicolon
id|msg-&gt;msg_iovlen
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;And chew down the partial one&n;&t; */
id|niv
(braket
l_int|0
)braket
dot
id|iov_len
op_assign
id|iv-&gt;iov_len
op_minus
id|amount
suffix:semicolon
id|niv
(braket
l_int|0
)braket
dot
id|iov_base
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|iv-&gt;iov_base
)paren
op_plus
id|amount
suffix:semicolon
id|iv
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; *&t;And copy any others&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|msg-&gt;msg_iovlen
suffix:semicolon
id|i
op_increment
)paren
(brace
id|niv
(braket
id|i
)braket
op_assign
op_star
id|iv
op_increment
suffix:semicolon
)brace
id|msg-&gt;msg_iov
op_assign
id|niv
suffix:semicolon
)brace
multiline_comment|/*&n; * Write data to socket.&n; */
r_static
r_inline
r_int
DECL|function|xprt_sendmsg
id|xprt_sendmsg
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_struct
id|rpc_rqst
op_star
id|req
)paren
(brace
r_struct
id|socket
op_star
id|sock
op_assign
id|xprt-&gt;sock
suffix:semicolon
r_struct
id|msghdr
id|msg
suffix:semicolon
id|mm_segment_t
id|oldfs
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|slen
op_assign
id|req-&gt;rq_slen
op_minus
id|req-&gt;rq_bytes_sent
suffix:semicolon
r_struct
id|iovec
id|niv
(braket
id|MAX_IOVEC
)braket
suffix:semicolon
r_if
c_cond
(paren
id|slen
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
id|xprt_pktdump
c_func
(paren
l_string|&quot;packet data:&quot;
comma
id|req-&gt;rq_svec-&gt;iov_base
comma
id|req-&gt;rq_svec-&gt;iov_len
)paren
suffix:semicolon
id|msg.msg_flags
op_assign
id|MSG_DONTWAIT
op_or
id|MSG_NOSIGNAL
suffix:semicolon
id|msg.msg_iov
op_assign
id|req-&gt;rq_svec
suffix:semicolon
id|msg.msg_iovlen
op_assign
id|req-&gt;rq_snr
suffix:semicolon
id|msg.msg_name
op_assign
(paren
r_struct
id|sockaddr
op_star
)paren
op_amp
id|xprt-&gt;addr
suffix:semicolon
id|msg.msg_namelen
op_assign
r_sizeof
(paren
id|xprt-&gt;addr
)paren
suffix:semicolon
id|msg.msg_control
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_controllen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Dont repeat bytes */
r_if
c_cond
(paren
id|req-&gt;rq_bytes_sent
)paren
id|xprt_move_iov
c_func
(paren
op_amp
id|msg
comma
id|niv
comma
id|req-&gt;rq_bytes_sent
)paren
suffix:semicolon
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
id|result
op_assign
id|sock_sendmsg
c_func
(paren
id|sock
comma
op_amp
id|msg
comma
id|slen
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      xprt_sendmsg(%d) = %d&bslash;n&quot;
comma
id|slen
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
r_return
id|result
suffix:semicolon
r_switch
c_cond
(paren
id|result
)paren
(brace
r_case
op_minus
id|ECONNREFUSED
suffix:colon
multiline_comment|/* When the server has died, an ICMP port unreachable message&n;&t;&t; * prompts ECONNREFUSED.&n;&t;&t; */
r_break
suffix:semicolon
r_case
op_minus
id|EAGAIN
suffix:colon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SOCK_NOSPACE
comma
op_amp
id|sock-&gt;flags
)paren
)paren
id|result
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ENOTCONN
suffix:colon
r_case
op_minus
id|EPIPE
suffix:colon
multiline_comment|/* connection broken */
r_if
c_cond
(paren
id|xprt-&gt;stream
)paren
id|result
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RPC: sendmsg returned error %d&bslash;n&quot;
comma
op_minus
id|result
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Read data from socket&n; */
r_static
r_int
DECL|function|xprt_recvmsg
id|xprt_recvmsg
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_struct
id|iovec
op_star
id|iov
comma
r_int
id|nr
comma
r_int
id|len
comma
r_int
id|shift
)paren
(brace
r_struct
id|socket
op_star
id|sock
op_assign
id|xprt-&gt;sock
suffix:semicolon
r_struct
id|msghdr
id|msg
suffix:semicolon
id|mm_segment_t
id|oldfs
suffix:semicolon
r_struct
id|iovec
id|niv
(braket
id|MAX_IOVEC
)braket
suffix:semicolon
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
id|msg.msg_flags
op_assign
id|MSG_DONTWAIT
op_or
id|MSG_NOSIGNAL
suffix:semicolon
id|msg.msg_iov
op_assign
id|iov
suffix:semicolon
id|msg.msg_iovlen
op_assign
id|nr
suffix:semicolon
id|msg.msg_name
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_namelen
op_assign
l_int|0
suffix:semicolon
id|msg.msg_control
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_controllen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Adjust the iovec if we&squot;ve already filled it */
r_if
c_cond
(paren
id|shift
)paren
id|xprt_move_iov
c_func
(paren
op_amp
id|msg
comma
id|niv
comma
id|shift
)paren
suffix:semicolon
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
id|result
op_assign
id|sock_recvmsg
c_func
(paren
id|sock
comma
op_amp
id|msg
comma
id|len
comma
id|MSG_DONTWAIT
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      xprt_recvmsg(iov %p, len %d) = %d&bslash;n&quot;
comma
id|iov
comma
id|len
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Adjust RPC congestion window&n; * We use a time-smoothed congestion estimator to avoid heavy oscillation.&n; */
r_static
r_void
DECL|function|xprt_adjust_cwnd
id|xprt_adjust_cwnd
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_int
id|result
)paren
(brace
r_int
r_int
id|cwnd
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;nocong
)paren
r_return
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt_sock_lock
)paren
suffix:semicolon
id|cwnd
op_assign
id|xprt-&gt;cwnd
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|xprt-&gt;cong
OL
id|cwnd
op_logical_or
id|time_before
c_func
(paren
id|jiffies
comma
id|xprt-&gt;congtime
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* The (cwnd &gt;&gt; 1) term makes sure&n;&t;&t; * the result gets rounded properly. */
id|cwnd
op_add_assign
(paren
id|RPC_CWNDSCALE
op_star
id|RPC_CWNDSCALE
op_plus
(paren
id|cwnd
op_rshift
l_int|1
)paren
)paren
op_div
id|cwnd
suffix:semicolon
r_if
c_cond
(paren
id|cwnd
OG
id|RPC_MAXCWND
)paren
id|cwnd
op_assign
id|RPC_MAXCWND
suffix:semicolon
r_else
id|pprintk
c_func
(paren
l_string|&quot;RPC: %lu %ld cwnd&bslash;n&quot;
comma
id|jiffies
comma
id|cwnd
)paren
suffix:semicolon
id|xprt-&gt;congtime
op_assign
id|jiffies
op_plus
(paren
(paren
id|cwnd
op_star
id|HZ
)paren
op_lshift
l_int|2
)paren
op_div
id|RPC_CWNDSCALE
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      cong %08lx, cwnd was %08lx, now %08lx, &quot;
l_string|&quot;time %ld ms&bslash;n&quot;
comma
id|xprt-&gt;cong
comma
id|xprt-&gt;cwnd
comma
id|cwnd
comma
(paren
id|xprt-&gt;congtime
op_minus
id|jiffies
)paren
op_star
l_int|1000
op_div
id|HZ
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
r_if
c_cond
(paren
(paren
id|cwnd
op_rshift_assign
l_int|1
)paren
OL
id|RPC_CWNDSCALE
)paren
id|cwnd
op_assign
id|RPC_CWNDSCALE
suffix:semicolon
id|xprt-&gt;congtime
op_assign
id|jiffies
op_plus
(paren
(paren
id|cwnd
op_star
id|HZ
)paren
op_lshift
l_int|3
)paren
op_div
id|RPC_CWNDSCALE
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      cong %ld, cwnd was %ld, now %ld, &quot;
l_string|&quot;time %ld ms&bslash;n&quot;
comma
id|xprt-&gt;cong
comma
id|xprt-&gt;cwnd
comma
id|cwnd
comma
(paren
id|xprt-&gt;congtime
op_minus
id|jiffies
)paren
op_star
l_int|1000
op_div
id|HZ
)paren
suffix:semicolon
id|pprintk
c_func
(paren
l_string|&quot;RPC: %lu %ld cwnd&bslash;n&quot;
comma
id|jiffies
comma
id|cwnd
)paren
suffix:semicolon
)brace
id|xprt-&gt;cwnd
op_assign
id|cwnd
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt_sock_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Adjust timeout values etc for next retransmit&n; */
r_int
DECL|function|xprt_adjust_timeout
id|xprt_adjust_timeout
c_func
(paren
r_struct
id|rpc_timeout
op_star
id|to
)paren
(brace
r_if
c_cond
(paren
id|to-&gt;to_retries
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|to-&gt;to_exponential
)paren
id|to-&gt;to_current
op_lshift_assign
l_int|1
suffix:semicolon
r_else
id|to-&gt;to_current
op_add_assign
id|to-&gt;to_increment
suffix:semicolon
r_if
c_cond
(paren
id|to-&gt;to_maxval
op_logical_and
id|to-&gt;to_current
op_ge
id|to-&gt;to_maxval
)paren
id|to-&gt;to_current
op_assign
id|to-&gt;to_maxval
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|to-&gt;to_exponential
)paren
id|to-&gt;to_initval
op_lshift_assign
l_int|1
suffix:semicolon
r_else
id|to-&gt;to_initval
op_add_assign
id|to-&gt;to_increment
suffix:semicolon
r_if
c_cond
(paren
id|to-&gt;to_maxval
op_logical_and
id|to-&gt;to_initval
op_ge
id|to-&gt;to_maxval
)paren
id|to-&gt;to_initval
op_assign
id|to-&gt;to_maxval
suffix:semicolon
id|to-&gt;to_current
op_assign
id|to-&gt;to_initval
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|to-&gt;to_current
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;xprt_adjust_timeout: to_current = 0!&bslash;n&quot;
)paren
suffix:semicolon
id|to-&gt;to_current
op_assign
l_int|5
op_star
id|HZ
suffix:semicolon
)brace
id|pprintk
c_func
(paren
l_string|&quot;RPC: %lu %s&bslash;n&quot;
comma
id|jiffies
comma
id|to-&gt;to_retries
ques
c_cond
l_string|&quot;retrans&quot;
suffix:colon
l_string|&quot;timeout&quot;
)paren
suffix:semicolon
r_return
id|to-&gt;to_retries
op_decrement
OG
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Close down a transport socket&n; */
r_static
r_void
DECL|function|xprt_close
id|xprt_close
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
r_struct
id|socket
op_star
id|sock
op_assign
id|xprt-&gt;sock
suffix:semicolon
r_struct
id|sock
op_star
id|sk
op_assign
id|xprt-&gt;inet
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk
)paren
r_return
suffix:semicolon
id|xprt-&gt;inet
op_assign
l_int|NULL
suffix:semicolon
id|xprt-&gt;sock
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;user_data
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;data_ready
op_assign
id|xprt-&gt;old_data_ready
suffix:semicolon
id|sk-&gt;state_change
op_assign
id|xprt-&gt;old_state_change
suffix:semicolon
id|sk-&gt;write_space
op_assign
id|xprt-&gt;old_write_space
suffix:semicolon
id|xprt_disconnect
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|sk-&gt;no_check
op_assign
l_int|0
suffix:semicolon
id|sock_release
c_func
(paren
id|sock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;TCP doesnt require the rpciod now - other things may&n;&t; *&t;but rpciod handles that not us.&n;&t; */
r_if
c_cond
(paren
id|xprt-&gt;stream
)paren
(brace
id|rpciod_down
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Mark a transport as disconnected&n; */
r_static
r_void
DECL|function|xprt_disconnect
id|xprt_disconnect
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC:      disconnected transport %p&bslash;n&quot;
comma
id|xprt
)paren
suffix:semicolon
id|xprt_clear_connected
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|xprt_remove_pending
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|rpc_wake_up_status
c_func
(paren
op_amp
id|xprt-&gt;pending
comma
op_minus
id|ENOTCONN
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Reconnect a broken TCP connection.&n; */
r_void
DECL|function|xprt_reconnect
id|xprt_reconnect
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|task-&gt;tk_xprt
suffix:semicolon
r_struct
id|socket
op_star
id|sock
op_assign
id|xprt-&gt;sock
suffix:semicolon
r_struct
id|sock
op_star
id|inet
op_assign
id|xprt-&gt;inet
suffix:semicolon
r_int
id|status
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d xprt_reconnect %p connected %d&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|xprt
comma
id|xprt_connected
c_func
(paren
id|xprt
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;shutdown
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xprt-&gt;stream
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xprt-&gt;addr.sin_port
)paren
(brace
id|task-&gt;tk_status
op_assign
op_minus
id|EIO
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|xprt_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;connecting
)paren
(brace
id|task-&gt;tk_timeout
op_assign
l_int|0
suffix:semicolon
id|rpc_sleep_on
c_func
(paren
op_amp
id|xprt-&gt;reconn
comma
id|task
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|xprt_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|xprt-&gt;connecting
op_assign
l_int|1
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|xprt_lock
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inet
)paren
(brace
multiline_comment|/* Create an unconnected socket */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sock
op_assign
id|xprt_create_socket
c_func
(paren
id|xprt-&gt;prot
comma
op_amp
id|xprt-&gt;timeout
)paren
)paren
)paren
r_goto
id|defer
suffix:semicolon
id|xprt_bind_socket
c_func
(paren
id|xprt
comma
id|sock
)paren
suffix:semicolon
id|inet
op_assign
id|sock-&gt;sk
suffix:semicolon
)brace
id|xprt_disconnect
c_func
(paren
id|xprt
)paren
suffix:semicolon
multiline_comment|/* Reset TCP record info */
id|xprt-&gt;tcp_offset
op_assign
l_int|0
suffix:semicolon
id|xprt-&gt;tcp_copied
op_assign
l_int|0
suffix:semicolon
id|xprt-&gt;tcp_more
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Now connect it asynchronously. */
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d connecting new socket&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|status
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|connect
c_func
(paren
id|sock
comma
(paren
r_struct
id|sockaddr
op_star
)paren
op_amp
id|xprt-&gt;addr
comma
r_sizeof
(paren
id|xprt-&gt;addr
)paren
comma
id|O_NONBLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
op_minus
id|EALREADY
suffix:colon
r_case
op_minus
id|EINPROGRESS
suffix:colon
id|status
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EISCONN
suffix:colon
r_case
op_minus
id|EPIPE
suffix:colon
id|status
op_assign
l_int|0
suffix:semicolon
id|xprt_close
c_func
(paren
id|xprt
)paren
suffix:semicolon
r_goto
id|defer
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;RPC: TCP connect error %d!&bslash;n&quot;
comma
op_minus
id|status
)paren
suffix:semicolon
id|xprt_close
c_func
(paren
id|xprt
)paren
suffix:semicolon
r_goto
id|defer
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d connect status %d connected %d&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|status
comma
id|xprt_connected
c_func
(paren
id|xprt
)paren
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt_sock_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xprt_connected
c_func
(paren
id|xprt
)paren
)paren
(brace
id|task-&gt;tk_timeout
op_assign
id|xprt-&gt;timeout.to_maxval
suffix:semicolon
id|rpc_sleep_on
c_func
(paren
op_amp
id|xprt-&gt;reconn
comma
id|task
comma
id|xprt_reconn_status
comma
l_int|NULL
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt_sock_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt_sock_lock
)paren
suffix:semicolon
)brace
id|defer
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|xprt_lock
)paren
suffix:semicolon
id|xprt-&gt;connecting
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|rpc_delay
c_func
(paren
id|task
comma
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
id|task-&gt;tk_status
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
)brace
id|rpc_wake_up
c_func
(paren
op_amp
id|xprt-&gt;reconn
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|xprt_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Reconnect timeout. We just mark the transport as not being in the&n; * process of reconnecting, and leave the rest to the upper layers.&n; */
r_static
r_void
DECL|function|xprt_reconn_status
id|xprt_reconn_status
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|task-&gt;tk_xprt
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d xprt_reconn_timeout %d&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|task-&gt;tk_status
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|xprt_lock
)paren
suffix:semicolon
id|xprt-&gt;connecting
op_assign
l_int|0
suffix:semicolon
id|rpc_wake_up
c_func
(paren
op_amp
id|xprt-&gt;reconn
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|xprt_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up the RPC request corresponding to a reply, and then lock it.&n; */
r_static
r_inline
r_struct
id|rpc_rqst
op_star
DECL|function|xprt_lookup_rqst
id|xprt_lookup_rqst
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
id|u32
id|xid
)paren
(brace
r_struct
id|rpc_task
op_star
id|head
comma
op_star
id|task
suffix:semicolon
r_struct
id|rpc_rqst
op_star
id|req
suffix:semicolon
r_int
id|safe
op_assign
l_int|0
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|head
op_assign
id|xprt-&gt;pending.task
)paren
op_ne
l_int|NULL
)paren
(brace
id|task
op_assign
id|head
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|req
op_assign
id|task-&gt;tk_rqstp
)paren
op_logical_and
id|req-&gt;rq_xid
op_eq
id|xid
)paren
r_goto
id|out
suffix:semicolon
id|task
op_assign
id|task-&gt;tk_next
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|safe
OG
l_int|100
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;xprt_lookup_rqst: loop in Q!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_bad
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|task
op_ne
id|head
)paren
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC:      unknown XID %08x in reply.&bslash;n&quot;
comma
id|xid
)paren
suffix:semicolon
id|out_bad
suffix:colon
id|req
op_assign
l_int|NULL
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|req
op_logical_and
op_logical_neg
id|__rpc_lock_task
c_func
(paren
id|req-&gt;rq_task
)paren
)paren
id|req
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
r_return
id|req
suffix:semicolon
)brace
multiline_comment|/*&n; * Complete reply received.&n; * The TCP code relies on us to remove the request from xprt-&gt;pending.&n; */
r_static
r_inline
r_void
DECL|function|xprt_complete_rqst
id|xprt_complete_rqst
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_struct
id|rpc_rqst
op_star
id|req
comma
r_int
id|copied
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
op_assign
id|req-&gt;rq_task
suffix:semicolon
multiline_comment|/* Adjust congestion window */
id|xprt_adjust_cwnd
c_func
(paren
id|xprt
comma
id|copied
)paren
suffix:semicolon
macro_line|#ifdef RPC_PROFILE
multiline_comment|/* Profile only reads for now */
r_if
c_cond
(paren
id|copied
OG
l_int|1024
)paren
(brace
r_static
r_int
r_int
id|nextstat
op_assign
l_int|0
suffix:semicolon
r_static
r_int
r_int
id|pkt_rtt
op_assign
l_int|0
comma
id|pkt_len
op_assign
l_int|0
comma
id|pkt_cnt
op_assign
l_int|0
suffix:semicolon
id|pkt_cnt
op_increment
suffix:semicolon
id|pkt_len
op_add_assign
id|req-&gt;rq_slen
op_plus
id|copied
suffix:semicolon
id|pkt_rtt
op_add_assign
id|jiffies
op_minus
id|req-&gt;rq_xtime
suffix:semicolon
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|nextstat
comma
id|jiffies
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC: %lu %ld cwnd&bslash;n&quot;
comma
id|jiffies
comma
id|xprt-&gt;cwnd
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RPC: %ld %ld %ld %ld stat&bslash;n&quot;
comma
id|jiffies
comma
id|pkt_cnt
comma
id|pkt_len
comma
id|pkt_rtt
)paren
suffix:semicolon
id|pkt_rtt
op_assign
id|pkt_len
op_assign
id|pkt_cnt
op_assign
l_int|0
suffix:semicolon
id|nextstat
op_assign
id|jiffies
op_plus
l_int|5
op_star
id|HZ
suffix:semicolon
)brace
)brace
macro_line|#endif
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d has input (%d bytes)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|copied
)paren
suffix:semicolon
id|task-&gt;tk_status
op_assign
id|copied
suffix:semicolon
id|req-&gt;rq_received
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* ... and wake up the process. */
id|rpc_wake_up_task
c_func
(paren
id|task
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * We have set things up such that we perform the checksum of the UDP&n; * packet in parallel with the copies into the RPC client iovec.  -DaveM&n; */
DECL|function|csum_partial_copy_to_page_cache
r_static
r_int
id|csum_partial_copy_to_page_cache
c_func
(paren
r_struct
id|iovec
op_star
id|iov
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|copied
)paren
(brace
id|__u8
op_star
id|pkt_data
op_assign
id|skb-&gt;h.raw
op_plus
r_sizeof
(paren
r_struct
id|udphdr
)paren
suffix:semicolon
id|__u8
op_star
id|cur_ptr
op_assign
id|iov-&gt;iov_base
suffix:semicolon
id|__kernel_size_t
id|cur_len
op_assign
id|iov-&gt;iov_len
suffix:semicolon
r_int
r_int
id|csum
op_assign
id|skb-&gt;csum
suffix:semicolon
r_int
id|need_csum
op_assign
(paren
id|skb-&gt;ip_summed
op_ne
id|CHECKSUM_UNNECESSARY
)paren
suffix:semicolon
r_int
id|slack
op_assign
id|skb-&gt;len
op_minus
id|copied
op_minus
r_sizeof
(paren
r_struct
id|udphdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_csum
)paren
id|csum
op_assign
id|csum_partial
c_func
(paren
id|skb-&gt;h.raw
comma
r_sizeof
(paren
r_struct
id|udphdr
)paren
comma
id|csum
)paren
suffix:semicolon
r_while
c_loop
(paren
id|copied
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|cur_len
)paren
(brace
r_int
id|to_move
op_assign
id|cur_len
suffix:semicolon
r_if
c_cond
(paren
id|to_move
OG
id|copied
)paren
id|to_move
op_assign
id|copied
suffix:semicolon
r_if
c_cond
(paren
id|need_csum
)paren
id|csum
op_assign
id|csum_partial_copy_nocheck
c_func
(paren
id|pkt_data
comma
id|cur_ptr
comma
id|to_move
comma
id|csum
)paren
suffix:semicolon
r_else
id|memcpy
c_func
(paren
id|cur_ptr
comma
id|pkt_data
comma
id|to_move
)paren
suffix:semicolon
id|pkt_data
op_add_assign
id|to_move
suffix:semicolon
id|copied
op_sub_assign
id|to_move
suffix:semicolon
id|cur_ptr
op_add_assign
id|to_move
suffix:semicolon
id|cur_len
op_sub_assign
id|to_move
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cur_len
op_le
l_int|0
)paren
(brace
id|iov
op_increment
suffix:semicolon
id|cur_len
op_assign
id|iov-&gt;iov_len
suffix:semicolon
id|cur_ptr
op_assign
id|iov-&gt;iov_base
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|need_csum
)paren
(brace
r_if
c_cond
(paren
id|slack
OG
l_int|0
)paren
id|csum
op_assign
id|csum_partial
c_func
(paren
id|pkt_data
comma
id|slack
comma
id|csum
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|csum_fold
c_func
(paren
id|csum
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Input handler for RPC replies. Called from a bottom half and hence&n; * atomic.&n; */
r_static
r_void
DECL|function|udp_data_ready
id|udp_data_ready
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
suffix:semicolon
r_struct
id|rpc_xprt
op_star
id|xprt
suffix:semicolon
r_struct
id|rpc_rqst
op_star
id|rovr
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|err
comma
id|repsize
comma
id|copied
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      udp_data_ready...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|xprt
op_assign
id|xprt_from_sock
c_func
(paren
id|sk
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC:      udp_data_ready request not found!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC:      udp_data_ready client %p&bslash;n&quot;
comma
id|xprt
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|skb_recv_datagram
c_func
(paren
id|sk
comma
l_int|0
comma
l_int|1
comma
op_amp
id|err
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;shutdown
)paren
r_goto
id|dropit
suffix:semicolon
id|repsize
op_assign
id|skb-&gt;len
op_minus
r_sizeof
(paren
r_struct
id|udphdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|repsize
OL
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC: impossible RPC reply size %d!&bslash;n&quot;
comma
id|repsize
)paren
suffix:semicolon
r_goto
id|dropit
suffix:semicolon
)brace
multiline_comment|/* Look up and lock the request corresponding to the given XID */
id|rovr
op_assign
id|xprt_lookup_rqst
c_func
(paren
id|xprt
comma
op_star
(paren
id|u32
op_star
)paren
(paren
id|skb-&gt;h.raw
op_plus
r_sizeof
(paren
r_struct
id|udphdr
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rovr
)paren
r_goto
id|dropit
suffix:semicolon
id|task
op_assign
id|rovr-&gt;rq_task
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d received reply&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|xprt_pktdump
c_func
(paren
l_string|&quot;packet data:&quot;
comma
(paren
id|u32
op_star
)paren
(paren
id|skb-&gt;h.raw
op_plus
r_sizeof
(paren
r_struct
id|udphdr
)paren
)paren
comma
id|repsize
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|copied
op_assign
id|rovr-&gt;rq_rlen
)paren
OG
id|repsize
)paren
id|copied
op_assign
id|repsize
suffix:semicolon
multiline_comment|/* Suck it into the iovec, verify checksum if not done by hw. */
r_if
c_cond
(paren
id|csum_partial_copy_to_page_cache
c_func
(paren
id|rovr-&gt;rq_rvec
comma
id|skb
comma
id|copied
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/* Something worked... */
id|dst_confirm
c_func
(paren
id|skb-&gt;dst
)paren
suffix:semicolon
id|xprt_complete_rqst
c_func
(paren
id|xprt
comma
id|rovr
comma
id|copied
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|rpc_unlock_task
c_func
(paren
id|task
)paren
suffix:semicolon
id|dropit
suffix:colon
id|skb_free_datagram
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;sleep
op_logical_and
id|waitqueue_active
c_func
(paren
id|sk-&gt;sleep
)paren
)paren
id|wake_up_interruptible
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * TCP read fragment marker&n; */
r_static
r_inline
r_int
DECL|function|tcp_read_fraghdr
id|tcp_read_fraghdr
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
r_struct
id|iovec
id|riov
suffix:semicolon
r_int
id|want
comma
id|result
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;tcp_offset
op_ge
id|xprt-&gt;tcp_reclen
op_plus
r_sizeof
(paren
id|xprt-&gt;tcp_recm
)paren
)paren
(brace
id|xprt-&gt;tcp_offset
op_assign
l_int|0
suffix:semicolon
id|xprt-&gt;tcp_reclen
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xprt-&gt;tcp_offset
op_ge
r_sizeof
(paren
id|xprt-&gt;tcp_recm
)paren
)paren
r_goto
id|done
suffix:semicolon
id|want
op_assign
r_sizeof
(paren
id|xprt-&gt;tcp_recm
)paren
op_minus
id|xprt-&gt;tcp_offset
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      reading header (%d bytes)&bslash;n&quot;
comma
id|want
)paren
suffix:semicolon
r_do
(brace
id|riov.iov_base
op_assign
(paren
(paren
id|u8
op_star
)paren
op_amp
id|xprt-&gt;tcp_recm
)paren
op_plus
id|xprt-&gt;tcp_offset
suffix:semicolon
id|riov.iov_len
op_assign
id|want
suffix:semicolon
id|result
op_assign
id|xprt_recvmsg
c_func
(paren
id|xprt
comma
op_amp
id|riov
comma
l_int|1
comma
id|want
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
id|xprt-&gt;tcp_offset
op_add_assign
id|result
suffix:semicolon
id|want
op_sub_assign
id|result
suffix:semicolon
)brace
r_while
c_loop
(paren
id|want
)paren
suffix:semicolon
multiline_comment|/* Is this another fragment in the last message */
r_if
c_cond
(paren
op_logical_neg
id|xprt-&gt;tcp_more
)paren
id|xprt-&gt;tcp_copied
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No, so we&squot;re reading a new message */
multiline_comment|/* Get the record length and mask out the last fragment bit */
id|xprt-&gt;tcp_reclen
op_assign
id|ntohl
c_func
(paren
id|xprt-&gt;tcp_recm
)paren
suffix:semicolon
id|xprt-&gt;tcp_more
op_assign
(paren
id|xprt-&gt;tcp_reclen
op_amp
l_int|0x80000000
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|xprt-&gt;tcp_reclen
op_and_assign
l_int|0x7fffffff
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      New record reclen %d morefrags %d&bslash;n&quot;
comma
id|xprt-&gt;tcp_reclen
comma
id|xprt-&gt;tcp_more
)paren
suffix:semicolon
id|done
suffix:colon
r_return
id|xprt-&gt;tcp_reclen
op_plus
r_sizeof
(paren
id|xprt-&gt;tcp_recm
)paren
op_minus
id|xprt-&gt;tcp_offset
suffix:semicolon
)brace
multiline_comment|/*&n; * TCP read xid&n; */
r_static
r_inline
r_int
DECL|function|tcp_read_xid
id|tcp_read_xid
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_int
id|avail
)paren
(brace
r_struct
id|iovec
id|riov
suffix:semicolon
r_int
id|want
comma
id|result
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;tcp_copied
op_ge
r_sizeof
(paren
id|xprt-&gt;tcp_xid
)paren
op_logical_or
op_logical_neg
id|avail
)paren
r_goto
id|done
suffix:semicolon
id|want
op_assign
id|MIN
c_func
(paren
r_sizeof
(paren
id|xprt-&gt;tcp_xid
)paren
op_minus
id|xprt-&gt;tcp_copied
comma
id|avail
)paren
suffix:semicolon
r_do
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC:      reading xid (%d bytes)&bslash;n&quot;
comma
id|want
)paren
suffix:semicolon
id|riov.iov_base
op_assign
(paren
(paren
id|u8
op_star
)paren
op_amp
id|xprt-&gt;tcp_xid
)paren
op_plus
id|xprt-&gt;tcp_copied
suffix:semicolon
id|riov.iov_len
op_assign
id|want
suffix:semicolon
id|result
op_assign
id|xprt_recvmsg
c_func
(paren
id|xprt
comma
op_amp
id|riov
comma
l_int|1
comma
id|want
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
id|xprt-&gt;tcp_copied
op_add_assign
id|result
suffix:semicolon
id|xprt-&gt;tcp_offset
op_add_assign
id|result
suffix:semicolon
id|want
op_sub_assign
id|result
suffix:semicolon
id|avail
op_sub_assign
id|result
suffix:semicolon
)brace
r_while
c_loop
(paren
id|want
)paren
suffix:semicolon
id|done
suffix:colon
r_return
id|avail
suffix:semicolon
)brace
multiline_comment|/*&n; * TCP read and complete request&n; */
r_static
r_inline
r_int
DECL|function|tcp_read_request
id|tcp_read_request
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_struct
id|rpc_rqst
op_star
id|req
comma
r_int
id|avail
)paren
(brace
r_int
id|want
comma
id|result
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_rlen
op_le
id|xprt-&gt;tcp_copied
op_logical_or
op_logical_neg
id|avail
)paren
r_goto
id|done
suffix:semicolon
id|want
op_assign
id|MIN
c_func
(paren
id|req-&gt;rq_rlen
op_minus
id|xprt-&gt;tcp_copied
comma
id|avail
)paren
suffix:semicolon
r_do
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d TCP receiving %d bytes&bslash;n&quot;
comma
id|req-&gt;rq_task-&gt;tk_pid
comma
id|want
)paren
suffix:semicolon
id|result
op_assign
id|xprt_recvmsg
c_func
(paren
id|xprt
comma
id|req-&gt;rq_rvec
comma
id|req-&gt;rq_rnr
comma
id|want
comma
id|xprt-&gt;tcp_copied
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
id|xprt-&gt;tcp_copied
op_add_assign
id|result
suffix:semicolon
id|xprt-&gt;tcp_offset
op_add_assign
id|result
suffix:semicolon
id|avail
op_sub_assign
id|result
suffix:semicolon
id|want
op_sub_assign
id|result
suffix:semicolon
)brace
r_while
c_loop
(paren
id|want
)paren
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|req-&gt;rq_rlen
OG
id|xprt-&gt;tcp_copied
op_logical_and
id|xprt-&gt;tcp_more
)paren
r_return
id|avail
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d received reply complete&bslash;n&quot;
comma
id|req-&gt;rq_task-&gt;tk_pid
)paren
suffix:semicolon
id|xprt_complete_rqst
c_func
(paren
id|xprt
comma
id|req
comma
id|xprt-&gt;tcp_copied
)paren
suffix:semicolon
r_return
id|avail
suffix:semicolon
)brace
multiline_comment|/*&n; * TCP discard extra bytes from a short read&n; */
r_static
r_inline
r_int
DECL|function|tcp_read_discard
id|tcp_read_discard
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_int
id|avail
)paren
(brace
r_struct
id|iovec
id|riov
suffix:semicolon
r_static
id|u8
id|dummy
(braket
l_int|64
)braket
suffix:semicolon
r_int
id|want
comma
id|result
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|avail
)paren
(brace
id|want
op_assign
id|MIN
c_func
(paren
id|avail
comma
r_sizeof
(paren
id|dummy
)paren
)paren
suffix:semicolon
id|riov.iov_base
op_assign
id|dummy
suffix:semicolon
id|riov.iov_len
op_assign
id|want
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      TCP skipping %d bytes&bslash;n&quot;
comma
id|want
)paren
suffix:semicolon
id|result
op_assign
id|xprt_recvmsg
c_func
(paren
id|xprt
comma
op_amp
id|riov
comma
l_int|1
comma
id|want
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
id|xprt-&gt;tcp_offset
op_add_assign
id|result
suffix:semicolon
id|avail
op_sub_assign
id|result
suffix:semicolon
)brace
r_return
id|avail
suffix:semicolon
)brace
multiline_comment|/*&n; * TCP record receive routine&n; * This is not the most efficient code since we call recvfrom thrice--&n; * first receiving the record marker, then the XID, then the data.&n; * &n; * The optimal solution would be a RPC support in the TCP layer, which&n; * would gather all data up to the next record marker and then pass us&n; * the list of all TCP segments ready to be copied.&n; */
r_static
r_int
DECL|function|tcp_input_record
id|tcp_input_record
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
r_struct
id|rpc_rqst
op_star
id|req
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|rpc_task
op_star
id|task
op_assign
l_int|NULL
suffix:semicolon
r_int
id|avail
comma
id|result
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      tcp_input_record&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;shutdown
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xprt_connected
c_func
(paren
id|xprt
)paren
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
multiline_comment|/* Read in a new fragment marker if necessary */
multiline_comment|/* Can we ever really expect to get completely empty fragments? */
r_if
c_cond
(paren
(paren
id|result
op_assign
id|tcp_read_fraghdr
c_func
(paren
id|xprt
)paren
)paren
op_le
l_int|0
)paren
r_return
id|result
suffix:semicolon
id|avail
op_assign
id|result
suffix:semicolon
multiline_comment|/* Read in the xid if necessary */
r_if
c_cond
(paren
(paren
id|result
op_assign
id|tcp_read_xid
c_func
(paren
id|xprt
comma
id|avail
)paren
)paren
op_le
l_int|0
)paren
r_return
id|result
suffix:semicolon
id|avail
op_assign
id|result
suffix:semicolon
multiline_comment|/* Find and lock the request corresponding to this xid */
id|req
op_assign
id|xprt_lookup_rqst
c_func
(paren
id|xprt
comma
id|xprt-&gt;tcp_xid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
id|task
op_assign
id|req-&gt;rq_task
suffix:semicolon
multiline_comment|/* Read in the request data */
id|result
op_assign
id|tcp_read_request
c_func
(paren
id|xprt
comma
id|req
comma
id|avail
)paren
suffix:semicolon
id|rpc_unlock_task
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
id|avail
op_assign
id|result
suffix:semicolon
)brace
multiline_comment|/* Skip over any trailing bytes on short reads */
r_if
c_cond
(paren
(paren
id|result
op_assign
id|tcp_read_discard
c_func
(paren
id|xprt
comma
id|avail
)paren
)paren
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      tcp_input_record done (off %d reclen %d copied %d)&bslash;n&quot;
comma
id|xprt-&gt;tcp_offset
comma
id|xprt-&gt;tcp_reclen
comma
id|xprt-&gt;tcp_copied
)paren
suffix:semicolon
id|result
op_assign
id|xprt-&gt;tcp_reclen
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;TCP task queue stuff&n; */
DECL|variable|rpc_xprt_pending
id|LIST_HEAD
c_func
(paren
id|rpc_xprt_pending
)paren
suffix:semicolon
multiline_comment|/* List of xprts having pending tcp requests */
r_static
r_inline
DECL|function|tcp_rpciod_queue
r_void
id|tcp_rpciod_queue
c_func
(paren
r_void
)paren
(brace
id|rpciod_wake_up
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
DECL|function|xprt_append_pending
r_void
id|xprt_append_pending
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|xprt-&gt;rx_pending
)paren
)paren
r_return
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|xprt-&gt;rx_pending
)paren
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|xprt-&gt;rx_pending
comma
id|rpc_xprt_pending.prev
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:     xprt queue %p&bslash;n&quot;
comma
id|xprt
)paren
suffix:semicolon
id|tcp_rpciod_queue
c_func
(paren
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
)brace
r_static
DECL|function|xprt_remove_pending
r_void
id|xprt_remove_pending
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|xprt-&gt;rx_pending
)paren
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|xprt-&gt;rx_pending
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|xprt-&gt;rx_pending
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
)brace
r_static
r_inline
DECL|function|xprt_remove_pending_next
r_struct
id|rpc_xprt
op_star
id|xprt_remove_pending_next
c_func
(paren
r_void
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|rpc_xprt_pending
)paren
)paren
(brace
id|xprt
op_assign
id|list_entry
c_func
(paren
id|rpc_xprt_pending.next
comma
r_struct
id|rpc_xprt
comma
id|rx_pending
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|xprt-&gt;rx_pending
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|xprt-&gt;rx_pending
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|rpc_queue_lock
)paren
suffix:semicolon
r_return
id|xprt
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is protected from tcp_data_ready and the stack as its run&n; *&t;inside of the RPC I/O daemon&n; */
r_void
DECL|function|__rpciod_tcp_dispatcher
id|__rpciod_tcp_dispatcher
c_func
(paren
r_void
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
suffix:semicolon
r_int
id|safe_retry
op_assign
l_int|0
comma
id|result
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;rpciod_tcp_dispatcher: Queue Running&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Empty each pending socket&n;&t; */
r_while
c_loop
(paren
(paren
id|xprt
op_assign
id|xprt_remove_pending_next
c_func
(paren
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;rpciod_tcp_dispatcher: Processing %p&bslash;n&quot;
comma
id|xprt
)paren
suffix:semicolon
r_do
(brace
id|result
op_assign
id|tcp_input_record
c_func
(paren
id|xprt
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|result
op_ge
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|safe_retry
op_increment
OG
l_int|200
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|safe_retry
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; *&t;data_ready callback for TCP. We can&squot;t just jump into the&n; *&t;tcp recvmsg functions inside of the network receive bh or&n; * &t;bad things occur. We queue it to pick up after networking&n; *&t;is done.&n; */
DECL|function|tcp_data_ready
r_static
r_void
id|tcp_data_ready
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      tcp_data_ready...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|xprt
op_assign
id|xprt_from_sock
c_func
(paren
id|sk
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Not a socket with xprt %p&bslash;n&quot;
comma
id|sk
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xprt-&gt;shutdown
)paren
r_goto
id|out
suffix:semicolon
id|xprt_append_pending
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      tcp_data_ready client %p&bslash;n&quot;
comma
id|xprt
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      state %x conn %d dead %d zapped %d&bslash;n&quot;
comma
id|sk-&gt;state
comma
id|xprt_connected
c_func
(paren
id|xprt
)paren
comma
id|sk-&gt;dead
comma
id|sk-&gt;zapped
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;sleep
op_logical_and
id|waitqueue_active
c_func
(paren
id|sk-&gt;sleep
)paren
)paren
id|wake_up_interruptible
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|tcp_state_change
id|tcp_state_change
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|xprt
op_assign
id|xprt_from_sock
c_func
(paren
id|sk
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      tcp_state_change client %p...&bslash;n&quot;
comma
id|xprt
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      state %x conn %d dead %d zapped %d&bslash;n&quot;
comma
id|sk-&gt;state
comma
id|xprt_connected
c_func
(paren
id|xprt
)paren
comma
id|sk-&gt;dead
comma
id|sk-&gt;zapped
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sk-&gt;state
)paren
(brace
r_case
id|TCP_ESTABLISHED
suffix:colon
r_if
c_cond
(paren
id|xprt_test_and_set_connected
c_func
(paren
id|xprt
)paren
)paren
r_break
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt_sock_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;snd_task
op_logical_and
id|xprt-&gt;snd_task-&gt;tk_rpcwait
op_eq
op_amp
id|xprt-&gt;sending
)paren
id|rpc_wake_up_task
c_func
(paren
id|xprt-&gt;snd_task
)paren
suffix:semicolon
id|rpc_wake_up
c_func
(paren
op_amp
id|xprt-&gt;reconn
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt_sock_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_SYN_SENT
suffix:colon
r_case
id|TCP_SYN_RECV
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|xprt_disconnect
c_func
(paren
id|xprt
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out
suffix:colon
r_if
c_cond
(paren
id|sk-&gt;sleep
op_logical_and
id|waitqueue_active
c_func
(paren
id|sk-&gt;sleep
)paren
)paren
id|wake_up_interruptible_all
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The following 2 routines allow a task to sleep while socket memory is&n; * low.&n; */
r_static
r_void
DECL|function|tcp_write_space
id|tcp_write_space
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
suffix:semicolon
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|xprt
op_assign
id|xprt_from_sock
c_func
(paren
id|sk
)paren
)paren
op_logical_or
op_logical_neg
(paren
id|sock
op_assign
id|sk-&gt;socket
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;shutdown
)paren
r_return
suffix:semicolon
multiline_comment|/* Wait until we have enough socket memory */
r_if
c_cond
(paren
op_logical_neg
id|sock_writeable
c_func
(paren
id|sk
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xprt_test_and_set_wspace
c_func
(paren
id|xprt
)paren
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt_sock_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;snd_task
op_logical_and
id|xprt-&gt;snd_task-&gt;tk_rpcwait
op_eq
op_amp
id|xprt-&gt;sending
)paren
id|rpc_wake_up_task
c_func
(paren
id|xprt-&gt;snd_task
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt_sock_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SOCK_NOSPACE
comma
op_amp
id|sock-&gt;flags
)paren
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;sleep
op_logical_and
id|waitqueue_active
c_func
(paren
id|sk-&gt;sleep
)paren
)paren
(brace
id|clear_bit
c_func
(paren
id|SOCK_NOSPACE
comma
op_amp
id|sock-&gt;flags
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
DECL|function|udp_write_space
id|udp_write_space
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|xprt
op_assign
id|xprt_from_sock
c_func
(paren
id|sk
)paren
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;shutdown
)paren
r_return
suffix:semicolon
multiline_comment|/* Wait until we have enough socket memory */
r_if
c_cond
(paren
id|sock_wspace
c_func
(paren
id|sk
)paren
OL
id|min
c_func
(paren
id|sk-&gt;sndbuf
comma
id|XPRT_MIN_WRITE_SPACE
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xprt_test_and_set_wspace
c_func
(paren
id|xprt
)paren
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt_sock_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;snd_task
op_logical_and
id|xprt-&gt;snd_task-&gt;tk_rpcwait
op_eq
op_amp
id|xprt-&gt;sending
)paren
id|rpc_wake_up_task
c_func
(paren
id|xprt-&gt;snd_task
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt_sock_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sk-&gt;sleep
op_logical_and
id|waitqueue_active
c_func
(paren
id|sk-&gt;sleep
)paren
)paren
id|wake_up_interruptible
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * RPC receive timeout handler.&n; */
r_static
r_void
DECL|function|xprt_timer
id|xprt_timer
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_rqst
op_star
id|req
op_assign
id|task-&gt;tk_rqstp
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
id|xprt_adjust_cwnd
c_func
(paren
id|task-&gt;tk_xprt
comma
op_minus
id|ETIMEDOUT
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d xprt_timer (%s request)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|req
ques
c_cond
l_string|&quot;pending&quot;
suffix:colon
l_string|&quot;backlogged&quot;
)paren
suffix:semicolon
id|task-&gt;tk_status
op_assign
op_minus
id|ETIMEDOUT
suffix:semicolon
id|task-&gt;tk_timeout
op_assign
l_int|0
suffix:semicolon
id|rpc_wake_up_task
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Serialize access to sockets, in order to prevent different&n; * requests from interfering with each other.&n; */
r_static
r_int
DECL|function|xprt_down_transmit
id|xprt_down_transmit
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|task-&gt;tk_rqstp-&gt;rq_xprt
suffix:semicolon
r_struct
id|rpc_rqst
op_star
id|req
op_assign
id|task-&gt;tk_rqstp
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|xprt_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;snd_task
op_logical_and
id|xprt-&gt;snd_task
op_ne
id|task
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d TCP write queue full (task %d)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|xprt-&gt;snd_task-&gt;tk_pid
)paren
suffix:semicolon
id|task-&gt;tk_timeout
op_assign
l_int|0
suffix:semicolon
id|task-&gt;tk_status
op_assign
op_minus
id|EAGAIN
suffix:semicolon
id|rpc_sleep_on
c_func
(paren
op_amp
id|xprt-&gt;sending
comma
id|task
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|xprt-&gt;snd_task
)paren
(brace
id|xprt-&gt;snd_task
op_assign
id|task
suffix:semicolon
macro_line|#ifdef RPC_PROFILE
id|req-&gt;rq_xtime
op_assign
id|jiffies
suffix:semicolon
macro_line|#endif
id|req-&gt;rq_bytes_sent
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|xprt_lock
)paren
suffix:semicolon
r_return
id|xprt-&gt;snd_task
op_eq
id|task
suffix:semicolon
)brace
multiline_comment|/*&n; * Releases the socket for use by other requests.&n; */
r_static
r_inline
r_void
DECL|function|xprt_up_transmit
id|xprt_up_transmit
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|task-&gt;tk_rqstp-&gt;rq_xprt
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;snd_task
op_logical_and
id|xprt-&gt;snd_task
op_eq
id|task
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|xprt_lock
)paren
suffix:semicolon
id|xprt-&gt;snd_task
op_assign
l_int|NULL
suffix:semicolon
id|rpc_wake_up_next
c_func
(paren
op_amp
id|xprt-&gt;sending
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|xprt_lock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Place the actual RPC call.&n; * We have to copy the iovec because sendmsg fiddles with its contents.&n; */
r_void
DECL|function|xprt_transmit
id|xprt_transmit
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_rqst
op_star
id|req
op_assign
id|task-&gt;tk_rqstp
suffix:semicolon
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|req-&gt;rq_xprt
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d xprt_transmit(%x)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
op_star
(paren
id|u32
op_star
)paren
(paren
id|req-&gt;rq_svec
(braket
l_int|0
)braket
dot
id|iov_base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;shutdown
)paren
id|task-&gt;tk_status
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xprt_connected
c_func
(paren
id|xprt
)paren
)paren
id|task-&gt;tk_status
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_status
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_rpcwait
)paren
id|rpc_remove_wait_queue
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* set up everything as needed. */
multiline_comment|/* Write the record marker */
r_if
c_cond
(paren
id|xprt-&gt;stream
)paren
(brace
id|u32
op_star
id|marker
op_assign
id|req-&gt;rq_svec
(braket
l_int|0
)braket
dot
id|iov_base
suffix:semicolon
op_star
id|marker
op_assign
id|htonl
c_func
(paren
l_int|0x80000000
op_or
(paren
id|req-&gt;rq_slen
op_minus
r_sizeof
(paren
op_star
id|marker
)paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|xprt_down_transmit
c_func
(paren
id|task
)paren
)paren
r_return
suffix:semicolon
id|do_xprt_transmit
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|do_xprt_transmit
id|do_xprt_transmit
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_rqst
op_star
id|req
op_assign
id|task-&gt;tk_rqstp
suffix:semicolon
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|req-&gt;rq_xprt
suffix:semicolon
r_int
id|status
comma
id|retry
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* For fast networks/servers we have to put the request on&n;&t; * the pending list now:&n;&t; * Note that we don&squot;t want the task timing out during the&n;&t; * call to xprt_sendmsg(), so we initially disable the timeout,&n;&t; * and then reset it later...&n;&t; */
id|xprt_receive
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* Continue transmitting the packet/record. We must be careful&n;&t; * to cope with writespace callbacks arriving _after_ we have&n;&t; * called xprt_sendmsg().&n;&t; */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|xprt_clear_wspace
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|status
op_assign
id|xprt_sendmsg
c_func
(paren
id|xprt
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;stream
)paren
(brace
id|req-&gt;rq_bytes_sent
op_add_assign
id|status
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_bytes_sent
op_ge
id|req-&gt;rq_slen
)paren
r_goto
id|out_receive
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|status
op_ge
id|req-&gt;rq_slen
)paren
r_goto
id|out_receive
suffix:semicolon
id|status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d xmit incomplete (%d left of %d)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|req-&gt;rq_slen
op_minus
id|req-&gt;rq_bytes_sent
comma
id|req-&gt;rq_slen
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|retry
op_increment
OG
l_int|50
)paren
r_break
suffix:semicolon
)brace
id|rpc_unlock_task
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* Note: at this point, task-&gt;tk_sleeping has not yet been set,&n;&t; *&t; hence there is no danger of the waking up task being put on&n;&t; *&t; schedq, and being picked up by a parallel run of rpciod().&n;&t; */
id|rpc_wake_up_task
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|RPC_IS_RUNNING
c_func
(paren
id|task
)paren
)paren
r_goto
id|out_release
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_received
)paren
r_goto
id|out_release
suffix:semicolon
id|task-&gt;tk_status
op_assign
id|status
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
op_minus
id|ENOMEM
suffix:colon
multiline_comment|/* Protect against (udp|tcp)_write_space */
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt_sock_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xprt_wspace
c_func
(paren
id|xprt
)paren
)paren
(brace
id|task-&gt;tk_timeout
op_assign
id|req-&gt;rq_timeout.to_current
suffix:semicolon
id|rpc_sleep_on
c_func
(paren
op_amp
id|xprt-&gt;sending
comma
id|task
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt_sock_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
op_minus
id|EAGAIN
suffix:colon
multiline_comment|/* Keep holding the socket if it is blocked */
id|rpc_delay
c_func
(paren
id|task
comma
id|HZ
op_rshift
l_int|4
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
op_minus
id|ECONNREFUSED
suffix:colon
r_case
op_minus
id|ENOTCONN
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|xprt-&gt;stream
)paren
r_return
suffix:semicolon
r_default
suffix:colon
r_goto
id|out_release
suffix:semicolon
)brace
id|out_receive
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d xmit complete&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
multiline_comment|/* Set the task&squot;s receive timeout value */
id|task-&gt;tk_timeout
op_assign
id|req-&gt;rq_timeout.to_current
suffix:semicolon
id|rpc_add_timer
c_func
(paren
id|task
comma
id|xprt_timer
)paren
suffix:semicolon
id|rpc_unlock_task
c_func
(paren
id|task
)paren
suffix:semicolon
id|out_release
suffix:colon
id|xprt_up_transmit
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Queue the task for a reply to our call.&n; * When the callback is invoked, the congestion window should have&n; * been updated already.&n; */
r_void
DECL|function|xprt_receive
id|xprt_receive
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_rqst
op_star
id|req
op_assign
id|task-&gt;tk_rqstp
suffix:semicolon
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|req-&gt;rq_xprt
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d xprt_receive&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|req-&gt;rq_received
op_assign
l_int|0
suffix:semicolon
id|task-&gt;tk_timeout
op_assign
l_int|0
suffix:semicolon
id|rpc_sleep_locked
c_func
(paren
op_amp
id|xprt-&gt;pending
comma
id|task
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Reserve an RPC call slot.&n; */
r_int
DECL|function|xprt_reserve
id|xprt_reserve
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|task-&gt;tk_xprt
suffix:semicolon
multiline_comment|/* We already have an initialized request. */
r_if
c_cond
(paren
id|task-&gt;tk_rqstp
)paren
r_return
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d xprt_reserve cong = %ld cwnd = %ld&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|xprt-&gt;cong
comma
id|xprt-&gt;cwnd
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt_sock_lock
)paren
suffix:semicolon
id|xprt_reserve_status
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_rqstp
)paren
(brace
id|task-&gt;tk_timeout
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|task-&gt;tk_timeout
)paren
(brace
id|task-&gt;tk_status
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
)brace
r_else
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC:      xprt_reserve waiting on backlog&bslash;n&quot;
)paren
suffix:semicolon
id|task-&gt;tk_status
op_assign
op_minus
id|EAGAIN
suffix:semicolon
id|rpc_sleep_on
c_func
(paren
op_amp
id|xprt-&gt;backlog
comma
id|task
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt_sock_lock
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d xprt_reserve returns %d&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|task-&gt;tk_status
)paren
suffix:semicolon
r_return
id|task-&gt;tk_status
suffix:semicolon
)brace
multiline_comment|/*&n; * Reservation callback&n; */
r_static
r_void
DECL|function|xprt_reserve_status
id|xprt_reserve_status
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|task-&gt;tk_xprt
suffix:semicolon
r_struct
id|rpc_rqst
op_star
id|req
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;shutdown
)paren
(brace
id|task-&gt;tk_status
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|task-&gt;tk_status
OL
l_int|0
)paren
(brace
multiline_comment|/* NOP */
)brace
r_else
r_if
c_cond
(paren
id|task-&gt;tk_rqstp
)paren
(brace
multiline_comment|/* We&squot;ve already been given a request slot: NOP */
)brace
r_else
(brace
r_if
c_cond
(paren
id|RPCXPRT_CONGESTED
c_func
(paren
id|xprt
)paren
op_logical_or
op_logical_neg
(paren
id|req
op_assign
id|xprt-&gt;free
)paren
)paren
r_goto
id|out_nofree
suffix:semicolon
multiline_comment|/* OK: There&squot;s room for us. Grab a free slot and bump&n;&t;&t; * congestion value */
id|xprt-&gt;free
op_assign
id|req-&gt;rq_next
suffix:semicolon
id|req-&gt;rq_next
op_assign
l_int|NULL
suffix:semicolon
id|xprt-&gt;cong
op_add_assign
id|RPC_CWNDSCALE
suffix:semicolon
id|task-&gt;tk_rqstp
op_assign
id|req
suffix:semicolon
id|xprt_request_init
c_func
(paren
id|task
comma
id|xprt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;free
)paren
id|xprt_clear_backlog
c_func
(paren
id|xprt
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
id|out_nofree
suffix:colon
id|task-&gt;tk_status
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize RPC request&n; */
r_static
r_void
DECL|function|xprt_request_init
id|xprt_request_init
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
comma
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
r_struct
id|rpc_rqst
op_star
id|req
op_assign
id|task-&gt;tk_rqstp
suffix:semicolon
r_static
id|u32
id|xid
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xid
)paren
id|xid
op_assign
id|CURRENT_TIME
op_lshift
l_int|12
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d reserved req %p xid %08x&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|req
comma
id|xid
)paren
suffix:semicolon
id|task-&gt;tk_status
op_assign
l_int|0
suffix:semicolon
id|req-&gt;rq_timeout
op_assign
id|xprt-&gt;timeout
suffix:semicolon
id|req-&gt;rq_task
op_assign
id|task
suffix:semicolon
id|req-&gt;rq_xprt
op_assign
id|xprt
suffix:semicolon
id|req-&gt;rq_xid
op_assign
id|xid
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xid
)paren
id|xid
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Release an RPC call slot&n; */
r_void
DECL|function|xprt_release
id|xprt_release
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
op_assign
id|task-&gt;tk_xprt
suffix:semicolon
r_struct
id|rpc_rqst
op_star
id|req
suffix:semicolon
id|xprt_up_transmit
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|req
op_assign
id|task-&gt;tk_rqstp
)paren
)paren
r_return
suffix:semicolon
id|task-&gt;tk_rqstp
op_assign
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|req
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|req
)paren
)paren
suffix:semicolon
multiline_comment|/* mark unused */
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d release request %p&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|req
)paren
suffix:semicolon
multiline_comment|/* remove slot from queue of pending */
r_if
c_cond
(paren
id|task-&gt;tk_rpcwait
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC: task of released request still queued!&bslash;n&quot;
)paren
suffix:semicolon
id|rpc_remove_wait_queue
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
id|spin_lock_bh
c_func
(paren
op_amp
id|xprt_sock_lock
)paren
suffix:semicolon
id|req-&gt;rq_next
op_assign
id|xprt-&gt;free
suffix:semicolon
id|xprt-&gt;free
op_assign
id|req
suffix:semicolon
multiline_comment|/* Decrease congestion value. */
id|xprt-&gt;cong
op_sub_assign
id|RPC_CWNDSCALE
suffix:semicolon
id|xprt_clear_backlog
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|xprt_sock_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set default timeout parameters&n; */
r_void
DECL|function|xprt_default_timeout
id|xprt_default_timeout
c_func
(paren
r_struct
id|rpc_timeout
op_star
id|to
comma
r_int
id|proto
)paren
(brace
r_if
c_cond
(paren
id|proto
op_eq
id|IPPROTO_UDP
)paren
id|xprt_set_timeout
c_func
(paren
id|to
comma
l_int|5
comma
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
r_else
id|xprt_set_timeout
c_func
(paren
id|to
comma
l_int|5
comma
l_int|60
op_star
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set constant timeout&n; */
r_void
DECL|function|xprt_set_timeout
id|xprt_set_timeout
c_func
(paren
r_struct
id|rpc_timeout
op_star
id|to
comma
r_int
r_int
id|retr
comma
r_int
r_int
id|incr
)paren
(brace
id|to-&gt;to_current
op_assign
id|to-&gt;to_initval
op_assign
id|to-&gt;to_increment
op_assign
id|incr
suffix:semicolon
id|to-&gt;to_maxval
op_assign
id|incr
op_star
id|retr
suffix:semicolon
id|to-&gt;to_resrvval
op_assign
id|incr
op_star
id|retr
suffix:semicolon
id|to-&gt;to_retries
op_assign
id|retr
suffix:semicolon
id|to-&gt;to_exponential
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize an RPC client&n; */
r_static
r_struct
id|rpc_xprt
op_star
DECL|function|xprt_setup
id|xprt_setup
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|proto
comma
r_struct
id|sockaddr_in
op_star
id|ap
comma
r_struct
id|rpc_timeout
op_star
id|to
)paren
(brace
r_struct
id|rpc_xprt
op_star
id|xprt
suffix:semicolon
r_struct
id|rpc_rqst
op_star
id|req
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      setting up %s transport...&bslash;n&quot;
comma
id|proto
op_eq
id|IPPROTO_UDP
ques
c_cond
l_string|&quot;UDP&quot;
suffix:colon
l_string|&quot;TCP&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xprt
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|rpc_xprt
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|xprt
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|xprt
)paren
)paren
suffix:semicolon
multiline_comment|/* Nnnngh! */
id|xprt-&gt;addr
op_assign
op_star
id|ap
suffix:semicolon
id|xprt-&gt;prot
op_assign
id|proto
suffix:semicolon
id|xprt-&gt;stream
op_assign
(paren
id|proto
op_eq
id|IPPROTO_TCP
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;stream
)paren
(brace
id|xprt-&gt;cwnd
op_assign
id|RPC_MAXCWND
suffix:semicolon
id|xprt-&gt;nocong
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|xprt-&gt;cwnd
op_assign
id|RPC_INITCWND
suffix:semicolon
id|xprt-&gt;congtime
op_assign
id|jiffies
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|xprt-&gt;cong_wait
)paren
suffix:semicolon
multiline_comment|/* Set timeout parameters */
r_if
c_cond
(paren
id|to
)paren
(brace
id|xprt-&gt;timeout
op_assign
op_star
id|to
suffix:semicolon
id|xprt-&gt;timeout.to_current
op_assign
id|to-&gt;to_initval
suffix:semicolon
id|xprt-&gt;timeout.to_resrvval
op_assign
id|to-&gt;to_maxval
op_lshift
l_int|1
suffix:semicolon
)brace
r_else
id|xprt_default_timeout
c_func
(paren
op_amp
id|xprt-&gt;timeout
comma
id|xprt-&gt;prot
)paren
suffix:semicolon
id|xprt-&gt;pending
op_assign
id|RPC_INIT_WAITQ
c_func
(paren
l_string|&quot;xprt_pending&quot;
)paren
suffix:semicolon
id|xprt-&gt;sending
op_assign
id|RPC_INIT_WAITQ
c_func
(paren
l_string|&quot;xprt_sending&quot;
)paren
suffix:semicolon
id|xprt-&gt;backlog
op_assign
id|RPC_INIT_WAITQ
c_func
(paren
l_string|&quot;xprt_backlog&quot;
)paren
suffix:semicolon
id|xprt-&gt;reconn
op_assign
id|RPC_INIT_WAITQ
c_func
(paren
l_string|&quot;xprt_reconn&quot;
)paren
suffix:semicolon
multiline_comment|/* initialize free list */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|req
op_assign
id|xprt-&gt;slot
suffix:semicolon
id|i
OL
id|RPC_MAXREQS
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
id|req-&gt;rq_next
op_assign
id|req
op_plus
l_int|1
suffix:semicolon
id|req-&gt;rq_next
op_assign
l_int|NULL
suffix:semicolon
id|xprt-&gt;free
op_assign
id|xprt-&gt;slot
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|xprt-&gt;rx_pending
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      created transport %p&bslash;n&quot;
comma
id|xprt
)paren
suffix:semicolon
id|xprt_bind_socket
c_func
(paren
id|xprt
comma
id|sock
)paren
suffix:semicolon
r_return
id|xprt
suffix:semicolon
)brace
multiline_comment|/*&n; * Bind to a reserved port&n; */
r_static
r_inline
r_int
DECL|function|xprt_bindresvport
id|xprt_bindresvport
c_func
(paren
r_struct
id|socket
op_star
id|sock
)paren
(brace
r_struct
id|sockaddr_in
id|myaddr
suffix:semicolon
r_int
id|err
comma
id|port
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|myaddr
comma
l_int|0
comma
r_sizeof
(paren
id|myaddr
)paren
)paren
suffix:semicolon
id|myaddr.sin_family
op_assign
id|AF_INET
suffix:semicolon
id|port
op_assign
l_int|800
suffix:semicolon
r_do
(brace
id|myaddr.sin_port
op_assign
id|htons
c_func
(paren
id|port
)paren
suffix:semicolon
id|err
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|bind
c_func
(paren
id|sock
comma
(paren
r_struct
id|sockaddr
op_star
)paren
op_amp
id|myaddr
comma
r_sizeof
(paren
id|myaddr
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_eq
op_minus
id|EADDRINUSE
op_logical_and
op_decrement
id|port
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;RPC: Can&squot;t bind to reserved port (%d).&bslash;n&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_static
r_int
DECL|function|xprt_bind_socket
id|xprt_bind_socket
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
comma
r_struct
id|socket
op_star
id|sock
)paren
(brace
r_struct
id|sock
op_star
id|sk
op_assign
id|sock-&gt;sk
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;inet
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|sk-&gt;user_data
op_assign
id|xprt
suffix:semicolon
id|xprt-&gt;old_data_ready
op_assign
id|sk-&gt;data_ready
suffix:semicolon
id|xprt-&gt;old_state_change
op_assign
id|sk-&gt;state_change
suffix:semicolon
id|xprt-&gt;old_write_space
op_assign
id|sk-&gt;write_space
suffix:semicolon
r_if
c_cond
(paren
id|xprt-&gt;prot
op_eq
id|IPPROTO_UDP
)paren
(brace
id|sk-&gt;data_ready
op_assign
id|udp_data_ready
suffix:semicolon
id|sk-&gt;write_space
op_assign
id|udp_write_space
suffix:semicolon
id|sk-&gt;no_check
op_assign
id|UDP_CSUM_NORCV
suffix:semicolon
id|xprt_set_connected
c_func
(paren
id|xprt
)paren
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;data_ready
op_assign
id|tcp_data_ready
suffix:semicolon
id|sk-&gt;state_change
op_assign
id|tcp_state_change
suffix:semicolon
id|sk-&gt;write_space
op_assign
id|tcp_write_space
suffix:semicolon
id|xprt_clear_connected
c_func
(paren
id|xprt
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset to new socket */
id|xprt-&gt;sock
op_assign
id|sock
suffix:semicolon
id|xprt-&gt;inet
op_assign
id|sk
suffix:semicolon
multiline_comment|/*&n;&t; *&t;TCP requires the rpc I/O daemon is present&n;&t; */
r_if
c_cond
(paren
id|xprt-&gt;stream
)paren
(brace
id|rpciod_up
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a client socket given the protocol and peer address.&n; */
r_static
r_struct
id|socket
op_star
DECL|function|xprt_create_socket
id|xprt_create_socket
c_func
(paren
r_int
id|proto
comma
r_struct
id|rpc_timeout
op_star
id|to
)paren
(brace
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_int
id|type
comma
id|err
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      xprt_create_socket(%s %d)&bslash;n&quot;
comma
(paren
id|proto
op_eq
id|IPPROTO_UDP
)paren
ques
c_cond
l_string|&quot;udp&quot;
suffix:colon
l_string|&quot;tcp&quot;
comma
id|proto
)paren
suffix:semicolon
id|type
op_assign
(paren
id|proto
op_eq
id|IPPROTO_UDP
)paren
ques
c_cond
id|SOCK_DGRAM
suffix:colon
id|SOCK_STREAM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|sock_create
c_func
(paren
id|PF_INET
comma
id|type
comma
id|proto
comma
op_amp
id|sock
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC: can&squot;t create socket (%d).&bslash;n&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
multiline_comment|/* If the caller has the capability, bind to a reserved port */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_BIND_SERVICE
)paren
op_logical_and
id|xprt_bindresvport
c_func
(paren
id|sock
)paren
OL
l_int|0
)paren
r_goto
id|failed
suffix:semicolon
r_return
id|sock
suffix:semicolon
id|failed
suffix:colon
id|sock_release
c_func
(paren
id|sock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Create an RPC client transport given the protocol and peer address.&n; */
r_struct
id|rpc_xprt
op_star
DECL|function|xprt_create_proto
id|xprt_create_proto
c_func
(paren
r_int
id|proto
comma
r_struct
id|sockaddr_in
op_star
id|sap
comma
r_struct
id|rpc_timeout
op_star
id|to
)paren
(brace
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_struct
id|rpc_xprt
op_star
id|xprt
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      xprt_create_proto called&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sock
op_assign
id|xprt_create_socket
c_func
(paren
id|proto
comma
id|to
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|xprt
op_assign
id|xprt_setup
c_func
(paren
id|sock
comma
id|proto
comma
id|sap
comma
id|to
)paren
)paren
)paren
id|sock_release
c_func
(paren
id|sock
)paren
suffix:semicolon
r_return
id|xprt
suffix:semicolon
)brace
multiline_comment|/*&n; * Prepare for transport shutdown.&n; */
r_void
DECL|function|xprt_shutdown
id|xprt_shutdown
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
id|xprt-&gt;shutdown
op_assign
l_int|1
suffix:semicolon
id|rpc_wake_up
c_func
(paren
op_amp
id|xprt-&gt;sending
)paren
suffix:semicolon
id|rpc_wake_up
c_func
(paren
op_amp
id|xprt-&gt;pending
)paren
suffix:semicolon
id|rpc_wake_up
c_func
(paren
op_amp
id|xprt-&gt;backlog
)paren
suffix:semicolon
id|rpc_wake_up
c_func
(paren
op_amp
id|xprt-&gt;reconn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|xprt-&gt;cong_wait
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|xprt-&gt;cong_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Clear the xprt backlog queue&n; */
r_int
DECL|function|xprt_clear_backlog
id|xprt_clear_backlog
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
r_if
c_cond
(paren
id|RPCXPRT_CONGESTED
c_func
(paren
id|xprt
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|rpc_wake_up_next
c_func
(paren
op_amp
id|xprt-&gt;backlog
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|xprt-&gt;cong_wait
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|xprt-&gt;cong_wait
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Destroy an RPC transport, killing off all requests.&n; */
r_int
DECL|function|xprt_destroy
id|xprt_destroy
c_func
(paren
r_struct
id|rpc_xprt
op_star
id|xprt
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC:      destroying transport %p&bslash;n&quot;
comma
id|xprt
)paren
suffix:semicolon
id|xprt_shutdown
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|xprt_close
c_func
(paren
id|xprt
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|xprt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
