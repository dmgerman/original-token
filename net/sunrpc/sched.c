multiline_comment|/*&n; * linux/net/sunrpc/sched.c&n; *&n; * Scheduling for synchronous and asynchronous RPC requests.&n; *&n; * Copyright (C) 1996 Olaf Kirch, &lt;okir@monad.swb.de&gt;&n; */
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/module.h&gt;
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/sunrpc/clnt.h&gt;
macro_line|#ifdef RPC_DEBUG
DECL|macro|RPCDBG_FACILITY
mdefine_line|#define RPCDBG_FACILITY&t;&t;RPCDBG_SCHED
DECL|variable|rpc_task_id
r_static
r_int
id|rpc_task_id
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * We give RPC the same get_free_pages priority as NFS&n; */
DECL|macro|GFP_RPC
mdefine_line|#define GFP_RPC&t;&t;&t;GFP_NFS
r_static
r_void
id|__rpc_default_timer
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
suffix:semicolon
r_static
r_void
id|rpciod_killall
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * When an asynchronous RPC task is activated within a bottom half&n; * handler, or while executing another RPC task, it is put on&n; * schedq, and rpciod is woken up.&n; */
DECL|variable|schedq
r_static
r_struct
id|rpc_wait_queue
id|schedq
op_assign
id|RPC_INIT_WAITQ
c_func
(paren
l_string|&quot;schedq&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * RPC tasks that create another task (e.g. for contacting the portmapper)&n; * will wait on this queue for their child&squot;s completion&n; */
DECL|variable|childq
r_static
r_struct
id|rpc_wait_queue
id|childq
op_assign
id|RPC_INIT_WAITQ
c_func
(paren
l_string|&quot;childq&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * All RPC tasks are linked into this list&n; */
DECL|variable|all_tasks
r_static
r_struct
id|rpc_task
op_star
id|all_tasks
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * rpciod-related stuff&n; */
DECL|variable|rpciod_idle
r_static
r_struct
id|wait_queue
op_star
id|rpciod_idle
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|rpciod_killer
r_static
r_struct
id|wait_queue
op_star
id|rpciod_killer
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|rpciod_sema
r_static
r_struct
id|semaphore
id|rpciod_sema
op_assign
id|MUTEX
suffix:semicolon
DECL|variable|rpciod_users
r_static
r_int
r_int
id|rpciod_users
op_assign
l_int|0
suffix:semicolon
DECL|variable|rpciod_pid
r_static
id|pid_t
id|rpciod_pid
op_assign
l_int|0
suffix:semicolon
DECL|variable|rpc_inhibit
r_static
r_int
id|rpc_inhibit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * This is the last-ditch buffer for NFS swap requests&n; */
DECL|variable|swap_buffer
r_static
id|u32
id|swap_buffer
(braket
id|PAGE_SIZE
op_rshift
l_int|2
)braket
suffix:semicolon
DECL|variable|swap_buffer_used
r_static
r_int
id|swap_buffer_used
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Add new request to wait queue.&n; *&n; * Swapper tasks always get inserted at the head of the queue.&n; * This should avoid many nasty memory deadlocks and hopefully&n; * improve overall performance.&n; * Everyone else gets appended to the queue to ensure proper FIFO behavior.&n; */
r_void
DECL|function|rpc_add_wait_queue
id|rpc_add_wait_queue
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|queue
comma
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_if
c_cond
(paren
id|task-&gt;tk_rpcwait
)paren
(brace
r_if
c_cond
(paren
id|task-&gt;tk_rpcwait
op_ne
id|queue
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;RPC: doubly enqueued task!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|RPC_IS_SWAPPER
c_func
(paren
id|task
)paren
)paren
id|rpc_insert_list
c_func
(paren
op_amp
id|queue-&gt;task
comma
id|task
)paren
suffix:semicolon
r_else
id|rpc_append_list
c_func
(paren
op_amp
id|queue-&gt;task
comma
id|task
)paren
suffix:semicolon
id|task-&gt;tk_rpcwait
op_assign
id|queue
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d added to queue %p &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|queue
comma
id|rpc_qname
c_func
(paren
id|queue
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove request from queue&n; */
r_void
DECL|function|rpc_remove_wait_queue
id|rpc_remove_wait_queue
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_wait_queue
op_star
id|queue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|queue
op_assign
id|task-&gt;tk_rpcwait
)paren
)paren
r_return
suffix:semicolon
id|rpc_remove_list
c_func
(paren
op_amp
id|queue-&gt;task
comma
id|task
)paren
suffix:semicolon
id|task-&gt;tk_rpcwait
op_assign
l_int|NULL
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d removed from queue %p &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|queue
comma
id|rpc_qname
c_func
(paren
id|queue
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set up a timer for the current task.&n; */
r_inline
r_void
DECL|function|rpc_add_timer
id|rpc_add_timer
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
comma
id|rpc_action
id|timer
)paren
(brace
r_int
r_int
id|expires
op_assign
id|jiffies
op_plus
id|task-&gt;tk_timeout
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d setting alarm for %lu ms&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|task-&gt;tk_timeout
op_star
l_int|1000
op_div
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timer
)paren
id|timer
op_assign
id|__rpc_default_timer
suffix:semicolon
r_if
c_cond
(paren
id|expires
OL
id|jiffies
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC: bad timeout value %ld - setting to 10 sec!&bslash;n&quot;
comma
id|task-&gt;tk_timeout
)paren
suffix:semicolon
id|expires
op_assign
id|jiffies
op_plus
l_int|10
op_star
id|HZ
suffix:semicolon
)brace
id|task-&gt;tk_timer.expires
op_assign
id|expires
suffix:semicolon
id|task-&gt;tk_timer.data
op_assign
(paren
r_int
r_int
)paren
id|task
suffix:semicolon
id|task-&gt;tk_timer.function
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|timer
suffix:semicolon
id|task-&gt;tk_timer.prev
op_assign
l_int|NULL
suffix:semicolon
id|task-&gt;tk_timer.next
op_assign
l_int|NULL
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|task-&gt;tk_timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Delete any timer for the current task.&n; * Must be called with interrupts off.&n; */
r_inline
r_void
DECL|function|rpc_del_timer
id|rpc_del_timer
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_if
c_cond
(paren
id|task-&gt;tk_timeout
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d deleting timer&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|task-&gt;tk_timer
)paren
suffix:semicolon
id|task-&gt;tk_timeout
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Make an RPC task runnable.&n; */
r_static
r_inline
r_void
DECL|function|rpc_make_runnable
id|rpc_make_runnable
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_if
c_cond
(paren
id|task-&gt;tk_timeout
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC: task w/ running timer in rpc_make_runnable!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|RPC_IS_ASYNC
c_func
(paren
id|task
)paren
)paren
(brace
id|rpc_add_wait_queue
c_func
(paren
op_amp
id|schedq
comma
id|task
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|rpciod_idle
)paren
suffix:semicolon
)brace
r_else
(brace
id|wake_up
c_func
(paren
op_amp
id|task-&gt;tk_wait
)paren
suffix:semicolon
)brace
id|task-&gt;tk_flags
op_or_assign
id|RPC_TASK_RUNNING
suffix:semicolon
)brace
multiline_comment|/*&n; * Prepare for sleeping on a wait queue.&n; * By always appending tasks to the list we ensure FIFO behavior.&n; * NB: An RPC task will only receive interrupt-driven events as long&n; * as it&squot;s on a wait queue.&n; */
r_static
r_void
DECL|function|__rpc_sleep_on
id|__rpc_sleep_on
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|q
comma
r_struct
id|rpc_task
op_star
id|task
comma
id|rpc_action
id|action
comma
id|rpc_action
id|timer
)paren
(brace
r_int
r_int
id|oldflags
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d sleep_on(queue &bslash;&quot;%s&bslash;&quot; time %ld)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|rpc_qname
c_func
(paren
id|q
)paren
comma
id|jiffies
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Protect the execution below.&n;&t; */
id|save_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|rpc_add_wait_queue
c_func
(paren
id|q
comma
id|task
)paren
suffix:semicolon
id|task-&gt;tk_callback
op_assign
id|action
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_timeout
)paren
id|rpc_add_timer
c_func
(paren
id|task
comma
id|timer
)paren
suffix:semicolon
id|task-&gt;tk_flags
op_and_assign
op_complement
id|RPC_TASK_RUNNING
suffix:semicolon
id|restore_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_void
DECL|function|rpc_sleep_on
id|rpc_sleep_on
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|q
comma
r_struct
id|rpc_task
op_star
id|task
comma
id|rpc_action
id|action
comma
id|rpc_action
id|timer
)paren
(brace
id|__rpc_sleep_on
c_func
(paren
id|q
comma
id|task
comma
id|action
comma
id|timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wake up a single task -- must be invoked with bottom halves off.&n; *&n; * It would probably suffice to cli/sti the del_timer and remove_wait_queue&n; * operations individually.&n; */
r_static
r_void
DECL|function|__rpc_wake_up
id|__rpc_wake_up
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d __rpc_wake_up (now %ld inh %d)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|jiffies
comma
id|rpc_inhibit
)paren
suffix:semicolon
macro_line|#ifdef RPC_DEBUG
r_if
c_cond
(paren
id|task-&gt;tk_magic
op_ne
l_int|0xf00baa
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC: attempt to wake up non-existing task!&bslash;n&quot;
)paren
suffix:semicolon
id|rpc_debug
op_assign
op_complement
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|rpc_del_timer
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_rpcwait
op_ne
op_amp
id|schedq
)paren
id|rpc_remove_wait_queue
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|RPC_IS_RUNNING
c_func
(paren
id|task
)paren
)paren
(brace
id|rpc_make_runnable
c_func
(paren
id|task
)paren
suffix:semicolon
id|task-&gt;tk_flags
op_or_assign
id|RPC_TASK_CALLBACK
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC:      __rpc_wake_up done&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Default timeout handler if none specified by user&n; */
r_static
r_void
DECL|function|__rpc_default_timer
id|__rpc_default_timer
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %d timeout (default timer)&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|task-&gt;tk_status
op_assign
op_minus
id|ETIMEDOUT
suffix:semicolon
id|task-&gt;tk_timeout
op_assign
l_int|0
suffix:semicolon
id|__rpc_wake_up
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wake up the specified task&n; */
r_void
DECL|function|rpc_wake_up_task
id|rpc_wake_up_task
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_int
r_int
id|oldflags
suffix:semicolon
id|save_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|__rpc_wake_up
c_func
(paren
id|task
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wake up the next task on the wait queue.&n; */
r_struct
id|rpc_task
op_star
DECL|function|rpc_wake_up_next
id|rpc_wake_up_next
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|queue
)paren
(brace
r_int
r_int
id|oldflags
suffix:semicolon
r_struct
id|rpc_task
op_star
id|task
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      wake_up_next(%p &bslash;&quot;%s&bslash;&quot;)&bslash;n&quot;
comma
id|queue
comma
id|rpc_qname
c_func
(paren
id|queue
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|task
op_assign
id|queue-&gt;task
)paren
op_ne
l_int|0
)paren
id|__rpc_wake_up
c_func
(paren
id|task
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
r_return
id|task
suffix:semicolon
)brace
multiline_comment|/*&n; * Wake up all tasks on a queue&n; */
r_void
DECL|function|rpc_wake_up
id|rpc_wake_up
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|queue
)paren
(brace
r_int
r_int
id|oldflags
suffix:semicolon
id|save_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|queue-&gt;task
)paren
id|__rpc_wake_up
c_func
(paren
id|queue-&gt;task
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wake up all tasks on a queue, and set their status value.&n; */
r_void
DECL|function|rpc_wake_up_status
id|rpc_wake_up_status
c_func
(paren
r_struct
id|rpc_wait_queue
op_star
id|queue
comma
r_int
id|status
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
suffix:semicolon
r_int
r_int
id|oldflags
suffix:semicolon
id|save_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|task
op_assign
id|queue-&gt;task
)paren
op_ne
l_int|NULL
)paren
(brace
id|task-&gt;tk_status
op_assign
id|status
suffix:semicolon
id|__rpc_wake_up
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Run a task at a later time&n; */
r_static
r_void
id|__rpc_atrun
c_func
(paren
r_struct
id|rpc_task
op_star
)paren
suffix:semicolon
r_void
DECL|function|rpc_delay
id|rpc_delay
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
comma
r_int
r_int
id|delay
)paren
(brace
r_static
r_struct
id|rpc_wait_queue
id|delay_queue
suffix:semicolon
id|task-&gt;tk_timeout
op_assign
id|delay
suffix:semicolon
id|rpc_sleep_on
c_func
(paren
op_amp
id|delay_queue
comma
id|task
comma
l_int|NULL
comma
id|__rpc_atrun
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|__rpc_atrun
id|__rpc_atrun
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
id|task-&gt;tk_status
op_assign
l_int|0
suffix:semicolon
id|__rpc_wake_up
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the RPC `scheduler&squot; (or rather, the finite state machine).&n; */
r_static
r_int
DECL|function|__rpc_execute
id|__rpc_execute
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_int
r_int
id|oldflags
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d rpc_execute flgs %x&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|task-&gt;tk_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|RPC_IS_RUNNING
c_func
(paren
id|task
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC: rpc_execute called for sleeping task!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Execute any pending callback.&n;&t;&t; */
r_if
c_cond
(paren
id|task-&gt;tk_flags
op_amp
id|RPC_TASK_CALLBACK
)paren
(brace
id|task-&gt;tk_flags
op_and_assign
op_complement
id|RPC_TASK_CALLBACK
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_callback
)paren
(brace
id|task
op_member_access_from_pointer
id|tk_callback
c_func
(paren
id|task
)paren
suffix:semicolon
id|task-&gt;tk_callback
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * No handler for next step means exit.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|task-&gt;tk_action
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Perform the next FSM step.&n;&t;&t; * tk_action may be NULL when the task has been killed&n;&t;&t; * by someone else.&n;&t;&t; */
r_if
c_cond
(paren
id|RPC_IS_RUNNING
c_func
(paren
id|task
)paren
op_logical_and
id|task-&gt;tk_action
)paren
id|task
op_member_access_from_pointer
id|tk_action
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check whether task is sleeping.&n;&t;&t; * Note that if the task may go to sleep in tk_action,&n;&t;&t; * and the RPC reply arrives before we get here, it will&n;&t;&t; * have state RUNNING, but will still be on schedq.&n;&t;&t; */
id|save_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RPC_IS_RUNNING
c_func
(paren
id|task
)paren
)paren
(brace
r_if
c_cond
(paren
id|task-&gt;tk_rpcwait
op_eq
op_amp
id|schedq
)paren
id|rpc_remove_wait_queue
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
r_else
r_while
c_loop
(paren
op_logical_neg
id|RPC_IS_RUNNING
c_func
(paren
id|task
)paren
)paren
(brace
r_if
c_cond
(paren
id|RPC_IS_ASYNC
c_func
(paren
id|task
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* sync task: sleep here */
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d sync task going to sleep&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|task-&gt;tk_wait
)paren
suffix:semicolon
multiline_comment|/* When the task received a signal, remove from&n;&t;&t;&t; * any queues etc, and make runnable again. */
r_if
c_cond
(paren
id|signalled
c_func
(paren
)paren
)paren
id|__rpc_wake_up
c_func
(paren
id|task
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d sync task resuming&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * When a sync task receives a signal, it exits with&n;&t;&t; * -ERESTARTSYS. In order to catch any callbacks that&n;&t;&t; * clean up after sleeping on some queue, we don&squot;t&n;&t;&t; * break the loop here, but go around once more.&n;&t;&t; */
r_if
c_cond
(paren
l_int|0
op_logical_and
op_logical_neg
id|RPC_IS_ASYNC
c_func
(paren
id|task
)paren
op_logical_and
id|signalled
c_func
(paren
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d got signal&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|rpc_exit
c_func
(paren
id|task
comma
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
)brace
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d exit() = %d&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|task-&gt;tk_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_exit
)paren
(brace
id|status
op_assign
id|task-&gt;tk_status
suffix:semicolon
id|task
op_member_access_from_pointer
id|tk_exit
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * User-visible entry point to the scheduler.&n; * The recursion protection is for debugging. It should go away once&n; * the code has stabilized.&n; */
r_void
DECL|function|rpc_execute
id|rpc_execute
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_static
r_int
id|executing
op_assign
l_int|0
suffix:semicolon
r_int
id|incr
op_assign
id|RPC_IS_ASYNC
c_func
(paren
id|task
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|incr
op_logical_and
(paren
id|executing
op_logical_or
id|rpc_inhibit
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC: rpc_execute called recursively!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|executing
op_add_assign
id|incr
suffix:semicolon
id|__rpc_execute
c_func
(paren
id|task
)paren
suffix:semicolon
id|executing
op_sub_assign
id|incr
suffix:semicolon
)brace
multiline_comment|/*&n; * This is our own little scheduler for async RPC tasks.&n; */
r_static
r_void
DECL|function|__rpc_schedule
id|__rpc_schedule
c_func
(paren
r_void
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|oldflags
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      rpc_schedule enter&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|save_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|task
op_assign
id|schedq.task
)paren
)paren
r_break
suffix:semicolon
id|rpc_del_timer
c_func
(paren
id|task
)paren
suffix:semicolon
id|rpc_remove_wait_queue
c_func
(paren
id|task
)paren
suffix:semicolon
id|task-&gt;tk_flags
op_or_assign
id|RPC_TASK_RUNNING
suffix:semicolon
id|restore_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
id|__rpc_execute
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|count
op_ge
l_int|200
)paren
(brace
id|count
op_assign
l_int|0
suffix:semicolon
id|need_resched
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|need_resched
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      rpc_schedule leave&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate memory for RPC purpose.&n; *&n; * This is yet another tricky issue: For sync requests issued by&n; * a user process, we want to make kmalloc sleep if there isn&squot;t&n; * enough memory. Async requests should not sleep too excessively&n; * because that will block rpciod (but that&squot;s not dramatic when&n; * it&squot;s starved of memory anyway). Finally, swapout requests should&n; * never sleep at all, and should not trigger another swap_out&n; * request through kmalloc which would just increase memory contention.&n; *&n; * I hope the following gets it right, which gives async requests&n; * a slight advantage over sync requests (good for writeback, debatable&n; * for readahead):&n; *&n; *   sync user requests:&t;GFP_KERNEL&n; *   async requests:&t;&t;GFP_RPC&t;&t;(== GFP_NFS)&n; *   swap requests:&t;&t;GFP_ATOMIC&t;(or new GFP_SWAPPER)&n; */
r_void
op_star
DECL|function|rpc_allocate
id|rpc_allocate
c_func
(paren
r_int
r_int
id|flags
comma
r_int
r_int
id|size
)paren
(brace
id|u32
op_star
id|buffer
suffix:semicolon
r_int
id|gfp
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|RPC_TASK_SWAPPER
)paren
id|gfp
op_assign
id|GFP_ATOMIC
suffix:semicolon
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|RPC_TASK_ASYNC
)paren
id|gfp
op_assign
id|GFP_RPC
suffix:semicolon
r_else
id|gfp
op_assign
id|GFP_KERNEL
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|buffer
op_assign
(paren
id|u32
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|gfp
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC:      allocated buffer %p&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|RPC_TASK_SWAPPER
)paren
op_logical_and
op_logical_neg
id|swap_buffer_used
op_increment
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC:      used last-ditch swap buffer&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|swap_buffer
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|RPC_TASK_ASYNC
)paren
r_return
l_int|NULL
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
(paren
id|HZ
op_rshift
l_int|4
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|signalled
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_void
DECL|function|rpc_free
id|rpc_free
c_func
(paren
r_void
op_star
id|buffer
)paren
(brace
r_if
c_cond
(paren
id|buffer
op_ne
id|swap_buffer
)paren
(brace
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|swap_buffer_used
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Creation and deletion of RPC task structures&n; */
r_inline
r_void
DECL|function|rpc_init_task
id|rpc_init_task
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
comma
r_struct
id|rpc_clnt
op_star
id|clnt
comma
id|rpc_action
id|callback
comma
r_int
id|flags
)paren
(brace
id|memset
c_func
(paren
id|task
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|task
)paren
)paren
suffix:semicolon
id|task-&gt;tk_client
op_assign
id|clnt
suffix:semicolon
id|task-&gt;tk_flags
op_assign
id|RPC_TASK_RUNNING
op_or
id|flags
suffix:semicolon
id|task-&gt;tk_exit
op_assign
id|callback
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;uid
op_ne
id|current-&gt;fsuid
op_logical_or
id|current-&gt;gid
op_ne
id|current-&gt;fsgid
)paren
id|task-&gt;tk_flags
op_or_assign
id|RPC_TASK_SETUID
suffix:semicolon
multiline_comment|/* Initialize retry counters */
id|task-&gt;tk_garb_retry
op_assign
l_int|2
suffix:semicolon
id|task-&gt;tk_cred_retry
op_assign
l_int|2
suffix:semicolon
id|task-&gt;tk_suid_retry
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Add to global list of all tasks */
id|task-&gt;tk_next_task
op_assign
id|all_tasks
suffix:semicolon
id|task-&gt;tk_prev_task
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|all_tasks
)paren
id|all_tasks-&gt;tk_prev_task
op_assign
id|task
suffix:semicolon
id|all_tasks
op_assign
id|task
suffix:semicolon
r_if
c_cond
(paren
id|clnt
)paren
id|clnt-&gt;cl_users
op_increment
suffix:semicolon
macro_line|#ifdef RPC_DEBUG
id|task-&gt;tk_magic
op_assign
l_int|0xf00baa
suffix:semicolon
id|task-&gt;tk_pid
op_assign
id|rpc_task_id
op_increment
suffix:semicolon
macro_line|#endif
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d new task procpid %d&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|current-&gt;pid
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a new task for the specified client.  We have to&n; * clean up after an allocation failure, as the client may&n; * have specified &quot;oneshot&quot;.&n; */
r_struct
id|rpc_task
op_star
DECL|function|rpc_new_task
id|rpc_new_task
c_func
(paren
r_struct
id|rpc_clnt
op_star
id|clnt
comma
id|rpc_action
id|callback
comma
r_int
id|flags
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
suffix:semicolon
id|task
op_assign
(paren
r_struct
id|rpc_task
op_star
)paren
id|rpc_allocate
c_func
(paren
id|flags
comma
r_sizeof
(paren
op_star
id|task
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|task
)paren
r_goto
id|cleanup
suffix:semicolon
id|rpc_init_task
c_func
(paren
id|task
comma
id|clnt
comma
id|callback
comma
id|flags
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d allocated task&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|task-&gt;tk_flags
op_or_assign
id|RPC_TASK_DYNAMIC
suffix:semicolon
id|out
suffix:colon
r_return
id|task
suffix:semicolon
id|cleanup
suffix:colon
multiline_comment|/* Check whether to release the client */
r_if
c_cond
(paren
id|clnt
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rpc_new_task: failed, users=%d, oneshot=%d&bslash;n&quot;
comma
id|clnt-&gt;cl_users
comma
id|clnt-&gt;cl_oneshot
)paren
suffix:semicolon
id|clnt-&gt;cl_users
op_increment
suffix:semicolon
multiline_comment|/* pretend we were used ... */
id|rpc_release_client
c_func
(paren
id|clnt
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
r_void
DECL|function|rpc_release_task
id|rpc_release_task
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|rpc_task
op_star
id|next
comma
op_star
id|prev
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d release task&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
multiline_comment|/* Remove from global task list */
id|prev
op_assign
id|task-&gt;tk_prev_task
suffix:semicolon
id|next
op_assign
id|task-&gt;tk_next_task
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
id|next-&gt;tk_prev_task
op_assign
id|prev
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;tk_next_task
op_assign
id|next
suffix:semicolon
r_else
id|all_tasks
op_assign
id|next
suffix:semicolon
multiline_comment|/* Release resources */
r_if
c_cond
(paren
id|task-&gt;tk_rqstp
)paren
id|xprt_release
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_cred
)paren
id|rpcauth_releasecred
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_buffer
)paren
(brace
id|rpc_free
c_func
(paren
id|task-&gt;tk_buffer
)paren
suffix:semicolon
id|task-&gt;tk_buffer
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|task-&gt;tk_client
)paren
(brace
id|rpc_release_client
c_func
(paren
id|task-&gt;tk_client
)paren
suffix:semicolon
id|task-&gt;tk_client
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef RPC_DEBUG
id|task-&gt;tk_magic
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|task-&gt;tk_flags
op_amp
id|RPC_TASK_DYNAMIC
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: %4d freeing task&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|task-&gt;tk_flags
op_and_assign
op_complement
id|RPC_TASK_DYNAMIC
suffix:semicolon
id|rpc_free
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Handling of RPC child tasks&n; * We can&squot;t simply call wake_up(parent) here, because the&n; * parent task may already have gone away&n; */
r_static
r_inline
r_struct
id|rpc_task
op_star
DECL|function|rpc_find_parent
id|rpc_find_parent
c_func
(paren
r_struct
id|rpc_task
op_star
id|child
)paren
(brace
r_struct
id|rpc_task
op_star
id|temp
comma
op_star
id|parent
suffix:semicolon
id|parent
op_assign
(paren
r_struct
id|rpc_task
op_star
)paren
id|child-&gt;tk_calldata
suffix:semicolon
r_for
c_loop
(paren
id|temp
op_assign
id|childq.task
suffix:semicolon
id|temp
suffix:semicolon
id|temp
op_assign
id|temp-&gt;tk_next
)paren
(brace
r_if
c_cond
(paren
id|temp
op_eq
id|parent
)paren
r_return
id|parent
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_void
DECL|function|rpc_child_exit
id|rpc_child_exit
c_func
(paren
r_struct
id|rpc_task
op_star
id|child
)paren
(brace
r_struct
id|rpc_task
op_star
id|parent
suffix:semicolon
r_if
c_cond
(paren
(paren
id|parent
op_assign
id|rpc_find_parent
c_func
(paren
id|child
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|parent-&gt;tk_status
op_assign
id|child-&gt;tk_status
suffix:semicolon
id|rpc_wake_up_task
c_func
(paren
id|parent
)paren
suffix:semicolon
)brace
id|rpc_release_task
c_func
(paren
id|child
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: rpc_new_task releases the client after a failure.&n; */
r_struct
id|rpc_task
op_star
DECL|function|rpc_new_child
id|rpc_new_child
c_func
(paren
r_struct
id|rpc_clnt
op_star
id|clnt
comma
r_struct
id|rpc_task
op_star
id|parent
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|task
op_assign
id|rpc_new_task
c_func
(paren
id|clnt
comma
l_int|NULL
comma
id|RPC_TASK_ASYNC
op_or
id|RPC_TASK_CHILD
)paren
)paren
)paren
(brace
id|parent-&gt;tk_status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|task-&gt;tk_exit
op_assign
id|rpc_child_exit
suffix:semicolon
id|task-&gt;tk_calldata
op_assign
id|parent
suffix:semicolon
r_return
id|task
suffix:semicolon
)brace
r_void
DECL|function|rpc_run_child
id|rpc_run_child
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
comma
r_struct
id|rpc_task
op_star
id|child
comma
id|rpc_action
id|func
)paren
(brace
id|rpc_make_runnable
c_func
(paren
id|child
)paren
suffix:semicolon
id|rpc_sleep_on
c_func
(paren
op_amp
id|childq
comma
id|task
comma
id|func
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Kill all tasks for the given client.&n; * XXX: kill their descendants as well?&n; */
r_void
DECL|function|rpc_killall_tasks
id|rpc_killall_tasks
c_func
(paren
r_struct
id|rpc_clnt
op_star
id|clnt
)paren
(brace
r_struct
id|rpc_task
op_star
op_star
id|q
comma
op_star
id|rovr
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC:      killing all tasks for client %p&bslash;n&quot;
comma
id|clnt
)paren
suffix:semicolon
id|rpc_inhibit
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
op_amp
id|all_tasks
suffix:semicolon
(paren
id|rovr
op_assign
op_star
id|q
)paren
suffix:semicolon
id|q
op_assign
op_amp
id|rovr-&gt;tk_next_task
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|clnt
op_logical_or
id|rovr-&gt;tk_client
op_eq
id|clnt
)paren
(brace
id|rovr-&gt;tk_flags
op_or_assign
id|RPC_TASK_KILLED
suffix:semicolon
id|rpc_exit
c_func
(paren
id|rovr
comma
op_minus
id|EIO
)paren
suffix:semicolon
id|rpc_wake_up_task
c_func
(paren
id|rovr
)paren
suffix:semicolon
)brace
)brace
id|rpc_inhibit
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the rpciod kernel thread&n; */
r_static
r_int
DECL|function|rpciod
id|rpciod
c_func
(paren
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|wait_queue
op_star
op_star
id|assassin
op_assign
(paren
r_struct
id|wait_queue
op_star
op_star
)paren
id|ptr
suffix:semicolon
r_int
r_int
id|oldflags
suffix:semicolon
r_int
id|rounds
op_assign
l_int|0
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Let our maker know we&squot;re running ...&n;&t; */
id|rpciod_pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|rpciod_idle
)paren
suffix:semicolon
id|exit_files
c_func
(paren
id|current
)paren
suffix:semicolon
id|exit_mm
c_func
(paren
id|current
)paren
suffix:semicolon
id|siginitsetinv
c_func
(paren
op_amp
id|current-&gt;blocked
comma
id|sigmask
c_func
(paren
id|SIGKILL
)paren
)paren
suffix:semicolon
id|current-&gt;session
op_assign
l_int|1
suffix:semicolon
id|current-&gt;pgrp
op_assign
l_int|1
suffix:semicolon
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;rpciod&quot;
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: rpciod starting (pid %d)&bslash;n&quot;
comma
id|rpciod_pid
)paren
suffix:semicolon
r_while
c_loop
(paren
id|rpciod_users
)paren
(brace
r_if
c_cond
(paren
id|signalled
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|sigismember
c_func
(paren
op_amp
id|current-&gt;signal
comma
id|SIGKILL
)paren
)paren
(brace
id|rpciod_killall
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;rpciod: ignoring signal (%d users)&bslash;n&quot;
comma
id|rpciod_users
)paren
suffix:semicolon
)brace
id|flush_signals
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
id|__rpc_schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|rounds
op_ge
l_int|64
)paren
(brace
multiline_comment|/* safeguard */
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|rounds
op_assign
l_int|0
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|schedq.task
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: rpciod back to sleep&bslash;n&quot;
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|rpciod_idle
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: switch to rpciod&bslash;n&quot;
)paren
suffix:semicolon
id|rounds
op_assign
l_int|0
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: rpciod shutdown commences&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|all_tasks
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rpciod: active tasks at shutdown?!&bslash;n&quot;
)paren
suffix:semicolon
id|rpciod_killall
c_func
(paren
)paren
suffix:semicolon
)brace
id|rpciod_pid
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
id|assassin
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: rpciod exiting&bslash;n&quot;
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|rpciod_killall
id|rpciod_killall
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|sigset_t
id|old_set
suffix:semicolon
multiline_comment|/* FIXME: What had been going on before was saving and restoring &n;&t;   current-&gt;signal.  This as opposed to blocking signals?  Do we&n;&t;   still need them to wake up out of schedule?  In any case it &n;&t;   isn&squot;t playing nice and a better way should be found.  */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
comma
id|flags
)paren
suffix:semicolon
id|old_set
op_assign
id|current-&gt;blocked
suffix:semicolon
id|sigfillset
c_func
(paren
op_amp
id|current-&gt;blocked
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|all_tasks
)paren
(brace
id|rpc_killall_tasks
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|__rpc_schedule
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|100
suffix:semicolon
id|need_resched
op_assign
l_int|1
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
comma
id|flags
)paren
suffix:semicolon
id|current-&gt;blocked
op_assign
id|old_set
suffix:semicolon
id|recalc_sigpending
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Start up the rpciod process if it&squot;s not already running.&n; */
r_int
DECL|function|rpciod_up
id|rpciod_up
c_func
(paren
r_void
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|down
c_func
(paren
op_amp
id|rpciod_sema
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;rpciod_up: pid %d, users %d&bslash;n&quot;
comma
id|rpciod_pid
comma
id|rpciod_users
)paren
suffix:semicolon
id|rpciod_users
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rpciod_pid
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * If there&squot;s no pid, we should be the first user.&n;&t; */
r_if
c_cond
(paren
id|rpciod_users
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;rpciod_up: no pid, %d users??&bslash;n&quot;
comma
id|rpciod_users
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Create the rpciod thread and wait for it to start.&n;&t; */
id|error
op_assign
id|kernel_thread
c_func
(paren
id|rpciod
comma
op_amp
id|rpciod_killer
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rpciod_up: create thread failed, error=%d&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|sleep_on
c_func
(paren
op_amp
id|rpciod_idle
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|rpciod_sema
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_void
DECL|function|rpciod_down
id|rpciod_down
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|down
c_func
(paren
op_amp
id|rpciod_sema
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;rpciod_down pid %d sema %d&bslash;n&quot;
comma
id|rpciod_pid
comma
id|rpciod_users
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rpciod_users
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|rpciod_users
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;rpciod_down: pid=%d, no users??&bslash;n&quot;
comma
id|rpciod_pid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rpciod_pid
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rpciod_down: Nothing to do!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|kill_proc
c_func
(paren
id|rpciod_pid
comma
id|SIGKILL
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Usually rpciod will exit very quickly, so we&n;&t; * wait briefly before checking the process id.&n;&t; */
id|current-&gt;sigpending
op_assign
l_int|0
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Display a message if we&squot;re going to wait longer.&n;&t; */
r_while
c_loop
(paren
id|rpciod_pid
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rpciod_down: waiting for pid %d to exit&bslash;n&quot;
comma
id|rpciod_pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signalled
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rpciod_down: caught signal&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|rpciod_killer
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
comma
id|flags
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
comma
id|flags
)paren
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|rpciod_sema
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
eof
