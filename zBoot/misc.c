macro_line|#include &quot;gzip.h&quot;
macro_line|#include &quot;lzw.h&quot;
multiline_comment|/*&n; * These are set up by the setup-routine at boot-time:&n; */
DECL|struct|screen_info
r_struct
id|screen_info
(brace
DECL|member|orig_x
r_int
r_char
id|orig_x
suffix:semicolon
DECL|member|orig_y
r_int
r_char
id|orig_y
suffix:semicolon
DECL|member|unused1
r_int
r_char
id|unused1
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|orig_video_page
r_int
r_int
id|orig_video_page
suffix:semicolon
DECL|member|orig_video_mode
r_int
r_char
id|orig_video_mode
suffix:semicolon
DECL|member|orig_video_cols
r_int
r_char
id|orig_video_cols
suffix:semicolon
DECL|member|orig_video_ega_ax
r_int
r_int
id|orig_video_ega_ax
suffix:semicolon
DECL|member|orig_video_ega_bx
r_int
r_int
id|orig_video_ega_bx
suffix:semicolon
DECL|member|orig_video_ega_cx
r_int
r_int
id|orig_video_ega_cx
suffix:semicolon
DECL|member|orig_video_lines
r_int
r_char
id|orig_video_lines
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * This is set up by the setup-routine at boot-time&n; */
DECL|macro|EXT_MEM_K
mdefine_line|#define EXT_MEM_K (*(unsigned short *)0x90002)
DECL|macro|DRIVE_INFO
mdefine_line|#define DRIVE_INFO (*(struct drive_info *)0x90080)
DECL|macro|SCREEN_INFO
mdefine_line|#define SCREEN_INFO (*(struct screen_info *)0x90000)
DECL|macro|RAMDISK_SIZE
mdefine_line|#define RAMDISK_SIZE (*(unsigned short *)0x901F8)
DECL|macro|ORIG_ROOT_DEV
mdefine_line|#define ORIG_ROOT_DEV (*(unsigned short *)0x901FC)
DECL|macro|AUX_DEVICE_INFO
mdefine_line|#define AUX_DEVICE_INFO (*(unsigned char *)0x901FF)
DECL|macro|EOF
mdefine_line|#define EOF -1
id|DECLARE
c_func
(paren
id|uch
comma
id|inbuf
comma
id|INBUFSIZ
)paren
suffix:semicolon
id|DECLARE
c_func
(paren
id|uch
comma
id|outbuf
comma
id|OUTBUFSIZ
op_plus
id|OUTBUF_EXTRA
)paren
suffix:semicolon
id|DECLARE
c_func
(paren
id|uch
comma
id|window
comma
id|WSIZE
)paren
suffix:semicolon
DECL|variable|outcnt
r_int
id|outcnt
suffix:semicolon
DECL|variable|insize
r_int
id|insize
suffix:semicolon
DECL|variable|inptr
r_int
id|inptr
suffix:semicolon
r_extern
r_char
id|input_data
(braket
)braket
suffix:semicolon
r_extern
r_int
id|input_len
suffix:semicolon
DECL|variable|input_ptr
r_int
id|input_ptr
suffix:semicolon
DECL|variable|method
DECL|variable|exit_code
DECL|variable|part_nb
DECL|variable|last_member
r_int
id|method
comma
id|exit_code
comma
id|part_nb
comma
id|last_member
suffix:semicolon
DECL|variable|test
r_int
id|test
op_assign
l_int|0
suffix:semicolon
DECL|variable|force
r_int
id|force
op_assign
l_int|0
suffix:semicolon
DECL|variable|verbose
r_int
id|verbose
op_assign
l_int|1
suffix:semicolon
DECL|variable|bytes_in
DECL|variable|bytes_out
r_int
id|bytes_in
comma
id|bytes_out
suffix:semicolon
DECL|variable|output_data
r_char
op_star
id|output_data
suffix:semicolon
DECL|variable|output_ptr
r_int
r_int
id|output_ptr
suffix:semicolon
r_extern
r_int
id|end
suffix:semicolon
DECL|variable|free_mem_ptr
r_int
id|free_mem_ptr
op_assign
(paren
r_int
)paren
op_amp
id|end
suffix:semicolon
DECL|variable|to_stdout
r_int
id|to_stdout
op_assign
l_int|0
suffix:semicolon
DECL|variable|hard_math
r_int
id|hard_math
op_assign
l_int|0
suffix:semicolon
DECL|variable|work
r_void
(paren
op_star
id|work
)paren
(paren
r_int
id|inf
comma
r_int
id|outf
)paren
suffix:semicolon
DECL|variable|vidmem
r_char
op_star
id|vidmem
op_assign
(paren
r_char
op_star
)paren
l_int|0xb8000
suffix:semicolon
DECL|variable|vidp
r_int
id|vidp
op_assign
l_int|0
suffix:semicolon
DECL|variable|lines
DECL|variable|cols
r_int
id|lines
comma
id|cols
suffix:semicolon
DECL|function|malloc
r_void
op_star
id|malloc
c_func
(paren
r_int
id|size
)paren
(brace
r_void
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
l_int|0
)paren
id|error
c_func
(paren
l_string|&quot;Malloc error&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free_mem_ptr
op_le
l_int|0
)paren
id|error
c_func
(paren
l_string|&quot;Memory error&bslash;n&quot;
)paren
suffix:semicolon
id|free_mem_ptr
op_assign
(paren
id|free_mem_ptr
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
suffix:semicolon
multiline_comment|/* Align */
id|p
op_assign
(paren
r_void
op_star
)paren
id|free_mem_ptr
suffix:semicolon
id|free_mem_ptr
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|free_mem_ptr
op_ge
(paren
l_int|640
op_star
l_int|1024
)paren
)paren
id|error
c_func
(paren
l_string|&quot;&bslash;nOut of memory&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
id|error
c_func
(paren
l_string|&quot;malloc = NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|free
r_void
id|free
c_func
(paren
r_void
op_star
id|where
)paren
(brace
multiline_comment|/* Don&squot;t care */
)brace
DECL|function|printk
r_int
id|printk
c_func
(paren
r_char
op_star
id|s
)paren
(brace
r_int
id|i
comma
id|n
suffix:semicolon
id|n
op_assign
id|strlen
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
id|n
op_assign
l_int|10
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|s
(braket
id|i
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|vidp
op_assign
(paren
(paren
id|vidp
op_div
(paren
id|cols
op_star
l_int|2
)paren
)paren
op_plus
l_int|1
)paren
op_star
id|cols
op_star
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|vidmem
(braket
id|vidp
)braket
op_assign
id|s
(braket
id|i
)braket
suffix:semicolon
id|vidp
op_assign
id|vidp
op_plus
l_int|2
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|memset
id|__ptr_t
id|memset
c_func
(paren
id|__ptr_t
id|s
comma
r_int
id|c
comma
r_int
id|n
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|ss
op_assign
(paren
r_char
op_star
)paren
id|s
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
id|ss
(braket
id|i
)braket
op_assign
id|c
suffix:semicolon
)brace
DECL|function|memcpy
id|__ptr_t
id|memcpy
c_func
(paren
id|__ptr_t
id|__dest
comma
id|__const
id|__ptr_t
id|__src
comma
r_int
id|__n
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|d
op_assign
(paren
r_char
op_star
)paren
id|__dest
comma
op_star
id|s
op_assign
(paren
r_char
op_star
)paren
id|__src
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|__n
suffix:semicolon
id|i
op_increment
)paren
id|d
(braket
id|i
)braket
op_assign
id|s
(braket
id|i
)braket
suffix:semicolon
)brace
r_extern
id|ulg
id|crc_32_tab
(braket
)braket
suffix:semicolon
multiline_comment|/* crc table, defined below */
multiline_comment|/* ===========================================================================&n; * Run a set of bytes through the crc shift register.  If s is a NULL&n; * pointer, then initialize the crc shift register contents instead.&n; * Return the current crc in either case.&n; */
DECL|function|updcrc
id|ulg
id|updcrc
c_func
(paren
id|s
comma
id|n
)paren
id|uch
op_star
id|s
suffix:semicolon
multiline_comment|/* pointer to bytes to pump through */
r_int
id|n
suffix:semicolon
multiline_comment|/* number of bytes in s[] */
(brace
r_register
id|ulg
id|c
suffix:semicolon
multiline_comment|/* temporary variable */
r_static
id|ulg
id|crc
op_assign
(paren
id|ulg
)paren
l_int|0xffffffffL
suffix:semicolon
multiline_comment|/* shift register contents */
r_if
c_cond
(paren
id|s
op_eq
l_int|NULL
)paren
(brace
id|c
op_assign
l_int|0xffffffffL
suffix:semicolon
)brace
r_else
(brace
id|c
op_assign
id|crc
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
)paren
(brace
id|c
op_assign
id|crc_32_tab
(braket
(paren
(paren
r_int
)paren
id|c
op_xor
(paren
op_star
id|s
op_increment
)paren
)paren
op_amp
l_int|0xff
)braket
op_xor
(paren
id|c
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
)brace
id|crc
op_assign
id|c
suffix:semicolon
r_return
id|c
op_xor
l_int|0xffffffffL
suffix:semicolon
multiline_comment|/* (instead of ~c for 64-bit machines) */
)brace
multiline_comment|/* ===========================================================================&n; * Clear input and output buffers&n; */
DECL|function|clear_bufs
r_void
id|clear_bufs
c_func
(paren
)paren
(brace
id|outcnt
op_assign
l_int|0
suffix:semicolon
id|insize
op_assign
id|inptr
op_assign
l_int|0
suffix:semicolon
id|bytes_in
op_assign
id|bytes_out
op_assign
l_int|0L
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Fill the input buffer. This is called only when the buffer is empty&n; * and at least one byte is really needed.&n; */
DECL|function|fill_inbuf
r_int
id|fill_inbuf
c_func
(paren
)paren
(brace
r_int
id|len
comma
id|i
suffix:semicolon
multiline_comment|/* Read as much as possible */
id|insize
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|len
op_assign
id|INBUFSIZ
op_minus
id|insize
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
(paren
id|input_len
op_minus
id|input_ptr
op_plus
l_int|1
)paren
)paren
id|len
op_assign
id|input_len
op_minus
id|input_ptr
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
op_logical_or
id|len
op_eq
id|EOF
)paren
r_break
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|inbuf
(braket
id|insize
op_plus
id|i
)braket
op_assign
id|input_data
(braket
id|input_ptr
op_plus
id|i
)braket
suffix:semicolon
id|insize
op_add_assign
id|len
suffix:semicolon
id|input_ptr
op_add_assign
id|len
suffix:semicolon
)brace
r_while
c_loop
(paren
id|insize
OL
id|INBUFSIZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|insize
op_eq
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to fill buffer&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|bytes_in
op_add_assign
(paren
id|ulg
)paren
id|insize
suffix:semicolon
id|inptr
op_assign
l_int|1
suffix:semicolon
r_return
id|inbuf
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Write the output window window[0..outcnt-1] and update crc and bytes_out.&n; * (Used for the decompressed data only.)&n; */
DECL|function|flush_window
r_void
id|flush_window
c_func
(paren
)paren
(brace
r_if
c_cond
(paren
id|outcnt
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|updcrc
c_func
(paren
id|window
comma
id|outcnt
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|output_data
(braket
id|output_ptr
)braket
comma
(paren
r_char
op_star
)paren
id|window
comma
id|outcnt
)paren
suffix:semicolon
id|bytes_out
op_add_assign
(paren
id|ulg
)paren
id|outcnt
suffix:semicolon
id|output_ptr
op_add_assign
(paren
id|ulg
)paren
id|outcnt
suffix:semicolon
id|outcnt
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ========================================================================&n; * Table of CRC-32&squot;s of all single-byte values (made by makecrc.c)&n; */
DECL|variable|crc_32_tab
id|ulg
id|crc_32_tab
(braket
)braket
op_assign
(brace
l_int|0x00000000L
comma
l_int|0x77073096L
comma
l_int|0xee0e612cL
comma
l_int|0x990951baL
comma
l_int|0x076dc419L
comma
l_int|0x706af48fL
comma
l_int|0xe963a535L
comma
l_int|0x9e6495a3L
comma
l_int|0x0edb8832L
comma
l_int|0x79dcb8a4L
comma
l_int|0xe0d5e91eL
comma
l_int|0x97d2d988L
comma
l_int|0x09b64c2bL
comma
l_int|0x7eb17cbdL
comma
l_int|0xe7b82d07L
comma
l_int|0x90bf1d91L
comma
l_int|0x1db71064L
comma
l_int|0x6ab020f2L
comma
l_int|0xf3b97148L
comma
l_int|0x84be41deL
comma
l_int|0x1adad47dL
comma
l_int|0x6ddde4ebL
comma
l_int|0xf4d4b551L
comma
l_int|0x83d385c7L
comma
l_int|0x136c9856L
comma
l_int|0x646ba8c0L
comma
l_int|0xfd62f97aL
comma
l_int|0x8a65c9ecL
comma
l_int|0x14015c4fL
comma
l_int|0x63066cd9L
comma
l_int|0xfa0f3d63L
comma
l_int|0x8d080df5L
comma
l_int|0x3b6e20c8L
comma
l_int|0x4c69105eL
comma
l_int|0xd56041e4L
comma
l_int|0xa2677172L
comma
l_int|0x3c03e4d1L
comma
l_int|0x4b04d447L
comma
l_int|0xd20d85fdL
comma
l_int|0xa50ab56bL
comma
l_int|0x35b5a8faL
comma
l_int|0x42b2986cL
comma
l_int|0xdbbbc9d6L
comma
l_int|0xacbcf940L
comma
l_int|0x32d86ce3L
comma
l_int|0x45df5c75L
comma
l_int|0xdcd60dcfL
comma
l_int|0xabd13d59L
comma
l_int|0x26d930acL
comma
l_int|0x51de003aL
comma
l_int|0xc8d75180L
comma
l_int|0xbfd06116L
comma
l_int|0x21b4f4b5L
comma
l_int|0x56b3c423L
comma
l_int|0xcfba9599L
comma
l_int|0xb8bda50fL
comma
l_int|0x2802b89eL
comma
l_int|0x5f058808L
comma
l_int|0xc60cd9b2L
comma
l_int|0xb10be924L
comma
l_int|0x2f6f7c87L
comma
l_int|0x58684c11L
comma
l_int|0xc1611dabL
comma
l_int|0xb6662d3dL
comma
l_int|0x76dc4190L
comma
l_int|0x01db7106L
comma
l_int|0x98d220bcL
comma
l_int|0xefd5102aL
comma
l_int|0x71b18589L
comma
l_int|0x06b6b51fL
comma
l_int|0x9fbfe4a5L
comma
l_int|0xe8b8d433L
comma
l_int|0x7807c9a2L
comma
l_int|0x0f00f934L
comma
l_int|0x9609a88eL
comma
l_int|0xe10e9818L
comma
l_int|0x7f6a0dbbL
comma
l_int|0x086d3d2dL
comma
l_int|0x91646c97L
comma
l_int|0xe6635c01L
comma
l_int|0x6b6b51f4L
comma
l_int|0x1c6c6162L
comma
l_int|0x856530d8L
comma
l_int|0xf262004eL
comma
l_int|0x6c0695edL
comma
l_int|0x1b01a57bL
comma
l_int|0x8208f4c1L
comma
l_int|0xf50fc457L
comma
l_int|0x65b0d9c6L
comma
l_int|0x12b7e950L
comma
l_int|0x8bbeb8eaL
comma
l_int|0xfcb9887cL
comma
l_int|0x62dd1ddfL
comma
l_int|0x15da2d49L
comma
l_int|0x8cd37cf3L
comma
l_int|0xfbd44c65L
comma
l_int|0x4db26158L
comma
l_int|0x3ab551ceL
comma
l_int|0xa3bc0074L
comma
l_int|0xd4bb30e2L
comma
l_int|0x4adfa541L
comma
l_int|0x3dd895d7L
comma
l_int|0xa4d1c46dL
comma
l_int|0xd3d6f4fbL
comma
l_int|0x4369e96aL
comma
l_int|0x346ed9fcL
comma
l_int|0xad678846L
comma
l_int|0xda60b8d0L
comma
l_int|0x44042d73L
comma
l_int|0x33031de5L
comma
l_int|0xaa0a4c5fL
comma
l_int|0xdd0d7cc9L
comma
l_int|0x5005713cL
comma
l_int|0x270241aaL
comma
l_int|0xbe0b1010L
comma
l_int|0xc90c2086L
comma
l_int|0x5768b525L
comma
l_int|0x206f85b3L
comma
l_int|0xb966d409L
comma
l_int|0xce61e49fL
comma
l_int|0x5edef90eL
comma
l_int|0x29d9c998L
comma
l_int|0xb0d09822L
comma
l_int|0xc7d7a8b4L
comma
l_int|0x59b33d17L
comma
l_int|0x2eb40d81L
comma
l_int|0xb7bd5c3bL
comma
l_int|0xc0ba6cadL
comma
l_int|0xedb88320L
comma
l_int|0x9abfb3b6L
comma
l_int|0x03b6e20cL
comma
l_int|0x74b1d29aL
comma
l_int|0xead54739L
comma
l_int|0x9dd277afL
comma
l_int|0x04db2615L
comma
l_int|0x73dc1683L
comma
l_int|0xe3630b12L
comma
l_int|0x94643b84L
comma
l_int|0x0d6d6a3eL
comma
l_int|0x7a6a5aa8L
comma
l_int|0xe40ecf0bL
comma
l_int|0x9309ff9dL
comma
l_int|0x0a00ae27L
comma
l_int|0x7d079eb1L
comma
l_int|0xf00f9344L
comma
l_int|0x8708a3d2L
comma
l_int|0x1e01f268L
comma
l_int|0x6906c2feL
comma
l_int|0xf762575dL
comma
l_int|0x806567cbL
comma
l_int|0x196c3671L
comma
l_int|0x6e6b06e7L
comma
l_int|0xfed41b76L
comma
l_int|0x89d32be0L
comma
l_int|0x10da7a5aL
comma
l_int|0x67dd4accL
comma
l_int|0xf9b9df6fL
comma
l_int|0x8ebeeff9L
comma
l_int|0x17b7be43L
comma
l_int|0x60b08ed5L
comma
l_int|0xd6d6a3e8L
comma
l_int|0xa1d1937eL
comma
l_int|0x38d8c2c4L
comma
l_int|0x4fdff252L
comma
l_int|0xd1bb67f1L
comma
l_int|0xa6bc5767L
comma
l_int|0x3fb506ddL
comma
l_int|0x48b2364bL
comma
l_int|0xd80d2bdaL
comma
l_int|0xaf0a1b4cL
comma
l_int|0x36034af6L
comma
l_int|0x41047a60L
comma
l_int|0xdf60efc3L
comma
l_int|0xa867df55L
comma
l_int|0x316e8eefL
comma
l_int|0x4669be79L
comma
l_int|0xcb61b38cL
comma
l_int|0xbc66831aL
comma
l_int|0x256fd2a0L
comma
l_int|0x5268e236L
comma
l_int|0xcc0c7795L
comma
l_int|0xbb0b4703L
comma
l_int|0x220216b9L
comma
l_int|0x5505262fL
comma
l_int|0xc5ba3bbeL
comma
l_int|0xb2bd0b28L
comma
l_int|0x2bb45a92L
comma
l_int|0x5cb36a04L
comma
l_int|0xc2d7ffa7L
comma
l_int|0xb5d0cf31L
comma
l_int|0x2cd99e8bL
comma
l_int|0x5bdeae1dL
comma
l_int|0x9b64c2b0L
comma
l_int|0xec63f226L
comma
l_int|0x756aa39cL
comma
l_int|0x026d930aL
comma
l_int|0x9c0906a9L
comma
l_int|0xeb0e363fL
comma
l_int|0x72076785L
comma
l_int|0x05005713L
comma
l_int|0x95bf4a82L
comma
l_int|0xe2b87a14L
comma
l_int|0x7bb12baeL
comma
l_int|0x0cb61b38L
comma
l_int|0x92d28e9bL
comma
l_int|0xe5d5be0dL
comma
l_int|0x7cdcefb7L
comma
l_int|0x0bdbdf21L
comma
l_int|0x86d3d2d4L
comma
l_int|0xf1d4e242L
comma
l_int|0x68ddb3f8L
comma
l_int|0x1fda836eL
comma
l_int|0x81be16cdL
comma
l_int|0xf6b9265bL
comma
l_int|0x6fb077e1L
comma
l_int|0x18b74777L
comma
l_int|0x88085ae6L
comma
l_int|0xff0f6a70L
comma
l_int|0x66063bcaL
comma
l_int|0x11010b5cL
comma
l_int|0x8f659effL
comma
l_int|0xf862ae69L
comma
l_int|0x616bffd3L
comma
l_int|0x166ccf45L
comma
l_int|0xa00ae278L
comma
l_int|0xd70dd2eeL
comma
l_int|0x4e048354L
comma
l_int|0x3903b3c2L
comma
l_int|0xa7672661L
comma
l_int|0xd06016f7L
comma
l_int|0x4969474dL
comma
l_int|0x3e6e77dbL
comma
l_int|0xaed16a4aL
comma
l_int|0xd9d65adcL
comma
l_int|0x40df0b66L
comma
l_int|0x37d83bf0L
comma
l_int|0xa9bcae53L
comma
l_int|0xdebb9ec5L
comma
l_int|0x47b2cf7fL
comma
l_int|0x30b5ffe9L
comma
l_int|0xbdbdf21cL
comma
l_int|0xcabac28aL
comma
l_int|0x53b39330L
comma
l_int|0x24b4a3a6L
comma
l_int|0xbad03605L
comma
l_int|0xcdd70693L
comma
l_int|0x54de5729L
comma
l_int|0x23d967bfL
comma
l_int|0xb3667a2eL
comma
l_int|0xc4614ab8L
comma
l_int|0x5d681b02L
comma
l_int|0x2a6f2b94L
comma
l_int|0xb40bbe37L
comma
l_int|0xc30c8ea1L
comma
l_int|0x5a05df1bL
comma
l_int|0x2d02ef8dL
)brace
suffix:semicolon
DECL|function|error
r_void
id|error
c_func
(paren
r_char
op_star
id|x
)paren
(brace
id|printk
c_func
(paren
id|x
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; -- System halted&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Halt */
)brace
DECL|macro|STACK_SIZE
mdefine_line|#define STACK_SIZE (4096)
DECL|variable|user_stack
r_int
id|user_stack
(braket
id|STACK_SIZE
)braket
suffix:semicolon
r_struct
(brace
DECL|member|a
r_int
op_star
id|a
suffix:semicolon
DECL|member|b
r_int
id|b
suffix:semicolon
DECL|variable|stack_start
)brace
id|stack_start
op_assign
(brace
op_amp
id|user_stack
(braket
id|STACK_SIZE
)braket
comma
l_int|0x10
)brace
suffix:semicolon
DECL|function|decompress_kernel
r_void
id|decompress_kernel
c_func
(paren
)paren
(brace
id|vidp
op_assign
l_int|0
suffix:semicolon
id|vidmem
(braket
l_int|0
)braket
op_assign
l_char|&squot;0&squot;
suffix:semicolon
id|lines
op_assign
id|SCREEN_INFO.orig_video_lines
suffix:semicolon
id|cols
op_assign
id|SCREEN_INFO.orig_video_cols
suffix:semicolon
r_if
c_cond
(paren
id|EXT_MEM_K
OL
l_int|2048
)paren
id|error
c_func
(paren
l_string|&quot;At least 2M of memory required by Turbo Ignition&bslash;n&quot;
)paren
suffix:semicolon
id|output_data
op_assign
(paren
r_char
op_star
)paren
l_int|1048576
suffix:semicolon
multiline_comment|/* Points to 1M */
id|output_ptr
op_assign
l_int|0
suffix:semicolon
id|exit_code
op_assign
l_int|0
suffix:semicolon
id|test
op_assign
l_int|0
suffix:semicolon
id|input_ptr
op_assign
l_int|0
suffix:semicolon
id|part_nb
op_assign
l_int|0
suffix:semicolon
id|clear_bufs
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Uncompressing Linux: check - &quot;
)paren
suffix:semicolon
id|method
op_assign
id|get_method
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;work - &quot;
)paren
suffix:semicolon
id|work
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;done.&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Now booting the kernel&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* ========================================================================&n; * Check the magic number of the input file and update ofname if an&n; * original name was given and to_stdout is not set.&n; * Return the compression method, -1 for error, -2 for warning.&n; * Set inptr to the offset of the next byte to be processed.&n; * This function may be called repeatedly for an input file consisting&n; * of several contiguous gzip&squot;ed members.&n; * IN assertions: there is at least one remaining compressed member.&n; *   If the member is a zip file, it must be the only one.&n; */
DECL|function|get_method
id|local
r_int
id|get_method
c_func
(paren
id|in
)paren
r_int
id|in
suffix:semicolon
multiline_comment|/* input file descriptor */
(brace
id|uch
id|flags
suffix:semicolon
r_char
id|magic
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* magic header */
id|magic
(braket
l_int|0
)braket
op_assign
(paren
r_char
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
id|magic
(braket
l_int|1
)braket
op_assign
(paren
r_char
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
id|method
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* unknown yet */
id|part_nb
op_increment
suffix:semicolon
multiline_comment|/* number of parts in gzip file */
id|last_member
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* assume multiple members in gzip file except for record oriented I/O */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|magic
comma
id|GZIP_MAGIC
comma
l_int|2
)paren
op_eq
l_int|0
op_logical_or
id|memcmp
c_func
(paren
id|magic
comma
id|OLD_GZIP_MAGIC
comma
l_int|2
)paren
op_eq
l_int|0
)paren
(brace
id|work
op_assign
id|unzip
suffix:semicolon
id|method
op_assign
(paren
r_int
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
id|flags
op_assign
(paren
id|uch
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|ENCRYPTED
)paren
op_ne
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Input is encrypted -- too secret&bslash;n&quot;
)paren
suffix:semicolon
id|exit_code
op_assign
id|ERROR
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|CONTINUATION
)paren
op_ne
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Input is a a multi-part gzip file&bslash;n&quot;
)paren
suffix:semicolon
id|exit_code
op_assign
id|ERROR
suffix:semicolon
r_if
c_cond
(paren
id|force
op_le
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|RESERVED
)paren
op_ne
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Input has invalid flags&bslash;n&quot;
)paren
suffix:semicolon
id|exit_code
op_assign
id|ERROR
suffix:semicolon
r_if
c_cond
(paren
id|force
op_le
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
(paren
id|ulg
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Get timestamp */
(paren
(paren
id|ulg
)paren
id|get_byte
c_func
(paren
)paren
)paren
op_lshift
l_int|8
suffix:semicolon
(paren
(paren
id|ulg
)paren
id|get_byte
c_func
(paren
)paren
)paren
op_lshift
l_int|16
suffix:semicolon
(paren
(paren
id|ulg
)paren
id|get_byte
c_func
(paren
)paren
)paren
op_lshift
l_int|24
suffix:semicolon
(paren
r_void
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Ignore extra flags for the moment */
(paren
r_void
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Ignore OS type for the moment */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|CONTINUATION
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|part
op_assign
(paren
r_int
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
id|part
op_or_assign
(paren
(paren
r_int
)paren
id|get_byte
c_func
(paren
)paren
)paren
op_lshift
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Input is not part number 1&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|EXTRA_FIELD
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|len
op_assign
(paren
r_int
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
id|len
op_or_assign
(paren
(paren
r_int
)paren
id|get_byte
c_func
(paren
)paren
)paren
op_lshift
l_int|8
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
(paren
r_void
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Get original file name if it was truncated */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|ORIG_NAME
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|to_stdout
op_logical_or
id|part_nb
OG
l_int|1
)paren
(brace
multiline_comment|/* Discard the old name */
r_while
c_loop
(paren
id|get_byte
c_func
(paren
)paren
op_ne
l_int|0
)paren
multiline_comment|/* null */
suffix:semicolon
)brace
r_else
(brace
)brace
multiline_comment|/* to_stdout */
)brace
multiline_comment|/* orig_name */
multiline_comment|/* Discard file comment if any */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|COMMENT
)paren
op_ne
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|get_byte
c_func
(paren
)paren
op_ne
l_int|0
)paren
multiline_comment|/* null */
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|magic
comma
id|PKZIP_MAGIC
comma
l_int|2
)paren
op_eq
l_int|0
op_logical_and
id|inptr
op_eq
l_int|2
op_logical_and
id|memcmp
c_func
(paren
id|inbuf
comma
id|PKZIP_MAGIC
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* To simplify the code, we support a zip file when alone only.&n;         * We are thus guaranteed that the entire local header fits in inbuf.&n;         */
id|inptr
op_assign
l_int|0
suffix:semicolon
id|work
op_assign
id|unzip
suffix:semicolon
r_if
c_cond
(paren
id|check_zipfile
c_func
(paren
id|in
)paren
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* check_zipfile may get ofname from the local header */
id|last_member
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|magic
comma
id|PACK_MAGIC
comma
l_int|2
)paren
op_eq
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;packed input&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|magic
comma
id|LZW_MAGIC
comma
l_int|2
)paren
op_eq
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;compressed input&quot;
)paren
suffix:semicolon
id|last_member
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|method
op_eq
op_minus
l_int|1
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Corrupted input&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exit_code
op_ne
id|ERROR
)paren
id|exit_code
op_assign
id|part_nb
op_eq
l_int|1
ques
c_cond
id|ERROR
suffix:colon
id|WARNING
suffix:semicolon
r_return
id|part_nb
op_eq
l_int|1
ques
c_cond
op_minus
l_int|1
suffix:colon
op_minus
l_int|2
suffix:semicolon
)brace
r_return
id|method
suffix:semicolon
)brace
eof
