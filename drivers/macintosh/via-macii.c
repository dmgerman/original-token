multiline_comment|/*&n; * Device driver for the via ADB on (many) Mac II-class machines&n; *&n; * Based on the original ADB keyboard handler Copyright (c) 1997 Alan Cox&n; * Also derived from code Copyright (C) 1996 Paul Mackerras.&n; *&n; * With various updates provided over the years by Michael Schmitz,&n; * Guideo Koerber and others.&n; *&n; * Rewrite for Unified ADB by Joshua M. Thompson (funaho@jurai.org)&n; *&n; * 1999-08-02 (jmt) - Initial rewrite for Unified ADB.&n; */
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/adb.h&gt;
macro_line|#include &lt;asm/macintosh.h&gt;
macro_line|#include &lt;asm/macints.h&gt;
macro_line|#include &lt;asm/machw.h&gt;
macro_line|#include &lt;asm/mac_via.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/init.h&gt;
DECL|variable|via
r_static
r_volatile
r_int
r_char
op_star
id|via
suffix:semicolon
multiline_comment|/* VIA registers - spaced 0x200 bytes apart */
DECL|macro|RS
mdefine_line|#define RS&t;&t;0x200&t;&t;/* skip between registers */
DECL|macro|B
mdefine_line|#define B&t;&t;0&t;&t;/* B-side data */
DECL|macro|A
mdefine_line|#define A&t;&t;RS&t;&t;/* A-side data */
DECL|macro|DIRB
mdefine_line|#define DIRB&t;&t;(2*RS)&t;&t;/* B-side direction (1=output) */
DECL|macro|DIRA
mdefine_line|#define DIRA&t;&t;(3*RS)&t;&t;/* A-side direction (1=output) */
DECL|macro|T1CL
mdefine_line|#define T1CL&t;&t;(4*RS)&t;&t;/* Timer 1 ctr/latch (low 8 bits) */
DECL|macro|T1CH
mdefine_line|#define T1CH&t;&t;(5*RS)&t;&t;/* Timer 1 counter (high 8 bits) */
DECL|macro|T1LL
mdefine_line|#define T1LL&t;&t;(6*RS)&t;&t;/* Timer 1 latch (low 8 bits) */
DECL|macro|T1LH
mdefine_line|#define T1LH&t;&t;(7*RS)&t;&t;/* Timer 1 latch (high 8 bits) */
DECL|macro|T2CL
mdefine_line|#define T2CL&t;&t;(8*RS)&t;&t;/* Timer 2 ctr/latch (low 8 bits) */
DECL|macro|T2CH
mdefine_line|#define T2CH&t;&t;(9*RS)&t;&t;/* Timer 2 counter (high 8 bits) */
DECL|macro|SR
mdefine_line|#define SR&t;&t;(10*RS)&t;&t;/* Shift register */
DECL|macro|ACR
mdefine_line|#define ACR&t;&t;(11*RS)&t;&t;/* Auxiliary control register */
DECL|macro|PCR
mdefine_line|#define PCR&t;&t;(12*RS)&t;&t;/* Peripheral control register */
DECL|macro|IFR
mdefine_line|#define IFR&t;&t;(13*RS)&t;&t;/* Interrupt flag register */
DECL|macro|IER
mdefine_line|#define IER&t;&t;(14*RS)&t;&t;/* Interrupt enable register */
DECL|macro|ANH
mdefine_line|#define ANH&t;&t;(15*RS)&t;&t;/* A-side data, no handshake */
multiline_comment|/* Bits in B data register: all active low */
DECL|macro|TREQ
mdefine_line|#define TREQ&t;&t;0x08&t;&t;/* Transfer request (input) */
DECL|macro|TACK
mdefine_line|#define TACK&t;&t;0x10&t;&t;/* Transfer acknowledge (output) */
DECL|macro|TIP
mdefine_line|#define TIP&t;&t;0x20&t;&t;/* Transfer in progress (output) */
DECL|macro|ST_MASK
mdefine_line|#define ST_MASK&t;&t;0x30&t;&t;/* mask for selecting ADB state bits */
multiline_comment|/* Bits in ACR */
DECL|macro|SR_CTRL
mdefine_line|#define SR_CTRL&t;&t;0x1c&t;&t;/* Shift register control bits */
DECL|macro|SR_EXT
mdefine_line|#define SR_EXT&t;&t;0x0c&t;&t;/* Shift on external clock */
DECL|macro|SR_OUT
mdefine_line|#define SR_OUT&t;&t;0x10&t;&t;/* Shift out if 1 */
multiline_comment|/* Bits in IFR and IER */
DECL|macro|IER_SET
mdefine_line|#define IER_SET&t;&t;0x80&t;&t;/* set bits in IER */
DECL|macro|IER_CLR
mdefine_line|#define IER_CLR&t;&t;0&t;&t;/* clear bits in IER */
DECL|macro|SR_INT
mdefine_line|#define SR_INT&t;&t;0x04&t;&t;/* Shift register full/empty */
DECL|macro|SR_DATA
mdefine_line|#define SR_DATA&t;&t;0x08&t;&t;/* Shift register data */
DECL|macro|SR_CLOCK
mdefine_line|#define SR_CLOCK&t;0x10&t;&t;/* Shift register clock */
multiline_comment|/* ADB transaction states according to GMHW */
DECL|macro|ST_CMD
mdefine_line|#define ST_CMD&t;&t;0x00&t;&t;/* ADB state: command byte */
DECL|macro|ST_EVEN
mdefine_line|#define ST_EVEN&t;&t;0x10&t;&t;/* ADB state: even data byte */
DECL|macro|ST_ODD
mdefine_line|#define ST_ODD&t;&t;0x20&t;&t;/* ADB state: odd data byte */
DECL|macro|ST_IDLE
mdefine_line|#define ST_IDLE&t;&t;0x30&t;&t;/* ADB state: idle, nothing to send */
r_static
r_int
id|macii_init_via
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|macii_start
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|macii_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|macii_retransmit
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_void
id|macii_queue_poll
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|macii_probe
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|macii_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|macii_send_request
c_func
(paren
r_struct
id|adb_request
op_star
id|req
comma
r_int
id|sync
)paren
suffix:semicolon
r_static
r_int
id|macii_write
c_func
(paren
r_struct
id|adb_request
op_star
id|req
)paren
suffix:semicolon
r_static
r_int
id|macii_autopoll
c_func
(paren
r_int
id|devs
)paren
suffix:semicolon
r_static
r_void
id|macii_poll
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|macii_reset_bus
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|via_macii_driver
r_struct
id|adb_driver
id|via_macii_driver
op_assign
(brace
l_string|&quot;Mac II&quot;
comma
id|macii_probe
comma
id|macii_init
comma
id|macii_send_request
comma
id|macii_autopoll
comma
id|macii_poll
comma
id|macii_reset_bus
)brace
suffix:semicolon
DECL|enum|macii_state
r_static
r_enum
id|macii_state
(brace
DECL|enumerator|idle
id|idle
comma
DECL|enumerator|sent_first_byte
id|sent_first_byte
comma
DECL|enumerator|sending
id|sending
comma
DECL|enumerator|reading
id|reading
comma
DECL|enumerator|read_done
id|read_done
comma
DECL|enumerator|awaiting_reply
id|awaiting_reply
DECL|variable|macii_state
)brace
id|macii_state
suffix:semicolon
DECL|variable|need_poll
r_static
r_int
id|need_poll
op_assign
l_int|0
suffix:semicolon
DECL|variable|command_byte
r_static
r_int
id|command_byte
op_assign
l_int|0
suffix:semicolon
DECL|variable|last_reply
r_static
r_int
id|last_reply
op_assign
l_int|0
suffix:semicolon
DECL|variable|last_active
r_static
r_int
id|last_active
op_assign
l_int|0
suffix:semicolon
DECL|variable|current_req
r_static
r_struct
id|adb_request
op_star
id|current_req
suffix:semicolon
DECL|variable|last_req
r_static
r_struct
id|adb_request
op_star
id|last_req
suffix:semicolon
DECL|variable|retry_req
r_static
r_struct
id|adb_request
op_star
id|retry_req
suffix:semicolon
DECL|variable|reply_buf
r_static
r_int
r_char
id|reply_buf
(braket
l_int|16
)braket
suffix:semicolon
DECL|variable|reply_ptr
r_static
r_int
r_char
op_star
id|reply_ptr
suffix:semicolon
DECL|variable|reply_len
r_static
r_int
id|reply_len
suffix:semicolon
DECL|variable|reading_reply
r_static
r_int
id|reading_reply
suffix:semicolon
DECL|variable|data_index
r_static
r_int
id|data_index
suffix:semicolon
DECL|variable|first_byte
r_static
r_int
id|first_byte
suffix:semicolon
DECL|variable|prefix_len
r_static
r_int
id|prefix_len
suffix:semicolon
DECL|variable|status
r_static
r_int
id|status
op_assign
id|ST_IDLE
op_or
id|TREQ
suffix:semicolon
DECL|variable|last_status
r_static
r_int
id|last_status
suffix:semicolon
DECL|variable|driver_running
r_static
r_int
id|driver_running
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* debug level 10 required for ADB logging (should be &amp;&amp; debug_adb, ideally) */
multiline_comment|/* Check for MacII style ADB */
DECL|function|macii_probe
r_static
r_int
id|macii_probe
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_ne
id|MAC_ADB_II
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|via
op_assign
id|via1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;adb: Mac II ADB Driver v0.4 for Unified ADB&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Initialize the driver */
DECL|function|macii_init
r_int
id|macii_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|err
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
id|macii_init_via
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|err
op_assign
id|request_irq
c_func
(paren
id|IRQ_MAC_ADB
comma
id|macii_interrupt
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;ADB&quot;
comma
id|macii_interrupt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|macii_state
op_assign
id|idle
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* initialize the hardware */
DECL|function|macii_init_via
r_static
r_int
id|macii_init_via
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|x
suffix:semicolon
multiline_comment|/* Set the lines up. We want TREQ as input TACK|TIP as output */
id|via
(braket
id|DIRB
)braket
op_assign
(paren
id|via
(braket
id|DIRB
)braket
op_or
id|TACK
op_or
id|TIP
)paren
op_amp
op_complement
id|TREQ
suffix:semicolon
multiline_comment|/* Set up state: idle */
id|via
(braket
id|B
)braket
op_or_assign
id|ST_IDLE
suffix:semicolon
id|last_status
op_assign
id|via
(braket
id|B
)braket
op_amp
(paren
id|ST_MASK
op_or
id|TREQ
)paren
suffix:semicolon
multiline_comment|/* Shift register on input */
id|via
(braket
id|ACR
)braket
op_assign
(paren
id|via
(braket
id|ACR
)braket
op_amp
op_complement
id|SR_CTRL
)paren
op_or
id|SR_EXT
suffix:semicolon
multiline_comment|/* Wipe any pending data and int */
id|x
op_assign
id|via
(braket
id|SR
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Send an ADB poll (Talk Register 0 command, tagged on the front of the request queue) */
DECL|function|macii_queue_poll
r_static
r_void
id|macii_queue_poll
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|device
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|in_poll
op_assign
l_int|0
suffix:semicolon
r_static
r_struct
id|adb_request
id|req
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|in_poll
)paren
id|printk
c_func
(paren
l_string|&quot;macii_queue_poll: double poll!&bslash;n&quot;
)paren
suffix:semicolon
id|in_poll
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|device
OG
l_int|15
)paren
id|device
op_assign
l_int|1
suffix:semicolon
id|adb_request
c_func
(paren
op_amp
id|req
comma
l_int|NULL
comma
id|ADBREQ_REPLY
op_or
id|ADBREQ_NOSEND
comma
l_int|1
comma
id|ADB_READREG
c_func
(paren
id|device
comma
l_int|0
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|req.next
op_assign
id|current_req
suffix:semicolon
id|current_req
op_assign
op_amp
id|req
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|macii_start
c_func
(paren
)paren
suffix:semicolon
id|in_poll
op_decrement
suffix:semicolon
)brace
multiline_comment|/* Send an ADB retransmit (Talk, appended to the request queue) */
DECL|function|macii_retransmit
r_static
r_void
id|macii_retransmit
c_func
(paren
r_int
id|device
)paren
(brace
r_static
r_int
id|in_retransmit
op_assign
l_int|0
suffix:semicolon
r_static
r_struct
id|adb_request
id|rt
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|in_retransmit
)paren
id|printk
c_func
(paren
l_string|&quot;macii_retransmit: double retransmit!&bslash;n&quot;
)paren
suffix:semicolon
id|in_retransmit
op_increment
suffix:semicolon
id|adb_request
c_func
(paren
op_amp
id|rt
comma
l_int|NULL
comma
id|ADBREQ_REPLY
op_or
id|ADBREQ_NOSEND
comma
l_int|1
comma
id|ADB_READREG
c_func
(paren
id|device
comma
l_int|0
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_req
op_ne
l_int|NULL
)paren
(brace
id|last_req-&gt;next
op_assign
op_amp
id|rt
suffix:semicolon
id|last_req
op_assign
op_amp
id|rt
suffix:semicolon
)brace
r_else
(brace
id|current_req
op_assign
op_amp
id|rt
suffix:semicolon
id|last_req
op_assign
op_amp
id|rt
suffix:semicolon
)brace
r_if
c_cond
(paren
id|macii_state
op_eq
id|idle
)paren
id|macii_start
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|in_retransmit
op_decrement
suffix:semicolon
)brace
multiline_comment|/* Send an ADB request; if sync, poll out the reply &squot;till it&squot;s done */
DECL|function|macii_send_request
r_static
r_int
id|macii_send_request
c_func
(paren
r_struct
id|adb_request
op_star
id|req
comma
r_int
id|sync
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|macii_write
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
id|sync
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|req-&gt;complete
)paren
id|macii_poll
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Send an ADB request */
DECL|function|macii_write
r_static
r_int
id|macii_write
c_func
(paren
r_struct
id|adb_request
op_star
id|req
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;nbytes
OL
l_int|2
op_logical_or
id|req-&gt;data
(braket
l_int|0
)braket
op_ne
id|ADB_PACKET
)paren
(brace
id|req-&gt;complete
op_assign
l_int|1
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|req-&gt;next
op_assign
l_int|0
suffix:semicolon
id|req-&gt;sent
op_assign
l_int|0
suffix:semicolon
id|req-&gt;complete
op_assign
l_int|0
suffix:semicolon
id|req-&gt;reply_len
op_assign
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_req
op_ne
l_int|NULL
)paren
(brace
id|last_req-&gt;next
op_assign
id|req
suffix:semicolon
id|last_req
op_assign
id|req
suffix:semicolon
)brace
r_else
(brace
id|current_req
op_assign
id|req
suffix:semicolon
id|last_req
op_assign
id|req
suffix:semicolon
r_if
c_cond
(paren
id|macii_state
op_eq
id|idle
)paren
id|macii_start
c_func
(paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Start auto-polling */
DECL|function|macii_autopoll
r_static
r_int
id|macii_autopoll
c_func
(paren
r_int
id|devs
)paren
(brace
multiline_comment|/* Just ping a random default address */
r_if
c_cond
(paren
op_logical_neg
(paren
id|current_req
op_logical_or
id|retry_req
)paren
)paren
id|macii_retransmit
c_func
(paren
(paren
id|last_active
template_param
l_int|0
)paren
ques
c_cond
id|last_active
suffix:colon
l_int|3
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Prod the chip without interrupts */
DECL|function|macii_poll
r_static
r_void
id|macii_poll
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|via
(braket
id|IFR
)braket
op_amp
id|SR_INT
)paren
id|macii_interrupt
c_func
(paren
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset the bus */
DECL|function|macii_reset_bus
r_static
r_int
id|macii_reset_bus
c_func
(paren
r_void
)paren
(brace
r_static
r_struct
id|adb_request
id|req
suffix:semicolon
multiline_comment|/* Command = 0, Address = ignored */
id|adb_request
c_func
(paren
op_amp
id|req
comma
l_int|NULL
comma
l_int|0
comma
l_int|1
comma
id|ADB_BUSRESET
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Start sending ADB packet */
DECL|function|macii_start
r_static
r_void
id|macii_start
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|adb_request
op_star
id|req
suffix:semicolon
id|req
op_assign
id|current_req
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
r_return
suffix:semicolon
multiline_comment|/* assert macii_state == idle */
r_if
c_cond
(paren
id|macii_state
op_ne
id|idle
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;macii_start: called while driver busy (%p %x %x)!&bslash;n&quot;
comma
id|req
comma
id|macii_state
comma
(paren
id|uint
)paren
id|via1
(braket
id|B
)braket
op_amp
(paren
id|ST_MASK
op_or
id|TREQ
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * IRQ signaled ?? (means ADB controller wants to send, or might &n;&t; * be end of packet if we were reading)&n;&t; */
r_if
c_cond
(paren
(paren
id|via
(braket
id|B
)braket
op_amp
id|TREQ
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;FIXME - we need to restart this on a timer&n;&t;&t; *&t;or a collision at boot hangs us.&n;&t;&t; *&t;Never set macii_state to idle here, or macii_start &n;&t;&t; *&t;won&squot;t be called again from send_request!&n;&t;&t; *&t;(need to re-check other cases ...)&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * if the interrupt handler set the need_poll&n;&t;&t; * flag, it&squot;s hopefully a SRQ poll or re-Talk&n;&t;&t; * so we try to send here anyway&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|need_poll
)paren
(brace
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;macii_start: device busy - retry %p state %d status %x!&bslash;n&quot;
comma
id|req
comma
id|macii_state
comma
(paren
id|uint
)paren
id|via
(braket
id|B
)braket
op_amp
(paren
id|ST_MASK
op_or
id|TREQ
)paren
)paren
suffix:semicolon
id|retry_req
op_assign
id|req
suffix:semicolon
multiline_comment|/* set ADB status here ? */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|need_poll
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Another retry pending? (sanity check)&n;&t; */
r_if
c_cond
(paren
id|retry_req
)paren
(brace
id|retry_req
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Now send it. Be careful though, that first byte of the request */
multiline_comment|/* is actually ADB_PACKET; the real data begins at index 1!&t;  */
multiline_comment|/* store command byte */
id|command_byte
op_assign
id|req-&gt;data
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Output mode */
id|via
(braket
id|ACR
)braket
op_or_assign
id|SR_OUT
suffix:semicolon
multiline_comment|/* Load data */
id|via
(braket
id|SR
)braket
op_assign
id|req-&gt;data
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* set ADB state to &squot;command&squot; */
id|via
(braket
id|B
)braket
op_assign
(paren
id|via
(braket
id|B
)braket
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_CMD
suffix:semicolon
id|macii_state
op_assign
id|sent_first_byte
suffix:semicolon
id|data_index
op_assign
l_int|2
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The notorious ADB interrupt handler - does all of the protocol handling, &n; * except for starting new send operations. Relies heavily on the ADB &n; * controller sending and receiving data, thereby generating SR interrupts&n; * for us. This means there has to be always activity on the ADB bus, otherwise&n; * the whole process dies and has to be re-kicked by sending TALK requests ...&n; * CUDA-based Macs seem to solve this with the autopoll option, for MacII-type&n; * ADB the problem isn&squot;t solved yet (retransmit of the latest active TALK seems&n; * a good choice; either on timeout or on a timer interrupt).&n; *&n; * The basic ADB state machine was left unchanged from the original MacII code&n; * by Alan Cox, which was based on the CUDA driver for PowerMac. &n; * The syntax of the ADB status lines seems to be totally different on MacII, &n; * though. MacII uses the states Command -&gt; Even -&gt; Odd -&gt; Even -&gt;...-&gt; Idle for&n; * sending, and Idle -&gt; Even -&gt; Odd -&gt; Even -&gt;...-&gt; Idle for receiving. Start &n; * and end of a receive packet are signaled by asserting /IRQ on the interrupt&n; * line. Timeouts are signaled by a sequence of 4 0xFF, with /IRQ asserted on &n; * every other byte. SRQ is probably signaled by 3 or more 0xFF tacked on the &n; * end of a packet. (Thanks to Guido Koerber for eavesdropping on the ADB &n; * protocol with a logic analyzer!!)&n; *&n; * Note: As of 21/10/97, the MacII ADB part works including timeout detection&n; * and retransmit (Talk to the last active device).&n; */
DECL|function|macii_interrupt
r_void
id|macii_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|x
comma
id|adbdir
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|adb_request
op_star
id|req
suffix:semicolon
id|last_status
op_assign
id|status
suffix:semicolon
multiline_comment|/* prevent races due to SCSI enabling ints */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver_running
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|driver_running
op_assign
l_int|1
suffix:semicolon
id|status
op_assign
id|via
(braket
id|B
)braket
op_amp
(paren
id|ST_MASK
op_or
id|TREQ
)paren
suffix:semicolon
id|adbdir
op_assign
id|via
(braket
id|ACR
)braket
op_amp
id|SR_OUT
suffix:semicolon
r_switch
c_cond
(paren
id|macii_state
)paren
(brace
r_case
id|idle
suffix:colon
id|x
op_assign
id|via
(braket
id|SR
)braket
suffix:semicolon
id|first_byte
op_assign
id|x
suffix:semicolon
multiline_comment|/* set ADB state = even for first data byte */
id|via
(braket
id|B
)braket
op_assign
(paren
id|via
(braket
id|B
)braket
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_EVEN
suffix:semicolon
id|reply_buf
(braket
l_int|0
)braket
op_assign
id|first_byte
suffix:semicolon
multiline_comment|/* was command_byte?? */
id|reply_ptr
op_assign
id|reply_buf
op_plus
l_int|1
suffix:semicolon
id|reply_len
op_assign
l_int|1
suffix:semicolon
id|prefix_len
op_assign
l_int|1
suffix:semicolon
id|reading_reply
op_assign
l_int|0
suffix:semicolon
id|macii_state
op_assign
id|reading
suffix:semicolon
r_break
suffix:semicolon
r_case
id|awaiting_reply
suffix:colon
multiline_comment|/* handshake etc. for II ?? */
id|x
op_assign
id|via
(braket
id|SR
)braket
suffix:semicolon
id|first_byte
op_assign
id|x
suffix:semicolon
multiline_comment|/* set ADB state = even for first data byte */
id|via
(braket
id|B
)braket
op_assign
(paren
id|via
(braket
id|B
)braket
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_EVEN
suffix:semicolon
id|current_req-&gt;reply
(braket
l_int|0
)braket
op_assign
id|first_byte
suffix:semicolon
id|reply_ptr
op_assign
id|current_req-&gt;reply
op_plus
l_int|1
suffix:semicolon
id|reply_len
op_assign
l_int|1
suffix:semicolon
id|prefix_len
op_assign
l_int|1
suffix:semicolon
id|reading_reply
op_assign
l_int|1
suffix:semicolon
id|macii_state
op_assign
id|reading
suffix:semicolon
r_break
suffix:semicolon
r_case
id|sent_first_byte
suffix:colon
id|req
op_assign
id|current_req
suffix:semicolon
multiline_comment|/* maybe we&squot;re already done (Talk, or Poll)? */
r_if
c_cond
(paren
id|data_index
op_ge
id|req-&gt;nbytes
)paren
(brace
multiline_comment|/* reset to shift in */
multiline_comment|/* If it&squot;s a Listen command and we&squot;re done, someone&squot;s doing weird stuff. */
r_if
c_cond
(paren
(paren
(paren
id|command_byte
op_amp
l_int|0x0C
)paren
op_eq
l_int|0x08
)paren
op_logical_and
(paren
id|console_loglevel
op_eq
l_int|10
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;macii_interrupt: listen command with no data: %x!&bslash;n&quot;
comma
id|command_byte
)paren
suffix:semicolon
multiline_comment|/* reset to shift in */
id|via
(braket
id|ACR
)braket
op_and_assign
op_complement
id|SR_OUT
suffix:semicolon
id|x
op_assign
id|via
(braket
id|SR
)braket
suffix:semicolon
multiline_comment|/* set ADB state idle - might get SRQ */
id|via
(braket
id|B
)braket
op_assign
(paren
id|via
(braket
id|B
)braket
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_IDLE
suffix:semicolon
id|req-&gt;sent
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;reply_expected
)paren
(brace
id|macii_state
op_assign
id|awaiting_reply
suffix:semicolon
)brace
r_else
(brace
id|req-&gt;complete
op_assign
l_int|1
suffix:semicolon
id|current_req
op_assign
id|req-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;done
)paren
(paren
op_star
id|req-&gt;done
)paren
(paren
id|req
)paren
suffix:semicolon
id|macii_state
op_assign
id|idle
suffix:semicolon
r_if
c_cond
(paren
id|current_req
op_logical_or
id|retry_req
)paren
id|macii_start
c_func
(paren
)paren
suffix:semicolon
r_else
id|macii_retransmit
c_func
(paren
(paren
id|command_byte
op_amp
l_int|0xF0
)paren
op_rshift
l_int|4
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* SR already set to shift out; send byte */
id|via
(braket
id|SR
)braket
op_assign
id|current_req-&gt;data
(braket
id|data_index
op_increment
)braket
suffix:semicolon
multiline_comment|/* set state to ST_EVEN (first byte was: ST_CMD) */
id|via
(braket
id|B
)braket
op_assign
(paren
id|via
(braket
id|B
)braket
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_EVEN
suffix:semicolon
id|macii_state
op_assign
id|sending
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|sending
suffix:colon
id|req
op_assign
id|current_req
suffix:semicolon
r_if
c_cond
(paren
id|data_index
op_ge
id|req-&gt;nbytes
)paren
(brace
multiline_comment|/* reset to shift in */
id|via
(braket
id|ACR
)braket
op_and_assign
op_complement
id|SR_OUT
suffix:semicolon
id|x
op_assign
id|via
(braket
id|SR
)braket
suffix:semicolon
multiline_comment|/* set ADB state idle - might get SRQ */
id|via
(braket
id|B
)braket
op_assign
(paren
id|via
(braket
id|B
)braket
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_IDLE
suffix:semicolon
id|req-&gt;sent
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;reply_expected
)paren
(brace
id|macii_state
op_assign
id|awaiting_reply
suffix:semicolon
)brace
r_else
(brace
id|req-&gt;complete
op_assign
l_int|1
suffix:semicolon
id|current_req
op_assign
id|req-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;done
)paren
(paren
op_star
id|req-&gt;done
)paren
(paren
id|req
)paren
suffix:semicolon
id|macii_state
op_assign
id|idle
suffix:semicolon
r_if
c_cond
(paren
id|current_req
op_logical_or
id|retry_req
)paren
id|macii_start
c_func
(paren
)paren
suffix:semicolon
r_else
id|macii_retransmit
c_func
(paren
(paren
id|command_byte
op_amp
l_int|0xF0
)paren
op_rshift
l_int|4
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|via
(braket
id|SR
)braket
op_assign
id|req-&gt;data
(braket
id|data_index
op_increment
)braket
suffix:semicolon
multiline_comment|/* invert state bits, toggle ODD/EVEN */
id|via
(braket
id|B
)braket
op_xor_assign
id|ST_MASK
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|reading
suffix:colon
multiline_comment|/* timeout / SRQ handling for II hw */
r_if
c_cond
(paren
(paren
id|first_byte
op_eq
l_int|0xFF
op_logical_and
(paren
id|reply_len
op_minus
id|prefix_len
)paren
op_eq
l_int|2
op_logical_and
id|memcmp
c_func
(paren
id|reply_ptr
op_minus
l_int|2
comma
l_string|&quot;&bslash;xFF&bslash;xFF&quot;
comma
l_int|2
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
(paren
id|reply_len
op_minus
id|prefix_len
)paren
op_eq
l_int|3
op_logical_and
id|memcmp
c_func
(paren
id|reply_ptr
op_minus
l_int|3
comma
l_string|&quot;&bslash;xFF&bslash;xFF&bslash;xFF&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * possible timeout (in fact, most probably a &n;&t;&t;&t;&t; * timeout, since SRQ can&squot;t be signaled without&n;&t;&t;&t;&t; * transfer on the bus).&n;&t;&t;&t;&t; * The last three bytes seen were FF, together &n;&t;&t;&t;&t; * with the starting byte (in case we started&n;&t;&t;&t;&t; * on &squot;idle&squot; or &squot;awaiting_reply&squot;) this probably&n;&t;&t;&t;&t; * makes four. So this is mostl likely #5!&n;&t;&t;&t;&t; * The timeout signal is a pattern 1 0 1 0 0..&n;&t;&t;&t;&t; * on /INT, meaning we missed it :-(&n;&t;&t;&t;&t; */
id|x
op_assign
id|via
(braket
id|SR
)braket
suffix:semicolon
r_if
c_cond
(paren
id|x
op_ne
l_int|0xFF
)paren
id|printk
c_func
(paren
l_string|&quot;macii_interrupt: mistaken timeout/SRQ!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|TREQ
)paren
op_eq
(paren
id|last_status
op_amp
id|TREQ
)paren
)paren
(brace
multiline_comment|/* Not a timeout. Unsolicited SRQ? weird. */
multiline_comment|/* Terminate the SRQ packet and poll */
id|need_poll
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* There&squot;s no packet to get, so reply is blank */
id|via
(braket
id|B
)braket
op_xor_assign
id|ST_MASK
suffix:semicolon
id|reply_ptr
op_sub_assign
(paren
id|reply_len
op_minus
id|prefix_len
)paren
suffix:semicolon
id|reply_len
op_assign
id|prefix_len
suffix:semicolon
id|macii_state
op_assign
id|read_done
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* end timeout / SRQ handling for II hw. */
r_if
c_cond
(paren
(paren
id|reply_len
op_minus
id|prefix_len
)paren
OG
l_int|3
op_logical_and
id|memcmp
c_func
(paren
id|reply_ptr
op_minus
l_int|3
comma
l_string|&quot;&bslash;xFF&bslash;xFF&bslash;xFF&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* SRQ tacked on data packet */
multiline_comment|/* Terminate the packet (SRQ never ends) */
id|x
op_assign
id|via
(braket
id|SR
)braket
suffix:semicolon
id|macii_state
op_assign
id|read_done
suffix:semicolon
id|reply_len
op_sub_assign
l_int|3
suffix:semicolon
id|reply_ptr
op_sub_assign
l_int|3
suffix:semicolon
id|need_poll
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* need to continue; next byte not seen else */
)brace
r_else
(brace
multiline_comment|/* Sanity check */
r_if
c_cond
(paren
id|reply_len
OG
l_int|15
)paren
id|reply_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* read byte */
id|x
op_assign
id|via
(braket
id|SR
)braket
suffix:semicolon
op_star
id|reply_ptr
op_assign
id|x
suffix:semicolon
id|reply_ptr
op_increment
suffix:semicolon
id|reply_len
op_increment
suffix:semicolon
)brace
multiline_comment|/* The usual handshake ... */
multiline_comment|/*&n;&t;&t;&t; * NetBSD hints that the next to last byte &n;&t;&t;&t; * is sent with IRQ !! &n;&t;&t;&t; * Guido found out it&squot;s the last one (0x0),&n;&t;&t;&t; * but IRQ should be asserted already.&n;&t;&t;&t; * Problem with timeout detection: First&n;&t;&t;&t; * transition to /IRQ might be second &n;&t;&t;&t; * byte of timeout packet! &n;&t;&t;&t; * Timeouts are signaled by 4x FF.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|TREQ
)paren
op_logical_and
(paren
id|x
op_eq
l_int|0x00
)paren
)paren
(brace
multiline_comment|/* != 0xFF */
multiline_comment|/* invert state bits, toggle ODD/EVEN */
id|via
(braket
id|B
)braket
op_xor_assign
id|ST_MASK
suffix:semicolon
multiline_comment|/* adjust packet length */
id|reply_len
op_decrement
suffix:semicolon
id|reply_ptr
op_decrement
suffix:semicolon
id|macii_state
op_assign
id|read_done
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* not caught: ST_CMD */
multiline_comment|/* required for re-entry &squot;reading&squot;! */
r_if
c_cond
(paren
(paren
id|status
op_amp
id|ST_MASK
)paren
op_eq
id|ST_IDLE
)paren
(brace
multiline_comment|/* (in)sanity check - set even */
id|via
(braket
id|B
)braket
op_assign
(paren
id|via
(braket
id|B
)braket
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_EVEN
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* invert state bits */
id|via
(braket
id|B
)braket
op_xor_assign
id|ST_MASK
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|read_done
suffix:colon
id|x
op_assign
id|via
(braket
id|SR
)braket
suffix:semicolon
r_if
c_cond
(paren
id|reading_reply
)paren
(brace
id|req
op_assign
id|current_req
suffix:semicolon
id|req-&gt;reply_len
op_assign
id|reply_ptr
op_minus
id|req-&gt;reply
suffix:semicolon
id|req-&gt;complete
op_assign
l_int|1
suffix:semicolon
id|current_req
op_assign
id|req-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;done
)paren
(paren
op_star
id|req-&gt;done
)paren
(paren
id|req
)paren
suffix:semicolon
)brace
r_else
(brace
id|adb_input
c_func
(paren
id|reply_buf
comma
id|reply_ptr
op_minus
id|reply_buf
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * remember this device ID; it&squot;s the latest we got a &n;&t;&t;&t; * reply from!&n;&t;&t;&t; */
id|last_reply
op_assign
id|command_byte
suffix:semicolon
id|last_active
op_assign
(paren
id|command_byte
op_amp
l_int|0xF0
)paren
op_rshift
l_int|4
suffix:semicolon
multiline_comment|/* SRQ seen before, initiate poll now */
r_if
c_cond
(paren
id|need_poll
)paren
(brace
id|macii_state
op_assign
id|idle
suffix:semicolon
id|macii_queue_poll
c_func
(paren
)paren
suffix:semicolon
id|need_poll
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* /IRQ seen, so the ADB controller has data for us */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|TREQ
)paren
)paren
(brace
multiline_comment|/* set ADB state to idle */
id|via
(braket
id|B
)braket
op_assign
(paren
id|via
(braket
id|B
)braket
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_IDLE
suffix:semicolon
id|macii_state
op_assign
id|reading
suffix:semicolon
id|reply_buf
(braket
l_int|0
)braket
op_assign
id|command_byte
suffix:semicolon
id|reply_ptr
op_assign
id|reply_buf
op_plus
l_int|1
suffix:semicolon
id|reply_len
op_assign
l_int|1
suffix:semicolon
id|prefix_len
op_assign
l_int|1
suffix:semicolon
id|reading_reply
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* no IRQ, send next packet or wait */
id|macii_state
op_assign
id|idle
suffix:semicolon
r_if
c_cond
(paren
id|current_req
)paren
id|macii_start
c_func
(paren
)paren
suffix:semicolon
r_else
id|macii_retransmit
c_func
(paren
id|last_active
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* reset mutex and interrupts */
id|driver_running
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
eof
