multiline_comment|/*&n;   * Copyright 1996 The Australian National University.&n;   * Copyright 1996 Fujitsu Laboratories Limited&n;   * &n;   * This software may be distributed under the terms of the Gnu&n;   * Public License version 2 or later&n;  */
multiline_comment|/* &n; * ap.c - Single AP1000 block driver.&n; *&n; * (C) dwalsh, Pious project, DCS, ANU 1996&n; *&n; * This block driver is designed to simply to perform&n; * io operations to the hosts file system. &n; *&n; * Heavily modified by tridge&n; *&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/ext2_fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/ap1000/apservice.h&gt;
DECL|macro|AP_DEBUG
mdefine_line|#define AP_DEBUG 0
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR APBLOCK_MAJOR
DECL|macro|AP_DRIVER
mdefine_line|#define AP_DRIVER 1
macro_line|#include &lt;linux/blk.h&gt;
DECL|macro|NUM_APDEVS
mdefine_line|#define NUM_APDEVS 8
DECL|macro|MAX_REQUESTS
mdefine_line|#define MAX_REQUESTS 1
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|busy_wait
)paren
suffix:semicolon
DECL|variable|ap_blocksizes
r_static
r_int
id|ap_blocksizes
(braket
id|NUM_APDEVS
)braket
suffix:semicolon
DECL|variable|ap_length
r_static
r_int
id|ap_length
(braket
id|NUM_APDEVS
)braket
suffix:semicolon
DECL|variable|ap_fds
r_static
r_int
id|ap_fds
(braket
id|NUM_APDEVS
)braket
suffix:semicolon
DECL|macro|SECTOR_BLOCK_SHIFT
mdefine_line|#define SECTOR_BLOCK_SHIFT 9
DECL|macro|AP_BLOCK_SHIFT
mdefine_line|#define AP_BLOCK_SHIFT 12 /* 4k blocks */
DECL|macro|AP_BLOCK_SIZE
mdefine_line|#define AP_BLOCK_SIZE (1&lt;&lt;AP_BLOCK_SHIFT)
DECL|variable|request_count
r_static
r_volatile
r_int
id|request_count
op_assign
l_int|0
suffix:semicolon
DECL|function|ap_release
r_static
r_void
id|ap_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|function|ap_request
r_static
r_void
id|ap_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_struct
id|cap_request
id|creq
suffix:semicolon
r_int
r_int
id|minor
suffix:semicolon
r_int
id|offset
comma
id|len
suffix:semicolon
r_struct
id|request
op_star
id|req
suffix:semicolon
r_if
c_cond
(paren
id|request_count
op_ge
id|MAX_REQUESTS
)paren
r_return
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|CURRENT
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
op_ne
id|MAJOR_NR
)paren
(brace
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: request list destroyed&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT-&gt;bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|CURRENT-&gt;bh
)paren
)paren
(brace
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
)brace
)brace
id|req
op_assign
id|CURRENT
suffix:semicolon
id|minor
op_assign
id|MINOR
c_func
(paren
id|req-&gt;rq_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|NUM_APDEVS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;apblock: request for invalid minor %d&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|offset
op_assign
id|req-&gt;sector
suffix:semicolon
id|len
op_assign
id|req-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_plus
id|len
)paren
OG
id|ap_length
(braket
id|minor
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;apblock: request for invalid sectors %d -&gt; %d&bslash;n&quot;
comma
id|offset
comma
id|offset
op_plus
id|len
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ap_fds
(braket
id|minor
)braket
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;apblock: minor %d not open&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/* convert to our units */
id|offset
op_lshift_assign
id|SECTOR_BLOCK_SHIFT
suffix:semicolon
id|len
op_lshift_assign
id|SECTOR_BLOCK_SHIFT
suffix:semicolon
multiline_comment|/* setup a request for the host */
id|creq.cid
op_assign
id|mpp_cid
c_func
(paren
)paren
suffix:semicolon
id|creq.size
op_assign
r_sizeof
(paren
id|creq
)paren
suffix:semicolon
id|creq.header
op_assign
l_int|0
suffix:semicolon
id|creq.data
(braket
l_int|0
)braket
op_assign
(paren
r_int
)paren
(paren
id|req
)paren
suffix:semicolon
id|creq.data
(braket
l_int|1
)braket
op_assign
id|ap_fds
(braket
id|minor
)braket
suffix:semicolon
id|creq.data
(braket
l_int|2
)braket
op_assign
id|offset
suffix:semicolon
id|creq.data
(braket
l_int|3
)braket
op_assign
id|len
suffix:semicolon
r_switch
c_cond
(paren
id|req-&gt;cmd
)paren
(brace
r_case
id|READ
suffix:colon
macro_line|#if AP_DEBUG
id|printk
c_func
(paren
l_string|&quot;apblock: read req=0x%x len=%d offset=%d&bslash;n&quot;
comma
id|req
comma
id|len
comma
id|offset
)paren
suffix:semicolon
macro_line|#endif
id|creq.type
op_assign
id|REQ_BREAD
suffix:semicolon
r_if
c_cond
(paren
id|bif_queue
c_func
(paren
op_amp
id|creq
comma
l_int|0
comma
l_int|0
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|WRITE
suffix:colon
macro_line|#if AP_DEBUG
id|printk
c_func
(paren
l_string|&quot;apblock: write req=0x%x len=%d offset=%d&bslash;n&quot;
comma
id|req
comma
id|len
comma
id|offset
)paren
suffix:semicolon
macro_line|#endif
id|creq.type
op_assign
id|REQ_BWRITE
suffix:semicolon
id|creq.size
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|bif_queue_nocopy
c_func
(paren
op_amp
id|creq
comma
id|req-&gt;buffer
comma
id|creq.size
op_minus
r_sizeof
(paren
id|creq
)paren
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;apblock: unknown ap op %d&bslash;n&quot;
comma
id|req-&gt;cmd
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|request_count
OL
id|MAX_REQUESTS
)paren
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/* this is called by ap1000/bif.c when a read/write has completed */
DECL|function|ap_complete
r_void
id|ap_complete
c_func
(paren
r_struct
id|cap_request
op_star
id|creq
)paren
(brace
macro_line|#if AP_DEBUG
r_struct
id|request
op_star
id|req
op_assign
(paren
r_struct
id|request
op_star
)paren
(paren
id|creq-&gt;data
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;request 0x%x complete&bslash;n&quot;
comma
id|req
)paren
suffix:semicolon
macro_line|#endif
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|request_count
op_decrement
suffix:semicolon
id|ap_request
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* this is called by ap1000/bif.c to find a buffer to put a BREAD into &n; using DMA */
DECL|function|ap_buffer
r_char
op_star
id|ap_buffer
c_func
(paren
r_struct
id|cap_request
op_star
id|creq
)paren
(brace
r_struct
id|request
op_star
id|req
op_assign
(paren
r_struct
id|request
op_star
)paren
(paren
id|creq-&gt;data
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|req-&gt;buffer
suffix:semicolon
)brace
DECL|function|ap_open
r_static
r_int
id|ap_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|cap_request
id|creq
suffix:semicolon
r_int
id|minor
suffix:semicolon
id|minor
op_assign
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
macro_line|#if AP_DEBUG
id|printk
c_func
(paren
l_string|&quot;ap_open: minor=%x&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|minor
op_ge
id|NUM_APDEVS
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* if its already open then don&squot;t do anything */
r_if
c_cond
(paren
id|ap_fds
(braket
id|minor
)braket
op_ne
op_minus
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* send the open request to the front end */
id|creq.cid
op_assign
id|mpp_cid
c_func
(paren
)paren
suffix:semicolon
id|creq.type
op_assign
id|REQ_BOPEN
suffix:semicolon
id|creq.header
op_assign
l_int|0
suffix:semicolon
id|creq.size
op_assign
r_sizeof
(paren
id|creq
)paren
suffix:semicolon
id|creq.data
(braket
l_int|0
)braket
op_assign
id|minor
suffix:semicolon
id|bif_queue
c_func
(paren
op_amp
id|creq
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* wait for the reply */
r_while
c_loop
(paren
id|ap_fds
(braket
id|minor
)braket
op_eq
op_minus
l_int|1
)paren
id|sleep_on
c_func
(paren
op_amp
id|busy_wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ap_ioctl
r_static
r_int
id|ap_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|inode
op_logical_or
op_logical_neg
id|inode-&gt;i_rdev
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|BLKGETSIZE
suffix:colon
multiline_comment|/* Return device size */
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ap_length
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this is called by ap1000/bif.c when a open reply comes in */
DECL|function|ap_open_reply
r_void
id|ap_open_reply
c_func
(paren
r_struct
id|cap_request
op_star
id|creq
)paren
(brace
r_int
id|minor
op_assign
id|creq-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
id|ap_fds
(braket
id|minor
)braket
op_assign
id|creq-&gt;data
(braket
l_int|1
)braket
suffix:semicolon
id|ap_length
(braket
id|minor
)braket
op_assign
id|creq-&gt;data
(braket
l_int|2
)braket
op_rshift
id|SECTOR_BLOCK_SHIFT
suffix:semicolon
macro_line|#if AP_DEBUG
id|printk
c_func
(paren
l_string|&quot;ap opened minor %d length=%d fd=%d&bslash;n&quot;
comma
id|minor
comma
id|ap_length
(braket
id|minor
)braket
comma
id|ap_fds
(braket
id|minor
)braket
)paren
suffix:semicolon
macro_line|#endif
id|wake_up
c_func
(paren
op_amp
id|busy_wait
)paren
suffix:semicolon
)brace
DECL|variable|ap_fops
r_static
r_struct
id|block_device_operations
id|ap_fops
op_assign
(brace
id|open
suffix:colon
id|ap_open
comma
id|release
suffix:colon
id|ap_release
comma
id|ioctl
suffix:colon
id|ap_ioctl
comma
)brace
suffix:semicolon
DECL|function|ap_init
r_int
id|ap_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_static
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|done
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;apblock&quot;
comma
op_amp
id|ap_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ap: unable to get major %d for ap block dev&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;ap_init: register dev %d&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
op_amp
id|ap_request
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_APDEVS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ap_blocksizes
(braket
id|i
)braket
op_assign
id|AP_BLOCK_SIZE
suffix:semicolon
id|ap_length
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|ap_fds
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|ap_blocksizes
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|32
suffix:semicolon
multiline_comment|/* 16k read ahead */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_APDEVS
suffix:semicolon
id|i
op_increment
)paren
id|register_disk
c_func
(paren
id|NILL
comma
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|i
)paren
comma
l_int|1
comma
op_amp
id|ap_fops
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* loadable module support */
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|error
op_assign
id|ap_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;APBLOCK: Loaded as module.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Before freeing the module, invalidate all of the protected buffers! */
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_APDEVS
suffix:semicolon
id|i
op_increment
)paren
id|invalidate_buffers
c_func
(paren
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|i
)paren
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;apblock&quot;
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif  /* MODULE */
eof
