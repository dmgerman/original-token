multiline_comment|/*&n; *  $Id: timer.c,v 1.3 2000/05/06 00:52:39 kai Exp $&n; *  Copyright (C) 1996  SpellCaster Telecommunications Inc.&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; *  For more information, please contact gpl-info@spellcast.com or write:&n; *&n; *     SpellCaster Telecommunications Inc.&n; *     5621 Finch Avenue East, Unit #3&n; *     Scarborough, Ontario  Canada&n; *     M1B 2T9&n; *     +1 (416) 297-8565&n; *     +1 (416) 297-6433 Facsimile&n; */
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &quot;includes.h&quot;
macro_line|#include &quot;hardware.h&quot;
macro_line|#include &quot;message.h&quot;
macro_line|#include &quot;card.h&quot;
r_extern
id|board
op_star
id|adapter
(braket
)braket
suffix:semicolon
r_extern
r_void
id|flushreadfifo
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_int
id|startproc
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_int
id|indicate_status
c_func
(paren
r_int
comma
r_int
comma
r_int
r_int
comma
r_char
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sendmessage
c_func
(paren
r_int
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * Write the proper values into the I/O ports following a reset&n; */
DECL|function|setup_ports
r_void
id|setup_ports
c_func
(paren
r_int
id|card
)paren
(brace
id|outb
c_func
(paren
(paren
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|rambase
op_rshift
l_int|12
)paren
comma
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|ioport
(braket
id|EXP_BASE
)braket
)paren
suffix:semicolon
multiline_comment|/* And the IRQ */
id|outb
c_func
(paren
(paren
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|interrupt
op_or
l_int|0x80
)paren
comma
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|ioport
(braket
id|IRQ_SELECT
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Timed function to check the status of a previous reset&n; * Must be very fast as this function runs in the context of&n; * an interrupt handler.&n; *&n; * Setup the ioports for the board that were cleared by the reset.&n; * Then, check to see if the signate has been set. Next, set the&n; * signature to a known value and issue a startproc if needed.&n; */
DECL|function|check_reset
r_void
id|check_reset
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|sig
suffix:semicolon
r_int
id|card
op_assign
(paren
r_int
r_int
)paren
id|data
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;%s: check_timer timer called&bslash;n&quot;
comma
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|devicename
)paren
suffix:semicolon
multiline_comment|/* Setup the io ports */
id|setup_ports
c_func
(paren
id|card
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|ioport
(braket
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|shmem_pgport
)braket
comma
(paren
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|shmem_magic
op_rshift
l_int|14
)paren
op_or
l_int|0x80
)paren
suffix:semicolon
id|sig
op_assign
(paren
r_int
r_int
)paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|rambase
op_plus
id|SIG_OFFSET
)paren
)paren
suffix:semicolon
multiline_comment|/* check the signature */
r_if
c_cond
(paren
id|sig
op_eq
id|SIGNATURE
)paren
(brace
id|flushreadfifo
c_func
(paren
id|card
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* See if we need to do a startproc */
r_if
c_cond
(paren
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|StartOnReset
)paren
id|startproc
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
r_else
(brace
id|pr_debug
c_func
(paren
l_string|&quot;%s: No signature yet, waiting another %d jiffies.&bslash;n&quot;
comma
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|devicename
comma
id|CHECKRESET_TIME
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|reset_timer
comma
id|jiffies
op_plus
id|CHECKRESET_TIME
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Timed function to check the status of a previous reset&n; * Must be very fast as this function runs in the context of&n; * an interrupt handler.&n; *&n; * Send check adapter-&gt;phystat to see if the channels are up&n; * If they are, tell ISDN4Linux that the board is up. If not,&n; * tell IADN4Linux that it is up. Always reset the timer to&n; * fire again (endless loop).&n; */
DECL|function|check_phystat
r_void
id|check_phystat
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|card
op_assign
(paren
r_int
r_int
)paren
id|data
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;%s: Checking status...&bslash;n&quot;
comma
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|devicename
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * check the results of the last PhyStat and change only if&n;&t; * has changed drastically&n;&t; */
r_if
c_cond
(paren
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|nphystat
op_logical_and
op_logical_neg
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|phystat
)paren
(brace
multiline_comment|/* All is well */
id|pr_debug
c_func
(paren
l_string|&quot;PhyStat transition to RUN&bslash;n&quot;
)paren
suffix:semicolon
id|pr_info
c_func
(paren
l_string|&quot;%s: Switch contacted, transmitter enabled&bslash;n&quot;
comma
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|devicename
)paren
suffix:semicolon
id|indicate_status
c_func
(paren
id|card
comma
id|ISDN_STAT_RUN
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|nphystat
op_logical_and
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|phystat
)paren
(brace
multiline_comment|/* All is not well */
id|pr_debug
c_func
(paren
l_string|&quot;PhyStat transition to STOP&bslash;n&quot;
)paren
suffix:semicolon
id|pr_info
c_func
(paren
l_string|&quot;%s: Switch connection lost, transmitter disabled&bslash;n&quot;
comma
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|devicename
)paren
suffix:semicolon
id|indicate_status
c_func
(paren
id|card
comma
id|ISDN_STAT_STOP
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|phystat
op_assign
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|nphystat
suffix:semicolon
multiline_comment|/* Reinitialize the timer */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|adapter
(braket
id|card
)braket
op_member_access_from_pointer
id|stat_timer
comma
id|jiffies
op_plus
id|CHECKSTAT_TIME
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Send a new cePhyStatus message */
id|sendmessage
c_func
(paren
id|card
comma
id|CEPID
comma
id|ceReqTypePhy
comma
id|ceReqClass2
comma
id|ceReqPhyStatus
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * When in trace mode, this callback is used to swap the working shared&n; * RAM page to the trace page(s) and process all received messages. It&n; * must be called often enough to get all of the messages out of RAM before&n; * it loops around.&n; * Trace messages are &bslash;n terminated strings.&n; * We output the messages in 64 byte chunks through readstat. Each chunk&n; * is scanned for a &bslash;n followed by a time stamp. If the timerstamp is older&n; * than the current time, scanning stops and the page and offset are recorded&n; * as the starting point the next time the trace timer is called. The final&n; * step is to restore the working page and reset the timer.&n; */
DECL|function|trace_timer
r_void
id|trace_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * Disable interrupts and swap the first page&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
eof
