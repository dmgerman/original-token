multiline_comment|/*&n; *&n; * Copyright (C) Eicon Technology Corporation, 2000.&n; *&n; * This source file is supplied for the exclusive use with Eicon&n; * Technology Corporation&squot;s range of DIVA Server Adapters.&n; *&n; * Eicon File Revision :    1.2  &n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY OF ANY KIND WHATSOEVER INCLUDING ANY &n; * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  &n; * See the GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; */
multiline_comment|/*&n; * Unix Eicon active card driver&n; * XLOG related functions&n; */
macro_line|#include &quot;sys.h&quot;
macro_line|#include &quot;idi.h&quot;
macro_line|#include &quot;pc.h&quot;
macro_line|#include &quot;pc_maint.h&quot;
macro_line|#include &quot;divalog.h&quot;
macro_line|#include &quot;adapter.h&quot;
macro_line|#include &quot;uxio.h&quot;
multiline_comment|/*&n; * convert/copy XLOG info into a KLOG entry&n; */
r_static
DECL|function|xlog_to_klog
r_void
id|xlog_to_klog
c_func
(paren
id|byte
op_star
id|b
comma
r_int
id|size
comma
r_int
id|card_num
)paren
(brace
r_typedef
r_struct
(brace
id|word
id|code
suffix:semicolon
id|word
id|time_hi
suffix:semicolon
id|word
id|time_lo
suffix:semicolon
id|word
id|xcode
suffix:semicolon
id|byte
id|data
(braket
l_int|2
)braket
suffix:semicolon
)brace
id|card_xlog_t
suffix:semicolon
id|card_xlog_t
op_star
id|x
suffix:semicolon
id|klog_t
id|klog
suffix:semicolon
id|x
op_assign
(paren
id|card_xlog_t
op_star
)paren
id|b
suffix:semicolon
id|bzero
c_func
(paren
op_amp
id|klog
comma
r_sizeof
(paren
id|klog
)paren
)paren
suffix:semicolon
id|klog.time_stamp
op_assign
(paren
id|dword
)paren
id|x-&gt;time_hi
suffix:semicolon
id|klog.time_stamp
op_assign
(paren
id|klog.time_stamp
op_lshift
l_int|16
)paren
op_or
(paren
id|dword
)paren
id|x-&gt;time_lo
suffix:semicolon
id|klog.length
op_assign
id|size
OG
r_sizeof
(paren
id|klog.buffer
)paren
ques
c_cond
r_sizeof
(paren
id|klog.buffer
)paren
suffix:colon
id|size
suffix:semicolon
id|klog.card
op_assign
id|card_num
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;code
op_eq
l_int|1
)paren
(brace
id|klog.type
op_assign
id|KLOG_XTXT_MSG
suffix:semicolon
id|klog.code
op_assign
l_int|0
suffix:semicolon
id|bcopy
c_func
(paren
op_amp
id|x-&gt;xcode
comma
id|klog.buffer
comma
id|klog.length
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|x-&gt;code
op_eq
l_int|2
)paren
(brace
id|klog.type
op_assign
id|KLOG_XLOG_MSG
suffix:semicolon
id|klog.code
op_assign
id|x-&gt;xcode
suffix:semicolon
id|bcopy
c_func
(paren
op_amp
id|x-&gt;data
comma
id|klog.buffer
comma
id|klog.length
)paren
suffix:semicolon
)brace
r_else
(brace
r_char
op_star
id|c
suffix:semicolon
r_int
id|i
suffix:semicolon
id|klog.type
op_assign
id|KLOG_TEXT_MSG
suffix:semicolon
id|klog.code
op_assign
l_int|0
suffix:semicolon
id|c
op_assign
l_string|&quot;divas: invalid xlog message code from card&quot;
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|c
)paren
(brace
id|klog.buffer
(braket
id|i
)braket
op_assign
op_star
id|c
suffix:semicolon
id|c
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|klog.buffer
(braket
id|i
)braket
op_assign
op_star
id|c
suffix:semicolon
)brace
multiline_comment|/* send to the log driver and return */
id|DivasLogAdd
c_func
(paren
op_amp
id|klog
comma
r_sizeof
(paren
id|klog
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * send an XLOG request down to specified card&n; * if response available from previous request then read it&n; * if not then just send down new request, ready for next time&n; */
DECL|function|DivasXlogReq
r_void
id|DivasXlogReq
c_func
(paren
r_int
id|card_num
)paren
(brace
id|card_t
op_star
id|card
suffix:semicolon
id|ADAPTER
op_star
id|a
suffix:semicolon
r_if
c_cond
(paren
(paren
id|card_num
OL
l_int|0
)paren
op_logical_or
(paren
id|card_num
OG
id|DivasCardNext
)paren
)paren
(brace
id|DPRINTF
c_func
(paren
(paren
l_string|&quot;xlog: invalid card number&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|card
op_assign
op_amp
id|DivasCards
(braket
id|card_num
)braket
suffix:semicolon
r_if
c_cond
(paren
id|DivasXlogRetrieve
c_func
(paren
id|card
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* send down request for next time */
id|a
op_assign
op_amp
id|card-&gt;a
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
(paren
id|word
op_star
)paren
(paren
id|card-&gt;xlog_offset
op_plus
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
(paren
id|word
op_star
)paren
(paren
id|dword
)paren
(paren
id|card-&gt;xlog_offset
)paren
comma
id|DO_LOG
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * retrieve XLOG request from specified card&n; * returns non-zero if new request sent to card&n; */
DECL|function|DivasXlogRetrieve
r_int
id|DivasXlogRetrieve
c_func
(paren
id|card_t
op_star
id|card
)paren
(brace
id|ADAPTER
op_star
id|a
suffix:semicolon
r_struct
id|mi_pc_maint
id|pcm
suffix:semicolon
id|a
op_assign
op_amp
id|card-&gt;a
suffix:semicolon
multiline_comment|/* get status of last request */
id|pcm.rc
op_assign
id|a
op_member_access_from_pointer
id|ram_in
c_func
(paren
id|a
comma
(paren
id|word
op_star
)paren
(paren
id|card-&gt;xlog_offset
op_plus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* if nothing there from previous request, send down a new one */
r_if
c_cond
(paren
id|pcm.rc
op_eq
id|OK
)paren
(brace
multiline_comment|/* read in response */
id|a
op_member_access_from_pointer
id|ram_in_buffer
c_func
(paren
id|a
comma
(paren
id|word
op_star
)paren
(paren
id|dword
)paren
id|card-&gt;xlog_offset
comma
op_amp
id|pcm
comma
r_sizeof
(paren
id|pcm
)paren
)paren
suffix:semicolon
id|xlog_to_klog
c_func
(paren
(paren
id|byte
op_star
)paren
op_amp
id|pcm.data
comma
r_sizeof
(paren
id|pcm.data
)paren
comma
(paren
r_int
)paren
(paren
id|card
op_minus
id|DivasCards
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* if any response received from card, re-send request */
r_if
c_cond
(paren
id|pcm.rc
)paren
(brace
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
(paren
id|word
op_star
)paren
(paren
id|card-&gt;xlog_offset
op_plus
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
id|a
op_member_access_from_pointer
id|ram_out
c_func
(paren
id|a
comma
(paren
id|word
op_star
)paren
(paren
id|dword
)paren
(paren
id|card-&gt;xlog_offset
)paren
comma
id|DO_LOG
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
