multiline_comment|/* $Id: foreign.h,v 1.1 1998/11/09 07:48:57 baccala Exp $&n; *&n; * HiSax ISDN driver - foreign chipset interface&n; *&n; * Author       Brent Baccala (baccala@FreeSoft.org)&n; *&n; *&n; *&n; * $Log: foreign.h,v $&n; * Revision 1.1  1998/11/09 07:48:57  baccala&n; * Initial DBRI ISDN code.  Sometimes works (brings up the link and you&n; * can telnet through it), sometimes doesn&squot;t (crashes the machine)&n; *&n; */
multiline_comment|/*&n; *       ISDN operations&n; *&n; * Many of these routines take an &quot;int dev&quot; argument, which is simply&n; * an index into the drivers[] array.  Currently, we only support a&n; * single foreign chip, so the value should always be 0.  B channel&n; * operations require an &quot;int chan&quot;, which should be 0 for channel B1&n; * and 1 for channel B2&n; *&n; * int get_irqnum(int dev)&n; *&n; *   returns the interrupt number being used by the chip.  ISDN4linux&n; *   uses this number to watch the interrupt during initialization and&n; *   make sure something is happening.&n; *&n; * int get_liu_state(int dev)&n; *&n; *   returns the current state of the ISDN Line Interface Unit (LIU)&n; *   as a number between 2 (state F2) and 7 (state F7).  0 may also be&n; *   returned if the chip doesn&squot;t exist or the LIU hasn&squot;t been&n; *   activated.  The meanings of the states are defined in I.430, ISDN&n; *   BRI Physical Layer Interface.  The most important two states are&n; *   F3 (shutdown) and F7 (syncronized).&n; *&n; * void liu_init(int dev, void (*callback)(void *), void *callback_arg)&n; *&n; *   initializes the LIU and optionally registers a callback to be&n; *   signaled upon a change of LIU state.  The callback will be called&n; *   with a single opaque callback_arg.  Once the callback has been&n; *   triggered, get_liu_state can be used to determine the LIU&n; *   current state.&n; *&n; * void liu_activate(int dev, int priority)&n; *&n; *   requests LIU activation at a given D-channel priority.&n; *   Successful activatation is achieved upon entering state F7, which&n; *   will trigger any callback previously registered with&n; *   liu_init.&n; *&n; * void liu_deactivate(int dev)&n; *&n; *   deactivates LIU.  Outstanding D and B channel transactions are&n; *   terminated rudely and without callback notification.  LIU change&n; *   of state callback will be triggered, however.&n; *&n; * void dxmit(int dev, __u8 *buffer, unsigned int count,&n; *            void (*callback)(void *, int), void *callback_arg)&n; *&n; *   transmits a packet - specified with buffer, count - over the D-channel&n; *   interface.  Buffer should begin with the LAPD address field and&n; *   end with the information field.  FCS and flag sequences should not&n; *   be included, nor is bit-stuffing required - all these functions are&n; *   performed by the chip.  The callback function will be called&n; *   DURING THE TOP HALF OF AN INTERRUPT HANDLER and will be passed&n; *   both the arbitrary callback_arg and an integer error indication:&n; *&n; *       0 - successful transmission; ready for next packet&n; *   non-0 - error value&n; *&n; *   The callback routine should defer any time-consuming operations&n; *   to a bottom-half handler; however, dxmit may be called&n; *   from within the callback to request back-to-back transmission of&n; *   a second packet (without repeating the priority/collision mechanism)&n; *&n; *   A comment about the &quot;collision detect&quot; error, which is signalled&n; *   whenever the echoed D-channel data didn&squot;t match the transmitted&n; *   data.  This is part of ISDN&squot;s normal multi-drop T-interface&n; *   operation, indicating that another device has attempted simultaneous&n; *   transmission, but can also result from line noise.  An immediate&n; *   requeue via dxmit is suggested, but repeated collision&n; *   errors may indicate a more serious problem.&n; *&n; * void drecv(int dev, __u8 *buffer, unsigned int size,&n; *            void (*callback)(void *, int, unsigned int),&n; *            void *callback_arg)&n; *&n; *   register a buffer - buffer, size - into which a D-channel packet&n; *   can be received.  The callback function will be called DURING&n; *   THE TOP HALF OF AN INTERRUPT HANDLER and will be passed an&n; *   arbitrary callback_arg, an integer error indication and the length&n; *   of the received packet, which will start with the address field,&n; *   end with the information field, and not contain flag or FCS&n; *   bytes.  Bit-stuffing will already have been corrected for.&n; *   Possible values of second callback argument &quot;error&quot;:&n; *&n; *       0 - successful reception&n; *   non-0 - error value&n; *&n; * int bopen(int dev, int chan, int hdlcmode, u_char xmit_idle_char)&n; *&n; *   This function should be called before any other operations on a B&n; *   channel.  mode is either non-0 to (de)encapsulate using HDLC or 0&n; *   for transparent operation. In addition to arranging for interrupt&n; *   handling and channel multiplexing, it sets the xmit_idle_char&n; *   which is transmitted on the interface when no data buffer is&n; *   available.  Suggested values are: 0 for ISDN audio; FF for HDLC&n; *   mark idle; 7E for HDLC flag idle.  Returns 0 on a successful&n; *   open; -1 on error.&n; *&n; *   If the chip doesn&squot;t support HDLC encapsulation (the Am7930&n; *   doesn&squot;t), an error will be returned opening L1_MODE_HDLC; the&n; *   HiSax driver should retry with L1_MODE_TRANS, then be prepared to&n; *   bit-stuff the data before shipping it to the driver.&n; *&n; * void bclose(int dev, int chan)&n; *&n; *   Shuts down a B channel when no longer in use.&n; *&n; * void bxmit(int dev, int chan, __u8 *buffer, unsigned int count,&n; *            void (*callback)(void *, int), void *callback_arg)&n; *&n; *   transmits a data block - specified with buffer, count - over the&n; *   B channel interface specified by dev/chan.  In mode L1_MODE_HDLC,&n; *   a complete HDLC frames should be relayed with a single bxmit.&n; *   The callback function will be called DURING THE TOP HALF OF AN&n; *   INTERRUPT HANDLER and will be passed the arbitrary callback_arg&n; *   and an integer error indication:&n; *&n; *       0 - successful transmission; ready for next packet&n; *   non-0 - error&n; *&n; *   The callback routine should defer any time-consuming operations&n; *   to a bottom-half handler; however, bxmit may be called&n; *   from within the callback to request back-to-back transmission of&n; *   another data block&n; *&n; * void brecv(int dev, int chan, __u8 *buffer, unsigned int size,&n; *            void (*callback)(void *, int, unsigned int), void *callback_arg)&n; *&n; *   receive a raw data block - specified with buffer, size - over the&n; *   B channel interface specified by dev/chan.  The callback function&n; *   will be called DURING THE TOP HALF OF AN INTERRUPT HANDLER and&n; *   will be passed the arbitrary callback_arg, an integer error&n; *   indication and the length of the received packet.  In HDLC mode,&n; *   the packet will start with the address field, end with the&n; *   information field, and will not contain flag or FCS bytes.&n; *   Bit-stuffing will already have been corrected for.&n; *&n; *   Possible values of second callback argument &quot;error&quot;:&n; *&n; *       0 - successful reception&n; *   non-0 - error value&n; *&n; *   The callback routine should defer any time-consuming operations&n; *   to a bottom-half handler; however, brecv may be called&n; *   from within the callback to register another buffer and ensure&n; *   continuous B channel reception without loss of data&n; * */
DECL|struct|foreign_interface
r_struct
id|foreign_interface
(brace
DECL|member|get_irqnum
r_int
(paren
op_star
id|get_irqnum
)paren
(paren
r_int
id|dev
)paren
suffix:semicolon
DECL|member|get_liu_state
r_int
(paren
op_star
id|get_liu_state
)paren
(paren
r_int
id|dev
)paren
suffix:semicolon
DECL|member|liu_init
r_void
(paren
op_star
id|liu_init
)paren
(paren
r_int
id|dev
comma
r_void
(paren
op_star
id|callback
)paren
(paren
r_void
op_star
)paren
comma
r_void
op_star
id|callback_arg
)paren
suffix:semicolon
DECL|member|liu_activate
r_void
(paren
op_star
id|liu_activate
)paren
(paren
r_int
id|dev
comma
r_int
id|priority
)paren
suffix:semicolon
DECL|member|liu_deactivate
r_void
(paren
op_star
id|liu_deactivate
)paren
(paren
r_int
id|dev
)paren
suffix:semicolon
DECL|member|dxmit
r_void
(paren
op_star
id|dxmit
)paren
(paren
r_int
id|dev
comma
id|__u8
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
(paren
op_star
id|callback
)paren
(paren
r_void
op_star
comma
r_int
)paren
comma
r_void
op_star
id|callback_arg
)paren
suffix:semicolon
DECL|member|drecv
r_void
(paren
op_star
id|drecv
)paren
(paren
r_int
id|dev
comma
id|__u8
op_star
id|buffer
comma
r_int
r_int
id|size
comma
r_void
(paren
op_star
id|callback
)paren
(paren
r_void
op_star
comma
r_int
comma
r_int
r_int
)paren
comma
r_void
op_star
id|callback_arg
)paren
suffix:semicolon
DECL|member|bopen
r_int
(paren
op_star
id|bopen
)paren
(paren
r_int
id|dev
comma
r_int
r_int
id|chan
comma
r_int
id|hdlcmode
comma
id|u_char
id|xmit_idle_char
)paren
suffix:semicolon
DECL|member|bclose
r_void
(paren
op_star
id|bclose
)paren
(paren
r_int
id|dev
comma
r_int
r_int
id|chan
)paren
suffix:semicolon
DECL|member|bxmit
r_void
(paren
op_star
id|bxmit
)paren
(paren
r_int
id|dev
comma
r_int
r_int
id|chan
comma
id|__u8
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
(paren
op_star
id|callback
)paren
(paren
r_void
op_star
comma
r_int
)paren
comma
r_void
op_star
id|callback_arg
)paren
suffix:semicolon
DECL|member|brecv
r_void
(paren
op_star
id|brecv
)paren
(paren
r_int
id|dev
comma
r_int
r_int
id|chan
comma
id|__u8
op_star
id|buffer
comma
r_int
r_int
id|size
comma
r_void
(paren
op_star
id|callback
)paren
(paren
r_void
op_star
comma
r_int
comma
r_int
r_int
)paren
comma
r_void
op_star
id|callback_arg
)paren
suffix:semicolon
DECL|member|next
r_struct
id|foreign_interface
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
r_extern
r_struct
id|foreign_interface
id|amd7930_foreign_interface
suffix:semicolon
r_extern
r_struct
id|foreign_interface
id|dbri_foreign_interface
suffix:semicolon
eof
