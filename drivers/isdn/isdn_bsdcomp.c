multiline_comment|/*&n; * BSD compression module&n; *&n; * Patched version for ISDN syncPPP written 1997/1998 by Michael Hipp&n; * The whole module is now SKB based.&n; *&n; * Compile with:&n; *  gcc -O2 -I/usr/src/linux/include -D__KERNEL__ -DMODULE -c isdn_bsdcomp.c&n; */
multiline_comment|/*&n; * Original copyright notice:&n; *&n; * Copyright (c) 1985, 1986 The Regents of the University of California.&n; * All rights reserved.&n; *&n; * This code is derived from software contributed to Berkeley by&n; * James A. Woods, derived from original work by Spencer Thomas&n; * and Joseph Orost.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions and the following disclaimer.&n; * 2. Redistributions in binary form must reproduce the above copyright&n; *    notice, this list of conditions and the following disclaimer in the&n; *    documentation and/or other materials provided with the distribution.&n; * 3. All advertising materials mentioning features or use of this software&n; *    must display the following acknowledgement:&n; *&t;This product includes software developed by the University of&n; *&t;California, Berkeley and its contributors.&n; * 4. Neither the name of the University nor the names of its contributors&n; *    may be used to endorse or promote products derived from this software&n; *    without specific prior written permission.&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS&squot;&squot; AND&n; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n; * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE&n; * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; */
macro_line|#ifndef MODULE
macro_line|#error This file must be compiled as a module.
macro_line|#endif
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;&t;/* used in new tty drivers */
macro_line|#include &lt;linux/signal.h&gt;&t;/* used in new tty drivers */
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/types.h&gt;
macro_line|#include &lt;linux/if.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/ppp_defs.h&gt;
macro_line|#include &lt;linux/isdn.h&gt;
macro_line|#include &lt;linux/isdn_ppp.h&gt;
multiline_comment|/* #include &lt;linux/netprotocol.h&gt; */
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/ppp-comp.h&gt;
macro_line|#include &quot;isdn_ppp.h&quot;
DECL|macro|BSD_VERSION
mdefine_line|#define BSD_VERSION(x)&t;((x) &gt;&gt; 5)
DECL|macro|BSD_NBITS
mdefine_line|#define BSD_NBITS(x)&t;((x) &amp; 0x1F)
DECL|macro|BSD_CURRENT_VERSION
mdefine_line|#define BSD_CURRENT_VERSION&t;1
DECL|macro|DEBUG
mdefine_line|#define DEBUG 1
multiline_comment|/*&n; * A dictionary for doing BSD compress.&n; */
DECL|struct|bsd_dict
r_struct
id|bsd_dict
(brace
DECL|member|fcode
id|u32
id|fcode
suffix:semicolon
DECL|member|codem1
id|u16
id|codem1
suffix:semicolon
multiline_comment|/* output of hash table -1 */
DECL|member|cptr
id|u16
id|cptr
suffix:semicolon
multiline_comment|/* map code to hash table entry */
)brace
suffix:semicolon
DECL|struct|bsd_db
r_struct
id|bsd_db
(brace
DECL|member|totlen
r_int
id|totlen
suffix:semicolon
multiline_comment|/* length of this structure */
DECL|member|hsize
r_int
r_int
id|hsize
suffix:semicolon
multiline_comment|/* size of the hash table */
DECL|member|hshift
r_int
r_char
id|hshift
suffix:semicolon
multiline_comment|/* used in hash function */
DECL|member|n_bits
r_int
r_char
id|n_bits
suffix:semicolon
multiline_comment|/* current bits/code */
DECL|member|maxbits
r_int
r_char
id|maxbits
suffix:semicolon
multiline_comment|/* maximum bits/code */
DECL|member|debug
r_int
r_char
id|debug
suffix:semicolon
multiline_comment|/* non-zero if debug desired */
DECL|member|unit
r_int
r_char
id|unit
suffix:semicolon
multiline_comment|/* ppp unit number */
DECL|member|seqno
id|u16
id|seqno
suffix:semicolon
multiline_comment|/* sequence # of next packet */
DECL|member|mru
r_int
r_int
id|mru
suffix:semicolon
multiline_comment|/* size of receive (decompress) bufr */
DECL|member|maxmaxcode
r_int
r_int
id|maxmaxcode
suffix:semicolon
multiline_comment|/* largest valid code */
DECL|member|max_ent
r_int
r_int
id|max_ent
suffix:semicolon
multiline_comment|/* largest code in use */
DECL|member|in_count
r_int
r_int
id|in_count
suffix:semicolon
multiline_comment|/* uncompressed bytes, aged */
DECL|member|bytes_out
r_int
r_int
id|bytes_out
suffix:semicolon
multiline_comment|/* compressed bytes, aged */
DECL|member|ratio
r_int
r_int
id|ratio
suffix:semicolon
multiline_comment|/* recent compression ratio */
DECL|member|checkpoint
r_int
r_int
id|checkpoint
suffix:semicolon
multiline_comment|/* when to next check the ratio */
DECL|member|clear_count
r_int
r_int
id|clear_count
suffix:semicolon
multiline_comment|/* times dictionary cleared */
DECL|member|incomp_count
r_int
r_int
id|incomp_count
suffix:semicolon
multiline_comment|/* incompressible packets */
DECL|member|incomp_bytes
r_int
r_int
id|incomp_bytes
suffix:semicolon
multiline_comment|/* incompressible bytes */
DECL|member|uncomp_count
r_int
r_int
id|uncomp_count
suffix:semicolon
multiline_comment|/* uncompressed packets */
DECL|member|uncomp_bytes
r_int
r_int
id|uncomp_bytes
suffix:semicolon
multiline_comment|/* uncompressed bytes */
DECL|member|comp_count
r_int
r_int
id|comp_count
suffix:semicolon
multiline_comment|/* compressed packets */
DECL|member|comp_bytes
r_int
r_int
id|comp_bytes
suffix:semicolon
multiline_comment|/* compressed bytes */
DECL|member|lens
r_int
r_int
op_star
id|lens
suffix:semicolon
multiline_comment|/* array of lengths of codes */
DECL|member|dict
r_struct
id|bsd_dict
op_star
id|dict
suffix:semicolon
multiline_comment|/* dictionary */
DECL|member|xmit
r_int
id|xmit
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|BSD_OVHD
mdefine_line|#define BSD_OVHD&t;2&t;&t;/* BSD compress overhead/packet */
DECL|macro|MIN_BSD_BITS
mdefine_line|#define MIN_BSD_BITS&t;9
DECL|macro|BSD_INIT_BITS
mdefine_line|#define BSD_INIT_BITS&t;MIN_BSD_BITS
DECL|macro|MAX_BSD_BITS
mdefine_line|#define MAX_BSD_BITS&t;15
multiline_comment|/*&n; * the next two codes should not be changed lightly, as they must not&n; * lie within the contiguous general code space.&n; */
DECL|macro|CLEAR
mdefine_line|#define CLEAR&t;256&t;&t;&t;/* table clear output code */
DECL|macro|FIRST
mdefine_line|#define FIRST&t;257&t;&t;&t;/* first free entry */
DECL|macro|LAST
mdefine_line|#define LAST&t;255
DECL|macro|MAXCODE
mdefine_line|#define MAXCODE(b)&t;((1 &lt;&lt; (b)) - 1)
DECL|macro|BADCODEM1
mdefine_line|#define BADCODEM1&t;MAXCODE(MAX_BSD_BITS);
DECL|macro|BSD_HASH
mdefine_line|#define BSD_HASH(prefix,suffix,hshift) ((((unsigned long)(suffix))&lt;&lt;(hshift)) &bslash;&n;&t;&t;&t;&t;&t; ^ (unsigned long)(prefix))
DECL|macro|BSD_KEY
mdefine_line|#define BSD_KEY(prefix,suffix)&t;&t;((((unsigned long)(suffix)) &lt;&lt; 16) &bslash;&n;&t;&t;&t;&t;&t; + (unsigned long)(prefix))
DECL|macro|CHECK_GAP
mdefine_line|#define CHECK_GAP&t;10000&t;&t;/* Ratio check interval */
DECL|macro|RATIO_SCALE_LOG
mdefine_line|#define RATIO_SCALE_LOG&t;8
DECL|macro|RATIO_SCALE
mdefine_line|#define RATIO_SCALE&t;(1&lt;&lt;RATIO_SCALE_LOG)
DECL|macro|RATIO_MAX
mdefine_line|#define RATIO_MAX&t;(0x7fffffff&gt;&gt;RATIO_SCALE_LOG)
multiline_comment|/*&n; * clear the dictionary&n; */
DECL|function|bsd_clear
r_static
r_void
id|bsd_clear
c_func
(paren
r_struct
id|bsd_db
op_star
id|db
)paren
(brace
id|db-&gt;clear_count
op_increment
suffix:semicolon
id|db-&gt;max_ent
op_assign
id|FIRST
op_minus
l_int|1
suffix:semicolon
id|db-&gt;n_bits
op_assign
id|BSD_INIT_BITS
suffix:semicolon
id|db-&gt;bytes_out
op_assign
l_int|0
suffix:semicolon
id|db-&gt;in_count
op_assign
l_int|0
suffix:semicolon
id|db-&gt;incomp_count
op_assign
l_int|0
suffix:semicolon
id|db-&gt;ratio
op_assign
l_int|0
suffix:semicolon
id|db-&gt;checkpoint
op_assign
id|CHECK_GAP
suffix:semicolon
)brace
multiline_comment|/*&n; * If the dictionary is full, then see if it is time to reset it.&n; *&n; * Compute the compression ratio using fixed-point arithmetic&n; * with 8 fractional bits.&n; *&n; * Since we have an infinite stream instead of a single file,&n; * watch only the local compression ratio.&n; *&n; * Since both peers must reset the dictionary at the same time even in&n; * the absence of CLEAR codes (while packets are incompressible), they&n; * must compute the same ratio.&n; */
DECL|function|bsd_check
r_static
r_int
id|bsd_check
(paren
r_struct
id|bsd_db
op_star
id|db
)paren
multiline_comment|/* 1=output CLEAR */
(brace
r_int
r_int
id|new_ratio
suffix:semicolon
r_if
c_cond
(paren
id|db-&gt;in_count
op_ge
id|db-&gt;checkpoint
)paren
(brace
multiline_comment|/* age the ratio by limiting the size of the counts */
r_if
c_cond
(paren
id|db-&gt;in_count
op_ge
id|RATIO_MAX
op_logical_or
id|db-&gt;bytes_out
op_ge
id|RATIO_MAX
)paren
(brace
id|db-&gt;in_count
op_sub_assign
(paren
id|db-&gt;in_count
op_rshift
l_int|2
)paren
suffix:semicolon
id|db-&gt;bytes_out
op_sub_assign
(paren
id|db-&gt;bytes_out
op_rshift
l_int|2
)paren
suffix:semicolon
)brace
id|db-&gt;checkpoint
op_assign
id|db-&gt;in_count
op_plus
id|CHECK_GAP
suffix:semicolon
r_if
c_cond
(paren
id|db-&gt;max_ent
op_ge
id|db-&gt;maxmaxcode
)paren
(brace
multiline_comment|/* Reset the dictionary only if the ratio is worse,&n;&t;     * or if it looks as if it has been poisoned&n;&t;     * by incompressible data.&n;&t;     *&n;&t;     * This does not overflow, because&n;&t;     *&t;db-&gt;in_count &lt;= RATIO_MAX.&n;&t;     */
id|new_ratio
op_assign
id|db-&gt;in_count
op_lshift
id|RATIO_SCALE_LOG
suffix:semicolon
r_if
c_cond
(paren
id|db-&gt;bytes_out
op_ne
l_int|0
)paren
(brace
id|new_ratio
op_div_assign
id|db-&gt;bytes_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_ratio
OL
id|db-&gt;ratio
op_logical_or
id|new_ratio
OL
l_int|1
op_star
id|RATIO_SCALE
)paren
(brace
id|bsd_clear
(paren
id|db
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|db-&gt;ratio
op_assign
id|new_ratio
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Return statistics.&n; */
DECL|function|bsd_stats
r_static
r_void
id|bsd_stats
(paren
r_void
op_star
id|state
comma
r_struct
id|compstat
op_star
id|stats
)paren
(brace
r_struct
id|bsd_db
op_star
id|db
op_assign
(paren
r_struct
id|bsd_db
op_star
)paren
id|state
suffix:semicolon
id|stats-&gt;unc_bytes
op_assign
id|db-&gt;uncomp_bytes
suffix:semicolon
id|stats-&gt;unc_packets
op_assign
id|db-&gt;uncomp_count
suffix:semicolon
id|stats-&gt;comp_bytes
op_assign
id|db-&gt;comp_bytes
suffix:semicolon
id|stats-&gt;comp_packets
op_assign
id|db-&gt;comp_count
suffix:semicolon
id|stats-&gt;inc_bytes
op_assign
id|db-&gt;incomp_bytes
suffix:semicolon
id|stats-&gt;inc_packets
op_assign
id|db-&gt;incomp_count
suffix:semicolon
id|stats-&gt;in_count
op_assign
id|db-&gt;in_count
suffix:semicolon
id|stats-&gt;bytes_out
op_assign
id|db-&gt;bytes_out
suffix:semicolon
)brace
multiline_comment|/*&n; * Reset state, as on a CCP ResetReq.&n; */
DECL|function|bsd_reset
r_static
r_void
id|bsd_reset
(paren
r_void
op_star
id|state
comma
r_int
r_char
id|code
comma
r_int
r_char
id|id
comma
r_int
r_char
op_star
id|data
comma
r_int
id|len
comma
r_struct
id|isdn_ppp_resetparams
op_star
id|rsparm
)paren
(brace
r_struct
id|bsd_db
op_star
id|db
op_assign
(paren
r_struct
id|bsd_db
op_star
)paren
id|state
suffix:semicolon
id|bsd_clear
c_func
(paren
id|db
)paren
suffix:semicolon
id|db-&gt;seqno
op_assign
l_int|0
suffix:semicolon
id|db-&gt;clear_count
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Release the compression structure&n; */
DECL|function|bsd_free
r_static
r_void
id|bsd_free
(paren
r_void
op_star
id|state
)paren
(brace
r_struct
id|bsd_db
op_star
id|db
op_assign
(paren
r_struct
id|bsd_db
op_star
)paren
id|state
suffix:semicolon
r_if
c_cond
(paren
id|db
)paren
(brace
multiline_comment|/*&n;&t;&t; * Release the dictionary&n;&t;&t; */
r_if
c_cond
(paren
id|db-&gt;dict
)paren
(brace
id|vfree
(paren
id|db-&gt;dict
)paren
suffix:semicolon
id|db-&gt;dict
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Release the string buffer&n;&t;&t; */
r_if
c_cond
(paren
id|db-&gt;lens
)paren
(brace
id|vfree
(paren
id|db-&gt;lens
)paren
suffix:semicolon
id|db-&gt;lens
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Finally release the structure itself.&n;&t;&t; */
id|kfree
(paren
id|db
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Allocate space for a (de) compressor.&n; */
DECL|function|bsd_alloc
r_static
r_void
op_star
id|bsd_alloc
(paren
r_struct
id|isdn_ppp_comp_data
op_star
id|data
)paren
(brace
r_int
id|bits
suffix:semicolon
r_int
r_int
id|hsize
comma
id|hshift
comma
id|maxmaxcode
suffix:semicolon
r_struct
id|bsd_db
op_star
id|db
suffix:semicolon
r_int
id|decomp
suffix:semicolon
r_static
r_int
r_int
id|htab
(braket
)braket
(braket
l_int|2
)braket
op_assign
(brace
(brace
l_int|5003
comma
l_int|4
)brace
comma
(brace
l_int|5003
comma
l_int|4
)brace
comma
(brace
l_int|5003
comma
l_int|4
)brace
comma
(brace
l_int|5003
comma
l_int|4
)brace
comma
(brace
l_int|9001
comma
l_int|5
)brace
comma
(brace
l_int|18013
comma
l_int|6
)brace
comma
(brace
l_int|35023
comma
l_int|7
)brace
comma
(brace
l_int|69001
comma
l_int|8
)brace
)brace
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;optlen
op_ne
l_int|1
op_logical_or
id|data-&gt;num
op_ne
id|CI_BSD_COMPRESS
op_logical_or
id|BSD_VERSION
c_func
(paren
id|data-&gt;options
(braket
l_int|0
)braket
)paren
op_ne
id|BSD_CURRENT_VERSION
)paren
r_return
l_int|NULL
suffix:semicolon
id|bits
op_assign
id|BSD_NBITS
c_func
(paren
id|data-&gt;options
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bits
template_param
l_int|15
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|hsize
op_assign
id|htab
(braket
id|bits
op_minus
l_int|9
)braket
(braket
l_int|0
)braket
suffix:semicolon
id|hshift
op_assign
id|htab
(braket
id|bits
op_minus
l_int|9
)braket
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate the main control structure for this instance.&n;&t; */
id|maxmaxcode
op_assign
id|MAXCODE
c_func
(paren
id|bits
)paren
suffix:semicolon
id|db
op_assign
(paren
r_struct
id|bsd_db
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|bsd_db
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|db
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
(paren
id|db
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|bsd_db
)paren
)paren
suffix:semicolon
id|db-&gt;xmit
op_assign
id|data-&gt;flags
op_amp
id|IPPP_COMP_FLAG_XMIT
suffix:semicolon
id|decomp
op_assign
id|db-&gt;xmit
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate space for the dictionary. This may be more than one page in&n;&t; * length.&n;&t; */
id|db-&gt;dict
op_assign
(paren
r_struct
id|bsd_dict
op_star
)paren
id|vmalloc
(paren
id|hsize
op_star
r_sizeof
(paren
r_struct
id|bsd_dict
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|db-&gt;dict
)paren
(brace
id|bsd_free
(paren
id|db
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/*&n;&t; * If this is the compression buffer then there is no length data.&n;&t; * For decompression, the length information is needed as well.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|decomp
)paren
id|db-&gt;lens
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
id|db-&gt;lens
op_assign
(paren
r_int
r_int
op_star
)paren
id|vmalloc
(paren
(paren
id|maxmaxcode
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|db-&gt;lens
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|db-&gt;lens
)paren
(brace
id|bsd_free
(paren
id|db
)paren
suffix:semicolon
multiline_comment|/* calls MOD_DEC_USE_COUNT; */
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Initialize the data information for the compression code&n;&t; */
id|db-&gt;totlen
op_assign
r_sizeof
(paren
r_struct
id|bsd_db
)paren
op_plus
(paren
r_sizeof
(paren
r_struct
id|bsd_dict
)paren
op_star
id|hsize
)paren
suffix:semicolon
id|db-&gt;hsize
op_assign
id|hsize
suffix:semicolon
id|db-&gt;hshift
op_assign
id|hshift
suffix:semicolon
id|db-&gt;maxmaxcode
op_assign
id|maxmaxcode
suffix:semicolon
id|db-&gt;maxbits
op_assign
id|bits
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|db
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize the database.&n; */
DECL|function|bsd_init
r_static
r_int
id|bsd_init
(paren
r_void
op_star
id|state
comma
r_struct
id|isdn_ppp_comp_data
op_star
id|data
comma
r_int
id|unit
comma
r_int
id|debug
)paren
(brace
r_struct
id|bsd_db
op_star
id|db
op_assign
id|state
suffix:semicolon
r_int
id|indx
suffix:semicolon
r_int
id|decomp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state
op_logical_or
op_logical_neg
id|data
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;isdn_bsd_init: [%d] ERR, state %lx data %lx&bslash;n&quot;
comma
id|unit
comma
(paren
r_int
)paren
id|state
comma
(paren
r_int
)paren
id|data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|decomp
op_assign
id|db-&gt;xmit
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;optlen
op_ne
l_int|1
op_logical_or
id|data-&gt;num
op_ne
id|CI_BSD_COMPRESS
op_logical_or
(paren
id|BSD_VERSION
c_func
(paren
id|data-&gt;options
(braket
l_int|0
)braket
)paren
op_ne
id|BSD_CURRENT_VERSION
)paren
op_logical_or
(paren
id|BSD_NBITS
c_func
(paren
id|data-&gt;options
(braket
l_int|0
)braket
)paren
op_ne
id|db-&gt;maxbits
)paren
op_logical_or
(paren
id|decomp
op_logical_and
id|db-&gt;lens
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;isdn_bsd: %d %d %d %d %lx&bslash;n&quot;
comma
id|data-&gt;optlen
comma
id|data-&gt;num
comma
id|data-&gt;options
(braket
l_int|0
)braket
comma
id|decomp
comma
(paren
r_int
r_int
)paren
id|db-&gt;lens
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|decomp
)paren
r_for
c_loop
(paren
id|indx
op_assign
id|LAST
suffix:semicolon
id|indx
op_ge
l_int|0
suffix:semicolon
id|indx
op_decrement
)paren
(brace
id|db-&gt;lens
(braket
id|indx
)braket
op_assign
l_int|1
suffix:semicolon
)brace
id|indx
op_assign
id|db-&gt;hsize
suffix:semicolon
r_while
c_loop
(paren
id|indx
op_decrement
op_ne
l_int|0
)paren
(brace
id|db-&gt;dict
(braket
id|indx
)braket
dot
id|codem1
op_assign
id|BADCODEM1
suffix:semicolon
id|db-&gt;dict
(braket
id|indx
)braket
dot
id|cptr
op_assign
l_int|0
suffix:semicolon
)brace
id|db-&gt;unit
op_assign
id|unit
suffix:semicolon
id|db-&gt;mru
op_assign
l_int|0
suffix:semicolon
id|db-&gt;debug
op_assign
l_int|1
suffix:semicolon
id|bsd_reset
c_func
(paren
id|db
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Obtain pointers to the various structures in the compression tables&n; */
DECL|macro|dict_ptrx
mdefine_line|#define dict_ptrx(p,idx) &amp;(p-&gt;dict[idx])
DECL|macro|lens_ptrx
mdefine_line|#define lens_ptrx(p,idx) &amp;(p-&gt;lens[idx])
macro_line|#ifdef DEBUG
DECL|function|lens_ptr
r_static
r_int
r_int
op_star
id|lens_ptr
c_func
(paren
r_struct
id|bsd_db
op_star
id|db
comma
r_int
id|idx
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|idx
OG
(paren
r_int
r_int
)paren
id|db-&gt;maxmaxcode
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;&lt;9&gt;ppp: lens_ptr(%d) &gt; max&bslash;n&quot;
comma
id|idx
)paren
suffix:semicolon
id|idx
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|lens_ptrx
(paren
id|db
comma
id|idx
)paren
suffix:semicolon
)brace
DECL|function|dict_ptr
r_static
r_struct
id|bsd_dict
op_star
id|dict_ptr
c_func
(paren
r_struct
id|bsd_db
op_star
id|db
comma
r_int
id|idx
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|idx
op_ge
(paren
r_int
r_int
)paren
id|db-&gt;hsize
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;&lt;9&gt;ppp: dict_ptr(%d) &gt; max&bslash;n&quot;
comma
id|idx
)paren
suffix:semicolon
id|idx
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|dict_ptrx
(paren
id|db
comma
id|idx
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|lens_ptr
mdefine_line|#define lens_ptr(db,idx) lens_ptrx(db,idx)
DECL|macro|dict_ptr
mdefine_line|#define dict_ptr(db,idx) dict_ptrx(db,idx)
macro_line|#endif
multiline_comment|/*&n; * compress a packet&n; */
DECL|function|bsd_compress
r_static
r_int
id|bsd_compress
(paren
r_void
op_star
id|state
comma
r_struct
id|sk_buff
op_star
id|skb_in
comma
r_struct
id|sk_buff
op_star
id|skb_out
comma
r_int
id|proto
)paren
(brace
r_struct
id|bsd_db
op_star
id|db
suffix:semicolon
r_int
id|hshift
suffix:semicolon
r_int
r_int
id|max_ent
suffix:semicolon
r_int
r_int
id|n_bits
suffix:semicolon
r_int
r_int
id|bitno
suffix:semicolon
r_int
r_int
id|accm
suffix:semicolon
r_int
id|ent
suffix:semicolon
r_int
r_int
id|fcode
suffix:semicolon
r_struct
id|bsd_dict
op_star
id|dictp
suffix:semicolon
r_int
r_char
id|c
suffix:semicolon
r_int
id|hval
comma
id|disp
comma
id|ilen
comma
id|mxcode
suffix:semicolon
r_int
r_char
op_star
id|rptr
op_assign
id|skb_in-&gt;data
suffix:semicolon
r_int
id|isize
op_assign
id|skb_in-&gt;len
suffix:semicolon
DECL|macro|OUTPUT
mdefine_line|#define OUTPUT(ent)&t;&t;&t;&bslash;&n;  {&t;&t;&t;&t;&t;&bslash;&n;    bitno -= n_bits;&t;&t;&t;&bslash;&n;    accm |= ((ent) &lt;&lt; bitno);&t;&t;&bslash;&n;    do&t;{&t;&t;&t;&t;&bslash;&n;        if(skb_out &amp;&amp; skb_tailroom(skb_out) &gt; 0) &t;&bslash;&n;      &t;&t;*(skb_put(skb_out,1)) = (unsigned char) (accm&gt;&gt;24); &bslash;&n;&t;accm &lt;&lt;= 8;&t;&t;&t;&bslash;&n;&t;bitno += 8;&t;&t;&t;&bslash;&n;    } while (bitno &lt;= 24);&t;&t;&bslash;&n;  }
multiline_comment|/*&n;&t; * If the protocol is not in the range we&squot;re interested in,&n;&t; * just return without compressing the packet.  If it is,&n;&t; * the protocol becomes the first byte to compress.&n;&t; */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;bsd_compress called with %x&bslash;n&quot;
comma
id|proto
)paren
suffix:semicolon
id|ent
op_assign
id|proto
suffix:semicolon
r_if
c_cond
(paren
id|proto
template_param
l_int|0xf9
op_logical_or
op_logical_neg
(paren
id|proto
op_amp
l_int|0x1
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|db
op_assign
(paren
r_struct
id|bsd_db
op_star
)paren
id|state
suffix:semicolon
id|hshift
op_assign
id|db-&gt;hshift
suffix:semicolon
id|max_ent
op_assign
id|db-&gt;max_ent
suffix:semicolon
id|n_bits
op_assign
id|db-&gt;n_bits
suffix:semicolon
id|bitno
op_assign
l_int|32
suffix:semicolon
id|accm
op_assign
l_int|0
suffix:semicolon
id|mxcode
op_assign
id|MAXCODE
(paren
id|n_bits
)paren
suffix:semicolon
multiline_comment|/* This is the PPP header information */
r_if
c_cond
(paren
id|skb_out
op_logical_and
id|skb_tailroom
c_func
(paren
id|skb_out
)paren
op_ge
l_int|2
)paren
(brace
r_char
op_star
id|v
op_assign
id|skb_put
c_func
(paren
id|skb_out
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* we only push our own data on the header,&n;&t;&t;  AC,PC and protos is pushed by caller  */
id|v
(braket
l_int|0
)braket
op_assign
id|db-&gt;seqno
op_rshift
l_int|8
suffix:semicolon
id|v
(braket
l_int|1
)braket
op_assign
id|db-&gt;seqno
suffix:semicolon
)brace
id|ilen
op_assign
op_increment
id|isize
suffix:semicolon
multiline_comment|/* This is off by one, but that is what is in draft! */
r_while
c_loop
(paren
op_decrement
id|ilen
OG
l_int|0
)paren
(brace
id|c
op_assign
op_star
id|rptr
op_increment
suffix:semicolon
id|fcode
op_assign
id|BSD_KEY
(paren
id|ent
comma
id|c
)paren
suffix:semicolon
id|hval
op_assign
id|BSD_HASH
(paren
id|ent
comma
id|c
comma
id|hshift
)paren
suffix:semicolon
id|dictp
op_assign
id|dict_ptr
(paren
id|db
comma
id|hval
)paren
suffix:semicolon
multiline_comment|/* Validate and then check the entry. */
r_if
c_cond
(paren
id|dictp-&gt;codem1
op_ge
id|max_ent
)paren
r_goto
id|nomatch
suffix:semicolon
r_if
c_cond
(paren
id|dictp-&gt;fcode
op_eq
id|fcode
)paren
(brace
id|ent
op_assign
id|dictp-&gt;codem1
op_plus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* found (prefix,suffix) */
)brace
multiline_comment|/* continue probing until a match or invalid entry */
id|disp
op_assign
(paren
id|hval
op_eq
l_int|0
)paren
ques
c_cond
l_int|1
suffix:colon
id|hval
suffix:semicolon
r_do
(brace
id|hval
op_add_assign
id|disp
suffix:semicolon
r_if
c_cond
(paren
id|hval
op_ge
id|db-&gt;hsize
)paren
id|hval
op_sub_assign
id|db-&gt;hsize
suffix:semicolon
id|dictp
op_assign
id|dict_ptr
(paren
id|db
comma
id|hval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dictp-&gt;codem1
op_ge
id|max_ent
)paren
r_goto
id|nomatch
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dictp-&gt;fcode
op_ne
id|fcode
)paren
suffix:semicolon
id|ent
op_assign
id|dictp-&gt;codem1
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* finally found (prefix,suffix) */
r_continue
suffix:semicolon
id|nomatch
suffix:colon
id|OUTPUT
c_func
(paren
id|ent
)paren
suffix:semicolon
multiline_comment|/* output the prefix */
multiline_comment|/* code -&gt; hashtable */
r_if
c_cond
(paren
id|max_ent
OL
id|db-&gt;maxmaxcode
)paren
(brace
r_struct
id|bsd_dict
op_star
id|dictp2
suffix:semicolon
r_struct
id|bsd_dict
op_star
id|dictp3
suffix:semicolon
r_int
id|indx
suffix:semicolon
multiline_comment|/* expand code size if needed */
r_if
c_cond
(paren
id|max_ent
op_ge
id|mxcode
)paren
(brace
id|db-&gt;n_bits
op_assign
op_increment
id|n_bits
suffix:semicolon
id|mxcode
op_assign
id|MAXCODE
(paren
id|n_bits
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * Invalidate old hash table entry using&n;&t;&t;&t; * this code, and then take it over.&n;&t;&t;&t; */
id|dictp2
op_assign
id|dict_ptr
(paren
id|db
comma
id|max_ent
op_plus
l_int|1
)paren
suffix:semicolon
id|indx
op_assign
id|dictp2-&gt;cptr
suffix:semicolon
id|dictp3
op_assign
id|dict_ptr
(paren
id|db
comma
id|indx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dictp3-&gt;codem1
op_eq
id|max_ent
)paren
id|dictp3-&gt;codem1
op_assign
id|BADCODEM1
suffix:semicolon
id|dictp2-&gt;cptr
op_assign
id|hval
suffix:semicolon
id|dictp-&gt;codem1
op_assign
id|max_ent
suffix:semicolon
id|dictp-&gt;fcode
op_assign
id|fcode
suffix:semicolon
id|db-&gt;max_ent
op_assign
op_increment
id|max_ent
suffix:semicolon
r_if
c_cond
(paren
id|db-&gt;lens
)paren
(brace
r_int
r_int
op_star
id|len1
op_assign
id|lens_ptr
(paren
id|db
comma
id|max_ent
)paren
suffix:semicolon
r_int
r_int
op_star
id|len2
op_assign
id|lens_ptr
(paren
id|db
comma
id|ent
)paren
suffix:semicolon
op_star
id|len1
op_assign
op_star
id|len2
op_plus
l_int|1
suffix:semicolon
)brace
)brace
id|ent
op_assign
id|c
suffix:semicolon
)brace
id|OUTPUT
c_func
(paren
id|ent
)paren
suffix:semicolon
multiline_comment|/* output the last code */
r_if
c_cond
(paren
id|skb_out
)paren
(brace
id|db-&gt;bytes_out
op_add_assign
id|skb_out-&gt;len
suffix:semicolon
)brace
multiline_comment|/* Do not count bytes from here */
id|db-&gt;uncomp_bytes
op_add_assign
id|isize
suffix:semicolon
id|db-&gt;in_count
op_add_assign
id|isize
suffix:semicolon
op_increment
id|db-&gt;uncomp_count
suffix:semicolon
op_increment
id|db-&gt;seqno
suffix:semicolon
r_if
c_cond
(paren
id|bitno
OL
l_int|32
)paren
op_increment
id|db-&gt;bytes_out
suffix:semicolon
multiline_comment|/* must be set before calling bsd_check */
multiline_comment|/*&n;&t; * Generate the clear command if needed&n;&t; */
r_if
c_cond
(paren
id|bsd_check
c_func
(paren
id|db
)paren
)paren
id|OUTPUT
(paren
id|CLEAR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Pad dribble bits of last code with ones.&n;&t; * Do not emit a completely useless byte of ones.&n;&t; */
r_if
c_cond
(paren
id|bitno
template_param
l_int|0
)paren
op_star
(paren
id|skb_put
c_func
(paren
id|skb_out
comma
l_int|1
)paren
)paren
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|accm
op_or
(paren
l_int|0xff
op_lshift
(paren
id|bitno
op_minus
l_int|8
)paren
)paren
)paren
op_rshift
l_int|24
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Increase code size if we would have without the packet&n;&t; * boundary because the decompressor will do so.&n;&t; */
r_if
c_cond
(paren
id|max_ent
op_ge
id|mxcode
op_logical_and
id|max_ent
OL
id|db-&gt;maxmaxcode
)paren
id|db-&gt;n_bits
op_increment
suffix:semicolon
multiline_comment|/* If output length is too large then this is an incompressible frame. */
r_if
c_cond
(paren
op_logical_neg
id|skb_out
op_logical_or
(paren
id|skb_out
op_logical_and
id|skb_out-&gt;len
op_ge
id|skb_in-&gt;len
)paren
)paren
(brace
op_increment
id|db-&gt;incomp_count
suffix:semicolon
id|db-&gt;incomp_bytes
op_add_assign
id|isize
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Count the number of compressed frames */
op_increment
id|db-&gt;comp_count
suffix:semicolon
id|db-&gt;comp_bytes
op_add_assign
id|skb_out-&gt;len
suffix:semicolon
r_return
id|skb_out-&gt;len
suffix:semicolon
DECL|macro|OUTPUT
macro_line|#undef OUTPUT
)brace
multiline_comment|/*&n; * Update the &quot;BSD Compress&quot; dictionary on the receiver for&n; * incompressible data by pretending to compress the incoming data.&n; */
DECL|function|bsd_incomp
r_static
r_void
id|bsd_incomp
(paren
r_void
op_star
id|state
comma
r_struct
id|sk_buff
op_star
id|skb_in
comma
r_int
id|proto
)paren
(brace
id|bsd_compress
(paren
id|state
comma
id|skb_in
comma
l_int|NULL
comma
id|proto
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Decompress &quot;BSD Compress&quot;.&n; */
DECL|function|bsd_decompress
r_static
r_int
id|bsd_decompress
(paren
r_void
op_star
id|state
comma
r_struct
id|sk_buff
op_star
id|skb_in
comma
r_struct
id|sk_buff
op_star
id|skb_out
comma
r_struct
id|isdn_ppp_resetparams
op_star
id|rsparm
)paren
(brace
r_struct
id|bsd_db
op_star
id|db
suffix:semicolon
r_int
r_int
id|max_ent
suffix:semicolon
r_int
r_int
id|accm
suffix:semicolon
r_int
r_int
id|bitno
suffix:semicolon
multiline_comment|/* 1st valid bit in accm */
r_int
r_int
id|n_bits
suffix:semicolon
r_int
r_int
id|tgtbitno
suffix:semicolon
multiline_comment|/* bitno when we have a code */
r_struct
id|bsd_dict
op_star
id|dictp
suffix:semicolon
r_int
id|seq
suffix:semicolon
r_int
r_int
id|incode
suffix:semicolon
r_int
r_int
id|oldcode
suffix:semicolon
r_int
r_int
id|finchar
suffix:semicolon
r_int
r_char
op_star
id|p
comma
op_star
id|ibuf
suffix:semicolon
r_int
id|ilen
suffix:semicolon
r_int
id|codelen
suffix:semicolon
r_int
id|extra
suffix:semicolon
id|db
op_assign
(paren
r_struct
id|bsd_db
op_star
)paren
id|state
suffix:semicolon
id|max_ent
op_assign
id|db-&gt;max_ent
suffix:semicolon
id|accm
op_assign
l_int|0
suffix:semicolon
id|bitno
op_assign
l_int|32
suffix:semicolon
multiline_comment|/* 1st valid bit in accm */
id|n_bits
op_assign
id|db-&gt;n_bits
suffix:semicolon
id|tgtbitno
op_assign
l_int|32
op_minus
id|n_bits
suffix:semicolon
multiline_comment|/* bitno when we have a code */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;bsd_decompress called&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb_in
op_logical_or
op_logical_neg
id|skb_out
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bsd_decompress called with NULL parameter&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|DECOMP_ERROR
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get the sequence number.&n;&t; */
r_if
c_cond
(paren
(paren
id|p
op_assign
id|skb_pull
c_func
(paren
id|skb_in
comma
l_int|2
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_return
id|DECOMP_ERROR
suffix:semicolon
)brace
id|p
op_sub_assign
l_int|2
suffix:semicolon
id|seq
op_assign
(paren
id|p
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_plus
id|p
(braket
l_int|1
)braket
suffix:semicolon
id|ilen
op_assign
id|skb_in-&gt;len
suffix:semicolon
id|ibuf
op_assign
id|skb_in-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t; * Check the sequence number and give up if it differs from&n;&t; * the value we&squot;re expecting.&n;&t; */
r_if
c_cond
(paren
id|seq
op_ne
id|db-&gt;seqno
)paren
(brace
r_if
c_cond
(paren
id|db-&gt;debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;bsd_decomp%d: bad sequence # %d, expected %d&bslash;n&quot;
comma
id|db-&gt;unit
comma
id|seq
comma
id|db-&gt;seqno
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|DECOMP_ERROR
suffix:semicolon
)brace
op_increment
id|db-&gt;seqno
suffix:semicolon
id|db-&gt;bytes_out
op_add_assign
id|ilen
suffix:semicolon
r_if
c_cond
(paren
id|skb_tailroom
c_func
(paren
id|skb_out
)paren
OG
l_int|0
)paren
(brace
op_star
(paren
id|skb_put
c_func
(paren
id|skb_out
comma
l_int|1
)paren
)paren
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_return
id|DECOMP_ERR_NOMEM
suffix:semicolon
id|oldcode
op_assign
id|CLEAR
suffix:semicolon
multiline_comment|/*&n;&t; * Keep the checkpoint correctly so that incompressible packets&n;&t; * clear the dictionary at the proper times.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|ilen
op_decrement
op_le
l_int|0
)paren
(brace
id|db-&gt;in_count
op_add_assign
(paren
id|skb_out-&gt;len
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* don&squot;t count the header */
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Accumulate bytes until we have a complete code.&n;&t;&t; * Then get the next code, relying on the 32-bit,&n;&t;&t; * unsigned accm to mask the result.&n;&t;&t; */
id|bitno
op_sub_assign
l_int|8
suffix:semicolon
id|accm
op_or_assign
op_star
id|ibuf
op_increment
op_lshift
id|bitno
suffix:semicolon
r_if
c_cond
(paren
id|tgtbitno
OL
id|bitno
)paren
r_continue
suffix:semicolon
id|incode
op_assign
id|accm
op_rshift
id|tgtbitno
suffix:semicolon
id|accm
op_lshift_assign
id|n_bits
suffix:semicolon
id|bitno
op_add_assign
id|n_bits
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The dictionary must only be cleared at the end of a packet.&n;&t;&t; */
r_if
c_cond
(paren
id|incode
op_eq
id|CLEAR
)paren
(brace
r_if
c_cond
(paren
id|ilen
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|db-&gt;debug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;bsd_decomp%d: bad CLEAR&bslash;n&quot;
comma
id|db-&gt;unit
)paren
suffix:semicolon
r_return
id|DECOMP_FATALERROR
suffix:semicolon
multiline_comment|/* probably a bug */
)brace
id|bsd_clear
c_func
(paren
id|db
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|incode
OG
id|max_ent
op_plus
l_int|2
)paren
op_logical_or
(paren
id|incode
OG
id|db-&gt;maxmaxcode
)paren
op_logical_or
(paren
id|incode
OG
id|max_ent
op_logical_and
id|oldcode
op_eq
id|CLEAR
)paren
)paren
(brace
r_if
c_cond
(paren
id|db-&gt;debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;bsd_decomp%d: bad code 0x%x oldcode=0x%x &quot;
comma
id|db-&gt;unit
comma
id|incode
comma
id|oldcode
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;max_ent=0x%x skb-&gt;Len=%d seqno=%d&bslash;n&quot;
comma
id|max_ent
comma
id|skb_out-&gt;len
comma
id|db-&gt;seqno
)paren
suffix:semicolon
)brace
r_return
id|DECOMP_FATALERROR
suffix:semicolon
multiline_comment|/* probably a bug */
)brace
multiline_comment|/* Special case for KwKwK string. */
r_if
c_cond
(paren
id|incode
OG
id|max_ent
)paren
(brace
id|finchar
op_assign
id|oldcode
suffix:semicolon
id|extra
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|finchar
op_assign
id|incode
suffix:semicolon
id|extra
op_assign
l_int|0
suffix:semicolon
)brace
id|codelen
op_assign
op_star
(paren
id|lens_ptr
(paren
id|db
comma
id|finchar
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_tailroom
c_func
(paren
id|skb_out
)paren
OL
id|codelen
op_plus
id|extra
)paren
(brace
r_if
c_cond
(paren
id|db-&gt;debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;bsd_decomp%d: ran out of mru&bslash;n&quot;
comma
id|db-&gt;unit
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;  len=%d, finchar=0x%x, codelen=%d,skblen=%d&bslash;n&quot;
comma
id|ilen
comma
id|finchar
comma
id|codelen
comma
id|skb_out-&gt;len
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
id|DECOMP_FATALERROR
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Decode this code and install it in the decompressed buffer.&n;&t;&t; */
id|p
op_assign
id|skb_put
c_func
(paren
id|skb_out
comma
id|codelen
)paren
suffix:semicolon
id|p
op_add_assign
id|codelen
suffix:semicolon
r_while
c_loop
(paren
id|finchar
OG
id|LAST
)paren
(brace
r_struct
id|bsd_dict
op_star
id|dictp2
op_assign
id|dict_ptr
(paren
id|db
comma
id|finchar
)paren
suffix:semicolon
id|dictp
op_assign
id|dict_ptr
(paren
id|db
comma
id|dictp2-&gt;cptr
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_decrement
id|codelen
op_le
l_int|0
op_logical_or
id|dictp-&gt;codem1
op_ne
id|finchar
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|codelen
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bsd_decomp%d: fell off end of chain &quot;
comma
id|db-&gt;unit
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;0x%x at 0x%x by 0x%x, max_ent=0x%x&bslash;n&quot;
comma
id|incode
comma
id|finchar
comma
id|dictp2-&gt;cptr
comma
id|max_ent
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dictp-&gt;codem1
op_ne
id|finchar
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bsd_decomp%d: bad code chain 0x%x finchar=0x%x &quot;
comma
id|db-&gt;unit
comma
id|incode
comma
id|finchar
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;oldcode=0x%x cptr=0x%x codem1=0x%x&bslash;n&quot;
comma
id|oldcode
comma
id|dictp2-&gt;cptr
comma
id|dictp-&gt;codem1
)paren
suffix:semicolon
)brace
)brace
r_return
id|DECOMP_FATALERROR
suffix:semicolon
)brace
macro_line|#endif
(brace
id|u32
id|fcode
op_assign
id|dictp-&gt;fcode
suffix:semicolon
op_star
op_decrement
id|p
op_assign
(paren
id|fcode
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|finchar
op_assign
id|fcode
op_amp
l_int|0xffff
suffix:semicolon
)brace
)brace
op_star
op_decrement
id|p
op_assign
id|finchar
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_decrement
id|codelen
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bsd_decomp%d: short by %d after code 0x%x, max_ent=0x%x&bslash;n&quot;
comma
id|db-&gt;unit
comma
id|codelen
comma
id|incode
comma
id|max_ent
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|extra
)paren
multiline_comment|/* the KwKwK case again */
op_star
(paren
id|skb_put
c_func
(paren
id|skb_out
comma
l_int|1
)paren
)paren
op_assign
id|finchar
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If not first code in a packet, and&n;&t;&t; * if not out of code space, then allocate a new code.&n;&t;&t; *&n;&t;&t; * Keep the hash table correct so it can be used&n;&t;&t; * with uncompressed packets.&n;&t;&t; */
r_if
c_cond
(paren
id|oldcode
op_ne
id|CLEAR
op_logical_and
id|max_ent
OL
id|db-&gt;maxmaxcode
)paren
(brace
r_struct
id|bsd_dict
op_star
id|dictp2
comma
op_star
id|dictp3
suffix:semicolon
id|u16
op_star
id|lens1
comma
op_star
id|lens2
suffix:semicolon
r_int
r_int
id|fcode
suffix:semicolon
r_int
id|hval
comma
id|disp
comma
id|indx
suffix:semicolon
id|fcode
op_assign
id|BSD_KEY
c_func
(paren
id|oldcode
comma
id|finchar
)paren
suffix:semicolon
id|hval
op_assign
id|BSD_HASH
c_func
(paren
id|oldcode
comma
id|finchar
comma
id|db-&gt;hshift
)paren
suffix:semicolon
id|dictp
op_assign
id|dict_ptr
(paren
id|db
comma
id|hval
)paren
suffix:semicolon
multiline_comment|/* look for a free hash table entry */
r_if
c_cond
(paren
id|dictp-&gt;codem1
OL
id|max_ent
)paren
(brace
id|disp
op_assign
(paren
id|hval
op_eq
l_int|0
)paren
ques
c_cond
l_int|1
suffix:colon
id|hval
suffix:semicolon
r_do
(brace
id|hval
op_add_assign
id|disp
suffix:semicolon
r_if
c_cond
(paren
id|hval
op_ge
id|db-&gt;hsize
)paren
id|hval
op_sub_assign
id|db-&gt;hsize
suffix:semicolon
id|dictp
op_assign
id|dict_ptr
(paren
id|db
comma
id|hval
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dictp-&gt;codem1
OL
id|max_ent
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Invalidate previous hash table entry&n;&t;&t;&t; * assigned this code, and then take it over&n;&t;&t;&t; */
id|dictp2
op_assign
id|dict_ptr
(paren
id|db
comma
id|max_ent
op_plus
l_int|1
)paren
suffix:semicolon
id|indx
op_assign
id|dictp2-&gt;cptr
suffix:semicolon
id|dictp3
op_assign
id|dict_ptr
(paren
id|db
comma
id|indx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dictp3-&gt;codem1
op_eq
id|max_ent
)paren
id|dictp3-&gt;codem1
op_assign
id|BADCODEM1
suffix:semicolon
id|dictp2-&gt;cptr
op_assign
id|hval
suffix:semicolon
id|dictp-&gt;codem1
op_assign
id|max_ent
suffix:semicolon
id|dictp-&gt;fcode
op_assign
id|fcode
suffix:semicolon
id|db-&gt;max_ent
op_assign
op_increment
id|max_ent
suffix:semicolon
multiline_comment|/* Update the length of this string. */
id|lens1
op_assign
id|lens_ptr
(paren
id|db
comma
id|max_ent
)paren
suffix:semicolon
id|lens2
op_assign
id|lens_ptr
(paren
id|db
comma
id|oldcode
)paren
suffix:semicolon
op_star
id|lens1
op_assign
op_star
id|lens2
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Expand code size if needed. */
r_if
c_cond
(paren
id|max_ent
op_ge
id|MAXCODE
c_func
(paren
id|n_bits
)paren
op_logical_and
id|max_ent
OL
id|db-&gt;maxmaxcode
)paren
(brace
id|db-&gt;n_bits
op_assign
op_increment
id|n_bits
suffix:semicolon
id|tgtbitno
op_assign
l_int|32
op_minus
id|n_bits
suffix:semicolon
)brace
)brace
id|oldcode
op_assign
id|incode
suffix:semicolon
)brace
op_increment
id|db-&gt;comp_count
suffix:semicolon
op_increment
id|db-&gt;uncomp_count
suffix:semicolon
id|db-&gt;comp_bytes
op_add_assign
id|skb_in-&gt;len
op_minus
id|BSD_OVHD
suffix:semicolon
id|db-&gt;uncomp_bytes
op_add_assign
id|skb_out-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|bsd_check
c_func
(paren
id|db
)paren
)paren
(brace
r_if
c_cond
(paren
id|db-&gt;debug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;bsd_decomp%d: peer should have cleared dictionary on %d&bslash;n&quot;
comma
id|db-&gt;unit
comma
id|db-&gt;seqno
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|skb_out-&gt;len
suffix:semicolon
)brace
multiline_comment|/*************************************************************&n; * Table of addresses for the BSD compression module&n; *************************************************************/
DECL|variable|ippp_bsd_compress
r_static
r_struct
id|isdn_ppp_compressor
id|ippp_bsd_compress
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
multiline_comment|/* prev,next: overwritten by isdn_ppp */
id|CI_BSD_COMPRESS
comma
multiline_comment|/* compress_proto */
id|bsd_alloc
comma
multiline_comment|/* alloc */
id|bsd_free
comma
multiline_comment|/* free */
id|bsd_init
comma
multiline_comment|/* init */
id|bsd_reset
comma
multiline_comment|/* reset */
id|bsd_compress
comma
multiline_comment|/* compress */
id|bsd_decompress
comma
multiline_comment|/* decompress */
id|bsd_incomp
comma
multiline_comment|/* incomp */
id|bsd_stats
multiline_comment|/* comp_stat */
)brace
suffix:semicolon
multiline_comment|/*************************************************************&n; * Module support routines&n; *************************************************************/
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|answer
op_assign
id|isdn_ppp_register_compressor
(paren
op_amp
id|ippp_bsd_compress
)paren
suffix:semicolon
r_if
c_cond
(paren
id|answer
op_eq
l_int|0
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;PPP BSD Compression module registered&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|answer
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|isdn_ppp_unregister_compressor
(paren
op_amp
id|ippp_bsd_compress
)paren
suffix:semicolon
)brace
eof
