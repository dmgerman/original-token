multiline_comment|/* $Id: hysdn_procfs.c,v 1.1 2000/02/10 19:45:18 werner Exp $&n;&n; * Linux driver for HYSDN cards, /proc/net filesystem log functions.&n; * written by Werner Cornelius (werner@titro.de) for Hypercope GmbH&n; *&n; * Copyright 1999  by Werner Cornelius (werner@titro.de)&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * $Log: hysdn_procfs.c,v $&n; * Revision 1.1  2000/02/10 19:45:18  werner&n; *&n; * Initial release&n; *&n; *&n; */
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &quot;hysdn_defs.h&quot;
DECL|variable|hysdn_procfs_revision
r_static
r_char
op_star
id|hysdn_procfs_revision
op_assign
l_string|&quot;$Revision: 1.1 $&quot;
suffix:semicolon
DECL|macro|INFO_OUT_LEN
mdefine_line|#define INFO_OUT_LEN 80&t;&t;/* length of info line including lf */
multiline_comment|/*************************************************/
multiline_comment|/* structure keeping ascii log for device output */
multiline_comment|/*************************************************/
DECL|struct|log_data
r_struct
id|log_data
(brace
DECL|member|next
r_struct
id|log_data
op_star
id|next
suffix:semicolon
DECL|member|usage_cnt
id|ulong
id|usage_cnt
suffix:semicolon
multiline_comment|/* number of files still to work */
DECL|member|proc_ctrl
r_void
op_star
id|proc_ctrl
suffix:semicolon
multiline_comment|/* pointer to own control procdata structure */
DECL|member|log_start
r_char
id|log_start
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* log string start (final len aligned by size) */
)brace
suffix:semicolon
multiline_comment|/**********************************************/
multiline_comment|/* structure holding proc entrys for one card */
multiline_comment|/**********************************************/
DECL|struct|procdata
r_struct
id|procdata
(brace
DECL|member|log
r_struct
id|proc_dir_entry
op_star
id|log
suffix:semicolon
multiline_comment|/* log entry */
DECL|member|log_name
r_char
id|log_name
(braket
l_int|15
)braket
suffix:semicolon
multiline_comment|/* log filename */
DECL|member|log_head
DECL|member|log_tail
r_struct
id|log_data
op_star
id|log_head
comma
op_star
id|log_tail
suffix:semicolon
multiline_comment|/* head and tail for queue */
DECL|member|if_used
r_int
id|if_used
suffix:semicolon
multiline_comment|/* open count for interface */
DECL|member|rd_queue
id|wait_queue_head_t
id|rd_queue
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/********************************************/
multiline_comment|/* put an log buffer into the log queue.    */
multiline_comment|/* This buffer will be kept until all files */
multiline_comment|/* opened for read got the contents.        */
multiline_comment|/* Flushes buffers not longer in use.       */
multiline_comment|/********************************************/
r_void
DECL|function|put_log_buffer
id|put_log_buffer
c_func
(paren
id|hysdn_card
op_star
id|card
comma
r_char
op_star
id|cp
)paren
(brace
r_struct
id|log_data
op_star
id|ib
suffix:semicolon
r_struct
id|procdata
op_star
id|pd
op_assign
id|card-&gt;procfs
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pd
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|cp
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;if_used
op_le
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* no open file for read */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ib
op_assign
(paren
r_struct
id|log_data
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|log_data
)paren
op_plus
id|strlen
c_func
(paren
id|cp
)paren
comma
id|GFP_ATOMIC
)paren
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* no memory */
id|strcpy
c_func
(paren
id|ib-&gt;log_start
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/* set output string */
id|ib-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|ib-&gt;proc_ctrl
op_assign
id|pd
suffix:semicolon
multiline_comment|/* point to own control structure */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ib-&gt;usage_cnt
op_assign
id|pd-&gt;if_used
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pd-&gt;log_head
)paren
id|pd-&gt;log_head
op_assign
id|ib
suffix:semicolon
multiline_comment|/* new head */
r_else
id|pd-&gt;log_tail-&gt;next
op_assign
id|ib
suffix:semicolon
multiline_comment|/* follows existing messages */
id|pd-&gt;log_tail
op_assign
id|ib
suffix:semicolon
multiline_comment|/* new tail */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* delete old entrys */
r_while
c_loop
(paren
id|pd-&gt;log_head-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|pd-&gt;log_head-&gt;usage_cnt
op_le
l_int|0
)paren
op_logical_and
(paren
id|pd-&gt;log_head-&gt;next-&gt;usage_cnt
op_le
l_int|0
)paren
)paren
(brace
id|ib
op_assign
id|pd-&gt;log_head
suffix:semicolon
id|pd-&gt;log_head
op_assign
id|pd-&gt;log_head-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|ib
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
multiline_comment|/* pd-&gt;log_head-&gt;next */
id|wake_up_interruptible
c_func
(paren
op_amp
(paren
id|pd-&gt;rd_queue
)paren
)paren
suffix:semicolon
multiline_comment|/* announce new entry */
)brace
multiline_comment|/* put_log_buffer */
multiline_comment|/*************************/
multiline_comment|/* dummy file operations */
multiline_comment|/*************************/
r_static
id|loff_t
DECL|function|hysdn_dummy_lseek
id|hysdn_dummy_lseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|orig
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
multiline_comment|/* hysdn_dummy_lseek */
multiline_comment|/**********************************/
multiline_comment|/* log file operations and tables */
multiline_comment|/**********************************/
multiline_comment|/****************************************/
multiline_comment|/* write log file -&gt; set log level bits */
multiline_comment|/****************************************/
r_static
id|ssize_t
DECL|function|hysdn_log_write
id|hysdn_log_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|off
)paren
(brace
r_int
id|retval
suffix:semicolon
id|hysdn_card
op_star
id|card
op_assign
(paren
id|hysdn_card
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_amp
id|file-&gt;f_pos
op_ne
id|off
)paren
multiline_comment|/* fs error check */
r_return
(paren
op_minus
id|ESPIPE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|pof_boot_write
c_func
(paren
id|card
comma
id|buf
comma
id|count
)paren
)paren
OL
l_int|0
)paren
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* an error occured */
r_return
(paren
id|retval
)paren
suffix:semicolon
)brace
multiline_comment|/* hysdn_log_write */
multiline_comment|/******************/
multiline_comment|/* read log file */
multiline_comment|/******************/
r_static
id|ssize_t
DECL|function|hysdn_log_read
id|hysdn_log_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|off
)paren
(brace
r_struct
id|log_data
op_star
id|inf
suffix:semicolon
r_int
id|len
suffix:semicolon
id|word
id|ino
suffix:semicolon
r_struct
id|procdata
op_star
id|pd
suffix:semicolon
id|hysdn_card
op_star
id|card
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
(paren
(paren
r_struct
id|log_data
op_star
op_star
)paren
id|file-&gt;private_data
)paren
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
multiline_comment|/* sorry, but we need to search the card */
id|ino
op_assign
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_ino
op_amp
l_int|0xFFFF
suffix:semicolon
multiline_comment|/* low-ino */
id|card
op_assign
id|card_root
suffix:semicolon
r_while
c_loop
(paren
id|card
)paren
(brace
id|pd
op_assign
id|card-&gt;procfs
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;log-&gt;low_ino
op_eq
id|ino
)paren
r_break
suffix:semicolon
id|card
op_assign
id|card-&gt;next
suffix:semicolon
multiline_comment|/* search next entry */
)brace
r_if
c_cond
(paren
id|card
)paren
id|interruptible_sleep_on
c_func
(paren
op_amp
(paren
id|pd-&gt;rd_queue
)paren
)paren
suffix:semicolon
r_else
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inf
op_assign
op_star
(paren
(paren
r_struct
id|log_data
op_star
op_star
)paren
id|file-&gt;private_data
)paren
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|inf-&gt;usage_cnt
op_decrement
suffix:semicolon
multiline_comment|/* new usage count */
(paren
r_struct
id|log_data
op_star
op_star
)paren
id|file-&gt;private_data
op_assign
op_amp
id|inf-&gt;next
suffix:semicolon
multiline_comment|/* next structure */
r_if
c_cond
(paren
(paren
id|len
op_assign
id|strlen
c_func
(paren
id|inf-&gt;log_start
)paren
)paren
op_le
id|count
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|inf-&gt;log_start
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|file-&gt;f_pos
op_add_assign
id|len
suffix:semicolon
r_return
(paren
id|len
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* hysdn_log_read */
multiline_comment|/******************/
multiline_comment|/* open log file */
multiline_comment|/******************/
r_static
r_int
DECL|function|hysdn_log_open
id|hysdn_log_open
c_func
(paren
r_struct
id|inode
op_star
id|ino
comma
r_struct
id|file
op_star
id|filep
)paren
(brace
id|hysdn_card
op_star
id|card
suffix:semicolon
r_struct
id|procdata
op_star
id|pd
suffix:semicolon
id|ulong
id|flags
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|card
op_assign
id|card_root
suffix:semicolon
r_while
c_loop
(paren
id|card
)paren
(brace
id|pd
op_assign
id|card-&gt;procfs
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;log-&gt;low_ino
op_eq
(paren
id|ino-&gt;i_ino
op_amp
l_int|0xFFFF
)paren
)paren
r_break
suffix:semicolon
id|card
op_assign
id|card-&gt;next
suffix:semicolon
multiline_comment|/* search next entry */
)brace
r_if
c_cond
(paren
op_logical_neg
id|card
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
multiline_comment|/* device is unknown/invalid */
)brace
id|filep-&gt;private_data
op_assign
id|card
suffix:semicolon
multiline_comment|/* remember our own card */
r_if
c_cond
(paren
(paren
id|filep-&gt;f_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
)paren
op_eq
id|FMODE_WRITE
)paren
(brace
multiline_comment|/* write only access -&gt; boot pof data */
r_if
c_cond
(paren
id|pof_boot_open
c_func
(paren
id|card
)paren
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EPERM
)paren
suffix:semicolon
multiline_comment|/* no permission this time */
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|filep-&gt;f_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
)paren
op_eq
id|FMODE_READ
)paren
(brace
multiline_comment|/* read access -&gt; log/debug read */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|pd-&gt;if_used
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;log_head
)paren
(paren
r_struct
id|log_data
op_star
op_star
)paren
id|filep-&gt;private_data
op_assign
op_amp
(paren
id|pd-&gt;log_tail-&gt;next
)paren
suffix:semicolon
r_else
(paren
r_struct
id|log_data
op_star
op_star
)paren
id|filep-&gt;private_data
op_assign
op_amp
(paren
id|pd-&gt;log_head
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* simultaneous read/write access forbidden ! */
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EPERM
)paren
suffix:semicolon
multiline_comment|/* no permission this time */
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* hysdn_log_open */
multiline_comment|/*******************************************************************************/
multiline_comment|/* close a cardlog file. If the file has been opened for exclusive write it is */
multiline_comment|/* assumed as pof data input and the pof loader is noticed about.              */
multiline_comment|/* Otherwise file is handled as log output. In this case the interface usage   */
multiline_comment|/* count is decremented and all buffers are noticed of closing. If this file   */
multiline_comment|/* was the last one to be closed, all buffers are freed.                       */
multiline_comment|/*******************************************************************************/
r_static
r_int
DECL|function|hysdn_log_close
id|hysdn_log_close
c_func
(paren
r_struct
id|inode
op_star
id|ino
comma
r_struct
id|file
op_star
id|filep
)paren
(brace
r_struct
id|log_data
op_star
id|inf
suffix:semicolon
r_struct
id|procdata
op_star
id|pd
suffix:semicolon
id|hysdn_card
op_star
id|card
suffix:semicolon
r_int
id|flags
comma
id|retval
op_assign
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|filep-&gt;f_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
)paren
op_eq
id|FMODE_WRITE
)paren
(brace
multiline_comment|/* write only access -&gt; write debug completely written */
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* success */
)brace
r_else
(brace
multiline_comment|/* read access -&gt; log/debug read, mark one further file as closed */
id|pd
op_assign
l_int|NULL
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|inf
op_assign
op_star
(paren
(paren
r_struct
id|log_data
op_star
op_star
)paren
id|filep-&gt;private_data
)paren
suffix:semicolon
multiline_comment|/* get first log entry */
r_if
c_cond
(paren
id|inf
)paren
id|pd
op_assign
(paren
r_struct
id|procdata
op_star
)paren
id|inf-&gt;proc_ctrl
suffix:semicolon
multiline_comment|/* still entries there */
r_else
(brace
multiline_comment|/* no info available -&gt; search card */
id|card
op_assign
id|card_root
suffix:semicolon
r_while
c_loop
(paren
id|card
)paren
(brace
id|pd
op_assign
id|card-&gt;procfs
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;log-&gt;low_ino
op_eq
(paren
id|ino-&gt;i_ino
op_amp
l_int|0xFFFF
)paren
)paren
r_break
suffix:semicolon
id|card
op_assign
id|card-&gt;next
suffix:semicolon
multiline_comment|/* search next entry */
)brace
r_if
c_cond
(paren
id|card
)paren
id|pd
op_assign
id|card-&gt;procfs
suffix:semicolon
multiline_comment|/* pointer to procfs ctrl */
)brace
r_if
c_cond
(paren
id|pd
)paren
id|pd-&gt;if_used
op_decrement
suffix:semicolon
multiline_comment|/* decrement interface usage count by one */
r_while
c_loop
(paren
id|inf
)paren
(brace
id|inf-&gt;usage_cnt
op_decrement
suffix:semicolon
multiline_comment|/* decrement usage count for buffers */
id|inf
op_assign
id|inf-&gt;next
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pd
)paren
r_if
c_cond
(paren
id|pd-&gt;if_used
op_le
l_int|0
)paren
multiline_comment|/* delete buffers if last file closed */
r_while
c_loop
(paren
id|pd-&gt;log_head
)paren
(brace
id|inf
op_assign
id|pd-&gt;log_head
suffix:semicolon
id|pd-&gt;log_head
op_assign
id|pd-&gt;log_head-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|inf
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* read access */
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|retval
)paren
suffix:semicolon
)brace
multiline_comment|/* hysdn_log_close */
multiline_comment|/*************************************************/
multiline_comment|/* select/poll routine to be able using select() */
multiline_comment|/*************************************************/
r_static
r_int
r_int
DECL|function|hysdn_log_poll
id|hysdn_log_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
id|word
id|ino
suffix:semicolon
id|hysdn_card
op_star
id|card
suffix:semicolon
r_struct
id|procdata
op_star
id|pd
suffix:semicolon
r_if
c_cond
(paren
(paren
id|file-&gt;f_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
)paren
op_eq
id|FMODE_WRITE
)paren
r_return
(paren
id|mask
)paren
suffix:semicolon
multiline_comment|/* no polling for write supported */
multiline_comment|/* we need to search the card */
id|ino
op_assign
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_ino
op_amp
l_int|0xFFFF
suffix:semicolon
multiline_comment|/* low-ino */
id|card
op_assign
id|card_root
suffix:semicolon
r_while
c_loop
(paren
id|card
)paren
(brace
id|pd
op_assign
id|card-&gt;procfs
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;log-&gt;low_ino
op_eq
id|ino
)paren
r_break
suffix:semicolon
id|card
op_assign
id|card-&gt;next
suffix:semicolon
multiline_comment|/* search next entry */
)brace
r_if
c_cond
(paren
op_logical_neg
id|card
)paren
r_return
(paren
id|mask
)paren
suffix:semicolon
multiline_comment|/* card not found */
id|poll_wait
c_func
(paren
id|file
comma
op_amp
(paren
id|pd-&gt;rd_queue
)paren
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
(paren
r_struct
id|log_data
op_star
op_star
)paren
id|file-&gt;private_data
)paren
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/* hysdn_log_poll */
multiline_comment|/**************************************************/
multiline_comment|/* table for log filesystem functions defined above. */
multiline_comment|/**************************************************/
DECL|variable|log_fops
r_static
r_struct
id|file_operations
id|log_fops
op_assign
(brace
id|llseek
suffix:colon
id|hysdn_dummy_lseek
comma
id|read
suffix:colon
id|hysdn_log_read
comma
id|write
suffix:colon
id|hysdn_log_write
comma
id|poll
suffix:colon
id|hysdn_log_poll
comma
id|open
suffix:colon
id|hysdn_log_open
comma
id|release
suffix:colon
id|hysdn_log_close
comma
)brace
suffix:semicolon
multiline_comment|/*****************************************/
multiline_comment|/* Output info data to the cardinfo file */
multiline_comment|/*****************************************/
r_static
r_int
DECL|function|info_read
id|info_read
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_char
id|tmp
(braket
id|INFO_OUT_LEN
op_star
l_int|11
op_plus
l_int|2
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
op_star
id|cp
suffix:semicolon
id|hysdn_card
op_star
id|card
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;id bus slot type irq iobase plx-mem    dp-mem     boot device&quot;
)paren
suffix:semicolon
id|cp
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* start of string */
r_while
c_loop
(paren
op_star
id|cp
)paren
id|cp
op_increment
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|cp
op_minus
id|tmp
)paren
op_mod
(paren
id|INFO_OUT_LEN
op_plus
l_int|1
)paren
)paren
op_ne
id|INFO_OUT_LEN
)paren
op_star
id|cp
op_increment
op_assign
l_char|&squot; &squot;
suffix:semicolon
op_star
id|cp
op_increment
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|card
op_assign
id|card_root
suffix:semicolon
multiline_comment|/* start of list */
r_while
c_loop
(paren
id|card
)paren
(brace
id|sprintf
c_func
(paren
id|cp
comma
l_string|&quot;%d  %3d %4d %4d %3d 0x%04x 0x%08x 0x%08x&quot;
comma
id|card-&gt;myid
comma
id|card-&gt;bus
comma
id|PCI_SLOT
c_func
(paren
id|card-&gt;devfn
)paren
comma
id|card-&gt;brdtype
comma
id|card-&gt;irq
comma
id|card-&gt;iobase
comma
id|card-&gt;plxbase
comma
id|card-&gt;membase
)paren
suffix:semicolon
id|card
op_assign
id|card-&gt;next
suffix:semicolon
r_while
c_loop
(paren
op_star
id|cp
)paren
id|cp
op_increment
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|cp
op_minus
id|tmp
)paren
op_mod
(paren
id|INFO_OUT_LEN
op_plus
l_int|1
)paren
)paren
op_ne
id|INFO_OUT_LEN
)paren
op_star
id|cp
op_increment
op_assign
l_char|&squot; &squot;
suffix:semicolon
op_star
id|cp
op_increment
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
)brace
id|i
op_assign
id|cp
op_minus
id|tmp
suffix:semicolon
op_star
id|start
op_assign
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_plus
id|length
OG
id|i
)paren
(brace
id|length
op_assign
id|i
op_minus
id|offset
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|offset
OG
id|i
)paren
(brace
id|length
op_assign
l_int|0
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
)brace
id|cp
op_assign
id|tmp
op_plus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
l_int|0
)paren
(brace
multiline_comment|/*   start_bh_atomic(); */
id|memcpy
c_func
(paren
id|buffer
comma
id|cp
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* end_bh_atomic(); */
r_return
id|length
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* info_read */
multiline_comment|/*****************************/
multiline_comment|/* hysdn subdir in /proc/net */
multiline_comment|/*****************************/
DECL|variable|hysdn_proc_entry
r_static
r_struct
id|proc_dir_entry
op_star
id|hysdn_proc_entry
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|hysdn_info_entry
r_static
r_struct
id|proc_dir_entry
op_star
id|hysdn_info_entry
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/***************************************************************************************/
multiline_comment|/* hysdn_procfs_init is called when the module is loaded and after the cards have been */
multiline_comment|/* detected. The needed proc dir and card entries are created.                         */
multiline_comment|/***************************************************************************************/
r_int
DECL|function|hysdn_procfs_init
id|hysdn_procfs_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|procdata
op_star
id|pd
suffix:semicolon
id|hysdn_card
op_star
id|card
suffix:semicolon
id|hysdn_proc_entry
op_assign
id|create_proc_entry
c_func
(paren
id|PROC_SUBDIR_NAME
comma
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
id|proc_net
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hysdn_proc_entry
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;HYSDN: unable to create hysdn subdir&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|hysdn_info_entry
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;cardinfo&quot;
comma
l_int|0
comma
id|hysdn_proc_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hysdn_info_entry
)paren
id|hysdn_info_entry-&gt;read_proc
op_assign
id|info_read
suffix:semicolon
multiline_comment|/* read info function */
multiline_comment|/* create all cardlog proc entries */
id|card
op_assign
id|card_root
suffix:semicolon
multiline_comment|/* start with first card */
r_while
c_loop
(paren
id|card
)paren
(brace
r_if
c_cond
(paren
(paren
id|pd
op_assign
(paren
r_struct
id|procdata
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|procdata
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|memset
c_func
(paren
id|pd
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|procdata
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|pd-&gt;log_name
comma
l_string|&quot;%s%d&quot;
comma
id|PROC_LOG_BASENAME
comma
id|card-&gt;myid
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pd-&gt;log
op_assign
id|create_proc_entry
c_func
(paren
id|pd-&gt;log_name
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|hysdn_proc_entry
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|pd-&gt;log-&gt;proc_fops
op_assign
op_amp
id|log_fops
suffix:semicolon
multiline_comment|/* set new operations table */
id|pd-&gt;log-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
)brace
id|init_waitqueue_head
c_func
(paren
op_amp
(paren
id|pd-&gt;rd_queue
)paren
)paren
suffix:semicolon
id|card-&gt;procfs
op_assign
(paren
r_void
op_star
)paren
id|pd
suffix:semicolon
multiline_comment|/* remember procfs structure */
)brace
id|card
op_assign
id|card-&gt;next
suffix:semicolon
multiline_comment|/* point to next card */
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;HYSDN: procfs Rev. %s initialised&bslash;n&quot;
comma
id|hysdn_getrev
c_func
(paren
id|hysdn_procfs_revision
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* hysdn_procfs_init */
multiline_comment|/***************************************************************************************/
multiline_comment|/* hysdn_procfs_release is called when the module is unloaded and before the cards     */
multiline_comment|/* resources are released. The module counter is assumed to be 0 !                     */
multiline_comment|/***************************************************************************************/
r_void
DECL|function|hysdn_procfs_release
id|hysdn_procfs_release
c_func
(paren
r_void
)paren
(brace
r_struct
id|procdata
op_star
id|pd
suffix:semicolon
id|hysdn_card
op_star
id|card
suffix:semicolon
id|card
op_assign
id|card_root
suffix:semicolon
multiline_comment|/* start with first card */
r_while
c_loop
(paren
id|card
)paren
(brace
r_if
c_cond
(paren
(paren
id|pd
op_assign
(paren
r_struct
id|procdata
op_star
)paren
id|card-&gt;procfs
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|pd-&gt;log
)paren
id|remove_proc_entry
c_func
(paren
id|pd-&gt;log_name
comma
id|hysdn_proc_entry
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pd
)paren
suffix:semicolon
multiline_comment|/* release memory */
)brace
id|card
op_assign
id|card-&gt;next
suffix:semicolon
multiline_comment|/* point to next card */
)brace
id|remove_proc_entry
c_func
(paren
l_string|&quot;cardinfo&quot;
comma
id|hysdn_proc_entry
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|PROC_SUBDIR_NAME
comma
id|proc_net
)paren
suffix:semicolon
)brace
multiline_comment|/* hysdn_procfs_release */
eof
