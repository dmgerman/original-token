multiline_comment|/* $Id: hysdn_init.c,v 1.6.6.1 2000/11/28 12:02:47 kai Exp $&n;&n; * Linux driver for HYSDN cards, init functions.&n; * written by Werner Cornelius (werner@titro.de) for Hypercope GmbH&n; *&n; * Copyright 1999  by Werner Cornelius (werner@titro.de)&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &quot;hysdn_defs.h&quot;
DECL|variable|hysdn_init_revision
r_static
r_char
op_star
id|hysdn_init_revision
op_assign
l_string|&quot;$Revision: 1.6.6.1 $&quot;
suffix:semicolon
DECL|variable|cardmax
r_int
id|cardmax
suffix:semicolon
multiline_comment|/* number of found cards */
DECL|variable|card_root
id|hysdn_card
op_star
id|card_root
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* pointer to first card */
multiline_comment|/**********************************************/
multiline_comment|/* table assigning PCI-sub ids to board types */
multiline_comment|/* the last entry contains all 0              */
multiline_comment|/**********************************************/
r_static
r_struct
(brace
DECL|member|subid
id|word
id|subid
suffix:semicolon
multiline_comment|/* PCI sub id */
DECL|member|cardtyp
id|uchar
id|cardtyp
suffix:semicolon
multiline_comment|/* card type assigned */
DECL|variable|pci_subid_map
)brace
id|pci_subid_map
(braket
)braket
op_assign
(brace
(brace
id|PCI_SUBDEVICE_ID_HYPERCOPE_METRO
comma
id|BD_METRO
)brace
comma
(brace
id|PCI_SUBDEVICE_ID_HYPERCOPE_CHAMP2
comma
id|BD_CHAMP2
)brace
comma
(brace
id|PCI_SUBDEVICE_ID_HYPERCOPE_ERGO
comma
id|BD_ERGO
)brace
comma
(brace
id|PCI_SUBDEVICE_ID_HYPERCOPE_OLD_ERGO
comma
id|BD_ERGO
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
multiline_comment|/* terminating entry */
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_struct
id|pci_device_id
id|hysdn_pci_tbl
(braket
)braket
id|__initdata
op_assign
(brace
(brace
id|PCI_VENDOR_ID_HYPERCOPE
comma
id|PCI_DEVICE_ID_HYPERCOPE_PLX
comma
id|PCI_ANY_ID
comma
id|PCI_SUBDEVICE_ID_HYPERCOPE_METRO
)brace
comma
(brace
id|PCI_VENDOR_ID_HYPERCOPE
comma
id|PCI_DEVICE_ID_HYPERCOPE_PLX
comma
id|PCI_ANY_ID
comma
id|PCI_SUBDEVICE_ID_HYPERCOPE_CHAMP2
)brace
comma
(brace
id|PCI_VENDOR_ID_HYPERCOPE
comma
id|PCI_DEVICE_ID_HYPERCOPE_PLX
comma
id|PCI_ANY_ID
comma
id|PCI_SUBDEVICE_ID_HYPERCOPE_ERGO
)brace
comma
(brace
id|PCI_VENDOR_ID_HYPERCOPE
comma
id|PCI_DEVICE_ID_HYPERCOPE_PLX
comma
id|PCI_ANY_ID
comma
id|PCI_SUBDEVICE_ID_HYPERCOPE_OLD_ERGO
)brace
comma
(brace
)brace
multiline_comment|/* Terminating entry */
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|hysdn_pci_tbl
)paren
suffix:semicolon
multiline_comment|/*********************************************************************/
multiline_comment|/* search_cards searches for available cards in the pci config data. */
multiline_comment|/* If a card is found, the card structure is allocated and the cards */
multiline_comment|/* ressources are reserved. cardmax is incremented.                  */
multiline_comment|/*********************************************************************/
r_static
r_void
DECL|function|search_cards
id|search_cards
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|akt_pcidev
op_assign
l_int|NULL
suffix:semicolon
id|hysdn_card
op_star
id|card
comma
op_star
id|card_last
suffix:semicolon
r_int
id|i
suffix:semicolon
id|card_root
op_assign
l_int|NULL
suffix:semicolon
id|card_last
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|akt_pcidev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_HYPERCOPE
comma
id|PCI_DEVICE_ID_HYPERCOPE_PLX
comma
id|akt_pcidev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|akt_pcidev
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|card
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|hysdn_card
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;HYSDN: unable to alloc device mem &bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|card
comma
l_int|0
comma
r_sizeof
(paren
id|hysdn_card
)paren
)paren
suffix:semicolon
id|card-&gt;myid
op_assign
id|cardmax
suffix:semicolon
multiline_comment|/* set own id */
id|card-&gt;bus
op_assign
id|akt_pcidev-&gt;bus-&gt;number
suffix:semicolon
id|card-&gt;devfn
op_assign
id|akt_pcidev-&gt;devfn
suffix:semicolon
multiline_comment|/* slot + function */
id|card-&gt;subsysid
op_assign
id|akt_pcidev-&gt;subsystem_device
suffix:semicolon
id|card-&gt;irq
op_assign
id|akt_pcidev-&gt;irq
suffix:semicolon
id|card-&gt;iobase
op_assign
id|pci_resource_start
c_func
(paren
id|akt_pcidev
comma
id|PCI_REG_PLX_IO_BASE
)paren
suffix:semicolon
id|card-&gt;plxbase
op_assign
id|pci_resource_start
c_func
(paren
id|akt_pcidev
comma
id|PCI_REG_PLX_MEM_BASE
)paren
suffix:semicolon
id|card-&gt;membase
op_assign
id|pci_resource_start
c_func
(paren
id|akt_pcidev
comma
id|PCI_REG_MEMORY_BASE
)paren
suffix:semicolon
id|card-&gt;brdtype
op_assign
id|BD_NONE
suffix:semicolon
multiline_comment|/* unknown */
id|card-&gt;debug_flags
op_assign
id|DEF_DEB_FLAGS
suffix:semicolon
multiline_comment|/* set default debug */
id|card-&gt;faxchans
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default no fax channels */
id|card-&gt;bchans
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* and 2 b-channels */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|pci_subid_map
(braket
id|i
)braket
dot
id|subid
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|pci_subid_map
(braket
id|i
)braket
dot
id|subid
op_eq
id|card-&gt;subsysid
)paren
(brace
id|card-&gt;brdtype
op_assign
id|pci_subid_map
(braket
id|i
)braket
dot
id|cardtyp
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;brdtype
op_ne
id|BD_NONE
)paren
(brace
r_if
c_cond
(paren
id|ergo_inithardware
c_func
(paren
id|card
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;HYSDN: card at io 0x%04x already in use&bslash;n&quot;
comma
id|card-&gt;iobase
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;HYSDN: unknown card id 0x%04x&bslash;n&quot;
comma
id|card-&gt;subsysid
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/* release mem */
r_continue
suffix:semicolon
)brace
id|cardmax
op_increment
suffix:semicolon
id|card-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*end of chain */
r_if
c_cond
(paren
id|card_last
)paren
id|card_last-&gt;next
op_assign
id|card
suffix:semicolon
multiline_comment|/* pointer to next card */
r_else
id|card_root
op_assign
id|card
suffix:semicolon
id|card_last
op_assign
id|card
suffix:semicolon
multiline_comment|/* new chain end */
)brace
multiline_comment|/* device found */
)brace
multiline_comment|/* search_cards */
multiline_comment|/************************************************************************************/
multiline_comment|/* free_resources frees the acquired PCI resources and returns the allocated memory */
multiline_comment|/************************************************************************************/
r_static
r_void
DECL|function|free_resources
id|free_resources
c_func
(paren
r_void
)paren
(brace
id|hysdn_card
op_star
id|card
suffix:semicolon
r_while
c_loop
(paren
id|card_root
)paren
(brace
id|card
op_assign
id|card_root
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;releasehardware
)paren
id|card
op_member_access_from_pointer
id|releasehardware
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/* free all hardware resources */
id|card_root
op_assign
id|card_root-&gt;next
suffix:semicolon
multiline_comment|/* remove card from chain */
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/* return mem */
)brace
multiline_comment|/* while card_root */
)brace
multiline_comment|/* free_resources */
multiline_comment|/**************************************************************************/
multiline_comment|/* stop_cards disables (hardware resets) all cards and disables interrupt */
multiline_comment|/**************************************************************************/
r_static
r_void
DECL|function|stop_cards
id|stop_cards
c_func
(paren
r_void
)paren
(brace
id|hysdn_card
op_star
id|card
suffix:semicolon
id|card
op_assign
id|card_root
suffix:semicolon
multiline_comment|/* first in chain */
r_while
c_loop
(paren
id|card
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;stopcard
)paren
id|card
op_member_access_from_pointer
id|stopcard
c_func
(paren
id|card
)paren
suffix:semicolon
id|card
op_assign
id|card-&gt;next
suffix:semicolon
multiline_comment|/* remove card from chain */
)brace
multiline_comment|/* while card */
)brace
multiline_comment|/* stop_cards */
multiline_comment|/****************************************************************************/
multiline_comment|/* The module startup and shutdown code. Only compiled when used as module. */
multiline_comment|/* Using the driver as module is always advisable, because the booting      */
multiline_comment|/* image becomes smaller and the driver code is only loaded when needed.    */
multiline_comment|/* Additionally newer versions may be activated without rebooting.          */
multiline_comment|/****************************************************************************/
macro_line|#ifdef CONFIG_MODULES
multiline_comment|/******************************************************/
multiline_comment|/* extract revision number from string for log output */
multiline_comment|/******************************************************/
r_char
op_star
DECL|function|hysdn_getrev
id|hysdn_getrev
c_func
(paren
r_const
r_char
op_star
id|revision
)paren
(brace
r_char
op_star
id|rev
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p
op_assign
id|strchr
c_func
(paren
id|revision
comma
l_char|&squot;:&squot;
)paren
)paren
)paren
(brace
id|rev
op_assign
id|p
op_plus
l_int|2
suffix:semicolon
id|p
op_assign
id|strchr
c_func
(paren
id|rev
comma
l_char|&squot;$&squot;
)paren
suffix:semicolon
op_star
op_decrement
id|p
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|rev
op_assign
l_string|&quot;???&quot;
suffix:semicolon
r_return
id|rev
suffix:semicolon
)brace
multiline_comment|/****************************************************************************/
multiline_comment|/* init_module is called once when the module is loaded to do all necessary */
multiline_comment|/* things like autodetect...                                                */
multiline_comment|/* If the return value of this function is 0 the init has been successfull  */
multiline_comment|/* and the module is added to the list in /proc/modules, otherwise an error */
multiline_comment|/* is assumed and the module will not be kept in memory.                    */
multiline_comment|/****************************************************************************/
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
r_char
id|tmp
(braket
l_int|50
)braket
suffix:semicolon
id|strcpy
c_func
(paren
id|tmp
comma
id|hysdn_init_revision
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;HYSDN: module Rev: %s loaded&bslash;n&quot;
comma
id|hysdn_getrev
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|tmp
comma
id|hysdn_net_revision
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;HYSDN: network interface Rev: %s &bslash;n&quot;
comma
id|hysdn_getrev
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;HYSDN: no PCI bus present, module not loaded&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|search_cards
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;HYSDN: %d card(s) found.&bslash;n&quot;
comma
id|cardmax
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hysdn_procconf_init
c_func
(paren
)paren
)paren
(brace
id|free_resources
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* proc file_sys not created */
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_HYSDN_CAPI
r_if
c_cond
(paren
id|cardmax
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|hycapi_init
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;HYCAPI: init failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_HYSDN_CAPI */
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* no error */
)brace
multiline_comment|/* init_module */
multiline_comment|/***********************************************************************/
multiline_comment|/* cleanup_module is called when the module is released by the kernel. */
multiline_comment|/* The routine is only called if init_module has been successfull and  */
multiline_comment|/* the module counter has a value of 0. Otherwise this function will   */
multiline_comment|/* not be called. This function must release all resources still allo- */
multiline_comment|/* cated as after the return from this function the module code will   */
multiline_comment|/* be removed from memory.                                             */
multiline_comment|/***********************************************************************/
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_HYSDN_CAPI
id|hysdn_card
op_star
id|card
suffix:semicolon
macro_line|#endif /* CONFIG_HYSDN_CAPI */
id|stop_cards
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_HYSDN_CAPI
id|card
op_assign
id|card_root
suffix:semicolon
multiline_comment|/* first in chain */
r_while
c_loop
(paren
id|card
)paren
(brace
id|hycapi_capi_release
c_func
(paren
id|card
)paren
suffix:semicolon
id|card
op_assign
id|card-&gt;next
suffix:semicolon
multiline_comment|/* remove card from chain */
)brace
multiline_comment|/* while card */
id|hycapi_cleanup
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_HYSDN_CAPI */
id|hysdn_procconf_release
c_func
(paren
)paren
suffix:semicolon
id|free_resources
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;HYSDN: module unloaded&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* cleanup_module */
macro_line|#endif&t;&t;&t;&t;/* CONFIG_MODULES */
eof
