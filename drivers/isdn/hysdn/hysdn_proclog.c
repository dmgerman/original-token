multiline_comment|/* $Id: hysdn_proclog.c,v 1.9 2000/11/25 17:01:01 kai Exp $&n;&n; * Linux driver for HYSDN cards, /proc/net filesystem log functions.&n; * written by Werner Cornelius (werner@titro.de) for Hypercope GmbH&n; *&n; * Copyright 1999  by Werner Cornelius (werner@titro.de)&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; */
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &quot;hysdn_defs.h&quot;
multiline_comment|/* the proc subdir for the interface is defined in the procconf module */
r_extern
r_struct
id|proc_dir_entry
op_star
id|hysdn_proc_entry
suffix:semicolon
multiline_comment|/*************************************************/
multiline_comment|/* structure keeping ascii log for device output */
multiline_comment|/*************************************************/
DECL|struct|log_data
r_struct
id|log_data
(brace
DECL|member|next
r_struct
id|log_data
op_star
id|next
suffix:semicolon
DECL|member|usage_cnt
id|ulong
id|usage_cnt
suffix:semicolon
multiline_comment|/* number of files still to work */
DECL|member|proc_ctrl
r_void
op_star
id|proc_ctrl
suffix:semicolon
multiline_comment|/* pointer to own control procdata structure */
DECL|member|log_start
r_char
id|log_start
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* log string start (final len aligned by size) */
)brace
suffix:semicolon
multiline_comment|/**********************************************/
multiline_comment|/* structure holding proc entrys for one card */
multiline_comment|/**********************************************/
DECL|struct|procdata
r_struct
id|procdata
(brace
DECL|member|log
r_struct
id|proc_dir_entry
op_star
id|log
suffix:semicolon
multiline_comment|/* log entry */
DECL|member|log_name
r_char
id|log_name
(braket
l_int|15
)braket
suffix:semicolon
multiline_comment|/* log filename */
DECL|member|log_head
DECL|member|log_tail
r_struct
id|log_data
op_star
id|log_head
comma
op_star
id|log_tail
suffix:semicolon
multiline_comment|/* head and tail for queue */
DECL|member|if_used
r_int
id|if_used
suffix:semicolon
multiline_comment|/* open count for interface */
DECL|member|del_lock
r_int
r_volatile
id|del_lock
suffix:semicolon
multiline_comment|/* lock for delete operations */
DECL|member|logtmp
id|uchar
id|logtmp
(braket
id|LOG_MAX_LINELEN
)braket
suffix:semicolon
DECL|member|rd_queue
id|wait_queue_head_t
id|rd_queue
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**********************************************/
multiline_comment|/* log function for cards error log interface */
multiline_comment|/**********************************************/
r_void
DECL|function|hysdn_card_errlog
id|hysdn_card_errlog
c_func
(paren
id|hysdn_card
op_star
id|card
comma
id|tErrLogEntry
op_star
id|logp
comma
r_int
id|maxsize
)paren
(brace
r_char
id|buf
(braket
id|ERRLOG_TEXT_SIZE
op_plus
l_int|40
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;LOG 0x%08lX 0x%08lX : %s&bslash;n&quot;
comma
id|logp-&gt;ulErrType
comma
id|logp-&gt;ulErrSubtype
comma
id|logp-&gt;ucText
)paren
suffix:semicolon
id|put_log_buffer
c_func
(paren
id|card
comma
id|buf
)paren
suffix:semicolon
multiline_comment|/* output the string */
)brace
multiline_comment|/* hysdn_card_errlog */
multiline_comment|/***************************************************/
multiline_comment|/* Log function using format specifiers for output */
multiline_comment|/***************************************************/
r_void
DECL|function|hysdn_addlog
id|hysdn_addlog
c_func
(paren
id|hysdn_card
op_star
id|card
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
r_struct
id|procdata
op_star
id|pd
op_assign
id|card-&gt;proclog
suffix:semicolon
r_char
op_star
id|cp
suffix:semicolon
id|va_list
id|args
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pd
)paren
r_return
suffix:semicolon
multiline_comment|/* log structure non existent */
id|cp
op_assign
id|pd-&gt;logtmp
suffix:semicolon
id|cp
op_add_assign
id|sprintf
c_func
(paren
id|cp
comma
l_string|&quot;HYSDN: card %d &quot;
comma
id|card-&gt;myid
)paren
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|cp
op_add_assign
id|vsprintf
c_func
(paren
id|cp
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
op_star
id|cp
op_increment
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
op_star
id|cp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;debug_flags
op_amp
id|DEB_OUT_SYSLOG
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s&quot;
comma
id|pd-&gt;logtmp
)paren
suffix:semicolon
r_else
id|put_log_buffer
c_func
(paren
id|card
comma
id|pd-&gt;logtmp
)paren
suffix:semicolon
)brace
multiline_comment|/* hysdn_addlog */
multiline_comment|/********************************************/
multiline_comment|/* put an log buffer into the log queue.    */
multiline_comment|/* This buffer will be kept until all files */
multiline_comment|/* opened for read got the contents.        */
multiline_comment|/* Flushes buffers not longer in use.       */
multiline_comment|/********************************************/
r_void
DECL|function|put_log_buffer
id|put_log_buffer
c_func
(paren
id|hysdn_card
op_star
id|card
comma
r_char
op_star
id|cp
)paren
(brace
r_struct
id|log_data
op_star
id|ib
suffix:semicolon
r_struct
id|procdata
op_star
id|pd
op_assign
id|card-&gt;proclog
suffix:semicolon
r_int
id|i
comma
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pd
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|cp
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;if_used
op_le
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* no open file for read */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ib
op_assign
(paren
r_struct
id|log_data
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|log_data
)paren
op_plus
id|strlen
c_func
(paren
id|cp
)paren
comma
id|GFP_ATOMIC
)paren
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* no memory */
id|strcpy
c_func
(paren
id|ib-&gt;log_start
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/* set output string */
id|ib-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|ib-&gt;proc_ctrl
op_assign
id|pd
suffix:semicolon
multiline_comment|/* point to own control structure */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ib-&gt;usage_cnt
op_assign
id|pd-&gt;if_used
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pd-&gt;log_head
)paren
id|pd-&gt;log_head
op_assign
id|ib
suffix:semicolon
multiline_comment|/* new head */
r_else
id|pd-&gt;log_tail-&gt;next
op_assign
id|ib
suffix:semicolon
multiline_comment|/* follows existing messages */
id|pd-&gt;log_tail
op_assign
id|ib
suffix:semicolon
multiline_comment|/* new tail */
id|i
op_assign
id|pd-&gt;del_lock
op_increment
suffix:semicolon
multiline_comment|/* get lock state */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* delete old entrys */
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_while
c_loop
(paren
id|pd-&gt;log_head-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|pd-&gt;log_head-&gt;usage_cnt
op_le
l_int|0
)paren
op_logical_and
(paren
id|pd-&gt;log_head-&gt;next-&gt;usage_cnt
op_le
l_int|0
)paren
)paren
(brace
id|ib
op_assign
id|pd-&gt;log_head
suffix:semicolon
id|pd-&gt;log_head
op_assign
id|pd-&gt;log_head-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|ib
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
multiline_comment|/* pd-&gt;log_head-&gt;next */
id|pd-&gt;del_lock
op_decrement
suffix:semicolon
multiline_comment|/* release lock level */
id|wake_up_interruptible
c_func
(paren
op_amp
(paren
id|pd-&gt;rd_queue
)paren
)paren
suffix:semicolon
multiline_comment|/* announce new entry */
)brace
multiline_comment|/* put_log_buffer */
multiline_comment|/*************************/
multiline_comment|/* dummy file operations */
multiline_comment|/*************************/
r_static
id|loff_t
DECL|function|hysdn_dummy_lseek
id|hysdn_dummy_lseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|orig
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
multiline_comment|/* hysdn_dummy_lseek */
multiline_comment|/******************************/
multiline_comment|/* file operations and tables */
multiline_comment|/******************************/
multiline_comment|/****************************************/
multiline_comment|/* write log file -&gt; set log level bits */
multiline_comment|/****************************************/
r_static
id|ssize_t
DECL|function|hysdn_log_write
id|hysdn_log_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|off
)paren
(brace
id|ulong
id|u
op_assign
l_int|0
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
id|uchar
op_star
id|cp
comma
id|valbuf
(braket
l_int|128
)braket
suffix:semicolon
r_int
id|base
op_assign
l_int|10
suffix:semicolon
id|hysdn_card
op_star
id|card
op_assign
(paren
id|hysdn_card
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_amp
id|file-&gt;f_pos
op_ne
id|off
)paren
multiline_comment|/* fs error check */
r_return
(paren
op_minus
id|ESPIPE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
(paren
r_sizeof
(paren
id|valbuf
)paren
op_minus
l_int|1
)paren
)paren
id|count
op_assign
r_sizeof
(paren
id|valbuf
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* limit length */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|valbuf
comma
id|buf
comma
id|count
)paren
)paren
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
multiline_comment|/* copy failed */
id|valbuf
(braket
id|count
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* terminating 0 */
id|cp
op_assign
id|valbuf
suffix:semicolon
r_if
c_cond
(paren
(paren
id|count
OG
l_int|2
)paren
op_logical_and
(paren
id|valbuf
(braket
l_int|0
)braket
op_eq
l_char|&squot;0&squot;
)paren
op_logical_and
(paren
id|valbuf
(braket
l_int|1
)braket
op_eq
l_char|&squot;x&squot;
)paren
)paren
(brace
id|cp
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* pointer after hex modifier */
id|base
op_assign
l_int|16
suffix:semicolon
)brace
multiline_comment|/* scan the input for debug flags */
r_while
c_loop
(paren
op_star
id|cp
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|cp
op_ge
l_char|&squot;0&squot;
)paren
op_logical_and
(paren
op_star
id|cp
op_le
l_char|&squot;9&squot;
)paren
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
id|u
op_mul_assign
id|base
suffix:semicolon
multiline_comment|/* adjust to next digit */
id|u
op_add_assign
op_star
id|cp
op_increment
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base
op_ne
l_int|16
)paren
r_break
suffix:semicolon
multiline_comment|/* end of number */
r_if
c_cond
(paren
(paren
op_star
id|cp
op_ge
l_char|&squot;a&squot;
)paren
op_logical_and
(paren
op_star
id|cp
op_le
l_char|&squot;f&squot;
)paren
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
id|u
op_mul_assign
id|base
suffix:semicolon
multiline_comment|/* adjust to next digit */
id|u
op_add_assign
op_star
id|cp
op_increment
op_minus
l_char|&squot;a&squot;
op_plus
l_int|10
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* terminated */
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|card-&gt;debug_flags
op_assign
id|u
suffix:semicolon
multiline_comment|/* remember debug flags */
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;debug set to 0x%lx&quot;
comma
id|card-&gt;debug_flags
)paren
suffix:semicolon
)brace
r_return
(paren
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* hysdn_log_write */
multiline_comment|/******************/
multiline_comment|/* read log file */
multiline_comment|/******************/
r_static
id|ssize_t
DECL|function|hysdn_log_read
id|hysdn_log_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|off
)paren
(brace
r_struct
id|log_data
op_star
id|inf
suffix:semicolon
r_int
id|len
suffix:semicolon
id|word
id|ino
suffix:semicolon
r_struct
id|procdata
op_star
id|pd
suffix:semicolon
id|hysdn_card
op_star
id|card
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
(paren
(paren
r_struct
id|log_data
op_star
op_star
)paren
id|file-&gt;private_data
)paren
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
multiline_comment|/* sorry, but we need to search the card */
id|ino
op_assign
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_ino
op_amp
l_int|0xFFFF
suffix:semicolon
multiline_comment|/* low-ino */
id|card
op_assign
id|card_root
suffix:semicolon
r_while
c_loop
(paren
id|card
)paren
(brace
id|pd
op_assign
id|card-&gt;proclog
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;log-&gt;low_ino
op_eq
id|ino
)paren
r_break
suffix:semicolon
id|card
op_assign
id|card-&gt;next
suffix:semicolon
multiline_comment|/* search next entry */
)brace
r_if
c_cond
(paren
id|card
)paren
id|interruptible_sleep_on
c_func
(paren
op_amp
(paren
id|pd-&gt;rd_queue
)paren
)paren
suffix:semicolon
r_else
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inf
op_assign
op_star
(paren
(paren
r_struct
id|log_data
op_star
op_star
)paren
id|file-&gt;private_data
)paren
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|inf-&gt;usage_cnt
op_decrement
suffix:semicolon
multiline_comment|/* new usage count */
(paren
r_struct
id|log_data
op_star
op_star
)paren
id|file-&gt;private_data
op_assign
op_amp
id|inf-&gt;next
suffix:semicolon
multiline_comment|/* next structure */
r_if
c_cond
(paren
(paren
id|len
op_assign
id|strlen
c_func
(paren
id|inf-&gt;log_start
)paren
)paren
op_le
id|count
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|inf-&gt;log_start
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|file-&gt;f_pos
op_add_assign
id|len
suffix:semicolon
r_return
(paren
id|len
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* hysdn_log_read */
multiline_comment|/******************/
multiline_comment|/* open log file */
multiline_comment|/******************/
r_static
r_int
DECL|function|hysdn_log_open
id|hysdn_log_open
c_func
(paren
r_struct
id|inode
op_star
id|ino
comma
r_struct
id|file
op_star
id|filep
)paren
(brace
id|hysdn_card
op_star
id|card
suffix:semicolon
r_struct
id|procdata
op_star
id|pd
suffix:semicolon
id|ulong
id|flags
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|card
op_assign
id|card_root
suffix:semicolon
r_while
c_loop
(paren
id|card
)paren
(brace
id|pd
op_assign
id|card-&gt;proclog
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;log-&gt;low_ino
op_eq
(paren
id|ino-&gt;i_ino
op_amp
l_int|0xFFFF
)paren
)paren
r_break
suffix:semicolon
id|card
op_assign
id|card-&gt;next
suffix:semicolon
multiline_comment|/* search next entry */
)brace
r_if
c_cond
(paren
op_logical_neg
id|card
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
multiline_comment|/* device is unknown/invalid */
)brace
id|filep-&gt;private_data
op_assign
id|card
suffix:semicolon
multiline_comment|/* remember our own card */
r_if
c_cond
(paren
(paren
id|filep-&gt;f_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
)paren
op_eq
id|FMODE_WRITE
)paren
(brace
multiline_comment|/* write only access -&gt; write log level only */
)brace
r_else
r_if
c_cond
(paren
(paren
id|filep-&gt;f_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
)paren
op_eq
id|FMODE_READ
)paren
(brace
multiline_comment|/* read access -&gt; log/debug read */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|pd-&gt;if_used
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;log_head
)paren
(paren
r_struct
id|log_data
op_star
op_star
)paren
id|filep-&gt;private_data
op_assign
op_amp
(paren
id|pd-&gt;log_tail-&gt;next
)paren
suffix:semicolon
r_else
(paren
r_struct
id|log_data
op_star
op_star
)paren
id|filep-&gt;private_data
op_assign
op_amp
(paren
id|pd-&gt;log_head
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* simultaneous read/write access forbidden ! */
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EPERM
)paren
suffix:semicolon
multiline_comment|/* no permission this time */
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* hysdn_log_open */
multiline_comment|/*******************************************************************************/
multiline_comment|/* close a cardlog file. If the file has been opened for exclusive write it is */
multiline_comment|/* assumed as pof data input and the pof loader is noticed about.              */
multiline_comment|/* Otherwise file is handled as log output. In this case the interface usage   */
multiline_comment|/* count is decremented and all buffers are noticed of closing. If this file   */
multiline_comment|/* was the last one to be closed, all buffers are freed.                       */
multiline_comment|/*******************************************************************************/
r_static
r_int
DECL|function|hysdn_log_close
id|hysdn_log_close
c_func
(paren
r_struct
id|inode
op_star
id|ino
comma
r_struct
id|file
op_star
id|filep
)paren
(brace
r_struct
id|log_data
op_star
id|inf
suffix:semicolon
r_struct
id|procdata
op_star
id|pd
suffix:semicolon
id|hysdn_card
op_star
id|card
suffix:semicolon
r_int
id|flags
comma
id|retval
op_assign
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|filep-&gt;f_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
)paren
op_eq
id|FMODE_WRITE
)paren
(brace
multiline_comment|/* write only access -&gt; write debug level written */
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* success */
)brace
r_else
(brace
multiline_comment|/* read access -&gt; log/debug read, mark one further file as closed */
id|pd
op_assign
l_int|NULL
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|inf
op_assign
op_star
(paren
(paren
r_struct
id|log_data
op_star
op_star
)paren
id|filep-&gt;private_data
)paren
suffix:semicolon
multiline_comment|/* get first log entry */
r_if
c_cond
(paren
id|inf
)paren
id|pd
op_assign
(paren
r_struct
id|procdata
op_star
)paren
id|inf-&gt;proc_ctrl
suffix:semicolon
multiline_comment|/* still entries there */
r_else
(brace
multiline_comment|/* no info available -&gt; search card */
id|card
op_assign
id|card_root
suffix:semicolon
r_while
c_loop
(paren
id|card
)paren
(brace
id|pd
op_assign
id|card-&gt;proclog
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;log-&gt;low_ino
op_eq
(paren
id|ino-&gt;i_ino
op_amp
l_int|0xFFFF
)paren
)paren
r_break
suffix:semicolon
id|card
op_assign
id|card-&gt;next
suffix:semicolon
multiline_comment|/* search next entry */
)brace
r_if
c_cond
(paren
id|card
)paren
id|pd
op_assign
id|card-&gt;proclog
suffix:semicolon
multiline_comment|/* pointer to procfs log */
)brace
r_if
c_cond
(paren
id|pd
)paren
id|pd-&gt;if_used
op_decrement
suffix:semicolon
multiline_comment|/* decrement interface usage count by one */
r_while
c_loop
(paren
id|inf
)paren
(brace
id|inf-&gt;usage_cnt
op_decrement
suffix:semicolon
multiline_comment|/* decrement usage count for buffers */
id|inf
op_assign
id|inf-&gt;next
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pd
)paren
r_if
c_cond
(paren
id|pd-&gt;if_used
op_le
l_int|0
)paren
multiline_comment|/* delete buffers if last file closed */
r_while
c_loop
(paren
id|pd-&gt;log_head
)paren
(brace
id|inf
op_assign
id|pd-&gt;log_head
suffix:semicolon
id|pd-&gt;log_head
op_assign
id|pd-&gt;log_head-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|inf
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* read access */
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|retval
)paren
suffix:semicolon
)brace
multiline_comment|/* hysdn_log_close */
multiline_comment|/*************************************************/
multiline_comment|/* select/poll routine to be able using select() */
multiline_comment|/*************************************************/
r_static
r_int
r_int
DECL|function|hysdn_log_poll
id|hysdn_log_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
id|word
id|ino
suffix:semicolon
id|hysdn_card
op_star
id|card
suffix:semicolon
r_struct
id|procdata
op_star
id|pd
suffix:semicolon
r_if
c_cond
(paren
(paren
id|file-&gt;f_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
)paren
op_eq
id|FMODE_WRITE
)paren
r_return
(paren
id|mask
)paren
suffix:semicolon
multiline_comment|/* no polling for write supported */
multiline_comment|/* we need to search the card */
id|ino
op_assign
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_ino
op_amp
l_int|0xFFFF
suffix:semicolon
multiline_comment|/* low-ino */
id|card
op_assign
id|card_root
suffix:semicolon
r_while
c_loop
(paren
id|card
)paren
(brace
id|pd
op_assign
id|card-&gt;proclog
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;log-&gt;low_ino
op_eq
id|ino
)paren
r_break
suffix:semicolon
id|card
op_assign
id|card-&gt;next
suffix:semicolon
multiline_comment|/* search next entry */
)brace
r_if
c_cond
(paren
op_logical_neg
id|card
)paren
r_return
(paren
id|mask
)paren
suffix:semicolon
multiline_comment|/* card not found */
id|poll_wait
c_func
(paren
id|file
comma
op_amp
(paren
id|pd-&gt;rd_queue
)paren
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
(paren
r_struct
id|log_data
op_star
op_star
)paren
id|file-&gt;private_data
)paren
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/* hysdn_log_poll */
multiline_comment|/**************************************************/
multiline_comment|/* table for log filesystem functions defined above. */
multiline_comment|/**************************************************/
DECL|variable|log_fops
r_static
r_struct
id|file_operations
id|log_fops
op_assign
(brace
id|llseek
suffix:colon
id|hysdn_dummy_lseek
comma
id|read
suffix:colon
id|hysdn_log_read
comma
id|write
suffix:colon
id|hysdn_log_write
comma
id|poll
suffix:colon
id|hysdn_log_poll
comma
id|open
suffix:colon
id|hysdn_log_open
comma
id|release
suffix:colon
id|hysdn_log_close
comma
)brace
suffix:semicolon
multiline_comment|/***********************************************************************************/
multiline_comment|/* hysdn_proclog_init is called when the module is loaded after creating the cards */
multiline_comment|/* conf files.                                                                     */
multiline_comment|/***********************************************************************************/
r_int
DECL|function|hysdn_proclog_init
id|hysdn_proclog_init
c_func
(paren
id|hysdn_card
op_star
id|card
)paren
(brace
r_struct
id|procdata
op_star
id|pd
suffix:semicolon
multiline_comment|/* create a cardlog proc entry */
r_if
c_cond
(paren
(paren
id|pd
op_assign
(paren
r_struct
id|procdata
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|procdata
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|memset
c_func
(paren
id|pd
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|procdata
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|pd-&gt;log_name
comma
l_string|&quot;%s%d&quot;
comma
id|PROC_LOG_BASENAME
comma
id|card-&gt;myid
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pd-&gt;log
op_assign
id|create_proc_entry
c_func
(paren
id|pd-&gt;log_name
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|hysdn_proc_entry
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|pd-&gt;log-&gt;proc_fops
op_assign
op_amp
id|log_fops
suffix:semicolon
id|pd-&gt;log-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
)brace
id|init_waitqueue_head
c_func
(paren
op_amp
(paren
id|pd-&gt;rd_queue
)paren
)paren
suffix:semicolon
id|card-&gt;proclog
op_assign
(paren
r_void
op_star
)paren
id|pd
suffix:semicolon
multiline_comment|/* remember procfs structure */
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* hysdn_proclog_init */
multiline_comment|/************************************************************************************/
multiline_comment|/* hysdn_proclog_release is called when the module is unloaded and before the cards */
multiline_comment|/* conf file is released                                                            */
multiline_comment|/* The module counter is assumed to be 0 !                                          */
multiline_comment|/************************************************************************************/
r_void
DECL|function|hysdn_proclog_release
id|hysdn_proclog_release
c_func
(paren
id|hysdn_card
op_star
id|card
)paren
(brace
r_struct
id|procdata
op_star
id|pd
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pd
op_assign
(paren
r_struct
id|procdata
op_star
)paren
id|card-&gt;proclog
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|pd-&gt;log
)paren
id|remove_proc_entry
c_func
(paren
id|pd-&gt;log_name
comma
id|hysdn_proc_entry
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pd
)paren
suffix:semicolon
multiline_comment|/* release memory */
id|card-&gt;proclog
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* hysdn_proclog_release */
eof
