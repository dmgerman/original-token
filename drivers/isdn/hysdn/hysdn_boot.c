multiline_comment|/* $Id: hysdn_boot.c,v 1.4 2000/11/13 22:51:47 kai Exp $&n;&n; * Linux driver for HYSDN cards, specific routines for booting and pof handling.&n; *&n; * written by Werner Cornelius (werner@titro.de) for Hypercope GmbH&n; *&n; * Copyright 1999  by Werner Cornelius (werner@titro.de)&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; */
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;hysdn_defs.h&quot;
macro_line|#include &quot;hysdn_pof.h&quot;
multiline_comment|/********************************/
multiline_comment|/* defines for pof read handler */
multiline_comment|/********************************/
DECL|macro|POF_READ_FILE_HEAD
mdefine_line|#define POF_READ_FILE_HEAD  0
DECL|macro|POF_READ_TAG_HEAD
mdefine_line|#define POF_READ_TAG_HEAD   1
DECL|macro|POF_READ_TAG_DATA
mdefine_line|#define POF_READ_TAG_DATA   2
multiline_comment|/************************************************************/
multiline_comment|/* definition of boot specific data area. This data is only */
multiline_comment|/* needed during boot and so allocated dynamically.         */
multiline_comment|/************************************************************/
DECL|struct|boot_data
r_struct
id|boot_data
(brace
DECL|member|Cryptor
id|word
id|Cryptor
suffix:semicolon
multiline_comment|/* for use with Decrypt function */
DECL|member|Nrecs
id|word
id|Nrecs
suffix:semicolon
multiline_comment|/* records remaining in file */
DECL|member|pof_state
id|uchar
id|pof_state
suffix:semicolon
multiline_comment|/* actual state of read handler */
DECL|member|is_crypted
id|uchar
id|is_crypted
suffix:semicolon
multiline_comment|/* card data is crypted */
DECL|member|BufSize
r_int
id|BufSize
suffix:semicolon
multiline_comment|/* actual number of bytes bufferd */
DECL|member|last_error
r_int
id|last_error
suffix:semicolon
multiline_comment|/* last occured error */
DECL|member|pof_recid
id|word
id|pof_recid
suffix:semicolon
multiline_comment|/* actual pof recid */
DECL|member|pof_reclen
id|ulong
id|pof_reclen
suffix:semicolon
multiline_comment|/* total length of pof record data */
DECL|member|pof_recoffset
id|ulong
id|pof_recoffset
suffix:semicolon
multiline_comment|/* actual offset inside pof record */
r_union
(brace
DECL|member|BootBuf
id|uchar
id|BootBuf
(braket
id|BOOT_BUF_SIZE
)braket
suffix:semicolon
multiline_comment|/* buffer as byte count */
DECL|member|PofRecHdr
id|tPofRecHdr
id|PofRecHdr
suffix:semicolon
multiline_comment|/* header for actual record/chunk */
DECL|member|PofFileHdr
id|tPofFileHdr
id|PofFileHdr
suffix:semicolon
multiline_comment|/* header from POF file */
DECL|member|PofTime
id|tPofTimeStamp
id|PofTime
suffix:semicolon
multiline_comment|/* time information */
DECL|member|buf
)brace
id|buf
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*****************************************************/
multiline_comment|/*  start decryption of sucessive POF file chuncks.  */
multiline_comment|/*                                                   */
multiline_comment|/*  to be called at start of POF file reading,       */
multiline_comment|/*  before starting any decryption on any POF record. */
multiline_comment|/*****************************************************/
r_void
DECL|function|StartDecryption
id|StartDecryption
c_func
(paren
r_struct
id|boot_data
op_star
id|boot
)paren
(brace
id|boot-&gt;Cryptor
op_assign
id|CRYPT_STARTTERM
suffix:semicolon
)brace
multiline_comment|/* StartDecryption */
multiline_comment|/***************************************************************/
multiline_comment|/* decrypt complete BootBuf                                    */
multiline_comment|/* NOTE: decryption must be applied to all or none boot tags - */
multiline_comment|/*       to HI and LO boot loader and (all) seq tags, because  */
multiline_comment|/*       global Cryptor is started for whole POF.              */
multiline_comment|/***************************************************************/
r_void
DECL|function|DecryptBuf
id|DecryptBuf
c_func
(paren
r_struct
id|boot_data
op_star
id|boot
comma
r_int
id|cnt
)paren
(brace
id|uchar
op_star
id|bufp
op_assign
id|boot-&gt;buf.BootBuf
suffix:semicolon
r_while
c_loop
(paren
id|cnt
op_decrement
)paren
(brace
id|boot-&gt;Cryptor
op_assign
(paren
id|boot-&gt;Cryptor
op_rshift
l_int|1
)paren
op_xor
(paren
(paren
id|boot-&gt;Cryptor
op_amp
l_int|1U
)paren
ques
c_cond
id|CRYPT_FEEDTERM
suffix:colon
l_int|0
)paren
suffix:semicolon
op_star
id|bufp
op_increment
op_xor_assign
(paren
id|uchar
)paren
id|boot-&gt;Cryptor
suffix:semicolon
)brace
)brace
multiline_comment|/* DecryptBuf */
multiline_comment|/********************************************************************************/
multiline_comment|/* pof_handle_data executes the required actions dependant on the active record */
multiline_comment|/* id. If successfull 0 is returned, a negative value shows an error.           */
multiline_comment|/********************************************************************************/
r_static
r_int
DECL|function|pof_handle_data
id|pof_handle_data
c_func
(paren
id|hysdn_card
op_star
id|card
comma
r_int
id|datlen
)paren
(brace
r_struct
id|boot_data
op_star
id|boot
op_assign
id|card-&gt;boot
suffix:semicolon
multiline_comment|/* pointer to boot specific data */
r_int
id|l
suffix:semicolon
id|uchar
op_star
id|imgp
suffix:semicolon
r_int
id|img_len
suffix:semicolon
multiline_comment|/* handle the different record types */
r_switch
c_cond
(paren
id|boot-&gt;pof_recid
)paren
(brace
r_case
id|TAG_TIMESTMP
suffix:colon
r_if
c_cond
(paren
id|card-&gt;debug_flags
op_amp
id|LOG_POF_RECORD
)paren
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;POF created %s&quot;
comma
id|boot-&gt;buf.PofTime.DateTimeText
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TAG_CBOOTDTA
suffix:colon
id|DecryptBuf
c_func
(paren
id|boot
comma
id|datlen
)paren
suffix:semicolon
multiline_comment|/* we need to encrypt the buffer */
r_case
id|TAG_BOOTDTA
suffix:colon
r_if
c_cond
(paren
id|card-&gt;debug_flags
op_amp
id|LOG_POF_RECORD
)paren
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;POF got %s len=%d offs=0x%lx&quot;
comma
(paren
id|boot-&gt;pof_recid
op_eq
id|TAG_CBOOTDTA
)paren
ques
c_cond
l_string|&quot;CBOOTDATA&quot;
suffix:colon
l_string|&quot;BOOTDTA&quot;
comma
id|datlen
comma
id|boot-&gt;pof_recoffset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|boot-&gt;pof_reclen
op_ne
id|POF_BOOT_LOADER_TOTAL_SIZE
)paren
(brace
id|boot-&gt;last_error
op_assign
id|EPOF_BAD_IMG_SIZE
suffix:semicolon
multiline_comment|/* invalid length */
r_return
(paren
id|boot-&gt;last_error
)paren
suffix:semicolon
)brace
id|imgp
op_assign
id|boot-&gt;buf.BootBuf
suffix:semicolon
multiline_comment|/* start of buffer */
id|img_len
op_assign
id|datlen
suffix:semicolon
multiline_comment|/* maximum length to transfer */
id|l
op_assign
id|POF_BOOT_LOADER_OFF_IN_PAGE
op_minus
(paren
id|boot-&gt;pof_recoffset
op_amp
(paren
id|POF_BOOT_LOADER_PAGE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
l_int|0
)paren
(brace
multiline_comment|/* buffer needs to be truncated */
id|imgp
op_add_assign
id|l
suffix:semicolon
multiline_comment|/* advance pointer */
id|img_len
op_sub_assign
id|l
suffix:semicolon
multiline_comment|/* adjust len */
)brace
multiline_comment|/* at this point no special handling for data wrapping over buffer */
multiline_comment|/* is necessary, because the boot image always will be adjusted to */
multiline_comment|/* match a page boundary inside the buffer.                        */
multiline_comment|/* The buffer for the boot image on the card is filled in 2 cycles */
multiline_comment|/* first the 1024 hi-words are put in the buffer, then the low 1024 */
multiline_comment|/* word are handled in the same way with different offset.         */
r_if
c_cond
(paren
id|img_len
OG
l_int|0
)paren
(brace
multiline_comment|/* data available for copy */
r_if
c_cond
(paren
(paren
id|boot-&gt;last_error
op_assign
id|card
op_member_access_from_pointer
id|writebootimg
c_func
(paren
id|card
comma
id|imgp
comma
(paren
id|boot-&gt;pof_recoffset
OG
id|POF_BOOT_LOADER_PAGE_SIZE
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|0
)paren
)paren
OL
l_int|0
)paren
r_return
(paren
id|boot-&gt;last_error
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* end of case boot image hi/lo */
r_case
id|TAG_CABSDATA
suffix:colon
id|DecryptBuf
c_func
(paren
id|boot
comma
id|datlen
)paren
suffix:semicolon
multiline_comment|/* we need to encrypt the buffer */
r_case
id|TAG_ABSDATA
suffix:colon
r_if
c_cond
(paren
id|card-&gt;debug_flags
op_amp
id|LOG_POF_RECORD
)paren
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;POF got %s len=%d offs=0x%lx&quot;
comma
(paren
id|boot-&gt;pof_recid
op_eq
id|TAG_CABSDATA
)paren
ques
c_cond
l_string|&quot;CABSDATA&quot;
suffix:colon
l_string|&quot;ABSDATA&quot;
comma
id|datlen
comma
id|boot-&gt;pof_recoffset
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|boot-&gt;last_error
op_assign
id|card
op_member_access_from_pointer
id|writebootseq
c_func
(paren
id|card
comma
id|boot-&gt;buf.BootBuf
comma
id|datlen
)paren
OL
l_int|0
)paren
)paren
r_return
(paren
id|boot-&gt;last_error
)paren
suffix:semicolon
multiline_comment|/* error writing data */
r_if
c_cond
(paren
id|boot-&gt;pof_recoffset
op_plus
id|datlen
op_ge
id|boot-&gt;pof_reclen
)paren
r_return
(paren
id|card
op_member_access_from_pointer
id|waitpofready
c_func
(paren
id|card
)paren
)paren
suffix:semicolon
multiline_comment|/* data completely spooled, wait for ready */
r_break
suffix:semicolon
multiline_comment|/* end of case boot seq data */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|card-&gt;debug_flags
op_amp
id|LOG_POF_RECORD
)paren
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;POF got data(id=0x%lx) len=%d offs=0x%lx&quot;
comma
id|boot-&gt;pof_recid
comma
id|datlen
comma
id|boot-&gt;pof_recoffset
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* simply skip record */
)brace
multiline_comment|/* switch boot-&gt;pof_recid */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* pof_handle_data */
multiline_comment|/******************************************************************************/
multiline_comment|/* pof_write_buffer is called when the buffer has been filled with the needed */
multiline_comment|/* number of data bytes. The number delivered is additionally supplied for    */
multiline_comment|/* verification. The functions handles the data and returns the needed number */
multiline_comment|/* of bytes for the next action. If the returned value is 0 or less an error  */
multiline_comment|/* occured and booting must be aborted.                                       */
multiline_comment|/******************************************************************************/
r_int
DECL|function|pof_write_buffer
id|pof_write_buffer
c_func
(paren
id|hysdn_card
op_star
id|card
comma
r_int
id|datlen
)paren
(brace
r_struct
id|boot_data
op_star
id|boot
op_assign
id|card-&gt;boot
suffix:semicolon
multiline_comment|/* pointer to boot specific data */
r_if
c_cond
(paren
op_logical_neg
id|boot
)paren
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
multiline_comment|/* invalid call */
r_if
c_cond
(paren
id|boot-&gt;last_error
OL
l_int|0
)paren
r_return
(paren
id|boot-&gt;last_error
)paren
suffix:semicolon
multiline_comment|/* repeated error */
r_if
c_cond
(paren
id|card-&gt;debug_flags
op_amp
id|LOG_POF_WRITE
)paren
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;POF write: got %d bytes &quot;
comma
id|datlen
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|boot-&gt;pof_state
)paren
(brace
r_case
id|POF_READ_FILE_HEAD
suffix:colon
r_if
c_cond
(paren
id|card-&gt;debug_flags
op_amp
id|LOG_POF_WRITE
)paren
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;POF write: checking file header&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|datlen
op_ne
r_sizeof
(paren
id|tPofFileHdr
)paren
)paren
(brace
id|boot-&gt;last_error
op_assign
op_minus
id|EPOF_INTERNAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|boot-&gt;buf.PofFileHdr.Magic
op_ne
id|TAGFILEMAGIC
)paren
(brace
id|boot-&gt;last_error
op_assign
op_minus
id|EPOF_BAD_MAGIC
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Setup the new state and vars */
id|boot-&gt;Nrecs
op_assign
(paren
id|word
)paren
(paren
id|boot-&gt;buf.PofFileHdr.N_PofRecs
)paren
suffix:semicolon
multiline_comment|/* limited to 65535 */
id|boot-&gt;pof_state
op_assign
id|POF_READ_TAG_HEAD
suffix:semicolon
multiline_comment|/* now start with single tags */
id|boot-&gt;last_error
op_assign
r_sizeof
(paren
id|tPofRecHdr
)paren
suffix:semicolon
multiline_comment|/* new length */
r_break
suffix:semicolon
r_case
id|POF_READ_TAG_HEAD
suffix:colon
r_if
c_cond
(paren
id|card-&gt;debug_flags
op_amp
id|LOG_POF_WRITE
)paren
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;POF write: checking tag header&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|datlen
op_ne
r_sizeof
(paren
id|tPofRecHdr
)paren
)paren
(brace
id|boot-&gt;last_error
op_assign
op_minus
id|EPOF_INTERNAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|boot-&gt;pof_recid
op_assign
id|boot-&gt;buf.PofRecHdr.PofRecId
suffix:semicolon
multiline_comment|/* actual pof recid */
id|boot-&gt;pof_reclen
op_assign
id|boot-&gt;buf.PofRecHdr.PofRecDataLen
suffix:semicolon
multiline_comment|/* total length */
id|boot-&gt;pof_recoffset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no starting offset */
r_if
c_cond
(paren
id|card-&gt;debug_flags
op_amp
id|LOG_POF_RECORD
)paren
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;POF: got record id=0x%lx length=%ld &quot;
comma
id|boot-&gt;pof_recid
comma
id|boot-&gt;pof_reclen
)paren
suffix:semicolon
id|boot-&gt;pof_state
op_assign
id|POF_READ_TAG_DATA
suffix:semicolon
multiline_comment|/* now start with tag data */
r_if
c_cond
(paren
id|boot-&gt;pof_reclen
OL
id|BOOT_BUF_SIZE
)paren
id|boot-&gt;last_error
op_assign
id|boot-&gt;pof_reclen
suffix:semicolon
multiline_comment|/* limit size */
r_else
id|boot-&gt;last_error
op_assign
id|BOOT_BUF_SIZE
suffix:semicolon
multiline_comment|/* maximum */
r_if
c_cond
(paren
op_logical_neg
id|boot-&gt;last_error
)paren
(brace
multiline_comment|/* no data inside record */
id|boot-&gt;pof_state
op_assign
id|POF_READ_TAG_HEAD
suffix:semicolon
multiline_comment|/* now start with single tags */
id|boot-&gt;last_error
op_assign
r_sizeof
(paren
id|tPofRecHdr
)paren
suffix:semicolon
multiline_comment|/* new length */
)brace
r_break
suffix:semicolon
r_case
id|POF_READ_TAG_DATA
suffix:colon
r_if
c_cond
(paren
id|card-&gt;debug_flags
op_amp
id|LOG_POF_WRITE
)paren
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;POF write: getting tag data&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|datlen
op_ne
id|boot-&gt;last_error
)paren
(brace
id|boot-&gt;last_error
op_assign
op_minus
id|EPOF_INTERNAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|boot-&gt;last_error
op_assign
id|pof_handle_data
c_func
(paren
id|card
comma
id|datlen
)paren
)paren
OL
l_int|0
)paren
r_return
(paren
id|boot-&gt;last_error
)paren
suffix:semicolon
multiline_comment|/* an error occured */
id|boot-&gt;pof_recoffset
op_add_assign
id|datlen
suffix:semicolon
r_if
c_cond
(paren
id|boot-&gt;pof_recoffset
op_ge
id|boot-&gt;pof_reclen
)paren
(brace
id|boot-&gt;pof_state
op_assign
id|POF_READ_TAG_HEAD
suffix:semicolon
multiline_comment|/* now start with single tags */
id|boot-&gt;last_error
op_assign
r_sizeof
(paren
id|tPofRecHdr
)paren
suffix:semicolon
multiline_comment|/* new length */
)brace
r_else
(brace
r_if
c_cond
(paren
id|boot-&gt;pof_reclen
op_minus
id|boot-&gt;pof_recoffset
OL
id|BOOT_BUF_SIZE
)paren
id|boot-&gt;last_error
op_assign
id|boot-&gt;pof_reclen
op_minus
id|boot-&gt;pof_recoffset
suffix:semicolon
multiline_comment|/* limit size */
r_else
id|boot-&gt;last_error
op_assign
id|BOOT_BUF_SIZE
suffix:semicolon
multiline_comment|/* maximum */
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|boot-&gt;last_error
op_assign
op_minus
id|EPOF_INTERNAL
suffix:semicolon
multiline_comment|/* unknown state */
r_break
suffix:semicolon
)brace
multiline_comment|/* switch (boot-&gt;pof_state) */
r_return
(paren
id|boot-&gt;last_error
)paren
suffix:semicolon
)brace
multiline_comment|/* pof_write_buffer */
multiline_comment|/*******************************************************************************/
multiline_comment|/* pof_write_open is called when an open for boot on the cardlog device occurs. */
multiline_comment|/* The function returns the needed number of bytes for the next operation. If  */
multiline_comment|/* the returned number is less or equal 0 an error specified by this code      */
multiline_comment|/* occurred. Additionally the pointer to the buffer data area is set on success */
multiline_comment|/*******************************************************************************/
r_int
DECL|function|pof_write_open
id|pof_write_open
c_func
(paren
id|hysdn_card
op_star
id|card
comma
id|uchar
op_star
op_star
id|bufp
)paren
(brace
r_struct
id|boot_data
op_star
id|boot
suffix:semicolon
multiline_comment|/* pointer to boot specific data */
r_if
c_cond
(paren
id|card-&gt;boot
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;debug_flags
op_amp
id|LOG_POF_OPEN
)paren
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;POF open: already opened for boot&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ERR_ALREADY_BOOT
)paren
suffix:semicolon
multiline_comment|/* boot already active */
)brace
multiline_comment|/* error no mem available */
r_if
c_cond
(paren
op_logical_neg
(paren
id|boot
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|boot_data
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;debug_flags
op_amp
id|LOG_MEM_ERR
)paren
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;POF open: unable to allocate mem&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
id|card-&gt;boot
op_assign
id|boot
suffix:semicolon
id|card-&gt;state
op_assign
id|CARD_STATE_BOOTING
suffix:semicolon
id|memset
c_func
(paren
id|boot
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|boot_data
)paren
)paren
suffix:semicolon
id|card
op_member_access_from_pointer
id|stopcard
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/* first stop the card */
r_if
c_cond
(paren
id|card
op_member_access_from_pointer
id|testram
c_func
(paren
id|card
)paren
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;debug_flags
op_amp
id|LOG_POF_OPEN
)paren
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;POF open: DPRAM test failure&quot;
)paren
suffix:semicolon
id|boot-&gt;last_error
op_assign
op_minus
id|ERR_BOARD_DPRAM
suffix:semicolon
id|card-&gt;state
op_assign
id|CARD_STATE_BOOTERR
suffix:semicolon
multiline_comment|/* show boot error */
r_return
(paren
id|boot-&gt;last_error
)paren
suffix:semicolon
)brace
id|boot-&gt;BufSize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Buffer is empty */
id|boot-&gt;pof_state
op_assign
id|POF_READ_FILE_HEAD
suffix:semicolon
multiline_comment|/* read file header */
id|StartDecryption
c_func
(paren
id|boot
)paren
suffix:semicolon
multiline_comment|/* if POF File should be encrypted */
r_if
c_cond
(paren
id|card-&gt;debug_flags
op_amp
id|LOG_POF_OPEN
)paren
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;POF open: success&quot;
)paren
suffix:semicolon
op_star
id|bufp
op_assign
id|boot-&gt;buf.BootBuf
suffix:semicolon
multiline_comment|/* point to buffer */
r_return
(paren
r_sizeof
(paren
id|tPofFileHdr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* pof_write_open */
multiline_comment|/********************************************************************************/
multiline_comment|/* pof_write_close is called when an close of boot on the cardlog device occurs. */
multiline_comment|/* The return value must be 0 if everything has happened as desired.            */
multiline_comment|/********************************************************************************/
r_int
DECL|function|pof_write_close
id|pof_write_close
c_func
(paren
id|hysdn_card
op_star
id|card
)paren
(brace
r_struct
id|boot_data
op_star
id|boot
op_assign
id|card-&gt;boot
suffix:semicolon
multiline_comment|/* pointer to boot specific data */
r_if
c_cond
(paren
op_logical_neg
id|boot
)paren
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
multiline_comment|/* invalid call */
id|card-&gt;boot
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* no boot active */
id|kfree
c_func
(paren
id|boot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;state
op_eq
id|CARD_STATE_RUN
)paren
id|card
op_member_access_from_pointer
id|set_errlog_state
c_func
(paren
id|card
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* activate error log */
r_if
c_cond
(paren
id|card-&gt;debug_flags
op_amp
id|LOG_POF_OPEN
)paren
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;POF close: success&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* pof_write_close */
multiline_comment|/*********************************************************************************/
multiline_comment|/* EvalSysrTokData checks additional records delivered with the Sysready Message */
multiline_comment|/* when POF has been booted. A return value of 0 is used if no error occured.    */
multiline_comment|/*********************************************************************************/
r_int
DECL|function|EvalSysrTokData
id|EvalSysrTokData
c_func
(paren
id|hysdn_card
op_star
id|card
comma
id|uchar
op_star
id|cp
comma
r_int
id|len
)paren
(brace
id|u_char
op_star
id|p
suffix:semicolon
id|u_char
id|crc
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;debug_flags
op_amp
id|LOG_POF_RECORD
)paren
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;SysReady Token data length %d&quot;
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|2
)paren
(brace
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;SysReady Token Data to short&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|p
op_assign
id|cp
comma
id|crc
op_assign
l_int|0
suffix:semicolon
id|p
OL
(paren
id|cp
op_plus
id|len
op_minus
l_int|2
)paren
suffix:semicolon
id|p
op_increment
)paren
r_if
c_cond
(paren
(paren
id|crc
op_amp
l_int|0x80
)paren
)paren
id|crc
op_assign
(paren
(paren
(paren
id|u_char
)paren
(paren
id|crc
op_lshift
l_int|1
)paren
)paren
op_plus
l_int|1
)paren
op_plus
op_star
id|p
suffix:semicolon
r_else
id|crc
op_assign
(paren
(paren
id|u_char
)paren
(paren
id|crc
op_lshift
l_int|1
)paren
)paren
op_plus
op_star
id|p
suffix:semicolon
id|crc
op_assign
op_complement
id|crc
suffix:semicolon
r_if
c_cond
(paren
id|crc
op_ne
op_star
(paren
id|cp
op_plus
id|len
op_minus
l_int|1
)paren
)paren
(brace
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;SysReady Token Data invalid CRC&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|len
op_decrement
suffix:semicolon
multiline_comment|/* dont check CRC byte */
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_star
id|cp
op_eq
id|SYSR_TOK_END
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* End of Token stream */
r_if
c_cond
(paren
id|len
OL
(paren
op_star
(paren
id|cp
op_plus
l_int|1
)paren
op_plus
l_int|2
)paren
)paren
(brace
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;token 0x%x invalid length %d&quot;
comma
op_star
id|cp
comma
op_star
(paren
id|cp
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
op_star
id|cp
)paren
(brace
r_case
id|SYSR_TOK_B_CHAN
suffix:colon
multiline_comment|/* 1 */
r_if
c_cond
(paren
op_star
(paren
id|cp
op_plus
l_int|1
)paren
op_ne
l_int|1
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* length invalid */
id|card-&gt;bchans
op_assign
op_star
(paren
id|cp
op_plus
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYSR_TOK_FAX_CHAN
suffix:colon
multiline_comment|/* 2 */
r_if
c_cond
(paren
op_star
(paren
id|cp
op_plus
l_int|1
)paren
op_ne
l_int|1
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* length invalid */
id|card-&gt;faxchans
op_assign
op_star
(paren
id|cp
op_plus
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYSR_TOK_MAC_ADDR
suffix:colon
multiline_comment|/* 3 */
r_if
c_cond
(paren
op_star
(paren
id|cp
op_plus
l_int|1
)paren
op_ne
l_int|6
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* length invalid */
id|memcpy
c_func
(paren
id|card-&gt;mac_addr
comma
id|cp
op_plus
l_int|2
comma
l_int|6
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;unknown token 0x%02x length %d&quot;
comma
op_star
id|cp
comma
op_star
(paren
id|cp
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|len
op_sub_assign
(paren
op_star
(paren
id|cp
op_plus
l_int|1
)paren
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* adjust len */
id|cp
op_add_assign
(paren
op_star
(paren
id|cp
op_plus
l_int|1
)paren
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* and pointer */
)brace
id|hysdn_addlog
c_func
(paren
id|card
comma
l_string|&quot;no end token found&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* EvalSysrTokData */
eof
