multiline_comment|/*&n; *  scsi_obsolete.c Copyright (C) 1992 Drew Eckhardt&n; *         Copyright (C) 1993, 1994, 1995 Eric Youngdale&n; *&n; *  generic mid-level SCSI driver&n; *      Initial versions: Drew Eckhardt&n; *      Subsequent revisions: Eric Youngdale&n; *&n; *  &lt;drew@colorado.edu&gt;&n; *&n; *  Bug correction thanks go to :&n; *      Rik Faith &lt;faith@cs.unc.edu&gt;&n; *      Tommy Thorn &lt;tthorn&gt;&n; *      Thomas Wuensche &lt;tw@fgb1.fgb.mw.tu-muenchen.de&gt;&n; *&n; *  Modified by Eric Youngdale eric@andante.org to&n; *  add scatter-gather, multiple outstanding request, and other&n; *  enhancements.&n; *&n; *  Native multichannel, wide scsi, /proc/scsi and hot plugging&n; *  support added by Michael Neuffer &lt;mike@i-connect.net&gt;&n; *&n; *  Major improvements to the timeout, abort, and reset processing,&n; *  as well as performance modifications for large queue depths by&n; *  Leonard N. Zubkoff &lt;lnz@dandelion.com&gt;&n; *&n; *  Improved compatibility with 2.0 behaviour by Manfred Spraul&n; *  &lt;masp0008@stud.uni-sb.de&gt;&n; */
multiline_comment|/*&n; *#########################################################################&n; *#########################################################################&n; *#########################################################################&n; *#########################################################################&n; *              NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE&n; *&n; *#########################################################################&n; *#########################################################################&n; *#########################################################################&n; *#########################################################################&n; *&n; * This file contains the &squot;old&squot; scsi error handling.  It is only present&n; * while the new error handling code is being debugged, and while the low&n; * level drivers are being converted to use the new code.  Once the last&n; * driver uses the new code this *ENTIRE* file will be nuked.&n; */
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;constants.h&quot;
DECL|macro|USE_STATIC_SCSI_MEMORY
macro_line|#undef USE_STATIC_SCSI_MEMORY
multiline_comment|/*&n;   static const char RCSid[] = &quot;$Header: /mnt/ide/home/eric/CVSROOT/linux/drivers/scsi/scsi_obsolete.c,v 1.1 1997/05/18 23:27:21 eric Exp $&quot;;&n; */
DECL|macro|INTERNAL_ERROR
mdefine_line|#define INTERNAL_ERROR (panic (&quot;Internal error in file %s, line %d.&bslash;n&quot;, __FILE__, __LINE__))
r_static
r_int
id|scsi_abort
c_func
(paren
id|Scsi_Cmnd
op_star
comma
r_int
id|code
)paren
suffix:semicolon
r_static
r_int
id|scsi_reset
c_func
(paren
id|Scsi_Cmnd
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
id|scsi_old_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
r_int
id|update_timeout
c_func
(paren
id|Scsi_Cmnd
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|scsi_old_times_out
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
r_extern
r_int
id|scsi_dispatch_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
DECL|macro|SCSI_BLOCK
mdefine_line|#define SCSI_BLOCK(HOST) (HOST-&gt;can_queue &amp;&amp; HOST-&gt;host_busy &gt;= HOST-&gt;can_queue)
DECL|variable|generic_sense
r_static
r_int
r_char
id|generic_sense
(braket
l_int|6
)braket
op_assign
(brace
id|REQUEST_SENSE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|255
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; *  This is the number  of clock ticks we should wait before we time out&n; *  and abort the command.  This is for  where the scsi.c module generates&n; *  the command, not where it originates from a higher level, in which&n; *  case the timeout is specified there.&n; *&n; *  ABORT_TIMEOUT and RESET_TIMEOUT are the timeouts for RESET and ABORT&n; *  respectively.&n; */
macro_line|#ifdef DEBUG_TIMEOUT
r_static
r_void
id|scsi_dump_status
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG
DECL|macro|SCSI_TIMEOUT
mdefine_line|#define SCSI_TIMEOUT (5*HZ)
macro_line|#else
DECL|macro|SCSI_TIMEOUT
mdefine_line|#define SCSI_TIMEOUT (2*HZ)
macro_line|#endif
macro_line|#ifdef DEBUG
DECL|macro|SENSE_TIMEOUT
mdefine_line|#define SENSE_TIMEOUT SCSI_TIMEOUT
DECL|macro|ABORT_TIMEOUT
mdefine_line|#define ABORT_TIMEOUT SCSI_TIMEOUT
DECL|macro|RESET_TIMEOUT
mdefine_line|#define RESET_TIMEOUT SCSI_TIMEOUT
macro_line|#else
DECL|macro|SENSE_TIMEOUT
mdefine_line|#define SENSE_TIMEOUT (5*HZ/10)
DECL|macro|RESET_TIMEOUT
mdefine_line|#define RESET_TIMEOUT (5*HZ/10)
DECL|macro|ABORT_TIMEOUT
mdefine_line|#define ABORT_TIMEOUT (5*HZ/10)
macro_line|#endif
multiline_comment|/* Do not call reset on error if we just did a reset within 15 sec. */
DECL|macro|MIN_RESET_PERIOD
mdefine_line|#define MIN_RESET_PERIOD (15*HZ)
multiline_comment|/*&n; *  Flag bits for the internal_timeout array&n; */
DECL|macro|IN_ABORT
mdefine_line|#define IN_ABORT  1
DECL|macro|IN_RESET
mdefine_line|#define IN_RESET  2
DECL|macro|IN_RESET2
mdefine_line|#define IN_RESET2 4
DECL|macro|IN_RESET3
mdefine_line|#define IN_RESET3 8
multiline_comment|/*&n; * This is our time out function, called when the timer expires for a&n; * given host adapter.  It will attempt to abort the currently executing&n; * command, that failing perform a kernel panic.&n; */
DECL|function|scsi_old_times_out
r_void
id|scsi_old_times_out
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Set the serial_number_at_timeout to the current serial_number */
id|SCpnt-&gt;serial_number_at_timeout
op_assign
id|SCpnt-&gt;serial_number
suffix:semicolon
r_switch
c_cond
(paren
id|SCpnt-&gt;internal_timeout
op_amp
(paren
id|IN_ABORT
op_or
id|IN_RESET
op_or
id|IN_RESET2
op_or
id|IN_RESET3
)paren
)paren
(brace
r_case
id|NORMAL_TIMEOUT
suffix:colon
(brace
macro_line|#ifdef DEBUG_TIMEOUT
id|scsi_dump_status
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
op_logical_neg
id|scsi_abort
c_func
(paren
id|SCpnt
comma
id|DID_TIME_OUT
)paren
)paren
r_break
suffix:semicolon
r_case
id|IN_ABORT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SCSI host %d abort (pid %ld) timed out - resetting&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_reset
c_func
(paren
id|SCpnt
comma
id|SCSI_RESET_ASYNCHRONOUS
)paren
)paren
r_break
suffix:semicolon
r_case
id|IN_RESET
suffix:colon
r_case
(paren
id|IN_ABORT
op_or
id|IN_RESET
)paren
suffix:colon
multiline_comment|/* This might be controversial, but if there is a bus hang,&n;&t;&t; * you might conceivably want the machine up and running&n;&t;&t; * esp if you have an ide disk.&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;SCSI host %d channel %d reset (pid %ld) timed out - &quot;
l_string|&quot;trying harder&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_RESET
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_or_assign
id|IN_RESET2
suffix:semicolon
id|scsi_reset
c_func
(paren
id|SCpnt
comma
id|SCSI_RESET_ASYNCHRONOUS
op_or
id|SCSI_RESET_SUGGEST_BUS_RESET
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IN_RESET2
suffix:colon
r_case
(paren
id|IN_ABORT
op_or
id|IN_RESET2
)paren
suffix:colon
multiline_comment|/* Obviously the bus reset didn&squot;t work.&n;&t;&t; * Let&squot;s try even harder and call for an HBA reset.&n;&t;&t; * Maybe the HBA itself crashed and this will shake it loose.&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;SCSI host %d reset (pid %ld) timed out - trying to shake it loose&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
(paren
id|IN_RESET
op_or
id|IN_RESET2
)paren
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_or_assign
id|IN_RESET3
suffix:semicolon
id|scsi_reset
c_func
(paren
id|SCpnt
comma
id|SCSI_RESET_ASYNCHRONOUS
op_or
id|SCSI_RESET_SUGGEST_HOST_RESET
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SCSI host %d reset (pid %ld) timed out again -&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;probably an unrecoverable SCSI bus or device hang.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  From what I can find in scsi_obsolete.c, this function is only called&n; *  by scsi_old_done and scsi_reset.  Both of these functions run with the&n; *  io_request_lock already held, so we need do nothing here about grabbing&n; *  any locks.&n; */
DECL|function|scsi_request_sense
r_static
r_void
id|scsi_request_sense
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|SCpnt-&gt;flags
op_or_assign
id|WAS_SENSE
op_or
id|ASKED_FOR_SENSE
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|SENSE_TIMEOUT
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|generic_sense
comma
r_sizeof
(paren
id|generic_sense
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|1
)braket
op_assign
id|SCpnt-&gt;lun
op_lshift
l_int|5
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
op_amp
id|SCpnt-&gt;sense_buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;sc_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
multiline_comment|/*&n;         * Ugly, ugly.  The newer interfaces all assume that the lock&n;         * isn&squot;t held.  Mustn&squot;t disappoint, or we deadlock the system.&n;         */
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|scsi_dispatch_cmd
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
)brace
DECL|function|check_sense
r_static
r_int
id|check_sense
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
multiline_comment|/* If there is no sense information, request it.  If we have already&n;&t; * requested it, there is no point in asking again - the firmware must&n;&t; * be confused.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x70
)paren
op_rshift
l_int|4
)paren
op_ne
l_int|7
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|SCpnt-&gt;flags
op_amp
id|ASKED_FOR_SENSE
)paren
)paren
r_return
id|SUGGEST_SENSE
suffix:semicolon
r_else
r_return
id|SUGGEST_RETRY
suffix:semicolon
)brace
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|ASKED_FOR_SENSE
suffix:semicolon
macro_line|#ifdef DEBUG_INIT
id|printk
c_func
(paren
l_string|&quot;scsi%d, channel%d : &quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
)paren
suffix:semicolon
id|print_sense
c_func
(paren
l_string|&quot;&quot;
comma
id|SCpnt
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xe0
)paren
r_return
id|SUGGEST_ABORT
suffix:semicolon
r_switch
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
(brace
r_case
id|NO_SENSE
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|RECOVERED_ERROR
suffix:colon
r_return
id|SUGGEST_IS_OK
suffix:semicolon
r_case
id|ABORTED_COMMAND
suffix:colon
r_return
id|SUGGEST_RETRY
suffix:semicolon
r_case
id|NOT_READY
suffix:colon
r_case
id|UNIT_ATTENTION
suffix:colon
multiline_comment|/*&n;&t;&t; * If we are expecting a CC/UA because of a bus reset that we&n;&t;&t; * performed, treat this just as a retry.  Otherwise this is&n;&t;&t; * information that we should pass up to the upper-level driver&n;&t;&t; * so that we can deal with it there.&n;&t;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;expecting_cc_ua
)paren
(brace
id|SCpnt-&gt;device-&gt;expecting_cc_ua
op_assign
l_int|0
suffix:semicolon
r_return
id|SUGGEST_RETRY
suffix:semicolon
)brace
r_return
id|SUGGEST_ABORT
suffix:semicolon
multiline_comment|/* these three are not supported */
r_case
id|COPY_ABORTED
suffix:colon
r_case
id|VOLUME_OVERFLOW
suffix:colon
r_case
id|MISCOMPARE
suffix:colon
r_case
id|MEDIUM_ERROR
suffix:colon
r_return
id|SUGGEST_REMAP
suffix:semicolon
r_case
id|BLANK_CHECK
suffix:colon
r_case
id|DATA_PROTECT
suffix:colon
r_case
id|HARDWARE_ERROR
suffix:colon
r_case
id|ILLEGAL_REQUEST
suffix:colon
r_default
suffix:colon
r_return
id|SUGGEST_ABORT
suffix:semicolon
)brace
)brace
multiline_comment|/* This function is the mid-level interrupt routine, which decides how&n; *  to handle error conditions.  Each invocation of this function must&n; *  do one and *only* one of the following:&n; *&n; *  (1) Call last_cmnd[host].done.  This is done for fatal errors and&n; *      normal completion, and indicates that the handling for this&n; *      request is complete.&n; *  (2) Call internal_cmnd to requeue the command.  This will result in&n; *      scsi_done being called again when the retry is complete.&n; *  (3) Call scsi_request_sense.  This asks the host adapter/drive for&n; *      more information about the error condition.  When the information&n; *      is available, scsi_done will be called again.&n; *  (4) Call reset().  This is sort of a last resort, and the idea is that&n; *      this may kick things loose and get the drive working again.  reset()&n; *      automatically calls scsi_request_sense, and thus scsi_done will be&n; *      called again once the reset is complete.&n; *&n; *      If none of the above actions are taken, the drive in question&n; *      will hang. If more than one of the above actions are taken by&n; *      scsi_done, then unpredictable behavior will result.&n; */
DECL|function|scsi_old_done
r_void
id|scsi_old_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_int
m_exit
op_assign
l_int|0
suffix:semicolon
r_int
id|checked
suffix:semicolon
r_int
id|oldto
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|Scsi_Device
op_star
id|device
op_assign
id|SCpnt-&gt;device
suffix:semicolon
r_int
id|result
op_assign
id|SCpnt-&gt;result
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|oldto
op_assign
id|update_timeout
c_func
(paren
id|SCpnt
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TIMEOUT
r_if
c_cond
(paren
id|result
)paren
id|printk
c_func
(paren
l_string|&quot;Non-zero result in scsi_done %x %d:%d&bslash;n&quot;
comma
id|result
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* If we requested an abort, (and we got it) then fix up the return&n;&t; *  status to say why&n;&t; */
r_if
c_cond
(paren
id|host_byte
c_func
(paren
id|result
)paren
op_eq
id|DID_ABORT
op_logical_and
id|SCpnt-&gt;abort_reason
)paren
id|SCpnt-&gt;result
op_assign
id|result
op_assign
(paren
id|result
op_amp
l_int|0xff00ffff
)paren
op_or
(paren
id|SCpnt-&gt;abort_reason
op_lshift
l_int|16
)paren
suffix:semicolon
DECL|macro|CMD_FINISHED
mdefine_line|#define CMD_FINISHED 0
DECL|macro|MAYREDO
mdefine_line|#define MAYREDO  1
DECL|macro|REDO
mdefine_line|#define REDO     3
DECL|macro|PENDING
mdefine_line|#define PENDING  4
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;In scsi_done(host = %d, result = %06x)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|result
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|SYNC_RESET
)paren
(brace
multiline_comment|/*&n;&t;&t;   * The behaviou of scsi_reset(SYNC) was changed in 2.1.? .&n;&t;&t;   * The scsi mid-layer does a REDO after every sync reset, the driver&n;&t;&t;   * must not do that any more. In order to prevent old drivers from&n;&t;&t;   * crashing, all scsi_done() calls during sync resets are ignored.&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;scsi%d: device driver called scsi_done() &quot;
l_string|&quot;for a synchronous reset.&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_SENSE
)paren
(brace
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|SCpnt-&gt;old_cmd_len
suffix:semicolon
id|SCpnt-&gt;sc_data_direction
op_assign
id|SCpnt-&gt;sc_old_data_direction
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
id|SCpnt-&gt;old_underflow
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|host_byte
c_func
(paren
id|result
)paren
)paren
(brace
r_case
id|DID_OK
suffix:colon
r_if
c_cond
(paren
id|status_byte
c_func
(paren
id|result
)paren
op_logical_and
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_SENSE
)paren
)paren
multiline_comment|/* Failed to obtain sense information */
(brace
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|WAS_SENSE
suffix:semicolon
macro_line|#if 0&t;&t;&t;&t;/* This cannot possibly be correct. */
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|SENSE_TIMEOUT
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_RESET
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : channel %d target %d lun %d request sense&quot;
l_string|&quot; failed, performing reset.&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
)paren
suffix:semicolon
id|scsi_reset
c_func
(paren
id|SCpnt
comma
id|SCSI_RESET_SYNCHRONOUS
)paren
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
m_exit
op_assign
(paren
id|DRIVER_HARD
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
id|status
op_assign
id|CMD_FINISHED
suffix:semicolon
)brace
)brace
r_else
r_switch
c_cond
(paren
id|msg_byte
c_func
(paren
id|result
)paren
)paren
(brace
r_case
id|COMMAND_COMPLETE
suffix:colon
r_switch
c_cond
(paren
id|status_byte
c_func
(paren
id|result
)paren
)paren
(brace
r_case
id|GOOD
suffix:colon
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_SENSE
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;In scsi_done, GOOD status, COMMAND COMPLETE, &quot;
l_string|&quot;parsing sense information.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|WAS_SENSE
suffix:semicolon
macro_line|#if 0&t;&t;&t;&t;/* This cannot possibly be correct. */
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|SENSE_TIMEOUT
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|checked
op_assign
id|check_sense
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_case
id|SUGGEST_SENSE
suffix:colon
r_case
l_int|0
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;NO SENSE.  status = REDO&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_IS_OK
suffix:colon
r_break
suffix:semicolon
r_case
id|SUGGEST_REMAP
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SENSE SUGGEST REMAP - status = CMD_FINISHED&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|status
op_assign
id|CMD_FINISHED
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_RETRY
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SENSE SUGGEST RETRY - status = MAYREDO&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|status
op_assign
id|MAYREDO
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_RETRY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_ABORT
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SENSE SUGGEST ABORT - status = CMD_FINISHED&quot;
)paren
suffix:semicolon
macro_line|#endif
id|status
op_assign
id|CMD_FINISHED
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Internal error %s %d &bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end WAS_SENSE */
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;COMMAND COMPLETE message returned, &quot;
l_string|&quot;status = CMD_FINISHED. &bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
m_exit
op_assign
id|DRIVER_OK
suffix:semicolon
id|status
op_assign
id|CMD_FINISHED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CHECK_CONDITION
suffix:colon
r_case
id|COMMAND_TERMINATED
suffix:colon
r_switch
c_cond
(paren
id|check_sense
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_REMAP
suffix:colon
id|status
op_assign
id|CMD_FINISHED
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_RETRY
suffix:colon
id|status
op_assign
id|MAYREDO
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_RETRY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_ABORT
suffix:colon
id|status
op_assign
id|CMD_FINISHED
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_SENSE
suffix:colon
id|scsi_request_sense
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|status
op_assign
id|PENDING
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CONDITION_GOOD
suffix:colon
r_case
id|INTERMEDIATE_GOOD
suffix:colon
r_case
id|INTERMEDIATE_C_GOOD
suffix:colon
r_break
suffix:semicolon
r_case
id|BUSY
suffix:colon
r_case
id|QUEUE_FULL
suffix:colon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESERVATION_CONFLICT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d, channel %d : RESERVATION CONFLICT performing&quot;
l_string|&quot; reset.&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
)paren
suffix:semicolon
id|scsi_reset
c_func
(paren
id|SCpnt
comma
id|SCSI_RESET_SYNCHRONOUS
)paren
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Internal error %s %d &bslash;n&quot;
l_string|&quot;status byte = %d &bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|status_byte
c_func
(paren
id|result
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;scsi: unsupported message byte %d received&bslash;n&quot;
comma
id|msg_byte
c_func
(paren
id|result
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DID_TIME_OUT
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Host returned DID_TIME_OUT - &quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_TIMEDOUT
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Aborting&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t;   Allow TEST_UNIT_READY and INQUIRY commands to timeout early&n;&t;&t;&t;   without causing resets.  All other commands should be retried.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|TEST_UNIT_READY
op_logical_and
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|INQUIRY
)paren
id|status
op_assign
id|MAYREDO
suffix:semicolon
m_exit
op_assign
(paren
id|DRIVER_TIMEOUT
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Retrying.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt-&gt;flags
op_or_assign
id|WAS_TIMEDOUT
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DID_BUS_BUSY
suffix:colon
r_case
id|DID_PARITY
suffix:colon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_NO_CONNECT
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Couldn&squot;t connect.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
m_exit
op_assign
(paren
id|DRIVER_HARD
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_ERROR
suffix:colon
id|status
op_assign
id|MAYREDO
suffix:semicolon
m_exit
op_assign
(paren
id|DRIVER_HARD
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_BAD_TARGET
suffix:colon
r_case
id|DID_ABORT
suffix:colon
m_exit
op_assign
(paren
id|DRIVER_INVALID
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_RESET
suffix:colon
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|IS_RESETTING
)paren
(brace
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|IS_RESETTING
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msg_byte
c_func
(paren
id|result
)paren
op_eq
id|GOOD
op_logical_and
id|status_byte
c_func
(paren
id|result
)paren
op_eq
id|CHECK_CONDITION
)paren
(brace
r_switch
c_cond
(paren
id|check_sense
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_REMAP
suffix:colon
r_case
id|SUGGEST_RETRY
suffix:colon
id|status
op_assign
id|MAYREDO
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_RETRY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_ABORT
suffix:colon
id|status
op_assign
id|CMD_FINISHED
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_SENSE
suffix:colon
id|scsi_request_sense
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|status
op_assign
id|PENDING
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
id|REDO
suffix:semicolon
m_exit
op_assign
id|SUGGEST_RETRY
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
m_exit
op_assign
(paren
id|DRIVER_ERROR
op_or
id|SUGGEST_DIE
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|CMD_FINISHED
suffix:colon
r_case
id|PENDING
suffix:colon
r_break
suffix:semicolon
r_case
id|MAYREDO
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;In MAYREDO, allowing %d retries, have %d&bslash;n&quot;
comma
id|SCpnt-&gt;allowed
comma
id|SCpnt-&gt;retries
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
op_increment
id|SCpnt-&gt;retries
)paren
OL
id|SCpnt-&gt;allowed
)paren
(brace
r_if
c_cond
(paren
(paren
id|SCpnt-&gt;retries
op_ge
(paren
id|SCpnt-&gt;allowed
op_rshift
l_int|1
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|SCpnt-&gt;host-&gt;resetting
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|SCpnt-&gt;host-&gt;last_reset
op_plus
id|MIN_RESET_PERIOD
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_RESET
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d channel %d : resetting for second half of retries.&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
)paren
suffix:semicolon
id|scsi_reset
c_func
(paren
id|SCpnt
comma
id|SCSI_RESET_SYNCHRONOUS
)paren
suffix:semicolon
multiline_comment|/* fall through to REDO */
)brace
)brace
r_else
(brace
id|status
op_assign
id|CMD_FINISHED
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* fall through to REDO */
r_case
id|REDO
suffix:colon
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_SENSE
)paren
id|scsi_request_sense
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_else
(brace
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|SCpnt-&gt;buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|SCpnt-&gt;bufflen
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|SCpnt-&gt;old_cmd_len
suffix:semicolon
id|SCpnt-&gt;sc_data_direction
op_assign
id|SCpnt-&gt;sc_old_data_direction
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
id|SCpnt-&gt;old_underflow
suffix:semicolon
id|SCpnt-&gt;result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;                         * Ugly, ugly.  The newer interfaces all&n;                         * assume that the lock isn&squot;t held.  Mustn&squot;t&n;                         * disappoint, or we deadlock the system.  &n;                         */
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|scsi_dispatch_cmd
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|INTERNAL_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_eq
id|CMD_FINISHED
)paren
(brace
id|Scsi_Request
op_star
id|SRpnt
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Calling done function - at address %p&bslash;n&quot;
comma
id|SCpnt-&gt;done
)paren
suffix:semicolon
macro_line|#endif
id|host-&gt;host_busy
op_decrement
suffix:semicolon
multiline_comment|/* Indicate that we are free */
id|device-&gt;device_busy
op_decrement
suffix:semicolon
multiline_comment|/* Decrement device usage counter. */
id|SCpnt-&gt;result
op_assign
id|result
op_or
(paren
(paren
m_exit
op_amp
l_int|0xff
)paren
op_lshift
l_int|24
)paren
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|SCpnt-&gt;old_cmd_len
suffix:semicolon
id|SCpnt-&gt;sc_data_direction
op_assign
id|SCpnt-&gt;sc_old_data_direction
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
id|SCpnt-&gt;old_underflow
suffix:semicolon
multiline_comment|/*&n;                 * The upper layers assume the lock isn&squot;t held.  We mustn&squot;t&n;                 * disappoint them.  When the new error handling code is in&n;                 * use, the upper code is run from a bottom half handler, so&n;                 * it isn&squot;t an issue.&n;                 */
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|SRpnt
op_assign
id|SCpnt-&gt;sc_request
suffix:semicolon
r_if
c_cond
(paren
id|SRpnt
op_ne
l_int|NULL
)paren
(brace
id|SRpnt-&gt;sr_result
op_assign
id|SRpnt-&gt;sr_command-&gt;result
suffix:semicolon
r_if
c_cond
(paren
id|SRpnt-&gt;sr_result
op_ne
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|SRpnt-&gt;sr_sense_buffer
comma
id|SRpnt-&gt;sr_command-&gt;sense_buffer
comma
r_sizeof
(paren
id|SRpnt-&gt;sr_sense_buffer
)paren
)paren
suffix:semicolon
)brace
)brace
id|SCpnt
op_member_access_from_pointer
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
)brace
DECL|macro|CMD_FINISHED
macro_line|#undef CMD_FINISHED
DECL|macro|REDO
macro_line|#undef REDO
DECL|macro|MAYREDO
macro_line|#undef MAYREDO
DECL|macro|PENDING
macro_line|#undef PENDING
)brace
multiline_comment|/*&n; * The scsi_abort function interfaces with the abort() function of the host&n; * we are aborting, and causes the current command to not complete.  The&n; * caller should deal with any error messages or status returned on the&n; * next call.&n; *&n; * This will not be called reentrantly for a given host.&n; */
multiline_comment|/*&n; * Since we&squot;re nice guys and specified that abort() and reset()&n; * can be non-reentrant.  The internal_timeout flags are used for&n; * this.&n; */
DECL|function|scsi_abort
r_static
r_int
id|scsi_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|why
)paren
(brace
r_int
id|oldto
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Protect against races here.  If the command is done, or we are&n;&t;&t; * on a different command forget it.&n;&t;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;serial_number
op_ne
id|SCpnt-&gt;serial_number_at_timeout
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;internal_timeout
op_amp
id|IN_ABORT
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt-&gt;internal_timeout
op_amp
id|IN_ABORT
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|SCpnt-&gt;internal_timeout
op_or_assign
id|IN_ABORT
suffix:semicolon
id|oldto
op_assign
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|ABORT_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|SCpnt-&gt;flags
op_amp
id|IS_RESETTING
)paren
op_logical_and
id|SCpnt-&gt;device-&gt;soft_reset
)paren
(brace
multiline_comment|/* OK, this command must have died when we did the&n;&t;&t;&t;&t; *  reset.  The device itself must have lied.&n;&t;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;Stale command on %d %d:%d appears to have died when&quot;
l_string|&quot; the bus was reset&bslash;n&quot;
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|host-&gt;host_busy
)paren
(brace
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;scsi : aborting command due to timeout : pid %lu, scsi%d,&quot;
l_string|&quot; channel %d, id %d, lun %d &quot;
comma
id|SCpnt-&gt;pid
comma
id|SCpnt-&gt;host-&gt;host_no
comma
(paren
r_int
)paren
id|SCpnt-&gt;channel
comma
(paren
r_int
)paren
id|SCpnt-&gt;target
comma
(paren
r_int
)paren
id|SCpnt-&gt;lun
)paren
suffix:semicolon
id|print_command
c_func
(paren
id|SCpnt-&gt;cmnd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;serial_number
op_ne
id|SCpnt-&gt;serial_number_at_timeout
)paren
r_return
l_int|0
suffix:semicolon
id|SCpnt-&gt;abort_reason
op_assign
id|why
suffix:semicolon
r_switch
c_cond
(paren
id|host-&gt;hostt
op_member_access_from_pointer
m_abort
(paren
id|SCpnt
)paren
)paren
(brace
multiline_comment|/* We do not know how to abort.  Try waiting another&n;&t;&t;&t;&t; * time increment and see if this helps. Set the&n;&t;&t;&t;&t; * WAS_TIMEDOUT flag set so we do not try this twice&n;&t;&t;&t;&t; */
r_case
id|SCSI_ABORT_BUSY
suffix:colon
multiline_comment|/* Tough call - returning 1 from&n;&t;&t;&t;&t;&t;&t; * this is too severe&n;&t;&t;&t;&t;&t;&t; */
r_case
id|SCSI_ABORT_SNOOZE
suffix:colon
r_if
c_cond
(paren
id|why
op_eq
id|DID_TIME_OUT
)paren
(brace
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_TIMEDOUT
)paren
(brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Indicate we cannot handle this.&n;&t;&t;&t;&t;&t;&t;&t;&t; * We drop down into the reset handler&n;&t;&t;&t;&t;&t;&t;&t;&t; * and try again&n;&t;&t;&t;&t;&t;&t;&t;&t; */
)brace
r_else
(brace
id|SCpnt-&gt;flags
op_or_assign
id|WAS_TIMEDOUT
suffix:semicolon
id|oldto
op_assign
id|SCpnt-&gt;timeout_per_command
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_ABORT_PENDING
suffix:colon
r_if
c_cond
(paren
id|why
op_ne
id|DID_TIME_OUT
)paren
(brace
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_ABORT_SUCCESS
suffix:colon
multiline_comment|/* We should have already aborted this one.  No&n;&t;&t;&t;&t; * need to adjust timeout&n;&t;&t;&t;&t; */
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_ABORT_NOT_RUNNING
suffix:colon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_ABORT_ERROR
suffix:colon
r_default
suffix:colon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* Mark a single SCSI Device as having been reset. */
DECL|function|scsi_mark_device_reset
r_static
r_inline
r_void
id|scsi_mark_device_reset
c_func
(paren
id|Scsi_Device
op_star
id|Device
)paren
(brace
id|Device-&gt;was_reset
op_assign
l_int|1
suffix:semicolon
id|Device-&gt;expecting_cc_ua
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Mark all SCSI Devices on a specific Host as having been reset. */
DECL|function|scsi_mark_host_reset
r_void
id|scsi_mark_host_reset
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|Host
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt
op_assign
id|Host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
id|scsi_mark_device_reset
c_func
(paren
id|SCpnt-&gt;device
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Mark all SCSI Devices on a specific Host Bus as having been reset. */
DECL|function|scsi_mark_bus_reset
r_static
r_void
id|scsi_mark_bus_reset
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|Host
comma
r_int
id|channel
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt
op_assign
id|Host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;channel
op_eq
id|channel
)paren
id|scsi_mark_device_reset
c_func
(paren
id|SCpnt-&gt;device
)paren
suffix:semicolon
)brace
)brace
DECL|function|scsi_reset
r_static
r_int
id|scsi_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
r_int
id|reset_flags
)paren
(brace
r_int
id|temp
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt1
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SCSI bus is being reset for host %d channel %d.&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|SCpnt-&gt;channel
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t; * First of all, we need to make a recommendation to the low-level&n;&t; * driver as to whether a BUS_DEVICE_RESET should be performed,&n;&t; * or whether we should do a full BUS_RESET.  There is no simple&n;&t; * algorithm here - we basically use a series of heuristics&n;&t; * to determine what we should do.&n;&t; */
id|SCpnt-&gt;host-&gt;suggest_bus_reset
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/*&n;&t; * First see if all of the active devices on the bus have&n;&t; * been jammed up so that we are attempting resets.  If so,&n;&t; * then suggest a bus reset.  Forcing a bus reset could&n;&t; * result in some race conditions, but no more than&n;&t; * you would usually get with timeouts.  We will cross&n;&t; * that bridge when we come to it.&n;&t; *&n;&t; * This is actually a pretty bad idea, since a sequence of&n;&t; * commands will often timeout together and this will cause a&n;&t; * Bus Device Reset followed immediately by a SCSI Bus Reset.&n;&t; * If all of the active devices really are jammed up, the&n;&t; * Bus Device Reset will quickly timeout and scsi_times_out&n;&t; * will follow up with a SCSI Bus Reset anyway.&n;&t; */
id|SCpnt1
op_assign
id|host-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt1
)paren
(brace
r_if
c_cond
(paren
id|SCpnt1-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
op_logical_and
(paren
id|SCpnt1-&gt;flags
op_amp
(paren
id|WAS_RESET
op_or
id|IS_RESETTING
)paren
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|SCpnt1
op_assign
id|SCpnt1-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt1
op_eq
l_int|NULL
)paren
(brace
id|reset_flags
op_or_assign
id|SCSI_RESET_SUGGEST_BUS_RESET
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the code that called us is suggesting a hard reset, then&n;&t; * definitely request it.  This usually occurs because a&n;&t; * BUS_DEVICE_RESET times out.&n;&t; *&n;&t; * Passing reset_flags along takes care of this automatically.&n;&t; */
r_if
c_cond
(paren
id|reset_flags
op_amp
id|SCSI_RESET_SUGGEST_BUS_RESET
)paren
(brace
id|SCpnt-&gt;host-&gt;suggest_bus_reset
op_assign
id|TRUE
suffix:semicolon
)brace
macro_line|#endif
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Protect against races here.  If the command is done, or we are&n;&t;&t; * on a different command forget it.&n;&t;&t; */
r_if
c_cond
(paren
id|reset_flags
op_amp
id|SCSI_RESET_ASYNCHRONOUS
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;serial_number
op_ne
id|SCpnt-&gt;serial_number_at_timeout
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;internal_timeout
op_amp
id|IN_RESET
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt-&gt;internal_timeout
op_amp
id|IN_RESET
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|SCpnt-&gt;internal_timeout
op_or_assign
id|IN_RESET
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|RESET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reset_flags
op_amp
id|SCSI_RESET_SYNCHRONOUS
)paren
id|SCpnt-&gt;flags
op_or_assign
id|SYNC_RESET
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;host_busy
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
id|SCpnt1
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt1
)paren
(brace
r_if
c_cond
(paren
id|SCpnt1-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
)paren
(brace
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
(paren
id|SCpnt1-&gt;flags
op_amp
id|IS_RESETTING
)paren
op_logical_and
op_logical_neg
(paren
id|SCpnt1-&gt;internal_timeout
op_amp
id|IN_ABORT
)paren
)paren
id|scsi_abort
c_func
(paren
id|SCpnt1
comma
id|DID_RESET
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt1-&gt;flags
op_or_assign
(paren
id|WAS_RESET
op_or
id|IS_RESETTING
)paren
suffix:semicolon
)brace
id|SCpnt1
op_assign
id|SCpnt1-&gt;next
suffix:semicolon
)brace
)brace
id|host-&gt;last_reset
op_assign
id|jiffies
suffix:semicolon
id|host-&gt;resetting
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * I suppose that the host reset callback will not play&n;&t;&t;&t;&t; * with the resetting field. We have just set the resetting&n;&t;&t;&t;&t; * flag here. -arca&n;&t;&t;&t;&t; */
id|temp
op_assign
id|host-&gt;hostt
op_member_access_from_pointer
id|reset
c_func
(paren
id|SCpnt
comma
id|reset_flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;   This test allows the driver to introduce an additional bus&n;&t;&t;&t;&t;   settle time delay by setting last_reset up to 20 seconds in&n;&t;&t;&t;&t;   the future.  In the normal case where the driver does not&n;&t;&t;&t;&t;   modify last_reset, it must be assumed that the actual bus&n;&t;&t;&t;&t;   reset occurred immediately prior to the return to this code,&n;&t;&t;&t;&t;   and so last_reset must be updated to the current time, so&n;&t;&t;&t;&t;   that the delay in internal_cmnd will guarantee at least a&n;&t;&t;&t;&t;   MIN_RESET_DELAY bus settle time.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|host-&gt;last_reset
op_minus
id|jiffies
OG
l_int|20UL
op_star
id|HZ
)paren
id|host-&gt;last_reset
op_assign
id|jiffies
suffix:semicolon
)brace
r_else
(brace
id|host-&gt;host_busy
op_increment
suffix:semicolon
id|host-&gt;last_reset
op_assign
id|jiffies
suffix:semicolon
id|host-&gt;resetting
op_assign
l_int|1
suffix:semicolon
id|SCpnt-&gt;flags
op_or_assign
(paren
id|WAS_RESET
op_or
id|IS_RESETTING
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * I suppose that the host reset callback will not play&n;&t;&t;&t;&t; * with the resetting field. We have just set the resetting&n;&t;&t;&t;&t; * flag here. -arca&n;&t;&t;&t;&t; */
id|temp
op_assign
id|host-&gt;hostt
op_member_access_from_pointer
id|reset
c_func
(paren
id|SCpnt
comma
id|reset_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|host-&gt;last_reset
comma
id|jiffies
)paren
op_logical_or
(paren
id|time_after
c_func
(paren
id|host-&gt;last_reset
comma
id|jiffies
op_plus
l_int|20
op_star
id|HZ
)paren
)paren
)paren
id|host-&gt;last_reset
op_assign
id|jiffies
suffix:semicolon
id|host-&gt;host_busy
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reset_flags
op_amp
id|SCSI_RESET_SYNCHRONOUS
)paren
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|SYNC_RESET
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;scsi reset function returned %d&bslash;n&quot;
comma
id|temp
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t; * Now figure out what we need to do, based upon&n;&t;&t;&t; * what the low level driver said that it did.&n;&t;&t;&t; * If the result is SCSI_RESET_SUCCESS, SCSI_RESET_PENDING,&n;&t;&t;&t; * or SCSI_RESET_WAKEUP, then the low level driver did a&n;&t;&t;&t; * bus device reset or bus reset, so we should go through&n;&t;&t;&t; * and mark one or all of the devices on that bus&n;&t;&t;&t; * as having been reset.&n;&t;&t;&t; */
r_switch
c_cond
(paren
id|temp
op_amp
id|SCSI_RESET_ACTION
)paren
(brace
r_case
id|SCSI_RESET_SUCCESS
suffix:colon
r_if
c_cond
(paren
id|temp
op_amp
id|SCSI_RESET_HOST_RESET
)paren
id|scsi_mark_host_reset
c_func
(paren
id|host
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|temp
op_amp
id|SCSI_RESET_BUS_RESET
)paren
id|scsi_mark_bus_reset
c_func
(paren
id|host
comma
id|SCpnt-&gt;channel
)paren
suffix:semicolon
r_else
id|scsi_mark_device_reset
c_func
(paren
id|SCpnt-&gt;device
)paren
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
(paren
id|IN_RESET
op_or
id|IN_RESET2
op_or
id|IN_RESET3
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_RESET_PENDING
suffix:colon
r_if
c_cond
(paren
id|temp
op_amp
id|SCSI_RESET_HOST_RESET
)paren
id|scsi_mark_host_reset
c_func
(paren
id|host
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|temp
op_amp
id|SCSI_RESET_BUS_RESET
)paren
id|scsi_mark_bus_reset
c_func
(paren
id|host
comma
id|SCpnt-&gt;channel
)paren
suffix:semicolon
r_else
id|scsi_mark_device_reset
c_func
(paren
id|SCpnt-&gt;device
)paren
suffix:semicolon
r_case
id|SCSI_RESET_NOT_RUNNING
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_RESET_PUNT
suffix:colon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
(paren
id|IN_RESET
op_or
id|IN_RESET2
op_or
id|IN_RESET3
)paren
suffix:semicolon
id|scsi_request_sense
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_RESET_WAKEUP
suffix:colon
r_if
c_cond
(paren
id|temp
op_amp
id|SCSI_RESET_HOST_RESET
)paren
id|scsi_mark_host_reset
c_func
(paren
id|host
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|temp
op_amp
id|SCSI_RESET_BUS_RESET
)paren
id|scsi_mark_bus_reset
c_func
(paren
id|host
comma
id|SCpnt-&gt;channel
)paren
suffix:semicolon
r_else
id|scsi_mark_device_reset
c_func
(paren
id|SCpnt-&gt;device
)paren
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
(paren
id|IN_RESET
op_or
id|IN_RESET2
op_or
id|IN_RESET3
)paren
suffix:semicolon
id|scsi_request_sense
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * If a bus reset was performed, we&n;&t;&t;&t;&t; * need to wake up each and every command&n;&t;&t;&t;&t; * that was active on the bus or if it was a HBA&n;&t;&t;&t;&t; * reset all active commands on all channels&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|temp
op_amp
id|SCSI_RESET_HOST_RESET
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
id|SCpnt1
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt1
)paren
(brace
r_if
c_cond
(paren
id|SCpnt1-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
op_logical_and
id|SCpnt1
op_ne
id|SCpnt
)paren
id|scsi_request_sense
c_func
(paren
id|SCpnt1
)paren
suffix:semicolon
id|SCpnt1
op_assign
id|SCpnt1-&gt;next
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|temp
op_amp
id|SCSI_RESET_BUS_RESET
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
id|SCpnt1
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt1
)paren
(brace
r_if
c_cond
(paren
id|SCpnt1-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
op_logical_and
id|SCpnt1
op_ne
id|SCpnt
op_logical_and
id|SCpnt1-&gt;channel
op_eq
id|SCpnt-&gt;channel
)paren
id|scsi_request_sense
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCpnt1
op_assign
id|SCpnt1-&gt;next
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_RESET_SNOOZE
suffix:colon
multiline_comment|/* In this case, we set the timeout field to 0&n;&t;&t;&t;&t; * so that this command does not time out any more,&n;&t;&t;&t;&t; * and we return 1 so that we get a message on the&n;&t;&t;&t;&t; * screen.&n;&t;&t;&t;&t; */
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
(paren
id|IN_RESET
op_or
id|IN_RESET2
op_or
id|IN_RESET3
)paren
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* If you snooze, you lose... */
r_case
id|SCSI_RESET_ERROR
suffix:colon
r_default
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
r_return
id|temp
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * The strategy is to cause the timer code to call scsi_times_out()&n; * when the soonest timeout is pending.&n; * The arguments are used when we are queueing a new command, because&n; * we do not want to subtract the time used from this time, but when we&n; * set the timer, we want to take this value into account.&n; */
DECL|function|update_timeout
r_int
id|update_timeout
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCset
comma
r_int
id|timeout
)paren
(brace
r_int
id|rtn
suffix:semicolon
multiline_comment|/*&n;&t; * We are using the new error handling code to actually register/deregister&n;&t; * timers for timeout.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|timer_pending
c_func
(paren
op_amp
id|SCset-&gt;eh_timeout
)paren
)paren
(brace
id|rtn
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|rtn
op_assign
id|SCset-&gt;eh_timeout.expires
op_minus
id|jiffies
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timeout
op_eq
l_int|0
)paren
(brace
id|scsi_delete_timer
c_func
(paren
id|SCset
)paren
suffix:semicolon
)brace
r_else
(brace
id|scsi_add_timer
c_func
(paren
id|SCset
comma
id|timeout
comma
id|scsi_old_times_out
)paren
suffix:semicolon
)brace
r_return
id|rtn
suffix:semicolon
)brace
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 4&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: nil&n; * tab-width: 8&n; * End:&n; */
eof
