multiline_comment|/* &n; * Set these options for all host adapters.&n; * &t;- Memory mapped IO does not work.&n; *&t;- Test 1 does a bus mastering test, which will help&n; *&t;  weed out brain damaged main boards.&n; */
DECL|macro|PERM_OPTIONS
mdefine_line|#define PERM_OPTIONS (OPTION_IO_MAPPED|OPTION_DEBUG_TEST1)
multiline_comment|/*&n; * Define SCSI_MALLOC to use scsi_malloc instead of kmalloc.  Other than&n; * preventing deadlock, I&squot;m not sure why we&squot;d want to do this.&n; */
DECL|macro|SCSI_MALLOC
mdefine_line|#define SCSI_MALLOC
multiline_comment|/*&n; * Sponsored by &n; *&t;iX Multiuser Multitasking Magazine&n; *&t;Hannover, Germany&n; *&t;hm@ix.de&n; *&n; * Copyright 1993, 1994 Drew Eckhardt&n; *      Visionary Computing &n; *      (Unix and Linux consulting and custom programming)&n; *      drew@Colorado.EDU&n; *&t;+1 (303) 786-7975&n; *&n; * TolerANT and SCSI SCRIPTS are registered trademarks of NCR Corporation.&n; * &n; * PRE-ALPHA&n; *&n; * For more information, please consult &n; *&n; *&n; * NCR 53C700/53C700-66&n; * SCSI I/O Processor&n; * Data Manual&n; *&n; * NCR53C710 &n; * SCSI I/O Processor&n; * Programmer&squot;s Guide&n; *&n; * NCR 53C810&n; * PCI-SCSI I/O Processor&n; * Data Manual&n; *&n; * NCR 53C810/53C820&n; * PCI-SCSI I/O Processor Design In Guide&n; *&n; * NCR Microelectronics&n; * 1635 Aeroplaza Drive&n; * Colorado Springs, CO 80916&n; * +1 (719) 578-3400&n; *&n; * Toll free literature number&n; * +1 (800) 334-5454&n; *&n; * PCI BIOS Specification Revision&n; * PCI Local Bus Specification&n; * PCI System Design Guide&n; *&n; * PCI Special Interest Group&n; * M/S HF3-15A&n; * 5200 N.E. Elam Young Parkway&n; * Hillsboro, Oregon 97124-6497&n; * +1 (503) 696-2000 &n; * +1 (800) 433-5177&n; */
multiline_comment|/*&n; * Design issues : &n; * The cumulative latency needed to propagate a read/write request &n; * through the filesystem, buffer cache, driver stacks, SCSI host, and &n; * SCSI device is ultimately the limiting factor in throughput once we &n; * have a sufficiently fast host adapter.&n; *  &n; * So, to maximize performance we want to keep the ratio of latency to data &n; * transfer time to a minimum by&n; * 1.  Minimizing the total number of commands sent (typical command latency&n; *&t;including drive and busmastering host overhead is as high as 4.5ms)&n; *&t;to transfer a given amount of data.  &n; *&n; *      This is accomplished by placing no arbitrary limit on the number&n; *&t;of scatter/gather buffers supported, since we can transfer 1K&n; *&t;per scatter/gather buffer without Eric&squot;s cluster patches, &n; *&t;4K with.  &n; *&n; * 2.  Minimizing the number of fatal interrupts serviced, since&n; * &t;fatal interrupts halt the SCSI I/O processor.  Basically,&n; *&t;this means offloading the practical maximum amount of processing &n; *&t;to the SCSI chip.&n; * &n; *&t;On the NCR53c810/820,  this is accomplished by using &n; *&t;&t;interrupt-on-the-fly signals with the DSA address as a &n; *&t;&t;parameter when commands complete, and only handling fatal &n; *&t;&t;errors and SDTR / WDTR &t;messages in the host code.&n; *&n; *&t;On the NCR53c710/720, interrupts are generated as on the NCR53c8x0,&n; *&t;&t;only the lack of a interrupt-on-the-fly facility complicates&n; *&t;&t;things.  &n; *&t;&t;&n; * &t;On the NCR53c700 and NCR53c700-66, operations that were done via &n; *&t;&t;indirect, table mode on the more advanced chips have&n; *&t;&t;been replaced by calls through a jump table which &n; *&t;&t;acts as a surrogate for the DSA.  Unfortunately, this &n; * &t;&t;means that we must service an interrupt for each &n; *&t;&t;disconnect/reconnect.&n; * &n; * 3.  Eliminating latency by pipelining operations at the different levels.&n; * &t;&n; *&t;This driver allows a configurable number of commands to be enqueued&n; *&t;for each target/lun combination (experimentally, I have discovered&n; *&t;that two seems to work best) and will ultimately allow for &n; *&t;SCSI-II tagged queueing.&n; * &t;&n; *&n; * Architecture : &n; * This driver is built around two queues of commands waiting to &n; * be executed - the Linux issue queue, and the shared Linux/NCR  &n; * queue which are manipulated by the NCR53c7xx_queue_command and &n; * NCR53c7x0_intr routines.&n; *&n; * When the higher level routines pass a SCSI request down to &n; * NCR53c7xx_queue_command, it looks to see if that target/lun &n; * is currently busy. If not, the command is inserted into the &n; * shared Linux/NCR queue, otherwise it is inserted into the Linux &n; * queue.&n; *&n; * As commands are completed, the interrupt routine is triggered,&n; * looks for commands in the linked list of completed commands with&n; * valid status, removes these commands from the list, calls &n; * the done routine, and flags their target/luns as not busy.&n; *&n; * Due to limitations in the intelligence of the NCR chips, certain&n; * concessions are made.  In many cases, it is easier to dynamically &n; * generate/fixup code rather than calculate on the NCR at run time.  &n; * So, code is generated or fixed up for&n; *&n; * - Handling data transfers, using a variable number of MOVE instructions&n; *&t;interspersed with CALL MSG_IN, WHEN MSGIN instructions.&n; *&n; * &t;The DATAIN and DATAOUT routines&t;are separate, so that an incorrect&n; *&t;direction can be trapped, and space isn&squot;t wasted. &n; *&n; *&t;It may turn out that we&squot;re better off using some sort &n; *&t;of table indirect instruction in a loop with a variable&n; *&t;sized table on the NCR53c710 and newer chips.&n; *&n; * - Checking for reselection (NCR53c710 and better)&n; *&n; * - Handling the details of SCSI context switches (NCR53c710 and better),&n; *&t;such as reprogramming appropriate synchronous parameters, &n; *&t;removing the dsa structure from the NCR&squot;s queue of outstanding&n; *&t;commands, etc.&n; *&n; */
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &quot;../block/blk.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;53c7,8xx.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#include &quot;sd.h&quot;
r_static
r_void
id|abnormal_finished
(paren
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
comma
r_int
id|result
)paren
suffix:semicolon
r_static
r_int
id|NCR53c8xx_run_tests
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
suffix:semicolon
DECL|variable|NCR53c8xx_script_len
r_static
r_int
id|NCR53c8xx_script_len
suffix:semicolon
r_static
r_void
id|NCR53c7x0_intr
(paren
r_int
id|irq
)paren
suffix:semicolon
r_static
r_void
id|intr_phase_mismatch
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|intr_dma
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|print_dsa
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_int
r_int
op_star
id|dsa
)paren
suffix:semicolon
r_static
r_int
id|print_insn
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_int
r_int
op_star
id|insn
comma
r_char
op_star
id|prefix
comma
r_int
id|kernel
)paren
suffix:semicolon
r_static
r_void
id|NCR53c8xx_dsa_fixup
(paren
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|NCR53c8x0_init_fixup
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
suffix:semicolon
r_static
r_int
id|NCR53c8x0_dstat_sir_intr
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|NCR53c8x0_soft_reset
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
suffix:semicolon
DECL|variable|first_host
r_static
r_struct
id|Scsi_Host
op_star
id|first_host
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Head of list of NCR boards */
DECL|variable|the_template
r_static
id|Scsi_Host_Template
op_star
id|the_template
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Allocate storage space for constant messages, etc. */
DECL|variable|NCR53c7xx_zero
r_static
r_int
id|NCR53c7xx_zero
op_assign
l_int|0
suffix:semicolon
DECL|variable|NCR53c7xx_sink
r_static
r_int
id|NCR53c7xx_sink
suffix:semicolon
DECL|variable|NCR53c7xx_msg_reject
r_static
r_char
id|NCR53c7xx_msg_reject
op_assign
id|MESSAGE_REJECT
suffix:semicolon
DECL|variable|NCR53c7xx_msg_abort
r_static
r_char
id|NCR53c7xx_msg_abort
op_assign
id|ABORT
suffix:semicolon
DECL|variable|NCR53c7xx_msg_nop
r_static
r_char
id|NCR53c7xx_msg_nop
op_assign
id|NOP
suffix:semicolon
multiline_comment|/* Buffer for commands run before *malloc() works */
multiline_comment|/* &n; * XXX - if need be, replace this with normal wait.&n; */
DECL|variable|scan_scsis_buf_busy
r_static
r_int
id|scan_scsis_buf_busy
op_assign
l_int|0
suffix:semicolon
DECL|variable|scan_scsis_buf
r_static
r_char
id|scan_scsis_buf
(braket
l_int|512
)braket
suffix:semicolon
multiline_comment|/*&n; * Spl-levels are evil. We shouldn&squot;t emulate braindamage.&n; *&t;&t;Linus&n; */
DECL|function|splx
r_static
r_int
id|splx
(paren
r_int
id|new_level
)paren
(brace
r_register
r_int
id|old_level
comma
id|tmp
suffix:semicolon
id|save_flags
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|old_level
op_assign
(paren
id|tmp
op_amp
l_int|0x200
)paren
ques
c_cond
l_int|7
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|new_level
)paren
id|sti
c_func
(paren
)paren
suffix:semicolon
r_else
id|cli
c_func
(paren
)paren
suffix:semicolon
r_return
id|old_level
suffix:semicolon
)brace
multiline_comment|/*&n; * TODO : &n; *&n; * 1.  Implement single step / trace code?&n; * &n; * 2.  The initial code has been tested on the NCR53c810.  I don&squot;t &n; *     have access to NCR53c700, 700-66 (Forex boards), NCR53c710&n; *     (NCR Pentium systems), NCR53c720, or NCR53c820 boards to finish&n; *     development on those platforms.&n; *&n; *     NCR53c820/720 - need to add wide transfer support, including WDTR &n; *     &t;&t;negotiation, programming of wide transfer capabilities&n; *&t;&t;on reselection and table indirect selection.&n; *&n; *     NCR53c720/710 - need to add fatal interrupt or GEN code for &n; *&t;&t;command completion signaling.   Need to take care of &n; *&t;        ADD WITH CARRY instructions since carry is unimplemented.&n; *&t;&t;Also need to modify all SDID, SCID, etc. registers,&n; *&t;&t;and table indirect select code since these use bit&n; *&t;&t;fielded (ie 1&lt;&lt;target) instead of binary encoded&n; *&t;&t;target ids.  Also, SCNTL3 is _not_ automatically&n; *&t;&t;programmed on selection, so we need to add more code.&n; * &n; *     NCR53c700/700-66 - need to add code to refix addresses on &n; *&t;&t;every nexus change, eliminate all table indirect code.&n; *&n; * 3.  The NCR53c7x0 series is very popular on other platforms that &n; *     could be running Linux - ie, some high performance AMIGA SCSI &n; *     boards use it.  &n; *&t;&n; *     So, I should include #ifdef&squot;d code so that it is &n; *     compatible with these systems.&n; *&t;&n; *     Specifically, the little Endian assumptions I made in my &n; *     bit fields need to change, and if the NCR doesn&squot;t see memory&n; *     the right way, we need to provide options to reverse words&n; *     when the scripts are relocated.&n; *&n; * 4.  Implement code to include page table entries for the &n; *     area occupied by memory mapped boards so we don&squot;t have &n; *     to use the potentially slower I/O accesses.&n; */
multiline_comment|/* &n; * XXX - note that my assembler was modified so that internally,&n; * the names used can take a prefix, so that there is no conflict&n; * between multiple copies of the same script assembled with &n; * different defines.&n; *&n; *&n; * Allow for simultaneous existence of multiple SCSI scripts so we &n; * can have a single driver binary for all of the family.&n; *&n; * - one for NCR53c700 and NCR53c700-66 chips&t;(not yet supported)&n; * - one for NCR53c710 and NCR53c720 chips&t;(not yet supported)&n; * - one for NCR53c810 and NCR53c820 chips &t;(only the NCR53c810 is&n; *&t;currently supported)&n; *&n; * For the very similar chips, we should probably hack the fixup code&n; * and interrupt code so that it works everywhere, but I suspect the &n; * NCR53c700 is going&n; * to need it&squot;s own fixup routine.&n; */
multiline_comment|/*&n; * Use to translate between device IDs of various types.&n; */
DECL|struct|pci_chip
r_struct
id|pci_chip
(brace
DECL|member|pci_device_id
r_int
r_int
id|pci_device_id
suffix:semicolon
DECL|member|chip
r_int
id|chip
suffix:semicolon
DECL|member|max_revision
r_int
id|max_revision
suffix:semicolon
DECL|member|min_revision
r_int
id|min_revision
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|pci_chip_ids
r_static
r_struct
id|pci_chip
id|pci_chip_ids
(braket
)braket
op_assign
(brace
(brace
id|PCI_DEVICE_ID_NCR_53C810
comma
l_int|810
comma
l_int|1
comma
l_int|1
)brace
comma
(brace
id|PCI_DEVICE_ID_NCR_53C815
comma
l_int|815
comma
l_int|2
comma
l_int|3
)brace
comma
(brace
id|PCI_DEVICE_ID_NCR_53C820
comma
l_int|820
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
(brace
id|PCI_DEVICE_ID_NCR_53C825
comma
l_int|825
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
)brace
suffix:semicolon
DECL|macro|NPCI_CHIP_IDS
mdefine_line|#define NPCI_CHIP_IDS (sizeof (pci_chip_ids) / sizeof(pci_chip_ids[0]))
multiline_comment|/* Forced detection and autoprobe code for various hardware */
DECL|struct|override
r_static
r_struct
id|override
(brace
DECL|member|chip
r_int
id|chip
suffix:semicolon
multiline_comment|/* 700, 70066, 710, 720, 810, 820 */
DECL|member|board
r_int
id|board
suffix:semicolon
multiline_comment|/* Any special board level gunk */
DECL|member|pci
r_int
id|pci
suffix:colon
l_int|1
suffix:semicolon
r_union
(brace
r_struct
(brace
DECL|member|base
r_int
id|base
suffix:semicolon
multiline_comment|/* Memory address - indicates memory mapped regs */
DECL|member|io_port
r_int
id|io_port
suffix:semicolon
multiline_comment|/* I/O port address - indicates I/O mapped regs */
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* IRQ line */
DECL|member|dma
r_int
id|dma
suffix:semicolon
multiline_comment|/* DMA channel &t;&t;- often none */
DECL|member|normal
)brace
id|normal
suffix:semicolon
r_struct
(brace
DECL|member|bus
r_int
id|bus
suffix:semicolon
DECL|member|device
r_int
id|device
suffix:semicolon
DECL|member|function
r_int
id|function
suffix:semicolon
DECL|member|pci
)brace
id|pci
suffix:semicolon
DECL|member|data
)brace
id|data
suffix:semicolon
DECL|member|options
r_int
id|options
suffix:semicolon
DECL|variable|overrides
)brace
id|overrides
(braket
l_int|4
)braket
op_assign
(brace
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
DECL|variable|commandline_current
r_static
r_int
id|commandline_current
op_assign
l_int|0
suffix:semicolon
DECL|variable|no_overrides
r_static
r_int
id|no_overrides
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
mdefine_line|#define OVERRIDE_LIMIT (sizeof(overrides) / sizeof(struct override))
macro_line|#else
DECL|macro|OVERRIDE_LIMIT
mdefine_line|#define OVERRIDE_LIMIT commandline_current
macro_line|#endif
multiline_comment|/*&n; * Function : static internal_setup(int board, int chip, char *str, int *ints)&n; *&n; * Purpose : LILO command line initialization of the overrides array,&n; * &n; * Inputs : board - currently, unsupported.  chip - 700, 70066, 710, 720&n; * &t;810, 815, 820, 825, although currently only the NCR53c810 is &n; *&t;supported.&n; * &n; */
DECL|function|internal_setup
r_static
r_void
id|internal_setup
c_func
(paren
r_int
id|board
comma
r_int
id|chip
comma
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_int
r_char
id|pci
suffix:semicolon
multiline_comment|/* Specifies a PCI override, with bus, device,&n;&t;&t;&t;&t;   function */
id|pci
op_assign
(paren
id|str
op_logical_and
op_logical_neg
id|strcmp
(paren
id|str
comma
l_string|&quot;pci&quot;
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Override syntaxes are as follows : &n; * ncr53c700,ncr53c700-66,ncr53c710,ncr53c720=mem,io,irq,dma&n; * ncr53c810,ncr53c820,ncr53c825=mem,io,irq or pci,bus,device,function&n; */
r_if
c_cond
(paren
id|commandline_current
OL
id|OVERRIDE_LIMIT
)paren
(brace
id|overrides
(braket
id|commandline_current
)braket
dot
id|pci
op_assign
id|pci
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci
)paren
(brace
id|overrides
(braket
id|commandline_current
)braket
dot
id|data.normal.base
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
id|overrides
(braket
id|commandline_current
)braket
dot
id|data.normal.io_port
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
id|overrides
(braket
id|commandline_current
)braket
dot
id|data.normal.irq
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
id|overrides
(braket
id|commandline_current
)braket
dot
id|data.normal.dma
op_assign
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|4
)paren
ques
c_cond
id|ints
(braket
l_int|4
)braket
suffix:colon
id|DMA_NONE
suffix:semicolon
id|overrides
(braket
id|commandline_current
)braket
dot
id|options
op_assign
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|5
)paren
ques
c_cond
id|ints
(braket
l_int|5
)braket
suffix:colon
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|overrides
(braket
id|commandline_current
)braket
dot
id|data.pci.bus
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
id|overrides
(braket
id|commandline_current
)braket
dot
id|data.pci.device
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
id|overrides
(braket
id|commandline_current
)braket
dot
id|data.pci.device
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
id|overrides
(braket
id|commandline_current
)braket
dot
id|options
op_assign
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|4
)paren
ques
c_cond
id|ints
(braket
l_int|4
)braket
suffix:colon
l_int|0
suffix:semicolon
)brace
id|overrides
(braket
id|commandline_current
)braket
dot
id|board
op_assign
id|board
suffix:semicolon
id|overrides
(braket
id|commandline_current
)braket
dot
id|chip
op_assign
id|chip
suffix:semicolon
op_increment
id|commandline_current
suffix:semicolon
op_increment
id|no_overrides
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;53c7,7x0.c:internal_setup() : too many overrides&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * XXX - we might want to implement a single override function&n; *       with a chip type field, revamp the command line configuration,&n; * &t; etc.&n; */
DECL|macro|setup_wrapper
mdefine_line|#define setup_wrapper(x) &t;&t;&t;&t;&bslash;&n;void ncr53c##x##_setup (char *str, int *ints) {&t;&t;&bslash;&n;    internal_setup (BOARD_GENERIC, x, str, ints);&t;&bslash;&n;}
id|setup_wrapper
c_func
(paren
l_int|700
)paren
id|setup_wrapper
c_func
(paren
l_int|70066
)paren
id|setup_wrapper
c_func
(paren
l_int|710
)paren
id|setup_wrapper
c_func
(paren
l_int|720
)paren
id|setup_wrapper
c_func
(paren
l_int|810
)paren
id|setup_wrapper
c_func
(paren
l_int|815
)paren
id|setup_wrapper
c_func
(paren
l_int|820
)paren
id|setup_wrapper
c_func
(paren
l_int|825
)paren
multiline_comment|/* &n; * Function : static int NCR53c7x0_init (struct Scsi_Host *host)&n; *&n; * Purpose :  initialize the internal structures for a given SCSI host&n; *&n; * Inputs : host - pointer to this host adapter&squot;s structure/ &n; *&n; * Preconditions : when this function is called, the chip_type &n; * &t;field of the hostdata structure MUST have been set.&n; */
DECL|function|NCR53c7x0_init
r_static
r_int
id|NCR53c7x0_init
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* unsigned char tmp; */
r_int
id|i
comma
id|j
comma
id|ccf
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|search
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hostdata-&gt;chip
)paren
(brace
r_case
l_int|810
suffix:colon
r_case
l_int|815
suffix:colon
r_case
l_int|820
suffix:colon
r_case
l_int|825
suffix:colon
id|hostdata-&gt;dstat_sir_intr
op_assign
id|NCR53c8x0_dstat_sir_intr
suffix:semicolon
id|hostdata-&gt;init_save_regs
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;dsa_fixup
op_assign
id|NCR53c8xx_dsa_fixup
suffix:semicolon
id|hostdata-&gt;init_fixup
op_assign
id|NCR53c8x0_init_fixup
suffix:semicolon
id|hostdata-&gt;soft_reset
op_assign
id|NCR53c8x0_soft_reset
suffix:semicolon
id|hostdata-&gt;run_tests
op_assign
id|NCR53c8xx_run_tests
suffix:semicolon
multiline_comment|/* Is the SCSI clock ever anything else on these chips? */
id|hostdata-&gt;scsi_clock
op_assign
l_int|40000000
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : chip type of %d is not supported yet, detaching.&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|hostdata-&gt;chip
)paren
suffix:semicolon
id|scsi_unregister
(paren
id|host
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;     * Set up an interrupt handler if we aren&squot;t already sharing an IRQ&n;     * with another board.&n;     */
r_for
c_loop
(paren
id|search
op_assign
id|first_host
suffix:semicolon
id|search
op_logical_and
(paren
id|search-&gt;hostt
op_eq
id|the_template
)paren
op_logical_and
(paren
id|search-&gt;irq
op_ne
id|host-&gt;irq
)paren
suffix:semicolon
id|search
op_assign
id|search-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|search
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|host-&gt;irq
comma
id|NCR53c7x0_intr
comma
id|SA_INTERRUPT
comma
l_string|&quot;53c7,8xx&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : IRQ%d not free, detaching&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|host-&gt;irq
)paren
suffix:semicolon
id|scsi_unregister
(paren
id|host
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : using interrupt handler previously installed for scsi%d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|search-&gt;host_no
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;scsi%d : using %s mapped access&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_MEMORY_MAPPED
)paren
ques
c_cond
l_string|&quot;memory&quot;
suffix:colon
l_string|&quot;io&quot;
)paren
suffix:semicolon
id|hostdata-&gt;dmode
op_assign
(paren
id|hostdata-&gt;chip
op_eq
l_int|700
op_logical_or
id|hostdata-&gt;chip
op_eq
l_int|70066
)paren
ques
c_cond
id|DMODE_REG_00
suffix:colon
id|DMODE_REG_10
suffix:semicolon
id|hostdata-&gt;istat
op_assign
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
ques
c_cond
id|ISTAT_REG_800
suffix:colon
id|ISTAT_REG_700
suffix:semicolon
multiline_comment|/* &n; * XXX - the NCR53c700 uses bitfielded registers for SCID, SDID, etc,&n; *&t;as does the 710 with one bit per SCSI ID.  Conversely, the NCR&n; * &t;uses a normal, 3 bit binary representation of these values.&n; *&n; * Get the rest of the NCR documentation, and FIND OUT where the change&n; * was.&n; */
macro_line|#if 0
id|tmp
op_assign
id|hostdata-&gt;this_id_mask
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SCID_REG
)paren
suffix:semicolon
r_for
c_loop
(paren
id|host-&gt;this_id
op_assign
l_int|0
suffix:semicolon
id|tmp
op_ne
l_int|1
suffix:semicolon
id|tmp
op_rshift_assign
l_int|1
comma
op_increment
id|host-&gt;this_id
)paren
suffix:semicolon
macro_line|#else
id|host-&gt;this_id
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SCID_REG
)paren
op_amp
l_int|7
suffix:semicolon
id|hostdata-&gt;this_id_mask
op_assign
l_int|1
op_lshift
id|host-&gt;this_id
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;scsi%d : using initiator ID %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|host-&gt;this_id
)paren
suffix:semicolon
multiline_comment|/*&n;     * Save important registers to allow a soft reset.&n;     */
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
(brace
multiline_comment|/* &n;     * CTEST4 controls burst mode disable.&n;     */
id|hostdata-&gt;saved_ctest4
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|CTEST4_REG_800
)paren
op_amp
id|CTEST4_800_SAVE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;     * CTEST7 controls cache snooping, burst mode, and support for &n;     * external differential drivers.&n;     */
id|hostdata-&gt;saved_ctest7
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|CTEST7_REG
)paren
op_amp
id|CTEST7_SAVE
suffix:semicolon
)brace
multiline_comment|/*&n;     * On NCR53c700 series chips, DCNTL controls the SCSI clock divisor,&n;     * on 800 series chips, it allows for a totem-pole IRQ driver.&n;     */
id|hostdata-&gt;saved_dcntl
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|DCNTL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
id|printk
(paren
l_string|&quot;scsi%d : using %s interrupts.&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
id|hostdata-&gt;saved_dcntl
op_amp
id|DCNTL_800_IRQM
)paren
ques
c_cond
l_string|&quot;level active&quot;
suffix:colon
l_string|&quot;edge triggered&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * DMODE controls DMA burst length, and on 700 series chips,&n;     * 286 mode and bus width  &n;     */
id|hostdata-&gt;saved_dmode
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|hostdata-&gt;dmode
)paren
suffix:semicolon
multiline_comment|/* &n;     * Now that burst length and enabled/disabled status is known, &n;     * clue the user in on it.&n;     */
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;saved_ctest4
op_amp
id|CTEST4_800_BDIS
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : burst mode disabled&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|hostdata-&gt;saved_dmode
op_amp
id|DMODE_BL_MASK
)paren
(brace
r_case
id|DMODE_BL_2
suffix:colon
id|i
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DMODE_BL_4
suffix:colon
id|i
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DMODE_BL_8
suffix:colon
id|i
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DMODE_BL_16
suffix:colon
id|i
op_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;scsi%d ; burst length %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * On NCR53c810 and NCR53c820 chips, SCNTL3 contails the synchronous&n;     * and normal clock conversion factors.&n;     */
r_if
c_cond
(paren
id|hostdata-&gt;chip
op_div
l_int|100
op_eq
l_int|8
)paren
(brace
id|hostdata-&gt;saved_scntl3
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SCNTL3_REG_800
)paren
suffix:semicolon
id|ccf
op_assign
id|hostdata-&gt;saved_scntl3
op_amp
id|SCNTL3_800_CCF_MASK
suffix:semicolon
)brace
r_else
id|ccf
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * If we don&squot;t have a SCSI clock programmed, pick one on the upper&n;     * bound of that allowed by NCR so that our transfers err on the &n;     * slow side, since transfer period must be &gt;= the agreed &n;     * appon period.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;scsi_clock
)paren
r_switch
c_cond
(paren
id|ccf
)paren
(brace
r_case
l_int|1
suffix:colon
id|hostdata-&gt;scsi_clock
op_assign
l_int|25000000
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Divide by 1.0 */
r_case
l_int|2
suffix:colon
id|hostdata-&gt;scsi_clock
op_assign
l_int|37500000
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Divide by 1.5 */
r_case
l_int|3
suffix:colon
id|hostdata-&gt;scsi_clock
op_assign
l_int|50000000
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Divide by 2.0 */
r_case
l_int|0
suffix:colon
multiline_comment|/* Divide by 3.0 */
r_case
l_int|4
suffix:colon
id|hostdata-&gt;scsi_clock
op_assign
l_int|66000000
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : clock conversion factor %d unknown.&bslash;n&quot;
l_string|&quot;         synchronous transfers disabled&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|ccf
)paren
suffix:semicolon
id|hostdata-&gt;options
op_and_assign
op_complement
id|OPTION_SYNCHRONOUS
suffix:semicolon
id|hostdata-&gt;scsi_clock
op_assign
l_int|0
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;scsi%d : using %dMHz SCSI clock&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|hostdata-&gt;scsi_clock
op_div
l_int|1000000
)paren
suffix:semicolon
multiline_comment|/*&n;     * Initialize per-target structures, including busy flags and &n;     * synchronous transfer parameters.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
op_increment
id|j
)paren
id|hostdata-&gt;busy
(braket
id|i
)braket
(braket
id|j
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t; * NCR53c700 and NCR53c700-66 chips lack the DSA and use a &n;&t; * different architecture.  For chips using the DSA architecture,&n;&t; * initialize the per-target synchronous parameters. &n;&t; */
r_if
c_cond
(paren
id|hostdata-&gt;chip
op_ne
l_int|700
op_logical_and
id|hostdata-&gt;chip
op_ne
l_int|70066
)paren
(brace
id|hostdata-&gt;sync
(braket
id|i
)braket
dot
id|select_indirect
op_or_assign
(paren
id|i
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* XXX - program SCSI script for immediate return */
id|hostdata-&gt;sync
(braket
id|i
)braket
dot
id|script
(braket
l_int|0
)braket
op_assign
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_RETURN
)paren
op_lshift
l_int|24
op_or
id|DBC_TCI_TRUE
suffix:semicolon
r_switch
c_cond
(paren
id|hostdata-&gt;chip
)paren
(brace
multiline_comment|/* Clock divisor */
r_case
l_int|825
suffix:colon
r_case
l_int|820
suffix:colon
multiline_comment|/* Fall through to 810 */
r_case
l_int|815
suffix:colon
r_case
l_int|810
suffix:colon
id|hostdata-&gt;sync
(braket
id|i
)braket
dot
id|select_indirect
op_or_assign
(paren
id|hostdata-&gt;saved_scntl3
)paren
op_lshift
l_int|24
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
)brace
)brace
id|hostdata-&gt;issue_queue
op_assign
id|hostdata-&gt;running_list
op_assign
id|hostdata-&gt;finished_queue
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;issue_dsa_head
op_assign
id|hostdata-&gt;issue_dsa_tail
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;init_save_regs
)paren
id|hostdata-&gt;init_save_regs
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;init_fixup
)paren
id|hostdata-&gt;init_fixup
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|the_template
)paren
(brace
id|the_template
op_assign
id|host-&gt;hostt
suffix:semicolon
id|first_host
op_assign
id|host
suffix:semicolon
)brace
id|hostdata-&gt;idle
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* &n;     * Linux SCSI drivers have always been plagued with initialization &n;     * problems - some didn&squot;t work with the BIOS disabled since they expected&n;     * initialization from it, some didn&squot;t work when the networking code&n;     * was enabled and registers got scrambled, etc.&n;     *&n;     * To avoid problems like this, in the future, we will do a soft &n;     * reset on the SCSI chip, taking it back to a sane state.&n;     */
id|hostdata-&gt;soft_reset
(paren
id|host
)paren
suffix:semicolon
id|hostdata-&gt;debug_count_limit
op_assign
op_minus
l_int|1
suffix:semicolon
id|hostdata-&gt;intrs
op_assign
op_minus
l_int|1
suffix:semicolon
id|hostdata-&gt;expecting_iid
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;expecting_sto
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hostdata-&gt;run_tests
op_logical_and
id|hostdata
op_member_access_from_pointer
id|run_tests
c_func
(paren
id|host
)paren
op_eq
op_minus
l_int|1
)paren
op_logical_or
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_TESTS_ONLY
)paren
)paren
(brace
multiline_comment|/* XXX Should disable interrupts, etc. here */
id|scsi_unregister
(paren
id|host
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : static int normal_init(Scsi_Host_Template *tpnt, int board, &n; *&t;int chip, int base, int io_port, int irq, int dma, int pcivalid,&n; *&t;unsigned char pci_bus, unsigned char pci_device_fn,&n; *&t;int options);&n; *&n; * Purpose : initializes a NCR53c7,8x0 based on base addresses,&n; *&t;IRQ, and DMA channel.&t;&n; *&t;&n; *&t;Useful where a new NCR chip is backwards compatible with&n; *&t;a supported chip, but the DEVICE ID has changed so it &n; *&t;doesn&squot;t show up when the autoprobe does a pcibios_find_device.&n; *&n; * Inputs : tpnt - Template for this SCSI adapter, board - board level&n; *&t;product, chip - 810, 820, or 825, bus - PCI bus, device_fn -&n; *&t;device and function encoding as used by PCI BIOS calls.&n; * &n; * Returns : 0 on success, -1 on failure.&n; *&n; */
DECL|function|normal_init
r_static
r_int
id|normal_init
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|board
comma
r_int
id|chip
comma
r_int
id|base
comma
r_int
id|io_port
comma
r_int
id|irq
comma
r_int
id|dma
comma
r_int
id|pci_valid
comma
r_int
r_char
id|pci_bus
comma
r_int
r_char
id|pci_device_fn
comma
r_int
id|options
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
suffix:semicolon
r_char
id|chip_str
(braket
l_int|80
)braket
suffix:semicolon
r_int
id|script_len
op_assign
l_int|0
comma
id|size
op_assign
l_int|0
suffix:semicolon
r_int
id|ok
op_assign
l_int|0
suffix:semicolon
id|options
op_or_assign
id|PERM_OPTIONS
suffix:semicolon
r_switch
c_cond
(paren
id|chip
)paren
(brace
r_case
l_int|825
suffix:colon
r_case
l_int|820
suffix:colon
r_case
l_int|815
suffix:colon
r_case
l_int|810
suffix:colon
id|script_len
op_assign
id|NCR53c8xx_script_len
suffix:semicolon
id|options
op_or_assign
id|OPTION_INTFLY
suffix:semicolon
id|sprintf
(paren
id|chip_str
comma
l_string|&quot;NCR53c%d&quot;
comma
id|chip
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi-ncr53c7,8xx : unsupported SCSI chip %d&bslash;n&quot;
comma
id|chip
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;scsi-ncr53c7,8xx : %s at memory 0x%x, io 0x%x, irq %d&quot;
comma
id|chip_str
comma
id|base
comma
id|io_port
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma
op_eq
id|DMA_NONE
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;, dma %d&bslash;n&quot;
comma
id|dma
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|chip
op_div
l_int|100
op_eq
l_int|8
)paren
op_logical_and
op_logical_neg
id|pci_valid
)paren
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : for better reliability and performance, please use the&bslash;n&quot;
l_string|&quot;        PCI override instead.&bslash;n&quot;
l_string|&quot;&t; Syntax : ncr53c8{10,20,25}=pci,&lt;bus&gt;,&lt;device&gt;,&lt;function&gt;&bslash;n&quot;
l_string|&quot;&t;          &lt;bus&gt; and &lt;device&gt; are usually 0.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|options
op_amp
id|OPTION_DEBUG_PROBE_ONLY
)paren
(brace
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : probe only enabled, aborting initialization&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|size
op_assign
r_sizeof
(paren
r_struct
id|NCR53c7x0_hostdata
)paren
op_plus
id|script_len
suffix:semicolon
id|instance
op_assign
id|scsi_register
(paren
id|tpnt
comma
id|size
)paren
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|hostdata-&gt;size
op_assign
id|size
suffix:semicolon
id|hostdata-&gt;script_count
op_assign
id|script_len
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|hostdata-&gt;board
op_assign
id|board
suffix:semicolon
id|hostdata-&gt;chip
op_assign
id|chip
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hostdata-&gt;pci_valid
op_assign
id|pci_valid
)paren
)paren
(brace
id|hostdata-&gt;pci_bus
op_assign
id|pci_bus
suffix:semicolon
id|hostdata-&gt;pci_device_fn
op_assign
id|pci_device_fn
suffix:semicolon
)brace
multiline_comment|/*&n;     * Being memory mapped is more desirable, since &n;     *&n;     * - Memory accesses may be faster.&n;     *&n;     * - The destination and source address spaces are the same for &n;     *&t; all instructions, meaning we don&squot;t have to twiddle dmode or &n;     *&t; any other registers.&n;     *&n;     * So, we try for memory mapped, and if we don&squot;t get it,&n;     * we go for port mapped, and that failing we tell the user&n;     * it can&squot;t work.&n;     */
r_if
c_cond
(paren
id|base
)paren
(brace
id|instance-&gt;base
op_assign
(paren
r_int
r_char
op_star
)paren
id|base
suffix:semicolon
multiline_comment|/* Check for forced I/O mapping */
r_if
c_cond
(paren
op_logical_neg
(paren
id|options
op_amp
id|OPTION_IO_MAPPED
)paren
)paren
(brace
id|options
op_or_assign
id|OPTION_MEMORY_MAPPED
suffix:semicolon
id|ok
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|options
op_and_assign
op_complement
id|OPTION_MEMORY_MAPPED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|io_port
)paren
(brace
id|instance-&gt;io_port
op_assign
id|io_port
suffix:semicolon
id|options
op_or_assign
id|OPTION_IO_MAPPED
suffix:semicolon
id|ok
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|options
op_and_assign
op_complement
id|OPTION_IO_MAPPED
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ok
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : not initializing, no I/O or memory mapping known &bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|scsi_unregister
(paren
id|instance
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|instance-&gt;irq
op_assign
id|irq
suffix:semicolon
id|instance-&gt;dma_channel
op_assign
id|dma
suffix:semicolon
id|hostdata-&gt;options
op_assign
id|options
suffix:semicolon
r_return
id|NCR53c7x0_init
c_func
(paren
id|instance
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : static int pci_init(Scsi_Host_Template *tpnt, int board, &n; *&t;int chip, int bus, int device_fn, int options)&n; *&n; * Purpose : initializes a NCR53c800 family based on the PCI&n; *&t;bus, device, and function location of it.  Allows &n; * &t;reprogramming of latency timer and determining addresses&n; *&t;and weather bus mastering, etc. are OK.&n; *&t;&n; *&t;Useful where a new NCR chip is backwards compatible with&n; *&t;a supported chip, but the DEVICE ID has changed so it &n; *&t;doesn&squot;t show up when the autoprobe does a pcibios_find_device.&n; *&n; * Inputs : tpnt - Template for this SCSI adapter, board - board level&n; *&t;product, chip - 810, 820, or 825, bus - PCI bus, device_fn -&n; *&t;device and function encoding as used by PCI BIOS calls.&n; * &n; * Returns : 0 on success, -1 on failure.&n; *&n; */
DECL|function|pci_init
r_static
r_int
id|pci_init
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|board
comma
r_int
id|chip
comma
r_int
r_char
id|bus
comma
r_int
r_char
id|device_fn
comma
r_int
id|options
)paren
(brace
r_int
r_int
id|vendor_id
comma
id|device_id
comma
id|command
suffix:semicolon
r_int
r_int
id|base
comma
id|io_port
suffix:semicolon
r_int
r_char
id|irq
comma
id|revision
suffix:semicolon
r_int
id|error
comma
id|expected_chip
comma
id|expected_id
comma
id|max_revision
comma
id|min_revision
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi-ncr53c7,8xx : at PCI bus %d, device %d,  function %d&bslash;n&quot;
comma
id|bus
comma
(paren
r_int
)paren
(paren
id|device_fn
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
comma
(paren
r_int
)paren
id|device_fn
op_amp
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibios_present
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi-ncr53c7,8xx : not initializing due to lack of PCI BIOS,&bslash;n&quot;
l_string|&quot;        try using memory, port, irq override instead.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|pcibios_read_config_word
(paren
id|bus
comma
id|device_fn
comma
id|PCI_VENDOR_ID
comma
op_amp
id|vendor_id
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_word
(paren
id|bus
comma
id|device_fn
comma
id|PCI_DEVICE_ID
comma
op_amp
id|device_id
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_word
(paren
id|bus
comma
id|device_fn
comma
id|PCI_COMMAND
comma
op_amp
id|command
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_dword
(paren
id|bus
comma
id|device_fn
comma
id|PCI_BASE_ADDRESS_0
comma
op_amp
id|io_port
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_dword
(paren
id|bus
comma
id|device_fn
comma
id|PCI_BASE_ADDRESS_1
comma
op_amp
id|base
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_byte
(paren
id|bus
comma
id|device_fn
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|revision
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_byte
(paren
id|bus
comma
id|device_fn
comma
id|PCI_INTERRUPT_LINE
comma
op_amp
id|irq
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : error %s not initializing due to error reading configuration space&bslash;n&quot;
l_string|&quot;&t; perhaps you specified an incorrect PCI bus, device, or function.&bslash;n&quot;
comma
id|pcibios_strerror
c_func
(paren
id|error
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If any one ever clones the NCR chips, this will have to change */
r_if
c_cond
(paren
id|vendor_id
op_ne
id|PCI_VENDOR_ID_NCR
)paren
(brace
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : not initializing, 0x%04x is not NCR vendor ID&bslash;n&quot;
comma
(paren
r_int
)paren
id|vendor_id
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n;     * Bit 0 is the address space indicator and must be one for I/O&n;     * space mappings, bit 1 is reserved, discard them after checking&n;     * that they have the correct value of 1.&n;     */
r_if
c_cond
(paren
id|command
op_amp
id|PCI_COMMAND_IO
)paren
(brace
r_if
c_cond
(paren
(paren
id|io_port
op_amp
l_int|3
)paren
op_ne
l_int|1
)paren
(brace
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : disabling I/O mapping since base address 0 (0x%lx)&bslash;n&quot;
l_string|&quot;        bits 0..1 indicate a non-IO mapping&bslash;n&quot;
comma
id|io_port
)paren
suffix:semicolon
id|io_port
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|io_port
op_and_assign
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|command
op_amp
id|PCI_COMMAND_MEMORY
)paren
(brace
r_if
c_cond
(paren
(paren
id|base
op_amp
id|PCI_BASE_ADDRESS_SPACE
)paren
op_ne
id|PCI_BASE_ADDRESS_SPACE_MEMORY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi-ncr53c7,8xx : disabling memory mapping since base address 1&bslash;n&quot;
l_string|&quot;        contains a non-memory mapping&bslash;n&quot;
)paren
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|base
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|io_port
op_logical_and
op_logical_neg
id|base
)paren
(brace
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : not initializing, both I/O and memory mappings disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|command
op_amp
id|PCI_COMMAND_MASTER
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : not initializing, BUS MASTERING was disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NPCI_CHIP_IDS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|device_id
op_eq
id|pci_chip_ids
(braket
id|i
)braket
dot
id|pci_device_id
)paren
(brace
id|max_revision
op_assign
id|pci_chip_ids
(braket
id|i
)braket
dot
id|max_revision
suffix:semicolon
id|min_revision
op_assign
id|pci_chip_ids
(braket
id|i
)braket
dot
id|min_revision
suffix:semicolon
id|expected_chip
op_assign
id|pci_chip_ids
(braket
id|i
)braket
dot
id|chip
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chip
op_eq
id|pci_chip_ids
(braket
id|i
)braket
dot
id|chip
)paren
id|expected_id
op_assign
id|pci_chip_ids
(braket
id|i
)braket
dot
id|pci_device_id
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chip
op_logical_and
id|device_id
op_ne
id|expected_id
)paren
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : warning : device id of 0x%04x doesn&squot;t&bslash;n&quot;
l_string|&quot;                   match expected 0x%04x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|device_id
comma
(paren
r_int
r_int
)paren
id|expected_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_revision
op_ne
op_minus
l_int|1
op_logical_and
id|revision
OG
id|max_revision
)paren
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : warning : revision of %d is greater than %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|revision
comma
id|max_revision
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|min_revision
op_ne
op_minus
l_int|1
op_logical_and
id|revision
OL
id|min_revision
)paren
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : warning : revision of %d is less than %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|revision
comma
id|min_revision
)paren
suffix:semicolon
r_return
id|normal_init
(paren
id|tpnt
comma
id|board
comma
id|chip
comma
(paren
r_int
)paren
id|base
comma
(paren
r_int
)paren
id|io_port
comma
(paren
r_int
)paren
id|irq
comma
id|DMA_NONE
comma
l_int|1
comma
id|bus
comma
id|device_fn
comma
id|options
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : int NCR53c7xx_detect(Scsi_Host_Template *tpnt)&n; *&n; * Purpose : detects and initializes NCR53c7,8x0 SCSI chips&n; *&t;that were autoprobed, overridden on the LILO command line, &n; *&t;or specified at compile time.&n; *&n; * Inputs : tpnt - template for this SCSI adapter&n; * &n; * Returns : number of host adapters detected&n; *&n; */
DECL|function|NCR53c7xx_detect
r_int
id|NCR53c7xx_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|current_chip
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|current_override
suffix:semicolon
r_int
id|count
suffix:semicolon
multiline_comment|/* Number of boards detected */
r_int
r_char
id|pci_bus
comma
id|pci_device_fn
suffix:semicolon
r_static
r_int
id|pci_index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Device index to PCI BIOS calls */
r_for
c_loop
(paren
id|current_override
op_assign
id|count
op_assign
l_int|0
suffix:semicolon
id|current_override
OL
id|OVERRIDE_LIMIT
suffix:semicolon
op_increment
id|current_override
)paren
(brace
r_if
c_cond
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|pci
ques
c_cond
op_logical_neg
id|pci_init
(paren
id|tpnt
comma
id|overrides
(braket
id|current_override
)braket
dot
id|board
comma
id|overrides
(braket
id|current_override
)braket
dot
id|chip
comma
(paren
r_int
r_char
)paren
id|overrides
(braket
id|current_override
)braket
dot
id|data.pci.bus
comma
(paren
(paren
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|data.pci.device
op_lshift
l_int|3
)paren
op_amp
l_int|0xf8
)paren
op_or
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|data.pci.function
op_amp
l_int|7
)paren
)paren
comma
id|overrides
(braket
id|current_override
)braket
dot
id|options
)paren
suffix:colon
op_logical_neg
id|normal_init
(paren
id|tpnt
comma
id|overrides
(braket
id|current_override
)braket
dot
id|board
comma
id|overrides
(braket
id|current_override
)braket
dot
id|chip
comma
id|overrides
(braket
id|current_override
)braket
dot
id|data.normal.base
comma
id|overrides
(braket
id|current_override
)braket
dot
id|data.normal.io_port
comma
id|overrides
(braket
id|current_override
)braket
dot
id|data.normal.irq
comma
id|overrides
(braket
id|current_override
)braket
dot
id|data.normal.dma
comma
l_int|0
multiline_comment|/* PCI data invalid */
comma
l_int|0
multiline_comment|/* PCI bus place holder */
comma
l_int|0
multiline_comment|/* PCI device_function place holder */
comma
id|overrides
(braket
id|current_override
)braket
dot
id|options
)paren
)paren
(brace
op_increment
id|count
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pcibios_present
c_func
(paren
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NPCI_CHIP_IDS
suffix:semicolon
op_increment
id|i
)paren
r_for
c_loop
(paren
id|pci_index
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|pcibios_find_device
(paren
id|PCI_VENDOR_ID_NCR
comma
id|pci_chip_ids
(braket
id|i
)braket
dot
id|pci_device_id
comma
id|pci_index
comma
op_amp
id|pci_bus
comma
op_amp
id|pci_device_fn
)paren
op_logical_and
op_logical_neg
id|pci_init
(paren
id|tpnt
comma
id|BOARD_GENERIC
comma
id|pci_chip_ids
(braket
id|i
)braket
dot
id|chip
comma
id|pci_bus
comma
id|pci_device_fn
comma
multiline_comment|/* no options */
l_int|0
)paren
suffix:semicolon
op_increment
id|count
comma
op_increment
id|pci_index
)paren
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* NCR53c810 and NCR53c820 script handling code */
macro_line|#include &quot;53c8xx_d.h&quot;
DECL|variable|NCR53c8xx_script_len
r_static
r_int
id|NCR53c8xx_script_len
op_assign
r_sizeof
(paren
id|SCRIPT
)paren
suffix:semicolon
multiline_comment|/* &n; * Function : static void NCR53c8x0_init_fixup (struct Scsi_Host *host)&n; *&n; * Purpose :  copy and fixup the SCSI SCRIPTS(tm) code for this device.&n; *&n; * Inputs : host - pointer to this host adapter&squot;s structure&n; *&n; */
DECL|function|NCR53c8x0_init_fixup
r_static
r_void
id|NCR53c8x0_init_fixup
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
r_char
id|tmp
suffix:semicolon
r_int
id|i
comma
id|ncr_to_memory
comma
id|memory_to_ncr
comma
id|ncr_to_ncr
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* XXX - NOTE : this code MUST be made endian aware */
multiline_comment|/*  Copy code into buffer that was allocated at detection time.  */
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|hostdata-&gt;script
comma
(paren
r_void
op_star
)paren
id|SCRIPT
comma
r_sizeof
(paren
id|SCRIPT
)paren
)paren
suffix:semicolon
multiline_comment|/* Fixup labels */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PATCHES
suffix:semicolon
op_increment
id|i
)paren
id|hostdata-&gt;script
(braket
id|LABELPATCHES
(braket
id|i
)braket
)braket
op_add_assign
(paren
r_int
r_int
)paren
id|hostdata-&gt;script
suffix:semicolon
multiline_comment|/* &n;     * Fixup absolutes set at boot-time.&n;     * &n;     * All Absolute variables suffixed with &quot;dsa_&quot; and &quot;int_&quot;&n;     * are constants, and need no fixup provided the assembler has done &n;     * it for us (I don&squot;t know what the &quot;real&quot; NCR assembler does in &n;     * this case, my assembler does the right magic).&n;     */
multiline_comment|/*&n;     * Just for the hell of it, preserve the settings of &n;     * Burst Length and Enable Read Line bits from the DMODE &n;     * register.  Make sure SCRIPTS start automagically.&n;     */
id|tmp
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|DMODE_REG_10
)paren
suffix:semicolon
id|tmp
op_and_assign
(paren
id|DMODE_800_ERL
op_or
id|DMODE_BL_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_MEMORY_MAPPED
)paren
)paren
(brace
id|base
op_assign
(paren
r_int
)paren
id|host-&gt;io_port
suffix:semicolon
id|memory_to_ncr
op_assign
id|tmp
op_or
id|DMODE_800_DIOM
suffix:semicolon
id|ncr_to_memory
op_assign
id|tmp
op_or
id|DMODE_800_SIOM
suffix:semicolon
id|ncr_to_ncr
op_assign
id|tmp
op_or
id|DMODE_800_DIOM
op_or
id|DMODE_800_SIOM
suffix:semicolon
)brace
r_else
(brace
id|base
op_assign
(paren
r_int
)paren
id|host-&gt;base
suffix:semicolon
id|ncr_to_ncr
op_assign
id|memory_to_ncr
op_assign
id|ncr_to_memory
op_assign
id|tmp
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;scsi%d : m_to_n = 0x%x, n_to_m = 0x%x, n_to_n = 0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|host-&gt;host_no
comma
(paren
r_int
)paren
id|memory_to_ncr
comma
(paren
r_int
)paren
id|ncr_to_memory
comma
id|ncr_to_ncr
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|addr_scratch
comma
id|base
op_plus
id|SCRATCHA_REG_800
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|addr_sfbr
comma
id|base
op_plus
id|SFBR_REG
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|addr_temp
comma
id|base
op_plus
id|TEMP_REG
)paren
suffix:semicolon
multiline_comment|/*&n;     * I needed some variables in the script to be accessible to &n;     * both the NCR chip and the host processor. For these variables,&n;     * I made the arbitrary decision to store them directly in the &n;     * hostdata structure rather than in the RELATIVE area of the &n;     * SCRIPTS.&n;     */
id|patch_abs_rwri_data
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|dmode_memory_to_memory
comma
id|tmp
)paren
suffix:semicolon
id|patch_abs_rwri_data
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|dmode_memory_to_ncr
comma
id|memory_to_ncr
)paren
suffix:semicolon
id|patch_abs_rwri_data
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|dmode_ncr_to_memory
comma
id|ncr_to_memory
)paren
suffix:semicolon
id|patch_abs_rwri_data
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|dmode_ncr_to_ncr
comma
id|ncr_to_ncr
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|issue_dsa_head
comma
(paren
r_int
)paren
op_amp
(paren
id|hostdata-&gt;issue_dsa_head
)paren
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|msg_buf
comma
(paren
r_int
)paren
op_amp
(paren
id|hostdata-&gt;msg_buf
)paren
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|reconnect_dsa_head
comma
(paren
r_int
)paren
op_amp
(paren
id|hostdata-&gt;reconnect_dsa_head
)paren
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|reselected_identify
comma
(paren
r_int
)paren
op_amp
(paren
id|hostdata-&gt;reselected_identify
)paren
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|reselected_tag
comma
(paren
r_int
)paren
op_amp
(paren
id|hostdata-&gt;reselected_tag
)paren
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|test_dest
comma
(paren
r_int
)paren
op_amp
(paren
id|hostdata-&gt;test_dest
)paren
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|test_src
comma
(paren
r_int
)paren
op_amp
(paren
id|hostdata-&gt;test_source
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * Make sure the NCR and Linux code agree on the location of &n;     * certain fields.&n;     */
multiline_comment|/* &n; * XXX - for cleanness, E_* fields should be type unsigned long *&n; * and should reflect the _relocated_ addresses.  Change this.&n; */
id|hostdata-&gt;E_accept_message
op_assign
id|Ent_accept_message
suffix:semicolon
id|hostdata-&gt;E_command_complete
op_assign
id|Ent_command_complete
suffix:semicolon
id|hostdata-&gt;E_debug_break
op_assign
id|Ent_debug_break
suffix:semicolon
id|hostdata-&gt;E_dsa_code_template
op_assign
id|Ent_dsa_code_template
suffix:semicolon
id|hostdata-&gt;E_dsa_code_template_end
op_assign
id|Ent_dsa_code_template_end
suffix:semicolon
id|hostdata-&gt;E_initiator_abort
op_assign
id|Ent_initiator_abort
suffix:semicolon
id|hostdata-&gt;E_msg_in
op_assign
id|Ent_msg_in
suffix:semicolon
id|hostdata-&gt;E_other_transfer
op_assign
id|Ent_other_transfer
suffix:semicolon
id|hostdata-&gt;E_reject_message
op_assign
id|Ent_reject_message
suffix:semicolon
id|hostdata-&gt;E_respond_message
op_assign
id|Ent_respond_message
suffix:semicolon
id|hostdata-&gt;E_schedule
op_assign
id|Ent_schedule
suffix:semicolon
id|hostdata-&gt;E_select
op_assign
id|Ent_select
suffix:semicolon
id|hostdata-&gt;E_select_msgout
op_assign
id|Ent_select_msgout
suffix:semicolon
id|hostdata-&gt;E_target_abort
op_assign
id|Ent_target_abort
suffix:semicolon
macro_line|#ifdef Ent_test_0
id|hostdata-&gt;E_test_0
op_assign
id|Ent_test_0
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;E_test_1
op_assign
id|Ent_test_1
suffix:semicolon
id|hostdata-&gt;E_test_2
op_assign
id|Ent_test_2
suffix:semicolon
macro_line|#ifdef Ent_test_3
id|hostdata-&gt;E_test_3
op_assign
id|Ent_test_3
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;dsa_cmdout
op_assign
id|A_dsa_cmdout
suffix:semicolon
id|hostdata-&gt;dsa_cmnd
op_assign
id|A_dsa_cmnd
suffix:semicolon
id|hostdata-&gt;dsa_datain
op_assign
id|A_dsa_datain
suffix:semicolon
id|hostdata-&gt;dsa_dataout
op_assign
id|A_dsa_dataout
suffix:semicolon
id|hostdata-&gt;dsa_end
op_assign
id|A_dsa_end
suffix:semicolon
id|hostdata-&gt;dsa_msgin
op_assign
id|A_dsa_msgin
suffix:semicolon
id|hostdata-&gt;dsa_msgout
op_assign
id|A_dsa_msgout
suffix:semicolon
id|hostdata-&gt;dsa_msgout_other
op_assign
id|A_dsa_msgout_other
suffix:semicolon
id|hostdata-&gt;dsa_next
op_assign
id|A_dsa_next
suffix:semicolon
id|hostdata-&gt;dsa_select
op_assign
id|A_dsa_select
suffix:semicolon
id|hostdata-&gt;dsa_start
op_assign
id|Ent_dsa_code_template
op_minus
id|Ent_dsa_zero
suffix:semicolon
id|hostdata-&gt;dsa_status
op_assign
id|A_dsa_status
suffix:semicolon
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|A_dsa_fields_start
op_ne
id|Ent_dsa_code_template_end
op_minus
id|Ent_dsa_zero
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : NCR dsa_fields start is %d not %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|A_dsa_fields_start
comma
id|Ent_dsa_code_template_end
op_minus
id|Ent_dsa_zero
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : NCR code relocated to 0x%lx&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
r_int
)paren
id|hostdata-&gt;script
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : static int NCR53c8xx_run_tests (struct Scsi_Host *host)&n; *&n; * Purpose : run various verification tests on the NCR chip, &n; *&t;including interrupt generation, and proper bus mastering&n; * &t;operation.&n; * &n; * Inputs : host - a properly initialized Scsi_Host structure&n; *&n; * Preconditions : the NCR chip must be in a halted state.&n; *&n; * Returns : 0 if all tests were successful, -1 on error.&n; * &n; */
DECL|function|NCR53c8xx_run_tests
r_static
r_int
id|NCR53c8xx_run_tests
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|timeout
comma
id|start
suffix:semicolon
r_int
id|old_level
comma
id|failed
comma
id|i
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : testing&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
multiline_comment|/* The NCR chip _must_ be idle to run the test scripts */
id|old_level
op_assign
id|splx
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;idle
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : chip not idle, aborting tests&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n;     * Check for functional interrupts, this could work as an&n;     * autoprobe routine.&n;     */
r_if
c_cond
(paren
id|hostdata-&gt;issue_dsa_head
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : hostdata-&gt;issue_dsa_head corrupt before test 1&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|hostdata-&gt;issue_dsa_head
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_TEST1
)paren
(brace
id|hostdata-&gt;idle
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;test_running
op_assign
l_int|1
suffix:semicolon
id|hostdata-&gt;test_completed
op_assign
op_minus
l_int|1
suffix:semicolon
id|hostdata-&gt;test_dest
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;test_source
op_assign
l_int|0xdeadbeef
suffix:semicolon
id|start
op_assign
(paren
(paren
r_int
r_int
)paren
id|hostdata-&gt;script
)paren
op_plus
id|hostdata-&gt;E_test_1
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|STATE_RUNNING
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : test 1&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|NCR53c7x0_write32
(paren
id|DSP_REG
comma
id|start
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot; started&bslash;n&quot;
)paren
suffix:semicolon
id|splx
c_func
(paren
l_int|7
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
l_int|50
suffix:semicolon
multiline_comment|/* arbitrary */
r_while
c_loop
(paren
(paren
id|hostdata-&gt;test_completed
op_eq
op_minus
l_int|1
)paren
op_logical_and
id|jiffies
OL
id|timeout
)paren
suffix:semicolon
id|failed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;test_completed
op_eq
op_minus
l_int|1
)paren
id|printk
(paren
l_string|&quot;scsi%d : driver test 1 timed out%s&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
id|hostdata-&gt;test_dest
op_eq
l_int|0xdeadbeef
)paren
ques
c_cond
l_string|&quot; due to lost interrupt.&bslash;n&quot;
l_string|&quot;         Please verify that the correct IRQ is being used for your board,&bslash;n&quot;
l_string|&quot;&t;      and that the motherboard IRQ jumpering matches the PCI setup on&bslash;n&quot;
l_string|&quot;         PCI systems.&bslash;n&quot;
l_string|&quot;         If you are using a NCR53c810 board in a PCI system, you should&bslash;n&quot;
l_string|&quot;         also verify that the board is jumpered to use PCI INTA, since&bslash;n&quot;
l_string|&quot;         most PCI motherboards lack support for INTB, INTC, and INTD.&bslash;n&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hostdata-&gt;test_completed
op_ne
l_int|1
)paren
id|printk
(paren
l_string|&quot;scsi%d : test 1 bad interrupt value (%ld)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|hostdata-&gt;test_completed
)paren
suffix:semicolon
r_else
id|failed
op_assign
(paren
id|hostdata-&gt;test_dest
op_ne
l_int|0xdeadbeef
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;test_dest
op_ne
l_int|0xdeadbeef
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : driver test 1 read 0x%x instead of 0xdeadbeef indicating a&bslash;n&quot;
l_string|&quot;         probable cache invalidation problem.  Please configure caching&bslash;n&quot;
l_string|&quot;&t;      as write-through or disabled&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|hostdata-&gt;test_dest
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|failed
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : DSP = 0x%lx (script at 0x%lx, start at 0x%lx)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
r_int
)paren
id|NCR53c7x0_read32
c_func
(paren
id|DSP_REG
)paren
comma
(paren
r_int
r_int
)paren
id|hostdata-&gt;script
comma
id|start
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : DSPS = 0x%lx&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
r_int
)paren
id|NCR53c7x0_read32
c_func
(paren
id|DSPS_REG
)paren
)paren
suffix:semicolon
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|hostdata-&gt;test_running
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hostdata-&gt;issue_dsa_head
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : hostdata-&gt;issue_dsa_head corrupt after test 1&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|hostdata-&gt;issue_dsa_head
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_TEST2
)paren
(brace
r_int
r_int
id|dsa
(braket
l_int|48
)braket
suffix:semicolon
r_int
r_char
id|identify
op_assign
id|IDENTIFY
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_int
r_char
id|cmd
(braket
l_int|6
)braket
suffix:semicolon
r_int
r_char
id|data
(braket
l_int|36
)braket
suffix:semicolon
r_int
r_char
id|status
op_assign
l_int|0xff
suffix:semicolon
r_int
r_char
id|msg
op_assign
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
id|cmd
(braket
l_int|2
)braket
op_assign
id|cmd
(braket
l_int|3
)braket
op_assign
id|cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|data
)paren
suffix:semicolon
id|dsa
(braket
l_int|2
)braket
op_assign
l_int|1
suffix:semicolon
id|dsa
(braket
l_int|3
)braket
op_assign
(paren
r_int
r_int
)paren
op_amp
id|identify
suffix:semicolon
id|dsa
(braket
l_int|4
)braket
op_assign
l_int|6
suffix:semicolon
id|dsa
(braket
l_int|5
)braket
op_assign
(paren
r_int
r_int
)paren
op_amp
id|cmd
suffix:semicolon
id|dsa
(braket
l_int|6
)braket
op_assign
r_sizeof
(paren
id|data
)paren
suffix:semicolon
id|dsa
(braket
l_int|7
)braket
op_assign
(paren
r_int
r_int
)paren
op_amp
id|data
suffix:semicolon
id|dsa
(braket
l_int|8
)braket
op_assign
l_int|1
suffix:semicolon
id|dsa
(braket
l_int|9
)braket
op_assign
(paren
r_int
r_int
)paren
op_amp
id|status
suffix:semicolon
id|dsa
(braket
l_int|10
)braket
op_assign
l_int|1
suffix:semicolon
id|dsa
(braket
l_int|11
)braket
op_assign
(paren
r_int
r_int
)paren
op_amp
id|msg
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
op_increment
id|i
)paren
(brace
id|splx
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;idle
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : chip not idle, aborting tests&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&t;     SCNTL3         SDID&t;*/
id|dsa
(braket
l_int|0
)braket
op_assign
(paren
l_int|0x33
op_lshift
l_int|24
)paren
op_or
(paren
id|i
op_lshift
l_int|16
)paren
suffix:semicolon
id|hostdata-&gt;idle
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;test_running
op_assign
l_int|2
suffix:semicolon
id|hostdata-&gt;test_completed
op_assign
op_minus
l_int|1
suffix:semicolon
id|start
op_assign
(paren
(paren
r_int
r_int
)paren
id|hostdata-&gt;script
)paren
op_plus
id|hostdata-&gt;E_test_2
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|STATE_RUNNING
suffix:semicolon
id|NCR53c7x0_write32
(paren
id|DSA_REG
comma
(paren
r_int
r_int
)paren
id|dsa
)paren
suffix:semicolon
id|NCR53c7x0_write32
(paren
id|DSP_REG
comma
id|start
)paren
suffix:semicolon
id|splx
c_func
(paren
l_int|7
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
l_int|500
suffix:semicolon
multiline_comment|/* arbitrary */
r_while
c_loop
(paren
(paren
id|hostdata-&gt;test_completed
op_eq
op_minus
l_int|1
)paren
op_logical_and
id|jiffies
OL
id|timeout
)paren
suffix:semicolon
id|NCR53c7x0_write32
(paren
id|DSA_REG
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;test_completed
op_eq
l_int|2
)paren
(brace
id|data
(braket
l_int|35
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : test 2 INQUIRY to target %d, lun 0 : %s&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|i
comma
id|data
op_plus
l_int|8
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : status &quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_status
(paren
id|status
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;nscsi%d : message &quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_msg
(paren
op_amp
id|msg
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hostdata-&gt;test_completed
op_eq
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : test 2 no connection with target %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;idle
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : not idle&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|hostdata-&gt;test_completed
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : test 2 timed out&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|hostdata-&gt;test_running
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;issue_dsa_head
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : hostdata-&gt;issue_dsa_head corrupt after test 2 id %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|i
)paren
suffix:semicolon
id|hostdata-&gt;issue_dsa_head
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
id|printk
(paren
l_string|&quot;scsi%d : tests complete.&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : static void NCR53c8xx_dsa_fixup (struct NCR53c7x0_cmd *cmd)&n; *&n; * Purpose : copy the NCR53c8xx dsa structure into cmd&squot;s dsa buffer,&n; * &t;performing all necessary relocation.&n; *&n; * Inputs : cmd, a NCR53c7x0_cmd structure with a dsa area large&n; *&t;enough to hold the NCR53c8xx dsa.&n; */
DECL|function|NCR53c8xx_dsa_fixup
r_static
r_void
id|NCR53c8xx_dsa_fixup
(paren
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
(brace
id|Scsi_Cmnd
op_star
id|c
op_assign
id|cmd-&gt;cmd
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|c-&gt;host
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memcpy
(paren
id|cmd-&gt;dsa
comma
id|hostdata-&gt;script
op_plus
(paren
id|hostdata-&gt;E_dsa_code_template
op_div
l_int|4
)paren
comma
id|hostdata-&gt;E_dsa_code_template_end
op_minus
id|hostdata-&gt;E_dsa_code_template
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|cmd-&gt;dsa
comma
id|Ent_dsa_code_template
op_div
r_sizeof
(paren
r_int
)paren
comma
id|dsa_temp_jump_resume
comma
(paren
(paren
r_int
r_int
)paren
id|cmd-&gt;dsa
)paren
op_plus
id|Ent_dsa_jump_resume
op_minus
id|Ent_dsa_zero
)paren
suffix:semicolon
id|patch_abs_rwri_data
(paren
id|cmd-&gt;dsa
comma
id|Ent_dsa_code_template
op_div
r_sizeof
(paren
r_int
)paren
comma
id|dsa_temp_lun
comma
id|c-&gt;lun
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|cmd-&gt;dsa
comma
id|Ent_dsa_code_template
op_div
r_sizeof
(paren
r_int
)paren
comma
id|dsa_temp_dsa_next
comma
(paren
(paren
r_int
r_int
)paren
id|cmd-&gt;dsa
)paren
op_plus
id|A_dsa_next
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|cmd-&gt;dsa
comma
id|Ent_dsa_code_template
op_div
r_sizeof
(paren
r_int
)paren
comma
id|dsa_temp_sync
comma
id|hostdata-&gt;sync
(braket
id|c-&gt;target
)braket
dot
id|select_indirect
)paren
suffix:semicolon
id|patch_abs_rwri_data
(paren
id|cmd-&gt;dsa
comma
id|Ent_dsa_code_template
op_div
r_sizeof
(paren
r_int
)paren
comma
id|dsa_temp_target
comma
id|c-&gt;target
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : static void abnormal_finished (struct NCR53c7x0_cmd *cmd, int&n; *&t;result)&n; *&n; * Purpose : mark SCSI command as finished, OR&squot;ing the host portion &n; *&t;of the result word into the result field of the corresponding&n; *&t;Scsi_Cmnd structure, and removing it from the internal queues.&n; *&n; * Inputs : cmd - command, result - entire result field&n; *&n; * Preconditions : the &t;NCR chip should be in a halted state when &n; *&t;abnormal_finished is run, since it modifies structures which&n; *&t;the NCR expects to have exclusive access to.&n; */
DECL|function|abnormal_finished
r_static
r_void
id|abnormal_finished
(paren
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
comma
r_int
id|result
)paren
(brace
id|Scsi_Cmnd
op_star
id|c
op_assign
id|cmd-&gt;cmd
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|c-&gt;host
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
id|old_level
suffix:semicolon
r_char
op_star
op_star
id|prev
comma
op_star
id|search
suffix:semicolon
r_int
id|i
suffix:semicolon
id|old_level
op_assign
id|splx
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
op_increment
id|i
)paren
(brace
r_for
c_loop
(paren
id|search
op_assign
(paren
r_char
op_star
)paren
(paren
id|i
ques
c_cond
id|hostdata-&gt;issue_dsa_head
suffix:colon
id|hostdata-&gt;reconnect_dsa_head
)paren
comma
id|prev
op_assign
(paren
r_char
op_star
op_star
)paren
(paren
id|i
ques
c_cond
op_amp
(paren
id|hostdata-&gt;issue_dsa_head
)paren
suffix:colon
op_amp
(paren
id|hostdata-&gt;reconnect_dsa_head
)paren
)paren
suffix:semicolon
id|search
op_logical_and
(paren
id|search
op_plus
id|hostdata-&gt;dsa_start
)paren
op_ne
(paren
r_char
op_star
)paren
id|cmd-&gt;dsa
suffix:semicolon
id|prev
op_assign
(paren
r_char
op_star
op_star
)paren
(paren
id|search
op_plus
id|hostdata-&gt;dsa_next
)paren
comma
id|search
op_assign
op_star
id|prev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|search
)paren
op_star
id|prev
op_assign
op_star
(paren
r_char
op_star
op_star
)paren
(paren
id|search
op_plus
id|hostdata-&gt;dsa_next
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd-&gt;prev
)paren
id|cmd-&gt;prev-&gt;next
op_assign
id|cmd-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;next
)paren
id|cmd-&gt;next-&gt;prev
op_assign
id|cmd-&gt;prev
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;running_list
op_eq
id|cmd
)paren
id|hostdata-&gt;running_list
op_assign
id|cmd-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scan_scsis_buf_busy
)paren
(brace
macro_line|#ifdef SCSI_MALLOC
id|scsi_free
(paren
(paren
r_void
op_star
)paren
id|cmd-&gt;real
comma
id|cmd-&gt;size
)paren
suffix:semicolon
macro_line|#else
id|kfree_s
(paren
id|cmd-&gt;real
comma
id|cmd-&gt;size
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|scan_scsis_buf_busy
op_assign
l_int|0
suffix:semicolon
)brace
id|c-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;result
op_assign
id|result
suffix:semicolon
id|c
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|c
)paren
suffix:semicolon
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : static void intr_break (struct Scsi_Host *host,&n; * &t;struct NCR53c7x0_cmd *cmd)&n; *&n; * Purpose :  Handler for breakpoint interrupts from a SCSI script&n; *&n; * Inputs : host - pointer to this host adapter&squot;s structure,&n; * &t;cmd - pointer to the command (if any) dsa was pointing &n; * &t;to.&n; *&n; */
DECL|function|intr_break
r_static
r_void
id|intr_break
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_break
op_star
id|bp
suffix:semicolon
macro_line|#if 0
id|Scsi_Cmnd
op_star
id|c
op_assign
id|cmd
ques
c_cond
id|cmd-&gt;cmd
suffix:colon
l_int|NULL
suffix:semicolon
macro_line|#endif
r_int
r_int
op_star
id|dsp
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
id|old_level
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/*&n;     * Find the break point corresponding to this address, and &n;     * dump the appropriate debugging information to standard &n;     * output.  &n;     */
id|old_level
op_assign
id|splx
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|dsp
op_assign
(paren
r_int
r_int
op_star
)paren
id|NCR53c7x0_read32
c_func
(paren
id|DSP_REG
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bp
op_assign
id|hostdata-&gt;breakpoints
suffix:semicolon
id|bp
op_logical_and
id|bp-&gt;address
op_ne
id|dsp
suffix:semicolon
id|bp
op_assign
id|bp-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
id|panic
c_func
(paren
l_string|&quot;scsi%d : break point interrupt from %p with no breakpoint!&quot;
comma
id|host-&gt;host_no
comma
id|dsp
)paren
suffix:semicolon
multiline_comment|/*&n;     * Configure the NCR chip for manual start mode, so that we can &n;     * point the DSP register at the instruction that follows the &n;     * INT int_debug_break instruction.&n;     */
id|NCR53c7x0_write8
(paren
id|hostdata-&gt;dmode
comma
id|NCR53c7x0_read8
c_func
(paren
id|hostdata-&gt;dmode
)paren
op_or
id|DMODE_MAN
)paren
suffix:semicolon
multiline_comment|/*&n;     * And update the DSP register, using the size of the old &n;     * instruction in bytes.&n;     */
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : static int asynchronous (struct Scsi_Host *host, int target)&n; *&n; * Purpose : reprogram between the selected SCSI Host adapter and target &n; *      (assumed to be currently connected) for asynchronous transfers.&n; *&n; * Inputs : host - SCSI host structure, target - numeric target ID.&n; *&n; * Preconditions : the NCR chip should be in one of the halted states&n; */
DECL|function|asynchronous
r_static
r_int
id|asynchronous
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_int
id|target
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
(brace
id|hostdata-&gt;sync
(braket
id|target
)braket
dot
id|select_indirect
op_assign
(paren
id|hostdata-&gt;saved_scntl3
op_lshift
l_int|24
)paren
op_or
(paren
id|target
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Fill in script here */
)brace
r_else
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_ne
l_int|700
)paren
op_logical_and
(paren
id|hostdata-&gt;chip
op_ne
l_int|70066
)paren
)paren
(brace
id|hostdata-&gt;sync
(braket
id|target
)braket
dot
id|select_indirect
op_assign
(paren
l_int|1
op_lshift
(paren
id|target
op_amp
l_int|7
)paren
)paren
op_lshift
l_int|16
suffix:semicolon
)brace
multiline_comment|/* &n; * Halted implies connected, when resetting we shouldn&squot;t change the &n; * current parameters but must reset all targets to asynchronous.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;state
op_eq
id|STATE_HALTED
)paren
(brace
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
(brace
id|NCR53c7x0_write8
(paren
id|SCNTL3_REG_800
comma
id|hostdata-&gt;saved_scntl3
)paren
suffix:semicolon
)brace
multiline_comment|/* Offset = 0, transfer period = divide SCLK by 4 */
id|NCR53c7x0_write8
(paren
id|SXFER_REG
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * XXX - do we want to go out of our way (ie, add extra code to selection&n; * &t;in the NCR53c710/NCR53c720 script) to reprogram the synchronous&n; * &t;conversion bits, or can we be content in just setting the &n; * &t;sxfer bits?&n; */
multiline_comment|/* Table for NCR53c8xx synchronous values */
r_static
r_const
r_struct
(brace
DECL|member|div
r_int
id|div
suffix:semicolon
DECL|member|scf
r_int
r_char
id|scf
suffix:semicolon
DECL|member|tp
r_int
r_char
id|tp
suffix:semicolon
DECL|variable|syncs
)brace
id|syncs
(braket
)braket
op_assign
(brace
multiline_comment|/*&t;div&t;scf&t;tp&t;div&t;scf&t;tp&t;div&t;scf&t;tp */
(brace
l_int|40
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
l_int|50
comma
l_int|1
comma
l_int|1
)brace
comma
(brace
l_int|60
comma
l_int|1
comma
l_int|2
)brace
comma
(brace
l_int|70
comma
l_int|1
comma
l_int|3
)brace
comma
(brace
l_int|75
comma
l_int|2
comma
l_int|1
)brace
comma
(brace
l_int|80
comma
l_int|1
comma
l_int|4
)brace
comma
(brace
l_int|90
comma
l_int|1
comma
l_int|5
)brace
comma
(brace
l_int|100
comma
l_int|1
comma
l_int|6
)brace
comma
(brace
l_int|105
comma
l_int|2
comma
l_int|3
)brace
comma
(brace
l_int|110
comma
l_int|1
comma
l_int|7
)brace
comma
(brace
l_int|120
comma
l_int|2
comma
l_int|4
)brace
comma
(brace
l_int|135
comma
l_int|2
comma
l_int|5
)brace
comma
(brace
l_int|140
comma
l_int|3
comma
l_int|3
)brace
comma
(brace
l_int|150
comma
l_int|2
comma
l_int|6
)brace
comma
(brace
l_int|160
comma
l_int|3
comma
l_int|4
)brace
comma
(brace
l_int|165
comma
l_int|2
comma
l_int|7
)brace
comma
(brace
l_int|180
comma
l_int|3
comma
l_int|5
)brace
comma
(brace
l_int|200
comma
l_int|3
comma
l_int|6
)brace
comma
(brace
l_int|210
comma
l_int|4
comma
l_int|3
)brace
comma
(brace
l_int|220
comma
l_int|3
comma
l_int|7
)brace
comma
(brace
l_int|240
comma
l_int|4
comma
l_int|4
)brace
comma
(brace
l_int|270
comma
l_int|4
comma
l_int|5
)brace
comma
(brace
l_int|300
comma
l_int|4
comma
l_int|6
)brace
comma
(brace
l_int|330
comma
l_int|4
comma
l_int|7
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Function : static void synchronous (struct Scsi_Host *host, int target, &n; *&t;char *msg)&n; *&n; * Purpose : reprogram transfers between the selected SCSI initiator and &n; *&t;target for synchronous SCSI transfers such that the synchronous &n; *&t;offset is less than that requested and period at least as long &n; *&t;as that requested.  Also modify *msg such that it contains &n; *&t;an appropriate response. &n; *&n; * Inputs : host - NCR53c7,8xx SCSI host, target - number SCSI target id,&n; *&t;msg - synchronous transfer request.&n; */
DECL|function|synchronous
r_static
r_void
id|synchronous
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_int
id|target
comma
r_char
op_star
id|msg
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
id|desire
comma
id|divisor
comma
id|i
comma
id|limit
suffix:semicolon
r_int
r_int
op_star
id|script
suffix:semicolon
r_int
r_char
id|scntl3
comma
id|sxfer
suffix:semicolon
multiline_comment|/* Scale divisor by 10 to accommodate fractions */
id|desire
op_assign
l_int|1000000000L
op_div
(paren
id|msg
(braket
l_int|3
)braket
op_star
l_int|4
)paren
suffix:semicolon
id|divisor
op_assign
id|desire
op_div
(paren
id|hostdata-&gt;scsi_clock
op_div
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
(braket
l_int|4
)braket
OG
l_int|8
)paren
id|msg
(braket
l_int|4
)braket
op_assign
l_int|8
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : optimal synchronous divisor of %d.%01d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|divisor
op_div
l_int|10
comma
id|divisor
op_mod
l_int|10
)paren
suffix:semicolon
id|limit
op_assign
(paren
r_sizeof
(paren
id|syncs
)paren
op_div
r_sizeof
(paren
id|syncs
(braket
l_int|0
)braket
)paren
)paren
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|limit
)paren
op_logical_and
(paren
id|divisor
OL
id|syncs
(braket
id|i
op_plus
l_int|1
)braket
dot
id|div
)paren
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : selected synchronous divisor of %d.%01d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|syncs
(braket
id|i
)braket
dot
id|div
op_div
l_int|10
comma
id|syncs
(braket
id|i
)braket
dot
id|div
op_mod
l_int|10
)paren
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
(paren
l_int|1000000000
op_div
id|divisor
op_div
l_int|10
op_div
l_int|4
)paren
suffix:semicolon
id|scntl3
op_assign
(paren
id|hostdata-&gt;chip
op_div
l_int|100
op_eq
l_int|8
)paren
ques
c_cond
(paren
(paren
id|hostdata-&gt;saved_scntl3
op_amp
op_complement
id|SCNTL3_800_SCF_MASK
)paren
op_or
(paren
id|syncs
(braket
id|i
)braket
dot
id|scf
op_lshift
id|SCNTL3_800_SCF_SHIFT
)paren
)paren
suffix:colon
l_int|0
suffix:semicolon
id|sxfer
op_assign
(paren
id|msg
(braket
l_int|4
)braket
op_lshift
id|SXFER_MO_SHIFT
)paren
op_or
(paren
(paren
id|syncs
(braket
id|i
)braket
dot
id|tp
)paren
op_lshift
id|SXFER_TP_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_ne
l_int|700
)paren
op_logical_and
(paren
id|hostdata-&gt;chip
op_ne
l_int|70066
)paren
)paren
(brace
id|hostdata-&gt;sync
(braket
id|target
)braket
dot
id|select_indirect
op_assign
(paren
id|scntl3
op_lshift
l_int|24
)paren
op_or
(paren
id|target
op_lshift
l_int|16
)paren
op_or
(paren
id|sxfer
op_lshift
l_int|8
)paren
suffix:semicolon
id|script
op_assign
id|hostdata-&gt;sync
(braket
id|target
)braket
dot
id|script
suffix:semicolon
multiline_comment|/* XXX - add NCR53c7x0 code to reprogram SCF bits if we want to */
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
(brace
id|script
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|DCMD_TYPE_RWRI
op_or
id|DCMD_RWRI_OPC_MODIFY
op_or
id|DCMD_RWRI_OP_MOVE
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|SCNTL3_REG_800
op_lshift
l_int|16
)paren
op_or
(paren
id|scntl3
op_lshift
l_int|8
)paren
suffix:semicolon
id|script
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|script
op_add_assign
l_int|2
suffix:semicolon
)brace
id|script
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|DCMD_TYPE_RWRI
op_or
id|DCMD_RWRI_OPC_MODIFY
op_or
id|DCMD_RWRI_OP_MOVE
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|SXFER_REG
op_lshift
l_int|16
)paren
op_or
(paren
id|sxfer
op_lshift
l_int|8
)paren
suffix:semicolon
id|script
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|script
op_add_assign
l_int|2
suffix:semicolon
id|script
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_RETURN
)paren
op_lshift
l_int|24
)paren
op_or
id|DBC_TCI_TRUE
suffix:semicolon
id|script
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|script
op_add_assign
l_int|2
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Function : static int NCR53c8x0_dstat_sir_intr (struct Scsi_Host *host,&n; * &t;struct NCR53c7x0_cmd *cmd)&n; *&n; * Purpose :  Handler for INT generated instructions for the &n; * &t;NCR53c810/820 SCSI SCRIPT&n; *&n; * Inputs : host - pointer to this host adapter&squot;s structure,&n; * &t;cmd - pointer to the command (if any) dsa was pointing &n; * &t;to.&n; *&n; */
DECL|function|NCR53c8x0_dstat_sir_intr
r_static
r_int
id|NCR53c8x0_dstat_sir_intr
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
id|Scsi_Cmnd
op_star
id|c
op_assign
id|cmd
ques
c_cond
id|cmd-&gt;cmd
suffix:colon
l_int|NULL
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|dsps
comma
op_star
id|dsp
suffix:semicolon
multiline_comment|/* Argument of the INT instruction */
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
id|dsps
op_assign
id|NCR53c7x0_read32
c_func
(paren
id|DSPS_REG
)paren
suffix:semicolon
id|dsp
op_assign
(paren
r_int
r_int
op_star
)paren
id|NCR53c7x0_read32
c_func
(paren
id|DSP_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : DSPS = 0x%lx&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|dsps
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|dsps
)paren
(brace
r_case
id|A_int_msg_1
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : message&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
)paren
id|printk
(paren
l_string|&quot; from target %d lun %d&quot;
comma
id|c-&gt;target
comma
id|c-&gt;lun
)paren
suffix:semicolon
id|print_msg
(paren
id|hostdata-&gt;msg_buf
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hostdata-&gt;msg_buf
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* &n;&t; * Unless we&squot;ve initiated synchronous negotiation, I don&squot;t&n;&t; * think that this should happen.&n;&t; */
r_case
id|MESSAGE_REJECT
suffix:colon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_accept_message
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INITIATE_RECOVERY
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : extended contingent allegiance not supported yet, rejecting&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_reject_message
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_NOTHING
suffix:semicolon
r_case
id|A_int_msg_sdtr
suffix:colon
r_if
c_cond
(paren
id|cmd
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : target %d %s synchronous transfer period %dns, offset%d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|c-&gt;target
comma
(paren
id|cmd-&gt;flags
op_amp
id|CMD_FLAG_SDTR
)paren
ques
c_cond
l_string|&quot;accepting&quot;
suffix:colon
l_string|&quot;requesting&quot;
comma
id|hostdata-&gt;msg_buf
(braket
l_int|3
)braket
op_star
l_int|4
comma
id|hostdata-&gt;msg_buf
(braket
l_int|4
)braket
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Initiator initiated, won&squot;t happen unless synchronous &n;&t; * &t;transfers are enabled.  If we get a SDTR message in&n;&t; * &t;response to our SDTR, we should program our parameters&n;&t; * &t;such that &n;&t; *&t;&t;offset &lt;= requested offset&n;&t; *&t;&t;period &gt;= requested period&t;&t; &t;&n;   &t; */
r_if
c_cond
(paren
id|cmd-&gt;flags
op_amp
id|CMD_FLAG_SDTR
)paren
(brace
id|cmd-&gt;flags
op_and_assign
op_complement
id|CMD_FLAG_SDTR
suffix:semicolon
id|synchronous
(paren
id|host
comma
id|c-&gt;target
comma
id|hostdata-&gt;msg_buf
)paren
suffix:semicolon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_accept_message
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
r_return
id|SPECIFIC_INT_NOTHING
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_SYNCHRONOUS
)paren
(brace
id|cmd-&gt;flags
op_or_assign
id|CMD_FLAG_DID_SDTR
suffix:semicolon
id|synchronous
(paren
id|host
comma
id|c-&gt;target
comma
id|hostdata-&gt;msg_buf
)paren
suffix:semicolon
)brace
r_else
(brace
id|hostdata-&gt;msg_buf
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0 offset = async */
)brace
id|patch_dsa_32
(paren
id|cmd-&gt;dsa
comma
id|dsa_msgout_other
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
id|patch_dsa_32
(paren
id|cmd-&gt;dsa
comma
id|dsa_msgout_other
comma
l_int|1
comma
id|hostdata-&gt;msg_buf
)paren
suffix:semicolon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_respond_message
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hostdata-&gt;msg_buf
(braket
l_int|4
)braket
)paren
(brace
r_int
id|Hz
op_assign
l_int|1000000000
op_div
(paren
id|hostdata-&gt;msg_buf
(braket
l_int|3
)braket
op_star
l_int|4
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : setting target %d to %d.%02dMhz %s SCSI%s&bslash;n&quot;
l_string|&quot;         period = %dns, max offset = %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|c-&gt;target
comma
id|Hz
op_div
l_int|1000000
comma
id|Hz
op_mod
l_int|1000000
comma
(paren
(paren
id|hostdata-&gt;msg_buf
(braket
l_int|3
)braket
OL
l_int|200
)paren
ques
c_cond
l_string|&quot;FAST &quot;
suffix:colon
l_string|&quot;synchronous&quot;
)paren
comma
(paren
(paren
id|hostdata-&gt;msg_buf
(braket
l_int|3
)braket
OL
l_int|200
)paren
ques
c_cond
l_string|&quot;-II&quot;
suffix:colon
l_string|&quot;&quot;
)paren
comma
(paren
r_int
)paren
id|hostdata-&gt;msg_buf
(braket
l_int|3
)braket
op_star
l_int|4
comma
(paren
r_int
)paren
id|hostdata-&gt;msg_buf
(braket
l_int|4
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;scsi%d : setting target %d to asynchronous SCSI&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|c-&gt;target
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_NOTHING
suffix:semicolon
)brace
multiline_comment|/* Fall through to abort */
r_case
id|A_int_msg_wdtr
suffix:colon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_reject_message
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
r_return
id|SPECIFIC_INT_NOTHING
suffix:semicolon
r_case
id|A_int_err_unexpected_phase
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : unexpected phase&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_return
id|SPECIFIC_INT_ABORT
suffix:semicolon
r_case
id|A_int_err_selected
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : selected by target %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
)paren
id|NCR53c7x0_read8
c_func
(paren
id|SSID_REG_800
)paren
op_amp
l_int|7
)paren
suffix:semicolon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_target_abort
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
r_return
id|SPECIFIC_INT_NOTHING
suffix:semicolon
r_case
id|A_int_err_unexpected_reselect
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : unexpected reselect by target %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
)paren
id|NCR53c7x0_read8
c_func
(paren
id|SSID_REG_800
)paren
)paren
suffix:semicolon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_initiator_abort
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
r_return
id|SPECIFIC_INT_NOTHING
suffix:semicolon
multiline_comment|/*&n; * Since contingent allegiance conditions are cleared by the next &n; * command issued to a target, we must issue a REQUEST SENSE &n; * command after receiving a CHECK CONDITION status, before&n; * another command is issued.&n; * &n; * Since this NCR53c7x0_cmd will be freed after use, we don&squot;t &n; * care if we step on the various fields, so modify a few things.&n; */
r_case
id|A_int_err_check_condition
suffix:colon
macro_line|#if 0
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
macro_line|#endif
id|printk
(paren
l_string|&quot;scsi%d : CHECK CONDITION&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : CHECK CONDITION with no SCSI command&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_return
id|SPECIFIC_INT_PANIC
suffix:semicolon
)brace
multiline_comment|/*&n; * When a contingent allegiance condition is created, the target &n; * reverts to asynchronous transfers.&n; */
id|asynchronous
(paren
id|host
comma
id|c-&gt;target
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Use normal one-byte selection message, with no attempts to &n;    &t; * reestablish synchronous or wide messages since this may&n;    &t; * be the crux of our problem.&n;&t; *&n;&t; * XXX - once SCSI-II tagged queuing is implemented, we&squot;ll&n;&t; * &t;have to set this up so that the rest of the DSA&n;&t; *&t;agrees with this being an untagged queue&squot;d command.&n;&t; */
id|patch_dsa_32
(paren
id|cmd-&gt;dsa
comma
id|dsa_msgout
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* &n;    &t; * Modify the table indirect for COMMAND OUT phase, since &n;    &t; * Request Sense is a six byte command.&n;    &t; */
id|patch_dsa_32
(paren
id|cmd-&gt;dsa
comma
id|dsa_cmdout
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
id|c-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|REQUEST_SENSE
suffix:semicolon
id|c-&gt;cmnd
(braket
l_int|1
)braket
op_and_assign
l_int|0xe0
suffix:semicolon
multiline_comment|/* Zero all but LUN */
id|c-&gt;cmnd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|c-&gt;cmnd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|c-&gt;cmnd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|c-&gt;sense_buffer
)paren
suffix:semicolon
id|c-&gt;cmnd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Disable dataout phase, and program datain to transfer to the &n;&t; * sense buffer, and add a jump to other_transfer after the &n;    &t; * command so overflow/underrun conditions are detected.&n;&t; */
id|patch_dsa_32
(paren
id|cmd-&gt;dsa
comma
id|dsa_dataout
comma
l_int|0
comma
id|hostdata-&gt;E_other_transfer
)paren
suffix:semicolon
id|patch_dsa_32
(paren
id|cmd-&gt;dsa
comma
id|dsa_datain
comma
l_int|0
comma
id|cmd-&gt;data_transfer_start
)paren
suffix:semicolon
id|cmd-&gt;data_transfer_start
(braket
l_int|0
)braket
op_assign
(paren
(paren
(paren
id|DCMD_TYPE_BMI
op_or
id|DCMD_BMI_OP_MOVE_I
op_or
id|DCMD_BMI_IO
)paren
)paren
op_lshift
l_int|24
)paren
op_or
r_sizeof
(paren
id|c-&gt;sense_buffer
)paren
suffix:semicolon
id|cmd-&gt;data_transfer_start
(braket
l_int|1
)braket
op_assign
(paren
r_int
r_int
)paren
id|c-&gt;sense_buffer
suffix:semicolon
id|cmd-&gt;data_transfer_start
(braket
l_int|2
)braket
op_assign
(paren
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_JUMP
)paren
op_lshift
l_int|24
)paren
op_or
id|DBC_TCI_TRUE
suffix:semicolon
id|cmd-&gt;data_transfer_start
(braket
l_int|3
)braket
op_assign
id|hostdata-&gt;E_other_transfer
suffix:semicolon
multiline_comment|/*&n;    &t; * Currently, this command is flagged as completed, ie &n;    &t; * it has valid status and message data.  Reflag it as&n;    &t; * incomplete.  Q - need to do something so that original&n;&t; * status, etc are used.&n;    &t; */
id|cmd-&gt;cmd-&gt;result
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* &n;&t; * Restart command as a REQUEST SENSE.&n;&t; */
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_select
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
r_return
id|SPECIFIC_INT_NOTHING
suffix:semicolon
r_case
id|A_int_debug_break
suffix:colon
r_return
id|SPECIFIC_INT_BREAK
suffix:semicolon
r_case
id|A_int_norm_aborted
suffix:colon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_schedule
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cmd
)paren
id|abnormal_finished
(paren
id|cmd
comma
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
id|SPECIFIC_INT_NOTHING
suffix:semicolon
r_case
id|A_int_test_1
suffix:colon
r_case
id|A_int_test_2
suffix:colon
id|hostdata-&gt;idle
op_assign
l_int|1
suffix:semicolon
id|hostdata-&gt;test_completed
op_assign
(paren
id|dsps
op_minus
id|A_int_test_1
)paren
op_div
l_int|0x00010000
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : test%ld complete&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|hostdata-&gt;test_completed
)paren
suffix:semicolon
r_return
id|SPECIFIC_INT_NOTHING
suffix:semicolon
macro_line|#ifdef A_int_debug_scheduled
r_case
id|A_int_debug_scheduled
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : new I/O 0x%lx scheduled&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|NCR53c7x0_read32
c_func
(paren
id|DSA_REG
)paren
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_idle
r_case
id|A_int_debug_idle
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : idle&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_cmd
r_case
id|A_int_debug_cmd
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : command sent&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_dsa_loaded
r_case
id|A_int_debug_dsa_loaded
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : DSA loaded with 0x%lx&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|NCR53c7x0_read32
c_func
(paren
id|DSA_REG
)paren
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_reselected
r_case
id|A_int_debug_reselected
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : reselected by target %d lun %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
)paren
id|NCR53c7x0_read8
c_func
(paren
id|SSID_REG_800
)paren
comma
(paren
r_int
)paren
id|hostdata-&gt;reselected_identify
op_amp
l_int|7
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_head
r_case
id|A_int_debug_head
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : issue_dsa_head now 0x%lx&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
r_int
)paren
id|hostdata-&gt;issue_dsa_head
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
(paren
id|dsps
op_amp
l_int|0xff000000
)paren
op_eq
l_int|0x03000000
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : misc debug interrupt 0x%lx&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|dsps
)paren
suffix:semicolon
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;scsi%d : unknown user interrupt 0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
)paren
id|dsps
)paren
suffix:semicolon
r_return
id|SPECIFIC_INT_PANIC
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * XXX - the stock NCR assembler won&squot;t output the scriptu.h file,&n; * which undefine&squot;s all #define&squot;d CPP symbols from the script.h&n; * file, which will create problems if you use multiple scripts&n; * with the same  symbol names.&n; *&n; * If you insist on using NCR&squot;s assembler, you could generate&n; * scriptu.h from script.h using something like &n; *&n; * grep #define script.h | &bslash;&n; * sed &squot;s/#define[ &t;][ &t;]*&bslash;([_a-zA-Z][_a-zA-Z0-9]*&bslash;).*$/#undefine &bslash;1/&squot; &bslash;&n; * &gt; scriptu.h&n; */
macro_line|#include &quot;53c8xx_u.h&quot;
multiline_comment|/* XXX - add alternate script handling code here */
macro_line|#ifdef NCR_DEBUG
multiline_comment|/*&n; * Debugging without a debugger is no fun. So, I&squot;ve provided &n; * a debugging interface in the NCR53c7x0 driver.  To avoid&n; * kernel cruft, there&squot;s just enough here to act as an interface&n; * to a user level debugger (aka, GDB).&n; *&n; *&n; * The following restrictions apply to debugger commands : &n; * 1.  The command must be terminated by a newline.&n; * 2.  Command length must be less than 80 bytes including the &n; * &t;newline.&n; * 3.  The entire command must be written with one system call.&n; */
DECL|variable|debugger_help
r_static
r_const
r_char
id|debugger_help
op_assign
l_string|&quot;bc &lt;addr&gt; &t;&t;&t;- clear breakpoint&bslash;n&quot;
l_string|&quot;bl&t;&t;&t;&t;- list breakpoints&bslash;n&quot;
l_string|&quot;bs &lt;addr&gt;&t;&t;&t;- set breakpoint&bslash;n&quot;
l_string|&quot;g&t;&t;&t;&t;- start&bslash;n&quot;
l_string|&quot;h&t;&t;&t;&t;- halt&bslash;n&quot;
l_string|&quot;?&t;&t;&t;&t;- this message&bslash;n&quot;
l_string|&quot;i&t;&t;&t;&t;- info&bslash;n&quot;
l_string|&quot;mp &lt;addr&gt; &lt;size&gt; &t;&t;- print memory&bslash;n&quot;
l_string|&quot;ms &lt;addr&gt; &lt;size&gt; &lt;value&gt;&t;- store memory&bslash;n&quot;
l_string|&quot;rp &lt;num&gt; &lt;size&gt;&t;&t;- print register&bslash;n&quot;
l_string|&quot;rs &lt;num&gt; &lt;size&gt; &lt;value&gt; &t;- store register&bslash;n&quot;
l_string|&quot;s&t;&t;&t;&t;- single step&bslash;n&quot;
l_string|&quot;tb&t;&t;&t;&t;- begin trace &bslash;n&quot;
l_string|&quot;te&t;&t;&t;&t;- end trace&bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n; * Whenever we change a break point, we should probably &n; * set the NCR up so that it is in a single step mode.&n; */
DECL|function|debugger_fn_bc
r_static
r_int
id|debugger_fn_bc
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|debugger_token
op_star
id|token
comma
r_int
r_int
id|args
(braket
)braket
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
r_struct
id|NCR53c7x0_break
op_star
id|bp
comma
op_star
op_star
id|prev
suffix:semicolon
r_int
id|old_level
suffix:semicolon
id|old_level
op_assign
id|splx
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bp
op_assign
(paren
r_struct
id|NCR53c7x0_break
op_star
)paren
id|instance-&gt;breakpoints
comma
id|prev
op_assign
(paren
r_struct
id|NCR53c7x0_break
op_star
op_star
)paren
op_amp
id|instance-&gt;breakpoints
suffix:semicolon
id|bp
suffix:semicolon
id|prev
op_assign
(paren
r_struct
id|NCR53c7x0_break
op_star
op_star
)paren
op_amp
(paren
id|bp-&gt;next
)paren
comma
id|bp
op_assign
(paren
r_struct
id|NCR53c7x0_break
op_star
)paren
id|bp-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
(brace
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* &n;     * XXX - we need to insure that the processor is halted &n;     * here in order to prevent a race condition.&n;     */
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|bp-&gt;addr
comma
(paren
r_void
op_star
)paren
id|bp-&gt;old
comma
r_sizeof
(paren
id|bp-&gt;old
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
op_star
id|prev
op_assign
id|bp-&gt;next
suffix:semicolon
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|debugger_fn_bl
r_static
r_int
id|debugger_fn_bl
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|debugger_token
op_star
id|token
comma
r_int
r_int
id|args
(braket
)braket
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_struct
id|NCR53c7x0_break
op_star
id|bp
suffix:semicolon
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|old_level
suffix:semicolon
multiline_comment|/* &n;     * XXX - we need to insure that the processor is halted &n;     * here in order to prevent a race condition.  So, if the &n;     * processor isn&squot;t halted, print an error message and continue.&n;     */
id|sprintf
(paren
id|buf
comma
l_string|&quot;scsi%d : bp : warning : processor not halted&bslash;b&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|debugger_kernel_write
(paren
id|host
comma
id|buf
comma
id|strlen
c_func
(paren
id|buf
)paren
)paren
suffix:semicolon
id|old_level
op_assign
id|splx
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bp
op_assign
(paren
r_struct
id|NCR53c7x0_break
op_star
)paren
id|host-&gt;breakpoints
suffix:semicolon
id|bp
suffix:semicolon
id|bp
op_assign
(paren
r_struct
id|NCR53c7x0_break
op_star
)paren
id|bp-&gt;next
)paren
suffix:semicolon
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;scsi%d : bp : success : at %08x, replaces %08x %08x&quot;
comma
id|bp-&gt;addr
comma
id|bp-&gt;old
(braket
l_int|0
)braket
comma
id|bp-&gt;old
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bp-&gt;old
(braket
l_int|0
)braket
op_amp
(paren
id|DCMD_TYPE_MASK
op_lshift
l_int|24
)paren
)paren
op_eq
(paren
id|DCMD_TYPE_MMI
op_lshift
l_int|24
)paren
)paren
(brace
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%08x&bslash;n&quot;
comma
op_star
(paren
r_int
op_star
)paren
id|bp-&gt;addr
)paren
suffix:semicolon
)brace
r_else
(brace
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|len
op_assign
id|strlen
c_func
(paren
id|buf
)paren
suffix:semicolon
id|debugger_kernel_write
(paren
id|host
comma
id|buf
comma
id|len
)paren
suffix:semicolon
)brace
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|debugger_fn_bs
r_static
r_int
id|debugger_fn_bs
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|debugger_token
op_star
id|token
comma
r_int
r_int
id|args
(braket
)braket
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_struct
id|NCR53c7x0_break
op_star
id|bp
suffix:semicolon
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|old_level
suffix:semicolon
id|old_level
op_assign
id|splx
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;state
op_ne
id|STATE_HALTED
)paren
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;scsi%d : bs : failure : NCR not halted&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|debugger_kernel_write
(paren
id|host
comma
id|buf
comma
id|strlen
c_func
(paren
id|buf
)paren
)paren
suffix:semicolon
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|bp
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|NCR53c7x0_break
)paren
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : kmalloc(%d) of breakpoint structure failed, try again&bslash;n&quot;
comma
id|host-&gt;host_no
comma
r_sizeof
(paren
r_struct
id|NCR53c7x0_break
)paren
)paren
suffix:semicolon
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|bp-&gt;address
op_assign
(paren
r_int
r_int
op_star
)paren
id|args
(braket
l_int|0
)braket
suffix:semicolon
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|bp-&gt;old_instruction
comma
(paren
r_void
op_star
)paren
id|bp-&gt;address
comma
l_int|8
)paren
suffix:semicolon
id|bp-&gt;old_size
op_assign
(paren
(paren
(paren
id|bp-&gt;old_instruction
(braket
l_int|0
)braket
op_rshift
l_int|24
)paren
op_amp
id|DCMD_TYPE_MASK
)paren
op_eq
id|DCMD_TYPE_MMI
ques
c_cond
l_int|3
suffix:colon
l_int|2
suffix:semicolon
id|bp-&gt;next
op_assign
id|hostdata-&gt;breakpoints
suffix:semicolon
id|hostdata-&gt;breakpoints
op_assign
id|bp-&gt;next
suffix:semicolon
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|bp-&gt;address
comma
(paren
r_void
op_star
)paren
id|hostdata-&gt;E_debug_break
comma
l_int|8
)paren
suffix:semicolon
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|TOKEN
mdefine_line|#define TOKEN(name,nargs) {#name, nargs, debugger_fn_##name}
DECL|struct|debugger_token
r_static
r_const
r_struct
id|debugger_token
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|numargs
r_int
id|numargs
suffix:semicolon
DECL|member|fn
r_int
(paren
op_star
id|fn
)paren
(paren
r_struct
id|debugger_token
op_star
id|token
comma
r_int
r_int
id|args
(braket
)braket
)paren
suffix:semicolon
DECL|variable|debugger_tokens
)brace
id|debugger_tokens
(braket
)braket
op_assign
(brace
id|TOKEN
c_func
(paren
id|bc
comma
l_int|1
)paren
comma
id|TOKEN
c_func
(paren
id|bl
comma
l_int|0
)paren
comma
id|TOKEN
c_func
(paren
id|bs
comma
l_int|1
)paren
comma
id|TOKEN
c_func
(paren
id|g
comma
l_int|0
)paren
comma
id|TOKEN
c_func
(paren
id|halt
comma
l_int|0
)paren
comma
(brace
id|DT_help
comma
l_string|&quot;?&quot;
comma
l_int|0
)brace
comma
id|TOKEN
c_func
(paren
id|h
comma
l_int|0
)paren
comma
id|TOKEN
c_func
(paren
id|i
comma
l_int|0
)paren
comma
id|TOKEN
c_func
(paren
id|mp
comma
l_int|2
)paren
comma
id|TOKEN
c_func
(paren
id|ms
comma
l_int|3
)paren
comma
id|TOKEN
c_func
(paren
id|rp
comma
l_int|2
)paren
comma
id|TOKEN
c_func
(paren
id|rs
comma
l_int|2
)paren
comma
id|TOKEN
c_func
(paren
id|s
comma
l_int|0
)paren
comma
id|TOKEN
c_func
(paren
id|tb
comma
l_int|0
)paren
comma
id|TOKEN
c_func
(paren
id|te
comma
l_int|0
)paren
)brace
suffix:semicolon
DECL|macro|NDT
mdefine_line|#define NDT sizeof(debugger_tokens / sizeof(struct debugger_token))
DECL|function|inode_to_host
r_static
r_struct
id|Scsi_Host
op_star
id|inode_to_host
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
"$"
r_int
id|dev
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|tmp
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;rdev
)paren
comma
id|host
op_assign
id|first_host
suffix:semicolon
(paren
id|host-&gt;hostt
op_eq
id|the_template
)paren
suffix:semicolon
op_decrement
id|dev
comma
id|host
op_assign
id|host-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
id|host
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|debugger_user_write
r_static
id|debugger_user_write
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
multiline_comment|/* This SCSI host */
r_struct
id|NCR53c7x0_hostadata
op_star
id|hostdata
suffix:semicolon
r_char
id|input_buf
(braket
l_int|80
)braket
comma
multiline_comment|/* Kernel space copy of buf */
op_star
id|ptr
suffix:semicolon
multiline_comment|/* Pointer to argument list */
r_int
r_int
id|args
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Arguments */
r_int
id|i
comma
id|j
comma
id|error
comma
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|host
op_assign
id|inode_to_host
c_func
(paren
id|inode
)paren
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_if
c_cond
(paren
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|buf
comma
id|count
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|80
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|memcpy_from_fs
c_func
(paren
id|input_buf
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|input_buf
(braket
id|count
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|input_buf
(braket
id|count
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NDT
suffix:semicolon
op_increment
id|i
)paren
(brace
id|len
op_assign
id|strlen
(paren
id|debugger_tokens
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|input_buf
comma
id|debugger_tokens
(braket
id|i
)braket
dot
id|name
comma
id|len
)paren
)paren
r_break
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|NDT
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
id|input_buf
op_plus
id|len
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|debugger_tokens
(braket
id|i
)braket
dot
id|nargs
op_logical_and
op_star
id|ptr
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_star
id|ptr
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|ptr
op_eq
l_char|&squot;&bslash;t&squot;
)paren
(brace
op_increment
id|ptr
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|isdigit
c_func
(paren
op_star
id|ptr
)paren
)paren
(brace
id|args
(braket
id|j
op_increment
)braket
op_assign
id|simple_strtoul
(paren
id|ptr
comma
op_amp
id|ptr
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|j
op_ne
id|debugger_tokens
(braket
id|i
)braket
dot
id|nargs
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|debugger_user_read
r_static
id|debugger_user_read
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
)brace
DECL|function|debugger_kernel_write
r_static
id|debugger_kernel_write
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
id|copy
comma
id|left
comma
id|old_level
suffix:semicolon
id|old_level
op_assign
id|splx
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|buflen
)paren
(brace
id|left
op_assign
(paren
id|hostdata-&gt;debug_buf
op_plus
id|hostdata-&gt;debug_size
op_minus
l_int|1
)paren
op_minus
id|hostdata-&gt;debug_write
suffix:semicolon
id|copy
op_assign
(paren
id|buflen
op_le
id|left
)paren
ques
c_cond
id|buflen
suffix:colon
id|left
suffix:semicolon
id|memcpy
(paren
id|hostdata-&gt;debug_write
comma
id|buf
comma
id|copy
)paren
suffix:semicolon
id|buf
op_add_assign
id|copy
suffix:semicolon
id|buflen
op_sub_assign
id|copy
suffix:semicolon
id|hostdata-&gt;debug_count
op_add_assign
id|copy
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hostdata-&gt;debug_write
op_add_assign
id|copy
)paren
op_eq
(paren
id|hostdata-&gt;debug_buf
op_plus
id|hostdata-&gt;debug_size
)paren
)paren
id|hosdata-&gt;debug_write
op_assign
id|hostdata-&gt;debug_buf
suffix:semicolon
)brace
(paren
r_void
)paren
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
)brace
macro_line|#endif /* def NCRDEBUG */
multiline_comment|/* &n; * Function : static void NCR538xx_soft_reset (struct Scsi_Host *host)&n; *&n; * Purpose :  perform a soft reset of the NCR53c8xx chip&n; *&n; * Inputs : host - pointer to this host adapter&squot;s structure&n; *&n; * Preconditions : NCR53c7x0_init must have been called for this &n; *      host.&n; * &n; */
DECL|function|NCR53c8x0_soft_reset
r_static
r_void
id|NCR53c8x0_soft_reset
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/*&n;     * Do a soft reset of the chip so that everything is &n;     * reinitialized to the power-on state.&n;     *&n;     * Basically follow the procedure outlined in the NCR53c700&n;     * data manual under Chapter Six, How to Use, Steps Necessary to&n;     * Start SCRIPTS, with the exception of actually starting the &n;     * script and setting up the synchronous transfer gunk.&n;     */
id|NCR53c7x0_write8
c_func
(paren
id|ISTAT_REG_800
comma
id|ISTAT_10_SRST
)paren
suffix:semicolon
id|NCR53c7x0_write8
c_func
(paren
id|ISTAT_REG_800
comma
l_int|0
)paren
suffix:semicolon
id|NCR53c7x0_write8
c_func
(paren
id|hostdata-&gt;dmode
comma
id|hostdata-&gt;saved_dmode
op_amp
op_complement
id|DMODE_MAN
)paren
suffix:semicolon
multiline_comment|/* &n;     * Respond to selection and reselection by targets and &n;     * use our _initiator_ SCSI ID for arbitration. &n;     *&n;     * XXX - Note : we must reprogram this when reselecting as &n;     *&t;a target.&n;     */
id|NCR53c7x0_write8
c_func
(paren
id|SCID_REG
comma
(paren
id|host-&gt;this_id
op_amp
l_int|7
)paren
op_or
id|SCID_800_RRE
op_or
id|SCID_800_SRE
)paren
suffix:semicolon
id|NCR53c7x0_write8
c_func
(paren
id|RESPID_REG_800
comma
id|hostdata-&gt;this_id_mask
)paren
suffix:semicolon
multiline_comment|/*&n;     * Use a maximum (1.6) second handshake to handshake timeout,&n;     * and SCSI recommended .5s selection timeout.&n;     */
id|NCR53c7x0_write8
c_func
(paren
id|STIME0_REG_800
comma
(paren
(paren
l_int|14
op_lshift
id|STIME0_800_SEL_SHIFT
)paren
op_amp
id|STIME0_800_SEL_MASK
)paren
multiline_comment|/* Disable HTH interrupt */
macro_line|#if 0
op_or
(paren
(paren
l_int|15
op_lshift
id|STIME0_800_HTH_SHIFT
)paren
op_amp
id|STIME0_800_HTH_MASK
)paren
macro_line|#endif
)paren
suffix:semicolon
multiline_comment|/*&n;     * Enable all interrupts, except parity which we only want when&n;     * the user requests it.&n;     */
id|NCR53c7x0_write8
c_func
(paren
id|DIEN_REG
comma
id|DIEN_800_MDPE
op_or
id|DIEN_800_BF
op_or
id|DIEN_ABRT
op_or
id|DIEN_SSI
op_or
id|DIEN_SIR
op_or
id|DIEN_800_IID
)paren
suffix:semicolon
id|NCR53c7x0_write8
c_func
(paren
id|SIEN0_REG_800
comma
(paren
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_PARITY
)paren
ques
c_cond
id|SIEN_PAR
suffix:colon
l_int|0
)paren
op_or
id|SIEN_RST
op_or
id|SIEN_UDC
op_or
id|SIEN_SGE
op_or
id|SIEN_800_SEL
op_or
id|SIEN_800_RESEL
op_or
id|SIEN_MA
)paren
suffix:semicolon
id|NCR53c7x0_write8
c_func
(paren
id|SIEN1_REG_800
comma
id|SIEN1_800_STO
op_or
id|SIEN1_800_HTH
)paren
suffix:semicolon
multiline_comment|/* &n;     * Use saved clock frequency divisor and scripts loaded in 16 bit&n;     * mode flags from the saved dcntl.&n;     */
id|NCR53c7x0_write8
c_func
(paren
id|DCNTL_REG
comma
id|hostdata-&gt;saved_dcntl
)paren
suffix:semicolon
id|NCR53c7x0_write8
c_func
(paren
id|CTEST4_REG_800
comma
id|hostdata-&gt;saved_ctest4
)paren
suffix:semicolon
multiline_comment|/* Enable active negation */
id|NCR53c7x0_write8
c_func
(paren
id|STEST3_REG_800
comma
id|STEST3_800_TE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function static struct NCR53c7x0_cmd *create_cmd (Scsi_Cmnd *cmd) &n; *&n; * Purpose : Using scsi_malloc() if the system is initialized,&n; *&t;scan_scsis_buf if not, allocate space to store the variable&n; *&t;length NCR53c7x0_cmd structure.  Initialize it based on &n; *&t;the Scsi_Cmnd structure passed in, including dsa and &n; *&t;Linux field initialization, and dsa code relocation.&n; *&n; * Inputs : cmd - SCSI command&n; *&n; * Returns : NCR53c7x0_cmd structure corresponding to cmd,&n; *&t;NULL on failure.&n; */
DECL|function|create_cmd
r_static
r_struct
id|NCR53c7x0_cmd
op_star
id|create_cmd
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;host
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/* Size of *tmp */
r_struct
id|NCR53c7x0_cmd
op_star
id|tmp
suffix:semicolon
multiline_comment|/* NCR53c7x0_cmd structure for this command */
r_int
id|datain
comma
multiline_comment|/* Number of instructions per phase */
id|dataout
suffix:semicolon
r_int
id|data_transfer_instructions
comma
multiline_comment|/* Count of dynamic instructions */
id|i
comma
multiline_comment|/* Counter */
id|alignment
suffix:semicolon
multiline_comment|/* Alignment adjustment (0 - 4) */
r_int
r_int
op_star
id|cmd_datain
comma
multiline_comment|/* Address of datain/dataout code */
op_star
id|cmd_dataout
suffix:semicolon
multiline_comment|/* Incremented as we assemble */
r_void
op_star
id|real
suffix:semicolon
multiline_comment|/* Real address */
id|NCR53c7x0_local_setup
c_func
(paren
id|cmd-&gt;host
)paren
suffix:semicolon
multiline_comment|/*&n;     * Decide weather we need to generate commands for DATA IN,&n;     * DATA OUT, neither, or both based on the SCSI command &n;     */
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* These commands do DATA IN */
r_case
id|INQUIRY
suffix:colon
r_case
id|MODE_SENSE
suffix:colon
r_case
id|READ_6
suffix:colon
r_case
id|READ_10
suffix:colon
r_case
id|READ_CAPACITY
suffix:colon
r_case
id|REQUEST_SENSE
suffix:colon
id|datain
op_assign
l_int|2
op_star
(paren
id|cmd-&gt;use_sg
ques
c_cond
id|cmd-&gt;use_sg
suffix:colon
l_int|1
)paren
op_plus
l_int|3
suffix:semicolon
id|dataout
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* These commands do DATA OUT */
r_case
id|MODE_SELECT
suffix:colon
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;scsi%d : command is &quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_command
c_func
(paren
id|cmd-&gt;cmnd
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0
id|printk
(paren
l_string|&quot;scsi%d : %d scatter/gather segments&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;use_sg
)paren
suffix:semicolon
macro_line|#endif
id|datain
op_assign
l_int|0
suffix:semicolon
id|dataout
op_assign
l_int|2
op_star
(paren
id|cmd-&gt;use_sg
ques
c_cond
id|cmd-&gt;use_sg
suffix:colon
l_int|1
)paren
op_plus
l_int|3
suffix:semicolon
macro_line|#if 0
id|hostdata-&gt;options
op_or_assign
id|OPTION_DEBUG_INTR
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
multiline_comment|/* &n;     * These commands do no data transfer, we should force an&n;     * interrupt if a data phase is attempted on them.&n;     */
r_case
id|START_STOP
suffix:colon
r_case
id|TEST_UNIT_READY
suffix:colon
id|datain
op_assign
id|dataout
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;     * We don&squot;t know about these commands, so generate code to handle&n;     * both DATA IN and DATA OUT phases.&n;     */
r_default
suffix:colon
id|datain
op_assign
id|dataout
op_assign
l_int|2
op_star
(paren
id|cmd-&gt;use_sg
ques
c_cond
id|cmd-&gt;use_sg
suffix:colon
l_int|1
)paren
op_plus
l_int|3
suffix:semicolon
)brace
multiline_comment|/*&n;     * Allocate memory for the NCR53c7x0_cmd structure.  &n;     */
multiline_comment|/* &n;     * For each data phase implemented, we need a JUMP instruction&n;     * to return control to other_transfer.  We also need a MOVE&n;     * and a CALL instruction for each scatter/gather segment.&n;     */
id|data_transfer_instructions
op_assign
id|datain
op_plus
id|dataout
suffix:semicolon
multiline_comment|/*&n;     * When we perform a request sense, we overwrite various things,&n;     * including the data transfer code.  Make sure we have enough&n;     * space to do that.&n;     */
r_if
c_cond
(paren
id|data_transfer_instructions
OL
l_int|2
)paren
id|data_transfer_instructions
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* &n;     * We need enough space to store the base NCR53c7x0 structure,&n;     * DSA, and data transfer instructions at 2 long words each,&n;     * as well as padding out to the next 512 bytes for scsi_malloc.&n;     *&n;     * We also need to guarantee alignment of _4_ bytes. &n;     */
macro_line|#ifdef SCSI_MALLOC
id|size
op_assign
(paren
(paren
r_sizeof
(paren
r_struct
id|NCR53c7x0_cmd
)paren
op_plus
(paren
id|hostdata-&gt;dsa_end
op_minus
id|hostdata-&gt;dsa_start
)paren
op_plus
l_int|2
op_star
r_sizeof
(paren
r_int
)paren
op_star
id|data_transfer_instructions
op_plus
l_int|4
op_plus
l_int|511
)paren
op_div
l_int|512
)paren
op_star
l_int|512
suffix:semicolon
macro_line|#else
id|size
op_assign
r_sizeof
(paren
r_struct
id|NCR53c7x0_cmd
)paren
op_plus
(paren
id|hostdata-&gt;dsa_end
op_minus
id|hostdata-&gt;dsa_start
)paren
op_plus
l_int|2
op_star
r_sizeof
(paren
r_int
)paren
op_star
id|data_transfer_instructions
op_plus
l_int|4
suffix:semicolon
macro_line|#endif
macro_line|#if 0
r_if
c_cond
(paren
id|size
OG
l_int|512
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : size = %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|size
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef SCSI_MALLOC
id|real
op_assign
id|in_scan_scsis
ques
c_cond
l_int|NULL
suffix:colon
id|scsi_malloc
(paren
id|size
)paren
suffix:semicolon
macro_line|#else
id|real
op_assign
id|kmalloc
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|real
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|scan_scsis_buf_busy
op_logical_and
id|size
op_le
r_sizeof
(paren
id|scan_scsis_buf
)paren
)paren
(brace
id|scan_scsis_buf_busy
op_assign
l_int|1
suffix:semicolon
id|real
op_assign
id|scan_scsis_buf
suffix:semicolon
)brace
r_else
(brace
id|panic
(paren
l_string|&quot;scsi%d : scan_scsis_buf too small (need %d bytes)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|size
)paren
suffix:semicolon
)brace
)brace
id|alignment
op_assign
l_int|4
op_minus
(paren
(paren
(paren
r_int
)paren
id|real
)paren
op_amp
l_int|3
)paren
suffix:semicolon
id|tmp
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|real
)paren
op_plus
id|alignment
)paren
suffix:semicolon
id|tmp-&gt;real
op_assign
id|real
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|tmp-&gt;dsa
)paren
op_amp
l_int|0x3
)paren
id|panic
(paren
l_string|&quot;scsi%d : pid %d dsa structure not dword aligned!&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
multiline_comment|/*&n;     * Initialize Linux specific fields.&n;     */
id|tmp-&gt;size
op_assign
id|size
suffix:semicolon
id|tmp-&gt;cmd
op_assign
id|cmd
suffix:semicolon
id|tmp-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* &n;     * Calculate addresses of dynamic code to fill in DSA&n;     */
id|tmp-&gt;data_transfer_start
op_assign
id|tmp-&gt;dsa
op_plus
(paren
id|hostdata-&gt;dsa_end
op_minus
id|hostdata-&gt;dsa_start
)paren
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|tmp-&gt;data_transfer_end
op_assign
id|tmp-&gt;data_transfer_start
op_plus
l_int|2
op_star
id|data_transfer_instructions
suffix:semicolon
id|cmd_datain
op_assign
id|datain
ques
c_cond
id|tmp-&gt;data_transfer_start
suffix:colon
l_int|NULL
suffix:semicolon
id|cmd_dataout
op_assign
id|dataout
ques
c_cond
(paren
id|datain
ques
c_cond
id|cmd_datain
op_plus
l_int|2
op_star
id|datain
suffix:colon
id|tmp
op_member_access_from_pointer
id|data_transfer_start
)paren
suffix:colon
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;     * Fill in the NCR53c7x0_cmd structure as follows&n;     * dsa, with fixed up DSA code&n;     * datain code&n;     * dataout code&n;     */
multiline_comment|/* Copy template code into dsa and perform all necessary fixups */
r_if
c_cond
(paren
id|hostdata-&gt;dsa_fixup
)paren
id|hostdata
op_member_access_from_pointer
id|dsa_fixup
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_next
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_cmnd
comma
l_int|0
comma
id|cmd
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_select
comma
l_int|0
comma
id|hostdata-&gt;sync
(braket
id|cmd-&gt;target
)braket
dot
id|select_indirect
)paren
suffix:semicolon
multiline_comment|/*&n;     * XXX - we need to figure this size based on weather&n;     * or not we&squot;ll be using any additional messages.&n;     */
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_msgout
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
macro_line|#if 0
id|tmp-&gt;select
(braket
l_int|0
)braket
op_assign
id|IDENTIFY
(paren
l_int|1
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#else
id|tmp-&gt;select
(braket
l_int|0
)braket
op_assign
id|IDENTIFY
(paren
l_int|0
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_msgout
comma
l_int|1
comma
id|tmp-&gt;select
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_cmdout
comma
l_int|0
comma
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_cmdout
comma
l_int|1
comma
id|cmd-&gt;cmnd
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_dataout
comma
l_int|0
comma
id|cmd_dataout
ques
c_cond
id|cmd_dataout
suffix:colon
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_other_transfer
op_div
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_datain
comma
l_int|0
comma
id|cmd_datain
ques
c_cond
id|cmd_datain
suffix:colon
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_other_transfer
op_div
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;     * XXX - need to make endian aware, should use separate variables&n;     * for both status and message bytes.&n;     */
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_msgin
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_msgin
comma
l_int|1
comma
(paren
(paren
(paren
r_int
r_int
)paren
op_amp
id|cmd-&gt;result
)paren
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_status
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_status
comma
l_int|1
comma
op_amp
id|cmd-&gt;result
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_msgout_other
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_msgout_other
comma
l_int|1
comma
op_amp
id|NCR53c7xx_msg_nop
)paren
suffix:semicolon
multiline_comment|/*&n;     * Generate code for zero or more of the DATA IN, DATA OUT phases &n;     * in the format &n;     *&n;     * MOVE first buffer length, first buffer address, WHEN phase&n;     * CALL msgin, WHEN MSG_IN &n;     * ...&n;     * MOVE last buffer length, last buffer address, WHEN phase&n;     * JUMP other_transfer&n;     */
multiline_comment|/* See if we&squot;re getting to data transfer */
macro_line|#if 0
r_if
c_cond
(paren
id|datain
)paren
(brace
id|cmd_datain
(braket
l_int|0
)braket
op_assign
l_int|0x98080000
suffix:semicolon
id|cmd_datain
(braket
l_int|1
)braket
op_assign
l_int|0x03ffd00d
suffix:semicolon
id|cmd_datain
op_add_assign
l_int|2
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* &n; * XXX - I&squot;m undecided weather all of this nonsense is faster&n; * in the long run, or weather I should just go and implement a loop&n; * on the NCR chip using table indirect mode?&n; *&n; * In any case, this is how it _must_ be done for 53c700/700-66 chips,&n; * so this stays even when we come up with something better.&n; *&n; * When we&squot;re limited to 1 simultaneous command, no overlapping processing,&n; * we&squot;re seeing 630K/sec, with 7% CPU usage on a slow Syquest 45M&n; * drive.&n; *&n; * Not bad, not good. We&squot;ll see.&n; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;use_sg
ques
c_cond
(paren
id|i
OL
id|cmd-&gt;use_sg
)paren
suffix:colon
op_logical_neg
id|i
suffix:semicolon
id|cmd_datain
op_add_assign
l_int|4
comma
id|cmd_dataout
op_add_assign
l_int|4
comma
op_increment
id|i
)paren
(brace
r_int
r_int
id|buf
op_assign
(paren
r_int
r_int
)paren
(paren
id|cmd-&gt;use_sg
ques
c_cond
(paren
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
)paren
(braket
id|i
)braket
dot
id|address
suffix:colon
id|cmd-&gt;request_buffer
)paren
suffix:semicolon
r_int
r_int
id|count
op_assign
(paren
r_int
r_int
)paren
(paren
id|cmd-&gt;use_sg
ques
c_cond
(paren
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
)paren
(braket
id|i
)braket
dot
id|length
suffix:colon
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|datain
)paren
(brace
id|cmd_datain
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|DCMD_TYPE_BMI
op_or
id|DCMD_BMI_OP_MOVE_I
op_or
id|DCMD_BMI_IO
)paren
op_lshift
l_int|24
)paren
op_or
id|count
suffix:semicolon
id|cmd_datain
(braket
l_int|1
)braket
op_assign
id|buf
suffix:semicolon
id|cmd_datain
(braket
l_int|2
)braket
op_assign
(paren
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_CALL
op_or
id|DCMD_TCI_CD
op_or
id|DCMD_TCI_IO
op_or
id|DCMD_TCI_MSG
)paren
op_lshift
l_int|24
)paren
op_or
id|DBC_TCI_WAIT_FOR_VALID
op_or
id|DBC_TCI_COMPARE_PHASE
op_or
id|DBC_TCI_TRUE
suffix:semicolon
id|cmd_datain
(braket
l_int|3
)braket
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_msg_in
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
macro_line|#if 0
id|print_insn
(paren
id|host
comma
id|cmd_datain
comma
l_string|&quot;dynamic &quot;
comma
l_int|1
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|cmd_datain
op_plus
l_int|2
comma
l_string|&quot;dynamic &quot;
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|dataout
)paren
(brace
id|cmd_dataout
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|DCMD_TYPE_BMI
op_or
id|DCMD_BMI_OP_MOVE_I
)paren
op_lshift
l_int|24
)paren
op_or
id|count
suffix:semicolon
id|cmd_dataout
(braket
l_int|1
)braket
op_assign
id|buf
suffix:semicolon
id|cmd_dataout
(braket
l_int|2
)braket
op_assign
(paren
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_CALL
op_or
id|DCMD_TCI_CD
op_or
id|DCMD_TCI_IO
op_or
id|DCMD_TCI_MSG
)paren
op_lshift
l_int|24
)paren
op_or
id|DBC_TCI_WAIT_FOR_VALID
op_or
id|DBC_TCI_COMPARE_PHASE
op_or
id|DBC_TCI_TRUE
suffix:semicolon
id|cmd_dataout
(braket
l_int|3
)braket
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_msg_in
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
macro_line|#if 0
id|print_insn
(paren
id|host
comma
id|cmd_dataout
comma
l_string|&quot;dynamic &quot;
comma
l_int|1
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|cmd_dataout
op_plus
l_int|2
comma
l_string|&quot;dynamic &quot;
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*&n;     * Install JUMP instructions after the data transfer routines to return&n;     * control to the do_other_transfer routines.&n;     */
r_if
c_cond
(paren
id|datain
)paren
(brace
id|cmd_datain
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_JUMP
)paren
op_lshift
l_int|24
)paren
op_or
id|DBC_TCI_TRUE
suffix:semicolon
id|cmd_datain
(braket
l_int|1
)braket
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_other_transfer
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
macro_line|#if 0
id|print_insn
(paren
id|host
comma
id|cmd_datain
comma
l_string|&quot;dynamic jump &quot;
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|cmd_datain
op_add_assign
l_int|2
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|datain
)paren
(brace
id|cmd_datain
(braket
l_int|0
)braket
op_assign
l_int|0x98080000
suffix:semicolon
id|cmd_datain
(braket
l_int|1
)braket
op_assign
l_int|0x03ffdeed
suffix:semicolon
id|cmd_datain
op_add_assign
l_int|2
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|dataout
)paren
(brace
id|cmd_dataout
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_JUMP
)paren
op_lshift
l_int|24
)paren
op_or
id|DBC_TCI_TRUE
suffix:semicolon
id|cmd_dataout
(braket
l_int|1
)braket
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_other_transfer
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
macro_line|#if 0
id|print_insn
(paren
id|host
comma
id|cmd_dataout
comma
l_string|&quot;dynamic jump &quot;
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|cmd_dataout
op_add_assign
l_int|2
suffix:semicolon
)brace
r_return
id|tmp
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : int NCR53c7xx_queue_command (Scsi_Cmnd *cmd,&n; *      void (*done)(Scsi_Cmnd *)) &n; *&n; * Purpose :  enqueues a SCSI command&n; *&n; * Inputs : cmd - SCSI command, done - function called on completion, with&n; *      a pointer to the command descriptor.&n; * &n; * Returns : 0&n; *&n; * Side effects : &n; *      cmd is added to the per instance issue_queue, with minor &n; *      twiddling done to the host specific fields of cmd.  If the &n; *      main coroutine is not running, it is restarted.&n; *&n; */
DECL|function|NCR53c7xx_queue_command
r_int
id|NCR53c7xx_queue_command
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_cmd
op_star
id|tmp
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;host
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
id|old_level
suffix:semicolon
r_int
r_char
id|target_was_busy
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_INIT_ONLY
op_or
id|OPTION_DEBUG_PROBE_ONLY
)paren
)paren
op_logical_or
(paren
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_TARGET_LIMIT
)paren
op_logical_and
op_logical_neg
(paren
id|hostdata-&gt;debug_lun_limit
(braket
id|cmd-&gt;target
)braket
op_amp
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
)paren
)paren
)paren
op_logical_or
id|cmd-&gt;target
OG
l_int|7
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : disabled target %d lun %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_NCOMMANDS_LIMIT
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;debug_count_limit
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : maximum commands exceeded&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hostdata-&gt;debug_count_limit
op_ne
op_minus
l_int|1
)paren
op_decrement
id|hostdata-&gt;debug_count_limit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_READ_ONLY
)paren
(brace
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : WRITE attempted with NO_WRITE debugging flag set&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;result
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* The NCR will overwrite message&n;&t;&t;&t;&t;&t;   and status with valid data */
id|cmd-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|tmp
op_assign
id|create_cmd
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;     * On NCR53c710 and better chips, we have two issue queues : &n;     * The queue maintained by the Linux driver, and the queue &n;     * maintained by the NCR chip.&n;     * &n;     * The Linux queue includes commands which have been generated,&n;     * but may be unable to execute because the device is busy, &n;     * where as the NCR queue contains commands to issue as soon&n;     * as BUS FREE is detected.&n;     *&n;     * NCR53c700 and NCR53c700-66 chips use only the Linux driver&n;     * queue. &n;     * &n;     * So, insert into the Linux queue if the device is busy or &n;     * we are running on an old chip, otherwise insert directly into&n;     * the NCR queue.&n;     */
multiline_comment|/*&n;     * REQUEST sense commands need to be executed before all other &n;     * commands since any command will clear the contingent allegiance &n;     * condition that exists and the sense data is only guaranteed to be &n;     * valid while the condition exists.&n;     */
id|old_level
op_assign
id|splx
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;     * Consider a target busy if there are _any_ commands running&n;     * on it.  &n;     * XXX - Once we do SCSI-II tagged queuing, we want to use &n;     *     a different definition of busy.&n;     */
id|target_was_busy
op_assign
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
(braket
id|cmd-&gt;lun
)braket
macro_line|#ifdef LUN_BUSY
op_increment
macro_line|#endif
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_700
)paren
op_logical_and
op_logical_neg
id|target_was_busy
)paren
(brace
r_int
r_char
op_star
id|dsa
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|tmp-&gt;dsa
)paren
op_minus
id|hostdata-&gt;dsa_start
suffix:semicolon
multiline_comment|/* dsa start is negative, so subtraction is used */
macro_line|#if 0&t;
id|printk
c_func
(paren
l_string|&quot;scsi%d : new dsa is 0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
)paren
id|dsa
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|hostdata-&gt;running_list
)paren
id|hostdata-&gt;running_list-&gt;prev
op_assign
id|tmp
suffix:semicolon
id|tmp-&gt;next
op_assign
id|hostdata-&gt;running_list
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;running_list
)paren
id|hostdata-&gt;running_list
op_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;idle
)paren
(brace
id|hostdata-&gt;idle
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|STATE_RUNNING
suffix:semicolon
id|NCR53c7x0_write32
(paren
id|DSP_REG
comma
(paren
(paren
r_int
r_int
)paren
id|hostdata-&gt;script
)paren
op_plus
id|hostdata-&gt;E_schedule
)paren
suffix:semicolon
)brace
multiline_comment|/* XXX - make function */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* &n;&t;     * If the NCR doesn&squot;t have any commands waiting in its&n;&t;     * issue queue, then we simply create a new issue queue,&n;&t;     * and signal the NCR that we have more commands.&n;&t;     */
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;issue_dsa_head
)paren
(brace
macro_line|#if 0
id|printk
(paren
l_string|&quot;scsi%d : no issue queue&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;issue_dsa_tail
op_assign
id|hostdata-&gt;issue_dsa_head
op_assign
id|dsa
suffix:semicolon
id|NCR53c7x0_write8
c_func
(paren
id|hostdata-&gt;istat
comma
id|NCR53c7x0_read8
c_func
(paren
id|hostdata-&gt;istat
)paren
op_or
id|ISTAT_10_SIGP
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;     * Otherwise, we blindly perform an atomic write &n;&t;     * to the next pointer of the last command we &n;&t;     * placed in that queue.&n;&t;     *&n;&t;     * Looks like it doesn&squot;t work, but I think it does - &n; &t;     */
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;scsi%d : existing issue queue&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
multiline_comment|/* XXX - Replace with XCHG or equivalent */
id|hostdata-&gt;issue_dsa_tail
op_assign
op_star
(paren
(paren
r_int
r_char
op_star
op_star
)paren
(paren
id|hostdata-&gt;issue_dsa_tail
op_plus
id|hostdata-&gt;dsa_next
)paren
)paren
op_assign
id|dsa
suffix:semicolon
multiline_comment|/*&n;&t;     * After which, one of two things will happen : &n;&t;     * The NCR will have scheduled a command, either this&n;&t;     * one, or the next one.  In this case, we successfully&n;&t;     * added our command to the queue.&n;&t;     *&n;&t;     * The NCR will have written the hostdata-&gt;issue_dsa_head&n;&t;     * pointer with the NULL pointer terminating the list,&n;&t;     * in which case we were too late.  If this happens,&n;&t;     * we restart&n;&t;     */
r_if
c_cond
(paren
id|hostdata-&gt;issue_dsa_head
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* XXX - end */
)brace
r_else
(brace
macro_line|#if 1
id|printk
(paren
l_string|&quot;scsi%d : using issue_queue instead of issue_dsa_head!&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|tmp
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|tmp-&gt;next
suffix:semicolon
id|tmp
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|tmp-&gt;next
)paren
suffix:semicolon
id|tmp-&gt;next
op_assign
id|tmp
suffix:semicolon
)brace
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fix_pointers
r_int
id|fix_pointers
(paren
r_int
r_int
id|dsa
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : static void intr_scsi (struct Scsi_Host *host, &n; * &t;struct NCR53c7x0_cmd *cmd)&n; *&n; * Purpose : handle all SCSI interrupts, indicated by the setting &n; * &t;of the SIP bit in the ISTAT register.&n; *&n; * Inputs : host, cmd - host and NCR command causing the interrupt, cmd&n; * &t;may be NULL.&n; */
DECL|function|intr_scsi
r_static
r_void
id|intr_scsi
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
r_char
id|sstat0_sist0
comma
id|sist1
comma
multiline_comment|/* Registers */
id|fatal
suffix:semicolon
multiline_comment|/* Did a fatal interrupt &n;&t;&t;&t;&t;&t;&t;   occur ? */
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
id|fatal
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
(brace
id|sstat0_sist0
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SIST0_REG_800
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|sist1
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SIST1_REG_800
)paren
suffix:semicolon
)brace
r_else
(brace
id|sstat0_sist0
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SSTAT0_REG
)paren
suffix:semicolon
id|sist1
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : SIST0 0x%0x, SIST1 0x%0x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|sstat0_sist0
comma
id|sist1
)paren
suffix:semicolon
multiline_comment|/* 250ms selection timeout */
r_if
c_cond
(paren
(paren
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
op_logical_and
(paren
id|sist1
op_amp
id|SIST1_800_STO
)paren
)paren
op_logical_or
(paren
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_ne
l_int|8
)paren
op_logical_and
id|sstat0_sist0
op_logical_and
id|SSTAT0_700_STO
)paren
)paren
(brace
id|fatal
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : Selection Timeout&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : target %d, lun %d, command &quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;cmd-&gt;target
comma
id|cmd-&gt;cmd-&gt;lun
)paren
suffix:semicolon
id|print_command
(paren
id|cmd-&gt;cmd-&gt;cmnd
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : dsp = 0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
)paren
id|NCR53c7x0_read32
c_func
(paren
id|DSP_REG
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : no command&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * XXX - question : how do we want to handle the Illegal Instruction&n; * &t;interrupt, which may occur before or after the Selection Timeout&n; * &t;interrupt?&n; */
r_if
c_cond
(paren
l_int|1
)paren
(brace
id|hostdata-&gt;idle
op_assign
l_int|1
suffix:semicolon
id|hostdata-&gt;expecting_sto
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;test_running
)paren
(brace
id|hostdata-&gt;test_running
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;test_completed
op_assign
l_int|3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd
)paren
(brace
id|abnormal_finished
c_func
(paren
id|cmd
comma
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
macro_line|#if 0&t;    
id|hostdata-&gt;intrs
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
)brace
r_if
c_cond
(paren
id|sstat0_sist0
op_amp
id|SSTAT0_UDC
)paren
(brace
id|fatal
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : target %d lun %d unexpected disconnect&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;cmd-&gt;target
comma
id|cmd-&gt;cmd-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
)paren
(brace
id|abnormal_finished
c_func
(paren
id|cmd
comma
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_schedule
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* SCSI PARITY error */
)brace
r_if
c_cond
(paren
id|sstat0_sist0
op_amp
id|SSTAT0_PAR
)paren
(brace
id|fatal
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_logical_and
id|cmd-&gt;cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : target %d lun %d parity error.&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;cmd-&gt;target
comma
id|cmd-&gt;cmd-&gt;lun
)paren
suffix:semicolon
id|abnormal_finished
(paren
id|cmd
comma
id|DID_PARITY
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;scsi%d : parity error&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
multiline_comment|/* Should send message out, parity error */
multiline_comment|/* XXX - Reduce synchronous transfer rate! */
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_initiator_abort
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* SCSI GROSS error */
)brace
r_if
c_cond
(paren
id|sstat0_sist0
op_amp
id|SSTAT0_SGE
)paren
(brace
id|fatal
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : gross error&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
multiline_comment|/* XXX Reduce synchronous transfer rate! */
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_initiator_abort
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Phase mismatch */
)brace
r_if
c_cond
(paren
id|sstat0_sist0
op_amp
id|SSTAT0_MA
)paren
(brace
id|fatal
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : SSTAT0_MA&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|intr_phase_mismatch
(paren
id|host
comma
id|cmd
)paren
suffix:semicolon
)brace
macro_line|#if 1
multiline_comment|/*&n; * If a fatal SCSI interrupt occurs, we must insure that the DMA and&n; * SCSI FIFOs were flushed.&n; */
r_if
c_cond
(paren
id|fatal
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;dstat_valid
)paren
(brace
id|hostdata-&gt;dstat
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|DSTAT_REG
)paren
suffix:semicolon
id|hostdata-&gt;dstat_valid
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* XXX - code check for 700/800 chips */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;dstat
op_amp
id|DSTAT_DFE
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : DMA FIFO not empty&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|NCR53c7x0_read8
(paren
id|CTEST2_REG_800
)paren
op_amp
id|CTEST2_800_DDIR
)paren
(brace
id|NCR53c7x0_write8
(paren
id|CTEST3_REG_800
comma
id|CTEST3_800_FLF
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|hostdata-&gt;dstat
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|DSTAT_REG
)paren
)paren
op_amp
id|DSTAT_DFE
)paren
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
id|NCR53c7x0_write8
(paren
id|CTEST3_REG_800
comma
id|CTEST3_800_CLF
)paren
suffix:semicolon
r_while
c_loop
(paren
id|NCR53c7x0_read8
(paren
id|CTEST3_REG_800
)paren
op_amp
id|CTEST3_800_CLF
)paren
suffix:semicolon
)brace
)brace
id|NCR53c7x0_write8
(paren
id|STEST3_REG_800
comma
id|STEST3_800_CSF
)paren
suffix:semicolon
r_while
c_loop
(paren
id|NCR53c7x0_read8
(paren
id|STEST3_REG_800
)paren
op_amp
id|STEST3_800_CSF
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * Function : static void NCR53c7x0_intr (int irq)&n; *&n; * Purpose : handle NCR53c7x0 interrupts for all NCR devices sharing&n; *&t;the same IRQ line.  &n; * &n; * Inputs : Since we&squot;re using the SA_INTERRUPT interrupt handler&n; *&t;semantics, irq indicates the interrupt which invoked &n; *&t;this handler.  &n; */
DECL|function|NCR53c7x0_intr
r_static
r_void
id|NCR53c7x0_intr
(paren
r_int
id|irq
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
multiline_comment|/* Host we are looking at */
r_int
r_char
id|istat
suffix:semicolon
multiline_comment|/* Values of interrupt regs */
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
suffix:semicolon
multiline_comment|/* host-&gt;hostdata */
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
comma
multiline_comment|/* command which halted */
op_star
op_star
id|cmd_prev_ptr
suffix:semicolon
r_int
r_int
op_star
id|dsa
suffix:semicolon
multiline_comment|/* DSA */
r_int
id|done
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Indicates when handler &n;&t;&t;&t;&t;&t;&t;   should terminate */
r_int
id|interrupted
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This HA generated &n;&t;&t;&t;&t;&t;&t;   an interrupt */
r_int
id|old_level
suffix:semicolon
macro_line|#ifdef NCR_DEBUG
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
multiline_comment|/* Debugging sprintf buffer */
r_int
id|buflen
suffix:semicolon
multiline_comment|/* Length of same */
macro_line|#endif
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;interrupt %d received&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
r_do
(brace
id|done
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|host
op_assign
id|first_host
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|hostdata-&gt;next
ques
c_cond
id|hostdata-&gt;next
suffix:colon
l_int|NULL
)paren
(brace
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|0
suffix:semicolon
id|interrupted
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|hostdata-&gt;dstat_valid
op_assign
l_int|0
suffix:semicolon
id|interrupted
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Only read istat once, since reading it again will unstack&n;&t;&t; * interrupts.&n;&t;&t; */
id|istat
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|hostdata-&gt;istat
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * INTFLY interrupts are used by the NCR53c720, NCR53c810,&n;&t;&t; * and NCR53c820 to signify completion of a command.  Since &n;&t;&t; * the SCSI processor continues running, we can&squot;t just look&n;&t;&t; * at the contents of the DSA register and continue running.&n;&t;&t; */
multiline_comment|/* XXX - this is getting big, and should move to intr_intfly() */
r_if
c_cond
(paren
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_INTFLY
)paren
op_logical_and
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
op_logical_and
(paren
id|istat
op_amp
id|ISTAT_800_INTF
)paren
)paren
)paren
(brace
r_char
id|search_found
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Got at least one ? */
id|done
op_assign
l_int|0
suffix:semicolon
id|interrupted
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* &n;&t;&t;     * Clear the INTF bit by writing a one.  This reset operation &n;&t;&t;     * is self-clearing.&n;&t;&t;     */
id|NCR53c7x0_write8
c_func
(paren
id|hostdata-&gt;istat
comma
id|istat
op_or
id|ISTAT_800_INTF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : INTFLY&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;     * Traverse our list of running commands, and look&n;&t;&t;     * for those with valid (non-0xff ff) status and message&n;&t;&t;     * bytes encoded in the result which signify command&n;&t;&t;     * completion.&n;&t;&t;     */
id|old_level
op_assign
id|splx
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|restart
suffix:colon
r_for
c_loop
(paren
id|cmd_prev_ptr
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
op_star
)paren
op_amp
(paren
id|hostdata-&gt;running_list
)paren
comma
id|cmd
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|hostdata-&gt;running_list
suffix:semicolon
id|cmd
suffix:semicolon
id|cmd_prev_ptr
op_assign
op_amp
(paren
id|cmd-&gt;next
)paren
comma
id|cmd
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|cmd-&gt;next
)paren
(brace
id|Scsi_Cmnd
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : very weird.&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp
op_assign
id|cmd-&gt;cmd
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : weird.  NCR53c7x0_cmd has no Scsi_Cmnd&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#if 0
id|printk
(paren
l_string|&quot;scsi%d : looking at result of 0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;cmd-&gt;result
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
(paren
id|tmp-&gt;result
op_amp
l_int|0xff
)paren
op_eq
l_int|0xff
)paren
op_logical_or
(paren
(paren
id|tmp-&gt;result
op_amp
l_int|0xff00
)paren
op_eq
l_int|0xff00
)paren
)paren
r_continue
suffix:semicolon
id|search_found
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Important - remove from list _before_ done is called */
multiline_comment|/* XXX - SLL.  Seems like DLL is unnecessary */
r_if
c_cond
(paren
id|cmd-&gt;prev
)paren
id|cmd-&gt;prev-&gt;next
op_assign
id|cmd-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cmd_prev_ptr
)paren
op_star
id|cmd_prev_ptr
op_assign
id|cmd-&gt;next
suffix:semicolon
macro_line|#ifdef LUN_BUSY
multiline_comment|/* Check for next command for target, add to issue queue */
r_if
c_cond
(paren
op_decrement
id|hostdata-&gt;busy
(braket
id|tmp-&gt;target
)braket
(braket
id|tmp-&gt;lun
)braket
)paren
(brace
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|scan_scsis_buf_busy
)paren
(brace
macro_line|#ifdef SCSI_MALLOC
id|scsi_free
(paren
(paren
r_void
op_star
)paren
id|cmd-&gt;real
comma
id|cmd-&gt;size
)paren
suffix:semicolon
macro_line|#else
id|kfree_s
(paren
(paren
r_void
op_star
)paren
id|cmd-&gt;real
comma
id|cmd-&gt;size
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|scan_scsis_buf_busy
op_assign
l_int|0
suffix:semicolon
)brace
id|tmp-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : command complete : pid %lu, id %d,lun %d result 0x%x &quot;
comma
id|host-&gt;host_no
comma
id|tmp-&gt;pid
comma
id|tmp-&gt;target
comma
id|tmp-&gt;lun
comma
id|tmp-&gt;result
)paren
suffix:semicolon
id|print_command
(paren
id|tmp-&gt;cmnd
)paren
suffix:semicolon
)brace
macro_line|#if 0
id|hostdata-&gt;options
op_and_assign
op_complement
id|OPTION_DEBUG_INTR
suffix:semicolon
macro_line|#endif
id|tmp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|search_found
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : WARNING : INTFLY with no completed commands.&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|istat
op_amp
(paren
id|ISTAT_SIP
op_or
id|ISTAT_DIP
)paren
)paren
(brace
id|done
op_assign
l_int|0
suffix:semicolon
id|interrupted
op_assign
l_int|1
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|STATE_HALTED
suffix:semicolon
multiline_comment|/*&n;&t;&t;     * NCR53c700 and NCR53c700-66 change the current SCSI&n;&t;&t;     * process, hostdata-&gt;current, in the Linux driver so&n;&t;&t;     * cmd = hostdata-&gt;current.&n;&t;&t;     *&n;&t;&t;     * With other chips, we must look through the commands&n;&t;&t;     * executing and find the command structure which &n;&t;&t;     * corresponds to the DSA register.&n;&t;&t;     */
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_700
)paren
(brace
id|cmd
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|hostdata-&gt;current
suffix:semicolon
)brace
r_else
(brace
id|dsa
op_assign
(paren
r_int
r_int
op_star
)paren
id|NCR53c7x0_read32
c_func
(paren
id|DSA_REG
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cmd
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|hostdata-&gt;running_list
suffix:semicolon
id|cmd
op_logical_and
(paren
id|dsa
op_plus
(paren
id|hostdata-&gt;dsa_start
op_div
r_sizeof
(paren
r_int
)paren
)paren
)paren
op_ne
id|cmd-&gt;dsa
suffix:semicolon
id|cmd
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
(paren
id|cmd-&gt;next
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
(brace
r_if
c_cond
(paren
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : interrupt for pid %lu, id %d, lun %d &quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;cmd-&gt;pid
comma
(paren
r_int
)paren
id|cmd-&gt;cmd-&gt;target
comma
(paren
r_int
)paren
id|cmd-&gt;cmd-&gt;lun
)paren
suffix:semicolon
id|print_command
(paren
id|cmd-&gt;cmd-&gt;cmnd
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : no active command&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|istat
op_amp
id|ISTAT_SIP
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : ISTAT_SIP&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|intr_scsi
(paren
id|host
comma
id|cmd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|istat
op_amp
id|ISTAT_DIP
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : ISTAT_DIP&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|intr_dma
(paren
id|host
comma
id|cmd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;dstat_valid
)paren
(brace
id|hostdata-&gt;dstat
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|DSTAT_REG
)paren
suffix:semicolon
id|hostdata-&gt;dstat_valid
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#if 1
multiline_comment|/* XXX - code check for 700/800 chips */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;dstat
op_amp
id|DSTAT_DFE
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : DMA FIFO not empty&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|NCR53c7x0_read8
(paren
id|CTEST2_REG_800
)paren
op_amp
id|CTEST2_800_DDIR
)paren
(brace
id|NCR53c7x0_write8
(paren
id|CTEST3_REG_800
comma
id|CTEST3_800_FLF
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|hostdata-&gt;dstat
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|DSTAT_REG
)paren
)paren
op_amp
id|DSTAT_DFE
)paren
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
id|NCR53c7x0_write8
(paren
id|CTEST3_REG_800
comma
id|CTEST3_800_CLF
)paren
suffix:semicolon
r_while
c_loop
(paren
id|NCR53c7x0_read8
(paren
id|CTEST3_REG_800
)paren
op_amp
id|CTEST3_800_CLF
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
)brace
r_while
c_loop
(paren
id|interrupted
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;intrs
op_ne
op_minus
l_int|1
)paren
id|hostdata-&gt;intrs
op_increment
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|hostdata-&gt;intrs
OG
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : too many interrupts, halting&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|hostdata-&gt;idle
op_assign
l_int|1
suffix:semicolon
id|hostdata-&gt;options
op_or_assign
id|OPTION_DEBUG_INIT_ONLY
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;dying...&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;idle
op_logical_and
id|hostdata-&gt;state
op_eq
id|STATE_HALTED
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;dsp_changed
)paren
(brace
id|hostdata-&gt;dsp
op_assign
(paren
r_int
r_int
op_star
)paren
id|NCR53c7x0_read32
c_func
(paren
id|DSP_REG
)paren
suffix:semicolon
)brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;scsi%d : new dsp is 0x%lx&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
)paren
id|hostdata-&gt;dsp
)paren
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;state
op_assign
id|STATE_RUNNING
suffix:semicolon
id|NCR53c7x0_write32
(paren
id|DSP_REG
comma
(paren
r_int
r_int
)paren
id|hostdata-&gt;dsp
)paren
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : static int abort_connected (struct Scsi_Host *host)&n; *&n; * Purpose : Assuming that the NCR SCSI processor is currently &n; * &t;halted, break the currently established nexus.  Clean&n; *&t;up of the NCR53c7x0_cmd and Scsi_Cmnd structures should&n; *&t;be done on receipt of the abort interrupt.&n; *&n; * Inputs : host - SCSI host&n; *&n; */
DECL|function|abort_connected
r_static
r_int
id|abort_connected
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_initiator_abort
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : DANGER : abort_connected() called &bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
multiline_comment|/* XXX - need to flag the command as aborted after the abort_connected&n; &t; code runs &n; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : static void intr_phase_mismatch (struct Scsi_Host *host, &n; *&t;struct NCR53c7x0_cmd *cmd)&n; *&n; * Purpose : Handle phase mismatch interrupts&n; *&n; * Inputs : host, cmd - host and NCR command causing the interrupt, cmd&n; * &t;may be NULL.&n; *&n; * Side effects : The abort_connected() routine is called or the NCR chip &n; *&t;is restarted, jumping to the command_complete entry point, or &n; *&t;patching the address and transfer count of the current instruction &n; *&t;and calling the msg_in entry point as appropriate.&n; *&n; */
DECL|function|intr_phase_mismatch
r_static
r_void
id|intr_phase_mismatch
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|dbc_dcmd
comma
op_star
id|dsp
comma
op_star
id|dsp_next
suffix:semicolon
r_int
r_char
id|dcmd
comma
id|sbcl
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_char
op_star
id|phase
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : phase mismatch interrupt occurred with no current command.&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|abort_connected
c_func
(paren
id|host
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;     * Corrective action is based on where in the SCSI SCRIPT(tm) the error &n;     * occurred, as well as which SCSI phase we are currently in.&n;     */
id|dsp_next
op_assign
(paren
r_int
r_int
op_star
)paren
id|NCR53c7x0_read32
c_func
(paren
id|DSP_REG
)paren
suffix:semicolon
multiline_comment|/*&n;     * Like other processors, the NCR adjusts the DSP pointer before&n;     * instruction decode.  Set the DSP address back to what it should&n;     * be for this instruction based on its size (2 or 3 longs).&n;     */
id|dbc_dcmd
op_assign
id|NCR53c7x0_read32
c_func
(paren
id|DBC_REG
)paren
suffix:semicolon
id|dcmd
op_assign
(paren
id|dbc_dcmd
op_amp
l_int|0xff000000
)paren
op_rshift
l_int|24
suffix:semicolon
id|dsp
op_assign
id|dsp_next
op_minus
id|NCR53c7x0_insn_size
c_func
(paren
id|dcmd
)paren
suffix:semicolon
multiline_comment|/*&n;     * Read new SCSI phase from the SBCL lines.&n;     *&n;     * Note that since all of our code uses a WHEN conditional instead of an &n;     * IF conditional, we don&squot;t need to wait for a valid REQ.&n;     */
id|sbcl
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SBCL_REG
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sbcl
)paren
(brace
r_case
id|SBCL_PHASE_DATAIN
suffix:colon
id|phase
op_assign
l_string|&quot;DATAIN&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBCL_PHASE_DATAOUT
suffix:colon
id|phase
op_assign
l_string|&quot;DATAOUT&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBCL_PHASE_MSGIN
suffix:colon
id|phase
op_assign
l_string|&quot;MSGIN&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBCL_PHASE_MSGOUT
suffix:colon
id|phase
op_assign
l_string|&quot;MSGOUT&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBCL_PHASE_CMDOUT
suffix:colon
id|phase
op_assign
l_string|&quot;CMDOUT&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBCL_PHASE_STATIN
suffix:colon
id|phase
op_assign
l_string|&quot;STATUSIN&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|phase
op_assign
l_string|&quot;unknown&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;     * The way the SCSI SCRIPTS(tm) are architected, recoverable phase&n;     * mismatches should only occur in the data transfer routines, or&n;     * when a command is being aborted.  &n;     */
r_if
c_cond
(paren
id|dsp
op_ge
id|cmd-&gt;data_transfer_start
op_amp
id|dsp
OL
id|cmd-&gt;data_transfer_end
)paren
(brace
multiline_comment|/*&n;&t; * There are three instructions used in our data transfer routines with&n;&t; * a phase conditional on them&n;&t; *&n;&t; * 1.  MOVE count, address, WHEN DATA_IN&n;&t; * 2.  MOVE count, address, WHEN DATA_OUT&n;&t; * 3.  CALL msg_in, WHEN MSG_IN.&n;&t; */
r_switch
c_cond
(paren
id|sbcl
op_amp
id|SBCL_PHASE_MASK
)paren
(brace
multiline_comment|/*&n;&t; * 1.  STATUS phase : pass control to command_complete as if &n;&t; *     a JUMP instruction was executed.  No patches are made.&n;&t; */
r_case
id|SBCL_PHASE_STATIN
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : new phase = STATIN&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_command_complete
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * 2.  MSGIN phase : pass control to msg_in as if a CALL&n;&t; *     instruction was executed.  Patch current instruction.&n;&t; */
multiline_comment|/* &n; * XXX - This is buggy.&n; */
r_case
id|SBCL_PHASE_MSGIN
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d  : new phase = MSGIN&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dcmd
op_amp
(paren
id|DCMD_TYPE_MASK
op_or
id|DCMD_BMI_OP_MASK
op_or
id|DCMD_BMI_INDIRECT
op_or
id|DCMD_BMI_MSG
op_or
id|DCMD_BMI_CD
)paren
)paren
op_eq
(paren
id|DCMD_TYPE_BMI
op_or
id|DCMD_BMI_OP_MOVE_I
)paren
)paren
(brace
id|dsp
(braket
l_int|0
)braket
op_assign
id|dbc_dcmd
suffix:semicolon
id|dsp
(braket
l_int|1
)braket
op_assign
id|NCR53c7x0_read32
c_func
(paren
id|DNAD_REG
)paren
suffix:semicolon
id|NCR53c7x0_write32
c_func
(paren
id|TEMP_REG
comma
(paren
r_int
r_int
)paren
id|dsp
)paren
suffix:semicolon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_msg_in
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : unexpected MSGIN in dynamic NCR code, dcmd=0x%x.&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|dcmd
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|dsp
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|dsp_next
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|abort_connected
(paren
id|host
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * MSGOUT phase - shouldn&squot;t happen, because we haven&squot;t &n;&t; *&t;&t;asserted ATN.&n;&t; * CMDOUT phase - shouldn&squot;t happen, since we&squot;ve already&n;&t; * &t;&t;sent a valid command.&n;&t; * DATAIN/DATAOUT - other one shouldn&squot;t happen, since &n;&t; * &t;&t;SCSI commands can ONLY have one or the other.&n;&t; *&n;&t; * So, we abort the command if one of these things happens.&n;&t; */
r_default
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : unexpected phase %s in data routine&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|phase
)paren
suffix:semicolon
id|abort_connected
c_func
(paren
id|host
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Any other phase mismatches abort the currently executing command.&n;     */
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;scsi%d : unexpected phase %s at dsp = 0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|phase
comma
(paren
r_int
)paren
id|dsp
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|dsp
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|dsp_next
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|abort_connected
c_func
(paren
id|host
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function : static void intr_dma (struct Scsi_Host *host, &n; * &t;struct NCR53c7x0_cmd *cmd)&n; *&n; * Purpose : handle all DMA interrupts, indicated by the setting &n; * &t;of the DIP bit in the ISTAT register.&n; *&n; * Inputs : host, cmd - host and NCR command causing the interrupt, cmd&n; * &t;may be NULL.&n; */
DECL|function|intr_dma
r_static
r_void
id|intr_dma
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
r_char
id|dstat
comma
multiline_comment|/* DSTAT */
id|dbc_dcmd
suffix:semicolon
multiline_comment|/* DCMD (high eight bits) + DBC */
r_int
r_int
op_star
id|dsp
comma
op_star
id|next_dsp
comma
multiline_comment|/* Current dsp */
op_star
id|dsa
suffix:semicolon
r_int
id|ipl
comma
multiline_comment|/* Old ipl from splx(0) */
id|tmp
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;dstat_valid
)paren
(brace
id|hostdata-&gt;dstat
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|DSTAT_REG
)paren
suffix:semicolon
id|hostdata-&gt;dstat_valid
op_assign
l_int|1
suffix:semicolon
)brace
id|dstat
op_assign
id|hostdata-&gt;dstat
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : DSTAT=0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
)paren
id|dstat
)paren
suffix:semicolon
id|dbc_dcmd
op_assign
id|NCR53c7x0_read32
(paren
id|DBC_REG
)paren
suffix:semicolon
id|next_dsp
op_assign
(paren
r_int
r_int
op_star
)paren
id|NCR53c7x0_read32
c_func
(paren
id|DSP_REG
)paren
suffix:semicolon
id|dsp
op_assign
id|next_dsp
op_minus
id|NCR53c7x0_insn_size
(paren
(paren
id|dbc_dcmd
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* XXX - check chip type */
id|dsa
op_assign
(paren
r_int
r_int
op_star
)paren
id|NCR53c7x0_read32
c_func
(paren
id|DSA_REG
)paren
suffix:semicolon
multiline_comment|/*&n;     * DSTAT_ABRT is the aborted interrupt.  This is set whenever the &n;     * SCSI chip is aborted.  &n;     * &n;     * With NCR53c700 and NCR53c700-66 style chips, we should only &n;     * get this when the chip is currently running the accept &n;     * reselect/select code and we have set the abort bit in the &n;     * ISTAT register.&n;     *&n;     */
r_if
c_cond
(paren
id|dstat
op_amp
id|DSTAT_ABRT
)paren
(brace
macro_line|#if 0
multiline_comment|/* XXX - add code here to deal with normal abort */
r_if
c_cond
(paren
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_700
)paren
op_logical_and
(paren
id|hostdata-&gt;state
op_eq
id|STATE_ABORTING
)paren
(brace
)brace
r_else
macro_line|#endif
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : unexpected abort interrupt at&bslash;n&quot;
l_string|&quot;         &quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|dsp
comma
l_string|&quot;s &quot;
comma
l_int|1
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * DSTAT_SSI is the single step interrupt.  Should be generated &n;     * whenever we have single stepped or are tracing.&n;     */
r_if
c_cond
(paren
id|dstat
op_amp
id|DSTAT_SSI
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_TRACE
)paren
(brace
)brace
r_else
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_SINGLE
)paren
(brace
id|print_insn
(paren
id|host
comma
id|dsp
comma
l_string|&quot;s &quot;
comma
l_int|0
)paren
suffix:semicolon
id|ipl
op_assign
id|splx
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* XXX - should we do this, or can we get away with writing dsp? */
id|NCR53c7x0_write8
(paren
id|DCNTL_REG
comma
(paren
id|NCR53c7x0_read8
c_func
(paren
id|DCNTL_REG
)paren
op_amp
op_complement
id|DCNTL_SSM
)paren
op_or
id|DCNTL_STD
)paren
suffix:semicolon
id|splx
c_func
(paren
id|ipl
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : unexpected single step interrupt at&bslash;n&quot;
l_string|&quot;         &quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|dsp
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;         mail drew@colorad.edu&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * DSTAT_IID / DSTAT_OPC (same bit, same meaning, only the name &n;     * is different) is generated whenever an illegal instruction is &n;     * encountered.  &n;     * &n;     * XXX - we may want to emulate INTFLY here, so we can use &n;     *    the same SCSI SCRIPT (tm) for NCR53c710 through NCR53c810  &n;     *&t;  chips once we remove the ADD WITH CARRY instructions.&n;     */
r_if
c_cond
(paren
id|dstat
op_amp
id|DSTAT_OPC
)paren
(brace
multiline_comment|/* &n;     * Ascertain if this IID interrupts occurred before or after a STO &n;     * interrupt.  Since the interrupt handling code now leaves &n;     * DSP unmodified until _after_ all stacked interrupts have been&n;     * processed, reading the DSP returns the original DSP register.&n;     * This means that if dsp lies between the select code, and &n;     * message out following the selection code (where the IID interrupt&n;     * would have to have occurred by due to the implicit wait for REQ),&n;     * we have an IID interrupt resulting from a STO condition and &n;     * can ignore it.&n;     */
r_if
c_cond
(paren
(paren
(paren
id|dsp
op_ge
(paren
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_select
op_div
r_sizeof
(paren
r_int
)paren
)paren
)paren
op_logical_and
(paren
id|dsp
op_le
(paren
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_select_msgout
op_div
r_sizeof
(paren
r_int
)paren
op_plus
l_int|8
)paren
)paren
)paren
op_logical_or
(paren
id|hostdata-&gt;test_running
op_eq
l_int|2
)paren
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : ignoring DSTAT_IID for SSTAT_STO&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;expecting_iid
)paren
(brace
id|hostdata-&gt;expecting_iid
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;idle
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;test_running
op_eq
l_int|2
)paren
(brace
id|hostdata-&gt;test_running
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;test_completed
op_assign
l_int|3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd
)paren
id|abnormal_finished
(paren
id|cmd
comma
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
r_else
(brace
id|hostdata-&gt;expecting_sto
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : illegal instruction &quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|dsp
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : DSP=0x%lx, DCMD|DBC=0x%lx, DSA=0x%lx&bslash;n&quot;
l_string|&quot;         DSPS=0x%lx, TEMP=0x%lx, DMODE=0x%x,&bslash;n&quot;
l_string|&quot;&t; DNAD=0x%lx&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
r_int
)paren
id|dsp
comma
id|dbc_dcmd
comma
(paren
r_int
r_int
)paren
id|dsa
comma
id|NCR53c7x0_read32
c_func
(paren
id|DSPS_REG
)paren
comma
id|NCR53c7x0_read32
c_func
(paren
id|TEMP_REG
)paren
comma
(paren
r_int
)paren
id|NCR53c7x0_read8
c_func
(paren
id|hostdata-&gt;dmode
)paren
comma
id|NCR53c7x0_read32
c_func
(paren
id|DNAD_REG
)paren
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;         mail drew@Colorado.EDU&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;     * DSTAT_BF are bus fault errors, generated when the chip has &n;     * attempted to access an illegal address.&n;     */
r_if
c_cond
(paren
id|dstat
op_amp
id|DSTAT_800_BF
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : BUS FAULT, DSP=0x%lx, DCMD|DBC=0x%lx, DSA=0x%lx&bslash;n&quot;
l_string|&quot;         DSPS=0x%lx, TEMP=0x%lx, DMODE=0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
r_int
)paren
id|dsp
comma
id|NCR53c7x0_read32
c_func
(paren
id|DBC_REG
)paren
comma
(paren
r_int
r_int
)paren
id|dsa
comma
id|NCR53c7x0_read32
c_func
(paren
id|DSPS_REG
)paren
comma
id|NCR53c7x0_read32
c_func
(paren
id|TEMP_REG
)paren
comma
(paren
r_int
)paren
id|NCR53c7x0_read8
c_func
(paren
id|hostdata-&gt;dmode
)paren
)paren
suffix:semicolon
id|print_dsa
(paren
id|host
comma
id|dsa
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : DSP-&gt;&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_insn
c_func
(paren
id|host
comma
id|dsp
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|print_insn
c_func
(paren
id|host
comma
id|next_dsp
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
macro_line|#if 0
id|panic
c_func
(paren
l_string|&quot;          mail drew@Colorado.EDU&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|hostdata-&gt;idle
op_assign
l_int|1
suffix:semicolon
id|hostdata-&gt;options
op_or_assign
id|OPTION_DEBUG_INIT_ONLY
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* &n;     * DSTAT_SIR interrupts are generated by the execution of &n;     * the INT instruction.  Since the exact values available &n;     * are determined entirely by the SCSI script running, &n;     * and are local to a particular script, a unique handler&n;     * is called for each script.&n;     */
r_if
c_cond
(paren
id|dstat
op_amp
id|DSTAT_SIR
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : DSTAT_SIR&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|tmp
op_assign
id|hostdata-&gt;dstat_sir_intr
(paren
id|host
comma
id|cmd
)paren
)paren
)paren
(brace
r_case
id|SPECIFIC_INT_NOTHING
suffix:colon
r_case
id|SPECIFIC_INT_RESTART
suffix:colon
r_break
suffix:semicolon
r_case
id|SPECIFIC_INT_ABORT
suffix:colon
id|abort_connected
c_func
(paren
id|host
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SPECIFIC_INT_PANIC
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : failure at &quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|dsp
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;          dstat_sir_intr() returned SPECIFIC_INT_PANIC&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SPECIFIC_INT_BREAK
suffix:colon
id|intr_break
(paren
id|host
comma
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : failure at &quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|dsp
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;          dstat_sir_intr() returned unknown value %d&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* All DMA interrupts are fatal.  Flush SCSI queue */
id|NCR53c7x0_write8
(paren
id|STEST3_REG_800
comma
id|STEST3_800_CSF
)paren
suffix:semicolon
r_while
c_loop
(paren
id|NCR53c7x0_read8
(paren
id|STEST3_REG_800
)paren
op_amp
id|STEST3_800_CSF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : static int print_insn (struct Scsi_Host *host, &n; * &t;unsigned long *insn, int kernel)&n; *&n; * Purpose : print numeric representation of the instruction pointed&n; * &t;to by insn to the debugging or kernel message buffer&n; *&t;as appropriate.  &n; *&n; * &t;If desired, a user level program can interpret this &n; * &t;information.&n; *&n; * Inputs : host, insn - host, pointer to instruction, prefix - &n; *&t;string to prepend, kernel - use printk instead of debugging buffer.&n; *&n; * Returns : size, in longs, of instruction printed.&n; */
DECL|function|print_insn
r_static
r_int
id|print_insn
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_int
r_int
op_star
id|insn
comma
r_char
op_star
id|prefix
comma
r_int
id|kernel
)paren
(brace
r_char
id|buf
(braket
l_int|80
)braket
comma
multiline_comment|/* Temporary buffer and pointer */
op_star
id|tmp
suffix:semicolon
r_int
r_char
id|dcmd
suffix:semicolon
multiline_comment|/* dcmd register for *insn */
r_int
id|size
suffix:semicolon
id|dcmd
op_assign
(paren
id|insn
(braket
l_int|0
)braket
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s%08lx : 0x%08lx 0x%08lx&quot;
comma
(paren
id|prefix
ques
c_cond
id|prefix
suffix:colon
l_string|&quot;&quot;
)paren
comma
(paren
r_int
r_int
)paren
id|insn
comma
id|insn
(braket
l_int|0
)braket
comma
id|insn
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|tmp
op_assign
id|buf
op_plus
id|strlen
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dcmd
op_amp
id|DCMD_TYPE_MASK
)paren
op_eq
id|DCMD_TYPE_MMI
)paren
(brace
id|sprintf
(paren
id|tmp
comma
l_string|&quot; 0x%08lx&bslash;n&quot;
comma
id|insn
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|size
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|sprintf
(paren
id|tmp
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|size
op_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kernel
)paren
id|printk
(paren
l_string|&quot;%s&quot;
comma
id|buf
)paren
suffix:semicolon
macro_line|#ifdef NCR_DEBUG
r_else
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|buf
)paren
suffix:semicolon
id|debugger_kernel_write
c_func
(paren
id|host
comma
id|buf
comma
id|len
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : int NCR53c7xx_abort (Scsi_Cmnd *cmd)&n; * &n; * Purpose : Abort an errant SCSI command, doing all necessary&n; *&t;cleanup of the issue_queue, running_list, shared Linux/NCR&n; *&t;dsa issue and reconnect queues.&n; *&n; * Inputs : cmd - command to abort, code - entire result field&n; *&n; * Returns : 0 on success, -1 on failure.&n; */
DECL|function|NCR53c7xx_abort
r_int
id|NCR53c7xx_abort
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;host
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
id|old_level
suffix:semicolon
r_struct
id|NCR53c7x0_cmd
op_star
id|curr
comma
op_star
op_star
id|prev
suffix:semicolon
id|old_level
op_assign
id|splx
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n; * The command could be hiding in the issue_queue.  This would be very&n; * nice, as commands can&squot;t be moved from the high level driver&squot;s issue queue &n; * into the shared queue until an interrupt routine is serviced, and this&n; * moving is atomic.  &n; *&n; * If this is the case, we don&squot;t have to worry about anything - we simply&n; * pull the command out of the old queue, and call it aborted.&n; */
r_for
c_loop
(paren
id|curr
op_assign
id|hostdata-&gt;issue_queue
comma
id|prev
op_assign
op_amp
(paren
id|hostdata-&gt;issue_queue
)paren
suffix:semicolon
id|curr
op_logical_and
id|curr-&gt;cmd
op_ne
id|cmd
suffix:semicolon
id|prev
op_assign
op_amp
(paren
id|curr-&gt;next
)paren
comma
id|curr
op_assign
id|curr-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curr
)paren
(brace
op_star
id|prev
op_assign
id|curr-&gt;next
suffix:semicolon
multiline_comment|/* XXX - get rid of DLL ? */
r_if
c_cond
(paren
id|curr-&gt;prev
)paren
id|curr-&gt;prev-&gt;next
op_assign
id|curr-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scan_scsis_buf_busy
)paren
(brace
macro_line|#ifdef SCSI_MALLOC
id|scsi_free
(paren
(paren
r_void
op_star
)paren
id|curr-&gt;real
comma
id|curr-&gt;size
)paren
suffix:semicolon
macro_line|#else
id|kfree_s
(paren
(paren
r_void
op_star
)paren
id|curr-&gt;real
comma
id|curr-&gt;size
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|scan_scsis_buf_busy
op_assign
l_int|0
suffix:semicolon
)brace
id|cmd-&gt;result
op_assign
l_int|0
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
multiline_comment|/* &n; * That failing, the command could be in our list of already executing &n; * commands.  If this is the case, drastic measures are called for.  &n; */
r_for
c_loop
(paren
id|curr
op_assign
id|hostdata-&gt;running_list
comma
id|prev
op_assign
op_amp
(paren
id|hostdata-&gt;running_list
)paren
suffix:semicolon
id|curr
op_logical_and
id|curr-&gt;cmd
op_ne
id|cmd
suffix:semicolon
id|prev
op_assign
op_amp
(paren
id|curr-&gt;next
)paren
comma
id|curr
op_assign
id|curr-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curr
)paren
(brace
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : DANGER : command in running list, can not abort.&bslash;n&quot;
comma
id|cmd-&gt;host-&gt;host_no
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
multiline_comment|/* &n; * And if we couldn&squot;t find it in any of our queues, it must have been &n; * a dropped interrupt.&n; */
id|curr
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scan_scsis_buf_busy
)paren
(brace
macro_line|#ifdef SCSI_MALLOC
id|scsi_free
(paren
(paren
r_void
op_star
)paren
id|curr-&gt;real
comma
id|curr-&gt;size
)paren
suffix:semicolon
macro_line|#else
id|kfree_s
(paren
(paren
r_void
op_star
)paren
id|curr-&gt;real
comma
id|curr-&gt;size
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|scan_scsis_buf_busy
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|cmd-&gt;result
op_amp
l_int|0xff00
)paren
op_eq
l_int|0xff00
)paren
op_logical_or
(paren
(paren
id|cmd-&gt;result
op_amp
l_int|0xff
)paren
op_eq
l_int|0xff
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : did this command ever run?&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;scsi%d : probably lost INTFLY, normal completion&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
)brace
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|splx
c_func
(paren
id|old_level
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : int NCR53c7xx_reset (Scsi_Cmnd *cmd) &n; * &n; * Purpose : perform a hard reset of the SCSI bus and NCR&n; * &t;chip.&n; *&n; * Inputs : cmd - command which caused the SCSI RESET&n; *&n; * Returns : 0 on success.&n; */
DECL|function|NCR53c7xx_reset
r_int
id|NCR53c7xx_reset
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd
ques
c_cond
id|cmd-&gt;host
suffix:colon
l_int|NULL
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
id|host
ques
c_cond
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:colon
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|host
)paren
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : DANGER : NCR53c7xx_reset is NOP&bslash;n&quot;
comma
id|cmd-&gt;host-&gt;host_no
)paren
suffix:semicolon
r_return
id|SCSI_RESET_SNOOZE
suffix:semicolon
)brace
multiline_comment|/*&n; * The NCR SDMS bios follows Annex A of the SCSI-CAM draft, and &n; * therefore shares the scsicam_bios_param function.&n; */
DECL|function|print_dsa
r_static
r_void
id|print_dsa
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_int
r_int
op_star
id|dsa
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_struct
id|NCR53c7x0_cmd
op_star
id|c
suffix:semicolon
r_int
id|i
comma
id|len
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : dsa at 0x%x&bslash;n&quot;
l_string|&quot;        + %d : dsa_msgout length = %d, data = 0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
)paren
id|dsa
comma
id|hostdata-&gt;dsa_msgout
comma
id|dsa
(braket
id|hostdata-&gt;dsa_msgout
op_div
r_sizeof
(paren
r_int
)paren
)braket
comma
id|dsa
(braket
id|hostdata-&gt;dsa_msgout
op_div
r_sizeof
(paren
r_int
)paren
op_plus
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|dsa
(braket
id|hostdata-&gt;dsa_msgout
op_div
r_sizeof
(paren
r_int
)paren
)braket
comma
id|ptr
op_assign
(paren
r_char
op_star
)paren
id|dsa
(braket
id|hostdata-&gt;dsa_msgout
op_div
r_sizeof
(paren
r_int
)paren
op_plus
l_int|1
)braket
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|ptr
op_add_assign
id|len
comma
id|i
op_sub_assign
id|len
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;               &quot;
)paren
suffix:semicolon
id|len
op_assign
id|print_msg
(paren
id|ptr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
eof
