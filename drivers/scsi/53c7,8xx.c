multiline_comment|/*&n; * PERM_OPTIONS are driver options which will be enabled for all NCR boards&n; * in the system at driver initialization time.&n; *&n; * Don&squot;t THINK about touching these in PERM_OPTIONS : &n; *   OPTION_IO_MAPPED &n; * &t;Memory mapped IO does not work under i86 Linux. &n; *&n; *   OPTION_DEBUG_TEST1&n; *&t;Test 1 does bus mastering and interrupt tests, which will help weed &n; *&t;out brain damaged main boards.&n; *&n; * These are development kernel changes.  Code for them included in this&n; * driver release may or may not work.  If you turn them on, you should be &n; * running the latest copy of the development sources from&n; *&n; *&t;ftp://tsx-11.mit.edu/pub/linux/ALPHA/scsi/53c7,8xx&n; *&n; * and be subscribed to the ncr53c810@colorado.edu mailing list.  To&n; * subscribe, send mail to majordomo@colorado.edu with &n; *&n; * &t;subscribe ncr53c810&n; * &n; * in the text.&n; *&n; *&n; *   OPTION_NO_ASYNC&n; *&t;Don&squot;t negotiate for asynchronous transfers on the first command &n; *&t;when OPTION_ALWAYS_SYNCHRONOUS is set.  Useful for dain bramaged&n; *&t;devices which do something bad rather than sending a MESSAGE &n; *&t;REJECT back to us like they should if they can&squot;t cope.&n; *&n; *   OPTION_SYNCHRONOUS&n; *&t;Enable support for synchronous transfers.  Target negotiated &n; *&t;synchronous transfers will be responded to.  To initiate &n; *&t;a synchronous transfer request,  call &n; *&n; *&t;    request_synchronous (hostno, target) &n; *&n; *&t;from within KGDB.&n; *&n; *   OPTION_ALWAYS_SYNCHRONOUS&n; *&t;Negotiate for synchronous transfers with every target after&n; *&t;driver initialization or a SCSI bus reset.  This is a bit dangerous, &n; *&t;since there are some dain bramaged SCSI devices which will accept&n; *&t;SDTR messages but keep talking asynchronously.&n; *&n; *   OPTION_DISCONNECT&n; *&t;Enable support for disconnect/reconnect.  To change the &n; *&t;default setting on a given host adapter, call&n; *&n; *&t;    request_disconnect (hostno, allow)&n; *&n; *&t;where allow is non-zero to allow, 0 to disallow.&n; * &n; *  If you really want to run 10MHz FAST SCSI-II transfers, you should &n; *  know that the NCR driver currently ignores parity information.  Most&n; *  systems do 5MHz SCSI fine.  I&squot;ve seen a lot that have problems faster&n; *  than 8MHz.  To play it safe, we only request 5MHz transfers.&n; *&n; *  If you&squot;d rather get 10MHz transfers, edit sdtr_message and change &n; *  the fourth byte from 50 to 25.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef CONFIG_SCSI_NCR53C7xx_sync
macro_line|#ifdef CONFIG_SCSI_NCR53C7xx_DISCONNECT
DECL|macro|PERM_OPTIONS
mdefine_line|#define PERM_OPTIONS (OPTION_IO_MAPPED|OPTION_DEBUG_TEST1|OPTION_DISCONNECT|&bslash;&n;&t;OPTION_SYNCHRONOUS|OPTION_ALWAYS_SYNCHRONOUS)
macro_line|#else
DECL|macro|PERM_OPTIONS
mdefine_line|#define PERM_OPTIONS (OPTION_IO_MAPPED|OPTION_DEBUG_TEST1|&bslash;&n;&t;OPTION_SYNCHRONOUS|OPTION_ALWAYS_SYNCHRONOUS)
macro_line|#endif
macro_line|#else
macro_line|#ifdef CONFIG_SCSI_NCR53C7xx_DISCONNECT
DECL|macro|PERM_OPTIONS
mdefine_line|#define PERM_OPTIONS (OPTION_IO_MAPPED|OPTION_DEBUG_TEST1|OPTION_DISCONNECT|&bslash;&n;&t;OPTION_SYNCHRONOUS)
macro_line|#else
DECL|macro|PERM_OPTIONS
mdefine_line|#define PERM_OPTIONS (OPTION_IO_MAPPED|OPTION_DEBUG_TEST1|OPTION_SYNCHRONOUS)
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n; * Sponsored by &n; *&t;iX Multiuser Multitasking Magazine&n; *&t;Hannover, Germany&n; *&t;hm@ix.de&n; *&n; * Copyright 1993, 1994, 1995 Drew Eckhardt&n; *      Visionary Computing &n; *      (Unix and Linux consulting and custom programming)&n; *      drew@PoohSticks.ORG&n; *&t;+1 (303) 786-7975&n; *&n; * TolerANT and SCSI SCRIPTS are registered trademarks of NCR Corporation.&n; * &n; * For more information, please consult &n; *&n; * NCR53C810 &n; * SCSI I/O Processor&n; * Programmer&squot;s Guide&n; *&n; * NCR 53C810&n; * PCI-SCSI I/O Processor&n; * Data Manual&n; *&n; * NCR 53C810/53C820&n; * PCI-SCSI I/O Processor Design In Guide&n; *&n; * For literature on Symbios Logic Inc. formerly NCR, SCSI, &n; * and Communication products please call (800) 334-5454 or&n; * (719) 536-3300. &n; * &n; * PCI BIOS Specification Revision&n; * PCI Local Bus Specification&n; * PCI System Design Guide&n; *&n; * PCI Special Interest Group&n; * M/S HF3-15A&n; * 5200 N.E. Elam Young Parkway&n; * Hillsboro, Oregon 97124-6497&n; * +1 (503) 696-2000 &n; * +1 (800) 433-5177&n; */
multiline_comment|/*&n; * Design issues : &n; * The cumulative latency needed to propagate a read/write request &n; * through the file system, buffer cache, driver stacks, SCSI host, and &n; * SCSI device is ultimately the limiting factor in throughput once we &n; * have a sufficiently fast host adapter.&n; *  &n; * So, to maximize performance we want to keep the ratio of latency to data &n; * transfer time to a minimum by&n; * 1.  Minimizing the total number of commands sent (typical command latency&n; *&t;including drive and bus mastering host overhead is as high as 4.5ms)&n; *&t;to transfer a given amount of data.  &n; *&n; *      This is accomplished by placing no arbitrary limit on the number&n; *&t;of scatter/gather buffers supported, since we can transfer 1K&n; *&t;per scatter/gather buffer without Eric&squot;s cluster patches, &n; *&t;4K with.  &n; *&n; * 2.  Minimizing the number of fatal interrupts serviced, since&n; * &t;fatal interrupts halt the SCSI I/O processor.  Basically,&n; *&t;this means offloading the practical maximum amount of processing &n; *&t;to the SCSI chip.&n; * &n; *&t;On the NCR53c810/820/720,  this is accomplished by using &n; *&t;&t;interrupt-on-the-fly signals when commands complete, &n; *&t;&t;and only handling fatal errors and SDTR / WDTR &t;messages &n; *&t;&t;in the host code.&n; *&n; *&t;On the NCR53c710, interrupts are generated as on the NCR53c8x0,&n; *&t;&t;only the lack of an interrupt-on-the-fly facility complicates&n; *&t;&t;things.   Also, SCSI ID registers and commands are &n; *&t;&t;bit fielded rather than binary encoded.&n; *&t;&t;&n; * &t;On the NCR53c700 and NCR53c700-66, operations that are done via &n; *&t;&t;indirect, table mode on the more advanced chips must be&n; *&t;        replaced by calls through a jump table which &n; *&t;&t;acts as a surrogate for the DSA.  Unfortunately, this &n; * &t;&t;will mean that we must service an interrupt for each &n; *&t;&t;disconnect/reconnect.&n; * &n; * 3.  Eliminating latency by pipelining operations at the different levels.&n; * &t;&n; *&t;This driver allows a configurable number of commands to be enqueued&n; *&t;for each target/lun combination (experimentally, I have discovered&n; *&t;that two seems to work best) and will ultimately allow for &n; *&t;SCSI-II tagged queuing.&n; * &t;&n; *&n; * Architecture : &n; * This driver is built around a Linux queue of commands waiting to &n; * be executed, and a shared Linux/NCR array of commands to start.  Commands&n; * are transfered to the array  by the run_process_issue_queue() function &n; * which is called whenever a command completes.&n; *&n; * As commands are completed, the interrupt routine is triggered,&n; * looks for commands in the linked list of completed commands with&n; * valid status, removes these commands from a list of running commands, &n; * calls the done routine, and flags their target/luns as not busy.&n; *&n; * Due to limitations in the intelligence of the NCR chips, certain&n; * concessions are made.  In many cases, it is easier to dynamically &n; * generate/fix-up code rather than calculate on the NCR at run time.  &n; * So, code is generated or fixed up for&n; *&n; * - Handling data transfers, using a variable number of MOVE instructions&n; *&t;interspersed with CALL MSG_IN, WHEN MSGIN instructions.&n; *&n; * &t;The DATAIN and DATAOUT routines&t;are separate, so that an incorrect&n; *&t;direction can be trapped, and space isn&squot;t wasted. &n; *&n; *&t;It may turn out that we&squot;re better off using some sort &n; *&t;of table indirect instruction in a loop with a variable&n; *&t;sized table on the NCR53c710 and newer chips.&n; *&n; * - Checking for reselection (NCR53c710 and better)&n; *&n; * - Handling the details of SCSI context switches (NCR53c710 and better),&n; *&t;such as reprogramming appropriate synchronous parameters, &n; *&t;removing the dsa structure from the NCR&squot;s queue of outstanding&n; *&t;commands, etc.&n; *&n; */
multiline_comment|/* &n; * Accommodate differences between stock 1.2.x and 1.3.x asm-i386/types.h&n; * so lusers can drop in 53c7,8xx.* and get something which compiles &n; * without warnings.&n; */
macro_line|#include &lt;linux/version.h&gt;
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;53c7,8xx.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
r_static
r_int
id|check_address
(paren
r_int
r_int
id|addr
comma
r_int
id|size
)paren
suffix:semicolon
r_static
r_void
id|dump_events
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_int
id|count
)paren
suffix:semicolon
r_static
id|Scsi_Cmnd
op_star
id|return_outstanding_commands
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_int
id|free
comma
r_int
id|issue
)paren
suffix:semicolon
r_static
r_void
id|hard_reset
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
suffix:semicolon
r_static
r_void
id|ncr_scsi_reset
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
suffix:semicolon
r_static
r_void
id|print_lots
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
suffix:semicolon
r_static
r_void
id|set_synchronous
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_int
id|target
comma
r_int
id|sxfer
comma
r_int
id|scntl3
comma
r_int
id|now_connected
)paren
suffix:semicolon
r_static
r_int
id|datapath_residual
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
suffix:semicolon
r_static
r_const
r_char
op_star
id|sbcl_to_phase
(paren
r_int
id|sbcl
)paren
suffix:semicolon
r_static
r_void
id|print_progress
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|print_queues
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
suffix:semicolon
r_static
r_void
id|process_issue_queue
(paren
r_int
r_int
id|flags
)paren
suffix:semicolon
r_static
r_int
id|shutdown
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
suffix:semicolon
r_static
r_void
id|abnormal_finished
(paren
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
comma
r_int
id|result
)paren
suffix:semicolon
r_static
r_int
id|disable
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
suffix:semicolon
r_static
r_int
id|NCR53c8xx_run_tests
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
suffix:semicolon
DECL|variable|NCR53c8xx_script_len
r_static
r_int
id|NCR53c8xx_script_len
suffix:semicolon
DECL|variable|NCR53c8xx_dsa_len
r_static
r_int
id|NCR53c8xx_dsa_len
suffix:semicolon
r_static
r_void
id|NCR53c7x0_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|do_NCR53c7x0_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|ncr_halt
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
suffix:semicolon
r_static
r_void
id|intr_phase_mismatch
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|intr_dma
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|print_dsa
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
id|u32
op_star
id|dsa
comma
r_const
r_char
op_star
id|prefix
)paren
suffix:semicolon
r_static
r_int
id|print_insn
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_const
id|u32
op_star
id|insn
comma
r_const
r_char
op_star
id|prefix
comma
r_int
id|kernel
)paren
suffix:semicolon
r_static
r_void
id|NCR53c8xx_dsa_fixup
(paren
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|NCR53c8x0_init_fixup
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
suffix:semicolon
r_static
r_int
id|NCR53c8x0_dstat_sir_intr
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|NCR53c8x0_soft_reset
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
suffix:semicolon
multiline_comment|/* INSMOD variables */
DECL|variable|perm_options
r_static
r_int
r_int
id|perm_options
op_assign
id|PERM_OPTIONS
suffix:semicolon
multiline_comment|/* 14 = .5s; 15 is max; decreasing divides by two. */
DECL|variable|selection_timeout
r_static
r_int
id|selection_timeout
op_assign
l_int|14
suffix:semicolon
multiline_comment|/* Size of event list (per host adapter) */
DECL|variable|track_events
r_static
r_int
id|track_events
op_assign
l_int|0
suffix:semicolon
DECL|variable|first_host
r_static
r_struct
id|Scsi_Host
op_star
id|first_host
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Head of list of NCR boards */
DECL|variable|the_template
r_static
id|Scsi_Host_Template
op_star
id|the_template
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * KNOWN BUGS :&n; * - There is some sort of conflict when the PPP driver is compiled with &n; * &t;support for 16 channels?&n; * &n; * - On systems which predate the 1.3.x initialization order change,&n; *      the NCR driver will cause Cannot get free page messages to appear.  &n; *      These are harmless, but I don&squot;t know of an easy way to avoid them.&n; *&n; * - With OPTION_DISCONNECT, on two systems under unknown circumstances,&n; *&t;we get a PHASE MISMATCH with DSA set to zero (suggests that we &n; *&t;are occurring somewhere in the reselection code) where &n; *&t;DSP=some value DCMD|DBC=same value.  &n; * &t;&n; *&t;Closer inspection suggests that we may be trying to execute&n; *&t;some portion of the DSA?&n; * scsi0 : handling residual transfer (+ 0 bytes from DMA FIFO)&n; * scsi0 : handling residual transfer (+ 0 bytes from DMA FIFO)&n; * scsi0 : no current command : unexpected phase MSGIN.&n; *         DSP=0x1c46cc, DCMD|DBC=0x1c46ac, DSA=0x0&n; *         DSPS=0x0, TEMP=0x1c3e70, DMODE=0x80&n; * scsi0 : DSP-&gt;&n; * 001c46cc : 0x001c46cc 0x00000000&n; * 001c46d4 : 0x001c5ea0 0x000011f8&n; *&n; *&t;Changed the print code in the phase_mismatch handler so&n; *&t;that we call print_lots to try to diagnose this.&n; *&n; */
multiline_comment|/* &n; * Possible future direction of architecture for max performance :&n; *&n; * We&squot;re using a single start array for the NCR chip.  This is &n; * sub-optimal, because we cannot add a command which would conflict with &n; * an executing command to this start queue, and therefore must insert the &n; * next command for a given I/T/L combination after the first has completed;&n; * incurring our interrupt latency between SCSI commands.&n; *&n; * To allow further pipelining of the NCR and host CPU operation, we want &n; * to set things up so that immediately on termination of a command destined &n; * for a given LUN, we get that LUN busy again.  &n; * &n; * To do this, we need to add a 32 bit pointer to which is jumped to &n; * on completion of a command.  If no new command is available, this &n; * would point to the usual DSA issue queue select routine.&n; *&n; * If one were, it would point to a per-NCR53c7x0_cmd select routine &n; * which starts execution immediately, inserting the command at the head &n; * of the start queue if the NCR chip is selected or reselected.&n; *&n; * We would change so that we keep a list of outstanding commands &n; * for each unit, rather than a single running_list.  We&squot;d insert &n; * a new command into the right running list; if the NCR didn&squot;t &n; * have something running for that yet, we&squot;d put it in the &n; * start queue as well.  Some magic needs to happen to handle the &n; * race condition between the first command terminating before the &n; * new one is written.&n; *&n; * Potential for profiling : &n; * Call do_gettimeofday(struct timeval *tv) to get 800ns resolution.&n; */
multiline_comment|/*&n; * TODO : &n; * 1.  To support WIDE transfers, not much needs to happen.  We&n; *&t;should do CHMOVE instructions instead of MOVEs when&n; *&t;we have scatter/gather segments of uneven length.  When&n; * &t;we do this, we need to handle the case where we disconnect&n; *&t;between segments.&n; * &n; * 2.  Currently, when Icky things happen we do a FATAL().  Instead,&n; *     we want to do an integrity check on the parts of the NCR hostdata&n; *     structure which were initialized at boot time; FATAL() if that &n; *     fails, and otherwise try to recover.  Keep track of how many&n; *     times this has happened within a single SCSI command; if it &n; *     gets excessive, then FATAL().&n; *&n; * 3.  Parity checking is currently disabled, and a few things should &n; *     happen here now that we support synchronous SCSI transfers :&n; *     1.  On soft-reset, we should set the EPC (Enable Parity Checking)&n; *&t;   and AAP (Assert SATN/ on parity error) bits in SCNTL0.&n; *&t;&n; *     2.  We should enable the parity interrupt in the SIEN0 register.&n; * &n; *     3.  intr_phase_mismatch() needs to believe that message out is &n; *&t;   always an &quot;acceptable&quot; phase to have a mismatch in.  If &n; *&t;   the old phase was MSG_IN, we should send a MESSAGE PARITY &n; *&t;   error.  If the old phase was something else, we should send&n; *&t;   a INITIATOR_DETECTED_ERROR message.  Note that this could&n; *&t;   cause a RESTORE POINTERS message; so we should handle that &n; *&t;   correctly first.  Instead, we should probably do an &n; *&t;   initiator_abort.&n; *&n; * 4.  MPEE bit of CTEST4 should be set so we get interrupted if &n; *     we detect an error.&n; *&n; *  &n; * 5.  The initial code has been tested on the NCR53c810.  I don&squot;t &n; *     have access to NCR53c700, 700-66 (Forex boards), NCR53c710&n; *     (NCR Pentium systems), NCR53c720, NCR53c820, or NCR53c825 boards to &n; *     finish development on those platforms.&n; *&n; *     NCR53c820/825/720 - need to add wide transfer support, including WDTR &n; *     &t;&t;negotiation, programming of wide transfer capabilities&n; *&t;&t;on reselection and table indirect selection.&n; *&n; *     NCR53c710 - need to add fatal interrupt or GEN code for &n; *&t;&t;command completion signaling.   Need to modify all &n; *&t;&t;SDID, SCID, etc. registers, and table indirect select code &n; *&t;&t;since these use bit fielded (ie 1&lt;&lt;target) instead of &n; *&t;&t;binary encoded target ids.  Need to accommodate&n; *&t;&t;different register mappings, probably scan through&n; *&t;&t;the SCRIPT code and change the non SFBR register operand&n; *&t;&t;of all MOVE instructions.&n; * &n; *     NCR53c700/700-66 - need to add code to refix addresses on &n; *&t;&t;every nexus change, eliminate all table indirect code,&n; *&t;&t;very messy.&n; *&n; * 6.  The NCR53c7x0 series is very popular on other platforms that &n; *     could be running Linux - ie, some high performance AMIGA SCSI &n; *     boards use it.  &n; *&t;&n; *     So, I should include #ifdef&squot;d code so that it is &n; *     compatible with these systems.&n; *&t;&n; *     Specifically, the little Endian assumptions I made in my &n; *     bit fields need to change, and if the NCR doesn&squot;t see memory&n; *     the right way, we need to provide options to reverse words&n; *     when the scripts are relocated.&n; *&n; * 7.  Use ioremap() to access memory mapped boards.  &n; */
multiline_comment|/* &n; * Allow for simultaneous existence of multiple SCSI scripts so we &n; * can have a single driver binary for all of the family.&n; *&n; * - one for NCR53c700 and NCR53c700-66 chips&t;(not yet supported)&n; * - one for rest (only the NCR53c810, 815, 820, and 825 are currently &n; *&t;supported)&n; * &n; * So that we only need two SCSI scripts, we need to modify things so&n; * that we fixup register accesses in READ/WRITE instructions, and &n; * we&squot;ll also have to accommodate the bit vs. binary encoding of IDs&n; * with the 7xx chips.&n; */
multiline_comment|/*&n; * Use pci_chips_ids to translate in both directions between PCI device ID &n; * and chip numbers.  &n; */
r_static
r_struct
(brace
DECL|member|pci_device_id
r_int
r_int
id|pci_device_id
suffix:semicolon
DECL|member|chip
r_int
id|chip
suffix:semicolon
multiline_comment|/* &n; * The revision field of the PCI_CLASS_REVISION register is compared &n; * against each of these fields if the field is not -1.  If it&n; * is less than min_revision or larger than max_revision, a warning&n; * message is printed.&n; */
DECL|member|max_revision
r_int
id|max_revision
suffix:semicolon
DECL|member|min_revision
r_int
id|min_revision
suffix:semicolon
DECL|variable|pci_chip_ids
)brace
id|pci_chip_ids
(braket
)braket
op_assign
(brace
(brace
id|PCI_DEVICE_ID_NCR_53C810
comma
l_int|810
comma
l_int|2
comma
l_int|1
)brace
comma
(brace
id|PCI_DEVICE_ID_NCR_53C815
comma
l_int|815
comma
l_int|3
comma
l_int|2
)brace
comma
(brace
id|PCI_DEVICE_ID_NCR_53C820
comma
l_int|820
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
(brace
id|PCI_DEVICE_ID_NCR_53C825
comma
l_int|825
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
)brace
suffix:semicolon
DECL|macro|NPCI_CHIP_IDS
mdefine_line|#define NPCI_CHIP_IDS (sizeof (pci_chip_ids) / sizeof(pci_chip_ids[0]))
DECL|macro|ROUNDUP
mdefine_line|#define ROUNDUP(adr,type)&t;&bslash;&n;  ((void *) (((long) (adr) + sizeof(type) - 1) &amp; ~(sizeof(type) - 1)))
multiline_comment|/* &n; * Forced detection and autoprobe code for various hardware.  Currently, &n; * entry points for these are not included in init/main.c because if the &n; * PCI BIOS code isn&squot;t working right, you&squot;re not going to be able to use &n; * the hardware anyways; this way we force users to solve their &n; * problems rather than forcing detection and blaming us when it &n; * does not work.&n; */
DECL|struct|override
r_static
r_struct
id|override
(brace
DECL|member|chip
r_int
id|chip
suffix:semicolon
multiline_comment|/* 700, 70066, 710, 720, 810, 820 */
DECL|member|board
r_int
id|board
suffix:semicolon
multiline_comment|/* Any special board level gunk */
DECL|member|pci
r_int
id|pci
suffix:colon
l_int|1
suffix:semicolon
r_union
(brace
r_struct
(brace
DECL|member|base
r_int
id|base
suffix:semicolon
multiline_comment|/* Memory address - indicates memory mapped regs */
DECL|member|io_port
r_int
id|io_port
suffix:semicolon
multiline_comment|/* I/O port address - indicates I/O mapped regs */
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* IRQ line */
DECL|member|dma
r_int
id|dma
suffix:semicolon
multiline_comment|/* DMA channel &t;&t;- often none */
DECL|member|normal
)brace
id|normal
suffix:semicolon
r_struct
(brace
DECL|member|bus
r_int
id|bus
suffix:semicolon
DECL|member|device
r_int
id|device
suffix:semicolon
DECL|member|function
r_int
id|function
suffix:semicolon
DECL|member|pci
)brace
id|pci
suffix:semicolon
DECL|member|data
)brace
id|data
suffix:semicolon
DECL|member|options
r_int
r_int
id|options
suffix:semicolon
DECL|variable|overrides
)brace
id|overrides
(braket
l_int|4
)braket
op_assign
(brace
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
DECL|variable|commandline_current
r_static
r_int
id|commandline_current
op_assign
l_int|0
suffix:semicolon
DECL|variable|no_overrides
r_static
r_int
id|no_overrides
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
DECL|macro|OVERRIDE_LIMIT
mdefine_line|#define OVERRIDE_LIMIT (sizeof(overrides) / sizeof(struct override))
macro_line|#else
DECL|macro|OVERRIDE_LIMIT
mdefine_line|#define OVERRIDE_LIMIT commandline_current
macro_line|#endif
multiline_comment|/*&n; * Function: issue_to_cmd&n; *&n; * Purpose: convert jump instruction in issue array to NCR53c7x0_cmd&n; *&t;structure pointer.  &n; *&n; * Inputs; issue - pointer to start of NOP or JUMP instruction&n; *&t;in issue array.&n; *&n; * Returns: pointer to command on success; 0 if opcode is NOP.&n; */
r_static
r_inline
r_struct
id|NCR53c7x0_cmd
op_star
DECL|function|issue_to_cmd
id|issue_to_cmd
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
comma
id|u32
op_star
id|issue
)paren
(brace
r_return
(paren
id|issue
(braket
l_int|0
)braket
op_ne
id|hostdata-&gt;NOP_insn
)paren
ques
c_cond
multiline_comment|/* &n;     * If the IF TRUE bit is set, it&squot;s a JUMP instruction.  The&n;     * operand is a bus pointer to the dsa_begin routine for this DSA.  The&n;     * dsa field of the NCR53c7x0_cmd structure starts with the &n;     * DSA code template.  By converting to a virtual address,&n;     * subtracting the code template size, and offset of the &n;     * dsa field, we end up with a pointer to the start of the &n;     * structure (alternatively, we could use the &n;     * dsa_cmnd field, an anachronism from when we weren&squot;t&n;     * sure what the relationship between the NCR structures&n;     * and host structures were going to be.&n;     */
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|bus_to_virt
(paren
id|le32_to_cpu
c_func
(paren
id|issue
(braket
l_int|1
)braket
)paren
)paren
op_minus
(paren
id|hostdata-&gt;E_dsa_code_begin
op_minus
id|hostdata-&gt;E_dsa_code_template
)paren
op_minus
m_offsetof
(paren
r_struct
id|NCR53c7x0_cmd
comma
id|dsa
)paren
)paren
multiline_comment|/* If the IF TRUE bit is not set, it&squot;s a NOP */
suffix:colon
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : static internal_setup(int board, int chip, char *str, int *ints)&n; *&n; * Purpose : LILO command line initialization of the overrides array,&n; * &n; * Inputs : board - currently, unsupported.  chip - 700, 70066, 710, 720&n; * &t;810, 815, 820, 825, although currently only the NCR53c810 is &n; *&t;supported.&n; * &n; */
r_static
r_void
DECL|function|internal_setup
id|internal_setup
c_func
(paren
r_int
id|board
comma
r_int
id|chip
comma
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_int
r_char
id|pci
suffix:semicolon
multiline_comment|/* Specifies a PCI override, with bus, device,&n;&t;&t;&t;&t;   function */
id|pci
op_assign
(paren
id|str
op_logical_and
op_logical_neg
id|strcmp
(paren
id|str
comma
l_string|&quot;pci&quot;
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Override syntaxes are as follows : &n; * ncr53c700,ncr53c700-66,ncr53c710,ncr53c720=mem,io,irq,dma&n; * ncr53c810,ncr53c820,ncr53c825=mem,io,irq or pci,bus,device,function&n; */
r_if
c_cond
(paren
id|commandline_current
OL
id|OVERRIDE_LIMIT
)paren
(brace
id|overrides
(braket
id|commandline_current
)braket
dot
id|pci
op_assign
id|pci
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci
)paren
(brace
id|overrides
(braket
id|commandline_current
)braket
dot
id|data.normal.base
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
id|overrides
(braket
id|commandline_current
)braket
dot
id|data.normal.io_port
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
id|overrides
(braket
id|commandline_current
)braket
dot
id|data.normal.irq
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
id|overrides
(braket
id|commandline_current
)braket
dot
id|data.normal.dma
op_assign
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|4
)paren
ques
c_cond
id|ints
(braket
l_int|4
)braket
suffix:colon
id|DMA_NONE
suffix:semicolon
multiline_comment|/* FIXME: options is now a long long */
id|overrides
(braket
id|commandline_current
)braket
dot
id|options
op_assign
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|5
)paren
ques
c_cond
id|ints
(braket
l_int|5
)braket
suffix:colon
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|overrides
(braket
id|commandline_current
)braket
dot
id|data.pci.bus
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
id|overrides
(braket
id|commandline_current
)braket
dot
id|data.pci.device
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
id|overrides
(braket
id|commandline_current
)braket
dot
id|data.pci.function
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* FIXME: options is now a long long */
id|overrides
(braket
id|commandline_current
)braket
dot
id|options
op_assign
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|4
)paren
ques
c_cond
id|ints
(braket
l_int|4
)braket
suffix:colon
l_int|0
suffix:semicolon
)brace
id|overrides
(braket
id|commandline_current
)braket
dot
id|board
op_assign
id|board
suffix:semicolon
id|overrides
(braket
id|commandline_current
)braket
dot
id|chip
op_assign
id|chip
suffix:semicolon
op_increment
id|commandline_current
suffix:semicolon
op_increment
id|no_overrides
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;53c7,7x0.c:internal_setup() : too many overrides&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * XXX - we might want to implement a single override function&n; *       with a chip type field, revamp the command line configuration,&n; * &t; etc.&n; */
DECL|macro|setup_wrapper
mdefine_line|#define setup_wrapper(x) &t;&t;&t;&t;&bslash;&n;void ncr53c##x##_setup (char *str, int *ints) {&t;&t;&bslash;&n;    internal_setup (BOARD_GENERIC, x, str, ints);&t;&bslash;&n;}
id|setup_wrapper
c_func
(paren
l_int|700
)paren
id|setup_wrapper
c_func
(paren
l_int|70066
)paren
id|setup_wrapper
c_func
(paren
l_int|710
)paren
id|setup_wrapper
c_func
(paren
l_int|720
)paren
id|setup_wrapper
c_func
(paren
l_int|810
)paren
id|setup_wrapper
c_func
(paren
l_int|815
)paren
id|setup_wrapper
c_func
(paren
l_int|820
)paren
id|setup_wrapper
c_func
(paren
l_int|825
)paren
multiline_comment|/* &n; * FIXME: we should junk these, in favor of synchronous_want and &n; * wide_want in the NCR53c7x0_hostdata structure.&n; */
multiline_comment|/* Template for &quot;preferred&quot; synchronous transfer parameters. */
DECL|variable|sdtr_message
r_static
r_const
r_int
r_char
id|sdtr_message
(braket
)braket
op_assign
(brace
macro_line|#ifdef CONFIG_SCSI_NCR53C7xx_FAST
id|EXTENDED_MESSAGE
comma
l_int|3
multiline_comment|/* length */
comma
id|EXTENDED_SDTR
comma
l_int|25
multiline_comment|/* *4ns */
comma
l_int|8
multiline_comment|/* off */
macro_line|#else
id|EXTENDED_MESSAGE
comma
l_int|3
multiline_comment|/* length */
comma
id|EXTENDED_SDTR
comma
l_int|50
multiline_comment|/* *4ns */
comma
l_int|8
multiline_comment|/* off */
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* Template to request asynchronous transfers */
DECL|variable|async_message
r_static
r_const
r_int
r_char
id|async_message
(braket
)braket
op_assign
(brace
id|EXTENDED_MESSAGE
comma
l_int|3
multiline_comment|/* length */
comma
id|EXTENDED_SDTR
comma
l_int|0
comma
l_int|0
multiline_comment|/* asynchronous */
)brace
suffix:semicolon
multiline_comment|/* Template for &quot;preferred&quot; WIDE transfer parameters */
DECL|variable|wdtr_message
r_static
r_const
r_int
r_char
id|wdtr_message
(braket
)braket
op_assign
(brace
id|EXTENDED_MESSAGE
comma
l_int|2
multiline_comment|/* length */
comma
id|EXTENDED_WDTR
comma
l_int|1
multiline_comment|/* 2^1 bytes */
)brace
suffix:semicolon
multiline_comment|/*&n; * Function : struct Scsi_Host *find_host (int host)&n; * &n; * Purpose : KGDB support function which translates a host number &n; * &t;to a host structure. &n; *&n; * Inputs : host - number of SCSI host&n; *&n; * Returns : NULL on failure, pointer to host structure on success.&n; */
macro_line|#if 0
r_static
r_struct
id|Scsi_Host
op_star
DECL|function|find_host
id|find_host
(paren
r_int
id|host
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|h
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
id|first_host
suffix:semicolon
id|h
op_logical_and
id|h-&gt;host_no
op_ne
id|host
suffix:semicolon
id|h
op_assign
id|h-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
(brace
id|printk
(paren
id|KERN_ALERT
l_string|&quot;scsi%d not found&bslash;n&quot;
comma
id|host
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|h-&gt;hostt
op_ne
id|the_template
)paren
(brace
id|printk
(paren
id|KERN_ALERT
l_string|&quot;scsi%d is not a NCR board&bslash;n&quot;
comma
id|host
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|h
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : request_synchronous (int host, int target)&n; * &n; * Purpose : KGDB interface which will allow us to negotiate for &n; * &t;synchronous transfers.  This ill be replaced with a more &n; * &t;integrated function; perhaps a new entry in the scsi_host &n; *&t;structure, accessible via an ioctl() or perhaps /proc/scsi.&n; *&n; * Inputs : host - number of SCSI host; target - number of target.&n; *&n; * Returns : 0 when negotiation has been setup for next SCSI command,&n; *&t;-1 on failure.&n; */
r_static
r_int
DECL|function|request_synchronous
id|request_synchronous
(paren
r_int
id|host
comma
r_int
id|target
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|h
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|target
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_ALERT
l_string|&quot;target %d is bogus&bslash;n&quot;
comma
id|target
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|h
op_assign
id|find_host
(paren
id|host
)paren
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|h-&gt;this_id
op_eq
id|target
)paren
(brace
id|printk
(paren
id|KERN_ALERT
l_string|&quot;target %d is host ID&bslash;n&quot;
comma
id|target
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|target
OG
id|h-&gt;max_id
)paren
(brace
id|printk
(paren
id|KERN_ALERT
l_string|&quot;target %d exceeds maximum of %d&bslash;n&quot;
comma
id|target
comma
id|h-&gt;max_id
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|h-&gt;hostdata
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;initiate_sdtr
op_amp
(paren
l_int|1
op_lshift
id|target
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ALERT
l_string|&quot;target %d already doing SDTR&bslash;n&quot;
comma
id|target
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|hostdata-&gt;initiate_sdtr
op_or_assign
(paren
l_int|1
op_lshift
id|target
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : request_disconnect (int host, int on_or_off)&n; * &n; * Purpose : KGDB support function, tells us to allow or disallow &n; *&t;disconnections.&n; *&n; * Inputs : host - number of SCSI host; on_or_off - non-zero to allow,&n; *&t;zero to disallow.&n; *&n; * Returns : 0 on success, *&t;-1 on failure.&n; */
r_static
r_int
DECL|function|request_disconnect
id|request_disconnect
(paren
r_int
id|host
comma
r_int
id|on_or_off
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|h
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|h
op_assign
id|find_host
(paren
id|host
)paren
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|h-&gt;hostdata
suffix:semicolon
r_if
c_cond
(paren
id|on_or_off
)paren
id|hostdata-&gt;options
op_or_assign
id|OPTION_DISCONNECT
suffix:semicolon
r_else
id|hostdata-&gt;options
op_and_assign
op_complement
id|OPTION_DISCONNECT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Function : static void NCR53c7x0_driver_init (struct Scsi_Host *host)&n; *&n; * Purpose : Initialize internal structures, as required on startup, or &n; *&t;after a SCSI bus reset.&n; * &n; * Inputs : host - pointer to this host adapter&squot;s structure&n; */
r_static
r_void
DECL|function|NCR53c7x0_driver_init
id|NCR53c7x0_driver_init
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|u32
op_star
id|curr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
(brace
id|hostdata-&gt;request_sense
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
op_increment
id|j
)paren
id|hostdata-&gt;busy
(braket
id|i
)braket
(braket
id|j
)braket
op_assign
l_int|0
suffix:semicolon
id|set_synchronous
(paren
id|host
comma
id|i
comma
multiline_comment|/* sxfer */
l_int|0
comma
id|hostdata-&gt;saved_scntl3
comma
l_int|0
)paren
suffix:semicolon
)brace
id|hostdata-&gt;issue_queue
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;running_list
op_assign
id|hostdata-&gt;finished_queue
op_assign
id|hostdata-&gt;curr
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|curr
op_assign
(paren
id|u32
op_star
)paren
id|hostdata-&gt;schedule
suffix:semicolon
id|i
OL
id|host-&gt;can_queue
suffix:semicolon
op_increment
id|i
comma
id|curr
op_add_assign
l_int|2
)paren
(brace
id|curr
(braket
l_int|0
)braket
op_assign
id|hostdata-&gt;NOP_insn
suffix:semicolon
id|curr
(braket
l_int|1
)braket
op_assign
id|le32_to_cpu
c_func
(paren
l_int|0xdeadbeef
)paren
suffix:semicolon
)brace
id|curr
(braket
l_int|0
)braket
op_assign
id|le32_to_cpu
c_func
(paren
(paren
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_JUMP
)paren
op_lshift
l_int|24
)paren
op_or
id|DBC_TCI_TRUE
)paren
suffix:semicolon
id|curr
(braket
l_int|1
)braket
op_assign
(paren
id|u32
)paren
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
(paren
id|hostdata-&gt;script
)paren
op_plus
id|hostdata-&gt;E_wait_reselect
)paren
suffix:semicolon
id|hostdata-&gt;reconnect_dsa_head
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;addr_reconnect_dsa_head
op_assign
(paren
id|u32
)paren
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
(paren
id|hostdata-&gt;reconnect_dsa_head
)paren
)paren
)paren
suffix:semicolon
id|hostdata-&gt;expecting_iid
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;expecting_sto
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_ALWAYS_SYNCHRONOUS
)paren
id|hostdata-&gt;initiate_sdtr
op_assign
id|le32_to_cpu
c_func
(paren
l_int|0xffff
)paren
suffix:semicolon
r_else
id|hostdata-&gt;initiate_sdtr
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;talked_to
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;idle
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : static int ccf_to_clock (int ccf)&n; *&n; * Purpose :  Return the largest SCSI clock allowable for a given&n; *&t;clock conversion factor, allowing us to do synchronous periods&n; *&t;when we don&squot;t know what the SCSI clock is by taking at least &n; *&t;as long as the device says we can.&n; *&n; * Inputs : ccf&n; *&n; * Returns : clock on success, -1 on failure.&n; */
r_static
r_int
DECL|function|ccf_to_clock
id|ccf_to_clock
(paren
r_int
id|ccf
)paren
(brace
r_switch
c_cond
(paren
id|ccf
)paren
(brace
r_case
l_int|1
suffix:colon
r_return
l_int|25000000
suffix:semicolon
multiline_comment|/* Divide by 1.0 */
r_case
l_int|2
suffix:colon
r_return
l_int|37500000
suffix:semicolon
multiline_comment|/* Divide by 1.5 */
r_case
l_int|3
suffix:colon
r_return
l_int|50000000
suffix:semicolon
multiline_comment|/* Divide by 2.0 */
r_case
l_int|0
suffix:colon
multiline_comment|/* Divide by 3.0 */
r_case
l_int|4
suffix:colon
r_return
l_int|66000000
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Function : static int clock_to_ccf (int clock)&n; *&n; * Purpose :  Return the clock conversion factor for a given SCSI clock.&n; *&n; * Inputs : clock - SCSI clock expressed in Hz.&n; *&n; * Returns : ccf on success, -1 on failure.&n; */
r_static
r_int
DECL|function|clock_to_ccf
id|clock_to_ccf
(paren
r_int
id|clock
)paren
(brace
r_if
c_cond
(paren
id|clock
OL
l_int|16666666
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|clock
OL
l_int|25000000
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Divide by 1.0 */
r_else
r_if
c_cond
(paren
id|clock
OL
l_int|37500000
)paren
r_return
l_int|2
suffix:semicolon
multiline_comment|/* Divide by 1.5 */
r_else
r_if
c_cond
(paren
id|clock
OL
l_int|50000000
)paren
r_return
l_int|3
suffix:semicolon
multiline_comment|/* Divide by 2.0 */
r_else
r_if
c_cond
(paren
id|clock
OL
l_int|66000000
)paren
r_return
l_int|4
suffix:semicolon
multiline_comment|/* Divide by 3.0 */
r_else
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : static int NCR53c7x0_init (struct Scsi_Host *host)&n; *&n; * Purpose :  initialize the internal structures for a given SCSI host&n; *&n; * Inputs : host - pointer to this host adapter&squot;s structure&n; *&n; * Preconditions : when this function is called, the chip_type &n; * &t;field of the hostdata structure MUST have been set.&n; *&n; * Returns : 0 on success, -1 on failure.&n; */
r_static
r_int
DECL|function|NCR53c7x0_init
id|NCR53c7x0_init
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_int
id|i
comma
id|ccf
comma
id|expected_ccf
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|search
suffix:semicolon
multiline_comment|/* &n;     * There are some things which we need to know about in order to provide&n;     * a semblance of support.  Print &squot;em if they aren&squot;t what we expect, &n;     * otherwise don&squot;t add to the noise.&n;     * &n;     * -1 means we don&squot;t know what to expect.&n;     */
r_int
id|expected_id
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|expected_clock
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|uninitialized
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;     * FIXME : this is only on Intel boxes.  On other platforms, this&n;     * will differ.&n;     */
r_int
id|expected_mapping
op_assign
id|OPTION_IO_MAPPED
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hostdata-&gt;chip
)paren
(brace
r_case
l_int|820
suffix:colon
r_case
l_int|825
suffix:colon
macro_line|#ifdef notyet
id|host-&gt;max_id
op_assign
l_int|15
suffix:semicolon
macro_line|#endif
multiline_comment|/* Fall through */
r_case
l_int|810
suffix:colon
r_case
l_int|815
suffix:colon
id|hostdata-&gt;dstat_sir_intr
op_assign
id|NCR53c8x0_dstat_sir_intr
suffix:semicolon
id|hostdata-&gt;init_save_regs
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;dsa_fixup
op_assign
id|NCR53c8xx_dsa_fixup
suffix:semicolon
id|hostdata-&gt;init_fixup
op_assign
id|NCR53c8x0_init_fixup
suffix:semicolon
id|hostdata-&gt;soft_reset
op_assign
id|NCR53c8x0_soft_reset
suffix:semicolon
id|hostdata-&gt;run_tests
op_assign
id|NCR53c8xx_run_tests
suffix:semicolon
multiline_comment|/* Is the SCSI clock ever anything else on these chips? */
id|expected_clock
op_assign
id|hostdata-&gt;scsi_clock
op_assign
l_int|40000000
suffix:semicolon
id|expected_id
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : chip type of %d is not supported yet, detaching.&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|hostdata-&gt;chip
)paren
suffix:semicolon
id|scsi_unregister
(paren
id|host
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Assign constants accessed by NCR */
id|hostdata-&gt;NCR53c7xx_zero
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;NCR53c7xx_msg_reject
op_assign
id|le32_to_cpu
c_func
(paren
id|MESSAGE_REJECT
)paren
suffix:semicolon
id|hostdata-&gt;NCR53c7xx_msg_abort
op_assign
id|le32_to_cpu
c_func
(paren
id|ABORT
)paren
suffix:semicolon
id|hostdata-&gt;NCR53c7xx_msg_nop
op_assign
id|le32_to_cpu
c_func
(paren
id|NOP
)paren
suffix:semicolon
id|hostdata-&gt;NOP_insn
op_assign
id|le32_to_cpu
c_func
(paren
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_JUMP
)paren
op_lshift
l_int|24
)paren
suffix:semicolon
r_if
c_cond
(paren
id|expected_mapping
op_eq
op_minus
l_int|1
op_logical_or
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_MEMORY_MAPPED
)paren
)paren
op_ne
(paren
id|expected_mapping
op_amp
id|OPTION_MEMORY_MAPPED
)paren
)paren
id|printk
(paren
l_string|&quot;scsi%d : using %s mapped access&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_MEMORY_MAPPED
)paren
ques
c_cond
l_string|&quot;memory&quot;
suffix:colon
l_string|&quot;io&quot;
)paren
suffix:semicolon
id|hostdata-&gt;dmode
op_assign
(paren
id|hostdata-&gt;chip
op_eq
l_int|700
op_logical_or
id|hostdata-&gt;chip
op_eq
l_int|70066
)paren
ques
c_cond
id|DMODE_REG_00
suffix:colon
id|DMODE_REG_10
suffix:semicolon
id|hostdata-&gt;istat
op_assign
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
ques
c_cond
id|ISTAT_REG_800
suffix:colon
id|ISTAT_REG_700
suffix:semicolon
multiline_comment|/* Only the ISTAT register is readable when the NCR is running, so make &n;   sure it&squot;s halted. */
id|ncr_halt
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* &n; * XXX - the NCR53c700 uses bitfielded registers for SCID, SDID, etc,&n; *&t;as does the 710 with one bit per SCSI ID.  Conversely, the NCR&n; * &t;uses a normal, 3 bit binary representation of these values.&n; *&n; * Get the rest of the NCR documentation, and FIND OUT where the change&n; * was.&n; */
macro_line|#if 0
id|tmp
op_assign
id|hostdata-&gt;this_id_mask
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SCID_REG
)paren
suffix:semicolon
r_for
c_loop
(paren
id|host-&gt;this_id
op_assign
l_int|0
suffix:semicolon
id|tmp
op_ne
l_int|1
suffix:semicolon
id|tmp
op_rshift_assign
l_int|1
comma
op_increment
id|host-&gt;this_id
)paren
suffix:semicolon
macro_line|#else
id|host-&gt;this_id
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SCID_REG
)paren
op_amp
l_int|15
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;this_id
op_eq
l_int|0
)paren
id|host-&gt;this_id
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* sanitize hostid---0 doesn&squot;t make sense */
id|hostdata-&gt;this_id_mask
op_assign
l_int|1
op_lshift
id|host-&gt;this_id
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Note : we should never encounter a board setup for ID0.  So,&n; * &t;if we see ID0, assume that it was uninitialized and set it&n; * &t;to the industry standard 7.&n; */
r_if
c_cond
(paren
op_logical_neg
id|host-&gt;this_id
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : initiator ID was %d, changing to 7&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|host-&gt;this_id
)paren
suffix:semicolon
id|host-&gt;this_id
op_assign
l_int|7
suffix:semicolon
id|hostdata-&gt;this_id_mask
op_assign
l_int|1
op_lshift
l_int|7
suffix:semicolon
id|uninitialized
op_assign
l_int|1
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|expected_id
op_eq
op_minus
l_int|1
op_logical_or
id|host-&gt;this_id
op_ne
id|expected_id
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : using initiator ID %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|host-&gt;this_id
)paren
suffix:semicolon
multiline_comment|/*&n;     * Save important registers to allow a soft reset.&n;     */
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
(brace
multiline_comment|/* &n;     * CTEST4 controls burst mode disable.&n;     */
id|hostdata-&gt;saved_ctest4
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|CTEST4_REG_800
)paren
op_amp
id|CTEST4_800_SAVE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;     * CTEST7 controls cache snooping, burst mode, and support for &n;     * external differential drivers.&n;     */
id|hostdata-&gt;saved_ctest7
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|CTEST7_REG
)paren
op_amp
id|CTEST7_SAVE
suffix:semicolon
)brace
multiline_comment|/*&n;     * On NCR53c700 series chips, DCNTL controls the SCSI clock divisor,&n;     * on 800 series chips, it allows for a totem-pole IRQ driver.&n;     */
id|hostdata-&gt;saved_dcntl
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|DCNTL_REG
)paren
suffix:semicolon
multiline_comment|/* &n;     * DCNTL_800_IRQM controls weather we are using an open drain&n;     * driver (reset) or totem pole driver (set).  In all cases, &n;     * it&squot;s level active.  I suppose this is an issue when we&squot;re trying to &n;     * wire-or the same PCI INTx line?&n;     */
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
id|hostdata-&gt;saved_dcntl
op_and_assign
op_complement
id|DCNTL_800_IRQM
suffix:semicolon
multiline_comment|/*&n;     * DMODE controls DMA burst length, and on 700 series chips,&n;     * 286 mode and bus width  &n;     */
id|hostdata-&gt;saved_dmode
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|hostdata-&gt;dmode
)paren
suffix:semicolon
multiline_comment|/* &n;     * Now that burst length and enabled/disabled status is known, &n;     * clue the user in on it.  &n;     */
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;saved_ctest4
op_amp
id|CTEST4_800_BDIS
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : burst mode disabled&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|hostdata-&gt;saved_dmode
op_amp
id|DMODE_BL_MASK
)paren
(brace
r_case
id|DMODE_BL_2
suffix:colon
id|i
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DMODE_BL_4
suffix:colon
id|i
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DMODE_BL_8
suffix:colon
id|i
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DMODE_BL_16
suffix:colon
id|i
op_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|i
op_assign
l_int|0
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;scsi%d : burst length %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * On NCR53c810 and NCR53c820 chips, SCNTL3 contails the synchronous&n;     * and normal clock conversion factors.&n;     */
r_if
c_cond
(paren
id|hostdata-&gt;chip
op_div
l_int|100
op_eq
l_int|8
)paren
(brace
id|expected_ccf
op_assign
id|clock_to_ccf
(paren
id|expected_clock
)paren
suffix:semicolon
id|hostdata-&gt;saved_scntl3
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SCNTL3_REG_800
)paren
suffix:semicolon
id|ccf
op_assign
id|hostdata-&gt;saved_scntl3
op_amp
id|SCNTL3_800_CCF_MASK
suffix:semicolon
r_if
c_cond
(paren
id|expected_ccf
op_ne
op_minus
l_int|1
op_logical_and
id|ccf
op_ne
id|expected_ccf
op_logical_and
op_logical_neg
id|ccf
)paren
(brace
id|hostdata-&gt;saved_scntl3
op_assign
(paren
id|hostdata-&gt;saved_scntl3
op_amp
op_complement
id|SCNTL3_800_CCF_MASK
)paren
op_or
id|expected_ccf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uninitialized
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : reset ccf to %d from %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|expected_ccf
comma
id|ccf
)paren
suffix:semicolon
id|uninitialized
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_else
id|ccf
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * If we don&squot;t have a SCSI clock programmed, pick one on the upper&n;     * bound of that allowed by NCR so that our transfers err on the &n;     * slow side, since transfer period must be &gt;= the agreed &n;     * upon period.&n;     */
r_if
c_cond
(paren
(paren
op_logical_neg
id|hostdata-&gt;scsi_clock
)paren
op_logical_and
(paren
id|hostdata-&gt;scsi_clock
op_assign
id|ccf_to_clock
(paren
id|ccf
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : clock conversion factor %d unknown.&bslash;n&quot;
l_string|&quot;         synchronous transfers disabled&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|ccf
)paren
suffix:semicolon
id|hostdata-&gt;options
op_and_assign
op_complement
id|OPTION_SYNCHRONOUS
suffix:semicolon
id|hostdata-&gt;scsi_clock
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|expected_clock
op_eq
op_minus
l_int|1
op_logical_or
id|hostdata-&gt;scsi_clock
op_ne
id|expected_clock
)paren
id|printk
(paren
l_string|&quot;scsi%d : using %dMHz SCSI clock&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|hostdata-&gt;scsi_clock
op_div
l_int|1000000
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
id|hostdata-&gt;cmd_allocated
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;init_save_regs
)paren
id|hostdata-&gt;init_save_regs
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;init_fixup
)paren
id|hostdata-&gt;init_fixup
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|the_template
)paren
(brace
id|the_template
op_assign
id|host-&gt;hostt
suffix:semicolon
id|first_host
op_assign
id|host
suffix:semicolon
)brace
multiline_comment|/* &n;     * Linux SCSI drivers have always been plagued with initialization &n;     * problems - some didn&squot;t work with the BIOS disabled since they expected&n;     * initialization from it, some didn&squot;t work when the networking code&n;     * was enabled and registers got scrambled, etc.&n;     *&n;     * To avoid problems like this, in the future, we will do a soft &n;     * reset on the SCSI chip, taking it back to a sane state.&n;     */
id|hostdata-&gt;soft_reset
(paren
id|host
)paren
suffix:semicolon
macro_line|#if 1
id|hostdata-&gt;debug_count_limit
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#else
id|hostdata-&gt;debug_count_limit
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;intrs
op_assign
op_minus
l_int|1
suffix:semicolon
id|hostdata-&gt;resets
op_assign
op_minus
l_int|1
suffix:semicolon
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|hostdata-&gt;synchronous_want
comma
(paren
r_void
op_star
)paren
id|sdtr_message
comma
r_sizeof
(paren
id|hostdata-&gt;synchronous_want
)paren
)paren
suffix:semicolon
id|NCR53c7x0_driver_init
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/*&n;     * Set up an interrupt handler if we aren&squot;t already sharing an IRQ&n;     * with another board.&n;     */
r_for
c_loop
(paren
id|search
op_assign
id|first_host
suffix:semicolon
id|search
op_logical_and
op_logical_neg
(paren
id|search-&gt;hostt
op_eq
id|the_template
op_logical_and
id|search-&gt;irq
op_eq
id|host-&gt;irq
op_logical_and
id|search
op_ne
id|host
)paren
suffix:semicolon
id|search
op_assign
id|search-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|search
)paren
(brace
macro_line|#ifdef __powerpc__
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|host-&gt;irq
comma
id|do_NCR53c7x0_intr
comma
id|SA_SHIRQ
comma
l_string|&quot;53c7,8xx&quot;
comma
l_int|NULL
)paren
)paren
macro_line|#else
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|host-&gt;irq
comma
id|do_NCR53c7x0_intr
comma
id|SA_INTERRUPT
comma
l_string|&quot;53c7,8xx&quot;
comma
l_int|NULL
)paren
)paren
macro_line|#endif
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : IRQ%d not free, detaching&bslash;n&quot;
l_string|&quot;         You have either a configuration problem, or a&bslash;n&quot;
l_string|&quot;         broken BIOS.  You may wish to manually assign&bslash;n&quot;
l_string|&quot;         an interrupt to the NCR board rather than using&bslash;n&quot;
l_string|&quot;         an automatic setting.&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|host-&gt;irq
)paren
suffix:semicolon
id|scsi_unregister
(paren
id|host
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : using interrupt handler previously installed for scsi%d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|search-&gt;host_no
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|hostdata-&gt;run_tests
op_logical_and
id|hostdata
op_member_access_from_pointer
id|run_tests
c_func
(paren
id|host
)paren
op_eq
op_minus
l_int|1
)paren
op_logical_or
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_TESTS_ONLY
)paren
)paren
(brace
multiline_comment|/* XXX Should disable interrupts, etc. here */
id|scsi_unregister
(paren
id|host
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|host-&gt;io_port
)paren
(brace
id|host-&gt;n_io_port
op_assign
l_int|128
suffix:semicolon
id|request_region
(paren
id|host-&gt;io_port
comma
id|host-&gt;n_io_port
comma
l_string|&quot;ncr53c7,8xx&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|NCR53c7x0_read8
(paren
id|SBCL_REG
)paren
op_amp
id|SBCL_BSY
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : bus wedge, doing SCSI reset&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|hard_reset
(paren
id|host
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : static int normal_init(Scsi_Host_Template *tpnt, int board, &n; *&t;int chip, u32 base, int io_port, int irq, int dma, int pcivalid,&n; *&t;unsigned char pci_bus, unsigned char pci_device_fn,&n; *&t;long long options);&n; *&n; * Purpose : initializes a NCR53c7,8x0 based on base addresses,&n; *&t;IRQ, and DMA channel.&t;&n; *&t;&n; *&t;Useful where a new NCR chip is backwards compatible with&n; *&t;a supported chip, but the DEVICE ID has changed so it &n; *&t;doesn&squot;t show up when the autoprobe does a pcibios_find_device.&n; *&n; * Inputs : tpnt - Template for this SCSI adapter, board - board level&n; *&t;product, chip - 810, 820, or 825, bus - PCI bus, device_fn -&n; *&t;device and function encoding as used by PCI BIOS calls.&n; * &n; * Returns : 0 on success, -1 on failure.&n; *&n; */
r_static
r_int
id|__init
DECL|function|normal_init
id|normal_init
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|board
comma
r_int
id|chip
comma
id|u32
id|base
comma
r_int
id|io_port
comma
r_int
id|irq
comma
r_int
id|dma
comma
r_int
id|pci_valid
comma
r_int
r_char
id|pci_bus
comma
r_int
r_char
id|pci_device_fn
comma
r_int
r_int
id|options
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
suffix:semicolon
r_char
id|chip_str
(braket
l_int|80
)braket
suffix:semicolon
r_int
id|script_len
op_assign
l_int|0
comma
id|dsa_len
op_assign
l_int|0
comma
id|size
op_assign
l_int|0
comma
id|max_cmd_size
op_assign
l_int|0
comma
id|schedule_size
op_assign
l_int|0
comma
id|ok
op_assign
l_int|0
suffix:semicolon
r_void
op_star
id|tmp
suffix:semicolon
id|options
op_or_assign
id|perm_options
suffix:semicolon
r_switch
c_cond
(paren
id|chip
)paren
(brace
r_case
l_int|825
suffix:colon
r_case
l_int|820
suffix:colon
r_case
l_int|815
suffix:colon
r_case
l_int|810
suffix:colon
id|schedule_size
op_assign
(paren
id|tpnt-&gt;can_queue
op_plus
l_int|1
)paren
op_star
l_int|8
multiline_comment|/* JUMP instruction size */
suffix:semicolon
id|script_len
op_assign
id|NCR53c8xx_script_len
suffix:semicolon
id|dsa_len
op_assign
id|NCR53c8xx_dsa_len
suffix:semicolon
id|options
op_or_assign
id|OPTION_INTFLY
suffix:semicolon
id|sprintf
(paren
id|chip_str
comma
l_string|&quot;NCR53c%d&quot;
comma
id|chip
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi-ncr53c7,8xx : unsupported SCSI chip %d&bslash;n&quot;
comma
id|chip
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;scsi-ncr53c7,8xx : %s at memory 0x%x, io 0x%x, irq %d&quot;
comma
id|chip_str
comma
(paren
r_int
)paren
id|base
comma
id|io_port
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma
op_eq
id|DMA_NONE
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;, dma %d&bslash;n&quot;
comma
id|dma
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|chip
op_div
l_int|100
op_eq
l_int|8
)paren
op_logical_and
op_logical_neg
id|pci_valid
)paren
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : for better reliability and performance, please use the&bslash;n&quot;
l_string|&quot;        PCI override instead.&bslash;n&quot;
l_string|&quot;&t; Syntax : ncr53c8{10,15,20,25}=pci,&lt;bus&gt;,&lt;device&gt;,&lt;function&gt;&bslash;n&quot;
l_string|&quot;                 &lt;bus&gt; and &lt;device&gt; are usually 0.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|options
op_amp
id|OPTION_DEBUG_PROBE_ONLY
)paren
(brace
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : probe only enabled, aborting initialization&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|max_cmd_size
op_assign
r_sizeof
(paren
r_struct
id|NCR53c7x0_cmd
)paren
op_plus
id|dsa_len
op_plus
multiline_comment|/* Size of dynamic part of command structure : */
l_int|2
op_star
multiline_comment|/* Worst case : we don&squot;t know if we need DATA IN or DATA out */
(paren
l_int|2
op_star
multiline_comment|/* Current instructions per scatter/gather segment */
id|tpnt-&gt;sg_tablesize
op_plus
l_int|3
multiline_comment|/* Current startup / termination required per phase */
)paren
op_star
l_int|8
multiline_comment|/* Each instruction is eight bytes */
suffix:semicolon
multiline_comment|/* Allocate fixed part of hostdata, dynamic part to hold appropriate&n;       SCSI SCRIPT(tm) plus a single, maximum-sized NCR53c7x0_cmd structure.&n;&n;       We need a NCR53c7x0_cmd structure for scan_scsis() when we are &n;       not loaded as a module, and when we&squot;re loaded as a module, we &n;       can&squot;t use a non-dynamically allocated structure because modules&n;       are vmalloc()&squot;d, which can allow structures to cross page &n;       boundaries and breaks our physical/virtual address assumptions&n;       for DMA.&n;&n;       So, we stick it past the end of our hostdata structure.&n;&n;       ASSUMPTION : &n;       &t; Regardless of how many simultaneous SCSI commands we allow,&n;&t; the probe code only executes a _single_ instruction at a time,&n;&t; so we only need one here, and don&squot;t need to allocate NCR53c7x0_cmd&n;&t; structures for each target until we are no longer in scan_scsis&n;&t; and kmalloc() has become functional (memory_init() happens &n;&t; after all device driver initialization).&n;    */
id|size
op_assign
r_sizeof
(paren
r_struct
id|NCR53c7x0_hostdata
)paren
op_plus
id|script_len
op_plus
multiline_comment|/* Note that alignment will be guaranteed, since we put the command&n;       allocated at probe time after the fixed-up SCSI script, which &n;       consists of 32 bit words, aligned on a 32 bit boundary.  But&n;       on a 64bit machine we need 8 byte alignment for hostdata-&gt;free, so&n;       we add in another 4 bytes to take care of potential misalignment&n;       */
(paren
r_sizeof
(paren
r_void
op_star
)paren
op_minus
r_sizeof
(paren
id|u32
)paren
)paren
op_plus
id|max_cmd_size
op_plus
id|schedule_size
suffix:semicolon
id|instance
op_assign
id|scsi_register
(paren
id|tpnt
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|instance
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* FIXME : if we ever support an ISA NCR53c7xx based board, we&n;       need to check if the chip is running in a 16 bit mode, and if so &n;       unregister it if it is past the 16M (0x1000000) mark */
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|hostdata-&gt;size
op_assign
id|size
suffix:semicolon
id|hostdata-&gt;script_count
op_assign
id|script_len
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|hostdata-&gt;board
op_assign
id|board
suffix:semicolon
id|hostdata-&gt;chip
op_assign
id|chip
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hostdata-&gt;pci_valid
op_assign
id|pci_valid
)paren
)paren
(brace
id|hostdata-&gt;pci_bus
op_assign
id|pci_bus
suffix:semicolon
id|hostdata-&gt;pci_device_fn
op_assign
id|pci_device_fn
suffix:semicolon
)brace
multiline_comment|/*&n;     * Being memory mapped is more desirable, since &n;     *&n;     * - Memory accesses may be faster.&n;     *&n;     * - The destination and source address spaces are the same for &n;     *&t; all instructions, meaning we don&squot;t have to twiddle dmode or &n;     *&t; any other registers.&n;     *&n;     * So, we try for memory mapped, and if we don&squot;t get it,&n;     * we go for port mapped, and that failing we tell the user&n;     * it can&squot;t work.&n;     */
r_if
c_cond
(paren
id|base
)paren
(brace
id|instance-&gt;base
op_assign
(paren
r_int
r_int
)paren
id|base
suffix:semicolon
multiline_comment|/* Check for forced I/O mapping */
r_if
c_cond
(paren
op_logical_neg
(paren
id|options
op_amp
id|OPTION_IO_MAPPED
)paren
)paren
(brace
id|options
op_or_assign
id|OPTION_MEMORY_MAPPED
suffix:semicolon
id|ok
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|options
op_and_assign
op_complement
id|OPTION_MEMORY_MAPPED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|io_port
)paren
(brace
id|instance-&gt;io_port
op_assign
id|io_port
suffix:semicolon
id|options
op_or_assign
id|OPTION_IO_MAPPED
suffix:semicolon
id|ok
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|options
op_and_assign
op_complement
id|OPTION_IO_MAPPED
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ok
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : not initializing, no I/O or memory mapping known &bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|scsi_unregister
(paren
id|instance
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|instance-&gt;irq
op_assign
id|irq
suffix:semicolon
id|instance-&gt;dma_channel
op_assign
id|dma
suffix:semicolon
id|hostdata-&gt;options
op_assign
id|options
suffix:semicolon
id|hostdata-&gt;dsa_len
op_assign
id|dsa_len
suffix:semicolon
id|hostdata-&gt;max_cmd_size
op_assign
id|max_cmd_size
suffix:semicolon
id|hostdata-&gt;num_cmds
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Initialize single command */
id|tmp
op_assign
(paren
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;script_count
)paren
suffix:semicolon
id|hostdata-&gt;free
op_assign
id|ROUNDUP
c_func
(paren
id|tmp
comma
r_void
op_star
)paren
suffix:semicolon
id|hostdata-&gt;free-&gt;real
op_assign
id|tmp
suffix:semicolon
id|hostdata-&gt;free-&gt;size
op_assign
id|max_cmd_size
suffix:semicolon
id|hostdata-&gt;free-&gt;free
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;free-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;extra_allocate
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Allocate command start code space */
id|hostdata-&gt;schedule
op_assign
(paren
id|chip
op_eq
l_int|700
op_logical_or
id|chip
op_eq
l_int|70066
)paren
ques
c_cond
l_int|NULL
suffix:colon
(paren
id|u32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|hostdata-&gt;free
op_plus
id|max_cmd_size
)paren
suffix:semicolon
multiline_comment|/* &n; * For diagnostic purposes, we don&squot;t really care how fast things blaze.&n; * For profiling, we want to access the 800ns resolution system clock,&n; * using a &squot;C&squot; call on the host processor.&n; *&n; * Therefore, there&squot;s no need for the NCR chip to directly manipulate&n; * this data, and we should put it wherever is most convenient for &n; * Linux.&n; */
r_if
c_cond
(paren
id|track_events
)paren
id|hostdata-&gt;events
op_assign
(paren
r_struct
id|NCR53c7x0_event
op_star
)paren
(paren
id|track_events
ques
c_cond
id|vmalloc
(paren
r_sizeof
(paren
r_struct
id|NCR53c7x0_event
)paren
op_star
id|track_events
)paren
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_else
id|hostdata-&gt;events
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;events
)paren
(brace
id|memset
(paren
(paren
r_void
op_star
)paren
id|hostdata-&gt;events
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|NCR53c7x0_event
)paren
op_star
id|track_events
)paren
suffix:semicolon
id|hostdata-&gt;event_size
op_assign
id|track_events
suffix:semicolon
id|hostdata-&gt;event_index
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|hostdata-&gt;event_size
op_assign
l_int|0
suffix:semicolon
r_return
id|NCR53c7x0_init
c_func
(paren
id|instance
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : static int ncr_pci_init(Scsi_Host_Template *tpnt, int board, &n; *&t;int chip, int bus, int device_fn, long long options)&n; *&n; * Purpose : initializes a NCR53c800 family based on the PCI&n; *&t;bus, device, and function location of it.  Allows &n; * &t;reprogramming of latency timer and determining addresses&n; *&t;and whether bus mastering, etc. are OK.&n; *&t;&n; *&t;Useful where a new NCR chip is backwards compatible with&n; *&t;a supported chip, but the DEVICE ID has changed so it &n; *&t;doesn&squot;t show up when the autoprobe does a pcibios_find_device.&n; *&n; * Inputs : tpnt - Template for this SCSI adapter, board - board level&n; *&t;product, chip - 810, 820, or 825, bus - PCI bus, device_fn -&n; *&t;device and function encoding as used by PCI BIOS calls.&n; * &n; * Returns : 0 on success, -1 on failure.&n; *&n; */
r_static
r_int
id|__init
DECL|function|ncr_pci_init
id|ncr_pci_init
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|board
comma
r_int
id|chip
comma
r_int
r_char
id|bus
comma
r_int
r_char
id|device_fn
comma
r_int
r_int
id|options
)paren
(brace
r_int
r_int
id|command
suffix:semicolon
r_int
r_int
id|base
comma
id|io_port
suffix:semicolon
r_int
r_char
id|revision
suffix:semicolon
r_int
id|error
comma
id|expected_chip
suffix:semicolon
r_int
id|expected_id
op_assign
op_minus
l_int|1
comma
id|max_revision
op_assign
op_minus
l_int|1
comma
id|min_revision
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|i
comma
id|irq
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
op_assign
id|pci_find_slot
c_func
(paren
id|bus
comma
id|device_fn
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi-ncr53c7,8xx : at PCI bus %d, device %d, function %d&bslash;n&quot;
comma
id|bus
comma
(paren
r_int
)paren
(paren
id|device_fn
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
comma
(paren
r_int
)paren
id|device_fn
op_amp
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pdev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi-ncr53c7,8xx : not initializing -- PCI device not found,&bslash;n&quot;
l_string|&quot;        try using memory, port, irq override instead.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|pci_read_config_word
(paren
id|pdev
comma
id|PCI_COMMAND
comma
op_amp
id|command
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pci_read_config_byte
(paren
id|pdev
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|revision
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : error %d not initializing due to error reading configuration space&bslash;n&quot;
l_string|&quot;&t; perhaps you specified an incorrect PCI bus, device, or function.&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pdev
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|io_port
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|base
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|1
)paren
suffix:semicolon
id|irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
multiline_comment|/* If any one ever clones the NCR chips, this will have to change */
r_if
c_cond
(paren
id|pdev-&gt;vendor
op_ne
id|PCI_VENDOR_ID_NCR
)paren
(brace
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : not initializing, 0x%04x is not NCR vendor ID&bslash;n&quot;
comma
(paren
r_int
)paren
id|pdev-&gt;vendor
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef __powerpc__
r_if
c_cond
(paren
op_logical_neg
(paren
id|command
op_amp
id|PCI_COMMAND_MASTER
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI: PCI Master Bit has not been set. Setting...&bslash;n&quot;
)paren
suffix:semicolon
id|command
op_or_assign
id|PCI_COMMAND_MASTER
op_or
id|PCI_COMMAND_IO
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|io_port
op_ge
l_int|0x10000000
op_logical_and
id|is_prep
)paren
(brace
multiline_comment|/* Mapping on PowerPC can&squot;t handle this! */
r_int
r_int
id|new_io_port
suffix:semicolon
id|new_io_port
op_assign
(paren
id|io_port
op_amp
l_int|0x00FFFFFF
)paren
op_or
l_int|0x01000000
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SCSI: I/O moved from %08X to %08x&bslash;n&quot;
comma
id|io_port
comma
id|new_io_port
)paren
suffix:semicolon
id|io_port
op_assign
id|new_io_port
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|pdev
comma
id|PCI_BASE_ADDRESS_0
comma
id|io_port
)paren
suffix:semicolon
id|pdev-&gt;base_address
(braket
l_int|0
)braket
op_assign
id|io_port
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* &n;     * Bit 0 is the address space indicator and must be one for I/O&n;     * space mappings, bit 1 is reserved, discard them after checking&n;     * that they have the correct value of 1.&n;     */
r_if
c_cond
(paren
id|command
op_amp
id|PCI_COMMAND_IO
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|pdev-&gt;resource
(braket
l_int|0
)braket
dot
id|flags
op_amp
id|IORESOURCE_IO
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : disabling I/O mapping since base &quot;
l_string|&quot;address 0&bslash;n        contains a non-IO mapping&bslash;n&quot;
)paren
suffix:semicolon
id|io_port
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|io_port
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|command
op_amp
id|PCI_COMMAND_MEMORY
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|pdev-&gt;resource
(braket
l_int|1
)braket
dot
id|flags
op_amp
id|IORESOURCE_MEM
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi-ncr53c7,8xx : disabling memory mapping since base &quot;
l_string|&quot;address 1&bslash;n        contains a non-memory mapping&bslash;n&quot;
)paren
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|base
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|io_port
op_logical_and
op_logical_neg
id|base
)paren
(brace
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : not initializing, both I/O and memory mappings disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|command
op_amp
id|PCI_COMMAND_MASTER
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : not initializing, BUS MASTERING was disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NPCI_CHIP_IDS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|pdev-&gt;device
op_eq
id|pci_chip_ids
(braket
id|i
)braket
dot
id|pci_device_id
)paren
(brace
id|max_revision
op_assign
id|pci_chip_ids
(braket
id|i
)braket
dot
id|max_revision
suffix:semicolon
id|min_revision
op_assign
id|pci_chip_ids
(braket
id|i
)braket
dot
id|min_revision
suffix:semicolon
id|expected_chip
op_assign
id|pci_chip_ids
(braket
id|i
)braket
dot
id|chip
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chip
op_eq
id|pci_chip_ids
(braket
id|i
)braket
dot
id|chip
)paren
id|expected_id
op_assign
id|pci_chip_ids
(braket
id|i
)braket
dot
id|pci_device_id
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chip
op_logical_and
id|pdev-&gt;device
op_ne
id|expected_id
)paren
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : warning : device id of 0x%04x doesn&squot;t&bslash;n&quot;
l_string|&quot;                   match expected 0x%04x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|pdev-&gt;device
comma
(paren
r_int
r_int
)paren
id|expected_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_revision
op_ne
op_minus
l_int|1
op_logical_and
id|revision
OG
id|max_revision
)paren
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : warning : revision of %d is greater than %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|revision
comma
id|max_revision
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|min_revision
op_ne
op_minus
l_int|1
op_logical_and
id|revision
OL
id|min_revision
)paren
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : warning : revision of %d is less than %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|revision
comma
id|min_revision
)paren
suffix:semicolon
r_if
c_cond
(paren
id|io_port
op_logical_and
id|check_region
(paren
id|io_port
comma
l_int|128
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi-ncr53c7,8xx : IO region 0x%x to 0x%x is in use&bslash;n&quot;
comma
(paren
r_int
)paren
id|io_port
comma
(paren
r_int
)paren
id|io_port
op_plus
l_int|127
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|normal_init
(paren
id|tpnt
comma
id|board
comma
id|chip
comma
(paren
r_int
)paren
id|base
comma
id|io_port
comma
(paren
r_int
)paren
id|irq
comma
id|DMA_NONE
comma
l_int|1
comma
id|bus
comma
id|device_fn
comma
id|options
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : int NCR53c7xx_detect(Scsi_Host_Template *tpnt)&n; *&n; * Purpose : detects and initializes NCR53c7,8x0 SCSI chips&n; *&t;that were autoprobed, overridden on the LILO command line, &n; *&t;or specified at compile time.&n; *&n; * Inputs : tpnt - template for this SCSI adapter&n; * &n; * Returns : number of host adapters detected&n; *&n; */
r_int
id|__init
DECL|function|NCR53c7xx_detect
(def_block
id|NCR53c7xx_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|current_override
suffix:semicolon
r_int
id|count
suffix:semicolon
multiline_comment|/* Number of boards detected */
r_int
r_char
id|pci_bus
comma
id|pci_device_fn
suffix:semicolon
r_static
r_int
id|pci_index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Device index to PCI BIOS calls */
id|tpnt-&gt;proc_name
op_assign
l_string|&quot;ncr53c7xx&quot;
suffix:semicolon
r_for
c_loop
(paren
id|current_override
op_assign
id|count
op_assign
l_int|0
suffix:semicolon
id|current_override
OL
id|OVERRIDE_LIMIT
suffix:semicolon
op_increment
id|current_override
)paren
(brace
r_if
c_cond
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|pci
ques
c_cond
op_logical_neg
id|ncr_pci_init
(paren
id|tpnt
comma
id|overrides
(braket
id|current_override
)braket
dot
id|board
comma
id|overrides
(braket
id|current_override
)braket
dot
id|chip
comma
(paren
r_int
r_char
)paren
id|overrides
(braket
id|current_override
)braket
dot
id|data.pci.bus
comma
(paren
(paren
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|data.pci.device
op_lshift
l_int|3
)paren
op_amp
l_int|0xf8
)paren
op_or
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|data.pci.function
op_amp
l_int|7
)paren
)paren
comma
id|overrides
(braket
id|current_override
)braket
dot
id|options
)paren
suffix:colon
op_logical_neg
id|normal_init
(paren
id|tpnt
comma
id|overrides
(braket
id|current_override
)braket
dot
id|board
comma
id|overrides
(braket
id|current_override
)braket
dot
id|chip
comma
id|overrides
(braket
id|current_override
)braket
dot
id|data.normal.base
comma
id|overrides
(braket
id|current_override
)braket
dot
id|data.normal.io_port
comma
id|overrides
(braket
id|current_override
)braket
dot
id|data.normal.irq
comma
id|overrides
(braket
id|current_override
)braket
dot
id|data.normal.dma
comma
l_int|0
multiline_comment|/* PCI data invalid */
comma
l_int|0
multiline_comment|/* PCI bus place holder */
comma
l_int|0
multiline_comment|/* PCI device_function place holder */
comma
id|overrides
(braket
id|current_override
)braket
dot
id|options
)paren
)paren
(brace
op_increment
id|count
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pci_present
c_func
(paren
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NPCI_CHIP_IDS
suffix:semicolon
op_increment
id|i
)paren
r_for
c_loop
(paren
id|pci_index
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|pcibios_find_device
(paren
id|PCI_VENDOR_ID_NCR
comma
id|pci_chip_ids
(braket
id|i
)braket
dot
id|pci_device_id
comma
id|pci_index
comma
op_amp
id|pci_bus
comma
op_amp
id|pci_device_fn
)paren
suffix:semicolon
op_increment
id|pci_index
)paren
r_if
c_cond
(paren
op_logical_neg
id|ncr_pci_init
(paren
id|tpnt
comma
id|BOARD_GENERIC
comma
id|pci_chip_ids
(braket
id|i
)braket
dot
id|chip
comma
id|pci_bus
comma
id|pci_device_fn
comma
multiline_comment|/* no options */
l_int|0
)paren
)paren
op_increment
id|count
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
)def_block
multiline_comment|/* NCR53c810 and NCR53c820 script handling code */
macro_line|#include &quot;53c8xx_d.h&quot;
macro_line|#ifdef A_int_debug_sync
DECL|macro|DEBUG_SYNC_INTR
mdefine_line|#define DEBUG_SYNC_INTR A_int_debug_sync
macro_line|#endif
DECL|variable|NCR53c8xx_script_len
r_static
r_int
id|NCR53c8xx_script_len
op_assign
r_sizeof
(paren
id|SCRIPT
)paren
suffix:semicolon
DECL|variable|NCR53c8xx_dsa_len
r_static
r_int
id|NCR53c8xx_dsa_len
op_assign
id|A_dsa_end
op_plus
id|Ent_dsa_zero
op_minus
id|Ent_dsa_code_template
suffix:semicolon
multiline_comment|/* &n; * Function : static void NCR53c8x0_init_fixup (struct Scsi_Host *host)&n; *&n; * Purpose :  copy and fixup the SCSI SCRIPTS(tm) code for this device.&n; *&n; * Inputs : host - pointer to this host adapter&squot;s structure&n; *&n; */
r_static
r_void
DECL|function|NCR53c8x0_init_fixup
id|NCR53c8x0_init_fixup
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
r_char
id|tmp
suffix:semicolon
r_int
id|i
comma
id|ncr_to_memory
comma
id|memory_to_ncr
suffix:semicolon
id|u32
id|base
suffix:semicolon
macro_line|#ifdef __powerpc__
r_int
r_int
op_star
id|script_ptr
suffix:semicolon
macro_line|#endif    
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* XXX - NOTE : this code MUST be made endian aware */
multiline_comment|/*  Copy code into buffer that was allocated at detection time.  */
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|hostdata-&gt;script
comma
(paren
r_void
op_star
)paren
id|SCRIPT
comma
r_sizeof
(paren
id|SCRIPT
)paren
)paren
suffix:semicolon
multiline_comment|/* Fixup labels */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PATCHES
suffix:semicolon
op_increment
id|i
)paren
id|hostdata-&gt;script
(braket
id|LABELPATCHES
(braket
id|i
)braket
)braket
op_add_assign
id|virt_to_bus
c_func
(paren
id|hostdata-&gt;script
)paren
suffix:semicolon
multiline_comment|/* Fixup addresses of constants that used to be EXTERNAL */
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|NCR53c7xx_msg_abort
comma
id|virt_to_bus
c_func
(paren
op_amp
(paren
id|hostdata-&gt;NCR53c7xx_msg_abort
)paren
)paren
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|NCR53c7xx_msg_reject
comma
id|virt_to_bus
c_func
(paren
op_amp
(paren
id|hostdata-&gt;NCR53c7xx_msg_reject
)paren
)paren
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|NCR53c7xx_zero
comma
id|virt_to_bus
c_func
(paren
op_amp
(paren
id|hostdata-&gt;NCR53c7xx_zero
)paren
)paren
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|NCR53c7xx_sink
comma
id|virt_to_bus
c_func
(paren
op_amp
(paren
id|hostdata-&gt;NCR53c7xx_sink
)paren
)paren
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|NOP_insn
comma
id|virt_to_bus
c_func
(paren
op_amp
(paren
id|hostdata-&gt;NOP_insn
)paren
)paren
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|schedule
comma
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
id|hostdata-&gt;schedule
)paren
)paren
suffix:semicolon
multiline_comment|/* Fixup references to external variables: */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|EXTERNAL_PATCHES_LEN
suffix:semicolon
op_increment
id|i
)paren
id|hostdata-&gt;script
(braket
id|EXTERNAL_PATCHES
(braket
id|i
)braket
dot
id|offset
)braket
op_add_assign
id|virt_to_bus
c_func
(paren
id|EXTERNAL_PATCHES
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
multiline_comment|/* &n;     * Fixup absolutes set at boot-time.&n;     * &n;     * All non-code absolute variables suffixed with &quot;dsa_&quot; and &quot;int_&quot;&n;     * are constants, and need no fixup provided the assembler has done &n;     * it for us (I don&squot;t know what the &quot;real&quot; NCR assembler does in &n;     * this case, my assembler does the right magic).&n;     */
id|patch_abs_rwri_data
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|dsa_save_data_pointer
comma
id|Ent_dsa_code_save_data_pointer
op_minus
id|Ent_dsa_zero
)paren
suffix:semicolon
id|patch_abs_rwri_data
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|dsa_restore_pointers
comma
id|Ent_dsa_code_restore_pointers
op_minus
id|Ent_dsa_zero
)paren
suffix:semicolon
id|patch_abs_rwri_data
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|dsa_check_reselect
comma
id|Ent_dsa_code_check_reselect
op_minus
id|Ent_dsa_zero
)paren
suffix:semicolon
multiline_comment|/*&n;     * Just for the hell of it, preserve the settings of &n;     * Burst Length and Enable Read Line bits from the DMODE &n;     * register.  Make sure SCRIPTS start automagically.&n;     */
id|tmp
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|DMODE_REG_10
)paren
suffix:semicolon
id|tmp
op_and_assign
(paren
id|DMODE_800_ERL
op_or
id|DMODE_BL_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_MEMORY_MAPPED
)paren
)paren
(brace
id|base
op_assign
(paren
id|u32
)paren
id|host-&gt;io_port
suffix:semicolon
id|memory_to_ncr
op_assign
id|tmp
op_or
id|DMODE_800_DIOM
suffix:semicolon
id|ncr_to_memory
op_assign
id|tmp
op_or
id|DMODE_800_SIOM
suffix:semicolon
)brace
r_else
(brace
id|base
op_assign
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
id|host-&gt;base
)paren
suffix:semicolon
id|memory_to_ncr
op_assign
id|ncr_to_memory
op_assign
id|tmp
suffix:semicolon
)brace
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|addr_scratch
comma
id|base
op_plus
id|SCRATCHA_REG_800
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|addr_temp
comma
id|base
op_plus
id|TEMP_REG
)paren
suffix:semicolon
multiline_comment|/*&n;     * I needed some variables in the script to be accessible to &n;     * both the NCR chip and the host processor. For these variables,&n;     * I made the arbitrary decision to store them directly in the &n;     * hostdata structure rather than in the RELATIVE area of the &n;     * SCRIPTS.&n;     */
id|patch_abs_rwri_data
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|dmode_memory_to_memory
comma
id|tmp
)paren
suffix:semicolon
id|patch_abs_rwri_data
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|dmode_memory_to_ncr
comma
id|memory_to_ncr
)paren
suffix:semicolon
id|patch_abs_rwri_data
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|dmode_ncr_to_memory
comma
id|ncr_to_memory
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|msg_buf
comma
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
(paren
id|hostdata-&gt;msg_buf
)paren
)paren
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|reconnect_dsa_head
comma
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
(paren
id|hostdata-&gt;reconnect_dsa_head
)paren
)paren
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|addr_reconnect_dsa_head
comma
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
(paren
id|hostdata-&gt;addr_reconnect_dsa_head
)paren
)paren
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|reselected_identify
comma
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
(paren
id|hostdata-&gt;reselected_identify
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* reselected_tag is currently unused */
macro_line|#if 0
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|reselected_tag
comma
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
(paren
id|hostdata-&gt;reselected_tag
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|test_dest
comma
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|hostdata-&gt;test_dest
)paren
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|test_src
comma
id|virt_to_bus
c_func
(paren
op_amp
id|hostdata-&gt;test_source
)paren
)paren
suffix:semicolon
id|patch_abs_rwri_data
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|dsa_check_reselect
comma
(paren
r_int
r_char
)paren
(paren
id|Ent_dsa_code_check_reselect
op_minus
id|Ent_dsa_zero
)paren
)paren
suffix:semicolon
multiline_comment|/* These are for event logging; the ncr_event enum contains the &n;   actual interrupt numbers. */
macro_line|#ifdef A_int_EVENT_SELECT
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|int_EVENT_SELECT
comma
(paren
id|u32
)paren
id|EVENT_SELECT
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_EVENT_DISCONNECT
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|int_EVENT_DISCONNECT
comma
(paren
id|u32
)paren
id|EVENT_DISCONNECT
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_EVENT_RESELECT
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|int_EVENT_RESELECT
comma
(paren
id|u32
)paren
id|EVENT_RESELECT
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_EVENT_COMPLETE
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|int_EVENT_COMPLETE
comma
(paren
id|u32
)paren
id|EVENT_COMPLETE
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_EVENT_IDLE
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|int_EVENT_IDLE
comma
(paren
id|u32
)paren
id|EVENT_IDLE
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_EVENT_SELECT_FAILED
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|int_EVENT_SELECT_FAILED
comma
(paren
id|u32
)paren
id|EVENT_SELECT_FAILED
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_EVENT_BEFORE_SELECT
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|int_EVENT_BEFORE_SELECT
comma
(paren
id|u32
)paren
id|EVENT_BEFORE_SELECT
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_EVENT_RESELECT_FAILED
id|patch_abs_32
(paren
id|hostdata-&gt;script
comma
l_int|0
comma
id|int_EVENT_RESELECT_FAILED
comma
(paren
id|u32
)paren
id|EVENT_RESELECT_FAILED
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;     * Make sure the NCR and Linux code agree on the location of &n;     * certain fields.&n;     */
id|hostdata-&gt;E_accept_message
op_assign
id|Ent_accept_message
suffix:semicolon
id|hostdata-&gt;E_command_complete
op_assign
id|Ent_command_complete
suffix:semicolon
id|hostdata-&gt;E_cmdout_cmdout
op_assign
id|Ent_cmdout_cmdout
suffix:semicolon
id|hostdata-&gt;E_data_transfer
op_assign
id|Ent_data_transfer
suffix:semicolon
id|hostdata-&gt;E_debug_break
op_assign
id|Ent_debug_break
suffix:semicolon
id|hostdata-&gt;E_dsa_code_template
op_assign
id|Ent_dsa_code_template
suffix:semicolon
id|hostdata-&gt;E_dsa_code_template_end
op_assign
id|Ent_dsa_code_template_end
suffix:semicolon
id|hostdata-&gt;E_end_data_transfer
op_assign
id|Ent_end_data_transfer
suffix:semicolon
id|hostdata-&gt;E_initiator_abort
op_assign
id|Ent_initiator_abort
suffix:semicolon
id|hostdata-&gt;E_msg_in
op_assign
id|Ent_msg_in
suffix:semicolon
id|hostdata-&gt;E_other_transfer
op_assign
id|Ent_other_transfer
suffix:semicolon
id|hostdata-&gt;E_other_in
op_assign
id|Ent_other_in
suffix:semicolon
id|hostdata-&gt;E_other_out
op_assign
id|Ent_other_out
suffix:semicolon
id|hostdata-&gt;E_reject_message
op_assign
id|Ent_reject_message
suffix:semicolon
id|hostdata-&gt;E_respond_message
op_assign
id|Ent_respond_message
suffix:semicolon
id|hostdata-&gt;E_select
op_assign
id|Ent_select
suffix:semicolon
id|hostdata-&gt;E_select_msgout
op_assign
id|Ent_select_msgout
suffix:semicolon
id|hostdata-&gt;E_target_abort
op_assign
id|Ent_target_abort
suffix:semicolon
macro_line|#ifdef Ent_test_0
id|hostdata-&gt;E_test_0
op_assign
id|Ent_test_0
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;E_test_1
op_assign
id|Ent_test_1
suffix:semicolon
id|hostdata-&gt;E_test_2
op_assign
id|Ent_test_2
suffix:semicolon
macro_line|#ifdef Ent_test_3
id|hostdata-&gt;E_test_3
op_assign
id|Ent_test_3
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;E_wait_reselect
op_assign
id|Ent_wait_reselect
suffix:semicolon
id|hostdata-&gt;E_dsa_code_begin
op_assign
id|Ent_dsa_code_begin
suffix:semicolon
id|hostdata-&gt;dsa_cmdout
op_assign
id|A_dsa_cmdout
suffix:semicolon
id|hostdata-&gt;dsa_cmnd
op_assign
id|A_dsa_cmnd
suffix:semicolon
id|hostdata-&gt;dsa_datain
op_assign
id|A_dsa_datain
suffix:semicolon
id|hostdata-&gt;dsa_dataout
op_assign
id|A_dsa_dataout
suffix:semicolon
id|hostdata-&gt;dsa_end
op_assign
id|A_dsa_end
suffix:semicolon
id|hostdata-&gt;dsa_msgin
op_assign
id|A_dsa_msgin
suffix:semicolon
id|hostdata-&gt;dsa_msgout
op_assign
id|A_dsa_msgout
suffix:semicolon
id|hostdata-&gt;dsa_msgout_other
op_assign
id|A_dsa_msgout_other
suffix:semicolon
id|hostdata-&gt;dsa_next
op_assign
id|A_dsa_next
suffix:semicolon
id|hostdata-&gt;dsa_select
op_assign
id|A_dsa_select
suffix:semicolon
id|hostdata-&gt;dsa_start
op_assign
id|Ent_dsa_code_template
op_minus
id|Ent_dsa_zero
suffix:semicolon
id|hostdata-&gt;dsa_status
op_assign
id|A_dsa_status
suffix:semicolon
id|hostdata-&gt;dsa_jump_dest
op_assign
id|Ent_dsa_code_fix_jump
op_minus
id|Ent_dsa_zero
op_plus
l_int|8
multiline_comment|/* destination operand */
suffix:semicolon
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|A_dsa_fields_start
op_ne
id|Ent_dsa_code_template_end
op_minus
id|Ent_dsa_zero
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : NCR dsa_fields start is %d not %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|A_dsa_fields_start
comma
id|Ent_dsa_code_template_end
op_minus
id|Ent_dsa_zero
)paren
suffix:semicolon
macro_line|#ifdef __powerpc__
multiline_comment|/* The PowerPC is Big Endian - adjust script appropriately */
id|script_ptr
op_assign
id|hostdata-&gt;script
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|SCRIPT
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
r_int
)paren
)paren
(brace
op_star
id|script_ptr
op_increment
op_assign
id|le32_to_cpu
c_func
(paren
op_star
id|script_ptr
)paren
suffix:semicolon
)brace
macro_line|#endif    &t;    
id|printk
c_func
(paren
l_string|&quot;scsi%d : NCR code relocated to 0x%lx (virt 0x%p)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|virt_to_bus
c_func
(paren
id|hostdata-&gt;script
)paren
comma
id|hostdata-&gt;script
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : static int NCR53c8xx_run_tests (struct Scsi_Host *host)&n; *&n; * Purpose : run various verification tests on the NCR chip, &n; *&t;including interrupt generation, and proper bus mastering&n; * &t;operation.&n; * &n; * Inputs : host - a properly initialized Scsi_Host structure&n; *&n; * Preconditions : the NCR chip must be in a halted state.&n; *&n; * Returns : 0 if all tests were successful, -1 on error.&n; * &n; */
r_static
r_int
DECL|function|NCR53c8xx_run_tests
id|NCR53c8xx_run_tests
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|u32
id|start
suffix:semicolon
r_int
id|failed
comma
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* The NCR chip _must_ be idle to run the test scripts */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;idle
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : chip not idle, aborting tests&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n;     * Check for functional interrupts, this could work as an&n;     * autoprobe routine.&n;     */
r_if
c_cond
(paren
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_TEST1
)paren
op_logical_and
id|hostdata-&gt;state
op_ne
id|STATE_DISABLED
)paren
(brace
id|hostdata-&gt;idle
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;test_running
op_assign
l_int|1
suffix:semicolon
id|hostdata-&gt;test_completed
op_assign
op_minus
l_int|1
suffix:semicolon
id|hostdata-&gt;test_dest
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;test_source
op_assign
l_int|0xdeadbeef
suffix:semicolon
id|start
op_assign
id|virt_to_bus
(paren
id|hostdata-&gt;script
)paren
op_plus
id|hostdata-&gt;E_test_1
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|STATE_RUNNING
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : test 1&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|NCR53c7x0_write32
(paren
id|DSP_REG
comma
id|start
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot; started&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * This is currently a .5 second timeout, since (in theory) no slow &n;&t; * board will take that long.  In practice, we&squot;ve seen one &n;&t; * pentium which occasionally fails with this, but works with &n;&t; * 10 times as much?&n;&t; */
id|timeout
op_assign
id|jiffies
op_plus
l_int|5
op_star
id|HZ
op_div
l_int|10
suffix:semicolon
r_while
c_loop
(paren
(paren
id|hostdata-&gt;test_completed
op_eq
op_minus
l_int|1
)paren
op_logical_and
id|jiffies
OL
id|timeout
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|failed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;test_completed
op_eq
op_minus
l_int|1
)paren
id|printk
(paren
l_string|&quot;scsi%d : driver test 1 timed out%s&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
id|hostdata-&gt;test_dest
op_eq
l_int|0xdeadbeef
)paren
ques
c_cond
l_string|&quot; due to lost interrupt.&bslash;n&quot;
l_string|&quot;         Please verify that the correct IRQ is being used for your board,&bslash;n&quot;
l_string|&quot;&t;      and that the motherboard IRQ jumpering matches the PCI setup on&bslash;n&quot;
l_string|&quot;         PCI systems.&bslash;n&quot;
l_string|&quot;         If you are using a NCR53c810 board in a PCI system, you should&bslash;n&quot;
l_string|&quot;         also verify that the board is jumpered to use PCI INTA, since&bslash;n&quot;
l_string|&quot;         most PCI motherboards lack support for INTB, INTC, and INTD.&bslash;n&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hostdata-&gt;test_completed
op_ne
l_int|1
)paren
id|printk
(paren
l_string|&quot;scsi%d : test 1 bad interrupt value (%d)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|hostdata-&gt;test_completed
)paren
suffix:semicolon
r_else
id|failed
op_assign
(paren
id|hostdata-&gt;test_dest
op_ne
l_int|0xdeadbeef
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;test_dest
op_ne
l_int|0xdeadbeef
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : driver test 1 read 0x%x instead of 0xdeadbeef indicating a&bslash;n&quot;
l_string|&quot;         probable cache invalidation problem.  Please configure caching&bslash;n&quot;
l_string|&quot;         as write-through or disabled&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|hostdata-&gt;test_dest
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|failed
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : DSP = 0x%p (script at 0x%p, start at 0x%x)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|bus_to_virt
c_func
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DSP_REG
)paren
)paren
comma
id|hostdata-&gt;script
comma
id|start
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : DSPS = 0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|NCR53c7x0_read32
c_func
(paren
id|DSPS_REG
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|hostdata-&gt;test_running
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_TEST2
)paren
op_logical_and
id|hostdata-&gt;state
op_ne
id|STATE_DISABLED
)paren
(brace
id|u32
id|dsa
(braket
l_int|48
)braket
suffix:semicolon
r_int
r_char
id|identify
op_assign
id|IDENTIFY
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_int
r_char
id|cmd
(braket
l_int|6
)braket
suffix:semicolon
r_int
r_char
id|data
(braket
l_int|36
)braket
suffix:semicolon
r_int
r_char
id|status
op_assign
l_int|0xff
suffix:semicolon
r_int
r_char
id|msg
op_assign
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
id|cmd
(braket
l_int|2
)braket
op_assign
id|cmd
(braket
l_int|3
)braket
op_assign
id|cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/* Need to adjust for endian-ness */
id|dsa
(braket
l_int|2
)braket
op_assign
id|le32_to_cpu
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|dsa
(braket
l_int|3
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
op_amp
id|identify
)paren
)paren
suffix:semicolon
id|dsa
(braket
l_int|4
)braket
op_assign
id|le32_to_cpu
c_func
(paren
l_int|6
)paren
suffix:semicolon
id|dsa
(braket
l_int|5
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
op_amp
id|cmd
)paren
)paren
suffix:semicolon
id|dsa
(braket
l_int|6
)braket
op_assign
id|le32_to_cpu
c_func
(paren
r_sizeof
(paren
id|data
)paren
)paren
suffix:semicolon
id|dsa
(braket
l_int|7
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
op_amp
id|data
)paren
)paren
suffix:semicolon
id|dsa
(braket
l_int|8
)braket
op_assign
id|le32_to_cpu
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|dsa
(braket
l_int|9
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
op_amp
id|status
)paren
)paren
suffix:semicolon
id|dsa
(braket
l_int|10
)braket
op_assign
id|le32_to_cpu
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|dsa
(braket
l_int|11
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
op_amp
id|msg
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
op_increment
id|i
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;idle
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : chip not idle, aborting tests&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&t;     SCNTL3         SDID&t;*/
id|dsa
(braket
l_int|0
)braket
op_assign
id|le32_to_cpu
c_func
(paren
(paren
l_int|0x33
op_lshift
l_int|24
)paren
op_or
(paren
id|i
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
id|hostdata-&gt;idle
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;test_running
op_assign
l_int|2
suffix:semicolon
id|hostdata-&gt;test_completed
op_assign
op_minus
l_int|1
suffix:semicolon
id|start
op_assign
id|virt_to_bus
c_func
(paren
id|hostdata-&gt;script
)paren
op_plus
id|hostdata-&gt;E_test_2
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|STATE_RUNNING
suffix:semicolon
id|NCR53c7x0_write32
(paren
id|DSA_REG
comma
id|virt_to_bus
c_func
(paren
id|dsa
)paren
)paren
suffix:semicolon
id|NCR53c7x0_write32
(paren
id|DSP_REG
comma
id|start
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
l_int|5
op_star
id|HZ
suffix:semicolon
multiline_comment|/* arbitrary */
r_while
c_loop
(paren
(paren
id|hostdata-&gt;test_completed
op_eq
op_minus
l_int|1
)paren
op_logical_and
id|jiffies
OL
id|timeout
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|NCR53c7x0_write32
(paren
id|DSA_REG
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;test_completed
op_eq
l_int|2
)paren
(brace
id|data
(braket
l_int|35
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : test 2 INQUIRY to target %d, lun 0 : %s&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|i
comma
id|data
op_plus
l_int|8
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : status &quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_status
(paren
id|status
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;nscsi%d : message &quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_msg
(paren
op_amp
id|msg
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hostdata-&gt;test_completed
op_eq
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : test 2 no connection with target %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;idle
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : not idle&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|hostdata-&gt;test_completed
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : test 2 timed out&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|hostdata-&gt;test_running
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : static void NCR53c8xx_dsa_fixup (struct NCR53c7x0_cmd *cmd)&n; *&n; * Purpose : copy the NCR53c8xx dsa structure into cmd&squot;s dsa buffer,&n; * &t;performing all necessary relocation.&n; *&n; * Inputs : cmd, a NCR53c7x0_cmd structure with a dsa area large&n; *&t;enough to hold the NCR53c8xx dsa.&n; */
r_static
r_void
DECL|function|NCR53c8xx_dsa_fixup
id|NCR53c8xx_dsa_fixup
(paren
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
(brace
id|Scsi_Cmnd
op_star
id|c
op_assign
id|cmd-&gt;cmd
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|c-&gt;host
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef __powerpc__
r_int
id|len
suffix:semicolon
r_int
r_int
op_star
id|dsa_ptr
suffix:semicolon
macro_line|#endif    
id|memcpy
(paren
id|cmd-&gt;dsa
comma
id|hostdata-&gt;script
op_plus
(paren
id|hostdata-&gt;E_dsa_code_template
op_div
l_int|4
)paren
comma
id|hostdata-&gt;E_dsa_code_template_end
op_minus
id|hostdata-&gt;E_dsa_code_template
)paren
suffix:semicolon
macro_line|#ifdef __powerpc__
multiline_comment|/* Note: the script has already been &squot;endianized&squot; */
id|dsa_ptr
op_assign
id|cmd-&gt;dsa
suffix:semicolon
id|len
op_assign
id|hostdata-&gt;E_dsa_code_template_end
op_minus
id|hostdata-&gt;E_dsa_code_template
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
r_int
)paren
)paren
(brace
op_star
id|dsa_ptr
op_increment
op_assign
id|le32_to_cpu
c_func
(paren
op_star
id|dsa_ptr
)paren
suffix:semicolon
)brace
macro_line|#endif    &t;
multiline_comment|/* &n;     * Note : within the NCR &squot;C&squot; code, dsa points to the _start_&n;     * of the DSA structure, and _not_ the offset of dsa_zero within&n;     * that structure used to facilitate shorter signed offsets&n;     * for the 8 bit ALU.&n;     * &n;     * The implications of this are that &n;     * &n;     * - 32 bit A_dsa_* absolute values require an additional &n;     * &t; dsa_zero added to their value to be correct, since they are &n;     *   relative to dsa_zero which is in essentially a separate&n;     *   space from the code symbols.&n;     *&n;     * - All other symbols require no special treatment.&n;     */
id|patch_abs_tci_data
(paren
id|cmd-&gt;dsa
comma
id|Ent_dsa_code_template
op_div
r_sizeof
(paren
id|u32
)paren
comma
id|dsa_temp_lun
comma
id|c-&gt;lun
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|cmd-&gt;dsa
comma
id|Ent_dsa_code_template
op_div
r_sizeof
(paren
id|u32
)paren
comma
id|dsa_temp_addr_next
comma
id|virt_to_bus
c_func
(paren
op_amp
id|cmd-&gt;dsa_next_addr
)paren
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|cmd-&gt;dsa
comma
id|Ent_dsa_code_template
op_div
r_sizeof
(paren
id|u32
)paren
comma
id|dsa_temp_next
comma
id|virt_to_bus
c_func
(paren
id|cmd-&gt;dsa
)paren
op_plus
id|Ent_dsa_zero
op_minus
id|Ent_dsa_code_template
op_plus
id|A_dsa_next
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|cmd-&gt;dsa
comma
id|Ent_dsa_code_template
op_div
r_sizeof
(paren
id|u32
)paren
comma
id|dsa_temp_sync
comma
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
id|hostdata-&gt;sync
(braket
id|c-&gt;target
)braket
dot
id|script
)paren
)paren
suffix:semicolon
id|patch_abs_tci_data
(paren
id|cmd-&gt;dsa
comma
id|Ent_dsa_code_template
op_div
r_sizeof
(paren
id|u32
)paren
comma
id|dsa_temp_target
comma
id|c-&gt;target
)paren
suffix:semicolon
multiline_comment|/* XXX - new pointer stuff */
id|patch_abs_32
(paren
id|cmd-&gt;dsa
comma
id|Ent_dsa_code_template
op_div
r_sizeof
(paren
id|u32
)paren
comma
id|dsa_temp_addr_saved_pointer
comma
id|virt_to_bus
c_func
(paren
op_amp
id|cmd-&gt;saved_data_pointer
)paren
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|cmd-&gt;dsa
comma
id|Ent_dsa_code_template
op_div
r_sizeof
(paren
id|u32
)paren
comma
id|dsa_temp_addr_saved_residual
comma
id|virt_to_bus
c_func
(paren
op_amp
id|cmd-&gt;saved_residual
)paren
)paren
suffix:semicolon
id|patch_abs_32
(paren
id|cmd-&gt;dsa
comma
id|Ent_dsa_code_template
op_div
r_sizeof
(paren
id|u32
)paren
comma
id|dsa_temp_addr_residual
comma
id|virt_to_bus
c_func
(paren
op_amp
id|cmd-&gt;residual
)paren
)paren
suffix:semicolon
multiline_comment|/*  XXX - new start stuff */
id|patch_abs_32
(paren
id|cmd-&gt;dsa
comma
id|Ent_dsa_code_template
op_div
r_sizeof
(paren
id|u32
)paren
comma
id|dsa_temp_addr_dsa_value
comma
id|virt_to_bus
c_func
(paren
op_amp
id|cmd-&gt;dsa_addr
)paren
)paren
suffix:semicolon
macro_line|#ifdef __powerpc__
id|dsa_ptr
op_assign
id|cmd-&gt;dsa
suffix:semicolon
id|len
op_assign
id|hostdata-&gt;E_dsa_code_template_end
op_minus
id|hostdata-&gt;E_dsa_code_template
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
r_int
)paren
)paren
(brace
op_star
id|dsa_ptr
op_increment
op_assign
id|le32_to_cpu
c_func
(paren
op_star
id|dsa_ptr
)paren
suffix:semicolon
)brace
macro_line|#endif    &t;
)brace
multiline_comment|/* &n; * Function : run_process_issue_queue (void)&n; * &n; * Purpose : insure that the coroutine is running and will process our &n; * &t;request.  process_issue_queue_running is checked/set here (in an &n; *&t;inline function) rather than in process_issue_queue itself to reduce &n; * &t;the chances of stack overflow.&n; *&n; */
DECL|variable|process_issue_queue_running
r_static
r_volatile
r_int
id|process_issue_queue_running
op_assign
l_int|0
suffix:semicolon
r_static
id|__inline__
r_void
DECL|function|run_process_issue_queue
id|run_process_issue_queue
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|process_issue_queue_running
)paren
(brace
id|process_issue_queue_running
op_assign
l_int|1
suffix:semicolon
id|process_issue_queue
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* &n;         * process_issue_queue_running is cleared in process_issue_queue &n;&t; * once it can&squot;t do more work, and process_issue_queue exits with &n;&t; * interrupts disabled.&n;&t; */
)brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : static void abnormal_finished (struct NCR53c7x0_cmd *cmd, int&n; *&t;result)&n; *&n; * Purpose : mark SCSI command as finished, OR&squot;ing the host portion &n; *&t;of the result word into the result field of the corresponding&n; *&t;Scsi_Cmnd structure, and removing it from the internal queues.&n; *&n; * Inputs : cmd - command, result - entire result field&n; *&n; * Preconditions : the &t;NCR chip should be in a halted state when &n; *&t;abnormal_finished is run, since it modifies structures which&n; *&t;the NCR expects to have exclusive access to.&n; */
r_static
r_void
DECL|function|abnormal_finished
id|abnormal_finished
(paren
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
comma
r_int
id|result
)paren
(brace
id|Scsi_Cmnd
op_star
id|c
op_assign
id|cmd-&gt;cmd
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|c-&gt;host
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|left
comma
id|found
suffix:semicolon
r_volatile
r_struct
id|NCR53c7x0_cmd
op_star
id|linux_search
suffix:semicolon
r_volatile
r_struct
id|NCR53c7x0_cmd
op_star
r_volatile
op_star
id|linux_prev
suffix:semicolon
r_volatile
id|u32
op_star
id|ncr_prev
comma
op_star
id|curr
comma
id|ncr_search
suffix:semicolon
macro_line|#if 0
id|printk
(paren
l_string|&quot;scsi%d: abnormal finished&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|found
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;     * Traverse the NCR issue array until we find a match or run out &n;     * of instructions.  Instructions in the NCR issue array are &n;     * either JUMP or NOP instructions, which are 2 words in length.&n;     */
r_for
c_loop
(paren
id|found
op_assign
l_int|0
comma
id|left
op_assign
id|host-&gt;can_queue
comma
id|curr
op_assign
id|hostdata-&gt;schedule
suffix:semicolon
id|left
OG
l_int|0
suffix:semicolon
op_decrement
id|left
comma
id|curr
op_add_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|issue_to_cmd
(paren
id|host
comma
id|hostdata
comma
(paren
id|u32
op_star
)paren
id|curr
)paren
op_eq
id|cmd
)paren
(brace
id|curr
(braket
l_int|0
)braket
op_assign
id|hostdata-&gt;NOP_insn
suffix:semicolon
id|curr
(braket
l_int|1
)braket
op_assign
id|le32_to_cpu
c_func
(paren
l_int|0xdeadbeef
)paren
suffix:semicolon
op_increment
id|found
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;     * Traverse the NCR reconnect list of DSA structures until we find &n;     * a pointer to this dsa or have found too many command structures.  &n;     * We let prev point at the next field of the previous element or &n;     * head of the list, so we don&squot;t do anything different for removing &n;     * the head element.  &n;     */
r_for
c_loop
(paren
id|left
op_assign
id|host-&gt;can_queue
comma
id|ncr_search
op_assign
id|le32_to_cpu
c_func
(paren
id|hostdata-&gt;reconnect_dsa_head
)paren
comma
id|ncr_prev
op_assign
op_amp
id|hostdata-&gt;reconnect_dsa_head
suffix:semicolon
id|left
op_ge
l_int|0
op_logical_and
id|ncr_search
op_logical_and
(paren
(paren
r_char
op_star
)paren
id|bus_to_virt
c_func
(paren
id|ncr_search
)paren
op_plus
id|hostdata-&gt;dsa_start
)paren
op_ne
(paren
r_char
op_star
)paren
id|cmd-&gt;dsa
suffix:semicolon
id|ncr_prev
op_assign
(paren
id|u32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|bus_to_virt
c_func
(paren
id|ncr_search
)paren
op_plus
id|hostdata-&gt;dsa_next
)paren
comma
id|ncr_search
op_assign
id|le32_to_cpu
c_func
(paren
op_star
id|ncr_prev
)paren
comma
op_decrement
id|left
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: loop detected in ncr reconnect list&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ncr_search
)paren
(brace
r_if
c_cond
(paren
id|found
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d: scsi %ld in ncr issue array and reconnect lists&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|c-&gt;pid
)paren
suffix:semicolon
r_else
(brace
r_volatile
id|u32
op_star
id|next
op_assign
(paren
id|u32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|bus_to_virt
c_func
(paren
id|ncr_search
)paren
op_plus
id|hostdata-&gt;dsa_next
)paren
suffix:semicolon
op_star
id|ncr_prev
op_assign
op_star
id|next
suffix:semicolon
multiline_comment|/* If we&squot;re at the tail end of the issue queue, update that pointer too. */
id|found
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * Traverse the host running list until we find this command or discover&n;     * we have too many elements, pointing linux_prev at the next field of the &n;     * linux_previous element or head of the list, search at this element.&n;     */
r_for
c_loop
(paren
id|left
op_assign
id|host-&gt;can_queue
comma
id|linux_search
op_assign
id|hostdata-&gt;running_list
comma
id|linux_prev
op_assign
op_amp
id|hostdata-&gt;running_list
suffix:semicolon
id|left
op_ge
l_int|0
op_logical_and
id|linux_search
op_logical_and
id|linux_search
op_ne
id|cmd
suffix:semicolon
id|linux_prev
op_assign
op_amp
(paren
id|linux_search-&gt;next
)paren
comma
id|linux_search
op_assign
id|linux_search-&gt;next
comma
op_decrement
id|left
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
OL
l_int|0
)paren
id|printk
(paren
l_string|&quot;scsi%d: loop detected in host running list for scsi pid %ld&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|c-&gt;pid
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|linux_search
)paren
(brace
op_star
id|linux_prev
op_assign
id|linux_search-&gt;next
suffix:semicolon
op_decrement
id|hostdata-&gt;busy
(braket
id|c-&gt;target
)braket
(braket
id|c-&gt;lun
)braket
suffix:semicolon
)brace
multiline_comment|/* Return the NCR command structure to the free list */
id|cmd-&gt;next
op_assign
id|hostdata-&gt;free
suffix:semicolon
id|hostdata-&gt;free
op_assign
id|cmd
suffix:semicolon
id|c-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* And return */
id|c-&gt;result
op_assign
id|result
suffix:semicolon
id|c
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|c
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|run_process_issue_queue
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : static void intr_break (struct Scsi_Host *host,&n; * &t;struct NCR53c7x0_cmd *cmd)&n; *&n; * Purpose :  Handler for breakpoint interrupts from a SCSI script&n; *&n; * Inputs : host - pointer to this host adapter&squot;s structure,&n; * &t;cmd - pointer to the command (if any) dsa was pointing &n; * &t;to.&n; *&n; */
r_static
r_void
DECL|function|intr_break
id|intr_break
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_break
op_star
id|bp
suffix:semicolon
macro_line|#if 0
id|Scsi_Cmnd
op_star
id|c
op_assign
id|cmd
ques
c_cond
id|cmd-&gt;cmd
suffix:colon
l_int|NULL
suffix:semicolon
macro_line|#endif
id|u32
op_star
id|dsp
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/*&n;     * Find the break point corresponding to this address, and &n;     * dump the appropriate debugging information to standard &n;     * output.  &n;     */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dsp
op_assign
(paren
id|u32
op_star
)paren
id|bus_to_virt
c_func
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DSP_REG
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bp
op_assign
id|hostdata-&gt;breakpoints
suffix:semicolon
id|bp
op_logical_and
id|bp-&gt;address
op_ne
id|dsp
suffix:semicolon
id|bp
op_assign
id|bp-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
id|panic
c_func
(paren
l_string|&quot;scsi%d : break point interrupt from %p with no breakpoint!&quot;
comma
id|host-&gt;host_no
comma
id|dsp
)paren
suffix:semicolon
multiline_comment|/*&n;     * Configure the NCR chip for manual start mode, so that we can &n;     * point the DSP register at the instruction that follows the &n;     * INT int_debug_break instruction.&n;     */
id|NCR53c7x0_write8
(paren
id|hostdata-&gt;dmode
comma
id|NCR53c7x0_read8
c_func
(paren
id|hostdata-&gt;dmode
)paren
op_or
id|DMODE_MAN
)paren
suffix:semicolon
multiline_comment|/*&n;     * And update the DSP register, using the size of the old &n;     * instruction in bytes.&n;     */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : static void print_synchronous (const char *prefix, &n; *&t;const unsigned char *msg)&n; * &n; * Purpose : print a pretty, user and machine parsable representation&n; *&t;of a SDTR message, including the &quot;real&quot; parameters, data&n; *&t;clock so we can tell transfer rate at a glance.&n; *&n; * Inputs ; prefix - text to prepend, msg - SDTR message (5 bytes)&n; */
r_static
r_void
DECL|function|print_synchronous
id|print_synchronous
(paren
r_const
r_char
op_star
id|prefix
comma
r_const
r_int
r_char
op_star
id|msg
)paren
(brace
r_if
c_cond
(paren
id|msg
(braket
l_int|4
)braket
)paren
(brace
r_int
id|Hz
op_assign
l_int|1000000000
op_div
(paren
id|msg
(braket
l_int|3
)braket
op_star
l_int|4
)paren
suffix:semicolon
r_int
id|integer
op_assign
id|Hz
op_div
l_int|1000000
suffix:semicolon
r_int
id|fraction
op_assign
(paren
id|Hz
op_minus
(paren
id|integer
op_star
l_int|1000000
)paren
)paren
op_div
l_int|10000
suffix:semicolon
id|printk
(paren
l_string|&quot;%speriod %dns offset %d %d.%02dMHz %s SCSI%s&bslash;n&quot;
comma
id|prefix
comma
(paren
r_int
)paren
id|msg
(braket
l_int|3
)braket
op_star
l_int|4
comma
(paren
r_int
)paren
id|msg
(braket
l_int|4
)braket
comma
id|integer
comma
id|fraction
comma
(paren
(paren
(paren
id|msg
(braket
l_int|3
)braket
op_star
l_int|4
)paren
OL
l_int|200
)paren
ques
c_cond
l_string|&quot;FAST&quot;
suffix:colon
l_string|&quot;synchronous&quot;
)paren
comma
(paren
(paren
(paren
id|msg
(braket
l_int|3
)braket
op_star
l_int|4
)paren
OL
l_int|200
)paren
ques
c_cond
l_string|&quot;-II&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
id|printk
(paren
l_string|&quot;%sasynchronous SCSI&bslash;n&quot;
comma
id|prefix
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : static void set_synchronous (struct Scsi_Host *host, &n; *&t; &t;int target, int sxfer, int scntl3, int now_connected)&n; *&n; * Purpose : reprogram transfers between the selected SCSI initiator and &n; *&t;target with the given register values; in the indirect&n; *&t;select operand, reselection script, and chip registers.&n; *&n; * Inputs : host - NCR53c7,8xx SCSI host, target - number SCSI target id,&n; *&t;sxfer and scntl3 - NCR registers. now_connected - if non-zero, &n; *&t;we should reprogram the registers now too.&n; */
r_static
r_void
DECL|function|set_synchronous
id|set_synchronous
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_int
id|target
comma
r_int
id|sxfer
comma
r_int
id|scntl3
comma
r_int
id|now_connected
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|u32
op_star
id|script
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* These are eight bit registers */
id|sxfer
op_and_assign
l_int|0xff
suffix:semicolon
id|scntl3
op_and_assign
l_int|0xff
suffix:semicolon
id|hostdata-&gt;sync
(braket
id|target
)braket
dot
id|sxfer_sanity
op_assign
id|sxfer
suffix:semicolon
id|hostdata-&gt;sync
(braket
id|target
)braket
dot
id|scntl3_sanity
op_assign
id|scntl3
suffix:semicolon
multiline_comment|/* &n; * HARD CODED : synchronous script is EIGHT words long.  This &n; * must agree with 53c7.8xx.h&n; */
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_ne
l_int|700
)paren
op_logical_and
(paren
id|hostdata-&gt;chip
op_ne
l_int|70066
)paren
)paren
(brace
id|hostdata-&gt;sync
(braket
id|target
)braket
dot
id|select_indirect
op_assign
(paren
id|scntl3
op_lshift
l_int|24
)paren
op_or
(paren
id|target
op_lshift
l_int|16
)paren
op_or
(paren
id|sxfer
op_lshift
l_int|8
)paren
suffix:semicolon
id|script
op_assign
(paren
id|u32
op_star
)paren
id|hostdata-&gt;sync
(braket
id|target
)braket
dot
id|script
suffix:semicolon
multiline_comment|/* XXX - add NCR53c7x0 code to reprogram SCF bits if we want to */
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
(brace
id|script
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|DCMD_TYPE_RWRI
op_or
id|DCMD_RWRI_OPC_MODIFY
op_or
id|DCMD_RWRI_OP_MOVE
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|SCNTL3_REG_800
op_lshift
l_int|16
)paren
op_or
(paren
id|scntl3
op_lshift
l_int|8
)paren
suffix:semicolon
id|script
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|script
op_add_assign
l_int|2
suffix:semicolon
)brace
id|script
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|DCMD_TYPE_RWRI
op_or
id|DCMD_RWRI_OPC_MODIFY
op_or
id|DCMD_RWRI_OP_MOVE
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|SXFER_REG
op_lshift
l_int|16
)paren
op_or
(paren
id|sxfer
op_lshift
l_int|8
)paren
suffix:semicolon
id|script
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|script
op_add_assign
l_int|2
suffix:semicolon
macro_line|#ifdef DEBUG_SYNC_INTR
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_DISCONNECT
)paren
(brace
id|script
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_INT
)paren
op_lshift
l_int|24
)paren
op_or
id|DBC_TCI_TRUE
suffix:semicolon
id|script
(braket
l_int|1
)braket
op_assign
id|DEBUG_SYNC_INTR
suffix:semicolon
id|script
op_add_assign
l_int|2
suffix:semicolon
)brace
macro_line|#endif
id|script
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_RETURN
)paren
op_lshift
l_int|24
)paren
op_or
id|DBC_TCI_TRUE
suffix:semicolon
id|script
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|script
op_add_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_SYNCHRONOUS
)paren
id|printk
(paren
l_string|&quot;scsi%d : target %d sync parameters are sxfer=0x%x, scntl3=0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|target
comma
id|sxfer
comma
id|scntl3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|now_connected
)paren
(brace
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
id|NCR53c7x0_write8
c_func
(paren
id|SCNTL3_REG_800
comma
id|scntl3
)paren
suffix:semicolon
id|NCR53c7x0_write8
c_func
(paren
id|SXFER_REG
comma
id|sxfer
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function : static int asynchronous (struct Scsi_Host *host, int target)&n; *&n; * Purpose : reprogram between the selected SCSI Host adapter and target &n; *      (assumed to be currently connected) for asynchronous transfers.&n; *&n; * Inputs : host - SCSI host structure, target - numeric target ID.&n; *&n; * Preconditions : the NCR chip should be in one of the halted states&n; */
r_static
r_void
DECL|function|asynchronous
id|asynchronous
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_int
id|target
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
id|set_synchronous
(paren
id|host
comma
id|target
comma
multiline_comment|/* no offset */
l_int|0
comma
id|hostdata-&gt;saved_scntl3
comma
l_int|1
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : setting target %d to asynchronous SCSI&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * XXX - do we want to go out of our way (ie, add extra code to selection&n; * &t;in the NCR53c710/NCR53c720 script) to reprogram the synchronous&n; * &t;conversion bits, or can we be content in just setting the &n; * &t;sxfer bits?&n; */
multiline_comment|/* Table for NCR53c8xx synchronous values */
r_static
r_const
r_struct
(brace
DECL|member|div
r_int
id|div
suffix:semicolon
multiline_comment|/* Total clock divisor * 10 */
DECL|member|scf
r_int
r_char
id|scf
suffix:semicolon
multiline_comment|/* */
DECL|member|tp
r_int
r_char
id|tp
suffix:semicolon
multiline_comment|/* 4 + tp = xferp divisor */
DECL|variable|syncs
)brace
id|syncs
(braket
)braket
op_assign
(brace
multiline_comment|/*&t;div&t;scf&t;tp&t;div&t;scf&t;tp&t;div&t;scf&t;tp */
(brace
l_int|40
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
l_int|50
comma
l_int|1
comma
l_int|1
)brace
comma
(brace
l_int|60
comma
l_int|1
comma
l_int|2
)brace
comma
(brace
l_int|70
comma
l_int|1
comma
l_int|3
)brace
comma
(brace
l_int|75
comma
l_int|2
comma
l_int|1
)brace
comma
(brace
l_int|80
comma
l_int|1
comma
l_int|4
)brace
comma
(brace
l_int|90
comma
l_int|1
comma
l_int|5
)brace
comma
(brace
l_int|100
comma
l_int|1
comma
l_int|6
)brace
comma
(brace
l_int|105
comma
l_int|2
comma
l_int|3
)brace
comma
(brace
l_int|110
comma
l_int|1
comma
l_int|7
)brace
comma
(brace
l_int|120
comma
l_int|2
comma
l_int|4
)brace
comma
(brace
l_int|135
comma
l_int|2
comma
l_int|5
)brace
comma
(brace
l_int|140
comma
l_int|3
comma
l_int|3
)brace
comma
(brace
l_int|150
comma
l_int|2
comma
l_int|6
)brace
comma
(brace
l_int|160
comma
l_int|3
comma
l_int|4
)brace
comma
(brace
l_int|165
comma
l_int|2
comma
l_int|7
)brace
comma
(brace
l_int|180
comma
l_int|3
comma
l_int|5
)brace
comma
(brace
l_int|200
comma
l_int|3
comma
l_int|6
)brace
comma
(brace
l_int|210
comma
l_int|4
comma
l_int|3
)brace
comma
(brace
l_int|220
comma
l_int|3
comma
l_int|7
)brace
comma
(brace
l_int|240
comma
l_int|4
comma
l_int|4
)brace
comma
(brace
l_int|270
comma
l_int|4
comma
l_int|5
)brace
comma
(brace
l_int|300
comma
l_int|4
comma
l_int|6
)brace
comma
(brace
l_int|330
comma
l_int|4
comma
l_int|7
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Function : static void synchronous (struct Scsi_Host *host, int target, &n; *&t;char *msg)&n; *&n; * Purpose : reprogram transfers between the selected SCSI initiator and &n; *&t;target for synchronous SCSI transfers such that the synchronous &n; *&t;offset is less than that requested and period at least as long &n; *&t;as that requested.  Also modify *msg such that it contains &n; *&t;an appropriate response. &n; *&n; * Inputs : host - NCR53c7,8xx SCSI host, target - number SCSI target id,&n; *&t;msg - synchronous transfer request.&n; */
r_static
r_void
DECL|function|synchronous
id|synchronous
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_int
id|target
comma
r_char
op_star
id|msg
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
id|desire
comma
id|divisor
comma
id|i
comma
id|limit
suffix:semicolon
r_int
r_char
id|scntl3
comma
id|sxfer
suffix:semicolon
multiline_comment|/* The diagnostic message fits on one line, even with max. width integers */
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
multiline_comment|/* Desired transfer clock in Hz */
id|desire
op_assign
l_int|1000000000L
op_div
(paren
id|msg
(braket
l_int|3
)braket
op_star
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Scale the available SCSI clock by 10 so we get tenths */
id|divisor
op_assign
(paren
id|hostdata-&gt;scsi_clock
op_star
l_int|10
)paren
op_div
id|desire
suffix:semicolon
multiline_comment|/* NCR chips can handle at most an offset of 8 */
r_if
c_cond
(paren
id|msg
(braket
l_int|4
)braket
OG
l_int|8
)paren
id|msg
(braket
l_int|4
)braket
op_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_SDTR
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : optimal synchronous divisor of %d.%01d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|divisor
op_div
l_int|10
comma
id|divisor
op_mod
l_int|10
)paren
suffix:semicolon
id|limit
op_assign
(paren
r_sizeof
(paren
id|syncs
)paren
op_div
r_sizeof
(paren
id|syncs
(braket
l_int|0
)braket
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|limit
)paren
op_logical_and
(paren
id|divisor
OG
id|syncs
(braket
id|i
)braket
dot
id|div
)paren
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_SDTR
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : selected synchronous divisor of %d.%01d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|syncs
(braket
id|i
)braket
dot
id|div
op_div
l_int|10
comma
id|syncs
(braket
id|i
)braket
dot
id|div
op_mod
l_int|10
)paren
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
(paren
(paren
l_int|1000000000L
op_div
id|hostdata-&gt;scsi_clock
)paren
op_star
id|syncs
(braket
id|i
)braket
dot
id|div
op_div
l_int|10
op_div
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_SDTR
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : selected synchronous period of %dns&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|msg
(braket
l_int|3
)braket
op_star
l_int|4
)paren
suffix:semicolon
id|scntl3
op_assign
(paren
id|hostdata-&gt;chip
op_div
l_int|100
op_eq
l_int|8
)paren
ques
c_cond
(paren
(paren
id|hostdata-&gt;saved_scntl3
op_amp
op_complement
id|SCNTL3_800_SCF_MASK
)paren
op_or
(paren
id|syncs
(braket
id|i
)braket
dot
id|scf
op_lshift
id|SCNTL3_800_SCF_SHIFT
)paren
)paren
suffix:colon
l_int|0
suffix:semicolon
id|sxfer
op_assign
(paren
id|msg
(braket
l_int|4
)braket
op_lshift
id|SXFER_MO_SHIFT
)paren
op_or
(paren
(paren
id|syncs
(braket
id|i
)braket
dot
id|tp
)paren
op_lshift
id|SXFER_TP_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_SDTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : sxfer=0x%x scntl3=0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
)paren
id|sxfer
comma
(paren
r_int
)paren
id|scntl3
)paren
suffix:semicolon
id|set_synchronous
(paren
id|host
comma
id|target
comma
id|sxfer
comma
id|scntl3
comma
l_int|1
)paren
suffix:semicolon
id|sprintf
(paren
id|buf
comma
l_string|&quot;scsi%d : setting target %d to &quot;
comma
id|host-&gt;host_no
comma
id|target
)paren
suffix:semicolon
id|print_synchronous
(paren
id|buf
comma
id|msg
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : static int NCR53c8x0_dstat_sir_intr (struct Scsi_Host *host,&n; * &t;struct NCR53c7x0_cmd *cmd)&n; *&n; * Purpose :  Handler for INT generated instructions for the &n; * &t;NCR53c810/820 SCSI SCRIPT&n; *&n; * Inputs : host - pointer to this host adapter&squot;s structure,&n; * &t;cmd - pointer to the command (if any) dsa was pointing &n; * &t;to.&n; *&n; */
r_static
r_int
DECL|function|NCR53c8x0_dstat_sir_intr
id|NCR53c8x0_dstat_sir_intr
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_int
id|print
suffix:semicolon
id|Scsi_Cmnd
op_star
id|c
op_assign
id|cmd
ques
c_cond
id|cmd-&gt;cmd
suffix:colon
l_int|NULL
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|u32
id|dsps
comma
op_star
id|dsp
suffix:semicolon
multiline_comment|/* Argument of the INT instruction */
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
id|dsps
op_assign
id|NCR53c7x0_read32
c_func
(paren
id|DSPS_REG
)paren
suffix:semicolon
id|dsp
op_assign
(paren
id|u32
op_star
)paren
id|bus_to_virt
c_func
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DSP_REG
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : DSPS = 0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|dsps
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|dsps
)paren
(brace
r_case
id|A_int_msg_1
suffix:colon
id|print
op_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|hostdata-&gt;msg_buf
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* &n;&t; * Unless we&squot;ve initiated synchronous negotiation, I don&squot;t&n;&t; * think that this should happen.&n;&t; */
r_case
id|MESSAGE_REJECT
suffix:colon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_accept_message
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_logical_and
(paren
id|cmd-&gt;flags
op_amp
id|CMD_FLAG_SDTR
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : target %d rejected SDTR&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|c-&gt;target
)paren
suffix:semicolon
id|cmd-&gt;flags
op_and_assign
op_complement
id|CMD_FLAG_SDTR
suffix:semicolon
id|asynchronous
(paren
id|host
comma
id|c-&gt;target
)paren
suffix:semicolon
id|print
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|INITIATE_RECOVERY
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : extended contingent allegiance not supported yet, rejecting&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
multiline_comment|/* Fall through to default */
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_reject_message
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : unsupported message, rejecting&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_reject_message
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|print
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : received message&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
id|printk
(paren
l_string|&quot; from target %d lun %d &quot;
comma
id|c-&gt;target
comma
id|c-&gt;lun
)paren
suffix:semicolon
id|print_msg
(paren
(paren
r_int
r_char
op_star
)paren
id|hostdata-&gt;msg_buf
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_NOTHING
suffix:semicolon
r_case
id|A_int_msg_sdtr
suffix:colon
multiline_comment|/*&n; * At this point, hostdata-&gt;msg_buf contains&n; * 0 EXTENDED MESSAGE&n; * 1 length &n; * 2 SDTR&n; * 3 period * 4ns&n; * 4 offset&n; */
r_if
c_cond
(paren
id|cmd
)paren
(brace
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
id|sprintf
(paren
id|buf
comma
l_string|&quot;scsi%d : target %d %s &quot;
comma
id|host-&gt;host_no
comma
id|c-&gt;target
comma
(paren
id|cmd-&gt;flags
op_amp
id|CMD_FLAG_SDTR
)paren
ques
c_cond
l_string|&quot;accepting&quot;
suffix:colon
l_string|&quot;requesting&quot;
)paren
suffix:semicolon
id|print_synchronous
(paren
id|buf
comma
(paren
r_int
r_char
op_star
)paren
id|hostdata-&gt;msg_buf
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Initiator initiated, won&squot;t happen unless synchronous &n;&t; * &t;transfers are enabled.  If we get a SDTR message in&n;&t; * &t;response to our SDTR, we should program our parameters&n;&t; * &t;such that &n;&t; *&t;&t;offset &lt;= requested offset&n;&t; *&t;&t;period &gt;= requested period&t;&t; &t;&n;   &t; */
r_if
c_cond
(paren
id|cmd-&gt;flags
op_amp
id|CMD_FLAG_SDTR
)paren
(brace
id|cmd-&gt;flags
op_and_assign
op_complement
id|CMD_FLAG_SDTR
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;msg_buf
(braket
l_int|4
)braket
)paren
id|synchronous
(paren
id|host
comma
id|c-&gt;target
comma
(paren
r_int
r_char
op_star
)paren
id|hostdata-&gt;msg_buf
)paren
suffix:semicolon
r_else
id|asynchronous
(paren
id|host
comma
id|c-&gt;target
)paren
suffix:semicolon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_accept_message
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
r_return
id|SPECIFIC_INT_NOTHING
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_SYNCHRONOUS
)paren
(brace
id|cmd-&gt;flags
op_or_assign
id|CMD_FLAG_DID_SDTR
suffix:semicolon
id|synchronous
(paren
id|host
comma
id|c-&gt;target
comma
(paren
r_int
r_char
op_star
)paren
id|hostdata-&gt;msg_buf
)paren
suffix:semicolon
)brace
r_else
(brace
id|hostdata-&gt;msg_buf
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0 offset = async */
id|asynchronous
(paren
id|host
comma
id|c-&gt;target
)paren
suffix:semicolon
)brace
id|patch_dsa_32
(paren
id|cmd-&gt;dsa
comma
id|dsa_msgout_other
comma
l_int|0
comma
id|le32_to_cpu
c_func
(paren
l_int|5
)paren
)paren
suffix:semicolon
id|patch_dsa_32
(paren
id|cmd-&gt;dsa
comma
id|dsa_msgout_other
comma
l_int|1
comma
(paren
id|u32
)paren
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
(paren
(paren
r_void
op_star
)paren
op_amp
id|hostdata-&gt;msg_buf
)paren
)paren
)paren
suffix:semicolon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_respond_message
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_NOTHING
suffix:semicolon
)brace
multiline_comment|/* Fall through to abort if we couldn&squot;t find a cmd, and &n;&t;   therefore a dsa structure to twiddle */
r_case
id|A_int_msg_wdtr
suffix:colon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_reject_message
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
r_return
id|SPECIFIC_INT_NOTHING
suffix:semicolon
r_case
id|A_int_err_unexpected_phase
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : unexpected phase&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_return
id|SPECIFIC_INT_ABORT
suffix:semicolon
r_case
id|A_int_err_selected
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : selected by target %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
)paren
id|NCR53c7x0_read8
c_func
(paren
id|SDID_REG_800
)paren
op_amp
l_int|7
)paren
suffix:semicolon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_target_abort
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
r_return
id|SPECIFIC_INT_NOTHING
suffix:semicolon
r_case
id|A_int_err_unexpected_reselect
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : unexpected reselect by target %d lun %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
)paren
id|NCR53c7x0_read8
c_func
(paren
id|SDID_REG_800
)paren
op_amp
l_int|7
comma
id|hostdata-&gt;reselected_identify
op_amp
l_int|7
)paren
suffix:semicolon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_initiator_abort
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
r_return
id|SPECIFIC_INT_NOTHING
suffix:semicolon
multiline_comment|/*&n; * Since contingent allegiance conditions are cleared by the next &n; * command issued to a target, we must issue a REQUEST SENSE &n; * command after receiving a CHECK CONDITION status, before&n; * another command is issued.&n; * &n; * Since this NCR53c7x0_cmd will be freed after use, we don&squot;t &n; * care if we step on the various fields, so modify a few things.&n; */
r_case
id|A_int_err_check_condition
suffix:colon
macro_line|#if 0
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
macro_line|#endif
id|printk
(paren
l_string|&quot;scsi%d : CHECK CONDITION&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : CHECK CONDITION with no SCSI command&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_return
id|SPECIFIC_INT_PANIC
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * FIXME : this uses the normal one-byte selection message.&n;&t; * &t;We may want to renegotiate for synchronous &amp; WIDE transfers&n;&t; * &t;since these could be the crux of our problem.&n;&t; *&n;&t; hostdata-&gt;NOP_insn* FIXME : once SCSI-II tagged queuing is implemented, we&squot;ll&n;&t; * &t;have to set this up so that the rest of the DSA&n;&t; *&t;agrees with this being an untagged queue&squot;d command.&n;&t; */
id|patch_dsa_32
(paren
id|cmd-&gt;dsa
comma
id|dsa_msgout
comma
l_int|0
comma
id|le32_to_cpu
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;    &t; * Modify the table indirect for COMMAND OUT phase, since &n;    &t; * Request Sense is a six byte command.&n;    &t; */
id|patch_dsa_32
(paren
id|cmd-&gt;dsa
comma
id|dsa_cmdout
comma
l_int|0
comma
id|le32_to_cpu
c_func
(paren
l_int|6
)paren
)paren
suffix:semicolon
id|c-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|REQUEST_SENSE
suffix:semicolon
id|c-&gt;cmnd
(braket
l_int|1
)braket
op_and_assign
l_int|0xe0
suffix:semicolon
multiline_comment|/* Zero all but LUN */
id|c-&gt;cmnd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|c-&gt;cmnd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|c-&gt;cmnd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|c-&gt;sense_buffer
)paren
suffix:semicolon
id|c-&gt;cmnd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Disable dataout phase, and program datain to transfer to the &n;&t; * sense buffer, and add a jump to other_transfer after the &n;    &t; * command so overflow/underrun conditions are detected.&n;&t; */
id|patch_dsa_32
(paren
id|cmd-&gt;dsa
comma
id|dsa_dataout
comma
l_int|0
comma
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
id|hostdata-&gt;script
)paren
op_plus
id|hostdata-&gt;E_other_transfer
)paren
)paren
suffix:semicolon
id|patch_dsa_32
(paren
id|cmd-&gt;dsa
comma
id|dsa_datain
comma
l_int|0
comma
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
id|cmd-&gt;data_transfer_start
)paren
)paren
)paren
suffix:semicolon
id|cmd-&gt;data_transfer_start
(braket
l_int|0
)braket
op_assign
id|le32_to_cpu
c_func
(paren
(paren
(paren
(paren
id|DCMD_TYPE_BMI
op_or
id|DCMD_BMI_OP_MOVE_I
op_or
id|DCMD_BMI_IO
)paren
)paren
op_lshift
l_int|24
)paren
op_or
r_sizeof
(paren
id|c-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|cmd-&gt;data_transfer_start
(braket
l_int|1
)braket
op_assign
(paren
id|u32
)paren
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
id|c-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|cmd-&gt;data_transfer_start
(braket
l_int|2
)braket
op_assign
id|le32_to_cpu
c_func
(paren
(paren
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_JUMP
)paren
op_lshift
l_int|24
)paren
op_or
id|DBC_TCI_TRUE
)paren
suffix:semicolon
id|cmd-&gt;data_transfer_start
(braket
l_int|3
)braket
op_assign
(paren
id|u32
)paren
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
id|hostdata-&gt;script
)paren
op_plus
id|hostdata-&gt;E_other_transfer
)paren
suffix:semicolon
multiline_comment|/*&n;    &t; * Currently, this command is flagged as completed, ie &n;    &t; * it has valid status and message data.  Reflag it as&n;    &t; * incomplete.  Q - need to do something so that original&n;&t; * status, etc are used.&n;    &t; */
id|cmd-&gt;cmd-&gt;result
op_assign
id|le32_to_cpu
c_func
(paren
l_int|0xffff
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Restart command as a REQUEST SENSE.&n;&t; */
id|hostdata-&gt;dsp
op_assign
(paren
id|u32
op_star
)paren
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_select
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
r_return
id|SPECIFIC_INT_NOTHING
suffix:semicolon
r_case
id|A_int_debug_break
suffix:colon
r_return
id|SPECIFIC_INT_BREAK
suffix:semicolon
r_case
id|A_int_norm_aborted
suffix:colon
id|hostdata-&gt;dsp
op_assign
(paren
id|u32
op_star
)paren
id|hostdata-&gt;schedule
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cmd
)paren
id|abnormal_finished
(paren
id|cmd
comma
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
id|SPECIFIC_INT_NOTHING
suffix:semicolon
r_case
id|A_int_test_1
suffix:colon
r_case
id|A_int_test_2
suffix:colon
id|hostdata-&gt;idle
op_assign
l_int|1
suffix:semicolon
id|hostdata-&gt;test_completed
op_assign
(paren
id|dsps
op_minus
id|A_int_test_1
)paren
op_div
l_int|0x00010000
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : test%d complete&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|hostdata-&gt;test_completed
)paren
suffix:semicolon
r_return
id|SPECIFIC_INT_NOTHING
suffix:semicolon
macro_line|#ifdef A_int_debug_reselected_ok
r_case
id|A_int_debug_reselected_ok
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
op_or
id|OPTION_DEBUG_DISCONNECT
)paren
)paren
(brace
multiline_comment|/* &n;&t;     * Note - this dsa is not based on location relative to &n;&t;     * the command structure, but to location relative to the &n;&t;     * DSA register &n;&t;     */
id|u32
op_star
id|dsa
suffix:semicolon
id|dsa
op_assign
(paren
id|u32
op_star
)paren
id|bus_to_virt
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DSA_REG
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : reselected_ok (DSA = 0x%x (virt 0x%p)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|NCR53c7x0_read32
c_func
(paren
id|DSA_REG
)paren
comma
id|dsa
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : resume address is 0x%x (virt 0x%p)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;saved_data_pointer
comma
id|bus_to_virt
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|cmd-&gt;saved_data_pointer
)paren
)paren
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|hostdata-&gt;script
op_plus
id|Ent_reselected_ok
op_div
r_sizeof
(paren
id|u32
)paren
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : sxfer=0x%x, scntl3=0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|NCR53c7x0_read8
c_func
(paren
id|SXFER_REG
)paren
comma
id|NCR53c7x0_read8
c_func
(paren
id|SCNTL3_REG_800
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
(brace
id|print_insn
(paren
id|host
comma
(paren
id|u32
op_star
)paren
id|hostdata-&gt;sync
(braket
id|c-&gt;target
)braket
dot
id|script
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
(paren
id|u32
op_star
)paren
id|hostdata-&gt;sync
(braket
id|c-&gt;target
)braket
dot
id|script
op_plus
l_int|2
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_reselect_check
r_case
id|A_int_debug_reselect_check
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
)paren
)paren
(brace
id|u32
op_star
id|dsa
suffix:semicolon
macro_line|#if 0
id|u32
op_star
id|code
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t;     * Note - this dsa is not based on location relative to &n;&t;     * the command structure, but to location relative to the &n;&t;     * DSA register &n;&t;     */
id|dsa
op_assign
id|bus_to_virt
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DSA_REG
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : reselected_check_next (DSA = 0x%lx (virt 0x%p))&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|virt_to_bus
c_func
(paren
id|dsa
)paren
comma
id|dsa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dsa
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : resume address is 0x%x (virt 0x%p)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;saved_data_pointer
comma
id|bus_to_virt
(paren
id|le32_to_cpu
c_func
(paren
id|cmd-&gt;saved_data_pointer
)paren
)paren
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;scsi%d : template code :&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_for
c_loop
(paren
id|code
op_assign
id|dsa
op_plus
(paren
id|Ent_dsa_code_check_reselect
op_minus
id|Ent_dsa_zero
)paren
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
id|code
OL
(paren
id|dsa
op_plus
id|Ent_dsa_zero
op_div
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
id|code
op_add_assign
id|print_insn
(paren
id|host
comma
id|code
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
id|print_insn
(paren
id|host
comma
id|hostdata-&gt;script
op_plus
id|Ent_reselected_ok
op_div
r_sizeof
(paren
id|u32
)paren
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_dsa_schedule
r_case
id|A_int_debug_dsa_schedule
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
)paren
)paren
(brace
id|u32
op_star
id|dsa
suffix:semicolon
multiline_comment|/* &n;&t;     * Note - this dsa is not based on location relative to &n;&t;     * the command structure, but to location relative to the &n;&t;     * DSA register &n;&t;     */
id|dsa
op_assign
(paren
id|u32
op_star
)paren
id|bus_to_virt
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DSA_REG
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : dsa_schedule (old DSA = 0x%lx (virt 0x%p))&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|virt_to_bus
c_func
(paren
id|dsa
)paren
comma
id|dsa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dsa
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : resume address is 0x%x (virt 0x%p)&bslash;n&quot;
l_string|&quot;         (temp was 0x%x (virt 0x%p))&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;saved_data_pointer
comma
id|bus_to_virt
(paren
id|le32_to_cpu
c_func
(paren
id|cmd-&gt;saved_data_pointer
)paren
)paren
comma
id|NCR53c7x0_read32
(paren
id|TEMP_REG
)paren
comma
id|bus_to_virt
(paren
id|NCR53c7x0_read32
c_func
(paren
id|TEMP_REG
)paren
)paren
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_scheduled
r_case
id|A_int_debug_scheduled
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : new I/O 0x%x (virt 0x%p) scheduled&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|NCR53c7x0_read32
c_func
(paren
id|DSA_REG
)paren
comma
id|bus_to_virt
c_func
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DSA_REG
)paren
)paren
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_idle
r_case
id|A_int_debug_idle
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : idle&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_cmd
r_case
id|A_int_debug_cmd
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : command sent&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_dsa_loaded
r_case
id|A_int_debug_dsa_loaded
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : DSA loaded with 0x%x (virt 0x%p)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|NCR53c7x0_read32
c_func
(paren
id|DSA_REG
)paren
comma
id|bus_to_virt
c_func
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DSA_REG
)paren
)paren
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_reselected
r_case
id|A_int_debug_reselected
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
op_or
id|OPTION_DEBUG_DISCONNECT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : reselected by target %d lun %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
)paren
id|NCR53c7x0_read8
c_func
(paren
id|SDID_REG_800
)paren
op_amp
op_complement
l_int|0x80
comma
(paren
r_int
)paren
id|hostdata-&gt;reselected_identify
op_amp
l_int|7
)paren
suffix:semicolon
id|print_queues
c_func
(paren
id|host
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_disconnect_msg
r_case
id|A_int_debug_disconnect_msg
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : target %d lun %d disconnecting&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|c-&gt;target
comma
id|c-&gt;lun
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;scsi%d : unknown target disconnecting&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_disconnected
r_case
id|A_int_debug_disconnected
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
op_or
id|OPTION_DEBUG_DISCONNECT
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : disconnected, new queues are&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_queues
c_func
(paren
id|host
)paren
suffix:semicolon
macro_line|#if 0
id|printk
(paren
l_string|&quot;scsi%d : sxfer=0x%x, scntl3=0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|NCR53c7x0_read8
c_func
(paren
id|SXFER_REG
)paren
comma
id|NCR53c7x0_read8
c_func
(paren
id|SCNTL3_REG_800
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|c
)paren
(brace
id|print_insn
(paren
id|host
comma
(paren
id|u32
op_star
)paren
id|hostdata-&gt;sync
(braket
id|c-&gt;target
)braket
dot
id|script
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
(paren
id|u32
op_star
)paren
id|hostdata-&gt;sync
(braket
id|c-&gt;target
)braket
dot
id|script
op_plus
l_int|2
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_panic
r_case
id|A_int_debug_panic
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : int_debug_panic received&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_lots
(paren
id|host
)paren
suffix:semicolon
r_return
id|SPECIFIC_INT_PANIC
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_saved
r_case
id|A_int_debug_saved
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
op_or
id|OPTION_DEBUG_DISCONNECT
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : saved data pointer 0x%x (virt 0x%p)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;saved_data_pointer
comma
id|bus_to_virt
(paren
id|le32_to_cpu
c_func
(paren
id|cmd-&gt;saved_data_pointer
)paren
)paren
)paren
suffix:semicolon
id|print_progress
(paren
id|c
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_restored
r_case
id|A_int_debug_restored
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
op_or
id|OPTION_DEBUG_DISCONNECT
)paren
)paren
(brace
r_if
c_cond
(paren
id|cmd
)paren
(brace
r_int
id|size
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : restored data pointer 0x%x (virt 0x%p)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;saved_data_pointer
comma
id|bus_to_virt
(paren
id|le32_to_cpu
c_func
(paren
id|cmd-&gt;saved_data_pointer
)paren
)paren
)paren
suffix:semicolon
id|size
op_assign
id|print_insn
(paren
id|host
comma
(paren
id|u32
op_star
)paren
id|bus_to_virt
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|cmd-&gt;saved_data_pointer
)paren
)paren
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|size
op_assign
id|print_insn
(paren
id|host
comma
(paren
id|u32
op_star
)paren
id|bus_to_virt
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|cmd-&gt;saved_data_pointer
)paren
)paren
op_plus
id|size
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|print_progress
(paren
id|c
)paren
suffix:semicolon
)brace
macro_line|#if 0
id|printk
(paren
l_string|&quot;scsi%d : datapath residual %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|datapath_residual
(paren
id|host
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_sync
r_case
id|A_int_debug_sync
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
op_or
id|OPTION_DEBUG_DISCONNECT
op_or
id|OPTION_DEBUG_SDTR
)paren
)paren
(brace
r_int
r_char
id|sxfer
op_assign
id|NCR53c7x0_read8
(paren
id|SXFER_REG
)paren
comma
id|scntl3
op_assign
id|NCR53c7x0_read8
(paren
id|SCNTL3_REG_800
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
(brace
r_if
c_cond
(paren
id|sxfer
op_ne
id|hostdata-&gt;sync
(braket
id|c-&gt;target
)braket
dot
id|sxfer_sanity
op_logical_or
id|scntl3
op_ne
id|hostdata-&gt;sync
(braket
id|c-&gt;target
)braket
dot
id|scntl3_sanity
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d :  sync sanity check failed sxfer=0x%x, scntl3=0x%x&quot;
comma
id|host-&gt;host_no
comma
id|sxfer
comma
id|scntl3
)paren
suffix:semicolon
id|NCR53c7x0_write8
(paren
id|SXFER_REG
comma
id|sxfer
)paren
suffix:semicolon
id|NCR53c7x0_write8
(paren
id|SCNTL3_REG_800
comma
id|scntl3
)paren
suffix:semicolon
)brace
)brace
r_else
id|printk
(paren
l_string|&quot;scsi%d : unknown command sxfer=0x%x, scntl3=0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
)paren
id|sxfer
comma
(paren
r_int
)paren
id|scntl3
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
macro_line|#ifdef A_int_debug_datain
r_case
id|A_int_debug_datain
suffix:colon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_SCRIPT
op_or
id|OPTION_DEBUG_INTR
op_or
id|OPTION_DEBUG_DISCONNECT
op_or
id|OPTION_DEBUG_SDTR
)paren
)paren
(brace
r_int
id|size
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : In do_datain (%s) sxfer=0x%x, scntl3=0x%x&bslash;n&quot;
l_string|&quot;         datapath residual=%d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|sbcl_to_phase
(paren
id|NCR53c7x0_read8
(paren
id|SBCL_REG
)paren
)paren
comma
(paren
r_int
)paren
id|NCR53c7x0_read8
c_func
(paren
id|SXFER_REG
)paren
comma
(paren
r_int
)paren
id|NCR53c7x0_read8
c_func
(paren
id|SCNTL3_REG_800
)paren
comma
id|datapath_residual
(paren
id|host
)paren
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|dsp
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|size
op_assign
id|print_insn
(paren
id|host
comma
(paren
id|u32
op_star
)paren
id|bus_to_virt
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|dsp
(braket
l_int|1
)braket
)paren
)paren
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
(paren
id|u32
op_star
)paren
id|bus_to_virt
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|dsp
(braket
l_int|1
)braket
)paren
)paren
op_plus
id|size
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n; * FIXME : for 7xx support, we need to read SDID_REG_700 and handle &n; *&t;the comparison as bitfielded,  not binary.&n; */
macro_line|#ifdef A_int_debug_check_dsa
r_case
id|A_int_debug_check_dsa
suffix:colon
r_if
c_cond
(paren
id|NCR53c7x0_read8
(paren
id|SCNTL1_REG
)paren
op_amp
id|SCNTL1_CON
)paren
(brace
r_int
id|sdid
op_assign
id|NCR53c7x0_read8
(paren
id|SDID_REG_800
)paren
op_amp
l_int|15
suffix:semicolon
r_char
op_star
id|where
op_assign
id|dsp
op_minus
id|NCR53c7x0_insn_size
c_func
(paren
id|NCR53c7x0_read8
(paren
id|DCMD_REG
)paren
)paren
op_eq
id|hostdata-&gt;script
op_plus
id|Ent_select_check_dsa
op_div
r_sizeof
(paren
id|u32
)paren
ques
c_cond
l_string|&quot;selection&quot;
suffix:colon
l_string|&quot;reselection&quot;
suffix:semicolon
r_if
c_cond
(paren
id|c
op_logical_and
id|sdid
op_ne
id|c-&gt;target
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : SDID target %d != DSA target %d at %s&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|sdid
comma
id|c-&gt;target
comma
id|where
)paren
suffix:semicolon
id|print_lots
c_func
(paren
id|host
)paren
suffix:semicolon
id|dump_events
(paren
id|host
comma
l_int|20
)paren
suffix:semicolon
r_return
id|SPECIFIC_INT_PANIC
suffix:semicolon
)brace
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
(paren
id|dsps
op_amp
l_int|0xff000000
)paren
op_eq
l_int|0x03000000
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : misc debug interrupt 0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|dsps
)paren
suffix:semicolon
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dsps
op_amp
l_int|0xff000000
)paren
op_eq
l_int|0x05000000
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;events
)paren
(brace
r_struct
id|NCR53c7x0_event
op_star
id|event
suffix:semicolon
op_increment
id|hostdata-&gt;event_index
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;event_index
op_ge
id|hostdata-&gt;event_size
)paren
id|hostdata-&gt;event_index
op_assign
l_int|0
suffix:semicolon
id|event
op_assign
(paren
r_struct
id|NCR53c7x0_event
op_star
)paren
id|hostdata-&gt;events
op_plus
id|hostdata-&gt;event_index
suffix:semicolon
id|event-&gt;event
op_assign
(paren
r_enum
id|ncr_event
)paren
id|dsps
suffix:semicolon
id|event-&gt;dsa
op_assign
id|bus_to_virt
c_func
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DSA_REG
)paren
)paren
suffix:semicolon
multiline_comment|/* FIXME : this needs to change for the &squot;7xx family */
r_if
c_cond
(paren
id|NCR53c7x0_read8
(paren
id|SCNTL1_REG
)paren
op_amp
id|SCNTL1_CON
)paren
id|event-&gt;target
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SSID_REG_800
)paren
suffix:semicolon
r_else
id|event-&gt;target
op_assign
l_int|255
suffix:semicolon
r_if
c_cond
(paren
id|event-&gt;event
op_eq
id|EVENT_RESELECT
)paren
id|event-&gt;lun
op_assign
id|hostdata-&gt;reselected_identify
op_amp
l_int|0xf
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
)paren
id|event-&gt;lun
op_assign
id|c-&gt;lun
suffix:semicolon
r_else
id|event-&gt;lun
op_assign
l_int|255
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
(paren
id|event-&gt;time
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
(brace
id|event-&gt;pid
op_assign
id|c-&gt;pid
suffix:semicolon
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|event-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|c-&gt;cmnd
comma
r_sizeof
(paren
id|event-&gt;cmnd
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|event-&gt;pid
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|SPECIFIC_INT_RESTART
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;scsi%d : unknown user interrupt 0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
)paren
id|dsps
)paren
suffix:semicolon
r_return
id|SPECIFIC_INT_PANIC
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * XXX - the stock NCR assembler won&squot;t output the scriptu.h file,&n; * which undefine&squot;s all #define&squot;d CPP symbols from the script.h&n; * file, which will create problems if you use multiple scripts&n; * with the same  symbol names.&n; *&n; * If you insist on using NCR&squot;s assembler, you could generate&n; * scriptu.h from script.h using something like &n; *&n; * grep #define script.h | &bslash;&n; * sed &squot;s/#define[ &t;][ &t;]*&bslash;([_a-zA-Z][_a-zA-Z0-9]*&bslash;).*$/#undefine &bslash;1/&squot; &bslash;&n; * &gt; scriptu.h&n; */
macro_line|#include &quot;53c8xx_u.h&quot;
multiline_comment|/* XXX - add alternate script handling code here */
macro_line|#ifdef NCR_DEBUG
multiline_comment|/*&n; * Debugging without a debugger is no fun. So, I&squot;ve provided &n; * a debugging interface in the NCR53c7x0 driver.  To avoid&n; * kernel cruft, there&squot;s just enough here to act as an interface&n; * to a user level debugger (aka, GDB).&n; *&n; *&n; * The following restrictions apply to debugger commands : &n; * 1.  The command must be terminated by a newline.&n; * 2.  Command length must be less than 80 bytes including the &n; * &t;newline.&n; * 3.  The entire command must be written with one system call.&n; */
DECL|variable|debugger_help
r_static
r_const
r_char
id|debugger_help
op_assign
l_string|&quot;bc &lt;addr&gt; &t;&t;&t;- clear breakpoint&bslash;n&quot;
l_string|&quot;bl&t;&t;&t;&t;- list breakpoints&bslash;n&quot;
l_string|&quot;bs &lt;addr&gt;&t;&t;&t;- set breakpoint&bslash;n&quot;
l_string|&quot;g&t;&t;&t;&t;- start&bslash;n&quot;
l_string|&quot;h&t;&t;&t;&t;- halt&bslash;n&quot;
l_string|&quot;?&t;&t;&t;&t;- this message&bslash;n&quot;
l_string|&quot;i&t;&t;&t;&t;- info&bslash;n&quot;
l_string|&quot;mp &lt;addr&gt; &lt;size&gt; &t;&t;- print memory&bslash;n&quot;
l_string|&quot;ms &lt;addr&gt; &lt;size&gt; &lt;value&gt;&t;- store memory&bslash;n&quot;
l_string|&quot;rp &lt;num&gt; &lt;size&gt;&t;&t;- print register&bslash;n&quot;
l_string|&quot;rs &lt;num&gt; &lt;size&gt; &lt;value&gt; &t;- store register&bslash;n&quot;
l_string|&quot;s                              - single step&bslash;n&quot;
l_string|&quot;tb&t;&t;&t;&t;- begin trace &bslash;n&quot;
l_string|&quot;te&t;&t;&t;&t;- end trace&bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n; * Whenever we change a break point, we should probably &n; * set the NCR up so that it is in a single step mode.&n; */
DECL|function|debugger_fn_bc
r_static
r_int
id|debugger_fn_bc
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|debugger_token
op_star
id|token
comma
id|u32
id|args
(braket
)braket
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
r_struct
id|NCR53c7x0_break
op_star
id|bp
comma
op_star
op_star
id|prev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bp
op_assign
(paren
r_struct
id|NCR53c7x0_break
op_star
)paren
id|instance-&gt;breakpoints
comma
id|prev
op_assign
(paren
r_struct
id|NCR53c7x0_break
op_star
op_star
)paren
op_amp
id|instance-&gt;breakpoints
suffix:semicolon
id|bp
suffix:semicolon
id|prev
op_assign
(paren
r_struct
id|NCR53c7x0_break
op_star
op_star
)paren
op_amp
(paren
id|bp-&gt;next
)paren
comma
id|bp
op_assign
(paren
r_struct
id|NCR53c7x0_break
op_star
)paren
id|bp-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* &n;     * XXX - we need to insure that the processor is halted &n;     * here in order to prevent a race condition.&n;     */
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|bp-&gt;addr
comma
(paren
r_void
op_star
)paren
id|bp-&gt;old
comma
r_sizeof
(paren
id|bp-&gt;old
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
op_star
id|prev
op_assign
id|bp-&gt;next
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|debugger_fn_bl
id|debugger_fn_bl
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|debugger_token
op_star
id|token
comma
id|u32
id|args
(braket
)braket
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_struct
id|NCR53c7x0_break
op_star
id|bp
suffix:semicolon
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* &n;     * XXX - we need to insure that the processor is halted &n;     * here in order to prevent a race condition.  So, if the &n;     * processor isn&squot;t halted, print an error message and continue.&n;     */
id|sprintf
(paren
id|buf
comma
l_string|&quot;scsi%d : bp : warning : processor not halted&bslash;b&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|debugger_kernel_write
(paren
id|host
comma
id|buf
comma
id|strlen
c_func
(paren
id|buf
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bp
op_assign
(paren
r_struct
id|NCR53c7x0_break
op_star
)paren
id|host-&gt;breakpoints
suffix:semicolon
id|bp
suffix:semicolon
id|bp
op_assign
(paren
r_struct
id|NCR53c7x0_break
op_star
)paren
id|bp-&gt;next
)paren
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;scsi%d : bp : success : at %08x, replaces %08x %08x&quot;
comma
id|bp-&gt;addr
comma
id|bp-&gt;old
(braket
l_int|0
)braket
comma
id|bp-&gt;old
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bp-&gt;old
(braket
l_int|0
)braket
op_amp
(paren
id|DCMD_TYPE_MASK
op_lshift
l_int|24
)paren
)paren
op_eq
(paren
id|DCMD_TYPE_MMI
op_lshift
l_int|24
)paren
)paren
(brace
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%08x&bslash;n&quot;
comma
op_star
(paren
id|u32
op_star
)paren
id|bp-&gt;addr
)paren
suffix:semicolon
)brace
r_else
(brace
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|len
op_assign
id|strlen
c_func
(paren
id|buf
)paren
suffix:semicolon
id|debugger_kernel_write
(paren
id|host
comma
id|buf
comma
id|len
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|debugger_fn_bs
id|debugger_fn_bs
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|debugger_token
op_star
id|token
comma
id|u32
id|args
(braket
)braket
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_struct
id|NCR53c7x0_break
op_star
id|bp
suffix:semicolon
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;state
op_ne
id|STATE_HALTED
)paren
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;scsi%d : bs : failure : NCR not halted&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|debugger_kernel_write
(paren
id|host
comma
id|buf
comma
id|strlen
c_func
(paren
id|buf
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|bp
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|NCR53c7x0_break
)paren
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : kmalloc(%d) of breakpoint structure failed, try again&bslash;n&quot;
comma
id|host-&gt;host_no
comma
r_sizeof
(paren
r_struct
id|NCR53c7x0_break
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|bp-&gt;address
op_assign
(paren
id|u32
op_star
)paren
id|args
(braket
l_int|0
)braket
suffix:semicolon
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|bp-&gt;old_instruction
comma
(paren
r_void
op_star
)paren
id|bp-&gt;address
comma
l_int|8
)paren
suffix:semicolon
id|bp-&gt;old_size
op_assign
(paren
(paren
(paren
id|bp-&gt;old_instruction
(braket
l_int|0
)braket
op_rshift
l_int|24
)paren
op_amp
id|DCMD_TYPE_MASK
)paren
op_eq
id|DCMD_TYPE_MMI
ques
c_cond
l_int|3
suffix:colon
l_int|2
suffix:semicolon
id|bp-&gt;next
op_assign
id|hostdata-&gt;breakpoints
suffix:semicolon
id|hostdata-&gt;breakpoints
op_assign
id|bp-&gt;next
suffix:semicolon
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|bp-&gt;address
comma
(paren
r_void
op_star
)paren
id|hostdata-&gt;E_debug_break
comma
l_int|8
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|TOKEN
mdefine_line|#define TOKEN(name,nargs) {#name, nargs, debugger_fn_##name}
DECL|struct|debugger_token
r_static
r_const
r_struct
id|debugger_token
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|numargs
r_int
id|numargs
suffix:semicolon
DECL|member|fn
r_int
(paren
op_star
id|fn
)paren
(paren
r_struct
id|debugger_token
op_star
id|token
comma
id|u32
id|args
(braket
)braket
)paren
suffix:semicolon
DECL|variable|debugger_tokens
)brace
id|debugger_tokens
(braket
)braket
op_assign
(brace
id|TOKEN
c_func
(paren
id|bc
comma
l_int|1
)paren
comma
id|TOKEN
c_func
(paren
id|bl
comma
l_int|0
)paren
comma
id|TOKEN
c_func
(paren
id|bs
comma
l_int|1
)paren
comma
id|TOKEN
c_func
(paren
id|g
comma
l_int|0
)paren
comma
id|TOKEN
c_func
(paren
id|halt
comma
l_int|0
)paren
comma
(brace
id|DT_help
comma
l_string|&quot;?&quot;
comma
l_int|0
)brace
comma
id|TOKEN
c_func
(paren
id|h
comma
l_int|0
)paren
comma
id|TOKEN
c_func
(paren
id|i
comma
l_int|0
)paren
comma
id|TOKEN
c_func
(paren
id|mp
comma
l_int|2
)paren
comma
id|TOKEN
c_func
(paren
id|ms
comma
l_int|3
)paren
comma
id|TOKEN
c_func
(paren
id|rp
comma
l_int|2
)paren
comma
id|TOKEN
c_func
(paren
id|rs
comma
l_int|2
)paren
comma
id|TOKEN
c_func
(paren
id|s
comma
l_int|0
)paren
comma
id|TOKEN
c_func
(paren
id|tb
comma
l_int|0
)paren
comma
id|TOKEN
c_func
(paren
id|te
comma
l_int|0
)paren
)brace
suffix:semicolon
DECL|macro|NDT
mdefine_line|#define NDT sizeof(debugger_tokens / sizeof(struct debugger_token))
DECL|function|inode_to_host
r_static
r_struct
id|Scsi_Host
op_star
id|inode_to_host
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
id|dev
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|tmp
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;rdev
)paren
comma
id|host
op_assign
id|first_host
suffix:semicolon
(paren
id|host-&gt;hostt
op_eq
id|the_template
)paren
suffix:semicolon
op_decrement
id|dev
comma
id|host
op_assign
id|host-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
id|host
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_int
DECL|function|debugger_user_write
id|debugger_user_write
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
multiline_comment|/* This SCSI host */
r_struct
id|NCR53c7x0_hostadata
op_star
id|hostdata
suffix:semicolon
r_char
id|input_buf
(braket
l_int|80
)braket
comma
multiline_comment|/* Kernel space copy of buf */
op_star
id|ptr
suffix:semicolon
multiline_comment|/* Pointer to argument list */
id|u32
id|args
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Arguments */
r_int
id|i
comma
id|j
comma
id|error
comma
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|host
op_assign
id|inode_to_host
c_func
(paren
id|inode
)paren
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_if
c_cond
(paren
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|buf
comma
id|count
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|80
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|memcpy_from_fs
c_func
(paren
id|input_buf
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|input_buf
(braket
id|count
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|input_buf
(braket
id|count
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NDT
suffix:semicolon
op_increment
id|i
)paren
(brace
id|len
op_assign
id|strlen
(paren
id|debugger_tokens
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|input_buf
comma
id|debugger_tokens
(braket
id|i
)braket
dot
id|name
comma
id|len
)paren
)paren
r_break
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|NDT
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
id|input_buf
op_plus
id|len
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|debugger_tokens
(braket
id|i
)braket
dot
id|nargs
op_logical_and
op_star
id|ptr
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_star
id|ptr
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|ptr
op_eq
l_char|&squot;&bslash;t&squot;
)paren
(brace
op_increment
id|ptr
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|isdigit
c_func
(paren
op_star
id|ptr
)paren
)paren
(brace
id|args
(braket
id|j
op_increment
)braket
op_assign
id|simple_strtoul
(paren
id|ptr
comma
op_amp
id|ptr
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|j
op_ne
id|debugger_tokens
(braket
id|i
)braket
dot
id|nargs
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_static
r_int
DECL|function|debugger_user_read
id|debugger_user_read
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
)brace
r_static
r_int
DECL|function|debugger_kernel_write
id|debugger_kernel_write
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
id|copy
comma
id|left
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|buflen
)paren
(brace
id|left
op_assign
(paren
id|hostdata-&gt;debug_buf
op_plus
id|hostdata-&gt;debug_size
op_minus
l_int|1
)paren
op_minus
id|hostdata-&gt;debug_write
suffix:semicolon
id|copy
op_assign
(paren
id|buflen
op_le
id|left
)paren
ques
c_cond
id|buflen
suffix:colon
id|left
suffix:semicolon
id|memcpy
(paren
id|hostdata-&gt;debug_write
comma
id|buf
comma
id|copy
)paren
suffix:semicolon
id|buf
op_add_assign
id|copy
suffix:semicolon
id|buflen
op_sub_assign
id|copy
suffix:semicolon
id|hostdata-&gt;debug_count
op_add_assign
id|copy
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hostdata-&gt;debug_write
op_add_assign
id|copy
)paren
op_eq
(paren
id|hostdata-&gt;debug_buf
op_plus
id|hostdata-&gt;debug_size
)paren
)paren
id|hosdata-&gt;debug_write
op_assign
id|hostdata-&gt;debug_buf
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* def NCRDEBUG */
multiline_comment|/* &n; * Function : static void NCR538xx_soft_reset (struct Scsi_Host *host)&n; *&n; * Purpose :  perform a soft reset of the NCR53c8xx chip&n; *&n; * Inputs : host - pointer to this host adapter&squot;s structure&n; *&n; * Preconditions : NCR53c7x0_init must have been called for this &n; *      host.&n; * &n; */
r_static
r_void
DECL|function|NCR53c8x0_soft_reset
id|NCR53c8x0_soft_reset
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/*&n;     * Do a soft reset of the chip so that everything is &n;     * reinitialized to the power-on state.&n;     *&n;     * Basically follow the procedure outlined in the NCR53c700&n;     * data manual under Chapter Six, How to Use, Steps Necessary to&n;     * Start SCRIPTS, with the exception of actually starting the &n;     * script and setting up the synchronous transfer gunk.&n;     */
id|NCR53c7x0_write8
c_func
(paren
id|ISTAT_REG_800
comma
id|ISTAT_10_SRST
)paren
suffix:semicolon
id|NCR53c7x0_write8
c_func
(paren
id|ISTAT_REG_800
comma
l_int|0
)paren
suffix:semicolon
id|NCR53c7x0_write8
c_func
(paren
id|hostdata-&gt;dmode
comma
id|hostdata-&gt;saved_dmode
op_amp
op_complement
id|DMODE_MAN
)paren
suffix:semicolon
multiline_comment|/* &n;     * Respond to reselection by targets and use our _initiator_ SCSI ID  &n;     * for arbitration. If notyet, also respond to SCSI selection.&n;     *&n;     * XXX - Note : we must reprogram this when reselecting as &n;     *&t;a target.&n;     */
macro_line|#ifdef notyet
id|NCR53c7x0_write8
c_func
(paren
id|SCID_REG
comma
(paren
id|host-&gt;this_id
op_amp
l_int|7
)paren
op_or
id|SCID_800_RRE
op_or
id|SCID_800_SRE
)paren
suffix:semicolon
macro_line|#else
id|NCR53c7x0_write8
c_func
(paren
id|SCID_REG
comma
(paren
id|host-&gt;this_id
op_amp
l_int|7
)paren
op_or
id|SCID_800_RRE
)paren
suffix:semicolon
macro_line|#endif
id|NCR53c7x0_write8
c_func
(paren
id|RESPID_REG_800
comma
id|hostdata-&gt;this_id_mask
)paren
suffix:semicolon
multiline_comment|/*&n;     * Use a maximum (1.6) second handshake to handshake timeout,&n;     * and SCSI recommended .5s selection timeout.&n;     */
multiline_comment|/*&n;     * The new gcc won&squot;t recognize preprocessing directives&n;     * within macro args.&n;     */
macro_line|#if 0
id|NCR53c7x0_write8
c_func
(paren
id|STIME0_REG_800
comma
(paren
(paren
id|selection_timeout
op_lshift
id|STIME0_800_SEL_SHIFT
)paren
op_amp
id|STIME0_800_SEL_MASK
)paren
op_or
(paren
(paren
l_int|15
op_lshift
id|STIME0_800_HTH_SHIFT
)paren
op_amp
id|STIME0_800_HTH_MASK
)paren
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* Disable HTH interrupt */
id|NCR53c7x0_write8
c_func
(paren
id|STIME0_REG_800
comma
(paren
(paren
id|selection_timeout
op_lshift
id|STIME0_800_SEL_SHIFT
)paren
op_amp
id|STIME0_800_SEL_MASK
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;     * Enable active negation for happy synchronous transfers.&n;     */
id|NCR53c7x0_write8
c_func
(paren
id|STEST3_REG_800
comma
id|STEST3_800_TE
)paren
suffix:semicolon
multiline_comment|/*&n;     * Enable all interrupts, except parity which we only want when&n;     * the user requests it.&n;     */
id|NCR53c7x0_write8
c_func
(paren
id|DIEN_REG
comma
id|DIEN_800_MDPE
op_or
id|DIEN_800_BF
op_or
id|DIEN_ABRT
op_or
id|DIEN_SSI
op_or
id|DIEN_SIR
op_or
id|DIEN_800_IID
)paren
suffix:semicolon
id|NCR53c7x0_write8
c_func
(paren
id|SIEN0_REG_800
comma
(paren
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_PARITY
)paren
ques
c_cond
id|SIEN_PAR
suffix:colon
l_int|0
)paren
op_or
id|SIEN_RST
op_or
id|SIEN_UDC
op_or
id|SIEN_SGE
op_or
id|SIEN_MA
)paren
suffix:semicolon
id|NCR53c7x0_write8
c_func
(paren
id|SIEN1_REG_800
comma
id|SIEN1_800_STO
op_or
id|SIEN1_800_HTH
)paren
suffix:semicolon
multiline_comment|/* &n;     * Use saved clock frequency divisor and scripts loaded in 16 bit&n;     * mode flags from the saved dcntl.&n;     */
id|NCR53c7x0_write8
c_func
(paren
id|DCNTL_REG
comma
id|hostdata-&gt;saved_dcntl
)paren
suffix:semicolon
id|NCR53c7x0_write8
c_func
(paren
id|CTEST4_REG_800
comma
id|hostdata-&gt;saved_ctest4
)paren
suffix:semicolon
multiline_comment|/* Enable active negation */
id|NCR53c7x0_write8
c_func
(paren
id|STEST3_REG_800
comma
id|STEST3_800_TE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function static struct NCR53c7x0_cmd *allocate_cmd (Scsi_Cmnd *cmd)&n; * &n; * Purpose : Return the first free NCR53c7x0_cmd structure (which are &n; * &t;reused in a LIFO manner to minimize cache thrashing).&n; *&n; * Side effects : If we haven&squot;t yet scheduled allocation of NCR53c7x0_cmd&n; *&t;structures for this device, do so.  Attempt to complete all scheduled&n; *&t;allocations using kmalloc(), putting NCR53c7x0_cmd structures on &n; *&t;the free list.  Teach programmers not to drink and hack.&n; *&n; * Inputs : cmd - SCSI command&n; *&n; * Returns : NCR53c7x0_cmd structure allocated on behalf of cmd;&n; *&t;NULL on failure.&n; */
r_static
r_struct
id|NCR53c7x0_cmd
op_star
DECL|function|allocate_cmd
id|allocate_cmd
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;host
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_void
op_star
id|real
suffix:semicolon
multiline_comment|/* Real address */
r_int
id|size
suffix:semicolon
multiline_comment|/* Size of *tmp */
r_struct
id|NCR53c7x0_cmd
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_ALLOCATION
)paren
id|printk
(paren
l_string|&quot;scsi%d : num_cmds = %d, can_queue = %d&bslash;n&quot;
l_string|&quot;         target = %d, lun = %d, %s&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|hostdata-&gt;num_cmds
comma
id|host-&gt;can_queue
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
(paren
id|hostdata-&gt;cmd_allocated
(braket
id|cmd-&gt;target
)braket
op_amp
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
)paren
ques
c_cond
l_string|&quot;already allocated&quot;
suffix:colon
l_string|&quot;not allocated&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * If we have not yet reserved commands for this I_T_L nexus, and&n; * the device exists (as indicated by permanent Scsi_Cmnd structures&n; * being allocated under 1.3.x, or being outside of scan_scsis in &n; * 1.2.x), do so now.&n; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;cmd_allocated
(braket
id|cmd-&gt;target
)braket
op_amp
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
)paren
op_logical_and
id|cmd-&gt;device
op_logical_and
id|cmd-&gt;device-&gt;has_cmdblocks
)paren
(brace
r_if
c_cond
(paren
(paren
id|hostdata-&gt;extra_allocate
op_plus
id|hostdata-&gt;num_cmds
)paren
OL
id|host-&gt;can_queue
)paren
id|hostdata-&gt;extra_allocate
op_add_assign
id|host-&gt;cmd_per_lun
suffix:semicolon
id|hostdata-&gt;cmd_allocated
(braket
id|cmd-&gt;target
)braket
op_or_assign
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|hostdata-&gt;extra_allocate
OG
l_int|0
suffix:semicolon
op_decrement
id|hostdata-&gt;extra_allocate
comma
op_increment
id|hostdata-&gt;num_cmds
)paren
(brace
multiline_comment|/* historically, kmalloc has returned unaligned addresses; pad so we &n;       have enough room to ROUNDUP */
id|size
op_assign
id|hostdata-&gt;max_cmd_size
op_plus
r_sizeof
(paren
r_void
op_star
)paren
suffix:semicolon
multiline_comment|/* FIXME: for ISA bus &squot;7xx chips, we need to or GFP_DMA in here */
id|real
op_assign
id|kmalloc
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|real
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_ALLOCATION
)paren
id|printk
(paren
l_string|&quot;scsi%d : kmalloc(%d) failed&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|size
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp
op_assign
id|ROUNDUP
c_func
(paren
id|real
comma
r_void
op_star
)paren
suffix:semicolon
id|tmp-&gt;real
op_assign
id|real
suffix:semicolon
id|tmp-&gt;size
op_assign
id|size
suffix:semicolon
id|tmp-&gt;free
op_assign
(paren
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
comma
r_int
)paren
)paren
id|kfree
)paren
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|tmp-&gt;next
op_assign
id|hostdata-&gt;free
suffix:semicolon
id|hostdata-&gt;free
op_assign
id|tmp
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|tmp
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|hostdata-&gt;free
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
id|hostdata-&gt;free
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
id|printk
(paren
l_string|&quot;scsi%d : can&squot;t allocate command for target %d lun %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
multiline_comment|/*&n; * Function static struct NCR53c7x0_cmd *create_cmd (Scsi_Cmnd *cmd) &n; *&n; *&n; * Purpose : allocate a NCR53c7x0_cmd structure, initialize it based on the &n; * &t;Scsi_Cmnd structure passed in cmd, including dsa and Linux field &n; * &t;initialization, and dsa code relocation.&n; *&n; * Inputs : cmd - SCSI command&n; *&n; * Returns : NCR53c7x0_cmd structure corresponding to cmd,&n; *&t;NULL on failure.&n; */
r_static
r_struct
id|NCR53c7x0_cmd
op_star
DECL|function|create_cmd
id|create_cmd
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;host
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_struct
id|NCR53c7x0_cmd
op_star
id|tmp
suffix:semicolon
multiline_comment|/* NCR53c7x0_cmd structure for this command */
r_int
id|datain
comma
multiline_comment|/* Number of instructions per phase */
id|dataout
suffix:semicolon
r_int
id|data_transfer_instructions
comma
multiline_comment|/* Count of dynamic instructions */
id|i
suffix:semicolon
multiline_comment|/* Counter */
id|u32
op_star
id|cmd_datain
comma
multiline_comment|/* Address of datain/dataout code */
op_star
id|cmd_dataout
suffix:semicolon
multiline_comment|/* Incremented as we assemble */
macro_line|#ifdef notyet
r_int
r_char
op_star
id|msgptr
suffix:semicolon
multiline_comment|/* Current byte in select message */
r_int
id|msglen
suffix:semicolon
multiline_comment|/* Length of whole select message */
macro_line|#endif
r_int
r_int
id|flags
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|cmd-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp
op_assign
id|allocate_cmd
(paren
id|cmd
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;     * Decide whether we need to generate commands for DATA IN,&n;     * DATA OUT, neither, or both based on the SCSI command &n;     */
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* These commands do DATA IN */
r_case
id|INQUIRY
suffix:colon
r_case
id|MODE_SENSE
suffix:colon
r_case
id|READ_6
suffix:colon
r_case
id|READ_10
suffix:colon
r_case
id|READ_CAPACITY
suffix:colon
r_case
id|REQUEST_SENSE
suffix:colon
id|datain
op_assign
l_int|2
op_star
(paren
id|cmd-&gt;use_sg
ques
c_cond
id|cmd-&gt;use_sg
suffix:colon
l_int|1
)paren
op_plus
l_int|3
suffix:semicolon
id|dataout
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* These commands do DATA OUT */
r_case
id|MODE_SELECT
suffix:colon
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;scsi%d : command is &quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_command
c_func
(paren
id|cmd-&gt;cmnd
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0
id|printk
(paren
l_string|&quot;scsi%d : %d scatter/gather segments&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;use_sg
)paren
suffix:semicolon
macro_line|#endif
id|datain
op_assign
l_int|0
suffix:semicolon
id|dataout
op_assign
l_int|2
op_star
(paren
id|cmd-&gt;use_sg
ques
c_cond
id|cmd-&gt;use_sg
suffix:colon
l_int|1
)paren
op_plus
l_int|3
suffix:semicolon
macro_line|#if 0
id|hostdata-&gt;options
op_or_assign
id|OPTION_DEBUG_INTR
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
multiline_comment|/* &n;     * These commands do no data transfer, we should force an&n;     * interrupt if a data phase is attempted on them.&n;     */
r_case
id|START_STOP
suffix:colon
multiline_comment|/* also SCAN, which may do DATA OUT */
r_case
id|TEST_UNIT_READY
suffix:colon
id|datain
op_assign
id|dataout
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;     * We don&squot;t know about these commands, so generate code to handle&n;     * both DATA IN and DATA OUT phases.&n;     */
r_default
suffix:colon
id|datain
op_assign
id|dataout
op_assign
l_int|2
op_star
(paren
id|cmd-&gt;use_sg
ques
c_cond
id|cmd-&gt;use_sg
suffix:colon
l_int|1
)paren
op_plus
l_int|3
suffix:semicolon
)brace
multiline_comment|/*&n;     * New code : so that active pointers work correctly regardless&n;     * &t;of where the saved data pointer is at, we want to immediately&n;     * &t;enter the dynamic code after selection, and on a non-data&n;     * &t;phase perform a CALL to the non-data phase handler, with&n;     * &t;returns back to this address.&n;     *&n;     * &t;If a phase mismatch is encountered in the middle of a &n;     * &t;Block MOVE instruction, we want to _leave_ that instruction&n;     *&t;unchanged as the current case is, modify a temporary buffer,&n;     *&t;and point the active pointer (TEMP) at that.&n;     *&n;     * &t;Furthermore, we want to implement a saved data pointer, &n;     * &t;set by the SAVE_DATA_POINTERs message.&n;     *&n;     * &t;So, the data transfer segments will change to &n;     *&t;&t;CALL data_transfer, WHEN NOT data phase&n;     *&t;&t;MOVE x, x, WHEN data phase&n;     *&t;&t;( repeat )&n;     *&t;&t;JUMP other_transfer&n;     */
id|data_transfer_instructions
op_assign
id|datain
op_plus
id|dataout
suffix:semicolon
multiline_comment|/*&n;     * When we perform a request sense, we overwrite various things,&n;     * including the data transfer code.  Make sure we have enough&n;     * space to do that.&n;     */
r_if
c_cond
(paren
id|data_transfer_instructions
OL
l_int|2
)paren
id|data_transfer_instructions
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;     * The saved data pointer is set up so that a RESTORE POINTERS message &n;     * will start the data transfer over at the beginning.&n;     */
id|tmp-&gt;saved_data_pointer
op_assign
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
(paren
id|hostdata-&gt;script
)paren
op_plus
id|hostdata-&gt;E_data_transfer
)paren
suffix:semicolon
multiline_comment|/*&n;     * Initialize Linux specific fields.&n;     */
id|tmp-&gt;cmd
op_assign
id|cmd
suffix:semicolon
id|tmp-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|tmp-&gt;dsa_next_addr
op_assign
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
id|tmp-&gt;dsa
)paren
op_plus
id|hostdata-&gt;dsa_next
op_minus
id|hostdata-&gt;dsa_start
)paren
suffix:semicolon
id|tmp-&gt;dsa_addr
op_assign
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
id|tmp-&gt;dsa
)paren
op_minus
id|hostdata-&gt;dsa_start
)paren
suffix:semicolon
multiline_comment|/* &n;     * Calculate addresses of dynamic code to fill in DSA&n;     */
id|tmp-&gt;data_transfer_start
op_assign
id|tmp-&gt;dsa
op_plus
(paren
id|hostdata-&gt;dsa_end
op_minus
id|hostdata-&gt;dsa_start
)paren
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
id|tmp-&gt;data_transfer_end
op_assign
id|tmp-&gt;data_transfer_start
op_plus
l_int|2
op_star
id|data_transfer_instructions
suffix:semicolon
id|cmd_datain
op_assign
id|datain
ques
c_cond
id|tmp-&gt;data_transfer_start
suffix:colon
l_int|NULL
suffix:semicolon
id|cmd_dataout
op_assign
id|dataout
ques
c_cond
(paren
id|datain
ques
c_cond
id|cmd_datain
op_plus
l_int|2
op_star
id|datain
suffix:colon
id|tmp
op_member_access_from_pointer
id|data_transfer_start
)paren
suffix:colon
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;     * Fill in the NCR53c7x0_cmd structure as follows&n;     * dsa, with fixed up DSA code&n;     * datain code&n;     * dataout code&n;     */
multiline_comment|/* Copy template code into dsa and perform all necessary fixups */
r_if
c_cond
(paren
id|hostdata-&gt;dsa_fixup
)paren
id|hostdata
op_member_access_from_pointer
id|dsa_fixup
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_next
comma
l_int|0
comma
id|le32_to_cpu
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_cmnd
comma
l_int|0
comma
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
id|cmd
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_SYNCHRONOUS
)paren
r_if
c_cond
(paren
id|hostdata-&gt;sync
(braket
id|cmd-&gt;target
)braket
dot
id|select_indirect
op_ne
(paren
(paren
id|hostdata-&gt;sync
(braket
id|cmd-&gt;target
)braket
dot
id|scntl3_sanity
op_lshift
l_int|24
)paren
op_or
(paren
id|cmd-&gt;target
op_lshift
l_int|16
)paren
op_or
(paren
id|hostdata-&gt;sync
(braket
id|cmd-&gt;target
)braket
dot
id|sxfer_sanity
op_lshift
l_int|8
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d :  sanity check failed select_indirect=0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|hostdata-&gt;sync
(braket
id|cmd-&gt;target
)braket
dot
id|select_indirect
)paren
suffix:semicolon
id|FATAL
c_func
(paren
id|host
)paren
suffix:semicolon
)brace
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_select
comma
l_int|0
comma
id|le32_to_cpu
c_func
(paren
id|hostdata-&gt;sync
(braket
id|cmd-&gt;target
)braket
dot
id|select_indirect
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * Right now, we&squot;ll do the WIDE and SYNCHRONOUS negotiations on&n;     * different commands; although it should be trivial to do them&n;     * both at the same time.&n;     */
r_if
c_cond
(paren
id|hostdata-&gt;initiate_wdtr
op_amp
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
)paren
(brace
id|memcpy
(paren
(paren
r_void
op_star
)paren
(paren
id|tmp-&gt;select
op_plus
l_int|1
)paren
comma
(paren
r_void
op_star
)paren
id|wdtr_message
comma
r_sizeof
(paren
id|wdtr_message
)paren
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_msgout
comma
l_int|0
comma
id|le32_to_cpu
c_func
(paren
l_int|1
op_plus
r_sizeof
(paren
id|wdtr_message
)paren
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|hostdata-&gt;initiate_wdtr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hostdata-&gt;initiate_sdtr
op_amp
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
)paren
(brace
id|memcpy
(paren
(paren
r_void
op_star
)paren
(paren
id|tmp-&gt;select
op_plus
l_int|1
)paren
comma
(paren
r_void
op_star
)paren
id|sdtr_message
comma
r_sizeof
(paren
id|sdtr_message
)paren
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_msgout
comma
l_int|0
comma
id|le32_to_cpu
c_func
(paren
l_int|1
op_plus
r_sizeof
(paren
id|sdtr_message
)paren
)paren
)paren
suffix:semicolon
id|tmp-&gt;flags
op_or_assign
id|CMD_FLAG_SDTR
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|hostdata-&gt;initiate_sdtr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#if 1
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;talked_to
op_amp
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_NO_ASYNC
)paren
)paren
(brace
id|memcpy
(paren
(paren
r_void
op_star
)paren
(paren
id|tmp-&gt;select
op_plus
l_int|1
)paren
comma
(paren
r_void
op_star
)paren
id|async_message
comma
r_sizeof
(paren
id|async_message
)paren
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_msgout
comma
l_int|0
comma
id|le32_to_cpu
c_func
(paren
l_int|1
op_plus
r_sizeof
(paren
id|async_message
)paren
)paren
)paren
suffix:semicolon
id|tmp-&gt;flags
op_or_assign
id|CMD_FLAG_SDTR
suffix:semicolon
)brace
macro_line|#endif
r_else
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_msgout
comma
l_int|0
comma
id|le32_to_cpu
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
id|hostdata-&gt;talked_to
op_or_assign
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
suffix:semicolon
id|tmp-&gt;select
(braket
l_int|0
)braket
op_assign
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DISCONNECT
)paren
ques
c_cond
id|IDENTIFY
(paren
l_int|1
comma
id|cmd-&gt;lun
)paren
suffix:colon
id|IDENTIFY
(paren
l_int|0
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_msgout
comma
l_int|1
comma
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
id|tmp-&gt;select
)paren
)paren
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_cmdout
comma
l_int|0
comma
id|le32_to_cpu
c_func
(paren
id|cmd-&gt;cmd_len
)paren
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_cmdout
comma
l_int|1
comma
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
id|cmd-&gt;cmnd
)paren
)paren
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_dataout
comma
l_int|0
comma
id|le32_to_cpu
c_func
(paren
id|cmd_dataout
ques
c_cond
id|virt_to_bus
(paren
id|cmd_dataout
)paren
suffix:colon
id|virt_to_bus
(paren
id|hostdata-&gt;script
)paren
op_plus
id|hostdata-&gt;E_other_transfer
)paren
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_datain
comma
l_int|0
comma
id|le32_to_cpu
c_func
(paren
id|cmd_datain
ques
c_cond
id|virt_to_bus
(paren
id|cmd_datain
)paren
suffix:colon
id|virt_to_bus
(paren
id|hostdata-&gt;script
)paren
op_plus
id|hostdata-&gt;E_other_transfer
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;     * XXX - need to make endian aware, should use separate variables&n;     * for both status and message bytes.&n;     */
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_msgin
comma
l_int|0
comma
id|le32_to_cpu
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* &n; * FIXME : these only works for little endian.  We probably want to &n; * &t;provide message and status fields in the NCR53c7x0_cmd &n; *&t;structure, and assign them to cmd-&gt;result when we&squot;re done.&n; */
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_msgin
comma
l_int|1
comma
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
op_amp
id|cmd-&gt;result
)paren
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_status
comma
l_int|0
comma
id|le32_to_cpu
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_status
comma
l_int|1
comma
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
op_amp
id|cmd-&gt;result
)paren
)paren
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_msgout_other
comma
l_int|0
comma
id|le32_to_cpu
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
id|patch_dsa_32
c_func
(paren
id|tmp-&gt;dsa
comma
id|dsa_msgout_other
comma
l_int|1
comma
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
op_amp
(paren
id|hostdata-&gt;NCR53c7xx_msg_nop
)paren
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * Generate code for zero or more of the DATA IN, DATA OUT phases &n;     * in the format &n;     *&n;     * CALL data_transfer, WHEN NOT phase&n;     * MOVE first buffer length, first buffer address, WHEN phase&n;     * ...&n;     * MOVE last buffer length, last buffer address, WHEN phase&n;     * JUMP other_transfer&n;     */
multiline_comment|/* &n; * See if we&squot;re getting to data transfer by generating an unconditional &n; * interrupt.&n; */
macro_line|#if 0
r_if
c_cond
(paren
id|datain
)paren
(brace
id|cmd_datain
(braket
l_int|0
)braket
op_assign
l_int|0x98080000
suffix:semicolon
id|cmd_datain
(braket
l_int|1
)braket
op_assign
l_int|0x03ffd00d
suffix:semicolon
id|cmd_datain
op_add_assign
l_int|2
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* &n; * XXX - I&squot;m undecided whether all of this nonsense is faster&n; * in the long run, or whether I should just go and implement a loop&n; * on the NCR chip using table indirect mode?&n; *&n; * In any case, this is how it _must_ be done for 53c700/700-66 chips,&n; * so this stays even when we come up with something better.&n; *&n; * When we&squot;re limited to 1 simultaneous command, no overlapping processing,&n; * we&squot;re seeing 630K/sec, with 7% CPU usage on a slow Syquest 45M&n; * drive.&n; *&n; * Not bad, not good. We&squot;ll see.&n; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;use_sg
ques
c_cond
(paren
id|i
OL
id|cmd-&gt;use_sg
)paren
suffix:colon
op_logical_neg
id|i
suffix:semicolon
id|cmd_datain
op_add_assign
l_int|4
comma
id|cmd_dataout
op_add_assign
l_int|4
comma
op_increment
id|i
)paren
(brace
id|u32
id|buf
op_assign
id|cmd-&gt;use_sg
ques
c_cond
id|virt_to_bus
c_func
(paren
(paren
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
)paren
(braket
id|i
)braket
dot
id|address
)paren
suffix:colon
id|virt_to_bus
c_func
(paren
id|cmd-&gt;request_buffer
)paren
suffix:semicolon
id|u32
id|count
op_assign
id|cmd-&gt;use_sg
ques
c_cond
(paren
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
)paren
(braket
id|i
)braket
dot
id|length
suffix:colon
id|cmd-&gt;request_bufflen
suffix:semicolon
r_if
c_cond
(paren
id|datain
)paren
(brace
multiline_comment|/* CALL other_in, WHEN NOT DATA_IN */
id|cmd_datain
(braket
l_int|0
)braket
op_assign
id|le32_to_cpu
c_func
(paren
(paren
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_CALL
op_or
id|DCMD_TCI_IO
)paren
op_lshift
l_int|24
)paren
op_or
id|DBC_TCI_WAIT_FOR_VALID
op_or
id|DBC_TCI_COMPARE_PHASE
)paren
suffix:semicolon
id|cmd_datain
(braket
l_int|1
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
(paren
id|hostdata-&gt;script
)paren
op_plus
id|hostdata-&gt;E_other_in
)paren
suffix:semicolon
multiline_comment|/* MOVE count, buf, WHEN DATA_IN */
id|cmd_datain
(braket
l_int|2
)braket
op_assign
id|le32_to_cpu
c_func
(paren
(paren
(paren
id|DCMD_TYPE_BMI
op_or
id|DCMD_BMI_OP_MOVE_I
op_or
id|DCMD_BMI_IO
)paren
op_lshift
l_int|24
)paren
op_or
id|count
)paren
suffix:semicolon
id|cmd_datain
(braket
l_int|3
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
)paren
suffix:semicolon
macro_line|#if 0
id|print_insn
(paren
id|host
comma
id|cmd_datain
comma
l_string|&quot;dynamic &quot;
comma
l_int|1
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|cmd_datain
op_plus
l_int|2
comma
l_string|&quot;dynamic &quot;
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|dataout
)paren
(brace
multiline_comment|/* CALL other_out, WHEN NOT DATA_OUT */
id|cmd_dataout
(braket
l_int|0
)braket
op_assign
id|le32_to_cpu
c_func
(paren
(paren
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_CALL
)paren
op_lshift
l_int|24
)paren
op_or
id|DBC_TCI_WAIT_FOR_VALID
op_or
id|DBC_TCI_COMPARE_PHASE
)paren
suffix:semicolon
id|cmd_dataout
(braket
l_int|1
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
id|hostdata-&gt;script
)paren
op_plus
id|hostdata-&gt;E_other_out
)paren
suffix:semicolon
multiline_comment|/* MOVE count, buf, WHEN DATA+OUT */
id|cmd_dataout
(braket
l_int|2
)braket
op_assign
id|le32_to_cpu
c_func
(paren
(paren
(paren
id|DCMD_TYPE_BMI
op_or
id|DCMD_BMI_OP_MOVE_I
)paren
op_lshift
l_int|24
)paren
op_or
id|count
)paren
suffix:semicolon
id|cmd_dataout
(braket
l_int|3
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
)paren
suffix:semicolon
macro_line|#if 0
id|print_insn
(paren
id|host
comma
id|cmd_dataout
comma
l_string|&quot;dynamic &quot;
comma
l_int|1
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|cmd_dataout
op_plus
l_int|2
comma
l_string|&quot;dynamic &quot;
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*&n;     * Install JUMP instructions after the data transfer routines to return&n;     * control to the do_other_transfer routines.&n;     */
r_if
c_cond
(paren
id|datain
)paren
(brace
id|cmd_datain
(braket
l_int|0
)braket
op_assign
id|le32_to_cpu
c_func
(paren
(paren
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_JUMP
)paren
op_lshift
l_int|24
)paren
op_or
id|DBC_TCI_TRUE
)paren
suffix:semicolon
id|cmd_datain
(braket
l_int|1
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
id|hostdata-&gt;script
)paren
op_plus
id|hostdata-&gt;E_other_transfer
)paren
suffix:semicolon
macro_line|#if 0
id|print_insn
(paren
id|host
comma
id|cmd_datain
comma
l_string|&quot;dynamic jump &quot;
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|cmd_datain
op_add_assign
l_int|2
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|datain
)paren
(brace
id|cmd_datain
(braket
l_int|0
)braket
op_assign
l_int|0x98080000
suffix:semicolon
id|cmd_datain
(braket
l_int|1
)braket
op_assign
l_int|0x03ffdeed
suffix:semicolon
id|cmd_datain
op_add_assign
l_int|2
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|dataout
)paren
(brace
id|cmd_dataout
(braket
l_int|0
)braket
op_assign
id|le32_to_cpu
c_func
(paren
(paren
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_JUMP
)paren
op_lshift
l_int|24
)paren
op_or
id|DBC_TCI_TRUE
)paren
suffix:semicolon
id|cmd_dataout
(braket
l_int|1
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
id|hostdata-&gt;script
)paren
op_plus
id|hostdata-&gt;E_other_transfer
)paren
suffix:semicolon
macro_line|#if 0
id|print_insn
(paren
id|host
comma
id|cmd_dataout
comma
l_string|&quot;dynamic jump &quot;
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|cmd_dataout
op_add_assign
l_int|2
suffix:semicolon
)brace
r_return
id|tmp
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : int NCR53c7xx_queue_command (Scsi_Cmnd *cmd,&n; *      void (*done)(Scsi_Cmnd *))&n; *&n; * Purpose :  enqueues a SCSI command&n; *&n; * Inputs : cmd - SCSI command, done - function called on completion, with&n; *      a pointer to the command descriptor.&n; *&n; * Returns : 0&n; *&n; * Side effects :&n; *      cmd is added to the per instance driver issue_queue, with major&n; *      twiddling done to the host specific fields of cmd.  If the&n; *      process_issue_queue coroutine isn&squot;t running, it is restarted.&n; * &n; * NOTE : we use the host_scribble field of the Scsi_Cmnd structure to &n; *&t;hold our own data, and pervert the ptr field of the SCp field&n; *&t;to create a linked list.&n; */
r_int
DECL|function|NCR53c7xx_queue_command
id|NCR53c7xx_queue_command
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;host
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|Scsi_Cmnd
op_star
id|tmp
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hostdata-&gt;options
op_amp
(paren
id|OPTION_DEBUG_INIT_ONLY
op_or
id|OPTION_DEBUG_PROBE_ONLY
)paren
)paren
op_logical_or
(paren
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_TARGET_LIMIT
)paren
op_logical_and
op_logical_neg
(paren
id|hostdata-&gt;debug_lun_limit
(braket
id|cmd-&gt;target
)braket
op_amp
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
)paren
)paren
op_logical_or
id|cmd-&gt;target
OG
id|host-&gt;max_id
op_logical_or
id|cmd-&gt;target
op_eq
id|host-&gt;this_id
op_logical_or
id|hostdata-&gt;state
op_eq
id|STATE_DISABLED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : disabled or bad target %d lun %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_NCOMMANDS_LIMIT
)paren
op_logical_and
(paren
id|hostdata-&gt;debug_count_limit
op_eq
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : maximum commands exceeded&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_READ_ONLY
)paren
(brace
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : WRITE attempted with NO_WRITE debugging flag set&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_TARGET_LIMIT
)paren
op_logical_and
id|hostdata-&gt;debug_count_limit
op_ne
op_minus
l_int|1
)paren
op_decrement
id|hostdata-&gt;debug_count_limit
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|le32_to_cpu
c_func
(paren
l_int|0xffff
)paren
suffix:semicolon
multiline_comment|/* The NCR will overwrite message&n;&t;&t;&t;&t;       and status with valid data */
id|cmd-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|tmp
op_assign
id|create_cmd
(paren
id|cmd
)paren
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * REQUEST SENSE commands are inserted at the head of the queue &n;     * so that we do not clear the contingent allegiance condition&n;     * they may be looking at.&n;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;issue_queue
)paren
op_logical_or
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
)paren
(brace
id|cmd-&gt;SCp.ptr
op_assign
(paren
r_int
r_char
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|hostdata-&gt;issue_queue
op_assign
id|cmd
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|tmp-&gt;SCp.ptr
suffix:semicolon
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;SCp.ptr
)paren
suffix:semicolon
id|tmp-&gt;SCp.ptr
op_assign
(paren
r_int
r_char
op_star
)paren
id|cmd
suffix:semicolon
)brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|run_process_issue_queue
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : void to_schedule_list (struct Scsi_Host *host,&n; * &t;struct NCR53c7x0_hostdata * hostdata, Scsi_Cmnd *cmd)&n; *&n; * Purpose : takes a SCSI command which was just removed from the &n; *&t;issue queue, and deals with it by inserting it in the first&n; *&t;free slot in the schedule list or by terminating it immediately.&n; *&n; * Inputs : &n; *&t;host - SCSI host adapter; hostdata - hostdata structure for &n; *&t;this adapter; cmd - a pointer to the command; should have &n; *&t;the host_scribble field initialized to point to a valid &n; *&t;&n; * Side effects : &n; *      cmd is added to the per instance schedule list, with minor &n; *      twiddling done to the host specific fields of cmd.&n; *&n; */
r_static
id|__inline__
r_void
DECL|function|to_schedule_list
id|to_schedule_list
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
comma
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
id|Scsi_Cmnd
op_star
id|tmp
op_assign
id|cmd-&gt;cmd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* dsa start is negative, so subtraction is used */
r_volatile
id|u32
op_star
id|curr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;scsi%d : new dsa is 0x%lx (virt 0x%p)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|virt_to_bus
c_func
(paren
id|dsa
)paren
comma
id|dsa
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;     * Work around race condition : if an interrupt fired and we &n;     * got disabled forget about this command.&n;     */
r_if
c_cond
(paren
id|hostdata-&gt;state
op_eq
id|STATE_DISABLED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : driver disabled&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|tmp-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
id|cmd-&gt;next
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|hostdata-&gt;free
suffix:semicolon
id|hostdata-&gt;free
op_assign
id|cmd
suffix:semicolon
id|tmp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|host-&gt;can_queue
comma
id|curr
op_assign
id|hostdata-&gt;schedule
suffix:semicolon
id|i
OG
l_int|0
op_logical_and
id|curr
(braket
l_int|0
)braket
op_ne
id|hostdata-&gt;NOP_insn
suffix:semicolon
op_decrement
id|i
comma
id|curr
op_add_assign
l_int|2
multiline_comment|/* JUMP instructions are two words */
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
(brace
op_increment
id|hostdata-&gt;busy
(braket
id|tmp-&gt;target
)braket
(braket
id|tmp-&gt;lun
)braket
suffix:semicolon
id|cmd-&gt;next
op_assign
id|hostdata-&gt;running_list
suffix:semicolon
id|hostdata-&gt;running_list
op_assign
id|cmd
suffix:semicolon
multiline_comment|/* Restore this instruction to a NOP once the command starts */
id|cmd-&gt;dsa
(braket
(paren
id|hostdata-&gt;dsa_jump_dest
op_minus
id|hostdata-&gt;dsa_start
)paren
op_div
r_sizeof
(paren
id|u32
)paren
)braket
op_assign
(paren
id|u32
)paren
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
(paren
(paren
r_void
op_star
)paren
id|curr
)paren
)paren
suffix:semicolon
multiline_comment|/* Replace the current jump operand.  */
id|curr
(braket
l_int|1
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
(paren
(paren
r_void
op_star
)paren
id|cmd-&gt;dsa
)paren
op_plus
id|hostdata-&gt;E_dsa_code_begin
op_minus
id|hostdata-&gt;E_dsa_code_template
)paren
suffix:semicolon
multiline_comment|/* Replace the NOP instruction with a JUMP */
id|curr
(braket
l_int|0
)braket
op_assign
id|le32_to_cpu
c_func
(paren
(paren
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_JUMP
)paren
op_lshift
l_int|24
)paren
op_or
id|DBC_TCI_TRUE
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;scsi%d: no free slot&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|disable
c_func
(paren
id|host
)paren
suffix:semicolon
id|tmp-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|cmd-&gt;next
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|hostdata-&gt;free
suffix:semicolon
id|hostdata-&gt;free
op_assign
id|cmd
suffix:semicolon
id|tmp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* &n;     * If the NCR chip is in an idle state, start it running the scheduler&n;     * immediately.  Otherwise, signal the chip to jump to schedule as &n;     * soon as it is idle.&n;     */
r_if
c_cond
(paren
id|hostdata-&gt;idle
)paren
(brace
id|hostdata-&gt;idle
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|STATE_RUNNING
suffix:semicolon
id|NCR53c7x0_write32
(paren
id|DSP_REG
comma
id|virt_to_bus
(paren
(paren
r_void
op_star
)paren
id|hostdata-&gt;schedule
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|NCR53c7x0_write8
c_func
(paren
id|hostdata-&gt;istat
comma
id|ISTAT_10_SIGP
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : busyp (struct Scsi_Host *host, struct NCR53c7x0_hostdata &n; *&t;*hostdata, Scsi_Cmnd *cmd)&n; *&n; * Purpose : decide if we can pass the given SCSI command on to the &n; *&t;device in question or not.&n; *  &n; * Returns : non-zero when we&squot;re busy, 0 when we aren&squot;t.&n; */
r_static
id|__inline__
r_int
DECL|function|busyp
id|busyp
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/* FIXME : in the future, this needs to accommodate SCSI-II tagged&n;       queuing, and we may be able to play with fairness here a bit.&n;     */
r_return
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
(braket
id|cmd-&gt;lun
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : process_issue_queue (void)&n; *&n; * Purpose : transfer commands from the issue queue to NCR start queue &n; *&t;of each NCR53c7/8xx in the system, avoiding kernel stack &n; *&t;overflows when the scsi_done() function is invoked recursively.&n; * &n; * NOTE : process_issue_queue exits with interrupts *disabled*, so the &n; *&t;caller must reenable them if it desires.&n; * &n; * NOTE : process_issue_queue should be called from both &n; *&t;NCR53c7x0_queue_command() and from the interrupt handler &n; *&t;after command completion in case NCR53c7x0_queue_command()&n; * &t;isn&squot;t invoked again but we&squot;ve freed up resources that are&n; *&t;needed.&n; */
r_static
r_void
DECL|function|process_issue_queue
id|process_issue_queue
(paren
r_int
r_int
id|flags
)paren
(brace
id|Scsi_Cmnd
op_star
id|tmp
comma
op_star
id|prev
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
suffix:semicolon
r_int
id|done
suffix:semicolon
multiline_comment|/*&n;     * We run (with interrupts disabled) until we&squot;re sure that none of &n;     * the host adapters have anything that can be done, at which point &n;     * we set process_issue_queue_running to 0 and exit.&n;     *&n;     * Interrupts are enabled before doing various other internal &n;     * instructions, after we&squot;ve decided that we need to run through&n;     * the loop again.&n;     *&n;     */
r_do
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Freeze request queues */
id|done
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|host
op_assign
id|first_host
suffix:semicolon
id|host
op_logical_and
id|host-&gt;hostt
op_eq
id|the_template
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
(brace
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;issue_queue
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;state
op_eq
id|STATE_DISABLED
)paren
(brace
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|hostdata-&gt;issue_queue
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;SCp.ptr
suffix:semicolon
id|tmp-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;host_scribble
)paren
(brace
(paren
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
op_member_access_from_pointer
id|next
op_assign
id|hostdata-&gt;free
suffix:semicolon
id|hostdata-&gt;free
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|tmp-&gt;host_scribble
suffix:semicolon
id|tmp-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
)brace
id|tmp-&gt;scsi_done
(paren
id|tmp
)paren
suffix:semicolon
id|done
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
comma
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|tmp
suffix:semicolon
id|prev
op_assign
id|tmp
comma
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;SCp.ptr
)paren
r_if
c_cond
(paren
op_logical_neg
id|tmp-&gt;host_scribble
op_logical_or
op_logical_neg
id|busyp
(paren
id|host
comma
id|hostdata
comma
id|tmp
)paren
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;SCp.ptr
op_assign
id|tmp-&gt;SCp.ptr
suffix:semicolon
r_else
id|hostdata-&gt;issue_queue
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;SCp.ptr
suffix:semicolon
id|tmp-&gt;SCp.ptr
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;host_scribble
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_QUEUES
)paren
id|printk
(paren
l_string|&quot;scsi%d : moving command for target %d lun %d to start list&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|tmp-&gt;target
comma
id|tmp-&gt;lun
)paren
suffix:semicolon
id|to_schedule_list
(paren
id|host
comma
id|hostdata
comma
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
suffix:semicolon
)brace
r_else
(brace
id|tmp-&gt;result
op_assign
id|le32_to_cpu
c_func
(paren
id|tmp-&gt;result
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|tmp-&gt;result
op_amp
l_int|0xff
)paren
op_eq
l_int|0xff
)paren
op_logical_or
(paren
(paren
id|tmp-&gt;result
op_amp
l_int|0xff00
)paren
op_eq
l_int|0xff00
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : danger Will Robinson!&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|tmp-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|disable
(paren
id|host
)paren
suffix:semicolon
)brace
id|tmp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|done
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if target/lun is not busy */
)brace
multiline_comment|/* if hostdata-&gt;issue_queue */
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* for host */
)brace
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
suffix:semicolon
id|process_issue_queue_running
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : static void intr_scsi (struct Scsi_Host *host, &n; * &t;struct NCR53c7x0_cmd *cmd)&n; *&n; * Purpose : handle all SCSI interrupts, indicated by the setting &n; * &t;of the SIP bit in the ISTAT register.&n; *&n; * Inputs : host, cmd - host and NCR command causing the interrupt, cmd&n; * &t;may be NULL.&n; */
r_static
r_void
DECL|function|intr_scsi
id|intr_scsi
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
r_char
id|sstat0_sist0
comma
id|sist1
comma
multiline_comment|/* Registers */
id|fatal
suffix:semicolon
multiline_comment|/* Did a fatal interrupt &n;&t;&t;&t;&t;&t;&t;   occur ? */
r_int
id|is_8xx_chip
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
id|fatal
op_assign
l_int|0
suffix:semicolon
id|is_8xx_chip
op_assign
(paren
(paren
r_int
)paren
(paren
id|hostdata-&gt;chip
op_minus
l_int|800
)paren
)paren
OL
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|is_8xx_chip
)paren
(brace
id|sstat0_sist0
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SIST0_REG_800
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|sist1
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SIST1_REG_800
)paren
suffix:semicolon
)brace
r_else
(brace
id|sstat0_sist0
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SSTAT0_REG
)paren
suffix:semicolon
id|sist1
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : SIST0 0x%0x, SIST1 0x%0x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|sstat0_sist0
comma
id|sist1
)paren
suffix:semicolon
multiline_comment|/* 250ms selection timeout */
r_if
c_cond
(paren
(paren
id|is_8xx_chip
op_logical_and
(paren
id|sist1
op_amp
id|SIST1_800_STO
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|is_8xx_chip
op_logical_and
(paren
id|sstat0_sist0
op_amp
id|SSTAT0_700_STO
)paren
)paren
)paren
(brace
id|fatal
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : Selection Timeout&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : target %d, lun %d, command &quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;cmd-&gt;target
comma
id|cmd-&gt;cmd-&gt;lun
)paren
suffix:semicolon
id|print_command
(paren
id|cmd-&gt;cmd-&gt;cmnd
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : dsp = 0x%x (virt 0x%p)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|NCR53c7x0_read32
c_func
(paren
id|DSP_REG
)paren
comma
id|bus_to_virt
c_func
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DSP_REG
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : no command&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * XXX - question : how do we want to handle the Illegal Instruction&n; * &t;interrupt, which may occur before or after the Selection Timeout&n; * &t;interrupt?&n; */
r_if
c_cond
(paren
l_int|1
)paren
(brace
id|hostdata-&gt;idle
op_assign
l_int|1
suffix:semicolon
id|hostdata-&gt;expecting_sto
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;test_running
)paren
(brace
id|hostdata-&gt;test_running
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;test_completed
op_assign
l_int|3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd
)paren
(brace
id|abnormal_finished
c_func
(paren
id|cmd
comma
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
macro_line|#if 0&t;    
id|hostdata-&gt;intrs
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*&n; * FIXME : in theory, we can also get a UDC when a STO occurs.&n; */
r_if
c_cond
(paren
id|sstat0_sist0
op_amp
id|SSTAT0_UDC
)paren
(brace
id|fatal
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : target %d lun %d unexpected disconnect&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;cmd-&gt;target
comma
id|cmd-&gt;cmd-&gt;lun
)paren
suffix:semicolon
id|print_lots
(paren
id|host
)paren
suffix:semicolon
id|abnormal_finished
c_func
(paren
id|cmd
comma
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;scsi%d : unexpected disconnect (no command)&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|hostdata-&gt;dsp
op_assign
(paren
id|u32
op_star
)paren
id|hostdata-&gt;schedule
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* SCSI PARITY error */
r_if
c_cond
(paren
id|sstat0_sist0
op_amp
id|SSTAT0_PAR
)paren
(brace
id|fatal
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_logical_and
id|cmd-&gt;cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : target %d lun %d parity error.&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;cmd-&gt;target
comma
id|cmd-&gt;cmd-&gt;lun
)paren
suffix:semicolon
id|abnormal_finished
(paren
id|cmd
comma
id|DID_PARITY
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;scsi%d : parity error&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
multiline_comment|/* Should send message out, parity error */
multiline_comment|/* XXX - Reduce synchronous transfer rate! */
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_initiator_abort
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* SCSI GROSS error */
)brace
r_if
c_cond
(paren
id|sstat0_sist0
op_amp
id|SSTAT0_SGE
)paren
(brace
id|fatal
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : gross error&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
multiline_comment|/* Reset SCSI offset */
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
(brace
id|NCR53c7x0_write8
(paren
id|STEST2_REG_800
comma
id|STEST2_800_ROF
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;         * A SCSI gross error may occur when we have &n;&t; *&n;&t; * - A synchronous offset which causes the SCSI FIFO to be overwritten.&n;&t; *&n;&t; * - A REQ which causes the maximum synchronous offset programmed in &n;&t; * &t;the SXFER register to be exceeded.&n;&t; *&n;&t; * - A phase change with an outstanding synchronous offset.&n;&t; *&n;&t; * - Residual data in the synchronous data FIFO, with a transfer&n;&t; *&t;other than a synchronous receive is started.$#&n;&t; */
multiline_comment|/* XXX Should deduce synchronous transfer rate! */
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_initiator_abort
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Phase mismatch */
)brace
r_if
c_cond
(paren
id|sstat0_sist0
op_amp
id|SSTAT0_MA
)paren
(brace
id|fatal
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : SSTAT0_MA&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|intr_phase_mismatch
(paren
id|host
comma
id|cmd
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|sstat0_sist0
op_amp
id|SIST0_800_RSL
)paren
id|printk
(paren
l_string|&quot;scsi%d : Oh no Mr. Bill!&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * If a fatal SCSI interrupt occurs, we must insure that the DMA and&n; * SCSI FIFOs were flushed.&n; */
r_if
c_cond
(paren
id|fatal
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;dstat_valid
)paren
(brace
id|hostdata-&gt;dstat
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|DSTAT_REG
)paren
suffix:semicolon
id|hostdata-&gt;dstat_valid
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* XXX - code check for 700/800 chips */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;dstat
op_amp
id|DSTAT_DFE
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : DMA FIFO not empty&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NCR53c7x0_read8
(paren
id|CTEST2_REG_800
)paren
op_amp
id|CTEST2_800_DDIR
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d: Flushing DMA FIFO&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|NCR53c7x0_write8
(paren
id|CTEST3_REG_800
comma
id|CTEST3_800_FLF
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|hostdata-&gt;dstat
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|DSTAT_REG
)paren
)paren
op_amp
id|DSTAT_DFE
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|NCR53c7x0_write8
(paren
id|CTEST3_REG_800
comma
id|CTEST3_800_CLF
)paren
suffix:semicolon
r_while
c_loop
(paren
id|NCR53c7x0_read8
(paren
id|CTEST3_REG_800
)paren
op_amp
id|CTEST3_800_CLF
)paren
suffix:semicolon
)brace
id|hostdata-&gt;dstat
op_or_assign
id|DSTAT_DFE
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Function : do_NCR53c7x0_intr()&n; *&n; * Purpose : A quick wrapper function added to grab the io_request_lock&n; *      spin lock prior to entering the real interrupt handler.  Needed&n; *      for 2.1.95 and above.&n; */
r_static
r_void
DECL|function|do_NCR53c7x0_intr
id|do_NCR53c7x0_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|NCR53c7x0_intr
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : static void NCR53c7x0_intr (int irq, void *dev_id, struct pt_regs * regs)&n; *&n; * Purpose : handle NCR53c7x0 interrupts for all NCR devices sharing&n; *&t;the same IRQ line.  &n; * &n; * Inputs : Since we&squot;re using the SA_INTERRUPT interrupt handler&n; *&t;semantics, irq indicates the interrupt which invoked &n; *&t;this handler.  &n; */
r_static
r_void
DECL|function|NCR53c7x0_intr
id|NCR53c7x0_intr
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
multiline_comment|/* Host we are looking at */
r_int
r_char
id|istat
suffix:semicolon
multiline_comment|/* Values of interrupt regs */
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
suffix:semicolon
multiline_comment|/* host-&gt;hostdata */
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
comma
multiline_comment|/* command which halted */
op_star
op_star
id|cmd_prev_ptr
suffix:semicolon
id|u32
op_star
id|dsa
suffix:semicolon
multiline_comment|/* DSA */
r_int
id|done
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Indicates when handler &n;&t;&t;&t;&t;&t;&t;   should terminate */
r_int
id|interrupted
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This HA generated &n;&t;&t;&t;&t;&t;&t;   an interrupt */
r_int
id|have_intfly
suffix:semicolon
multiline_comment|/* Don&squot;t print warning &n;&t;&t;&t;&t;&t;&t;   messages when we stack&n;&t;&t;&t;&t;&t;&t;   INTFLYs */
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef NCR_DEBUG
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
multiline_comment|/* Debugging sprintf buffer */
r_int
id|buflen
suffix:semicolon
multiline_comment|/* Length of same */
macro_line|#endif
r_do
(brace
id|done
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|host
op_assign
id|first_host
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
r_if
c_cond
(paren
id|host-&gt;hostt
op_eq
id|the_template
op_logical_and
id|host-&gt;irq
op_eq
id|irq
)paren
(brace
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|0
suffix:semicolon
id|interrupted
op_assign
l_int|0
suffix:semicolon
id|have_intfly
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_int
id|is_8xx_chip
suffix:semicolon
id|hostdata-&gt;dstat_valid
op_assign
l_int|0
suffix:semicolon
id|interrupted
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Only read istat once, since reading it again will unstack&n;&t;&t; * interrupts?&n;&t;&t; */
id|istat
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|hostdata-&gt;istat
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * INTFLY interrupts are used by the NCR53c720, NCR53c810,&n;&t;&t; * and NCR53c820 to signify completion of a command.  Since &n;&t;&t; * the SCSI processor continues running, we can&squot;t just look&n;&t;&t; * at the contents of the DSA register and continue running.&n;&t;&t; */
multiline_comment|/* XXX - this is too big, offends my sense of aesthetics, and should &n;   move to intr_intfly() */
id|is_8xx_chip
op_assign
(paren
(paren
r_int
)paren
(paren
id|hostdata-&gt;chip
op_minus
l_int|800
)paren
)paren
OL
l_int|100
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_INTFLY
)paren
op_logical_and
(paren
id|is_8xx_chip
op_logical_and
(paren
id|istat
op_amp
id|ISTAT_800_INTF
)paren
)paren
)paren
(brace
r_char
id|search_found
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Got at least one ? */
id|done
op_assign
l_int|0
suffix:semicolon
id|interrupted
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* &n;&t;&t;     * Clear the INTF bit by writing a one.  &n;&t;&t;     * This reset operation is self-clearing.&n;&t;&t;     */
id|NCR53c7x0_write8
c_func
(paren
id|hostdata-&gt;istat
comma
id|istat
op_or
id|ISTAT_800_INTF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : INTFLY&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;     * Traverse our list of running commands, and look&n;&t;&t;     * for those with valid (non-0xff ff) status and message&n;&t;&t;     * bytes encoded in the result which signify command&n;&t;&t;     * completion.&n;&t;&t;     */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|restart
suffix:colon
r_for
c_loop
(paren
id|cmd_prev_ptr
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
op_star
)paren
op_amp
(paren
id|hostdata-&gt;running_list
)paren
comma
id|cmd
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|hostdata-&gt;running_list
suffix:semicolon
id|cmd
suffix:semicolon
id|cmd_prev_ptr
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
op_star
)paren
op_amp
(paren
id|cmd-&gt;next
)paren
comma
id|cmd
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|cmd-&gt;next
)paren
(brace
id|Scsi_Cmnd
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : very weird.&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp
op_assign
id|cmd-&gt;cmd
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : weird.  NCR53c7x0_cmd has no Scsi_Cmnd&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#if 0
id|printk
(paren
l_string|&quot;scsi%d : looking at result of 0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;cmd-&gt;result
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef __powerpc__
r_if
c_cond
(paren
id|tmp-&gt;result
op_eq
id|le32_to_cpu
c_func
(paren
l_int|0xffff
)paren
)paren
r_continue
suffix:semicolon
id|tmp-&gt;result
op_assign
id|le32_to_cpu
c_func
(paren
id|tmp-&gt;result
)paren
suffix:semicolon
macro_line|#else&t;&t;&t;
r_if
c_cond
(paren
(paren
(paren
id|tmp-&gt;result
op_amp
l_int|0xff
)paren
op_eq
l_int|0xff
)paren
op_logical_or
(paren
(paren
id|tmp-&gt;result
op_amp
l_int|0xff00
)paren
op_eq
l_int|0xff00
)paren
)paren
r_continue
suffix:semicolon
macro_line|#endif&t;&t;&t;    
id|search_found
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Important - remove from list _before_ done is called */
r_if
c_cond
(paren
id|cmd_prev_ptr
)paren
op_star
id|cmd_prev_ptr
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|cmd-&gt;next
suffix:semicolon
op_decrement
id|hostdata-&gt;busy
(braket
id|tmp-&gt;target
)braket
(braket
id|tmp-&gt;lun
)braket
suffix:semicolon
id|cmd-&gt;next
op_assign
id|hostdata-&gt;free
suffix:semicolon
id|hostdata-&gt;free
op_assign
id|cmd
suffix:semicolon
id|tmp-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : command complete : pid %lu, id %d,lun %d result 0x%x &quot;
comma
id|host-&gt;host_no
comma
id|tmp-&gt;pid
comma
id|tmp-&gt;target
comma
id|tmp-&gt;lun
comma
id|tmp-&gt;result
)paren
suffix:semicolon
id|print_command
(paren
id|tmp-&gt;cmnd
)paren
suffix:semicolon
)brace
macro_line|#if 0
id|hostdata-&gt;options
op_and_assign
op_complement
id|OPTION_DEBUG_INTR
suffix:semicolon
macro_line|#endif
id|tmp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;     * I think that we&squot;re stacking INTFLY interrupts; taking care of &n;     * all the finished commands on the first one, and then getting&n;     * worried when we see the next one.  The magic with have_intfly&n;     * should tell if this is the case..&n;     */
r_if
c_cond
(paren
op_logical_neg
id|search_found
op_logical_and
op_logical_neg
id|have_intfly
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : WARNING : INTFLY with no completed commands.&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|have_intfly
)paren
(brace
id|have_intfly
op_assign
l_int|1
suffix:semicolon
id|run_process_issue_queue
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|istat
op_amp
(paren
id|ISTAT_SIP
op_or
id|ISTAT_DIP
)paren
)paren
(brace
id|done
op_assign
l_int|0
suffix:semicolon
id|interrupted
op_assign
l_int|1
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|STATE_HALTED
suffix:semicolon
r_if
c_cond
(paren
id|NCR53c7x0_read8
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
ques
c_cond
id|SSTAT1_REG
suffix:colon
id|SSTAT2_REG
)paren
op_amp
id|SSTAT2_FF_MASK
)paren
id|printk
(paren
l_string|&quot;scsi%d : SCSI FIFO not empty&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;     * NCR53c700 and NCR53c700-66 change the current SCSI&n;&t;&t;     * process, hostdata-&gt;curr, in the Linux driver so&n;&t;&t;     * cmd = hostdata-&gt;curr.&n;&t;&t;     *&n;&t;&t;     * With other chips, we must look through the commands&n;&t;&t;     * executing and find the command structure which &n;&t;&t;     * corresponds to the DSA register.&n;&t;&t;     */
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_700
)paren
(brace
id|cmd
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|hostdata-&gt;curr
suffix:semicolon
)brace
r_else
(brace
id|dsa
op_assign
id|bus_to_virt
c_func
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DSA_REG
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cmd
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|hostdata-&gt;running_list
suffix:semicolon
id|cmd
op_logical_and
(paren
id|dsa
op_plus
(paren
id|hostdata-&gt;dsa_start
op_div
r_sizeof
(paren
id|u32
)paren
)paren
)paren
op_ne
id|cmd-&gt;dsa
suffix:semicolon
id|cmd
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
(paren
id|cmd-&gt;next
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
(brace
r_if
c_cond
(paren
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : interrupt for pid %lu, id %d, lun %d &quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;cmd-&gt;pid
comma
(paren
r_int
)paren
id|cmd-&gt;cmd-&gt;target
comma
(paren
r_int
)paren
id|cmd-&gt;cmd-&gt;lun
)paren
suffix:semicolon
id|print_command
(paren
id|cmd-&gt;cmd-&gt;cmnd
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : no active command&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|istat
op_amp
id|ISTAT_SIP
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : ISTAT_SIP&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|intr_scsi
(paren
id|host
comma
id|cmd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|istat
op_amp
id|ISTAT_DIP
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : ISTAT_DIP&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|intr_dma
(paren
id|host
comma
id|cmd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;dstat_valid
)paren
(brace
id|hostdata-&gt;dstat
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|DSTAT_REG
)paren
suffix:semicolon
id|hostdata-&gt;dstat_valid
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* XXX - code check for 700/800 chips */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;dstat
op_amp
id|DSTAT_DFE
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : DMA FIFO not empty&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NCR53c7x0_read8
(paren
id|CTEST2_REG_800
)paren
op_amp
id|CTEST2_800_DDIR
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d: Flushing DMA FIFO&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|NCR53c7x0_write8
(paren
id|CTEST3_REG_800
comma
id|CTEST3_800_FLF
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|hostdata-&gt;dstat
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|DSTAT_REG
)paren
)paren
op_amp
id|DSTAT_DFE
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|NCR53c7x0_write8
(paren
id|CTEST3_REG_800
comma
id|CTEST3_800_CLF
)paren
suffix:semicolon
r_while
c_loop
(paren
id|NCR53c7x0_read8
(paren
id|CTEST3_REG_800
)paren
op_amp
id|CTEST3_800_CLF
)paren
suffix:semicolon
)brace
id|hostdata-&gt;dstat
op_or_assign
id|DSTAT_DFE
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|interrupted
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;intrs
op_ne
op_minus
l_int|1
)paren
id|hostdata-&gt;intrs
op_increment
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|hostdata-&gt;intrs
OG
l_int|40
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : too many interrupts, halting&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|disable
c_func
(paren
id|host
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;idle
op_logical_and
id|hostdata-&gt;state
op_eq
id|STATE_HALTED
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;dsp_changed
)paren
(brace
id|hostdata-&gt;dsp
op_assign
(paren
id|u32
op_star
)paren
id|bus_to_virt
c_func
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DSP_REG
)paren
)paren
suffix:semicolon
)brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;scsi%d : new dsp is 0x%lx (virt 0x%p)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|virt_to_bus
c_func
(paren
id|hostdata-&gt;dsp
)paren
comma
id|hostdata-&gt;dsp
)paren
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;state
op_assign
id|STATE_RUNNING
suffix:semicolon
id|NCR53c7x0_write32
(paren
id|DSP_REG
comma
id|virt_to_bus
c_func
(paren
id|hostdata-&gt;dsp
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : static int abort_connected (struct Scsi_Host *host)&n; *&n; * Purpose : Assuming that the NCR SCSI processor is currently &n; * &t;halted, break the currently established nexus.  Clean&n; *&t;up of the NCR53c7x0_cmd and Scsi_Cmnd structures should&n; *&t;be done on receipt of the abort interrupt.&n; *&n; * Inputs : host - SCSI host&n; *&n; */
r_static
r_int
DECL|function|abort_connected
id|abort_connected
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
macro_line|#ifdef NEW_ABORT
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
multiline_comment|/* FIXME : this probably should change for production kernels; at the &n;   least, counter should move to a per-host structure. */
r_static
r_int
id|counter
op_assign
l_int|5
suffix:semicolon
macro_line|#ifdef NEW_ABORT
r_int
id|sstat
comma
id|phase
comma
id|offset
suffix:semicolon
id|u32
op_star
id|script
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_decrement
id|counter
op_le
l_int|0
)paren
(brace
id|disable
c_func
(paren
id|host
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;scsi%d : DANGER : abort_connected() called &bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
macro_line|#ifdef NEW_ABORT
multiline_comment|/*&n; * New strategy : Rather than using a generic abort routine,&n; * we&squot;ll specifically try to source or sink the appropriate&n; * amount of data for the phase we&squot;re currently in (taking into &n; * account the current synchronous offset) &n; */
id|sstat
op_assign
(paren
id|NCR53c8x0_read8
(paren
(paren
id|chip
op_div
l_int|100
)paren
op_eq
l_int|8
ques
c_cond
id|SSTAT1_REG
suffix:colon
id|SSTAT2_REG
)paren
suffix:semicolon
id|offset
op_assign
id|OFFSET
(paren
id|sstat
op_amp
id|SSTAT2_FF_MASK
)paren
op_rshift
id|SSTAT2_FF_SHIFT
suffix:semicolon
id|phase
op_assign
id|sstat
op_amp
id|SSTAT2_PHASE_MASK
suffix:semicolon
multiline_comment|/*&n; * SET ATN&n; * MOVE source_or_sink, WHEN CURRENT PHASE &n; * &lt; repeat for each outstanding byte &gt;&n; * JUMP send_abort_message&n; */
id|script
op_assign
id|hostdata-&gt;abort_script
op_assign
id|kmalloc
(paren
l_int|8
multiline_comment|/* instruction size */
op_star
(paren
l_int|1
multiline_comment|/* set ATN */
op_plus
(paren
op_logical_neg
id|offset
ques
c_cond
l_int|1
suffix:colon
id|offset
)paren
multiline_comment|/* One transfer per outstanding byte */
op_plus
l_int|1
multiline_comment|/* send abort message */
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
macro_line|#else /* def NEW_ABORT */
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_initiator_abort
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
macro_line|#endif /* def NEW_ABORT */
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* XXX - need to flag the command as aborted after the abort_connected&n; &t; code runs &n; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : static int datapath_residual (Scsi_Host *host)&n; *&n; * Purpose : return residual data count of what&squot;s in the chip.&n; *&n; * Inputs : host - SCSI host&n; */
r_static
r_int
DECL|function|datapath_residual
id|datapath_residual
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
id|count
comma
id|synchronous
comma
id|sstat
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* COMPAT : the 700 and 700-66 need to use DFIFO_00_BO_MASK */
id|count
op_assign
(paren
(paren
id|NCR53c7x0_read8
(paren
id|DFIFO_REG
)paren
op_amp
id|DFIFO_10_BO_MASK
)paren
op_minus
(paren
id|NCR53c7x0_read32
(paren
id|DBC_REG
)paren
op_amp
id|DFIFO_10_BO_MASK
)paren
)paren
op_amp
id|DFIFO_10_BO_MASK
suffix:semicolon
id|synchronous
op_assign
id|NCR53c7x0_read8
(paren
id|SXFER_REG
)paren
op_amp
id|SXFER_MO_MASK
suffix:semicolon
multiline_comment|/* COMPAT : DDIR is elsewhere on non-&squot;8xx chips. */
r_if
c_cond
(paren
id|NCR53c7x0_read8
(paren
id|CTEST2_REG_800
)paren
op_amp
id|CTEST2_800_DDIR
)paren
(brace
multiline_comment|/* Receive */
r_if
c_cond
(paren
id|synchronous
)paren
id|count
op_add_assign
(paren
id|NCR53c7x0_read8
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
ques
c_cond
id|SSTAT1_REG
suffix:colon
id|SSTAT2_REG
)paren
op_amp
id|SSTAT2_FF_MASK
)paren
op_rshift
id|SSTAT2_FF_SHIFT
suffix:semicolon
r_else
r_if
c_cond
(paren
id|NCR53c7x0_read8
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
ques
c_cond
id|SSTAT0_REG
suffix:colon
id|SSTAT1_REG
)paren
op_amp
id|SSTAT1_ILF
)paren
op_increment
id|count
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Send */
id|sstat
op_assign
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
ques
c_cond
id|NCR53c7x0_read8
(paren
id|SSTAT0_REG
)paren
suffix:colon
id|NCR53c7x0_read8
(paren
id|SSTAT1_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sstat
op_amp
id|SSTAT1_OLF
)paren
op_increment
id|count
suffix:semicolon
r_if
c_cond
(paren
id|synchronous
op_logical_and
(paren
id|sstat
op_amp
id|SSTAT1_ORF
)paren
)paren
op_increment
id|count
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : static const char * sbcl_to_phase (int sbcl)_&n; *&n; * Purpose : Convert SBCL register to user-parsable phase representation&n; *&n; * Inputs : sbcl - value of sbcl register&n; */
r_static
r_const
r_char
op_star
DECL|function|sbcl_to_phase
id|sbcl_to_phase
(paren
r_int
id|sbcl
)paren
(brace
r_switch
c_cond
(paren
id|sbcl
op_amp
id|SBCL_PHASE_MASK
)paren
(brace
r_case
id|SBCL_PHASE_DATAIN
suffix:colon
r_return
l_string|&quot;DATAIN&quot;
suffix:semicolon
r_case
id|SBCL_PHASE_DATAOUT
suffix:colon
r_return
l_string|&quot;DATAOUT&quot;
suffix:semicolon
r_case
id|SBCL_PHASE_MSGIN
suffix:colon
r_return
l_string|&quot;MSGIN&quot;
suffix:semicolon
r_case
id|SBCL_PHASE_MSGOUT
suffix:colon
r_return
l_string|&quot;MSGOUT&quot;
suffix:semicolon
r_case
id|SBCL_PHASE_CMDOUT
suffix:colon
r_return
l_string|&quot;CMDOUT&quot;
suffix:semicolon
r_case
id|SBCL_PHASE_STATIN
suffix:colon
r_return
l_string|&quot;STATUSIN&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Function : static const char * sstat2_to_phase (int sstat)_&n; *&n; * Purpose : Convert SSTAT2 register to user-parsable phase representation&n; *&n; * Inputs : sstat - value of sstat register&n; */
r_static
r_const
r_char
op_star
DECL|function|sstat2_to_phase
id|sstat2_to_phase
(paren
r_int
id|sstat
)paren
(brace
r_switch
c_cond
(paren
id|sstat
op_amp
id|SSTAT2_PHASE_MASK
)paren
(brace
r_case
id|SSTAT2_PHASE_DATAIN
suffix:colon
r_return
l_string|&quot;DATAIN&quot;
suffix:semicolon
r_case
id|SSTAT2_PHASE_DATAOUT
suffix:colon
r_return
l_string|&quot;DATAOUT&quot;
suffix:semicolon
r_case
id|SSTAT2_PHASE_MSGIN
suffix:colon
r_return
l_string|&quot;MSGIN&quot;
suffix:semicolon
r_case
id|SSTAT2_PHASE_MSGOUT
suffix:colon
r_return
l_string|&quot;MSGOUT&quot;
suffix:semicolon
r_case
id|SSTAT2_PHASE_CMDOUT
suffix:colon
r_return
l_string|&quot;CMDOUT&quot;
suffix:semicolon
r_case
id|SSTAT2_PHASE_STATIN
suffix:colon
r_return
l_string|&quot;STATUSIN&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Function : static void intr_phase_mismatch (struct Scsi_Host *host, &n; *&t;struct NCR53c7x0_cmd *cmd)&n; *&n; * Purpose : Handle phase mismatch interrupts&n; *&n; * Inputs : host, cmd - host and NCR command causing the interrupt, cmd&n; * &t;may be NULL.&n; *&n; * Side effects : The abort_connected() routine is called or the NCR chip &n; *&t;is restarted, jumping to the command_complete entry point, or &n; *&t;patching the address and transfer count of the current instruction &n; *&t;and calling the msg_in entry point as appropriate.&n; */
r_static
r_void
DECL|function|intr_phase_mismatch
id|intr_phase_mismatch
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
id|u32
id|dbc_dcmd
comma
op_star
id|dsp
comma
op_star
id|dsp_next
suffix:semicolon
r_int
r_char
id|dcmd
comma
id|sbcl
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
id|residual
suffix:semicolon
r_enum
(brace
id|ACTION_ABORT
comma
id|ACTION_ABORT_PRINT
comma
id|ACTION_CONTINUE
)brace
id|action
op_assign
id|ACTION_ABORT_PRINT
suffix:semicolon
r_const
r_char
op_star
id|where
op_assign
l_int|NULL
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/*&n;     * Corrective action is based on where in the SCSI SCRIPT(tm) the error &n;     * occurred, as well as which SCSI phase we are currently in.&n;     */
id|dsp_next
op_assign
id|bus_to_virt
c_func
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DSP_REG
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;     * Fetch the current instruction, and remove the operands for easier &n;     * interpretation.&n;     */
id|dbc_dcmd
op_assign
id|NCR53c7x0_read32
c_func
(paren
id|DBC_REG
)paren
suffix:semicolon
id|dcmd
op_assign
(paren
id|dbc_dcmd
op_amp
l_int|0xff000000
)paren
op_rshift
l_int|24
suffix:semicolon
multiline_comment|/*&n;     * Like other processors, the NCR adjusts the instruction pointer before&n;     * instruction decode.  Set the DSP address back to what it should&n;     * be for this instruction based on its size (2 or 3 32 bit words).&n;     */
id|dsp
op_assign
id|dsp_next
op_minus
id|NCR53c7x0_insn_size
c_func
(paren
id|dcmd
)paren
suffix:semicolon
multiline_comment|/*&n;     * Read new SCSI phase from the SBCL lines.  Since all of our code uses &n;     * a WHEN conditional instead of an IF conditional, we don&squot;t need to &n;     * wait for a new REQ.&n;     */
id|sbcl
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SBCL_REG
)paren
op_amp
id|SBCL_PHASE_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
(brace
id|action
op_assign
id|ACTION_ABORT_PRINT
suffix:semicolon
id|where
op_assign
l_string|&quot;no current command&quot;
suffix:semicolon
multiline_comment|/*&n;     * The way my SCSI SCRIPTS(tm) are architected, recoverable phase&n;     * mismatches should only occur where we&squot;re doing a multi-byte  &n;     * BMI instruction.  Specifically, this means &n;     *&n;     *  - select messages (a SCSI-I target may ignore additional messages&n;     * &t;&t;after the IDENTIFY; any target may reject a SDTR or WDTR)&n;     *&n;     *  - command out (targets may send a message to signal an error &n;     * &t;&t;condition, or go into STATUSIN after they&squot;ve decided &n;     *&t;&t;they don&squot;t like the command.&n;     *&n;     *&t;- reply_message (targets may reject a multi-byte message in the &n;     *&t;&t;middle)&n;     *&n;     * &t;- data transfer routines (command completion with buffer space&n;     *&t;&t;left, disconnect message, or error message)&n;     */
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|dsp
op_ge
id|cmd-&gt;data_transfer_start
op_logical_and
id|dsp
OL
id|cmd-&gt;data_transfer_end
)paren
)paren
op_logical_or
id|dsp
op_eq
(paren
id|cmd-&gt;residual
op_plus
l_int|2
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|dcmd
op_amp
(paren
id|DCMD_TYPE_MASK
op_or
id|DCMD_BMI_OP_MASK
op_or
id|DCMD_BMI_INDIRECT
op_or
id|DCMD_BMI_MSG
op_or
id|DCMD_BMI_CD
)paren
)paren
op_eq
(paren
id|DCMD_TYPE_BMI
op_or
id|DCMD_BMI_OP_MOVE_I
)paren
)paren
(brace
id|residual
op_assign
id|datapath_residual
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_DISCONNECT
)paren
id|printk
(paren
l_string|&quot;scsi%d : handling residual transfer (+ %d bytes from DMA FIFO)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|residual
)paren
suffix:semicolon
multiline_comment|/*&n;&t;     * The first instruction is a CALL to the alternate handler for &n;&t;     * this data transfer phase, so we can do calls to &n;&t;     * munge_msg_restart as we would if control were passed &n;&t;     * from normal dynamic code.&n;&t;     */
r_if
c_cond
(paren
id|dsp
op_ne
id|cmd-&gt;residual
op_plus
l_int|2
)paren
(brace
id|cmd-&gt;residual
(braket
l_int|0
)braket
op_assign
id|le32_to_cpu
c_func
(paren
(paren
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_CALL
op_or
(paren
(paren
id|dcmd
op_amp
id|DCMD_BMI_IO
)paren
ques
c_cond
id|DCMD_TCI_IO
suffix:colon
l_int|0
)paren
)paren
op_lshift
l_int|24
)paren
op_or
id|DBC_TCI_WAIT_FOR_VALID
op_or
id|DBC_TCI_COMPARE_PHASE
)paren
suffix:semicolon
id|cmd-&gt;residual
(braket
l_int|1
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
id|hostdata-&gt;script
)paren
op_plus
(paren
(paren
id|dcmd
op_amp
id|DCMD_BMI_IO
)paren
ques
c_cond
id|hostdata-&gt;E_other_in
suffix:colon
id|hostdata-&gt;E_other_out
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;     * The second instruction is the a data transfer block&n;&t;     * move instruction, reflecting the pointer and count at the &n;&t;     * time of the phase mismatch.&n;&t;     */
id|cmd-&gt;residual
(braket
l_int|2
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|dbc_dcmd
op_plus
id|residual
)paren
suffix:semicolon
id|cmd-&gt;residual
(braket
l_int|3
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DNAD_REG
)paren
op_minus
id|residual
)paren
suffix:semicolon
multiline_comment|/*&n;&t;     * The third and final instruction is a jump to the instruction&n;&t;     * which follows the instruction which had to be &squot;split&squot;&n;&t;     */
r_if
c_cond
(paren
id|dsp
op_ne
id|cmd-&gt;residual
op_plus
l_int|2
)paren
(brace
id|cmd-&gt;residual
(braket
l_int|4
)braket
op_assign
id|le32_to_cpu
c_func
(paren
(paren
(paren
id|DCMD_TYPE_TCI
op_or
id|DCMD_TCI_OP_JUMP
)paren
op_lshift
l_int|24
)paren
op_or
id|DBC_TCI_TRUE
)paren
suffix:semicolon
id|cmd-&gt;residual
(braket
l_int|5
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|virt_to_bus
c_func
(paren
id|dsp_next
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;     * For the sake of simplicity, transfer control to the &n;&t;     * conditional CALL at the start of the residual buffer.&n;&t;     */
id|hostdata-&gt;dsp
op_assign
id|cmd-&gt;residual
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
id|action
op_assign
id|ACTION_CONTINUE
suffix:semicolon
)brace
r_else
(brace
id|where
op_assign
l_string|&quot;non-BMI dynamic DSA code&quot;
suffix:semicolon
id|action
op_assign
id|ACTION_ABORT_PRINT
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|dsp
op_eq
(paren
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_select_msgout
op_div
l_int|4
)paren
)paren
(brace
multiline_comment|/* Release ATN */
id|NCR53c7x0_write8
(paren
id|SOCL_REG
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sbcl
)paren
(brace
multiline_comment|/* &n;     * Some devices (SQ555 come to mind) grab the IDENTIFY message&n;     * sent on selection, and decide to go into COMMAND OUT phase&n;     * rather than accepting the rest of the messages or rejecting&n;     * them.  Handle these devices gracefully.&n;     */
r_case
id|SBCL_PHASE_CMDOUT
suffix:colon
id|hostdata-&gt;dsp
op_assign
id|dsp
op_plus
l_int|2
multiline_comment|/* two _words_ */
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : target %d ignored SDTR and went into COMMAND OUT&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;cmd-&gt;target
)paren
suffix:semicolon
id|cmd-&gt;flags
op_and_assign
op_complement
id|CMD_FLAG_SDTR
suffix:semicolon
id|action
op_assign
id|ACTION_CONTINUE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBCL_PHASE_MSGIN
suffix:colon
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_msg_in
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
id|action
op_assign
id|ACTION_CONTINUE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|where
op_assign
l_string|&quot;select message out&quot;
suffix:semicolon
id|action
op_assign
id|ACTION_ABORT_PRINT
suffix:semicolon
)brace
multiline_comment|/*&n;     * Some SCSI devices will interpret a command as they read the bytes&n;     * off the SCSI bus, and may decide that the command is Bogus before &n;     * they&squot;ve read the entire command off the bus.&n;     */
)brace
r_else
r_if
c_cond
(paren
id|dsp
op_eq
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_cmdout_cmdout
op_div
r_sizeof
(paren
id|u32
)paren
)paren
(brace
id|hostdata-&gt;dsp
op_assign
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_data_transfer
op_div
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
id|hostdata-&gt;dsp_changed
op_assign
l_int|1
suffix:semicolon
id|action
op_assign
id|ACTION_CONTINUE
suffix:semicolon
multiline_comment|/* FIXME : we need to handle message reject, etc. within msg_respond. */
macro_line|#ifdef notyet
)brace
r_else
r_if
c_cond
(paren
id|dsp
op_eq
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_reply_message
)paren
(brace
r_switch
c_cond
(paren
id|sbcl
)paren
(brace
multiline_comment|/* Any other phase mismatches abort the currently executing command.  */
macro_line|#endif
)brace
r_else
(brace
id|where
op_assign
l_string|&quot;unknown location&quot;
suffix:semicolon
id|action
op_assign
id|ACTION_ABORT_PRINT
suffix:semicolon
)brace
multiline_comment|/* Flush DMA FIFO */
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;dstat_valid
)paren
(brace
id|hostdata-&gt;dstat
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|DSTAT_REG
)paren
suffix:semicolon
id|hostdata-&gt;dstat_valid
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;dstat
op_amp
id|DSTAT_DFE
)paren
)paren
(brace
r_if
c_cond
(paren
id|NCR53c7x0_read8
(paren
id|CTEST2_REG_800
)paren
op_amp
id|CTEST2_800_DDIR
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d: Flushing DMA FIFO&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|NCR53c7x0_write8
(paren
id|CTEST3_REG_800
comma
id|CTEST3_800_FLF
)paren
suffix:semicolon
multiline_comment|/* FIXME : what about stacked DMA interrupts? */
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|hostdata-&gt;dstat
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|DSTAT_REG
)paren
)paren
op_amp
id|DSTAT_DFE
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|NCR53c7x0_write8
(paren
id|CTEST3_REG_800
comma
id|CTEST3_800_CLF
)paren
suffix:semicolon
r_while
c_loop
(paren
id|NCR53c7x0_read8
(paren
id|CTEST3_REG_800
)paren
op_amp
id|CTEST3_800_CLF
)paren
suffix:semicolon
)brace
id|hostdata-&gt;dstat
op_or_assign
id|DSTAT_DFE
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|ACTION_ABORT_PRINT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : %s : unexpected phase %s.&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|where
ques
c_cond
id|where
suffix:colon
l_string|&quot;unknown location&quot;
comma
id|sbcl_to_phase
c_func
(paren
id|sbcl
)paren
)paren
suffix:semicolon
id|print_lots
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* Fall through to ACTION_ABORT */
r_case
id|ACTION_ABORT
suffix:colon
id|abort_connected
(paren
id|host
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACTION_CONTINUE
suffix:colon
r_break
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|hostdata-&gt;dsp_changed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: new dsp 0x%p&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|hostdata-&gt;dsp
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|hostdata-&gt;dsp
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * Function : static void intr_bf (struct Scsi_Host *host, &n; * &t;struct NCR53c7x0_cmd *cmd)&n; *&n; * Purpose : handle BUS FAULT interrupts &n; *&n; * Inputs : host, cmd - host and NCR command causing the interrupt, cmd&n; * &t;may be NULL.&n; */
r_static
r_void
DECL|function|intr_bf
id|intr_bf
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|u32
op_star
id|dsp
comma
op_star
id|next_dsp
comma
multiline_comment|/* Current dsp */
op_star
id|dsa
comma
id|dbc_dcmd
suffix:semicolon
multiline_comment|/* DCMD (high eight bits) + DBC */
r_int
r_int
id|pci_status
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|reason
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Default behavior is for a silent error, with a retry until we&squot;ve&n;       exhausted retries. */
r_enum
(brace
id|MAYBE
comma
id|ALWAYS
comma
id|NEVER
)brace
id|retry
op_assign
id|MAYBE
suffix:semicolon
r_int
id|report
op_assign
l_int|0
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
id|dbc_dcmd
op_assign
id|NCR53c7x0_read32
(paren
id|DBC_REG
)paren
suffix:semicolon
id|next_dsp
op_assign
id|bus_to_virt
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DSP_REG
)paren
)paren
suffix:semicolon
id|dsp
op_assign
id|next_dsp
op_minus
id|NCR53c7x0_insn_size
(paren
(paren
id|dbc_dcmd
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* FIXME - check chip type  */
id|dsa
op_assign
id|bus_to_virt
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DSA_REG
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * Bus faults can be caused by either a Bad Address or &n;     * Target Abort. We should check the Received Target Abort&n;     * bit of the PCI status register and Master Abort Bit.&n;     *&n;     * &t;- Master Abort bit indicates that no device claimed&n;     *&t;&t;the address with DEVSEL within five clocks&n;     *&n;     *&t;- Target Abort bit indicates that a target claimed it,&n;     *&t;&t;but changed its mind once it saw the byte enables.&n;     *&n;     */
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
(brace
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|tmp
op_assign
id|pcibios_read_config_word
(paren
id|hostdata-&gt;pci_bus
comma
id|hostdata-&gt;pci_device_fn
comma
id|PCI_STATUS
comma
op_amp
id|pci_status
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
id|PCIBIOS_SUCCESSFUL
)paren
(brace
r_if
c_cond
(paren
id|pci_status
op_amp
id|PCI_STATUS_REC_TARGET_ABORT
)paren
(brace
id|reason
op_assign
l_string|&quot;PCI target abort&quot;
suffix:semicolon
id|pci_status
op_and_assign
op_complement
id|PCI_STATUS_REC_TARGET_ABORT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pci_status
op_amp
id|PCI_STATUS_REC_MASTER_ABORT
)paren
(brace
id|reason
op_assign
l_string|&quot;No device asserted PCI DEVSEL within five bus clocks&quot;
suffix:semicolon
id|pci_status
op_and_assign
op_complement
id|PCI_STATUS_REC_MASTER_ABORT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pci_status
op_amp
id|PCI_STATUS_PARITY
)paren
(brace
id|report
op_assign
l_int|1
suffix:semicolon
id|pci_status
op_and_assign
op_complement
id|PCI_STATUS_PARITY
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;scsi%d : couldn&squot;t read status register : error %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|tmp
)paren
suffix:semicolon
id|retry
op_assign
id|NEVER
suffix:semicolon
)brace
)brace
macro_line|#ifndef notyet
id|report
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|report
op_logical_and
id|reason
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;scsi%d : BUS FAULT reason = %s&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|reason
ques
c_cond
id|reason
suffix:colon
l_string|&quot;unknown&quot;
)paren
suffix:semicolon
id|print_lots
(paren
id|host
)paren
suffix:semicolon
)brace
macro_line|#ifndef notyet
id|retry
op_assign
id|NEVER
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;     * TODO : we should attempt to recover from any spurious bus &n;     * faults.  After X retries, we should figure that things are &n;     * sufficiently wedged, and call NCR53c7xx_reset.&n;     *&n;     * This code should only get executed once we&squot;ve decided that we &n;     * cannot retry.&n;     */
r_if
c_cond
(paren
id|retry
op_eq
id|NEVER
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;          mail drew@PoohSticks.ORG&bslash;n&quot;
)paren
suffix:semicolon
id|FATAL
(paren
id|host
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function : static void intr_dma (struct Scsi_Host *host, &n; * &t;struct NCR53c7x0_cmd *cmd)&n; *&n; * Purpose : handle all DMA interrupts, indicated by the setting &n; * &t;of the DIP bit in the ISTAT register.&n; *&n; * Inputs : host, cmd - host and NCR command causing the interrupt, cmd&n; * &t;may be NULL.&n; */
r_static
r_void
DECL|function|intr_dma
id|intr_dma
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
r_char
id|dstat
suffix:semicolon
multiline_comment|/* DSTAT */
id|u32
op_star
id|dsp
comma
op_star
id|next_dsp
comma
multiline_comment|/* Current dsp */
op_star
id|dsa
comma
id|dbc_dcmd
suffix:semicolon
multiline_comment|/* DCMD (high eight bits) + DBC */
r_int
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;dstat_valid
)paren
(brace
id|hostdata-&gt;dstat
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|DSTAT_REG
)paren
suffix:semicolon
id|hostdata-&gt;dstat_valid
op_assign
l_int|1
suffix:semicolon
)brace
id|dstat
op_assign
id|hostdata-&gt;dstat
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : DSTAT=0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
(paren
r_int
)paren
id|dstat
)paren
suffix:semicolon
id|dbc_dcmd
op_assign
id|NCR53c7x0_read32
(paren
id|DBC_REG
)paren
suffix:semicolon
id|next_dsp
op_assign
id|bus_to_virt
c_func
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DSP_REG
)paren
)paren
suffix:semicolon
id|dsp
op_assign
id|next_dsp
op_minus
id|NCR53c7x0_insn_size
(paren
(paren
id|dbc_dcmd
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* XXX - check chip type */
id|dsa
op_assign
id|bus_to_virt
c_func
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DSA_REG
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * DSTAT_ABRT is the aborted interrupt.  This is set whenever the &n;     * SCSI chip is aborted.  &n;     * &n;     * With NCR53c700 and NCR53c700-66 style chips, we should only &n;     * get this when the chip is currently running the accept &n;     * reselect/select code and we have set the abort bit in the &n;     * ISTAT register.&n;     *&n;     */
r_if
c_cond
(paren
id|dstat
op_amp
id|DSTAT_ABRT
)paren
(brace
macro_line|#if 0
multiline_comment|/* XXX - add code here to deal with normal abort */
r_if
c_cond
(paren
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_700
)paren
op_logical_and
(paren
id|hostdata-&gt;state
op_eq
id|STATE_ABORTING
)paren
)paren
(brace
)brace
r_else
macro_line|#endif
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;scsi%d : unexpected abort interrupt at&bslash;n&quot;
l_string|&quot;         &quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|dsp
comma
id|KERN_ALERT
l_string|&quot;s &quot;
comma
l_int|1
)paren
suffix:semicolon
id|FATAL
(paren
id|host
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * DSTAT_SSI is the single step interrupt.  Should be generated &n;     * whenever we have single stepped or are tracing.&n;     */
r_if
c_cond
(paren
id|dstat
op_amp
id|DSTAT_SSI
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_TRACE
)paren
(brace
)brace
r_else
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_SINGLE
)paren
(brace
id|print_insn
(paren
id|host
comma
id|dsp
comma
l_string|&quot;s &quot;
comma
l_int|0
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* XXX - should we do this, or can we get away with writing dsp? */
id|NCR53c7x0_write8
(paren
id|DCNTL_REG
comma
(paren
id|NCR53c7x0_read8
c_func
(paren
id|DCNTL_REG
)paren
op_amp
op_complement
id|DCNTL_SSM
)paren
op_or
id|DCNTL_STD
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;scsi%d : unexpected single step interrupt at&bslash;n&quot;
l_string|&quot;         &quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|dsp
comma
id|KERN_ALERT
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;         mail drew@PoohSticks.ORG&bslash;n&quot;
)paren
suffix:semicolon
id|FATAL
(paren
id|host
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * DSTAT_IID / DSTAT_OPC (same bit, same meaning, only the name &n;     * is different) is generated whenever an illegal instruction is &n;     * encountered.  &n;     * &n;     * XXX - we may want to emulate INTFLY here, so we can use &n;     *    the same SCSI SCRIPT (tm) for NCR53c710 through NCR53c810  &n;     *&t;  chips.&n;     */
r_if
c_cond
(paren
id|dstat
op_amp
id|DSTAT_OPC
)paren
(brace
multiline_comment|/* &n;     * Ascertain if this IID interrupts occurred before or after a STO &n;     * interrupt.  Since the interrupt handling code now leaves &n;     * DSP unmodified until _after_ all stacked interrupts have been&n;     * processed, reading the DSP returns the original DSP register.&n;     * This means that if dsp lies between the select code, and &n;     * message out following the selection code (where the IID interrupt&n;     * would have to have occurred by due to the implicit wait for REQ),&n;     * we have an IID interrupt resulting from a STO condition and &n;     * can ignore it.&n;     */
r_if
c_cond
(paren
(paren
(paren
id|dsp
op_ge
(paren
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_select
op_div
r_sizeof
(paren
id|u32
)paren
)paren
)paren
op_logical_and
(paren
id|dsp
op_le
(paren
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_select_msgout
op_div
r_sizeof
(paren
id|u32
)paren
op_plus
l_int|8
)paren
)paren
)paren
op_logical_or
(paren
id|hostdata-&gt;test_running
op_eq
l_int|2
)paren
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : ignoring DSTAT_IID for SSTAT_STO&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;expecting_iid
)paren
(brace
id|hostdata-&gt;expecting_iid
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;idle
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;test_running
op_eq
l_int|2
)paren
(brace
id|hostdata-&gt;test_running
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;test_completed
op_assign
l_int|3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd
)paren
id|abnormal_finished
(paren
id|cmd
comma
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
r_else
(brace
id|hostdata-&gt;expecting_sto
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;     * We can&squot;t guarantee we&squot;ll be able to execute the WAIT DISCONNECT&n;     * instruction within the 3.4us of bus free and arbitration delay&n;     * that a target can RESELECT in and assert REQ after we&squot;ve dropped&n;     * ACK.  If this happens, we&squot;ll get an illegal instruction interrupt.&n;     * Doing away with the WAIT DISCONNECT instructions broke everything,&n;     * so instead I&squot;ll settle for moving one WAIT DISCONNECT a few &n;     * instructions closer to the CLEAR ACK before it to minimize the&n;     * chances of this happening, and handle it if it occurs anyway.&n;     *&n;     * Simply continue with what we were doing, and control should&n;     * be transfered to the schedule routine which will ultimately&n;     * pass control onto the reselection or selection (not yet)&n;     * code.&n;     */
)brace
r_else
r_if
c_cond
(paren
id|dbc_dcmd
op_eq
l_int|0x48000000
op_logical_and
(paren
id|NCR53c7x0_read8
(paren
id|SBCL_REG
)paren
op_amp
id|SBCL_REQ
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_NO_PRINT_RACE
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: REQ before WAIT DISCONNECT IID&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|hostdata-&gt;options
op_or_assign
id|OPTION_NO_PRINT_RACE
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;scsi%d : illegal instruction&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_lots
(paren
id|host
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;         mail drew@PoohSticks.ORG with ALL&bslash;n&quot;
l_string|&quot;         boot messages and diagnostic output&bslash;n&quot;
)paren
suffix:semicolon
id|FATAL
(paren
id|host
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;     * DSTAT_BF are bus fault errors&n;     */
r_if
c_cond
(paren
id|dstat
op_amp
id|DSTAT_800_BF
)paren
(brace
id|intr_bf
(paren
id|host
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;     * DSTAT_SIR interrupts are generated by the execution of &n;     * the INT instruction.  Since the exact values available &n;     * are determined entirely by the SCSI script running, &n;     * and are local to a particular script, a unique handler&n;     * is called for each script.&n;     */
r_if
c_cond
(paren
id|dstat
op_amp
id|DSTAT_SIR
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;options
op_amp
id|OPTION_DEBUG_INTR
)paren
id|printk
(paren
l_string|&quot;scsi%d : DSTAT_SIR&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|tmp
op_assign
id|hostdata-&gt;dstat_sir_intr
(paren
id|host
comma
id|cmd
)paren
)paren
)paren
(brace
r_case
id|SPECIFIC_INT_NOTHING
suffix:colon
r_case
id|SPECIFIC_INT_RESTART
suffix:colon
r_break
suffix:semicolon
r_case
id|SPECIFIC_INT_ABORT
suffix:colon
id|abort_connected
c_func
(paren
id|host
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SPECIFIC_INT_PANIC
suffix:colon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;scsi%d : failure at &quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|dsp
comma
id|KERN_ALERT
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;          dstat_sir_intr() returned SPECIFIC_INT_PANIC&bslash;n&quot;
)paren
suffix:semicolon
id|FATAL
(paren
id|host
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SPECIFIC_INT_BREAK
suffix:colon
id|intr_break
(paren
id|host
comma
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;scsi%d : failure at &quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|print_insn
(paren
id|host
comma
id|dsp
comma
id|KERN_ALERT
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;          dstat_sir_intr() returned unknown value %d&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
id|FATAL
(paren
id|host
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
op_logical_and
(paren
id|dstat
op_amp
id|DSTAT_800_MDPE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;scsi%d : Master Data Parity Error&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|FATAL
(paren
id|host
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function : static int print_insn (struct Scsi_Host *host, &n; * &t;u32 *insn, int kernel)&n; *&n; * Purpose : print numeric representation of the instruction pointed&n; * &t;to by insn to the debugging or kernel message buffer&n; *&t;as appropriate.  &n; *&n; * &t;If desired, a user level program can interpret this &n; * &t;information.&n; *&n; * Inputs : host, insn - host, pointer to instruction, prefix - &n; *&t;string to prepend, kernel - use printk instead of debugging buffer.&n; *&n; * Returns : size, in u32s, of instruction printed.&n; */
multiline_comment|/*&n; * FIXME: should change kernel parameter so that it takes an ENUM&n; * &t;specifying severity - either KERN_ALERT or KERN_PANIC so&n; *&t;all panic messages are output with the same severity.&n; */
r_static
r_int
DECL|function|print_insn
id|print_insn
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_const
id|u32
op_star
id|insn
comma
r_const
r_char
op_star
id|prefix
comma
r_int
id|kernel
)paren
(brace
r_char
id|buf
(braket
l_int|160
)braket
comma
multiline_comment|/* Temporary buffer and pointer.  ICKY &n;&t;&t;&t;&t;   arbitrary length.  */
op_star
id|tmp
suffix:semicolon
r_int
r_char
id|dcmd
suffix:semicolon
multiline_comment|/* dcmd register for *insn */
r_int
id|size
suffix:semicolon
multiline_comment|/* &n;     * Check to see if the instruction pointer is not bogus before &n;     * indirecting through it; avoiding red-zone at start of &n;     * memory.&n;     *&n;     * FIXME: icky magic needs to happen here on non-intel boxes which&n;     * don&squot;t have kernel memory mapped in like this.  Might be reasonable&n;     * to use vverify()?&n;     */
r_if
c_cond
(paren
id|virt_to_phys
c_func
(paren
(paren
r_void
op_star
)paren
id|insn
)paren
template_param
id|virt_to_phys
c_func
(paren
id|high_memory
)paren
op_logical_or
(paren
(paren
(paren
(paren
id|dcmd
op_assign
(paren
id|insn
(braket
l_int|0
)braket
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
)paren
op_amp
id|DCMD_TYPE_MMI
)paren
op_eq
id|DCMD_TYPE_MMI
)paren
op_logical_and
id|virt_to_phys
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|insn
op_plus
l_int|12
)paren
)paren
OG
id|virt_to_phys
c_func
(paren
id|high_memory
)paren
)paren
)paren
(brace
id|size
op_assign
l_int|0
suffix:semicolon
id|sprintf
(paren
id|buf
comma
l_string|&quot;%s%p: address out of range&bslash;n&quot;
comma
id|prefix
comma
id|insn
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &n; * FIXME : (void *) cast in virt_to_bus should be unnecessary, because&n; * &t;it should take const void * as argument.&n; */
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s0x%lx (virt 0x%p) : 0x%08x 0x%08x (virt 0x%p)&quot;
comma
(paren
id|prefix
ques
c_cond
id|prefix
suffix:colon
l_string|&quot;&quot;
)paren
comma
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
id|insn
)paren
comma
id|insn
comma
id|insn
(braket
l_int|0
)braket
comma
id|insn
(braket
l_int|1
)braket
comma
id|bus_to_virt
(paren
id|le32_to_cpu
c_func
(paren
id|insn
(braket
l_int|1
)braket
)paren
)paren
)paren
suffix:semicolon
id|tmp
op_assign
id|buf
op_plus
id|strlen
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dcmd
op_amp
id|DCMD_TYPE_MASK
)paren
op_eq
id|DCMD_TYPE_MMI
)paren
(brace
id|sprintf
(paren
id|tmp
comma
l_string|&quot; 0x%08x (virt 0x%p)&bslash;n&quot;
comma
id|insn
(braket
l_int|2
)braket
comma
id|bus_to_virt
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|insn
(braket
l_int|2
)braket
)paren
)paren
)paren
suffix:semicolon
id|size
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|sprintf
(paren
id|tmp
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|size
op_assign
l_int|2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|kernel
)paren
id|printk
(paren
l_string|&quot;%s&quot;
comma
id|buf
)paren
suffix:semicolon
macro_line|#ifdef NCR_DEBUG
r_else
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|buf
)paren
suffix:semicolon
id|debugger_kernel_write
c_func
(paren
id|host
comma
id|buf
comma
id|len
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : static const char *ncr_state (int state)&n; *&n; * Purpose : convert state (probably from hostdata-&gt;state) to a string&n; *&n; * Inputs : state&n; *&n; * Returns : char * representation of state, &quot;unknown&quot; on error.&n; */
macro_line|#if 0
r_static
r_const
r_char
op_star
DECL|function|ncr_state
id|ncr_state
(paren
r_int
id|state
)paren
(brace
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|STATE_HALTED
suffix:colon
r_return
l_string|&quot;halted&quot;
suffix:semicolon
r_case
id|STATE_WAITING
suffix:colon
r_return
l_string|&quot;waiting&quot;
suffix:semicolon
r_case
id|STATE_RUNNING
suffix:colon
r_return
l_string|&quot;running&quot;
suffix:semicolon
r_case
id|STATE_ABORTING
suffix:colon
r_return
l_string|&quot;aborting&quot;
suffix:semicolon
r_case
id|STATE_DISABLED
suffix:colon
r_return
l_string|&quot;disabled&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n; * Function : int NCR53c7xx_abort (Scsi_Cmnd *cmd)&n; * &n; * Purpose : Abort an errant SCSI command, doing all necessary&n; *&t;cleanup of the issue_queue, running_list, shared Linux/NCR&n; *&t;dsa issue and reconnect queues.&n; *&n; * Inputs : cmd - command to abort, code - entire result field&n; *&n; * Returns : 0 on success, -1 on failure.&n; */
r_int
DECL|function|NCR53c7xx_abort
id|NCR53c7xx_abort
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;host
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
id|host
ques
c_cond
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:colon
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|result
suffix:semicolon
r_struct
id|NCR53c7x0_cmd
op_star
id|curr
comma
op_star
op_star
id|prev
suffix:semicolon
id|Scsi_Cmnd
op_star
id|me
comma
op_star
op_star
id|last
suffix:semicolon
macro_line|#if 0
r_static
r_int
id|cache_pid
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
(brace
id|printk
(paren
l_string|&quot;Bogus SCSI command pid %ld; no host structure&bslash;n&quot;
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_ERROR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|hostdata
)paren
(brace
id|printk
(paren
l_string|&quot;Bogus SCSI host %d; no hostdata&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_ERROR
suffix:semicolon
)brace
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/*&n; * CHECK : I don&squot;t think that reading ISTAT will unstack any interrupts,&n; *&t;since we need to write the INTF bit to clear it, and SCSI/DMA&n; * &t;interrupts don&squot;t clear until we read SSTAT/SIST and DSTAT registers.&n; *&t;&n; *&t;See that this is the case.&n; *&n; * I suspect that several of our failures may be coming from a new fatal&n; * interrupt (possibly due to a phase mismatch) happening after we&squot;ve left&n; * the interrupt handler, but before the PIC has had the interrupt condition&n; * cleared.&n; */
r_if
c_cond
(paren
id|NCR53c7x0_read8
c_func
(paren
id|hostdata-&gt;istat
)paren
op_amp
(paren
id|ISTAT_DIP
op_or
id|ISTAT_SIP
op_or
(paren
id|hostdata-&gt;chip
op_div
l_int|100
op_eq
l_int|8
ques
c_cond
id|ISTAT_800_INTF
suffix:colon
l_int|0
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : dropped interrupt for command %ld&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
id|NCR53c7x0_intr
(paren
id|host-&gt;irq
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_BUSY
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|cache_pid
op_eq
id|cmd-&gt;pid
)paren
id|panic
(paren
l_string|&quot;scsi%d : bloody fetus %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
r_else
id|cache_pid
op_assign
id|cmd-&gt;pid
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * The command could be hiding in the issue_queue.  This would be very&n; * nice, as commands can&squot;t be moved from the high level driver&squot;s issue queue &n; * into the shared queue until an interrupt routine is serviced, and this&n; * moving is atomic.  &n; *&n; * If this is the case, we don&squot;t have to worry about anything - we simply&n; * pull the command out of the old queue, and call it aborted.&n; */
r_for
c_loop
(paren
id|me
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
comma
id|last
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
id|hostdata-&gt;issue_queue
)paren
suffix:semicolon
id|me
op_logical_and
id|me
op_ne
id|cmd
suffix:semicolon
id|last
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
id|me-&gt;SCp.ptr
)paren
comma
id|me
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|me-&gt;SCp.ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|me
)paren
(brace
op_star
id|last
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|me-&gt;SCp.ptr
suffix:semicolon
r_if
c_cond
(paren
id|me-&gt;host_scribble
)paren
(brace
(paren
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|me-&gt;host_scribble
)paren
op_member_access_from_pointer
id|next
op_assign
id|hostdata-&gt;free
suffix:semicolon
id|hostdata-&gt;free
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|me-&gt;host_scribble
suffix:semicolon
id|me-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
)brace
id|cmd-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : found command %ld in Linux issue queue&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|me-&gt;pid
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|run_process_issue_queue
c_func
(paren
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
multiline_comment|/* &n; * That failing, the command could be in our list of already executing &n; * commands.  If this is the case, drastic measures are called for.  &n; */
r_for
c_loop
(paren
id|curr
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|hostdata-&gt;running_list
comma
id|prev
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
op_star
)paren
op_amp
(paren
id|hostdata-&gt;running_list
)paren
suffix:semicolon
id|curr
op_logical_and
id|curr-&gt;cmd
op_ne
id|cmd
suffix:semicolon
id|prev
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
op_star
)paren
op_amp
(paren
id|curr-&gt;next
)paren
comma
id|curr
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|curr-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curr
)paren
(brace
id|result
op_assign
id|le32_to_cpu
c_func
(paren
id|cmd-&gt;result
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_amp
l_int|0xff
)paren
op_ne
l_int|0xff
op_logical_and
(paren
id|result
op_amp
l_int|0xff00
)paren
op_ne
l_int|0xff00
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
op_star
id|prev
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|curr-&gt;next
suffix:semicolon
id|curr-&gt;next
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|hostdata-&gt;free
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;free
op_assign
id|curr
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : found finished command %ld in running list&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;scsi%d : DANGER : command running, can not abort.&bslash;n&quot;
comma
id|cmd-&gt;host-&gt;host_no
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_BUSY
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * And if we couldn&squot;t find it in any of our queues, it must have been &n; * a dropped interrupt.&n; */
id|curr
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
r_if
c_cond
(paren
id|curr
)paren
(brace
id|curr-&gt;next
op_assign
id|hostdata-&gt;free
suffix:semicolon
id|hostdata-&gt;free
op_assign
id|curr
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
)brace
id|result
op_assign
id|le32_to_cpu
c_func
(paren
id|cmd-&gt;result
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|result
op_amp
l_int|0xff00
)paren
op_eq
l_int|0xff00
)paren
op_logical_or
(paren
(paren
id|result
op_amp
l_int|0xff
)paren
op_eq
l_int|0xff
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : did this command ever run?&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;scsi%d : probably lost INTFLY, normal completion&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
multiline_comment|/* &n; * FIXME : We need to add an additional flag which indicates if a &n; * command was ever counted as BUSY, so if we end up here we can&n; * decrement the busy count if and only if it is necessary.&n; */
op_decrement
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
(braket
id|cmd-&gt;lun
)braket
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/* &n; * We need to run process_issue_queue since termination of this command &n; * may allow another queued command to execute first? &n; */
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : int NCR53c7xx_reset (Scsi_Cmnd *cmd) &n; * &n; * Purpose : perform a hard reset of the SCSI bus and NCR&n; * &t;chip.&n; *&n; * Inputs : cmd - command which caused the SCSI RESET&n; *&n; * Returns : 0 on success.&n; */
r_int
DECL|function|NCR53c7xx_reset
id|NCR53c7xx_reset
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_int
id|reset_flags
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_struct
id|NCR53c7x0_cmd
op_star
id|c
suffix:semicolon
id|Scsi_Cmnd
op_star
id|tmp
suffix:semicolon
multiline_comment|/*&n;     * When we call scsi_done(), it&squot;s going to wake up anything sleeping on the&n;     * resources which were in use by the aborted commands, and we&squot;ll start to &n;     * get new commands.&n;     *&n;     * We can&squot;t let this happen until after we&squot;ve re-initialized the driver&n;     * structures, and can&squot;t reinitialize those structures until after we&squot;ve &n;     * dealt with their contents.&n;     *&n;     * So, we need to find all of the commands which were running, stick&n;     * them on a linked list of completed commands (we&squot;ll use the host_scribble&n;     * pointer), do our reinitialization, and then call the done function for&n;     * each command.  &n;     */
id|Scsi_Cmnd
op_star
id|nuke_list
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;host
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ncr_halt
(paren
id|host
)paren
suffix:semicolon
id|print_lots
(paren
id|host
)paren
suffix:semicolon
id|dump_events
(paren
id|host
comma
l_int|30
)paren
suffix:semicolon
id|ncr_scsi_reset
(paren
id|host
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|nuke_list
op_assign
id|return_outstanding_commands
(paren
id|host
comma
l_int|1
multiline_comment|/* free */
comma
l_int|0
multiline_comment|/* issue */
)paren
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;SCp.buffer
)paren
r_if
c_cond
(paren
id|tmp
op_eq
id|cmd
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* &n;     * If we didn&squot;t find the command which caused this reset in our running&n;     * list, then we&squot;ve lost it.  See that it terminates normally anyway.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|c
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
(brace
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;next
op_assign
id|hostdata-&gt;free
suffix:semicolon
id|hostdata-&gt;free
op_assign
id|c
suffix:semicolon
)brace
r_else
id|printk
(paren
l_string|&quot;scsi%d: lost command %ld&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
id|cmd-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|nuke_list
suffix:semicolon
id|nuke_list
op_assign
id|cmd
suffix:semicolon
)brace
id|NCR53c7x0_driver_init
(paren
id|host
)paren
suffix:semicolon
id|hostdata-&gt;soft_reset
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;resets
op_eq
l_int|0
)paren
id|disable
c_func
(paren
id|host
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hostdata-&gt;resets
op_ne
op_minus
l_int|1
)paren
op_decrement
id|hostdata-&gt;resets
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|nuke_list
suffix:semicolon
id|nuke_list
op_assign
id|tmp
)paren
(brace
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|nuke_list-&gt;SCp.buffer
suffix:semicolon
id|nuke_list-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|nuke_list-&gt;scsi_done
(paren
id|nuke_list
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_RESET_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * The NCR SDMS bios follows Annex A of the SCSI-CAM draft, and &n; * therefore shares the scsicam_bios_param function.&n; */
multiline_comment|/*&n; * Function : int insn_to_offset (Scsi_Cmnd *cmd, u32 *insn)&n; *&n; * Purpose : convert instructions stored at NCR pointer into data &n; *&t;pointer offset.&n; * &n; * Inputs : cmd - SCSI command; insn - pointer to instruction.  Either current&n; *&t;DSP, or saved data pointer.&n; *&n; * Returns : offset on success, -1 on failure.&n; */
r_static
r_int
DECL|function|insn_to_offset
id|insn_to_offset
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
id|u32
op_star
id|insn
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
r_struct
id|NCR53c7x0_cmd
op_star
id|ncmd
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
r_int
id|offset
op_assign
l_int|0
comma
id|buffers
suffix:semicolon
r_struct
id|scatterlist
op_star
id|segment
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * With the current code implementation, if the insn is inside dynamically &n; * generated code, the data pointer will be the instruction preceding &n; * the next transfer segment.&n; */
r_if
c_cond
(paren
op_logical_neg
id|check_address
(paren
(paren
r_int
r_int
)paren
id|ncmd
comma
r_sizeof
(paren
r_struct
id|NCR53c7x0_cmd
)paren
)paren
op_logical_and
(paren
(paren
id|insn
op_ge
id|ncmd-&gt;data_transfer_start
op_logical_and
id|insn
OL
id|ncmd-&gt;data_transfer_end
)paren
op_logical_or
(paren
id|insn
op_ge
id|ncmd-&gt;residual
op_logical_and
id|insn
OL
(paren
id|ncmd-&gt;residual
op_plus
r_sizeof
(paren
id|ncmd-&gt;residual
)paren
)paren
)paren
)paren
)paren
(brace
id|ptr
op_assign
id|bus_to_virt
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|insn
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|buffers
op_assign
id|cmd-&gt;use_sg
)paren
)paren
(brace
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
comma
id|segment
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
id|buffers
op_logical_and
op_logical_neg
(paren
(paren
id|found
op_assign
(paren
(paren
id|ptr
op_ge
id|segment-&gt;address
)paren
op_logical_and
(paren
id|ptr
OL
(paren
id|segment-&gt;address
op_plus
id|segment-&gt;length
)paren
)paren
)paren
)paren
)paren
suffix:semicolon
op_decrement
id|buffers
comma
id|offset
op_add_assign
id|segment-&gt;length
comma
op_increment
id|segment
)paren
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;scsi%d: comparing 0x%p to 0x%p&bslash;n&quot;
comma
id|cmd-&gt;host-&gt;host_no
comma
id|saved
comma
id|segment-&gt;address
)paren
suffix:semicolon
macro_line|#else
suffix:semicolon
macro_line|#endif
id|offset
op_add_assign
id|ptr
op_minus
id|segment-&gt;address
suffix:semicolon
)brace
r_else
(brace
id|found
op_assign
l_int|1
suffix:semicolon
id|offset
op_assign
id|ptr
op_minus
(paren
r_char
op_star
)paren
(paren
id|cmd-&gt;request_buffer
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|insn
op_ge
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_data_transfer
op_div
r_sizeof
(paren
id|u32
)paren
)paren
op_logical_and
(paren
id|insn
op_le
id|hostdata-&gt;script
op_plus
id|hostdata-&gt;E_end_data_transfer
op_div
r_sizeof
(paren
id|u32
)paren
)paren
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|found
ques
c_cond
id|offset
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : void print_progress (Scsi_Cmnd *cmd) &n; * &n; * Purpose : print the current location of the saved data pointer&n; *&n; * Inputs : cmd - command we are interested in&n; *&n; */
r_static
r_void
DECL|function|print_progress
id|print_progress
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_cmd
op_star
id|ncmd
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
r_int
id|offset
comma
id|i
suffix:semicolon
r_char
op_star
id|where
suffix:semicolon
id|u32
op_star
id|ptr
suffix:semicolon
id|NCR53c7x0_local_setup
(paren
id|cmd-&gt;host
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|check_address
(paren
(paren
r_int
r_int
)paren
id|ncmd
comma
r_sizeof
(paren
r_struct
id|NCR53c7x0_cmd
)paren
)paren
op_eq
op_minus
l_int|1
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|where
op_assign
l_string|&quot;saved&quot;
suffix:semicolon
id|ptr
op_assign
id|bus_to_virt
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|ncmd-&gt;saved_data_pointer
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|where
op_assign
l_string|&quot;active&quot;
suffix:semicolon
id|ptr
op_assign
id|bus_to_virt
(paren
id|NCR53c7x0_read32
(paren
id|DSP_REG
)paren
op_minus
id|NCR53c7x0_insn_size
(paren
id|NCR53c7x0_read8
(paren
id|DCMD_REG
)paren
)paren
op_star
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
)brace
id|offset
op_assign
id|insn_to_offset
(paren
id|cmd
comma
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ne
op_minus
l_int|1
)paren
id|printk
(paren
l_string|&quot;scsi%d : %s data pointer at offset %d&bslash;n&quot;
comma
id|cmd-&gt;host-&gt;host_no
comma
id|where
comma
id|offset
)paren
suffix:semicolon
r_else
(brace
r_int
id|size
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : can&squot;t determine %s data pointer offset&bslash;n&quot;
comma
id|cmd-&gt;host-&gt;host_no
comma
id|where
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ncmd
)paren
(brace
id|size
op_assign
id|print_insn
(paren
id|cmd-&gt;host
comma
id|bus_to_virt
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|ncmd-&gt;saved_data_pointer
)paren
)paren
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
id|print_insn
(paren
id|cmd-&gt;host
comma
id|bus_to_virt
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|ncmd-&gt;saved_data_pointer
)paren
)paren
op_plus
id|size
op_star
r_sizeof
(paren
id|u32
)paren
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_static
r_void
DECL|function|print_dsa
id|print_dsa
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
id|u32
op_star
id|dsa
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
id|i
comma
id|len
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_if
c_cond
(paren
id|check_address
(paren
(paren
r_int
r_int
)paren
id|dsa
comma
id|hostdata-&gt;dsa_end
op_minus
id|hostdata-&gt;dsa_start
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : bad dsa virt 0x%p&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|dsa
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%sscsi%d : dsa at phys 0x%lx (virt 0x%p)&bslash;n&quot;
l_string|&quot;        + %d : dsa_msgout length = %u, data = 0x%x (virt 0x%p)&bslash;n&quot;
comma
id|prefix
ques
c_cond
id|prefix
suffix:colon
l_string|&quot;&quot;
comma
id|host-&gt;host_no
comma
id|virt_to_bus
(paren
id|dsa
)paren
comma
id|dsa
comma
id|hostdata-&gt;dsa_msgout
comma
id|le32_to_cpu
c_func
(paren
id|dsa
(braket
id|hostdata-&gt;dsa_msgout
op_div
r_sizeof
(paren
id|u32
)paren
)braket
)paren
comma
id|le32_to_cpu
c_func
(paren
id|dsa
(braket
id|hostdata-&gt;dsa_msgout
op_div
r_sizeof
(paren
id|u32
)paren
op_plus
l_int|1
)braket
)paren
comma
id|bus_to_virt
(paren
id|le32_to_cpu
c_func
(paren
id|dsa
(braket
id|hostdata-&gt;dsa_msgout
op_div
r_sizeof
(paren
id|u32
)paren
op_plus
l_int|1
)braket
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;     * Only print messages if they&squot;re sane in length so we don&squot;t&n;     * blow the kernel printk buffer on something which won&squot;t buy us&n;     * anything.&n;     */
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|dsa
(braket
id|hostdata-&gt;dsa_msgout
op_div
r_sizeof
(paren
id|u32
)paren
)braket
)paren
OL
r_sizeof
(paren
id|hostdata-&gt;free-&gt;select
)paren
)paren
r_for
c_loop
(paren
id|i
op_assign
id|le32_to_cpu
c_func
(paren
id|dsa
(braket
id|hostdata-&gt;dsa_msgout
op_div
r_sizeof
(paren
id|u32
)paren
)braket
)paren
comma
id|ptr
op_assign
id|bus_to_virt
(paren
id|le32_to_cpu
c_func
(paren
id|dsa
(braket
id|hostdata-&gt;dsa_msgout
op_div
r_sizeof
(paren
id|u32
)paren
op_plus
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|i
OG
l_int|0
op_logical_and
op_logical_neg
id|check_address
(paren
(paren
r_int
r_int
)paren
id|ptr
comma
l_int|1
)paren
suffix:semicolon
id|ptr
op_add_assign
id|len
comma
id|i
op_sub_assign
id|len
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;               &quot;
)paren
suffix:semicolon
id|len
op_assign
id|print_msg
(paren
id|ptr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;        + %d : select_indirect = 0x%x&bslash;n&quot;
comma
id|hostdata-&gt;dsa_select
comma
id|le32_to_cpu
c_func
(paren
id|dsa
(braket
id|hostdata-&gt;dsa_select
op_div
r_sizeof
(paren
id|u32
)paren
)braket
)paren
)paren
suffix:semicolon
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|bus_to_virt
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|dsa
(braket
id|hostdata-&gt;dsa_cmnd
op_div
r_sizeof
(paren
id|u32
)paren
)braket
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        + %d : dsa_cmnd = 0x%x &quot;
comma
id|hostdata-&gt;dsa_cmnd
comma
(paren
id|u32
)paren
id|virt_to_bus
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;               result = 0x%x, target = %d, lun = %d, cmd = &quot;
comma
id|cmd-&gt;result
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|print_command
c_func
(paren
id|cmd-&gt;cmnd
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        + %d : dsa_next = 0x%x&bslash;n&quot;
comma
id|hostdata-&gt;dsa_next
comma
id|le32_to_cpu
c_func
(paren
id|dsa
(braket
id|hostdata-&gt;dsa_next
op_div
r_sizeof
(paren
id|u32
)paren
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d target %d : sxfer_sanity = 0x%x, scntl3_sanity = 0x%x&bslash;n&quot;
l_string|&quot;                   script : &quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;target
comma
id|hostdata-&gt;sync
(braket
id|cmd-&gt;target
)braket
dot
id|sxfer_sanity
comma
id|hostdata-&gt;sync
(braket
id|cmd-&gt;target
)braket
dot
id|scntl3_sanity
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_sizeof
(paren
id|hostdata-&gt;sync
(braket
id|cmd-&gt;target
)braket
dot
id|script
)paren
op_div
l_int|4
)paren
suffix:semicolon
op_increment
id|i
)paren
id|printk
(paren
l_string|&quot;0x%x &quot;
comma
id|hostdata-&gt;sync
(braket
id|cmd-&gt;target
)braket
dot
id|script
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|print_progress
(paren
id|cmd
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function : void print_queues (Scsi_Host *host) &n; * &n; * Purpose : print the contents of the NCR issue and reconnect queues&n; *&n; * Inputs : host - SCSI host we are interested in&n; *&n; */
r_static
r_void
DECL|function|print_queues
id|print_queues
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|u32
op_star
id|dsa
comma
op_star
id|next_dsa
suffix:semicolon
r_volatile
id|u32
op_star
id|curr
suffix:semicolon
r_int
id|left
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
comma
op_star
id|next_cmd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : issue queue&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_for
c_loop
(paren
id|left
op_assign
id|host-&gt;can_queue
comma
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|left
op_ge
l_int|0
op_logical_and
id|cmd
suffix:semicolon
id|cmd
op_assign
id|next_cmd
)paren
(brace
id|next_cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;SCp.ptr
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;host_scribble
)paren
(brace
r_if
c_cond
(paren
id|check_address
(paren
(paren
r_int
r_int
)paren
(paren
id|cmd-&gt;host_scribble
)paren
comma
r_sizeof
(paren
id|cmd-&gt;host_scribble
)paren
)paren
op_eq
op_minus
l_int|1
)paren
id|printk
(paren
l_string|&quot;scsi%d: scsi pid %ld bad pointer to NCR53c7x0_cmd&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
multiline_comment|/* print_dsa does sanity check on address, no need to check */
r_else
id|print_dsa
(paren
id|host
comma
id|bus_to_virt
c_func
(paren
id|le32_to_cpu
c_func
(paren
(paren
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|cmd-&gt;host_scribble
)paren
op_member_access_from_pointer
id|dsa
)paren
)paren
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_else
id|printk
(paren
l_string|&quot;scsi%d : scsi pid %ld for target %d lun %d has no NCR53c7x0_cmd&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|left
op_le
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : loop detected in issue queue&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Traverse the NCR reconnect and start DSA structures, printing out &n;     * each element until we hit the end or detect a loop.  Currently,&n;     * the reconnect structure is a linked list; and the start structure&n;     * is an array.  Eventually, the reconnect structure will become a &n;     * list as well, since this simplifies the code.&n;     */
id|printk
(paren
l_string|&quot;scsi%d : schedule dsa array :&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_for
c_loop
(paren
id|left
op_assign
id|host-&gt;can_queue
comma
id|curr
op_assign
id|hostdata-&gt;schedule
suffix:semicolon
id|left
OG
l_int|0
suffix:semicolon
id|curr
op_add_assign
l_int|2
comma
op_decrement
id|left
)paren
r_if
c_cond
(paren
id|curr
(braket
l_int|0
)braket
op_ne
id|hostdata-&gt;NOP_insn
)paren
multiline_comment|/* FIXME : convert pointer to dsa_begin to pointer to dsa. */
id|print_dsa
(paren
id|host
comma
id|bus_to_virt
(paren
id|le32_to_cpu
c_func
(paren
id|curr
(braket
l_int|1
)braket
)paren
op_minus
(paren
id|hostdata-&gt;E_dsa_code_begin
op_minus
id|hostdata-&gt;E_dsa_code_template
)paren
)paren
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : end schedule dsa array&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : reconnect_dsa_head :&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_for
c_loop
(paren
id|left
op_assign
id|host-&gt;can_queue
comma
id|dsa
op_assign
id|bus_to_virt
(paren
id|le32_to_cpu
c_func
(paren
id|hostdata-&gt;reconnect_dsa_head
)paren
)paren
suffix:semicolon
id|left
op_ge
l_int|0
op_logical_and
id|dsa
suffix:semicolon
id|dsa
op_assign
id|next_dsa
)paren
(brace
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_address
(paren
(paren
r_int
r_int
)paren
id|dsa
comma
r_sizeof
(paren
id|dsa
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d: bad DSA pointer 0x%p&quot;
comma
id|host-&gt;host_no
comma
id|dsa
)paren
suffix:semicolon
id|next_dsa
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|next_dsa
op_assign
id|bus_to_virt
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|dsa
(braket
id|hostdata-&gt;dsa_next
op_div
r_sizeof
(paren
id|u32
)paren
)braket
)paren
)paren
suffix:semicolon
id|print_dsa
(paren
id|host
comma
id|dsa
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;scsi%d : end reconnect_dsa_head&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
OL
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d: possible loop in ncr reconnect list&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|print_lots
id|print_lots
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|u32
op_star
id|dsp_next
comma
op_star
id|dsp
comma
op_star
id|dsa
comma
id|dbc_dcmd
suffix:semicolon
r_int
r_char
id|dcmd
comma
id|sbcl
suffix:semicolon
r_int
id|i
comma
id|size
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dsp_next
op_assign
id|bus_to_virt
c_func
(paren
id|NCR53c7x0_read32
(paren
id|DSP_REG
)paren
)paren
)paren
)paren
(brace
id|dbc_dcmd
op_assign
id|NCR53c7x0_read32
c_func
(paren
id|DBC_REG
)paren
suffix:semicolon
id|dcmd
op_assign
(paren
id|dbc_dcmd
op_amp
l_int|0xff000000
)paren
op_rshift
l_int|24
suffix:semicolon
id|dsp
op_assign
id|dsp_next
op_minus
id|NCR53c7x0_insn_size
c_func
(paren
id|dcmd
)paren
suffix:semicolon
id|dsa
op_assign
id|bus_to_virt
c_func
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DSA_REG
)paren
)paren
suffix:semicolon
id|sbcl
op_assign
id|NCR53c7x0_read8
(paren
id|SBCL_REG
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : DCMD|DBC=0x%x, DNAD=0x%x (virt 0x%p)&bslash;n&quot;
l_string|&quot;         DSA=0x%lx (virt 0x%p)&bslash;n&quot;
l_string|&quot;         DSPS=0x%x, TEMP=0x%x (virt 0x%p), DMODE=0x%x&bslash;n&quot;
l_string|&quot;         SXFER=0x%x, SCNTL3=0x%x&bslash;n&quot;
l_string|&quot;         %s%s%sphase=%s, %d bytes in SCSI FIFO&bslash;n&quot;
l_string|&quot;         STEST0=0x%x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|dbc_dcmd
comma
id|NCR53c7x0_read32
c_func
(paren
id|DNAD_REG
)paren
comma
id|bus_to_virt
c_func
(paren
id|NCR53c7x0_read32
c_func
(paren
id|DNAD_REG
)paren
)paren
comma
id|virt_to_bus
c_func
(paren
id|dsa
)paren
comma
id|dsa
comma
id|NCR53c7x0_read32
c_func
(paren
id|DSPS_REG
)paren
comma
id|NCR53c7x0_read32
c_func
(paren
id|TEMP_REG
)paren
comma
id|bus_to_virt
(paren
id|NCR53c7x0_read32
c_func
(paren
id|TEMP_REG
)paren
)paren
comma
(paren
r_int
)paren
id|NCR53c7x0_read8
c_func
(paren
id|hostdata-&gt;dmode
)paren
comma
(paren
r_int
)paren
id|NCR53c7x0_read8
c_func
(paren
id|SXFER_REG
)paren
comma
(paren
r_int
)paren
id|NCR53c7x0_read8
c_func
(paren
id|SCNTL3_REG_800
)paren
comma
(paren
id|sbcl
op_amp
id|SBCL_BSY
)paren
ques
c_cond
l_string|&quot;BSY &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|sbcl
op_amp
id|SBCL_SEL
)paren
ques
c_cond
l_string|&quot;SEL &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|sbcl
op_amp
id|SBCL_REQ
)paren
ques
c_cond
l_string|&quot;REQ &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|sstat2_to_phase
c_func
(paren
id|NCR53c7x0_read8
(paren
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
ques
c_cond
id|SSTAT1_REG
suffix:colon
id|SSTAT2_REG
)paren
)paren
comma
(paren
id|NCR53c7x0_read8
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
ques
c_cond
id|SSTAT1_REG
suffix:colon
id|SSTAT2_REG
)paren
op_amp
id|SSTAT2_FF_MASK
)paren
op_rshift
id|SSTAT2_FF_SHIFT
comma
id|NCR53c7x0_read8
(paren
id|STEST0_REG_800
)paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : DSP 0x%lx (virt 0x%p) -&gt;&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|virt_to_bus
c_func
(paren
id|dsp
)paren
comma
id|dsp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|6
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
comma
id|dsp
op_add_assign
id|size
)paren
id|size
op_assign
id|print_insn
(paren
id|host
comma
id|dsp
comma
l_string|&quot;&quot;
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NCR53c7x0_read8
(paren
id|SCNTL1_REG
)paren
op_amp
id|SCNTL1_CON
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : connected (SDID=0x%x, SSID=0x%x)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|NCR53c7x0_read8
(paren
id|SDID_REG_800
)paren
comma
id|NCR53c7x0_read8
(paren
id|SSID_REG_800
)paren
)paren
suffix:semicolon
id|print_dsa
(paren
id|host
comma
id|dsa
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
macro_line|#if 1
id|print_queues
(paren
id|host
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*&n; * Function : static int shutdown (struct Scsi_Host *host)&n; * &n; * Purpose : does a clean (we hope) shutdown of the NCR SCSI &n; *&t;chip.  Use prior to dumping core, unloading the NCR driver,&n; * &n; * Returns : 0 on success&n; */
r_static
r_int
DECL|function|shutdown
id|shutdown
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Get in a state where we can reset the SCSI bus */
id|ncr_halt
(paren
id|host
)paren
suffix:semicolon
id|ncr_scsi_reset
(paren
id|host
)paren
suffix:semicolon
id|hostdata
op_member_access_from_pointer
id|soft_reset
c_func
(paren
id|host
)paren
suffix:semicolon
id|disable
(paren
id|host
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : void ncr_scsi_reset (struct Scsi_Host *host)&n; *&n; * Purpose : reset the SCSI bus.&n; */
r_static
r_void
DECL|function|ncr_scsi_reset
id|ncr_scsi_reset
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|sien
op_assign
l_int|0
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
(brace
id|sien
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SIEN0_REG_800
)paren
suffix:semicolon
id|NCR53c7x0_write8
c_func
(paren
id|SIEN0_REG_800
comma
id|sien
op_amp
op_complement
id|SIEN_RST
)paren
suffix:semicolon
)brace
id|NCR53c7x0_write8
c_func
(paren
id|SCNTL1_REG
comma
id|SCNTL1_RST
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
multiline_comment|/* Minimum amount of time to assert RST */
id|NCR53c7x0_write8
c_func
(paren
id|SCNTL1_REG
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
(brace
id|NCR53c7x0_write8
c_func
(paren
id|SIEN0_REG_800
comma
id|sien
)paren
suffix:semicolon
)brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : void hard_reset (struct Scsi_Host *host)&n; *&n; */
r_static
r_void
DECL|function|hard_reset
id|hard_reset
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ncr_scsi_reset
c_func
(paren
id|host
)paren
suffix:semicolon
id|NCR53c7x0_driver_init
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;soft_reset
)paren
id|hostdata-&gt;soft_reset
(paren
id|host
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : Scsi_Cmnd *return_outstanding_commands (struct Scsi_Host *host,&n; *&t;int free, int issue)&n; *&n; * Purpose : return a linked list (using the SCp.buffer field as next,&n; *&t;so we don&squot;t perturb hostdata.  We don&squot;t use a field of the &n; *&t;NCR53c7x0_cmd structure since we may not have allocated one &n; *&t;for the command causing the reset.) of Scsi_Cmnd structures that &n; *  &t;had propagated below the Linux issue queue level.  If free is set, &n; *&t;free the NCR53c7x0_cmd structures which are associated with &n; *&t;the Scsi_Cmnd structures, and clean up any internal &n; *&t;NCR lists that the commands were on.  If issue is set,&n; *&t;also return commands in the issue queue.&n; *&n; * Returns : linked list of commands&n; *&n; * NOTE : the caller should insure that the NCR chip is halted&n; *&t;if the free flag is set. &n; */
r_static
id|Scsi_Cmnd
op_star
DECL|function|return_outstanding_commands
id|return_outstanding_commands
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_int
id|free
comma
r_int
id|issue
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_struct
id|NCR53c7x0_cmd
op_star
id|c
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u32
op_star
id|curr
suffix:semicolon
id|Scsi_Cmnd
op_star
id|list
op_assign
l_int|NULL
comma
op_star
id|tmp
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|hostdata-&gt;running_list
suffix:semicolon
id|c
suffix:semicolon
id|c
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|c-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|c-&gt;cmd-&gt;SCp.buffer
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : loop detected in running list!&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;Duh? Bad things happening in the NCR driver&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|c-&gt;cmd-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|list
suffix:semicolon
id|list
op_assign
id|c-&gt;cmd
suffix:semicolon
r_if
c_cond
(paren
id|free
)paren
(brace
id|c-&gt;next
op_assign
id|hostdata-&gt;free
suffix:semicolon
id|hostdata-&gt;free
op_assign
id|c
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|free
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|curr
op_assign
(paren
id|u32
op_star
)paren
id|hostdata-&gt;schedule
suffix:semicolon
id|i
OL
id|host-&gt;can_queue
suffix:semicolon
op_increment
id|i
comma
id|curr
op_add_assign
l_int|2
)paren
(brace
id|curr
(braket
l_int|0
)braket
op_assign
id|hostdata-&gt;NOP_insn
suffix:semicolon
id|curr
(braket
l_int|1
)braket
op_assign
id|le32_to_cpu
c_func
(paren
l_int|0xdeadbeef
)paren
suffix:semicolon
)brace
id|hostdata-&gt;curr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|issue
)paren
(brace
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;SCp.buffer
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : loop detected in issue queue!&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|list
suffix:semicolon
id|list
op_assign
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|free
)paren
id|hostdata-&gt;issue_queue
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|list
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : static int disable (struct Scsi_Host *host)&n; *&n; * Purpose : disables the given NCR host, causing all commands&n; * &t;to return a driver error.  Call this so we can unload the&n; * &t;module during development and try again.  Eventually, &n; * &t;we should be able to find clean workarounds for these&n; * &t;problems.&n; *&n; * Inputs : host - hostadapter to twiddle&n; *&n; * Returns : 0 on success.&n; */
r_static
r_int
DECL|function|disable
id|disable
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|Scsi_Cmnd
op_star
id|nuke_list
comma
op_star
id|tmp
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;state
op_ne
id|STATE_HALTED
)paren
id|ncr_halt
(paren
id|host
)paren
suffix:semicolon
id|nuke_list
op_assign
id|return_outstanding_commands
(paren
id|host
comma
l_int|1
multiline_comment|/* free */
comma
l_int|1
multiline_comment|/* issue */
)paren
suffix:semicolon
id|hard_reset
(paren
id|host
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|STATE_DISABLED
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : nuking commands&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|nuke_list
suffix:semicolon
id|nuke_list
op_assign
id|tmp
)paren
(brace
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|nuke_list-&gt;SCp.buffer
suffix:semicolon
id|nuke_list-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|nuke_list
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|nuke_list
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;scsi%d : done. &bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ALERT
l_string|&quot;scsi%d : disabled.  Unload and reload&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : static int ncr_halt (struct Scsi_Host *host)&n; * &n; * Purpose : halts the SCSI SCRIPTS(tm) processor on the NCR chip&n; *&n; * Inputs : host - SCSI chip to halt&n; *&n; * Returns : 0 on success&n; */
r_static
r_int
DECL|function|ncr_halt
id|ncr_halt
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|NCR53c7x0_local_declare
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|istat
comma
id|tmp
suffix:semicolon
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
id|stage
suffix:semicolon
id|NCR53c7x0_local_setup
c_func
(paren
id|host
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Stage 0 : eat all interrupts&n;       Stage 1 : set ABORT&n;       Stage 2 : eat all but abort interrupts&n;       Stage 3 : eat all interrupts&n;     */
r_for
c_loop
(paren
id|stage
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|stage
op_eq
l_int|1
)paren
(brace
id|NCR53c7x0_write8
c_func
(paren
id|hostdata-&gt;istat
comma
id|ISTAT_ABRT
)paren
suffix:semicolon
op_increment
id|stage
suffix:semicolon
)brace
id|istat
op_assign
id|NCR53c7x0_read8
(paren
id|hostdata-&gt;istat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|istat
op_amp
id|ISTAT_SIP
)paren
(brace
r_if
c_cond
(paren
(paren
id|hostdata-&gt;chip
op_div
l_int|100
)paren
op_eq
l_int|8
)paren
(brace
id|tmp
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SIST0_REG_800
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|tmp
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SIST1_REG_800
)paren
suffix:semicolon
)brace
r_else
(brace
id|tmp
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|SSTAT0_REG
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|istat
op_amp
id|ISTAT_DIP
)paren
(brace
id|tmp
op_assign
id|NCR53c7x0_read8
c_func
(paren
id|DSTAT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stage
op_eq
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|tmp
op_amp
id|DSTAT_ABRT
)paren
(brace
id|NCR53c7x0_write8
c_func
(paren
id|hostdata-&gt;istat
comma
l_int|0
)paren
suffix:semicolon
op_increment
id|stage
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;scsi%d : could not halt NCR chip&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|disable
(paren
id|host
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|istat
op_amp
(paren
id|ISTAT_SIP
op_or
id|ISTAT_DIP
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|stage
op_eq
l_int|0
)paren
op_increment
id|stage
suffix:semicolon
r_else
r_if
c_cond
(paren
id|stage
op_eq
l_int|3
)paren
r_break
suffix:semicolon
)brace
)brace
id|hostdata-&gt;state
op_assign
id|STATE_HALTED
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if 0
id|print_lots
(paren
id|host
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * Function: event_name (int event)&n; * &n; * Purpose: map event enum into user-readable strings.&n; */
r_static
r_const
r_char
op_star
DECL|function|event_name
id|event_name
(paren
r_int
id|event
)paren
(brace
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|EVENT_NONE
suffix:colon
r_return
l_string|&quot;none&quot;
suffix:semicolon
r_case
id|EVENT_ISSUE_QUEUE
suffix:colon
r_return
l_string|&quot;to issue queue&quot;
suffix:semicolon
r_case
id|EVENT_START_QUEUE
suffix:colon
r_return
l_string|&quot;to start queue&quot;
suffix:semicolon
r_case
id|EVENT_SELECT
suffix:colon
r_return
l_string|&quot;selected&quot;
suffix:semicolon
r_case
id|EVENT_DISCONNECT
suffix:colon
r_return
l_string|&quot;disconnected&quot;
suffix:semicolon
r_case
id|EVENT_RESELECT
suffix:colon
r_return
l_string|&quot;reselected&quot;
suffix:semicolon
r_case
id|EVENT_COMPLETE
suffix:colon
r_return
l_string|&quot;completed&quot;
suffix:semicolon
r_case
id|EVENT_IDLE
suffix:colon
r_return
l_string|&quot;idle&quot;
suffix:semicolon
r_case
id|EVENT_SELECT_FAILED
suffix:colon
r_return
l_string|&quot;select failed&quot;
suffix:semicolon
r_case
id|EVENT_BEFORE_SELECT
suffix:colon
r_return
l_string|&quot;before select&quot;
suffix:semicolon
r_case
id|EVENT_RESELECT_FAILED
suffix:colon
r_return
l_string|&quot;reselect failed&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function : void dump_events (struct Scsi_Host *host, count)&n; *&n; * Purpose : print last count events which have occurred.&n; */
r_static
r_void
DECL|function|dump_events
id|dump_events
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_int
id|count
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_struct
id|NCR53c7x0_event
id|event
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;events
)paren
(brace
r_if
c_cond
(paren
id|count
OG
id|hostdata-&gt;event_size
)paren
id|count
op_assign
id|hostdata-&gt;event_size
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|hostdata-&gt;event_index
suffix:semicolon
id|count
OG
l_int|0
suffix:semicolon
id|i
op_assign
(paren
id|i
ques
c_cond
id|i
op_minus
l_int|1
suffix:colon
id|hostdata-&gt;event_size
op_minus
l_int|1
)paren
comma
op_decrement
id|count
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n; * By copying the event we&squot;re currently examining with interrupts&n; * disabled, we can do multiple printk(), etc. operations and &n; * still be guaranteed that they&squot;re happening on the same &n; * event structure.&n; */
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#if 0
id|event
op_assign
id|hostdata-&gt;events
(braket
id|i
)braket
suffix:semicolon
macro_line|#else
id|memcpy
(paren
(paren
r_void
op_star
)paren
op_amp
id|event
comma
(paren
r_void
op_star
)paren
op_amp
(paren
id|hostdata-&gt;events
(braket
id|i
)braket
)paren
comma
r_sizeof
(paren
id|event
)paren
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : %s event %d at %ld secs %ld usecs target %d lun %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|event_name
(paren
id|event.event
)paren
comma
id|count
comma
(paren
r_int
)paren
id|event.time.tv_sec
comma
(paren
r_int
)paren
id|event.time.tv_usec
comma
id|event.target
comma
id|event.lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event.dsa
)paren
id|printk
(paren
l_string|&quot;         event for dsa 0x%lx (virt 0x%p)&bslash;n&quot;
comma
id|virt_to_bus
c_func
(paren
id|event.dsa
)paren
comma
id|event.dsa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event.pid
op_ne
op_minus
l_int|1
)paren
(brace
id|printk
(paren
l_string|&quot;         event for pid %ld &quot;
comma
id|event.pid
)paren
suffix:semicolon
id|print_command
(paren
id|event.cmnd
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * Function: check_address&n; *&n; * Purpose: Check to see if a possibly corrupt pointer will fault the &n; *&t;kernel.&n; *&n; * Inputs: addr - address; size - size of area&n; *&n; * Returns: 0 if area is OK, -1 on error.&n; *&n; * NOTES: should be implemented in terms of vverify on kernels &n; *&t;that have it.&n; */
r_static
r_int
DECL|function|check_address
id|check_address
(paren
r_int
r_int
id|addr
comma
r_int
id|size
)paren
(brace
r_return
(paren
id|virt_to_phys
c_func
(paren
(paren
r_void
op_star
)paren
id|addr
)paren
template_param
id|virt_to_phys
c_func
(paren
id|high_memory
)paren
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
r_int
DECL|function|NCR53c7x0_release
id|NCR53c7x0_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_struct
id|NCR53c7x0_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR53c7x0_hostdata
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_struct
id|NCR53c7x0_cmd
op_star
id|cmd
comma
op_star
id|tmp
suffix:semicolon
id|shutdown
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;irq
op_ne
id|IRQ_NONE
)paren
(brace
r_int
id|irq_count
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|tmp
suffix:semicolon
r_for
c_loop
(paren
id|irq_count
op_assign
l_int|0
comma
id|tmp
op_assign
id|first_host
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
r_if
c_cond
(paren
id|tmp-&gt;hostt
op_eq
id|the_template
op_logical_and
id|tmp-&gt;irq
op_eq
id|host-&gt;irq
)paren
op_increment
id|irq_count
suffix:semicolon
r_if
c_cond
(paren
id|irq_count
op_eq
l_int|1
)paren
id|free_irq
c_func
(paren
id|host-&gt;irq
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|host-&gt;dma_channel
op_ne
id|DMA_NONE
)paren
id|free_dma
c_func
(paren
id|host-&gt;dma_channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;io_port
)paren
id|release_region
c_func
(paren
id|host-&gt;io_port
comma
id|host-&gt;n_io_port
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cmd
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|hostdata-&gt;free
suffix:semicolon
id|cmd
suffix:semicolon
id|cmd
op_assign
id|tmp
comma
op_decrement
id|hostdata-&gt;num_cmds
)paren
(brace
id|tmp
op_assign
(paren
r_struct
id|NCR53c7x0_cmd
op_star
)paren
id|cmd-&gt;next
suffix:semicolon
multiline_comment|/* &n;     * If we&squot;re going to loop, try to stop it to get a more accurate&n;     * count of the leaked commands.&n;     */
id|cmd-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;free
)paren
id|cmd-&gt;free
(paren
(paren
r_void
op_star
)paren
id|cmd-&gt;real
comma
id|cmd-&gt;size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hostdata-&gt;num_cmds
)paren
id|printk
(paren
l_string|&quot;scsi%d : leaked %d NCR53c7x0_cmd structures&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|hostdata-&gt;num_cmds
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;events
)paren
id|vfree
(paren
(paren
r_void
op_star
)paren
id|hostdata-&gt;events
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* def MODULE */
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|NCR53c7xx
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
eof
