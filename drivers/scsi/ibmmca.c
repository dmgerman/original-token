multiline_comment|/*&n; * Low Level Driver for the IBM Microchannel SCSI Subsystem&n; *&n; * Copyright (c) 1995 Strom Systems, Inc. under the terms of the GNU &n; * General Public License. Written by Martin Kolinek, December 1995.&n; */
multiline_comment|/* Update history:&n;   Jan 15 1996:  First public release.&n;   - Martin Kolinek&n;&n;   Jan 23 1996:  Scrapped code which reassigned scsi devices to logical&n;   device numbers. Instead, the existing assignment (created&n;   when the machine is powered-up or rebooted) is used. &n;   A side effect is that the upper layer of Linux SCSI &n;   device driver gets bogus scsi ids (this is benign), &n;   and also the hard disks are ordered under Linux the &n;   same way as they are under dos (i.e., C: disk is sda, &n;   D: disk is sdb, etc.).&n;   - Martin Kolinek&n;&n;   I think that the CD-ROM is now detected only if a CD is &n;   inside CD_ROM while Linux boots. This can be fixed later,&n;   once the driver works on all types of PS/2&squot;s.&n;   - Martin Kolinek&n;&n;   Feb 7 1996:   Modified biosparam function. Fixed the CD-ROM detection. &n;   For now, devices other than harddisk and CD_ROM are &n;   ignored. Temporarily modified abort() function &n;   to behave like reset().&n;   - Martin Kolinek&n;&n;   Mar 31 1996:  The integrated scsi subsystem is correctly found&n;   in PS/2 models 56,57, but not in model 76. Therefore&n;   the ibmmca_scsi_setup() function has been added today.&n;   This function allows the user to force detection of&n;   scsi subsystem. The kernel option has format&n;   ibmmcascsi=n&n;   where n is the scsi_id (pun) of the subsystem. Most likely, n is 7.&n;   - Martin Kolinek&n;&n;   Aug 21 1996:  Modified the code which maps ldns to (pun,0).  It was&n;   insufficient for those of us with CD-ROM changers.&n;   - Chris Beauregard&n; &n;   Dec 14 1996: More improvements to the ldn mapping.  See check_devices&n;   for details.  Did more fiddling with the integrated SCSI detection,&n;   but I think it&squot;s ultimately hopeless without actually testing the&n;   model of the machine.  The 56, 57, 76 and 95 (ultimedia) all have&n;   different integrated SCSI register configurations.  However, the 56&n;   and 57 are the only ones that have problems with forced detection.&n;   - Chris Beauregard&n; &n;   Mar 8-16 1997: Modified driver to run as a module and to support &n;   multiple adapters. A structure, called ibmmca_hostdata, is now&n;   present, containing all the variables, that were once only&n;   available for one single adapter. The find_subsystem-routine has vanished.&n;   The hardware recognition is now done in ibmmca_detect directly.&n;   This routine checks for presence of MCA-bus, checks the interrupt&n;   level and continues with checking the installed hardware.&n;   Certain PS/2-models do not recognize a SCSI-subsystem automatically.&n;   Hence, the setup defined by command-line-parameters is checked first.&n;   Thereafter, the routine probes for an integrated SCSI-subsystem.&n;   Finally, adapters are checked. This method has the advantage to cover all&n;   possible combinations of multiple SCSI-subsystems on one MCA-board. Up to&n;   eight SCSI-subsystems can be recognized and announced to the upper-level&n;   drivers with this improvement. A set of defines made changes to other&n;   routines as small as possible.&n;   - Klaus Kudielka&n;   &n;   May 30 1997: (v1.5b)&n;   1) SCSI-command capability enlarged by the recognition of MODE_SELECT.&n;      This needs the RD-Bit to be disabled on IM_OTHER_SCSI_CMD_CMD which &n;      allows data to be written from the system to the device. It is a&n;      necessary step to be allowed to set blocksize of SCSI-tape-drives and &n;      the tape-speed, whithout confusing the SCSI-Subsystem.&n;   2) The recognition of a tape is included in the check_devices routine.&n;      This is done by checking for TYPE_TAPE, that is already defined in&n;      the kernel-scsi-environment. The markup of a tape is done in the &n;      global ldn_is_tape[] array. If the entry on index ldn &n;      is 1, there is a tapedrive connected.&n;   3) The ldn_is_tape[] array is necessary to distinguish between tape- and &n;      other devices. Fixed blocklength devices should not cause a problem&n;      with the SCB-command for read and write in the ibmmca_queuecommand&n;      subroutine. Therefore, I only derivate the READ_XX, WRITE_XX for&n;      the tape-devices, as recommended by IBM in this Technical Reference,&n;      mentioned below. (IBM recommends to avoid using the read/write of the&n;      subsystem, but the fact was, that read/write causes a command error from&n;      the subsystem and this causes kernel-panic.)&n;   4) In addition, I propose to use the ldn instead of a fix char for the&n;      display of PS2_DISK_LED_ON(). On 95, one can distinguish between the&n;      devices that are accessed. It shows activity and easyfies debugging.   &n;   The tape-support has been tested with a SONY SDT-5200 and a HP DDS-2&n;   (I do not know yet the type). Optimization and CD-ROM audio-support, &n;   I am working on ...&n;   - Michael Lang&n;   &n;   June 19 1997: (v1.6b)&n;   1) Submitting the extra-array ldn_is_tape[] -&gt; to the local ld[]&n;      device-array. &n;   2) CD-ROM Audio-Play seems to work now.&n;   3) When using DDS-2 (120M) DAT-Tapes, mtst shows still density-code&n;      0x13 for ordinary DDS (61000 BPM) instead 0x24 for DDS-2. This appears &n;      also on Adaptec 2940 adaptor in a PCI-System. Therefore, I assume that &n;      the problem is independent of the low-level-driver/bus-architecture.&n;   4) Hexadecimal ldn on PS/2-95 LED-display.&n;   5) Fixing of the PS/2-LED on/off that it works right with tapedrives and&n;      does not confuse the disk_rw_in_progress counter.&n;   - Michael Lang&n;  &n;   June 21 1997: (v1.7b)&n;   1) Adding of a proc_info routine to inform in /proc/scsi/ibmmca/&lt;host&gt; the&n;      outer-world about operational load statistics on the different ldns,&n;      seen by the driver. Everybody that has more than one IBM-SCSI should&n;      test this, because I only have one and cannot see what happens with more&n;      than one IBM-SCSI hosts.&n;   2) Definition of a driver version-number to have a better recognition of &n;      the source when there are existing too much releases that may confuse&n;      the user, when reading about release-specific problems. Up to know,&n;      I calculated the version-number to be 1.7. Because we are in BETA-test&n;      yet, it is today 1.7b.&n;   3) Sorry for the heavy bug I programmed on June 19 1997! After that, the&n;      CD-ROM did not work any more! The C7-command was a fake impression&n;      I got while programming. Now, the READ and WRITE commands for CD-ROM are&n;      no longer running over the subsystem, but just over &n;      IM_OTHER_SCSI_CMD_CMD. On my observations (PS/2-95), now CD-ROM mounts&n;      much faster(!) and hopefully all fancy multimedia-functions, like direct&n;      digital recording from audio-CDs also work. (I tried it with cdda2wav&n;      from the cdwtools-package and it filled up the harddisk immediately :-).)&n;      To easify boolean logics, a further local device-type in ld[], called&n;      is_cdrom has been included.&n;   4) If one uses a SCSI-device of unsupported type/commands, one&n;      immediately runs into a kernel-panic caused by Command Error. To better&n;      understand which SCSI-command caused the problem, I extended this&n;      specific panic-message slightly.&n;   - Michael Lang&n; &n;   June 25 1997: (v1.8b)&n;   1) Some cosmetical changes for the handling of SCSI-device-types.&n;      Now, also CD-Burners / WORMs and SCSI-scanners should work. For&n;      MO-drives I have no experience, therefore not yet supported.&n;      In logical_devices I changed from different type-variables to one&n;      called &squot;device_type&squot; where the values, corresponding to scsi.h,&n;      of a SCSI-device are stored.&n;   2) There existed a small bug, that maps a device, coming after a SCSI-tape&n;      wrong. Therefore, e.g. a CD-ROM changer would have been mapped wrong&n;      -&gt; problem removed.&n;   3) Extension of the logical_device structure. Now it contains also device,&n;      vendor and revision-level of a SCSI-device for internal usage.&n;   - Michael Lang&n;&n;   June 26-29 1997: (v2.0b)&n;   1) The release number 2.0b is necessary because of the completely new done&n;      recognition and handling of SCSI-devices with the adapter. As I got&n;      from Chris the hint, that the subsystem can reassign ldns dynamically,&n;      I remembered this immediate_assign-command, I found once in the handbook.&n;      Now, the driver first kills all ldn assignments that are set by default&n;      on the SCSI-subsystem. After that, it probes on all puns and luns for&n;      devices by going through all combinations with immediate_assign and&n;      probing for devices, using device_inquiry. The found physical(!) pun,lun&n;      structure is stored in get_scsi[][] as device types. This is followed&n;      by the assignment of all ldns to existing SCSI-devices. If more ldns&n;      than devices are available, they are assigned to non existing pun,lun&n;      combinations to satisfy the adapter. With this, the dynamical mapping&n;      was possible to implement. (For further info see the text in the &n;      source-code and in the description below. Read the description&n;      below BEFORE installing this driver on your system!)&n;   2) Changed the name IBMMCA_DRIVER_VERSION to IBMMCA_SCSI_DRIVER_VERSION.&n;   3) The LED-display shows on PS/2-95 no longer the ldn, but the SCSI-ID&n;      (pun) of the accessed SCSI-device. This is now senseful, because the &n;      pun known within the driver is exactly the pun of the physical device&n;      and no longer a fake one.&n;   4) The /proc/scsi/ibmmca/&lt;host_no&gt; consists now of the first part, where&n;      hit-statistics of ldns is shown and a second part, where the maps of &n;      physical and logical SCSI-devices are displayed. This could be very &n;      interesting, when one is using more than 15 SCSI-devices in order to &n;      follow the dynamical remapping of ldns.&n;   - Michael Lang&n; &n;   June 26-29 1997: (v2.0b-1)&n;   1) I forgot to switch the local_checking_phase_flag to 1 and back to 0&n;      in the dynamical remapping part in ibmmca_queuecommand for the &n;      device_exist routine. Sorry.&n;   - Michael Lang&n; &n;   July 1-13 1997: (v3.0b,c)&n;   1) Merging of the driver-developments of Klaus Kudielka and Michael Lang &n;      in order to get a optimum and unified driver-release for the &n;      IBM-SCSI-Subsystem-Adapter(s).&n;         For people, using the Kernel-release &gt;=2.1.0, module-support should &n;      be no problem. For users, running under &lt;2.1.0, module-support may not &n;      work, because the methods have changed between 2.0.x and 2.1.x.&n;   2) Added some more effective statistics for /proc-output.&n;   3) Change typecasting at necessary points from (unsigned long) to&n;      virt_to_bus().&n;   4) Included #if... at special points to have specific adaption of the&n;      driver to kernel 2.0.x and 2.1.x. It should therefore also run with &n;      later releases.&n;   5) Magneto-Optical drives and medium-changers are also recognized, now.&n;      Therefore, we have a completely gapfree recognition of all SCSI-&n;      device-types, that are known by Linux up to kernel 2.1.31.&n;   6) The flag SCSI_IBMMCA_DEV_RESET has been inserted. If it is set within&n;      the configuration, each connected SCSI-device will get a reset command&n;      during boottime. This can be necessary for some special SCSI-devices.&n;      This flag should be included in Config.in.&n;      (See also the new Config.in file.)&n;   Probable next improvement: bad disk handler.&n;   - Michael Lang&n; &n;   Sept 14 1997: (v3.0c)&n;   1) Some debugging and speed optimization applied.&n;   - Michael Lang&n;&n;   Dec 15, 1997&n;    - chrisb@truespectra.com&n;    - made the front panel display thingy optional, specified from the&n;    command-line via ibmmcascsi=display.  Along the lines of the /LED&n;    option for the OS/2 driver.&n;    - fixed small bug in the LED display that would hang some machines.&n;    - reversed ordering of the drives (using the&n;    IBMMCA_SCSI_ORDER_STANDARD define).  This is necessary for two main&n;    reasons:&n;&t;- users who&squot;ve already installed Linux won&squot;t be screwed.  Keep&n;&t;in mind that not everyone is a kernel hacker.&n;&t;- be consistent with the BIOS ordering of the drives.  In the&n;&t;BIOS, id 6 is C:, id 0 might be D:.  With this scheme, they&squot;d be&n;&t;backwards.  This confuses the crap out of those heathens who&squot;ve&n;&t;got a impure Linux installation (which, &lt;wince&gt;, I&squot;m one of).&n;    This whole problem arises because IBM is actually non-standard with&n;    the id to BIOS mappings.  You&squot;ll find, in fdomain.c, a similar&n;    comment about a few FD BIOS revisions.  The Linux (and apparently&n;    industry) standard is that C: maps to scsi id (0,0).  Let&squot;s stick&n;    with that standard.&n;    - Since this is technically a branch of my own, I changed the&n;    version number to 3.0e-cpb.&n;&n;   Jan 17, 1998: (v3.0f)&n;   1) Addition of some statistical info for /proc in proc_info.&n;   2) Taking care of the SCSI-assignment problem, dealed by Chris at Dec 15&n;      1997. In fact, IBM is right, concerning the assignment of SCSI-devices &n;      to driveletters. It is conform to the ANSI-definition of the SCSI-&n;      standard to assign drive C: to SCSI-id 6, because it is the highest&n;      hardware priority after the hostadapter (that has still today by&n;      default everywhere id 7). Also realtime-operating systems that I use, &n;      like LynxOS and OS9, which are quite industrial systems use top-down&n;      numbering of the harddisks, that is also starting at id 6. Now, one&n;      sits a bit between two chairs. On one hand side, using the define&n;      IBMMCA_SCSI_ORDER_STANDARD makes Linux assigning disks conform to&n;      the IBM- and ANSI-SCSI-standard and keeps this driver downward&n;      compatible to older releases, on the other hand side, people is quite&n;      habituated in believing that C: is assigned to (0,0) and much other&n;      SCSI-BIOS do so. Therefore, I moved the IBMMCA_SCSI_ORDER_STANDARD &n;      define out of the driver and put it into Config.in as subitem of &n;      &squot;IBM SCSI support&squot;. A help, added to Documentation/Configure.help &n;      explains the differences between saying &squot;y&squot; or &squot;n&squot; to the user, when &n;      IBMMCA_SCSI_ORDER_STANDARD prompts, so the ordinary user is enabled to &n;      choose the way of assignment, depending on his own situation and gusto.&n;   3) Adapted SCSI_IBMMCA_DEV_RESET to the local naming convention, so it is&n;      now called IBMMCA_SCSI_DEV_RESET.&n;   4) Optimization of proc_info and its subroutines.&n;   5) Added more in-source-comments and extended the driver description by&n;      some explanation about the SCSI-device-assignment problem.&n;   - Michael Lang&n;   &n;   Jan 18, 1998: (v3.0g)&n;   1) Correcting names to be absolutely conform to the later 2.1.x releases.&n;      This is necessary for &n;            IBMMCA_SCSI_DEV_RESET -&gt; CONFIG_IBMMCA_SCSI_DEV_RESET&n;            IBMMCA_SCSI_ORDER_STANDARD -&gt; CONFIG_IBMMCA_SCSI_ORDER_STANDARD&n;   - Michael Lang&n;&n;&t;TODO:&n; &n;&t;- It seems that the handling of bad disks is really bad -&n;&t;  non-existent, in fact.&n;        - More testing of the full driver-controlled dynamical ldn &n;          (re)mapping for up to 56 SCSI-devices.&n;        - Support more SCSI-device-types, if Linux defines more.&n;        - Support more of the SCSI-command set.&n;&t;- Support some of the caching abilities, particularly Read Prefetch.&n;&t;  This fetches data into the cache, which later gets hit by the&n;&t;  regular Read Data.&n;        - Abort and Reset functions still slightly buggy. Especially when&n;          floppydisk(!) operations report errors.&n;&n;******************************************************************************/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/head.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/mca.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/spinlock.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;ibmmca.h&quot;
macro_line|#include &lt;linux/config.h&gt;&t;&t;/* for CONFIG_SCSI_IBMMCA etc. */
multiline_comment|/*--------------------------------------------------------------------*/
multiline_comment|/* current version of this driver-source: */
DECL|macro|IBMMCA_SCSI_DRIVER_VERSION
mdefine_line|#define IBMMCA_SCSI_DRIVER_VERSION &quot;3.0f&quot;
multiline_comment|/* use standard Linux ordering, where C: maps to (0,0), unlike the IBM&n;standard which seems to like C: =&gt; (6,0) */
multiline_comment|/* #define IBMMCA_SCSI_ORDER_STANDARD is defined/undefined in Config.in&n; * now, while configuring the kernel. */
multiline_comment|/*&n;   Driver Description&n;&n;   (A) Subsystem Detection&n;   This is done in the ibmmca_detect() function and is easy, since&n;   the information about MCA integrated subsystems and plug-in &n;   adapters is readily available in structure *mca_info.&n;&n;   (B) Physical Units, Logical Units, and Logical Devices&n;   There can be up to 56 devices on SCSI bus (besides the adapter):&n;   there are up to 7 &quot;physical units&quot; (each identified by physical unit &n;   number or pun, also called the scsi id, this is the number you select&n;   with hardware jumpers), and each physical unit can have up to 8 &n;   &quot;logical units&quot; (each identified by logical unit number, or lun, &n;   between 0 and 7). &n;&n;   Typically the adapter has pun=7, so puns of other physical units&n;   are between 0 and 6. Almost all physical units have only one   &n;   logical unit, with lun=0. A CD-ROM jukebox would be an example of &n;   a physical unit with more than one logical unit.&n;&n;   The embedded microprocessor of IBM SCSI subsystem hides the complex&n;   two-dimensional (pun,lun) organization from the operating system.&n;   When the machine is powered-up (or rebooted, I am not sure), the &n;   embedded microprocessor checks, on it own, all 56 possible (pun,lun) &n;   combinations, and first 15 devices found are assigned into a &n;   one-dimensional array of so-called &quot;logical devices&quot;, identified by &n;   &quot;logical device numbers&quot; or ldn. The last ldn=15 is reserved for &n;   the subsystem itself. &n;&n;   One consequence of information hiding is that the real (pun,lun)    &n;   numbers are also hidden. Therefore this driver takes the following&n;   approach: It checks the ldn&squot;s (0 to 6) to find out which ldn&squot;s&n;   have devices assigned. This is done by function check_devices() and&n;   device_exists(). The interrupt handler has a special paragraph of code&n;   (see local_checking_phase_flag) to assist in the checking. Assume, for&n;   example, that three logical devices were found assigned at ldn 0, 1, 2.&n;   These are presented to the upper layer of Linux SCSI driver&n;   as devices with bogus (pun, lun) equal to (0,0), (1,0), (2,0). &n;   On the other hand, if the upper layer issues a command to device&n;   say (4,0), this driver returns DID_NO_CONNECT error.&n;&n;   That last paragraph is no longer correct, but is left for&n;   historical purposes.  It limited the number of devices to 7, far&n;   fewer than the 15 that it could use.  Now it just maps&n;   ldn -&gt; (ldn/8,ldn%8).  We end up with a real mishmash of puns&n;   and luns, but it all seems to work. - Chris Beaurgard&n;&n;   And that last paragraph is also no longer correct.  It uses a&n;   slightly more complex mapping that will always map hard disks to&n;   (x,0), for some x, and consecutive none disk devices will usually&n;   share puns.&n; &n;   Again, the last paragraphs are no longer correct. Now, the physical&n;   SCSI-devices on the SCSI-bus are probed via immediate_assign- and&n;   device_inquiry-commands. This delivers a exact map of the physical&n;   SCSI-world that is now stored in the get_scsi[][]-array. This means,&n;   that the once hidden pun,lun assignment is now known to this driver.&n;   It no longer believes in default-settings of the subsystem and maps all&n;   ldns to existing pun,lun by foot. This assures full control of the ldn&n;   mapping and allows dynamical remapping of ldns to different pun,lun, if&n;   there are more SCSI-devices installed than ldns available (n&gt;15). The&n;   ldns from 0 to 6 get &squot;hardwired&squot; by this driver to puns 0 to 7 at lun=0,&n;   excluding the pun of the subsystem. This assures, that at least simple &n;   SCSI-installations have optimum access-speed and are not touched by&n;   dynamical remapping. The ldns 7 to 14 are put to existing devices with &n;   lun&gt;0 or to non-existing devices, in order to satisfy the subsystem, if &n;   there are less than 15 SCSI-devices connected. In the case of more than 15 &n;   devices, the dynamical mapping goes active. If the get_scsi[][] reports a &n;   device to be existant, but it has no ldn assigned, it gets a ldn out of 7 &n;   to 14. The numbers are assigned in cyclic order. Therefore it takes 8 &n;   dynamical assignments on SCSI-devices, until a certain device &n;   looses its ldn again. This assures, that dynamical remapping is avoided &n;   during intense I/O between up to eight SCSI-devices (means pun,lun &n;   combinations). A further advantage of this method is, that people who&n;   build their kernel without probing on all luns will get what they expect.&n; &n;   IMPORTANT: Because of the now correct recognition of physical pun,lun, and &n;   their report to mid-level- and higher-level-drivers, the new reported puns&n;   can be different from the old, faked puns. Therefore, Linux will eventually&n;   change /dev/sdXXX assignments and prompt you for corrupted superblock&n;   repair on boottime. In this case DO NOT PANIC, YOUR DISKS ARE STILL OK!!!&n;   You have to reboot (CTRL-D) with a old kernel and set the /etc/fstab-file&n;   entries right. After that, the system should come up as errorfree as before.&n;   If your boot-partition is not coming up, also edit the /etc/lilo.conf-file&n;   in a Linux session booted on old kernel and run lilo before reboot. Check&n;   lilo.conf anyway to get boot on other partitions with foreign OSes right&n;   again. &n; &n;   The problem is, that Linux does not assign the SCSI-devices in the&n;   way as described in the ANSI-SCSI-standard. Linux assigns /dev/sda to &n;   the device with at minimum id 0. But the first drive should be at id 6,&n;   because for historical reasons, drive at id 6 has, by hardware, the highest&n;   priority and a drive at id 0 the lowest. IBM was one of the rare producers,&n;   where the BIOS assigns drives belonging to the ANSI-SCSI-standard. Most &n;   other producers&squot; BIOS does not (I think even Adaptec-BIOS). The &n;   IBMMCA_SCSI_ORDER_STANDARD flag helps to be able to choose the preferred &n;   way of SCSI-device-assignment. Defining this flag would result in Linux &n;   determining the devices in the same order as DOS and OS/2 does on your &n;   MCA-machine. This is also standard on most industrial computers. Leaving &n;   this flag undefined will get your devices ordered in the default way of &n;   Linux. See also the remarks of Chris Beauregard from Dec 15, 1997 and&n;   the followups.&n;   &n;   (C) Regular Processing &n;   Only three functions get involved: ibmmca_queuecommand(), issue_cmd(),&n;   and interrupt_handler().&n;&n;   The upper layer issues a scsi command by calling function &n;   ibmmca_queuecommand(). This function fills a &quot;subsystem control block&quot;&n;   (scb) and calls a local function issue_cmd(), which writes a scb &n;   command into subsystem I/O ports. Once the scb command is carried out, &n;   interrupt_handler() is invoked. If a device is determined to be existant&n;   and it has not assigned any ldn, it gets one dynamically.&n;&n;   (D) Abort, Reset.&n;   These are implemented with busy waiting for interrupt to arrive.&n;   The abort does not worked well for me, so I instead call the &n;   ibmmca_reset() from the ibmmca_abort() function.&n;&n;   (E) Disk Geometry&n;   The ibmmca_biosparams() function should return same disk geometry &n;   as bios. This is needed for fdisk, etc. The returned geometry is &n;   certainly correct for disk smaller than 1 gigabyte, but I am not &n;   100% sure that it is correct for larger disks.&n;&n;   (F) Kernel Boot Option &n;   The function ibmmca_scsi_setup() is called if option ibmmcascsi=n &n;   is passed to the kernel. See file linux/init/main.c for details.&n;   &n;   (G) Driver Module Support&n;   Is implemented and tested by K. Kudielka. This could probably not work&n;   on kernels &lt;2.1.0.&n;  &n;   (H) Multiple Hostadapter Support&n;   This driver supports up to eight interfaces of type IBM-SCSI-Subsystem. &n;   Integrated-, and MCA-adapters are automatically recognized. Unrecognizable&n;   IBM-SCSI-Subsystem interfaces can be specified as kernel-parameters.&n; &n;   (I) /proc-Filesystem Information&n;   Information about the driver condition is given in &n;   /proc/scsi/ibmmca/&lt;host_no&gt;. ibmmca_proc_info provides this information.&n; */
multiline_comment|/*--------------------------------------------------------------------*/
multiline_comment|/* Here are the values and structures specific for the subsystem. &n; * The source of information is &quot;Update for the PS/2 Hardware &n; * Interface Technical Reference, Common Interfaces&quot;, September 1991, &n; * part number 04G3281, available in the U.S. for $21.75 at &n; * 1-800-IBM-PCTB, elsewhere call your local friendly IBM &n; * representative.&n; * In addition to SCSI subsystem, this update contains fairly detailed &n; * (at hardware register level) sections on diskette  controller,&n; * keyboard controller, serial port controller, VGA, and XGA.&n; *&n; * Additional information from &quot;Personal System/2 Micro Channel SCSI&n; * Adapter with Cache Technical Reference&quot;, March 1990, PN 68X2365,&n; * probably available from the same source (or possibly found buried&n; * in officemates desk).&n; *&n; * Further literature/program-sources referred for this driver:&n; * &n; * Friedhelm Schmidt, &quot;SCSI-Bus und IDE-Schnittstelle - Moderne Peripherie-&n; * Schnittstellen: Hardware, Protokollbeschreibung und Anwendung&quot;, 2. Aufl.&n; * Addison Wesley, 1996.&n; * &n; * Michael K. Johnson, &quot;The Linux Kernel Hackers&squot; Guide&quot;, Version 0.6, Chapel&n; * Hill - North Carolina, 1995&n; * &n; * Andreas Kaiser, &quot;SCSI TAPE BACKUP for OS/2 2.0&quot;, Version 2.12, Stuttgart&n; * 1993&n; */
multiline_comment|/*--------------------------------------------------------------------*/
multiline_comment|/* driver configuration */
DECL|macro|IM_MAX_HOSTS
mdefine_line|#define IM_MAX_HOSTS      8             /* maximum number of host adapters */
DECL|macro|IM_RESET_DELAY
mdefine_line|#define IM_RESET_DELAY    10            /* seconds allowed for a reset */
multiline_comment|/* driver debugging - #undef all for normal operation */
multiline_comment|/* if defined: count interrupts and ignore this special one: */
DECL|macro|IM_DEBUG_TIMEOUT
macro_line|#undef  IM_DEBUG_TIMEOUT  50            
multiline_comment|/* verbose interrupt: */
DECL|macro|IM_DEBUG_INT
macro_line|#undef  IM_DEBUG_INT                   
multiline_comment|/* verbose queuecommand: */
DECL|macro|IM_DEBUG_CMD
macro_line|#undef  IM_DEBUG_CMD    
multiline_comment|/* verbose queucommand for specific SCSI-device type: */
DECL|macro|IM_DEBUG_CMD_SPEC_DEV
macro_line|#undef  IM_DEBUG_CMD_SPEC_DEV          
multiline_comment|/* verbose device probing */
DECL|macro|IM_DEBUG_PROBE
macro_line|#undef  IM_DEBUG_PROBE
multiline_comment|/* device type that shall be displayed on syslog (only during debugging): */
DECL|macro|IM_DEBUG_CMD_DEVICE
mdefine_line|#define IM_DEBUG_CMD_DEVICE   TYPE_TAPE
multiline_comment|/* relative addresses of hardware registers on a subsystem */
DECL|macro|IM_CMD_REG
mdefine_line|#define IM_CMD_REG   (shpnt-&gt;io_port)   /*Command Interface, (4 bytes long) */
DECL|macro|IM_ATTN_REG
mdefine_line|#define IM_ATTN_REG  (shpnt-&gt;io_port+4) /*Attention (1 byte) */
DECL|macro|IM_CTR_REG
mdefine_line|#define IM_CTR_REG   (shpnt-&gt;io_port+5) /*Basic Control (1 byte) */
DECL|macro|IM_INTR_REG
mdefine_line|#define IM_INTR_REG  (shpnt-&gt;io_port+6) /*Interrupt Status (1 byte, r/o) */
DECL|macro|IM_STAT_REG
mdefine_line|#define IM_STAT_REG  (shpnt-&gt;io_port+7) /*Basic Status (1 byte, read only) */
multiline_comment|/* basic I/O-port of first adapter */
DECL|macro|IM_IO_PORT
mdefine_line|#define IM_IO_PORT   0x3540
multiline_comment|/* maximum number of hosts that can be found */
DECL|macro|IM_N_IO_PORT
mdefine_line|#define IM_N_IO_PORT 8
multiline_comment|/*requests going into the upper nibble of the Attention register */
multiline_comment|/*note: the lower nibble specifies the device(0-14), or subsystem(15) */
DECL|macro|IM_IMM_CMD
mdefine_line|#define IM_IMM_CMD   0x10&t;/*immediate command */
DECL|macro|IM_SCB
mdefine_line|#define IM_SCB       0x30&t;/*Subsystem Control Block command */
DECL|macro|IM_LONG_SCB
mdefine_line|#define IM_LONG_SCB  0x40&t;/*long Subsystem Control Block command */
DECL|macro|IM_EOI
mdefine_line|#define IM_EOI       0xe0&t;/*end-of-interrupt request */
multiline_comment|/*values for bits 7,1,0 of Basic Control reg. (bits 6-2 reserved) */
DECL|macro|IM_HW_RESET
mdefine_line|#define IM_HW_RESET     0x80&t;/*hardware reset */
DECL|macro|IM_ENABLE_DMA
mdefine_line|#define IM_ENABLE_DMA   0x02&t;/*enable subsystem&squot;s busmaster DMA */
DECL|macro|IM_ENABLE_INTR
mdefine_line|#define IM_ENABLE_INTR  0x01&t;/*enable interrupts to the system */
multiline_comment|/*to interpret the upper nibble of Interrupt Status register */
multiline_comment|/*note: the lower nibble specifies the device(0-14), or subsystem(15) */
DECL|macro|IM_SCB_CMD_COMPLETED
mdefine_line|#define IM_SCB_CMD_COMPLETED               0x10
DECL|macro|IM_SCB_CMD_COMPLETED_WITH_RETRIES
mdefine_line|#define IM_SCB_CMD_COMPLETED_WITH_RETRIES  0x50
DECL|macro|IM_ADAPTER_HW_FAILURE
mdefine_line|#define IM_ADAPTER_HW_FAILURE              0x70
DECL|macro|IM_IMMEDIATE_CMD_COMPLETED
mdefine_line|#define IM_IMMEDIATE_CMD_COMPLETED         0xa0
DECL|macro|IM_CMD_COMPLETED_WITH_FAILURE
mdefine_line|#define IM_CMD_COMPLETED_WITH_FAILURE      0xc0
DECL|macro|IM_CMD_ERROR
mdefine_line|#define IM_CMD_ERROR                       0xe0
DECL|macro|IM_SOFTWARE_SEQUENCING_ERROR
mdefine_line|#define IM_SOFTWARE_SEQUENCING_ERROR       0xf0
multiline_comment|/*to interpret bits 3-0 of Basic Status register (bits 7-4 reserved) */
DECL|macro|IM_CMD_REG_FULL
mdefine_line|#define IM_CMD_REG_FULL   0x08
DECL|macro|IM_CMD_REG_EMPTY
mdefine_line|#define IM_CMD_REG_EMPTY  0x04
DECL|macro|IM_INTR_REQUEST
mdefine_line|#define IM_INTR_REQUEST   0x02
DECL|macro|IM_BUSY
mdefine_line|#define IM_BUSY           0x01
multiline_comment|/*immediate commands (word written into low 2 bytes of command reg) */
DECL|macro|IM_RESET_IMM_CMD
mdefine_line|#define IM_RESET_IMM_CMD        0x0400
DECL|macro|IM_FEATURE_CTR_IMM_CMD
mdefine_line|#define IM_FEATURE_CTR_IMM_CMD  0x040c
DECL|macro|IM_DMA_PACING_IMM_CMD
mdefine_line|#define IM_DMA_PACING_IMM_CMD   0x040d
DECL|macro|IM_ASSIGN_IMM_CMD
mdefine_line|#define IM_ASSIGN_IMM_CMD       0x040e
DECL|macro|IM_ABORT_IMM_CMD
mdefine_line|#define IM_ABORT_IMM_CMD        0x040f
DECL|macro|IM_FORMAT_PREP_IMM_CMD
mdefine_line|#define IM_FORMAT_PREP_IMM_CMD  0x0417
multiline_comment|/*SCB (Subsystem Control Block) structure */
DECL|struct|im_scb
r_struct
id|im_scb
(brace
DECL|member|command
r_int
r_int
id|command
suffix:semicolon
multiline_comment|/*command word (read, etc.) */
DECL|member|enable
r_int
r_int
id|enable
suffix:semicolon
multiline_comment|/*enable word, modifies cmd */
r_union
(brace
DECL|member|log_blk_adr
r_int
r_int
id|log_blk_adr
suffix:semicolon
multiline_comment|/*block address on SCSI device */
DECL|member|scsi_cmd_length
r_int
r_char
id|scsi_cmd_length
suffix:semicolon
multiline_comment|/*6,10,12, for other scsi cmd */
)brace
DECL|member|u1
id|u1
suffix:semicolon
DECL|member|sys_buf_adr
r_int
r_int
id|sys_buf_adr
suffix:semicolon
multiline_comment|/*physical system memory adr */
DECL|member|sys_buf_length
r_int
r_int
id|sys_buf_length
suffix:semicolon
multiline_comment|/*size of sys mem buffer */
DECL|member|tsb_adr
r_int
r_int
id|tsb_adr
suffix:semicolon
multiline_comment|/*Termination Status Block adr */
DECL|member|scb_chain_adr
r_int
r_int
id|scb_chain_adr
suffix:semicolon
multiline_comment|/*optional SCB chain address */
r_union
(brace
r_struct
(brace
DECL|member|count
r_int
r_int
id|count
suffix:semicolon
multiline_comment|/*block count, on SCSI device */
DECL|member|length
r_int
r_int
id|length
suffix:semicolon
multiline_comment|/*block length, on SCSI device */
)brace
DECL|member|blk
id|blk
suffix:semicolon
DECL|member|scsi_command
r_int
r_char
id|scsi_command
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/*other scsi command */
)brace
DECL|member|u2
id|u2
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*structure scatter-gather element (for list of system memory areas) */
DECL|struct|im_sge
r_struct
id|im_sge
(brace
DECL|member|address
r_void
op_star
id|address
suffix:semicolon
DECL|member|byte_length
r_int
r_int
id|byte_length
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*values for SCB command word */
DECL|macro|IM_NO_SYNCHRONOUS
mdefine_line|#define IM_NO_SYNCHRONOUS      0x0040&t;/*flag for any command */
DECL|macro|IM_NO_DISCONNECT
mdefine_line|#define IM_NO_DISCONNECT       0x0080&t;/*flag for any command */
DECL|macro|IM_READ_DATA_CMD
mdefine_line|#define IM_READ_DATA_CMD       0x1c01
DECL|macro|IM_WRITE_DATA_CMD
mdefine_line|#define IM_WRITE_DATA_CMD      0x1c02
DECL|macro|IM_READ_VERIFY_CMD
mdefine_line|#define IM_READ_VERIFY_CMD     0x1c03
DECL|macro|IM_WRITE_VERIFY_CMD
mdefine_line|#define IM_WRITE_VERIFY_CMD    0x1c04
DECL|macro|IM_REQUEST_SENSE_CMD
mdefine_line|#define IM_REQUEST_SENSE_CMD   0x1c08
DECL|macro|IM_READ_CAPACITY_CMD
mdefine_line|#define IM_READ_CAPACITY_CMD   0x1c09
DECL|macro|IM_DEVICE_INQUIRY_CMD
mdefine_line|#define IM_DEVICE_INQUIRY_CMD  0x1c0b
DECL|macro|IM_OTHER_SCSI_CMD_CMD
mdefine_line|#define IM_OTHER_SCSI_CMD_CMD  0x241f
multiline_comment|/* unused, but supported, SCB commands */
DECL|macro|IM_GET_COMMAND_COMPLETE_STATUS_CMD
mdefine_line|#define IM_GET_COMMAND_COMPLETE_STATUS_CMD   0x1c07 /* command status */
DECL|macro|IM_GET_POS_INFO_CMD
mdefine_line|#define IM_GET_POS_INFO_CMD                  0x1c0a /* returns neat stuff */
DECL|macro|IM_READ_PREFETCH_CMD
mdefine_line|#define IM_READ_PREFETCH_CMD                 0x1c31 /* caching controller only */
DECL|macro|IM_FOMAT_UNIT_CMD
mdefine_line|#define IM_FOMAT_UNIT_CMD                    0x1c16 /* format unit */
DECL|macro|IM_REASSIGN_BLOCK_CMD
mdefine_line|#define IM_REASSIGN_BLOCK_CMD                0x1c18 /* in case of error */
multiline_comment|/*values to set bits in the enable word of SCB */
DECL|macro|IM_READ_CONTROL
mdefine_line|#define IM_READ_CONTROL              0x8000
DECL|macro|IM_REPORT_TSB_ONLY_ON_ERROR
mdefine_line|#define IM_REPORT_TSB_ONLY_ON_ERROR  0x4000
DECL|macro|IM_RETRY_ENABLE
mdefine_line|#define IM_RETRY_ENABLE              0x2000
DECL|macro|IM_POINTER_TO_LIST
mdefine_line|#define IM_POINTER_TO_LIST           0x1000
DECL|macro|IM_SUPRESS_EXCEPTION_SHORT
mdefine_line|#define IM_SUPRESS_EXCEPTION_SHORT   0x0400
DECL|macro|IM_CHAIN_ON_NO_ERROR
mdefine_line|#define IM_CHAIN_ON_NO_ERROR         0x0001
multiline_comment|/*TSB (Termination Status Block) structure */
DECL|struct|im_tsb
r_struct
id|im_tsb
(brace
DECL|member|end_status
r_int
r_int
id|end_status
suffix:semicolon
DECL|member|reserved1
r_int
r_int
id|reserved1
suffix:semicolon
DECL|member|residual_byte_count
r_int
r_int
id|residual_byte_count
suffix:semicolon
DECL|member|sg_list_element_adr
r_int
r_int
id|sg_list_element_adr
suffix:semicolon
DECL|member|status_length
r_int
r_int
id|status_length
suffix:semicolon
DECL|member|dev_status
r_int
r_char
id|dev_status
suffix:semicolon
DECL|member|cmd_status
r_int
r_char
id|cmd_status
suffix:semicolon
DECL|member|dev_error
r_int
r_char
id|dev_error
suffix:semicolon
DECL|member|cmd_error
r_int
r_char
id|cmd_error
suffix:semicolon
DECL|member|reserved2
r_int
r_int
id|reserved2
suffix:semicolon
DECL|member|reserved3
r_int
r_int
id|reserved3
suffix:semicolon
DECL|member|low_of_last_scb_adr
r_int
r_int
id|low_of_last_scb_adr
suffix:semicolon
DECL|member|high_of_last_scb_adr
r_int
r_int
id|high_of_last_scb_adr
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*subsystem uses interrupt request level 14 */
DECL|macro|IM_IRQ
mdefine_line|#define IM_IRQ  14
multiline_comment|/*--------------------------------------------------------------------*/
multiline_comment|/*&n;&t;The model 95 doesn&squot;t have a standard activity light.  Instead it&n;&t;has a row of LEDs on the front.  We use the last one as the activity&n;&t;indicator if we think we&squot;re on a model 95.  I suspect the model id&n;&t;check will be either too narrow or too general, and some machines&n;&t;won&squot;t have an activity indicator.  Oh well...&n;&n;&t;The regular PS/2 disk led is turned on/off by bits 6,7 of system&n;&t;control port.&n;*/
multiline_comment|/* LED display-port (actually, last LED on display) */
DECL|macro|MOD95_LED_PORT
mdefine_line|#define MOD95_LED_PORT&t;   0x108
multiline_comment|/* system-control-register of PS/2s with diskindicator */
DECL|macro|PS2_SYS_CTR
mdefine_line|#define PS2_SYS_CTR        0x92
multiline_comment|/* The SCSI-ID(!) of the accessed SCSI-device is shown on PS/2-95 machines&squot; LED&n;   displays. ldn is no longer displayed here, because the ldn mapping is now &n;   done dynamically and the ldn &lt;-&gt; pun,lun maps can be looked-up at boottime &n;   or during uptime in /proc/scsi/ibmmca/&lt;host_no&gt; in case of trouble, &n;   interest, debugging or just for having fun. The left number gives the&n;   host-adapter number and the right shows the accessed SCSI-ID. */
multiline_comment|/* use_display is set by the ibmmcascsi=display command line arg */
DECL|variable|use_display
r_static
r_int
id|use_display
op_assign
l_int|0
suffix:semicolon
DECL|macro|PS2_DISK_LED_ON
mdefine_line|#define PS2_DISK_LED_ON(ad,id) {&bslash;&n;&t;if( use_display ) { outb((char)(id+48), MOD95_LED_PORT ); &bslash;&n;        outb((char)(ad+48), MOD95_LED_PORT+1); } &bslash;&n;&t;else outb(inb(PS2_SYS_CTR) | 0xc0, PS2_SYS_CTR); &bslash;&n;}
multiline_comment|/* bug fixed, Dec 15, 1997, where | was replaced by &amp; here */
DECL|macro|PS2_DISK_LED_OFF
mdefine_line|#define PS2_DISK_LED_OFF() {&bslash;&n;&t;if( use_display ) { outb( &squot; &squot;, MOD95_LED_PORT ); &bslash;&n;        outb(&squot; &squot;, MOD95_LED_PORT+1); } &bslash;&n;&t;else outb(inb(PS2_SYS_CTR) &amp; 0x3f, PS2_SYS_CTR); &bslash;&n;}
multiline_comment|/*--------------------------------------------------------------------*/
multiline_comment|/*list of supported subsystems */
DECL|struct|subsys_list_struct
r_struct
id|subsys_list_struct
(brace
DECL|member|mca_id
r_int
r_int
id|mca_id
suffix:semicolon
DECL|member|description
r_char
op_star
id|description
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* List of possible IBM-SCSI-adapters */
DECL|variable|subsys_list
r_struct
id|subsys_list_struct
id|subsys_list
(braket
)braket
op_assign
(brace
(brace
l_int|0x8efc
comma
l_string|&quot;IBM Fast SCSI-2 Adapter&quot;
)brace
comma
(brace
l_int|0x8efd
comma
l_string|&quot;IBM 7568 Industrial Computer SCSI Adapter w/cache&quot;
)brace
comma
(brace
l_int|0x8ef8
comma
l_string|&quot;IBM Expansion Unit SCSI Controller&quot;
)brace
comma
(brace
l_int|0x8eff
comma
l_string|&quot;IBM SCSI Adapter w/Cache&quot;
)brace
comma
(brace
l_int|0x8efe
comma
l_string|&quot;IBM SCSI Adapter&quot;
)brace
comma
)brace
suffix:semicolon
multiline_comment|/*for /proc filesystem */
DECL|variable|proc_scsi_ibmmca
r_struct
id|proc_dir_entry
id|proc_scsi_ibmmca
op_assign
(brace
id|PROC_SCSI_IBMMCA
comma
l_int|6
comma
l_string|&quot;ibmmca&quot;
comma
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
l_int|2
)brace
suffix:semicolon
multiline_comment|/* Max number of logical devices (can be up from 0 to 14).  15 is the address&n;of the adapter itself. */
DECL|macro|MAX_LOG_DEV
mdefine_line|#define MAX_LOG_DEV  15
multiline_comment|/*local data for a logical device */
DECL|struct|logical_device
r_struct
id|logical_device
(brace
DECL|member|scb
r_struct
id|im_scb
id|scb
suffix:semicolon
multiline_comment|/* SCSI-subsystem-control-block structure */
DECL|member|tsb
r_struct
id|im_tsb
id|tsb
suffix:semicolon
DECL|member|sge
r_struct
id|im_sge
id|sge
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|cmd
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
multiline_comment|/* SCSI-command that is currently in progress */
DECL|member|device_type
r_int
id|device_type
suffix:semicolon
multiline_comment|/* type of the SCSI-device. See include/scsi/scsi.h&n;&t;&t;        for interpretation of the possible values */
DECL|member|block_length
r_int
id|block_length
suffix:semicolon
multiline_comment|/* blocksize of a particular logical SCSI-device */
)brace
suffix:semicolon
multiline_comment|/* statistics of the driver during operations (for proc_info) */
DECL|struct|Driver_Statistics
r_struct
id|Driver_Statistics
(brace
multiline_comment|/* SCSI statistics on the adapter */
DECL|member|ldn_access
r_int
id|ldn_access
(braket
id|MAX_LOG_DEV
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* total accesses on a ldn */
DECL|member|ldn_read_access
r_int
id|ldn_read_access
(braket
id|MAX_LOG_DEV
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* total read-access on a ldn */
DECL|member|ldn_write_access
r_int
id|ldn_write_access
(braket
id|MAX_LOG_DEV
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* total write-access on a ldn */
DECL|member|ldn_inquiry_access
r_int
id|ldn_inquiry_access
(braket
id|MAX_LOG_DEV
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* total inquiries on a ldn */
DECL|member|ldn_modeselect_access
r_int
id|ldn_modeselect_access
(braket
id|MAX_LOG_DEV
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* total mode selects on ldn */
DECL|member|total_accesses
r_int
id|total_accesses
suffix:semicolon
multiline_comment|/* total accesses on all ldns */
DECL|member|total_interrupts
r_int
id|total_interrupts
suffix:semicolon
multiline_comment|/* total interrupts (should be&n;&t;&t;&t;&t;&t;&t;same as total_accesses) */
multiline_comment|/* dynamical assignment statistics */
DECL|member|total_scsi_devices
r_int
id|total_scsi_devices
suffix:semicolon
multiline_comment|/* number of physical pun,lun */
DECL|member|dyn_flag
r_int
id|dyn_flag
suffix:semicolon
multiline_comment|/* flag showing dynamical mode */
DECL|member|dynamical_assignments
r_int
id|dynamical_assignments
suffix:semicolon
multiline_comment|/* number of remappings of ldns */
DECL|member|ldn_assignments
r_int
id|ldn_assignments
(braket
id|MAX_LOG_DEV
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* number of remappings of each&n;&t;&t;&t;&t;&t;        ldn */
)brace
suffix:semicolon
multiline_comment|/* data structure for each host adapter */
DECL|struct|ibmmca_hostdata
r_struct
id|ibmmca_hostdata
(brace
multiline_comment|/* array of logical devices: */
DECL|member|_ld
r_struct
id|logical_device
id|_ld
(braket
id|MAX_LOG_DEV
)braket
suffix:semicolon
multiline_comment|/* array to convert (pun, lun) into logical device number: */
DECL|member|_get_ldn
r_int
r_char
id|_get_ldn
(braket
l_int|8
)braket
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/*array that contains the information about the physical SCSI-devices&n;   attached to this host adapter: */
DECL|member|_get_scsi
r_int
r_char
id|_get_scsi
(braket
l_int|8
)braket
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* used only when checking logical devices: */
DECL|member|_local_checking_phase_flag
r_int
id|_local_checking_phase_flag
suffix:semicolon
multiline_comment|/* report received interrupt: */
DECL|member|_got_interrupt
r_int
id|_got_interrupt
suffix:semicolon
multiline_comment|/* report termination-status of SCSI-command: */
DECL|member|_stat_result
r_int
id|_stat_result
suffix:semicolon
multiline_comment|/* reset status (used only when doing reset): */
DECL|member|_reset_status
r_int
id|_reset_status
suffix:semicolon
multiline_comment|/* code of the last SCSI command (needed for panic info): */
DECL|member|_last_scsi_command
r_int
id|_last_scsi_command
suffix:semicolon
multiline_comment|/* Counter that points on the next reassignable ldn for dynamical &n;   remapping. The default value is 7, that is the first reassignable &n;   number in the list at boottime: */
DECL|member|_next_ldn
r_int
id|_next_ldn
suffix:semicolon
multiline_comment|/* Statistics-structure for this IBM-SCSI-host: */
DECL|member|_IBM_DS
r_struct
id|Driver_Statistics
id|_IBM_DS
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* macros to access host data structure */
DECL|macro|HOSTDATA
mdefine_line|#define HOSTDATA(shpnt) ((struct ibmmca_hostdata *) shpnt-&gt;hostdata)
DECL|macro|subsystem_pun
mdefine_line|#define subsystem_pun (shpnt-&gt;this_id)
DECL|macro|ld
mdefine_line|#define ld (HOSTDATA(shpnt)-&gt;_ld)
DECL|macro|get_ldn
mdefine_line|#define get_ldn (HOSTDATA(shpnt)-&gt;_get_ldn)
DECL|macro|get_scsi
mdefine_line|#define get_scsi (HOSTDATA(shpnt)-&gt;_get_scsi)
DECL|macro|local_checking_phase_flag
mdefine_line|#define local_checking_phase_flag (HOSTDATA(shpnt)-&gt;_local_checking_phase_flag)
DECL|macro|got_interrupt
mdefine_line|#define got_interrupt (HOSTDATA(shpnt)-&gt;_got_interrupt)
DECL|macro|stat_result
mdefine_line|#define stat_result (HOSTDATA(shpnt)-&gt;_stat_result)
DECL|macro|reset_status
mdefine_line|#define reset_status (HOSTDATA(shpnt)-&gt;_reset_status)
DECL|macro|last_scsi_command
mdefine_line|#define last_scsi_command (HOSTDATA(shpnt)-&gt;_last_scsi_command)
DECL|macro|next_ldn
mdefine_line|#define next_ldn (HOSTDATA(shpnt)-&gt;_next_ldn)
DECL|macro|IBM_DS
mdefine_line|#define IBM_DS (HOSTDATA(shpnt)-&gt;_IBM_DS)
multiline_comment|/* Define a arbitrary number as subsystem-marker-type. This number is, as &n;   described in the ANSI-SCSI-standard, not occupied by other device-types. */
DECL|macro|TYPE_IBM_SCSI_ADAPTER
mdefine_line|#define TYPE_IBM_SCSI_ADAPTER   0x2F
multiline_comment|/* Define 0xFF for no device type, because this type is not defined within&n;   the ANSI-SCSI-standard, therefore, it can be used and should not cause any&n;   harm. */
DECL|macro|TYPE_NO_DEVICE
mdefine_line|#define TYPE_NO_DEVICE          0xFF
multiline_comment|/* define medium-changer. If this is not defined previously, e.g. Linux&n;   2.0.x, define this type here. */
macro_line|#ifndef TYPE_MEDIUM_CHANGER
DECL|macro|TYPE_MEDIUM_CHANGER
mdefine_line|#define TYPE_MEDIUM_CHANGER     0x08
macro_line|#endif
multiline_comment|/* define possible operations for the immediate_assign command */
DECL|macro|SET_LDN
mdefine_line|#define SET_LDN        0
DECL|macro|REMOVE_LDN
mdefine_line|#define REMOVE_LDN     1
multiline_comment|/* reset status flag contents */
DECL|macro|IM_RESET_NOT_IN_PROGRESS
mdefine_line|#define IM_RESET_NOT_IN_PROGRESS   0
DECL|macro|IM_RESET_IN_PROGRESS
mdefine_line|#define IM_RESET_IN_PROGRESS       1
DECL|macro|IM_RESET_FINISHED_OK
mdefine_line|#define IM_RESET_FINISHED_OK       2
DECL|macro|IM_RESET_FINISHED_FAIL
mdefine_line|#define IM_RESET_FINISHED_FAIL     3
multiline_comment|/*-----------------------------------------------------------------------*/
multiline_comment|/* if this is nonzero, ibmmcascsi option has been passed to the kernel */
DECL|variable|io_port
r_static
r_int
id|io_port
(braket
id|IM_MAX_HOSTS
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|scsi_id
r_static
r_int
id|scsi_id
(braket
id|IM_MAX_HOSTS
)braket
op_assign
(brace
l_int|7
comma
l_int|7
comma
l_int|7
comma
l_int|7
comma
l_int|7
comma
l_int|7
comma
l_int|7
comma
l_int|7
)brace
suffix:semicolon
multiline_comment|/* fill module-parameters only, when this define is present.&n;   (that is kernel version 2.1.x) */
macro_line|#ifdef MODULE_PARM
id|MODULE_PARM
c_func
(paren
id|io_port
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|IM_MAX_HOSTS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|scsi_id
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|IM_MAX_HOSTS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*counter of concurrent disk read/writes, to turn on/off disk led */
DECL|variable|disk_rw_in_progress
r_static
r_int
id|disk_rw_in_progress
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* host information */
DECL|variable|found
r_static
r_int
id|found
op_assign
l_int|0
suffix:semicolon
DECL|variable|hosts
r_static
r_struct
id|Scsi_Host
op_star
id|hosts
(braket
id|IM_MAX_HOSTS
op_plus
l_int|1
)braket
op_assign
(brace
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*-----------------------------------------------------------------------*/
multiline_comment|/*local functions in forward declaration */
r_static
r_void
id|interrupt_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|do_interrupt_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|issue_cmd
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_int
r_int
id|cmd_reg
comma
r_int
r_char
id|attn_reg
)paren
suffix:semicolon
r_static
r_void
id|internal_done
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|check_devices
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
suffix:semicolon
r_static
r_int
id|immediate_assign
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_int
r_int
id|pun
comma
r_int
r_int
id|lun
comma
r_int
r_int
id|ldn
comma
r_int
r_int
id|operation
)paren
suffix:semicolon
r_static
r_int
id|device_inquiry
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_int
id|ldn
comma
r_int
r_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_char
op_star
id|ti_p
c_func
(paren
r_int
id|value
)paren
suffix:semicolon
r_static
r_char
op_star
id|ti_l
c_func
(paren
r_int
id|value
)paren
suffix:semicolon
r_static
r_int
id|device_exists
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_int
id|ldn
comma
r_int
op_star
id|block_length
comma
r_int
op_star
id|device_type
)paren
suffix:semicolon
r_static
r_struct
id|Scsi_Host
op_star
id|ibmmca_register
c_func
(paren
id|Scsi_Host_Template
op_star
r_template
comma
r_int
id|port
comma
r_int
id|id
)paren
suffix:semicolon
multiline_comment|/* local functions needed for proc_info */
r_static
r_int
id|ldn_access_load
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_int
id|ldn
)paren
suffix:semicolon
r_static
r_int
id|ldn_access_total_read_write
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
suffix:semicolon
multiline_comment|/*--------------------------------------------------------------------*/
r_static
r_void
DECL|function|do_interrupt_handler
id|do_interrupt_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|interrupt_handler
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|interrupt_handler
id|interrupt_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_int
r_int
id|intr_reg
suffix:semicolon
r_int
r_int
id|cmd_result
suffix:semicolon
r_int
r_int
id|ldn
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* search for one adapter-response on shared interrupt */
r_do
id|shpnt
op_assign
id|hosts
(braket
id|i
op_increment
)braket
suffix:semicolon
r_while
c_loop
(paren
id|shpnt
op_logical_and
op_logical_neg
(paren
id|inb
c_func
(paren
id|IM_STAT_REG
)paren
op_amp
id|IM_INTR_REQUEST
)paren
)paren
suffix:semicolon
multiline_comment|/* return if some other device on this IRQ caused the interrupt */
r_if
c_cond
(paren
op_logical_neg
id|shpnt
)paren
r_return
suffix:semicolon
multiline_comment|/*get command result and logical device */
id|intr_reg
op_assign
id|inb
(paren
id|IM_INTR_REG
)paren
suffix:semicolon
id|cmd_result
op_assign
id|intr_reg
op_amp
l_int|0xf0
suffix:semicolon
id|ldn
op_assign
id|intr_reg
op_amp
l_int|0x0f
suffix:semicolon
multiline_comment|/*must wait for attention reg not busy, then send EOI to subsystem */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
(paren
id|IM_STAT_REG
)paren
op_amp
id|IM_BUSY
)paren
)paren
r_break
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|outb
(paren
id|IM_EOI
op_or
id|ldn
comma
id|IM_ATTN_REG
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*these should never happen (hw fails, or a local programming bug) */
r_if
c_cond
(paren
id|cmd_result
op_eq
id|IM_ADAPTER_HW_FAILURE
)paren
id|panic
(paren
l_string|&quot;IBM MCA SCSI: subsystem hardware failure. Last SCSI_CMD=0x%X. &bslash;n&quot;
comma
id|last_scsi_command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd_result
op_eq
id|IM_CMD_ERROR
)paren
id|panic
(paren
l_string|&quot;IBM MCA SCSI: command error. Last SCSI_CMD=0x%X. &bslash;n&quot;
comma
id|last_scsi_command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd_result
op_eq
id|IM_SOFTWARE_SEQUENCING_ERROR
)paren
id|panic
(paren
l_string|&quot;IBM MCA SCSI: software sequencing error. Last SCSI_CMD=0x%X. &bslash;n&quot;
comma
id|last_scsi_command
)paren
suffix:semicolon
multiline_comment|/* if no panic appeared, increase the interrupt-counter */
id|IBM_DS.total_interrupts
op_increment
suffix:semicolon
multiline_comment|/*only for local checking phase */
r_if
c_cond
(paren
id|local_checking_phase_flag
)paren
(brace
id|stat_result
op_assign
id|cmd_result
suffix:semicolon
id|got_interrupt
op_assign
l_int|1
suffix:semicolon
id|reset_status
op_assign
id|IM_RESET_FINISHED_OK
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*handling of commands coming from upper level of scsi driver */
r_else
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
multiline_comment|/*verify ldn, and may handle rare reset immediate command */
r_if
c_cond
(paren
id|ldn
op_ge
id|MAX_LOG_DEV
)paren
(brace
r_if
c_cond
(paren
id|ldn
op_eq
l_int|0xf
op_logical_and
id|reset_status
op_eq
id|IM_RESET_IN_PROGRESS
)paren
(brace
r_if
c_cond
(paren
id|cmd_result
op_eq
id|IM_CMD_COMPLETED_WITH_FAILURE
)paren
(brace
id|reset_status
op_assign
id|IM_RESET_FINISHED_FAIL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*reset disk led counter, turn off disk led */
id|disk_rw_in_progress
op_assign
l_int|0
suffix:semicolon
id|PS2_DISK_LED_OFF
(paren
)paren
suffix:semicolon
id|reset_status
op_assign
id|IM_RESET_FINISHED_OK
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_else
id|panic
(paren
l_string|&quot;IBM MCA SCSI: invalid logical device number.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef IM_DEBUG_TIMEOUT
(brace
r_static
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|count
op_eq
id|IM_DEBUG_TIMEOUT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: Ignoring interrupt.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*if no command structure, just return, else clear cmd */
id|cmd
op_assign
id|ld
(braket
id|ldn
)braket
dot
id|cmd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
r_return
suffix:semicolon
id|ld
(braket
id|ldn
)braket
dot
id|cmd
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef IM_DEBUG_INT
id|printk
c_func
(paren
l_string|&quot;cmd=%02x ireg=%02x ds=%02x cs=%02x de=%02x ce=%02x&bslash;n&quot;
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
id|intr_reg
comma
id|ld
(braket
id|ldn
)braket
dot
id|tsb.dev_status
comma
id|ld
(braket
id|ldn
)braket
dot
id|tsb.cmd_status
comma
id|ld
(braket
id|ldn
)braket
dot
id|tsb.dev_error
comma
id|ld
(braket
id|ldn
)braket
dot
id|tsb.cmd_error
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*if this is end of media read/write, may turn off PS/2 disk led */
r_if
c_cond
(paren
(paren
id|ld
(braket
id|ldn
)braket
dot
id|device_type
op_ne
id|TYPE_NO_LUN
)paren
op_logical_and
(paren
id|ld
(braket
id|ldn
)braket
dot
id|device_type
op_ne
id|TYPE_NO_DEVICE
)paren
)paren
(brace
multiline_comment|/* only access this, if there was a valid device addressed */
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|READ_6
suffix:colon
r_case
id|WRITE_6
suffix:colon
r_case
id|READ_10
suffix:colon
r_case
id|WRITE_10
suffix:colon
r_case
id|READ_12
suffix:colon
r_case
id|WRITE_12
suffix:colon
r_if
c_cond
(paren
op_decrement
id|disk_rw_in_progress
op_eq
l_int|0
)paren
id|PS2_DISK_LED_OFF
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*write device status into cmd-&gt;result, and call done function */
r_if
c_cond
(paren
id|cmd_result
op_eq
id|IM_CMD_COMPLETED_WITH_FAILURE
)paren
id|cmd-&gt;result
op_assign
id|ld
(braket
id|ldn
)braket
dot
id|tsb.dev_status
op_amp
l_int|0x1e
suffix:semicolon
r_else
id|cmd-&gt;result
op_assign
l_int|0
suffix:semicolon
(paren
id|cmd-&gt;scsi_done
)paren
(paren
id|cmd
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*--------------------------------------------------------------------*/
r_static
r_void
DECL|function|issue_cmd
id|issue_cmd
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_int
r_int
id|cmd_reg
comma
r_int
r_char
id|attn_reg
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*must wait for attention reg not busy */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
(paren
id|IM_STAT_REG
)paren
op_amp
id|IM_BUSY
)paren
)paren
r_break
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*write registers and enable system interrupts */
id|outl
(paren
id|cmd_reg
comma
id|IM_CMD_REG
)paren
suffix:semicolon
id|outb
(paren
id|attn_reg
comma
id|IM_ATTN_REG
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*--------------------------------------------------------------------*/
r_static
r_void
DECL|function|internal_done
id|internal_done
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|cmd-&gt;SCp.Status
op_increment
suffix:semicolon
)brace
multiline_comment|/*--------------------------------------------------------------------*/
DECL|function|ibmmca_getinfo
r_static
r_int
id|ibmmca_getinfo
(paren
r_char
op_star
id|buf
comma
r_int
id|slot
comma
r_void
op_star
id|dev
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shpnt
op_assign
id|dev
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|len
op_add_assign
id|sprintf
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Subsystem PUN: %d&bslash;n&quot;
comma
id|subsystem_pun
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;I/O base address: 0x%lx&bslash;n&quot;
comma
id|IM_CMD_REG
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*--------------------------------------------------------------------*/
multiline_comment|/* SCSI-SCB-command for device_inquiry */
DECL|function|device_inquiry
r_static
r_int
id|device_inquiry
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_int
id|ldn
comma
r_int
r_char
op_star
id|buf
)paren
(brace
r_struct
id|im_scb
id|scb
suffix:semicolon
r_struct
id|im_tsb
id|tsb
suffix:semicolon
r_int
id|retries
suffix:semicolon
r_for
c_loop
(paren
id|retries
op_assign
l_int|0
suffix:semicolon
id|retries
OL
l_int|3
suffix:semicolon
id|retries
op_increment
)paren
(brace
multiline_comment|/*fill scb with inquiry command */
id|scb.command
op_assign
id|IM_DEVICE_INQUIRY_CMD
suffix:semicolon
id|scb.enable
op_assign
id|IM_READ_CONTROL
op_or
id|IM_SUPRESS_EXCEPTION_SHORT
suffix:semicolon
id|scb.sys_buf_adr
op_assign
id|virt_to_bus
c_func
(paren
id|buf
)paren
suffix:semicolon
id|scb.sys_buf_length
op_assign
l_int|255
suffix:semicolon
id|scb.tsb_adr
op_assign
id|virt_to_bus
c_func
(paren
op_amp
id|tsb
)paren
suffix:semicolon
multiline_comment|/*issue scb to passed ldn, and busy wait for interrupt */
id|got_interrupt
op_assign
l_int|0
suffix:semicolon
id|issue_cmd
(paren
id|shpnt
comma
id|virt_to_bus
c_func
(paren
op_amp
id|scb
)paren
comma
id|IM_SCB
op_or
id|ldn
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|got_interrupt
)paren
id|barrier
(paren
)paren
suffix:semicolon
multiline_comment|/*if command succesful, break */
r_if
c_cond
(paren
id|stat_result
op_eq
id|IM_SCB_CMD_COMPLETED
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*if all three retries failed, return &quot;no device at this ldn&quot; */
r_if
c_cond
(paren
id|retries
op_ge
l_int|3
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* SCSI-immediate-command for assign. This functions maps/unmaps specific&n;   ldn-numbers on SCSI (PUN,LUN). It is needed for presetting of the&n;   subsystem and for dynamical remapping od ldns. */
DECL|function|immediate_assign
r_static
r_int
id|immediate_assign
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_int
r_int
id|pun
comma
r_int
r_int
id|lun
comma
r_int
r_int
id|ldn
comma
r_int
r_int
id|operation
)paren
(brace
r_int
id|retries
suffix:semicolon
r_int
r_int
id|imm_command
suffix:semicolon
r_for
c_loop
(paren
id|retries
op_assign
l_int|0
suffix:semicolon
id|retries
OL
l_int|3
suffix:semicolon
id|retries
op_increment
)paren
(brace
id|imm_command
op_assign
id|inl
c_func
(paren
id|IM_CMD_REG
)paren
suffix:semicolon
id|imm_command
op_and_assign
(paren
r_int
r_int
)paren
(paren
l_int|0xF8000000
)paren
suffix:semicolon
multiline_comment|/* keep reserved bits */
id|imm_command
op_or_assign
(paren
r_int
r_int
)paren
(paren
id|IM_ASSIGN_IMM_CMD
)paren
suffix:semicolon
id|imm_command
op_or_assign
(paren
r_int
r_int
)paren
(paren
(paren
id|lun
op_amp
l_int|7
)paren
op_lshift
l_int|24
)paren
suffix:semicolon
id|imm_command
op_or_assign
(paren
r_int
r_int
)paren
(paren
(paren
id|operation
op_amp
l_int|1
)paren
op_lshift
l_int|23
)paren
suffix:semicolon
id|imm_command
op_or_assign
(paren
r_int
r_int
)paren
(paren
(paren
id|pun
op_amp
l_int|7
)paren
op_lshift
l_int|20
)paren
suffix:semicolon
id|imm_command
op_or_assign
(paren
r_int
r_int
)paren
(paren
(paren
id|ldn
op_amp
l_int|15
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|got_interrupt
op_assign
l_int|0
suffix:semicolon
id|issue_cmd
(paren
id|shpnt
comma
(paren
r_int
r_int
)paren
(paren
id|imm_command
)paren
comma
id|IM_IMM_CMD
op_or
l_int|0xf
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|got_interrupt
)paren
id|barrier
(paren
)paren
suffix:semicolon
multiline_comment|/*if command succesful, break */
r_if
c_cond
(paren
id|stat_result
op_eq
id|IM_IMMEDIATE_CMD_COMPLETED
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retries
op_ge
l_int|3
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* type-interpreter for physical device numbers */
DECL|function|ti_p
r_static
r_char
op_star
id|ti_p
c_func
(paren
r_int
id|value
)paren
(brace
r_switch
c_cond
(paren
id|value
)paren
(brace
r_case
id|TYPE_IBM_SCSI_ADAPTER
suffix:colon
r_return
l_string|&quot;A&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_DISK
suffix:colon
r_return
l_string|&quot;D&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_TAPE
suffix:colon
r_return
l_string|&quot;T&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_PROCESSOR
suffix:colon
r_return
l_string|&quot;P&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_WORM
suffix:colon
r_return
l_string|&quot;W&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_ROM
suffix:colon
r_return
l_string|&quot;R&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_SCANNER
suffix:colon
r_return
l_string|&quot;S&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_MOD
suffix:colon
r_return
l_string|&quot;M&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_MEDIUM_CHANGER
suffix:colon
r_return
l_string|&quot;C&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_NO_LUN
suffix:colon
r_return
l_string|&quot;+&quot;
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* show NO_LUN */
r_case
id|TYPE_NO_DEVICE
suffix:colon
r_default
suffix:colon
r_return
l_string|&quot;-&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_string|&quot;-&quot;
suffix:semicolon
)brace
multiline_comment|/* interpreter for logical device numbers (ldn) */
DECL|function|ti_l
r_static
r_char
op_star
id|ti_l
c_func
(paren
r_int
id|value
)paren
(brace
r_const
r_char
id|hex
(braket
l_int|16
)braket
op_assign
(paren
l_string|&quot;0123456789abcdef&quot;
)paren
suffix:semicolon
r_static
r_char
id|answer
(braket
l_int|2
)braket
suffix:semicolon
id|answer
(braket
l_int|1
)braket
op_assign
(paren
r_char
)paren
(paren
l_int|0x0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_le
id|MAX_LOG_DEV
)paren
id|answer
(braket
l_int|0
)braket
op_assign
id|hex
(braket
id|value
)braket
suffix:semicolon
r_else
id|answer
(braket
l_int|0
)braket
op_assign
l_char|&squot;-&squot;
suffix:semicolon
r_return
(paren
r_char
op_star
)paren
op_amp
id|answer
suffix:semicolon
)brace
multiline_comment|/* &n;   The following routine probes the SCSI-devices in four steps:&n;   1. The current ldn -&gt; pun,lun mapping is removed on the SCSI-adapter.&n;   2. ldn 0 is used to go through all possible combinations of pun,lun and&n;      a device_inquiry is done to fiddle out whether there is a device&n;      responding or not. This physical map is stored in get_scsi[][].&n;   3. The 15 available ldns (0-14) are mapped to existing pun,lun.&n;      If there are more devices than ldns, it stops at 14 for the boot&n;      time. Dynamical remapping will be done in ibmmca_queuecommand.&n;   4. If there are less than 15 valid pun,lun, the remaining ldns are&n;      mapped to NON-existing pun,lun to satisfy the adapter. Information&n;      about pun,lun -&gt; ldn is stored as before in get_ldn[][].&n;   This method leads to the result, that the SCSI-pun,lun shown to Linux&n;   mid-level- and higher-level-drivers is exactly corresponding to the&n;   physical reality on the SCSI-bus. Therefore, it is possible that users&n;   of older releases of this driver have to rewrite their fstab-file, because&n;   the /dev/sdXXX could have changed due to the right pun,lun report, now.&n;   The assignment of ALL ldns avoids dynamical remapping by the adapter&n;   itself.&n; */
DECL|function|check_devices
r_static
r_void
id|check_devices
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_int
id|id
comma
id|lun
comma
id|ldn
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|256
)braket
suffix:semicolon
r_int
id|count_devices
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* local counter for connected device */
multiline_comment|/* assign default values to certain variables */
id|IBM_DS.dyn_flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* normally no need for dynamical ldn management */
id|next_ldn
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* next ldn to be assigned is 7, because 0-6 is &squot;hardwired&squot;*/
id|last_scsi_command
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* emptify last SCSI-command storage */
multiline_comment|/* initialize the very important driver-informational arrays/structs */
id|memset
(paren
id|ld
comma
l_int|0
comma
r_sizeof
id|ld
)paren
suffix:semicolon
id|memset
(paren
id|get_ldn
comma
id|TYPE_NO_DEVICE
comma
r_sizeof
id|get_ldn
)paren
suffix:semicolon
multiline_comment|/* this is essential ! */
id|memset
(paren
id|get_scsi
comma
id|TYPE_NO_DEVICE
comma
r_sizeof
id|get_scsi
)paren
suffix:semicolon
multiline_comment|/* this is essential ! */
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
l_int|8
suffix:semicolon
id|lun
op_increment
)paren
multiline_comment|/* mark the adapter at its pun on all luns*/
(brace
id|get_scsi
(braket
id|subsystem_pun
)braket
(braket
id|lun
)braket
op_assign
id|TYPE_IBM_SCSI_ADAPTER
suffix:semicolon
id|get_ldn
(braket
id|subsystem_pun
)braket
(braket
id|lun
)braket
op_assign
id|MAX_LOG_DEV
suffix:semicolon
multiline_comment|/* make sure, the subsystem&n;&t;&t;&t;&t;&t;&t;    ldn is active for all&n;&t;&t;&t;&t;&t;&t;    luns. */
)brace
multiline_comment|/* STEP 1: */
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: Removing current logical SCSI-device mapping.&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ldn
op_assign
l_int|0
suffix:semicolon
id|ldn
OL
id|MAX_LOG_DEV
suffix:semicolon
id|ldn
op_increment
)paren
(brace
macro_line|#ifdef IM_DEBUG_PROBE
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
macro_line|#endif
id|immediate_assign
c_func
(paren
id|shpnt
comma
l_int|0
comma
l_int|0
comma
id|ldn
comma
id|REMOVE_LDN
)paren
suffix:semicolon
multiline_comment|/* remove ldn (wherever)*/
)brace
id|lun
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default lun is 0 */
multiline_comment|/* STEP 2: */
id|printk
c_func
(paren
l_string|&quot;&bslash;nIBM MCA SCSI: Probing SCSI-devices.&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|id
op_assign
l_int|0
suffix:semicolon
id|id
OL
l_int|8
suffix:semicolon
id|id
op_increment
)paren
macro_line|#ifdef CONFIG_SCSI_MULTI_LUN
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
l_int|8
suffix:semicolon
id|lun
op_increment
)paren
macro_line|#endif
(brace
macro_line|#ifdef IM_DEBUG_PROBE
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|id
op_ne
id|subsystem_pun
)paren
(brace
multiline_comment|/* if pun is not the adapter: */
id|immediate_assign
c_func
(paren
id|shpnt
comma
id|id
comma
id|lun
comma
l_int|0
comma
id|SET_LDN
)paren
suffix:semicolon
multiline_comment|/*set ldn=0 to pun,lun*/
r_if
c_cond
(paren
id|device_inquiry
c_func
(paren
id|shpnt
comma
l_int|0
comma
id|buf
)paren
)paren
multiline_comment|/* probe device */
(brace
id|get_scsi
(braket
id|id
)braket
(braket
id|lun
)braket
op_assign
(paren
r_int
r_char
)paren
id|buf
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* entry, even &n;&t;&t;&t;&t;&t;&t;&t;     for NO_LUN */
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_ne
id|TYPE_NO_LUN
)paren
id|count_devices
op_increment
suffix:semicolon
multiline_comment|/* a existing device is found */
)brace
id|immediate_assign
c_func
(paren
id|shpnt
comma
id|id
comma
id|lun
comma
l_int|0
comma
id|REMOVE_LDN
)paren
suffix:semicolon
multiline_comment|/* remove ldn */
)brace
)brace
multiline_comment|/* STEP 3: */
id|printk
c_func
(paren
l_string|&quot;&bslash;nIBM MCA SCSI: Mapping SCSI-devices.&quot;
)paren
suffix:semicolon
id|ldn
op_assign
l_int|0
suffix:semicolon
id|lun
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_SCSI_MULTI_LUN   
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
l_int|8
op_logical_and
id|ldn
OL
id|MAX_LOG_DEV
suffix:semicolon
id|lun
op_increment
)paren
macro_line|#endif
r_for
c_loop
(paren
id|id
op_assign
l_int|0
suffix:semicolon
id|id
OL
l_int|8
op_logical_and
id|ldn
OL
id|MAX_LOG_DEV
suffix:semicolon
id|id
op_increment
)paren
(brace
macro_line|#ifdef IM_DEBUG_PROBE
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|id
op_ne
id|subsystem_pun
)paren
(brace
r_if
c_cond
(paren
id|get_scsi
(braket
id|id
)braket
(braket
id|lun
)braket
op_ne
id|TYPE_NO_LUN
op_logical_and
id|get_scsi
(braket
id|id
)braket
(braket
id|lun
)braket
op_ne
id|TYPE_NO_DEVICE
)paren
(brace
multiline_comment|/* Only map if accepted type. Always enter for &n;&t;&t;   lun == 0 to get no gaps into ldn-mapping for ldn&lt;7. */
id|immediate_assign
c_func
(paren
id|shpnt
comma
id|id
comma
id|lun
comma
id|ldn
comma
id|SET_LDN
)paren
suffix:semicolon
id|get_ldn
(braket
id|id
)braket
(braket
id|lun
)braket
op_assign
id|ldn
suffix:semicolon
multiline_comment|/* map ldn */
r_if
c_cond
(paren
id|device_exists
(paren
id|shpnt
comma
id|ldn
comma
op_amp
id|ld
(braket
id|ldn
)braket
dot
id|block_length
comma
op_amp
id|ld
(braket
id|ldn
)braket
dot
id|device_type
)paren
)paren
(brace
macro_line|#ifdef CONFIG_IBMMCA_SCSI_DEV_RESET
r_int
id|ticks
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;(resetting)&quot;
)paren
suffix:semicolon
id|ticks
op_assign
id|IM_RESET_DELAY
op_star
id|HZ
suffix:semicolon
id|reset_status
op_assign
id|IM_RESET_IN_PROGRESS
suffix:semicolon
id|issue_cmd
(paren
id|shpnt
comma
id|IM_RESET_IMM_CMD
comma
id|IM_IMM_CMD
op_or
id|ldn
)paren
suffix:semicolon
r_while
c_loop
(paren
id|reset_status
op_eq
id|IM_RESET_IN_PROGRESS
op_logical_and
op_decrement
id|ticks
)paren
(brace
id|mdelay
c_func
(paren
l_int|1
op_plus
l_int|999
op_div
id|HZ
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* if reset did not complete, just claim */
r_if
c_cond
(paren
op_logical_neg
id|ticks
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: reset did not complete within %d seconds.&bslash;n&quot;
comma
id|IM_RESET_DELAY
)paren
suffix:semicolon
id|reset_status
op_assign
id|IM_RESET_FINISHED_OK
suffix:semicolon
multiline_comment|/* did not work, finish */
)brace
macro_line|#endif
id|ldn
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* device vanished, probably because we don&squot;t know how to&n;&t;&t;     * handle it or because it has problems */
r_if
c_cond
(paren
id|lun
OG
l_int|0
)paren
(brace
multiline_comment|/* remove mapping */
id|get_ldn
(braket
id|id
)braket
(braket
id|lun
)braket
op_assign
id|TYPE_NO_DEVICE
suffix:semicolon
id|immediate_assign
c_func
(paren
id|shpnt
comma
l_int|0
comma
l_int|0
comma
id|ldn
comma
id|REMOVE_LDN
)paren
suffix:semicolon
)brace
r_else
id|ldn
op_increment
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|lun
op_eq
l_int|0
)paren
(brace
multiline_comment|/* map lun == 0, even if no device exists */
id|immediate_assign
c_func
(paren
id|shpnt
comma
id|id
comma
id|lun
comma
id|ldn
comma
id|SET_LDN
)paren
suffix:semicolon
id|get_ldn
(braket
id|id
)braket
(braket
id|lun
)braket
op_assign
id|ldn
suffix:semicolon
multiline_comment|/* map ldn */
id|ldn
op_increment
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* STEP 4: */
multiline_comment|/* map remaining ldns to non-existing devices */
r_for
c_loop
(paren
id|lun
op_assign
l_int|1
suffix:semicolon
id|lun
OL
l_int|8
op_logical_and
id|ldn
OL
id|MAX_LOG_DEV
suffix:semicolon
id|lun
op_increment
)paren
r_for
c_loop
(paren
id|id
op_assign
l_int|0
suffix:semicolon
id|id
OL
l_int|8
op_logical_and
id|ldn
OL
id|MAX_LOG_DEV
suffix:semicolon
id|id
op_increment
)paren
(brace
r_if
c_cond
(paren
id|get_scsi
(braket
id|id
)braket
(braket
id|lun
)braket
op_eq
id|TYPE_NO_LUN
op_logical_or
id|get_scsi
(braket
id|id
)braket
(braket
id|lun
)braket
op_eq
id|TYPE_NO_DEVICE
)paren
(brace
multiline_comment|/* Map remaining ldns only to NON-existing pun,lun&n;&t;        combinations to make sure an inquiry will fail. &n;&t;        For MULTI_LUN, it is needed to avoid adapter autonome&n;&t;        SCSI-remapping. */
id|immediate_assign
c_func
(paren
id|shpnt
comma
id|id
comma
id|lun
comma
id|ldn
comma
id|SET_LDN
)paren
suffix:semicolon
id|get_ldn
(braket
id|id
)braket
(braket
id|lun
)braket
op_assign
id|ldn
suffix:semicolon
id|ldn
op_increment
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IBMMCA_SCSI_ORDER_STANDARD
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: SCSI-access-order: IBM/ANSI.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: SCSI-access-order: Linux.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef IM_DEBUG_PROBE
multiline_comment|/* Show the physical and logical mapping during boot. */
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: Determined SCSI-device-mapping:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    Physical SCSI-Device Map               Logical SCSI-Device Map&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ID&bslash;&bslash;LUN  0  1  2  3  4  5  6  7       ID&bslash;&bslash;LUN  0  1  2  3  4  5  6  7&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|id
op_assign
l_int|0
suffix:semicolon
id|id
OL
l_int|8
suffix:semicolon
id|id
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2d     %2s %2s %2s %2s %2s %2s %2s %2s&quot;
comma
id|id
comma
id|ti_p
c_func
(paren
id|get_scsi
(braket
id|id
)braket
(braket
l_int|0
)braket
)paren
comma
id|ti_p
c_func
(paren
id|get_scsi
(braket
id|id
)braket
(braket
l_int|1
)braket
)paren
comma
id|ti_p
c_func
(paren
id|get_scsi
(braket
id|id
)braket
(braket
l_int|2
)braket
)paren
comma
id|ti_p
c_func
(paren
id|get_scsi
(braket
id|id
)braket
(braket
l_int|3
)braket
)paren
comma
id|ti_p
c_func
(paren
id|get_scsi
(braket
id|id
)braket
(braket
l_int|4
)braket
)paren
comma
id|ti_p
c_func
(paren
id|get_scsi
(braket
id|id
)braket
(braket
l_int|5
)braket
)paren
comma
id|ti_p
c_func
(paren
id|get_scsi
(braket
id|id
)braket
(braket
l_int|6
)braket
)paren
comma
id|ti_p
c_func
(paren
id|get_scsi
(braket
id|id
)braket
(braket
l_int|7
)braket
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;       %2d     &quot;
comma
id|id
)paren
suffix:semicolon
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
l_int|8
suffix:semicolon
id|lun
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%2s &quot;
comma
id|ti_l
c_func
(paren
id|get_ldn
(braket
id|id
)braket
(braket
id|lun
)braket
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* assign total number of found SCSI-devices to the statistics struct */
id|IBM_DS.total_scsi_devices
op_assign
id|count_devices
suffix:semicolon
multiline_comment|/* decide for output in /proc-filesystem, if the configuration of&n;      SCSI-devices makes dynamical reassignment of devices necessary */
r_if
c_cond
(paren
id|count_devices
op_ge
id|MAX_LOG_DEV
)paren
id|IBM_DS.dyn_flag
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* dynamical assignment is necessary */
r_else
id|IBM_DS.dyn_flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* dynamical assignment is not necessary */
multiline_comment|/* If no SCSI-devices are assigned, return 1 in order to cause message. */
r_if
c_cond
(paren
id|ldn
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: Warning: No SCSI-devices found/assignable!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* reset the counters for statistics on the current adapter */
id|IBM_DS.total_accesses
op_assign
l_int|0
suffix:semicolon
id|IBM_DS.total_interrupts
op_assign
l_int|0
suffix:semicolon
id|IBM_DS.dynamical_assignments
op_assign
l_int|0
suffix:semicolon
id|memset
(paren
id|IBM_DS.ldn_access
comma
l_int|0x0
comma
r_sizeof
(paren
id|IBM_DS.ldn_access
)paren
)paren
suffix:semicolon
id|memset
(paren
id|IBM_DS.ldn_read_access
comma
l_int|0x0
comma
r_sizeof
(paren
id|IBM_DS.ldn_read_access
)paren
)paren
suffix:semicolon
id|memset
(paren
id|IBM_DS.ldn_write_access
comma
l_int|0x0
comma
r_sizeof
(paren
id|IBM_DS.ldn_write_access
)paren
)paren
suffix:semicolon
id|memset
(paren
id|IBM_DS.ldn_inquiry_access
comma
l_int|0x0
comma
r_sizeof
(paren
id|IBM_DS.ldn_inquiry_access
)paren
)paren
suffix:semicolon
id|memset
(paren
id|IBM_DS.ldn_modeselect_access
comma
l_int|0x0
comma
r_sizeof
(paren
id|IBM_DS.ldn_modeselect_access
)paren
)paren
suffix:semicolon
id|memset
(paren
id|IBM_DS.ldn_assignments
comma
l_int|0x0
comma
r_sizeof
(paren
id|IBM_DS.ldn_assignments
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*--------------------------------------------------------------------*/
r_static
r_int
DECL|function|device_exists
id|device_exists
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_int
id|ldn
comma
r_int
op_star
id|block_length
comma
r_int
op_star
id|device_type
)paren
(brace
r_struct
id|im_scb
id|scb
suffix:semicolon
r_struct
id|im_tsb
id|tsb
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|256
)braket
suffix:semicolon
r_int
id|retries
suffix:semicolon
multiline_comment|/* if no valid device found, return immediately with 0 */
r_if
c_cond
(paren
op_logical_neg
(paren
id|device_inquiry
c_func
(paren
id|shpnt
comma
id|ldn
comma
id|buf
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*if device is CD_ROM, assume block size 2048 and return */
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_eq
id|TYPE_ROM
)paren
(brace
op_star
id|device_type
op_assign
id|TYPE_ROM
suffix:semicolon
op_star
id|block_length
op_assign
l_int|2048
suffix:semicolon
multiline_comment|/* (standard blocksize for yellow-/red-book) */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_eq
id|TYPE_WORM
)paren
multiline_comment|/* CD-burner, WORM, Linux handles this as CD-ROM &n;&t;&t;&t;      therefore, the block_length is also 2048. */
(brace
op_star
id|device_type
op_assign
id|TYPE_WORM
suffix:semicolon
op_star
id|block_length
op_assign
l_int|2048
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* if device is disk, use &quot;read capacity&quot; to find its block size */
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_eq
id|TYPE_DISK
)paren
(brace
op_star
id|device_type
op_assign
id|TYPE_DISK
suffix:semicolon
r_for
c_loop
(paren
id|retries
op_assign
l_int|0
suffix:semicolon
id|retries
OL
l_int|3
suffix:semicolon
id|retries
op_increment
)paren
(brace
multiline_comment|/*fill scb with read capacity command */
id|scb.command
op_assign
id|IM_READ_CAPACITY_CMD
suffix:semicolon
id|scb.enable
op_assign
id|IM_READ_CONTROL
suffix:semicolon
id|scb.sys_buf_adr
op_assign
id|virt_to_bus
c_func
(paren
id|buf
)paren
suffix:semicolon
id|scb.sys_buf_length
op_assign
l_int|8
suffix:semicolon
id|scb.tsb_adr
op_assign
id|virt_to_bus
c_func
(paren
op_amp
id|tsb
)paren
suffix:semicolon
multiline_comment|/*issue scb to passed ldn, and busy wait for interrupt */
id|got_interrupt
op_assign
l_int|0
suffix:semicolon
id|issue_cmd
(paren
id|shpnt
comma
id|virt_to_bus
c_func
(paren
op_amp
id|scb
)paren
comma
id|IM_SCB
op_or
id|ldn
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|got_interrupt
)paren
id|barrier
(paren
)paren
suffix:semicolon
multiline_comment|/*if got capacity, get block length and return one device found */
r_if
c_cond
(paren
id|stat_result
op_eq
id|IM_SCB_CMD_COMPLETED
)paren
(brace
op_star
id|block_length
op_assign
id|buf
(braket
l_int|7
)braket
op_plus
(paren
id|buf
(braket
l_int|6
)braket
op_lshift
l_int|8
)paren
op_plus
(paren
id|buf
(braket
l_int|5
)braket
op_lshift
l_int|16
)paren
op_plus
(paren
id|buf
(braket
l_int|4
)braket
op_lshift
l_int|24
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*if all three retries failed, return &quot;no device at this ldn&quot; */
r_if
c_cond
(paren
id|retries
op_ge
l_int|3
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if this is a magneto-optical drive, treat it like a harddisk */
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_eq
id|TYPE_MOD
)paren
(brace
op_star
id|device_type
op_assign
id|TYPE_MOD
suffix:semicolon
r_for
c_loop
(paren
id|retries
op_assign
l_int|0
suffix:semicolon
id|retries
OL
l_int|3
suffix:semicolon
id|retries
op_increment
)paren
(brace
multiline_comment|/*fill scb with read capacity command */
id|scb.command
op_assign
id|IM_READ_CAPACITY_CMD
suffix:semicolon
id|scb.enable
op_assign
id|IM_READ_CONTROL
suffix:semicolon
id|scb.sys_buf_adr
op_assign
id|virt_to_bus
c_func
(paren
id|buf
)paren
suffix:semicolon
id|scb.sys_buf_length
op_assign
l_int|8
suffix:semicolon
id|scb.tsb_adr
op_assign
id|virt_to_bus
c_func
(paren
op_amp
id|tsb
)paren
suffix:semicolon
multiline_comment|/*issue scb to passed ldn, and busy wait for interrupt */
id|got_interrupt
op_assign
l_int|0
suffix:semicolon
id|issue_cmd
(paren
id|shpnt
comma
id|virt_to_bus
c_func
(paren
op_amp
id|scb
)paren
comma
id|IM_SCB
op_or
id|ldn
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|got_interrupt
)paren
id|barrier
(paren
)paren
suffix:semicolon
multiline_comment|/*if got capacity, get block length and return one device found */
r_if
c_cond
(paren
id|stat_result
op_eq
id|IM_SCB_CMD_COMPLETED
)paren
(brace
op_star
id|block_length
op_assign
id|buf
(braket
l_int|7
)braket
op_plus
(paren
id|buf
(braket
l_int|6
)braket
op_lshift
l_int|8
)paren
op_plus
(paren
id|buf
(braket
l_int|5
)braket
op_lshift
l_int|16
)paren
op_plus
(paren
id|buf
(braket
l_int|4
)braket
op_lshift
l_int|24
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*if all three retries failed, return &quot;no device at this ldn&quot; */
r_if
c_cond
(paren
id|retries
op_ge
l_int|3
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_eq
id|TYPE_TAPE
)paren
multiline_comment|/* TAPE-device found */
(brace
op_star
id|device_type
op_assign
id|TYPE_TAPE
suffix:semicolon
op_star
id|block_length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not in use (setting by mt and mtst in op.) */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_eq
id|TYPE_PROCESSOR
)paren
multiline_comment|/* HP-Scanners, diverse SCSI-processing units*/
(brace
op_star
id|device_type
op_assign
id|TYPE_PROCESSOR
suffix:semicolon
op_star
id|block_length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* they set their stuff on drivers */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_eq
id|TYPE_SCANNER
)paren
multiline_comment|/* other SCSI-scanners */
(brace
op_star
id|device_type
op_assign
id|TYPE_SCANNER
suffix:semicolon
op_star
id|block_length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* they set their stuff on drivers */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_eq
id|TYPE_MEDIUM_CHANGER
)paren
multiline_comment|/* Medium-Changer */
(brace
op_star
id|device_type
op_assign
id|TYPE_MEDIUM_CHANGER
suffix:semicolon
op_star
id|block_length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* One never knows, what to expect on a medium&n;&t;&t;&t;    changer device. */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Up to now, no SCSI-devices that are known up to kernel 2.1.31 are&n;     ignored! MO-drives are now supported and treated as harddisk. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*--------------------------------------------------------------------*/
macro_line|#ifdef CONFIG_SCSI_IBMMCA
r_void
DECL|function|ibmmca_scsi_setup
id|ibmmca_scsi_setup
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_if
c_cond
(paren
id|str
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;display&quot;
)paren
)paren
(brace
id|use_display
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ints
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IM_MAX_HOSTS
op_logical_and
id|i
OL
id|ints
(braket
l_int|0
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
id|io_port
(braket
id|i
)braket
op_assign
id|ints
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/*--------------------------------------------------------------------*/
r_int
DECL|function|ibmmca_detect
id|ibmmca_detect
(paren
id|Scsi_Host_Template
op_star
r_template
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_int
id|port
comma
id|id
comma
id|i
comma
id|list_size
comma
id|slot
suffix:semicolon
r_int
id|pos2
comma
id|pos3
suffix:semicolon
multiline_comment|/* if this is not MCA machine, return &quot;nothing found&quot; */
r_if
c_cond
(paren
op_logical_neg
id|MCA_bus
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* get interrupt request level */
r_if
c_cond
(paren
id|request_irq
(paren
id|IM_IRQ
comma
id|do_interrupt_handler
comma
id|SA_SHIRQ
comma
l_string|&quot;ibmmca&quot;
comma
id|hosts
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: Unable to get IRQ %d.&bslash;n&quot;
comma
id|IM_IRQ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if ibmmcascsi setup option was passed to kernel, return &quot;found&quot; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IM_MAX_HOSTS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|io_port
(braket
id|i
)braket
OG
l_int|0
op_logical_and
id|scsi_id
(braket
id|i
)braket
op_ge
l_int|0
op_logical_and
id|scsi_id
(braket
id|i
)braket
OL
l_int|8
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: forced detection, io=0x%x, scsi id=%d.&bslash;n&quot;
comma
id|io_port
(braket
id|i
)braket
comma
id|scsi_id
(braket
id|i
)braket
)paren
suffix:semicolon
id|ibmmca_register
c_func
(paren
r_template
comma
id|io_port
(braket
id|i
)braket
comma
id|scsi_id
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
)paren
r_return
id|found
suffix:semicolon
multiline_comment|/* first look for the SCSI integrated on the motherboard */
id|pos2
op_assign
id|mca_read_stored_pos
c_func
(paren
id|MCA_INTEGSCSI
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pos2
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|pos3
op_assign
id|mca_read_stored_pos
c_func
(paren
id|MCA_INTEGSCSI
comma
l_int|3
)paren
suffix:semicolon
id|port
op_assign
id|IM_IO_PORT
op_plus
(paren
(paren
id|pos2
op_amp
l_int|0x0e
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
id|id
op_assign
(paren
id|pos3
op_amp
l_int|0xe0
)paren
op_rshift
l_int|5
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: integrated SCSI found, io=0x%x, scsi id=%d.&bslash;n&quot;
comma
id|port
comma
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|shpnt
op_assign
id|ibmmca_register
c_func
(paren
r_template
comma
id|port
comma
id|id
)paren
)paren
)paren
(brace
id|mca_set_adapter_name
c_func
(paren
id|MCA_INTEGSCSI
comma
l_string|&quot;PS/2 Integrated SCSI&quot;
)paren
suffix:semicolon
id|mca_set_adapter_procfn
c_func
(paren
id|MCA_INTEGSCSI
comma
(paren
id|MCA_ProcFn
)paren
id|ibmmca_getinfo
comma
id|shpnt
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* now look for other adapters */
id|list_size
op_assign
r_sizeof
(paren
id|subsys_list
)paren
op_div
r_sizeof
(paren
r_struct
id|subsys_list_struct
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|list_size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|slot
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|slot
op_assign
id|mca_find_adapter
c_func
(paren
id|subsys_list
(braket
id|i
)braket
dot
id|mca_id
comma
id|slot
)paren
)paren
op_ne
id|MCA_NOTFOUND
)paren
(brace
id|pos2
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|2
)paren
suffix:semicolon
id|pos3
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|3
)paren
suffix:semicolon
id|port
op_assign
id|IM_IO_PORT
op_plus
(paren
(paren
id|pos2
op_amp
l_int|0x0e
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
id|id
op_assign
(paren
id|pos3
op_amp
l_int|0xe0
)paren
op_rshift
l_int|5
suffix:semicolon
id|printk
(paren
l_string|&quot;IBM MCA SCSI: %s found in slot %d, io=0x%x, scsi id=%d.&bslash;n&quot;
comma
id|subsys_list
(braket
id|i
)braket
dot
id|description
comma
id|slot
op_plus
l_int|1
comma
id|port
comma
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|shpnt
op_assign
id|ibmmca_register
c_func
(paren
r_template
comma
id|port
comma
id|id
)paren
)paren
)paren
(brace
id|mca_set_adapter_name
(paren
id|slot
comma
id|subsys_list
(braket
id|i
)braket
dot
id|description
)paren
suffix:semicolon
id|mca_set_adapter_procfn
(paren
id|slot
comma
(paren
id|MCA_ProcFn
)paren
id|ibmmca_getinfo
comma
id|shpnt
)paren
suffix:semicolon
)brace
id|slot
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|free_irq
(paren
id|IM_IRQ
comma
id|hosts
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: No adapter attached.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|found
suffix:semicolon
)brace
r_static
r_struct
id|Scsi_Host
op_star
DECL|function|ibmmca_register
id|ibmmca_register
c_func
(paren
id|Scsi_Host_Template
op_star
r_template
comma
r_int
id|port
comma
r_int
id|id
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/* check I/O region */
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|port
comma
id|IM_N_IO_PORT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: Unable to get I/O region 0x%x-0x%x.&bslash;n&quot;
comma
id|port
comma
id|port
op_plus
id|IM_N_IO_PORT
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* register host */
id|shpnt
op_assign
id|scsi_register
c_func
(paren
r_template
comma
r_sizeof
(paren
r_struct
id|ibmmca_hostdata
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|shpnt
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: Unable to register host.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* request I/O region */
id|request_region
c_func
(paren
id|port
comma
id|IM_N_IO_PORT
comma
l_string|&quot;ibmmca&quot;
)paren
suffix:semicolon
id|hosts
(braket
id|found
op_increment
)braket
op_assign
id|shpnt
suffix:semicolon
id|shpnt-&gt;irq
op_assign
id|IM_IRQ
suffix:semicolon
id|shpnt-&gt;io_port
op_assign
id|port
suffix:semicolon
id|shpnt-&gt;n_io_port
op_assign
id|IM_N_IO_PORT
suffix:semicolon
id|shpnt-&gt;this_id
op_assign
id|id
suffix:semicolon
id|reset_status
op_assign
id|IM_RESET_NOT_IN_PROGRESS
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
id|get_ldn
(braket
id|i
)braket
(braket
id|j
)braket
op_assign
id|MAX_LOG_DEV
suffix:semicolon
multiline_comment|/* check which logical devices exist */
id|local_checking_phase_flag
op_assign
l_int|1
suffix:semicolon
id|check_devices
c_func
(paren
id|shpnt
)paren
suffix:semicolon
id|local_checking_phase_flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* an ibm mca subsystem has been detected */
r_return
id|shpnt
suffix:semicolon
)brace
multiline_comment|/*--------------------------------------------------------------------*/
r_int
DECL|function|ibmmca_command
id|ibmmca_command
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|ibmmca_queuecommand
(paren
id|cmd
comma
id|internal_done
)paren
suffix:semicolon
id|cmd-&gt;SCp.Status
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|cmd-&gt;SCp.Status
)paren
id|barrier
(paren
)paren
suffix:semicolon
r_return
id|cmd-&gt;result
suffix:semicolon
)brace
multiline_comment|/*--------------------------------------------------------------------*/
r_int
DECL|function|ibmmca_release
id|ibmmca_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
id|release_region
c_func
(paren
id|shpnt-&gt;io_port
comma
id|shpnt-&gt;n_io_port
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_decrement
id|found
)paren
)paren
id|free_irq
c_func
(paren
id|shpnt-&gt;irq
comma
id|hosts
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*--------------------------------------------------------------------*/
multiline_comment|/* The following routine is the SCSI command queue. The old edition is&n;   now improved by dynamical reassignment of ldn numbers that are &n;   currently not assigned. The mechanism works in a way, that first&n;   the physical structure is checked. If at a certain pun,lun a device&n;   should be present, the routine proceeds to the ldn check from&n;   get_ldn. An answer of 0xff would show-up, that the aimed device is&n;   currently not assigned any ldn. At this point, the dynamical &n;   remapping algorithm is called. It works in a way, that it goes in&n;   cyclic order through the ldns from 7 to 14. If a ldn is assigned,&n;   it takes 8 dynamical reassignment calls, until a device looses its&n;   ldn again. With this method it is assured, that while doing &n;   intense I/O between up to eight devices, no dynamical remapping is&n;   done there. ldns 0 through 6(!) are left untouched, which means, that&n;   puns 0 through 7(!) on lun=0 are always accessible without remapping.&n;   These ldns are statically assigned by this driver. The subsystem always &n;   occupies at least one pun, therefore 7 ldns (at lun=0) for other devices &n;   are sufficient. (The adapter uses always ldn=15, at whatever pun it is.) */
DECL|function|ibmmca_queuecommand
r_int
id|ibmmca_queuecommand
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
r_int
id|ldn
suffix:semicolon
r_int
r_int
id|scsi_cmd
suffix:semicolon
r_struct
id|im_scb
op_star
id|scb
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
op_assign
id|cmd-&gt;host
suffix:semicolon
r_int
id|current_ldn
suffix:semicolon
r_int
id|id
comma
id|lun
suffix:semicolon
multiline_comment|/* use industry standard ordering of the IDs */
macro_line|#ifdef CONFIG_IBMMCA_SCSI_ORDER_STANDARD
r_int
id|target
op_assign
l_int|6
op_minus
id|cmd-&gt;target
suffix:semicolon
macro_line|#else
r_int
id|target
op_assign
id|cmd-&gt;target
suffix:semicolon
macro_line|#endif
multiline_comment|/*if (target,lun) is NO LUN or not existing at all, return error */
r_if
c_cond
(paren
(paren
id|get_scsi
(braket
id|target
)braket
(braket
id|cmd-&gt;lun
)braket
op_eq
id|TYPE_NO_LUN
)paren
op_logical_or
(paren
id|get_scsi
(braket
id|target
)braket
(braket
id|cmd-&gt;lun
)braket
op_eq
id|TYPE_NO_DEVICE
)paren
)paren
(brace
id|cmd-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|done
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*if (target,lun) unassigned, do further checks... */
id|ldn
op_assign
id|get_ldn
(braket
id|target
)braket
(braket
id|cmd-&gt;lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ldn
op_ge
id|MAX_LOG_DEV
)paren
multiline_comment|/* on invalid ldn do special stuff */
(brace
r_if
c_cond
(paren
id|ldn
OG
id|MAX_LOG_DEV
)paren
multiline_comment|/* dynamical remapping if ldn unassigned */
(brace
id|current_ldn
op_assign
id|next_ldn
suffix:semicolon
multiline_comment|/* stop-value for one circle */
r_while
c_loop
(paren
id|ld
(braket
id|next_ldn
)braket
dot
id|cmd
)paren
multiline_comment|/* search for a occupied, but not in */
(brace
multiline_comment|/* command-processing ldn. */
id|next_ldn
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|next_ldn
op_ge
id|MAX_LOG_DEV
)paren
id|next_ldn
op_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|current_ldn
op_eq
id|next_ldn
)paren
multiline_comment|/* One circle done ? */
(brace
multiline_comment|/* no non-processing ldn found */
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: Cannot assign SCSI-device dynamically!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;              On ldn 7-14 SCSI-commands everywhere in progress.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;              Reporting DID_NO_CONNECT for device (%d,%d).&bslash;n&quot;
comma
id|target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* return no connect*/
id|done
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* unmap non-processing ldn */
r_for
c_loop
(paren
id|id
op_assign
l_int|0
suffix:semicolon
id|id
OL
l_int|8
suffix:semicolon
id|id
op_increment
)paren
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
l_int|8
suffix:semicolon
id|lun
op_increment
)paren
(brace
r_if
c_cond
(paren
id|get_ldn
(braket
id|id
)braket
(braket
id|lun
)braket
op_eq
id|next_ldn
)paren
(brace
id|get_ldn
(braket
id|id
)braket
(braket
id|lun
)braket
op_assign
id|TYPE_NO_DEVICE
suffix:semicolon
multiline_comment|/* unmap entry */
r_goto
id|DYN_ASSIGN
suffix:semicolon
multiline_comment|/* jump out as fast as possible */
)brace
)brace
id|DYN_ASSIGN
suffix:colon
multiline_comment|/* unassign found ldn (pun,lun does not matter for remove) */
id|immediate_assign
c_func
(paren
id|shpnt
comma
l_int|0
comma
l_int|0
comma
id|next_ldn
comma
id|REMOVE_LDN
)paren
suffix:semicolon
multiline_comment|/* assign found ldn to aimed pun,lun */
id|immediate_assign
c_func
(paren
id|shpnt
comma
id|target
comma
id|cmd-&gt;lun
comma
id|next_ldn
comma
id|SET_LDN
)paren
suffix:semicolon
multiline_comment|/* map found ldn to pun,lun */
id|get_ldn
(braket
id|target
)braket
(braket
id|cmd-&gt;lun
)braket
op_assign
id|next_ldn
suffix:semicolon
multiline_comment|/* change ldn to the right value, that is now next_ldn */
id|ldn
op_assign
id|next_ldn
suffix:semicolon
multiline_comment|/* set reduced interrupt_handler-mode for checking */
id|local_checking_phase_flag
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* get device information for ld[ldn] */
r_if
c_cond
(paren
id|device_exists
(paren
id|shpnt
comma
id|ldn
comma
op_amp
id|ld
(braket
id|ldn
)braket
dot
id|block_length
comma
op_amp
id|ld
(braket
id|ldn
)braket
dot
id|device_type
)paren
)paren
(brace
id|ld
(braket
id|ldn
)braket
dot
id|cmd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* To prevent panic set 0, because&n;&t;&t;&t;&t;     devices that were not assigned,&n;&t;&t;&t;&t;     should have nothing in progress. */
multiline_comment|/* increase assignment counters for statistics in /proc */
id|IBM_DS.dynamical_assignments
op_increment
suffix:semicolon
id|IBM_DS.ldn_assignments
(braket
id|ldn
)braket
op_increment
suffix:semicolon
)brace
r_else
multiline_comment|/* panic here, because a device, found at boottime has &n;&t;&t;    vanished */
id|panic
c_func
(paren
l_string|&quot;IBM MCA SCSI: ldn=0x%x, SCSI-device on (%d,%d) vanished!&bslash;n&quot;
comma
id|ldn
comma
id|target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
multiline_comment|/* set back to normal interrupt_handling */
id|local_checking_phase_flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Information on syslog terminal */
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: ldn=0x%x dynamically reassigned to (%d,%d).&bslash;n&quot;
comma
id|ldn
comma
id|target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
multiline_comment|/* increase next_ldn for next dynamical assignment */
id|next_ldn
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|next_ldn
op_ge
id|MAX_LOG_DEV
)paren
id|next_ldn
op_assign
l_int|7
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* wall against Linux accesses to the subsystem adapter */
id|cmd-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|done
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*verify there is no command already in progress for this log dev */
r_if
c_cond
(paren
id|ld
(braket
id|ldn
)braket
dot
id|cmd
)paren
id|panic
(paren
l_string|&quot;IBM MCA SCSI: cmd already in progress for this ldn.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*save done in cmd, and save cmd for the interrupt handler */
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|ld
(braket
id|ldn
)braket
dot
id|cmd
op_assign
id|cmd
suffix:semicolon
multiline_comment|/*fill scb information independent of the scsi command */
id|scb
op_assign
op_amp
(paren
id|ld
(braket
id|ldn
)braket
dot
id|scb
)paren
suffix:semicolon
id|scb-&gt;enable
op_assign
id|IM_REPORT_TSB_ONLY_ON_ERROR
suffix:semicolon
id|scb-&gt;tsb_adr
op_assign
id|virt_to_bus
c_func
(paren
op_amp
(paren
id|ld
(braket
id|ldn
)braket
dot
id|tsb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
r_int
id|i
op_assign
id|cmd-&gt;use_sg
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sl
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|16
)paren
id|panic
(paren
l_string|&quot;IBM MCA SCSI: scatter-gather list too long.&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|i
op_ge
l_int|0
)paren
(brace
id|ld
(braket
id|ldn
)braket
dot
id|sge
(braket
id|i
)braket
dot
id|address
op_assign
(paren
r_void
op_star
)paren
id|virt_to_bus
c_func
(paren
id|sl
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
id|ld
(braket
id|ldn
)braket
dot
id|sge
(braket
id|i
)braket
dot
id|byte_length
op_assign
id|sl
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
id|scb-&gt;enable
op_or_assign
id|IM_POINTER_TO_LIST
suffix:semicolon
id|scb-&gt;sys_buf_adr
op_assign
id|virt_to_bus
c_func
(paren
op_amp
(paren
id|ld
(braket
id|ldn
)braket
dot
id|sge
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|scb-&gt;sys_buf_length
op_assign
id|cmd-&gt;use_sg
op_star
r_sizeof
(paren
r_struct
id|im_sge
)paren
suffix:semicolon
)brace
r_else
(brace
id|scb-&gt;sys_buf_adr
op_assign
id|virt_to_bus
c_func
(paren
id|cmd-&gt;request_buffer
)paren
suffix:semicolon
id|scb-&gt;sys_buf_length
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
)brace
multiline_comment|/*fill scb information dependent on scsi command */
id|scsi_cmd
op_assign
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#ifdef IM_DEBUG_CMD
id|printk
c_func
(paren
l_string|&quot;issue scsi cmd=%02x to ldn=%d&bslash;n&quot;
comma
id|scsi_cmd
comma
id|ldn
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* for specific device-type debugging: */
macro_line|#ifdef IM_DEBUG_CMD_SPEC_DEV
r_if
c_cond
(paren
id|ld
(braket
id|ldn
)braket
dot
id|device_type
op_eq
id|IM_DEBUG_CMD_DEVICE
)paren
id|printk
c_func
(paren
l_string|&quot;(SCSI-device-type=0x%x) issue scsi cmd=%02x to ldn=%d&bslash;n&quot;
comma
id|ld
(braket
id|ldn
)braket
dot
id|device_type
comma
id|scsi_cmd
comma
id|ldn
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* for possible panics store current command */
id|last_scsi_command
op_assign
id|scsi_cmd
suffix:semicolon
multiline_comment|/* update statistical info */
id|IBM_DS.total_accesses
op_increment
suffix:semicolon
id|IBM_DS.ldn_access
(braket
id|ldn
)braket
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|scsi_cmd
)paren
(brace
r_case
id|READ_6
suffix:colon
r_case
id|WRITE_6
suffix:colon
r_case
id|READ_10
suffix:colon
r_case
id|WRITE_10
suffix:colon
r_case
id|READ_12
suffix:colon
r_case
id|WRITE_12
suffix:colon
multiline_comment|/* statistics for proc_info */
r_if
c_cond
(paren
(paren
id|scsi_cmd
op_eq
id|READ_6
)paren
op_logical_or
(paren
id|scsi_cmd
op_eq
id|READ_10
)paren
op_logical_or
(paren
id|scsi_cmd
op_eq
id|READ_12
)paren
)paren
id|IBM_DS.ldn_read_access
(braket
id|ldn
)braket
op_increment
suffix:semicolon
multiline_comment|/* increase READ-access on ldn stat. */
r_else
r_if
c_cond
(paren
(paren
id|scsi_cmd
op_eq
id|WRITE_6
)paren
op_logical_or
(paren
id|scsi_cmd
op_eq
id|WRITE_10
)paren
op_logical_or
(paren
id|scsi_cmd
op_eq
id|WRITE_12
)paren
)paren
id|IBM_DS.ldn_write_access
(braket
id|ldn
)braket
op_increment
suffix:semicolon
multiline_comment|/* increase write-count on ldn stat.*/
multiline_comment|/* Distinguish between disk and other devices. Only disks (that are the&n;&t; most frequently accessed devices) should be supported by the &n;         IBM-SCSI-Subsystem commands. */
r_switch
c_cond
(paren
id|ld
(braket
id|ldn
)braket
dot
id|device_type
)paren
(brace
r_case
id|TYPE_DISK
suffix:colon
multiline_comment|/* for harddisks enter here ... */
r_case
id|TYPE_MOD
suffix:colon
multiline_comment|/* ... try it also for MO-drives (send flames as */
multiline_comment|/* you like, if this won&squot;t work.) */
r_if
c_cond
(paren
id|scsi_cmd
op_eq
id|READ_6
op_logical_or
id|scsi_cmd
op_eq
id|READ_10
op_logical_or
id|scsi_cmd
op_eq
id|READ_12
)paren
(brace
id|scb-&gt;command
op_assign
id|IM_READ_DATA_CMD
suffix:semicolon
id|scb-&gt;enable
op_or_assign
id|IM_READ_CONTROL
suffix:semicolon
)brace
r_else
(brace
id|scb-&gt;command
op_assign
id|IM_WRITE_DATA_CMD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsi_cmd
op_eq
id|READ_6
op_logical_or
id|scsi_cmd
op_eq
id|WRITE_6
)paren
(brace
id|scb-&gt;u1.log_blk_adr
op_assign
(paren
(paren
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|0
)paren
op_or
(paren
(paren
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
(paren
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|1
)braket
)paren
op_amp
l_int|0x1f
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|scb-&gt;u2.blk.count
op_assign
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
)brace
r_else
(brace
id|scb-&gt;u1.log_blk_adr
op_assign
(paren
(paren
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|5
)braket
)paren
op_lshift
l_int|0
)paren
op_or
(paren
(paren
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
)paren
suffix:semicolon
id|scb-&gt;u2.blk.count
op_assign
(paren
(paren
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|8
)braket
)paren
op_lshift
l_int|0
)paren
op_or
(paren
(paren
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
id|scb-&gt;u2.blk.length
op_assign
id|ld
(braket
id|ldn
)braket
dot
id|block_length
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|disk_rw_in_progress
op_eq
l_int|1
)paren
id|PS2_DISK_LED_ON
(paren
id|shpnt-&gt;host_no
comma
id|target
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* for other devices, enter here. Other types are not known by&n;&t;     Linux! TYPE_NO_LUN is forbidden as valid device. */
r_case
id|TYPE_ROM
suffix:colon
r_case
id|TYPE_TAPE
suffix:colon
r_case
id|TYPE_PROCESSOR
suffix:colon
r_case
id|TYPE_WORM
suffix:colon
r_case
id|TYPE_SCANNER
suffix:colon
r_case
id|TYPE_MEDIUM_CHANGER
suffix:colon
multiline_comment|/* If there is a sequential-device, IBM recommends to use&n;&t;      IM_OTHER_SCSI_CMD_CMD instead of subsystem READ/WRITE. &n;&t;      Good/modern CD-ROM-drives are capable of&n;&t;      reading sequential AND random-access. This leads to the problem,&n;&t;      that random-accesses are covered by the subsystem, but &n;&t;      sequentials are not, as like for tape-drives. Therefore, it is&n;&t;      the easiest way to use IM_OTHER_SCSI_CMD_CMD for all read-ops&n;&t;      on CD-ROM-drives in order not to run into timing problems and&n;&t;      to have a stable state. In addition, data-access on CD-ROMs&n;&t;      works faster like that. Strange, but obvious. */
id|scb-&gt;command
op_assign
id|IM_OTHER_SCSI_CMD_CMD
suffix:semicolon
r_if
c_cond
(paren
id|scsi_cmd
op_eq
id|READ_6
op_logical_or
id|scsi_cmd
op_eq
id|READ_10
op_logical_or
id|scsi_cmd
op_eq
id|READ_12
)paren
multiline_comment|/* enable READ */
id|scb-&gt;enable
op_or_assign
id|IM_READ_CONTROL
op_or
id|IM_SUPRESS_EXCEPTION_SHORT
suffix:semicolon
r_else
id|scb-&gt;enable
op_or_assign
id|IM_SUPRESS_EXCEPTION_SHORT
suffix:semicolon
multiline_comment|/* assume WRITE */
id|scb-&gt;u1.scsi_cmd_length
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|memcpy
(paren
id|scb-&gt;u2.scsi_command
comma
id|cmd-&gt;cmnd
comma
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
multiline_comment|/* Read/write on this non-disk devices is also displayworthy, &n;&t;      so flash-up the LED/display. */
r_if
c_cond
(paren
op_increment
id|disk_rw_in_progress
op_eq
l_int|1
)paren
id|PS2_DISK_LED_ON
(paren
id|shpnt-&gt;host_no
comma
id|target
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|INQUIRY
suffix:colon
id|IBM_DS.ldn_inquiry_access
(braket
id|ldn
)braket
op_increment
suffix:semicolon
id|scb-&gt;command
op_assign
id|IM_DEVICE_INQUIRY_CMD
suffix:semicolon
id|scb-&gt;enable
op_or_assign
id|IM_READ_CONTROL
op_or
id|IM_SUPRESS_EXCEPTION_SHORT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ_CAPACITY
suffix:colon
id|scb-&gt;command
op_assign
id|IM_READ_CAPACITY_CMD
suffix:semicolon
id|scb-&gt;enable
op_or_assign
id|IM_READ_CONTROL
suffix:semicolon
multiline_comment|/* the length of system memory buffer must be exactly 8 bytes */
r_if
c_cond
(paren
id|scb-&gt;sys_buf_length
op_ge
l_int|8
)paren
id|scb-&gt;sys_buf_length
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Commands that need read-only-mode (system &lt;- device): */
r_case
id|REQUEST_SENSE
suffix:colon
id|scb-&gt;command
op_assign
id|IM_REQUEST_SENSE_CMD
suffix:semicolon
id|scb-&gt;enable
op_or_assign
id|IM_READ_CONTROL
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Commands that need write-only-mode (system -&gt; device): */
r_case
id|MODE_SELECT
suffix:colon
r_case
id|MODE_SELECT_10
suffix:colon
id|IBM_DS.ldn_modeselect_access
(braket
id|ldn
)braket
op_increment
suffix:semicolon
id|scb-&gt;command
op_assign
id|IM_OTHER_SCSI_CMD_CMD
suffix:semicolon
id|scb-&gt;enable
op_or_assign
id|IM_SUPRESS_EXCEPTION_SHORT
suffix:semicolon
multiline_comment|/*Select needs WRITE-enabled*/
id|scb-&gt;u1.scsi_cmd_length
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|memcpy
(paren
id|scb-&gt;u2.scsi_command
comma
id|cmd-&gt;cmnd
comma
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* For other commands, read-only is useful. Most other commands are &n;       running without an input-data-block. */
r_default
suffix:colon
id|scb-&gt;command
op_assign
id|IM_OTHER_SCSI_CMD_CMD
suffix:semicolon
id|scb-&gt;enable
op_or_assign
id|IM_READ_CONTROL
op_or
id|IM_SUPRESS_EXCEPTION_SHORT
suffix:semicolon
id|scb-&gt;u1.scsi_cmd_length
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|memcpy
(paren
id|scb-&gt;u2.scsi_command
comma
id|cmd-&gt;cmnd
comma
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*issue scb command, and return */
id|issue_cmd
(paren
id|shpnt
comma
id|virt_to_bus
c_func
(paren
id|scb
)paren
comma
id|IM_SCB
op_or
id|ldn
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*--------------------------------------------------------------------*/
r_int
DECL|function|ibmmca_abort
id|ibmmca_abort
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/* The code below doesn&squot;t work right now, so we tell the upper layer&n;     that we can&squot;t abort. This eventually causes a reset.&n;     */
r_return
id|SCSI_ABORT_SNOOZE
suffix:semicolon
macro_line|#if 0
r_struct
id|Scsi_host
op_star
id|shpnt
op_assign
id|cmd-&gt;host
suffix:semicolon
r_int
r_int
id|ldn
suffix:semicolon
r_void
(paren
op_star
id|saved_done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IBMMCA_SCSI_ORDER_STANDARD
r_int
id|target
op_assign
l_int|6
op_minus
id|cmd-&gt;target
suffix:semicolon
macro_line|#else
r_int
id|target
op_assign
id|cmd-&gt;target
suffix:semicolon
macro_line|#endif
multiline_comment|/*get logical device number, and disable system interrupts */
id|printk
(paren
l_string|&quot;IBM MCA SCSI: sending abort to device id=%d lun=%d.&bslash;n&quot;
comma
id|target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|ldn
op_assign
id|get_ldn
(braket
id|target
)braket
(braket
id|cmd-&gt;lun
)braket
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
multiline_comment|/*if cmd for this ldn has already finished, no need to abort */
r_if
c_cond
(paren
op_logical_neg
id|ld
(braket
id|ldn
)braket
dot
id|cmd
)paren
(brace
multiline_comment|/* sti (); */
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
multiline_comment|/* Clear ld.cmd, save done function, install internal done, &n;   * send abort immediate command (this enables sys. interrupts), &n;   * and wait until the interrupt arrives. &n;   */
id|ld
(braket
id|ldn
)braket
dot
id|cmd
op_assign
l_int|0
suffix:semicolon
id|saved_done
op_assign
id|cmd-&gt;scsi_done
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|internal_done
suffix:semicolon
id|cmd-&gt;SCp.Status
op_assign
l_int|0
suffix:semicolon
id|issue_cmd
(paren
id|shpnt
comma
id|T_IMM_CMD
comma
id|IM_IMM_CMD
op_or
id|ldn
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|cmd-&gt;SCp.Status
)paren
id|barrier
(paren
)paren
suffix:semicolon
multiline_comment|/*if abort went well, call saved done, then return success or error */
r_if
c_cond
(paren
id|cmd-&gt;result
op_eq
l_int|0
)paren
(brace
id|cmd-&gt;result
op_or_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|saved_done
(paren
id|cmd
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
r_else
r_return
id|SCSI_ABORT_ERROR
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*--------------------------------------------------------------------*/
r_int
DECL|function|ibmmca_reset
id|ibmmca_reset
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_int
id|reset_flags
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shpnt
op_assign
id|cmd-&gt;host
suffix:semicolon
r_int
id|ticks
op_assign
id|IM_RESET_DELAY
op_star
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|local_checking_phase_flag
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: unable to reset while checking devices.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|SCSI_RESET_SNOOZE
suffix:semicolon
)brace
multiline_comment|/* issue reset immediate command to subsystem, and wait for interrupt */
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: resetting all devices.&bslash;n&quot;
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|reset_status
op_assign
id|IM_RESET_IN_PROGRESS
suffix:semicolon
id|issue_cmd
(paren
id|shpnt
comma
id|IM_RESET_IMM_CMD
comma
id|IM_IMM_CMD
op_or
l_int|0xf
)paren
suffix:semicolon
r_while
c_loop
(paren
id|reset_status
op_eq
id|IM_RESET_IN_PROGRESS
op_logical_and
op_decrement
id|ticks
)paren
(brace
id|mdelay
c_func
(paren
l_int|1
op_plus
l_int|999
op_div
id|HZ
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* if reset did not complete, just return an error*/
r_if
c_cond
(paren
op_logical_neg
id|ticks
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: reset did not complete within %d seconds.&bslash;n&quot;
comma
id|IM_RESET_DELAY
)paren
suffix:semicolon
id|reset_status
op_assign
id|IM_RESET_FINISHED_FAIL
suffix:semicolon
r_return
id|SCSI_RESET_ERROR
suffix:semicolon
)brace
multiline_comment|/* if reset failed, just return an error */
r_if
c_cond
(paren
id|reset_status
op_eq
id|IM_RESET_FINISHED_FAIL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IBM MCA SCSI: reset failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|SCSI_RESET_ERROR
suffix:semicolon
)brace
multiline_comment|/* so reset finished ok - call outstanding done&squot;s, and return success */
id|printk
(paren
l_string|&quot;IBM MCA SCSI: reset completed without error.&bslash;n&quot;
)paren
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_LOG_DEV
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
op_assign
id|ld
(braket
id|i
)braket
dot
id|cmd
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_logical_and
id|cmd-&gt;scsi_done
)paren
(brace
id|ld
(braket
id|i
)braket
dot
id|cmd
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_RESET
suffix:semicolon
(paren
id|cmd-&gt;scsi_done
)paren
(paren
id|cmd
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|SCSI_RESET_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*--------------------------------------------------------------------*/
r_int
DECL|function|ibmmca_biosparam
id|ibmmca_biosparam
(paren
id|Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
op_star
id|info
)paren
(brace
id|info
(braket
l_int|0
)braket
op_assign
l_int|64
suffix:semicolon
id|info
(braket
l_int|1
)braket
op_assign
l_int|32
suffix:semicolon
id|info
(braket
l_int|2
)braket
op_assign
id|disk-&gt;capacity
op_div
(paren
id|info
(braket
l_int|0
)braket
op_star
id|info
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
(braket
l_int|2
)braket
op_ge
l_int|1024
)paren
(brace
id|info
(braket
l_int|0
)braket
op_assign
l_int|128
suffix:semicolon
id|info
(braket
l_int|1
)braket
op_assign
l_int|63
suffix:semicolon
id|info
(braket
l_int|2
)braket
op_assign
id|disk-&gt;capacity
op_div
(paren
id|info
(braket
l_int|0
)braket
op_star
id|info
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
(braket
l_int|2
)braket
op_ge
l_int|1024
)paren
(brace
id|info
(braket
l_int|0
)braket
op_assign
l_int|255
suffix:semicolon
id|info
(braket
l_int|1
)braket
op_assign
l_int|63
suffix:semicolon
id|info
(braket
l_int|2
)braket
op_assign
id|disk-&gt;capacity
op_div
(paren
id|info
(braket
l_int|0
)braket
op_star
id|info
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
(braket
l_int|2
)braket
op_ge
l_int|1024
)paren
id|info
(braket
l_int|2
)braket
op_assign
l_int|1023
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* calculate percentage of total accesses on a ldn */
DECL|function|ldn_access_load
r_static
r_int
id|ldn_access_load
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_int
id|ldn
)paren
(brace
r_if
c_cond
(paren
id|IBM_DS.total_accesses
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IBM_DS.ldn_access
(braket
id|ldn
)braket
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|IBM_DS.ldn_access
(braket
id|ldn
)braket
op_star
l_int|100
)paren
op_div
id|IBM_DS.total_accesses
suffix:semicolon
)brace
multiline_comment|/* calculate total amount of r/w-accesses */
DECL|function|ldn_access_total_read_write
r_static
r_int
id|ldn_access_total_read_write
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_int
id|a
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|MAX_LOG_DEV
suffix:semicolon
id|i
op_increment
)paren
id|a
op_add_assign
id|IBM_DS.ldn_read_access
(braket
id|i
)braket
op_plus
id|IBM_DS.ldn_write_access
(braket
id|i
)braket
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
DECL|function|ldn_access_total_inquiry
r_static
r_int
id|ldn_access_total_inquiry
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_int
id|a
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|MAX_LOG_DEV
suffix:semicolon
id|i
op_increment
)paren
id|a
op_add_assign
id|IBM_DS.ldn_inquiry_access
(braket
id|i
)braket
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
DECL|function|ldn_access_total_modeselect
r_static
r_int
id|ldn_access_total_modeselect
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_int
id|a
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|MAX_LOG_DEV
suffix:semicolon
id|i
op_increment
)paren
id|a
op_add_assign
id|IBM_DS.ldn_modeselect_access
(braket
id|i
)braket
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
multiline_comment|/* routine to display info in the proc-fs-structure (a deluxe feature) */
DECL|function|ibmmca_proc_info
r_int
id|ibmmca_proc_info
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|inout
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|id
comma
id|lun
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|hosts
(braket
id|i
)braket
op_logical_and
id|hosts
(braket
id|i
)braket
op_member_access_from_pointer
id|host_no
op_ne
id|hostno
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
id|shpnt
op_assign
id|hosts
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|shpnt
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;nCan&squot;t find adapter for host number %d&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;n             IBM-SCSI-Subsystem-Linux-Driver, Version %s&bslash;n&bslash;n&bslash;n&quot;
comma
id|IBMMCA_SCSI_DRIVER_VERSION
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot; SCSI Access-Statistics:&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IBMMCA_SCSI_ORDER_STANDARD
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;               ANSI-SCSI-standard order.: Yes&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;               ANSI-SCSI-standard order.: No&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SCSI_MULTI_LUN
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;               Multiple LUN probing.....: Yes&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;               Multiple LUN probing.....: No&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;               This Hostnumber..........: %d&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;               Base I/O-Port............: 0x%lx&bslash;n&quot;
comma
id|IM_CMD_REG
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;               (Shared) IRQ.............: %d&bslash;n&quot;
comma
id|IM_IRQ
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;               Total Interrupts.........: %d&bslash;n&quot;
comma
id|IBM_DS.total_interrupts
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;               Total SCSI Accesses......: %d&bslash;n&quot;
comma
id|IBM_DS.total_accesses
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;                 Total SCSI READ/WRITE..: %d&bslash;n&quot;
comma
id|ldn_access_total_read_write
c_func
(paren
id|shpnt
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;                 Total SCSI Inquiries...: %d&bslash;n&quot;
comma
id|ldn_access_total_inquiry
c_func
(paren
id|shpnt
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;                 Total SCSI Modeselects.: %d&bslash;n&quot;
comma
id|ldn_access_total_modeselect
c_func
(paren
id|shpnt
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;                 Total SCSI other cmds..: %d&bslash;n&bslash;n&quot;
comma
id|IBM_DS.total_accesses
op_minus
id|ldn_access_total_read_write
c_func
(paren
id|shpnt
)paren
op_minus
id|ldn_access_total_modeselect
c_func
(paren
id|shpnt
)paren
op_minus
id|ldn_access_total_inquiry
c_func
(paren
id|shpnt
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot; Logical-Device-Number (LDN) Access-Statistics:&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;         LDN | Accesses [%%] |   READ    |   WRITE   | ASSIGNMENTS&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;        -----|--------------|-----------|-----------|--------------&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|MAX_LOG_DEV
suffix:semicolon
id|i
op_increment
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;         %2X  |    %3d       |  %8d |  %8d | %8d&bslash;n&quot;
comma
id|i
comma
id|ldn_access_load
c_func
(paren
id|shpnt
comma
id|i
)paren
comma
id|IBM_DS.ldn_read_access
(braket
id|i
)braket
comma
id|IBM_DS.ldn_write_access
(braket
id|i
)braket
comma
id|IBM_DS.ldn_assignments
(braket
id|i
)braket
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;        -----------------------------------------------------------&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot; Dynamical-LDN-Assignment-Statistics:&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;               Number of physical SCSI-devices..: %d (+ Adapter)&bslash;n&quot;
comma
id|IBM_DS.total_scsi_devices
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;               Dynamical Assignment necessaray..: %s&bslash;n&quot;
comma
id|IBM_DS.dyn_flag
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No &quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;               Next LDN to be assigned..........: 0x%x&bslash;n&quot;
comma
id|next_ldn
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;               Dynamical assignments done yet...: %d&bslash;n&quot;
comma
id|IBM_DS.dynamical_assignments
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;n Current SCSI-Device-Mapping:&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;        Physical SCSI-Device Map               Logical SCSI-Device Map&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;    ID&bslash;&bslash;LUN  0  1  2  3  4  5  6  7       ID&bslash;&bslash;LUN  0  1  2  3  4  5  6  7&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|id
op_assign
l_int|0
suffix:semicolon
id|id
op_le
l_int|7
suffix:semicolon
id|id
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;    %2d     %2s %2s %2s %2s %2s %2s %2s %2s&quot;
comma
id|id
comma
id|ti_p
c_func
(paren
id|get_scsi
(braket
id|id
)braket
(braket
l_int|0
)braket
)paren
comma
id|ti_p
c_func
(paren
id|get_scsi
(braket
id|id
)braket
(braket
l_int|1
)braket
)paren
comma
id|ti_p
c_func
(paren
id|get_scsi
(braket
id|id
)braket
(braket
l_int|2
)braket
)paren
comma
id|ti_p
c_func
(paren
id|get_scsi
(braket
id|id
)braket
(braket
l_int|3
)braket
)paren
comma
id|ti_p
c_func
(paren
id|get_scsi
(braket
id|id
)braket
(braket
l_int|4
)braket
)paren
comma
id|ti_p
c_func
(paren
id|get_scsi
(braket
id|id
)braket
(braket
l_int|5
)braket
)paren
comma
id|ti_p
c_func
(paren
id|get_scsi
(braket
id|id
)braket
(braket
l_int|6
)braket
)paren
comma
id|ti_p
c_func
(paren
id|get_scsi
(braket
id|id
)braket
(braket
l_int|7
)braket
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;       %2d     &quot;
comma
id|id
)paren
suffix:semicolon
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
l_int|8
suffix:semicolon
id|lun
op_increment
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%2s &quot;
comma
id|ti_l
c_func
(paren
id|get_ldn
(braket
id|id
)braket
(braket
id|lun
)braket
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;(A = IBM-Subsystem, D = Harddisk, T = Tapedrive, P = Processor, W = WORM,&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot; R = CD-ROM, S = Scanner, M = MO-Drive, C = Medium-Changer, + = unprovided LUN,&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot; - = nothing found)&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
id|len
op_sub_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#ifdef MODULE
multiline_comment|/* Eventually this will go into an include file, but this will be later */
DECL|variable|driver_template
id|Scsi_Host_Template
id|driver_template
op_assign
id|IBMMCA
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
macro_line|#endif
multiline_comment|/*--------------------------------------------------------------------*/
eof
