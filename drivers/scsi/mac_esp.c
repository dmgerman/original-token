multiline_comment|/*&n; * 68k mac 53c9[46] scsi driver&n; *&n; * copyright (c) 1998, David Weis weisd3458@uni.edu&n; *&n; * debugging on Quadra 800 and 660AV Michael Schmitz, Dave Kilzer 7/98&n; *&n; * based loosely on cyber_esp.c&n; */
multiline_comment|/* these are unused for now */
DECL|macro|myreadl
mdefine_line|#define myreadl(addr) (*(volatile unsigned int *) (addr))
DECL|macro|mywritel
mdefine_line|#define mywritel(b, addr) ((*(volatile unsigned int *) (addr)) = (b))
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;NCR53C9x.h&quot;
macro_line|#include &quot;mac_esp.h&quot;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/macints.h&gt;
macro_line|#include &lt;asm/machw.h&gt;
macro_line|#include &lt;asm/mac_via.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/macintosh.h&gt;
DECL|macro|mac_turnon_irq
mdefine_line|#define mac_turnon_irq(x)&t;mac_enable_irq(x)
DECL|macro|mac_turnoff_irq
mdefine_line|#define mac_turnoff_irq(x)&t;mac_disable_irq(x)
r_extern
r_inline
r_void
id|esp_handle
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
suffix:semicolon
r_extern
r_void
id|mac_esp_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|pregs
)paren
suffix:semicolon
r_static
r_int
id|dma_bytes_sent
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_int
id|fifo_count
)paren
suffix:semicolon
r_static
r_int
id|dma_can_transfer
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|sp
)paren
suffix:semicolon
r_static
r_void
id|dma_dump_state
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
suffix:semicolon
r_static
r_void
id|dma_init_read
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_char
op_star
id|vaddress
comma
r_int
id|length
)paren
suffix:semicolon
r_static
r_void
id|dma_init_write
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_char
op_star
id|vaddress
comma
r_int
id|length
)paren
suffix:semicolon
r_static
r_void
id|dma_ints_off
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
suffix:semicolon
r_static
r_void
id|dma_ints_on
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
suffix:semicolon
r_static
r_int
id|dma_irq_p
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
suffix:semicolon
r_static
r_int
id|dma_irq_p_quick
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
suffix:semicolon
r_static
r_void
id|dma_led_off
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
suffix:semicolon
r_static
r_void
id|dma_led_on
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
suffix:semicolon
r_static
r_int
id|dma_ports_p
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
suffix:semicolon
r_static
r_void
id|dma_setup
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
id|__u32
id|addr
comma
r_int
id|count
comma
r_int
id|write
)paren
suffix:semicolon
r_static
r_void
id|dma_setup_quick
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
id|__u32
id|addr
comma
r_int
id|count
comma
r_int
id|write
)paren
suffix:semicolon
r_static
r_int
id|esp_dafb_dma_irq_p
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|espdev
)paren
suffix:semicolon
r_static
r_int
id|esp_iosb_dma_irq_p
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|espdev
)paren
suffix:semicolon
DECL|variable|cmd_buffer
r_volatile
r_int
r_char
id|cmd_buffer
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* This is where all commands are put&n;&t;&t;&t;&t; * before they are transfered to the ESP chip&n;&t;&t;&t;&t; * via PIO.&n;&t;&t;&t;&t; */
DECL|variable|esp_initialized
r_static
r_int
id|esp_initialized
op_assign
l_int|0
suffix:semicolon
DECL|variable|setup_num_esps
r_static
r_int
id|setup_num_esps
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|setup_disconnect
r_static
r_int
id|setup_disconnect
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|setup_nosync
r_static
r_int
id|setup_nosync
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|setup_can_queue
r_static
r_int
id|setup_can_queue
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|setup_cmd_per_lun
r_static
r_int
id|setup_cmd_per_lun
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|setup_sg_tablesize
r_static
r_int
id|setup_sg_tablesize
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef SUPPORT_TAGS
DECL|variable|setup_use_tagged_queuing
r_static
r_int
id|setup_use_tagged_queuing
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
DECL|variable|setup_hostid
r_static
r_int
id|setup_hostid
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Experimental ESP inthandler; check macints.c to make sure dev_id is &n; * set up properly!&n; */
DECL|function|mac_esp_intr
r_void
id|mac_esp_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|pregs
)paren
(brace
r_struct
id|NCR_ESP
op_star
id|esp
op_assign
(paren
r_struct
id|NCR_ESP
op_star
)paren
id|dev_id
suffix:semicolon
r_int
id|irq_p
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Handle the one ESP interrupt showing at this IRQ level. */
r_if
c_cond
(paren
(paren
(paren
id|esp
)paren
op_member_access_from_pointer
id|irq
op_amp
l_int|0xff
)paren
op_eq
id|irq
)paren
(brace
multiline_comment|/*&n;&t; * Debug ..&n;&t; */
id|irq_p
op_assign
id|esp
op_member_access_from_pointer
id|dma_irq_p
c_func
(paren
id|esp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;mac_esp: irq_p %x current %p disconnected %p&bslash;n&quot;
comma
id|irq_p
comma
id|esp-&gt;current_SC
comma
id|esp-&gt;disconnected_SC
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Mac: if we&squot;re here, it&squot;s an ESP interrupt for sure!&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|esp-&gt;current_SC
op_logical_or
id|esp-&gt;disconnected_SC
)paren
)paren
(brace
id|esp
op_member_access_from_pointer
id|dma_ints_off
c_func
(paren
id|esp
)paren
suffix:semicolon
id|ESPIRQ
c_func
(paren
(paren
l_string|&quot;I%d(&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp_handle
c_func
(paren
id|esp
)paren
suffix:semicolon
id|ESPIRQ
c_func
(paren
(paren
l_string|&quot;)&quot;
)paren
)paren
suffix:semicolon
id|esp
op_member_access_from_pointer
id|dma_ints_on
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Debug hooks; use for playing with the interrupt flag testing and interrupt&n; * acknowledge on the various machines&n; */
DECL|function|scsi_esp_polled
r_void
id|scsi_esp_polled
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|pregs
)paren
(brace
r_if
c_cond
(paren
id|esp_initialized
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|mac_esp_intr
c_func
(paren
id|irq
comma
id|dev_id
comma
id|pregs
)paren
suffix:semicolon
)brace
DECL|function|fake_intr
r_void
id|fake_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|pregs
)paren
(brace
macro_line|#ifdef DEBUG_MAC_ESP
id|printk
c_func
(paren
l_string|&quot;mac_esp: got irq&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|mac_esp_intr
c_func
(paren
id|irq
comma
id|dev_id
comma
id|pregs
)paren
suffix:semicolon
)brace
DECL|function|fake_drq
r_void
id|fake_drq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|pregs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mac_esp: got drq&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|macro|DRIVER_SETUP
mdefine_line|#define DRIVER_SETUP
multiline_comment|/*&n; * Function : mac_esp_setup(char *str, int *ints)&n; *&n; * Purpose : booter command line initialization of the overrides array,&n; *&n; * Inputs : str - unused, ints - array of integer parameters with ints[0]&n; *&t;equal to the number of ints.&n; *&n; * Currently unused in the new driver; need to add settable parameters to the &n; * detect function.&n; *&n; */
DECL|function|mac_esp_setup
r_static
r_int
id|__init
id|mac_esp_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
macro_line|#ifdef DRIVER_SETUP
multiline_comment|/* Format of mac53c9x parameter is:&n;&t; *   mac53c9x=&lt;num_esps&gt;,&lt;disconnect&gt;,&lt;nosync&gt;,&lt;can_queue&gt;,&lt;cmd_per_lun&gt;,&lt;sg_tablesize&gt;,&lt;hostid&gt;,&lt;use_tags&gt;&n;&t; * Negative values mean don&squot;t change.&n;&t; */
multiline_comment|/* Grmbl... the standard parameter parsing can&squot;t handle negative numbers&n;&t; * :-( So let&squot;s do it ourselves!&n;&t; */
r_int
id|i
op_assign
id|ints
(braket
l_int|0
)braket
op_plus
l_int|1
comma
id|fact
suffix:semicolon
r_while
c_loop
(paren
id|str
op_logical_and
(paren
id|isdigit
c_func
(paren
op_star
id|str
)paren
op_logical_or
op_star
id|str
op_eq
l_char|&squot;-&squot;
)paren
op_logical_and
id|i
op_le
l_int|10
)paren
(brace
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;-&squot;
)paren
id|fact
op_assign
op_minus
l_int|1
comma
op_increment
id|str
suffix:semicolon
r_else
id|fact
op_assign
l_int|1
suffix:semicolon
id|ints
(braket
id|i
op_increment
)braket
op_assign
id|simple_strtoul
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
op_star
id|fact
suffix:semicolon
r_if
c_cond
(paren
(paren
id|str
op_assign
id|strchr
c_func
(paren
id|str
comma
l_char|&squot;,&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
op_increment
id|str
suffix:semicolon
)brace
id|ints
(braket
l_int|0
)braket
op_assign
id|i
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OL
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mac_esp_setup: no arguments!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|1
)braket
OG
l_int|0
)paren
multiline_comment|/* no limits on this, just &gt; 0 */
r_if
c_cond
(paren
id|ints
(braket
l_int|1
)braket
op_ge
l_int|0
op_logical_and
id|ints
(braket
l_int|1
)braket
op_le
l_int|2
)paren
id|setup_num_esps
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ints
(braket
l_int|1
)braket
OG
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;mac_esp_setup: invalid number of hosts %d !&bslash;n&quot;
comma
id|ints
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|2
)braket
OG
l_int|0
)paren
id|setup_disconnect
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|3
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|3
)braket
op_ge
l_int|0
)paren
(brace
id|setup_nosync
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|4
)braket
OG
l_int|0
)paren
multiline_comment|/* no limits on this, just &gt; 0 */
id|setup_can_queue
op_assign
id|ints
(braket
l_int|4
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|5
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|5
)braket
OG
l_int|0
)paren
id|setup_cmd_per_lun
op_assign
id|ints
(braket
l_int|5
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|6
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|6
)braket
op_ge
l_int|0
)paren
(brace
id|setup_sg_tablesize
op_assign
id|ints
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* Must be &lt;= SG_ALL (255) */
r_if
c_cond
(paren
id|setup_sg_tablesize
OG
id|SG_ALL
)paren
id|setup_sg_tablesize
op_assign
id|SG_ALL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|7
)paren
(brace
multiline_comment|/* Must be between 0 and 7 */
r_if
c_cond
(paren
id|ints
(braket
l_int|7
)braket
op_ge
l_int|0
op_logical_and
id|ints
(braket
l_int|7
)braket
op_le
l_int|7
)paren
id|setup_hostid
op_assign
id|ints
(braket
l_int|7
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ints
(braket
l_int|7
)braket
OG
l_int|7
)paren
id|printk
c_func
(paren
l_string|&quot;mac_esp_setup: invalid host ID %d !&bslash;n&quot;
comma
id|ints
(braket
l_int|7
)braket
)paren
suffix:semicolon
)brace
macro_line|#ifdef SUPPORT_TAGS
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|8
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|8
)braket
op_ge
l_int|0
)paren
id|setup_use_tagged_queuing
op_assign
op_logical_neg
op_logical_neg
id|ints
(braket
l_int|8
)braket
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;mac53c9x=&quot;
comma
id|mac_esp_setup
)paren
suffix:semicolon
multiline_comment|/*&n; * ESP address &squot;detection&squot;&n; */
DECL|function|get_base
r_int
r_int
id|get_base
c_func
(paren
r_int
id|chip_num
)paren
(brace
multiline_comment|/*&n;&t; * using the chip_num and mac model, figure out where the&n;&t; * chips are mapped&n;&t; */
r_int
r_int
id|io_base
op_assign
l_int|0x50f00000
suffix:semicolon
r_int
r_int
id|second_offset
op_assign
l_int|0x402
suffix:semicolon
r_int
r_int
id|scsi_loc
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|macintosh_config-&gt;scsi_type
)paren
(brace
multiline_comment|/* 950, 900, 700 */
r_case
id|MAC_SCSI_QUADRA2
suffix:colon
id|scsi_loc
op_assign
id|io_base
op_plus
l_int|0xf000
op_plus
(paren
(paren
id|chip_num
op_eq
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
id|second_offset
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* av&squot;s */
r_case
id|MAC_SCSI_QUADRA3
suffix:colon
id|scsi_loc
op_assign
id|io_base
op_plus
l_int|0x18000
op_plus
(paren
(paren
id|chip_num
op_eq
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
id|second_offset
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* most quadra/centris models are like this */
r_case
id|MAC_SCSI_QUADRA
suffix:colon
id|scsi_loc
op_assign
id|io_base
op_plus
l_int|0x10000
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;mac_esp: get_base: hit default!&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_loc
op_assign
id|io_base
op_plus
l_int|0x10000
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* switch */
id|printk
c_func
(paren
l_string|&quot;mac_esp: io base at 0x%lx&bslash;n&quot;
comma
id|scsi_loc
)paren
suffix:semicolon
r_return
id|scsi_loc
suffix:semicolon
)brace
multiline_comment|/*&n; * Model dependent ESP setup&n; */
DECL|function|mac_esp_detect
r_int
id|mac_esp_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|quick
op_assign
l_int|0
suffix:semicolon
r_int
id|chipnum
comma
id|chipspresent
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
r_int
r_int
id|timeout
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|esp_initialized
OG
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* what do we have in this machine... */
r_if
c_cond
(paren
id|MACHW_PRESENT
c_func
(paren
id|MAC_SCSI_96
)paren
)paren
(brace
id|chipspresent
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MACHW_PRESENT
c_func
(paren
id|MAC_SCSI_96_2
)paren
)paren
(brace
id|chipspresent
op_increment
suffix:semicolon
)brace
multiline_comment|/* number of ESPs present ? */
r_if
c_cond
(paren
id|setup_num_esps
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|chipspresent
op_ge
id|setup_num_esps
)paren
id|chipspresent
op_assign
id|setup_num_esps
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;mac_esp_detect: num_hosts detected %d setup %d &bslash;n&quot;
comma
id|chipspresent
comma
id|setup_num_esps
)paren
suffix:semicolon
)brace
multiline_comment|/* TODO: add disconnect / nosync flags */
multiline_comment|/* setup variables */
id|tpnt-&gt;can_queue
op_assign
(paren
id|setup_can_queue
OG
l_int|0
)paren
ques
c_cond
id|setup_can_queue
suffix:colon
l_int|7
suffix:semicolon
id|tpnt-&gt;cmd_per_lun
op_assign
(paren
id|setup_cmd_per_lun
OG
l_int|0
)paren
ques
c_cond
id|setup_cmd_per_lun
suffix:colon
l_int|1
suffix:semicolon
id|tpnt-&gt;sg_tablesize
op_assign
(paren
id|setup_sg_tablesize
op_ge
l_int|0
)paren
ques
c_cond
id|setup_sg_tablesize
suffix:colon
id|SG_ALL
suffix:semicolon
r_if
c_cond
(paren
id|setup_hostid
op_ge
l_int|0
)paren
id|tpnt-&gt;this_id
op_assign
id|setup_hostid
suffix:semicolon
r_else
(brace
multiline_comment|/* use 7 as default */
id|tpnt-&gt;this_id
op_assign
l_int|7
suffix:semicolon
)brace
macro_line|#ifdef SUPPORT_TAGS
r_if
c_cond
(paren
id|setup_use_tagged_queuing
OL
l_int|0
)paren
id|setup_use_tagged_queuing
op_assign
id|DEFAULT_USE_TAGGED_QUEUING
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|chipnum
op_assign
l_int|0
suffix:semicolon
id|chipnum
OL
id|chipspresent
suffix:semicolon
id|chipnum
op_increment
)paren
(brace
r_struct
id|NCR_ESP
op_star
id|esp
suffix:semicolon
id|esp
op_assign
id|esp_allocate
c_func
(paren
id|tpnt
comma
(paren
r_void
op_star
)paren
l_int|NULL
)paren
suffix:semicolon
id|esp-&gt;eregs
op_assign
(paren
r_struct
id|ESP_regs
op_star
)paren
id|get_base
c_func
(paren
id|chipnum
)paren
suffix:semicolon
id|esp-&gt;dma_irq_p
op_assign
op_amp
id|esp_dafb_dma_irq_p
suffix:semicolon
r_if
c_cond
(paren
id|chipnum
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|macintosh_config-&gt;scsi_type
op_eq
id|MAC_SCSI_QUADRA
)paren
(brace
multiline_comment|/* most machines except those below :-) */
id|quick
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;dma_irq_p
op_assign
op_amp
id|esp_iosb_dma_irq_p
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;scsi_type
op_eq
id|MAC_SCSI_QUADRA3
)paren
(brace
multiline_comment|/* mostly av&squot;s */
id|quick
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* q950, 900, 700 */
id|quick
op_assign
l_int|1
suffix:semicolon
id|writel
c_func
(paren
l_int|0x1d1
comma
l_int|0xf9800024
)paren
suffix:semicolon
id|esp-&gt;dregs
op_assign
(paren
r_void
op_star
)paren
l_int|0xf9800024
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* chipnum */
id|quick
op_assign
l_int|1
suffix:semicolon
id|writel
c_func
(paren
l_int|0x1d1
comma
l_int|0xf9800028
)paren
suffix:semicolon
id|esp-&gt;dregs
op_assign
(paren
r_void
op_star
)paren
l_int|0xf9800028
suffix:semicolon
)brace
multiline_comment|/* chipnum == 0 */
multiline_comment|/* use pio for command bytes; pio for message/data: TBI */
id|esp-&gt;do_pio_cmds
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Set the command buffer */
id|esp-&gt;esp_command
op_assign
(paren
r_volatile
r_int
r_char
op_star
)paren
id|cmd_buffer
suffix:semicolon
id|esp-&gt;esp_command_dvma
op_assign
(paren
r_volatile
r_int
r_char
op_star
)paren
id|cmd_buffer
suffix:semicolon
multiline_comment|/* various functions */
id|esp-&gt;dma_bytes_sent
op_assign
op_amp
id|dma_bytes_sent
suffix:semicolon
id|esp-&gt;dma_can_transfer
op_assign
op_amp
id|dma_can_transfer
suffix:semicolon
id|esp-&gt;dma_dump_state
op_assign
op_amp
id|dma_dump_state
suffix:semicolon
id|esp-&gt;dma_init_read
op_assign
l_int|NULL
suffix:semicolon
id|esp-&gt;dma_init_write
op_assign
l_int|NULL
suffix:semicolon
id|esp-&gt;dma_ints_off
op_assign
op_amp
id|dma_ints_off
suffix:semicolon
id|esp-&gt;dma_ints_on
op_assign
op_amp
id|dma_ints_on
suffix:semicolon
id|esp-&gt;dma_ports_p
op_assign
op_amp
id|dma_ports_p
suffix:semicolon
multiline_comment|/* Optional functions */
id|esp-&gt;dma_barrier
op_assign
l_int|NULL
suffix:semicolon
id|esp-&gt;dma_drain
op_assign
l_int|NULL
suffix:semicolon
id|esp-&gt;dma_invalidate
op_assign
l_int|NULL
suffix:semicolon
id|esp-&gt;dma_irq_entry
op_assign
l_int|NULL
suffix:semicolon
id|esp-&gt;dma_irq_exit
op_assign
l_int|NULL
suffix:semicolon
id|esp-&gt;dma_led_on
op_assign
l_int|NULL
suffix:semicolon
id|esp-&gt;dma_led_off
op_assign
l_int|NULL
suffix:semicolon
id|esp-&gt;dma_poll
op_assign
l_int|NULL
suffix:semicolon
id|esp-&gt;dma_reset
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* SCSI chip speed */
multiline_comment|/* below esp-&gt;cfreq = 40000000; */
r_if
c_cond
(paren
id|quick
)paren
(brace
multiline_comment|/* &squot;quick&squot; means there&squot;s handshake glue logic like in the 5380 case */
id|esp-&gt;dma_setup
op_assign
op_amp
id|dma_setup_quick
suffix:semicolon
)brace
r_else
(brace
id|esp-&gt;dma_setup
op_assign
op_amp
id|dma_setup
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chipnum
op_eq
l_int|0
)paren
(brace
id|esp-&gt;irq
op_assign
id|IRQ_MAC_SCSI
suffix:semicolon
id|request_irq
c_func
(paren
id|IRQ_MAC_SCSI
comma
id|esp_intr
comma
l_int|0
comma
l_string|&quot;Mac ESP SCSI&quot;
comma
id|esp
)paren
suffix:semicolon
macro_line|#if 0&t;/* conflicts with IOP ADB */
id|request_irq
c_func
(paren
id|IRQ_MAC_SCSIDRQ
comma
id|fake_drq
comma
l_int|0
comma
l_string|&quot;Mac ESP DRQ&quot;
comma
id|esp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|macintosh_config-&gt;scsi_type
op_eq
id|MAC_SCSI_QUADRA
)paren
(brace
id|esp-&gt;cfreq
op_assign
l_int|16500000
suffix:semicolon
)brace
r_else
(brace
id|esp-&gt;cfreq
op_assign
l_int|25000000
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* chipnum == 1 */
id|esp-&gt;irq
op_assign
id|IRQ_MAC_SCSIDRQ
suffix:semicolon
macro_line|#if 0&t;/* conflicts with IOP ADB */
id|request_irq
c_func
(paren
id|IRQ_MAC_SCSIDRQ
comma
id|esp_intr
comma
l_int|0
comma
l_string|&quot;Mac ESP SCSI 2&quot;
comma
id|esp
)paren
suffix:semicolon
macro_line|#endif
id|esp-&gt;cfreq
op_assign
l_int|25000000
suffix:semicolon
)brace
r_if
c_cond
(paren
id|quick
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;esp: using quick version&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;esp: addr at 0x%p&bslash;n&quot;
comma
id|esp-&gt;eregs
)paren
suffix:semicolon
id|esp-&gt;scsi_id
op_assign
l_int|7
suffix:semicolon
id|esp-&gt;diff
op_assign
l_int|0
suffix:semicolon
id|esp_initialize
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
multiline_comment|/* for chipnum */
r_if
c_cond
(paren
id|chipspresent
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;nmac_esp: %d esp controllers found&bslash;n&quot;
comma
id|chipspresent
)paren
suffix:semicolon
id|esp_initialized
op_assign
id|chipspresent
suffix:semicolon
r_return
id|chipspresent
suffix:semicolon
)brace
multiline_comment|/*&n; * I&squot;ve been wondering what this is supposed to do, for some time. Talking &n; * to Allen Briggs: These machines have an extra register someplace where the&n; * DRQ pin of the ESP can be monitored. That isn&squot;t useful for determining &n; * anything else (such as reselect interrupt or other magic) though. &n; * Maybe make the semantics should be changed like &n; * if (esp-&gt;current_SC)&n; *&t;... check DRQ flag ...&n; * else &n; *&t;... disconnected, check pending VIA interrupt ...&n; *&n; * There&squot;s a problem with using the dabf flag or mac_irq_pending() here: both&n; * seem to return 1 even though no interrupt is currently pending, resulting&n; * in esp_exec_cmd() holding off the next command, and possibly infinite loops&n; * in esp_intr(). &n; * Short term fix: just use esp_status &amp; ESP_STAT_INTR here, as long as we&n; * use simple PIO. The DRQ status will be important when implementing pseudo&n; * DMA mode (set up ESP transfer count, return, do a batch of bytes in PIO or &n; * &squot;hardware handshake&squot; mode upon DRQ).&n; * If you plan on changing this (i.e. to save the esp_status register access in &n; * favor of a VIA register access or a shadow register for the IFR), make sure&n; * to try a debug version of this first to monitor what registers would be a good&n; * indicator of the ESP interrupt.&n; */
DECL|function|esp_dafb_dma_irq_p
r_static
r_int
id|esp_dafb_dma_irq_p
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
(brace
r_int
r_int
id|ret
suffix:semicolon
r_int
id|sreg
op_assign
id|esp_read
c_func
(paren
id|esp-&gt;eregs-&gt;esp_status
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_MAC_ESP
id|printk
c_func
(paren
l_string|&quot;mac_esp: esp_dafb_dma_irq_p dafb %d irq %d&bslash;n&quot;
comma
id|readl
c_func
(paren
id|esp-&gt;dregs
)paren
comma
id|mac_irq_pending
c_func
(paren
id|IRQ_MAC_SCSI
)paren
)paren
suffix:semicolon
macro_line|#endif
id|sreg
op_and_assign
id|ESP_STAT_INTR
suffix:semicolon
multiline_comment|/*&n;&t; * maybe working; this is essentially what&squot;s used for iosb_dma_irq_p&n;&t; */
r_if
c_cond
(paren
id|sreg
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * didn&squot;t work ...&n;&t; */
macro_line|#if 0
r_if
c_cond
(paren
id|esp-&gt;current_SC
)paren
id|ret
op_assign
id|readl
c_func
(paren
id|esp-&gt;dregs
)paren
op_amp
l_int|0x200
suffix:semicolon
r_else
r_if
c_cond
(paren
id|esp-&gt;disconnected_SC
)paren
id|ret
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* sreg ?? */
r_else
id|ret
op_assign
id|mac_irq_pending
c_func
(paren
id|IRQ_MAC_SCSI
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * See above: testing mac_irq_pending always returned 8 (SCSI IRQ) regardless &n; * of the actual ESP status.&n; */
DECL|function|esp_iosb_dma_irq_p
r_static
r_int
id|esp_iosb_dma_irq_p
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
(brace
r_int
id|ret
op_assign
id|mac_irq_pending
c_func
(paren
id|IRQ_MAC_SCSI
)paren
op_logical_or
id|mac_irq_pending
c_func
(paren
id|IRQ_MAC_SCSIDRQ
)paren
suffix:semicolon
r_int
id|sreg
op_assign
id|esp_read
c_func
(paren
id|esp-&gt;eregs-&gt;esp_status
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_MAC_ESP
id|printk
c_func
(paren
l_string|&quot;mac_esp: dma_irq_p drq %d irq %d sreg %x curr %p disc %p&bslash;n&quot;
comma
id|mac_irq_pending
c_func
(paren
id|IRQ_MAC_SCSIDRQ
)paren
comma
id|mac_irq_pending
c_func
(paren
id|IRQ_MAC_SCSI
)paren
comma
id|sreg
comma
id|esp-&gt;current_SC
comma
id|esp-&gt;disconnected_SC
)paren
suffix:semicolon
macro_line|#endif
id|sreg
op_and_assign
id|ESP_STAT_INTR
suffix:semicolon
r_if
c_cond
(paren
id|sreg
)paren
r_return
(paren
id|sreg
)paren
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This seems to be OK for PIO at least ... usually 0 after PIO.&n; */
DECL|function|dma_bytes_sent
r_static
r_int
id|dma_bytes_sent
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_int
id|fifo_count
)paren
(brace
macro_line|#ifdef DEBUG_MAC_ESP
id|printk
c_func
(paren
l_string|&quot;mac_esp: dma bytes sent = %x&bslash;n&quot;
comma
id|fifo_count
)paren
suffix:semicolon
macro_line|#endif
r_return
id|fifo_count
suffix:semicolon
)brace
multiline_comment|/*&n; * dma_can_transfer is used to switch between DMA and PIO, if DMA (pseudo)&n; * is ever implemented. Returning 0 here will use PIO.&n; */
DECL|function|dma_can_transfer
r_static
r_int
id|dma_can_transfer
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
r_int
r_int
id|sz
op_assign
id|sp-&gt;SCp.this_residual
suffix:semicolon
macro_line|#if 0&t;/* no DMA yet; make conditional */
r_if
c_cond
(paren
id|sz
OG
l_int|0x10000000
)paren
(brace
id|sz
op_assign
l_int|0x10000000
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;mac_esp: dma can transfer = 0lx%x&bslash;n&quot;
comma
id|sz
)paren
suffix:semicolon
macro_line|#else
macro_line|#ifdef DEBUG_MAC_ESP
id|printk
c_func
(paren
l_string|&quot;mac_esp: pio to transfer = %ld&bslash;n&quot;
comma
id|sz
)paren
suffix:semicolon
macro_line|#endif
id|sz
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_return
id|sz
suffix:semicolon
)brace
multiline_comment|/*&n; * Not yet ...&n; */
DECL|function|dma_dump_state
r_static
r_void
id|dma_dump_state
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
(brace
macro_line|#ifdef DEBUG_MAC_ESP
id|printk
c_func
(paren
l_string|&quot;mac_esp: dma_dump_state: called&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: dma -- cond_reg&lt;%02x&gt;&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
(paren
(paren
r_struct
id|mac_dma_registers
op_star
)paren
(paren
id|esp-&gt;dregs
)paren
)paren
op_member_access_from_pointer
id|cond_reg
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * DMA setup: should be used to set up the ESP transfer count for pseudo&n; * DMA transfers; need a DRQ transfer function to do the actual transfer&n; */
DECL|function|dma_init_read
r_static
r_void
id|dma_init_read
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_char
op_star
id|vaddress
comma
r_int
id|length
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mac_esp: dma_init_read&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|dma_init_write
r_static
r_void
id|dma_init_write
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_char
op_star
id|vaddress
comma
r_int
id|length
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mac_esp: dma_init_write&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|dma_ints_off
r_static
r_void
id|dma_ints_off
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
(brace
id|mac_turnoff_irq
c_func
(paren
id|esp-&gt;irq
)paren
suffix:semicolon
)brace
DECL|function|dma_ints_on
r_static
r_void
id|dma_ints_on
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
(brace
id|mac_turnon_irq
c_func
(paren
id|esp-&gt;irq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * generic dma_irq_p(), unused&n; */
DECL|function|dma_irq_p
r_static
r_int
id|dma_irq_p
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
(brace
r_int
id|i
op_assign
id|esp_read
c_func
(paren
id|esp-&gt;eregs-&gt;esp_status
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_MAC_ESP
id|printk
c_func
(paren
l_string|&quot;mac_esp: dma_irq_p status %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|i
op_amp
id|ESP_STAT_INTR
)paren
suffix:semicolon
)brace
DECL|function|dma_irq_p_quick
r_static
r_int
id|dma_irq_p_quick
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
(brace
multiline_comment|/*&n;&t; * Copied from iosb_dma_irq_p()&n;&t; */
r_int
id|ret
op_assign
id|mac_irq_pending
c_func
(paren
id|IRQ_MAC_SCSI
)paren
op_logical_or
id|mac_irq_pending
c_func
(paren
id|IRQ_MAC_SCSIDRQ
)paren
suffix:semicolon
r_int
id|sreg
op_assign
id|esp_read
c_func
(paren
id|esp-&gt;eregs-&gt;esp_status
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_MAC_ESP
id|printk
c_func
(paren
l_string|&quot;mac_esp: dma_irq_p drq %d irq %d sreg %x curr %p disc %p&bslash;n&quot;
comma
id|mac_irq_pending
c_func
(paren
id|IRQ_MAC_SCSIDRQ
)paren
comma
id|mac_irq_pending
c_func
(paren
id|IRQ_MAC_SCSI
)paren
comma
id|sreg
comma
id|esp-&gt;current_SC
comma
id|esp-&gt;disconnected_SC
)paren
suffix:semicolon
macro_line|#endif
id|sreg
op_and_assign
id|ESP_STAT_INTR
suffix:semicolon
r_if
c_cond
(paren
id|sreg
)paren
r_return
(paren
id|sreg
)paren
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dma_led_off
r_static
r_void
id|dma_led_off
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
(brace
macro_line|#ifdef DEBUG_MAC_ESP
id|printk
c_func
(paren
l_string|&quot;mac_esp: dma_led_off: called&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|dma_led_on
r_static
r_void
id|dma_led_on
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
(brace
macro_line|#ifdef DEBUG_MAC_ESP
id|printk
c_func
(paren
l_string|&quot;mac_esp: dma_led_on: called&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|dma_ports_p
r_static
r_int
id|dma_ports_p
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dma_setup
r_static
r_void
id|dma_setup
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
id|__u32
id|addr
comma
r_int
id|count
comma
r_int
id|write
)paren
(brace
macro_line|#ifdef DEBUG_MAC_ESP
id|printk
c_func
(paren
l_string|&quot;mac_esp: dma_setup&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|write
)paren
(brace
id|dma_init_read
c_func
(paren
id|esp
comma
(paren
r_char
op_star
)paren
id|addr
comma
id|count
)paren
suffix:semicolon
)brace
r_else
(brace
id|dma_init_write
c_func
(paren
id|esp
comma
(paren
r_char
op_star
)paren
id|addr
comma
id|count
)paren
suffix:semicolon
)brace
)brace
DECL|function|dma_setup_quick
r_static
r_void
id|dma_setup_quick
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
id|__u32
id|addr
comma
r_int
id|count
comma
r_int
id|write
)paren
(brace
macro_line|#ifdef DEBUG_MAC_ESP
id|printk
c_func
(paren
l_string|&quot;mac_esp: dma_setup_quick&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|SCSI_MAC_ESP
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
eof
