multiline_comment|/*&n; *&t;buslogic.c&t;(C) 1993, 1994 David B. Gentzel&n; *&t;Low-level scsi driver for BusLogic adapters&n; *&t;by David B. Gentzel, Whitfield Software Services, Carnegie, PA&n; *&t;    (gentzel@nova.enet.dec.com)&n; *&t;Thanks to BusLogic for providing the necessary documentation&n; *&n; *&t;The original version of this driver was derived from aha1542.[ch] which&n; *&t;is Copyright (C) 1992 Tommy Thorn.  Much has been reworked, but most of&n; *&t;basic structure and substantial chunks of code still remain.&n; *&n; *&t;Thanks to the following individuals who have made contributions (of&n; *&t;(code, information, support, or testing) to this driver:&n; *&t;&t;Eric Youngdale&t;&t;Leonard Zubkoff&n; *&t;&t;Tomas Hurka&t;&t;Andrew Walker&n; */
multiline_comment|/*&n; * TODO:&n; *&t;1. Clean up error handling &amp; reporting.&n; *&t;2. Find out why scatter/gather is limited to 16 requests per command.&n; *&t;3. Test/improve/fix abort &amp; reset functions.&n; *&t;4. Look at command linking.&n; *&t;5. Allow multiple boards to share an IRQ if the bus allows (EISA, MCA,&n; *&t;   and PCI).&n; *&t;6. Avoid using the 445S workaround for board revs &gt;= D.&n; */
multiline_comment|/*&n; * NOTES:&n; *    BusLogic (formerly BusTek) manufactures an extensive family of&n; *    intelligent, high performance SCSI-2 host adapters.  They all support&n; *    command queueing and scatter/gather I/O.  Most importantly, they all&n; *    support identical programming interfaces, so a single driver can be used&n; *    for all boards.&n; *&n; *    Actually, they all support TWO identical programming interfaces!  They&n; *    have an Adaptec 154x compatible interface (complete with 24 bit&n; *    addresses) as well as a &quot;native&quot; 32 bit interface.  As such, the Linux&n; *    aha1542 driver can be used to drive them, but with less than optimal&n; *    performance (at least for the EISA, VESA, and MCA boards).&n; *&n; *    Here is the scoop on the various models:&n; *&t;BT-542B - ISA first-party DMA with floppy support.&n; *&t;BT-545S - 542B + FAST SCSI and active termination.&n; *&t;BT-545D - 545S + differential termination.&n; *&t;BT-640A - MCA bus-master with floppy support.&n; *&t;BT-646S - 640A + FAST SCSI and active termination.&n; *&t;BT-646D - 646S + differential termination.&n; *&t;BT-742A - EISA bus-master with floppy support.&n; *&t;BT-747S - 742A + FAST SCSI, active termination, and 2.88M floppy.&n; *&t;BT-747D - 747S + differential termination.&n; *&t;BT-757S - 747S + WIDE SCSI.&n; *&t;BT-757D - 747D + WIDE SCSI.&n; *&t;BT-445S - VESA bus-master FAST SCSI with active termination and floppy&n; *&t;&t;  support.&n; *&t;BT-445C - 445S + enhanced BIOS &amp; firmware options.&n; *&t;BT-946C - PCI bus-master FAST SCSI. (??? Nothing else known.)&n; *&n; *    ??? I believe other boards besides the 445 now have a &quot;C&quot; model, but I&n; *    have no facts on them.&n; *&n; *    This driver SHOULD support all of these boards.  It has only been tested&n; *    with a 747S and 445S.&n; *&n; *    Should you require further information on any of these boards, BusLogic&n; *    can be reached at (408)492-9090.  Their BBS # is (408)492-1984 (maybe BBS&n; *    stands for &quot;Big Brother System&quot;?).&n; *&n; *    Places flagged with a triple question-mark are things which are either&n; *    unfinished, questionable, or wrong.&n; */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/head.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &quot;../block/blk.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;sd.h&quot;
DECL|macro|BUSLOGIC_PRIVATE_H
mdefine_line|#define BUSLOGIC_PRIVATE_H&t;/* Get the &quot;private&quot; stuff */
macro_line|#include &quot;buslogic.h&quot;
macro_line|#ifndef BUSLOGIC_DEBUG
DECL|macro|BUSLOGIC_DEBUG
macro_line|# define BUSLOGIC_DEBUG 0
macro_line|#endif
multiline_comment|/* If different port addresses are needed (e.g. to install more than two&n;   cards), you must define BUSLOGIC_PORT_OVERRIDE to be a comma-separated list&n;   of the addresses which will be checked.  This can also be used to resolve a&n;   conflict if the port-probing at a standard port causes problems with&n;   another board. */
multiline_comment|/* #define BUSLOGIC_PORT_OVERRIDE 0x330, 0x334, 0x130, 0x134, 0x230, 0x234 */
multiline_comment|/* Define this to be either BIOS_TRANSLATION_DEFAULT or BIOS_TRANSLATION_BIG&n;   if you wish to bypass the test for this, which uses an undocumented port.&n;   The test is believed to fail on at least some AMI BusLogic clones. */
multiline_comment|/* #define BIOS_TRANSLATION_OVERRIDE BIOS_TRANSLATION_BIG */
DECL|macro|BUSLOGIC_VERSION
mdefine_line|#define BUSLOGIC_VERSION &quot;1.13&quot;
multiline_comment|/* Not a random value - if this is too large, the system hangs for a long time&n;   waiting for something to happen if a board is not installed. */
multiline_comment|/* ??? I don&squot;t really like this as it will wait longer on slow machines.&n;   Perhaps we should base this on the loops_per_second &quot;Bogomips&quot; value? */
DECL|macro|WAITNEXTTIMEOUT
mdefine_line|#define WAITNEXTTIMEOUT 3000000
multiline_comment|/* This is for the scsi_malloc call in buslogic_queuecommand. */
multiline_comment|/* ??? I&squot;d up this to 4096, but would we be in danger of using up the&n;   scsi_malloc memory pool? */
multiline_comment|/* This could be a concern, I guess.  It may be possible to fix things so that&n;   the table generated in sd.c is compatible with the low-level code, but&n;   don&squot;t hold your breath.  -ERY */
DECL|macro|BUSLOGIC_SG_MALLOC
mdefine_line|#define BUSLOGIC_SG_MALLOC 512
multiline_comment|/* Since the SG list is malloced, we have to limit the length. */
DECL|macro|BUSLOGIC_MAX_SG
mdefine_line|#define BUSLOGIC_MAX_SG (BUSLOGIC_SG_MALLOC / sizeof (struct chain))
multiline_comment|/* ??? Arbitrary.  If we can dynamically allocate the mailbox arrays, I may&n;   bump up this number. */
DECL|macro|BUSLOGIC_MAILBOXES
mdefine_line|#define BUSLOGIC_MAILBOXES 16
DECL|macro|BUSLOGIC_CMDLUN
mdefine_line|#define BUSLOGIC_CMDLUN 4&t;&t;/* ??? Arbitrary */
multiline_comment|/* BusLogic boards can be configured for quite a number of port addresses (six&n;   to be exact), but I generally do not want the driver poking around at&n;   random.  We allow two port addresses - this allows people to use a BusLogic&n;   with a MIDI card, which frequently also uses 0x330. */
DECL|variable|bases
r_static
r_const
r_int
r_int
id|bases
(braket
)braket
op_assign
(brace
macro_line|#ifdef BUSLOGIC_PORT_OVERRIDE
id|BUSLOGIC_PORT_OVERRIDE
macro_line|#else
l_int|0x330
comma
l_int|0x334
comma
multiline_comment|/* 0x130, 0x134, 0x230, 0x234 */
macro_line|#endif
)brace
suffix:semicolon
DECL|macro|BIOS_TRANSLATION_DEFAULT
mdefine_line|#define BIOS_TRANSLATION_DEFAULT 0&t;/* Default case */
DECL|macro|BIOS_TRANSLATION_BIG
mdefine_line|#define BIOS_TRANSLATION_BIG 1&t;&t;/* Big disk (&gt; 1G) case */
DECL|struct|hostdata
r_struct
id|hostdata
(brace
DECL|member|bus_type
r_int
r_int
id|bus_type
suffix:semicolon
DECL|member|bios_translation
r_int
r_int
id|bios_translation
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* BIOS mapping (for compatibility) */
DECL|member|last_mbi_used
r_int
id|last_mbi_used
suffix:semicolon
DECL|member|last_mbo_used
r_int
id|last_mbo_used
suffix:semicolon
DECL|member|model
r_char
id|model
(braket
l_int|7
)braket
suffix:semicolon
DECL|member|firmware_rev
r_char
id|firmware_rev
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|sc
id|Scsi_Cmnd
op_star
id|sc
(braket
id|BUSLOGIC_MAILBOXES
)braket
suffix:semicolon
DECL|member|mb
r_struct
id|mailbox
id|mb
(braket
l_int|2
op_star
id|BUSLOGIC_MAILBOXES
)braket
suffix:semicolon
DECL|member|ccbs
r_struct
id|ccb
id|ccbs
(braket
id|BUSLOGIC_MAILBOXES
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|HOSTDATA
mdefine_line|#define HOSTDATA(host) ((struct hostdata *)&amp;(host)-&gt;hostdata)
multiline_comment|/* One for each IRQ level (9-15), although 13 will never be used. */
DECL|variable|host
r_static
r_struct
id|Scsi_Host
op_star
id|host
(braket
l_int|7
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
r_static
r_int
id|setup_mailboxes
c_func
(paren
r_int
r_int
id|base
comma
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
suffix:semicolon
r_static
r_int
id|restart
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
suffix:semicolon
DECL|macro|INTR_RESET
mdefine_line|#define INTR_RESET(base) outb(RINT, CONTROL(base))
DECL|macro|buslogic_printk
mdefine_line|#define buslogic_printk buslogic_prefix(),printk
DECL|macro|CHECK
mdefine_line|#define CHECK(cond) if (cond) ; else goto fail
DECL|macro|WAIT
mdefine_line|#define WAIT(port, allof, noneof) &bslash;&n;    CHECK(wait(port, allof, noneof, WAITNEXTTIMEOUT, FALSE))
DECL|macro|WAIT_WHILE
mdefine_line|#define WAIT_WHILE(port, mask) WAIT(port, 0, mask)
DECL|macro|WAIT_UNTIL
mdefine_line|#define WAIT_UNTIL(port, mask) WAIT(port, mask, 0)
DECL|macro|WAIT_FAST
mdefine_line|#define WAIT_FAST(port, allof, noneof) &bslash;&n;    CHECK(wait(port, allof, noneof, 100, TRUE))
DECL|macro|WAIT_WHILE_FAST
mdefine_line|#define WAIT_WHILE_FAST(port, mask) WAIT_FAST(port, 0, mask)
DECL|macro|WAIT_UNTIL_FAST
mdefine_line|#define WAIT_UNTIL_FAST(port, mask) WAIT_FAST(port, mask, 0)
multiline_comment|/* If delay != 0, we use the udelay call to regulate the amount of time we&n;   wait.&n;&n;   This is inline as it is always called with constant arguments and hence&n;   will be very well optimized. */
DECL|function|wait
r_static
id|__inline__
r_int
id|wait
c_func
(paren
r_int
r_int
id|port
comma
r_int
r_char
id|allof
comma
r_int
r_char
id|noneof
comma
r_int
r_int
id|timeout
comma
r_int
id|delay
)paren
(brace
r_int
id|bits
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|bits
op_assign
id|inb
c_func
(paren
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bits
op_amp
id|allof
)paren
op_eq
id|allof
op_logical_and
(paren
id|bits
op_amp
id|noneof
)paren
op_eq
l_int|0
)paren
r_return
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|delay
)paren
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|timeout
op_eq
l_int|0
)paren
r_return
id|FALSE
suffix:semicolon
)brace
)brace
DECL|function|buslogic_prefix
r_static
r_void
id|buslogic_prefix
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BusLogic SCSI: &quot;
)paren
suffix:semicolon
)brace
DECL|function|buslogic_stat
r_static
r_void
id|buslogic_stat
c_func
(paren
r_int
r_int
id|base
)paren
(brace
r_int
id|s
op_assign
id|inb
c_func
(paren
id|STATUS
c_func
(paren
id|base
)paren
)paren
comma
id|i
op_assign
id|inb
c_func
(paren
id|INTERRUPT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|buslogic_printk
c_func
(paren
l_string|&quot;status=%02X intrflags=%02X&bslash;n&quot;
comma
id|s
comma
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* This is a bit complicated, but we need to make sure that an interrupt&n;   routine does not send something out while we are in the middle of this.&n;   Fortunately, it is only at boot time that multi-byte messages are ever&n;   sent. */
DECL|function|buslogic_out
r_static
r_int
id|buslogic_out
c_func
(paren
r_int
r_int
id|base
comma
r_const
r_int
r_char
op_star
id|cmdp
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_eq
l_int|1
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|WAIT_WHILE
c_func
(paren
id|STATUS
c_func
(paren
id|base
)paren
comma
id|CPRBSY
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|STATUS
c_func
(paren
id|base
)paren
)paren
op_amp
id|CPRBSY
)paren
)paren
(brace
id|outb
c_func
(paren
op_star
id|cmdp
comma
id|COMMAND_PARAMETER
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
id|WAIT_WHILE
c_func
(paren
id|STATUS
c_func
(paren
id|base
)paren
comma
id|CPRBSY
)paren
suffix:semicolon
id|outb
c_func
(paren
op_star
id|cmdp
op_increment
comma
id|COMMAND_PARAMETER
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|FALSE
suffix:semicolon
id|fail
suffix:colon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_out failed(%u): &quot;
comma
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|buslogic_stat
c_func
(paren
id|base
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* Only used at boot time, so we do not need to worry about latency as much&n;   here.  This waits a very short period of time.  We use this if we are not&n;   sure whether the board will respond to the command we just sent. */
DECL|function|buslogic_in
r_static
r_int
id|buslogic_in
c_func
(paren
r_int
r_int
id|base
comma
r_int
r_char
op_star
id|cmdp
comma
r_int
id|len
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
id|WAIT_UNTIL_FAST
c_func
(paren
id|STATUS
c_func
(paren
id|base
)paren
comma
id|DIRRDY
)paren
suffix:semicolon
op_star
id|cmdp
op_increment
op_assign
id|inb
c_func
(paren
id|DATA_IN
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
id|fail
suffix:colon
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_IO)
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_in failed(%u): &quot;
comma
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|buslogic_stat
c_func
(paren
id|base
)paren
suffix:semicolon
macro_line|#endif
r_return
id|TRUE
suffix:semicolon
)brace
DECL|function|makecode
r_static
r_int
r_int
id|makecode
c_func
(paren
r_int
r_int
id|haerr
comma
r_int
r_int
id|scsierr
)paren
(brace
r_int
r_int
id|hosterr
suffix:semicolon
r_const
r_char
op_star
id|errstr
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_ERRORS) &amp;&amp; defined(CONFIG_SCSI_CONSTANTS)
r_static
r_const
r_char
op_star
r_const
id|buslogic_status
(braket
)braket
op_assign
(brace
multiline_comment|/* 00 */
l_string|&quot;Command completed normally&quot;
comma
multiline_comment|/* 01-07 */
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
multiline_comment|/* 08-09 */
l_int|NULL
comma
l_int|NULL
comma
multiline_comment|/* 0A */
l_string|&quot;Linked command completed normally&quot;
comma
multiline_comment|/* 0B */
l_string|&quot;Linked command completed normally, interrupt generated&quot;
comma
multiline_comment|/* 0C-0F */
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
multiline_comment|/* 10 */
l_int|NULL
comma
multiline_comment|/* 11 */
l_string|&quot;Selection timed out&quot;
comma
multiline_comment|/* 12 */
l_string|&quot;Data overrun/underrun&quot;
comma
multiline_comment|/* 13 */
l_string|&quot;Unexpected bus free&quot;
comma
multiline_comment|/* 14 */
l_string|&quot;Target bus phase sequence failure&quot;
comma
multiline_comment|/* 15 */
l_string|&quot;First byte of outgoing MB was invalid&quot;
comma
multiline_comment|/* 16 */
l_string|&quot;Invalid CCB Operation Code&quot;
comma
multiline_comment|/* 17 */
l_string|&quot;Linked CCB does not have the same LUN&quot;
comma
multiline_comment|/* 18 */
l_string|&quot;Invalid Target Direction received from Host&quot;
comma
multiline_comment|/* 19 */
l_string|&quot;Duplicate CCB Received in Target Mode&quot;
comma
multiline_comment|/* 1A */
l_string|&quot;Invalid CCB or Segment List Parameter&quot;
comma
multiline_comment|/* 1B */
l_string|&quot;Auto request sense failed&quot;
comma
multiline_comment|/* 1C */
l_string|&quot;SCSI-2 tagged queueing message was rejected by the target&quot;
comma
multiline_comment|/* 1D-1F */
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
multiline_comment|/* 20 */
l_string|&quot;Host adapter hardware failure&quot;
comma
multiline_comment|/* 21 */
l_string|&quot;Target did not respond to SCSI ATN and the HA SCSI bus reset&quot;
comma
multiline_comment|/* 22 */
l_string|&quot;Host adapter asserted a SCSI bus reset&quot;
comma
multiline_comment|/* 23 */
l_string|&quot;Other SCSI devices asserted a SCSI bus reset&quot;
comma
)brace
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|haerr
)paren
(brace
r_case
l_int|0x00
suffix:colon
multiline_comment|/* Normal completion. */
r_case
l_int|0x0A
suffix:colon
multiline_comment|/* Linked command complete without error and linked&n;&t;&t;&t;   normally. */
r_case
l_int|0x0B
suffix:colon
multiline_comment|/* Linked command complete without error, interrupt&n;&t;&t;&t;   generated. */
id|hosterr
op_assign
id|DID_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x11
suffix:colon
multiline_comment|/* Selection time out: the initiator selection or&n;&t;&t;&t;   target reselection was not complete within the SCSI&n;&t;&t;&t;   time out period. */
id|hosterr
op_assign
id|DID_TIME_OUT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x14
suffix:colon
multiline_comment|/* Target bus phase sequence failure - An invalid bus&n;&t;&t;&t;   phase or bus phase sequence was requested by the&n;&t;&t;&t;   target.  The host adapter will generate a SCSI&n;&t;&t;&t;   Reset Condition, notifying the host with a RSTS&n;&t;&t;&t;   interrupt. */
r_case
l_int|0x21
suffix:colon
multiline_comment|/* The target did not respond to SCSI ATN and the host&n;&t;&t;&t;   adapter consequently issued a SCSI bus reset to&n;&t;&t;&t;   clear up the failure. */
r_case
l_int|0x22
suffix:colon
multiline_comment|/* The host adapter asserted a SCSI bus reset. */
id|hosterr
op_assign
id|DID_RESET
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x12
suffix:colon
multiline_comment|/* Data overrun/underrun: the target attempted to&n;&t;&t;&t;   transfer more data than was allocated by the Data&n;&t;&t;&t;   Length field or the sum of the Scatter/Gather Data&n;&t;&t;&t;   Length fields. */
r_case
l_int|0x13
suffix:colon
multiline_comment|/* Unexpected bus free - The target dropped the SCSI&n;&t;&t;&t;   BSY at an unexpected time. */
r_case
l_int|0x15
suffix:colon
multiline_comment|/* MBO command was not 00, 01, or 02 - The first byte&n;&t;&t;&t;   of the MB was invalid.  This usually indicates a&n;&t;&t;&t;   software failure. */
r_case
l_int|0x16
suffix:colon
multiline_comment|/* Invalid CCB Operation Code - The first byte of the&n;&t;&t;&t;   CCB was invalid.  This usually indicates a software&n;&t;&t;&t;   failure. */
r_case
l_int|0x17
suffix:colon
multiline_comment|/* Linked CCB does not have the same LUN - A&n;&t;&t;&t;   subsequent CCB of a set of linked CCB&squot;s does not&n;&t;&t;&t;   specify the same logical unit number as the&n;&t;&t;&t;   first. */
r_case
l_int|0x18
suffix:colon
multiline_comment|/* Invalid Target Direction received from Host - The&n;&t;&t;&t;   direction of a Target Mode CCB was invalid. */
r_case
l_int|0x19
suffix:colon
multiline_comment|/* Duplicate CCB Received in Target Mode - More than&n;&t;&t;&t;   once CCB was received to service data transfer&n;&t;&t;&t;   between the same target LUN and initiator SCSI ID&n;&t;&t;&t;   in the same direction. */
r_case
l_int|0x1A
suffix:colon
multiline_comment|/* Invalid CCB or Segment List Parameter - A segment&n;&t;&t;&t;   list with a zero length segment or invalid segment&n;&t;&t;&t;   list boundaries was received.  A CCB parameter was&n;&t;&t;&t;   invalid. */
r_case
l_int|0x1B
suffix:colon
multiline_comment|/* Auto request sense failed. */
r_case
l_int|0x1C
suffix:colon
multiline_comment|/* SCSI-2 tagged queueing message was rejected by the&n;&t;&t;&t;   target. */
r_case
l_int|0x20
suffix:colon
multiline_comment|/* The host adapter hardware failed. */
r_case
l_int|0x23
suffix:colon
multiline_comment|/* Other SCSI devices asserted a SCSI bus reset. */
id|hosterr
op_assign
id|DID_ERROR
suffix:semicolon
multiline_comment|/* ??? Couldn&squot;t find any better. */
r_break
suffix:semicolon
r_default
suffix:colon
macro_line|#ifndef CONFIG_SCSI_CONSTANTS
id|errstr
op_assign
l_string|&quot;unknown hoststatus&quot;
suffix:semicolon
macro_line|#endif
id|hosterr
op_assign
id|DID_ERROR
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_ERRORS)
macro_line|# ifdef CONFIG_SCSI_CONSTANTS
r_if
c_cond
(paren
id|hosterr
op_ne
id|DID_OK
)paren
(brace
r_if
c_cond
(paren
id|haerr
OL
id|ARRAY_SIZE
c_func
(paren
id|buslogic_status
)paren
)paren
id|errstr
op_assign
id|buslogic_status
(braket
id|haerr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|errstr
op_eq
l_int|NULL
)paren
id|errstr
op_assign
l_string|&quot;unknown hoststatus&quot;
suffix:semicolon
)brace
macro_line|# else
r_if
c_cond
(paren
id|hosterr
op_eq
id|DID_ERROR
)paren
id|errstr
op_assign
l_string|&quot;&quot;
suffix:semicolon
macro_line|# endif
macro_line|#endif
r_if
c_cond
(paren
id|errstr
op_ne
l_int|NULL
)paren
id|buslogic_printk
c_func
(paren
l_string|&quot;makecode: %s (%02X)&bslash;n&quot;
comma
id|errstr
comma
id|haerr
)paren
suffix:semicolon
r_return
(paren
id|hosterr
op_lshift
l_int|16
)paren
op_or
id|scsierr
suffix:semicolon
)brace
multiline_comment|/* ??? this should really be &quot;const struct Scsi_Host *&quot; */
DECL|function|buslogic_info
r_const
r_char
op_star
id|buslogic_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_return
l_string|&quot;BusLogic SCSI driver &quot;
id|BUSLOGIC_VERSION
suffix:semicolon
)brace
multiline_comment|/* A &quot;high&quot; level interrupt handler. */
DECL|function|buslogic_interrupt
r_static
r_void
id|buslogic_interrupt
c_func
(paren
r_int
id|junk
)paren
(brace
r_void
(paren
op_star
id|my_done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
op_assign
l_int|NULL
suffix:semicolon
r_int
id|errstatus
comma
id|mbistatus
op_assign
id|MBX_NOT_IN_USE
comma
id|number_serviced
comma
id|found
suffix:semicolon
r_int
id|mbi
comma
id|mbo
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
id|Scsi_Cmnd
op_star
id|sctmp
suffix:semicolon
r_int
id|irqno
comma
id|base
comma
id|flag
suffix:semicolon
r_int
id|needs_restart
suffix:semicolon
r_struct
id|mailbox
op_star
id|mb
suffix:semicolon
r_struct
id|ccb
op_star
id|ccb
suffix:semicolon
multiline_comment|/* Magic - this -2 is only required for slow interrupt handlers */
id|irqno
op_assign
(paren
(paren
r_int
op_star
)paren
id|junk
)paren
(braket
op_minus
l_int|2
)braket
suffix:semicolon
id|shpnt
op_assign
id|host
(braket
id|irqno
op_minus
l_int|9
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|shpnt
)paren
id|panic
c_func
(paren
l_string|&quot;buslogic.c: NULL SCSI host entry&quot;
)paren
suffix:semicolon
id|mb
op_assign
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|mb
suffix:semicolon
id|ccb
op_assign
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|ccbs
suffix:semicolon
id|base
op_assign
id|shpnt-&gt;io_port
suffix:semicolon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_INTERRUPT)
id|flag
op_assign
id|inb
c_func
(paren
id|INTERRUPT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_interrupt: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flag
op_amp
id|INTV
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;no interrupt? &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|IMBL
)paren
id|printk
c_func
(paren
l_string|&quot;IMBL &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|MBOR
)paren
id|printk
c_func
(paren
l_string|&quot;MBOR &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|CMDC
)paren
id|printk
c_func
(paren
l_string|&quot;CMDC &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|RSTS
)paren
id|printk
c_func
(paren
l_string|&quot;RSTS &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;status %02X&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
c_func
(paren
id|base
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif
id|number_serviced
op_assign
l_int|0
suffix:semicolon
id|needs_restart
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|flag
op_assign
id|inb
c_func
(paren
id|INTERRUPT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* Check for unusual interrupts.  If any of these happen, we should&n;&t;   probably do something special, but for now just printing a message&n;&t;   is sufficient.  A SCSI reset detected is something that we really&n;&t;   need to deal with in some way. */
r_if
c_cond
(paren
id|flag
op_amp
(paren
id|MBOR
op_or
id|CMDC
op_or
id|RSTS
)paren
)paren
(brace
id|buslogic_printk
c_func
(paren
l_string|&quot;Unusual flag:&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|MBOR
)paren
id|printk
c_func
(paren
l_string|&quot; MBOR&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|CMDC
)paren
id|printk
c_func
(paren
l_string|&quot; CMDC&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|RSTS
)paren
(brace
id|needs_restart
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; RSTS&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|INTR_RESET
c_func
(paren
id|base
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|mbi
op_assign
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|last_mbi_used
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mbi
op_ge
l_int|2
op_star
id|BUSLOGIC_MAILBOXES
)paren
id|mbi
op_assign
id|BUSLOGIC_MAILBOXES
suffix:semicolon
multiline_comment|/* I use the &quot;found&quot; variable as I like to keep cli/sti pairs at the&n;&t;   same block level.  Debugging dropped sti&squot;s is no fun... */
id|found
op_assign
id|FALSE
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|mb
(braket
id|mbi
)braket
dot
id|status
op_ne
id|MBX_NOT_IN_USE
)paren
(brace
id|found
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|mbi
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mbi
op_ge
l_int|2
op_star
id|BUSLOGIC_MAILBOXES
)paren
id|mbi
op_assign
id|BUSLOGIC_MAILBOXES
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mbi
op_ne
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|last_mbi_used
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found
)paren
(brace
id|mbo
op_assign
(paren
r_struct
id|ccb
op_star
)paren
id|mb
(braket
id|mbi
)braket
dot
id|ccbptr
op_minus
id|ccb
suffix:semicolon
id|mbistatus
op_assign
id|mb
(braket
id|mbi
)braket
dot
id|status
suffix:semicolon
id|mb
(braket
id|mbi
)braket
dot
id|status
op_assign
id|MBX_NOT_IN_USE
suffix:semicolon
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|last_mbi_used
op_assign
id|mbi
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
multiline_comment|/* Hmm, no mail.  Must have read it the last time around. */
r_if
c_cond
(paren
op_logical_neg
id|number_serviced
op_logical_and
op_logical_neg
id|needs_restart
)paren
id|buslogic_printk
c_func
(paren
l_string|&quot;interrupt received, but no mail.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* We detected a reset.  Restart all pending commands for devices&n;&t;       that use the hard reset option. */
r_if
c_cond
(paren
id|needs_restart
)paren
id|restart
c_func
(paren
id|shpnt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_INTERRUPT)
r_if
c_cond
(paren
id|ccb
(braket
id|mbo
)braket
dot
id|tarstat
op_logical_or
id|ccb
(braket
id|mbo
)braket
dot
id|hastat
)paren
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_interrupt: returning %08X (status %d)&bslash;n&quot;
comma
(paren
(paren
r_int
)paren
id|ccb
(braket
id|mbo
)braket
dot
id|hastat
op_lshift
l_int|16
)paren
op_or
id|ccb
(braket
id|mbo
)braket
dot
id|tarstat
comma
id|mb
(braket
id|mbi
)braket
dot
id|status
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|mbistatus
op_eq
id|MBX_COMPLETION_NOT_FOUND
)paren
r_continue
suffix:semicolon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_INTERRUPT)
id|buslogic_printk
c_func
(paren
l_string|&quot;...done %u %u&bslash;n&quot;
comma
id|mbo
comma
id|mbi
)paren
suffix:semicolon
macro_line|#endif
id|sctmp
op_assign
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|sc
(braket
id|mbo
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sctmp
op_logical_or
op_logical_neg
id|sctmp-&gt;scsi_done
)paren
(brace
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_interrupt: Unexpected interrupt&bslash;n&quot;
)paren
suffix:semicolon
id|buslogic_printk
c_func
(paren
l_string|&quot;tarstat=%02X, hastat=%02X id=%d lun=%d ccb#=%u&bslash;n&quot;
comma
id|ccb
(braket
id|mbo
)braket
dot
id|tarstat
comma
id|ccb
(braket
id|mbo
)braket
dot
id|hastat
comma
id|ccb
(braket
id|mbo
)braket
dot
id|id
comma
id|ccb
(braket
id|mbo
)braket
dot
id|lun
comma
id|mbo
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|my_done
op_assign
id|sctmp-&gt;scsi_done
suffix:semicolon
r_if
c_cond
(paren
id|sctmp-&gt;host_scribble
)paren
id|scsi_free
c_func
(paren
id|sctmp-&gt;host_scribble
comma
id|BUSLOGIC_SG_MALLOC
)paren
suffix:semicolon
multiline_comment|/* ??? more error checking left out here */
r_if
c_cond
(paren
id|mbistatus
op_ne
id|MBX_COMPLETION_OK
)paren
(brace
multiline_comment|/* ??? This is surely wrong, but I don&squot;t know what&squot;s right. */
id|errstatus
op_assign
id|makecode
c_func
(paren
id|ccb
(braket
id|mbo
)braket
dot
id|hastat
comma
id|ccb
(braket
id|mbo
)braket
dot
id|tarstat
)paren
suffix:semicolon
)brace
r_else
id|errstatus
op_assign
l_int|0
suffix:semicolon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_INTERRUPT)
r_if
c_cond
(paren
id|errstatus
)paren
id|buslogic_printk
c_func
(paren
l_string|&quot;error: %04X %04X&bslash;n&quot;
comma
id|ccb
(braket
id|mbo
)braket
dot
id|hastat
comma
id|ccb
(braket
id|mbo
)braket
dot
id|tarstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status_byte
c_func
(paren
id|ccb
(braket
id|mbo
)braket
dot
id|tarstat
)paren
op_eq
id|CHECK_CONDITION
)paren
(brace
r_int
id|i
suffix:semicolon
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_interrupt: sense:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
id|sctmp-&gt;sense_buffer
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %02X&quot;
comma
id|sctmp-&gt;sense_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|errstatus
)paren
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_interrupt: returning %08X&bslash;n&quot;
comma
id|errstatus
)paren
suffix:semicolon
macro_line|#endif
id|sctmp-&gt;result
op_assign
id|errstatus
suffix:semicolon
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|sc
(braket
id|mbo
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* This effectively frees up&n;&t;&t;&t;&t;&t;&t;   the mailbox slot, as far as&n;&t;&t;&t;&t;&t;&t;   queuecommand is&n;&t;&t;&t;&t;&t;&t;   concerned. */
id|my_done
c_func
(paren
id|sctmp
)paren
suffix:semicolon
id|number_serviced
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* ??? Why does queuecommand return a value?  scsi.c never looks at it... */
DECL|function|buslogic_queuecommand
r_int
id|buslogic_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|scpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_static
r_const
r_int
r_char
id|buscmd
(braket
)braket
op_assign
(brace
id|CMD_START_SCSI
)brace
suffix:semicolon
r_int
r_char
id|direction
suffix:semicolon
r_int
r_char
op_star
id|cmd
op_assign
(paren
r_int
r_char
op_star
)paren
id|scpnt-&gt;cmnd
suffix:semicolon
r_int
r_char
id|target
op_assign
id|scpnt-&gt;target
suffix:semicolon
r_int
r_char
id|lun
op_assign
id|scpnt-&gt;lun
suffix:semicolon
r_void
op_star
id|buff
op_assign
id|scpnt-&gt;request_buffer
suffix:semicolon
r_int
id|bufflen
op_assign
id|scpnt-&gt;request_bufflen
suffix:semicolon
r_int
id|mbo
suffix:semicolon
r_struct
id|mailbox
op_star
id|mb
suffix:semicolon
r_struct
id|ccb
op_star
id|ccb
suffix:semicolon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_COMMAND)
r_if
c_cond
(paren
id|target
OG
l_int|1
)paren
(brace
id|scpnt-&gt;result
op_assign
id|DID_TIME_OUT
op_lshift
l_int|16
suffix:semicolon
id|done
c_func
(paren
id|scpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_star
id|cmd
op_eq
id|REQUEST_SENSE
)paren
(brace
macro_line|#if (BUSLOGIC_DEBUG &amp; (BD_COMMAND | BD_ERRORS))
r_if
c_cond
(paren
id|bufflen
op_ne
r_sizeof
id|scpnt-&gt;sense_buffer
)paren
(brace
id|buslogic_printk
c_func
(paren
l_string|&quot;Wrong buffer length supplied for request sense&quot;
l_string|&quot; (%d)&bslash;n&quot;
comma
id|bufflen
)paren
suffix:semicolon
)brace
macro_line|#endif
id|scpnt-&gt;result
op_assign
l_int|0
suffix:semicolon
id|done
c_func
(paren
id|scpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_COMMAND)
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_star
id|cmd
op_eq
id|READ_10
op_logical_or
op_star
id|cmd
op_eq
id|WRITE_10
op_logical_or
op_star
id|cmd
op_eq
id|READ_6
op_logical_or
op_star
id|cmd
op_eq
id|WRITE_6
)paren
id|i
op_assign
op_star
(paren
r_int
op_star
)paren
(paren
id|cmd
op_plus
l_int|2
)paren
suffix:semicolon
r_else
id|i
op_assign
op_minus
l_int|1
suffix:semicolon
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_queuecommand:&quot;
l_string|&quot; dev %d cmd %02X pos %d len %d &quot;
comma
id|target
comma
op_star
id|cmd
comma
id|i
comma
id|bufflen
)paren
suffix:semicolon
id|buslogic_stat
c_func
(paren
id|scpnt-&gt;host-&gt;io_port
)paren
suffix:semicolon
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_queuecommand: dumping scsi cmd:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|scpnt-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %02X&quot;
comma
id|cmd
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|cmd
op_eq
id|WRITE_10
op_logical_or
op_star
id|cmd
op_eq
id|WRITE_6
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* we are still testing, so *don&squot;t* write */
)brace
macro_line|#endif
id|mb
op_assign
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|mb
suffix:semicolon
id|ccb
op_assign
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|ccbs
suffix:semicolon
multiline_comment|/* Use the outgoing mailboxes in a round-robin fashion, because this&n;       is how the host adapter will scan for them. */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|mbo
op_assign
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|last_mbo_used
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mbo
op_ge
id|BUSLOGIC_MAILBOXES
)paren
id|mbo
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|mb
(braket
id|mbo
)braket
dot
id|status
op_eq
id|MBX_NOT_IN_USE
op_logical_and
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|sc
(braket
id|mbo
)braket
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|mbo
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mbo
op_ge
id|BUSLOGIC_MAILBOXES
)paren
id|mbo
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mbo
op_ne
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|last_mbo_used
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mb
(braket
id|mbo
)braket
dot
id|status
op_ne
id|MBX_NOT_IN_USE
op_logical_or
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|sc
(braket
id|mbo
)braket
)paren
(brace
multiline_comment|/* ??? Instead of panicing, should we enable OMBR interrupts and&n;&t;   sleep until we get one? */
id|panic
c_func
(paren
l_string|&quot;buslogic.c: unable to find empty mailbox&quot;
)paren
suffix:semicolon
)brace
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|sc
(braket
id|mbo
)braket
op_assign
id|scpnt
suffix:semicolon
multiline_comment|/* This will effectively&n;&t;&t;&t;&t;&t;&t;   prevent someone else from&n;&t;&t;&t;&t;&t;&t;   screwing with this cdb. */
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|last_mbo_used
op_assign
id|mbo
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_COMMAND)
id|buslogic_printk
c_func
(paren
l_string|&quot;sending command (%d %08X)...&quot;
comma
id|mbo
comma
id|done
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* This gets trashed for some reason */
id|mb
(braket
id|mbo
)braket
dot
id|ccbptr
op_assign
op_amp
id|ccb
(braket
id|mbo
)braket
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ccb
(braket
id|mbo
)braket
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ccb
)paren
)paren
suffix:semicolon
id|ccb
(braket
id|mbo
)braket
dot
id|cdblen
op_assign
id|scpnt-&gt;cmd_len
suffix:semicolon
multiline_comment|/* SCSI Command Descriptor&n;&t;&t;&t;&t;&t;&t;   Block Length */
id|direction
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|cmd
op_eq
id|READ_10
op_logical_or
op_star
id|cmd
op_eq
id|READ_6
)paren
id|direction
op_assign
l_int|8
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|cmd
op_eq
id|WRITE_10
op_logical_or
op_star
id|cmd
op_eq
id|WRITE_6
)paren
id|direction
op_assign
l_int|16
suffix:semicolon
id|memcpy
c_func
(paren
id|ccb
(braket
id|mbo
)braket
dot
id|cdb
comma
id|cmd
comma
id|ccb
(braket
id|mbo
)braket
dot
id|cdblen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scpnt-&gt;use_sg
)paren
(brace
r_struct
id|scatterlist
op_star
id|sgpnt
suffix:semicolon
r_struct
id|chain
op_star
id|cptr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ccb
(braket
id|mbo
)braket
dot
id|op
op_assign
id|CCB_OP_INIT_SG
suffix:semicolon
multiline_comment|/* SCSI Initiator Command&n;&t;&t;&t;&t;&t;   w/scatter-gather */
id|scpnt-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|scsi_malloc
c_func
(paren
id|BUSLOGIC_SG_MALLOC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scpnt-&gt;host_scribble
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;buslogic.c: unable to allocate DMA memory&quot;
)paren
suffix:semicolon
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|scpnt-&gt;request_buffer
suffix:semicolon
id|cptr
op_assign
(paren
r_struct
id|chain
op_star
)paren
id|scpnt-&gt;host_scribble
suffix:semicolon
r_if
c_cond
(paren
id|scpnt-&gt;use_sg
OG
id|scpnt-&gt;host-&gt;sg_tablesize
)paren
(brace
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_queuecommand: bad segment list,&quot;
l_string|&quot; %d &gt; %d&bslash;n&quot;
comma
id|scpnt-&gt;use_sg
comma
id|scpnt-&gt;host-&gt;sg_tablesize
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;buslogic.c: bad segment list&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|scpnt-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cptr
(braket
id|i
)braket
dot
id|dataptr
op_assign
id|sgpnt
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|cptr
(braket
id|i
)braket
dot
id|datalen
op_assign
id|sgpnt
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
id|ccb
(braket
id|mbo
)braket
dot
id|datalen
op_assign
id|scpnt-&gt;use_sg
op_star
r_sizeof
(paren
r_struct
id|chain
)paren
suffix:semicolon
id|ccb
(braket
id|mbo
)braket
dot
id|dataptr
op_assign
id|cptr
suffix:semicolon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_COMMAND)
(brace
r_int
r_char
op_star
id|ptr
suffix:semicolon
id|buslogic_printk
c_func
(paren
l_string|&quot;cptr %08X:&quot;
comma
id|cptr
)paren
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
id|cptr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|18
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %02X&quot;
comma
id|ptr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
(brace
id|ccb
(braket
id|mbo
)braket
dot
id|op
op_assign
id|CCB_OP_INIT
suffix:semicolon
multiline_comment|/* SCSI Initiator Command */
id|scpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|ccb
(braket
id|mbo
)braket
dot
id|datalen
op_assign
id|bufflen
suffix:semicolon
id|ccb
(braket
id|mbo
)braket
dot
id|dataptr
op_assign
id|buff
suffix:semicolon
)brace
id|ccb
(braket
id|mbo
)braket
dot
id|id
op_assign
id|target
suffix:semicolon
id|ccb
(braket
id|mbo
)braket
dot
id|lun
op_assign
id|lun
suffix:semicolon
id|ccb
(braket
id|mbo
)braket
dot
id|dir
op_assign
id|direction
suffix:semicolon
id|ccb
(braket
id|mbo
)braket
dot
id|rsalen
op_assign
r_sizeof
id|scpnt-&gt;sense_buffer
suffix:semicolon
id|ccb
(braket
id|mbo
)braket
dot
id|senseptr
op_assign
id|scpnt-&gt;sense_buffer
suffix:semicolon
id|ccb
(braket
id|mbo
)braket
dot
id|linkptr
op_assign
l_int|NULL
suffix:semicolon
id|ccb
(braket
id|mbo
)braket
dot
id|commlinkid
op_assign
l_int|0
suffix:semicolon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_COMMAND)
(brace
r_int
id|i
suffix:semicolon
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_queuecommand: sending...&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
id|ccb
(braket
id|mbo
)braket
op_minus
l_int|10
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %02X&quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|ccb
(braket
id|mbo
)braket
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|done
)paren
(brace
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_COMMAND)
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_queuecommand: now waiting for interrupt: &quot;
)paren
suffix:semicolon
id|buslogic_stat
c_func
(paren
id|scpnt-&gt;host-&gt;io_port
)paren
suffix:semicolon
macro_line|#endif
id|scpnt-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|mb
(braket
id|mbo
)braket
dot
id|status
op_assign
id|MBX_ACTION_START
suffix:semicolon
multiline_comment|/* start scsi command */
id|buslogic_out
c_func
(paren
id|scpnt-&gt;host-&gt;io_port
comma
id|buscmd
comma
r_sizeof
id|buscmd
)paren
suffix:semicolon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_COMMAND)
id|buslogic_stat
c_func
(paren
id|scpnt-&gt;host-&gt;io_port
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_queuecommand: done can&squot;t be NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_void
id|internal_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|scpnt
)paren
(brace
id|scpnt-&gt;SCp.Status
op_increment
suffix:semicolon
)brace
r_int
id|buslogic_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|scpnt
)paren
(brace
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_COMMAND)
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_command: calling buslogic_queuecommand&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|buslogic_queuecommand
c_func
(paren
id|scpnt
comma
id|internal_done
)paren
suffix:semicolon
id|scpnt-&gt;SCp.Status
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|scpnt-&gt;SCp.Status
)paren
r_continue
suffix:semicolon
r_return
id|scpnt-&gt;result
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Initialize mailboxes. */
DECL|function|setup_mailboxes
r_static
r_int
id|setup_mailboxes
c_func
(paren
r_int
r_int
id|base
comma
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|ok
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Innocent until proven guilty... */
r_struct
id|mailbox
op_star
id|mb
op_assign
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|mb
suffix:semicolon
r_struct
id|ccb
op_star
id|ccb
op_assign
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|ccbs
suffix:semicolon
r_struct
(brace
r_int
r_char
id|cmd
comma
id|count
suffix:semicolon
r_void
op_star
id|base
id|PACKED
suffix:semicolon
)brace
id|cmd
op_assign
(brace
id|CMD_INITEXTMB
comma
id|BUSLOGIC_MAILBOXES
comma
id|mb
)brace
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BUSLOGIC_MAILBOXES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mb
(braket
id|i
)braket
dot
id|status
op_assign
id|mb
(braket
id|BUSLOGIC_MAILBOXES
op_plus
id|i
)braket
dot
id|status
op_assign
id|MBX_NOT_IN_USE
suffix:semicolon
id|mb
(braket
id|i
)braket
dot
id|ccbptr
op_assign
op_amp
id|ccb
(braket
id|i
)braket
suffix:semicolon
)brace
id|INTR_RESET
c_func
(paren
id|base
)paren
suffix:semicolon
multiline_comment|/* reset interrupts, so they don&squot;t block */
r_if
c_cond
(paren
id|buslogic_out
c_func
(paren
id|base
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|cmd
comma
r_sizeof
id|cmd
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|WAIT_UNTIL
c_func
(paren
id|INTERRUPT
c_func
(paren
id|base
)paren
comma
id|CMDC
)paren
suffix:semicolon
id|ok
op_assign
id|TRUE
suffix:semicolon
r_while
c_loop
(paren
l_int|0
)paren
(brace
id|fail
suffix:colon
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_detect: failed setting up mailboxes&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|INTR_RESET
c_func
(paren
id|base
)paren
suffix:semicolon
r_return
op_logical_neg
id|ok
suffix:semicolon
)brace
DECL|function|getconfig
r_static
r_int
id|getconfig
c_func
(paren
r_int
r_int
id|base
comma
r_int
r_char
op_star
id|irq
comma
r_int
r_char
op_star
id|dma
comma
r_int
r_char
op_star
id|id
comma
r_char
op_star
id|bus_type
comma
r_int
r_int
op_star
id|max_sg
comma
r_const
r_int
r_char
op_star
op_star
id|bios
)paren
(brace
r_int
r_char
id|inquiry_cmd
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_char
id|inquiry_result
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_DETECT)
id|buslogic_printk
c_func
(paren
l_string|&quot;getconfig: called&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|i
op_assign
id|inb
c_func
(paren
id|STATUS
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|DIRRDY
)paren
id|i
op_assign
id|inb
c_func
(paren
id|DATA_IN
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|inquiry_cmd
(braket
l_int|0
)braket
op_assign
id|CMD_RETCONF
suffix:semicolon
id|buslogic_out
c_func
(paren
id|base
comma
id|inquiry_cmd
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buslogic_in
c_func
(paren
id|base
comma
id|inquiry_result
comma
l_int|3
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|WAIT_UNTIL_FAST
c_func
(paren
id|INTERRUPT
c_func
(paren
id|base
)paren
comma
id|CMDC
)paren
suffix:semicolon
id|INTR_RESET
c_func
(paren
id|base
)paren
suffix:semicolon
multiline_comment|/* Defer using the DMA value until we know the bus type. */
op_star
id|dma
op_assign
id|inquiry_result
(braket
l_int|0
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|inquiry_result
(braket
l_int|1
)braket
)paren
(brace
r_case
l_int|0x01
suffix:colon
op_star
id|irq
op_assign
l_int|9
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x02
suffix:colon
op_star
id|irq
op_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x04
suffix:colon
op_star
id|irq
op_assign
l_int|11
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x08
suffix:colon
op_star
id|irq
op_assign
l_int|12
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x20
suffix:colon
op_star
id|irq
op_assign
l_int|14
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x40
suffix:colon
op_star
id|irq
op_assign
l_int|15
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|buslogic_printk
c_func
(paren
l_string|&quot;Unable to determine BusLogic IRQ level.&quot;
l_string|&quot;  Disabling board.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
op_star
id|id
op_assign
id|inquiry_result
(braket
l_int|2
)braket
op_amp
l_int|0x7
suffix:semicolon
multiline_comment|/* I expected Adaptec boards to fail on this, but it doesn&squot;t happen... */
id|inquiry_cmd
(braket
l_int|0
)braket
op_assign
id|CMD_INQEXTSETUP
suffix:semicolon
id|inquiry_cmd
(braket
l_int|1
)braket
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|buslogic_out
c_func
(paren
id|base
comma
id|inquiry_cmd
comma
l_int|2
)paren
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
id|buslogic_in
c_func
(paren
id|base
comma
id|inquiry_result
comma
id|inquiry_cmd
(braket
l_int|1
)braket
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|WAIT_UNTIL_FAST
c_func
(paren
id|INTERRUPT
c_func
(paren
id|base
)paren
comma
id|CMDC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|STATUS
c_func
(paren
id|base
)paren
)paren
op_amp
id|CMDINV
)paren
r_goto
id|fail
suffix:semicolon
id|INTR_RESET
c_func
(paren
id|base
)paren
suffix:semicolon
op_star
id|bus_type
op_assign
id|inquiry_result
(braket
l_int|0
)braket
suffix:semicolon
id|CHECK
c_func
(paren
op_star
id|bus_type
op_eq
l_char|&squot;A&squot;
op_logical_or
op_star
id|bus_type
op_eq
l_char|&squot;E&squot;
op_logical_or
op_star
id|bus_type
op_eq
l_char|&squot;M&squot;
)paren
suffix:semicolon
op_star
id|bios
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|inquiry_result
(braket
l_int|1
)braket
op_lshift
l_int|12
)paren
suffix:semicolon
op_star
id|max_sg
op_assign
(paren
id|inquiry_result
(braket
l_int|3
)braket
op_lshift
l_int|8
)paren
op_or
id|inquiry_result
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* We only need a DMA channel for ISA boards.  Some other types of boards&n;       (such as the 747S) have an option to report a DMA channel even though&n;       none is used (for compatibility with Adaptec drivers which require a&n;       DMA channel).  We ignore this. */
r_if
c_cond
(paren
op_star
id|bus_type
op_eq
l_char|&squot;A&squot;
)paren
r_switch
c_cond
(paren
op_star
id|dma
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* This indicates that no DMA channel is used. */
op_star
id|dma
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x20
suffix:colon
op_star
id|dma
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x40
suffix:colon
op_star
id|dma
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x80
suffix:colon
op_star
id|dma
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|buslogic_printk
c_func
(paren
l_string|&quot;Unable to determine BusLogic DMA channel.&quot;
l_string|&quot;  Disabling board.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
r_else
op_star
id|dma
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|0
)paren
(brace
id|fail
suffix:colon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_DETECT)
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_detect: query board settings&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|TRUE
suffix:semicolon
)brace
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Query the board.  This acts both as part of the detection sequence and as a&n;   means to get necessary configuration information. */
DECL|function|buslogic_query
r_static
r_int
id|buslogic_query
c_func
(paren
r_int
r_int
id|base
comma
r_int
r_char
op_star
id|trans
comma
r_int
r_char
op_star
id|irq
comma
r_int
r_char
op_star
id|dma
comma
r_int
r_char
op_star
id|id
comma
r_char
op_star
id|bus_type
comma
r_int
r_int
op_star
id|max_sg
comma
r_const
r_int
r_char
op_star
op_star
id|bios
comma
r_char
op_star
id|model
comma
r_char
op_star
id|firmware_rev
)paren
(brace
r_int
r_char
id|inquiry_cmd
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_char
id|inquiry_result
(braket
l_int|6
)braket
suffix:semicolon
r_int
r_char
id|geo
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_DETECT)
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_query: called&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Quick and dirty test for presence of the card. */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|STATUS
c_func
(paren
id|base
)paren
)paren
op_eq
l_int|0xFF
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/* Check the GEOMETRY port early for quick bailout on Adaptec boards. */
id|geo
op_assign
id|inb
c_func
(paren
id|GEOMETRY
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_DETECT)
id|buslogic_printk
c_func
(paren
l_string|&quot;geometry bits: %02X&bslash;n&quot;
comma
id|geo
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Here is where we tell the men from the boys (i.e. Adaptec&squot;s don&squot;t&n;       support the GEOMETRY port, the men do :-) */
r_if
c_cond
(paren
id|geo
op_eq
l_int|0xFF
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/* In case some other card was probing here, reset interrupts. */
id|INTR_RESET
c_func
(paren
id|base
)paren
suffix:semicolon
multiline_comment|/* Reset the adapter.  I ought to make a hard reset, but it&squot;s not really&n;       necessary. */
id|outb
c_func
(paren
id|RSOFT
op_or
id|RINT
multiline_comment|/* | RSBUS*/
comma
id|CONTROL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* Wait a little bit for things to settle down. */
id|i
op_assign
id|jiffies
op_plus
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|i
OG
id|jiffies
)paren
suffix:semicolon
multiline_comment|/* Expect INREQ and HARDY, any of the others are bad. */
id|WAIT
c_func
(paren
id|STATUS
c_func
(paren
id|base
)paren
comma
id|INREQ
op_or
id|HARDY
comma
id|DACT
op_or
id|DFAIL
op_or
id|CMDINV
op_or
id|DIRRDY
op_or
id|CPRBSY
)paren
suffix:semicolon
multiline_comment|/* Shouldn&squot;t have generated any interrupts during reset. */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|INTERRUPT
c_func
(paren
id|base
)paren
)paren
op_amp
id|INTRMASK
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/* Getting the BusLogic firmware revision level is a bit tricky.  We get&n;       the first two digits (d.d) from CMD_INQUIRY and then use two undocumented&n;       commands to get the remaining digit and letter (d.ddl as in 3.31C). */
id|inquiry_cmd
(braket
l_int|0
)braket
op_assign
id|CMD_INQUIRY
suffix:semicolon
id|buslogic_out
c_func
(paren
id|base
comma
id|inquiry_cmd
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buslogic_in
c_func
(paren
id|base
comma
id|inquiry_result
comma
l_int|4
)paren
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/* Reading port should reset DIRRDY. */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|STATUS
c_func
(paren
id|base
)paren
)paren
op_amp
id|DIRRDY
)paren
r_goto
id|fail
suffix:semicolon
id|WAIT_UNTIL_FAST
c_func
(paren
id|INTERRUPT
c_func
(paren
id|base
)paren
comma
id|CMDC
)paren
suffix:semicolon
id|INTR_RESET
c_func
(paren
id|base
)paren
suffix:semicolon
id|firmware_rev
(braket
l_int|0
)braket
op_assign
id|inquiry_result
(braket
l_int|2
)braket
suffix:semicolon
id|firmware_rev
(braket
l_int|1
)braket
op_assign
l_char|&squot;.&squot;
suffix:semicolon
id|firmware_rev
(braket
l_int|2
)braket
op_assign
id|inquiry_result
(braket
l_int|3
)braket
suffix:semicolon
id|firmware_rev
(braket
l_int|3
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
macro_line|#if 0
id|buslogic_printk
c_func
(paren
l_string|&quot;Inquiry Bytes: %02X(%c) %02X(%c)&bslash;n&quot;
comma
id|inquiry_result
(braket
l_int|0
)braket
comma
id|inquiry_result
(braket
l_int|0
)braket
comma
id|inquiry_result
(braket
l_int|1
)braket
comma
id|inquiry_result
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|getconfig
c_func
(paren
id|base
comma
id|irq
comma
id|dma
comma
id|id
comma
id|bus_type
comma
id|max_sg
comma
id|bios
)paren
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/* Set up defaults */
macro_line|#ifdef BIOS_TRANSLATION_OVERRIDE
op_star
id|trans
op_assign
id|BIOS_TRANSLATION_OVERRIDE
suffix:semicolon
macro_line|#else
op_star
id|trans
op_assign
id|BIOS_TRANSLATION_DEFAULT
suffix:semicolon
macro_line|#endif
id|model
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|model
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ??? Begin undocumented command use.&n;       These may not be supported by clones. */
r_do
(brace
multiline_comment|/* ??? It appears as though AMI BusLogic clones don&squot;t implement this&n;&t;   feature.  As an experiment, if we read a 00 we ignore the GEO_GT_1GB&n;&t;   bit and skip all further undocumented commands. */
r_if
c_cond
(paren
id|geo
op_eq
l_int|0x00
)paren
r_break
suffix:semicolon
macro_line|#ifndef BIOS_TRANSLATION_OVERRIDE
op_star
id|trans
op_assign
(paren
(paren
id|geo
op_amp
id|GEO_GT_1GB
)paren
ques
c_cond
id|BIOS_TRANSLATION_BIG
suffix:colon
id|BIOS_TRANSLATION_DEFAULT
)paren
suffix:semicolon
macro_line|#endif
id|inquiry_cmd
(braket
l_int|0
)braket
op_assign
id|CMD_VER_NO_LAST
suffix:semicolon
id|buslogic_out
c_func
(paren
id|base
comma
id|inquiry_cmd
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buslogic_in
c_func
(paren
id|base
comma
id|inquiry_result
comma
l_int|1
)paren
)paren
r_break
suffix:semicolon
id|WAIT_UNTIL_FAST
c_func
(paren
id|INTERRUPT
c_func
(paren
id|base
)paren
comma
id|CMDC
)paren
suffix:semicolon
id|INTR_RESET
c_func
(paren
id|base
)paren
suffix:semicolon
id|firmware_rev
(braket
l_int|3
)braket
op_assign
id|inquiry_result
(braket
l_int|0
)braket
suffix:semicolon
id|firmware_rev
(braket
l_int|4
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|inquiry_cmd
(braket
l_int|0
)braket
op_assign
id|CMD_VER_NO_LETTER
suffix:semicolon
id|buslogic_out
c_func
(paren
id|base
comma
id|inquiry_cmd
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buslogic_in
c_func
(paren
id|base
comma
id|inquiry_result
comma
l_int|1
)paren
)paren
r_break
suffix:semicolon
id|WAIT_UNTIL_FAST
c_func
(paren
id|INTERRUPT
c_func
(paren
id|base
)paren
comma
id|CMDC
)paren
suffix:semicolon
id|INTR_RESET
c_func
(paren
id|base
)paren
suffix:semicolon
id|firmware_rev
(braket
l_int|4
)braket
op_assign
id|inquiry_result
(braket
l_int|0
)braket
suffix:semicolon
id|firmware_rev
(braket
l_int|5
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* Use undocumented command to get model number and revision. */
id|inquiry_cmd
(braket
l_int|0
)braket
op_assign
id|CMD_RET_MODEL_NO
suffix:semicolon
id|inquiry_cmd
(braket
l_int|1
)braket
op_assign
l_int|6
suffix:semicolon
id|buslogic_out
c_func
(paren
id|base
comma
id|inquiry_cmd
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buslogic_in
c_func
(paren
id|base
comma
id|inquiry_result
comma
id|inquiry_cmd
(braket
l_int|1
)braket
)paren
)paren
r_break
suffix:semicolon
id|WAIT_UNTIL_FAST
c_func
(paren
id|INTERRUPT
c_func
(paren
id|base
)paren
comma
id|CMDC
)paren
suffix:semicolon
id|INTR_RESET
c_func
(paren
id|base
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|model
comma
id|inquiry_result
comma
l_int|5
)paren
suffix:semicolon
id|model
(braket
l_int|5
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|model
(braket
l_int|6
)braket
op_assign
id|inquiry_result
(braket
l_int|5
)braket
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* ??? End undocumented command use. */
multiline_comment|/* bus_type from getconfig doesn&squot;t differentiate between EISA/VESA.  We&n;       override using the model number here. */
multiline_comment|/* ??? What bus_type gets returned for PCI? */
r_switch
c_cond
(paren
op_star
id|bus_type
)paren
(brace
r_case
l_char|&squot;E&squot;
suffix:colon
r_switch
c_cond
(paren
id|model
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;4&squot;
suffix:colon
op_star
id|bus_type
op_assign
l_char|&squot;V&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;7&squot;
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|bus_type
op_assign
l_char|&squot;X&squot;
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|0
)paren
(brace
id|fail
suffix:colon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_DETECT)
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_query: query board settings&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|TRUE
suffix:semicolon
)brace
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* return non-zero on detection */
DECL|function|buslogic_detect
r_int
id|buslogic_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
r_char
id|dma
suffix:semicolon
r_int
r_char
id|irq
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_int
r_char
id|id
suffix:semicolon
r_char
id|bus_type
suffix:semicolon
r_int
r_int
id|max_sg
suffix:semicolon
r_int
r_char
id|bios_translation
suffix:semicolon
r_const
r_int
r_char
op_star
id|bios
suffix:semicolon
r_char
op_star
id|model
suffix:semicolon
r_char
op_star
id|firmware_rev
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_int
id|indx
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_DETECT)
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_detect:&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|tpnt-&gt;can_queue
op_assign
id|BUSLOGIC_MAILBOXES
suffix:semicolon
r_for
c_loop
(paren
id|indx
op_assign
l_int|0
suffix:semicolon
id|indx
OL
id|ARRAY_SIZE
c_func
(paren
id|bases
)paren
suffix:semicolon
id|indx
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|check_region
c_func
(paren
id|bases
(braket
id|indx
)braket
comma
l_int|4
)paren
)paren
(brace
id|shpnt
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
r_sizeof
(paren
r_struct
id|hostdata
)paren
)paren
suffix:semicolon
id|base
op_assign
id|bases
(braket
id|indx
)braket
suffix:semicolon
id|model
op_assign
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|model
suffix:semicolon
id|firmware_rev
op_assign
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|firmware_rev
suffix:semicolon
r_if
c_cond
(paren
id|buslogic_query
c_func
(paren
id|base
comma
op_amp
id|bios_translation
comma
op_amp
id|irq
comma
op_amp
id|dma
comma
op_amp
id|id
comma
op_amp
id|bus_type
comma
op_amp
id|max_sg
comma
op_amp
id|bios
comma
id|model
comma
id|firmware_rev
)paren
)paren
r_goto
id|unregister
suffix:semicolon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_DETECT)
id|buslogic_stat
c_func
(paren
id|base
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|setup_mailboxes
c_func
(paren
id|base
comma
id|shpnt
)paren
)paren
r_goto
id|unregister
suffix:semicolon
multiline_comment|/* Set the Bus on/off-times as not to ruin floppy performance.&n;&t;       CMD_BUSOFF_TIME is a noop for EISA boards (and possibly&n;&t;       others???). */
r_if
c_cond
(paren
id|bus_type
op_ne
l_char|&squot;E&squot;
)paren
(brace
multiline_comment|/* The default ON/OFF times for BusLogic adapters is 7/4. */
r_static
r_const
r_int
r_char
id|oncmd
(braket
)braket
op_assign
(brace
id|CMD_BUSON_TIME
comma
l_int|7
)brace
suffix:semicolon
r_static
r_const
r_int
r_char
id|offcmd
(braket
)braket
op_assign
(brace
id|CMD_BUSOFF_TIME
comma
l_int|5
)brace
suffix:semicolon
id|INTR_RESET
c_func
(paren
id|base
)paren
suffix:semicolon
id|buslogic_out
c_func
(paren
id|base
comma
id|oncmd
comma
r_sizeof
id|oncmd
)paren
suffix:semicolon
id|WAIT_UNTIL
c_func
(paren
id|INTERRUPT
c_func
(paren
id|base
)paren
comma
id|CMDC
)paren
suffix:semicolon
id|INTR_RESET
c_func
(paren
id|base
)paren
suffix:semicolon
id|buslogic_out
c_func
(paren
id|base
comma
id|offcmd
comma
r_sizeof
id|offcmd
)paren
suffix:semicolon
id|WAIT_UNTIL
c_func
(paren
id|INTERRUPT
c_func
(paren
id|base
)paren
comma
id|CMDC
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|0
)paren
(brace
id|fail
suffix:colon
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_detect:&quot;
l_string|&quot; setting bus on/off-time failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|INTR_RESET
c_func
(paren
id|base
)paren
suffix:semicolon
)brace
id|buslogic_printk
c_func
(paren
l_string|&quot;Configuring %s HA at port 0x%03X, IRQ %u&quot;
comma
(paren
id|bus_type
op_eq
l_char|&squot;A&squot;
ques
c_cond
l_string|&quot;ISA&quot;
suffix:colon
(paren
id|bus_type
op_eq
l_char|&squot;E&squot;
ques
c_cond
l_string|&quot;EISA&quot;
suffix:colon
(paren
id|bus_type
op_eq
l_char|&squot;M&squot;
ques
c_cond
l_string|&quot;MCA&quot;
suffix:colon
(paren
id|bus_type
op_eq
l_char|&squot;P&squot;
ques
c_cond
l_string|&quot;PCI&quot;
suffix:colon
(paren
id|bus_type
op_eq
l_char|&squot;V&squot;
ques
c_cond
l_string|&quot;VESA&quot;
suffix:colon
(paren
id|bus_type
op_eq
l_char|&squot;X&squot;
ques
c_cond
l_string|&quot;EISA/VESA&quot;
suffix:colon
l_string|&quot;Unknown&quot;
)paren
)paren
)paren
)paren
)paren
)paren
comma
id|base
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bios
op_ne
l_int|NULL
)paren
id|printk
c_func
(paren
l_string|&quot;, BIOS 0x%05X&quot;
comma
(paren
r_int
r_int
)paren
id|bios
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;, DMA %u&quot;
comma
id|dma
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, ID %u&bslash;n&quot;
comma
id|id
)paren
suffix:semicolon
id|buslogic_printk
c_func
(paren
l_string|&quot;Model Number: %s&quot;
comma
(paren
id|model
(braket
l_int|0
)braket
ques
c_cond
id|model
suffix:colon
l_string|&quot;Unknown&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|model
(braket
l_int|0
)braket
)paren
id|printk
c_func
(paren
l_string|&quot; (revision %d)&quot;
comma
id|model
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|buslogic_printk
c_func
(paren
l_string|&quot;Firmware revision: %s&bslash;n&quot;
comma
id|firmware_rev
)paren
suffix:semicolon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_DETECT)
id|buslogic_stat
c_func
(paren
id|base
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_DETECT)
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_detect: enable interrupt channel %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|irq
comma
id|buslogic_interrupt
comma
l_int|0
comma
l_string|&quot;buslogic&quot;
)paren
)paren
(brace
id|buslogic_printk
c_func
(paren
l_string|&quot;Unable to allocate IRQ for &quot;
l_string|&quot;BusLogic controller.&bslash;n&quot;
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_goto
id|unregister
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dma
)paren
(brace
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|dma
comma
l_string|&quot;buslogic&quot;
)paren
)paren
(brace
id|buslogic_printk
c_func
(paren
l_string|&quot;Unable to allocate DMA channel for &quot;
l_string|&quot;BusLogic controller.&bslash;n&quot;
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_goto
id|unregister
suffix:semicolon
)brace
multiline_comment|/* The DMA-Controller.  We need to fool with this because we&n;&t;&t;   want to be able to use an ISA BusLogic without having to&n;&t;&t;   have the BIOS enabled. */
id|set_dma_mode
c_func
(paren
id|dma
comma
id|DMA_MODE_CASCADE
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|dma
)paren
suffix:semicolon
)brace
id|host
(braket
id|irq
op_minus
l_int|9
)braket
op_assign
id|shpnt
suffix:semicolon
id|shpnt-&gt;this_id
op_assign
id|id
suffix:semicolon
multiline_comment|/* Only type &squot;A&squot; (AT/ISA) bus adapters use unchecked DMA. */
id|shpnt-&gt;unchecked_isa_dma
op_assign
(paren
id|bus_type
op_eq
l_char|&squot;A&squot;
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_NO_BUGGY_BUSLOGIC
multiline_comment|/* There is a hardware bug in the BT-445S prior to revision D.&n;&t;       When the BIOS is enabled and you have more than 16MB of memory,&n;&t;       the card mishandles memory transfers over 16MB which (if viewed&n;&t;       as a 24-bit address) overlap with the BIOS address space.  For&n;&t;       example if you have the BIOS located at physical address&n;&t;       0xDC000 and a DMA transfer from the card to RAM starts at&n;&t;       physical address 0x10DC000 then the transfer is messed up.  To&n;&t;       be more precise every fourth byte of the transfer is messed up.&n;&t;       (This analysis courtesy of Tomas Hurka, author of the NeXTSTEP&n;&t;       BusLogic driver.) */
r_if
c_cond
(paren
id|bus_type
op_eq
l_char|&squot;V&squot;
multiline_comment|/* 445 */
op_logical_and
id|firmware_rev
(braket
l_int|0
)braket
op_le
l_char|&squot;3&squot;
multiline_comment|/* S */
op_logical_and
id|bios
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* BIOS enabled */
macro_line|#if 1
multiline_comment|/* Now that LNZ&squot;s forbidden_addr stuff makes it into the higher&n;&t;&t;   level scsi code, we can use this instead. */
multiline_comment|/* Avoid addresses which &quot;mirror&quot; the BIOS for DMA. */
id|shpnt-&gt;forbidden_addr
op_assign
id|bios
suffix:semicolon
id|shpnt-&gt;forbidden_size
op_assign
l_int|16
op_star
l_int|1024
suffix:semicolon
macro_line|#else
multiline_comment|/* Use double-buffering. */
id|shpnt-&gt;unchecked_isa_dma
op_assign
id|TRUE
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif
multiline_comment|/* Have to keep cmd_per_lun at 1 for ISA machines otherwise lots&n;&t;       of memory gets sucked up for bounce buffers.  */
id|shpnt-&gt;cmd_per_lun
op_assign
(paren
id|shpnt-&gt;unchecked_isa_dma
ques
c_cond
l_int|1
suffix:colon
id|BUSLOGIC_CMDLUN
)paren
suffix:semicolon
id|shpnt-&gt;sg_tablesize
op_assign
id|max_sg
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;sg_tablesize
OG
id|BUSLOGIC_MAX_SG
)paren
id|shpnt-&gt;sg_tablesize
op_assign
id|BUSLOGIC_MAX_SG
suffix:semicolon
multiline_comment|/* ??? shpnt-&gt;base should really be &quot;const unsigned char *&quot;... */
id|shpnt-&gt;base
op_assign
(paren
r_int
r_char
op_star
)paren
id|bios
suffix:semicolon
id|shpnt-&gt;io_port
op_assign
id|base
suffix:semicolon
id|shpnt-&gt;dma_channel
op_assign
id|dma
suffix:semicolon
id|shpnt-&gt;irq
op_assign
id|irq
suffix:semicolon
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|bios_translation
op_assign
id|bios_translation
suffix:semicolon
r_if
c_cond
(paren
id|bios_translation
op_eq
id|BIOS_TRANSLATION_BIG
)paren
id|buslogic_printk
c_func
(paren
l_string|&quot;Using extended bios translation.&bslash;n&quot;
)paren
suffix:semicolon
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|last_mbi_used
op_assign
l_int|2
op_star
id|BUSLOGIC_MAILBOXES
op_minus
l_int|1
suffix:semicolon
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|last_mbo_used
op_assign
id|BUSLOGIC_MAILBOXES
op_minus
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|sc
comma
l_int|0
comma
r_sizeof
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|sc
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if 0
(brace
r_int
r_char
id|buf
(braket
l_int|8
)braket
suffix:semicolon
r_int
r_char
id|cmd
(braket
)braket
op_assign
(brace
id|READ_CAPACITY
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_DETECT)
id|buslogic_printk
c_func
(paren
l_string|&quot;*** READ CAPACITY ***&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
id|buf
suffix:semicolon
id|i
op_increment
)paren
id|buf
(braket
id|i
)braket
op_assign
l_int|0x87
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|buslogic_command
c_func
(paren
id|i
comma
id|cmd
comma
id|buf
comma
r_sizeof
id|buf
)paren
)paren
(brace
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_detect: LU %u &quot;
l_string|&quot;sector_size %d device_size %d&bslash;n&quot;
comma
id|i
comma
op_star
(paren
r_int
op_star
)paren
(paren
id|buf
op_plus
l_int|4
)paren
comma
op_star
(paren
r_int
op_star
)paren
id|buf
)paren
suffix:semicolon
)brace
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_DETECT)
id|buslogic_printk
c_func
(paren
l_string|&quot;*** NOW RUNNING MY OWN TEST ***&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_static
id|buffer
(braket
l_int|512
)braket
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
id|READ_10
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|xany2scsi
c_func
(paren
id|cmd
op_plus
l_int|2
comma
id|i
)paren
suffix:semicolon
id|cmd
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd
(braket
l_int|7
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd
(braket
l_int|8
)braket
op_assign
l_int|1
suffix:semicolon
id|cmd
(braket
l_int|9
)braket
op_assign
l_int|0
suffix:semicolon
id|buslogic_command
c_func
(paren
l_int|0
comma
id|cmd
comma
id|buffer
comma
r_sizeof
id|buffer
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|snarf_region
c_func
(paren
id|bases
(braket
id|indx
)braket
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Register the IO ports that&n;&t;&t;&t;&t;&t;&t;   we use */
id|count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
id|unregister
suffix:colon
id|scsi_unregister
c_func
(paren
id|shpnt
)paren
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|restart
r_static
r_int
id|restart
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
r_static
r_const
r_int
r_char
id|buscmd
(braket
)braket
op_assign
(brace
id|CMD_START_SCSI
)brace
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BUSLOGIC_MAILBOXES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|sc
(braket
id|i
)braket
op_logical_and
op_logical_neg
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|sc
(braket
id|i
)braket
op_member_access_from_pointer
id|device-&gt;soft_reset
)paren
(brace
macro_line|#if 0
id|HOSTDATA
c_func
(paren
id|shpnt
)paren
op_member_access_from_pointer
id|mb
(braket
id|i
)braket
dot
id|status
op_assign
id|MBX_ACTION_START
suffix:semicolon
multiline_comment|/* Indicate ready to restart... */
macro_line|#endif
id|count
op_increment
suffix:semicolon
)brace
id|buslogic_printk
c_func
(paren
l_string|&quot;Potential to restart %d stalled commands...&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* start scsi command */
r_if
c_cond
(paren
id|count
)paren
id|buslogic_out
c_func
(paren
id|shpnt-&gt;host-&gt;io_port
comma
id|buscmd
comma
r_sizeof
id|buscmd
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ??? The abort command for the aha1542 does not leave the device in a clean&n;   state where it is available to be used again.  As it is not clear whether&n;   the same problem exists with BusLogic boards, we will enable this and see&n;   if it works. */
DECL|function|buslogic_abort
r_int
id|buslogic_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|scpnt
)paren
(brace
macro_line|#if 1
r_static
r_const
r_int
r_char
id|buscmd
(braket
)braket
op_assign
(brace
id|CMD_START_SCSI
)brace
suffix:semicolon
r_struct
id|mailbox
op_star
id|mb
suffix:semicolon
r_int
id|mbi
comma
id|mbo
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_abort: %X %X&bslash;n&quot;
comma
id|inb
c_func
(paren
id|STATUS
c_func
(paren
id|scpnt-&gt;host-&gt;io_port
)paren
)paren
comma
id|inb
c_func
(paren
id|INTERRUPT
c_func
(paren
id|scpnt-&gt;host-&gt;io_port
)paren
)paren
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|mb
op_assign
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|mb
suffix:semicolon
id|mbi
op_assign
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|last_mbi_used
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mbi
op_ge
l_int|2
op_star
id|BUSLOGIC_MAILBOXES
)paren
id|mbi
op_assign
id|BUSLOGIC_MAILBOXES
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|mb
(braket
id|mbi
)braket
dot
id|status
op_ne
id|MBX_NOT_IN_USE
)paren
r_break
suffix:semicolon
id|mbi
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mbi
op_ge
l_int|2
op_star
id|BUSLOGIC_MAILBOXES
)paren
id|mbi
op_assign
id|BUSLOGIC_MAILBOXES
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mbi
op_ne
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|last_mbi_used
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mb
(braket
id|mbi
)braket
dot
id|status
op_ne
id|MBX_NOT_IN_USE
)paren
(brace
id|buslogic_printk
c_func
(paren
l_string|&quot;Lost interrupt discovered on irq %d&quot;
l_string|&quot; - attempting to recover&bslash;n&quot;
comma
id|scpnt-&gt;host-&gt;irq
)paren
suffix:semicolon
(brace
r_int
id|intval
(braket
l_int|3
)braket
suffix:semicolon
id|intval
(braket
l_int|0
)braket
op_assign
id|scpnt-&gt;host-&gt;irq
suffix:semicolon
id|buslogic_interrupt
c_func
(paren
(paren
r_int
)paren
op_amp
id|intval
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
)brace
multiline_comment|/* OK, no lost interrupt.  Try looking to see how many pending commands we&n;       think we have. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BUSLOGIC_MAILBOXES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|sc
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|sc
(braket
id|i
)braket
op_eq
id|scpnt
)paren
(brace
id|buslogic_printk
c_func
(paren
l_string|&quot;Timed out command pending for %4.4X&bslash;n&quot;
comma
id|scpnt-&gt;request.dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|mb
(braket
id|i
)braket
dot
id|status
op_ne
id|MBX_NOT_IN_USE
)paren
(brace
id|buslogic_printk
c_func
(paren
l_string|&quot;OGMB still full - restarting&bslash;n&quot;
)paren
suffix:semicolon
id|buslogic_out
c_func
(paren
id|scpnt-&gt;host-&gt;io_port
comma
id|buscmd
comma
r_sizeof
id|buscmd
)paren
suffix:semicolon
)brace
)brace
r_else
id|buslogic_printk
c_func
(paren
l_string|&quot;Other pending command %4.4X&bslash;n&quot;
comma
id|scpnt-&gt;request.dev
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_ABORT)
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_abort&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 1
multiline_comment|/* This section of code should be used carefully - some devices cannot&n;       abort a command, and this merely makes it worse. */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mbo
op_assign
l_int|0
suffix:semicolon
id|mbo
OL
id|BUSLOGIC_MAILBOXES
suffix:semicolon
id|mbo
op_increment
)paren
r_if
c_cond
(paren
id|scpnt
op_eq
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|sc
(braket
id|mbo
)braket
)paren
(brace
id|mb
(braket
id|mbo
)braket
dot
id|status
op_assign
id|MBX_ACTION_ABORT
suffix:semicolon
id|buslogic_out
c_func
(paren
id|scpnt-&gt;host-&gt;io_port
comma
id|buscmd
comma
r_sizeof
id|buscmd
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
multiline_comment|/* We do not implement a reset function here, but the upper level code assumes&n;   that it will get some kind of response for the command in scpnt.  We must&n;   oblige, or the command will hang the SCSI system.  For a first go, we assume&n;   that the BusLogic notifies us with all of the pending commands (it does&n;   implement soft reset, after all). */
DECL|function|buslogic_reset
r_int
id|buslogic_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|scpnt
)paren
(brace
r_static
r_const
r_int
r_char
id|buscmd
(braket
)braket
op_assign
(brace
id|CMD_START_SCSI
)brace
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
macro_line|#if (BUSLOGIC_DEBUG &amp; BD_RESET)
id|buslogic_printk
c_func
(paren
l_string|&quot;buslogic_reset&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0
multiline_comment|/* This does a scsi reset for all devices on the bus. */
id|outb
c_func
(paren
id|RSBUS
comma
id|CONTROL
c_func
(paren
id|scpnt-&gt;host-&gt;io_port
)paren
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* This does a selective reset of just the one device. */
multiline_comment|/* First locate the ccb for this command. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BUSLOGIC_MAILBOXES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|sc
(braket
id|i
)braket
op_eq
id|scpnt
)paren
(brace
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|ccbs
(braket
id|i
)braket
dot
id|op
op_assign
id|CCB_OP_BUS_RESET
suffix:semicolon
multiline_comment|/* Now tell the BusLogic to flush all pending commands for this&n;&t;       target. */
id|buslogic_out
c_func
(paren
id|scpnt-&gt;host-&gt;io_port
comma
id|buscmd
comma
r_sizeof
id|buscmd
)paren
suffix:semicolon
multiline_comment|/* Here is the tricky part.  What to do next.  Do we get an&n;&t;       interrupt for the commands that we aborted with the specified&n;&t;       target, or do we generate this on our own?  Try it without first&n;&t;       and see what happens. */
id|buslogic_printk
c_func
(paren
l_string|&quot;Sent BUS DEVICE RESET to target %d&bslash;n&quot;
comma
id|scpnt-&gt;target
)paren
suffix:semicolon
multiline_comment|/* If the first does not work, then try the second.  I think the&n;&t;       first option is more likely to be correct.  Free the command&n;&t;       block for all commands running on this target... */
macro_line|#if 1
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BUSLOGIC_MAILBOXES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|sc
(braket
id|i
)braket
op_logical_and
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|sc
(braket
id|i
)braket
op_member_access_from_pointer
id|target
op_eq
id|scpnt-&gt;target
)paren
(brace
id|Scsi_Cmnd
op_star
id|sctmp
op_assign
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|sc
(braket
id|i
)braket
suffix:semicolon
id|sctmp-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|sctmp-&gt;host_scribble
)paren
id|scsi_free
c_func
(paren
id|sctmp-&gt;host_scribble
comma
id|BUSLOGIC_SG_MALLOC
)paren
suffix:semicolon
id|buslogic_printk
c_func
(paren
l_string|&quot;Sending DID_RESET for target %d&bslash;n&quot;
comma
id|scpnt-&gt;target
)paren
suffix:semicolon
id|sctmp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|scpnt
)paren
suffix:semicolon
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|sc
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|HOSTDATA
c_func
(paren
id|scpnt-&gt;host
)paren
op_member_access_from_pointer
id|mb
(braket
id|i
)braket
dot
id|status
op_assign
id|MBX_NOT_IN_USE
suffix:semicolon
)brace
r_return
id|SCSI_RESET_SUCCESS
suffix:semicolon
macro_line|#else
r_return
id|SCSI_RESET_PENDING
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif
multiline_comment|/* No active command at this time, so this means that each time we got some&n;       kind of response the last time through.  Tell the mid-level code to&n;       request sense information in order to decide what to do next. */
r_return
id|SCSI_RESET_PUNT
suffix:semicolon
)brace
multiline_comment|/* ??? This is probably not correct for series &quot;C&quot; boards.  I believe these&n;   support separate mappings for each disk.  We would need to issue a&n;   CMD_READ_FW_LOCAL_RAM command to check for the particular drive being&n;   queried.  Note that series &quot;C&quot; boards can be differentiated by having&n;   HOSTDATA(disk-&gt;device-&gt;host)-&gt;firmware_rev[0] &gt;= &squot;4&squot;. */
DECL|function|buslogic_biosparam
r_int
id|buslogic_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
r_int
id|dev
comma
r_int
op_star
id|ip
)paren
(brace
r_int
r_int
id|size
op_assign
id|disk-&gt;capacity
suffix:semicolon
multiline_comment|/* ip[0] == heads, ip[1] == sectors, ip[2] == cylinders */
r_if
c_cond
(paren
id|HOSTDATA
c_func
(paren
id|disk-&gt;device-&gt;host
)paren
op_member_access_from_pointer
id|bios_translation
op_eq
id|BIOS_TRANSLATION_BIG
op_logical_and
id|size
op_ge
l_int|0x200000
)paren
(brace
multiline_comment|/* 1GB */
r_if
c_cond
(paren
id|size
op_ge
l_int|0x400000
)paren
(brace
multiline_comment|/* 2GB */
macro_line|#if 0&t;/* ??? Used in earlier kernels, but disagrees with BusLogic info. */
r_if
c_cond
(paren
id|mb
op_ge
l_int|0x800000
)paren
(brace
multiline_comment|/* 4GB */
id|ip
(braket
l_int|0
)braket
op_assign
l_int|256
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|64
suffix:semicolon
)brace
r_else
(brace
id|ip
(braket
l_int|0
)braket
op_assign
l_int|256
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|32
suffix:semicolon
)brace
macro_line|#else
id|ip
(braket
l_int|0
)braket
op_assign
l_int|256
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|64
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|ip
(braket
l_int|0
)braket
op_assign
l_int|128
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|32
suffix:semicolon
)brace
)brace
r_else
(brace
id|ip
(braket
l_int|0
)braket
op_assign
l_int|64
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|32
suffix:semicolon
)brace
id|ip
(braket
l_int|2
)braket
op_assign
id|size
op_div
(paren
id|ip
(braket
l_int|0
)braket
op_star
id|ip
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/*    if (ip[2] &gt; 1024)&n;&t;ip[2] = 1024; */
r_return
l_int|0
suffix:semicolon
)brace
eof
