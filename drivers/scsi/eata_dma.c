multiline_comment|/************************************************************&n; *&t;&t;&t;&t;&t;&t;&t;    *&n; *&t;&t;    Linux EATA SCSI driver&t;&t;    *&n; *&t;&t;&t;&t;&t;&t;&t;    *&n; *  based on the CAM document CAM/89-004 rev. 2.0c,&t;    *&n; *  DPT&squot;s driver kit, some internal documents and source,   *&n; *  and several other Linux scsi drivers and kernel docs.   *&n; *&t;&t;&t;&t;&t;&t;&t;    *&n; *  The driver currently:&t;&t;&t;&t;    *&n; *&t;-supports all ISA based EATA-DMA boards&t;&t;    *&n; *&t;-supports all EISA based EATA-DMA boards&t;    *&n; *&t;-supports all PCI based EATA-DMA boards&t;&t;    *&n; *&t;-supports multiple HBAs with &amp; without IRQ sharing  *&n; *&t;-supports all SCSI channels on multi channel boards *&n; *&t;-needs identical IDs on all channels of a HBA&t;    * &n; *&t;-can be loaded as module&t;&t;&t;    *&n; *&t;-displays statistical and hardware information&t;    *&n; *&t; in /proc/scsi/eata_dma&t;&t;&t;&t;    *&n; *      -provides rudimentary latency measurement           * &n; *       possibilities via /proc/scsi/eata_dma/&lt;hostnum&gt;    *&n; *&t;&t;&t;&t;&t;&t;&t;    *&n; *  (c)1993,94,95 Michael Neuffer&t;&t;&t;    *&n; *&t;&t;  neuffer@goofy.zdv.uni-mainz.de&t;    *&n; *&t;&t;&t;&t;&t;&t;&t;    *&n; *  This program is free software; you can redistribute it  *&n; *  and/or modify it under the terms of the GNU General&t;    *&n; *  Public License as published by the Free Software&t;    *&n; *  Foundation; either version 2 of the License, or&t;    *&n; *  (at your option) any later version.&t;&t;&t;    *&n; *&t;&t;&t;&t;&t;&t;&t;    *&n; *  This program is distributed in the hope that it will be *&n; *  useful, but WITHOUT ANY WARRANTY; without even the&t;    *&n; *  implied warranty of MERCHANTABILITY or FITNESS FOR A    *&n; *  PARTICULAR PURPOSE.&t; See the GNU General Public License *&n; *  for more details.&t;&t;&t;&t;&t;    *&n; *&t;&t;&t;&t;&t;&t;&t;    *&n; *  You should have received a copy of the GNU General&t;    *&n; *  Public License along with this kernel; if not, write to *&n; *  the Free Software Foundation, Inc., 675 Mass Ave,&t;    *&n; *  Cambridge, MA 02139, USA.&t;&t;&t;&t;    *&n; *&t;&t;&t;&t;&t;&t;&t;    *&n; * I have to thank DPT for their excellent support. I took  *&n; * me almost a year and a stopover at their HQ, on my first *&n; * trip to the USA, to get it, but since then they&squot;ve been  *&n; * very helpful and tried to give me all the infos and&t;    *&n; * support I need.&t;&t;&t;&t;&t;    *&n; *&t;&t;&t;&t;&t;&t;&t;    *&n; * Thanks also to Greg Hosler who did a lot of testing and  *&n; * found quite a number of bugs during the development.&t;    *&n; ************************************************************&n; *  last change: 95/09/17                 OS: Linux 1.3.28  *&n; ************************************************************/
multiline_comment|/* Look in eata_dma.h for configuration and revision information */
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/types.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &lt;linux/scsicam.h&gt;
macro_line|#include &quot;eata_dma.h&quot;
macro_line|#include &quot;eata_dma_proc.h&quot; 
macro_line|#include&lt;linux/stat.h&gt;
DECL|variable|proc_scsi_eata_dma
r_struct
id|proc_dir_entry
id|proc_scsi_eata_dma
op_assign
(brace
id|PROC_SCSI_EATA
comma
l_int|8
comma
l_string|&quot;eata_dma&quot;
comma
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
l_int|2
)brace
suffix:semicolon
DECL|variable|ISAbases
r_static
id|u32
id|ISAbases
(braket
)braket
op_assign
(brace
l_int|0x1F0
comma
l_int|0x170
comma
l_int|0x330
comma
l_int|0x230
)brace
suffix:semicolon
DECL|variable|EISAbases
r_static
id|unchar
id|EISAbases
(braket
)braket
op_assign
(brace
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)brace
suffix:semicolon
DECL|variable|registered_HBAs
r_static
id|uint
id|registered_HBAs
op_assign
l_int|0
suffix:semicolon
DECL|variable|last_HBA
r_static
r_struct
id|Scsi_Host
op_star
id|last_HBA
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|first_HBA
r_static
r_struct
id|Scsi_Host
op_star
id|first_HBA
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|reg_IRQ
r_static
id|unchar
id|reg_IRQ
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|reg_IRQL
r_static
id|unchar
id|reg_IRQL
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|status
r_static
r_struct
id|eata_sp
op_star
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Statuspacket array   */
DECL|variable|dma_scratch
r_static
r_void
op_star
id|dma_scratch
op_assign
l_int|0
suffix:semicolon
DECL|variable|fake_int_base
r_static
id|u32
id|fake_int_base
suffix:semicolon
DECL|variable|fake_int_result
r_static
r_int
id|fake_int_result
suffix:semicolon
DECL|variable|fake_int_happened
r_static
r_int
id|fake_int_happened
suffix:semicolon
DECL|variable|int_counter
r_static
id|ulong
id|int_counter
op_assign
l_int|0
suffix:semicolon
DECL|variable|queue_counter
r_static
id|ulong
id|queue_counter
op_assign
l_int|0
suffix:semicolon
DECL|function|eata_scsi_done
r_void
id|eata_scsi_done
(paren
id|Scsi_Cmnd
op_star
id|scmd
)paren
(brace
id|scmd-&gt;request.rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
r_if
c_cond
(paren
id|scmd-&gt;request.sem
op_ne
l_int|NULL
)paren
id|up
c_func
(paren
id|scmd-&gt;request.sem
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|eata_fake_int_handler
r_void
id|eata_fake_int_handler
c_func
(paren
id|s32
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|fake_int_result
op_assign
id|inb
c_func
(paren
id|fake_int_base
op_plus
id|HA_RSTATUS
)paren
suffix:semicolon
id|fake_int_happened
op_assign
id|TRUE
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_INTR3
comma
id|printk
c_func
(paren
l_string|&quot;eata_fake_int_handler called irq%d base %#x&quot;
l_string|&quot; res %#x&bslash;n&quot;
comma
id|irq
comma
id|fake_int_base
comma
id|fake_int_result
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#include &quot;eata_dma_proc.c&quot;
macro_line|#ifdef MODULE
DECL|function|eata_release
r_int
id|eata_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|sh
)paren
(brace
id|uint
id|i
suffix:semicolon
r_if
c_cond
(paren
id|sh-&gt;irq
op_logical_and
id|reg_IRQ
(braket
id|sh-&gt;irq
)braket
op_eq
l_int|1
)paren
id|free_irq
c_func
(paren
id|sh-&gt;irq
)paren
suffix:semicolon
r_else
id|reg_IRQ
(braket
id|sh-&gt;irq
)braket
op_decrement
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_void
op_star
)paren
id|status
comma
l_int|512
)paren
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_void
op_star
)paren
id|dma_scratch
comma
l_int|512
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sh-&gt;can_queue
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Free all SG arrays */
r_if
c_cond
(paren
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|ccb
(braket
id|i
)braket
dot
id|sg_list
op_ne
l_int|NULL
)paren
(brace
id|scsi_init_free
c_func
(paren
(paren
r_void
op_star
)paren
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|ccb
(braket
id|i
)braket
dot
id|sg_list
comma
id|sh-&gt;sg_tablesize
op_star
r_sizeof
(paren
r_struct
id|eata_sg_list
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|channel
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sh-&gt;dma_channel
op_ne
l_int|0xff
)paren
id|free_dma
c_func
(paren
id|sh-&gt;dma_channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh-&gt;io_port
op_logical_and
id|sh-&gt;n_io_port
)paren
id|release_region
c_func
(paren
id|sh-&gt;io_port
comma
id|sh-&gt;n_io_port
)paren
suffix:semicolon
)brace
r_return
id|TRUE
suffix:semicolon
)brace
macro_line|#endif
DECL|function|eata_int_handler
r_void
id|eata_int_handler
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|uint
id|i
comma
id|result
op_assign
l_int|0
suffix:semicolon
id|uint
id|hba_stat
comma
id|scsi_stat
comma
id|eata_stat
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_struct
id|eata_ccb
op_star
id|cp
suffix:semicolon
r_struct
id|eata_sp
op_star
id|sp
suffix:semicolon
id|uint
id|base
suffix:semicolon
id|ulong
id|flags
suffix:semicolon
id|uint
id|x
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|sh
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|1
comma
id|sh
op_assign
id|first_HBA
suffix:semicolon
id|x
op_le
id|registered_HBAs
suffix:semicolon
id|x
op_increment
comma
id|sh
op_assign
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|prev
)paren
(brace
r_if
c_cond
(paren
id|sh-&gt;irq
op_ne
id|irq
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
(paren
id|uint
)paren
id|sh-&gt;base
op_plus
id|HA_RAUXSTAT
)paren
op_amp
id|HA_AIRQ
)paren
)paren
r_continue
suffix:semicolon
id|int_counter
op_increment
suffix:semicolon
id|sp
op_assign
op_amp
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|sp
suffix:semicolon
id|cp
op_assign
id|sp-&gt;ccb
suffix:semicolon
multiline_comment|/* Has been passed thru, no conversion needed */
id|cmd
op_assign
id|cp-&gt;cmd
suffix:semicolon
id|base
op_assign
(paren
id|uint
)paren
id|cmd-&gt;host-&gt;base
suffix:semicolon
id|hba_stat
op_assign
id|sp-&gt;hba_stat
suffix:semicolon
id|scsi_stat
op_assign
(paren
id|sp-&gt;scsi_stat
op_rshift
l_int|1
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;EOC
op_eq
id|FALSE
)paren
(brace
id|eata_stat
op_assign
id|inb
c_func
(paren
id|base
op_plus
id|HA_RSTATUS
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;eata_dma: int_handler, board: %x cmd %lx returned &quot;
l_string|&quot;unfinished.&bslash;nEATA: %x HBA: %x SCSI: %x spadr %lx spadrirq &quot;
l_string|&quot;%lx, irq%d&bslash;n&quot;
comma
id|base
comma
(paren
r_int
)paren
id|cp
comma
id|eata_stat
comma
id|hba_stat
comma
id|scsi_stat
comma
(paren
r_int
)paren
op_amp
id|status
comma
(paren
r_int
)paren
op_amp
id|status
(braket
id|irq
)braket
comma
id|irq
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_DELAY
comma
id|DEL2
c_func
(paren
l_int|800
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cp-&gt;status
op_eq
id|LOCKED
)paren
(brace
id|cp-&gt;status
op_assign
id|FREE
suffix:semicolon
id|eata_stat
op_assign
id|inb
c_func
(paren
id|base
op_plus
id|HA_RSTATUS
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;eata_dma: int_handler, freeing locked queueslot&bslash;n&quot;
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_INTR
op_logical_and
id|DBG_DELAY
comma
id|DEL2
c_func
(paren
l_int|800
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|eata_stat
op_assign
id|inb
c_func
(paren
id|base
op_plus
id|HA_RSTATUS
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_INTR
comma
id|printk
c_func
(paren
l_string|&quot;IRQ %d received, base %#.4x, pid %ld, target: &quot;
l_string|&quot;%x, lun: %x, ea_s: %#.2x, hba_s: %#.2x &bslash;n&quot;
comma
id|irq
comma
id|base
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|eata_stat
comma
id|hba_stat
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hba_stat
)paren
(brace
r_case
id|HA_NO_ERROR
suffix:colon
multiline_comment|/* NO Error */
r_if
c_cond
(paren
id|scsi_stat
op_eq
id|CONDITION_GOOD
op_logical_and
id|cmd-&gt;device-&gt;type
op_eq
id|TYPE_DISK
op_logical_and
(paren
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|t_state
(braket
id|cp-&gt;cp_channel
)braket
(braket
id|cp-&gt;cp_id
)braket
op_eq
id|RESET
)paren
)paren
id|result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
r_else
r_if
c_cond
(paren
id|scsi_stat
op_eq
id|GOOD
)paren
(brace
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|t_state
(braket
id|cp-&gt;cp_channel
)braket
(braket
id|cp-&gt;cp_id
)braket
op_assign
id|OK
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|do_latency
op_eq
id|TRUE
op_logical_and
id|cp-&gt;timestamp
)paren
(brace
id|uint
id|time
suffix:semicolon
id|time
op_assign
id|jiffies
op_minus
id|cp-&gt;timestamp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cp-&gt;rw_latency
)paren
op_eq
id|TRUE
)paren
(brace
multiline_comment|/* was WRITE */
r_if
c_cond
(paren
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|writes_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|1
)braket
OG
id|time
)paren
(brace
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|writes_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|1
)braket
op_assign
id|time
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|writes_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|2
)braket
OL
id|time
)paren
(brace
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|writes_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|2
)braket
op_assign
id|time
suffix:semicolon
)brace
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|writes_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|3
)braket
op_add_assign
id|time
suffix:semicolon
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|writes_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|0
)braket
op_increment
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|reads_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|1
)braket
OG
id|time
)paren
(brace
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|reads_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|1
)braket
op_assign
id|time
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|reads_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|2
)braket
OL
id|time
)paren
(brace
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|reads_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|2
)braket
op_assign
id|time
suffix:semicolon
)brace
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|reads_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|3
)braket
op_add_assign
id|time
suffix:semicolon
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|reads_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|0
)braket
op_increment
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|scsi_stat
op_eq
id|CHECK_CONDITION
op_logical_and
id|cmd-&gt;device-&gt;type
op_eq
id|TYPE_DISK
op_logical_and
(paren
id|cmd-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
id|RECOVERED_ERROR
)paren
id|result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
r_else
id|result
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|t_timeout
(braket
id|cp-&gt;cp_channel
)braket
(braket
id|cp-&gt;cp_id
)braket
op_assign
id|OK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HA_ERR_SEL_TO
suffix:colon
multiline_comment|/* Selection Timeout */
id|result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HA_ERR_CMD_TO
suffix:colon
multiline_comment|/* Command Timeout   */
r_if
c_cond
(paren
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|t_timeout
(braket
id|cp-&gt;cp_channel
)braket
(braket
id|cp-&gt;cp_id
)braket
OG
l_int|1
)paren
id|result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_else
(brace
id|result
op_assign
id|DID_TIME_OUT
op_lshift
l_int|16
suffix:semicolon
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|t_timeout
(braket
id|cp-&gt;cp_channel
)braket
(braket
id|cp-&gt;cp_id
)braket
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|HA_ERR_RESET
suffix:colon
multiline_comment|/* SCSI Bus Reset Received */
r_case
id|HA_INIT_POWERUP
suffix:colon
multiline_comment|/* Initial Controller Power-up */
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;type
op_ne
id|TYPE_TAPE
)paren
id|result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
r_else
id|result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAXTARGET
suffix:semicolon
id|i
op_increment
)paren
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|t_state
(braket
id|cp-&gt;cp_channel
)braket
(braket
id|i
)braket
op_assign
id|RESET
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HA_UNX_BUSPHASE
suffix:colon
multiline_comment|/* Unexpected Bus Phase */
r_case
id|HA_UNX_BUS_FREE
suffix:colon
multiline_comment|/* Unexpected Bus Free */
r_case
id|HA_BUS_PARITY
suffix:colon
multiline_comment|/* Bus Parity Error */
r_case
id|HA_SCSI_HUNG
suffix:colon
multiline_comment|/* SCSI Hung */
r_case
id|HA_UNX_MSGRJCT
suffix:colon
multiline_comment|/* Unexpected Message Reject */
r_case
id|HA_RESET_STUCK
suffix:colon
multiline_comment|/* SCSI Bus Reset Stuck */
r_case
id|HA_RSENSE_FAIL
suffix:colon
multiline_comment|/* Auto Request-Sense Failed */
r_case
id|HA_PARITY_ERR
suffix:colon
multiline_comment|/* Controller Ram Parity */
r_default
suffix:colon
id|result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cmd-&gt;result
op_assign
id|result
op_or
(paren
id|scsi_stat
op_lshift
l_int|1
)paren
suffix:semicolon
macro_line|#if DBG_INTR2
r_if
c_cond
(paren
id|scsi_stat
op_logical_or
id|result
op_logical_or
id|hba_stat
op_logical_or
id|eata_stat
op_ne
l_int|0x50
op_logical_or
id|cmd-&gt;scsi_done
op_eq
l_int|NULL
op_logical_or
id|cmd-&gt;device-&gt;id
op_eq
l_int|7
)paren
id|printk
c_func
(paren
l_string|&quot;HBA: %d, channel %d, id: %d, lun %d, pid %ld:&bslash;n&quot;
l_string|&quot;eata_stat %#x, hba_stat %#.2x, scsi_stat %#.2x, &quot;
l_string|&quot;sense_key: %#x, result: %#.8x&bslash;n&quot;
comma
id|x
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
comma
id|cmd-&gt;pid
comma
id|eata_stat
comma
id|hba_stat
comma
id|scsi_stat
comma
id|cmd-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
comma
id|cmd-&gt;result
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_INTR
op_logical_and
id|DBG_DELAY
comma
id|DEL2
c_func
(paren
l_int|800
)paren
)paren
suffix:semicolon
macro_line|#endif
id|cp-&gt;status
op_assign
id|FREE
suffix:semicolon
multiline_comment|/* now we can release the slot  */
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|eata_send_command
r_inline
r_int
id|eata_send_command
c_func
(paren
id|u32
id|addr
comma
id|u32
id|base
comma
id|u8
id|command
)paren
(brace
r_int
id|loop
op_assign
id|R_LIMIT
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|base
op_plus
id|HA_RAUXSTAT
)paren
op_amp
id|HA_ABUSY
)paren
r_if
c_cond
(paren
op_decrement
id|loop
op_eq
l_int|0
)paren
r_return
id|FALSE
suffix:semicolon
multiline_comment|/* And now the address in nice little byte chunks */
id|outb
c_func
(paren
id|addr
op_amp
l_int|0x000000ff
comma
id|base
op_plus
id|HA_WDMAADDR
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|addr
op_amp
l_int|0x0000ff00
)paren
op_rshift
l_int|8
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|addr
op_amp
l_int|0x00ff0000
)paren
op_rshift
l_int|16
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|addr
op_amp
l_int|0xff000000
)paren
op_rshift
l_int|24
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|3
)paren
suffix:semicolon
id|outb
c_func
(paren
id|command
comma
id|base
op_plus
id|HA_WCOMMAND
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
macro_line|#if 0 
r_inline
r_int
id|eata_send_immediate
c_func
(paren
id|u32
id|addr
comma
id|u32
id|base
comma
id|u8
id|cmnd
comma
id|u8
id|cmnd2
comma
id|u8
id|id
comma
id|u8
id|lun
)paren
(brace
r_if
c_cond
(paren
id|addr
)paren
(brace
id|outb
c_func
(paren
id|addr
op_amp
l_int|0x000000ff
comma
id|base
op_plus
id|HA_WDMAADDR
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|addr
op_amp
l_int|0x0000ff00
)paren
op_rshift
l_int|8
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|addr
op_amp
l_int|0x00ff0000
)paren
op_rshift
l_int|16
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|addr
op_amp
l_int|0xff000000
)paren
op_rshift
l_int|24
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|3
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
id|id
comma
id|base
op_plus
id|HA_WSUBCODE
)paren
suffix:semicolon
id|outb
c_func
(paren
id|lun
comma
id|base
op_plus
id|HA_WSUBLUN
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|cmnd2
comma
id|base
op_plus
id|HA_WCOMMAND2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|cmnd
comma
id|base
op_plus
id|HA_WCOMMAND
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
macro_line|#endif
DECL|function|eata_queue
r_int
id|eata_queue
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
r_int
id|i
comma
id|x
comma
id|y
suffix:semicolon
id|u32
id|flags
suffix:semicolon
id|hostdata
op_star
id|hd
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|sh
suffix:semicolon
r_struct
id|eata_ccb
op_star
id|cp
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sl
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|queue_counter
op_increment
suffix:semicolon
id|hd
op_assign
id|HD
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|sh
op_assign
id|cmd-&gt;host
suffix:semicolon
multiline_comment|/* check for free slot */
r_for
c_loop
(paren
id|y
op_assign
id|hd-&gt;last_ccb
op_plus
l_int|1
comma
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|sh-&gt;can_queue
suffix:semicolon
id|x
op_increment
comma
id|y
op_increment
)paren
(brace
r_if
c_cond
(paren
id|y
op_ge
id|sh-&gt;can_queue
)paren
id|y
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;ccb
(braket
id|y
)braket
dot
id|status
op_eq
id|FREE
)paren
r_break
suffix:semicolon
)brace
id|hd-&gt;last_ccb
op_assign
id|y
suffix:semicolon
r_if
c_cond
(paren
id|x
op_ge
id|sh-&gt;can_queue
)paren
(brace
id|uint
id|z
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;eata_dma: run out of queue slots cmdno:%ld&quot;
l_string|&quot; intrno: %ld, can_queue: %d, x: %d, y: %d&bslash;n&quot;
comma
id|queue_counter
comma
id|int_counter
comma
id|sh-&gt;can_queue
comma
id|x
comma
id|y
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;List of free queueslots:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|z
op_assign
l_int|0
suffix:semicolon
id|z
OL
id|sh-&gt;can_queue
suffix:semicolon
id|z
op_add_assign
l_int|2
)paren
(brace
r_switch
c_cond
(paren
id|hd-&gt;ccb
(braket
id|z
)braket
dot
id|status
)paren
(brace
r_case
id|FREE
suffix:colon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;Slot %2d is FREE  &bslash;t&quot;
comma
id|z
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USED
suffix:colon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;Slot %2d is USED  &bslash;t&quot;
comma
id|z
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LOCKED
suffix:colon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;Slot %2d is LOCKED&bslash;t&quot;
comma
id|z
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;Slot %2d is UNKNOWN&bslash;t&quot;
comma
id|z
)paren
suffix:semicolon
)brace
id|panic
c_func
(paren
l_string|&quot;&bslash;nSystem halted.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|cp
op_assign
op_amp
id|hd-&gt;ccb
(braket
id|y
)braket
suffix:semicolon
id|memset
c_func
(paren
id|cp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|eata_ccb
)paren
op_minus
r_sizeof
(paren
r_struct
id|eata_sg_list
op_star
)paren
)paren
suffix:semicolon
id|cp-&gt;status
op_assign
id|USED
suffix:semicolon
multiline_comment|/* claim free slot */
id|DBG
c_func
(paren
id|DBG_QUEUE
comma
id|printk
c_func
(paren
l_string|&quot;eata_queue pid %ld, target: %x, lun: %x, y %d&bslash;n&quot;
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|y
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_QUEUE
op_logical_and
id|DBG_DELAY
comma
id|DEL2
c_func
(paren
l_int|250
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;do_latency
op_eq
id|TRUE
)paren
(brace
r_int
id|x
comma
id|z
suffix:semicolon
r_int
op_star
id|sho
suffix:semicolon
r_int
op_star
id|lon
suffix:semicolon
id|x
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* just to keep GCC quiet */
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_6
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_10
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_12
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_6
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_10
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_12
)paren
(brace
id|cp-&gt;timestamp
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* For latency measurements */
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|WRITE_6
suffix:colon
r_case
id|READ_6
suffix:colon
id|x
op_assign
id|cmd-&gt;cmnd
(braket
l_int|4
)braket
op_div
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WRITE_10
suffix:colon
r_case
id|READ_10
suffix:colon
id|sho
op_assign
(paren
r_int
op_star
)paren
op_amp
id|cmd-&gt;cmnd
(braket
l_int|7
)braket
suffix:semicolon
id|x
op_assign
id|ntohs
c_func
(paren
op_star
id|sho
)paren
op_div
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WRITE_12
suffix:colon
r_case
id|READ_12
suffix:colon
id|lon
op_assign
(paren
r_int
op_star
)paren
op_amp
id|cmd-&gt;cmnd
(braket
l_int|6
)braket
suffix:semicolon
id|x
op_assign
id|ntohl
c_func
(paren
op_star
id|lon
)paren
op_div
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|z
op_assign
l_int|0
suffix:semicolon
(paren
id|x
OG
(paren
l_int|1
op_lshift
id|z
)paren
)paren
op_logical_and
(paren
id|z
op_le
l_int|11
)paren
suffix:semicolon
id|z
op_increment
)paren
(brace
multiline_comment|/* nothing */
suffix:semicolon
)brace
id|cp-&gt;sizeindex
op_assign
id|z
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_6
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_10
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_12
)paren
(brace
id|cp-&gt;rw_latency
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
)brace
id|cmd-&gt;scsi_done
op_assign
(paren
r_void
op_star
)paren
id|done
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|CHANGE_DEFINITION
suffix:colon
r_case
id|COMPARE
suffix:colon
r_case
id|COPY
suffix:colon
r_case
id|COPY_VERIFY
suffix:colon
r_case
id|LOG_SELECT
suffix:colon
r_case
id|MODE_SELECT
suffix:colon
r_case
id|MODE_SELECT_10
suffix:colon
r_case
id|SEND_DIAGNOSTIC
suffix:colon
r_case
id|WRITE_BUFFER
suffix:colon
r_case
id|FORMAT_UNIT
suffix:colon
r_case
id|REASSIGN_BLOCKS
suffix:colon
r_case
id|RESERVE
suffix:colon
r_case
id|SEARCH_EQUAL
suffix:colon
r_case
id|SEARCH_HIGH
suffix:colon
r_case
id|SEARCH_LOW
suffix:colon
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
r_case
id|WRITE_VERIFY
suffix:colon
r_case
id|UPDATE_BLOCK
suffix:colon
r_case
id|WRITE_LONG
suffix:colon
r_case
id|WRITE_SAME
suffix:colon
r_case
id|SEARCH_HIGH_12
suffix:colon
r_case
id|SEARCH_EQUAL_12
suffix:colon
r_case
id|SEARCH_LOW_12
suffix:colon
r_case
id|WRITE_12
suffix:colon
r_case
id|WRITE_VERIFY_12
suffix:colon
r_case
id|SET_WINDOW
suffix:colon
r_case
id|MEDIUM_SCAN
suffix:colon
r_case
id|SEND_VOLUME_TAG
suffix:colon
r_case
l_int|0xea
suffix:colon
multiline_comment|/* alternate number for WRITE LONG */
id|cp-&gt;DataOut
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Output mode */
r_break
suffix:semicolon
r_case
id|TEST_UNIT_READY
suffix:colon
r_default
suffix:colon
id|cp-&gt;DataIn
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Input mode  */
)brace
multiline_comment|/* FIXME: This will will have to be changed once the midlevel driver &n;     *        allows different HBA IDs on every channel.&n;     */
r_if
c_cond
(paren
id|cmd-&gt;target
op_eq
id|sh-&gt;this_id
)paren
id|cp-&gt;Interpret
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Interpret command */
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
id|cp-&gt;scatter
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* SG mode     */
r_if
c_cond
(paren
id|cp-&gt;sg_list
op_eq
l_int|NULL
)paren
(brace
id|cp-&gt;sg_list
op_assign
id|kmalloc
c_func
(paren
id|SG_SIZE_BIG
op_star
r_sizeof
(paren
r_struct
id|eata_sg_list
)paren
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cp-&gt;sg_list
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;eata_dma: Run out of DMA memory for SG lists !&bslash;n&quot;
)paren
suffix:semicolon
id|cp-&gt;cp_dataDMA
op_assign
id|htonl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|cp-&gt;sg_list
)paren
)paren
suffix:semicolon
id|cp-&gt;cp_datalen
op_assign
id|htonl
c_func
(paren
id|cmd-&gt;use_sg
op_star
r_sizeof
(paren
r_struct
id|eata_sg_list
)paren
)paren
suffix:semicolon
id|sl
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cmd-&gt;use_sg
suffix:semicolon
id|i
op_increment
comma
id|sl
op_increment
)paren
(brace
id|cp-&gt;sg_list
(braket
id|i
)braket
dot
id|data
op_assign
id|htonl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|sl-&gt;address
)paren
)paren
suffix:semicolon
id|cp-&gt;sg_list
(braket
id|i
)braket
dot
id|len
op_assign
id|htonl
c_func
(paren
(paren
id|u32
)paren
id|sl-&gt;length
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|cp-&gt;scatter
op_assign
id|FALSE
suffix:semicolon
id|cp-&gt;cp_datalen
op_assign
id|htonl
c_func
(paren
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
id|cp-&gt;cp_dataDMA
op_assign
id|htonl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|cmd-&gt;request_buffer
)paren
)paren
suffix:semicolon
)brace
id|cp-&gt;Auto_Req_Sen
op_assign
id|TRUE
suffix:semicolon
id|cp-&gt;cp_reqDMA
op_assign
id|htonl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|cmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|cp-&gt;reqlen
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
id|cp-&gt;cp_id
op_assign
id|cmd-&gt;target
suffix:semicolon
id|cp-&gt;cp_channel
op_assign
id|cmd-&gt;channel
suffix:semicolon
id|cp-&gt;cp_lun
op_assign
id|cmd-&gt;lun
suffix:semicolon
id|cp-&gt;cp_dispri
op_assign
id|TRUE
suffix:semicolon
id|cp-&gt;cp_identify
op_assign
id|TRUE
suffix:semicolon
id|memcpy
c_func
(paren
id|cp-&gt;cp_cdb
comma
id|cmd-&gt;cmnd
comma
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
id|cp-&gt;cp_statDMA
op_assign
id|htonl
c_func
(paren
id|virt_to_bus
c_func
(paren
op_amp
(paren
id|hd-&gt;sp
)paren
)paren
)paren
suffix:semicolon
id|cp-&gt;cp_viraddr
op_assign
id|cp
suffix:semicolon
multiline_comment|/* This will be passed thru, so we don&squot;t need to convert it */
id|cp-&gt;cmd
op_assign
id|cmd
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
(paren
r_char
op_star
)paren
op_amp
id|hd-&gt;ccb
(braket
id|y
)braket
suffix:semicolon
r_if
c_cond
(paren
id|eata_send_command
c_func
(paren
(paren
id|u32
)paren
id|cp
comma
(paren
id|u32
)paren
id|sh-&gt;base
comma
id|EATA_CMD_DMA_SEND_CP
)paren
op_eq
id|FALSE
)paren
(brace
id|cmd-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;eata_queue target %d, pid %ld, HBA busy, returning DID_BUS_BUSY&bslash;n&quot;
comma
id|cmd-&gt;target
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|cp-&gt;status
op_assign
id|FREE
suffix:semicolon
multiline_comment|/* Hmmm..... */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DBG
c_func
(paren
id|DBG_QUEUE
comma
id|printk
c_func
(paren
l_string|&quot;Queued base %#.4x pid: %ld target: %x lun: %x &quot;
l_string|&quot;slot %d irq %d&bslash;n&quot;
comma
(paren
id|s32
)paren
id|sh-&gt;base
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|y
comma
id|sh-&gt;irq
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_QUEUE
op_logical_and
id|DBG_DELAY
comma
id|DEL2
c_func
(paren
l_int|200
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|eata_abort
r_int
id|eata_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|ulong
id|flags
suffix:semicolon
id|ulong
id|loop
op_assign
id|R_LIMIT
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;eata_abort called pid: %ld target: %x lun: %x&quot;
l_string|&quot; reason %x&bslash;n&quot;
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|cmd-&gt;abort_reason
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DEL2
c_func
(paren
l_int|500
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
(paren
id|u32
)paren
(paren
id|cmd-&gt;host-&gt;base
)paren
op_plus
id|HA_RAUXSTAT
)paren
op_amp
id|HA_ABUSY
)paren
r_if
c_cond
(paren
op_decrement
id|loop
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eata_dma: abort, timeout error.&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DEL2
c_func
(paren
l_int|500
)paren
)paren
suffix:semicolon
r_return
(paren
id|SCSI_ABORT_ERROR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|status
op_eq
id|USED
)paren
(brace
id|DBG
c_func
(paren
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;Returning: SCSI_ABORT_BUSY&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
id|SCSI_ABORT_BUSY
)paren
suffix:semicolon
multiline_comment|/* SNOOZE */
)brace
r_if
c_cond
(paren
id|CD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|status
op_eq
id|FREE
)paren
(brace
id|DBG
c_func
(paren
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;Returning: SCSI_ABORT_NOT_RUNNING&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
id|SCSI_ABORT_NOT_RUNNING
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|status
op_eq
id|RESET
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;eata_dma: abort, command reset error.&bslash;n&quot;
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DEL2
c_func
(paren
l_int|500
)paren
)paren
suffix:semicolon
r_return
(paren
id|SCSI_ABORT_ERROR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|status
op_eq
id|LOCKED
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;eata_dma: abort, queue slot locked.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DEL2
c_func
(paren
l_int|500
)paren
)paren
suffix:semicolon
r_return
(paren
id|SCSI_ABORT_NOT_RUNNING
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;eata_dma: abort: invalid slot status&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|eata_reset
r_int
id|eata_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|ushort
id|x
comma
id|z
suffix:semicolon
id|ulong
id|time
comma
id|limit
op_assign
l_int|0
suffix:semicolon
id|ulong
id|loop
op_assign
id|R_LIMIT
suffix:semicolon
id|ulong
id|flags
suffix:semicolon
id|unchar
id|success
op_assign
id|FALSE
suffix:semicolon
id|Scsi_Cmnd
op_star
id|sp
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;eata_reset called pid:%ld target: %x lun: %x&quot;
l_string|&quot; reason %x&bslash;n&quot;
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|cmd-&gt;abort_reason
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|state
op_eq
id|RESET
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eata_reset: exit, already in reset.&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DEL2
c_func
(paren
l_int|500
)paren
)paren
suffix:semicolon
r_return
(paren
id|SCSI_RESET_ERROR
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|inb
c_func
(paren
(paren
id|u32
)paren
(paren
id|cmd-&gt;host-&gt;base
)paren
op_plus
id|HA_RAUXSTAT
)paren
op_amp
id|HA_ABUSY
)paren
r_if
c_cond
(paren
op_decrement
id|loop
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eata_reset: exit, timeout error.&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DEL2
c_func
(paren
l_int|500
)paren
)paren
suffix:semicolon
r_return
(paren
id|SCSI_RESET_ERROR
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|MAXCHANNEL
suffix:semicolon
id|x
op_increment
)paren
(brace
r_for
c_loop
(paren
id|z
op_assign
l_int|0
suffix:semicolon
id|z
OL
id|MAXTARGET
suffix:semicolon
id|z
op_increment
)paren
(brace
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|t_state
(braket
id|x
)braket
(braket
id|z
)braket
op_assign
id|RESET
suffix:semicolon
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|t_timeout
(braket
id|x
)braket
(braket
id|z
)braket
op_assign
id|NO_TIMEOUT
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|cmd-&gt;host-&gt;can_queue
suffix:semicolon
id|x
op_increment
)paren
(brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|ccb
(braket
id|x
)braket
dot
id|status
op_eq
id|FREE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|ccb
(braket
id|x
)braket
dot
id|status
op_eq
id|LOCKED
)paren
(brace
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|ccb
(braket
id|x
)braket
dot
id|status
op_assign
id|FREE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;eata_reset: locked slot %d forced free.&bslash;n&quot;
comma
id|x
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DEL2
c_func
(paren
l_int|500
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|sp
op_assign
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|ccb
(braket
id|x
)braket
dot
id|cmd
suffix:semicolon
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|ccb
(braket
id|x
)braket
dot
id|status
op_assign
id|RESET
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;eata_reset: slot %d in reset, pid %ld.&bslash;n&quot;
comma
id|x
comma
id|sp-&gt;pid
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DEL2
c_func
(paren
l_int|500
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sp
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;eata_reset: slot %d, sp==NULL.&bslash;n&quot;
comma
id|x
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DEL2
c_func
(paren
l_int|500
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sp
op_eq
id|cmd
)paren
id|success
op_assign
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* hard reset the HBA  */
id|inb
c_func
(paren
(paren
id|u32
)paren
(paren
id|cmd-&gt;host-&gt;base
)paren
op_plus
id|HA_RSTATUS
)paren
suffix:semicolon
multiline_comment|/* This might cause trouble */
id|eata_send_command
c_func
(paren
l_int|0
comma
(paren
id|u32
)paren
id|cmd-&gt;host-&gt;base
comma
id|EATA_CMD_RESET
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;eata_reset: board reset done, enabling interrupts.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|state
op_assign
id|RESET
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|time
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
(paren
id|time
op_plus
(paren
l_int|3
op_star
id|HZ
)paren
)paren
op_logical_or
id|limit
op_increment
OL
l_int|10000000
)paren
multiline_comment|/* As time goes by... */
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;eata_reset: interrupts disabled, loops %ld.&bslash;n&quot;
comma
id|limit
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DEL2
c_func
(paren
l_int|500
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|cmd-&gt;host-&gt;can_queue
suffix:semicolon
id|x
op_increment
)paren
(brace
multiline_comment|/* Skip slots already set free by interrupt */
r_if
c_cond
(paren
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|ccb
(braket
id|x
)braket
dot
id|status
op_ne
id|RESET
)paren
r_continue
suffix:semicolon
id|sp
op_assign
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|ccb
(braket
id|x
)braket
dot
id|cmd
suffix:semicolon
id|sp-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* This mailbox is still waiting for its interrupt */
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|ccb
(braket
id|x
)braket
dot
id|status
op_assign
id|LOCKED
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;eata_reset: slot %d locked, DID_RESET, pid %ld done.&bslash;n&quot;
comma
id|x
comma
id|sp-&gt;pid
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DEL2
c_func
(paren
l_int|500
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|sp
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|state
op_assign
id|FALSE
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|success
)paren
(brace
id|DBG
c_func
(paren
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;eata_reset: exit, success.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DEL2
c_func
(paren
l_int|500
)paren
)paren
suffix:semicolon
r_return
(paren
id|SCSI_RESET_SUCCESS
)paren
suffix:semicolon
)brace
r_else
(brace
id|DBG
c_func
(paren
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;eata_reset: exit, wakeup.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DEL2
c_func
(paren
l_int|500
)paren
)paren
suffix:semicolon
r_return
(paren
id|SCSI_RESET_PUNT
)paren
suffix:semicolon
)brace
)brace
DECL|function|get_board_data
r_char
op_star
id|get_board_data
c_func
(paren
id|u32
id|base
comma
id|u32
id|irq
comma
id|u32
id|id
)paren
(brace
r_struct
id|eata_ccb
op_star
id|cp
suffix:semicolon
r_struct
id|eata_sp
op_star
id|sp
suffix:semicolon
r_static
r_char
op_star
id|buff
suffix:semicolon
id|ulong
id|i
suffix:semicolon
id|ulong
id|limit
op_assign
l_int|0
suffix:semicolon
id|cp
op_assign
(paren
r_struct
id|eata_ccb
op_star
)paren
id|scsi_init_malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|eata_ccb
)paren
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
id|sp
op_assign
(paren
r_struct
id|eata_sp
op_star
)paren
id|scsi_init_malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|eata_sp
)paren
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
id|buff
op_assign
id|dma_scratch
suffix:semicolon
id|memset
c_func
(paren
id|cp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|eata_ccb
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|sp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|eata_sp
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|buff
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
id|cp-&gt;DataIn
op_assign
id|TRUE
suffix:semicolon
id|cp-&gt;Interpret
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Interpret command */
id|cp-&gt;cp_dispri
op_assign
id|TRUE
suffix:semicolon
id|cp-&gt;cp_identify
op_assign
id|TRUE
suffix:semicolon
id|cp-&gt;cp_datalen
op_assign
id|htonl
c_func
(paren
l_int|56
)paren
suffix:semicolon
id|cp-&gt;cp_dataDMA
op_assign
id|htonl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|buff
)paren
)paren
suffix:semicolon
id|cp-&gt;cp_statDMA
op_assign
id|htonl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|sp
)paren
)paren
suffix:semicolon
id|cp-&gt;cp_viraddr
op_assign
id|cp
suffix:semicolon
id|cp-&gt;cp_id
op_assign
id|id
suffix:semicolon
id|cp-&gt;cp_lun
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;cp_cdb
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|cp-&gt;cp_cdb
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;cp_cdb
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;cp_cdb
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;cp_cdb
(braket
l_int|4
)braket
op_assign
l_int|56
suffix:semicolon
id|cp-&gt;cp_cdb
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|fake_int_base
op_assign
id|base
suffix:semicolon
id|fake_int_result
op_assign
id|FALSE
suffix:semicolon
id|fake_int_happened
op_assign
id|FALSE
suffix:semicolon
id|eata_send_command
c_func
(paren
(paren
id|u32
)paren
id|cp
comma
(paren
id|u32
)paren
id|base
comma
id|EATA_CMD_DMA_SEND_CP
)paren
suffix:semicolon
id|i
op_assign
id|jiffies
op_plus
(paren
l_int|3
op_star
id|HZ
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fake_int_happened
op_eq
id|FALSE
op_logical_and
id|jiffies
op_le
id|i
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_INTR3
comma
id|printk
c_func
(paren
l_string|&quot;fake_int_result: %#x hbastat %#x scsistat %#x,&quot;
l_string|&quot; buff %p sp %p&bslash;n&quot;
comma
id|fake_int_result
comma
(paren
id|u32
)paren
(paren
id|sp-&gt;hba_stat
multiline_comment|/*&amp; 0x7f*/
)paren
comma
(paren
id|u32
)paren
id|sp-&gt;scsi_stat
comma
id|buff
comma
id|sp
)paren
)paren
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_void
op_star
)paren
id|cp
comma
r_sizeof
(paren
r_struct
id|eata_ccb
)paren
)paren
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_void
op_star
)paren
id|sp
comma
r_sizeof
(paren
r_struct
id|eata_sp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fake_int_result
op_amp
id|HA_SERROR
)paren
op_logical_or
id|jiffies
OG
id|i
)paren
(brace
multiline_comment|/* hard reset the HBA  */
id|inb
c_func
(paren
(paren
id|u32
)paren
(paren
id|base
)paren
op_plus
id|HA_RSTATUS
)paren
suffix:semicolon
id|eata_send_command
c_func
(paren
l_int|0
comma
id|base
comma
id|EATA_CMD_RESET
)paren
suffix:semicolon
id|i
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
(paren
id|i
op_plus
(paren
l_int|3
op_star
id|HZ
)paren
)paren
op_logical_and
id|limit
op_increment
OL
l_int|10000000
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
r_return
(paren
id|buff
)paren
suffix:semicolon
)brace
DECL|function|check_blink_state
r_int
id|check_blink_state
c_func
(paren
r_int
id|base
)paren
(brace
id|ushort
id|loops
op_assign
l_int|10
suffix:semicolon
id|u32
id|blinkindicator
suffix:semicolon
id|u32
id|state
op_assign
l_int|0x12345678
suffix:semicolon
id|u32
id|oldstate
op_assign
l_int|0
suffix:semicolon
id|blinkindicator
op_assign
id|htonl
c_func
(paren
l_int|0x54504442
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|loops
op_decrement
)paren
op_logical_and
(paren
id|state
op_ne
id|oldstate
)paren
)paren
(brace
id|oldstate
op_assign
id|state
suffix:semicolon
id|state
op_assign
id|inl
c_func
(paren
(paren
id|uint
)paren
id|base
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|DBG
c_func
(paren
id|DBG_BLINK
comma
id|printk
c_func
(paren
l_string|&quot;Did Blink check. Status: %d&bslash;n&quot;
comma
(paren
id|state
op_eq
id|oldstate
)paren
op_logical_and
(paren
id|state
op_eq
id|blinkindicator
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|state
op_eq
id|oldstate
)paren
op_logical_and
(paren
id|state
op_eq
id|blinkindicator
)paren
)paren
r_return
id|TRUE
suffix:semicolon
r_else
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
DECL|function|get_conf_PIO
r_int
id|get_conf_PIO
c_func
(paren
id|u32
id|base
comma
r_struct
id|get_conf
op_star
id|buf
)paren
(brace
id|ulong
id|loop
op_assign
id|R_LIMIT
suffix:semicolon
id|u16
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|base
comma
l_int|9
)paren
)paren
(brace
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|get_conf
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|base
op_plus
id|HA_RSTATUS
)paren
op_amp
id|HA_SBUSY
)paren
r_if
c_cond
(paren
op_decrement
id|loop
op_eq
l_int|0
)paren
r_return
(paren
id|FALSE
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_PIO
op_logical_and
id|DBG_PROBE
comma
id|printk
c_func
(paren
l_string|&quot;Issuing PIO READ CONFIG to HBA at %#x&bslash;n&quot;
comma
id|base
)paren
)paren
suffix:semicolon
id|eata_send_command
c_func
(paren
l_int|0
comma
id|base
comma
id|EATA_CMD_PIO_READ_CONFIG
)paren
suffix:semicolon
id|loop
op_assign
id|R_LIMIT
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
(paren
id|u16
op_star
)paren
id|buf
suffix:semicolon
(paren
r_int
)paren
id|p
op_le
(paren
(paren
r_int
)paren
id|buf
op_plus
(paren
r_sizeof
(paren
r_struct
id|get_conf
)paren
op_div
l_int|2
)paren
)paren
suffix:semicolon
id|p
op_increment
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|base
op_plus
id|HA_RSTATUS
)paren
op_amp
id|HA_SDRQ
)paren
)paren
r_if
c_cond
(paren
op_decrement
id|loop
op_eq
l_int|0
)paren
r_return
(paren
id|FALSE
)paren
suffix:semicolon
id|loop
op_assign
id|R_LIMIT
suffix:semicolon
op_star
id|p
op_assign
id|inw
c_func
(paren
id|base
op_plus
id|HA_RDATA
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|base
op_plus
id|HA_RSTATUS
)paren
op_amp
id|HA_SERROR
)paren
)paren
(brace
multiline_comment|/* Error ? */
r_if
c_cond
(paren
id|htonl
c_func
(paren
id|EATA_SIGNATURE
)paren
op_eq
id|buf-&gt;signature
)paren
(brace
id|DBG
c_func
(paren
id|DBG_PIO
op_logical_and
id|DBG_PROBE
comma
id|printk
c_func
(paren
l_string|&quot;EATA Controller found at %x &quot;
l_string|&quot;EATA Level: %x&bslash;n&quot;
comma
(paren
id|uint
)paren
id|base
comma
(paren
id|uint
)paren
(paren
id|buf-&gt;version
)paren
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|base
op_plus
id|HA_RSTATUS
)paren
op_amp
id|HA_SDRQ
)paren
id|inw
c_func
(paren
id|base
op_plus
id|HA_RDATA
)paren
suffix:semicolon
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|DBG
c_func
(paren
id|DBG_PROBE
comma
id|printk
c_func
(paren
l_string|&quot;eata_dma: get_conf_PIO, error during transfer &quot;
l_string|&quot;for HBA at %lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|base
)paren
)paren
suffix:semicolon
)brace
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
DECL|function|print_config
r_void
id|print_config
c_func
(paren
r_struct
id|get_conf
op_star
id|gc
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Please check values: (read config data)&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;LEN: %d ver:%d OCS:%d TAR:%d TRNXFR:%d MORES:%d DMAS:%d&bslash;n&quot;
comma
(paren
id|u32
)paren
id|ntohl
c_func
(paren
id|gc-&gt;len
)paren
comma
id|gc-&gt;version
comma
id|gc-&gt;OCS_enabled
comma
id|gc-&gt;TAR_support
comma
id|gc-&gt;TRNXFR
comma
id|gc-&gt;MORE_support
comma
id|gc-&gt;DMA_support
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;DMAV:%d HAAV:%d SCSIID0:%d ID1:%d ID2:%d QUEUE:%d SG:%d SEC:%d&bslash;n&quot;
comma
id|gc-&gt;DMA_valid
comma
id|gc-&gt;HAA_valid
comma
id|gc-&gt;scsi_id
(braket
l_int|3
)braket
comma
id|gc-&gt;scsi_id
(braket
l_int|2
)braket
comma
id|gc-&gt;scsi_id
(braket
l_int|1
)braket
comma
id|ntohs
c_func
(paren
id|gc-&gt;queuesiz
)paren
comma
id|ntohs
c_func
(paren
id|gc-&gt;SGsiz
)paren
comma
id|gc-&gt;SECOND
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IRQ:%d IRQT:%d DMAC:%d FORCADR:%d SG_64K:%d SG_UAE:%d MID:%d &quot;
l_string|&quot;MCH:%d MLUN:%d&bslash;n&quot;
comma
id|gc-&gt;IRQ
comma
id|gc-&gt;IRQ_TR
comma
(paren
l_int|8
op_minus
id|gc-&gt;DMA_channel
)paren
op_amp
l_int|7
comma
id|gc-&gt;FORCADR
comma
id|gc-&gt;SG_64K
comma
id|gc-&gt;SG_UAE
comma
id|gc-&gt;MAX_ID
comma
id|gc-&gt;MAX_CHAN
comma
id|gc-&gt;MAX_LUN
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RIDQ:%d PCI:%d EISA:%d&bslash;n&quot;
comma
id|gc-&gt;ID_qest
comma
id|gc-&gt;is_PCI
comma
id|gc-&gt;is_EISA
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DPT_DEBUG
comma
id|DELAY
c_func
(paren
l_int|14
)paren
)paren
suffix:semicolon
)brace
DECL|function|register_HBA
r_int
id|register_HBA
c_func
(paren
id|u32
id|base
comma
r_struct
id|get_conf
op_star
id|gc
comma
id|Scsi_Host_Template
op_star
id|tpnt
comma
id|u8
id|bustype
)paren
(brace
id|ulong
id|size
op_assign
l_int|0
suffix:semicolon
id|unchar
id|dma_channel
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|buff
op_assign
l_int|0
suffix:semicolon
id|unchar
id|bugs
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|sh
suffix:semicolon
id|hostdata
op_star
id|hd
suffix:semicolon
r_int
id|x
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_REGISTER
comma
id|print_config
c_func
(paren
id|gc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gc-&gt;DMA_support
op_eq
id|FALSE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;The EATA HBA at %#.4x does not support DMA.&bslash;n&quot;
l_string|&quot;Please use the EATA-PIO driver.&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gc-&gt;HAA_valid
op_eq
id|FALSE
op_logical_or
id|ntohl
c_func
(paren
id|gc-&gt;len
)paren
OL
l_int|0x22
)paren
(brace
id|gc-&gt;MAX_CHAN
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reg_IRQ
(braket
id|gc-&gt;IRQ
)braket
op_eq
id|FALSE
)paren
(brace
multiline_comment|/* Interrupt already registered ? */
r_if
c_cond
(paren
op_logical_neg
id|request_irq
c_func
(paren
id|gc-&gt;IRQ
comma
(paren
r_void
op_star
)paren
id|eata_fake_int_handler
comma
id|SA_INTERRUPT
comma
l_string|&quot;eata_dma&quot;
)paren
)paren
(brace
id|reg_IRQ
(braket
id|gc-&gt;IRQ
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gc-&gt;IRQ_TR
)paren
id|reg_IRQL
(braket
id|gc-&gt;IRQ
)braket
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* IRQ is edge triggered */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Couldn&squot;t allocate IRQ %d, Sorry.&quot;
comma
id|gc-&gt;IRQ
)paren
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* More than one HBA on this IRQ */
r_if
c_cond
(paren
id|reg_IRQL
(braket
id|gc-&gt;IRQ
)braket
op_eq
id|TRUE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Can&squot;t support more than one HBA on this IRQ,&bslash;n&quot;
l_string|&quot;  if the IRQ is edge triggered. Sorry.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
r_else
id|reg_IRQ
(braket
id|gc-&gt;IRQ
)braket
op_increment
suffix:semicolon
)brace
multiline_comment|/* if gc-&gt;DMA_valid it must be an ISA HBA and we have to register it */
id|dma_channel
op_assign
id|BUSMASTER
suffix:semicolon
r_if
c_cond
(paren
id|gc-&gt;DMA_valid
)paren
(brace
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|dma_channel
op_assign
(paren
l_int|8
op_minus
id|gc-&gt;DMA_channel
)paren
op_amp
l_int|7
comma
l_string|&quot;eata_dma&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to allocate DMA channel %d for ISA HBA at %#.4x.&bslash;n&quot;
comma
id|dma_channel
comma
id|base
)paren
suffix:semicolon
id|reg_IRQ
(braket
id|gc-&gt;IRQ
)braket
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|reg_IRQ
(braket
id|gc-&gt;IRQ
)braket
op_eq
l_int|0
)paren
id|free_irq
c_func
(paren
id|gc-&gt;IRQ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gc-&gt;IRQ_TR
op_eq
id|FALSE
)paren
id|reg_IRQL
(braket
id|gc-&gt;IRQ
)braket
op_assign
id|FALSE
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
)brace
macro_line|#if !(NEWSTUFF)
r_if
c_cond
(paren
id|bustype
op_ne
id|IS_EISA
op_logical_and
id|bustype
op_ne
id|IS_ISA
)paren
macro_line|#endif
id|buff
op_assign
id|get_board_data
c_func
(paren
id|base
comma
id|gc-&gt;IRQ
comma
id|gc-&gt;scsi_id
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
macro_line|#if !(NEWSTUFF)
r_if
c_cond
(paren
id|bustype
op_eq
id|IS_EISA
op_logical_or
id|bustype
op_eq
id|IS_ISA
)paren
(brace
id|bugs
op_assign
id|bugs
op_logical_or
id|BROKEN_INQUIRY
suffix:semicolon
)brace
r_else
(brace
macro_line|#endif
r_if
c_cond
(paren
id|gc-&gt;DMA_support
op_eq
id|FALSE
)paren
id|printk
c_func
(paren
l_string|&quot;HBA at %#.4x doesn&squot;t support DMA. Sorry&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;HBA at %#.4x does not react on INQUIRY. Sorry.&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gc-&gt;DMA_valid
)paren
id|free_dma
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
id|reg_IRQ
(braket
id|gc-&gt;IRQ
)braket
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|reg_IRQ
(braket
id|gc-&gt;IRQ
)braket
op_eq
l_int|0
)paren
id|free_irq
c_func
(paren
id|gc-&gt;IRQ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gc-&gt;IRQ_TR
op_eq
id|FALSE
)paren
id|reg_IRQL
(braket
id|gc-&gt;IRQ
)braket
op_assign
id|FALSE
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
macro_line|#if !(NEWSTUFF)
)brace
macro_line|#endif
)brace
r_if
c_cond
(paren
id|gc-&gt;DMA_support
op_eq
id|FALSE
op_logical_and
id|buff
op_ne
l_int|NULL
)paren
id|printk
c_func
(paren
l_string|&quot;HBA %.12sat %#.4x doesn&squot;t set the DMA_support flag correctly.&bslash;n&quot;
comma
op_amp
id|buff
(braket
l_int|16
)braket
comma
id|base
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|base
comma
l_int|9
comma
l_string|&quot;eata_dma&quot;
)paren
suffix:semicolon
multiline_comment|/* We already checked the &n;&t;&t;&t;&t;&t;  * availability, so this&n;&t;&t;&t;&t;&t;  * should not fail.&n;&t;&t;&t;&t;&t;  */
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|gc-&gt;queuesiz
)paren
op_eq
l_int|0
)paren
(brace
id|gc-&gt;queuesiz
op_assign
id|ntohs
c_func
(paren
l_int|64
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Warning: Queue size has to be corrected. Assuming 64 queueslots&bslash;n&quot;
l_string|&quot;         This might be a PM2012B with a defective Firmware&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|size
op_assign
r_sizeof
(paren
id|hostdata
)paren
op_plus
(paren
(paren
r_sizeof
(paren
r_struct
id|eata_ccb
)paren
op_plus
r_sizeof
(paren
r_int
)paren
)paren
op_star
id|ntohs
c_func
(paren
id|gc-&gt;queuesiz
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_REGISTER
comma
id|printk
c_func
(paren
l_string|&quot;scsi_register size: %ld&bslash;n&quot;
comma
id|size
)paren
)paren
suffix:semicolon
id|sh
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|gc-&gt;DMA_valid
)paren
id|free_dma
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
id|reg_IRQ
(braket
id|gc-&gt;IRQ
)braket
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|reg_IRQ
(braket
id|gc-&gt;IRQ
)braket
op_eq
l_int|0
)paren
id|free_irq
c_func
(paren
id|gc-&gt;IRQ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gc-&gt;IRQ_TR
op_eq
id|FALSE
)paren
id|reg_IRQL
(braket
id|gc-&gt;IRQ
)braket
op_assign
id|FALSE
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
id|hd
op_assign
id|SD
c_func
(paren
id|sh
)paren
suffix:semicolon
id|memset
c_func
(paren
id|hd-&gt;ccb
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|eata_ccb
)paren
op_star
id|ntohs
c_func
(paren
id|gc-&gt;queuesiz
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|hd-&gt;reads
comma
l_int|0
comma
r_sizeof
(paren
id|u32
)paren
op_star
l_int|26
)paren
suffix:semicolon
id|hd-&gt;broken_INQUIRY
op_assign
(paren
id|bugs
op_amp
id|BROKEN_INQUIRY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;broken_INQUIRY
op_eq
id|TRUE
)paren
(brace
id|strcpy
c_func
(paren
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|vendor
comma
l_string|&quot;DPT&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|name
comma
l_string|&quot;??????????&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|revision
comma
l_string|&quot;???.?&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|strncpy
c_func
(paren
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|vendor
comma
op_amp
id|buff
(braket
l_int|8
)braket
comma
l_int|8
)paren
suffix:semicolon
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|vendor
(braket
l_int|8
)braket
op_assign
l_int|0
suffix:semicolon
id|strncpy
c_func
(paren
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|name
comma
op_amp
id|buff
(braket
l_int|16
)braket
comma
l_int|17
)paren
suffix:semicolon
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|name
(braket
l_int|17
)braket
op_assign
l_int|0
suffix:semicolon
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|revision
(braket
l_int|0
)braket
op_assign
id|buff
(braket
l_int|32
)braket
suffix:semicolon
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|revision
(braket
l_int|1
)braket
op_assign
id|buff
(braket
l_int|33
)braket
suffix:semicolon
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|revision
(braket
l_int|2
)braket
op_assign
id|buff
(braket
l_int|34
)braket
suffix:semicolon
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|revision
(braket
l_int|3
)braket
op_assign
l_char|&squot;.&squot;
suffix:semicolon
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|revision
(braket
l_int|4
)braket
op_assign
id|buff
(braket
l_int|35
)braket
suffix:semicolon
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|revision
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|ntohl
c_func
(paren
id|gc-&gt;len
)paren
)paren
(brace
r_case
l_int|0x1c
suffix:colon
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|EATA_revision
op_assign
l_char|&squot;a&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1e
suffix:colon
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|EATA_revision
op_assign
l_char|&squot;b&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x22
suffix:colon
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|EATA_revision
op_assign
l_char|&squot;c&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x24
suffix:colon
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|EATA_revision
op_assign
l_char|&squot;z&squot;
suffix:semicolon
r_default
suffix:colon
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|EATA_revision
op_assign
l_char|&squot;?&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|gc-&gt;len
)paren
op_ge
l_int|0x22
)paren
(brace
r_if
c_cond
(paren
id|gc-&gt;is_PCI
op_eq
id|TRUE
)paren
id|hd-&gt;bustype
op_assign
id|IS_PCI
suffix:semicolon
r_else
r_if
c_cond
(paren
id|gc-&gt;is_EISA
op_eq
id|TRUE
)paren
id|hd-&gt;bustype
op_assign
id|IS_EISA
suffix:semicolon
r_else
id|hd-&gt;bustype
op_assign
id|IS_ISA
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hd-&gt;broken_INQUIRY
op_eq
id|FALSE
)paren
(brace
r_if
c_cond
(paren
id|buff
(braket
l_int|21
)braket
op_eq
l_char|&squot;4&squot;
)paren
id|hd-&gt;bustype
op_assign
id|IS_PCI
suffix:semicolon
r_else
r_if
c_cond
(paren
id|buff
(braket
l_int|21
)braket
op_eq
l_char|&squot;2&squot;
)paren
id|hd-&gt;bustype
op_assign
id|IS_EISA
suffix:semicolon
r_else
id|hd-&gt;bustype
op_assign
id|IS_ISA
suffix:semicolon
)brace
r_else
id|hd-&gt;bustype
op_assign
id|bustype
suffix:semicolon
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|gc-&gt;len
)paren
op_ge
l_int|0x22
)paren
(brace
id|sh-&gt;max_id
op_assign
id|gc-&gt;MAX_ID
op_plus
l_int|1
suffix:semicolon
id|sh-&gt;max_lun
op_assign
id|gc-&gt;MAX_LUN
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|sh-&gt;max_id
op_assign
l_int|8
suffix:semicolon
id|sh-&gt;max_lun
op_assign
l_int|8
suffix:semicolon
)brace
id|hd-&gt;channel
op_assign
id|gc-&gt;MAX_CHAN
suffix:semicolon
id|sh-&gt;max_channel
op_assign
id|gc-&gt;MAX_CHAN
suffix:semicolon
id|sh-&gt;unique_id
op_assign
id|base
suffix:semicolon
id|sh-&gt;base
op_assign
(paren
r_char
op_star
)paren
id|base
suffix:semicolon
id|sh-&gt;io_port
op_assign
id|base
suffix:semicolon
id|sh-&gt;n_io_port
op_assign
l_int|9
suffix:semicolon
id|sh-&gt;irq
op_assign
id|gc-&gt;IRQ
suffix:semicolon
id|sh-&gt;dma_channel
op_assign
id|dma_channel
suffix:semicolon
multiline_comment|/* FIXME:&n;     * SCSI midlevel code should support different HBA ids on every channel&n;     */
id|sh-&gt;this_id
op_assign
id|gc-&gt;scsi_id
(braket
l_int|3
)braket
suffix:semicolon
id|sh-&gt;can_queue
op_assign
id|ntohs
c_func
(paren
id|gc-&gt;queuesiz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gc-&gt;OCS_enabled
op_eq
id|TRUE
)paren
(brace
r_if
c_cond
(paren
id|hd-&gt;bustype
op_ne
id|IS_ISA
)paren
(brace
id|sh-&gt;cmd_per_lun
op_assign
id|sh-&gt;can_queue
op_div
id|C_P_L_DIV
suffix:semicolon
)brace
r_else
id|sh-&gt;cmd_per_lun
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* We artificially limit this to conserve memory, &n;&t;&t;&t;&t;  * which would be needed for ISA bounce buffers */
)brace
r_else
id|sh-&gt;cmd_per_lun
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* FIXME:&n;     * SG should be allocated more dynamically &n;     */
multiline_comment|/*&n;     * If we are using a ISA board, we can&squot;t use extended SG,&n;     * because we would need exessive amounts of memory for&n;     * bounce buffers.&n;     */
r_if
c_cond
(paren
id|gc-&gt;SG_64K
op_eq
id|TRUE
op_logical_and
id|ntohs
c_func
(paren
id|gc-&gt;SGsiz
)paren
op_eq
l_int|64
op_logical_and
id|hd-&gt;bustype
op_ne
id|IS_ISA
)paren
(brace
id|sh-&gt;sg_tablesize
op_assign
id|SG_SIZE_BIG
suffix:semicolon
id|sh-&gt;use_clustering
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
id|sh-&gt;sg_tablesize
op_assign
id|ntohs
c_func
(paren
id|gc-&gt;SGsiz
)paren
suffix:semicolon
id|sh-&gt;use_clustering
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|sh-&gt;sg_tablesize
OG
id|SG_SIZE
op_logical_or
id|sh-&gt;sg_tablesize
op_eq
l_int|0
)paren
(brace
id|sh-&gt;sg_tablesize
op_assign
id|SG_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|gc-&gt;SGsiz
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;Warning: SG size had to be corrected.&bslash;n&quot;
l_string|&quot;This might be a PM2012 with a defective Firmware&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|gc-&gt;SECOND
)paren
id|hd-&gt;primary
op_assign
id|FALSE
suffix:semicolon
r_else
id|hd-&gt;primary
op_assign
id|TRUE
suffix:semicolon
id|sh-&gt;wish_block
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;bustype
op_ne
id|IS_ISA
)paren
(brace
id|sh-&gt;unchecked_isa_dma
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
id|sh-&gt;unchecked_isa_dma
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* We&squot;re doing ISA DMA */
)brace
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
op_le
l_int|11
suffix:semicolon
id|x
op_increment
)paren
(brace
multiline_comment|/* Initialize min. latency */
id|hd-&gt;writes_lat
(braket
id|x
)braket
(braket
l_int|1
)braket
op_assign
l_int|0xffffffff
suffix:semicolon
id|hd-&gt;reads_lat
(braket
id|x
)braket
(braket
l_int|1
)braket
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
id|hd-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* build a linked list of all HBAs */
id|hd-&gt;prev
op_assign
id|last_HBA
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;prev
op_ne
l_int|NULL
)paren
(brace
id|SD
c_func
(paren
id|hd-&gt;prev
)paren
op_member_access_from_pointer
id|next
op_assign
id|sh
suffix:semicolon
)brace
id|last_HBA
op_assign
id|sh
suffix:semicolon
r_if
c_cond
(paren
id|first_HBA
op_eq
l_int|NULL
)paren
id|first_HBA
op_assign
id|sh
suffix:semicolon
id|registered_HBAs
op_increment
suffix:semicolon
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
DECL|function|find_EISA
r_void
id|find_EISA
c_func
(paren
r_struct
id|get_conf
op_star
id|buf
comma
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
id|u32
id|base
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#if CHECKPAL
id|u8
id|pal1
comma
id|pal2
comma
id|pal3
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAXEISA
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|EISAbases
(braket
id|i
)braket
op_eq
id|TRUE
)paren
(brace
multiline_comment|/* Still a possibility ?&t;      */
id|base
op_assign
l_int|0x1c88
op_plus
(paren
id|i
op_star
l_int|0x1000
)paren
suffix:semicolon
macro_line|#if CHECKPAL
id|pal1
op_assign
id|inb
c_func
(paren
(paren
id|u16
)paren
id|base
op_minus
l_int|8
)paren
suffix:semicolon
id|pal2
op_assign
id|inb
c_func
(paren
(paren
id|u16
)paren
id|base
op_minus
l_int|7
)paren
suffix:semicolon
id|pal3
op_assign
id|inb
c_func
(paren
(paren
id|u16
)paren
id|base
op_minus
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|pal1
op_eq
l_int|0x12
)paren
op_logical_and
(paren
id|pal2
op_eq
l_int|0x14
)paren
)paren
op_logical_or
(paren
(paren
id|pal1
op_eq
l_int|0x38
)paren
op_logical_and
(paren
id|pal2
op_eq
l_int|0xa3
)paren
op_logical_and
(paren
id|pal3
op_eq
l_int|0x82
)paren
)paren
op_logical_or
(paren
(paren
id|pal1
op_eq
l_int|0x06
)paren
op_logical_and
(paren
id|pal2
op_eq
l_int|0x94
)paren
op_logical_and
(paren
id|pal3
op_eq
l_int|0x24
)paren
)paren
)paren
(brace
id|DBG
c_func
(paren
id|DBG_PROBE
comma
id|printk
c_func
(paren
l_string|&quot;EISA EATA id tags found: %x %x %x &bslash;n&quot;
comma
(paren
r_int
)paren
id|pal1
comma
(paren
r_int
)paren
id|pal2
comma
(paren
r_int
)paren
id|pal3
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|get_conf_PIO
c_func
(paren
id|base
comma
id|buf
)paren
op_eq
id|TRUE
)paren
(brace
r_if
c_cond
(paren
id|buf-&gt;IRQ
)paren
(brace
id|DBG
c_func
(paren
id|DBG_EISA
comma
id|printk
c_func
(paren
l_string|&quot;Registering EISA HBA&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|register_HBA
c_func
(paren
id|base
comma
id|buf
comma
id|tpnt
comma
id|IS_EISA
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;eata_dma: No valid IRQ. HBA removed from list&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|check_blink_state
c_func
(paren
id|base
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;HBA is in BLINK state. Consult your HBAs &quot;
l_string|&quot; Manual to correct this.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Nothing found here so we take it from the list */
id|EISAbases
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#if CHECKPAL
)brace
macro_line|#endif
)brace
)brace
r_return
suffix:semicolon
)brace
DECL|function|find_ISA
r_void
id|find_ISA
c_func
(paren
r_struct
id|get_conf
op_star
id|buf
comma
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAXISA
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ISAbases
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
id|get_conf_PIO
c_func
(paren
id|ISAbases
(braket
id|i
)braket
comma
id|buf
)paren
op_eq
id|TRUE
)paren
(brace
id|DBG
c_func
(paren
id|DBG_ISA
comma
id|printk
c_func
(paren
l_string|&quot;Registering ISA HBA&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|register_HBA
c_func
(paren
id|ISAbases
(braket
id|i
)braket
comma
id|buf
comma
id|tpnt
comma
id|IS_ISA
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|check_blink_state
c_func
(paren
id|ISAbases
(braket
id|i
)braket
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;HBA is in BLINK state. Consult your HBAs &quot;
l_string|&quot;Manual to correct this.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ISAbases
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
DECL|function|find_PCI
r_void
id|find_PCI
c_func
(paren
r_struct
id|get_conf
op_star
id|buf
comma
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
macro_line|#ifndef CONFIG_PCI
id|printk
c_func
(paren
l_string|&quot;eata_dma: kernel PCI support not enabled. Skipping scan for PCI HBAs.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|u8
id|pci_bus
comma
id|pci_device_fn
suffix:semicolon
r_static
id|s16
id|pci_index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Device index to PCI BIOS calls */
id|u32
id|base
op_assign
l_int|0
suffix:semicolon
id|u16
id|com_adr
suffix:semicolon
id|u16
id|rev_device
suffix:semicolon
id|u32
id|error
comma
id|i
comma
id|x
suffix:semicolon
id|u8
id|pal1
comma
id|pal2
comma
id|pal3
suffix:semicolon
r_if
c_cond
(paren
id|pcibios_present
c_func
(paren
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|MAXPCI
suffix:semicolon
op_increment
id|i
comma
op_increment
id|pci_index
)paren
(brace
r_if
c_cond
(paren
id|pcibios_find_device
c_func
(paren
id|PCI_VENDOR_ID_DPT
comma
id|PCI_DEVICE_ID_DPT
comma
id|pci_index
comma
op_amp
id|pci_bus
comma
op_amp
id|pci_device_fn
)paren
)paren
r_break
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_PROBE
op_logical_and
id|DBG_PCI
comma
id|printk
c_func
(paren
l_string|&quot;eata_dma: HBA at bus %d, device %d,&quot;
l_string|&quot; function %d, index %d&bslash;n&quot;
comma
(paren
id|s32
)paren
id|pci_bus
comma
(paren
id|s32
)paren
(paren
(paren
id|pci_device_fn
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
)paren
comma
(paren
id|s32
)paren
(paren
id|pci_device_fn
op_amp
l_int|7
)paren
comma
id|pci_index
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|error
op_assign
id|pcibios_read_config_word
c_func
(paren
id|pci_bus
comma
id|pci_device_fn
comma
id|PCI_CLASS_DEVICE
comma
op_amp
id|rev_device
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|rev_device
op_eq
id|PCI_CLASS_STORAGE_SCSI
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|error
op_assign
id|pcibios_read_config_word
c_func
(paren
id|pci_bus
comma
id|pci_device_fn
comma
id|PCI_COMMAND
comma
(paren
id|u16
op_star
)paren
op_amp
id|com_adr
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|com_adr
op_amp
id|PCI_COMMAND_IO
)paren
op_logical_and
(paren
id|com_adr
op_amp
id|PCI_COMMAND_MASTER
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eata_dma: HBA has IO or BUSMASTER mode disabled&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;eata_dma: error %x while reading &quot;
l_string|&quot;PCI_COMMAND&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;eata_dma: DEVICECLASSID %x didn&squot;t match&bslash;n&quot;
comma
id|rev_device
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;eata_dma: error %x while reading PCI_CLASS_BASE&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|error
op_assign
id|pcibios_read_config_dword
c_func
(paren
id|pci_bus
comma
id|pci_device_fn
comma
id|PCI_BASE_ADDRESS_0
comma
(paren
r_int
op_star
)paren
op_amp
id|base
)paren
)paren
)paren
(brace
multiline_comment|/* Check if the address is valid */
r_if
c_cond
(paren
id|base
op_amp
l_int|0x01
)paren
(brace
id|base
op_and_assign
l_int|0xfffffffe
suffix:semicolon
multiline_comment|/* EISA tag there ? */
id|pal1
op_assign
id|inb
c_func
(paren
id|base
)paren
suffix:semicolon
id|pal2
op_assign
id|inb
c_func
(paren
id|base
op_plus
l_int|1
)paren
suffix:semicolon
id|pal3
op_assign
id|inb
c_func
(paren
id|base
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|pal1
op_eq
l_int|0x12
)paren
op_logical_and
(paren
id|pal2
op_eq
l_int|0x14
)paren
)paren
op_logical_or
(paren
(paren
id|pal1
op_eq
l_int|0x38
)paren
op_logical_and
(paren
id|pal2
op_eq
l_int|0xa3
)paren
op_logical_and
(paren
id|pal3
op_eq
l_int|0x82
)paren
)paren
op_logical_or
(paren
(paren
id|pal1
op_eq
l_int|0x06
)paren
op_logical_and
(paren
id|pal2
op_eq
l_int|0x94
)paren
op_logical_and
(paren
id|pal3
op_eq
l_int|0x24
)paren
)paren
)paren
id|base
op_add_assign
l_int|0x08
suffix:semicolon
r_else
id|base
op_add_assign
l_int|0x10
suffix:semicolon
multiline_comment|/* Now, THIS is the real address */
r_if
c_cond
(paren
id|base
op_ne
l_int|0x1f8
)paren
(brace
multiline_comment|/* We didn&squot;t find it in the primary search */
r_if
c_cond
(paren
id|get_conf_PIO
c_func
(paren
id|base
comma
id|buf
)paren
op_eq
id|TRUE
)paren
(brace
multiline_comment|/* OK. We made it till here, so we can go now  &n;&t;&t;&t;     * and register it. We  only have to check and &n;&t;&t;&t;     * eventually remove it from the EISA and ISA list &n;&t;&t;&t;     */
id|DBG
c_func
(paren
id|DBG_PCI
comma
id|printk
c_func
(paren
l_string|&quot;Registering PCI HBA&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|register_HBA
c_func
(paren
id|base
comma
id|buf
comma
id|tpnt
comma
id|IS_PCI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
OL
l_int|0x1000
)paren
(brace
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|MAXISA
suffix:semicolon
op_increment
id|x
)paren
(brace
r_if
c_cond
(paren
id|ISAbases
(braket
id|x
)braket
op_eq
id|base
)paren
(brace
id|ISAbases
(braket
id|x
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|base
op_amp
l_int|0x0fff
)paren
op_eq
l_int|0x0c88
)paren
id|EISAbases
(braket
(paren
id|base
op_rshift
l_int|12
)paren
op_amp
l_int|0x0f
)braket
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* break; */
)brace
r_else
r_if
c_cond
(paren
id|check_blink_state
c_func
(paren
id|base
)paren
op_eq
id|TRUE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eata_dma: HBA is in BLINK state.&bslash;n&quot;
l_string|&quot;Consult your HBAs Manual to correct this.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;eata_dma: error %x while reading &quot;
l_string|&quot;PCI_BASE_ADDRESS_0&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;eata_dma: No BIOS32 extensions present. This driver release &quot;
l_string|&quot;still depends on it.&bslash;n&quot;
l_string|&quot;&t;  Skipping scan for PCI HBAs. &bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* #ifndef CONFIG_PCI */
r_return
suffix:semicolon
)brace
DECL|function|eata_detect
r_int
id|eata_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|HBA_ptr
suffix:semicolon
r_struct
id|get_conf
id|gc
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DBG
c_func
(paren
(paren
id|DBG_PROBE
op_logical_and
id|DBG_DELAY
)paren
op_logical_or
id|DPT_DEBUG
comma
id|printk
c_func
(paren
l_string|&quot;Using lots of delays to let you read the debugging output&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|tpnt-&gt;proc_dir
op_assign
op_amp
id|proc_scsi_eata_dma
suffix:semicolon
id|status
op_assign
id|scsi_init_malloc
c_func
(paren
l_int|512
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
id|dma_scratch
op_assign
id|scsi_init_malloc
c_func
(paren
l_int|512
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|NULL
op_logical_or
id|dma_scratch
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eata_dma: can&squot;t allocate enough memory to probe for hosts !&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|find_PCI
c_func
(paren
op_amp
id|gc
comma
id|tpnt
)paren
suffix:semicolon
id|find_EISA
c_func
(paren
op_amp
id|gc
comma
id|tpnt
)paren
suffix:semicolon
id|find_ISA
c_func
(paren
op_amp
id|gc
comma
id|tpnt
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|MAXIRQ
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Now that we know what we have, we     */
r_if
c_cond
(paren
id|reg_IRQ
(braket
id|i
)braket
)paren
(brace
multiline_comment|/* exchange the interrupt handler which  */
id|free_irq
c_func
(paren
id|i
)paren
suffix:semicolon
multiline_comment|/* we used for probing with the real one */
id|request_irq
c_func
(paren
id|i
comma
(paren
r_void
op_star
)paren
(paren
id|eata_int_handler
)paren
comma
id|SA_INTERRUPT
comma
l_string|&quot;eata_dma&quot;
)paren
suffix:semicolon
)brace
)brace
id|HBA_ptr
op_assign
id|first_HBA
suffix:semicolon
r_if
c_cond
(paren
id|registered_HBAs
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;EATA (Extended Attachment) driver version: %d.%d%s&bslash;n&quot;
l_string|&quot;developed in co-operation with DPT&bslash;n&quot;
l_string|&quot;(c) 1993-95 Michael Neuffer, neuffer@goofy.zdv.uni-mainz.de&bslash;n&quot;
comma
id|VER_MAJOR
comma
id|VER_MINOR
comma
id|VER_SUB
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Registered HBAs:&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nHBA no. Boardtype: Revis: EATA: Bus: BaseIO: IRQ: DMA: Ch: &quot;
l_string|&quot;ID: Pr: QS: SG: CPL:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|registered_HBAs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%-2d: %.10s v%s 2.0%c  %s %#.4x   %2d&quot;
comma
id|HBA_ptr-&gt;host_no
comma
id|SD
c_func
(paren
id|HBA_ptr
)paren
op_member_access_from_pointer
id|name
comma
id|SD
c_func
(paren
id|HBA_ptr
)paren
op_member_access_from_pointer
id|revision
comma
id|SD
c_func
(paren
id|HBA_ptr
)paren
op_member_access_from_pointer
id|EATA_revision
comma
(paren
id|SD
c_func
(paren
id|HBA_ptr
)paren
op_member_access_from_pointer
id|bustype
op_eq
l_char|&squot;P&squot;
)paren
ques
c_cond
l_string|&quot;PCI &quot;
suffix:colon
(paren
id|SD
c_func
(paren
id|HBA_ptr
)paren
op_member_access_from_pointer
id|bustype
op_eq
l_char|&squot;E&squot;
)paren
ques
c_cond
l_string|&quot;EISA&quot;
suffix:colon
l_string|&quot;ISA &quot;
comma
(paren
id|u32
)paren
id|HBA_ptr-&gt;base
comma
id|HBA_ptr-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HBA_ptr-&gt;dma_channel
op_ne
id|BUSMASTER
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;   %2x &quot;
comma
id|HBA_ptr-&gt;dma_channel
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;  %s&quot;
comma
l_string|&quot;BMST&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  %d   %d   %c  %2d  %2d   %2d&bslash;n&quot;
comma
id|SD
c_func
(paren
id|HBA_ptr
)paren
op_member_access_from_pointer
id|channel
comma
id|HBA_ptr-&gt;this_id
comma
(paren
id|SD
c_func
(paren
id|HBA_ptr
)paren
op_member_access_from_pointer
id|primary
op_eq
id|TRUE
)paren
ques
c_cond
l_char|&squot;Y&squot;
suffix:colon
l_char|&squot;N&squot;
comma
id|HBA_ptr-&gt;can_queue
comma
id|HBA_ptr-&gt;sg_tablesize
comma
id|HBA_ptr-&gt;cmd_per_lun
)paren
suffix:semicolon
id|HBA_ptr
op_assign
id|SD
c_func
(paren
id|HBA_ptr
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
)brace
r_else
(brace
id|scsi_init_free
c_func
(paren
(paren
r_void
op_star
)paren
id|status
comma
l_int|512
)paren
suffix:semicolon
)brace
id|scsi_init_free
c_func
(paren
(paren
r_void
op_star
)paren
id|dma_scratch
comma
l_int|512
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DPT_DEBUG
comma
id|DELAY
c_func
(paren
l_int|12
)paren
)paren
suffix:semicolon
r_return
id|registered_HBAs
suffix:semicolon
)brace
macro_line|#ifdef MODULE
multiline_comment|/* Eventually this will go into an include file, but this will be later */
DECL|variable|driver_template
id|Scsi_Host_Template
id|driver_template
op_assign
id|EATA_DMA
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
macro_line|#endif
multiline_comment|/*&n; * Overrides for Emacs so that we almost follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 4&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * tab-width: 8&n; * End:&n; */
eof
