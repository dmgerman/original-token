multiline_comment|/************************************************************&n; *&t;&t;&t;&t;&t;&t;&t;    *&n; *&t;&t;    Linux EATA SCSI driver&t;&t;    *&n; *&t;&t;&t;&t;&t;&t;&t;    *&n; *  based on the CAM document CAM/89-004 rev. 2.0c,&t;    *&n; *  DPT&squot;s driver kit, some internal documents and source,   *&n; *  and several other Linux scsi drivers and kernel docs.   *&n; *&t;&t;&t;&t;&t;&t;&t;    *&n; *  The driver currently:&t;&t;&t;&t;    *&n; *&t;-supports all ISA based EATA-DMA boards&t;&t;    *&n; *       like PM2011, PM2021, PM2041, PM3021                *&n; *&t;-supports all EISA based EATA-DMA boards&t;    *&n; *       like PM2012B, PM2022, PM2122, PM2322, PM2042,      *&n; *            PM3122, PM3222, PM3332                        *&n; *&t;-supports all PCI based EATA-DMA boards&t;&t;    *&n; *       like PM2024, PM2124, PM2044, PM2144, PM3224,       *&n; *            PM3334                                        *&n; *      -supports the Wide, Ultra Wide and Differential     *&n; *       versions of the boards                             *&n; *&t;-supports multiple HBAs with &amp; without IRQ sharing  *&n; *&t;-supports all SCSI channels on multi channel boards *&n; *      -supports ix86 and MIPS, untested on ALPHA          *&n; *&t;-needs identical IDs on all channels of a HBA&t;    * &n; *&t;-can be loaded as module&t;&t;&t;    *&n; *&t;-displays statistical and hardware information&t;    *&n; *&t; in /proc/scsi/eata_dma&t;&t;&t;&t;    *&n; *      -provides rudimentary latency measurement           * &n; *       possibilities via /proc/scsi/eata_dma/&lt;hostnum&gt;    *&n; *&t;&t;&t;&t;&t;&t;&t;    *&n; *  (c)1993-96 Michael Neuffer&t;&t;&t;            *&n; *             mike@i-Connect.Net                           *&n; *&t;       neuffer@mail.uni-mainz.de&t;            *&n; *&t;&t;&t;&t;&t;&t;&t;    *&n; *  This program is free software; you can redistribute it  *&n; *  and/or modify it under the terms of the GNU General&t;    *&n; *  Public License as published by the Free Software&t;    *&n; *  Foundation; either version 2 of the License, or&t;    *&n; *  (at your option) any later version.&t;&t;&t;    *&n; *&t;&t;&t;&t;&t;&t;&t;    *&n; *  This program is distributed in the hope that it will be *&n; *  useful, but WITHOUT ANY WARRANTY; without even the&t;    *&n; *  implied warranty of MERCHANTABILITY or FITNESS FOR A    *&n; *  PARTICULAR PURPOSE.&t; See the GNU General Public License *&n; *  for more details.&t;&t;&t;&t;&t;    *&n; *&t;&t;&t;&t;&t;&t;&t;    *&n; *  You should have received a copy of the GNU General&t;    *&n; *  Public License along with this kernel; if not, write to *&n; *  the Free Software Foundation, Inc., 675 Mass Ave,&t;    *&n; *  Cambridge, MA 02139, USA.&t;&t;&t;&t;    *&n; *&t;&t;&t;&t;&t;&t;&t;    *&n; * I have to thank DPT for their excellent support. I took  *&n; * me almost a year and a stopover at their HQ, on my first *&n; * trip to the USA, to get it, but since then they&squot;ve been  *&n; * very helpful and tried to give me all the infos and&t;    *&n; * support I need.&t;&t;&t;&t;&t;    *&n; *&t;&t;&t;&t;&t;&t;&t;    *&n; * Thanks also to Simon Shapiro, Greg Hosler and Mike       *&n; * Jagdis who did a lot of testing and found quite a number *&n; * of bugs during the development.                          *&n; ************************************************************&n; *  last change: 96/10/21                 OS: Linux 2.0.23  *&n; ************************************************************/
multiline_comment|/* Look in eata_dma.h for configuration and revision information */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/types.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#ifdef __mips__
macro_line|#include &lt;asm/cachectl.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;eata_dma.h&quot;
macro_line|#include &quot;eata_dma_proc.h&quot; 
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/config.h&gt;&t;/* for CONFIG_PCI */
DECL|variable|ISAbases
r_static
id|u32
id|ISAbases
(braket
)braket
op_assign
(brace
l_int|0x1F0
comma
l_int|0x170
comma
l_int|0x330
comma
l_int|0x230
)brace
suffix:semicolon
DECL|variable|EISAbases
r_static
id|unchar
id|EISAbases
(braket
)braket
op_assign
(brace
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)brace
suffix:semicolon
DECL|variable|registered_HBAs
r_static
id|uint
id|registered_HBAs
op_assign
l_int|0
suffix:semicolon
DECL|variable|last_HBA
r_static
r_struct
id|Scsi_Host
op_star
id|last_HBA
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|first_HBA
r_static
r_struct
id|Scsi_Host
op_star
id|first_HBA
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|reg_IRQ
r_static
id|unchar
id|reg_IRQ
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|reg_IRQL
r_static
id|unchar
id|reg_IRQL
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|status
r_static
r_struct
id|eata_sp
op_star
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Statuspacket array   */
DECL|variable|dma_scratch
r_static
r_void
op_star
id|dma_scratch
op_assign
l_int|0
suffix:semicolon
DECL|variable|fake_int_base
r_static
r_struct
id|eata_register
op_star
id|fake_int_base
suffix:semicolon
DECL|variable|fake_int_result
r_static
r_int
id|fake_int_result
suffix:semicolon
DECL|variable|fake_int_happened
r_static
r_int
id|fake_int_happened
suffix:semicolon
DECL|variable|int_counter
r_static
id|ulong
id|int_counter
op_assign
l_int|0
suffix:semicolon
DECL|variable|queue_counter
r_static
id|ulong
id|queue_counter
op_assign
l_int|0
suffix:semicolon
DECL|function|eata_fake_int_handler
r_void
id|eata_fake_int_handler
c_func
(paren
id|s32
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|fake_int_result
op_assign
id|inb
c_func
(paren
(paren
id|ulong
)paren
id|fake_int_base
op_plus
id|HA_RSTATUS
)paren
suffix:semicolon
id|fake_int_happened
op_assign
id|TRUE
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_INTR3
comma
id|printk
c_func
(paren
l_string|&quot;eata_fake_int_handler called irq%d base %p&quot;
l_string|&quot; res %#x&bslash;n&quot;
comma
id|irq
comma
id|fake_int_base
comma
id|fake_int_result
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#include &quot;eata_dma_proc.c&quot;
macro_line|#ifdef MODULE
DECL|function|eata_release
r_int
id|eata_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|sh
)paren
(brace
id|uint
id|i
suffix:semicolon
r_if
c_cond
(paren
id|sh-&gt;irq
op_logical_and
id|reg_IRQ
(braket
id|sh-&gt;irq
)braket
op_eq
l_int|1
)paren
id|free_irq
c_func
(paren
id|sh-&gt;irq
comma
l_int|NULL
)paren
suffix:semicolon
r_else
id|reg_IRQ
(braket
id|sh-&gt;irq
)braket
op_decrement
suffix:semicolon
id|kfree
c_func
(paren
(paren
r_void
op_star
)paren
id|status
)paren
suffix:semicolon
id|kfree
c_func
(paren
(paren
r_void
op_star
)paren
id|dma_scratch
op_minus
l_int|4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sh-&gt;can_queue
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Free all SG arrays */
r_if
c_cond
(paren
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|ccb
(braket
id|i
)braket
dot
id|sg_list
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
(paren
r_void
op_star
)paren
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|ccb
(braket
id|i
)braket
dot
id|sg_list
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|channel
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sh-&gt;dma_channel
op_ne
id|BUSMASTER
)paren
id|free_dma
c_func
(paren
id|sh-&gt;dma_channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh-&gt;io_port
op_logical_and
id|sh-&gt;n_io_port
)paren
id|release_region
c_func
(paren
id|sh-&gt;io_port
comma
id|sh-&gt;n_io_port
)paren
suffix:semicolon
)brace
r_return
id|TRUE
suffix:semicolon
)brace
macro_line|#endif
DECL|function|eata_latency_in
r_inline
r_void
id|eata_latency_in
c_func
(paren
r_struct
id|eata_ccb
op_star
id|cp
comma
id|hostdata
op_star
id|hd
)paren
(brace
id|uint
id|time
suffix:semicolon
id|time
op_assign
id|jiffies
op_minus
id|cp-&gt;timestamp
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;all_lat
(braket
l_int|1
)braket
OG
id|time
)paren
(brace
id|hd-&gt;all_lat
(braket
l_int|1
)braket
op_assign
id|time
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hd-&gt;all_lat
(braket
l_int|2
)braket
OL
id|time
)paren
(brace
id|hd-&gt;all_lat
(braket
l_int|2
)braket
op_assign
id|time
suffix:semicolon
)brace
id|hd-&gt;all_lat
(braket
l_int|3
)braket
op_add_assign
id|time
suffix:semicolon
id|hd-&gt;all_lat
(braket
l_int|0
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cp-&gt;rw_latency
)paren
op_eq
id|WRITE
)paren
(brace
multiline_comment|/* was WRITE */
r_if
c_cond
(paren
id|hd-&gt;writes_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|1
)braket
OG
id|time
)paren
(brace
id|hd-&gt;writes_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|1
)braket
op_assign
id|time
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hd-&gt;writes_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|2
)braket
OL
id|time
)paren
(brace
id|hd-&gt;writes_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|2
)braket
op_assign
id|time
suffix:semicolon
)brace
id|hd-&gt;writes_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|3
)braket
op_add_assign
id|time
suffix:semicolon
id|hd-&gt;writes_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|0
)braket
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;rw_latency
)paren
op_eq
id|READ
)paren
(brace
r_if
c_cond
(paren
id|hd-&gt;reads_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|1
)braket
OG
id|time
)paren
(brace
id|hd-&gt;reads_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|1
)braket
op_assign
id|time
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hd-&gt;reads_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|2
)braket
OL
id|time
)paren
(brace
id|hd-&gt;reads_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|2
)braket
op_assign
id|time
suffix:semicolon
)brace
id|hd-&gt;reads_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|3
)braket
op_add_assign
id|time
suffix:semicolon
id|hd-&gt;reads_lat
(braket
id|cp-&gt;sizeindex
)braket
(braket
l_int|0
)braket
op_increment
suffix:semicolon
)brace
)brace
DECL|function|eata_latency_out
r_inline
r_void
id|eata_latency_out
c_func
(paren
r_struct
id|eata_ccb
op_star
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|x
comma
id|z
suffix:semicolon
r_int
op_star
id|sho
suffix:semicolon
r_int
op_star
id|lon
suffix:semicolon
id|x
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* just to keep GCC quiet */
id|cp-&gt;timestamp
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* For latency measurements */
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|WRITE_6
suffix:colon
id|x
op_assign
id|cmd-&gt;cmnd
(braket
l_int|4
)braket
op_div
l_int|2
suffix:semicolon
id|cp-&gt;rw_latency
op_assign
id|WRITE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ_6
suffix:colon
id|x
op_assign
id|cmd-&gt;cmnd
(braket
l_int|4
)braket
op_div
l_int|2
suffix:semicolon
id|cp-&gt;rw_latency
op_assign
id|READ
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WRITE_10
suffix:colon
id|sho
op_assign
(paren
r_int
op_star
)paren
op_amp
id|cmd-&gt;cmnd
(braket
l_int|7
)braket
suffix:semicolon
id|x
op_assign
id|ntohs
c_func
(paren
op_star
id|sho
)paren
op_div
l_int|2
suffix:semicolon
id|cp-&gt;rw_latency
op_assign
id|WRITE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ_10
suffix:colon
id|sho
op_assign
(paren
r_int
op_star
)paren
op_amp
id|cmd-&gt;cmnd
(braket
l_int|7
)braket
suffix:semicolon
id|x
op_assign
id|ntohs
c_func
(paren
op_star
id|sho
)paren
op_div
l_int|2
suffix:semicolon
id|cp-&gt;rw_latency
op_assign
id|READ
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WRITE_12
suffix:colon
id|lon
op_assign
(paren
r_int
op_star
)paren
op_amp
id|cmd-&gt;cmnd
(braket
l_int|6
)braket
suffix:semicolon
id|x
op_assign
id|ntohl
c_func
(paren
op_star
id|lon
)paren
op_div
l_int|2
suffix:semicolon
id|cp-&gt;rw_latency
op_assign
id|WRITE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ_12
suffix:colon
id|lon
op_assign
(paren
r_int
op_star
)paren
op_amp
id|cmd-&gt;cmnd
(braket
l_int|6
)braket
suffix:semicolon
id|x
op_assign
id|ntohl
c_func
(paren
op_star
id|lon
)paren
op_div
l_int|2
suffix:semicolon
id|cp-&gt;rw_latency
op_assign
id|READ
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|cp-&gt;rw_latency
op_assign
id|OTHER
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_6
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_10
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_12
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_6
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_10
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_12
)paren
(brace
r_for
c_loop
(paren
id|z
op_assign
l_int|0
suffix:semicolon
(paren
id|x
OG
(paren
l_int|1
op_lshift
id|z
)paren
)paren
op_logical_and
(paren
id|z
op_le
l_int|11
)paren
suffix:semicolon
id|z
op_increment
)paren
(brace
multiline_comment|/* nothing */
suffix:semicolon
)brace
id|cp-&gt;sizeindex
op_assign
id|z
suffix:semicolon
)brace
)brace
r_void
id|eata_int_handler
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
DECL|function|do_eata_int_handler
r_void
id|do_eata_int_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|eata_int_handler
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|eata_int_handler
r_void
id|eata_int_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|uint
id|i
comma
id|result
op_assign
l_int|0
suffix:semicolon
id|uint
id|hba_stat
comma
id|scsi_stat
comma
id|eata_stat
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_struct
id|eata_ccb
op_star
id|ccb
suffix:semicolon
r_struct
id|eata_sp
op_star
id|sp
suffix:semicolon
id|uint
id|base
suffix:semicolon
id|uint
id|x
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|sh
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|1
comma
id|sh
op_assign
id|first_HBA
suffix:semicolon
id|x
op_le
id|registered_HBAs
suffix:semicolon
id|x
op_increment
comma
id|sh
op_assign
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|next
)paren
(brace
r_if
c_cond
(paren
id|sh-&gt;irq
op_ne
id|irq
)paren
r_continue
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
(paren
id|uint
)paren
id|sh-&gt;base
op_plus
id|HA_RAUXSTAT
)paren
op_amp
id|HA_AIRQ
)paren
(brace
id|int_counter
op_increment
suffix:semicolon
id|sp
op_assign
op_amp
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|sp
suffix:semicolon
macro_line|#ifdef __mips__
id|sys_cacheflush
c_func
(paren
id|sp
comma
r_sizeof
(paren
r_struct
id|eata_sp
)paren
comma
l_int|2
)paren
suffix:semicolon
macro_line|#endif
id|ccb
op_assign
id|sp-&gt;ccb
suffix:semicolon
r_if
c_cond
(paren
id|ccb
op_eq
l_int|NULL
)paren
(brace
id|eata_stat
op_assign
id|inb
c_func
(paren
(paren
id|uint
)paren
id|sh-&gt;base
op_plus
id|HA_RSTATUS
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;eata_dma: int_handler, Spurious IRQ %d &quot;
l_string|&quot;received. CCB pointer not set.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cmd
op_assign
id|ccb-&gt;cmd
suffix:semicolon
id|base
op_assign
(paren
id|uint
)paren
id|cmd-&gt;host-&gt;base
suffix:semicolon
id|hba_stat
op_assign
id|sp-&gt;hba_stat
suffix:semicolon
id|scsi_stat
op_assign
(paren
id|sp-&gt;scsi_stat
op_rshift
l_int|1
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;EOC
op_eq
id|FALSE
)paren
(brace
id|eata_stat
op_assign
id|inb
c_func
(paren
id|base
op_plus
id|HA_RSTATUS
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;eata_dma: int_handler, board: %x cmd %lx &quot;
l_string|&quot;returned unfinished.&bslash;n&quot;
l_string|&quot;EATA: %x HBA: %x SCSI: %x spadr %lx spadrirq %lx, &quot;
l_string|&quot;irq%d&bslash;n&quot;
comma
id|base
comma
(paren
r_int
)paren
id|ccb
comma
id|eata_stat
comma
id|hba_stat
comma
id|scsi_stat
comma
(paren
r_int
)paren
op_amp
id|status
comma
(paren
r_int
)paren
op_amp
id|status
(braket
id|irq
)braket
comma
id|irq
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|ccb-&gt;status
op_assign
id|FREE
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sp-&gt;EOC
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Clean out this flag */
r_if
c_cond
(paren
id|ccb-&gt;status
op_eq
id|LOCKED
op_logical_or
id|ccb-&gt;status
op_eq
id|RESET
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eata_dma: int_handler, reseted command pid %ld returned&quot;
l_string|&quot;&bslash;n&quot;
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_INTR
op_logical_and
id|DBG_DELAY
comma
id|DELAY
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
)brace
id|eata_stat
op_assign
id|inb
c_func
(paren
id|base
op_plus
id|HA_RSTATUS
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_INTR
comma
id|printk
c_func
(paren
l_string|&quot;IRQ %d received, base %#.4x, pid %ld, &quot;
l_string|&quot;target: %x, lun: %x, ea_s: %#.2x, hba_s: &quot;
l_string|&quot;%#.2x &bslash;n&quot;
comma
id|irq
comma
id|base
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|eata_stat
comma
id|hba_stat
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hba_stat
)paren
(brace
r_case
id|HA_NO_ERROR
suffix:colon
multiline_comment|/* NO Error */
r_if
c_cond
(paren
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|do_latency
op_eq
id|TRUE
op_logical_and
id|ccb-&gt;timestamp
)paren
(brace
id|eata_latency_in
c_func
(paren
id|ccb
comma
id|HD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
)brace
id|result
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HA_ERR_SEL_TO
suffix:colon
multiline_comment|/* Selection Timeout */
r_case
id|HA_ERR_CMD_TO
suffix:colon
multiline_comment|/* Command Timeout   */
id|result
op_assign
id|DID_TIME_OUT
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HA_BUS_RESET
suffix:colon
multiline_comment|/* SCSI Bus Reset Received */
id|result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_STATUS
comma
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: BUS RESET &quot;
l_string|&quot;received on cmd %ld&bslash;n&quot;
comma
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|HBA_number
comma
id|cmd-&gt;pid
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HA_INIT_POWERUP
suffix:colon
multiline_comment|/* Initial Controller Power-up */
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;type
op_ne
id|TYPE_TAPE
)paren
id|result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
r_else
id|result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAXTARGET
suffix:semicolon
id|i
op_increment
)paren
id|DBG
c_func
(paren
id|DBG_STATUS
comma
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;scsi%d: cmd pid %ld &quot;
l_string|&quot;returned with INIT_POWERUP&bslash;n&quot;
comma
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|HBA_number
comma
id|cmd-&gt;pid
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HA_CP_ABORT_NA
suffix:colon
r_case
id|HA_CP_ABORTED
suffix:colon
id|result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_STATUS
comma
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: aborted cmd &quot;
l_string|&quot;returned&bslash;n&quot;
comma
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|HBA_number
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HA_CP_RESET_NA
suffix:colon
r_case
id|HA_CP_RESET
suffix:colon
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|resetlevel
(braket
id|cmd-&gt;channel
)braket
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_STATUS
comma
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: reseted cmd &quot;
l_string|&quot;pid %ldreturned&bslash;n&quot;
comma
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|HBA_number
comma
id|cmd-&gt;pid
)paren
)paren
suffix:semicolon
r_case
id|HA_SCSI_HUNG
suffix:colon
multiline_comment|/* SCSI Hung                 */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi%d: SCSI hung&bslash;n&quot;
comma
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|HBA_number
)paren
suffix:semicolon
id|result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HA_RSENSE_FAIL
suffix:colon
multiline_comment|/* Auto Request-Sense Failed */
id|DBG
c_func
(paren
id|DBG_STATUS
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi%d: Auto Request Sense &quot;
l_string|&quot;Failed&bslash;n&quot;
comma
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|HBA_number
)paren
)paren
suffix:semicolon
id|result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HA_UNX_BUSPHASE
suffix:colon
multiline_comment|/* Unexpected Bus Phase */
r_case
id|HA_UNX_BUS_FREE
suffix:colon
multiline_comment|/* Unexpected Bus Free */
r_case
id|HA_BUS_PARITY
suffix:colon
multiline_comment|/* Bus Parity Error */
r_case
id|HA_UNX_MSGRJCT
suffix:colon
multiline_comment|/* Unexpected Message Reject */
r_case
id|HA_RESET_STUCK
suffix:colon
multiline_comment|/* SCSI Bus Reset Stuck */
r_case
id|HA_PARITY_ERR
suffix:colon
multiline_comment|/* Controller Ram Parity */
r_default
suffix:colon
id|result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cmd-&gt;result
op_assign
id|result
op_or
(paren
id|scsi_stat
op_lshift
l_int|1
)paren
suffix:semicolon
macro_line|#if DBG_INTR2
r_if
c_cond
(paren
id|scsi_stat
op_logical_or
id|result
op_logical_or
id|hba_stat
op_logical_or
id|eata_stat
op_ne
l_int|0x50
op_logical_or
id|cmd-&gt;scsi_done
op_eq
l_int|NULL
op_logical_or
id|cmd-&gt;device-&gt;id
op_eq
l_int|7
)paren
id|printk
c_func
(paren
l_string|&quot;HBA: %d, channel %d, id: %d, lun %d, pid %ld:&bslash;n&quot;
l_string|&quot;eata_stat %#x, hba_stat %#.2x, scsi_stat %#.2x, &quot;
l_string|&quot;sense_key: %#x, result: %#.8x&bslash;n&quot;
comma
id|x
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
comma
id|cmd-&gt;pid
comma
id|eata_stat
comma
id|hba_stat
comma
id|scsi_stat
comma
id|cmd-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
comma
id|cmd-&gt;result
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_INTR
op_logical_and
id|DBG_DELAY
comma
id|DELAY
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
macro_line|#endif
id|ccb-&gt;status
op_assign
id|FREE
suffix:semicolon
multiline_comment|/* now we can release the slot  */
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
DECL|function|eata_send_command
r_inline
r_int
id|eata_send_command
c_func
(paren
id|u32
id|addr
comma
id|u32
id|base
comma
id|u8
id|command
)paren
(brace
r_int
id|loop
op_assign
id|R_LIMIT
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|base
op_plus
id|HA_RAUXSTAT
)paren
op_amp
id|HA_ABUSY
)paren
r_if
c_cond
(paren
op_decrement
id|loop
op_eq
l_int|0
)paren
r_return
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_ne
(paren
id|u32
)paren
l_int|NULL
)paren
(brace
id|addr
op_assign
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
id|addr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * This is overkill.....but the MIPSen seem to need this&n;     * and it will be optimized away for i86 and ALPHA machines.&n;     */
id|flush_cache_all
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* And now the address in nice little byte chunks */
macro_line|#ifdef __LITTLE_ENDIAN
id|outb
c_func
(paren
id|addr
comma
id|base
op_plus
id|HA_WDMAADDR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|addr
op_rshift
l_int|8
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|addr
op_rshift
l_int|16
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|addr
op_rshift
l_int|24
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|3
)paren
suffix:semicolon
macro_line|#else
id|outb
c_func
(paren
id|addr
op_rshift
l_int|24
comma
id|base
op_plus
id|HA_WDMAADDR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|addr
op_rshift
l_int|16
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|addr
op_rshift
l_int|8
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|addr
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|3
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|command
comma
id|base
op_plus
id|HA_WCOMMAND
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
DECL|function|eata_send_immediate
r_inline
r_int
id|eata_send_immediate
c_func
(paren
id|u32
id|base
comma
id|u32
id|addr
comma
id|u8
id|ifc
comma
id|u8
id|code
comma
id|u8
id|code2
)paren
(brace
r_if
c_cond
(paren
id|addr
op_ne
(paren
id|u32
)paren
l_int|NULL
)paren
(brace
id|addr
op_assign
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
id|addr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * This is overkill.....but the MIPSen seem to need this&n;     * and it will be optimized away for i86 and ALPHA machines.&n;     */
id|flush_cache_all
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0
comma
id|base
op_plus
id|HA_WDMAADDR
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
)paren
(brace
macro_line|#ifdef __LITTLE_ENDIAN
id|outb
c_func
(paren
id|addr
comma
id|base
op_plus
id|HA_WDMAADDR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|addr
op_rshift
l_int|8
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|addr
op_rshift
l_int|16
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|addr
op_rshift
l_int|24
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|3
)paren
suffix:semicolon
macro_line|#else
id|outb
c_func
(paren
id|addr
op_rshift
l_int|24
comma
id|base
op_plus
id|HA_WDMAADDR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|addr
op_rshift
l_int|16
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|addr
op_rshift
l_int|8
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|addr
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|3
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|outb
c_func
(paren
l_int|0x0
comma
id|base
op_plus
id|HA_WDMAADDR
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0
comma
id|base
op_plus
id|HA_WDMAADDR
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|code2
comma
id|base
op_plus
id|HA_WCODE2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|code
comma
id|base
op_plus
id|HA_WCODE
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|ifc
comma
id|base
op_plus
id|HA_WIFC
)paren
suffix:semicolon
id|outb
c_func
(paren
id|EATA_CMD_IMMEDIATE
comma
id|base
op_plus
id|HA_WCOMMAND
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
DECL|function|eata_queue
r_int
id|eata_queue
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
r_int
id|i
comma
id|x
comma
id|y
suffix:semicolon
id|ulong
id|flags
suffix:semicolon
id|hostdata
op_star
id|hd
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|sh
suffix:semicolon
r_struct
id|eata_ccb
op_star
id|ccb
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sl
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#if 0
r_for
c_loop
(paren
id|x
op_assign
l_int|1
comma
id|sh
op_assign
id|first_HBA
suffix:semicolon
id|x
op_le
id|registered_HBAs
suffix:semicolon
id|x
op_increment
comma
id|sh
op_assign
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|next
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
(paren
id|uint
)paren
id|sh-&gt;base
op_plus
id|HA_RAUXSTAT
)paren
op_amp
id|HA_AIRQ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eata_dma: scsi%d interrupt pending in eata_queue.&bslash;n&quot;
l_string|&quot;          Calling interrupt handler.&bslash;n&quot;
comma
id|sh-&gt;host_no
)paren
suffix:semicolon
id|eata_int_handler
c_func
(paren
id|sh-&gt;irq
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|queue_counter
op_increment
suffix:semicolon
id|hd
op_assign
id|HD
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|sh
op_assign
id|cmd-&gt;host
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
id|cmd-&gt;sense_buffer
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
(brace
id|DBG
c_func
(paren
id|DBG_REQSENSE
comma
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Tried to REQUEST SENSE&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* check for free slot */
r_for
c_loop
(paren
id|y
op_assign
id|hd-&gt;last_ccb
op_plus
l_int|1
comma
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|sh-&gt;can_queue
suffix:semicolon
id|x
op_increment
comma
id|y
op_increment
)paren
(brace
r_if
c_cond
(paren
id|y
op_ge
id|sh-&gt;can_queue
)paren
id|y
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;ccb
(braket
id|y
)braket
dot
id|status
op_eq
id|FREE
)paren
r_break
suffix:semicolon
)brace
id|hd-&gt;last_ccb
op_assign
id|y
suffix:semicolon
r_if
c_cond
(paren
id|x
op_ge
id|sh-&gt;can_queue
)paren
(brace
id|cmd-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_QUEUE
op_logical_and
id|DBG_ABNORM
comma
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;eata_queue pid %ld, HBA QUEUE FULL..., &quot;
l_string|&quot;returning DID_BUS_BUSY&bslash;n&quot;
comma
id|cmd-&gt;pid
)paren
)paren
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ccb
op_assign
op_amp
id|hd-&gt;ccb
(braket
id|y
)braket
suffix:semicolon
id|memset
c_func
(paren
id|ccb
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|eata_ccb
)paren
op_minus
r_sizeof
(paren
r_struct
id|eata_sg_list
op_star
)paren
)paren
suffix:semicolon
id|ccb-&gt;status
op_assign
id|USED
suffix:semicolon
multiline_comment|/* claim free slot */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_QUEUE
comma
id|printk
c_func
(paren
l_string|&quot;eata_queue pid %ld, target: %x, lun: %x, y %d&bslash;n&quot;
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|y
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_QUEUE
op_logical_and
id|DBG_DELAY
comma
id|DELAY
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;do_latency
op_eq
id|TRUE
)paren
(brace
id|eata_latency_out
c_func
(paren
id|ccb
comma
id|cmd
)paren
suffix:semicolon
)brace
id|cmd-&gt;scsi_done
op_assign
(paren
r_void
op_star
)paren
id|done
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|CHANGE_DEFINITION
suffix:colon
r_case
id|COMPARE
suffix:colon
r_case
id|COPY
suffix:colon
r_case
id|COPY_VERIFY
suffix:colon
r_case
id|LOG_SELECT
suffix:colon
r_case
id|MODE_SELECT
suffix:colon
r_case
id|MODE_SELECT_10
suffix:colon
r_case
id|SEND_DIAGNOSTIC
suffix:colon
r_case
id|WRITE_BUFFER
suffix:colon
r_case
id|FORMAT_UNIT
suffix:colon
r_case
id|REASSIGN_BLOCKS
suffix:colon
r_case
id|RESERVE
suffix:colon
r_case
id|SEARCH_EQUAL
suffix:colon
r_case
id|SEARCH_HIGH
suffix:colon
r_case
id|SEARCH_LOW
suffix:colon
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
r_case
id|WRITE_VERIFY
suffix:colon
r_case
id|UPDATE_BLOCK
suffix:colon
r_case
id|WRITE_LONG
suffix:colon
r_case
id|WRITE_SAME
suffix:colon
r_case
id|SEARCH_HIGH_12
suffix:colon
r_case
id|SEARCH_EQUAL_12
suffix:colon
r_case
id|SEARCH_LOW_12
suffix:colon
r_case
id|WRITE_12
suffix:colon
r_case
id|WRITE_VERIFY_12
suffix:colon
r_case
id|SET_WINDOW
suffix:colon
r_case
id|MEDIUM_SCAN
suffix:colon
r_case
id|SEND_VOLUME_TAG
suffix:colon
r_case
l_int|0xea
suffix:colon
multiline_comment|/* alternate number for WRITE LONG */
id|ccb-&gt;DataOut
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Output mode */
r_break
suffix:semicolon
r_case
id|TEST_UNIT_READY
suffix:colon
r_default
suffix:colon
id|ccb-&gt;DataIn
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Input mode  */
)brace
multiline_comment|/* FIXME: This will will have to be changed once the midlevel driver &n;     *        allows different HBA IDs on every channel.&n;     */
r_if
c_cond
(paren
id|cmd-&gt;target
op_eq
id|sh-&gt;this_id
)paren
id|ccb-&gt;Interpret
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Interpret command */
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
id|ccb-&gt;scatter
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* SG mode     */
r_if
c_cond
(paren
id|ccb-&gt;sg_list
op_eq
l_int|NULL
)paren
(brace
id|ccb-&gt;sg_list
op_assign
id|kmalloc
c_func
(paren
id|sh-&gt;sg_tablesize
op_star
r_sizeof
(paren
r_struct
id|eata_sg_list
)paren
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ccb-&gt;sg_list
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;     *&t;Claim the bus was busy. Actually we are the problem but this&n;&t;     *  will do a deferred retry for us ;)&n;&t;     */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;eata_dma: Run out of DMA memory for SG lists !&bslash;n&quot;
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
id|ccb-&gt;status
op_assign
id|FREE
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ccb-&gt;cp_dataDMA
op_assign
id|htonl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|ccb-&gt;sg_list
)paren
)paren
suffix:semicolon
id|ccb-&gt;cp_datalen
op_assign
id|htonl
c_func
(paren
id|cmd-&gt;use_sg
op_star
r_sizeof
(paren
r_struct
id|eata_sg_list
)paren
)paren
suffix:semicolon
id|sl
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cmd-&gt;use_sg
suffix:semicolon
id|i
op_increment
comma
id|sl
op_increment
)paren
(brace
id|ccb-&gt;sg_list
(braket
id|i
)braket
dot
id|data
op_assign
id|htonl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|sl-&gt;address
)paren
)paren
suffix:semicolon
id|ccb-&gt;sg_list
(braket
id|i
)braket
dot
id|len
op_assign
id|htonl
c_func
(paren
(paren
id|u32
)paren
id|sl-&gt;length
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|ccb-&gt;scatter
op_assign
id|FALSE
suffix:semicolon
id|ccb-&gt;cp_datalen
op_assign
id|htonl
c_func
(paren
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
id|ccb-&gt;cp_dataDMA
op_assign
id|htonl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|cmd-&gt;request_buffer
)paren
)paren
suffix:semicolon
)brace
id|ccb-&gt;Auto_Req_Sen
op_assign
id|TRUE
suffix:semicolon
id|ccb-&gt;cp_reqDMA
op_assign
id|htonl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|cmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|ccb-&gt;reqlen
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
id|ccb-&gt;cp_id
op_assign
id|cmd-&gt;target
suffix:semicolon
id|ccb-&gt;cp_channel
op_assign
id|cmd-&gt;channel
suffix:semicolon
id|ccb-&gt;cp_lun
op_assign
id|cmd-&gt;lun
suffix:semicolon
id|ccb-&gt;cp_dispri
op_assign
id|TRUE
suffix:semicolon
id|ccb-&gt;cp_identify
op_assign
id|TRUE
suffix:semicolon
id|memcpy
c_func
(paren
id|ccb-&gt;cp_cdb
comma
id|cmd-&gt;cmnd
comma
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
id|ccb-&gt;cp_statDMA
op_assign
id|htonl
c_func
(paren
id|virt_to_bus
c_func
(paren
op_amp
(paren
id|hd-&gt;sp
)paren
)paren
)paren
suffix:semicolon
id|ccb-&gt;cp_viraddr
op_assign
id|ccb
suffix:semicolon
multiline_comment|/* This will be passed thru, so we don&squot;t need to &n;&t;&t;&t;    * convert it */
id|ccb-&gt;cmd
op_assign
id|cmd
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
(paren
r_char
op_star
)paren
op_amp
id|hd-&gt;ccb
(braket
id|y
)braket
suffix:semicolon
r_if
c_cond
(paren
id|eata_send_command
c_func
(paren
(paren
id|u32
)paren
id|ccb
comma
(paren
id|u32
)paren
id|sh-&gt;base
comma
id|EATA_CMD_DMA_SEND_CP
)paren
op_eq
id|FALSE
)paren
(brace
id|cmd-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_QUEUE
op_logical_and
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;eata_queue target %d, pid %ld, HBA busy, &quot;
l_string|&quot;returning DID_BUS_BUSY&bslash;n&quot;
comma
id|cmd-&gt;target
comma
id|cmd-&gt;pid
)paren
)paren
suffix:semicolon
id|ccb-&gt;status
op_assign
id|FREE
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DBG
c_func
(paren
id|DBG_QUEUE
comma
id|printk
c_func
(paren
l_string|&quot;Queued base %#.4x pid: %ld target: %x lun: %x &quot;
l_string|&quot;slot %d irq %d&bslash;n&quot;
comma
(paren
id|s32
)paren
id|sh-&gt;base
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|y
comma
id|sh-&gt;irq
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_QUEUE
op_logical_and
id|DBG_DELAY
comma
id|DELAY
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|eata_abort
r_int
id|eata_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|ulong
id|loop
op_assign
id|HZ
op_div
l_int|2
suffix:semicolon
id|ulong
id|flags
suffix:semicolon
r_int
id|x
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|sh
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;eata_abort called pid: %ld target: %x lun: %x&quot;
l_string|&quot; reason %x&bslash;n&quot;
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|cmd-&gt;abort_reason
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DELAY
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* Some interrupt controllers seem to loose interrupts */
r_for
c_loop
(paren
id|x
op_assign
l_int|1
comma
id|sh
op_assign
id|first_HBA
suffix:semicolon
id|x
op_le
id|registered_HBAs
suffix:semicolon
id|x
op_increment
comma
id|sh
op_assign
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|next
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
(paren
id|uint
)paren
id|sh-&gt;base
op_plus
id|HA_RAUXSTAT
)paren
op_amp
id|HA_AIRQ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eata_dma: scsi%d interrupt pending in eata_abort.&bslash;n&quot;
l_string|&quot;          Calling interrupt handler.&bslash;n&quot;
comma
id|sh-&gt;host_no
)paren
suffix:semicolon
id|eata_int_handler
c_func
(paren
id|sh-&gt;irq
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|inb
c_func
(paren
(paren
id|u32
)paren
(paren
id|cmd-&gt;host-&gt;base
)paren
op_plus
id|HA_RAUXSTAT
)paren
op_amp
id|HA_ABUSY
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|loop
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eata_dma: abort, timeout error.&bslash;n&quot;
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DELAY
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
id|SCSI_ABORT_ERROR
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|CD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|status
op_eq
id|RESET
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eata_dma: abort, command reset error.&bslash;n&quot;
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DELAY
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
id|SCSI_ABORT_ERROR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|status
op_eq
id|LOCKED
)paren
(brace
id|DBG
c_func
(paren
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;eata_dma: abort, queue slot locked.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DELAY
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
id|SCSI_ABORT_NOT_RUNNING
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|status
op_eq
id|USED
)paren
(brace
id|DBG
c_func
(paren
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;Returning: SCSI_ABORT_BUSY&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
id|SCSI_ABORT_BUSY
)paren
suffix:semicolon
multiline_comment|/* SNOOZE */
)brace
r_if
c_cond
(paren
id|CD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|status
op_eq
id|FREE
)paren
(brace
id|DBG
c_func
(paren
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;Returning: SCSI_ABORT_NOT_RUNNING&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
id|SCSI_ABORT_NOT_RUNNING
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;eata_dma: abort: invalid slot status&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|eata_reset
r_int
id|eata_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_int
id|resetflags
)paren
(brace
id|uint
id|x
suffix:semicolon
multiline_comment|/* 10 million PCI reads take at least one third of a second */
id|ulong
id|loop
op_assign
l_int|10
op_star
l_int|1000
op_star
l_int|1000
suffix:semicolon
id|ulong
id|flags
suffix:semicolon
id|unchar
id|success
op_assign
id|FALSE
suffix:semicolon
id|Scsi_Cmnd
op_star
id|sp
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|sh
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;eata_reset called pid:%ld target: %x lun: %x&quot;
l_string|&quot; reason %x&bslash;n&quot;
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|cmd-&gt;abort_reason
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|1
comma
id|sh
op_assign
id|first_HBA
suffix:semicolon
id|x
op_le
id|registered_HBAs
suffix:semicolon
id|x
op_increment
comma
id|sh
op_assign
id|SD
c_func
(paren
id|sh
)paren
op_member_access_from_pointer
id|next
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
(paren
id|uint
)paren
id|sh-&gt;base
op_plus
id|HA_RAUXSTAT
)paren
op_amp
id|HA_AIRQ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eata_dma: scsi%d interrupt pending in eata_reset.&bslash;n&quot;
l_string|&quot;          Calling interrupt handler.&bslash;n&quot;
comma
id|sh-&gt;host_no
)paren
suffix:semicolon
id|eata_int_handler
c_func
(paren
id|sh-&gt;irq
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|state
op_eq
id|RESET
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eata_reset: exit, already in reset.&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DELAY
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
r_return
(paren
id|SCSI_RESET_ERROR
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|inb
c_func
(paren
(paren
id|u32
)paren
(paren
id|cmd-&gt;host-&gt;base
)paren
op_plus
id|HA_RAUXSTAT
)paren
op_amp
id|HA_ABUSY
)paren
r_if
c_cond
(paren
op_decrement
id|loop
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eata_reset: exit, timeout error.&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DELAY
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
r_return
(paren
id|SCSI_RESET_ERROR
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|cmd-&gt;host-&gt;can_queue
suffix:semicolon
id|x
op_increment
)paren
(brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|ccb
(braket
id|x
)braket
dot
id|status
op_eq
id|FREE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|ccb
(braket
id|x
)braket
dot
id|status
op_eq
id|LOCKED
)paren
(brace
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|ccb
(braket
id|x
)braket
dot
id|status
op_assign
id|FREE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;eata_reset: locked slot %d forced free.&bslash;n&quot;
comma
id|x
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DELAY
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|sp
op_assign
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|ccb
(braket
id|x
)braket
dot
id|cmd
suffix:semicolon
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|ccb
(braket
id|x
)braket
dot
id|status
op_assign
id|RESET
suffix:semicolon
r_if
c_cond
(paren
id|sp
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;eata_reset: slot %d, sp==NULL.&bslash;n&quot;
comma
id|x
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;eata_reset: slot %d in reset, pid %ld.&bslash;n&quot;
comma
id|x
comma
id|sp-&gt;pid
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DELAY
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sp
op_eq
id|cmd
)paren
id|success
op_assign
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* hard reset the HBA  */
id|inb
c_func
(paren
(paren
id|u32
)paren
(paren
id|cmd-&gt;host-&gt;base
)paren
op_plus
id|HA_RSTATUS
)paren
suffix:semicolon
multiline_comment|/* This might cause trouble */
id|eata_send_command
c_func
(paren
l_int|0
comma
(paren
id|u32
)paren
id|cmd-&gt;host-&gt;base
comma
id|EATA_CMD_RESET
)paren
suffix:semicolon
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|state
op_assign
id|RESET
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;eata_reset: board reset done, enabling &quot;
l_string|&quot;interrupts.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|DELAY
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* In theorie we should get interrupts and set free all&n;&t;       * used queueslots */
id|DBG
c_func
(paren
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;eata_reset: interrupts disabled again.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DELAY
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|cmd-&gt;host-&gt;can_queue
suffix:semicolon
id|x
op_increment
)paren
(brace
multiline_comment|/* Skip slots already set free by interrupt and those that &n;         * are still LOCKED from the last reset */
r_if
c_cond
(paren
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|ccb
(braket
id|x
)braket
dot
id|status
op_ne
id|RESET
)paren
r_continue
suffix:semicolon
id|sp
op_assign
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|ccb
(braket
id|x
)braket
dot
id|cmd
suffix:semicolon
id|sp-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* This mailbox is still waiting for its interrupt */
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|ccb
(braket
id|x
)braket
dot
id|status
op_assign
id|LOCKED
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;eata_reset: slot %d locked, DID_RESET, pid %ld done.&bslash;n&quot;
comma
id|x
comma
id|sp-&gt;pid
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DELAY
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
id|sp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|sp
)paren
suffix:semicolon
)brace
id|HD
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|state
op_assign
id|FALSE
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|success
)paren
(brace
id|DBG
c_func
(paren
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;eata_reset: exit, pending.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DELAY
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
r_return
(paren
id|SCSI_RESET_PENDING
)paren
suffix:semicolon
)brace
r_else
(brace
id|DBG
c_func
(paren
id|DBG_ABNORM
comma
id|printk
c_func
(paren
l_string|&quot;eata_reset: exit, wakeup.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_ABNORM
op_logical_and
id|DBG_DELAY
comma
id|DELAY
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
r_return
(paren
id|SCSI_RESET_PUNT
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Here we try to determine the optimum queue depth for&n; * each attached device.&n; *&n; * At the moment the algorithm is rather simple&n; */
DECL|function|eata_select_queue_depths
r_static
r_void
id|eata_select_queue_depths
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
id|Scsi_Device
op_star
id|devicelist
)paren
(brace
id|Scsi_Device
op_star
id|device
suffix:semicolon
r_int
id|devcount
op_assign
l_int|0
suffix:semicolon
r_int
id|factor
op_assign
l_int|0
suffix:semicolon
macro_line|#if CRIPPLE_QUEUE    
r_for
c_loop
(paren
id|device
op_assign
id|devicelist
suffix:semicolon
id|device
op_ne
l_int|NULL
suffix:semicolon
id|device
op_assign
id|device-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;host
op_eq
id|host
)paren
(brace
id|device-&gt;queue_depth
op_assign
l_int|2
suffix:semicolon
)brace
)brace
macro_line|#else
multiline_comment|/* First we do a sample run go find out what we have */
r_for
c_loop
(paren
id|device
op_assign
id|devicelist
suffix:semicolon
id|device
op_ne
l_int|NULL
suffix:semicolon
id|device
op_assign
id|device-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;host
op_eq
id|host
)paren
(brace
id|devcount
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|device-&gt;type
)paren
(brace
r_case
id|TYPE_DISK
suffix:colon
r_case
id|TYPE_MOD
suffix:colon
id|factor
op_add_assign
id|TYPE_DISK_QUEUE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_TAPE
suffix:colon
id|factor
op_add_assign
id|TYPE_TAPE_QUEUE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_WORM
suffix:colon
r_case
id|TYPE_ROM
suffix:colon
id|factor
op_add_assign
id|TYPE_ROM_QUEUE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_PROCESSOR
suffix:colon
r_case
id|TYPE_SCANNER
suffix:colon
r_default
suffix:colon
id|factor
op_add_assign
id|TYPE_OTHER_QUEUE
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|DBG
c_func
(paren
id|DBG_REGISTER
comma
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;scsi%d: needed queueslots %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|factor
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|factor
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We don&squot;t want to get a DIV BY ZERO error */
id|factor
op_assign
l_int|1
suffix:semicolon
)brace
id|factor
op_assign
(paren
id|SD
c_func
(paren
id|host
)paren
op_member_access_from_pointer
id|queuesize
op_star
l_int|10
)paren
op_div
id|factor
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_REGISTER
comma
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;scsi%d: using factor %dE-1&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|factor
)paren
)paren
suffix:semicolon
multiline_comment|/* Now that have the factor we can set the individual queuesizes */
r_for
c_loop
(paren
id|device
op_assign
id|devicelist
suffix:semicolon
id|device
op_ne
l_int|NULL
suffix:semicolon
id|device
op_assign
id|device-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;host
op_eq
id|host
)paren
(brace
r_if
c_cond
(paren
id|SD
c_func
(paren
id|device-&gt;host
)paren
op_member_access_from_pointer
id|bustype
op_ne
id|IS_ISA
)paren
(brace
r_switch
c_cond
(paren
id|device-&gt;type
)paren
(brace
r_case
id|TYPE_DISK
suffix:colon
r_case
id|TYPE_MOD
suffix:colon
id|device-&gt;queue_depth
op_assign
(paren
id|TYPE_DISK_QUEUE
op_star
id|factor
)paren
op_div
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_TAPE
suffix:colon
id|device-&gt;queue_depth
op_assign
(paren
id|TYPE_TAPE_QUEUE
op_star
id|factor
)paren
op_div
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_WORM
suffix:colon
r_case
id|TYPE_ROM
suffix:colon
id|device-&gt;queue_depth
op_assign
(paren
id|TYPE_ROM_QUEUE
op_star
id|factor
)paren
op_div
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_PROCESSOR
suffix:colon
r_case
id|TYPE_SCANNER
suffix:colon
r_default
suffix:colon
id|device-&gt;queue_depth
op_assign
(paren
id|TYPE_OTHER_QUEUE
op_star
id|factor
)paren
op_div
l_int|10
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* ISA forces us to limit the queue depth because of the &n;&t;&t;    * bounce buffer memory overhead. I know this is cruel */
id|device-&gt;queue_depth
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* &n;&t;     * It showed that we need to set an upper limit of commands &n;             * we can allow to  queue for a single device on the bus. &n;&t;     * If we get above that limit, the broken midlevel SCSI code &n;&t;     * will produce bogus timeouts and aborts en masse. :-(&n;&t;     */
r_if
c_cond
(paren
id|device-&gt;queue_depth
OG
id|UPPER_DEVICE_QUEUE_LIMIT
)paren
(brace
id|device-&gt;queue_depth
op_assign
id|UPPER_DEVICE_QUEUE_LIMIT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|device-&gt;queue_depth
op_eq
l_int|0
)paren
(brace
id|device-&gt;queue_depth
op_assign
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi%d: queue depth for target %d on channel %d &quot;
l_string|&quot;set to %d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|device-&gt;id
comma
id|device-&gt;channel
comma
id|device-&gt;queue_depth
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
macro_line|#if CHECK_BLINK
DECL|function|check_blink_state
r_int
id|check_blink_state
c_func
(paren
r_int
id|base
)paren
(brace
id|ushort
id|loops
op_assign
l_int|10
suffix:semicolon
id|u32
id|blinkindicator
suffix:semicolon
id|u32
id|state
op_assign
l_int|0x12345678
suffix:semicolon
id|u32
id|oldstate
op_assign
l_int|0
suffix:semicolon
id|blinkindicator
op_assign
id|htonl
c_func
(paren
l_int|0x54504442
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|loops
op_decrement
)paren
op_logical_and
(paren
id|state
op_ne
id|oldstate
)paren
)paren
(brace
id|oldstate
op_assign
id|state
suffix:semicolon
id|state
op_assign
id|inl
c_func
(paren
(paren
id|uint
)paren
id|base
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|DBG
c_func
(paren
id|DBG_BLINK
comma
id|printk
c_func
(paren
l_string|&quot;Did Blink check. Status: %d&bslash;n&quot;
comma
(paren
id|state
op_eq
id|oldstate
)paren
op_logical_and
(paren
id|state
op_eq
id|blinkindicator
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|state
op_eq
id|oldstate
)paren
op_logical_and
(paren
id|state
op_eq
id|blinkindicator
)paren
)paren
r_return
id|TRUE
suffix:semicolon
r_else
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|get_board_data
r_char
op_star
id|get_board_data
c_func
(paren
id|u32
id|base
comma
id|u32
id|irq
comma
id|u32
id|id
)paren
(brace
r_struct
id|eata_ccb
op_star
id|cp
suffix:semicolon
r_struct
id|eata_sp
op_star
id|sp
suffix:semicolon
r_static
r_char
op_star
id|buff
suffix:semicolon
id|ulong
id|i
suffix:semicolon
id|cp
op_assign
(paren
r_struct
id|eata_ccb
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|eata_ccb
)paren
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|sp
op_assign
(paren
r_struct
id|eata_sp
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|eata_sp
)paren
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sp
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|cp
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|buff
op_assign
id|dma_scratch
suffix:semicolon
id|memset
c_func
(paren
id|cp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|eata_ccb
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|sp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|eata_sp
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|buff
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
id|cp-&gt;DataIn
op_assign
id|TRUE
suffix:semicolon
id|cp-&gt;Interpret
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Interpret command */
id|cp-&gt;cp_dispri
op_assign
id|TRUE
suffix:semicolon
id|cp-&gt;cp_identify
op_assign
id|TRUE
suffix:semicolon
id|cp-&gt;cp_datalen
op_assign
id|htonl
c_func
(paren
l_int|56
)paren
suffix:semicolon
id|cp-&gt;cp_dataDMA
op_assign
id|htonl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|buff
)paren
)paren
suffix:semicolon
id|cp-&gt;cp_statDMA
op_assign
id|htonl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|sp
)paren
)paren
suffix:semicolon
id|cp-&gt;cp_viraddr
op_assign
id|cp
suffix:semicolon
id|cp-&gt;cp_id
op_assign
id|id
suffix:semicolon
id|cp-&gt;cp_lun
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;cp_cdb
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|cp-&gt;cp_cdb
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;cp_cdb
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;cp_cdb
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;cp_cdb
(braket
l_int|4
)braket
op_assign
l_int|56
suffix:semicolon
id|cp-&gt;cp_cdb
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|fake_int_base
op_assign
(paren
r_struct
id|eata_register
op_star
)paren
id|base
suffix:semicolon
id|fake_int_result
op_assign
id|FALSE
suffix:semicolon
id|fake_int_happened
op_assign
id|FALSE
suffix:semicolon
id|eata_send_command
c_func
(paren
(paren
id|u32
)paren
id|cp
comma
(paren
id|u32
)paren
id|base
comma
id|EATA_CMD_DMA_SEND_CP
)paren
suffix:semicolon
id|i
op_assign
id|jiffies
op_plus
(paren
l_int|3
op_star
id|HZ
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fake_int_happened
op_eq
id|FALSE
op_logical_and
id|time_before_eq
c_func
(paren
id|jiffies
comma
id|i
)paren
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_INTR3
comma
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;fake_int_result: %#x hbastat %#x &quot;
l_string|&quot;scsistat %#x, buff %p sp %p&bslash;n&quot;
comma
id|fake_int_result
comma
(paren
id|u32
)paren
(paren
id|sp-&gt;hba_stat
multiline_comment|/*&amp; 0x7f*/
)paren
comma
(paren
id|u32
)paren
id|sp-&gt;scsi_stat
comma
id|buff
comma
id|sp
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
(paren
r_void
op_star
)paren
id|cp
)paren
suffix:semicolon
id|kfree
c_func
(paren
(paren
r_void
op_star
)paren
id|sp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fake_int_result
op_amp
id|HA_SERROR
)paren
op_logical_or
id|time_after
c_func
(paren
id|jiffies
comma
id|i
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;eata_dma: trying to reset HBA at %x to clear &quot;
l_string|&quot;possible blink state&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
multiline_comment|/* hard reset the HBA  */
id|inb
c_func
(paren
(paren
id|u32
)paren
(paren
id|base
)paren
op_plus
id|HA_RSTATUS
)paren
suffix:semicolon
id|eata_send_command
c_func
(paren
l_int|0
comma
id|base
comma
id|EATA_CMD_RESET
)paren
suffix:semicolon
id|DELAY
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
r_return
(paren
id|buff
)paren
suffix:semicolon
)brace
DECL|function|get_conf_PIO
r_int
id|get_conf_PIO
c_func
(paren
id|u32
id|base
comma
r_struct
id|get_conf
op_star
id|buf
)paren
(brace
id|ulong
id|loop
op_assign
id|R_LIMIT
suffix:semicolon
id|u16
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|base
comma
l_int|9
)paren
)paren
(brace
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|get_conf
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|base
op_plus
id|HA_RSTATUS
)paren
op_amp
id|HA_SBUSY
)paren
r_if
c_cond
(paren
op_decrement
id|loop
op_eq
l_int|0
)paren
r_return
(paren
id|FALSE
)paren
suffix:semicolon
id|fake_int_base
op_assign
(paren
r_struct
id|eata_register
op_star
)paren
id|base
suffix:semicolon
id|fake_int_result
op_assign
id|FALSE
suffix:semicolon
id|fake_int_happened
op_assign
id|FALSE
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_PIO
op_logical_and
id|DBG_PROBE
comma
id|printk
c_func
(paren
l_string|&quot;Issuing PIO READ CONFIG to HBA at %#x&bslash;n&quot;
comma
id|base
)paren
)paren
suffix:semicolon
id|eata_send_command
c_func
(paren
l_int|0
comma
id|base
comma
id|EATA_CMD_PIO_READ_CONFIG
)paren
suffix:semicolon
id|loop
op_assign
id|R_LIMIT
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
(paren
id|u16
op_star
)paren
id|buf
suffix:semicolon
(paren
r_int
)paren
id|p
op_le
(paren
(paren
r_int
)paren
id|buf
op_plus
(paren
r_sizeof
(paren
r_struct
id|get_conf
)paren
op_div
l_int|2
)paren
)paren
suffix:semicolon
id|p
op_increment
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|base
op_plus
id|HA_RSTATUS
)paren
op_amp
id|HA_SDRQ
)paren
)paren
r_if
c_cond
(paren
op_decrement
id|loop
op_eq
l_int|0
)paren
r_return
(paren
id|FALSE
)paren
suffix:semicolon
id|loop
op_assign
id|R_LIMIT
suffix:semicolon
op_star
id|p
op_assign
id|inw
c_func
(paren
id|base
op_plus
id|HA_RDATA
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|base
op_plus
id|HA_RSTATUS
)paren
op_amp
id|HA_SERROR
)paren
)paren
(brace
multiline_comment|/* Error ? */
r_if
c_cond
(paren
id|htonl
c_func
(paren
id|EATA_SIGNATURE
)paren
op_eq
id|buf-&gt;signature
)paren
(brace
id|DBG
c_func
(paren
id|DBG_PIO
op_logical_and
id|DBG_PROBE
comma
id|printk
c_func
(paren
l_string|&quot;EATA Controller found at %x &quot;
l_string|&quot;EATA Level: %x&bslash;n&quot;
comma
(paren
id|uint
)paren
id|base
comma
(paren
id|uint
)paren
(paren
id|buf-&gt;version
)paren
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|base
op_plus
id|HA_RSTATUS
)paren
op_amp
id|HA_SDRQ
)paren
id|inw
c_func
(paren
id|base
op_plus
id|HA_RDATA
)paren
suffix:semicolon
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|DBG
c_func
(paren
id|DBG_PROBE
comma
id|printk
c_func
(paren
l_string|&quot;eata_dma: get_conf_PIO, error during transfer &quot;
l_string|&quot;for HBA at %lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|base
)paren
)paren
suffix:semicolon
)brace
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
DECL|function|print_config
r_void
id|print_config
c_func
(paren
r_struct
id|get_conf
op_star
id|gc
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;LEN: %d ver:%d OCS:%d TAR:%d TRNXFR:%d MORES:%d DMAS:%d&bslash;n&quot;
comma
(paren
id|u32
)paren
id|ntohl
c_func
(paren
id|gc-&gt;len
)paren
comma
id|gc-&gt;version
comma
id|gc-&gt;OCS_enabled
comma
id|gc-&gt;TAR_support
comma
id|gc-&gt;TRNXFR
comma
id|gc-&gt;MORE_support
comma
id|gc-&gt;DMA_support
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;DMAV:%d HAAV:%d SCSIID0:%d ID1:%d ID2:%d QUEUE:%d SG:%d SEC:%d&bslash;n&quot;
comma
id|gc-&gt;DMA_valid
comma
id|gc-&gt;HAA_valid
comma
id|gc-&gt;scsi_id
(braket
l_int|3
)braket
comma
id|gc-&gt;scsi_id
(braket
l_int|2
)braket
comma
id|gc-&gt;scsi_id
(braket
l_int|1
)braket
comma
id|ntohs
c_func
(paren
id|gc-&gt;queuesiz
)paren
comma
id|ntohs
c_func
(paren
id|gc-&gt;SGsiz
)paren
comma
id|gc-&gt;SECOND
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IRQ:%d IRQT:%d DMAC:%d FORCADR:%d SG_64K:%d SG_UAE:%d MID:%d &quot;
l_string|&quot;MCH:%d MLUN:%d&bslash;n&quot;
comma
id|gc-&gt;IRQ
comma
id|gc-&gt;IRQ_TR
comma
(paren
l_int|8
op_minus
id|gc-&gt;DMA_channel
)paren
op_amp
l_int|7
comma
id|gc-&gt;FORCADR
comma
id|gc-&gt;SG_64K
comma
id|gc-&gt;SG_UAE
comma
id|gc-&gt;MAX_ID
comma
id|gc-&gt;MAX_CHAN
comma
id|gc-&gt;MAX_LUN
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RIDQ:%d PCI:%d EISA:%d&bslash;n&quot;
comma
id|gc-&gt;ID_qest
comma
id|gc-&gt;is_PCI
comma
id|gc-&gt;is_EISA
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DPT_DEBUG
comma
id|DELAY
c_func
(paren
l_int|14
)paren
)paren
suffix:semicolon
)brace
DECL|function|register_HBA
r_int
id|register_HBA
c_func
(paren
id|u32
id|base
comma
r_struct
id|get_conf
op_star
id|gc
comma
id|Scsi_Host_Template
op_star
id|tpnt
comma
id|u8
id|bustype
)paren
(brace
id|ulong
id|size
op_assign
l_int|0
suffix:semicolon
id|unchar
id|dma_channel
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|buff
op_assign
l_int|0
suffix:semicolon
id|unchar
id|bugs
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|sh
suffix:semicolon
id|hostdata
op_star
id|hd
suffix:semicolon
r_int
id|x
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_REGISTER
comma
id|print_config
c_func
(paren
id|gc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gc-&gt;DMA_support
op_eq
id|FALSE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;The EATA HBA at %#.4x does not support DMA.&bslash;n&quot;
l_string|&quot;Please use the EATA-PIO driver.&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gc-&gt;HAA_valid
op_eq
id|FALSE
op_logical_or
id|ntohl
c_func
(paren
id|gc-&gt;len
)paren
OL
l_int|0x22
)paren
(brace
id|gc-&gt;MAX_CHAN
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reg_IRQ
(braket
id|gc-&gt;IRQ
)braket
op_eq
id|FALSE
)paren
(brace
multiline_comment|/* Interrupt already registered ? */
r_if
c_cond
(paren
op_logical_neg
id|request_irq
c_func
(paren
id|gc-&gt;IRQ
comma
(paren
r_void
op_star
)paren
id|eata_fake_int_handler
comma
id|SA_INTERRUPT
comma
l_string|&quot;eata_dma&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|reg_IRQ
(braket
id|gc-&gt;IRQ
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gc-&gt;IRQ_TR
)paren
id|reg_IRQL
(braket
id|gc-&gt;IRQ
)braket
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* IRQ is edge triggered */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Couldn&squot;t allocate IRQ %d, Sorry.&quot;
comma
id|gc-&gt;IRQ
)paren
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* More than one HBA on this IRQ */
r_if
c_cond
(paren
id|reg_IRQL
(braket
id|gc-&gt;IRQ
)braket
op_eq
id|TRUE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Can&squot;t support more than one HBA on this IRQ,&bslash;n&quot;
l_string|&quot;  if the IRQ is edge triggered. Sorry.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
r_else
id|reg_IRQ
(braket
id|gc-&gt;IRQ
)braket
op_increment
suffix:semicolon
)brace
multiline_comment|/* If DMA is supported but DMA_valid isn&squot;t set to indicate that&n;     * the channel number is given we must have pre 2.0 firmware (1.7?)&n;     * which leaves us to guess since the &quot;newer ones&quot; also don&squot;t set the &n;     * DMA_valid bit.&n;     */
r_if
c_cond
(paren
id|gc-&gt;DMA_support
op_logical_and
op_logical_neg
id|gc-&gt;DMA_valid
op_logical_and
id|gc-&gt;DMA_channel
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;eata_dma: If you are using a pre 2.0 firmware &quot;
l_string|&quot;please update it !&bslash;n&quot;
l_string|&quot;          You can get new firmware releases from ftp.dpt.com&bslash;n&quot;
)paren
suffix:semicolon
id|gc-&gt;DMA_channel
op_assign
(paren
id|base
op_eq
l_int|0x1f0
ques
c_cond
l_int|3
multiline_comment|/* DMA=5 */
suffix:colon
l_int|2
multiline_comment|/* DMA=6 */
)paren
suffix:semicolon
id|gc-&gt;DMA_valid
op_assign
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* if gc-&gt;DMA_valid it must be an ISA HBA and we have to register it */
id|dma_channel
op_assign
id|BUSMASTER
suffix:semicolon
r_if
c_cond
(paren
id|gc-&gt;DMA_valid
)paren
(brace
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|dma_channel
op_assign
(paren
l_int|8
op_minus
id|gc-&gt;DMA_channel
)paren
op_amp
l_int|7
comma
l_string|&quot;eata_dma&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Unable to allocate DMA channel %d for ISA HBA&quot;
l_string|&quot; at %#.4x.&bslash;n&quot;
comma
id|dma_channel
comma
id|base
)paren
suffix:semicolon
id|reg_IRQ
(braket
id|gc-&gt;IRQ
)braket
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|reg_IRQ
(braket
id|gc-&gt;IRQ
)braket
op_eq
l_int|0
)paren
id|free_irq
c_func
(paren
id|gc-&gt;IRQ
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gc-&gt;IRQ_TR
op_eq
id|FALSE
)paren
id|reg_IRQL
(braket
id|gc-&gt;IRQ
)braket
op_assign
id|FALSE
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dma_channel
op_ne
id|BUSMASTER
)paren
(brace
id|disable_dma
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|dma_channel
comma
id|DMA_MODE_CASCADE
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bustype
op_ne
id|IS_EISA
op_logical_and
id|bustype
op_ne
id|IS_ISA
)paren
id|buff
op_assign
id|get_board_data
c_func
(paren
id|base
comma
id|gc-&gt;IRQ
comma
id|gc-&gt;scsi_id
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|bustype
op_eq
id|IS_EISA
op_logical_or
id|bustype
op_eq
id|IS_ISA
)paren
(brace
id|bugs
op_assign
id|bugs
op_logical_or
id|BROKEN_INQUIRY
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|gc-&gt;DMA_support
op_eq
id|FALSE
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;HBA at %#.4x doesn&squot;t support DMA. &quot;
l_string|&quot;Sorry&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;HBA at %#.4x does not react on INQUIRY. &quot;
l_string|&quot;Sorry.&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gc-&gt;DMA_valid
)paren
id|free_dma
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
id|reg_IRQ
(braket
id|gc-&gt;IRQ
)braket
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|reg_IRQ
(braket
id|gc-&gt;IRQ
)braket
op_eq
l_int|0
)paren
id|free_irq
c_func
(paren
id|gc-&gt;IRQ
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gc-&gt;IRQ_TR
op_eq
id|FALSE
)paren
id|reg_IRQL
(braket
id|gc-&gt;IRQ
)braket
op_assign
id|FALSE
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|gc-&gt;DMA_support
op_eq
id|FALSE
op_logical_and
id|buff
op_ne
l_int|NULL
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;HBA %.12sat %#.4x doesn&squot;t set the DMA_support &quot;
l_string|&quot;flag correctly.&bslash;n&quot;
comma
op_amp
id|buff
(braket
l_int|16
)braket
comma
id|base
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|base
comma
l_int|9
comma
l_string|&quot;eata_dma&quot;
)paren
suffix:semicolon
multiline_comment|/* We already checked the &n;&t;&t;&t;&t;&t;  * availability, so this&n;&t;&t;&t;&t;&t;  * should not fail.&n;&t;&t;&t;&t;&t;  */
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|gc-&gt;queuesiz
)paren
op_eq
l_int|0
)paren
(brace
id|gc-&gt;queuesiz
op_assign
id|ntohs
c_func
(paren
l_int|64
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Warning: Queue size has to be corrected. Assuming&quot;
l_string|&quot; 64 queueslots&bslash;n&quot;
l_string|&quot;         This might be a PM2012B with a defective Firmware&bslash;n&quot;
l_string|&quot;         Contact DPT support@dpt.com for an upgrade&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|size
op_assign
r_sizeof
(paren
id|hostdata
)paren
op_plus
(paren
(paren
r_sizeof
(paren
r_struct
id|eata_ccb
)paren
op_plus
r_sizeof
(paren
r_int
)paren
)paren
op_star
id|ntohs
c_func
(paren
id|gc-&gt;queuesiz
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_REGISTER
comma
id|printk
c_func
(paren
l_string|&quot;scsi_register size: %ld&bslash;n&quot;
comma
id|size
)paren
)paren
suffix:semicolon
id|sh
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh
op_ne
l_int|NULL
)paren
(brace
id|hd
op_assign
id|SD
c_func
(paren
id|sh
)paren
suffix:semicolon
id|memset
c_func
(paren
id|hd-&gt;reads
comma
l_int|0
comma
r_sizeof
(paren
id|u32
)paren
op_star
l_int|26
)paren
suffix:semicolon
id|sh-&gt;select_queue_depths
op_assign
id|eata_select_queue_depths
suffix:semicolon
id|hd-&gt;bustype
op_assign
id|bustype
suffix:semicolon
multiline_comment|/*&n;&t; * If we are using a ISA board, we can&squot;t use extended SG,&n;&t; * because we would need excessive amounts of memory for&n;&t; * bounce buffers.&n;&t; */
r_if
c_cond
(paren
id|gc-&gt;SG_64K
op_eq
id|TRUE
op_logical_and
id|ntohs
c_func
(paren
id|gc-&gt;SGsiz
)paren
op_eq
l_int|64
op_logical_and
id|hd-&gt;bustype
op_ne
id|IS_ISA
)paren
(brace
id|sh-&gt;sg_tablesize
op_assign
id|SG_SIZE_BIG
suffix:semicolon
)brace
r_else
(brace
id|sh-&gt;sg_tablesize
op_assign
id|ntohs
c_func
(paren
id|gc-&gt;SGsiz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh-&gt;sg_tablesize
OG
id|SG_SIZE
op_logical_or
id|sh-&gt;sg_tablesize
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sh-&gt;sg_tablesize
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Warning: SG size had to be fixed.&bslash;n&quot;
l_string|&quot;This might be a PM2012 with a defective Firmware&quot;
l_string|&quot;&bslash;nContact DPT support@dpt.com for an upgrade&bslash;n&quot;
)paren
suffix:semicolon
id|sh-&gt;sg_tablesize
op_assign
id|SG_SIZE
suffix:semicolon
)brace
)brace
id|hd-&gt;sgsize
op_assign
id|sh-&gt;sg_tablesize
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sh
op_ne
l_int|NULL
)paren
(brace
id|sh-&gt;can_queue
op_assign
id|hd-&gt;queuesize
op_assign
id|ntohs
c_func
(paren
id|gc-&gt;queuesiz
)paren
suffix:semicolon
id|sh-&gt;cmd_per_lun
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sh
op_eq
l_int|NULL
)paren
(brace
id|DBG
c_func
(paren
id|DBG_REGISTER
comma
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;eata_dma: couldn&squot;t register HBA&quot;
l_string|&quot; at%x &bslash;n&quot;
comma
id|base
)paren
)paren
suffix:semicolon
id|scsi_unregister
c_func
(paren
id|sh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gc-&gt;DMA_valid
)paren
id|free_dma
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
id|reg_IRQ
(braket
id|gc-&gt;IRQ
)braket
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|reg_IRQ
(braket
id|gc-&gt;IRQ
)braket
op_eq
l_int|0
)paren
id|free_irq
c_func
(paren
id|gc-&gt;IRQ
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gc-&gt;IRQ_TR
op_eq
id|FALSE
)paren
id|reg_IRQL
(braket
id|gc-&gt;IRQ
)braket
op_assign
id|FALSE
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
id|hd-&gt;broken_INQUIRY
op_assign
(paren
id|bugs
op_amp
id|BROKEN_INQUIRY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;broken_INQUIRY
op_eq
id|TRUE
)paren
(brace
id|strcpy
c_func
(paren
id|hd-&gt;vendor
comma
l_string|&quot;DPT&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|hd-&gt;name
comma
l_string|&quot;??????????&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|hd-&gt;revision
comma
l_string|&quot;???.?&quot;
)paren
suffix:semicolon
id|hd-&gt;firmware_revision
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|strncpy
c_func
(paren
id|hd-&gt;vendor
comma
op_amp
id|buff
(braket
l_int|8
)braket
comma
l_int|8
)paren
suffix:semicolon
id|hd-&gt;vendor
(braket
l_int|8
)braket
op_assign
l_int|0
suffix:semicolon
id|strncpy
c_func
(paren
id|hd-&gt;name
comma
op_amp
id|buff
(braket
l_int|16
)braket
comma
l_int|17
)paren
suffix:semicolon
id|hd-&gt;name
(braket
l_int|17
)braket
op_assign
l_int|0
suffix:semicolon
id|hd-&gt;revision
(braket
l_int|0
)braket
op_assign
id|buff
(braket
l_int|32
)braket
suffix:semicolon
id|hd-&gt;revision
(braket
l_int|1
)braket
op_assign
id|buff
(braket
l_int|33
)braket
suffix:semicolon
id|hd-&gt;revision
(braket
l_int|2
)braket
op_assign
id|buff
(braket
l_int|34
)braket
suffix:semicolon
id|hd-&gt;revision
(braket
l_int|3
)braket
op_assign
l_char|&squot;.&squot;
suffix:semicolon
id|hd-&gt;revision
(braket
l_int|4
)braket
op_assign
id|buff
(braket
l_int|35
)braket
suffix:semicolon
id|hd-&gt;revision
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|hd-&gt;firmware_revision
op_assign
(paren
id|buff
(braket
l_int|32
)braket
op_lshift
l_int|24
)paren
op_plus
(paren
id|buff
(braket
l_int|33
)braket
op_lshift
l_int|16
)paren
op_plus
(paren
id|buff
(braket
l_int|34
)braket
op_lshift
l_int|8
)paren
op_plus
id|buff
(braket
l_int|35
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hd-&gt;firmware_revision
op_ge
(paren
(paren
l_char|&squot;0&squot;
op_lshift
l_int|24
)paren
op_plus
(paren
l_char|&squot;7&squot;
op_lshift
l_int|16
)paren
op_plus
(paren
l_char|&squot;G&squot;
op_lshift
l_int|8
)paren
op_plus
l_char|&squot;0&squot;
)paren
)paren
id|hd-&gt;immediate_support
op_assign
l_int|1
suffix:semicolon
r_else
id|hd-&gt;immediate_support
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|ntohl
c_func
(paren
id|gc-&gt;len
)paren
)paren
(brace
r_case
l_int|0x1c
suffix:colon
id|hd-&gt;EATA_revision
op_assign
l_char|&squot;a&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1e
suffix:colon
id|hd-&gt;EATA_revision
op_assign
l_char|&squot;b&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x22
suffix:colon
id|hd-&gt;EATA_revision
op_assign
l_char|&squot;c&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x24
suffix:colon
id|hd-&gt;EATA_revision
op_assign
l_char|&squot;z&squot;
suffix:semicolon
r_default
suffix:colon
id|hd-&gt;EATA_revision
op_assign
l_char|&squot;?&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|gc-&gt;len
)paren
op_ge
l_int|0x22
)paren
(brace
id|sh-&gt;max_id
op_assign
id|gc-&gt;MAX_ID
op_plus
l_int|1
suffix:semicolon
id|sh-&gt;max_lun
op_assign
id|gc-&gt;MAX_LUN
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|sh-&gt;max_id
op_assign
l_int|8
suffix:semicolon
id|sh-&gt;max_lun
op_assign
l_int|8
suffix:semicolon
)brace
id|hd-&gt;HBA_number
op_assign
id|sh-&gt;host_no
suffix:semicolon
id|hd-&gt;channel
op_assign
id|gc-&gt;MAX_CHAN
suffix:semicolon
id|sh-&gt;max_channel
op_assign
id|gc-&gt;MAX_CHAN
suffix:semicolon
id|sh-&gt;unique_id
op_assign
id|base
suffix:semicolon
id|sh-&gt;base
op_assign
id|base
suffix:semicolon
id|sh-&gt;io_port
op_assign
id|base
suffix:semicolon
id|sh-&gt;n_io_port
op_assign
l_int|9
suffix:semicolon
id|sh-&gt;irq
op_assign
id|gc-&gt;IRQ
suffix:semicolon
id|sh-&gt;dma_channel
op_assign
id|dma_channel
suffix:semicolon
multiline_comment|/* FIXME:&n;     * SCSI midlevel code should support different HBA ids on every channel&n;     */
id|sh-&gt;this_id
op_assign
id|gc-&gt;scsi_id
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|gc-&gt;SECOND
)paren
id|hd-&gt;primary
op_assign
id|FALSE
suffix:semicolon
r_else
id|hd-&gt;primary
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;bustype
op_ne
id|IS_ISA
)paren
(brace
id|sh-&gt;unchecked_isa_dma
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
id|sh-&gt;unchecked_isa_dma
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* We&squot;re doing ISA DMA */
)brace
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
op_le
l_int|11
suffix:semicolon
id|x
op_increment
)paren
(brace
multiline_comment|/* Initialize min. latency */
id|hd-&gt;writes_lat
(braket
id|x
)braket
(braket
l_int|1
)braket
op_assign
l_int|0xffffffff
suffix:semicolon
id|hd-&gt;reads_lat
(braket
id|x
)braket
(braket
l_int|1
)braket
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
id|hd-&gt;all_lat
(braket
l_int|1
)braket
op_assign
l_int|0xffffffff
suffix:semicolon
id|hd-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* build a linked list of all HBAs */
id|hd-&gt;prev
op_assign
id|last_HBA
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;prev
op_ne
l_int|NULL
)paren
(brace
id|SD
c_func
(paren
id|hd-&gt;prev
)paren
op_member_access_from_pointer
id|next
op_assign
id|sh
suffix:semicolon
)brace
id|last_HBA
op_assign
id|sh
suffix:semicolon
r_if
c_cond
(paren
id|first_HBA
op_eq
l_int|NULL
)paren
id|first_HBA
op_assign
id|sh
suffix:semicolon
id|registered_HBAs
op_increment
suffix:semicolon
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
DECL|function|find_EISA
r_void
id|find_EISA
c_func
(paren
r_struct
id|get_conf
op_star
id|buf
comma
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
id|u32
id|base
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#if CHECKPAL
id|u8
id|pal1
comma
id|pal2
comma
id|pal3
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAXEISA
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|EISAbases
(braket
id|i
)braket
op_eq
id|TRUE
)paren
(brace
multiline_comment|/* Still a possibility ?&t;      */
id|base
op_assign
l_int|0x1c88
op_plus
(paren
id|i
op_star
l_int|0x1000
)paren
suffix:semicolon
macro_line|#if CHECKPAL
id|pal1
op_assign
id|inb
c_func
(paren
(paren
id|u16
)paren
id|base
op_minus
l_int|8
)paren
suffix:semicolon
id|pal2
op_assign
id|inb
c_func
(paren
(paren
id|u16
)paren
id|base
op_minus
l_int|7
)paren
suffix:semicolon
id|pal3
op_assign
id|inb
c_func
(paren
(paren
id|u16
)paren
id|base
op_minus
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|pal1
op_eq
id|DPT_ID1
)paren
op_logical_and
(paren
id|pal2
op_eq
id|DPT_ID2
)paren
)paren
op_logical_or
(paren
(paren
id|pal1
op_eq
id|NEC_ID1
)paren
op_logical_and
(paren
id|pal2
op_eq
id|NEC_ID2
)paren
op_logical_and
(paren
id|pal3
op_eq
id|NEC_ID3
)paren
)paren
op_logical_or
(paren
(paren
id|pal1
op_eq
id|ATT_ID1
)paren
op_logical_and
(paren
id|pal2
op_eq
id|ATT_ID2
)paren
op_logical_and
(paren
id|pal3
op_eq
id|ATT_ID3
)paren
)paren
)paren
(brace
id|DBG
c_func
(paren
id|DBG_PROBE
comma
id|printk
c_func
(paren
l_string|&quot;EISA EATA id tags found: %x %x %x &bslash;n&quot;
comma
(paren
r_int
)paren
id|pal1
comma
(paren
r_int
)paren
id|pal2
comma
(paren
r_int
)paren
id|pal3
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|get_conf_PIO
c_func
(paren
id|base
comma
id|buf
)paren
op_eq
id|TRUE
)paren
(brace
r_if
c_cond
(paren
id|buf-&gt;IRQ
)paren
(brace
id|DBG
c_func
(paren
id|DBG_EISA
comma
id|printk
c_func
(paren
l_string|&quot;Registering EISA HBA&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|register_HBA
c_func
(paren
id|base
comma
id|buf
comma
id|tpnt
comma
id|IS_EISA
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;eata_dma: No valid IRQ. HBA removed from list&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#if CHECK_BLINK
r_else
(brace
r_if
c_cond
(paren
id|check_blink_state
c_func
(paren
id|base
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;HBA is in BLINK state. Consult your HBAs &quot;
l_string|&quot;Manual to correct this.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Nothing found here so we take it from the list */
id|EISAbases
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#if CHECKPAL
)brace
macro_line|#endif
)brace
)brace
r_return
suffix:semicolon
)brace
DECL|function|find_ISA
r_void
id|find_ISA
c_func
(paren
r_struct
id|get_conf
op_star
id|buf
comma
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAXISA
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ISAbases
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
id|get_conf_PIO
c_func
(paren
id|ISAbases
(braket
id|i
)braket
comma
id|buf
)paren
op_eq
id|TRUE
)paren
(brace
id|DBG
c_func
(paren
id|DBG_ISA
comma
id|printk
c_func
(paren
l_string|&quot;Registering ISA HBA&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|register_HBA
c_func
(paren
id|ISAbases
(braket
id|i
)braket
comma
id|buf
comma
id|tpnt
comma
id|IS_ISA
)paren
suffix:semicolon
)brace
macro_line|#if CHECK_BLINK
r_else
(brace
r_if
c_cond
(paren
id|check_blink_state
c_func
(paren
id|ISAbases
(braket
id|i
)braket
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;HBA is in BLINK state. Consult your HBAs &quot;
l_string|&quot;Manual to correct this.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ISAbases
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
DECL|function|find_PCI
r_void
id|find_PCI
c_func
(paren
r_struct
id|get_conf
op_star
id|buf
comma
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
macro_line|#ifndef CONFIG_PCI
id|printk
c_func
(paren
l_string|&quot;eata_dma: kernel PCI support not enabled. Skipping scan for PCI HBAs.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
r_struct
id|pci_dev
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|u32
id|base
comma
id|x
suffix:semicolon
id|u8
id|pal1
comma
id|pal2
comma
id|pal3
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_DPT
comma
id|PCI_DEVICE_ID_DPT
comma
id|dev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|DBG
c_func
(paren
id|DBG_PROBE
op_logical_and
id|DBG_PCI
comma
id|printk
c_func
(paren
l_string|&quot;eata_dma: find_PCI, HBA at %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|dev
)paren
)paren
r_continue
suffix:semicolon
id|pci_set_master
c_func
(paren
id|dev
)paren
suffix:semicolon
id|base
op_assign
id|pci_resource_flags
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_amp
id|IORESOURCE_MEM
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eata_dma: invalid base address of device %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|base
op_assign
id|pci_resource_start
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* EISA tag there ? */
id|pal1
op_assign
id|inb
c_func
(paren
id|base
)paren
suffix:semicolon
id|pal2
op_assign
id|inb
c_func
(paren
id|base
op_plus
l_int|1
)paren
suffix:semicolon
id|pal3
op_assign
id|inb
c_func
(paren
id|base
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|pal1
op_eq
id|DPT_ID1
)paren
op_logical_and
(paren
id|pal2
op_eq
id|DPT_ID2
)paren
)paren
op_logical_or
(paren
(paren
id|pal1
op_eq
id|NEC_ID1
)paren
op_logical_and
(paren
id|pal2
op_eq
id|NEC_ID2
)paren
op_logical_and
(paren
id|pal3
op_eq
id|NEC_ID3
)paren
)paren
op_logical_or
(paren
(paren
id|pal1
op_eq
id|ATT_ID1
)paren
op_logical_and
(paren
id|pal2
op_eq
id|ATT_ID2
)paren
op_logical_and
(paren
id|pal3
op_eq
id|ATT_ID3
)paren
)paren
)paren
id|base
op_add_assign
l_int|0x08
suffix:semicolon
r_else
id|base
op_add_assign
l_int|0x10
suffix:semicolon
multiline_comment|/* Now, THIS is the real address */
r_if
c_cond
(paren
id|base
op_ne
l_int|0x1f8
)paren
(brace
multiline_comment|/* We didn&squot;t find it in the primary search */
r_if
c_cond
(paren
id|get_conf_PIO
c_func
(paren
id|base
comma
id|buf
)paren
op_eq
id|TRUE
)paren
(brace
multiline_comment|/* OK. We made it till here, so we can go now  &n;&t;&t;     * and register it. We only have to check and &n;&t;&t;     * eventually remove it from the EISA and ISA list &n;&t;&t;     */
id|DBG
c_func
(paren
id|DBG_PCI
comma
id|printk
c_func
(paren
l_string|&quot;Registering PCI HBA&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|register_HBA
c_func
(paren
id|base
comma
id|buf
comma
id|tpnt
comma
id|IS_PCI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
OL
l_int|0x1000
)paren
(brace
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|MAXISA
suffix:semicolon
op_increment
id|x
)paren
(brace
r_if
c_cond
(paren
id|ISAbases
(braket
id|x
)braket
op_eq
id|base
)paren
(brace
id|ISAbases
(braket
id|x
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|base
op_amp
l_int|0x0fff
)paren
op_eq
l_int|0x0c88
)paren
id|EISAbases
(braket
(paren
id|base
op_rshift
l_int|12
)paren
op_amp
l_int|0x0f
)braket
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if CHECK_BLINK
r_else
r_if
c_cond
(paren
id|check_blink_state
c_func
(paren
id|base
)paren
op_eq
id|TRUE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eata_dma: HBA is in BLINK state.&bslash;n&quot;
l_string|&quot;Consult your HBAs manual to correct this.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
)brace
macro_line|#endif /* #ifndef CONFIG_PCI */
)brace
DECL|function|eata_detect
r_int
id|eata_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|HBA_ptr
suffix:semicolon
r_struct
id|get_conf
id|gc
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DBG
c_func
(paren
(paren
id|DBG_PROBE
op_logical_and
id|DBG_DELAY
)paren
op_logical_or
id|DPT_DEBUG
comma
id|printk
c_func
(paren
l_string|&quot;Using lots of delays to let you read the debugging output&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|tpnt-&gt;proc_name
op_assign
l_string|&quot;eata_dma&quot;
suffix:semicolon
id|status
op_assign
id|kmalloc
c_func
(paren
l_int|512
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
id|dma_scratch
op_assign
id|kmalloc
c_func
(paren
l_int|1024
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|NULL
op_logical_or
id|dma_scratch
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eata_dma: can&squot;t allocate enough memory to probe for hosts !&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|kfree
c_func
(paren
id|status
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dma_scratch
)paren
(brace
id|kfree
c_func
(paren
id|dma_scratch
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|dma_scratch
op_add_assign
l_int|4
suffix:semicolon
id|find_PCI
c_func
(paren
op_amp
id|gc
comma
id|tpnt
)paren
suffix:semicolon
id|find_EISA
c_func
(paren
op_amp
id|gc
comma
id|tpnt
)paren
suffix:semicolon
id|find_ISA
c_func
(paren
op_amp
id|gc
comma
id|tpnt
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|MAXIRQ
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Now that we know what we have, we     */
r_if
c_cond
(paren
id|reg_IRQ
(braket
id|i
)braket
op_ge
l_int|1
)paren
(brace
multiline_comment|/* exchange the interrupt handler which  */
id|free_irq
c_func
(paren
id|i
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* we used for probing with the real one */
id|request_irq
c_func
(paren
id|i
comma
(paren
r_void
op_star
)paren
(paren
id|do_eata_int_handler
)paren
comma
id|SA_INTERRUPT
op_or
id|SA_SHIRQ
comma
l_string|&quot;eata_dma&quot;
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
id|HBA_ptr
op_assign
id|first_HBA
suffix:semicolon
r_if
c_cond
(paren
id|registered_HBAs
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;EATA (Extended Attachment) driver version: %d.%d%s&quot;
l_string|&quot;&bslash;ndeveloped in co-operation with DPT&bslash;n&quot;
l_string|&quot;(c) 1993-96 Michael Neuffer, mike@i-Connect.Net&bslash;n&quot;
comma
id|VER_MAJOR
comma
id|VER_MINOR
comma
id|VER_SUB
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Registered HBAs:&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nHBA no. Boardtype    Revis  EATA Bus  BaseIO IRQ&quot;
l_string|&quot; DMA Ch ID Pr QS  S/G IS&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|registered_HBAs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%-2d: %.12s v%s 2.0%c %s %#.4x  %2d&quot;
comma
id|HBA_ptr-&gt;host_no
comma
id|SD
c_func
(paren
id|HBA_ptr
)paren
op_member_access_from_pointer
id|name
comma
id|SD
c_func
(paren
id|HBA_ptr
)paren
op_member_access_from_pointer
id|revision
comma
id|SD
c_func
(paren
id|HBA_ptr
)paren
op_member_access_from_pointer
id|EATA_revision
comma
(paren
id|SD
c_func
(paren
id|HBA_ptr
)paren
op_member_access_from_pointer
id|bustype
op_eq
l_char|&squot;P&squot;
)paren
ques
c_cond
l_string|&quot;PCI &quot;
suffix:colon
(paren
id|SD
c_func
(paren
id|HBA_ptr
)paren
op_member_access_from_pointer
id|bustype
op_eq
l_char|&squot;E&squot;
)paren
ques
c_cond
l_string|&quot;EISA&quot;
suffix:colon
l_string|&quot;ISA &quot;
comma
(paren
id|u32
)paren
id|HBA_ptr-&gt;base
comma
id|HBA_ptr-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HBA_ptr-&gt;dma_channel
op_ne
id|BUSMASTER
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;  %2x &quot;
comma
id|HBA_ptr-&gt;dma_channel
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot; %s&quot;
comma
l_string|&quot;BMST&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %d  %d  %c %3d %3d %c&bslash;n&quot;
comma
id|SD
c_func
(paren
id|HBA_ptr
)paren
op_member_access_from_pointer
id|channel
op_plus
l_int|1
comma
id|HBA_ptr-&gt;this_id
comma
(paren
id|SD
c_func
(paren
id|HBA_ptr
)paren
op_member_access_from_pointer
id|primary
op_eq
id|TRUE
)paren
ques
c_cond
l_char|&squot;Y&squot;
suffix:colon
l_char|&squot;N&squot;
comma
id|HBA_ptr-&gt;can_queue
comma
id|HBA_ptr-&gt;sg_tablesize
comma
(paren
id|SD
c_func
(paren
id|HBA_ptr
)paren
op_member_access_from_pointer
id|immediate_support
op_eq
id|TRUE
)paren
ques
c_cond
l_char|&squot;Y&squot;
suffix:colon
l_char|&squot;N&squot;
)paren
suffix:semicolon
id|HBA_ptr
op_assign
id|SD
c_func
(paren
id|HBA_ptr
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
)brace
r_else
(brace
id|kfree
c_func
(paren
(paren
r_void
op_star
)paren
id|status
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
(paren
r_void
op_star
)paren
id|dma_scratch
op_minus
l_int|4
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DPT_DEBUG
comma
id|DELAY
c_func
(paren
l_int|12
)paren
)paren
suffix:semicolon
r_return
id|registered_HBAs
suffix:semicolon
)brace
multiline_comment|/* Eventually this will go into an include file, but this will be later */
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|EATA_DMA
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
multiline_comment|/*&n; * Overrides for Emacs so that we almost follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 4&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * tab-width: 8&n; * End:&n; */
eof
