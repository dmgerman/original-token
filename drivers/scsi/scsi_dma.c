multiline_comment|/*&n; *  scsi_dma.c Copyright (C) 2000 Eric Youngdale&n; *&n; *  mid-level SCSI DMA bounce buffer allocator&n; *&n; */
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#ifdef CONFIG_KMOD
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#endif
multiline_comment|/*&n; * PAGE_SIZE must be a multiple of the sector size (512).  True&n; * for all reasonably recent architectures (even the VAX...).&n; */
DECL|macro|SECTOR_SIZE
mdefine_line|#define SECTOR_SIZE&t;&t;512
DECL|macro|SECTORS_PER_PAGE
mdefine_line|#define SECTORS_PER_PAGE&t;(PAGE_SIZE/SECTOR_SIZE)
macro_line|#if SECTORS_PER_PAGE &lt;= 8
DECL|typedef|FreeSectorBitmap
r_typedef
r_int
r_char
id|FreeSectorBitmap
suffix:semicolon
macro_line|#elif SECTORS_PER_PAGE &lt;= 32
DECL|typedef|FreeSectorBitmap
r_typedef
r_int
r_int
id|FreeSectorBitmap
suffix:semicolon
macro_line|#else
macro_line|#error You lose.
macro_line|#endif
multiline_comment|/*&n; * Used for access to internal allocator used for DMA safe buffers.&n; */
DECL|variable|allocator_request_lock
r_static
id|spinlock_t
id|allocator_request_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|dma_malloc_freelist
r_static
id|FreeSectorBitmap
op_star
id|dma_malloc_freelist
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|need_isa_bounce_buffers
r_static
r_int
id|need_isa_bounce_buffers
suffix:semicolon
DECL|variable|dma_sectors
r_static
r_int
r_int
id|dma_sectors
op_assign
l_int|0
suffix:semicolon
DECL|variable|scsi_dma_free_sectors
r_int
r_int
id|scsi_dma_free_sectors
op_assign
l_int|0
suffix:semicolon
DECL|variable|scsi_need_isa_buffer
r_int
r_int
id|scsi_need_isa_buffer
op_assign
l_int|0
suffix:semicolon
DECL|variable|dma_malloc_pages
r_static
r_int
r_char
op_star
op_star
id|dma_malloc_pages
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * Function:    scsi_malloc&n; *&n; * Purpose:     Allocate memory from the DMA-safe pool.&n; *&n; * Arguments:   len       - amount of memory we need.&n; *&n; * Lock status: No locks assumed to be held.  This function is SMP-safe.&n; *&n; * Returns:     Pointer to memory block.&n; *&n; * Notes:       Prior to the new queue code, this function was not SMP-safe.&n; *              This function can only allocate in units of sectors&n; *              (i.e. 512 bytes).&n; *&n; *              We cannot use the normal system allocator becuase we need&n; *              to be able to guarantee that we can process a complete disk&n; *              I/O request without touching the system allocator.  Think&n; *              about it - if the system were heavily swapping, and tried to&n; *              write out a block of memory to disk, and the SCSI code needed&n; *              to allocate more memory in order to be able to write the&n; *              data to disk, you would wedge the system.&n; */
DECL|function|scsi_malloc
r_void
op_star
id|scsi_malloc
c_func
(paren
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|nbits
comma
id|mask
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
id|len
op_mod
id|SECTOR_SIZE
op_ne
l_int|0
op_logical_or
id|len
OG
id|PAGE_SIZE
)paren
r_return
l_int|NULL
suffix:semicolon
id|nbits
op_assign
id|len
op_rshift
l_int|9
suffix:semicolon
id|mask
op_assign
(paren
l_int|1
op_lshift
id|nbits
)paren
op_minus
l_int|1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|i
op_increment
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
op_le
id|SECTORS_PER_PAGE
op_minus
id|nbits
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|dma_malloc_freelist
(braket
id|i
)braket
op_amp
(paren
id|mask
op_lshift
id|j
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|dma_malloc_freelist
(braket
id|i
)braket
op_or_assign
(paren
id|mask
op_lshift
id|j
)paren
suffix:semicolon
id|scsi_dma_free_sectors
op_sub_assign
id|nbits
suffix:semicolon
macro_line|#ifdef DEBUG
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;SMalloc: %d %p [From:%p]&bslash;n&quot;
comma
id|len
comma
id|dma_malloc_pages
(braket
id|i
)braket
op_plus
(paren
id|j
op_lshift
l_int|9
)paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SMalloc: %d %p [From:%p]&bslash;n&quot;
comma
id|len
comma
id|dma_malloc_pages
(braket
id|i
)braket
op_plus
(paren
id|j
op_lshift
l_int|9
)paren
)paren
suffix:semicolon
macro_line|#endif
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|dma_malloc_pages
(braket
id|i
)braket
op_plus
(paren
id|j
op_lshift
l_int|9
)paren
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Nope.  No more */
)brace
multiline_comment|/*&n; * Function:    scsi_free&n; *&n; * Purpose:     Free memory into the DMA-safe pool.&n; *&n; * Arguments:   ptr       - data block we are freeing.&n; *              len       - size of block we are freeing.&n; *&n; * Lock status: No locks assumed to be held.  This function is SMP-safe.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       This function *must* only be used to free memory&n; *              allocated from scsi_malloc().&n; *&n; *              Prior to the new queue code, this function was not SMP-safe.&n; *              This function can only allocate in units of sectors&n; *              (i.e. 512 bytes).&n; */
DECL|function|scsi_free
r_int
id|scsi_free
c_func
(paren
r_void
op_star
id|obj
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|page
comma
id|sector
comma
id|nbits
comma
id|mask
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG
r_int
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __mips__
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;move&bslash;t%0,$31&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ret
)paren
)paren
suffix:semicolon
macro_line|#else
id|ret
op_assign
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;scsi_free %p %d&bslash;n&quot;
comma
id|obj
comma
id|len
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;SFree: %p %d&bslash;n&quot;
comma
id|obj
comma
id|len
)paren
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
l_int|0
suffix:semicolon
id|page
OL
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|page
op_increment
)paren
(brace
r_int
r_int
id|page_addr
op_assign
(paren
r_int
r_int
)paren
id|dma_malloc_pages
(braket
id|page
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|obj
op_ge
id|page_addr
op_logical_and
(paren
r_int
r_int
)paren
id|obj
OL
id|page_addr
op_plus
id|PAGE_SIZE
)paren
(brace
id|sector
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|obj
)paren
op_minus
id|page_addr
)paren
op_rshift
l_int|9
suffix:semicolon
id|nbits
op_assign
id|len
op_rshift
l_int|9
suffix:semicolon
id|mask
op_assign
(paren
l_int|1
op_lshift
id|nbits
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sector
op_plus
id|nbits
OG
id|SECTORS_PER_PAGE
)paren
id|panic
c_func
(paren
l_string|&quot;scsi_free:Bad memory alignment&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dma_malloc_freelist
(braket
id|page
)braket
op_amp
(paren
id|mask
op_lshift
id|sector
)paren
)paren
op_ne
(paren
id|mask
op_lshift
id|sector
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;scsi_free(obj=%p, len=%d) called from %08lx&bslash;n&quot;
comma
id|obj
comma
id|len
comma
id|ret
)paren
suffix:semicolon
macro_line|#endif
id|panic
c_func
(paren
l_string|&quot;scsi_free:Trying to free unused memory&quot;
)paren
suffix:semicolon
)brace
id|scsi_dma_free_sectors
op_add_assign
id|nbits
suffix:semicolon
id|dma_malloc_freelist
(braket
id|page
)braket
op_and_assign
op_complement
(paren
id|mask
op_lshift
id|sector
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|panic
c_func
(paren
l_string|&quot;scsi_free:Bad offset&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_resize_dma_pool&n; *&n; * Purpose:     Ensure that the DMA pool is sufficiently large to be&n; *              able to guarantee that we can always process I/O requests&n; *              without calling the system allocator.&n; *&n; * Arguments:   None.&n; *&n; * Lock status: No locks assumed to be held.  This function is SMP-safe.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       Prior to the new queue code, this function was not SMP-safe.&n; *              Go through the device list and recompute the most appropriate&n; *              size for the dma pool.  Then grab more memory (as required).&n; */
DECL|function|scsi_resize_dma_pool
r_void
id|scsi_resize_dma_pool
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|k
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|FreeSectorBitmap
op_star
id|new_dma_malloc_freelist
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|new_dma_sectors
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|new_need_isa_buffer
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
op_star
id|new_dma_malloc_pages
op_assign
l_int|NULL
suffix:semicolon
r_int
id|out_of_space
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_hostlist
)paren
(brace
multiline_comment|/*&n;&t;&t; * Free up the DMA pool.&n;&t;&t; */
r_if
c_cond
(paren
id|scsi_dma_free_sectors
op_ne
id|dma_sectors
)paren
id|panic
c_func
(paren
l_string|&quot;SCSI DMA pool memory leak %d %d&bslash;n&quot;
comma
id|scsi_dma_free_sectors
comma
id|dma_sectors
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|i
op_increment
)paren
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|dma_malloc_pages
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_pages
)paren
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_pages
)paren
suffix:semicolon
id|dma_malloc_pages
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_freelist
)paren
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_freelist
)paren
suffix:semicolon
id|dma_malloc_freelist
op_assign
l_int|NULL
suffix:semicolon
id|dma_sectors
op_assign
l_int|0
suffix:semicolon
id|scsi_dma_free_sectors
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Next, check to see if we need to extend the DMA buffer pool */
id|new_dma_sectors
op_assign
l_int|2
op_star
id|SECTORS_PER_PAGE
suffix:semicolon
multiline_comment|/* Base value we use */
r_if
c_cond
(paren
id|__pa
c_func
(paren
id|high_memory
)paren
op_minus
l_int|1
OG
id|ISA_DMA_THRESHOLD
)paren
id|need_isa_bounce_buffers
op_assign
l_int|1
suffix:semicolon
r_else
id|need_isa_bounce_buffers
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|scsi_devicelist
)paren
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
id|new_dma_sectors
op_add_assign
id|SECTORS_PER_PAGE
suffix:semicolon
multiline_comment|/* Increment for each host */
r_for
c_loop
(paren
id|host
op_assign
id|scsi_hostlist
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * sd and sr drivers allocate scatterlists.&n;&t;&t;&t; * sr drivers may allocate for each command 1x2048 or 2x1024 extra&n;&t;&t;&t; * buffers for 2k sector size and 1k fs.&n;&t;&t;&t; * sg driver allocates buffers &lt; 4k.&n;&t;&t;&t; * st driver does not need buffers from the dma pool.&n;&t;&t;&t; * estimate 4k buffer/command for devices of unknown type (should panic).&n;&t;&t;&t; */
r_if
c_cond
(paren
id|SDpnt-&gt;type
op_eq
id|TYPE_WORM
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_ROM
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_DISK
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_MOD
)paren
(brace
r_int
id|nents
op_assign
id|host-&gt;sg_tablesize
suffix:semicolon
macro_line|#ifdef DMA_CHUNK_SIZE
multiline_comment|/* If the architecture does DMA sg merging, make sure&n;&t;&t;&t;&t;   we count with at least 64 entries even for HBAs&n;&t;&t;&t;&t;   which handle very few sg entries.  */
r_if
c_cond
(paren
id|nents
OL
l_int|64
)paren
id|nents
op_assign
l_int|64
suffix:semicolon
macro_line|#endif
id|new_dma_sectors
op_add_assign
(paren
(paren
id|nents
op_star
r_sizeof
(paren
r_struct
id|scatterlist
)paren
op_plus
l_int|511
)paren
op_rshift
l_int|9
)paren
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;type
op_eq
id|TYPE_WORM
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_ROM
)paren
id|new_dma_sectors
op_add_assign
(paren
l_int|2048
op_rshift
l_int|9
)paren
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SDpnt-&gt;type
op_eq
id|TYPE_SCANNER
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_PROCESSOR
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_COMM
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_MEDIUM_CHANGER
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_ENCLOSURE
)paren
(brace
id|new_dma_sectors
op_add_assign
(paren
l_int|4096
op_rshift
l_int|9
)paren
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|SDpnt-&gt;type
op_ne
id|TYPE_TAPE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: unknown device type %d&bslash;n&quot;
comma
id|SDpnt-&gt;type
)paren
suffix:semicolon
id|new_dma_sectors
op_add_assign
(paren
l_int|4096
op_rshift
l_int|9
)paren
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|host-&gt;unchecked_isa_dma
op_logical_and
id|need_isa_bounce_buffers
op_logical_and
id|SDpnt-&gt;type
op_ne
id|TYPE_TAPE
)paren
(brace
id|new_dma_sectors
op_add_assign
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
op_star
id|host-&gt;sg_tablesize
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
id|new_need_isa_buffer
op_increment
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef DEBUG_INIT
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: needed dma sectors = %d&bslash;n&quot;
comma
id|new_dma_sectors
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* limit DMA memory to 32MB: */
id|new_dma_sectors
op_assign
(paren
id|new_dma_sectors
op_plus
l_int|15
)paren
op_amp
l_int|0xfff0
suffix:semicolon
multiline_comment|/*&n;&t; * We never shrink the buffers - this leads to&n;&t; * race conditions that I would rather not even think&n;&t; * about right now.&n;&t; */
macro_line|#if 0&t;&t;&t;&t;/* Why do this? No gain and risks out_of_space */
r_if
c_cond
(paren
id|new_dma_sectors
OL
id|dma_sectors
)paren
id|new_dma_sectors
op_assign
id|dma_sectors
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|new_dma_sectors
op_le
id|dma_sectors
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* best to quit while we are in front */
)brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|20
suffix:semicolon
op_increment
id|k
)paren
(brace
multiline_comment|/* just in case */
id|out_of_space
op_assign
l_int|0
suffix:semicolon
id|size
op_assign
(paren
id|new_dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
id|FreeSectorBitmap
)paren
suffix:semicolon
id|new_dma_malloc_freelist
op_assign
(paren
id|FreeSectorBitmap
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_dma_malloc_freelist
)paren
(brace
id|memset
c_func
(paren
id|new_dma_malloc_freelist
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|size
op_assign
(paren
id|new_dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|new_dma_malloc_pages
)paren
suffix:semicolon
id|new_dma_malloc_pages
op_assign
(paren
r_int
r_char
op_star
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_dma_malloc_pages
)paren
(brace
id|size
op_assign
(paren
id|new_dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
id|FreeSectorBitmap
)paren
suffix:semicolon
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|new_dma_malloc_freelist
)paren
suffix:semicolon
id|out_of_space
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|memset
c_func
(paren
id|new_dma_malloc_pages
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
)brace
)brace
r_else
id|out_of_space
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|out_of_space
)paren
op_logical_and
(paren
id|new_dma_sectors
OG
id|dma_sectors
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|i
OL
id|new_dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|new_dma_malloc_pages
(braket
id|i
)braket
op_assign
(paren
r_int
r_char
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
op_or
id|GFP_DMA
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_dma_malloc_pages
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ne
id|new_dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
(brace
multiline_comment|/* clean up */
r_int
id|k
op_assign
id|i
suffix:semicolon
id|out_of_space
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|k
suffix:semicolon
op_increment
id|i
)paren
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|new_dma_malloc_pages
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|out_of_space
)paren
(brace
multiline_comment|/* try scaling down new_dma_sectors request */
id|printk
c_func
(paren
l_string|&quot;scsi::resize_dma_pool: WARNING, dma_sectors=%u, &quot;
l_string|&quot;wanted=%u, scaling&bslash;n&quot;
comma
id|dma_sectors
comma
id|new_dma_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_dma_sectors
OL
(paren
l_int|8
op_star
id|SECTORS_PER_PAGE
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* pretty well hopeless ... */
id|new_dma_sectors
op_assign
(paren
id|new_dma_sectors
op_star
l_int|3
)paren
op_div
l_int|4
suffix:semicolon
id|new_dma_sectors
op_assign
(paren
id|new_dma_sectors
op_plus
l_int|15
)paren
op_amp
l_int|0xfff0
suffix:semicolon
r_if
c_cond
(paren
id|new_dma_sectors
op_le
id|dma_sectors
)paren
r_break
suffix:semicolon
multiline_comment|/* stick with what we have got */
)brace
r_else
r_break
suffix:semicolon
multiline_comment|/* found space ... */
)brace
multiline_comment|/* end of for loop */
r_if
c_cond
(paren
id|out_of_space
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
id|scsi_need_isa_buffer
op_assign
id|new_need_isa_buffer
suffix:semicolon
multiline_comment|/* some useful info */
id|printk
c_func
(paren
l_string|&quot;      WARNING, not enough memory, pool not expanded&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* When we dick with the actual DMA list, we need to&n;&t; * protect things&n;&t; */
r_if
c_cond
(paren
id|dma_malloc_freelist
)paren
(brace
id|size
op_assign
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
id|FreeSectorBitmap
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_dma_malloc_freelist
comma
id|dma_malloc_freelist
comma
id|size
)paren
suffix:semicolon
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_freelist
)paren
suffix:semicolon
)brace
id|dma_malloc_freelist
op_assign
id|new_dma_malloc_freelist
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_pages
)paren
(brace
id|size
op_assign
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|dma_malloc_pages
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_dma_malloc_pages
comma
id|dma_malloc_pages
comma
id|size
)paren
suffix:semicolon
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_pages
)paren
suffix:semicolon
)brace
id|scsi_dma_free_sectors
op_add_assign
id|new_dma_sectors
op_minus
id|dma_sectors
suffix:semicolon
id|dma_malloc_pages
op_assign
id|new_dma_malloc_pages
suffix:semicolon
id|dma_sectors
op_assign
id|new_dma_sectors
suffix:semicolon
id|scsi_need_isa_buffer
op_assign
id|new_need_isa_buffer
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_INIT
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: dma free sectors   = %d&bslash;n&quot;
comma
id|scsi_dma_free_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: dma sectors        = %d&bslash;n&quot;
comma
id|dma_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: need isa buffers   = %d&bslash;n&quot;
comma
id|scsi_need_isa_buffer
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Function:    scsi_init_minimal_dma_pool&n; *&n; * Purpose:     Allocate a minimal (1-page) DMA pool.&n; *&n; * Arguments:   None.&n; *&n; * Lock status: No locks assumed to be held.  This function is SMP-safe.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       &n; */
DECL|function|scsi_init_minimal_dma_pool
r_int
id|scsi_init_minimal_dma_pool
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|has_space
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
id|dma_sectors
op_assign
id|PAGE_SIZE
op_div
id|SECTOR_SIZE
suffix:semicolon
id|scsi_dma_free_sectors
op_assign
id|dma_sectors
suffix:semicolon
multiline_comment|/*&n;&t; * Set up a minimal DMA buffer list - this will be used during scan_scsis&n;&t; * in some cases.&n;&t; */
multiline_comment|/* One bit per sector to indicate free/busy */
id|size
op_assign
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
id|FreeSectorBitmap
)paren
suffix:semicolon
id|dma_malloc_freelist
op_assign
(paren
id|FreeSectorBitmap
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_freelist
)paren
(brace
id|memset
c_func
(paren
id|dma_malloc_freelist
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* One pointer per page for the page list */
id|dma_malloc_pages
op_assign
(paren
r_int
r_char
op_star
op_star
)paren
id|kmalloc
c_func
(paren
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|dma_malloc_pages
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_pages
)paren
(brace
id|memset
c_func
(paren
id|dma_malloc_pages
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|dma_malloc_pages
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_char
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
op_or
id|GFP_DMA
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_pages
(braket
l_int|0
)braket
)paren
id|has_space
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|has_space
)paren
(brace
r_if
c_cond
(paren
id|dma_malloc_freelist
)paren
(brace
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_freelist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_pages
)paren
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_pages
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi::init_module: failed, out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
