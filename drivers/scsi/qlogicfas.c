multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/*&n;   Qlogic linux driver - work in progress. No Warranty express or implied.&n;   Use at your own risk.  Support Tort Reform so you won&squot;t have to read all&n;   these silly disclaimers.&n;&n;   Copyright 1994, Tom Zerucha.   &n;   tz@execpc.com&n;   &n;   Additional Code, and much appreciated help by&n;   Michael A. Griffith&n;   grif@cs.ucr.edu&n;&n;   Thanks to Eric Youngdale and Dave Hinds for loadable module and PCMCIA&n;   help respectively, and for suffering through my foolishness during the&n;   debugging process.&n;&n;   Reference Qlogic FAS408 Technical Manual, 53408-510-00A, May 10, 1994&n;   (you can reference it, but it is incomplete and inaccurate in places)&n;&n;   Version 0.46 1/30/97 - kernel 1.2.0+&n;&n;   Functions as standalone, loadable, and PCMCIA driver, the latter from&n;   Dave Hinds&squot; PCMCIA package.&n;&n;   Redistributable under terms of the GNU Public License&n;&n;*/
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* Configuration */
multiline_comment|/* Set the following to 2 to use normal interrupt (active high/totempole-&n;   tristate), otherwise use 0 (REQUIRED FOR PCMCIA) for active low, open&n;   drain */
DECL|macro|QL_INT_ACTIVE_HIGH
mdefine_line|#define QL_INT_ACTIVE_HIGH 2
multiline_comment|/* Set the following to 1 to enable the use of interrupts.  Note that 0 tends&n;   to be more stable, but slower (or ties up the system more) */
DECL|macro|QL_USE_IRQ
mdefine_line|#define QL_USE_IRQ 1
multiline_comment|/* Set the following to max out the speed of the PIO PseudoDMA transfers,&n;   again, 0 tends to be slower, but more stable.  */
DECL|macro|QL_TURBO_PDMA
mdefine_line|#define QL_TURBO_PDMA 1
multiline_comment|/* This should be 1 to enable parity detection */
DECL|macro|QL_ENABLE_PARITY
mdefine_line|#define QL_ENABLE_PARITY 1
multiline_comment|/* This will reset all devices when the driver is initialized (during bootup).&n;   The other linux drivers don&squot;t do this, but the DOS drivers do, and after&n;   using DOS or some kind of crash or lockup this will bring things back&n;   without requiring a cold boot.  It does take some time to recover from a&n;   reset, so it is slower, and I have seen timeouts so that devices weren&squot;t&n;   recognized when this was set. */
DECL|macro|QL_RESET_AT_START
mdefine_line|#define QL_RESET_AT_START 0
multiline_comment|/* crystal frequency in megahertz (for offset 5 and 9)&n;   Please set this for your card.  Most Qlogic cards are 40 Mhz.  The&n;   Control Concepts ISA (not VLB) is 24 Mhz */
DECL|macro|XTALFREQ
mdefine_line|#define XTALFREQ&t;40
multiline_comment|/**********/
multiline_comment|/* DANGER! modify these at your own risk */
multiline_comment|/* SLOWCABLE can usually be reset to zero if you have a clean setup and&n;   proper termination.  The rest are for synchronous transfers and other&n;   advanced features if your device can transfer faster than 5Mb/sec.&n;   If you are really curious, email me for a quick howto until I have&n;   something official */
multiline_comment|/**********/
multiline_comment|/*****/
multiline_comment|/* config register 1 (offset 8) options */
multiline_comment|/* This needs to be set to 1 if your cabling is long or noisy */
DECL|macro|SLOWCABLE
mdefine_line|#define SLOWCABLE 1
multiline_comment|/*****/
multiline_comment|/* offset 0xc */
multiline_comment|/* This will set fast (10Mhz) synchronous timing when set to 1&n;   For this to have an effect, FASTCLK must also be 1 */
DECL|macro|FASTSCSI
mdefine_line|#define FASTSCSI 0
multiline_comment|/* This when set to 1 will set a faster sync transfer rate */
DECL|macro|FASTCLK
mdefine_line|#define FASTCLK 0
multiline_comment|/*(XTALFREQ&gt;25?1:0)*/
multiline_comment|/*****/
multiline_comment|/* offset 6 */
multiline_comment|/* This is the sync transfer divisor, XTALFREQ/X will be the maximum&n;   achievable data rate (assuming the rest of the system is capable&n;   and set properly) */
DECL|macro|SYNCXFRPD
mdefine_line|#define SYNCXFRPD 5
multiline_comment|/*(XTALFREQ/5)*/
multiline_comment|/*****/
multiline_comment|/* offset 7 */
multiline_comment|/* This is the count of how many synchronous transfers can take place&n;&t;i.e. how many reqs can occur before an ack is given.&n;&t;The maximum value for this is 15, the upper bits can modify&n;&t;REQ/ACK assertion and deassertion during synchronous transfers&n;&t;If this is 0, the bus will only transfer asynchronously */
DECL|macro|SYNCOFFST
mdefine_line|#define SYNCOFFST 0
multiline_comment|/* for the curious, bits 7&amp;6 control the deassertion delay in 1/2 cycles&n;&t;of the 40Mhz clock. If FASTCLK is 1, specifying 01 (1/2) will&n;&t;cause the deassertion to be early by 1/2 clock.  Bits 5&amp;4 control&n;&t;the assertion delay, also in 1/2 clocks (FASTCLK is ignored here). */
multiline_comment|/*----------------------------------------------------------------*/
macro_line|#ifdef PCMCIA
DECL|macro|QL_INT_ACTIVE_HIGH
macro_line|#undef QL_INT_ACTIVE_HIGH
DECL|macro|QL_INT_ACTIVE_HIGH
mdefine_line|#define QL_INT_ACTIVE_HIGH 0
macro_line|#endif 
macro_line|#include &lt;linux/module.h&gt;
macro_line|#ifdef PCMCIA
DECL|macro|MODULE
macro_line|#undef MODULE
macro_line|#endif 
macro_line|#include &lt;linux/blk.h&gt;&t;/* to get disk capacity */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;qlogicfas.h&quot;
macro_line|#include&lt;linux/stat.h&gt;
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* driver state info, local to driver */
DECL|variable|qbase
r_static
r_int
id|qbase
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Port */
DECL|variable|qinitid
r_static
r_int
id|qinitid
suffix:semicolon
multiline_comment|/* initiator ID */
DECL|variable|qabort
r_static
r_int
id|qabort
suffix:semicolon
multiline_comment|/* Flag to cause an abort */
DECL|variable|qlirq
r_static
r_int
id|qlirq
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* IRQ being used */
DECL|variable|qinfo
r_static
r_char
id|qinfo
(braket
l_int|80
)braket
suffix:semicolon
multiline_comment|/* description */
DECL|variable|qlcmd
r_static
id|Scsi_Cmnd
op_star
id|qlcmd
suffix:semicolon
multiline_comment|/* current command being processed */
DECL|variable|qlcfg5
r_static
r_int
id|qlcfg5
op_assign
(paren
id|XTALFREQ
op_lshift
l_int|5
)paren
suffix:semicolon
multiline_comment|/* 15625/512 */
DECL|variable|qlcfg6
r_static
r_int
id|qlcfg6
op_assign
id|SYNCXFRPD
suffix:semicolon
DECL|variable|qlcfg7
r_static
r_int
id|qlcfg7
op_assign
id|SYNCOFFST
suffix:semicolon
DECL|variable|qlcfg8
r_static
r_int
id|qlcfg8
op_assign
(paren
id|SLOWCABLE
op_lshift
l_int|7
)paren
op_or
(paren
id|QL_ENABLE_PARITY
op_lshift
l_int|4
)paren
suffix:semicolon
DECL|variable|qlcfg9
r_static
r_int
id|qlcfg9
op_assign
(paren
(paren
id|XTALFREQ
op_plus
l_int|4
)paren
op_div
l_int|5
)paren
suffix:semicolon
DECL|variable|qlcfgc
r_static
r_int
id|qlcfgc
op_assign
(paren
id|FASTCLK
op_lshift
l_int|3
)paren
op_or
(paren
id|FASTSCSI
op_lshift
l_int|4
)paren
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* The qlogic card uses two register maps - These macros select which one */
DECL|macro|REG0
mdefine_line|#define REG0 ( outb( inb( qbase + 0xd ) &amp; 0x7f , qbase + 0xd ), outb( 4 , qbase + 0xd ))
DECL|macro|REG1
mdefine_line|#define REG1 ( outb( inb( qbase + 0xd ) | 0x80 , qbase + 0xd ), outb( 0xb4 | QL_INT_ACTIVE_HIGH , qbase + 0xd ))
multiline_comment|/* following is watchdog timeout in microseconds */
DECL|macro|WATCHDOG
mdefine_line|#define WATCHDOG 5000000
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* the following will set the monitor border color (useful to find&n;   where something crashed or gets stuck at and as a simple profiler) */
macro_line|#if 0
mdefine_line|#define rtrc(i) {inb(0x3da);outb(0x31,0x3c0);outb((i),0x3c0);}
macro_line|#else
DECL|macro|rtrc
mdefine_line|#define rtrc(i) {}
macro_line|#endif
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* local functions */
multiline_comment|/*----------------------------------------------------------------*/
r_static
r_void
id|ql_zap
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* error recovery - reset everything */
DECL|function|ql_zap
r_void
id|ql_zap
c_func
(paren
)paren
(brace
r_int
id|x
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|x
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|0xd
)paren
suffix:semicolon
id|REG0
suffix:semicolon
id|outb
c_func
(paren
l_int|3
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* reset SCSI */
id|outb
c_func
(paren
l_int|2
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* reset chip */
r_if
c_cond
(paren
id|x
op_amp
l_int|0x80
)paren
id|REG1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* do pseudo-dma */
DECL|function|ql_pdma
r_static
r_int
id|ql_pdma
c_func
(paren
r_int
id|phase
comma
r_char
op_star
id|request
comma
r_int
id|reqlen
)paren
(brace
r_int
id|j
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|phase
op_amp
l_int|1
)paren
(brace
multiline_comment|/* in */
macro_line|#if QL_TURBO_PDMA
id|rtrc
c_func
(paren
l_int|4
)paren
multiline_comment|/* empty fifo in large chunks */
r_if
c_cond
(paren
id|reqlen
op_ge
l_int|128
op_logical_and
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
op_amp
l_int|2
)paren
)paren
(brace
multiline_comment|/* full */
id|insl
c_func
(paren
id|qbase
op_plus
l_int|4
comma
id|request
comma
l_int|32
)paren
suffix:semicolon
id|reqlen
op_sub_assign
l_int|128
suffix:semicolon
id|request
op_add_assign
l_int|128
suffix:semicolon
)brace
r_while
c_loop
(paren
id|reqlen
op_ge
l_int|84
op_logical_and
op_logical_neg
(paren
id|j
op_amp
l_int|0xc0
)paren
)paren
multiline_comment|/* 2/3 */
r_if
c_cond
(paren
(paren
id|j
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
)paren
op_amp
l_int|4
)paren
(brace
id|insl
c_func
(paren
id|qbase
op_plus
l_int|4
comma
id|request
comma
l_int|21
)paren
suffix:semicolon
id|reqlen
op_sub_assign
l_int|84
suffix:semicolon
id|request
op_add_assign
l_int|84
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reqlen
op_ge
l_int|44
op_logical_and
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
op_amp
l_int|8
)paren
)paren
(brace
multiline_comment|/* 1/3 */
id|insl
c_func
(paren
id|qbase
op_plus
l_int|4
comma
id|request
comma
l_int|11
)paren
suffix:semicolon
id|reqlen
op_sub_assign
l_int|44
suffix:semicolon
id|request
op_add_assign
l_int|44
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* until both empty and int (or until reclen is 0) */
id|rtrc
c_func
(paren
l_int|7
)paren
id|j
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|reqlen
op_logical_and
op_logical_neg
(paren
(paren
id|j
op_amp
l_int|0x10
)paren
op_logical_and
(paren
id|j
op_amp
l_int|0xc0
)paren
)paren
)paren
(brace
multiline_comment|/* while bytes to receive and not empty */
id|j
op_and_assign
l_int|0xc0
suffix:semicolon
r_while
c_loop
(paren
id|reqlen
op_logical_and
op_logical_neg
(paren
(paren
id|j
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
)paren
op_amp
l_int|0x10
)paren
)paren
(brace
op_star
id|request
op_increment
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|4
)paren
suffix:semicolon
id|reqlen
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
op_amp
l_int|0x10
)paren
(brace
id|j
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* out */
macro_line|#if QL_TURBO_PDMA
id|rtrc
c_func
(paren
l_int|4
)paren
r_if
c_cond
(paren
id|reqlen
op_ge
l_int|128
op_logical_and
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
op_amp
l_int|0x10
)paren
(brace
multiline_comment|/* empty */
id|outsl
c_func
(paren
id|qbase
op_plus
l_int|4
comma
id|request
comma
l_int|32
)paren
suffix:semicolon
id|reqlen
op_sub_assign
l_int|128
suffix:semicolon
id|request
op_add_assign
l_int|128
suffix:semicolon
)brace
r_while
c_loop
(paren
id|reqlen
op_ge
l_int|84
op_logical_and
op_logical_neg
(paren
id|j
op_amp
l_int|0xc0
)paren
)paren
multiline_comment|/* 1/3 */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|j
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
)paren
op_amp
l_int|8
)paren
)paren
(brace
id|outsl
c_func
(paren
id|qbase
op_plus
l_int|4
comma
id|request
comma
l_int|21
)paren
suffix:semicolon
id|reqlen
op_sub_assign
l_int|84
suffix:semicolon
id|request
op_add_assign
l_int|84
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reqlen
op_ge
l_int|40
op_logical_and
op_logical_neg
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
op_amp
l_int|4
)paren
)paren
(brace
multiline_comment|/* 2/3 */
id|outsl
c_func
(paren
id|qbase
op_plus
l_int|4
comma
id|request
comma
l_int|10
)paren
suffix:semicolon
id|reqlen
op_sub_assign
l_int|40
suffix:semicolon
id|request
op_add_assign
l_int|40
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* until full and int (or until reclen is 0) */
id|rtrc
c_func
(paren
l_int|7
)paren
id|j
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|reqlen
op_logical_and
op_logical_neg
(paren
(paren
id|j
op_amp
l_int|2
)paren
op_logical_and
(paren
id|j
op_amp
l_int|0xc0
)paren
)paren
)paren
(brace
multiline_comment|/* while bytes to send and not full */
r_while
c_loop
(paren
id|reqlen
op_logical_and
op_logical_neg
(paren
(paren
id|j
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
)paren
op_amp
l_int|2
)paren
)paren
(brace
id|outb
c_func
(paren
op_star
id|request
op_increment
comma
id|qbase
op_plus
l_int|4
)paren
suffix:semicolon
id|reqlen
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
op_amp
l_int|2
)paren
(brace
id|j
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* maybe return reqlen */
r_return
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
op_amp
l_int|0xc0
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* wait for interrupt flag (polled - not real hardware interrupt) */
DECL|function|ql_wai
r_static
r_int
id|ql_wai
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|k
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|jiffies
op_plus
id|WATCHDOG
suffix:semicolon
r_while
c_loop
(paren
id|i
OG
id|jiffies
op_logical_and
op_logical_neg
id|qabort
op_logical_and
op_logical_neg
(paren
(paren
id|k
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|4
)paren
)paren
op_amp
l_int|0xe0
)paren
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_le
id|jiffies
)paren
r_return
(paren
id|DID_TIME_OUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qabort
)paren
r_return
(paren
id|qabort
op_eq
l_int|1
ques
c_cond
id|DID_ABORT
suffix:colon
id|DID_RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
op_amp
l_int|0x60
)paren
id|ql_zap
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
op_amp
l_int|0x20
)paren
r_return
(paren
id|DID_PARITY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
op_amp
l_int|0x40
)paren
r_return
(paren
id|DID_ERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* initiate scsi command - queueing handler */
DECL|function|ql_icmd
r_static
r_void
id|ql_icmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|qabort
op_assign
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|REG0
suffix:semicolon
multiline_comment|/* clearing of interrupts and the fifo is needed */
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
suffix:semicolon
multiline_comment|/* clear interrupts */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
)paren
multiline_comment|/* if still interrupting */
id|outb
c_func
(paren
l_int|2
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* reset chip */
r_else
r_if
c_cond
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|7
)paren
op_amp
l_int|0x1f
)paren
id|outb
c_func
(paren
l_int|1
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* clear fifo */
r_while
c_loop
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
)paren
suffix:semicolon
multiline_comment|/* clear ints */
id|REG1
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|qbase
op_plus
l_int|8
)paren
suffix:semicolon
multiline_comment|/* set for PIO pseudo DMA */
id|outb
c_func
(paren
l_int|0
comma
id|qbase
op_plus
l_int|0xb
)paren
suffix:semicolon
multiline_comment|/* disable ints */
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
suffix:semicolon
multiline_comment|/* clear int bits */
id|REG0
suffix:semicolon
id|outb
c_func
(paren
l_int|0x40
comma
id|qbase
op_plus
l_int|0xb
)paren
suffix:semicolon
multiline_comment|/* enable features */
multiline_comment|/* configurables */
id|outb
c_func
(paren
id|qlcfgc
comma
id|qbase
op_plus
l_int|0xc
)paren
suffix:semicolon
multiline_comment|/* config: no reset interrupt, (initiator) bus id */
id|outb
c_func
(paren
l_int|0x40
op_or
id|qlcfg8
op_or
id|qinitid
comma
id|qbase
op_plus
l_int|8
)paren
suffix:semicolon
id|outb
c_func
(paren
id|qlcfg7
comma
id|qbase
op_plus
l_int|7
)paren
suffix:semicolon
id|outb
c_func
(paren
id|qlcfg6
comma
id|qbase
op_plus
l_int|6
)paren
suffix:semicolon
multiline_comment|/**/
id|outb
c_func
(paren
id|qlcfg5
comma
id|qbase
op_plus
l_int|5
)paren
suffix:semicolon
multiline_comment|/* select timer */
id|outb
c_func
(paren
id|qlcfg9
op_amp
l_int|7
comma
id|qbase
op_plus
l_int|9
)paren
suffix:semicolon
multiline_comment|/* prescaler */
multiline_comment|/*&t;outb(0x99, qbase + 5);&t;*/
id|outb
c_func
(paren
id|cmd-&gt;target
comma
id|qbase
op_plus
l_int|4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cmd-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
id|outb
c_func
(paren
id|cmd-&gt;cmnd
(braket
id|i
)braket
comma
id|qbase
op_plus
l_int|2
)paren
suffix:semicolon
id|qlcmd
op_assign
id|cmd
suffix:semicolon
id|outb
c_func
(paren
l_int|0x41
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* select and send command */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* process scsi command - usually after interrupt */
DECL|function|ql_pcmd
r_static
r_int
r_int
id|ql_pcmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_int
r_int
id|result
suffix:semicolon
multiline_comment|/* ultimate return result */
r_int
r_int
id|status
suffix:semicolon
multiline_comment|/* scsi returned status */
r_int
r_int
id|message
suffix:semicolon
multiline_comment|/* scsi returned message */
r_int
r_int
id|phase
suffix:semicolon
multiline_comment|/* recorded scsi phase */
r_int
r_int
id|reqlen
suffix:semicolon
multiline_comment|/* total length of transfer */
r_struct
id|scatterlist
op_star
id|sglist
suffix:semicolon
multiline_comment|/* scatter-gather list pointer */
r_int
r_int
id|sgcount
suffix:semicolon
multiline_comment|/* sg counter */
id|rtrc
c_func
(paren
l_int|1
)paren
id|j
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|6
)paren
suffix:semicolon
id|i
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0x20
)paren
(brace
r_return
(paren
id|DID_NO_CONNECT
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
id|i
op_or_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
suffix:semicolon
multiline_comment|/* the 0x10 bit can be set after the 0x08 */
r_if
c_cond
(paren
id|i
op_ne
l_int|0x18
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Ql:Bad Interrupt status:%02x&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|ql_zap
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|DID_BAD_INTR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
id|j
op_and_assign
l_int|7
suffix:semicolon
multiline_comment|/* j = inb( qbase + 7 ) &gt;&gt; 5; */
multiline_comment|/* correct status is supposed to be step 4 */
multiline_comment|/* it sometimes returns step 3 but with 0 bytes left to send */
multiline_comment|/* We can try stuffing the FIFO with the max each time, but we will get a&n;   sequence of 3 if any bytes are left (but we do flush the FIFO anyway */
r_if
c_cond
(paren
id|j
op_ne
l_int|3
op_logical_and
id|j
op_ne
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Ql:Bad sequence for command %d, int %02X, cmdleft = %d&bslash;n&quot;
comma
id|j
comma
id|i
comma
id|inb
c_func
(paren
id|qbase
op_plus
l_int|7
)paren
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|ql_zap
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
id|result
op_assign
id|DID_OK
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|7
)paren
op_amp
l_int|0x1f
)paren
multiline_comment|/* if some bytes in fifo */
id|outb
c_func
(paren
l_int|1
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* clear fifo */
multiline_comment|/* note that request_bufflen is the total xfer size when sg is used */
id|reqlen
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
multiline_comment|/* note that it won&squot;t work if transfers &gt; 16M are requested */
r_if
c_cond
(paren
id|reqlen
op_logical_and
op_logical_neg
(paren
(paren
id|phase
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|4
)paren
)paren
op_amp
l_int|6
)paren
)paren
(brace
multiline_comment|/* data phase */
id|rtrc
c_func
(paren
l_int|2
)paren
id|outb
c_func
(paren
id|reqlen
comma
id|qbase
)paren
suffix:semicolon
multiline_comment|/* low-mid xfer cnt */
id|outb
c_func
(paren
id|reqlen
op_rshift
l_int|8
comma
id|qbase
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* low-mid xfer cnt */
id|outb
c_func
(paren
id|reqlen
op_rshift
l_int|16
comma
id|qbase
op_plus
l_int|0xe
)paren
suffix:semicolon
multiline_comment|/* high xfer cnt */
id|outb
c_func
(paren
l_int|0x90
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* command do xfer */
multiline_comment|/* PIO pseudo DMA to buffer or sglist */
id|REG1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;use_sg
)paren
id|ql_pdma
c_func
(paren
id|phase
comma
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
r_else
(brace
id|sgcount
op_assign
id|cmd-&gt;use_sg
suffix:semicolon
id|sglist
op_assign
id|cmd-&gt;request_buffer
suffix:semicolon
r_while
c_loop
(paren
id|sgcount
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|qabort
)paren
(brace
id|REG0
suffix:semicolon
r_return
(paren
(paren
id|qabort
op_eq
l_int|1
ques
c_cond
id|DID_ABORT
suffix:colon
id|DID_RESET
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ql_pdma
c_func
(paren
id|phase
comma
id|sglist-&gt;address
comma
id|sglist-&gt;length
)paren
)paren
r_break
suffix:semicolon
id|sglist
op_increment
suffix:semicolon
)brace
)brace
id|REG0
suffix:semicolon
id|rtrc
c_func
(paren
l_int|2
)paren
multiline_comment|/* wait for irq (split into second state of irq handler if this can take time) */
r_if
c_cond
(paren
(paren
id|k
op_assign
id|ql_wai
c_func
(paren
)paren
)paren
)paren
r_return
(paren
id|k
op_lshift
l_int|16
)paren
suffix:semicolon
id|k
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
suffix:semicolon
multiline_comment|/* should be 0x10, bus service */
)brace
multiline_comment|/*** Enter Status (and Message In) Phase ***/
id|k
op_assign
id|jiffies
op_plus
id|WATCHDOG
suffix:semicolon
r_while
c_loop
(paren
id|k
OG
id|jiffies
op_logical_and
op_logical_neg
id|qabort
op_logical_and
op_logical_neg
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|4
)paren
op_amp
l_int|6
)paren
)paren
suffix:semicolon
multiline_comment|/* wait for status phase */
r_if
c_cond
(paren
id|k
op_le
id|jiffies
)paren
(brace
id|ql_zap
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|DID_TIME_OUT
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
)paren
suffix:semicolon
multiline_comment|/* clear pending ints */
r_if
c_cond
(paren
id|qabort
)paren
r_return
(paren
(paren
id|qabort
op_eq
l_int|1
ques
c_cond
id|DID_ABORT
suffix:colon
id|DID_RESET
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x11
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* get status and message */
r_if
c_cond
(paren
(paren
id|k
op_assign
id|ql_wai
c_func
(paren
)paren
)paren
)paren
r_return
(paren
id|k
op_lshift
l_int|16
)paren
suffix:semicolon
id|i
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
suffix:semicolon
multiline_comment|/* get chip irq stat */
id|j
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|7
)paren
op_amp
l_int|0x1f
suffix:semicolon
multiline_comment|/* and bytes rec&squot;d */
id|status
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|2
)paren
suffix:semicolon
id|message
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* should get function complete int if Status and message, else bus serv if only status */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|i
op_eq
l_int|8
op_logical_and
id|j
op_eq
l_int|2
)paren
op_logical_or
(paren
id|i
op_eq
l_int|0x10
op_logical_and
id|j
op_eq
l_int|1
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Ql:Error during status phase, int=%02X, %d bytes recd&bslash;n&quot;
comma
id|i
comma
id|j
)paren
suffix:semicolon
id|result
op_assign
id|DID_ERROR
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0x12
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* done, disconnect */
id|rtrc
c_func
(paren
l_int|1
)paren
r_if
c_cond
(paren
(paren
id|k
op_assign
id|ql_wai
c_func
(paren
)paren
)paren
)paren
r_return
(paren
id|k
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* should get bus service interrupt and disconnect interrupt */
id|i
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
suffix:semicolon
multiline_comment|/* should be bus service */
r_while
c_loop
(paren
op_logical_neg
id|qabort
op_logical_and
(paren
(paren
id|i
op_amp
l_int|0x20
)paren
op_ne
l_int|0x20
)paren
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|i
op_or_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
suffix:semicolon
)brace
id|rtrc
c_func
(paren
l_int|0
)paren
r_if
c_cond
(paren
id|qabort
)paren
r_return
(paren
(paren
id|qabort
op_eq
l_int|1
ques
c_cond
id|DID_ABORT
suffix:colon
id|DID_RESET
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
(paren
id|result
op_lshift
l_int|16
)paren
op_or
(paren
id|message
op_lshift
l_int|8
)paren
op_or
(paren
id|status
op_amp
id|STATUS_MASK
)paren
suffix:semicolon
)brace
macro_line|#if QL_USE_IRQ
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* interrupt handler */
DECL|function|ql_ihandl
r_static
r_void
id|ql_ihandl
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|Scsi_Cmnd
op_star
id|icmd
suffix:semicolon
id|REG0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|4
)paren
op_amp
l_int|0x80
)paren
)paren
multiline_comment|/* false alarm? */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|qlcmd
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* no command to process? */
r_int
id|i
suffix:semicolon
id|i
op_assign
l_int|16
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
op_logical_and
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
)paren
suffix:semicolon
multiline_comment|/* maybe also ql_zap() */
r_return
suffix:semicolon
)brace
id|icmd
op_assign
id|qlcmd
suffix:semicolon
id|icmd-&gt;result
op_assign
id|ql_pcmd
c_func
(paren
id|icmd
)paren
suffix:semicolon
id|qlcmd
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* if result is CHECK CONDITION done calls qcommand to request sense */
(paren
id|icmd-&gt;scsi_done
)paren
(paren
id|icmd
)paren
suffix:semicolon
)brace
DECL|function|do_ql_ihandl
r_static
r_void
id|do_ql_ihandl
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|ql_ihandl
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* global functions */
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* non queued command */
macro_line|#if QL_USE_IRQ
DECL|function|qlidone
r_static
r_void
id|qlidone
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
)brace
suffix:semicolon
multiline_comment|/* null function */
macro_line|#endif
multiline_comment|/* command process */
DECL|function|qlogicfas_command
r_int
id|qlogicfas_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|k
suffix:semicolon
macro_line|#if QL_USE_IRQ
r_if
c_cond
(paren
id|qlirq
op_ge
l_int|0
)paren
(brace
id|qlogicfas_queuecommand
c_func
(paren
id|cmd
comma
id|qlidone
)paren
suffix:semicolon
r_while
c_loop
(paren
id|qlcmd
op_ne
l_int|NULL
)paren
suffix:semicolon
r_return
id|cmd-&gt;result
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* non-irq version */
r_if
c_cond
(paren
id|cmd-&gt;target
op_eq
id|qinitid
)paren
r_return
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
id|ql_icmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|k
op_assign
id|ql_wai
c_func
(paren
)paren
)paren
)paren
r_return
(paren
id|k
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
id|ql_pcmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
macro_line|#if QL_USE_IRQ
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* queued command */
DECL|function|qlogicfas_queuecommand
r_int
id|qlogicfas_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_if
c_cond
(paren
id|cmd-&gt;target
op_eq
id|qinitid
)paren
(brace
id|cmd-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
multiline_comment|/* wait for the last command&squot;s interrupt to finish */
r_while
c_loop
(paren
id|qlcmd
op_ne
l_int|NULL
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|ql_icmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else
DECL|function|qlogicfas_queuecommand
r_int
id|qlogicfas_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef PCMCIA
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* allow PCMCIA code to preset the port */
multiline_comment|/* port should be 0 and irq to -1 respectively for autoprobing */
DECL|function|qlogicfas_preset
r_void
id|qlogicfas_preset
c_func
(paren
r_int
id|port
comma
r_int
id|irq
)paren
(brace
id|qbase
op_assign
id|port
suffix:semicolon
id|qlirq
op_assign
id|irq
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* look for qlogic card and init if found */
DECL|function|qlogicfas_detect
r_int
id|qlogicfas_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|host
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/* these are only used by IRQ detect */
r_int
id|qltyp
suffix:semicolon
multiline_comment|/* type of chip */
r_struct
id|Scsi_Host
op_star
id|hreg
suffix:semicolon
multiline_comment|/* registered host structure */
r_int
r_int
id|flags
suffix:semicolon
id|host-&gt;proc_name
op_assign
l_string|&quot;qlogicfas&quot;
suffix:semicolon
multiline_comment|/* Qlogic Cards only exist at 0x230 or 0x330 (the chip itself decodes the&n;   address - I check 230 first since MIDI cards are typically at 330&n;&n;   Theoretically, two Qlogic cards can coexist in the same system.  This&n;   should work by simply using this as a loadable module for the second&n;   card, but I haven&squot;t tested this.&n;*/
r_if
c_cond
(paren
op_logical_neg
id|qbase
)paren
(brace
r_for
c_loop
(paren
id|qbase
op_assign
l_int|0x230
suffix:semicolon
id|qbase
OL
l_int|0x430
suffix:semicolon
id|qbase
op_add_assign
l_int|0x100
)paren
(brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|qbase
comma
l_int|0x10
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|REG1
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|0xe
)paren
op_xor
id|inb
c_func
(paren
id|qbase
op_plus
l_int|0xe
)paren
)paren
op_eq
l_int|7
)paren
op_logical_and
(paren
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|0xe
)paren
op_xor
id|inb
c_func
(paren
id|qbase
op_plus
l_int|0xe
)paren
)paren
op_eq
l_int|7
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|qbase
op_eq
l_int|0x430
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Ql: Using preset base address of %03x&bslash;n&quot;
comma
id|qbase
)paren
suffix:semicolon
id|qltyp
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|0xe
)paren
op_amp
l_int|0xf8
suffix:semicolon
id|qinitid
op_assign
id|host-&gt;this_id
suffix:semicolon
r_if
c_cond
(paren
id|qinitid
OL
l_int|0
)paren
id|qinitid
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* if no ID, use 7 */
id|outb
c_func
(paren
l_int|1
comma
id|qbase
op_plus
l_int|8
)paren
suffix:semicolon
multiline_comment|/* set for PIO pseudo DMA */
id|REG0
suffix:semicolon
id|outb
c_func
(paren
l_int|0x40
op_or
id|qlcfg8
op_or
id|qinitid
comma
id|qbase
op_plus
l_int|8
)paren
suffix:semicolon
multiline_comment|/* (ini) bus id, disable scsi rst */
id|outb
c_func
(paren
id|qlcfg5
comma
id|qbase
op_plus
l_int|5
)paren
suffix:semicolon
multiline_comment|/* select timer */
id|outb
c_func
(paren
id|qlcfg9
comma
id|qbase
op_plus
l_int|9
)paren
suffix:semicolon
multiline_comment|/* prescaler */
macro_line|#if QL_RESET_AT_START
id|outb
c_func
(paren
l_int|3
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
id|REG1
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|0xf
)paren
op_amp
l_int|4
)paren
(brace
suffix:semicolon
)brace
id|REG0
suffix:semicolon
macro_line|#endif
macro_line|#if QL_USE_IRQ
multiline_comment|/* IRQ probe - toggle pin and check request pending */
r_if
c_cond
(paren
id|qlirq
op_eq
op_minus
l_int|1
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|i
op_assign
l_int|0xffff
suffix:semicolon
id|j
op_assign
l_int|3
suffix:semicolon
id|outb
c_func
(paren
l_int|0x90
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* illegal command - cause interrupt */
id|REG1
suffix:semicolon
id|outb
c_func
(paren
l_int|10
comma
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/* access pending interrupt map */
id|outb
c_func
(paren
l_int|10
comma
l_int|0xa0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|j
op_decrement
)paren
(brace
id|outb
c_func
(paren
l_int|0xb0
op_or
id|QL_INT_ACTIVE_HIGH
comma
id|qbase
op_plus
l_int|0xd
)paren
suffix:semicolon
multiline_comment|/* int pin off */
id|i
op_and_assign
op_complement
(paren
id|inb
c_func
(paren
l_int|0x20
)paren
op_or
(paren
id|inb
c_func
(paren
l_int|0xa0
)paren
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
multiline_comment|/* find IRQ off */
id|outb
c_func
(paren
l_int|0xb4
op_or
id|QL_INT_ACTIVE_HIGH
comma
id|qbase
op_plus
l_int|0xd
)paren
suffix:semicolon
multiline_comment|/* int pin on */
id|i
op_and_assign
id|inb
c_func
(paren
l_int|0x20
)paren
op_or
(paren
id|inb
c_func
(paren
l_int|0xa0
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* find IRQ on */
)brace
id|REG0
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
)paren
suffix:semicolon
multiline_comment|/* purge int */
id|j
op_assign
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|i
)paren
multiline_comment|/* find on bit */
id|i
op_rshift_assign
l_int|1
comma
id|j
op_increment
suffix:semicolon
multiline_comment|/* should check for exactly 1 on */
id|qlirq
op_assign
id|j
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Ql: Using preset IRQ %d&bslash;n&quot;
comma
id|qlirq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qlirq
op_ge
l_int|0
op_logical_and
op_logical_neg
id|request_irq
c_func
(paren
id|qlirq
comma
id|do_ql_ihandl
comma
l_int|0
comma
l_string|&quot;qlogicfas&quot;
comma
l_int|NULL
)paren
)paren
id|host-&gt;can_queue
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|request_region
c_func
(paren
id|qbase
comma
l_int|0x10
comma
l_string|&quot;qlogicfas&quot;
)paren
suffix:semicolon
id|hreg
op_assign
id|scsi_register
c_func
(paren
id|host
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* no host data */
id|hreg-&gt;io_port
op_assign
id|qbase
suffix:semicolon
id|hreg-&gt;n_io_port
op_assign
l_int|16
suffix:semicolon
id|hreg-&gt;dma_channel
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|qlirq
op_ne
op_minus
l_int|1
)paren
(brace
id|hreg-&gt;irq
op_assign
id|qlirq
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|qinfo
comma
l_string|&quot;Qlogicfas Driver version 0.46, chip %02X at %03X, IRQ %d, TPdma:%d&quot;
comma
id|qltyp
comma
id|qbase
comma
id|qlirq
comma
id|QL_TURBO_PDMA
)paren
suffix:semicolon
id|host-&gt;name
op_assign
id|qinfo
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* return bios parameters */
DECL|function|qlogicfas_biosparam
r_int
id|qlogicfas_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
id|ip
(braket
)braket
)paren
(brace
multiline_comment|/* This should mimic the DOS Qlogic driver&squot;s behavior exactly */
id|ip
(braket
l_int|0
)braket
op_assign
l_int|0x40
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|0x20
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
id|disk-&gt;capacity
op_div
(paren
id|ip
(braket
l_int|0
)braket
op_star
id|ip
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
(braket
l_int|2
)braket
OG
l_int|1024
)paren
(brace
id|ip
(braket
l_int|0
)braket
op_assign
l_int|0xff
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|0x3f
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
id|disk-&gt;capacity
op_div
(paren
id|ip
(braket
l_int|0
)braket
op_star
id|ip
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|ip
(braket
l_int|2
)braket
OG
l_int|1023
)paren
id|ip
(braket
l_int|2
)braket
op_assign
l_int|1023
suffix:semicolon
macro_line|#endif
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* abort command in progress */
DECL|function|qlogicfas_abort
r_int
id|qlogicfas_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|qabort
op_assign
l_int|1
suffix:semicolon
id|ql_zap
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* reset SCSI bus */
DECL|function|qlogicfas_reset
r_int
id|qlogicfas_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_int
id|ignored
)paren
(brace
id|qabort
op_assign
l_int|2
suffix:semicolon
id|ql_zap
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* return info string */
DECL|function|qlogicfas_info
r_const
r_char
op_star
id|qlogicfas_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_return
id|qinfo
suffix:semicolon
)brace
multiline_comment|/* Eventually this will go into an include file, but this will be later */
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|QLOGICFAS
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
eof
