multiline_comment|/*&n; * Generic Generic NCR5380 driver&n; *&t;&n; * Copyright 1993, Drew Eckhardt&n; *&t;Visionary Computing&n; *&t;(Unix and Linux consulting and custom programming)&n; *&t;drew@colorado.edu&n; *      +1 (303) 440-4894&n; *&n; * NCR53C400 extensions (c) 1994,1995,1996, Kevin Lentin&n; *    K.Lentin@cs.monash.edu.au&n; *&n; * ALPHA RELEASE 1. &n; *&n; * For more information, please consult &n; *&n; * NCR 5380 Family&n; * SCSI Protocol Controller&n; * Databook&n; *&n; * NCR Microelectronics&n; * 1635 Aeroplaza Drive&n; * Colorado Springs, CO 80916&n; * 1+ (719) 578-3400&n; * 1+ (800) 334-5454&n; */
multiline_comment|/* &n; * TODO : flesh out DMA support, find some one actually using this (I have&n; * &t;a memory mapped Trantor board that works fine)&n; */
multiline_comment|/*&n; * Options :&n; *&n; * PARITY - enable parity checking.  Not supported.&n; *&n; * SCSI2 - enable support for SCSI-II tagged queueing.  Untested.&n; *&n; * USLEEP - enable support for devices that don&squot;t disconnect.  Untested.&n; *&n; * The card is detected and initialized in one of several ways : &n; * 1.  With command line overrides - NCR5380=port,irq may be &n; *     used on the LILO command line to override the defaults.&n; *&n; * 2.  With the GENERIC_NCR5380_OVERRIDE compile time define.  This is &n; *     specified as an array of address, irq, dma, board tuples.  Ie, for&n; *     one board at 0x350, IRQ5, no dma, I could say  &n; *     -DGENERIC_NCR5380_OVERRIDE={{0xcc000, 5, DMA_NONE, BOARD_NCR5380}}&n; * &n; * -1 should be specified for no or DMA interrupt, -2 to autoprobe for an &n; * &t;IRQ line if overridden on the command line.&n; */
multiline_comment|/*&n; * $Log: generic_NCR5380.c,v $&n; */
DECL|macro|AUTOPROBE_IRQ
mdefine_line|#define AUTOPROBE_IRQ
DECL|macro|AUTOSENSE
mdefine_line|#define AUTOSENSE
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef CONFIG_SCSI_GENERIC_NCR53C400
DECL|macro|NCR53C400_PSEUDO_DMA
mdefine_line|#define NCR53C400_PSEUDO_DMA 1
DECL|macro|PSEUDO_DMA
mdefine_line|#define PSEUDO_DMA
DECL|macro|NCR53C400
mdefine_line|#define NCR53C400
macro_line|#endif
macro_line|#if defined(CONFIG_SCSI_G_NCR5380_PORT) &amp;&amp; defined(CONFIG_SCSI_G_NCR5380_MEM)
macro_line|#error You can not configure the Generic NCR 5380 SCSI Driver for memory mapped I/O and port mapped I/O at the same time (yet)
macro_line|#endif
macro_line|#if !defined(CONFIG_SCSI_G_NCR5380_PORT) &amp;&amp; !defined(CONFIG_SCSI_G_NCR5380_MEM)
macro_line|#error You must configure the Generic NCR 5380 SCSI Driver for one of memory mapped I/O and port mapped I/O.
macro_line|#endif
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;g_NCR5380.h&quot;
macro_line|#include &quot;NCR5380.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include&lt;linux/stat.h&gt;
DECL|variable|proc_scsi_g_ncr5380
r_struct
id|proc_dir_entry
id|proc_scsi_g_ncr5380
op_assign
(brace
id|PROC_SCSI_GENERIC_NCR5380
comma
l_int|9
comma
l_string|&quot;g_NCR5380&quot;
comma
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
l_int|2
)brace
suffix:semicolon
DECL|struct|override
r_static
r_struct
id|override
(brace
DECL|member|NCR5380_implementation_fields
id|NCR5380_implementation_fields
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|dma
r_int
id|dma
suffix:semicolon
DECL|member|board
r_int
id|board
suffix:semicolon
multiline_comment|/* Use NCR53c400, Ricoh, etc. extensions ? */
DECL|variable|overrides
)brace
id|overrides
macro_line|#ifdef GENERIC_NCR5380_OVERRIDE 
(braket
)braket
op_assign
id|GENERIC_NCR5380_OVERRIDE
macro_line|#else
(braket
l_int|1
)braket
op_assign
(brace
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
macro_line|#endif
DECL|macro|NO_OVERRIDES
mdefine_line|#define NO_OVERRIDES (sizeof(overrides) / sizeof(struct override))
multiline_comment|/*&n; * Function : static internal_setup(int board, char *str, int *ints)&n; *&n; * Purpose : LILO command line initialization of the overrides array,&n; * &n; * Inputs : board - either BOARD_NCR5380 for a normal NCR5380 board, &n; * &t;or BOARD_NCR53C400 for a NCR53C400 board. str - unused, ints - &n; *&t;array of integer parameters with ints[0] equal to the number of ints.&n; *&n; */
r_static
r_void
id|internal_setup
c_func
(paren
r_int
id|board
comma
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_static
r_int
id|commandline_current
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|board
)paren
(brace
r_case
id|BOARD_NCR5380
suffix:colon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ne
l_int|2
op_logical_and
id|ints
(braket
l_int|0
)braket
op_ne
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;generic_NCR5380_setup : usage ncr5380=&quot;
id|STRVAL
c_func
(paren
id|NCR5380_map_name
)paren
l_string|&quot;,irq,dma&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|BOARD_NCR53C400
suffix:colon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ne
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;generic_NCR53C400_setup : usage ncr53c400= &quot;
id|STRVAL
c_func
(paren
id|NCR5380_map_name
)paren
l_string|&quot;,irq&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|commandline_current
OL
id|NO_OVERRIDES
)paren
(brace
id|overrides
(braket
id|commandline_current
)braket
dot
id|NCR5380_map_name
op_assign
(paren
id|NCR5380_map_type
)paren
id|ints
(braket
l_int|1
)braket
suffix:semicolon
id|overrides
(braket
id|commandline_current
)braket
dot
id|irq
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_eq
l_int|3
)paren
id|overrides
(braket
id|commandline_current
)braket
dot
id|dma
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
r_else
id|overrides
(braket
id|commandline_current
)braket
dot
id|dma
op_assign
id|DMA_NONE
suffix:semicolon
id|overrides
(braket
id|commandline_current
)braket
dot
id|board
op_assign
id|board
suffix:semicolon
op_increment
id|commandline_current
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function : generic_NCR5380_setup (char *str, int *ints)&n; *&n; * Purpose : LILO command line initialization of the overrides array,&n; * &n; * Inputs : str - unused, ints - array of integer paramters with ints[0] &n; * &t;equal to the number of ints.&n; */
r_void
id|generic_NCR5380_setup
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|internal_setup
(paren
id|BOARD_NCR5380
comma
id|str
comma
id|ints
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : generic_NCR53C400_setup (char *str, int *ints)&n; *&n; * Purpose : LILO command line initialization of the overrides array,&n; * &n; * Inputs : str - unused, ints - array of integer paramters with ints[0] &n; * &t;equal to the number of ints.&n; */
r_void
id|generic_NCR53C400_setup
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|internal_setup
(paren
id|BOARD_NCR53C400
comma
id|str
comma
id|ints
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : int generic_NCR5380_detect(Scsi_Host_Template * tpnt)&n; *&n; * Purpose : initializes generic NCR5380 driver based on the &n; *&t;command line / compile time port and irq definitions.&n; *&n; * Inputs : tpnt - template for this SCSI adapter.&n; * &n; * Returns : 1 if a host adapter was found, 0 if not.&n; *&n; */
r_int
id|generic_NCR5380_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_static
r_int
id|current_override
op_assign
l_int|0
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
id|tpnt-&gt;proc_dir
op_assign
op_amp
id|proc_scsi_g_ncr5380
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|current_override
OL
id|NO_OVERRIDES
suffix:semicolon
op_increment
id|current_override
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|NCR5380_map_name
)paren
)paren
r_continue
suffix:semicolon
r_switch
c_cond
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|board
)paren
(brace
r_case
id|BOARD_NCR5380
suffix:colon
id|flags
op_assign
id|FLAG_NO_PSEUDO_DMA
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOARD_NCR53C400
suffix:colon
id|flags
op_assign
id|FLAG_NCR53C400
suffix:semicolon
r_break
suffix:semicolon
)brace
id|instance
op_assign
id|scsi_register
(paren
id|tpnt
comma
r_sizeof
(paren
r_struct
id|NCR5380_hostdata
)paren
)paren
suffix:semicolon
id|instance-&gt;NCR5380_instance_name
op_assign
id|overrides
(braket
id|current_override
)braket
dot
id|NCR5380_map_name
suffix:semicolon
id|NCR5380_init
c_func
(paren
id|instance
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|irq
op_ne
id|IRQ_AUTO
)paren
id|instance-&gt;irq
op_assign
id|overrides
(braket
id|current_override
)braket
dot
id|irq
suffix:semicolon
r_else
id|instance-&gt;irq
op_assign
id|NCR5380_probe_irq
c_func
(paren
id|instance
comma
l_int|0xffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|instance-&gt;irq
op_ne
id|IRQ_NONE
)paren
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|instance-&gt;irq
comma
id|generic_NCR5380_intr
comma
id|SA_INTERRUPT
comma
l_string|&quot;NCR5380&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : IRQ%d not free, interrupts disabled&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|instance-&gt;irq
)paren
suffix:semicolon
id|instance-&gt;irq
op_assign
id|IRQ_NONE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|instance-&gt;irq
op_eq
id|IRQ_NONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : interrupts not enabled. for better interactive performance,&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : please jumper the board for a free IRQ.&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : at &quot;
id|STRVAL
c_func
(paren
id|NCR5380_map_name
)paren
l_string|&quot; 0x%x&quot;
comma
id|instance-&gt;host_no
comma
(paren
r_int
r_int
)paren
id|instance-&gt;NCR5380_instance_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|instance-&gt;irq
op_eq
id|IRQ_NONE
)paren
id|printk
(paren
l_string|&quot; interrupts disabled&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot; irq %d&quot;
comma
id|instance-&gt;irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; options CAN_QUEUE=%d  CMD_PER_LUN=%d release=%d&quot;
comma
id|CAN_QUEUE
comma
id|CMD_PER_LUN
comma
id|GENERIC_NCR5380_PUBLIC_RELEASE
)paren
suffix:semicolon
id|NCR5380_print_options
c_func
(paren
id|instance
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
op_increment
id|current_override
suffix:semicolon
op_increment
id|count
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
r_const
r_char
op_star
id|generic_NCR5380_info
(paren
r_void
)paren
(brace
r_static
r_const
r_char
id|string
(braket
)braket
op_assign
l_string|&quot;Generic NCR5380/53C400 Info&quot;
suffix:semicolon
r_return
id|string
suffix:semicolon
)brace
r_int
id|generic_NCR5380_release_resources
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|instance-&gt;irq
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef BIOSPARAM
multiline_comment|/*&n; * Function : int generic_NCR5380_biosparam(Disk * disk, kdev_t dev, int *ip)&n; *&n; * Purpose : Generates a BIOS / DOS compatable H-C-S mapping for &n; *&t;the specified device / size.&n; * &n; * Inputs : size = size of device in sectors (512 bytes), dev = block device&n; *&t;major / minor, ip[] = {heads, sectors, cylinders}  &n; *&n; * Returns : allways 0 (success), initializes ip&n; *&t;&n; */
multiline_comment|/* &n; * XXX Most SCSI boards use this mapping, I could be incorrect.  Some one&n; * using hard disks on a trantor should verify that this mapping corresponds&n; * to that used by the BIOS / ASPI driver by running the linux fdisk program&n; * and matching the H_C_S coordinates to what DOS uses.&n; */
r_int
id|generic_NCR5380_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
op_star
id|ip
)paren
(brace
r_int
id|size
op_assign
id|disk-&gt;capacity
suffix:semicolon
id|ip
(braket
l_int|0
)braket
op_assign
l_int|64
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|32
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
id|size
op_rshift
l_int|11
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_int
id|generic_NCR5380_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|inout
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|scsi_ptr
suffix:semicolon
r_for
c_loop
(paren
id|scsi_ptr
op_assign
id|first_instance
suffix:semicolon
id|scsi_ptr
suffix:semicolon
id|scsi_ptr
op_assign
id|scsi_ptr-&gt;next
)paren
r_if
c_cond
(paren
id|scsi_ptr-&gt;host_no
op_eq
id|hostno
)paren
r_break
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;SCSI host number %d : %s&bslash;n&quot;
comma
id|scsi_ptr-&gt;host_no
comma
id|scsi_ptr-&gt;hostt-&gt;name
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Generic NCR5380 driver version %d&bslash;n&quot;
comma
id|GENERIC_NCR5380_PUBLIC_RELEASE
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;NCR5380 driver core version %d&bslash;n&quot;
comma
id|NCR5380_PUBLIC_RELEASE
)paren
suffix:semicolon
macro_line|#ifdef NCR53C400
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;NCR53C400 driver extension version %d&bslash;n&quot;
comma
id|NCR53C400_PUBLIC_RELEASE
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;NCR53C400 card%s detected&bslash;n&quot;
comma
(paren
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|scsi_ptr-&gt;hostdata
)paren
op_member_access_from_pointer
id|flags
op_amp
id|FLAG_NCR53C400
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; not&quot;
)paren
suffix:semicolon
macro_line|# if NCR53C400_PSEUDO_DMA
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;NCR53C400 pseudo DMA being used&bslash;n&quot;
)paren
suffix:semicolon
macro_line|# endif
macro_line|#else
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;NO NCR53C400 driver extensions&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Using %s mapping at %s 0x%x, &quot;
comma
id|STRVAL
c_func
(paren
id|NCR5380_map_config
)paren
comma
id|STRVAL
c_func
(paren
id|NCR5380_map_name
)paren
comma
id|scsi_ptr-&gt;NCR5380_instance_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_ptr-&gt;irq
op_eq
id|IRQ_NONE
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;interrupts disabled&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;on interrupt %d&bslash;n&quot;
comma
id|scsi_ptr-&gt;irq
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
id|len
op_sub_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#if NCR53C400_PSEUDO_DMA
r_static
r_inline
r_int
id|NCR5380_pread
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
r_char
op_star
id|dst
comma
r_int
id|len
)paren
(brace
r_int
id|blocks
op_assign
id|len
op_div
l_int|128
suffix:semicolon
r_int
id|start
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|bl
suffix:semicolon
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
id|printk
c_func
(paren
l_string|&quot;53C400r: About to read %d blocks for %d bytes&bslash;n&quot;
comma
id|blocks
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|C400_CONTROL_STATUS_REG
comma
id|CSR_BASE
op_or
id|CSR_TRANS_DIR
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|C400_BLOCK_COUNTER_REG
comma
id|blocks
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
id|printk
c_func
(paren
l_string|&quot;53C400r: %d blocks left&bslash;n&quot;
comma
id|blocks
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|bl
op_assign
id|NCR5380_read
c_func
(paren
id|C400_BLOCK_COUNTER_REG
)paren
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
r_if
c_cond
(paren
id|blocks
)paren
id|printk
c_func
(paren
l_string|&quot;53C400r: blocks still == %d&bslash;n&quot;
comma
id|blocks
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;53C400r: Exiting loop&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
macro_line|#if 1
r_if
c_cond
(paren
id|NCR5380_read
c_func
(paren
id|C400_CONTROL_STATUS_REG
)paren
op_amp
id|CSR_GATED_53C80_IRQ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;53C400r: Got 53C80_IRQ start=%d, blocks=%d&bslash;n&quot;
comma
id|start
comma
id|blocks
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
id|printk
c_func
(paren
l_string|&quot;53C400r: Waiting for buffer, bl=%d&bslash;n&quot;
comma
id|bl
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|C400_CONTROL_STATUS_REG
)paren
op_amp
id|CSR_HOST_BUF_NOT_RDY
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
id|printk
c_func
(paren
l_string|&quot;53C400r: Transferring 128 bytes&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SCSI_G_NCR5380_PORT
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|128
suffix:semicolon
id|i
op_increment
)paren
id|dst
(braket
id|start
op_plus
id|i
)braket
op_assign
id|NCR5380_read
c_func
(paren
id|C400_HOST_BUFFER
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* implies CONFIG_SCSI_G_NCR5380_MEM */
id|memmove
c_func
(paren
id|dst
op_plus
id|start
comma
id|NCR53C400_host_buffer
op_plus
id|NCR5380_map_name
comma
l_int|128
)paren
suffix:semicolon
macro_line|#endif
id|start
op_add_assign
l_int|128
suffix:semicolon
id|blocks
op_decrement
suffix:semicolon
)brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
id|printk
c_func
(paren
l_string|&quot;53C400r: EXTRA: Waiting for buffer&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|C400_CONTROL_STATUS_REG
)paren
op_amp
id|CSR_HOST_BUF_NOT_RDY
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
id|printk
c_func
(paren
l_string|&quot;53C400r: Transferring EXTRA 128 bytes&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SCSI_G_NCR5380_PORT
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|128
suffix:semicolon
id|i
op_increment
)paren
id|dst
(braket
id|start
op_plus
id|i
)braket
op_assign
id|NCR5380_read
c_func
(paren
id|C400_HOST_BUFFER
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* implies CONFIG_SCSI_G_NCR5380_MEM */
id|memmove
c_func
(paren
id|dst
op_plus
id|start
comma
id|NCR53C400_host_buffer
op_plus
id|NCR5380_map_name
comma
l_int|128
)paren
suffix:semicolon
macro_line|#endif
id|start
op_add_assign
l_int|128
suffix:semicolon
id|blocks
op_decrement
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
id|printk
c_func
(paren
l_string|&quot;53C400r: Final values: blocks=%d   start=%d&bslash;n&quot;
comma
id|blocks
comma
id|start
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|C400_CONTROL_STATUS_REG
)paren
op_amp
id|CSR_GATED_53C80_IRQ
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;53C400r: no 53C80 gated irq after transfer&quot;
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
r_else
id|printk
c_func
(paren
l_string|&quot;53C400r: Got 53C80 interupt and tried to clear it&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* DON&squot;T DO THIS - THEY NEVER ARRIVE!&n;    printk(&quot;53C400r: Waiting for 53C80 registers&bslash;n&quot;);&n;    while (NCR5380_read(C400_CONTROL_STATUS_REG) &amp; CSR_53C80_REG)&n;&t;;&n;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_END_DMA_TRANSFER
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;53C400r: no end dma signal&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
r_else
id|printk
c_func
(paren
l_string|&quot;53C400r: end dma as expected&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
id|NCR5380_pwrite
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
r_char
op_star
id|src
comma
r_int
id|len
)paren
(brace
r_int
id|blocks
op_assign
id|len
op_div
l_int|128
suffix:semicolon
r_int
id|start
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|bl
suffix:semicolon
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w: About to write %d blocks for %d bytes&bslash;n&quot;
comma
id|blocks
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|C400_CONTROL_STATUS_REG
comma
id|CSR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|C400_BLOCK_COUNTER_REG
comma
id|blocks
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|NCR5380_read
c_func
(paren
id|C400_CONTROL_STATUS_REG
)paren
op_amp
id|CSR_GATED_53C80_IRQ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;53C400w: Got 53C80_IRQ start=%d, blocks=%d&bslash;n&quot;
comma
id|start
comma
id|blocks
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bl
op_assign
id|NCR5380_read
c_func
(paren
id|C400_BLOCK_COUNTER_REG
)paren
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
r_if
c_cond
(paren
id|blocks
)paren
id|printk
c_func
(paren
l_string|&quot;53C400w: exiting loop, blocks still == %d&bslash;n&quot;
comma
id|blocks
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;53C400w: exiting loop&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w: %d blocks left&bslash;n&quot;
comma
id|blocks
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;53C400w: waiting for buffer, bl=%d&bslash;n&quot;
comma
id|bl
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|C400_CONTROL_STATUS_REG
)paren
op_amp
id|CSR_HOST_BUF_NOT_RDY
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w: transferring 128 bytes&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SCSI_G_NCR5380_PORT
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|128
suffix:semicolon
id|i
op_increment
)paren
id|NCR5380_write
c_func
(paren
id|C400_HOST_BUFFER
comma
id|src
(braket
id|start
op_plus
id|i
)braket
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* implies CONFIG_SCSI_G_NCR5380_MEM */
id|memmove
c_func
(paren
id|NCR53C400_host_buffer
op_plus
id|NCR5380_map_name
comma
id|src
op_plus
id|start
comma
l_int|128
)paren
suffix:semicolon
macro_line|#endif
id|start
op_add_assign
l_int|128
suffix:semicolon
id|blocks
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blocks
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w: EXTRA waiting for buffer&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|C400_CONTROL_STATUS_REG
)paren
op_amp
id|CSR_HOST_BUF_NOT_RDY
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w: transferring EXTRA 128 bytes&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SCSI_G_NCR5380_PORT
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|128
suffix:semicolon
id|i
op_increment
)paren
id|NCR5380_write
c_func
(paren
id|C400_HOST_BUFFER
comma
id|src
(braket
id|start
op_plus
id|i
)braket
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* implies CONFIG_SCSI_G_NCR5380_MEM */
id|memmove
c_func
(paren
id|NCR53C400_host_buffer
op_plus
id|NCR5380_map_name
comma
id|src
op_plus
id|start
comma
l_int|128
)paren
suffix:semicolon
macro_line|#endif
id|start
op_add_assign
l_int|128
suffix:semicolon
id|blocks
op_decrement
suffix:semicolon
)brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
r_else
id|printk
c_func
(paren
l_string|&quot;53C400w: No EXTRA required&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w: Final values: blocks=%d   start=%d&bslash;n&quot;
comma
id|blocks
comma
id|start
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;53C400w: waiting for registers to be available&bslash;n&quot;
)paren
suffix:semicolon
id|THEY
id|NEVER
id|DO
op_logical_neg
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|C400_CONTROL_STATUS_REG
)paren
op_amp
id|CSR_53C80_REG
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;53C400w: Got em&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Let&squot;s wait for this instead - could be ugly */
multiline_comment|/* All documentation says to check for this. Maybe my hardware is too&n;     * fast. Waiting for it seems to work fine! KLL&n;     */
r_while
c_loop
(paren
op_logical_neg
(paren
id|i
op_assign
id|NCR5380_read
c_func
(paren
id|C400_CONTROL_STATUS_REG
)paren
op_amp
id|CSR_GATED_53C80_IRQ
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * I know. i is certainly != 0 here but the loop is new. See previous&n;     * comment.&n;     */
r_if
c_cond
(paren
id|i
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|prink
c_func
(paren
l_string|&quot;53C400w: got 53C80 gated irq (last block)&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|i
op_assign
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
)paren
op_amp
id|BASR_END_DMA_TRANSFER
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;53C400w: No END OF DMA bit - WHOOPS! BASR=%0x&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
r_else
id|printk
c_func
(paren
l_string|&quot;53C400w: Got END OF DMA&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;53C400w: no 53C80 gated irq after transfer (last block)&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_END_DMA_TRANSFER
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;53C400w: no end dma signal&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w: waiting for last byte...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|TARGET_COMMAND_REG
)paren
op_amp
id|TCR_LAST_BYTE_SENT
)paren
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w:     got last byte.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;53C400w: pwrite exiting with status 0, whoopee!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* PSEUDO_DMA */
macro_line|#include &quot;NCR5380.c&quot;
macro_line|#ifdef MODULE
multiline_comment|/* Eventually this will go into an include file, but this will be later */
id|Scsi_Host_Template
id|driver_template
op_assign
id|GENERIC_NCR5380
suffix:semicolon
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &quot;scsi_module.c&quot;
macro_line|#endif
eof
