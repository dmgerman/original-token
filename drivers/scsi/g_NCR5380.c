multiline_comment|/*&n; * Generic Generic NCR5380 driver&n; *&t;&n; * Copyright 1993, Drew Eckhardt&n; *&t;Visionary Computing&n; *&t;(Unix and Linux consulting and custom programming)&n; *&t;drew@colorado.edu&n; *      +1 (303) 440-4894&n; *&n; * NCR53C400 extensions (c) 1994,1995,1996, Kevin Lentin&n; *    K.Lentin@cs.monash.edu.au&n; *&n; * NCR53C400A extensions (c) 1996, Ingmar Baumgart&n; *    ingmar@gonzo.schwaben.de&n; *&n; * DTC3181E extensions (c) 1997, Ronald van Cuijlenborg&n; * ronald.van.cuijlenborg@tip.nl or nutty@dds.nl&n; *&n; * Added ISAPNP support for DTC436 adapters,&n; * Thomas Sailer, sailer@ife.ee.ethz.ch&n; *&n; * ALPHA RELEASE 1. &n; *&n; * For more information, please consult &n; *&n; * NCR 5380 Family&n; * SCSI Protocol Controller&n; * Databook&n; *&n; * NCR Microelectronics&n; * 1635 Aeroplaza Drive&n; * Colorado Springs, CO 80916&n; * 1+ (719) 578-3400&n; * 1+ (800) 334-5454&n; */
multiline_comment|/* &n; * TODO : flesh out DMA support, find some one actually using this (I have&n; * &t;a memory mapped Trantor board that works fine)&n; */
multiline_comment|/*&n; * Options :&n; *&n; * PARITY - enable parity checking.  Not supported.&n; *&n; * SCSI2 - enable support for SCSI-II tagged queueing.  Untested.&n; *&n; * USLEEP - enable support for devices that don&squot;t disconnect.  Untested.&n; *&n; * The card is detected and initialized in one of several ways : &n; * 1.  With command line overrides - NCR5380=port,irq may be &n; *     used on the LILO command line to override the defaults.&n; *&n; * 2.  With the GENERIC_NCR5380_OVERRIDE compile time define.  This is &n; *     specified as an array of address, irq, dma, board tuples.  Ie, for&n; *     one board at 0x350, IRQ5, no dma, I could say  &n; *     -DGENERIC_NCR5380_OVERRIDE={{0xcc000, 5, DMA_NONE, BOARD_NCR5380}}&n; * &n; * -1 should be specified for no or DMA interrupt, -2 to autoprobe for an &n; * &t;IRQ line if overridden on the command line.&n; *&n; * 3.  When included as a module, with arguments passed on the command line:&n; *         ncr_irq=xx&t;the interrupt&n; *         ncr_addr=xx  the port or base address (for port or memory&n; *              &t;mapped, resp.)&n; *         ncr_dma=xx&t;the DMA&n; *         ncr_5380=1&t;to set up for a NCR5380 board&n; *         ncr_53c400=1&t;to set up for a NCR53C400 board&n; *     e.g.&n; *     modprobe g_NCR5380 ncr_irq=5 ncr_addr=0x350 ncr_5380=1&n; *       for a port mapped NCR5380 board or&n; *     modprobe g_NCR5380 ncr_irq=255 ncr_addr=0xc8000 ncr_53c400=1&n; *       for a memory mapped NCR53C400 board with interrupts disabled.&n; * &n; * 255 should be specified for no or DMA interrupt, 254 to autoprobe for an &n; * &t;IRQ line if overridden on the command line.&n; *     &n; */
multiline_comment|/*&n; * $Log: generic_NCR5380.c,v $&n; */
multiline_comment|/* settings for DTC3181E card with only Mustek scanner attached */
DECL|macro|USLEEP
mdefine_line|#define USLEEP
DECL|macro|USLEEP_POLL
mdefine_line|#define USLEEP_POLL&t;1
DECL|macro|USLEEP_SLEEP
mdefine_line|#define USLEEP_SLEEP&t;20
DECL|macro|USLEEP_WAITLONG
mdefine_line|#define USLEEP_WAITLONG&t;500
DECL|macro|AUTOPROBE_IRQ
mdefine_line|#define AUTOPROBE_IRQ
DECL|macro|AUTOSENSE
mdefine_line|#define AUTOSENSE
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef CONFIG_SCSI_GENERIC_NCR53C400
DECL|macro|NCR53C400_PSEUDO_DMA
mdefine_line|#define NCR53C400_PSEUDO_DMA 1
DECL|macro|PSEUDO_DMA
mdefine_line|#define PSEUDO_DMA
DECL|macro|NCR53C400
mdefine_line|#define NCR53C400
DECL|macro|NCR5380_STATS
mdefine_line|#define NCR5380_STATS
DECL|macro|NCR5380_STAT_LIMIT
macro_line|#undef NCR5380_STAT_LIMIT
macro_line|#endif
macro_line|#if defined(CONFIG_SCSI_G_NCR5380_PORT) &amp;&amp; defined(CONFIG_SCSI_G_NCR5380_MEM)
macro_line|#error You can not configure the Generic NCR 5380 SCSI Driver for memory mapped I/O and port mapped I/O at the same time (yet)
macro_line|#endif
macro_line|#if !defined(CONFIG_SCSI_G_NCR5380_PORT) &amp;&amp; !defined(CONFIG_SCSI_G_NCR5380_MEM)
macro_line|#error You must configure the Generic NCR 5380 SCSI Driver for one of memory mapped I/O and port mapped I/O.
macro_line|#endif
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;g_NCR5380.h&quot;
macro_line|#include &quot;NCR5380.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/isapnp.h&gt;
DECL|macro|NCR_NOT_SET
mdefine_line|#define NCR_NOT_SET 0
DECL|variable|ncr_irq
r_static
r_int
id|ncr_irq
op_assign
id|NCR_NOT_SET
suffix:semicolon
DECL|variable|ncr_dma
r_static
r_int
id|ncr_dma
op_assign
id|NCR_NOT_SET
suffix:semicolon
DECL|variable|ncr_addr
r_static
r_int
id|ncr_addr
op_assign
id|NCR_NOT_SET
suffix:semicolon
DECL|variable|ncr_5380
r_static
r_int
id|ncr_5380
op_assign
id|NCR_NOT_SET
suffix:semicolon
DECL|variable|ncr_53c400
r_static
r_int
id|ncr_53c400
op_assign
id|NCR_NOT_SET
suffix:semicolon
DECL|variable|ncr_53c400a
r_static
r_int
id|ncr_53c400a
op_assign
id|NCR_NOT_SET
suffix:semicolon
DECL|variable|dtc_3181e
r_static
r_int
id|dtc_3181e
op_assign
id|NCR_NOT_SET
suffix:semicolon
DECL|struct|override
r_static
r_struct
id|override
(brace
DECL|member|NCR5380_implementation_fields
id|NCR5380_implementation_fields
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|dma
r_int
id|dma
suffix:semicolon
DECL|member|board
r_int
id|board
suffix:semicolon
multiline_comment|/* Use NCR53c400, Ricoh, etc. extensions ? */
)brace
id|overrides
macro_line|#ifdef GENERIC_NCR5380_OVERRIDE 
DECL|variable|__initdata
(braket
)braket
id|__initdata
op_assign
id|GENERIC_NCR5380_OVERRIDE
macro_line|#else
(braket
l_int|1
)braket
id|__initdata
op_assign
(brace
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
macro_line|#endif
DECL|macro|NO_OVERRIDES
mdefine_line|#define NO_OVERRIDES (sizeof(overrides) / sizeof(struct override))
multiline_comment|/*&n; * Function : static internal_setup(int board, char *str, int *ints)&n; *&n; * Purpose : LILO command line initialization of the overrides array,&n; * &n; * Inputs : board - either BOARD_NCR5380 for a normal NCR5380 board, &n; * &t;or BOARD_NCR53C400 for a NCR53C400 board. str - unused, ints - &n; *&t;array of integer parameters with ints[0] equal to the number of ints.&n; *&n; */
r_static
r_void
id|__init
(def_block
id|internal_setup
c_func
(paren
r_int
id|board
comma
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_static
r_int
id|commandline_current
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|board
)paren
(brace
r_case
id|BOARD_NCR5380
suffix:colon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ne
l_int|2
op_logical_and
id|ints
(braket
l_int|0
)braket
op_ne
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;generic_NCR5380_setup : usage ncr5380=&quot;
id|STRVAL
c_func
(paren
id|NCR5380_map_name
)paren
l_string|&quot;,irq,dma&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BOARD_NCR53C400
suffix:colon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ne
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;generic_NCR53C400_setup : usage ncr53c400=&quot;
id|STRVAL
c_func
(paren
id|NCR5380_map_name
)paren
l_string|&quot;,irq&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BOARD_NCR53C400A
suffix:colon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ne
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;generic_NCR53C400A_setup : usage ncr53c400a=&quot;
id|STRVAL
c_func
(paren
id|NCR5380_map_name
)paren
l_string|&quot;,irq&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BOARD_DTC3181E
suffix:colon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ne
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;generic_DTC3181E_setup : usage dtc3181e=&quot;
id|STRVAL
c_func
(paren
id|NCR5380_map_name
)paren
l_string|&quot;,irq&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|commandline_current
OL
id|NO_OVERRIDES
)paren
(brace
id|overrides
(braket
id|commandline_current
)braket
dot
id|NCR5380_map_name
op_assign
(paren
id|NCR5380_map_type
)paren
id|ints
(braket
l_int|1
)braket
suffix:semicolon
id|overrides
(braket
id|commandline_current
)braket
dot
id|irq
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_eq
l_int|3
)paren
id|overrides
(braket
id|commandline_current
)braket
dot
id|dma
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
r_else
id|overrides
(braket
id|commandline_current
)braket
dot
id|dma
op_assign
id|DMA_NONE
suffix:semicolon
id|overrides
(braket
id|commandline_current
)braket
dot
id|board
op_assign
id|board
suffix:semicolon
op_increment
id|commandline_current
suffix:semicolon
)brace
)brace
)def_block
multiline_comment|/*&n; * Function : generic_NCR5380_setup (char *str, int *ints)&n; *&n; * Purpose : LILO command line initialization of the overrides array,&n; * &n; * Inputs : str - unused, ints - array of integer parameters with ints[0] &n; * &t;equal to the number of ints.&n; */
r_void
id|__init
id|generic_NCR5380_setup
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|internal_setup
(paren
id|BOARD_NCR5380
comma
id|str
comma
id|ints
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : generic_NCR53C400_setup (char *str, int *ints)&n; *&n; * Purpose : LILO command line initialization of the overrides array,&n; * &n; * Inputs : str - unused, ints - array of integer parameters with ints[0] &n; * &t;equal to the number of ints.&n; */
r_void
id|__init
id|generic_NCR53C400_setup
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|internal_setup
(paren
id|BOARD_NCR53C400
comma
id|str
comma
id|ints
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : generic_NCR53C400A_setup (char *str, int *ints)&n; *&n; * Purpose : LILO command line initialization of the overrides array,&n; * &n; * Inputs : str - unused, ints - array of integer parameters with ints[0] &n; * &t;equal to the number of ints.&n; */
r_void
id|generic_NCR53C400A_setup
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|internal_setup
(paren
id|BOARD_NCR53C400A
comma
id|str
comma
id|ints
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : generic_DTC3181E_setup (char *str, int *ints)&n; *&n; * Purpose : LILO command line initialization of the overrides array,&n; * &n; * Inputs : str - unused, ints - array of integer parameters with ints[0] &n; * &t;equal to the number of ints.&n; */
r_void
id|generic_DTC3181E_setup
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|internal_setup
(paren
id|BOARD_DTC3181E
comma
id|str
comma
id|ints
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : int generic_NCR5380_detect(Scsi_Host_Template * tpnt)&n; *&n; * Purpose : initializes generic NCR5380 driver based on the &n; *&t;command line / compile time port and irq definitions.&n; *&n; * Inputs : tpnt - template for this SCSI adapter.&n; * &n; * Returns : 1 if a host adapter was found, 0 if not.&n; *&n; */
r_int
id|__init
(def_block
id|generic_NCR5380_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_static
r_int
id|current_override
op_assign
l_int|0
suffix:semicolon
r_int
id|count
comma
id|i
suffix:semicolon
id|u_int
op_star
id|ports
suffix:semicolon
id|u_int
id|ncr_53c400a_ports
(braket
)braket
op_assign
(brace
l_int|0x280
comma
l_int|0x290
comma
l_int|0x300
comma
l_int|0x310
comma
l_int|0x330
comma
l_int|0x340
comma
l_int|0x348
comma
l_int|0x350
comma
l_int|0
)brace
suffix:semicolon
id|u_int
id|dtc_3181e_ports
(braket
)braket
op_assign
(brace
l_int|0x220
comma
l_int|0x240
comma
l_int|0x280
comma
l_int|0x2a0
comma
l_int|0x2c0
comma
l_int|0x300
comma
l_int|0x320
comma
l_int|0x340
comma
l_int|0
)brace
suffix:semicolon
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_if
c_cond
(paren
id|ncr_irq
op_ne
id|NCR_NOT_SET
)paren
id|overrides
(braket
l_int|0
)braket
dot
id|irq
op_assign
id|ncr_irq
suffix:semicolon
r_if
c_cond
(paren
id|ncr_dma
op_ne
id|NCR_NOT_SET
)paren
id|overrides
(braket
l_int|0
)braket
dot
id|dma
op_assign
id|ncr_dma
suffix:semicolon
r_if
c_cond
(paren
id|ncr_addr
op_ne
id|NCR_NOT_SET
)paren
id|overrides
(braket
l_int|0
)braket
dot
id|NCR5380_map_name
op_assign
(paren
id|NCR5380_map_type
)paren
id|ncr_addr
suffix:semicolon
r_if
c_cond
(paren
id|ncr_5380
op_ne
id|NCR_NOT_SET
)paren
id|overrides
(braket
l_int|0
)braket
dot
id|board
op_assign
id|BOARD_NCR5380
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ncr_53c400
op_ne
id|NCR_NOT_SET
)paren
id|overrides
(braket
l_int|0
)braket
dot
id|board
op_assign
id|BOARD_NCR53C400
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ncr_53c400a
op_ne
id|NCR_NOT_SET
)paren
id|overrides
(braket
l_int|0
)braket
dot
id|board
op_assign
id|BOARD_NCR53C400A
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dtc_3181e
op_ne
id|NCR_NOT_SET
)paren
id|overrides
(braket
l_int|0
)braket
dot
id|board
op_assign
id|BOARD_DTC3181E
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|current_override
op_logical_and
id|isapnp_present
c_func
(paren
)paren
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dev
op_assign
id|isapnp_find_dev
c_func
(paren
l_int|NULL
comma
id|ISAPNP_VENDOR
c_func
(paren
l_char|&squot;D&squot;
comma
l_char|&squot;T&squot;
comma
l_char|&squot;C&squot;
)paren
comma
id|ISAPNP_FUNCTION
c_func
(paren
l_int|0x436e
)paren
comma
id|dev
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|count
op_ge
id|NO_OVERRIDES
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;active
op_logical_and
id|dev
op_member_access_from_pointer
id|prepare
c_func
(paren
id|dev
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;dtc436e probe: prepare failed&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;resource
(braket
l_int|0
)braket
dot
id|flags
op_amp
id|IORESOURCE_IO
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;active
op_logical_and
id|dev
op_member_access_from_pointer
id|activate
c_func
(paren
id|dev
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;dtc436e probe: activate failed&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;irq_resource
(braket
l_int|0
)braket
dot
id|flags
op_amp
id|IORESOURCE_IRQ
)paren
id|overrides
(braket
id|count
)braket
dot
id|irq
op_assign
id|dev-&gt;irq_resource
(braket
l_int|0
)braket
dot
id|start
suffix:semicolon
r_else
id|overrides
(braket
id|count
)braket
dot
id|irq
op_assign
id|IRQ_NONE
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;dma_resource
(braket
l_int|0
)braket
dot
id|flags
op_amp
id|IORESOURCE_DMA
)paren
id|overrides
(braket
id|count
)braket
dot
id|dma
op_assign
id|dev-&gt;dma_resource
(braket
l_int|0
)braket
dot
id|start
suffix:semicolon
r_else
id|overrides
(braket
id|count
)braket
dot
id|dma
op_assign
id|DMA_NONE
suffix:semicolon
id|overrides
(braket
id|count
)braket
dot
id|NCR5380_map_name
op_assign
(paren
id|NCR5380_map_type
)paren
id|dev-&gt;resource
(braket
l_int|0
)braket
dot
id|start
suffix:semicolon
id|overrides
(braket
id|count
)braket
dot
id|board
op_assign
id|BOARD_DTC3181E
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
)brace
id|tpnt-&gt;proc_name
op_assign
l_string|&quot;g_NCR5380&quot;
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|current_override
OL
id|NO_OVERRIDES
suffix:semicolon
op_increment
id|current_override
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|NCR5380_map_name
)paren
)paren
r_continue
suffix:semicolon
id|ports
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|board
)paren
(brace
r_case
id|BOARD_NCR5380
suffix:colon
id|flags
op_assign
id|FLAG_NO_PSEUDO_DMA
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOARD_NCR53C400
suffix:colon
id|flags
op_assign
id|FLAG_NCR53C400
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOARD_NCR53C400A
suffix:colon
id|flags
op_assign
id|FLAG_NO_PSEUDO_DMA
suffix:semicolon
id|ports
op_assign
id|ncr_53c400a_ports
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOARD_DTC3181E
suffix:colon
id|flags
op_assign
id|FLAG_NO_PSEUDO_DMA
op_or
id|FLAG_DTC3181E
suffix:semicolon
id|ports
op_assign
id|dtc_3181e_ports
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SCSI_G_NCR5380_PORT
r_if
c_cond
(paren
id|ports
)paren
(brace
multiline_comment|/* wakeup sequence for the NCR53C400A and DTC3181E*/
multiline_comment|/* Disable the adapter and look for a free io port */
id|outb
c_func
(paren
l_int|0x59
comma
l_int|0x779
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xb9
comma
l_int|0x379
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xc5
comma
l_int|0x379
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xae
comma
l_int|0x379
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xa6
comma
l_int|0x379
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
l_int|0x379
)paren
suffix:semicolon
r_if
c_cond
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|NCR5380_map_name
op_ne
id|PORT_AUTO
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|ports
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|NCR5380_map_name
op_eq
id|ports
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
)brace
r_else
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|ports
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|check_region
c_func
(paren
id|ports
(braket
id|i
)braket
comma
l_int|16
)paren
)paren
op_logical_and
(paren
id|inb
c_func
(paren
id|ports
(braket
id|i
)braket
)paren
op_eq
l_int|0xff
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ports
(braket
id|i
)braket
)paren
(brace
id|outb
c_func
(paren
l_int|0x59
comma
l_int|0x779
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xb9
comma
l_int|0x379
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xc5
comma
l_int|0x379
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xae
comma
l_int|0x379
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xa6
comma
l_int|0x379
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x80
op_or
id|i
comma
l_int|0x379
)paren
suffix:semicolon
multiline_comment|/* set io port to be used */
id|outb
c_func
(paren
l_int|0xc0
comma
id|ports
(braket
id|i
)braket
op_plus
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|ports
(braket
id|i
)braket
op_plus
l_int|9
)paren
op_ne
l_int|0x80
)paren
r_continue
suffix:semicolon
r_else
id|overrides
(braket
id|current_override
)braket
dot
id|NCR5380_map_name
op_assign
id|ports
(braket
id|i
)braket
suffix:semicolon
)brace
r_else
r_continue
suffix:semicolon
)brace
id|request_region
c_func
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|NCR5380_map_name
comma
id|NCR5380_region_size
comma
l_string|&quot;ncr5380&quot;
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|check_mem_region
c_func
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|NCR5380_map_name
comma
id|NCR5380_region_size
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|request_mem_region
c_func
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|NCR5380_map_name
comma
id|NCR5380_region_size
comma
l_string|&quot;ncr5380&quot;
)paren
suffix:semicolon
macro_line|#endif
id|instance
op_assign
id|scsi_register
(paren
id|tpnt
comma
r_sizeof
(paren
r_struct
id|NCR5380_hostdata
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|instance
op_eq
l_int|NULL
)paren
(brace
macro_line|#ifdef CONFIG_SCSI_G_NCR5380_PORT
id|release_region
c_func
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|NCR5380_map_name
comma
id|NCR5380_region_size
)paren
suffix:semicolon
macro_line|#else
id|release_mem_region
c_func
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|NCR5380_map_name
comma
id|NCR5380_region_size
)paren
suffix:semicolon
macro_line|#endif
)brace
id|instance-&gt;NCR5380_instance_name
op_assign
id|overrides
(braket
id|current_override
)braket
dot
id|NCR5380_map_name
suffix:semicolon
id|NCR5380_init
c_func
(paren
id|instance
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|overrides
(braket
id|current_override
)braket
dot
id|irq
op_ne
id|IRQ_AUTO
)paren
id|instance-&gt;irq
op_assign
id|overrides
(braket
id|current_override
)braket
dot
id|irq
suffix:semicolon
r_else
id|instance-&gt;irq
op_assign
id|NCR5380_probe_irq
c_func
(paren
id|instance
comma
l_int|0xffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|instance-&gt;irq
op_ne
id|IRQ_NONE
)paren
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|instance-&gt;irq
comma
id|do_generic_NCR5380_intr
comma
id|SA_INTERRUPT
comma
l_string|&quot;NCR5380&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : IRQ%d not free, interrupts disabled&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|instance-&gt;irq
)paren
suffix:semicolon
id|instance-&gt;irq
op_assign
id|IRQ_NONE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|instance-&gt;irq
op_eq
id|IRQ_NONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : interrupts not enabled. for better interactive performance,&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : please jumper the board for a free IRQ.&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : at &quot;
id|STRVAL
c_func
(paren
id|NCR5380_map_name
)paren
l_string|&quot; 0x%x&quot;
comma
id|instance-&gt;host_no
comma
(paren
r_int
r_int
)paren
id|instance-&gt;NCR5380_instance_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|instance-&gt;irq
op_eq
id|IRQ_NONE
)paren
id|printk
(paren
l_string|&quot; interrupts disabled&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot; irq %d&quot;
comma
id|instance-&gt;irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; options CAN_QUEUE=%d  CMD_PER_LUN=%d release=%d&quot;
comma
id|CAN_QUEUE
comma
id|CMD_PER_LUN
comma
id|GENERIC_NCR5380_PUBLIC_RELEASE
)paren
suffix:semicolon
id|NCR5380_print_options
c_func
(paren
id|instance
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
op_increment
id|current_override
suffix:semicolon
op_increment
id|count
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
)def_block
r_const
r_char
op_star
id|generic_NCR5380_info
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_static
r_const
r_char
id|string
(braket
)braket
op_assign
l_string|&quot;Generic NCR5380/53C400 Driver&quot;
suffix:semicolon
r_return
id|string
suffix:semicolon
)brace
r_int
id|generic_NCR5380_release_resources
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SCSI_G_NCR5380_PORT
id|release_region
c_func
(paren
id|instance-&gt;NCR5380_instance_name
comma
id|NCR5380_region_size
)paren
suffix:semicolon
macro_line|#else
id|release_mem_region
c_func
(paren
id|instance-&gt;NCR5380_instance_name
comma
id|NCR5380_region_size
)paren
suffix:semicolon
macro_line|#endif    
r_if
c_cond
(paren
id|instance-&gt;irq
op_ne
id|IRQ_NONE
)paren
id|free_irq
c_func
(paren
id|instance-&gt;irq
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef BIOSPARAM
multiline_comment|/*&n; * Function : int generic_NCR5380_biosparam(Disk * disk, kdev_t dev, int *ip)&n; *&n; * Purpose : Generates a BIOS / DOS compatible H-C-S mapping for &n; *&t;the specified device / size.&n; * &n; * Inputs : size = size of device in sectors (512 bytes), dev = block device&n; *&t;major / minor, ip[] = {heads, sectors, cylinders}  &n; *&n; * Returns : always 0 (success), initializes ip&n; *&t;&n; */
multiline_comment|/* &n; * XXX Most SCSI boards use this mapping, I could be incorrect.  Some one&n; * using hard disks on a trantor should verify that this mapping corresponds&n; * to that used by the BIOS / ASPI driver by running the linux fdisk program&n; * and matching the H_C_S coordinates to what DOS uses.&n; */
r_int
id|generic_NCR5380_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
op_star
id|ip
)paren
(brace
r_int
id|size
op_assign
id|disk-&gt;capacity
suffix:semicolon
id|ip
(braket
l_int|0
)braket
op_assign
l_int|64
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|32
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
id|size
op_rshift
l_int|11
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if NCR53C400_PSEUDO_DMA
r_static
r_inline
r_int
id|NCR5380_pread
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
r_char
op_star
id|dst
comma
r_int
id|len
)paren
(brace
r_int
id|blocks
op_assign
id|len
op_div
l_int|128
suffix:semicolon
r_int
id|start
op_assign
l_int|0
suffix:semicolon
r_int
id|bl
suffix:semicolon
macro_line|#ifdef CONFIG_SCSI_G_NCR5380_PORT
r_int
id|i
suffix:semicolon
macro_line|#endif 
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
id|printk
c_func
(paren
l_string|&quot;53C400r: About to read %d blocks for %d bytes&bslash;n&quot;
comma
id|blocks
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|C400_CONTROL_STATUS_REG
comma
id|CSR_BASE
op_or
id|CSR_TRANS_DIR
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|C400_BLOCK_COUNTER_REG
comma
id|blocks
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
id|printk
c_func
(paren
l_string|&quot;53C400r: %d blocks left&bslash;n&quot;
comma
id|blocks
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|bl
op_assign
id|NCR5380_read
c_func
(paren
id|C400_BLOCK_COUNTER_REG
)paren
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
r_if
c_cond
(paren
id|blocks
)paren
id|printk
c_func
(paren
l_string|&quot;53C400r: blocks still == %d&bslash;n&quot;
comma
id|blocks
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;53C400r: Exiting loop&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
macro_line|#if 1
r_if
c_cond
(paren
id|NCR5380_read
c_func
(paren
id|C400_CONTROL_STATUS_REG
)paren
op_amp
id|CSR_GATED_53C80_IRQ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;53C400r: Got 53C80_IRQ start=%d, blocks=%d&bslash;n&quot;
comma
id|start
comma
id|blocks
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
id|printk
c_func
(paren
l_string|&quot;53C400r: Waiting for buffer, bl=%d&bslash;n&quot;
comma
id|bl
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|C400_CONTROL_STATUS_REG
)paren
op_amp
id|CSR_HOST_BUF_NOT_RDY
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
id|printk
c_func
(paren
l_string|&quot;53C400r: Transferring 128 bytes&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SCSI_G_NCR5380_PORT
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|128
suffix:semicolon
id|i
op_increment
)paren
id|dst
(braket
id|start
op_plus
id|i
)braket
op_assign
id|NCR5380_read
c_func
(paren
id|C400_HOST_BUFFER
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* implies CONFIG_SCSI_G_NCR5380_MEM */
id|isa_memcpy_fromio
c_func
(paren
id|dst
op_plus
id|start
comma
id|NCR53C400_host_buffer
op_plus
id|NCR5380_map_name
comma
l_int|128
)paren
suffix:semicolon
macro_line|#endif
id|start
op_add_assign
l_int|128
suffix:semicolon
id|blocks
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blocks
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
id|printk
c_func
(paren
l_string|&quot;53C400r: EXTRA: Waiting for buffer&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|C400_CONTROL_STATUS_REG
)paren
op_amp
id|CSR_HOST_BUF_NOT_RDY
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
id|printk
c_func
(paren
l_string|&quot;53C400r: Transferring EXTRA 128 bytes&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SCSI_G_NCR5380_PORT
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|128
suffix:semicolon
id|i
op_increment
)paren
id|dst
(braket
id|start
op_plus
id|i
)braket
op_assign
id|NCR5380_read
c_func
(paren
id|C400_HOST_BUFFER
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* implies CONFIG_SCSI_G_NCR5380_MEM */
id|isa_memcpy_fromio
c_func
(paren
id|dst
op_plus
id|start
comma
id|NCR53C400_host_buffer
op_plus
id|NCR5380_map_name
comma
l_int|128
)paren
suffix:semicolon
macro_line|#endif
id|start
op_add_assign
l_int|128
suffix:semicolon
id|blocks
op_decrement
suffix:semicolon
)brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
r_else
id|printk
c_func
(paren
l_string|&quot;53C400r: No EXTRA required&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
id|printk
c_func
(paren
l_string|&quot;53C400r: Final values: blocks=%d   start=%d&bslash;n&quot;
comma
id|blocks
comma
id|start
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|C400_CONTROL_STATUS_REG
)paren
op_amp
id|CSR_GATED_53C80_IRQ
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;53C400r: no 53C80 gated irq after transfer&quot;
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
r_else
id|printk
c_func
(paren
l_string|&quot;53C400r: Got 53C80 interrupt and tried to clear it&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* DON&squot;T DO THIS - THEY NEVER ARRIVE!&n;    printk(&quot;53C400r: Waiting for 53C80 registers&bslash;n&quot;);&n;    while (NCR5380_read(C400_CONTROL_STATUS_REG) &amp; CSR_53C80_REG)&n;&t;;&n;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_END_DMA_TRANSFER
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;53C400r: no end dma signal&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PREAD)
r_else
id|printk
c_func
(paren
l_string|&quot;53C400r: end dma as expected&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
id|NCR5380_pwrite
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
r_char
op_star
id|src
comma
r_int
id|len
)paren
(brace
r_int
id|blocks
op_assign
id|len
op_div
l_int|128
suffix:semicolon
r_int
id|start
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|bl
suffix:semicolon
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w: About to write %d blocks for %d bytes&bslash;n&quot;
comma
id|blocks
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|C400_CONTROL_STATUS_REG
comma
id|CSR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|C400_BLOCK_COUNTER_REG
comma
id|blocks
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|NCR5380_read
c_func
(paren
id|C400_CONTROL_STATUS_REG
)paren
op_amp
id|CSR_GATED_53C80_IRQ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;53C400w: Got 53C80_IRQ start=%d, blocks=%d&bslash;n&quot;
comma
id|start
comma
id|blocks
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bl
op_assign
id|NCR5380_read
c_func
(paren
id|C400_BLOCK_COUNTER_REG
)paren
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
r_if
c_cond
(paren
id|blocks
)paren
id|printk
c_func
(paren
l_string|&quot;53C400w: exiting loop, blocks still == %d&bslash;n&quot;
comma
id|blocks
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;53C400w: exiting loop&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w: %d blocks left&bslash;n&quot;
comma
id|blocks
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;53C400w: waiting for buffer, bl=%d&bslash;n&quot;
comma
id|bl
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|C400_CONTROL_STATUS_REG
)paren
op_amp
id|CSR_HOST_BUF_NOT_RDY
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w: transferring 128 bytes&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SCSI_G_NCR5380_PORT
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|128
suffix:semicolon
id|i
op_increment
)paren
id|NCR5380_write
c_func
(paren
id|C400_HOST_BUFFER
comma
id|src
(braket
id|start
op_plus
id|i
)braket
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* implies CONFIG_SCSI_G_NCR5380_MEM */
id|isa_memcpy_toio
c_func
(paren
id|NCR53C400_host_buffer
op_plus
id|NCR5380_map_name
comma
id|src
op_plus
id|start
comma
l_int|128
)paren
suffix:semicolon
macro_line|#endif
id|start
op_add_assign
l_int|128
suffix:semicolon
id|blocks
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blocks
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w: EXTRA waiting for buffer&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|C400_CONTROL_STATUS_REG
)paren
op_amp
id|CSR_HOST_BUF_NOT_RDY
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w: transferring EXTRA 128 bytes&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SCSI_G_NCR5380_PORT
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|128
suffix:semicolon
id|i
op_increment
)paren
id|NCR5380_write
c_func
(paren
id|C400_HOST_BUFFER
comma
id|src
(braket
id|start
op_plus
id|i
)braket
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* implies CONFIG_SCSI_G_NCR5380_MEM */
id|isa_memcpy_toio
c_func
(paren
id|NCR53C400_host_buffer
op_plus
id|NCR5380_map_name
comma
id|src
op_plus
id|start
comma
l_int|128
)paren
suffix:semicolon
macro_line|#endif
id|start
op_add_assign
l_int|128
suffix:semicolon
id|blocks
op_decrement
suffix:semicolon
)brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
r_else
id|printk
c_func
(paren
l_string|&quot;53C400w: No EXTRA required&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w: Final values: blocks=%d   start=%d&bslash;n&quot;
comma
id|blocks
comma
id|start
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;53C400w: waiting for registers to be available&bslash;n&quot;
)paren
suffix:semicolon
id|THEY
id|NEVER
id|DO
op_logical_neg
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|C400_CONTROL_STATUS_REG
)paren
op_amp
id|CSR_53C80_REG
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;53C400w: Got em&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Let&squot;s wait for this instead - could be ugly */
multiline_comment|/* All documentation says to check for this. Maybe my hardware is too&n;     * fast. Waiting for it seems to work fine! KLL&n;     */
r_while
c_loop
(paren
op_logical_neg
(paren
id|i
op_assign
id|NCR5380_read
c_func
(paren
id|C400_CONTROL_STATUS_REG
)paren
op_amp
id|CSR_GATED_53C80_IRQ
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * I know. i is certainly != 0 here but the loop is new. See previous&n;     * comment.&n;     */
r_if
c_cond
(paren
id|i
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w: got 53C80 gated irq (last block)&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|i
op_assign
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
)paren
op_amp
id|BASR_END_DMA_TRANSFER
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;53C400w: No END OF DMA bit - WHOOPS! BASR=%0x&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
r_else
id|printk
c_func
(paren
l_string|&quot;53C400w: Got END OF DMA&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;53C400w: no 53C80 gated irq after transfer (last block)&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_END_DMA_TRANSFER
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;53C400w: no end dma signal&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w: waiting for last byte...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|TARGET_COMMAND_REG
)paren
op_amp
id|TCR_LAST_BYTE_SENT
)paren
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w:     got last byte.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;53C400w: pwrite exiting with status 0, whoopee!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* PSEUDO_DMA */
macro_line|#include &quot;NCR5380.c&quot;
DECL|macro|PRINTP
mdefine_line|#define PRINTP(x) len += sprintf(buffer+len, x)
DECL|macro|ANDP
mdefine_line|#define ANDP ,
r_static
r_int
id|sprint_opcode
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
id|len
comma
r_int
id|opcode
)paren
(brace
r_int
id|start
op_assign
id|len
suffix:semicolon
id|PRINTP
c_func
(paren
l_string|&quot;0x%02x &quot;
id|ANDP
id|opcode
)paren
suffix:semicolon
r_return
id|len
op_minus
id|start
suffix:semicolon
)brace
r_static
r_int
id|sprint_command
(paren
r_char
op_star
id|buffer
comma
r_int
id|len
comma
r_int
r_char
op_star
id|command
)paren
(brace
r_int
id|i
comma
id|s
comma
id|start
op_assign
id|len
suffix:semicolon
id|len
op_add_assign
id|sprint_opcode
c_func
(paren
id|buffer
comma
id|len
comma
id|command
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
comma
id|s
op_assign
id|COMMAND_SIZE
c_func
(paren
id|command
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
OL
id|s
suffix:semicolon
op_increment
id|i
)paren
id|PRINTP
c_func
(paren
l_string|&quot;%02x &quot;
id|ANDP
id|command
(braket
id|i
)braket
)paren
suffix:semicolon
id|PRINTP
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|len
op_minus
id|start
suffix:semicolon
)brace
r_static
r_int
id|sprint_Scsi_Cmnd
(paren
r_char
op_star
id|buffer
comma
r_int
id|len
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|start
op_assign
id|len
suffix:semicolon
id|PRINTP
c_func
(paren
l_string|&quot;host number %d destination target %d, lun %d&bslash;n&quot;
id|ANDP
id|cmd-&gt;host-&gt;host_no
id|ANDP
id|cmd-&gt;target
id|ANDP
id|cmd-&gt;lun
)paren
suffix:semicolon
id|PRINTP
c_func
(paren
l_string|&quot;        command = &quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprint_command
(paren
id|buffer
comma
id|len
comma
id|cmd-&gt;cmnd
)paren
suffix:semicolon
r_return
id|len
op_minus
id|start
suffix:semicolon
)brace
r_int
id|generic_NCR5380_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|inout
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|scsi_ptr
suffix:semicolon
id|Scsi_Cmnd
op_star
id|ptr
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
suffix:semicolon
macro_line|#ifdef NCR5380_STATS
id|Scsi_Device
op_star
id|dev
suffix:semicolon
r_extern
r_const
r_char
op_star
r_const
id|scsi_device_types
(braket
id|MAX_SCSI_DEVICE_CODE
)braket
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|scsi_ptr
op_assign
id|first_instance
suffix:semicolon
id|scsi_ptr
suffix:semicolon
id|scsi_ptr
op_assign
id|scsi_ptr-&gt;next
)paren
r_if
c_cond
(paren
id|scsi_ptr-&gt;host_no
op_eq
id|hostno
)paren
r_break
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|scsi_ptr
)paren
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|scsi_ptr-&gt;hostdata
suffix:semicolon
id|PRINTP
c_func
(paren
l_string|&quot;SCSI host number %d : %s&bslash;n&quot;
id|ANDP
id|scsi_ptr-&gt;host_no
id|ANDP
id|scsi_ptr-&gt;hostt-&gt;name
)paren
suffix:semicolon
id|PRINTP
c_func
(paren
l_string|&quot;Generic NCR5380 driver version %d&bslash;n&quot;
id|ANDP
id|GENERIC_NCR5380_PUBLIC_RELEASE
)paren
suffix:semicolon
id|PRINTP
c_func
(paren
l_string|&quot;NCR5380 core version %d&bslash;n&quot;
id|ANDP
id|NCR5380_PUBLIC_RELEASE
)paren
suffix:semicolon
macro_line|#ifdef NCR53C400
id|PRINTP
c_func
(paren
l_string|&quot;NCR53C400 extension version %d&bslash;n&quot;
id|ANDP
id|NCR53C400_PUBLIC_RELEASE
)paren
suffix:semicolon
id|PRINTP
c_func
(paren
l_string|&quot;NCR53C400 card%s detected&bslash;n&quot;
id|ANDP
(paren
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|scsi_ptr-&gt;hostdata
)paren
op_member_access_from_pointer
id|flags
op_amp
id|FLAG_NCR53C400
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; not&quot;
)paren
suffix:semicolon
macro_line|# if NCR53C400_PSEUDO_DMA
id|PRINTP
c_func
(paren
l_string|&quot;NCR53C400 pseudo DMA used&bslash;n&quot;
)paren
suffix:semicolon
macro_line|# endif
macro_line|#else
id|PRINTP
c_func
(paren
l_string|&quot;NO NCR53C400 driver extensions&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|PRINTP
c_func
(paren
l_string|&quot;Using %s mapping at %s 0x%lx, &quot;
id|ANDP
id|STRVAL
c_func
(paren
id|NCR5380_map_config
)paren
id|ANDP
id|STRVAL
c_func
(paren
id|NCR5380_map_name
)paren
id|ANDP
id|scsi_ptr-&gt;NCR5380_instance_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_ptr-&gt;irq
op_eq
id|IRQ_NONE
)paren
id|PRINTP
c_func
(paren
l_string|&quot;no interrupt&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|PRINTP
c_func
(paren
l_string|&quot;on interrupt %d&bslash;n&quot;
id|ANDP
id|scsi_ptr-&gt;irq
)paren
suffix:semicolon
macro_line|#ifdef NCR5380_STATS
r_if
c_cond
(paren
id|hostdata-&gt;connected
op_logical_or
id|hostdata-&gt;issue_queue
op_logical_or
id|hostdata-&gt;disconnected_queue
)paren
id|PRINTP
c_func
(paren
l_string|&quot;There are commands pending, transfer rates may be crud&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;pendingr
)paren
id|PRINTP
c_func
(paren
l_string|&quot;  %d pending reads&quot;
id|ANDP
id|hostdata-&gt;pendingr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;pendingw
)paren
id|PRINTP
c_func
(paren
l_string|&quot;  %d pending writes&quot;
id|ANDP
id|hostdata-&gt;pendingw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;pendingr
op_logical_or
id|hostdata-&gt;pendingw
)paren
id|PRINTP
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|scsi_ptr-&gt;host_queue
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_int
r_int
id|br
op_assign
id|hostdata-&gt;bytes_read
(braket
id|dev-&gt;id
)braket
suffix:semicolon
r_int
r_int
id|bw
op_assign
id|hostdata-&gt;bytes_write
(braket
id|dev-&gt;id
)braket
suffix:semicolon
r_int
id|tr
op_assign
id|hostdata-&gt;time_read
(braket
id|dev-&gt;id
)braket
op_div
id|HZ
suffix:semicolon
r_int
id|tw
op_assign
id|hostdata-&gt;time_write
(braket
id|dev-&gt;id
)braket
op_div
id|HZ
suffix:semicolon
id|PRINTP
c_func
(paren
l_string|&quot;  T:%d %s &quot;
id|ANDP
id|dev-&gt;id
id|ANDP
(paren
id|dev-&gt;type
OL
id|MAX_SCSI_DEVICE_CODE
)paren
ques
c_cond
id|scsi_device_types
(braket
(paren
r_int
)paren
id|dev-&gt;type
)braket
suffix:colon
l_string|&quot;Unknown&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dev-&gt;vendor
(braket
id|i
)braket
op_ge
l_int|0x20
)paren
op_star
(paren
id|buffer
op_plus
(paren
id|len
op_increment
)paren
)paren
op_assign
id|dev-&gt;vendor
(braket
id|i
)braket
suffix:semicolon
op_star
(paren
id|buffer
op_plus
(paren
id|len
op_increment
)paren
)paren
op_assign
l_char|&squot; &squot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dev-&gt;model
(braket
id|i
)braket
op_ge
l_int|0x20
)paren
op_star
(paren
id|buffer
op_plus
(paren
id|len
op_increment
)paren
)paren
op_assign
id|dev-&gt;model
(braket
id|i
)braket
suffix:semicolon
op_star
(paren
id|buffer
op_plus
(paren
id|len
op_increment
)paren
)paren
op_assign
l_char|&squot; &squot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dev-&gt;rev
(braket
id|i
)braket
op_ge
l_int|0x20
)paren
op_star
(paren
id|buffer
op_plus
(paren
id|len
op_increment
)paren
)paren
op_assign
id|dev-&gt;rev
(braket
id|i
)braket
suffix:semicolon
op_star
(paren
id|buffer
op_plus
(paren
id|len
op_increment
)paren
)paren
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|PRINTP
c_func
(paren
l_string|&quot;&bslash;n%10ld kb read    in %5ld secs&quot;
id|ANDP
id|br
op_div
l_int|1024
id|ANDP
id|tr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tr
)paren
id|PRINTP
c_func
(paren
l_string|&quot; @ %5ld bps&quot;
id|ANDP
id|br
op_div
id|tr
)paren
suffix:semicolon
id|PRINTP
c_func
(paren
l_string|&quot;&bslash;n%10ld kb written in %5ld secs&quot;
id|ANDP
id|bw
op_div
l_int|1024
id|ANDP
id|tw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tw
)paren
id|PRINTP
c_func
(paren
l_string|&quot; @ %5ld bps&quot;
id|ANDP
id|bw
op_div
id|tw
)paren
suffix:semicolon
id|PRINTP
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|status
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|SR_REQ
)paren
)paren
id|PRINTP
c_func
(paren
l_string|&quot;REQ not asserted, phase unknown.&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|phases
(braket
id|i
)braket
dot
id|value
op_ne
id|PHASE_UNKNOWN
)paren
op_logical_and
(paren
id|phases
(braket
id|i
)braket
dot
id|value
op_ne
(paren
id|status
op_amp
id|PHASE_MASK
)paren
)paren
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
id|PRINTP
c_func
(paren
l_string|&quot;Phase %s&bslash;n&quot;
id|ANDP
id|phases
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;connected
)paren
(brace
id|PRINTP
c_func
(paren
l_string|&quot;No currently connected command&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|len
op_add_assign
id|sprint_Scsi_Cmnd
(paren
id|buffer
comma
id|len
comma
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;connected
)paren
suffix:semicolon
)brace
id|PRINTP
c_func
(paren
l_string|&quot;issue_queue&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|ptr
suffix:semicolon
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
)paren
id|len
op_add_assign
id|sprint_Scsi_Cmnd
(paren
id|buffer
comma
id|len
comma
id|ptr
)paren
suffix:semicolon
id|PRINTP
c_func
(paren
l_string|&quot;disconnected_queue&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_queue
suffix:semicolon
id|ptr
suffix:semicolon
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
)paren
id|len
op_add_assign
id|sprint_Scsi_Cmnd
(paren
id|buffer
comma
id|len
comma
id|ptr
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
id|len
op_sub_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|macro|PRINTP
macro_line|#undef PRINTP
DECL|macro|ANDP
macro_line|#undef ANDP
multiline_comment|/* Eventually this will go into an include file, but this will be later */
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|GENERIC_NCR5380
suffix:semicolon
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &quot;scsi_module.c&quot;
macro_line|#ifdef MODULE 
id|MODULE_PARM
c_func
(paren
id|ncr_irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ncr_dma
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ncr_addr
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ncr_5380
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ncr_53c400
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ncr_53c400a
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dtc_3181e
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
eof
