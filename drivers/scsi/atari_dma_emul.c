multiline_comment|/*&n; * atari_dma_emul.c -- TT SCSI DMA emulator for the Hades.&n; *&n; * Copyright 1997 Wout Klaren &lt;W.Klaren@inter.nl.net&gt;&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file COPYING in the main directory of this archive&n; * for more details.&n; *&n; * This code was written using the Hades TOS source code as a&n; * reference. This source code can be found on the home page&n; * of Medusa Computer Systems.&n; *&n; * Version 0.1, 1997-09-24.&n; * &n; * This code should be considered experimental. It has only been&n; * tested on a Hades with a 68060. It might not work on a Hades&n; * with a 68040. Make backups of your hard drives before using&n; * this code.&n; */
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|hades_dma_ctrl
mdefine_line|#define hades_dma_ctrl&t;&t;(*(unsigned char *) 0xffff8717)
DECL|macro|hades_psdm_reg
mdefine_line|#define hades_psdm_reg&t;&t;(*(unsigned char *) 0xffff8741)
DECL|macro|TRANSFER_SIZE
mdefine_line|#define TRANSFER_SIZE&t;&t;16
DECL|struct|m68040_frame
r_struct
id|m68040_frame
(brace
DECL|member|effaddr
r_int
r_int
id|effaddr
suffix:semicolon
multiline_comment|/* effective address */
DECL|member|ssw
r_int
r_int
id|ssw
suffix:semicolon
multiline_comment|/* special status word */
DECL|member|wb3s
r_int
r_int
id|wb3s
suffix:semicolon
multiline_comment|/* write back 3 status */
DECL|member|wb2s
r_int
r_int
id|wb2s
suffix:semicolon
multiline_comment|/* write back 2 status */
DECL|member|wb1s
r_int
r_int
id|wb1s
suffix:semicolon
multiline_comment|/* write back 1 status */
DECL|member|faddr
r_int
r_int
id|faddr
suffix:semicolon
multiline_comment|/* fault address */
DECL|member|wb3a
r_int
r_int
id|wb3a
suffix:semicolon
multiline_comment|/* write back 3 address */
DECL|member|wb3d
r_int
r_int
id|wb3d
suffix:semicolon
multiline_comment|/* write back 3 data */
DECL|member|wb2a
r_int
r_int
id|wb2a
suffix:semicolon
multiline_comment|/* write back 2 address */
DECL|member|wb2d
r_int
r_int
id|wb2d
suffix:semicolon
multiline_comment|/* write back 2 data */
DECL|member|wb1a
r_int
r_int
id|wb1a
suffix:semicolon
multiline_comment|/* write back 1 address */
DECL|member|wb1dpd0
r_int
r_int
id|wb1dpd0
suffix:semicolon
multiline_comment|/* write back 1 data/push data 0*/
DECL|member|pd1
r_int
r_int
id|pd1
suffix:semicolon
multiline_comment|/* push data 1*/
DECL|member|pd2
r_int
r_int
id|pd2
suffix:semicolon
multiline_comment|/* push data 2*/
DECL|member|pd3
r_int
r_int
id|pd3
suffix:semicolon
multiline_comment|/* push data 3*/
)brace
suffix:semicolon
DECL|function|writeback
r_static
r_void
id|writeback
(paren
r_int
r_int
id|wbs
comma
r_int
r_int
id|wba
comma
r_int
r_int
id|wbd
comma
r_void
op_star
id|old_buserr
)paren
(brace
id|mm_segment_t
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
r_static
r_void
op_star
id|save_buserr
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;movec.l&t;%%vbr,%%a0&bslash;n&bslash;t&quot;
l_string|&quot;move.l&t;%0,8(%%a0)&bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
op_logical_and
id|bus_error
)paren
suffix:colon
l_string|&quot;a0&quot;
)paren
suffix:semicolon
id|save_buserr
op_assign
id|old_buserr
suffix:semicolon
id|set_fs
(paren
id|MAKE_MM_SEG
c_func
(paren
id|wbs
op_amp
id|WBTM_040
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|wbs
op_amp
id|WBSIZ_040
)paren
(brace
r_case
id|BA_SIZE_BYTE
suffix:colon
id|put_user
(paren
id|wbd
op_amp
l_int|0xff
comma
(paren
r_char
op_star
)paren
id|wba
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BA_SIZE_WORD
suffix:colon
id|put_user
(paren
id|wbd
op_amp
l_int|0xffff
comma
(paren
r_int
op_star
)paren
id|wba
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BA_SIZE_LONG
suffix:colon
id|put_user
(paren
id|wbd
comma
(paren
r_int
op_star
)paren
id|wba
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|set_fs
(paren
id|fs
)paren
suffix:semicolon
r_return
suffix:semicolon
id|bus_error
suffix:colon
id|__asm__
id|__volatile__
(paren
l_string|&quot;cmp.l&t;%0,2(%%sp)&bslash;n&bslash;t&quot;
l_string|&quot;bcs.s&t;.jump_old&bslash;n&bslash;t&quot;
l_string|&quot;cmp.l&t;%1,2(%%sp)&bslash;n&bslash;t&quot;
l_string|&quot;bls.s&t;.restore_old&bslash;n&quot;
l_string|&quot;.jump_old:&bslash;n&bslash;t&quot;
l_string|&quot;move.l&t;%2,-(%%sp)&bslash;n&bslash;t&quot;
l_string|&quot;rts&bslash;n&quot;
l_string|&quot;.restore_old:&bslash;n&bslash;t&quot;
l_string|&quot;move.l&t;%%a0,-(%%sp)&bslash;n&bslash;t&quot;
l_string|&quot;movec.l&t;%%vbr,%%a0&bslash;n&bslash;t&quot;
l_string|&quot;move.l&t;%2,8(%%a0)&bslash;n&bslash;t&quot;
l_string|&quot;move.l&t;(%%sp)+,%%a0&bslash;n&bslash;t&quot;
l_string|&quot;rte&bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
l_string|&quot;i&quot;
(paren
id|writeback
)paren
comma
l_string|&quot;i&quot;
(paren
op_logical_and
id|bus_error
)paren
comma
l_string|&quot;m&quot;
(paren
id|save_buserr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * static inline void set_restdata_reg(unsigned char *cur_addr)&n; *&n; * Set the rest data register if necessary.&n; */
DECL|function|set_restdata_reg
r_static
r_inline
r_void
id|set_restdata_reg
c_func
(paren
r_int
r_char
op_star
id|cur_addr
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|cur_addr
op_amp
op_complement
l_int|3
)paren
op_ne
l_int|0
)paren
id|tt_scsi_dma.dma_restdata
op_assign
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
(paren
r_int
)paren
id|cur_addr
op_amp
op_complement
l_int|3
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * void hades_dma_emulator(int irq, void *dummy, struct pt_regs *fp)&n; * &n; * This code emulates TT SCSI DMA on the Hades.&n; * &n; * Note the following:&n; * &n; * 1. When there is no byte available to read from the SCSI bus, or&n; *    when a byte cannot yet bet written to the SCSI bus, a bus&n; *    error occurs when reading or writing the pseudo DMA data&n; *    register (hades_psdm_reg). We have to catch this bus error&n; *    and try again to read or write the byte. If after several tries&n; *    we still get a bus error, the interrupt handler is left. When&n; *    the byte can be read or written, the interrupt handler is&n; *    called again.&n; * &n; * 2. The SCSI interrupt must be disabled in this interrupt handler.&n; * &n; * 3. If we set the EOP signal, the SCSI controller still expects one&n; *    byte to be read or written. Therefore the last byte is transferred&n; *    separately, after setting the EOP signal.&n; * &n; * 4. When this function is left, the address pointer (start_addr) is&n; *    converted to a physical address. Because it points one byte&n; *    further than the last transfered byte, it can point outside the&n; *    current page. If virt_to_phys() is called with this address we&n; *    might get an access error. Therefore virt_to_phys() is called with&n; *    start_addr - 1 if the count has reached zero. The result is&n; *    increased with one.&n; */
DECL|function|hades_dma_emulator
r_static
r_void
id|hades_dma_emulator
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dummy
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_int
r_int
id|dma_base
suffix:semicolon
r_register
r_int
r_int
id|dma_cnt
id|asm
(paren
l_string|&quot;d3&quot;
)paren
suffix:semicolon
r_static
r_int
id|save_buserr
suffix:semicolon
r_register
r_int
r_int
id|save_sp
id|asm
(paren
l_string|&quot;d4&quot;
)paren
suffix:semicolon
r_register
r_int
id|tries
id|asm
(paren
l_string|&quot;d5&quot;
)paren
suffix:semicolon
r_register
r_int
r_char
op_star
id|start_addr
id|asm
(paren
l_string|&quot;a3&quot;
)paren
comma
op_star
id|end_addr
id|asm
(paren
l_string|&quot;a4&quot;
)paren
suffix:semicolon
r_register
r_int
r_char
op_star
id|eff_addr
suffix:semicolon
r_register
r_int
r_char
op_star
id|psdm_reg
suffix:semicolon
r_int
r_int
id|rem
suffix:semicolon
id|atari_disable_irq
c_func
(paren
id|IRQ_TT_MFP_SCSI
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read the dma address and count registers.&n;&t; */
id|dma_base
op_assign
id|SCSI_DMA_READ_P
c_func
(paren
id|dma_addr
)paren
suffix:semicolon
id|dma_cnt
op_assign
id|SCSI_DMA_READ_P
c_func
(paren
id|dma_cnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if DMA is still enabled.&n;&t; */
r_if
c_cond
(paren
(paren
id|tt_scsi_dma.dma_ctrl
op_amp
l_int|2
)paren
op_eq
l_int|0
)paren
(brace
id|atari_enable_irq
c_func
(paren
id|IRQ_TT_MFP_SCSI
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dma_cnt
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;DMA emulation: count is zero.&bslash;n&quot;
)paren
suffix:semicolon
id|tt_scsi_dma.dma_ctrl
op_and_assign
l_int|0xfd
suffix:semicolon
multiline_comment|/* DMA ready. */
id|atari_enable_irq
c_func
(paren
id|IRQ_TT_MFP_SCSI
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Install new bus error routine.&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;movec.l&t;%%vbr,%%a0&bslash;n&bslash;t&quot;
l_string|&quot;move.l&t;8(%%a0),%0&bslash;n&bslash;t&quot;
l_string|&quot;move.l&t;%1,8(%%a0)&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|save_buserr
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
op_logical_and
id|scsi_bus_error
)paren
suffix:colon
l_string|&quot;a0&quot;
)paren
suffix:semicolon
id|hades_dma_ctrl
op_and_assign
l_int|0xfc
suffix:semicolon
multiline_comment|/* Bus error and EOP off. */
multiline_comment|/*&n;&t; * Save the stack pointer.&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;move.l&t;%%sp,%0&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|save_sp
)paren
)paren
suffix:semicolon
id|tries
op_assign
l_int|100
suffix:semicolon
multiline_comment|/* Maximum number of bus errors. */
id|start_addr
op_assign
id|phys_to_virt
c_func
(paren
id|dma_base
)paren
suffix:semicolon
id|end_addr
op_assign
id|start_addr
op_plus
id|dma_cnt
suffix:semicolon
id|scsi_loop
suffix:colon
id|dma_cnt
op_decrement
suffix:semicolon
id|rem
op_assign
id|dma_cnt
op_amp
(paren
id|TRANSFER_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|dma_cnt
op_and_assign
op_complement
(paren
id|TRANSFER_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|psdm_reg
op_assign
op_amp
id|hades_psdm_reg
suffix:semicolon
r_if
c_cond
(paren
id|tt_scsi_dma.dma_ctrl
op_amp
l_int|1
)paren
multiline_comment|/* Read or write? */
(brace
multiline_comment|/*&n;&t;&t; * SCSI write. Abort when count is zero.&n;&t;&t; */
r_switch
c_cond
(paren
id|rem
)paren
(brace
r_case
l_int|0
suffix:colon
r_while
c_loop
(paren
id|dma_cnt
OG
l_int|0
)paren
(brace
id|dma_cnt
op_sub_assign
id|TRANSFER_SIZE
suffix:semicolon
op_star
id|psdm_reg
op_assign
op_star
id|start_addr
op_increment
suffix:semicolon
r_case
l_int|15
suffix:colon
op_star
id|psdm_reg
op_assign
op_star
id|start_addr
op_increment
suffix:semicolon
r_case
l_int|14
suffix:colon
op_star
id|psdm_reg
op_assign
op_star
id|start_addr
op_increment
suffix:semicolon
r_case
l_int|13
suffix:colon
op_star
id|psdm_reg
op_assign
op_star
id|start_addr
op_increment
suffix:semicolon
r_case
l_int|12
suffix:colon
op_star
id|psdm_reg
op_assign
op_star
id|start_addr
op_increment
suffix:semicolon
r_case
l_int|11
suffix:colon
op_star
id|psdm_reg
op_assign
op_star
id|start_addr
op_increment
suffix:semicolon
r_case
l_int|10
suffix:colon
op_star
id|psdm_reg
op_assign
op_star
id|start_addr
op_increment
suffix:semicolon
r_case
l_int|9
suffix:colon
op_star
id|psdm_reg
op_assign
op_star
id|start_addr
op_increment
suffix:semicolon
r_case
l_int|8
suffix:colon
op_star
id|psdm_reg
op_assign
op_star
id|start_addr
op_increment
suffix:semicolon
r_case
l_int|7
suffix:colon
op_star
id|psdm_reg
op_assign
op_star
id|start_addr
op_increment
suffix:semicolon
r_case
l_int|6
suffix:colon
op_star
id|psdm_reg
op_assign
op_star
id|start_addr
op_increment
suffix:semicolon
r_case
l_int|5
suffix:colon
op_star
id|psdm_reg
op_assign
op_star
id|start_addr
op_increment
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
id|psdm_reg
op_assign
op_star
id|start_addr
op_increment
suffix:semicolon
r_case
l_int|3
suffix:colon
op_star
id|psdm_reg
op_assign
op_star
id|start_addr
op_increment
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
id|psdm_reg
op_assign
op_star
id|start_addr
op_increment
suffix:semicolon
r_case
l_int|1
suffix:colon
op_star
id|psdm_reg
op_assign
op_star
id|start_addr
op_increment
suffix:semicolon
)brace
)brace
id|hades_dma_ctrl
op_or_assign
l_int|1
suffix:semicolon
multiline_comment|/* Set EOP. */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
op_star
id|psdm_reg
op_assign
op_star
id|start_addr
op_increment
suffix:semicolon
multiline_comment|/* Dummy byte. */
id|tt_scsi_dma.dma_ctrl
op_and_assign
l_int|0xfd
suffix:semicolon
multiline_comment|/* DMA ready. */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * SCSI read. Abort when count is zero.&n;&t;&t; */
r_switch
c_cond
(paren
id|rem
)paren
(brace
r_case
l_int|0
suffix:colon
r_while
c_loop
(paren
id|dma_cnt
OG
l_int|0
)paren
(brace
id|dma_cnt
op_sub_assign
id|TRANSFER_SIZE
suffix:semicolon
op_star
id|start_addr
op_increment
op_assign
op_star
id|psdm_reg
suffix:semicolon
r_case
l_int|15
suffix:colon
op_star
id|start_addr
op_increment
op_assign
op_star
id|psdm_reg
suffix:semicolon
r_case
l_int|14
suffix:colon
op_star
id|start_addr
op_increment
op_assign
op_star
id|psdm_reg
suffix:semicolon
r_case
l_int|13
suffix:colon
op_star
id|start_addr
op_increment
op_assign
op_star
id|psdm_reg
suffix:semicolon
r_case
l_int|12
suffix:colon
op_star
id|start_addr
op_increment
op_assign
op_star
id|psdm_reg
suffix:semicolon
r_case
l_int|11
suffix:colon
op_star
id|start_addr
op_increment
op_assign
op_star
id|psdm_reg
suffix:semicolon
r_case
l_int|10
suffix:colon
op_star
id|start_addr
op_increment
op_assign
op_star
id|psdm_reg
suffix:semicolon
r_case
l_int|9
suffix:colon
op_star
id|start_addr
op_increment
op_assign
op_star
id|psdm_reg
suffix:semicolon
r_case
l_int|8
suffix:colon
op_star
id|start_addr
op_increment
op_assign
op_star
id|psdm_reg
suffix:semicolon
r_case
l_int|7
suffix:colon
op_star
id|start_addr
op_increment
op_assign
op_star
id|psdm_reg
suffix:semicolon
r_case
l_int|6
suffix:colon
op_star
id|start_addr
op_increment
op_assign
op_star
id|psdm_reg
suffix:semicolon
r_case
l_int|5
suffix:colon
op_star
id|start_addr
op_increment
op_assign
op_star
id|psdm_reg
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
id|start_addr
op_increment
op_assign
op_star
id|psdm_reg
suffix:semicolon
r_case
l_int|3
suffix:colon
op_star
id|start_addr
op_increment
op_assign
op_star
id|psdm_reg
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
id|start_addr
op_increment
op_assign
op_star
id|psdm_reg
suffix:semicolon
r_case
l_int|1
suffix:colon
op_star
id|start_addr
op_increment
op_assign
op_star
id|psdm_reg
suffix:semicolon
)brace
)brace
id|hades_dma_ctrl
op_or_assign
l_int|1
suffix:semicolon
multiline_comment|/* Set EOP. */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
op_star
id|start_addr
op_increment
op_assign
op_star
id|psdm_reg
suffix:semicolon
id|tt_scsi_dma.dma_ctrl
op_and_assign
l_int|0xfd
suffix:semicolon
multiline_comment|/* DMA ready. */
id|set_restdata_reg
c_func
(paren
id|start_addr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start_addr
op_ne
id|end_addr
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;DMA emulation: FATAL: Count is not zero at end of transfer.&bslash;n&quot;
)paren
suffix:semicolon
id|dma_cnt
op_assign
id|end_addr
op_minus
id|start_addr
suffix:semicolon
id|scsi_end
suffix:colon
id|dma_base
op_assign
(paren
id|dma_cnt
op_eq
l_int|0
)paren
ques
c_cond
id|virt_to_phys
c_func
(paren
id|start_addr
op_minus
l_int|1
)paren
op_plus
l_int|1
suffix:colon
id|virt_to_phys
c_func
(paren
id|start_addr
)paren
suffix:semicolon
id|SCSI_DMA_WRITE_P
c_func
(paren
id|dma_addr
comma
id|dma_base
)paren
suffix:semicolon
id|SCSI_DMA_WRITE_P
c_func
(paren
id|dma_cnt
comma
id|dma_cnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Restore old bus error routine.&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;movec.l&t;%%vbr,%%a0&bslash;n&bslash;t&quot;
l_string|&quot;move.l&t;%0,8(%%a0)&bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|save_buserr
)paren
suffix:colon
l_string|&quot;a0&quot;
)paren
suffix:semicolon
id|atari_enable_irq
c_func
(paren
id|IRQ_TT_MFP_SCSI
)paren
suffix:semicolon
r_return
suffix:semicolon
id|scsi_bus_error
suffix:colon
multiline_comment|/*&n;&t; * First check if the bus error is caused by our code.&n;&t; * If not, call the original handler.&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;cmp.l&t;%0,2(%%sp)&bslash;n&bslash;t&quot;
l_string|&quot;bcs.s&t;.old_vector&bslash;n&bslash;t&quot;
l_string|&quot;cmp.l&t;%1,2(%%sp)&bslash;n&bslash;t&quot;
l_string|&quot;bls.s&t;.scsi_buserr&bslash;n&quot;
l_string|&quot;.old_vector:&bslash;n&bslash;t&quot;
l_string|&quot;move.l&t;%2,-(%%sp)&bslash;n&bslash;t&quot;
l_string|&quot;rts&bslash;n&quot;
l_string|&quot;.scsi_buserr:&bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
l_string|&quot;i&quot;
(paren
op_logical_and
id|scsi_loop
)paren
comma
l_string|&quot;i&quot;
(paren
op_logical_and
id|scsi_end
)paren
comma
l_string|&quot;m&quot;
(paren
id|save_buserr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CPU_IS_060
)paren
(brace
multiline_comment|/*&n;&t;&t; * Get effective address and restore the stack.&n;&t;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;move.l&t;8(%%sp),%0&bslash;n&bslash;t&quot;
l_string|&quot;move.l&t;%1,%%sp&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=a&amp;&quot;
(paren
id|eff_addr
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|save_sp
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_register
r_struct
id|m68040_frame
op_star
id|frame
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;lea&t;8(%%sp),%0&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=a&amp;&quot;
(paren
id|frame
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tt_scsi_dma.dma_ctrl
op_amp
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Bus error while writing.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|frame-&gt;wb3s
op_amp
id|WBV_040
)paren
(brace
r_if
c_cond
(paren
id|frame-&gt;wb3a
op_eq
(paren
r_int
)paren
op_amp
id|hades_psdm_reg
)paren
id|start_addr
op_decrement
suffix:semicolon
r_else
id|writeback
c_func
(paren
id|frame-&gt;wb3s
comma
id|frame-&gt;wb3a
comma
id|frame-&gt;wb3d
comma
op_logical_and
id|scsi_bus_error
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|frame-&gt;wb2s
op_amp
id|WBV_040
)paren
(brace
r_if
c_cond
(paren
id|frame-&gt;wb2a
op_eq
(paren
r_int
)paren
op_amp
id|hades_psdm_reg
)paren
id|start_addr
op_decrement
suffix:semicolon
r_else
id|writeback
c_func
(paren
id|frame-&gt;wb2s
comma
id|frame-&gt;wb2a
comma
id|frame-&gt;wb2d
comma
op_logical_and
id|scsi_bus_error
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|frame-&gt;wb1s
op_amp
id|WBV_040
)paren
(brace
r_if
c_cond
(paren
id|frame-&gt;wb1a
op_eq
(paren
r_int
)paren
op_amp
id|hades_psdm_reg
)paren
id|start_addr
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Bus error while reading.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|frame-&gt;wb3s
op_amp
id|WBV_040
)paren
id|writeback
c_func
(paren
id|frame-&gt;wb3s
comma
id|frame-&gt;wb3a
comma
id|frame-&gt;wb3d
comma
op_logical_and
id|scsi_bus_error
)paren
suffix:semicolon
)brace
id|eff_addr
op_assign
(paren
r_int
r_char
op_star
)paren
id|frame-&gt;faddr
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;move.l&t;%0,%%sp&bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|save_sp
)paren
)paren
suffix:semicolon
)brace
id|dma_cnt
op_assign
id|end_addr
op_minus
id|start_addr
suffix:semicolon
r_if
c_cond
(paren
id|eff_addr
op_eq
op_amp
id|hades_psdm_reg
)paren
(brace
multiline_comment|/*&n;&t;&t; * Bus error occurred while reading the pseudo&n;&t;&t; * DMA register. Time out.&n;&t;&t; */
id|tries
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|tries
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|tt_scsi_dma.dma_ctrl
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
multiline_comment|/* Read or write? */
id|set_restdata_reg
c_func
(paren
id|start_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_cnt
op_le
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;DMA emulation: Fatal &quot;
l_string|&quot;error while %s the last byte.&bslash;n&quot;
comma
(paren
id|tt_scsi_dma.dma_ctrl
op_amp
l_int|1
)paren
ques
c_cond
l_string|&quot;writing&quot;
suffix:colon
l_string|&quot;reading&quot;
)paren
suffix:semicolon
r_goto
id|scsi_end
suffix:semicolon
)brace
r_else
r_goto
id|scsi_loop
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Bus error during pseudo DMA transfer.&n;&t;&t; * Terminate the DMA transfer.&n;&t;&t; */
id|hades_dma_ctrl
op_or_assign
l_int|3
suffix:semicolon
multiline_comment|/* Set EOP and bus error. */
r_if
c_cond
(paren
(paren
id|tt_scsi_dma.dma_ctrl
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
multiline_comment|/* Read or write? */
id|set_restdata_reg
c_func
(paren
id|start_addr
)paren
suffix:semicolon
r_goto
id|scsi_end
suffix:semicolon
)brace
)brace
eof
