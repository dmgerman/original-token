macro_line|#ifndef NDEBUG
DECL|macro|NDEBUG
mdefine_line|#define NDEBUG (NDEBUG_RESTART_SELECT | NDEBUG_ABORT)
macro_line|#endif
multiline_comment|/* &n; * NCR 5380 generic driver routines.  These should make it *trivial*&n; *      to implement 5380 SCSI drivers under Linux with a non-trantor&n; *      architecture.&n; *&n; *      Note that these routines also work with NR53c400 family chips.&n; *&n; * Copyright 1993, Drew Eckhardt&n; *      Visionary Computing &n; *      (Unix and Linux consulting and custom programming)&n; *      drew@colorado.edu&n; *      +1 (303) 666-5836&n; *&n; * DISTRIBUTION RELEASE 6. &n; *&n; * For more information, please consult &n; *&n; * NCR 5380 Family&n; * SCSI Protocol Controller&n; * Databook&n; *&n; * NCR Microelectronics&n; * 1635 Aeroplaza Drive&n; * Colorado Springs, CO 80916&n; * 1+ (719) 578-3400&n; * 1+ (800) 334-5454&n; */
multiline_comment|/*&n; * $Log: NCR5380.c,v $&n;&n; * Revision 1.10 1998/9/2&t;Alan Cox&n; *&t;&t;&t;&t;(alan@redhat.com)&n; * Fixed up the timer lockups reported so far. Things still suck. Looking &n; * forward to 2.3 and per device request queues. Then it&squot;ll be possible to&n; * SMP thread this beast and improve life no end.&n; &n; * Revision 1.9  1997/7/27&t;Ronald van Cuijlenborg&n; *&t;&t;&t;&t;(ronald.van.cuijlenborg@tip.nl or nutty@dds.nl)&n; * (hopefully) fixed and enhanced USLEEP&n; * added support for DTC3181E card (for Mustek scanner)&n; *&n;&n; * Revision 1.8&t;&t;&t;Ingmar Baumgart&n; *&t;&t;&t;&t;(ingmar@gonzo.schwaben.de)&n; * added support for NCR53C400a card&n; *&n;&n; * Revision 1.7  1996/3/2       Ray Van Tassle (rayvt@comm.mot.com)&n; * added proc_info&n; * added support needed for DTC 3180/3280&n; * fixed a couple of bugs&n; *&n;&n; * Revision 1.5  1994/01/19  09:14:57  drew&n; * Fixed udelay() hack that was being used on DATAOUT phases&n; * instead of a proper wait for the final handshake.&n; *&n; * Revision 1.4  1994/01/19  06:44:25  drew&n; * *** empty log message ***&n; *&n; * Revision 1.3  1994/01/19  05:24:40  drew&n; * Added support for TCR LAST_BYTE_SENT bit.&n; *&n; * Revision 1.2  1994/01/15  06:14:11  drew&n; * REAL DMA support, bug fixes.&n; *&n; * Revision 1.1  1994/01/15  06:00:54  drew&n; * Initial revision&n; *&n; */
multiline_comment|/*&n; * Further development / testing that should be done : &n; * 1.  Cleanup the NCR5380_transfer_dma function and DMA operation complete&n; *     code so that everything does the same thing that&squot;s done at the &n; *     end of a pseudo-DMA read operation.&n; *&n; * 2.  Fix REAL_DMA (interrupt driven, polled works fine) -&n; *     basically, transfer size needs to be reduced by one &n; *     and the last byte read as is done with PSEUDO_DMA.&n; * &n; * 3.  Test USLEEP code &n; *&n; * 4.  Test SCSI-II tagged queueing (I have no devices which support &n; *      tagged queueing)&n; *&n; * 5.  Test linked command handling code after Eric is ready with &n; *      the high level code.&n; */
macro_line|#if (NDEBUG &amp; NDEBUG_LISTS)
DECL|macro|LIST
mdefine_line|#define LIST(x,y) {printk(&quot;LINE:%d   Adding %p to %p&bslash;n&quot;, __LINE__, (void*)(x), (void*)(y)); if ((x)==(y)) udelay(5); }
DECL|macro|REMOVE
mdefine_line|#define REMOVE(w,x,y,z) {printk(&quot;LINE:%d   Removing: %p-&gt;%p  %p-&gt;%p &bslash;n&quot;, __LINE__, (void*)(w), (void*)(x), (void*)(y), (void*)(z)); if ((x)==(y)) udelay(5); }
macro_line|#else
DECL|macro|LIST
mdefine_line|#define LIST(x,y)
DECL|macro|REMOVE
mdefine_line|#define REMOVE(w,x,y,z)
macro_line|#endif
macro_line|#ifndef notyet
DECL|macro|LINKED
macro_line|#undef LINKED
DECL|macro|REAL_DMA
macro_line|#undef REAL_DMA
macro_line|#endif
macro_line|#ifdef REAL_DMA_POLL
DECL|macro|READ_OVERRUNS
macro_line|#undef READ_OVERRUNS
DECL|macro|READ_OVERRUNS
mdefine_line|#define READ_OVERRUNS
macro_line|#endif
multiline_comment|/*&n; * Design&n; * Issues :&n; *&n; * The other Linux SCSI drivers were written when Linux was Intel PC-only,&n; * and specifically for each board rather than each chip.  This makes their&n; * adaptation to platforms like the Mac (Some of which use NCR5380&squot;s)&n; * more difficult than it has to be.&n; *&n; * Also, many of the SCSI drivers were written before the command queuing&n; * routines were implemented, meaning their implementations of queued &n; * commands were hacked on rather than designed in from the start.&n; *&n; * When I designed the Linux SCSI drivers I figured that &n; * while having two different SCSI boards in a system might be useful&n; * for debugging things, two of the same type wouldn&squot;t be used.&n; * Well, I was wrong and a number of users have mailed me about running&n; * multiple high-performance SCSI boards in a server.&n; *&n; * Finally, when I get questions from users, I have no idea what &n; * revision of my driver they are running.&n; *&n; * This driver attempts to address these problems :&n; * This is a generic 5380 driver.  To use it on a different platform, &n; * one simply writes appropriate system specific macros (ie, data&n; * transfer - some PC&squot;s will use the I/O bus, 68K&squot;s must use &n; * memory mapped) and drops this file in their &squot;C&squot; wrapper.&n; *&n; * As far as command queueing, two queues are maintained for &n; * each 5380 in the system - commands that haven&squot;t been issued yet,&n; * and commands that are currently executing.  This means that an &n; * unlimited number of commands may be queued, letting &n; * more commands propagate from the higher driver levels giving higher &n; * throughput.  Note that both I_T_L and I_T_L_Q nexuses are supported, &n; * allowing multiple commands to propagate all the way to a SCSI-II device &n; * while a command is already executing.&n; *&n; * To solve the multiple-boards-in-the-same-system problem, &n; * there is a separate instance structure for each instance&n; * of a 5380 in the system.  So, multiple NCR5380 drivers will&n; * be able to coexist with appropriate changes to the high level&n; * SCSI code.  &n; *&n; * A NCR5380_PUBLIC_REVISION macro is provided, with the release&n; * number (updated for each public release) printed by the &n; * NCR5380_print_options command, which should be called from the &n; * wrapper detect function, so that I know what release of the driver&n; * users are using.&n; *&n; * Issues specific to the NCR5380 : &n; *&n; * When used in a PIO or pseudo-dma mode, the NCR5380 is a braindead &n; * piece of hardware that requires you to sit in a loop polling for &n; * the REQ signal as long as you are connected.  Some devices are &n; * brain dead (ie, many TEXEL CD ROM drives) and won&squot;t disconnect &n; * while doing long seek operations.&n; * &n; * The workaround for this is to keep track of devices that have&n; * disconnected.  If the device hasn&squot;t disconnected, for commands that&n; * should disconnect, we do something like &n; *&n; * while (!REQ is asserted) { sleep for N usecs; poll for M usecs }&n; * &n; * Some tweaking of N and M needs to be done.  An algorithm based &n; * on &quot;time to data&quot; would give the best results as long as short time&n; * to datas (ie, on the same track) were considered, however these &n; * broken devices are the exception rather than the rule and I&squot;d rather&n; * spend my time optimizing for the normal case.&n; *&n; * Architecture :&n; *&n; * At the heart of the design is a coroutine, NCR5380_main,&n; * which is started when not running by the interrupt handler,&n; * timer, and queue command function.  It attempts to establish&n; * I_T_L or I_T_L_Q nexuses by removing the commands from the &n; * issue queue and calling NCR5380_select() if a nexus &n; * is not established. &n; *&n; * Once a nexus is established, the NCR5380_information_transfer()&n; * phase goes through the various phases as instructed by the target.&n; * if the target goes into MSG IN and sends a DISCONNECT message,&n; * the command structure is placed into the per instance disconnected&n; * queue, and NCR5380_main tries to find more work.  If USLEEP&n; * was defined, and the target is idle for too long, the system&n; * will try to sleep.&n; *&n; * If a command has disconnected, eventually an interrupt will trigger,&n; * calling NCR5380_intr()  which will in turn call NCR5380_reselect&n; * to reestablish a nexus.  This will run main if necessary.&n; *&n; * On command termination, the done function will be called as &n; * appropriate.&n; *&n; * SCSI pointers are maintained in the SCp field of SCSI command &n; * structures, being initialized after the command is connected&n; * in NCR5380_select, and set as appropriate in NCR5380_information_transfer.&n; * Note that in violation of the standard, an implicit SAVE POINTERS operation&n; * is done, since some BROKEN disks fail to issue an explicit SAVE POINTERS.&n; */
multiline_comment|/*&n; * Using this file :&n; * This file a skeleton Linux SCSI driver for the NCR 5380 series&n; * of chips.  To use it, you write an architecture specific functions &n; * and macros and include this file in your driver.&n; *&n; * These macros control options : &n; * AUTOPROBE_IRQ - if defined, the NCR5380_probe_irq() function will be &n; *      defined.&n; * &n; * AUTOSENSE - if defined, REQUEST SENSE will be performed automatically&n; *      for commands that return with a CHECK CONDITION status. &n; *&n; * DIFFERENTIAL - if defined, NCR53c81 chips will use external differential&n; *      transceivers. &n; *&n; * DONT_USE_INTR - if defined, never use interrupts, even if we probe or&n; *      override-configure an IRQ.&n; *&n; * LIMIT_TRANSFERSIZE - if defined, limit the pseudo-dma transfers to 512&n; *      bytes at a time.  Since interrupts are disabled by default during&n; *      these transfers, we might need this to give reasonable interrupt&n; *      service time if the transfer size gets too large.&n; *&n; * LINKED - if defined, linked commands are supported.&n; *&n; * PSEUDO_DMA - if defined, PSEUDO DMA is used during the data transfer phases.&n; *&n; * REAL_DMA - if defined, REAL DMA is used during the data transfer phases.&n; *&n; * REAL_DMA_POLL - if defined, REAL DMA is used but the driver doesn&squot;t&n; *      rely on phase mismatch and EOP interrupts to determine end &n; *      of phase.&n; *&n; * SCSI2 - if defined, SCSI-2 tagged queuing is used where possible&n; *&n; * UNSAFE - leave interrupts enabled during pseudo-DMA transfers.  You&n; *          only really want to use this if you&squot;re having a problem with&n; *          dropped characters during high speed communications, and even&n; *          then, you&squot;re going to be better off twiddling with transfersize&n; *          in the high level code.&n; *&n; * USLEEP - if defined, on devices that aren&squot;t disconnecting from the &n; *      bus, we will go to sleep so that the CPU can get real work done &n; *      when we run a command that won&squot;t complete immediately.&n; *&n; * Defaults for these will be provided if USLEEP is defined, although&n; * the user may want to adjust these to allocate CPU resources to &n; * the SCSI driver or &quot;real&quot; code.&n; * &n; * USLEEP_SLEEP - amount of time, in jiffies, to sleep&n; *&n; * USLEEP_POLL - amount of time, in jiffies, to poll&n; *&n; * These macros MUST be defined :&n; * NCR5380_local_declare() - declare any local variables needed for your&n; *      transfer routines.&n; *&n; * NCR5380_setup(instance) - initialize any local variables needed from a given&n; *      instance of the host adapter for NCR5380_{read,write,pread,pwrite}&n; * &n; * NCR5380_read(register)  - read from the specified register&n; *&n; * NCR5380_write(register, value) - write to the specific register &n; *&n; * NCR5380_implementation_fields  - additional fields needed for this &n; *      specific implementation of the NCR5380&n; *&n; * Either real DMA *or* pseudo DMA may be implemented&n; * REAL functions : &n; * NCR5380_REAL_DMA should be defined if real DMA is to be used.&n; * Note that the DMA setup functions should return the number of bytes &n; *      that they were able to program the controller for.&n; *&n; * Also note that generic i386/PC versions of these macros are &n; *      available as NCR5380_i386_dma_write_setup,&n; *      NCR5380_i386_dma_read_setup, and NCR5380_i386_dma_residual.&n; *&n; * NCR5380_dma_write_setup(instance, src, count) - initialize&n; * NCR5380_dma_read_setup(instance, dst, count) - initialize&n; * NCR5380_dma_residual(instance); - residual count&n; *&n; * PSEUDO functions :&n; * NCR5380_pwrite(instance, src, count)&n; * NCR5380_pread(instance, dst, count);&n; *&n; * If nothing specific to this implementation needs doing (ie, with external&n; * hardware), you must also define &n; *  &n; * NCR5380_queue_command&n; * NCR5380_reset&n; * NCR5380_abort&n; * NCR5380_proc_info&n; *&n; * to be the global entry points into the specific driver, ie &n; * #define NCR5380_queue_command t128_queue_command.&n; *&n; * If this is not done, the routines will be defined as static functions&n; * with the NCR5380* names and the user must provide a globally&n; * accessible wrapper function.&n; *&n; * The generic driver is initialized by calling NCR5380_init(instance),&n; * after setting the appropriate host specific fields and ID.  If the &n; * driver wishes to autoprobe for an IRQ line, the NCR5380_probe_irq(instance,&n; * possible) function may be used.  Before the specific driver initialization&n; * code finishes, NCR5380_print_options should be called.&n; */
r_static
r_int
id|do_abort
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
suffix:semicolon
r_static
r_void
id|do_reset
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
suffix:semicolon
DECL|variable|first_instance
r_static
r_struct
id|Scsi_Host
op_star
id|first_instance
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|the_template
r_static
id|Scsi_Host_Template
op_star
id|the_template
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef USLEEP
DECL|variable|usleep_timer
r_struct
id|timer_list
id|usleep_timer
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Function : void initialize_SCp(Scsi_Cmnd *cmd)&n; *&n; * Purpose : initialize the saved data pointers for cmd to point to the &n; *      start of the buffer.&n; *&n; * Inputs : cmd - Scsi_Cmnd structure to have pointers reset.&n; */
DECL|function|initialize_SCp
r_static
id|__inline__
r_void
id|initialize_SCp
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/* &n;&t; * Initialize the Scsi Pointer field so that all of the commands in the &n;&t; * various queues are valid.&n;&t; */
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
id|cmd-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
id|cmd-&gt;SCp.buffers_residual
op_assign
id|cmd-&gt;use_sg
op_minus
l_int|1
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|cmd-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
r_else
(brace
id|cmd-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.buffers_residual
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
)brace
)brace
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#ifdef NDEBUG
r_static
r_struct
(brace
DECL|member|mask
r_int
r_char
id|mask
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|variable|signals
)brace
id|signals
(braket
)braket
op_assign
(brace
(brace
id|SR_DBP
comma
l_string|&quot;PARITY&quot;
)brace
comma
(brace
id|SR_RST
comma
l_string|&quot;RST&quot;
)brace
comma
(brace
id|SR_BSY
comma
l_string|&quot;BSY&quot;
)brace
comma
(brace
id|SR_REQ
comma
l_string|&quot;REQ&quot;
)brace
comma
(brace
id|SR_MSG
comma
l_string|&quot;MSG&quot;
)brace
comma
(brace
id|SR_CD
comma
l_string|&quot;CD&quot;
)brace
comma
(brace
id|SR_IO
comma
l_string|&quot;IO&quot;
)brace
comma
(brace
id|SR_SEL
comma
l_string|&quot;SEL&quot;
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
comma
DECL|variable|basrs
id|basrs
(braket
)braket
op_assign
(brace
(brace
id|BASR_ATN
comma
l_string|&quot;ATN&quot;
)brace
comma
(brace
id|BASR_ACK
comma
l_string|&quot;ACK&quot;
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
comma
DECL|variable|icrs
id|icrs
(braket
)braket
op_assign
(brace
(brace
id|ICR_ASSERT_RST
comma
l_string|&quot;ASSERT RST&quot;
)brace
comma
(brace
id|ICR_ASSERT_ACK
comma
l_string|&quot;ASSERT ACK&quot;
)brace
comma
(brace
id|ICR_ASSERT_BSY
comma
l_string|&quot;ASSERT BSY&quot;
)brace
comma
(brace
id|ICR_ASSERT_SEL
comma
l_string|&quot;ASSERT SEL&quot;
)brace
comma
(brace
id|ICR_ASSERT_ATN
comma
l_string|&quot;ASSERT ATN&quot;
)brace
comma
(brace
id|ICR_ASSERT_DATA
comma
l_string|&quot;ASSERT DATA&quot;
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
comma
DECL|variable|mrs
id|mrs
(braket
)braket
op_assign
(brace
(brace
id|MR_BLOCK_DMA_MODE
comma
l_string|&quot;MODE BLOCK DMA&quot;
)brace
comma
(brace
id|MR_TARGET
comma
l_string|&quot;MODE TARGET&quot;
)brace
comma
(brace
id|MR_ENABLE_PAR_CHECK
comma
l_string|&quot;MODE PARITY CHECK&quot;
)brace
comma
(brace
id|MR_ENABLE_PAR_INTR
comma
l_string|&quot;MODE PARITY INTR&quot;
)brace
comma
(brace
id|MR_MONITOR_BSY
comma
l_string|&quot;MODE MONITOR BSY&quot;
)brace
comma
(brace
id|MR_DMA_MODE
comma
l_string|&quot;MODE DMA&quot;
)brace
comma
(brace
id|MR_ARBITRATE
comma
l_string|&quot;MODE ARBITRATION&quot;
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Function : void NCR5380_print(struct Scsi_Host *instance)&n; *&n; * Purpose : print the SCSI bus signals for debugging purposes&n; *&n; * Input : instance - which NCR5380&n; */
DECL|function|NCR5380_print
r_static
r_void
id|NCR5380_print
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|status
comma
id|data
comma
id|basr
comma
id|mr
comma
id|icr
comma
id|i
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|data
op_assign
id|NCR5380_read
c_func
(paren
id|CURRENT_SCSI_DATA_REG
)paren
suffix:semicolon
id|status
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
suffix:semicolon
id|mr
op_assign
id|NCR5380_read
c_func
(paren
id|MODE_REG
)paren
suffix:semicolon
id|icr
op_assign
id|NCR5380_read
c_func
(paren
id|INITIATOR_COMMAND_REG
)paren
suffix:semicolon
id|basr
op_assign
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;STATUS_REG: %02x &quot;
comma
id|status
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|signals
(braket
id|i
)braket
dot
id|mask
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|status
op_amp
id|signals
(braket
id|i
)braket
dot
id|mask
)paren
id|printk
c_func
(paren
l_string|&quot;,%s&quot;
comma
id|signals
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nBASR: %02x &quot;
comma
id|basr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|basrs
(braket
id|i
)braket
dot
id|mask
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|basr
op_amp
id|basrs
(braket
id|i
)braket
dot
id|mask
)paren
id|printk
c_func
(paren
l_string|&quot;,%s&quot;
comma
id|basrs
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nICR: %02x &quot;
comma
id|icr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|icrs
(braket
id|i
)braket
dot
id|mask
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|icr
op_amp
id|icrs
(braket
id|i
)braket
dot
id|mask
)paren
id|printk
c_func
(paren
l_string|&quot;,%s&quot;
comma
id|icrs
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nMODE: %02x &quot;
comma
id|mr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mrs
(braket
id|i
)braket
dot
id|mask
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|mr
op_amp
id|mrs
(braket
id|i
)braket
dot
id|mask
)paren
id|printk
c_func
(paren
l_string|&quot;,%s&quot;
comma
id|mrs
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_static
r_struct
(brace
DECL|member|value
r_int
r_char
id|value
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|variable|phases
)brace
id|phases
(braket
)braket
op_assign
(brace
(brace
id|PHASE_DATAOUT
comma
l_string|&quot;DATAOUT&quot;
)brace
comma
(brace
id|PHASE_DATAIN
comma
l_string|&quot;DATAIN&quot;
)brace
comma
(brace
id|PHASE_CMDOUT
comma
l_string|&quot;CMDOUT&quot;
)brace
comma
(brace
id|PHASE_STATIN
comma
l_string|&quot;STATIN&quot;
)brace
comma
(brace
id|PHASE_MSGOUT
comma
l_string|&quot;MSGOUT&quot;
)brace
comma
(brace
id|PHASE_MSGIN
comma
l_string|&quot;MSGIN&quot;
)brace
comma
(brace
id|PHASE_UNKNOWN
comma
l_string|&quot;UNKNOWN&quot;
)brace
)brace
suffix:semicolon
multiline_comment|/* &n; * Function : void NCR5380_print_phase(struct Scsi_Host *instance)&n; *&n; * Purpose : print the current SCSI phase for debugging purposes&n; *&n; * Input : instance - which NCR5380&n; */
DECL|function|NCR5380_print_phase
r_static
r_void
id|NCR5380_print_phase
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_int
id|i
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
id|status
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|SR_REQ
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : REQ not asserted, phase unknown.&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|phases
(braket
id|i
)braket
dot
id|value
op_ne
id|PHASE_UNKNOWN
)paren
op_logical_and
(paren
id|phases
(braket
id|i
)braket
dot
id|value
op_ne
(paren
id|status
op_amp
id|PHASE_MASK
)paren
)paren
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase %s&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|phases
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n; * We need to have our coroutine active given these constraints : &n; * 1.  The mutex flag, main_running, can only be set when the main &n; *     routine can actually process data, otherwise SCSI commands&n; *     will never get issued.&n; *&n; * 2.  NCR5380_main() shouldn&squot;t be called before it has exited, because&n; *     other drivers have had kernel stack overflows in similar&n; *     situations.&n; *&n; * 3.  We don&squot;t want to inline NCR5380_main() because of space concerns,&n; *     even though it is only called in two places.&n; *&n; * So, the solution is to set the mutex in an inline wrapper for the &n; * main coroutine, and have the main coroutine exit with interrupts &n; * disabled after the final search through the queues so that no race &n; * conditions are possible.&n; */
DECL|variable|main_running
r_static
r_volatile
r_int
id|main_running
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n; * Function : run_main(void)&n; * &n; * Purpose : insure that the coroutine is running and will process our &n; *      request.  main_running is checked/set here (in an inline function)&n; *      rather than in NCR5380_main itself to reduce the chances of stack&n; *      overflow.&n; *&n; */
DECL|function|run_main
r_static
id|__inline__
r_void
id|run_main
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|main_running
)paren
(brace
id|main_running
op_assign
l_int|1
suffix:semicolon
id|NCR5380_main
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef USLEEP
multiline_comment|/*&n; * These need tweaking, and would probably work best as per-device &n; * flags initialized differently for disk, tape, cd, etc devices.&n; * People with broken devices are free to experiment as to what gives&n; * the best results for them.&n; *&n; * USLEEP_SLEEP should be a minimum seek time.&n; *&n; * USLEEP_POLL should be a maximum rotational latency.&n; */
macro_line|#ifndef USLEEP_SLEEP
multiline_comment|/* 20 ms (reasonable hard disk speed) */
DECL|macro|USLEEP_SLEEP
mdefine_line|#define USLEEP_SLEEP (20*HZ/1000)
macro_line|#endif
multiline_comment|/* 300 RPM (floppy speed) */
macro_line|#ifndef USLEEP_POLL
DECL|macro|USLEEP_POLL
mdefine_line|#define USLEEP_POLL (200*HZ/1000)
macro_line|#endif
macro_line|#ifndef USLEEP_WAITLONG
multiline_comment|/* RvC: (reasonable time to wait on select error) */
DECL|macro|USLEEP_WAITLONG
mdefine_line|#define USLEEP_WAITLONG USLEEP_SLEEP
macro_line|#endif
DECL|variable|expires_first
r_static
r_struct
id|Scsi_Host
op_star
id|expires_first
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* &n; * Function : int should_disconnect (unsigned char cmd)&n; *&n; * Purpose : decide weather a command would normally disconnect or &n; *      not, since if it won&squot;t disconnect we should go to sleep.&n; *&n; * Input : cmd - opcode of SCSI command&n; *&n; * Returns : DISCONNECT_LONG if we should disconnect for a really long &n; *      time (ie always, sleep, look for REQ active, sleep), &n; *      DISCONNECT_TIME_TO_DATA if we would only disconnect for a normal&n; *      time-to-data delay, DISCONNECT_NONE if this command would return&n; *      immediately.&n; *&n; *      Future sleep algorithms based on time to data can exploit &n; *      something like this so they can differentiate between &quot;normal&quot; &n; *      (ie, read, write, seek) and unusual commands (ie, * format).&n; *&n; * Note : We don&squot;t deal with commands that handle an immediate disconnect,&n; *        &n; */
DECL|function|should_disconnect
r_static
r_int
id|should_disconnect
c_func
(paren
r_int
r_char
id|cmd
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|READ_6
suffix:colon
r_case
id|WRITE_6
suffix:colon
r_case
id|SEEK_6
suffix:colon
r_case
id|READ_10
suffix:colon
r_case
id|WRITE_10
suffix:colon
r_case
id|SEEK_10
suffix:colon
r_return
id|DISCONNECT_TIME_TO_DATA
suffix:semicolon
r_case
id|FORMAT_UNIT
suffix:colon
r_case
id|SEARCH_HIGH
suffix:colon
r_case
id|SEARCH_LOW
suffix:colon
r_case
id|SEARCH_EQUAL
suffix:colon
r_return
id|DISCONNECT_LONG
suffix:semicolon
r_default
suffix:colon
r_return
id|DISCONNECT_NONE
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Assumes instance-&gt;time_expires has been set in higher level code.&n; */
DECL|function|NCR5380_set_timer
r_static
r_int
id|NCR5380_set_timer
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|tmp
comma
op_star
op_star
id|prev
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
(paren
id|instance-&gt;hostdata
)paren
)paren
op_member_access_from_pointer
id|next_timer
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|prev
op_assign
op_amp
id|expires_first
comma
id|tmp
op_assign
id|expires_first
suffix:semicolon
id|tmp
suffix:semicolon
id|prev
op_assign
op_amp
(paren
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|tmp-&gt;hostdata
)paren
op_member_access_from_pointer
id|next_timer
)paren
comma
id|tmp
op_assign
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|tmp-&gt;hostdata
)paren
op_member_access_from_pointer
id|next_timer
)paren
r_if
c_cond
(paren
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
)paren
op_member_access_from_pointer
id|time_expires
OL
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|tmp-&gt;hostdata
)paren
op_member_access_from_pointer
id|time_expires
)paren
r_break
suffix:semicolon
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
)paren
op_member_access_from_pointer
id|next_timer
op_assign
id|tmp
suffix:semicolon
op_star
id|prev
op_assign
id|instance
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|usleep_timer
comma
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|expires_first-&gt;hostdata
)paren
op_member_access_from_pointer
id|time_expires
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Doing something about unwanted reentrancy here might be useful */
DECL|function|NCR5380_timer_fn
r_void
id|NCR5380_timer_fn
c_func
(paren
r_int
r_int
id|surplus_to_requirements
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|expires_first
op_logical_and
id|time_before_eq
c_func
(paren
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|expires_first-&gt;hostdata
)paren
op_member_access_from_pointer
id|time_expires
comma
id|jiffies
)paren
suffix:semicolon
)paren
(brace
id|instance
op_assign
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|expires_first-&gt;hostdata
)paren
op_member_access_from_pointer
id|next_timer
suffix:semicolon
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|expires_first-&gt;hostdata
)paren
op_member_access_from_pointer
id|next_timer
op_assign
l_int|NULL
suffix:semicolon
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|expires_first-&gt;hostdata
)paren
op_member_access_from_pointer
id|time_expires
op_assign
l_int|0
suffix:semicolon
id|expires_first
op_assign
id|instance
suffix:semicolon
)brace
id|del_timer
c_func
(paren
op_amp
id|usleep_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|expires_first
)paren
(brace
id|usleep_timer.expires
op_assign
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|expires_first-&gt;hostdata
)paren
op_member_access_from_pointer
id|time_expires
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|usleep_timer
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|run_main
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* def USLEEP */
DECL|function|NCR5380_all_init
r_static
r_inline
r_void
id|NCR5380_all_init
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_INIT)
id|printk
c_func
(paren
l_string|&quot;scsi : NCR5380_all_init()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|done
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef USLEEP
id|init_timer
c_func
(paren
op_amp
id|usleep_timer
)paren
suffix:semicolon
id|usleep_timer.function
op_assign
id|NCR5380_timer_fn
suffix:semicolon
macro_line|#endif
)brace
)brace
macro_line|#ifdef AUTOPROBE_IRQ
multiline_comment|/*&n; * Function : int NCR5380_probe_irq (struct Scsi_Host *instance, int possible)&n; * &n; * Purpose : autoprobe for the IRQ line used by the NCR5380.  &n; *&n; * Inputs : instance - pointer to this instance of the NCR5380 driver,&n; *          possible - bitmask of permissible interrupts.&n; *&n; * Returns : number of the IRQ selected, IRQ_NONE if no interrupt fired.&n; * &n; * XXX no effort is made to deal with spurious interrupts. &n; */
DECL|variable|__initdata
r_static
r_int
id|probe_irq
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|function|probe_intr
r_static
r_void
id|__init
id|probe_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|probe_irq
op_assign
id|irq
suffix:semicolon
)brace
DECL|function|NCR5380_probe_irq
r_static
r_int
id|__init
id|NCR5380_probe_irq
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
id|possible
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_int
id|trying_irqs
comma
id|i
comma
id|mask
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
r_for
c_loop
(paren
id|trying_irqs
op_assign
id|i
op_assign
l_int|0
comma
id|mask
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
comma
id|mask
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|possible
)paren
op_logical_and
(paren
id|request_irq
c_func
(paren
id|i
comma
op_amp
id|probe_intr
comma
id|SA_INTERRUPT
comma
l_string|&quot;NCR-probe&quot;
comma
l_int|NULL
)paren
op_eq
l_int|0
)paren
)paren
id|trying_irqs
op_or_assign
id|mask
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
(paren
l_int|250
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
id|probe_irq
op_assign
id|IRQ_NONE
suffix:semicolon
multiline_comment|/*&n; * A interrupt is triggered whenever BSY = false, SEL = true&n; * and a bit set in the SELECT_ENABLE_REG is asserted on the &n; * SCSI bus.&n; *&n; * Note that the bus is only driven when the phase control signals&n; * (I/O, C/D, and MSG) match those in the TCR, so we must reset that&n; * to zero.&n; */
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
l_int|0
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|OUTPUT_DATA_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
op_or
id|ICR_ASSERT_SEL
)paren
suffix:semicolon
r_while
c_loop
(paren
id|probe_irq
op_eq
id|IRQ_NONE
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
l_int|0
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mask
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
comma
id|mask
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|trying_irqs
op_amp
id|mask
)paren
id|free_irq
c_func
(paren
id|i
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|probe_irq
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* AUTOPROBE_IRQ */
multiline_comment|/*&n; * Function : void NCR58380_print_options (struct Scsi_Host *instance)&n; *&n; * Purpose : called by probe code indicating the NCR5380 driver&n; *           options that were selected.&n; *&n; * Inputs : instance, pointer to this instance.  Unused.&n; */
DECL|function|NCR5380_print_options
r_static
r_void
id|__init
id|NCR5380_print_options
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; generic options&quot;
macro_line|#ifdef AUTOPROBE_IRQ
l_string|&quot; AUTOPROBE_IRQ&quot;
macro_line|#endif
macro_line|#ifdef AUTOSENSE
l_string|&quot; AUTOSENSE&quot;
macro_line|#endif
macro_line|#ifdef DIFFERENTIAL
l_string|&quot; DIFFERENTIAL&quot;
macro_line|#endif
macro_line|#ifdef REAL_DMA
l_string|&quot; REAL DMA&quot;
macro_line|#endif
macro_line|#ifdef REAL_DMA_POLL
l_string|&quot; REAL DMA POLL&quot;
macro_line|#endif
macro_line|#ifdef PARITY
l_string|&quot; PARITY&quot;
macro_line|#endif
macro_line|#ifdef PSEUDO_DMA
l_string|&quot; PSEUDO DMA&quot;
macro_line|#endif
macro_line|#ifdef SCSI2
l_string|&quot; SCSI-2&quot;
macro_line|#endif
macro_line|#ifdef UNSAFE
l_string|&quot; UNSAFE &quot;
macro_line|#endif
)paren
suffix:semicolon
macro_line|#ifdef USLEEP
id|printk
c_func
(paren
l_string|&quot; USLEEP, USLEEP_POLL=%d USLEEP_SLEEP=%d&quot;
comma
id|USLEEP_POLL
comma
id|USLEEP_SLEEP
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot; generic release=%d&quot;
comma
id|NCR5380_PUBLIC_RELEASE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
)paren
op_member_access_from_pointer
id|flags
op_amp
id|FLAG_NCR53C400
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; ncr53c400 release=%d&quot;
comma
id|NCR53C400_PUBLIC_RELEASE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function : void NCR5380_print_status (struct Scsi_Host *instance)&n; *&n; * Purpose : print commands in the various queues, called from&n; *      NCR5380_abort and NCR5380_debug to aid debugging.&n; *&n; * Inputs : instance, pointer to this instance.  &n; */
DECL|function|NCR5380_print_status
r_static
r_void
id|NCR5380_print_status
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
r_static
r_char
id|pr_bfr
(braket
l_int|512
)braket
suffix:semicolon
r_char
op_star
id|start
suffix:semicolon
r_int
id|len
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NCR5380 : coroutine is%s running.&bslash;n&quot;
comma
id|main_running
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;n&squot;t&quot;
)paren
suffix:semicolon
macro_line|#ifdef NDEBUG
id|NCR5380_print
c_func
(paren
id|instance
)paren
suffix:semicolon
id|NCR5380_print_phase
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
id|len
op_assign
id|NCR5380_proc_info
c_func
(paren
id|pr_bfr
comma
op_amp
id|start
comma
l_int|0
comma
r_sizeof
(paren
id|pr_bfr
)paren
comma
id|instance-&gt;host_no
comma
l_int|0
)paren
suffix:semicolon
id|pr_bfr
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n%s&bslash;n&quot;
comma
id|pr_bfr
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************/
multiline_comment|/*&n; * /proc/scsi/[dtc pas16 t128 generic]/[0-ASC_NUM_BOARD_SUPPORTED]&n; *&n; * *buffer: I/O buffer&n; * **start: if inout == FALSE pointer into buffer where user read should start&n; * offset: current offset&n; * length: length of buffer&n; * hostno: Scsi_Host host_no&n; * inout: TRUE - user is writing; FALSE - user is reading&n; *&n; * Return the number of bytes read from or written&n; */
DECL|macro|SPRINTF
macro_line|#undef SPRINTF
DECL|macro|SPRINTF
mdefine_line|#define SPRINTF(args...) do { if(pos &lt; buffer + length-80) pos += sprintf(pos, ## args); } while(0)
r_static
r_char
op_star
id|lprint_Scsi_Cmnd
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_char
op_star
id|pos
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
suffix:semicolon
r_static
r_char
op_star
id|lprint_command
c_func
(paren
r_int
r_char
op_star
id|cmd
comma
r_char
op_star
id|pos
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_char
op_star
id|lprint_opcode
c_func
(paren
r_int
id|opcode
comma
r_char
op_star
id|pos
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
suffix:semicolon
macro_line|#ifndef NCR5380_proc_info
r_static
macro_line|#endif
DECL|function|NCR5380_proc_info
r_int
id|NCR5380_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|inout
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|pos
op_assign
id|buffer
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
suffix:semicolon
id|Scsi_Cmnd
op_star
id|ptr
suffix:semicolon
r_for
c_loop
(paren
id|instance
op_assign
id|first_instance
suffix:semicolon
id|instance
op_logical_and
id|instance-&gt;host_no
op_ne
id|hostno
suffix:semicolon
id|instance
op_assign
id|instance-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|instance
)paren
r_return
(paren
op_minus
id|ESRCH
)paren
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
r_if
c_cond
(paren
id|inout
)paren
(brace
multiline_comment|/* Has data been written to the file ? */
macro_line|#ifdef DTC_PUBLIC_RELEASE
id|dtc_wmaxi
op_assign
id|dtc_maxi
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#ifdef PAS16_PUBLIC_RELEASE
id|pas_wmaxi
op_assign
id|pas_maxi
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_return
(paren
op_minus
id|ENOSYS
)paren
suffix:semicolon
multiline_comment|/* Currently this is a no-op */
)brace
id|SPRINTF
c_func
(paren
l_string|&quot;NCR5380 core release=%d.   &quot;
comma
id|NCR5380_PUBLIC_RELEASE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
)paren
op_member_access_from_pointer
id|flags
op_amp
id|FLAG_NCR53C400
)paren
id|SPRINTF
c_func
(paren
l_string|&quot;ncr53c400 release=%d.  &quot;
comma
id|NCR53C400_PUBLIC_RELEASE
)paren
suffix:semicolon
macro_line|#ifdef DTC_PUBLIC_RELEASE
id|SPRINTF
c_func
(paren
l_string|&quot;DTC 3180/3280 release %d&quot;
comma
id|DTC_PUBLIC_RELEASE
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef T128_PUBLIC_RELEASE
id|SPRINTF
c_func
(paren
l_string|&quot;T128 release %d&quot;
comma
id|T128_PUBLIC_RELEASE
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef GENERIC_NCR5380_PUBLIC_RELEASE
id|SPRINTF
c_func
(paren
l_string|&quot;Generic5380 release %d&quot;
comma
id|GENERIC_NCR5380_PUBLIC_RELEASE
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef PAS16_PUBLIC_RELEASE
id|SPRINTF
c_func
(paren
l_string|&quot;PAS16 release=%d&quot;
comma
id|PAS16_PUBLIC_RELEASE
)paren
suffix:semicolon
macro_line|#endif
id|SPRINTF
c_func
(paren
l_string|&quot;&bslash;nBase Addr: 0x%05lX    &quot;
comma
(paren
r_int
)paren
id|instance-&gt;base
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;io_port: %04x      &quot;
comma
(paren
r_int
)paren
id|instance-&gt;io_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|instance-&gt;irq
op_eq
id|IRQ_NONE
)paren
id|SPRINTF
c_func
(paren
l_string|&quot;IRQ: None.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|SPRINTF
c_func
(paren
l_string|&quot;IRQ: %d.&bslash;n&quot;
comma
id|instance-&gt;irq
)paren
suffix:semicolon
macro_line|#ifdef DTC_PUBLIC_RELEASE
id|SPRINTF
c_func
(paren
l_string|&quot;Highwater I/O busy_spin_counts -- write: %d  read: %d&bslash;n&quot;
comma
id|dtc_wmaxi
comma
id|dtc_maxi
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef PAS16_PUBLIC_RELEASE
id|SPRINTF
c_func
(paren
l_string|&quot;Highwater I/O busy_spin_counts -- write: %d  read: %d&bslash;n&quot;
comma
id|pas_wmaxi
comma
id|pas_maxi
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;NCR5380 : coroutine is%s running.&bslash;n&quot;
comma
id|main_running
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;n&squot;t&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;connected
)paren
id|SPRINTF
c_func
(paren
l_string|&quot;scsi%d: no currently connected command&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
r_else
id|pos
op_assign
id|lprint_Scsi_Cmnd
c_func
(paren
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;connected
comma
id|pos
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;scsi%d: issue_queue&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|ptr
suffix:semicolon
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
)paren
id|pos
op_assign
id|lprint_Scsi_Cmnd
c_func
(paren
id|ptr
comma
id|pos
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;scsi%d: disconnected_queue&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_queue
suffix:semicolon
id|ptr
suffix:semicolon
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
)paren
id|pos
op_assign
id|lprint_Scsi_Cmnd
c_func
(paren
id|ptr
comma
id|pos
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_minus
id|buffer
OL
id|offset
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pos
op_minus
id|buffer
op_minus
id|offset
OL
id|length
)paren
r_return
id|pos
op_minus
id|buffer
op_minus
id|offset
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
r_static
DECL|function|lprint_Scsi_Cmnd
r_char
op_star
id|lprint_Scsi_Cmnd
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_char
op_star
id|pos
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
id|SPRINTF
c_func
(paren
l_string|&quot;scsi%d : destination target %d, lun %d&bslash;n&quot;
comma
id|cmd-&gt;host-&gt;host_no
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;        command = &quot;
)paren
suffix:semicolon
id|pos
op_assign
id|lprint_command
c_func
(paren
id|cmd-&gt;cmnd
comma
id|pos
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
r_return
(paren
id|pos
)paren
suffix:semicolon
)brace
r_static
DECL|function|lprint_command
r_char
op_star
id|lprint_command
c_func
(paren
r_int
r_char
op_star
id|command
comma
r_char
op_star
id|pos
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_int
id|i
comma
id|s
suffix:semicolon
id|pos
op_assign
id|lprint_opcode
c_func
(paren
id|command
(braket
l_int|0
)braket
comma
id|pos
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
comma
id|s
op_assign
id|COMMAND_SIZE
c_func
(paren
id|command
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
OL
id|s
suffix:semicolon
op_increment
id|i
)paren
id|SPRINTF
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|command
(braket
id|i
)braket
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|pos
)paren
suffix:semicolon
)brace
r_static
DECL|function|lprint_opcode
r_char
op_star
id|lprint_opcode
c_func
(paren
r_int
id|opcode
comma
r_char
op_star
id|pos
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
id|SPRINTF
c_func
(paren
l_string|&quot;%2d (0x%02x)&quot;
comma
id|opcode
comma
id|opcode
)paren
suffix:semicolon
r_return
(paren
id|pos
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : void NCR5380_init (struct Scsi_Host *instance, flags)&n; *&n; * Purpose : initializes *instance and corresponding 5380 chip,&n; *      with flags OR&squot;d into the initial flags value.&n; *&n; * Inputs : instance - instantiation of the 5380 driver.  &n; *&n; * Notes : I assume that the host, hostno, and id bits have been&n; *      set correctly.  I don&squot;t care about the irq and other fields. &n; * &n; */
DECL|function|NCR5380_init
r_static
r_void
id|__init
id|NCR5380_init
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
id|flags
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_int
id|i
comma
id|pass
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
multiline_comment|/* &n;&t; * On NCR53C400 boards, NCR5380 registers are mapped 8 past &n;&t; * the base address.&n;&t; */
macro_line|#ifdef NCR53C400
r_if
c_cond
(paren
id|flags
op_amp
id|FLAG_NCR53C400
)paren
id|instance-&gt;NCR5380_instance_name
op_add_assign
id|NCR53C400_address_adjust
suffix:semicolon
macro_line|#endif
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
id|NCR5380_all_init
c_func
(paren
)paren
suffix:semicolon
id|hostdata-&gt;aborted
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;id_mask
op_assign
l_int|1
op_lshift
id|instance-&gt;this_id
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|hostdata-&gt;id_mask
suffix:semicolon
id|i
op_le
l_int|0x80
suffix:semicolon
id|i
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|i
OG
id|hostdata-&gt;id_mask
)paren
id|hostdata-&gt;id_higher_mask
op_or_assign
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
id|hostdata-&gt;busy
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef REAL_DMA
id|hostdata-&gt;dmalen
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;targets_present
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;issue_queue
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;disconnected_queue
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef NCR5380_STATS
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
(brace
id|hostdata-&gt;time_read
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;time_write
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;bytes_read
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;bytes_write
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|hostdata-&gt;timebase
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;pendingw
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;pendingr
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* The CHECK code seems to break the 53C400. Will check it later maybe */
r_if
c_cond
(paren
id|flags
op_amp
id|FLAG_NCR53C400
)paren
id|hostdata-&gt;flags
op_assign
id|FLAG_HAS_LAST_BYTE_SENT
op_or
id|flags
suffix:semicolon
r_else
id|hostdata-&gt;flags
op_assign
id|FLAG_CHECK_LAST_BYTE_SENT
op_or
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|the_template
)paren
(brace
id|the_template
op_assign
id|instance-&gt;hostt
suffix:semicolon
id|first_instance
op_assign
id|instance
suffix:semicolon
)brace
macro_line|#ifdef USLEEP
id|hostdata-&gt;time_expires
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;next_timer
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
macro_line|#ifndef AUTOSENSE
r_if
c_cond
(paren
(paren
id|instance-&gt;cmd_per_lun
OG
l_int|1
)paren
op_logical_or
id|instance-&gt;can_queue
OG
l_int|1
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : WARNING : support for multiple outstanding commands enabled&bslash;n&quot;
l_string|&quot;         without AUTOSENSE option, contingent allegiance conditions may&bslash;n&quot;
l_string|&quot;         be incorrectly cleared.&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* def AUTOSENSE */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
l_int|0
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef NCR53C400
r_if
c_cond
(paren
id|hostdata-&gt;flags
op_amp
id|FLAG_NCR53C400
)paren
(brace
id|NCR5380_write
c_func
(paren
id|C400_CONTROL_STATUS_REG
comma
id|CSR_BASE
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* &n;&t; * Detect and correct bus wedge problems.&n;&t; *&n;&t; * If the system crashed, it may have crashed in a state &n;&t; * where a SCSI command was still executing, and the &n;&t; * SCSI bus is not in a BUS FREE STATE.&n;&t; *&n;&t; * If this is the case, we&squot;ll try to abort the currently&n;&t; * established nexus which we know nothing about, and that&n;&t; * failing, do a hard reset of the SCSI bus &n;&t; */
r_for
c_loop
(paren
id|pass
op_assign
l_int|1
suffix:semicolon
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_BSY
)paren
op_logical_and
id|pass
op_le
l_int|6
suffix:semicolon
op_increment
id|pass
)paren
(brace
r_switch
c_cond
(paren
id|pass
)paren
(brace
r_case
l_int|1
suffix:colon
r_case
l_int|3
suffix:colon
r_case
l_int|5
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d: SCSI bus busy, waiting up to five seconds&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
l_int|5
op_star
id|HZ
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
op_logical_and
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_BSY
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d: bus busy, attempting abort&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|do_abort
c_func
(paren
id|instance
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d: bus busy, attempting reset&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|do_reset
c_func
(paren
id|instance
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d: bus locked solid or invalid override&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* &n; * Function : int NCR5380_queue_command (Scsi_Cmnd *cmd, &n; *      void (*done)(Scsi_Cmnd *)) &n; *&n; * Purpose :  enqueues a SCSI command&n; *&n; * Inputs : cmd - SCSI command, done - function called on completion, with&n; *      a pointer to the command descriptor.&n; * &n; * Returns : 0&n; *&n; * Side effects : &n; *      cmd is added to the per instance issue_queue, with minor &n; *      twiddling done to the host specific fields of cmd.  If the &n; *      main coroutine is not running, it is restarted.&n; *&n; */
multiline_comment|/* Only make static if a wrapper function is used */
macro_line|#ifndef NCR5380_queue_command
r_static
macro_line|#endif
DECL|function|NCR5380_queue_command
r_int
id|NCR5380_queue_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|instance
op_assign
id|cmd-&gt;host
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|Scsi_Cmnd
op_star
id|tmp
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_NO_WRITE)
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : WRITE attempted with NO_WRITE debugging flag set&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* (NDEBUG &amp; NDEBUG_NO_WRITE) */
macro_line|#ifdef NCR5380_STATS
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;connected
op_logical_and
op_logical_neg
id|hostdata-&gt;issue_queue
op_logical_and
op_logical_neg
id|hostdata-&gt;disconnected_queue
)paren
(brace
id|hostdata-&gt;timebase
op_assign
id|jiffies
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef NCR5380_STAT_LIMIT
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
OG
id|NCR5380_STAT_LIMIT
)paren
macro_line|#endif
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|WRITE
suffix:colon
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
id|hostdata-&gt;time_write
(braket
id|cmd-&gt;target
)braket
op_sub_assign
(paren
id|jiffies
op_minus
id|hostdata-&gt;timebase
)paren
suffix:semicolon
id|hostdata-&gt;bytes_write
(braket
id|cmd-&gt;target
)braket
op_add_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|hostdata-&gt;pendingw
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ
suffix:colon
r_case
id|READ_6
suffix:colon
r_case
id|READ_10
suffix:colon
id|hostdata-&gt;time_read
(braket
id|cmd-&gt;target
)braket
op_sub_assign
(paren
id|jiffies
op_minus
id|hostdata-&gt;timebase
)paren
suffix:semicolon
id|hostdata-&gt;bytes_read
(braket
id|cmd-&gt;target
)braket
op_add_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|hostdata-&gt;pendingr
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* &n;&t; * We use the host_scribble field as a pointer to the next command  &n;&t; * in a queue &n;&t; */
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t; * Insert the cmd into the issue queue. Note that REQUEST SENSE &n;&t; * commands are added to the head of the queue since any command will&n;&t; * clear the contingent allegiance condition that exists and the &n;&t; * sense data is only guaranteed to be valid while the condition exists.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;issue_queue
)paren
op_logical_or
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
)paren
(brace
id|LIST
c_func
(paren
id|cmd
comma
id|hostdata-&gt;issue_queue
)paren
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|hostdata-&gt;issue_queue
op_assign
id|cmd
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|tmp-&gt;host_scribble
suffix:semicolon
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
suffix:semicolon
id|LIST
c_func
(paren
id|cmd
comma
id|tmp
)paren
suffix:semicolon
id|tmp-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|cmd
suffix:semicolon
)brace
macro_line|#if (NDEBUG &amp; NDEBUG_QUEUES)
id|printk
c_func
(paren
l_string|&quot;scsi%d : command added to %s of queue&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
ques
c_cond
l_string|&quot;head&quot;
suffix:colon
l_string|&quot;tail&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Run the coroutine if it isn&squot;t already running. */
id|run_main
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : NCR5380_main (void) &n; *&n; * Purpose : NCR5380_main is a coroutine that runs as long as more work can &n; *      be done on the NCR5380 host adapters in a system.  Both &n; *      NCR5380_queue_command() and NCR5380_intr() will try to start it &n; *      in case it is not running.&n; * &n; * NOTE : NCR5380_main exits with interrupts *disabled*, the caller should &n; *  reenable them.  This prevents reentrancy and kernel stack overflow.&n; */
DECL|function|NCR5380_main
r_static
r_void
id|NCR5380_main
c_func
(paren
r_void
)paren
(brace
id|Scsi_Cmnd
op_star
id|tmp
comma
op_star
id|prev
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
suffix:semicolon
r_int
id|done
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * We run (with interrupts disabled) until we&squot;re sure that none of &n;&t; * the host adapters have anything that can be done, at which point &n;&t; * we set main_running to 0 and exit.&n;&t; *&n;&t; * Interrupts are enabled before doing various other internal &n;&t; * instructions, after we&squot;ve decided that we need to run through&n;&t; * the loop again.&n;&t; *&n;&t; * this should prevent any race conditions.&n;&t; */
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_do
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Freeze request queues */
id|done
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|instance
op_assign
id|first_instance
suffix:semicolon
id|instance
op_logical_and
id|instance-&gt;hostt
op_eq
id|the_template
suffix:semicolon
id|instance
op_assign
id|instance-&gt;next
)paren
(brace
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef USLEEP
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;connected
op_logical_and
op_logical_neg
id|hostdata-&gt;selecting
)paren
(brace
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;connected
)paren
(brace
macro_line|#endif&t;&t;&t;
macro_line|#if (NDEBUG &amp; NDEBUG_MAIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d : not connected&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t;&t; * Search through the issue_queue for a command destined&n;&t;&t;&t;&t; * for a target that&squot;s not busy.&n;&t;&t;&t;&t; */
macro_line|#if (NDEBUG &amp; NDEBUG_LISTS)
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
comma
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|tmp
op_logical_and
(paren
id|tmp
op_ne
id|prev
)paren
suffix:semicolon
id|prev
op_assign
id|tmp
comma
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
suffix:semicolon
multiline_comment|/*printk(&quot;%p  &quot;, tmp); */
r_if
c_cond
(paren
(paren
id|tmp
op_eq
id|prev
)paren
op_logical_and
id|tmp
)paren
id|printk
c_func
(paren
l_string|&quot; LOOP&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* else printk(&quot;&bslash;n&quot;); */
macro_line|#endif
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
comma
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|tmp
suffix:semicolon
id|prev
op_assign
id|tmp
comma
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_LISTS)
r_if
c_cond
(paren
id|prev
op_ne
id|tmp
)paren
id|printk
c_func
(paren
l_string|&quot;MAIN tmp=%p   target=%d   busy=%d lun=%d&bslash;n&quot;
comma
id|tmp
comma
id|tmp-&gt;target
comma
id|hostdata-&gt;busy
(braket
id|tmp-&gt;target
)braket
comma
id|tmp-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*  When we find one, remove it from the issue queue. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;busy
(braket
id|tmp-&gt;target
)braket
op_amp
(paren
l_int|1
op_lshift
id|tmp-&gt;lun
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
(brace
id|REMOVE
c_func
(paren
id|prev
comma
id|prev-&gt;host_scribble
comma
id|tmp
comma
id|tmp-&gt;host_scribble
)paren
suffix:semicolon
id|prev-&gt;host_scribble
op_assign
id|tmp-&gt;host_scribble
suffix:semicolon
)brace
r_else
(brace
id|REMOVE
c_func
(paren
op_minus
l_int|1
comma
id|hostdata-&gt;issue_queue
comma
id|tmp
comma
id|tmp-&gt;host_scribble
)paren
suffix:semicolon
id|hostdata-&gt;issue_queue
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
suffix:semicolon
)brace
id|tmp-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* reenable interrupts after finding one */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * Attempt to establish an I_T_L nexus here. &n;&t;&t;&t;&t;&t;&t; * On success, instance-&gt;hostdata-&gt;connected is set.&n;&t;&t;&t;&t;&t;&t; * On failure, we must add the command back to the&n;&t;&t;&t;&t;&t;&t; *   issue queue so we can keep trying. &n;&t;&t;&t;&t;&t;&t; */
macro_line|#if (NDEBUG &amp; (NDEBUG_MAIN | NDEBUG_QUEUES))
id|printk
c_func
(paren
l_string|&quot;scsi%d : main() : command for target %d lun %d removed from issue_queue&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|tmp-&gt;target
comma
id|tmp-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * A successful selection is defined as one that &n;&t;&t;&t;&t;&t;&t; * leaves us with the command connected and &n;&t;&t;&t;&t;&t;&t; * in hostdata-&gt;connected, OR has terminated the&n;&t;&t;&t;&t;&t;&t; * command.&n;&t;&t;&t;&t;&t;&t; *&n;&t;&t;&t;&t;&t;&t; * With successful commands, we fall through&n;&t;&t;&t;&t;&t;&t; * and see if we can do an information transfer,&n;&t;&t;&t;&t;&t;&t; * with failures we will restart.&n;&t;&t;&t;&t;&t;&t; */
macro_line|#ifdef USLEEP
id|hostdata-&gt;selecting
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* RvC: have to preset this&n;&t;&t;&t;&t;&t;&t;&t;to indicate a new command is being performed */
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|NCR5380_select
c_func
(paren
id|instance
comma
id|tmp
comma
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * REQUEST SENSE commands are issued without tagged&n;&t;&t;&t;&t;&t;&t; * queueing, even on SCSI-II devices because the &n;&t;&t;&t;&t;&t;&t; * contingent allegiance condition exists for the &n;&t;&t;&t;&t;&t;&t; * entire unit.&n;&t;&t;&t;&t;&t;&t; */
(paren
id|tmp-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
ques
c_cond
id|TAG_NONE
suffix:colon
id|TAG_NEXT
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_else
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|LIST
c_func
(paren
id|tmp
comma
id|hostdata-&gt;issue_queue
)paren
suffix:semicolon
id|tmp-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|hostdata-&gt;issue_queue
op_assign
id|tmp
suffix:semicolon
id|done
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; (NDEBUG_MAIN | NDEBUG_QUEUES))
id|printk
c_func
(paren
l_string|&quot;scsi%d : main(): select() failed, returned to issue_queue&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/* if target/lun is not busy */
)brace
multiline_comment|/* for */
)brace
multiline_comment|/* if (!hostdata-&gt;connected) */
macro_line|#ifdef USLEEP
r_if
c_cond
(paren
id|hostdata-&gt;selecting
)paren
(brace
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;selecting
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NCR5380_select
c_func
(paren
id|instance
comma
id|tmp
comma
(paren
id|tmp-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
ques
c_cond
id|TAG_NONE
suffix:colon
id|TAG_NEXT
)paren
)paren
(brace
multiline_comment|/* Ok ?? */
)brace
r_else
(brace
multiline_comment|/* RvC: device failed, so we wait a long time&n;&t;&t;&t;&t;&t;this is needed for Mustek scanners, that&n;&t;&t;&t;&t;&t;do not respond to commands immediately&n;&t;&t;&t;&t;&t;after a scan */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;scsi%d: device %d did not respond in time&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|tmp-&gt;target
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|LIST
c_func
(paren
id|tmp
comma
id|hostdata-&gt;issue_queue
)paren
suffix:semicolon
id|tmp-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|hostdata-&gt;issue_queue
op_assign
id|tmp
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|hostdata-&gt;time_expires
op_assign
id|jiffies
op_plus
id|USLEEP_WAITLONG
suffix:semicolon
id|NCR5380_set_timer
(paren
id|instance
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* if hostdata-&gt;selecting */
macro_line|#endif
r_if
c_cond
(paren
id|hostdata-&gt;connected
macro_line|#ifdef REAL_DMA
op_logical_and
op_logical_neg
id|hostdata-&gt;dmalen
macro_line|#endif
macro_line|#ifdef USLEEP
op_logical_and
(paren
op_logical_neg
id|hostdata-&gt;time_expires
op_logical_or
id|time_before_eq
c_func
(paren
id|hostdata-&gt;time_expires
comma
id|jiffies
)paren
)paren
macro_line|#endif
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_MAIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d : main() : performing information transfer&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_information_transfer
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_MAIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d : main() : done set false&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|done
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
multiline_comment|/* for instance */
)brace
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
multiline_comment|/* &t;cli();*/
id|main_running
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifndef DONT_USE_INTR
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
multiline_comment|/*&n; * Function : void NCR5380_intr (int irq)&n; * &n; * Purpose : handle interrupts, reestablishing I_T_L or I_T_L_Q nexuses&n; *      from the disconnected queue, and restarting NCR5380_main() &n; *      as required.&n; *&n; * Inputs : int irq, irq that caused this interrupt.&n; *&n; */
DECL|function|NCR5380_intr
r_static
r_void
id|NCR5380_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_int
id|done
suffix:semicolon
r_int
r_char
id|basr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_INTR)
id|printk
c_func
(paren
l_string|&quot;scsi : NCR5380 irq %d triggered&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
r_do
(brace
id|done
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|instance
op_assign
id|first_instance
suffix:semicolon
id|instance
op_logical_and
(paren
id|instance-&gt;hostt
op_eq
id|the_template
)paren
suffix:semicolon
id|instance
op_assign
id|instance-&gt;next
)paren
r_if
c_cond
(paren
id|instance-&gt;irq
op_eq
id|irq
)paren
(brace
multiline_comment|/* Look for pending interrupts */
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
id|basr
op_assign
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
suffix:semicolon
multiline_comment|/* XXX dispatch to appropriate routine if found and done=0 */
r_if
c_cond
(paren
id|basr
op_amp
id|BASR_IRQ
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_INTR)
id|NCR5380_print
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
(paren
id|SR_SEL
op_or
id|SR_IO
)paren
)paren
op_eq
(paren
id|SR_SEL
op_or
id|SR_IO
)paren
)paren
(brace
id|done
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_INTR)
id|printk
c_func
(paren
l_string|&quot;scsi%d : SEL interrupt&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_reselect
c_func
(paren
id|instance
)paren
suffix:semicolon
(paren
r_void
)paren
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|basr
op_amp
id|BASR_PARITY_ERROR
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_INTR)
id|printk
c_func
(paren
l_string|&quot;scsi%d : PARITY interrupt&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
(paren
r_void
)paren
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_RST
)paren
op_eq
id|SR_RST
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_INTR)
id|printk
c_func
(paren
l_string|&quot;scsi%d : RESET interrupt&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
(paren
r_void
)paren
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  &n; * XXX the rest of the interrupt conditions should *only* occur during a &n; * DMA transfer, which I haven&squot;t gotten around to fixing yet.&n; */
macro_line|#if defined(REAL_DMA)
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * We should only get PHASE MISMATCH and EOP interrupts&n;&t;&t;&t;&t;&t;&t; * if we have DMA enabled, so do a sanity check based on&n;&t;&t;&t;&t;&t;&t; * the current setting of the MODE register.&n;&t;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|NCR5380_read
c_func
(paren
id|MODE_REG
)paren
op_amp
id|MR_DMA
)paren
op_logical_and
(paren
(paren
id|basr
op_amp
id|BASR_END_DMA_TRANSFER
)paren
op_logical_or
op_logical_neg
(paren
id|basr
op_amp
id|BASR_PHASE_MATCH
)paren
)paren
)paren
(brace
r_int
id|transfered
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;connected
)paren
id|panic
c_func
(paren
l_string|&quot;scsi%d : received end of DMA interrupt with no connected cmd&bslash;n&quot;
comma
id|instance-&gt;hostno
)paren
suffix:semicolon
id|transfered
op_assign
(paren
id|hostdata-&gt;dmalen
op_minus
id|NCR5380_dma_residual
c_func
(paren
id|instance
)paren
)paren
suffix:semicolon
id|hostdata-&gt;connected-&gt;SCp.this_residual
op_sub_assign
id|transferred
suffix:semicolon
id|hostdata-&gt;connected-&gt;SCp.ptr
op_add_assign
id|transferred
suffix:semicolon
id|hostdata-&gt;dmalen
op_assign
l_int|0
suffix:semicolon
(paren
r_void
)paren
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
macro_line|#if NCR_TIMEOUT
(brace
r_int
r_int
id|timeout
op_assign
id|jiffies
op_plus
id|NCR_TIMEOUT
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_ACK
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d: timeout at NCR5380.c:%d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|__LINE__
)paren
suffix:semicolon
)brace
macro_line|#else&t;&t;&t;&t;/* NCR_TIMEOUT */
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_ACK
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
)brace
macro_line|#else
macro_line|#if (NDEBUG &amp; NDEBUG_INTR)
id|printk
c_func
(paren
l_string|&quot;scsi : unknown interrupt, BASR 0x%X, MR 0x%X, SR 0x%x&bslash;n&quot;
comma
id|basr
comma
id|NCR5380_read
c_func
(paren
id|MODE_REG
)paren
comma
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
suffix:semicolon
macro_line|#endif
(paren
r_void
)paren
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/* if BASR_IRQ */
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
id|run_main
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* if (instance-&gt;irq == irq) */
)brace
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
suffix:semicolon
)brace
DECL|function|do_NCR5380_intr
r_static
r_void
id|do_NCR5380_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|NCR5380_intr
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef NCR5380_STATS
DECL|function|collect_stats
r_static
r_void
id|collect_stats
c_func
(paren
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
macro_line|#ifdef NCR5380_STAT_LIMIT
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
OG
id|NCR5380_STAT_LIMIT
)paren
macro_line|#endif
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|WRITE
suffix:colon
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
id|hostdata-&gt;time_write
(braket
id|cmd-&gt;target
)braket
op_add_assign
(paren
id|jiffies
op_minus
id|hostdata-&gt;timebase
)paren
suffix:semicolon
multiline_comment|/*hostdata-&gt;bytes_write[cmd-&gt;target] += cmd-&gt;request_bufflen; */
id|hostdata-&gt;pendingw
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ
suffix:colon
r_case
id|READ_6
suffix:colon
r_case
id|READ_10
suffix:colon
id|hostdata-&gt;time_read
(braket
id|cmd-&gt;target
)braket
op_add_assign
(paren
id|jiffies
op_minus
id|hostdata-&gt;timebase
)paren
suffix:semicolon
multiline_comment|/*hostdata-&gt;bytes_read[cmd-&gt;target] += cmd-&gt;request_bufflen; */
id|hostdata-&gt;pendingr
op_decrement
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* &n; * Function : int NCR5380_select (struct Scsi_Host *instance, Scsi_Cmnd *cmd, &n; *      int tag);&n; *&n; * Purpose : establishes I_T_L or I_T_L_Q nexus for new or existing command,&n; *      including ARBITRATION, SELECTION, and initial message out for &n; *      IDENTIFY and queue messages. &n; *&n; * Inputs : instance - instantiation of the 5380 driver on which this &n; *      target lives, cmd - SCSI command to execute, tag - set to TAG_NEXT for &n; *      new tag, TAG_NONE for untagged queueing, otherwise set to the tag for &n; *      the command that is presently connected.&n; * &n; * Returns : -1 if selection could not execute for some reason,&n; *      0 if selection succeeded or failed because the target &n; *      did not respond.&n; *&n; * Side effects : &n; *      If bus busy, arbitration failed, etc, NCR5380_select() will exit &n; *              with registers as they should have been on entry - ie&n; *              SELECT_ENABLE will be set appropriately, the NCR5380&n; *              will cease to drive any SCSI bus signals.&n; *&n; *      If successful : I_T_L or I_T_L_Q nexus will be established, &n; *              instance-&gt;connected will be set to cmd.  &n; *              SELECT interrupt will be disabled.&n; *&n; *      If failed (no target) : cmd-&gt;scsi_done() will be called, and the &n; *              cmd-&gt;result host byte set to DID_BAD_TARGET.&n; */
DECL|function|NCR5380_select
r_static
r_int
id|NCR5380_select
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|tag
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
r_int
r_char
id|tmp
(braket
l_int|3
)braket
comma
id|phase
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef USLEEP
r_int
r_char
id|value
suffix:semicolon
macro_line|#endif
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#ifdef USLEEP
r_if
c_cond
(paren
id|hostdata-&gt;selecting
)paren
(brace
r_goto
id|part2
suffix:semicolon
multiline_comment|/* RvC: sorry prof. Dijkstra, but it keeps the&n;&t;&t;&t;&t;   rest of the code nearly the same */
)brace
macro_line|#endif
id|hostdata-&gt;restart_select
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined (NDEBUG) &amp;&amp; (NDEBUG &amp; NDEBUG_ARBITRATION)
id|NCR5380_print
c_func
(paren
id|instance
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : starting arbitration, id = %d&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|instance-&gt;this_id
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Set the phase bits to 0, otherwise the NCR5380 won&squot;t drive the &n;&t; * data bus during SELECTION.&n;&t; */
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Start arbitration.&n;&t; */
id|NCR5380_write
c_func
(paren
id|OUTPUT_DATA_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_ARBITRATE
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Wait for arbitration logic to complete */
macro_line|#if NCR_TIMEOUT
(brace
r_int
r_int
id|timeout
op_assign
id|jiffies
op_plus
l_int|2
op_star
id|NCR_TIMEOUT
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|INITIATOR_COMMAND_REG
)paren
op_amp
id|ICR_ARBITRATION_PROGRESS
)paren
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: arbitration timeout at %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#else&t;&t;&t;&t;/* NCR_TIMEOUT */
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|INITIATOR_COMMAND_REG
)paren
op_amp
id|ICR_ARBITRATION_PROGRESS
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if (NDEBUG &amp; NDEBUG_ARBITRATION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : arbitration complete&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
multiline_comment|/* Avoid GCC 2.4.5 asm needs to many reloads error */
id|__asm__
c_func
(paren
l_string|&quot;nop&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t; * The arbitration delay is 2.2us, but this is a minimum and there is &n;&t; * no maximum so we can safely sleep for ceil(2.2) usecs to accommodate&n;&t; * the integral nature of udelay().&n;&t; *&n;&t; */
id|udelay
c_func
(paren
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Check for lost arbitration */
r_if
c_cond
(paren
(paren
id|NCR5380_read
c_func
(paren
id|INITIATOR_COMMAND_REG
)paren
op_amp
id|ICR_ARBITRATION_LOST
)paren
op_logical_or
(paren
id|NCR5380_read
c_func
(paren
id|CURRENT_SCSI_DATA_REG
)paren
op_amp
id|hostdata-&gt;id_higher_mask
)paren
op_logical_or
(paren
id|NCR5380_read
c_func
(paren
id|INITIATOR_COMMAND_REG
)paren
op_amp
id|ICR_ARBITRATION_LOST
)paren
)paren
(brace
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_ARBITRATION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : lost arbitration, deasserting MR_ARBITRATE&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_SEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;flags
op_amp
id|FLAG_DTC3181E
)paren
op_logical_and
multiline_comment|/* RvC: DTC3181E has some trouble with this&n;&t;&t; *&t;so we simply removed it. Seems to work with&n;&t;&t; *&t;only Mustek scanner attached&n;&t;&t; */
(paren
id|NCR5380_read
c_func
(paren
id|INITIATOR_COMMAND_REG
)paren
op_amp
id|ICR_ARBITRATION_LOST
)paren
)paren
(brace
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_ARBITRATION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : lost arbitration, deasserting ICR_ASSERT_SEL&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Again, bus clear + bus settle time is 1.2us, however, this is &n;&t; * a minimum so we&squot;ll udelay ceil(1.2)&n;&t; */
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_ARBITRATION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : won arbitration&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t; * Now that we have won arbitration, start Selection process, asserting &n;&t; * the host and target ID&squot;s on the SCSI bus.&n;&t; */
id|NCR5380_write
c_func
(paren
id|OUTPUT_DATA_REG
comma
(paren
id|hostdata-&gt;id_mask
op_or
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Raise ATN while SEL is true before BSY goes false from arbitration,&n;&t; * since this is the only way to guarantee that we&squot;ll get a MESSAGE OUT&n;&t; * phase immediately after selection.&n;&t; */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
(paren
id|ICR_BASE
op_or
id|ICR_ASSERT_BSY
op_or
id|ICR_ASSERT_DATA
op_or
id|ICR_ASSERT_ATN
op_or
id|ICR_ASSERT_SEL
)paren
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Reselect interrupts must be turned off prior to the dropping of BSY,&n;&t; * otherwise we will trigger an interrupt.&n;&t; */
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The initiator shall then wait at least two deskew delays and release &n;&t; * the BSY signal.&n;&t; */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* wingel -- wait two bus deskew delay &gt;2*45ns */
multiline_comment|/* Reset BSY */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
(paren
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
op_or
id|ICR_ASSERT_ATN
op_or
id|ICR_ASSERT_SEL
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Something weird happens when we cease to drive BSY - looks&n;&t; * like the board/chip is letting us do another read before the &n;&t; * appropriate propagation delay has expired, and we&squot;re confusing&n;&t; * a BSY signal from ourselves as the target&squot;s response to SELECTION.&n;&t; *&n;&t; * A small delay (the &squot;C++&squot; frontend breaks the pipeline with an&n;&t; * unnecessary jump, making it work on my 386-33/Trantor T128, the&n;&t; * tighter &squot;C&squot; code breaks and requires this) solves the problem - &n;&t; * the 1 us delay is arbitrary, and only used because this delay will &n;&t; * be the same on other platforms and since it works here, it should &n;&t; * work there.&n;&t; *&n;&t; * wingel suggests that this could be due to failing to wait&n;&t; * one deskew delay.&n;&t; */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_SELECTION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : selecting target %d&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;target
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t; * The SCSI specification calls for a 250 ms timeout for the actual &n;&t; * selection.&n;&t; */
id|timeout
op_assign
id|jiffies
op_plus
(paren
l_int|250
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * XXX very interesting - we&squot;re seeing a bounce where the BSY we &n;&t; * asserted is being reflected / still asserted (propagation delay?)&n;&t; * and it&squot;s detecting as true.  Sigh.&n;&t; */
macro_line|#ifdef USLEEP
id|hostdata-&gt;select_time
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we count the clock ticks at which we polled */
id|hostdata-&gt;selecting
op_assign
id|cmd
suffix:semicolon
id|part2
suffix:colon
multiline_comment|/* RvC: here we enter after a sleeping period, or immediately after&n;&t;&t;execution of part 1&n;&t;&t;we poll only once ech clock tick */
id|value
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
(paren
id|SR_BSY
op_or
id|SR_IO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_and
(paren
id|hostdata-&gt;select_time
OL
l_int|25
)paren
)paren
(brace
multiline_comment|/* RvC: we still must wait for a device response */
id|hostdata-&gt;select_time
op_increment
suffix:semicolon
multiline_comment|/* after 25 ticks the device has failed */
id|hostdata-&gt;time_expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|NCR5380_set_timer
c_func
(paren
id|instance
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* RvC: we return here with hostdata-&gt;selecting set,&n;&t;&t;&t;&t;   to go to sleep */
)brace
id|hostdata-&gt;selecting
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear this pointer, because we passed the&n;&t;&t;&t;&t;waiting period */
macro_line|#else
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
op_logical_and
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
(paren
id|SR_BSY
op_or
id|SR_IO
)paren
)paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
(paren
id|SR_SEL
op_or
id|SR_IO
)paren
)paren
op_eq
(paren
id|SR_SEL
op_or
id|SR_IO
)paren
)paren
(brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|NCR5380_reselect
c_func
(paren
id|instance
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : reselection after won arbitration?&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * No less than two deskew delays after the initiator detects the &n;&t; * BSY signal is true, it shall release the SEL signal and may &n;&t; * change the DATA BUS.                                     -wingel&n;&t; */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_BSY
)paren
)paren
(brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;targets_present
op_amp
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : weirdness&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;restart_select
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;trestart select&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_SELECTION)
id|NCR5380_print
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|cmd-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
macro_line|#ifdef NCR5380_STATS
id|collect_stats
c_func
(paren
id|hostdata
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_SELECTION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : target did not respond within 250ms&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|hostdata-&gt;targets_present
op_or_assign
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since we followed the SCSI spec, and raised ATN while SEL &n;&t; * was true but before BSY was false during selection, the information&n;&t; * transfer phase should be a MESSAGE OUT phase so that we can send the&n;&t; * IDENTIFY message.&n;&t; * &n;&t; * If SCSI-II tagged queuing is enabled, we also send a SIMPLE_QUEUE_TAG&n;&t; * message (2 bytes) with a tag ID that we increment with every command&n;&t; * until it wraps back to 0.&n;&t; *&n;&t; * XXX - it turns out that there are some broken SCSI-II devices,&n;&t; *       which claim to support tagged queuing but fail when more than&n;&t; *       some number of commands are issued at once.&n;&t; */
multiline_comment|/* Wait for start of REQ/ACK handshake */
macro_line|#ifdef NCR_TIMEOUT
(brace
r_int
r_int
id|timeout
op_assign
id|jiffies
op_plus
id|NCR_TIMEOUT
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: timeout at NCR5380.c:%d&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|__LINE__
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#else&t;&t;&t;&t;/* NCR_TIMEOUT */
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* def NCR_TIMEOUT */
macro_line|#if (NDEBUG &amp; NDEBUG_SELECTION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : target %d selected, going into MESSAGE OUT phase.&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;target
)paren
suffix:semicolon
macro_line|#endif
id|tmp
(braket
l_int|0
)braket
op_assign
id|IDENTIFY
c_func
(paren
(paren
(paren
id|instance-&gt;irq
op_eq
id|IRQ_NONE
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#ifdef SCSI2
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;tagged_queue
op_logical_and
(paren
id|tag
op_ne
id|TAG_NONE
)paren
)paren
(brace
id|tmp
(braket
l_int|1
)braket
op_assign
id|SIMPLE_QUEUE_TAG
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|TAG_NEXT
)paren
(brace
multiline_comment|/* 0 is TAG_NONE, used to imply no tag for this command */
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;current_tag
op_eq
l_int|0
)paren
id|cmd-&gt;device-&gt;current_tag
op_assign
l_int|1
suffix:semicolon
id|cmd-&gt;tag
op_assign
id|cmd-&gt;device-&gt;current_tag
suffix:semicolon
id|cmd-&gt;device-&gt;current_tag
op_increment
suffix:semicolon
)brace
r_else
id|cmd-&gt;tag
op_assign
(paren
r_int
r_char
)paren
id|tag
suffix:semicolon
id|tmp
(braket
l_int|2
)braket
op_assign
id|cmd-&gt;tag
suffix:semicolon
id|hostdata-&gt;last_message
op_assign
id|SIMPLE_QUEUE_TAG
suffix:semicolon
id|len
op_assign
l_int|3
suffix:semicolon
)brace
r_else
macro_line|#endif&t;&t;&t;&t;/* def SCSI2 */
(brace
id|len
op_assign
l_int|1
suffix:semicolon
id|cmd-&gt;tag
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Send message(s) */
id|data
op_assign
id|tmp
suffix:semicolon
id|phase
op_assign
id|PHASE_MSGOUT
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_SELECTION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : nexus established.&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* XXX need to handle errors here */
id|hostdata-&gt;connected
op_assign
id|cmd
suffix:semicolon
macro_line|#ifdef SCSI2
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;device-&gt;tagged_queue
)paren
macro_line|#endif
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_or_assign
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|initialize_SCp
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : int NCR5380_transfer_pio (struct Scsi_Host *instance, &n; *      unsigned char *phase, int *count, unsigned char **data)&n; *&n; * Purpose : transfers data in given phase using polled I/O&n; *&n; * Inputs : instance - instance of driver, *phase - pointer to &n; *      what phase is expected, *count - pointer to number of &n; *      bytes to transfer, **data - pointer to data pointer.&n; * &n; * Returns : -1 when different phase is entered without transferring&n; *      maximum number of bytes, 0 if all bytes or transfered or exit&n; *      is in same phase.&n; *&n; *      Also, *phase, *count, *data are modified in place.&n; *&n; * XXX Note : handling for bus free may be useful.&n; */
multiline_comment|/*&n; * Note : this code is not as quick as it could be, however it &n; * IS 100% reliable, and for the actual data transfer where speed&n; * counts, we will always do a pseudo DMA or DMA transfer.&n; */
DECL|function|NCR5380_transfer_pio
r_static
r_int
id|NCR5380_transfer_pio
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
r_char
op_star
id|phase
comma
r_int
op_star
id|count
comma
r_int
r_char
op_star
op_star
id|data
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_register
r_int
r_char
id|p
op_assign
op_star
id|phase
comma
id|tmp
suffix:semicolon
r_register
r_int
id|c
op_assign
op_star
id|count
suffix:semicolon
r_register
r_int
r_char
op_star
id|d
op_assign
op_star
id|data
suffix:semicolon
macro_line|#ifdef USLEEP
multiline_comment|/*&n;&t; *&t;RvC: some administrative data to process polling time&n;&t; */
r_int
id|break_allowed
op_assign
l_int|0
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
macro_line|#endif
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_PIO)
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_amp
id|SR_IO
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : pio write %d bytes&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|c
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;scsi%d : pio read %d bytes&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|c
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t; * The NCR5380 chip will only drive the SCSI bus when the &n;&t; * phase specified in the appropriate bits of the TARGET COMMAND&n;&t; * REGISTER match the STATUS REGISTER&n;&t; */
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
id|PHASE_SR_TO_TCR
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
macro_line|#ifdef USLEEP
multiline_comment|/* RvC: don&squot;t know if this is necessary, but other SCSI I/O is short&n;&t; *&t;so breaks are not necessary there&n;&t; */
r_if
c_cond
(paren
(paren
id|p
op_eq
id|PHASE_DATAIN
)paren
op_logical_or
(paren
id|p
op_eq
id|PHASE_DATAOUT
)paren
)paren
(brace
id|break_allowed
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_do
(brace
multiline_comment|/* &n;&t;&t; * Wait for assertion of REQ, after which the phase bits will be &n;&t;&t; * valid &n;&t;&t; */
macro_line|#ifdef USLEEP
multiline_comment|/* RvC: we simply poll once, after that we stop temporarily&n;&t;&t; *&t;and let the device buffer fill up&n;&t;&t; *&t;if breaking is not allowed, we keep polling as long as needed&n;&t;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|tmp
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
op_amp
id|SR_REQ
)paren
op_logical_and
op_logical_neg
id|break_allowed
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp
op_amp
id|SR_REQ
)paren
)paren
(brace
multiline_comment|/* timeout condition */
id|hostdata-&gt;time_expires
op_assign
id|jiffies
op_plus
id|USLEEP_SLEEP
suffix:semicolon
id|NCR5380_set_timer
(paren
id|instance
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#else
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|tmp
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
op_amp
id|SR_REQ
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if (NDEBUG &amp; NDEBUG_HANDSHAKE)
id|printk
c_func
(paren
l_string|&quot;scsi%d : REQ detected&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check for phase mismatch */
r_if
c_cond
(paren
(paren
id|tmp
op_amp
id|PHASE_MASK
)paren
op_ne
id|p
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_PIO)
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase mismatch&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|NCR5380_print_phase
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
multiline_comment|/* Do actual transfer from SCSI bus to / from memory */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_amp
id|SR_IO
)paren
)paren
id|NCR5380_write
c_func
(paren
id|OUTPUT_DATA_REG
comma
op_star
id|d
)paren
suffix:semicolon
r_else
op_star
id|d
op_assign
id|NCR5380_read
c_func
(paren
id|CURRENT_SCSI_DATA_REG
)paren
suffix:semicolon
op_increment
id|d
suffix:semicolon
multiline_comment|/* &n;&t;&t; * The SCSI standard suggests that in MSGOUT phase, the initiator&n;&t;&t; * should drop ATN on the last byte of the message phase&n;&t;&t; * after REQ has been asserted for the handshake but before&n;&t;&t; * the initiator raises ACK.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_amp
id|SR_IO
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|p
op_amp
id|SR_MSG
)paren
op_logical_and
id|c
OG
l_int|1
)paren
)paren
(brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_PIO)
id|NCR5380_print
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
op_or
id|ICR_ASSERT_ACK
)paren
suffix:semicolon
)brace
r_else
(brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_PIO)
id|NCR5380_print
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
op_or
id|ICR_ASSERT_ATN
op_or
id|ICR_ASSERT_ACK
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_PIO)
id|NCR5380_print
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ACK
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_HANDSHAKE)
id|printk
c_func
(paren
l_string|&quot;scsi%d : req false, handshake complete&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * We have several special cases to consider during REQ/ACK handshaking : &n; * 1.  We were in MSGOUT phase, and we are on the last byte of the &n; *      message.  ATN must be dropped as ACK is dropped.&n; *&n; * 2.  We are in a MSGIN phase, and we are on the last byte of the  &n; *      message.  We must exit with ACK asserted, so that the calling&n; *      code may raise ATN before dropping ACK to reject the message.&n; *&n; * 3.  ACK and ATN are clear and the target may proceed as normal.&n; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_eq
id|PHASE_MSGIN
op_logical_and
id|c
op_eq
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
id|PHASE_MSGOUT
op_logical_and
id|c
OG
l_int|1
)paren
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
r_else
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_decrement
id|c
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_PIO)
id|printk
c_func
(paren
l_string|&quot;scsi%d : residual %d&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|c
)paren
suffix:semicolon
macro_line|#endif
op_star
id|count
op_assign
id|c
suffix:semicolon
op_star
id|data
op_assign
id|d
suffix:semicolon
id|tmp
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_amp
id|SR_REQ
)paren
op_star
id|phase
op_assign
id|tmp
op_amp
id|PHASE_MASK
suffix:semicolon
r_else
op_star
id|phase
op_assign
id|PHASE_UNKNOWN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
op_logical_or
(paren
op_star
id|phase
op_eq
id|p
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|do_reset
r_static
r_void
id|do_reset
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|host
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
id|PHASE_SR_TO_TCR
c_func
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|PHASE_MASK
)paren
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_RST
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&n;&t;&t;&t;&t; * Function : do_abort (Scsi_Host *host)&n;&t;&t;&t;&t; * &n;&t;&t;&t;&t; * Purpose : abort the currently established nexus.  Should only be &n;&t;&t;&t;&t; *      called from a routine which can drop into a &n;&t;&t;&t;&t; * &n;&t;&t;&t;&t; * Returns : 0 on success, -1 on failure.&n;&t;&t;&t;&t; */
DECL|function|do_abort
r_static
r_int
id|do_abort
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_int
r_char
id|tmp
comma
op_star
id|msgptr
comma
id|phase
suffix:semicolon
r_int
id|len
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* Request message out phase */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Wait for the target to indicate a valid phase by asserting &n;&t; * REQ.  Once this happens, we&squot;ll have either a MSGOUT phase &n;&t; * and can immediately send the ABORT message, or we&squot;ll have some &n;&t; * other phase and will have to source/sink data.&n;&t; * &n;&t; * We really don&squot;t care what value was on the bus or what value&n;&t; * the target sees, so we just handshake.&n;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
id|tmp
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
op_amp
id|SR_REQ
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
id|PHASE_SR_TO_TCR
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
id|PHASE_MASK
)paren
op_ne
id|PHASE_MSGOUT
)paren
(brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
op_or
id|ICR_ASSERT_ACK
)paren
suffix:semicolon
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
)brace
id|tmp
op_assign
id|ABORT
suffix:semicolon
id|msgptr
op_assign
op_amp
id|tmp
suffix:semicolon
id|len
op_assign
l_int|1
suffix:semicolon
id|phase
op_assign
id|PHASE_MSGOUT
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|host
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|msgptr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we got here, and the command completed successfully,&n;&t; * we&squot;re about to go into bus free state.&n;&t; */
r_return
id|len
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#if defined(REAL_DMA) || defined(PSEUDO_DMA) || defined (REAL_DMA_POLL)
multiline_comment|/* &n; * Function : int NCR5380_transfer_dma (struct Scsi_Host *instance, &n; *      unsigned char *phase, int *count, unsigned char **data)&n; *&n; * Purpose : transfers data in given phase using either real&n; *      or pseudo DMA.&n; *&n; * Inputs : instance - instance of driver, *phase - pointer to &n; *      what phase is expected, *count - pointer to number of &n; *      bytes to transfer, **data - pointer to data pointer.&n; * &n; * Returns : -1 when different phase is entered without transferring&n; *      maximum number of bytes, 0 if all bytes or transfered or exit&n; *      is in same phase.&n; *&n; *      Also, *phase, *count, *data are modified in place.&n; *&n; */
DECL|function|NCR5380_transfer_dma
r_static
r_int
id|NCR5380_transfer_dma
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
r_char
op_star
id|phase
comma
r_int
op_star
id|count
comma
r_int
r_char
op_star
op_star
id|data
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_register
r_int
id|c
op_assign
op_star
id|count
suffix:semicolon
r_register
r_int
r_char
id|p
op_assign
op_star
id|phase
suffix:semicolon
r_register
r_int
r_char
op_star
id|d
op_assign
op_star
id|data
suffix:semicolon
r_int
r_char
id|tmp
suffix:semicolon
macro_line|#if defined(PSEUDO_DMA) &amp;&amp; !defined(UNSAFE)
r_int
r_int
id|flags
suffix:semicolon
macro_line|#endif
r_int
id|foo
suffix:semicolon
macro_line|#if defined(REAL_DMA_POLL)
r_int
id|cnt
comma
id|toPIO
suffix:semicolon
r_int
r_char
id|saved_data
op_assign
l_int|0
comma
id|overrun
op_assign
l_int|0
comma
id|residue
suffix:semicolon
macro_line|#endif
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_assign
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|PHASE_MASK
)paren
)paren
op_ne
id|p
)paren
(brace
op_star
id|phase
op_assign
id|tmp
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#if defined(REAL_DMA) || defined(REAL_DMA_POLL)
macro_line|#ifdef READ_OVERRUNS if (p &amp; SR_IO) { c -= 2;
)brace
macro_line|#endif
macro_line|#if (NDEBUG &amp; NDEBUG_DMA)
id|printk
c_func
(paren
l_string|&quot;scsi%d : initializing DMA channel %d for %s, %d bytes %s %0x&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|instance-&gt;dma_channel
comma
(paren
id|p
op_amp
id|SR_IO
)paren
ques
c_cond
l_string|&quot;reading&quot;
suffix:colon
l_string|&quot;writing&quot;
comma
id|c
comma
(paren
id|p
op_amp
id|SR_IO
)paren
ques
c_cond
l_string|&quot;to&quot;
suffix:colon
l_string|&quot;from&quot;
comma
(paren
r_int
)paren
id|d
)paren
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;dma_len
op_assign
(paren
id|p
op_amp
id|SR_IO
)paren
ques
c_cond
id|NCR5380_dma_read_setup
c_func
(paren
id|instance
comma
id|d
comma
id|c
)paren
suffix:colon
id|NCR5380_dma_write_setup
c_func
(paren
id|instance
comma
id|d
comma
id|c
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
id|PHASE_SR_TO_TCR
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
macro_line|#ifdef REAL_DMA
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
op_or
id|MR_DMA_MODE
op_or
id|MR_ENABLE_EOP_INTR
op_or
id|MR_MONITOR_BSY
)paren
suffix:semicolon
macro_line|#elif defined(REAL_DMA_POLL)
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
op_or
id|MR_DMA_MODE
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/*&n;&t; * Note : on my sample board, watch-dog timeouts occurred when interrupts&n;&t; * were not disabled for the duration of a single DMA transfer, from &n;&t; * before the setting of DMA mode to after transfer of the last byte.&n;&t; */
macro_line|#if defined(PSEUDO_DMA) &amp;&amp; !defined(UNSAFE)
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* KLL May need eop and parity in 53c400 */
r_if
c_cond
(paren
id|hostdata-&gt;flags
op_amp
id|FLAG_NCR53C400
)paren
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
op_or
id|MR_DMA_MODE
op_or
id|MR_ENABLE_PAR_CHECK
op_or
id|MR_ENABLE_PAR_INTR
op_or
id|MR_ENABLE_EOP_INTR
op_or
id|MR_DMA_MODE
op_or
id|MR_MONITOR_BSY
)paren
suffix:semicolon
r_else
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
op_or
id|MR_DMA_MODE
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* def REAL_DMA */
macro_line|#if (NDEBUG &amp; NDEBUG_DMA) &amp; 0
id|printk
c_func
(paren
l_string|&quot;scsi%d : mode reg = 0x%X&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|NCR5380_read
c_func
(paren
id|MODE_REG
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n; * FOO stuff. For some UNAPPARENT reason, I&squot;m getting &n; * watchdog timers fired on bootup for NO APPARENT REASON, meaning it&squot;s&n; * probably a timing problem.&n; *&n; * Since this is the only place I have back-to-back writes, perhaps this &n; * is the problem?&n; */
r_if
c_cond
(paren
id|p
op_amp
id|SR_IO
)paren
(brace
macro_line|#ifndef FOO
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|START_DMA_INITIATOR_RECEIVE_REG
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifndef FOO
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
)paren
suffix:semicolon
macro_line|#ifndef FOO
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|START_DMA_SEND_REG
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifndef FOO
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if defined(REAL_DMA_POLL)
r_do
(brace
id|tmp
op_assign
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|tmp
op_amp
id|BASR_PHASE_MATCH
)paren
op_logical_and
op_logical_neg
(paren
id|tmp
op_amp
(paren
id|BASR_BUSY_ERROR
op_or
id|BASR_END_DMA_TRANSFER
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;   At this point, either we&squot;ve completed DMA, or we have a phase mismatch,&n;   or we&squot;ve unexpectedly lost BUSY (which is a real error).&n;&n;   For write DMAs, we want to wait until the last byte has been&n;   transferred out over the bus before we turn off DMA mode.  Alas, there&n;   seems to be no terribly good way of doing this on a 5380 under all&n;   conditions.  For non-scatter-gather operations, we can wait until REQ&n;   and ACK both go false, or until a phase mismatch occurs.  Gather-writes&n;   are nastier, since the device will be expecting more data than we&n;   are prepared to send it, and REQ will remain asserted.  On a 53C8[01] we&n;   could test LAST BIT SENT to assure transfer (I imagine this is precisely&n;   why this signal was added to the newer chips) but on the older 538[01]&n;   this signal does not exist.  The workaround for this lack is a watchdog;&n;   we bail out of the wait-loop after a modest amount of wait-time if&n;   the usual exit conditions are not met.  Not a terribly clean or&n;   correct solution :-%&n;&n;   Reads are equally tricky due to a nasty characteristic of the NCR5380.&n;   If the chip is in DMA mode for an READ, it will respond to a target&squot;s&n;   REQ by latching the SCSI data into the INPUT DATA register and asserting&n;   ACK, even if it has _already_ been notified by the DMA controller that&n;   the current DMA transfer has completed!  If the NCR5380 is then taken&n;   out of DMA mode, this already-acknowledged byte is lost.&n;&n;   This is not a problem for &quot;one DMA transfer per command&quot; reads, because&n;   the situation will never arise... either all of the data is DMA&squot;ed&n;   properly, or the target switches to MESSAGE IN phase to signal a&n;   disconnection (either operation bringing the DMA to a clean halt).&n;   However, in order to handle scatter-reads, we must work around the&n;   problem.  The chosen fix is to DMA N-2 bytes, then check for the&n;   condition before taking the NCR5380 out of DMA mode.  One or two extra&n;   bytes are transferred via PIO as necessary to fill out the original&n;   request.&n; */
r_if
c_cond
(paren
id|p
op_amp
id|SR_IO
)paren
(brace
macro_line|#ifdef READ_OVERRUNS
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
(paren
id|BASR_PHASE_MATCH
op_or
id|BASR_ACK
)paren
)paren
op_eq
(paren
id|BASR_PHASE_MATCH
op_or
id|BASR_ACK
)paren
)paren
)paren
(brace
id|saved_data
op_assign
id|NCR5380_read
c_func
(paren
id|INPUT_DATA_REGISTER
)paren
suffix:semicolon
id|overrun
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
(brace
r_int
id|limit
op_assign
l_int|100
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|tmp
op_assign
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
)paren
op_amp
id|BASR_ACK
)paren
op_logical_or
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp
op_amp
id|BASR_PHASE_MATCH
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|limit
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
macro_line|#if (NDEBUG &amp; NDEBUG_DMA)
id|printk
c_func
(paren
l_string|&quot;scsi%d : polled DMA transfer complete, basr 0x%X, sr 0x%X&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|tmp
comma
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|residue
op_assign
id|NCR5380_dma_residual
c_func
(paren
id|instance
)paren
suffix:semicolon
id|c
op_sub_assign
id|residue
suffix:semicolon
op_star
id|count
op_sub_assign
id|c
suffix:semicolon
op_star
id|data
op_add_assign
id|c
suffix:semicolon
op_star
id|phase
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|PHASE_MASK
suffix:semicolon
macro_line|#ifdef READ_OVERRUNS
r_if
c_cond
(paren
op_star
id|phase
op_eq
id|p
op_logical_and
(paren
id|p
op_amp
id|SR_IO
)paren
op_logical_and
id|residue
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|overrun
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_DMA)
id|printk
c_func
(paren
l_string|&quot;Got an input overrun, using saved byte&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
op_star
op_star
id|data
op_assign
id|saved_data
suffix:semicolon
op_star
id|data
op_add_assign
l_int|1
suffix:semicolon
op_star
id|count
op_sub_assign
l_int|1
suffix:semicolon
id|cnt
op_assign
id|toPIO
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;No overrun??&bslash;n&quot;
)paren
suffix:semicolon
id|cnt
op_assign
id|toPIO
op_assign
l_int|2
suffix:semicolon
)brace
macro_line|#if (NDEBUG &amp; NDEBUG_DMA)
id|printk
c_func
(paren
l_string|&quot;Doing %d-byte PIO to 0x%X&bslash;n&quot;
comma
id|cnt
comma
op_star
id|data
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
id|phase
comma
op_amp
id|cnt
comma
id|data
)paren
suffix:semicolon
op_star
id|count
op_sub_assign
id|toPIO
op_minus
id|cnt
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if (NDEBUG &amp; NDEBUG_DMA)
id|printk
c_func
(paren
l_string|&quot;Return with data ptr = 0x%X, count %d, last 0x%X, next 0x%X&bslash;n&quot;
comma
op_star
id|data
comma
op_star
id|count
comma
op_star
(paren
op_star
id|data
op_plus
op_star
id|count
op_minus
l_int|1
)paren
comma
op_star
(paren
op_star
id|data
op_plus
op_star
id|count
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
macro_line|#elif defined(REAL_DMA)
r_return
l_int|0
suffix:semicolon
macro_line|#else&t;&t;&t;&t;/* defined(REAL_DMA_POLL) */
r_if
c_cond
(paren
id|p
op_amp
id|SR_IO
)paren
(brace
macro_line|#ifdef DMA_WORKS_RIGHT
id|foo
op_assign
id|NCR5380_pread
c_func
(paren
id|instance
comma
id|d
comma
id|c
)paren
suffix:semicolon
macro_line|#else
r_int
id|diff
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;flags
op_amp
id|FLAG_NCR53C400
)paren
(brace
id|diff
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|foo
op_assign
id|NCR5380_pread
c_func
(paren
id|instance
comma
id|d
comma
id|c
op_minus
id|diff
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * We can&squot;t disable DMA mode after successfully transferring &n;&t;&t; * what we plan to be the last byte, since that would open up&n;&t;&t; * a race condition where if the target asserted REQ before &n;&t;&t; * we got the DMA mode reset, the NCR5380 would have latched&n;&t;&t; * an additional byte into the INPUT DATA register and we&squot;d&n;&t;&t; * have dropped it.&n;&t;&t; * &n;&t;&t; * The workaround was to transfer one fewer bytes than we &n;&t;&t; * intended to with the pseudo-DMA read function, wait for &n;&t;&t; * the chip to latch the last byte, read it, and then disable&n;&t;&t; * pseudo-DMA mode.&n;&t;&t; * &n;&t;&t; * After REQ is asserted, the NCR5380 asserts DRQ and ACK.&n;&t;&t; * REQ is deasserted when ACK is asserted, and not reasserted&n;&t;&t; * until ACK goes false.  Since the NCR5380 won&squot;t lower ACK&n;&t;&t; * until DACK is asserted, which won&squot;t happen unless we twiddle&n;&t;&t; * the DMA port or we take the NCR5380 out of DMA mode, we &n;&t;&t; * can guarantee that we won&squot;t handshake another extra &n;&t;&t; * byte.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;flags
op_amp
id|FLAG_NCR53C400
)paren
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_DRQ
)paren
)paren
suffix:semicolon
multiline_comment|/* Wait for clean handshake */
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
suffix:semicolon
id|d
(braket
id|c
op_minus
l_int|1
)braket
op_assign
id|NCR5380_read
c_func
(paren
id|INPUT_DATA_REG
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
r_else
(brace
macro_line|#ifdef DMA_WORKS_RIGHT
id|foo
op_assign
id|NCR5380_pwrite
c_func
(paren
id|instance
comma
id|d
comma
id|c
)paren
suffix:semicolon
macro_line|#else
r_int
id|timeout
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;About to pwrite %d bytes&bslash;n&quot;
comma
id|c
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|foo
op_assign
id|NCR5380_pwrite
c_func
(paren
id|instance
comma
id|d
comma
id|c
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Wait for the last byte to be sent.  If REQ is being asserted for &n;&t;&t; * the byte we&squot;re interested, we&squot;ll ACK it and it will go false.  &n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;flags
op_amp
id|FLAG_HAS_LAST_BYTE_SENT
)paren
)paren
(brace
id|timeout
op_assign
l_int|20000
suffix:semicolon
macro_line|#if 1
macro_line|#if 1
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_DRQ
)paren
op_logical_and
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_PHASE_MATCH
)paren
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|timeout
op_logical_and
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_ACK
)paren
suffix:semicolon
op_decrement
id|timeout
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|timeout
op_logical_and
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
suffix:semicolon
op_decrement
id|timeout
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if (NDEBUG &amp; NDEBUG_LAST_BYTE_SENT)
r_if
c_cond
(paren
op_logical_neg
id|timeout
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : timed out on last byte&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|hostdata-&gt;flags
op_amp
id|FLAG_CHECK_LAST_BYTE_SENT
)paren
(brace
id|hostdata-&gt;flags
op_and_assign
op_complement
id|FLAG_CHECK_LAST_BYTE_SENT
suffix:semicolon
r_if
c_cond
(paren
id|NCR5380_read
c_func
(paren
id|TARGET_COMMAND_REG
)paren
op_amp
id|TCR_LAST_BYTE_SENT
)paren
(brace
id|hostdata-&gt;flags
op_or_assign
id|FLAG_HAS_LAST_BYTE_SENT
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_LAST_BYTE_SENT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : last bit sent works&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
r_else
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;Waiting for LASTBYTE&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|TARGET_COMMAND_REG
)paren
op_amp
id|TCR_LAST_BYTE_SENT
)paren
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;Got LASTBYTE&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#else
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif
)brace
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|p
op_amp
id|SR_IO
)paren
)paren
op_logical_and
(paren
id|hostdata-&gt;flags
op_amp
id|FLAG_NCR53C400
)paren
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w: Checking for IRQ&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_IRQ
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_C400_PWRITE)
id|printk
c_func
(paren
l_string|&quot;53C400w:    got it, reading reset interrupt reg&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;53C400w:    IRQ NOT THERE!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
op_star
id|data
op_assign
id|d
op_plus
id|c
suffix:semicolon
op_star
id|count
op_assign
l_int|0
suffix:semicolon
op_star
id|phase
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|PHASE_MASK
suffix:semicolon
macro_line|#if 0
DECL|variable|instance
id|NCR5380_print_phase
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(PSEUDO_DMA) &amp;&amp; !defined(UNSAFE)
DECL|variable|flags
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* defined(REAL_DMA_POLL) */
r_return
id|foo
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* def REAL_DMA */
)brace
macro_line|#endif&t;&t;&t;&t;/* defined(REAL_DMA) | defined(PSEUDO_DMA) */
multiline_comment|/*&n; * Function : NCR5380_information_transfer (struct Scsi_Host *instance)&n; *&n; * Purpose : run through the various SCSI phases and do as the target &n; *      directs us to.  Operates on the currently connected command, &n; *      instance-&gt;connected.&n; *&n; * Inputs : instance, instance for which we are doing commands&n; *&n; * Side effects : SCSI things happen, the disconnected queue will be &n; *      modified if a command disconnects, *instance-&gt;connected will&n; *      change.&n; *&n; * XXX Note : we need to watch for bus free or a reset condition here &n; *      to recover from an unexpected bus free condition.&n; */
r_static
r_void
id|NCR5380_information_transfer
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
r_int
r_char
id|msgout
op_assign
id|NOP
suffix:semicolon
r_int
id|sink
op_assign
l_int|0
suffix:semicolon
r_int
id|len
suffix:semicolon
macro_line|#if defined(PSEUDO_DMA) || defined(REAL_DMA_POLL)
r_int
id|transfersize
suffix:semicolon
macro_line|#endif
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
r_char
id|phase
comma
id|tmp
comma
id|extended_msg
(braket
l_int|10
)braket
comma
id|old_phase
op_assign
l_int|0xff
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;connected
suffix:semicolon
macro_line|#ifdef USLEEP
multiline_comment|/* RvC: we need to set the end of the polling time */
r_int
r_int
id|poll_time
op_assign
id|jiffies
op_plus
id|USLEEP_POLL
suffix:semicolon
macro_line|#endif
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|tmp
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
suffix:semicolon
multiline_comment|/* We only have a valid SCSI phase when REQ is asserted */
r_if
c_cond
(paren
id|tmp
op_amp
id|SR_REQ
)paren
(brace
id|phase
op_assign
(paren
id|tmp
op_amp
id|PHASE_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|phase
op_ne
id|old_phase
)paren
(brace
id|old_phase
op_assign
id|phase
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_INFORMATION)
id|NCR5380_print_phase
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|sink
op_logical_and
(paren
id|phase
op_ne
id|PHASE_MSGOUT
)paren
)paren
(brace
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
id|PHASE_SR_TO_TCR
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
op_or
id|ICR_ASSERT_ACK
)paren
suffix:semicolon
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
id|sink
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|phase
)paren
(brace
r_case
id|PHASE_DATAIN
suffix:colon
r_case
id|PHASE_DATAOUT
suffix:colon
macro_line|#if (NDEBUG &amp; NDEBUG_NO_DATAOUT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : NDEBUG_NO_DATAOUT set, attempted DATAOUT aborted&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|sink
op_assign
l_int|1
suffix:semicolon
id|do_abort
c_func
(paren
id|instance
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t;&t;&t;&t; * If there is no room left in the current buffer in the&n;&t;&t;&t;&t; * scatter-gather list, move onto the next one.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;SCp.this_residual
op_logical_and
id|cmd-&gt;SCp.buffers_residual
)paren
(brace
op_increment
id|cmd-&gt;SCp.buffer
suffix:semicolon
op_decrement
id|cmd-&gt;SCp.buffers_residual
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
id|cmd-&gt;SCp.buffer-&gt;address
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_INFORMATION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : %d bytes and %d buffers left&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;SCp.this_residual
comma
id|cmd-&gt;SCp.buffers_residual
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * The preferred transfer method is going to be &n;&t;&t;&t;&t; * PSEUDO-DMA for systems that are strictly PIO,&n;&t;&t;&t;&t; * since we can let the hardware do the handshaking.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * For this to work, we need to know the transfersize&n;&t;&t;&t;&t; * ahead of time, since the pseudo-DMA code will sit&n;&t;&t;&t;&t; * in an unconditional loop.&n;&t;&t;&t;&t; */
macro_line|#if defined(PSEUDO_DMA) || defined(REAL_DMA_POLL)
multiline_comment|/* KLL&n;&t;&t;&t;&t; * PSEUDO_DMA is defined here. If this is the g_NCR5380&n;&t;&t;&t;&t; * driver then it will always be defined, so the&n;&t;&t;&t;&t; * FLAG_NO_PSEUDO_DMA is used to inhibit PDMA in the base&n;&t;&t;&t;&t; * NCR5380 case.  I think this is a fairly clean solution.&n;&t;&t;&t;&t; * We supplement these 2 if&squot;s with the flag.&n;&t;&t;&t;&t; */
macro_line|#ifdef NCR5380_dma_xfer_len
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;device-&gt;borken
op_logical_and
op_logical_neg
(paren
id|hostdata-&gt;flags
op_amp
id|FLAG_NO_PSEUDO_DMA
)paren
op_logical_and
(paren
id|transfersize
op_assign
id|NCR5380_dma_xfer_len
c_func
(paren
id|instance
comma
id|cmd
)paren
)paren
op_ne
l_int|0
)paren
(brace
macro_line|#else
id|transfersize
op_assign
id|cmd-&gt;transfersize
suffix:semicolon
macro_line|#ifdef LIMIT_TRANSFERSIZE&t;/* If we have problems with interrupt service */
r_if
c_cond
(paren
id|transfersize
OG
l_int|512
)paren
id|transfersize
op_assign
l_int|512
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* LIMIT_TRANSFERSIZE */
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;device-&gt;borken
op_logical_and
id|transfersize
op_logical_and
op_logical_neg
(paren
id|hostdata-&gt;flags
op_amp
id|FLAG_NO_PSEUDO_DMA
)paren
op_logical_and
id|cmd-&gt;SCp.this_residual
op_logical_and
op_logical_neg
(paren
id|cmd-&gt;SCp.this_residual
op_mod
id|transfersize
)paren
)paren
(brace
multiline_comment|/* Limit transfers to 32K, for xx400 &amp; xx406&n;&t;&t;&t;&t;&t; * pseudoDMA that transfers in 128 bytes blocks. */
r_if
c_cond
(paren
id|transfersize
OG
l_int|32
op_star
l_int|1024
)paren
id|transfersize
op_assign
l_int|32
op_star
l_int|1024
suffix:semicolon
macro_line|#endif
id|len
op_assign
id|transfersize
suffix:semicolon
r_if
c_cond
(paren
id|NCR5380_transfer_dma
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
(paren
r_int
r_char
op_star
op_star
)paren
op_amp
id|cmd-&gt;SCp.ptr
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * If the watchdog timer fires, all future accesses to this&n;&t;&t;&t;&t;&t;&t; * device will use the polled-IO.&n;&t;&t;&t;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;scsi%d : switching target %d lun %d to slow handshake&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|cmd-&gt;device-&gt;borken
op_assign
l_int|1
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
id|sink
op_assign
l_int|1
suffix:semicolon
id|do_abort
c_func
(paren
id|instance
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/* XXX - need to source or sink data here, as appropriate */
)brace
r_else
id|cmd-&gt;SCp.this_residual
op_sub_assign
id|transfersize
op_minus
id|len
suffix:semicolon
)brace
r_else
macro_line|#endif&t;&t;&t;&t;/* defined(PSEUDO_DMA) || defined(REAL_DMA_POLL) */
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
(paren
r_int
op_star
)paren
op_amp
id|cmd-&gt;SCp.this_residual
comma
(paren
r_int
r_char
op_star
op_star
)paren
op_amp
id|cmd-&gt;SCp.ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PHASE_MSGIN
suffix:colon
id|len
op_assign
l_int|1
suffix:semicolon
id|data
op_assign
op_amp
id|tmp
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
id|cmd-&gt;SCp.Message
op_assign
id|tmp
suffix:semicolon
r_switch
c_cond
(paren
id|tmp
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Linking lets us reduce the time required to get the &n;&t;&t;&t;&t;&t; * next command out to the device, hopefully this will&n;&t;&t;&t;&t;&t; * mean we don&squot;t waste another revolution due to the delays&n;&t;&t;&t;&t;&t; * required by ARBITRATION and another SELECTION.&n;&t;&t;&t;&t;&t; *&n;&t;&t;&t;&t;&t; * In the current implementation proposal, low level drivers&n;&t;&t;&t;&t;&t; * merely have to start the next command, pointed to by &n;&t;&t;&t;&t;&t; * next_link, done() is called as with unlinked commands.&n;&t;&t;&t;&t;&t; */
macro_line|#ifdef LINKED
r_case
id|LINKED_CMD_COMPLETE
suffix:colon
r_case
id|LINKED_FLG_CMD_COMPLETE
suffix:colon
multiline_comment|/* Accept message by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_LINKED)
id|printk
c_func
(paren
l_string|&quot;scsi%d : target %d lun %d linked command complete.&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Sanity check : A linked command should only terminate with&n;&t;&t;&t;&t;&t; * one of these messages if there are more linked commands&n;&t;&t;&t;&t;&t; * available.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;next_link
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : target %d lun %d linked command complete, no next_link&bslash;n&quot;
id|instance-&gt;host_no
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|sink
op_assign
l_int|1
suffix:semicolon
id|do_abort
c_func
(paren
id|instance
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|initialize_SCp
c_func
(paren
id|cmd-&gt;next_link
)paren
suffix:semicolon
multiline_comment|/* The next command is still part of this process */
id|cmd-&gt;next_link-&gt;tag
op_assign
id|cmd-&gt;tag
suffix:semicolon
id|cmd-&gt;result
op_assign
id|cmd-&gt;SCp.Status
op_or
(paren
id|cmd-&gt;SCp.Message
op_lshift
l_int|8
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_LINKED)
id|printk
c_func
(paren
l_string|&quot;scsi%d : target %d lun %d linked request done, calling scsi_done().&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef NCR5380_STATS
id|collect_stats
c_func
(paren
id|hostdata
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|cmd
op_assign
id|hostdata-&gt;connected
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* def LINKED */
r_case
id|ABORT
suffix:colon
r_case
id|COMMAND_COMPLETE
suffix:colon
multiline_comment|/* Accept message by clearing ACK */
id|sink
op_assign
l_int|1
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_QUEUES)
id|printk
c_func
(paren
l_string|&quot;scsi%d : command for target %d, lun %d completed&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * I&squot;m not sure what the correct thing to do here is : &n;&t;&t;&t;&t;&t; * &n;&t;&t;&t;&t;&t; * If the command that just executed is NOT a request &n;&t;&t;&t;&t;&t; * sense, the obvious thing to do is to set the result&n;&t;&t;&t;&t;&t; * code to the values of the stored parameters.&n;&t;&t;&t;&t;&t; * &n;&t;&t;&t;&t;&t; * If it was a REQUEST SENSE command, we need some way &n;&t;&t;&t;&t;&t; * to differentiate between the failure code of the original&n;&t;&t;&t;&t;&t; * and the failure code of the REQUEST sense - the obvious&n;&t;&t;&t;&t;&t; * case is success, where we fall through and leave the result&n;&t;&t;&t;&t;&t; * code unchanged.&n;&t;&t;&t;&t;&t; * &n;&t;&t;&t;&t;&t; * The non-obvious place is where the REQUEST SENSE failed &n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|REQUEST_SENSE
)paren
id|cmd-&gt;result
op_assign
id|cmd-&gt;SCp.Status
op_or
(paren
id|cmd-&gt;SCp.Message
op_lshift
l_int|8
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd-&gt;SCp.Status
op_ne
id|GOOD
)paren
id|cmd-&gt;result
op_assign
(paren
id|cmd-&gt;result
op_amp
l_int|0x00ffff
)paren
op_or
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
macro_line|#ifdef AUTOSENSE
r_if
c_cond
(paren
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|REQUEST_SENSE
)paren
op_logical_and
(paren
id|cmd-&gt;SCp.Status
op_eq
id|CHECK_CONDITION
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_AUTOSENSE)
id|printk
c_func
(paren
l_string|&quot;scsi%d : performing request sense&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|REQUEST_SENSE
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|1
)braket
op_and_assign
l_int|0xe0
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.buffers_residual
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|cmd-&gt;sense_buffer
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|LIST
c_func
(paren
id|cmd
comma
id|hostdata-&gt;issue_queue
)paren
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|hostdata-&gt;issue_queue
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_QUEUES)
id|printk
c_func
(paren
l_string|&quot;scsi%d : REQUEST SENSE added to head of issue queue&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
macro_line|#endif&t;&t;&t;&t;/* def AUTOSENSE */
macro_line|#ifdef NCR5380_STATS
id|collect_stats
c_func
(paren
id|hostdata
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * Restore phase bits to 0 so an interrupted selection, &n;&t;&t;&t;&t;&t; * arbitration can resume.&n;&t;&t;&t;&t;&t; */
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_BSY
)paren
op_logical_and
op_logical_neg
id|hostdata-&gt;connected
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|MESSAGE_REJECT
suffix:colon
multiline_comment|/* Accept message by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hostdata-&gt;last_message
)paren
(brace
r_case
id|HEAD_OF_QUEUE_TAG
suffix:colon
r_case
id|ORDERED_QUEUE_TAG
suffix:colon
r_case
id|SIMPLE_QUEUE_TAG
suffix:colon
id|cmd-&gt;device-&gt;tagged_queue
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_or_assign
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_case
id|DISCONNECT
suffix:colon
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Accept message by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|cmd-&gt;device-&gt;disconnect
op_assign
l_int|1
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|LIST
c_func
(paren
id|cmd
comma
id|hostdata-&gt;disconnected_queue
)paren
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|hostdata-&gt;disconnected_queue
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;disconnected_queue
op_assign
id|cmd
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_QUEUES)
id|printk
c_func
(paren
l_string|&quot;scsi%d : command for target %d lun %d was moved from connected to&quot;
l_string|&quot;  the disconnected_queue&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * Restore phase bits to 0 so an interrupted selection, &n;&t;&t;&t;&t;&t;&t; * arbitration can resume.&n;&t;&t;&t;&t;&t;&t; */
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Enable reselect interrupts */
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
multiline_comment|/* Wait for bus free to avoid nasty timeouts */
r_while
c_loop
(paren
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_BSY
)paren
op_logical_and
op_logical_neg
id|hostdata-&gt;connected
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
macro_line|#if 0
id|NCR5380_print_status
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * The SCSI data pointer is *IMPLICITLY* saved on a disconnect&n;&t;&t;&t;&t;&t; * operation, in violation of the SCSI spec so we can safely &n;&t;&t;&t;&t;&t; * ignore SAVE/RESTORE pointers calls.&n;&t;&t;&t;&t;&t; *&n;&t;&t;&t;&t;&t; * Unfortunately, some disks violate the SCSI spec and &n;&t;&t;&t;&t;&t; * don&squot;t issue the required SAVE_POINTERS message before&n;&t;&t;&t;&t;&t; * disconnecting, and we have to break spec to remain &n;&t;&t;&t;&t;&t; * compatible.&n;&t;&t;&t;&t;&t; */
r_case
id|SAVE_POINTERS
suffix:colon
r_case
id|RESTORE_POINTERS
suffix:colon
multiline_comment|/* Accept message by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EXTENDED_MESSAGE
suffix:colon
multiline_comment|/* &n; * Extended messages are sent in the following format :&n; * Byte         &n; * 0            EXTENDED_MESSAGE == 1&n; * 1            length (includes one byte for code, doesn&squot;t &n; *              include first two bytes)&n; * 2            code&n; * 3..length+1  arguments&n; *&n; * Start the extended message buffer with the EXTENDED_MESSAGE&n; * byte, since print_msg() wants the whole thing.  &n; */
id|extended_msg
(braket
l_int|0
)braket
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
multiline_comment|/* Accept first byte by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_EXTENDED)
id|printk
c_func
(paren
l_string|&quot;scsi%d : receiving extended message&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|len
op_assign
l_int|2
suffix:semicolon
id|data
op_assign
id|extended_msg
op_plus
l_int|1
suffix:semicolon
id|phase
op_assign
id|PHASE_MSGIN
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_EXTENDED)
id|printk
c_func
(paren
l_string|&quot;scsi%d : length=%d, code=0x%02x&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
(paren
r_int
)paren
id|extended_msg
(braket
l_int|1
)braket
comma
(paren
r_int
)paren
id|extended_msg
(braket
l_int|2
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_and
id|extended_msg
(braket
l_int|1
)braket
op_le
(paren
r_sizeof
(paren
id|extended_msg
)paren
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* Accept third byte by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|len
op_assign
id|extended_msg
(braket
l_int|1
)braket
op_minus
l_int|1
suffix:semicolon
id|data
op_assign
id|extended_msg
op_plus
l_int|3
suffix:semicolon
id|phase
op_assign
id|PHASE_MSGIN
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_EXTENDED)
id|printk
c_func
(paren
l_string|&quot;scsi%d : message received, residual %d&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|extended_msg
(braket
l_int|2
)braket
)paren
(brace
r_case
id|EXTENDED_SDTR
suffix:colon
r_case
id|EXTENDED_WDTR
suffix:colon
r_case
id|EXTENDED_MODIFY_DATA_POINTER
suffix:colon
r_case
id|EXTENDED_EXTENDED_IDENTIFY
suffix:colon
id|tmp
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|len
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: error receiving extended message&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|tmp
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: extended message code %02x length %d is too long&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|extended_msg
(braket
l_int|2
)braket
comma
id|extended_msg
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|tmp
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Fall through to reject message */
multiline_comment|/* &n;&t;&t;&t;&t;&t; * If we get something weird that we aren&squot;t expecting, &n;&t;&t;&t;&t;&t; * reject it.&n;&t;&t;&t;&t;&t; */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: rejecting message &quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|print_msg
c_func
(paren
id|extended_msg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tmp
op_ne
id|EXTENDED_MESSAGE
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d: rejecting unknown message %02x from target %d, lun %d&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|tmp
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;scsi%d: rejecting unknown extended message code %02x, length %d from target %d, lun %d&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|extended_msg
(braket
l_int|1
)braket
comma
id|extended_msg
(braket
l_int|0
)braket
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|msgout
op_assign
id|MESSAGE_REJECT
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* switch (tmp) */
r_break
suffix:semicolon
r_case
id|PHASE_MSGOUT
suffix:colon
id|len
op_assign
l_int|1
suffix:semicolon
id|data
op_assign
op_amp
id|msgout
suffix:semicolon
id|hostdata-&gt;last_message
op_assign
id|msgout
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msgout
op_eq
id|ABORT
)paren
(brace
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
macro_line|#ifdef NCR5380_STATS
id|collect_stats
c_func
(paren
id|hostdata
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|msgout
op_assign
id|NOP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PHASE_CMDOUT
suffix:colon
id|len
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|data
op_assign
id|cmd-&gt;cmnd
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * XXX for performance reasons, on machines with a &n;&t;&t;&t;&t; * PSEUDO-DMA architecture we should probably &n;&t;&t;&t;&t; * use the dma transfer function.  &n;&t;&t;&t;&t; */
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
macro_line|#ifdef USLEEP
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;device-&gt;disconnect
op_logical_and
id|should_disconnect
c_func
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
)paren
(brace
id|hostdata-&gt;time_expires
op_assign
id|jiffies
op_plus
id|USLEEP_SLEEP
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_USLEEP)
id|printk
c_func
(paren
l_string|&quot;scsi%d : issued command, sleeping until %ul&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|hostdata-&gt;time_expires
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_set_timer
c_func
(paren
id|instance
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* def USLEEP */
r_break
suffix:semicolon
r_case
id|PHASE_STATIN
suffix:colon
id|len
op_assign
l_int|1
suffix:semicolon
id|data
op_assign
op_amp
id|tmp
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
id|cmd-&gt;SCp.Status
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : unknown phase&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#ifdef NDEBUG
id|NCR5380_print
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* switch(phase) */
)brace
multiline_comment|/* if (tmp * SR_REQ) */
macro_line|#ifdef USLEEP
r_else
(brace
multiline_comment|/* RvC: go to sleep if polling time expired&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;device-&gt;disconnect
op_logical_and
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|poll_time
)paren
)paren
(brace
id|hostdata-&gt;time_expires
op_assign
id|jiffies
op_plus
id|USLEEP_SLEEP
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_USLEEP)
id|printk
c_func
(paren
l_string|&quot;scsi%d : poll timed out, sleeping until %ul&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|hostdata-&gt;time_expires
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_set_timer
c_func
(paren
id|instance
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
multiline_comment|/* while (1) */
)brace
multiline_comment|/*&n; * Function : void NCR5380_reselect (struct Scsi_Host *instance)&n; *&n; * Purpose : does reselection, initializing the instance-&gt;connected &n; *      field to point to the Scsi_Cmnd for which the I_T_L or I_T_L_Q &n; *      nexus has been reestablished,&n; *      &n; * Inputs : instance - this instance of the NCR5380.&n; *&n; */
r_static
r_void
id|NCR5380_reselect
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
r_int
r_char
id|target_mask
suffix:semicolon
r_int
r_char
id|lun
comma
id|phase
suffix:semicolon
r_int
id|len
suffix:semicolon
macro_line|#ifdef SCSI2
r_int
r_char
id|tag
suffix:semicolon
macro_line|#endif
r_int
r_char
id|msg
(braket
l_int|3
)braket
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
id|Scsi_Cmnd
op_star
id|tmp
op_assign
l_int|NULL
comma
op_star
id|prev
suffix:semicolon
r_int
m_abort
op_assign
l_int|0
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Disable arbitration, etc. since the host adapter obviously&n;&t; * lost, and tell an interrupted NCR5380_select() to restart.&n;&t; */
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|hostdata-&gt;restart_select
op_assign
l_int|1
suffix:semicolon
id|target_mask
op_assign
id|NCR5380_read
c_func
(paren
id|CURRENT_SCSI_DATA_REG
)paren
op_amp
op_complement
(paren
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_RESELECTION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : reselect&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t; * At this point, we have detected that our SCSI ID is on the bus,&n;&t; * SEL is true and BSY was false for at least one bus settle delay&n;&t; * (400 ns).&n;&t; *&n;&t; * We must assert BSY ourselves, until the target drops the SEL&n;&t; * signal.&n;&t; */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_BSY
)paren
suffix:semicolon
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_SEL
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for target to go into MSGIN.&n;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
)paren
suffix:semicolon
id|len
op_assign
l_int|1
suffix:semicolon
id|data
op_assign
id|msg
suffix:semicolon
id|phase
op_assign
id|PHASE_MSGIN
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msg
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : expecting IDENTIFY message, got &quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|print_msg
c_func
(paren
id|msg
)paren
suffix:semicolon
m_abort
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Accept message by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|lun
op_assign
(paren
id|msg
(braket
l_int|0
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * We need to add code for SCSI-II to track which devices have&n;&t;&t; * I_T_L_Q nexuses established, and which have simple I_T_L&n;&t;&t; * nexuses so we can chose to do additional data transfer.&n;&t;&t; */
macro_line|#ifdef SCSI2
macro_line|#error &quot;SCSI-II tagged queueing is not supported yet&quot;
macro_line|#endif
multiline_comment|/* &n;&t;&t; * Find the command corresponding to the I_T_L or I_T_L_Q  nexus we &n;&t;&t; * just reestablished, and remove it from the disconnected queue.&n;&t;&t; */
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_queue
comma
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|tmp
suffix:semicolon
id|prev
op_assign
id|tmp
comma
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
r_if
c_cond
(paren
(paren
id|target_mask
op_eq
(paren
l_int|1
op_lshift
id|tmp-&gt;target
)paren
)paren
op_logical_and
(paren
id|lun
op_eq
id|tmp-&gt;lun
)paren
macro_line|#ifdef SCSI2
op_logical_and
(paren
id|tag
op_eq
id|tmp-&gt;tag
)paren
macro_line|#endif
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
(brace
id|REMOVE
c_func
(paren
id|prev
comma
id|prev-&gt;host_scribble
comma
id|tmp
comma
id|tmp-&gt;host_scribble
)paren
suffix:semicolon
id|prev-&gt;host_scribble
op_assign
id|tmp-&gt;host_scribble
suffix:semicolon
)brace
r_else
(brace
id|REMOVE
c_func
(paren
op_minus
l_int|1
comma
id|hostdata-&gt;disconnected_queue
comma
id|tmp
comma
id|tmp-&gt;host_scribble
)paren
suffix:semicolon
id|hostdata-&gt;disconnected_queue
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
suffix:semicolon
)brace
id|tmp-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
macro_line|#ifdef SCSI2
id|printk
c_func
(paren
l_string|&quot;scsi%d : warning : target bitmask %02x lun %d tag %d not in disconnect_queue.&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|target_mask
comma
id|lun
comma
id|tag
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;scsi%d : warning : target bitmask %02x lun %d not in disconnect_queue.&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|target_mask
comma
id|lun
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t;&t;&t; * Since we have an established nexus that we can&squot;t do anything with,&n;&t;&t;&t; * we must abort it.  &n;&t;&t;&t; */
m_abort
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
m_abort
)paren
(brace
id|do_abort
c_func
(paren
id|instance
)paren
suffix:semicolon
)brace
r_else
(brace
id|hostdata-&gt;connected
op_assign
id|tmp
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_RESELECTION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : nexus established, target = %d, lun = %d, tag = %d&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|tmp-&gt;target
comma
id|tmp-&gt;lun
comma
id|tmp-&gt;tag
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*&n; * Function : void NCR5380_dma_complete (struct Scsi_Host *instance)&n; *&n; * Purpose : called by interrupt handler when DMA finishes or a phase&n; *      mismatch occurs (which would finish the DMA transfer).  &n; *&n; * Inputs : instance - this instance of the NCR5380.&n; *&n; * Returns : pointer to the Scsi_Cmnd structure for which the I_T_L&n; *      nexus has been reestablished, on failure NULL is returned.&n; */
macro_line|#ifdef REAL_DMA
r_static
r_void
id|NCR5380_dma_complete
c_func
(paren
id|NCR5380_instance
op_star
id|instance
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
id|instance-&gt;hostdata
)paren
suffix:semicolon
r_int
id|transferred
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX this might not be right.&n;&t; *&n;&t; * Wait for final byte to transfer, ie wait for ACK to go false.&n;&t; *&n;&t; * We should use the Last Byte Sent bit, unfortunately this is &n;&t; * not available on the 5380/5381 (only the various CMOS chips)&n;&t; */
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_ACK
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The only places we should see a phase mismatch and have to send&n;&t; * data from the same set of pointers will be the data transfer&n;&t; * phases.  So, residual, requested length are only important here.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;connected-&gt;SCp.phase
op_amp
id|SR_CD
)paren
)paren
(brace
id|transferred
op_assign
id|instance-&gt;dmalen
op_minus
id|NCR5380_dma_residual
c_func
(paren
)paren
suffix:semicolon
id|hostdata-&gt;connected-&gt;SCp.this_residual
op_sub_assign
id|transferred
suffix:semicolon
id|hostdata-&gt;connected-&gt;SCp.ptr
op_add_assign
id|transferred
suffix:semicolon
)brace
)brace
macro_line|#endif&t;&t;&t;&t;/* def REAL_DMA */
multiline_comment|/*&n; * Function : int NCR5380_abort (Scsi_Cmnd *cmd)&n; *&n; * Purpose : abort a command&n; *&n; * Inputs : cmd - the Scsi_Cmnd to abort, code - code to set the &n; *      host byte of the result field to, if zero DID_ABORTED is &n; *      used.&n; *&n; * Returns : 0 - success, -1 on failure.&n; *&n; * XXX - there is no way to abort the command that is currently &n; *       connected, you have to wait for it to complete.  If this is &n; *       a problem, we could implement longjmp() / setjmp(), setjmp()&n; *       called where the loop started in NCR5380_main().&n; */
macro_line|#ifndef NCR5380_abort
r_static
macro_line|#endif
r_int
id|NCR5380_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
op_assign
id|cmd-&gt;host
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|Scsi_Cmnd
op_star
id|tmp
comma
op_star
op_star
id|prev
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : aborting command&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|print_Scsi_Cmnd
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|NCR5380_print_status
c_func
(paren
id|instance
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : aborting command&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|print_Scsi_Cmnd
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|NCR5380_print_status
c_func
(paren
id|instance
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_ABORT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : abort called&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        basr 0x%X, sr 0x%X&bslash;n&quot;
comma
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
comma
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0
multiline_comment|/*&n; * Case 1 : If the command is the currently executing command, &n; * we&squot;ll set the aborted flag and return control so that &n; * information transfer routine can exit cleanly.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;connected
op_eq
id|cmd
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_ABORT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : aborting connected command&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;aborted
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; * We should perform BSY checking, and make sure we haven&squot;t slipped&n; * into BUS FREE.&n; */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
multiline_comment|/* &n; * Since we can&squot;t change phases until we&squot;ve completed the current &n; * handshake, we have to source or sink a byte of data if the current&n; * phase is not MSGOUT.&n; */
multiline_comment|/* &n; * Return control to the executing NCR drive so we can clear the&n; * aborted flag and get back into our main loop.&n; */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* &n; * Case 2 : If the command hasn&squot;t been issued yet, we simply remove it &n; *          from the issue queue.&n; */
macro_line|#if (NDEBUG &amp; NDEBUG_ABORT)
multiline_comment|/* KLL */
id|printk
c_func
(paren
l_string|&quot;scsi%d : abort going into loop.&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
id|hostdata-&gt;issue_queue
)paren
comma
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|tmp
suffix:semicolon
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
id|tmp-&gt;host_scribble
)paren
comma
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
r_if
c_cond
(paren
id|cmd
op_eq
id|tmp
)paren
(brace
id|REMOVE
c_func
(paren
l_int|5
comma
op_star
id|prev
comma
id|tmp
comma
id|tmp-&gt;host_scribble
)paren
suffix:semicolon
(paren
op_star
id|prev
)paren
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
suffix:semicolon
id|tmp-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_ABORT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : abort removed command from issue queue.&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|tmp
op_member_access_from_pointer
id|done
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
macro_line|#if (NDEBUG  &amp; NDEBUG_ABORT)
multiline_comment|/* KLL */
r_else
r_if
c_cond
(paren
id|prev
op_eq
id|tmp
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : LOOP&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n; * Case 3 : If any commands are connected, we&squot;re going to fail the abort&n; *          and let the high level SCSI driver retry at a later time or &n; *          issue a reset.&n; *&n; *          Timeouts, and therefore aborted commands, will be highly unlikely&n; *          and handling them cleanly in this situation would make the common&n; *          case of noresets less efficient, and would pollute our code.  So,&n; *          we fail.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;connected
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_ABORT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : abort failed, command connected.&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
multiline_comment|/*&n; * Case 4: If the command is currently disconnected from the bus, and &n; *      there are no connected commands, we reconnect the I_T_L or &n; *      I_T_L_Q nexus associated with it, go into message out, and send &n; *      an abort message.&n; *&n; * This case is especially ugly. In order to reestablish the nexus, we&n; * need to call NCR5380_select().  The easiest way to implement this &n; * function was to abort if the bus was busy, and let the interrupt&n; * handler triggered on the SEL for reselect take care of lost arbitrations&n; * where necessary, meaning interrupts need to be enabled.&n; *&n; * When interrupts are enabled, the queues may change - so we &n; * can&squot;t remove it from the disconnected queue before selecting it&n; * because that could cause a failure in hashing the nexus if that &n; * device reselected.&n; * &n; * Since the queues may change, we can&squot;t use the pointers from when we&n; * first locate it.&n; *&n; * So, we must first locate the command, and if NCR5380_select()&n; * succeeds, then issue the abort, relocate the command and remove&n; * it from the disconnected queue.&n; */
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_queue
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
r_if
c_cond
(paren
id|cmd
op_eq
id|tmp
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_ABORT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : aborting disconnected command.&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|NCR5380_select
c_func
(paren
id|instance
comma
id|cmd
comma
(paren
r_int
)paren
id|cmd-&gt;tag
)paren
)paren
r_return
id|SCSI_ABORT_BUSY
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_ABORT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : nexus reestablished.&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|do_abort
c_func
(paren
id|instance
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
id|hostdata-&gt;disconnected_queue
)paren
comma
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_queue
suffix:semicolon
id|tmp
suffix:semicolon
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
id|tmp-&gt;host_scribble
)paren
comma
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
r_if
c_cond
(paren
id|cmd
op_eq
id|tmp
)paren
(brace
id|REMOVE
c_func
(paren
l_int|5
comma
op_star
id|prev
comma
id|tmp
comma
id|tmp-&gt;host_scribble
)paren
suffix:semicolon
op_star
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
suffix:semicolon
id|tmp-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|tmp
op_member_access_from_pointer
id|done
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Case 5 : If we reached this point, the command was not found in any of &n; *          the queues.&n; *&n; * We probably reached this point because of an unlikely race condition&n; * between the command completing successfully and the abortion code,&n; * so we won&squot;t panic, but we will notify the user in case something really&n; * broke.&n; */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : warning : SCSI command probably completed successfully&bslash;n&quot;
l_string|&quot;         before abortion&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : int NCR5380_reset (Scsi_Cmnd *cmd, unsigned int reset_flags)&n; * &n; * Purpose : reset the SCSI bus.&n; *&n; * Returns : SCSI_RESET_WAKEUP&n; *&n; */
macro_line|#ifndef NCR5380_reset
r_static
macro_line|#endif
r_int
id|NCR5380_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_int
id|dummy
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|cmd-&gt;host
)paren
suffix:semicolon
id|NCR5380_print_status
c_func
(paren
id|cmd-&gt;host
)paren
suffix:semicolon
id|do_reset
c_func
(paren
id|cmd-&gt;host
)paren
suffix:semicolon
r_return
id|SCSI_RESET_WAKEUP
suffix:semicolon
)brace
eof
