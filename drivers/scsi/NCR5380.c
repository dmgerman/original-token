DECL|macro|NDEBUG
mdefine_line|#define NDEBUG (NDEBUG_RESTART_SELECT)
multiline_comment|/* &n; * NCR 5380 generic driver routines.  These should make it *trivial*&n; * &t;to implement 5380 SCSI drivers under Linux with a non-trantor&n; *&t;architecture.&n; *&n; *&t;Note that these routines also work with NR53c400 family chips.&n; *&n; * Copyright 1993, Drew Eckhardt&n; *&t;Visionary Computing &n; *&t;(Unix and Linux consulting and custom programming)&n; * &t;drew@colorado.edu&n; *&t;+1 (303) 666-5836&n; *&n; * DISTRIBUTION RELEASE 6. &n; *&n; * For more information, please consult &n; *&n; * NCR 5380 Family&n; * SCSI Protocol Controller&n; * Databook&n; *&n; * NCR Microelectronics&n; * 1635 Aeroplaza Drive&n; * Colorado Springs, CO 80916&n; * 1+ (719) 578-3400&n; * 1+ (800) 334-5454&n; */
multiline_comment|/*&n; * $Log: NCR5380.c,v $&n; * Revision 1.5  1994/01/19  09:14:57  drew&n; * Fixed udelay() hack that was being used on DATAOUT phases&n; * instead of a proper wait for the final handshake.&n; *&n; * Revision 1.4  1994/01/19  06:44:25  drew&n; * *** empty log message ***&n; *&n; * Revision 1.3  1994/01/19  05:24:40  drew&n; * Added support for TCR LAST_BYTE_SENT bit.&n; *&n; * Revision 1.2  1994/01/15  06:14:11  drew&n; * REAL DMA support, bug fixes.&n; *&n; * Revision 1.1  1994/01/15  06:00:54  drew&n; * Initial revision&n; *&n; */
multiline_comment|/*&n; * Further development / testing that should be done : &n; * 1.  Cleanup the NCR5380_transfer_dma function and DMA operation complete&n; *     code so that everything does the same thing that&squot;s done at the &n; *     end of a pseudo-DMA read operation.&n; *&n; * 2.  Fix REAL_DMA (interrupt driven, polled works fine) -&n; *     basically, transfer size needs to be reduced by one &n; *     and the last byte read as is done with PSEUDO_DMA.&n; * &n; * 3.  Test USLEEP code &n; *&n; * 4.  Test SCSI-II tagged queueing (I have no devices which support &n; *&t;tagged queueing)&n; *&n; * 5.  Test linked command handling code after Eric is ready with &n; *      the high level code.&n; */
macro_line|#ifndef notyet
DECL|macro|LINKED
macro_line|#undef LINKED
DECL|macro|USLEEP
macro_line|#undef USLEEP
DECL|macro|REAL_DMA
macro_line|#undef REAL_DMA
macro_line|#endif
macro_line|#ifdef REAL_DMA_POLL
DECL|macro|READ_OVERRUNS
macro_line|#undef READ_OVERRUNS
DECL|macro|READ_OVERRUNS
mdefine_line|#define READ_OVERRUNS
macro_line|#endif
multiline_comment|/*&n; * Design&n; * Issues :&n; *&n; * The other Linux SCSI drivers were written when Linux was Intel PC-only,&n; * and specifically for each board rather than each chip.  This makes their&n; * adaptation to platforms like the Mac (Some of which use NCR5380&squot;s)&n; * more difficult than it has to be.&n; *&n; * Also, many of the SCSI drivers were written before the command queuing&n; * routines were implemented, meaning their implementations of queued &n; * commands were hacked on rather than designed in from the start.&n; *&n; * When I designed the Linux SCSI drivers I figured that &n; * while having two different SCSI boards in a system might be useful&n; * for debugging things, two of the same type wouldn&squot;t be used.&n; * Well, I was wrong and a number of users have mailed me about running&n; * multiple high-performance SCSI boards in a server.&n; *&n; * Finally, when I get questions from users, I have no idea what &n; * revision of my driver they are running.&n; *&n; * This driver attempts to address these problems :&n; * This is a generic 5380 driver.  To use it on a different platform, &n; * one simply writes appropriate system specific macros (ie, data&n; * transfer - some PC&squot;s will use the I/O bus, 68K&squot;s must use &n; * memory mapped) and drops this file in their &squot;C&squot; wrapper.&n; *&n; * As far as command queueing, two queues are maintained for &n; * each 5380 in the system - commands that haven&squot;t been issued yet,&n; * and commands that are currently executing.  This means that an &n; * unlimited number of commands may be queued, letting &n; * more commands propagate from the higher driver levels giving higher &n; * throughput.  Note that both I_T_L and I_T_L_Q nexuses are supported, &n; * allowing multiple commands to propagate all the way to a SCSI-II device &n; * while a command is already executing.&n; *&n; * To solve the multiple-boards-in-the-same-system problem, &n; * there is a separate instance structure for each instance&n; * of a 5380 in the system.  So, multiple NCR5380 drivers will&n; * be able to coexist with appropriate changes to the high level&n; * SCSI code.  &n; *&n; * A NCR5380_PUBLIC_REVISION macro is provided, with the release&n; * number (updated for each public release) printed by the &n; * NCR5380_print_options command, which should be called from the &n; * wrapper detect function, so that I know what release of the driver&n; * users are using.&n; *&n; * Issues specific to the NCR5380 : &n; *&n; * When used in a PIO or pseudo-dma mode, the NCR5380 is a braindead &n; * piece of hardware that requires you to sit in a loop polling for &n; * the REQ signal as long as you are connected.  Some devices are &n; * brain dead (ie, many TEXEL CD ROM drives) and won&squot;t disconnect &n; * while doing long seek operations.&n; * &n; * The workaround for this is to keep track of devices that have&n; * disconnected.  If the device hasn&squot;t disconnected, for commands that&n; * should disconnect, we do something like &n; *&n; * while (!REQ is asserted) { sleep for N usecs; poll for M usecs }&n; * &n; * Some tweaking of N and M needs to be done.  An algorithm based &n; * on &quot;time to data&quot; would give the best results as long as short time&n; * to datas (ie, on the same track) were considered, however these &n; * broken devices are the exception rather than the rule and I&squot;d rather&n; * spend my time optimizing for the normal case.&n; *&n; * Architecture :&n; *&n; * At the heart of the design is a coroutine, NCR5380_main,&n; * which is started when not running by the interrupt handler,&n; * timer, and queue command function.  It attempts to establish&n; * I_T_L or I_T_L_Q nexuses by removing the commands from the &n; * issue queue and calling NCR5380_select() if a nexus &n; * is not established. &n; *&n; * Once a nexus is established, the NCR5380_information_transfer()&n; * phase goes through the various phases as instructed by the target.&n; * if the target goes into MSG IN and sends a DISCONNECT message,&n; * the command structure is placed into the per instance disconnected&n; * queue, and NCR5380_main tries to find more work.  If USLEEP&n; * was defined, and the target is idle for too long, the system&n; * will try to sleep.&n; *&n; * If a command has disconnected, eventually an interrupt will trigger,&n; * calling NCR5380_intr()  which will in turn call NCR5380_reselect&n; * to reestablish a nexus.  This will run main if necessary.&n; *&n; * On command termination, the done function will be called as &n; * appropriate.&n; *&n; * SCSI pointers are maintained in the SCp field of SCSI command &n; * structures, being initialized after the command is connected&n; * in NCR5380_select, and set as appropriate in NCR5380_information_transfer.&n; * Note that in violation of the standard, an implicit SAVE POINTERS operation&n; * is done, since some BROKEN disks fail to issue an explicit SAVE POINTERS.&n; */
multiline_comment|/*&n; * Using this file :&n; * This file a skeleton Linux SCSI driver for the NCR 5380 series&n; * of chips.  To use it, you write a architecture specific functions &n; * and macros and include this file in your driver.&n; *&n; * These macros control options : &n; * AUTOPROBE_IRQ - if defined, the NCR5380_probe_irq() function will be &n; *&t;defined.&n; * &n; * AUTOSENSE - if defined, REQUEST SENSE will be performed automatically&n; *&t;for commands that return with a CHECK CONDITION status. &n; *&n; * DIFFERENTIAL - if defined, NCR53c81 chips will use external differential&n; * &t;transceivers. &n; *&n; * LIMIT_TRANSFERSIZE - if defined, limit the pseudo-dma transfers to 512&n; *&t;bytes at a time.  Since interrupts are disabled by default during&n; *&t;these transfers, we might need this to give reasonable interrupt&n; *&t;service time if the transfer size gets too large.&n; *&n; * LINKED - if defined, linked commands are supported.&n; *&n; * PSEUDO_DMA - if defined, PSEUDO DMA is used during the data transfer phases.&n; *&n; * REAL_DMA - if defined, REAL DMA is used during the data transfer phases.&n; *&n; * REAL_DMA_POLL - if defined, REAL DMA is used but the driver doesn&squot;t&n; * &t;rely on phase mismatch and EOP interrupts to determine end &n; *&t;of phase.&n; *&n; * SCSI2 - if defined, SCSI-2 tagged queuing is used where possible&n; *&n; * UNSAFE - leave interrupts enabled during pseudo-DMA transfers.  You&n; *&t;    only really want to use this if you&squot;re having a problem with&n; *&t;    dropped characters during high speed communications, and even&n; *&t;    then, you&squot;re going to be better off twiddling with transfersize&n; *&t;    in the high level code.&n; *&n; * USLEEP - if defined, on devices that aren&squot;t disconnecting from the &n; *&t;bus, we will go to sleep so that the CPU can get real work done &n; *&t;when we run a command that won&squot;t complete immediately.&n; *&n; * Note that if USLEEP is defined, NCR5380_TIMER *must* also be&n; * defined.&n; *&n; * Defaults for these will be provided if USLEEP is defined, although&n; * the user may want to adjust these to allocate CPU resources to &n; * the SCSI driver or &quot;real&quot; code.&n; * &n; * USLEEP_SLEEP - amount of time, in jiffies, to sleep&n; *&n; * USLEEP_POLL - amount of time, in jiffies, to poll&n; *&n; * These macros MUST be defined :&n; * NCR5380_local_declare() - declare any local variables needed for your transfer&n; *&t;routines.&n; *&n; * NCR5380_setup(instance) - initialize any local variables needed from a given&n; *&t;instance of the host adapter for NCR5380_{read,write,pread,pwrite}&n; * &n; * NCR5380_read(register)  - read from the specified register&n; *&n; * NCR5380_write(register, value) - write to the specific register &n; *&n; * NCR5380_implementation_fields  - additional fields needed for this &n; *&t;specific implementation of the NCR5380&n; *&n; * Either real DMA *or* pseudo DMA may be implemented&n; * REAL functions : &n; * NCR5380_REAL_DMA should be defined if real DMA is to be used.&n; * Note that the DMA setup functions should return the number of bytes &n; *&t;that they were able to program the controller for.&n; *&n; * Also note that generic i386/PC versions of these macros are &n; *&t;available as NCR5380_i386_dma_write_setup,&n; *&t;NCR5380_i386_dma_read_setup, and NCR5380_i386_dma_residual.&n; *&n; * NCR5380_dma_write_setup(instance, src, count) - initialize&n; * NCR5380_dma_read_setup(instance, dst, count) - initialize&n; * NCR5380_dma_residual(instance); - residual count&n; *&n; * PSEUDO functions :&n; * NCR5380_pwrite(instance, src, count)&n; * NCR5380_pread(instance, dst, count);&n; *&n; * If nothing specific to this implementation needs doing (ie, with external&n; * hardware), you must also define &n; *  &n; * NCR5380_queue_command&n; * NCR5380_reset&n; * NCR5380_abort&n; *&n; * to be the global entry points into the specific driver, ie &n; * #define NCR5380_queue_command t128_queue_command.&n; *&n; * If this is not done, the routines will be defined as static functions&n; * with the NCR5380* names and the user must provide a globally&n; * accessible wrapper function.&n; *&n; * The generic driver is initialized by calling NCR5380_init(instance),&n; * after setting the appropriate host specific fields and ID.  If the &n; * driver wishes to autoprobe for an IRQ line, the NCR5380_probe_irq(instance,&n; * possible) function may be used.  Before the specific driver initialization&n; * code finishes, NCR5380_print_options should be called.&n; */
DECL|variable|first_instance
r_static
r_struct
id|Scsi_Host
op_star
id|first_instance
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|the_template
r_static
id|Scsi_Host_Template
op_star
id|the_template
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * Function : void initialize_SCp(Scsi_Cmnd *cmd)&n; *&n; * Purpose : initialize the saved data pointers for cmd to point to the &n; *&t;start of the buffer.&n; *&n; * Inputs : cmd - Scsi_Cmnd structure to have pointers reset.&n; */
DECL|function|initialize_SCp
r_static
id|__inline__
r_void
id|initialize_SCp
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/* &n;     * Initialize the Scsi Pointer field so that all of the commands in the &n;     * various queues are valid.&n;     */
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
id|cmd-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
id|cmd-&gt;SCp.buffers_residual
op_assign
id|cmd-&gt;use_sg
op_minus
l_int|1
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|cmd-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
r_else
(brace
id|cmd-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.buffers_residual
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
)brace
)brace
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#ifdef NDEBUG
r_static
r_struct
(brace
DECL|member|mask
r_int
r_char
id|mask
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
)brace
DECL|variable|signals
id|signals
(braket
)braket
op_assign
(brace
(brace
id|SR_DBP
comma
l_string|&quot;PARITY&quot;
)brace
comma
(brace
id|SR_RST
comma
l_string|&quot;RST&quot;
)brace
comma
(brace
id|SR_BSY
comma
l_string|&quot;BSY&quot;
)brace
comma
(brace
id|SR_REQ
comma
l_string|&quot;REQ&quot;
)brace
comma
(brace
id|SR_MSG
comma
l_string|&quot;MSG&quot;
)brace
comma
(brace
id|SR_CD
comma
l_string|&quot;CD&quot;
)brace
comma
(brace
id|SR_IO
comma
l_string|&quot;IO&quot;
)brace
comma
(brace
id|SR_SEL
comma
l_string|&quot;SEL&quot;
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
comma
DECL|variable|basrs
id|basrs
(braket
)braket
op_assign
(brace
(brace
id|BASR_ATN
comma
l_string|&quot;ATN&quot;
)brace
comma
(brace
id|BASR_ACK
comma
l_string|&quot;ACK&quot;
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
comma
DECL|variable|icrs
id|icrs
(braket
)braket
op_assign
(brace
(brace
id|ICR_ASSERT_RST
comma
l_string|&quot;ASSERT RST&quot;
)brace
comma
(brace
id|ICR_ASSERT_ACK
comma
l_string|&quot;ASSERT ACK&quot;
)brace
comma
(brace
id|ICR_ASSERT_BSY
comma
l_string|&quot;ASSERT BSY&quot;
)brace
comma
(brace
id|ICR_ASSERT_SEL
comma
l_string|&quot;ASSERT SEL&quot;
)brace
comma
(brace
id|ICR_ASSERT_ATN
comma
l_string|&quot;ASSERT ATN&quot;
)brace
comma
(brace
id|ICR_ASSERT_DATA
comma
l_string|&quot;ASSERT DATA&quot;
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
comma
DECL|variable|mrs
id|mrs
(braket
)braket
op_assign
(brace
(brace
id|MR_BLOCK_DMA_MODE
comma
l_string|&quot;MODE BLOCK DMA&quot;
)brace
comma
(brace
id|MR_TARGET
comma
l_string|&quot;MODE TARGET&quot;
)brace
comma
(brace
id|MR_ENABLE_PAR_CHECK
comma
l_string|&quot;MODE PARITY CHECK&quot;
)brace
comma
(brace
id|MR_ENABLE_PAR_INTR
comma
l_string|&quot;MODE PARITY INTR&quot;
)brace
comma
(brace
id|MR_MONITOR_BSY
comma
l_string|&quot;MODE MONITOR BSY&quot;
)brace
comma
(brace
id|MR_DMA_MODE
comma
l_string|&quot;MODE DMA&quot;
)brace
comma
(brace
id|MR_ARBITRATE
comma
l_string|&quot;MODE ARBITRATION&quot;
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Function : void NCR5380_print(struct Scsi_Host *instance)&n; *&n; * Purpose : print the SCSI bus signals for debugging purposes&n; *&n; * Input : instance - which NCR5380&n; */
DECL|function|NCR5380_print
r_static
r_void
id|NCR5380_print
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_int
r_char
id|status
comma
id|data
comma
id|basr
comma
id|mr
comma
id|icr
comma
id|i
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|data
op_assign
id|NCR5380_read
c_func
(paren
id|CURRENT_SCSI_DATA_REG
)paren
suffix:semicolon
id|status
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
suffix:semicolon
id|mr
op_assign
id|NCR5380_read
c_func
(paren
id|MODE_REG
)paren
suffix:semicolon
id|icr
op_assign
id|NCR5380_read
c_func
(paren
id|INITIATOR_COMMAND_REG
)paren
suffix:semicolon
id|basr
op_assign
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|signals
(braket
id|i
)braket
dot
id|mask
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|status
op_amp
id|signals
(braket
id|i
)braket
dot
id|mask
)paren
id|printk
c_func
(paren
l_string|&quot; %s&quot;
comma
id|signals
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|basrs
(braket
id|i
)braket
dot
id|mask
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|basr
op_amp
id|basrs
(braket
id|i
)braket
dot
id|mask
)paren
id|printk
c_func
(paren
l_string|&quot; %s&quot;
comma
id|basrs
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|icrs
(braket
id|i
)braket
dot
id|mask
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|icr
op_amp
id|icrs
(braket
id|i
)braket
dot
id|mask
)paren
id|printk
c_func
(paren
l_string|&quot; %s&quot;
comma
id|icrs
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mrs
(braket
id|i
)braket
dot
id|mask
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|mr
op_amp
id|mrs
(braket
id|i
)braket
dot
id|mask
)paren
id|printk
c_func
(paren
l_string|&quot; %s&quot;
comma
id|mrs
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_static
r_struct
(brace
DECL|member|value
r_int
r_char
id|value
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|variable|phases
)brace
id|phases
(braket
)braket
op_assign
(brace
(brace
id|PHASE_DATAOUT
comma
l_string|&quot;DATAOUT&quot;
)brace
comma
(brace
id|PHASE_DATAIN
comma
l_string|&quot;DATAIN&quot;
)brace
comma
(brace
id|PHASE_CMDOUT
comma
l_string|&quot;CMDOUT&quot;
)brace
comma
(brace
id|PHASE_STATIN
comma
l_string|&quot;STATIN&quot;
)brace
comma
(brace
id|PHASE_MSGOUT
comma
l_string|&quot;MSGOUT&quot;
)brace
comma
(brace
id|PHASE_MSGIN
comma
l_string|&quot;MSGIN&quot;
)brace
comma
(brace
id|PHASE_UNKNOWN
comma
l_string|&quot;UNKNOWN&quot;
)brace
)brace
suffix:semicolon
multiline_comment|/* &n; * Function : void NCR5380_print_phase(struct Scsi_Host *instance)&n; *&n; * Purpose : print the current SCSI phase for debugging purposes&n; *&n; * Input : instance - which NCR5380&n; */
DECL|function|NCR5380_print_phase
r_static
r_void
id|NCR5380_print_phase
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_int
id|i
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
id|status
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|SR_REQ
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : REQ not asserted, phase unknown.&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|phases
(braket
id|i
)braket
dot
id|value
op_ne
id|PHASE_UNKNOWN
)paren
op_logical_and
(paren
id|phases
(braket
id|i
)braket
dot
id|value
op_ne
(paren
id|status
op_amp
id|PHASE_MASK
)paren
)paren
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase %s&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|phases
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n; * We need to have our coroutine active given these constraints : &n; * 1.  The mutex flag, main_running, can only be set when the main &n; *     routine can actually process data, otherwise SCSI commands&n; *     will never get issued.&n; *&n; * 2.  NCR5380_main() shouldn&squot;t be called before it has exited, because&n; *     other drivers have had kernel stack overflows in similar&n; *     situations.&n; *&n; * 3.  We don&squot;t want to inline NCR5380_main() because of space concerns,&n; *     even though it is only called in two places.&n; *&n; * So, the solution is to set the mutex in an inline wrapper for the &n; * main coroutine, and have the main coroutine exit with interrupts &n; * disabled after the final search through the queues so that no race &n; * conditions are possible.&n; */
DECL|variable|main_running
r_static
r_volatile
r_int
id|main_running
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n; * Function : run_main(void)&n; * &n; * Purpose : insure that the coroutine is running and will process our &n; * &t;request.  main_running is checked/set here (in an inline function)&n; *&t;rather than in NCR5380_main itself to reduce the chances of stack&n; *&t;overflow.&n; *&n; */
DECL|function|run_main
r_static
id|__inline__
r_void
id|run_main
c_func
(paren
r_void
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|main_running
)paren
(brace
id|main_running
op_assign
l_int|1
suffix:semicolon
id|NCR5380_main
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;         * main_running is cleared in NCR5380_main once it can&squot;t do &n;&t; * more work, and NCR5380_main exits with interrupts disabled.&n;&t; */
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef USLEEP
macro_line|#ifndef NCR5380_TIMER
macro_line|#error &quot;NCR5380_TIMER must be defined so that this type of NCR5380 driver gets a unique timer.&quot;
macro_line|#endif
multiline_comment|/*&n; * These need tweaking, and would probably work best as per-device &n; * flags initialized differently for disk, tape, cd, etc devices.&n; * People with broken devices are free to experiment as to what gives&n; * the best results for them.&n; *&n; * USLEEP_SLEEP should be a minimum seek time.&n; *&n; * USLEEP_POLL should be a maximum rotational latency.&n; */
macro_line|#ifndef USLEEP_SLEEP
multiline_comment|/* 20 ms (reasonable hard disk speed) */
DECL|macro|USLEEP_SLEEP
mdefine_line|#define USLEEP_SLEEP 2
macro_line|#endif
multiline_comment|/* 300 RPM (floppy speed) */
macro_line|#ifndef USLEEP_POLL
DECL|macro|USLEEP_POLL
mdefine_line|#define USLEEP_POLL 20
macro_line|#endif
DECL|variable|expires_first
r_static
r_struct
id|Scsi_Host
op_star
id|expires_first
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* &n; * Function : int should_disconnect (unsigned char cmd)&n; *&n; * Purpose : decide weather a command would normally disconnect or &n; *&t;not, since if it won&squot;t disconnect we should go to sleep.&n; *&n; * Input : cmd - opcode of SCSI command&n; *&n; * Returns : DISCONNECT_LONG if we should disconnect for a really long &n; * &t;time (ie always, sleep, look for REQ active, sleep), &n; *&t;DISCONNECT_TIME_TO_DATA if we would only disconnect for a normal&n; * &t;time-to-data delay, DISCONNECT_NONE if this command would return&n; * &t;immediately.&n; *&n; *      Future sleep algorithms based on time to data can exploit &n; *      something like this so they can differentiate between &quot;normal&quot; &n; *&t;(ie, read, write, seek) and unusual commands (ie, * format).&n; *&n; * Note : We don&squot;t deal with commands that handle an immediate disconnect,&n; *        &n; */
DECL|function|should_disconnect
r_static
r_int
id|should_disconnect
(paren
r_int
r_char
id|cmd
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|READ_6
suffix:colon
r_case
id|WRITE_6
suffix:colon
r_case
id|SEEK_6
suffix:colon
r_case
id|READ_10
suffix:colon
r_case
id|WRITE_10
suffix:colon
r_case
id|SEEK_10
suffix:colon
r_return
id|DISCONNECT_TIME_TO_DATA
suffix:semicolon
r_case
id|FORMAT_UNIT
suffix:colon
r_case
id|SEARCH_HIGH
suffix:colon
r_case
id|SEARCH_LOW
suffix:colon
r_case
id|SEARCH_EQUAL
suffix:colon
r_return
id|DISCONNECT_LONG
suffix:semicolon
r_default
suffix:colon
r_return
id|DISCONNECT_NONE
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Assumes instance-&gt;time_expires has been set in higher level code.&n; */
DECL|function|NCR5380_set_timer
r_static
r_int
id|NCR5380_set_timer
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|tmp
comma
op_star
op_star
id|prev
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
(paren
id|instance-&gt;host_data
)paren
)paren
op_member_access_from_pointer
id|next_timer
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|prev
op_assign
op_amp
id|expires_first
comma
id|tmp
op_assign
id|expires_first
suffix:semicolon
id|tmp
suffix:semicolon
id|prev
op_assign
op_amp
(paren
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|tmp-&gt;host_data
)paren
op_member_access_from_pointer
id|next_timer
)paren
comma
id|tmp
op_assign
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|tmp-&gt;host_data
)paren
op_member_access_from_pointer
id|next_timer
)paren
r_if
c_cond
(paren
id|instance-&gt;time_expires
OL
id|tmp-&gt;time_expires
)paren
r_break
suffix:semicolon
id|instance-&gt;next_timer
op_assign
id|tmp
suffix:semicolon
op_star
id|prev
op_assign
id|instance
suffix:semicolon
id|timer_table
(braket
id|NCR5380_TIMER
)braket
dot
id|expires
op_assign
id|expires_first-&gt;time_expires
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|NCR5380_TIMER
suffix:semicolon
id|sti
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Doing something about unwanted reentrancy here might be useful */
DECL|function|NCR5380_timer_fn
r_void
id|NCR5380_timer_fn
c_func
(paren
r_void
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|expires_first
op_logical_and
id|expires_first-&gt;time_expires
op_ge
id|jiffies
suffix:semicolon
)paren
(brace
id|instance
op_assign
(paren
(paren
id|NCR5380_hostdata
op_star
)paren
id|expires_first-&gt;host_data
)paren
op_member_access_from_pointer
id|expires_next
suffix:semicolon
(paren
(paren
id|NCR5380_hostdata
op_star
)paren
id|expires_first-&gt;host_data
)paren
op_member_access_from_pointer
id|expires_next
op_assign
l_int|NULL
suffix:semicolon
(paren
(paren
id|NCR5380_hostdata
op_star
)paren
id|expires_first-&gt;host_data
)paren
op_member_access_from_pointer
id|time_expires
op_assign
l_int|0
suffix:semicolon
id|expires_first
op_assign
id|instance
suffix:semicolon
)brace
r_if
c_cond
(paren
id|expires_first
)paren
(brace
id|timer_table
(braket
id|NCR5380_TIMER
)braket
dot
id|expires
op_assign
(paren
(paren
id|NCR5380_hostdata
op_star
)paren
id|expires_first-&gt;host_data
)paren
op_member_access_from_pointer
id|time_expires
suffix:semicolon
id|timer_active
op_or_assign
(paren
l_int|1
op_lshift
id|NCR5380_TIMER
)paren
suffix:semicolon
)brace
r_else
(brace
id|timer_table
(braket
id|NCR5380_TIMER
)braket
dot
id|expires
op_assign
l_int|0
suffix:semicolon
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|MCR5380_TIMER
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|run_main
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* def USLEEP */
DECL|function|NCR5380_all_init
r_static
r_void
id|NCR5380_all_init
(paren
r_void
)paren
(brace
r_static
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_INIT)
id|printk
c_func
(paren
l_string|&quot;scsi : NCR5380_all_init()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|done
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef USLEEP
id|timer_table
(braket
id|NCR5380_TIMER
)braket
dot
id|expires
op_assign
l_int|0
suffix:semicolon
id|timer_table
(braket
id|NCR5380_TIMER
)braket
dot
id|fn
op_assign
id|NCR5380_timer_fn
suffix:semicolon
macro_line|#endif
)brace
)brace
macro_line|#ifdef AUTOPROBE_IRQ
multiline_comment|/*&n; * Function : int NCR5380_probe_irq (struct Scsi_Host *instance, int possible)&n; * &n; * Purpose : autoprobe for the IRQ line used by the NCR5380.  &n; *&n; * Inputs : instance - pointer to this instance of the NCR5380 driver,&n; *          possible - bitmask of permissible interrupts.&n; *&n; * Returns : number of the IRQ selected, IRQ_NONE if no interrupt fired.&n; * &n; * XXX no effort is made to deal with spurious interrupts. &n; */
DECL|variable|probe_irq
r_static
r_int
id|probe_irq
suffix:semicolon
DECL|function|probe_intr
r_static
r_void
id|probe_intr
(paren
r_int
id|sig
)paren
(brace
id|probe_irq
op_assign
id|sig
suffix:semicolon
)brace
suffix:semicolon
DECL|function|NCR5380_probe_irq
r_static
r_int
id|NCR5380_probe_irq
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
id|possible
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_int
id|trying_irqs
comma
id|i
comma
id|mask
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
r_for
c_loop
(paren
id|trying_irqs
op_assign
id|i
op_assign
l_int|0
comma
id|mask
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
comma
id|mask
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|possible
)paren
op_logical_and
(paren
id|request_irq
c_func
(paren
id|i
comma
op_amp
id|probe_intr
comma
id|SA_INTERRUPT
comma
l_string|&quot;NCR-probe&quot;
)paren
op_eq
l_int|0
)paren
)paren
id|trying_irqs
op_or_assign
id|mask
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
l_int|25
suffix:semicolon
id|probe_irq
op_assign
id|IRQ_NONE
suffix:semicolon
multiline_comment|/*&n; * A interrupt is triggered whenever BSY = false, SEL = true&n; * and a bit set in the SELECT_ENABLE_REG is asserted on the &n; * SCSI bus.&n; *&n; * Note that the bus is only driven when the phase control signals&n; * (I/O, C/D, and MSG) match those in the TCR, so we must reset that&n; * to zero.&n; */
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
l_int|0
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|OUTPUT_DATA_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
op_or
id|ICR_ASSERT_SEL
)paren
suffix:semicolon
r_while
c_loop
(paren
id|probe_irq
op_eq
id|IRQ_NONE
op_logical_and
id|jiffies
OL
id|timeout
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
l_int|0
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mask
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
comma
id|mask
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|trying_irqs
op_amp
id|mask
)paren
id|free_irq
c_func
(paren
id|i
)paren
suffix:semicolon
r_return
id|probe_irq
suffix:semicolon
)brace
macro_line|#endif /* AUTOPROBE_IRQ */
multiline_comment|/*&n; * Function : void NCR58380_print_options (struct Scsi_Host *instance)&n; *&n; * Purpose : called by probe code indicating the NCR5380 driver&n; *&t;     options that were selected.&n; *&n; * Inputs : instance, pointer to this instance.  Unused.&n; */
DECL|function|NCR5380_print_options
r_static
r_void
id|NCR5380_print_options
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; generic options&quot;
macro_line|#ifdef AUTOPROBE_IRQ
l_string|&quot; AUTOPROBE_IRQ&quot;
macro_line|#endif
macro_line|#ifdef AUTOSENSE 
l_string|&quot; AUTOSENSE&quot;
macro_line|#endif
macro_line|#ifdef DIFFERENTIAL
l_string|&quot; DIFFERENTIAL&quot;
macro_line|#endif
macro_line|#ifdef REAL_DMA
l_string|&quot; REAL DMA&quot;
macro_line|#endif
macro_line|#ifdef REAL_DMA_POLL
l_string|&quot; REAL DMA POLL&quot;
macro_line|#endif
macro_line|#ifdef PARITY
l_string|&quot; PARITY&quot;
macro_line|#endif
macro_line|#ifdef PSEUDO_DMA
l_string|&quot; PSEUDO DMA&quot;
macro_line|#endif
macro_line|#ifdef SCSI2
l_string|&quot; SCSI-2&quot;
macro_line|#endif
macro_line|#ifdef UNSAFE
l_string|&quot; UNSAFE &quot;
macro_line|#endif
)paren
suffix:semicolon
macro_line|#ifdef USLEEP
id|printk
c_func
(paren
l_string|&quot; USLEEP, USLEEP_POLL=%d USLEEP_SLEEP=%d&quot;
comma
id|USLEEP_POLL
comma
id|USLEEP_SLEEP
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot; generic release=%d&quot;
comma
id|NCR5380_PUBLIC_RELEASE
)paren
suffix:semicolon
macro_line|#ifdef NCR53C400
r_if
c_cond
(paren
id|hostdata-&gt;flags
op_amp
id|FLAG_NCR53C400
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; ncr53c400 release=%d&quot;
comma
id|NCR53C400_PUBLIC_RELEASE
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * Function : void NCR5380_print_status (struct Scsi_Host *instance)&n; *&n; * Purpose : print commands in the various queues, called from&n; *&t;NCR5380_abort and NCR5380_debug to aid debugging.&n; *&n; * Inputs : instance, pointer to this instance.  &n; */
DECL|function|NCR5380_print_status
r_static
r_void
id|NCR5380_print_status
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|Scsi_Cmnd
op_star
id|ptr
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NCR5380 : coroutine is%s running.&bslash;n&quot;
comma
id|main_running
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;n&squot;t&quot;
)paren
suffix:semicolon
macro_line|#ifdef NDEBUG
id|NCR5380_print
(paren
id|instance
)paren
suffix:semicolon
id|NCR5380_print_phase
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;connected
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d: no currently connected command&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
)brace
r_else
(brace
id|print_Scsi_Cmnd
(paren
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;connected
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;scsi%d: issue_queue&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|ptr
suffix:semicolon
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
)paren
id|print_Scsi_Cmnd
(paren
id|ptr
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d: disconnected_queue&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_queue
suffix:semicolon
id|ptr
suffix:semicolon
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
)paren
id|print_Scsi_Cmnd
(paren
id|ptr
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : void NCR5380_init (struct Scsi_Host *instance, flags)&n; *&n; * Purpose : initializes *instance and corresponding 5380 chip,&n; *&t;with flags OR&squot;d into the initial flags value.&n; *&n; * Inputs : instance - instantiation of the 5380 driver.  &n; *&n; * Notes : I assume that the host, hostno, and id bits have been&n; * &t;set correctly.  I don&squot;t care about the irq and other fields. &n; * &n; */
DECL|function|NCR5380_init
r_static
r_void
id|NCR5380_init
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
id|flags
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
multiline_comment|/* &n;     * On NCR53C400 boards, NCR5380 registers are mapped 8 past &n;     * the base address.&n;     */
r_if
c_cond
(paren
id|flags
op_amp
id|FLAG_NCR53C400
)paren
id|instance-&gt;io_port
op_add_assign
l_int|8
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
id|NCR5380_all_init
c_func
(paren
)paren
suffix:semicolon
id|hostdata-&gt;aborted
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;id_mask
op_assign
l_int|1
op_lshift
id|instance-&gt;this_id
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|hostdata-&gt;id_mask
suffix:semicolon
id|i
op_le
l_int|0x80
suffix:semicolon
id|i
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|i
OG
id|hostdata-&gt;id_mask
)paren
id|hostdata-&gt;id_higher_mask
op_or_assign
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
id|hostdata-&gt;busy
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef REAL_DMA
id|hostdata-&gt;dmalen
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;targets_present
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;issue_queue
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;disconnected_queue
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;flags
op_assign
id|FLAG_CHECK_LAST_BYTE_SENT
op_or
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|the_template
)paren
(brace
id|the_template
op_assign
id|instance-&gt;hostt
suffix:semicolon
id|first_instance
op_assign
id|instance
suffix:semicolon
)brace
macro_line|#ifdef USLEEP
id|hostdata-&gt;time_expires
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;next_timer
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
macro_line|#ifndef AUTOSENSE
r_if
c_cond
(paren
(paren
id|instance-&gt;cmd_per_lun
OG
l_int|1
)paren
op_logical_or
id|instance-&gt;can_queue
OG
l_int|1
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : WARNING : support for multiple outstanding commands enabled&bslash;n&quot;
l_string|&quot;         without AUTOSENSE option, contingent allegiance conditions may&bslash;n&quot;
l_string|&quot;         be incorrectly cleared.&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif /* def AUTOSENSE */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
l_int|0
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef NCR53C400
r_if
c_cond
(paren
id|hostdata-&gt;flags
op_amp
id|FLAG_NCR53C400
)paren
(brace
id|NCR5380_write
c_func
(paren
id|C400_CONTROL_STATUS_REG
comma
id|CSR_BASE
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/* &n; * Function : int NCR5380_queue_command (Scsi_Cmnd *cmd, &n; *&t;void (*done)(Scsi_Cmnd *)) &n; *&n; * Purpose :  enqueues a SCSI command&n; *&n; * Inputs : cmd - SCSI command, done - function called on completion, with&n; *&t;a pointer to the command descriptor.&n; * &n; * Returns : 0&n; *&n; * Side effects : &n; *      cmd is added to the per instance issue_queue, with minor &n; *&t;twiddling done to the host specific fields of cmd.  If the &n; *&t;main coroutine is not running, it is restarted.&n; *&n; */
multiline_comment|/* Only make static if a wrapper function is used */
macro_line|#ifndef NCR5380_queue_command
r_static
macro_line|#endif
DECL|function|NCR5380_queue_command
r_int
id|NCR5380_queue_command
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
id|Scsi_Cmnd
op_star
id|tmp
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_NO_WRITE)
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|WRITE
suffix:colon
r_case
id|WRITE_10
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : WRITE attempted with NO_WRITE debugging flag set&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* (NDEBUG &amp; NDEBUG_NO_WRITE) */
multiline_comment|/* &n;     * We use the host_scribble field as a pointer to the next command  &n;     * in a queue &n;     */
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;     * Insert the cmd into the issue queue. Note that REQUEST SENSE &n;     * commands are added to the head of the queue since any command will&n;     * clear the contingent allegiance condition that exists and the &n;     * sense data is only guaranteed to be valid while the condition exists.&n;     */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;issue_queue
)paren
op_logical_or
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
)paren
(brace
id|cmd-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|hostdata-&gt;issue_queue
op_assign
id|cmd
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|tmp-&gt;host_scribble
suffix:semicolon
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
suffix:semicolon
id|tmp-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|cmd
suffix:semicolon
)brace
macro_line|#if (NDEBUG &amp; NDEBUG_QUEUES)
id|printk
c_func
(paren
l_string|&quot;scsi%d : command added to %s of queue&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
ques
c_cond
l_string|&quot;head&quot;
suffix:colon
l_string|&quot;tail&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Run the coroutine if it isn&squot;t already running. */
id|run_main
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : NCR5380_main (void) &n; *&n; * Purpose : NCR5380_main is a coroutine that runs as long as more work can &n; *&t;be done on the NCR5380 host adapters in a system.  Both &n; *&t;NCR5380_queue_command() and NCR5380_intr() will try to start it &n; *&t;in case it is not running.&n; * &n; * NOTE : NCR5380_main exits with interrupts *disabled*, the caller should &n; *  reenable them.  This prevents reentrancy and kernel stack overflow.&n; */
DECL|function|NCR5380_main
r_static
r_void
id|NCR5380_main
(paren
r_void
)paren
(brace
id|Scsi_Cmnd
op_star
id|tmp
comma
op_star
id|prev
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
suffix:semicolon
r_int
id|done
suffix:semicolon
multiline_comment|/*&n;     * We run (with interrupts disabled) until we&squot;re sure that none of &n;     * the host adapters have anything that can be done, at which point &n;     * we set main_running to 0 and exit.&n;     *&n;     * Interrupts are enabled before doing various other internal &n;     * instructions, after we&squot;ve decided that we need to run through&n;     * the loop again.&n;     *&n;     * this should prevent any race conditions.&n;     */
r_do
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Freeze request queues */
id|done
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|instance
op_assign
id|first_instance
suffix:semicolon
id|instance
op_logical_and
id|instance-&gt;hostt
op_eq
id|the_template
suffix:semicolon
id|instance
op_assign
id|instance-&gt;next
)paren
(brace
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;connected
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_MAIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d : not connected&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Search through the issue_queue for a command destined&n;&t;&t; * for a target that&squot;s not busy.&n;&t;&t; */
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
comma
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|tmp
suffix:semicolon
id|prev
op_assign
id|tmp
comma
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
multiline_comment|/*  When we find one, remove it from the issue queue. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;busy
(braket
id|tmp-&gt;target
)braket
op_amp
(paren
l_int|1
op_lshift
id|tmp-&gt;lun
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;host_scribble
op_assign
id|tmp-&gt;host_scribble
suffix:semicolon
r_else
id|hostdata-&gt;issue_queue
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
suffix:semicolon
id|tmp-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* reenable interrupts after finding one */
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; * Attempt to establish an I_T_L nexus here. &n;&t;&t;&t; * On success, instance-&gt;hostdata-&gt;connected is set.&n;&t;&t;&t; * On failure, we must add the command back to the&n;&t;&t;&t; *   issue queue so we can keep trying.&t;&n;&t;&t;&t; */
macro_line|#if (NDEBUG &amp; (NDEBUG_MAIN | NDEBUG_QUEUES))
id|printk
c_func
(paren
l_string|&quot;scsi%d : main() : command for target %d lun %d removed from issue_queue&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|tmp-&gt;target
comma
id|tmp-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;    &t;&t;&t; * REQUEST SENSE commands are issued without tagged&n;    &t;&t;&t; * queueing, even on SCSI-II devices because the &n;    &t;&t;&t; * contingent allegiance condition exists for the &n;    &t;&t;&t; * entire unit.&n;    &t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|NCR5380_select
c_func
(paren
id|instance
comma
id|tmp
comma
(paren
id|tmp-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
ques
c_cond
id|TAG_NONE
suffix:colon
id|TAG_NEXT
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_else
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|tmp-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|hostdata-&gt;issue_queue
op_assign
id|tmp
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; (NDEBUG_MAIN | NDEBUG_QUEUES))
id|printk
c_func
(paren
l_string|&quot;scsi%d : main(): select() failed, returned to issue_queue&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/* if target/lun is not busy */
)brace
multiline_comment|/* if (!hostdata-&gt;connected) */
r_if
c_cond
(paren
id|hostdata-&gt;connected
macro_line|#ifdef REAL_DMA
op_logical_and
op_logical_neg
id|hostdata-&gt;dmalen
macro_line|#endif
macro_line|#ifdef USLEEP
op_logical_and
(paren
op_logical_neg
id|hostdata-&gt;time_expires
op_logical_or
id|hostdata-&gt;time_expires
op_ge
id|jiffies
)paren
macro_line|#endif
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_MAIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d : main() : performing information transfer&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_information_transfer
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_MAIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d : main() : done set false&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|done
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
multiline_comment|/* for instance */
)brace
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
suffix:semicolon
id|main_running
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : void NCR5380_intr (int irq)&n; * &n; * Purpose : handle interrupts, reestablishing I_T_L or I_T_L_Q nexuses&n; *&t;from the disconnected queue, and restarting NCR5380_main() &n; *&t;as required.&n; *&n; * Inputs : int irq, irq that caused this interrupt.&n; *&n; */
DECL|function|NCR5380_intr
r_static
r_void
id|NCR5380_intr
(paren
r_int
id|irq
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_int
id|done
suffix:semicolon
r_int
r_char
id|basr
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_INTR)
id|printk
c_func
(paren
l_string|&quot;scsi : NCR5380 irq %d triggered&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
r_do
(brace
id|done
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|instance
op_assign
id|first_instance
suffix:semicolon
id|instance
op_logical_and
(paren
id|instance-&gt;hostt
op_eq
id|the_template
)paren
suffix:semicolon
id|instance
op_assign
id|instance-&gt;next
)paren
r_if
c_cond
(paren
id|instance-&gt;irq
op_eq
id|irq
)paren
(brace
multiline_comment|/* Look for pending interrupts */
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
id|basr
op_assign
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
suffix:semicolon
multiline_comment|/* XXX dispatch to appropriate routine if found and done=0 */
r_if
c_cond
(paren
id|basr
op_amp
id|BASR_IRQ
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_INTR)
id|NCR5380_print
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
(paren
id|SR_SEL
op_or
id|SR_IO
)paren
)paren
op_eq
(paren
id|SR_SEL
op_or
id|SR_IO
)paren
)paren
(brace
id|done
op_assign
l_int|0
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_INTR)
id|printk
c_func
(paren
l_string|&quot;scsi%d : SEL interrupt&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_reselect
c_func
(paren
id|instance
)paren
suffix:semicolon
(paren
r_void
)paren
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|basr
op_amp
id|BASR_PARITY_ERROR
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_INTR)
id|printk
c_func
(paren
l_string|&quot;scsi%d : PARITY interrupt&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
(paren
r_void
)paren
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_RST
)paren
op_eq
id|SR_RST
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_INTR)
id|printk
c_func
(paren
l_string|&quot;scsi%d : RESET interrupt&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
(paren
r_void
)paren
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  &n; * XXX the rest of the interrupt conditions should *only* occur during a &n; * DMA transfer, which I haven&squot;t gotten around to fixing yet.&n; */
macro_line|#if defined(REAL_DMA)
multiline_comment|/*&n;&t;&t;     * We should only get PHASE MISMATCH and EOP interrupts&n;&t;&t;     * if we have DMA enabled, so do a sanity check based on&n;&t;&t;     * the current setting of the MODE register.&n;&t;&t;     */
r_if
c_cond
(paren
(paren
id|NCR5380_read
c_func
(paren
id|MODE_REG
)paren
op_amp
id|MR_DMA
)paren
op_logical_and
(paren
(paren
id|basr
op_amp
id|BASR_END_DMA_TRANSFER
)paren
op_logical_or
op_logical_neg
(paren
id|basr
op_amp
id|BASR_PHASE_MATCH
)paren
)paren
)paren
(brace
r_int
id|transfered
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;connected
)paren
id|panic
c_func
(paren
l_string|&quot;scsi%d : received end of DMA interrupt with no connected cmd&bslash;n&quot;
comma
id|instance-&gt;hostno
)paren
suffix:semicolon
id|transfered
op_assign
(paren
id|hostdata-&gt;dmalen
op_minus
id|NCR5380_dma_residual
c_func
(paren
id|instance
)paren
)paren
suffix:semicolon
id|hostdata-&gt;connected-&gt;SCp.this_residual
op_sub_assign
id|transferred
suffix:semicolon
id|hostdata-&gt;connected-&gt;SCp.ptr
op_add_assign
id|transferred
suffix:semicolon
id|hostdata-&gt;dmalen
op_assign
l_int|0
suffix:semicolon
(paren
r_void
)paren
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
macro_line|#if NCR_TIMEOUT
(brace
r_int
r_int
id|timeout
op_assign
id|jiffies
op_plus
id|NCR_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_ACK
op_logical_and
id|jiffies
OL
id|timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
op_ge
id|timeout
)paren
id|printk
c_func
(paren
l_string|&quot;scsi: timeout at %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
)brace
macro_line|#else /* NCR_TIMEOUT */
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_ACK
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
)brace
macro_line|#else
macro_line|#if (NDEBUG &amp; NDEBUG_INTR)
id|printk
c_func
(paren
l_string|&quot;scsi : unknown interrupt, BASR 0x%X, MR 0x%X, SR 0x%x&bslash;n&quot;
comma
id|basr
comma
id|NCR5380_read
c_func
(paren
id|MODE_REG
)paren
comma
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
suffix:semicolon
macro_line|#endif
(paren
r_void
)paren
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/* if BASR_IRQ */
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
id|run_main
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* if (instance-&gt;irq == irq) */
)brace
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : int NCR5380_select (struct Scsi_Host *instance, Scsi_Cmnd *cmd, &n; *&t;int tag);&n; *&n; * Purpose : establishes I_T_L or I_T_L_Q nexus for new or existing command,&n; *&t;including ARBITRATION, SELECTION, and initial message out for &n; *&t;IDENTIFY and queue messages. &n; *&n; * Inputs : instance - instantiation of the 5380 driver on which this &n; * &t;target lives, cmd - SCSI command to execute, tag - set to TAG_NEXT for &n; *&t;new tag, TAG_NONE for untagged queueing, otherwise set to the tag for &n; *&t;the command that is presently connected.&n; * &n; * Returns : -1 if selection could not execute for some reason,&n; *&t;0 if selection succeeded or failed because the target &n; * &t;did not respond.&n; *&n; * Side effects : &n; * &t;If bus busy, arbitration failed, etc, NCR5380_select() will exit &n; *&t;&t;with registers as they should have been on entry - ie&n; *&t;&t;SELECT_ENABLE will be set appropriately, the NCR5380&n; *&t;&t;will cease to drive any SCSI bus signals.&n; *&n; *&t;If successful : I_T_L or I_T_L_Q nexus will be established, &n; *&t;&t;instance-&gt;connected will be set to cmd.  &n; * &t;&t;SELECT interrupt will be disabled.&n; *&n; *&t;If failed (no target) : cmd-&gt;scsi_done() will be called, and the &n; *&t;&t;cmd-&gt;result host byte set to DID_BAD_TARGET.&n; */
DECL|function|NCR5380_select
r_static
r_int
id|NCR5380_select
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|tag
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
r_int
r_char
id|tmp
(braket
l_int|3
)braket
comma
id|phase
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
id|hostdata-&gt;restart_select
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined (NDEBUG) &amp;&amp; (NDEBUG &amp; NDEBUG_ARBITRATION) 
id|NCR5380_print
c_func
(paren
id|instance
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : starting arbitration, id = %d&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|instance-&gt;this_id
)paren
suffix:semicolon
macro_line|#endif
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;     * Set the phase bits to 0, otherwise the NCR5380 won&squot;t drive the &n;     * data bus during SELECTION.&n;     */
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;     * Start arbitration.&n;     */
id|NCR5380_write
c_func
(paren
id|OUTPUT_DATA_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_ARBITRATE
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Wait for arbitration logic to complete */
macro_line|#if NCR_TIMEOUT
(brace
r_int
r_int
id|timeout
op_assign
id|jiffies
op_plus
l_int|2
op_star
id|NCR_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|INITIATOR_COMMAND_REG
)paren
op_amp
id|ICR_ARBITRATION_PROGRESS
)paren
op_logical_and
id|jiffies
OL
id|timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
op_ge
id|timeout
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: arbitration timeout at %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#else /* NCR_TIMEOUT */
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|INITIATOR_COMMAND_REG
)paren
op_amp
id|ICR_ARBITRATION_PROGRESS
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if (NDEBUG &amp; NDEBUG_ARBITRATION) 
id|printk
c_func
(paren
l_string|&quot;scsi%d : arbitration complete&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
multiline_comment|/* Avoid GCC 2.4.5 asm needs to many reloads error */
id|__asm__
c_func
(paren
l_string|&quot;nop&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;     * The arbitration delay is 2.2us, but this is a minimum and there is &n;     * no maximum so we can safely sleep for ceil(2.2) usecs to accommodate&n;     * the integral nature of udelay().&n;     *&n;     */
id|udelay
c_func
(paren
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Check for lost arbitration */
r_if
c_cond
(paren
(paren
id|NCR5380_read
c_func
(paren
id|INITIATOR_COMMAND_REG
)paren
op_amp
id|ICR_ARBITRATION_LOST
)paren
op_logical_or
(paren
id|NCR5380_read
c_func
(paren
id|CURRENT_SCSI_DATA_REG
)paren
op_amp
id|hostdata-&gt;id_higher_mask
)paren
op_logical_or
(paren
id|NCR5380_read
c_func
(paren
id|INITIATOR_COMMAND_REG
)paren
op_amp
id|ICR_ARBITRATION_LOST
)paren
)paren
(brace
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_ARBITRATION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : lost arbitration, deasserting MR_ARBITRATE&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_SEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NCR5380_read
c_func
(paren
id|INITIATOR_COMMAND_REG
)paren
op_amp
id|ICR_ARBITRATION_LOST
)paren
(brace
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_ARBITRATION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : lost arbitration, deasserting ICR_ASSERT_SEL&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n;     * Again, bus clear + bus settle time is 1.2us, however, this is &n;     * a minimum so we&squot;ll udelay ceil(1.2)&n;     */
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_ARBITRATION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : won arbitration&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;     * Now that we have won arbitration, start Selection process, asserting &n;     * the host and target ID&squot;s on the SCSI bus.&n;     */
id|NCR5380_write
c_func
(paren
id|OUTPUT_DATA_REG
comma
(paren
id|hostdata-&gt;id_mask
op_or
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;     * Raise ATN while SEL is true before BSY goes false from arbitration,&n;     * since this is the only way to guarantee that we&squot;ll get a MESSAGE OUT&n;     * phase immediately after selection.&n;     */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
(paren
id|ICR_BASE
op_or
id|ICR_ASSERT_BSY
op_or
id|ICR_ASSERT_DATA
op_or
id|ICR_ASSERT_ATN
op_or
id|ICR_ASSERT_SEL
)paren
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
multiline_comment|/* &n;     * Reselect interrupts must be turned off prior to the dropping of BSY,&n;     * otherwise we will trigger an interrupt.&n;     */
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Reset BSY */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
(paren
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
op_or
id|ICR_ASSERT_ATN
op_or
id|ICR_ASSERT_SEL
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;     * Something weird happens when we cease to drive BSY - looks&n;     * like the board/chip is letting us do another read before the &n;     * appropriate propagation delay has expired, and we&squot;re confusing&n;     * a BSY signal from ourselves as the target&squot;s response to SELECTION.&n;     *&n;     * A small delay (the &squot;C++&squot; frontend breaks the pipeline with an&n;     * unnecessary jump, making it work on my 386-33/Trantor T128, the&n;     * tighter &squot;C&squot; code breaks and requires this) solves the problem - &n;     * the 1 us delay is arbitrary, and only used because this delay will &n;     * be the same on other platforms and since it works here, it should &n;     * work there.&n;     */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_SELECTION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : selecting target %d&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;target
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;     * The SCSI specification calls for a 250 ms timeout for the actual &n;     * selection.&n;     */
id|timeout
op_assign
id|jiffies
op_plus
l_int|25
suffix:semicolon
multiline_comment|/* &n;     * XXX very interesting - we&squot;re seeing a bounce where the BSY we &n;     * asserted is being reflected / still asserted (propagation delay?)&n;     * and it&squot;s detecting as true.  Sigh.&n;     */
r_while
c_loop
(paren
(paren
id|jiffies
OL
id|timeout
)paren
op_logical_and
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
(paren
id|SR_BSY
op_or
id|SR_IO
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
(paren
id|SR_SEL
op_or
id|SR_IO
)paren
)paren
op_eq
(paren
id|SR_SEL
op_or
id|SR_IO
)paren
)paren
(brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|NCR5380_reselect
c_func
(paren
id|instance
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : reselection after won arbitration?&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_BSY
)paren
)paren
(brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;targets_present
op_amp
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : weirdness&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;restart_select
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;trestart select&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef NDEBUG
id|NCR5380_print
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|cmd-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_SELECTION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : target did not respond within 250ms&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|hostdata-&gt;targets_present
op_or_assign
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
suffix:semicolon
multiline_comment|/*&n;     * Since we followed the SCSI spec, and raised ATN while SEL &n;     * was true but before BSY was false during selection, the information&n;     * transfer phase should be a MESSAGE OUT phase so that we can send the&n;     * IDENTIFY message.&n;     * &n;     * If SCSI-II tagged queuing is enabled, we also send a SIMPLE_QUEUE_TAG&n;     * message (2 bytes) with a tag ID that we increment with every command&n;     * until it wraps back to 0.&n;     *&n;     * XXX - it turns out that there are some broken SCSI-II devices,&n;     *&t;     which claim to support tagged queuing but fail when more than&n;     *&t;     some number of commands are issued at once.&n;     */
multiline_comment|/* Wait for start of REQ/ACK handshake */
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_SELECTION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : target %d selected, going into MESSAGE OUT phase.&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;target
)paren
suffix:semicolon
macro_line|#endif
id|tmp
(braket
l_int|0
)braket
op_assign
id|IDENTIFY
c_func
(paren
(paren
(paren
id|instance-&gt;irq
op_eq
id|IRQ_NONE
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#ifdef SCSI2
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;tagged_queue
op_logical_and
(paren
id|tag
op_ne
id|TAG_NONE
)paren
)paren
(brace
id|tmp
(braket
l_int|1
)braket
op_assign
id|SIMPLE_QUEUE_TAG
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|TAG_NEXT
)paren
(brace
multiline_comment|/* 0 is TAG_NONE, used to imply no tag for this command */
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;current_tag
op_eq
l_int|0
)paren
id|cmd-&gt;device-&gt;current_tag
op_assign
l_int|1
suffix:semicolon
id|cmd-&gt;tag
op_assign
id|cmd-&gt;device-&gt;current_tag
suffix:semicolon
id|cmd-&gt;device-&gt;current_tag
op_increment
suffix:semicolon
)brace
r_else
id|cmd-&gt;tag
op_assign
(paren
r_int
r_char
)paren
id|tag
suffix:semicolon
id|tmp
(braket
l_int|2
)braket
op_assign
id|cmd-&gt;tag
suffix:semicolon
id|hostdata-&gt;last_message
op_assign
id|SIMPLE_QUEUE_TAG
suffix:semicolon
id|len
op_assign
l_int|3
suffix:semicolon
)brace
r_else
macro_line|#endif /* def SCSI2 */
(brace
id|len
op_assign
l_int|1
suffix:semicolon
id|cmd-&gt;tag
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Send message(s) */
id|data
op_assign
id|tmp
suffix:semicolon
id|phase
op_assign
id|PHASE_MSGOUT
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_SELECTION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : nexus established.&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* XXX need to handle errors here */
id|hostdata-&gt;connected
op_assign
id|cmd
suffix:semicolon
macro_line|#ifdef SCSI2
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;device-&gt;tagged_queue
)paren
macro_line|#endif    
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_or_assign
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|initialize_SCp
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : int NCR5380_transfer_pio (struct Scsi_Host *instance, &n; *      unsigned char *phase, int *count, unsigned char **data)&n; *&n; * Purpose : transfers data in given phase using polled I/O&n; *&n; * Inputs : instance - instance of driver, *phase - pointer to &n; *&t;what phase is expected, *count - pointer to number of &n; *&t;bytes to transfer, **data - pointer to data pointer.&n; * &n; * Returns : -1 when different phase is entered without transferring&n; *&t;maximum number of bytes, 0 if all bytes or transfered or exit&n; *&t;is in same phase.&n; *&n; * &t;Also, *phase, *count, *data are modified in place.&n; *&n; * XXX Note : handling for bus free may be useful.&n; */
multiline_comment|/*&n; * Note : this code is not as quick as it could be, however it &n; * IS 100% reliable, and for the actual data transfer where speed&n; * counts, we will always do a pseudo DMA or DMA transfer.&n; */
DECL|function|NCR5380_transfer_pio
r_static
r_int
id|NCR5380_transfer_pio
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
r_char
op_star
id|phase
comma
r_int
op_star
id|count
comma
r_int
r_char
op_star
op_star
id|data
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_register
r_int
r_char
id|p
op_assign
op_star
id|phase
comma
id|tmp
suffix:semicolon
r_register
r_int
id|c
op_assign
op_star
id|count
suffix:semicolon
r_register
r_int
r_char
op_star
id|d
op_assign
op_star
id|data
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
multiline_comment|/* &n;     * The NCR5380 chip will only drive the SCSI bus when the &n;     * phase specified in the appropriate bits of the TARGET COMMAND&n;     * REGISTER match the STATUS REGISTER&n;     */
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
id|PHASE_SR_TO_TCR
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* &n;&t; * Wait for assertion of REQ, after which the phase bits will be &n;&t; * valid &n;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|tmp
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
op_amp
id|SR_REQ
)paren
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_HANDSHAKE)
id|printk
c_func
(paren
l_string|&quot;scsi%d : REQ detected&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check for phase mismatch */
r_if
c_cond
(paren
(paren
id|tmp
op_amp
id|PHASE_MASK
)paren
op_ne
id|p
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_PIO)
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase mismatch&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|NCR5380_print_phase
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
multiline_comment|/* Do actual transfer from SCSI bus to / from memory */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_amp
id|SR_IO
)paren
)paren
id|NCR5380_write
c_func
(paren
id|OUTPUT_DATA_REG
comma
op_star
id|d
)paren
suffix:semicolon
r_else
op_star
id|d
op_assign
id|NCR5380_read
c_func
(paren
id|CURRENT_SCSI_DATA_REG
)paren
suffix:semicolon
op_increment
id|d
suffix:semicolon
multiline_comment|/* &n;&t; * The SCSI standard suggests that in MSGOUT phase, the initiator&n;&t; * should drop ATN on the last byte of the message phase&n;&t; * after REQ has been asserted for the handshake but before&n;&t; * the initiator raises ACK.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_amp
id|SR_IO
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|p
op_amp
id|SR_MSG
)paren
op_logical_and
id|c
OG
l_int|1
)paren
)paren
(brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_PIO)
id|NCR5380_print
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
op_or
id|ICR_ASSERT_ACK
)paren
suffix:semicolon
)brace
r_else
(brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_PIO)
id|NCR5380_print
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
op_or
id|ICR_ASSERT_ATN
op_or
id|ICR_ASSERT_ACK
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_PIO)
id|NCR5380_print
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ACK
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_HANDSHAKE)
id|printk
c_func
(paren
l_string|&quot;scsi%d : req false, handshake complete&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * We have several special cases to consider during REQ/ACK handshaking : &n; * 1.  We were in MSGOUT phase, and we are on the last byte of the &n; *&t;message.  ATN must be dropped as ACK is dropped.&n; *&n; * 2.  We are in a MSGIN phase, and we are on the last byte of the  &n; *&t;message.  We must exit with ACK asserted, so that the calling&n; *&t;code may raise ATN before dropping ACK to reject the message.&n; *&n; * 3.  ACK and ATN are clear and the target may proceed as normal.&n; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_eq
id|PHASE_MSGIN
op_logical_and
id|c
op_eq
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
id|PHASE_MSGOUT
op_logical_and
id|c
OG
l_int|1
)paren
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
r_else
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_decrement
id|c
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_PIO) 
id|printk
c_func
(paren
l_string|&quot;scsi%d : residual %d&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|c
)paren
suffix:semicolon
macro_line|#endif
op_star
id|count
op_assign
id|c
suffix:semicolon
op_star
id|data
op_assign
id|d
suffix:semicolon
id|tmp
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_amp
id|SR_REQ
)paren
op_star
id|phase
op_assign
id|tmp
op_amp
id|PHASE_MASK
suffix:semicolon
r_else
op_star
id|phase
op_assign
id|PHASE_UNKNOWN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
op_logical_or
(paren
op_star
id|phase
op_eq
id|p
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#if defined(REAL_DMA) || defined(PSEUDO_DMA) || defined (REAL_DMA_POLL)
multiline_comment|/* &n; * Function : int NCR5380_transfer_dma (struct Scsi_Host *instance, &n; *      unsigned char *phase, int *count, unsigned char **data)&n; *&n; * Purpose : transfers data in given phase using either real&n; *&t;or pseudo DMA.&n; *&n; * Inputs : instance - instance of driver, *phase - pointer to &n; *&t;what phase is expected, *count - pointer to number of &n; *&t;bytes to transfer, **data - pointer to data pointer.&n; * &n; * Returns : -1 when different phase is entered without transferring&n; *&t;maximum number of bytes, 0 if all bytes or transfered or exit&n; *&t;is in same phase.&n; *&n; * &t;Also, *phase, *count, *data are modified in place.&n; *&n; */
DECL|function|NCR5380_transfer_dma
r_static
r_int
id|NCR5380_transfer_dma
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
r_char
op_star
id|phase
comma
r_int
op_star
id|count
comma
r_int
r_char
op_star
op_star
id|data
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_register
r_int
id|c
op_assign
op_star
id|count
suffix:semicolon
r_register
r_int
r_char
id|p
op_assign
op_star
id|phase
suffix:semicolon
r_register
r_int
r_char
op_star
id|d
op_assign
op_star
id|data
suffix:semicolon
r_int
r_char
id|tmp
suffix:semicolon
r_int
id|foo
suffix:semicolon
macro_line|#if defined(REAL_DMA_POLL)
r_int
id|cnt
comma
id|toPIO
suffix:semicolon
r_int
r_char
id|saved_data
op_assign
l_int|0
comma
id|overrun
op_assign
l_int|0
comma
id|residue
suffix:semicolon
macro_line|#endif
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_assign
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|PHASE_MASK
)paren
)paren
op_ne
id|p
)paren
(brace
op_star
id|phase
op_assign
id|tmp
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#if defined(REAL_DMA) || defined(REAL_DMA_POLL) 
macro_line|#ifdef READ_OVERRUNS
r_if
c_cond
(paren
id|p
op_amp
id|SR_IO
)paren
(brace
id|c
op_sub_assign
l_int|2
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if (NDEBUG &amp; NDEBUG_DMA)
id|printk
c_func
(paren
l_string|&quot;scsi%d : initializing DMA channel %d for %s, %d bytes %s %0x&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|instance-&gt;dma_channel
comma
(paren
id|p
op_amp
id|SR_IO
)paren
ques
c_cond
l_string|&quot;reading&quot;
suffix:colon
l_string|&quot;writing&quot;
comma
id|c
comma
(paren
id|p
op_amp
id|SR_IO
)paren
ques
c_cond
l_string|&quot;to&quot;
suffix:colon
l_string|&quot;from&quot;
comma
(paren
r_int
)paren
id|d
)paren
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;dma_len
op_assign
(paren
id|p
op_amp
id|SR_IO
)paren
ques
c_cond
id|NCR5380_dma_read_setup
c_func
(paren
id|instance
comma
id|d
comma
id|c
)paren
suffix:colon
id|NCR5380_dma_write_setup
c_func
(paren
id|instance
comma
id|d
comma
id|c
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
id|PHASE_SR_TO_TCR
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
macro_line|#ifdef REAL_DMA
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
op_or
id|MR_DMA_MODE
op_or
id|MR_ENABLE_EOP_INTR
op_or
id|MR_MONITOR_BSY
)paren
suffix:semicolon
macro_line|#elif defined(REAL_DMA_POLL)
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
op_or
id|MR_DMA_MODE
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/*&n;     * Note : on my sample board, watch-dog timeouts occured when interrupts&n;     * were not disabled for the duration of a single DMA transfer, from &n;     * before the setting of DMA mode to after transfer of the last byte.&n;     */
macro_line|#if defined(PSEUDO_DMA) &amp;&amp; !defined(UNSAFE)
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
op_or
id|MR_DMA_MODE
)paren
suffix:semicolon
macro_line|#endif /* def REAL_DMA */
macro_line|#if (NDEBUG &amp; NDEBUG_DMA) &amp; 0
id|printk
c_func
(paren
l_string|&quot;scsi%d : mode reg = 0x%X&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|NCR5380_read
c_func
(paren
id|MODE_REG
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n; * FOO stuff. For some UNAPPARENT reason, I&squot;m getting &n; * watchdog timers fired on bootup for NO APPARENT REASON, meaning it&squot;s&n; * probably a timing problem.&n; *&n; * Since this is the only place I have back-to-back writes, perhaps this &n; * is the problem?&n; */
r_if
c_cond
(paren
id|p
op_amp
id|SR_IO
)paren
(brace
macro_line|#ifndef FOO
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|START_DMA_INITIATOR_RECEIVE_REG
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifndef FOO
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
)paren
suffix:semicolon
macro_line|#ifndef FOO
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|START_DMA_SEND_REG
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifndef FOO
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if defined(REAL_DMA_POLL)
r_do
(brace
id|tmp
op_assign
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|tmp
op_amp
id|BASR_PHASE_MATCH
)paren
op_logical_and
op_logical_neg
(paren
id|tmp
op_amp
(paren
id|BASR_BUSY_ERROR
op_or
id|BASR_END_DMA_TRANSFER
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;  At this point, either we&squot;ve completed DMA, or we have a phase mismatch,&n;  or we&squot;ve unexpectedly lost BUSY (which is a real error).&n;&n;  For write DMAs, we want to wait until the last byte has been&n;  transferred out over the bus before we turn off DMA mode.  Alas, there&n;  seems to be no terribly good way of doing this on a 5380 under all&n;  conditions.  For non-scatter-gather operations, we can wait until REQ&n;  and ACK both go false, or until a phase mismatch occurs.  Gather-writes&n;  are nastier, since the device will be expecting more data than we&n;  are prepared to send it, and REQ will remain asserted.  On a 53C8[01] we&n;  could test LAST BIT SENT to assure transfer (I imagine this is precisely&n;  why this signal was added to the newer chips) but on the older 538[01]&n;  this signal does not exist.  The workaround for this lack is a watchdog;&n;  we bail out of the wait-loop after a modest amount of wait-time if&n;  the usual exit conditions are not met.  Not a terribly clean or&n;  correct solution :-%&n;&n;  Reads are equally tricky due to a nasty characteristic of the NCR5380.&n;  If the chip is in DMA mode for an READ, it will respond to a target&squot;s&n;  REQ by latching the SCSI data into the INPUT DATA register and asserting&n;  ACK, even if it has _already_ been notified by the DMA controller that&n;  the current DMA transfer has completed!  If the NCR5380 is then taken&n;  out of DMA mode, this already-acknowledged byte is lost.&n;&n;  This is not a problem for &quot;one DMA transfer per command&quot; reads, because&n;  the situation will never arise... either all of the data is DMA&squot;ed&n;  properly, or the target switches to MESSAGE IN phase to signal a&n;  disconnection (either operation bringing the DMA to a clean halt).&n;  However, in order to handle scatter-reads, we must work around the&n;  problem.  The chosen fix is to DMA N-2 bytes, then check for the&n;  condition before taking the NCR5380 out of DMA mode.  One or two extra&n;  bytes are transferred via PIO as necessary to fill out the original&n;  request.&n;*/
r_if
c_cond
(paren
id|p
op_amp
id|SR_IO
)paren
(brace
macro_line|#ifdef READ_OVERRUNS
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
(paren
id|BASR_PHASE_MATCH
op_or
id|BASR_ACK
)paren
)paren
op_eq
(paren
id|BASR_PHASE_MATCH
op_or
id|BASR_ACK
)paren
)paren
)paren
(brace
id|saved_data
op_assign
id|NCR5380_read
c_func
(paren
id|INPUT_DATA_REGISTER
)paren
suffix:semicolon
id|overrun
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
(brace
r_int
id|limit
op_assign
l_int|100
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|tmp
op_assign
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
)paren
op_amp
id|BASR_ACK
)paren
op_logical_or
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp
op_amp
id|BASR_PHASE_MATCH
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|limit
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
macro_line|#if (NDEBUG &amp; NDEBUG_DMA)
id|printk
c_func
(paren
l_string|&quot;scsi%d : polled DMA transfer complete, basr 0x%X, sr 0x%X&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|tmp
comma
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|residue
op_assign
id|NCR5380_dma_residual
c_func
(paren
id|instance
)paren
suffix:semicolon
id|c
op_sub_assign
id|residue
suffix:semicolon
op_star
id|count
op_sub_assign
id|c
suffix:semicolon
op_star
id|data
op_add_assign
id|c
suffix:semicolon
op_star
id|phase
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|PHASE_MASK
suffix:semicolon
macro_line|#ifdef READ_OVERRUNS
r_if
c_cond
(paren
op_star
id|phase
op_eq
id|p
op_logical_and
(paren
id|p
op_amp
id|SR_IO
)paren
op_logical_and
id|residue
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|overrun
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_DMA)
id|printk
c_func
(paren
l_string|&quot;Got an input overrun, using saved byte&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
op_star
op_star
id|data
op_assign
id|saved_data
suffix:semicolon
op_star
id|data
op_add_assign
l_int|1
suffix:semicolon
op_star
id|count
op_sub_assign
l_int|1
suffix:semicolon
id|cnt
op_assign
id|toPIO
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;No overrun??&bslash;n&quot;
)paren
suffix:semicolon
id|cnt
op_assign
id|toPIO
op_assign
l_int|2
suffix:semicolon
)brace
macro_line|#if (NDEBUG &amp; NDEBUG_DMA)
id|printk
c_func
(paren
l_string|&quot;Doing %d-byte PIO to 0x%X&bslash;n&quot;
comma
id|cnt
comma
op_star
id|data
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
id|phase
comma
op_amp
id|cnt
comma
id|data
)paren
suffix:semicolon
op_star
id|count
op_sub_assign
id|toPIO
op_minus
id|cnt
suffix:semicolon
)brace
macro_line|#endif        
macro_line|#if (NDEBUG &amp; NDEBUG_DMA)
id|printk
c_func
(paren
l_string|&quot;Return with data ptr = 0x%X, count %d, last 0x%X, next 0x%X&bslash;n&quot;
comma
op_star
id|data
comma
op_star
id|count
comma
op_star
(paren
op_star
id|data
op_plus
op_star
id|count
op_minus
l_int|1
)paren
comma
op_star
(paren
op_star
id|data
op_plus
op_star
id|count
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
macro_line|#elif defined(REAL_DMA)
r_return
l_int|0
suffix:semicolon
macro_line|#else /* defined(REAL_DMA_POLL) */
r_if
c_cond
(paren
id|p
op_amp
id|SR_IO
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|foo
op_assign
id|NCR5380_pread
c_func
(paren
id|instance
comma
id|d
comma
id|c
op_minus
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;     * We can&squot;t disable DMA mode after successfully transferring &n;&t;     * what we plan to be the last byte, since that would open up&n;&t;     * a race condition where if the target asserted REQ before &n;&t;     * we got the DMA mode reset, the NCR5380 would have latched&n;&t;     * an additional byte into the INPUT DATA register and we&squot;d&n;&t;     * have dropped it.&n;&t;     * &n;&t;     * The workaround was to transfer one fewer bytes than we &n;&t;     * intended to with the pseudo-DMA read function, wait for &n;&t;     * the chip to latch the last byte, read it, and then disable&n;&t;     * pseudo-DMA mode.&n;&t;     * &n;&t;     * After REQ is asserted, the NCR5380 asserts DRQ and ACK.&n;&t;     * REQ is deasserted when ACK is asserted, and not reasserted&n;&t;     * until ACK goes false.  Since the NCR5380 won&squot;t lower ACK&n;&t;     * until DACK is asserted, which won&squot;t happen unless we twiddle&n;&t;     * the DMA port or we take the NCR5380 out of DMA mode, we &n;&t;     * can guarantee that we won&squot;t handshake another extra &n;&t;     * byte.&n;    &t;     */
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_DRQ
)paren
)paren
suffix:semicolon
multiline_comment|/* Wait for clean handshake */
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
suffix:semicolon
id|d
(braket
id|c
op_minus
l_int|1
)braket
op_assign
id|NCR5380_read
c_func
(paren
id|INPUT_DATA_REG
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|timeout
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|foo
op_assign
id|NCR5380_pwrite
c_func
(paren
id|instance
comma
id|d
comma
id|c
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;     * Wait for the last byte to be sent.  If REQ is being asserted for &n;&t;     * the byte we&squot;re interested, we&squot;ll ACK it and it will go false.  &n;&t;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;flags
op_amp
id|FLAG_HAS_LAST_BYTE_SENT
)paren
)paren
(brace
id|timeout
op_assign
l_int|20000
suffix:semicolon
macro_line|#if 1
macro_line|#if 1
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_DRQ
)paren
op_logical_and
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_PHASE_MATCH
)paren
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|timeout
op_logical_and
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_ACK
)paren
suffix:semicolon
op_decrement
id|timeout
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|timeout
op_logical_and
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
suffix:semicolon
op_decrement
id|timeout
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if (NDEBUG &amp; NDEBUG_LAST_BYTE_SENT)
r_if
c_cond
(paren
op_logical_neg
id|timeout
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : timed out on last byte&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|hostdata-&gt;flags
op_amp
id|FLAG_CHECK_LAST_BYTE_SENT
)paren
(brace
id|hostdata-&gt;flags
op_and_assign
op_complement
id|FLAG_CHECK_LAST_BYTE_SENT
suffix:semicolon
r_if
c_cond
(paren
id|NCR5380_read
c_func
(paren
id|TARGET_COMMAND_REG
)paren
op_amp
id|TCR_LAST_BYTE_SENT
)paren
(brace
id|hostdata-&gt;flags
op_or_assign
id|FLAG_HAS_LAST_BYTE_SENT
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_LAST_BYTE_SENT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : last bit sent works&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
r_else
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|TARGET_COMMAND_REG
)paren
op_amp
id|TCR_LAST_BYTE_SENT
)paren
)paren
suffix:semicolon
macro_line|#else
id|udelay
(paren
l_int|5
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
op_star
id|data
op_assign
id|d
op_plus
id|c
suffix:semicolon
op_star
id|count
op_assign
l_int|0
suffix:semicolon
op_star
id|phase
op_assign
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
op_amp
id|PHASE_MASK
)paren
)paren
suffix:semicolon
macro_line|#if defined(PSEUDO_DMA) &amp;&amp; !defined(UNSAFE)
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* defined(REAL_DMA_POLL) */
r_return
id|foo
suffix:semicolon
macro_line|#endif /* def REAL_DMA */
)brace
macro_line|#endif /* defined(REAL_DMA) | defined(PSEUDO_DMA) */
multiline_comment|/*&n; * Function : NCR5380_information_transfer (struct Scsi_Host *instance)&n; *&n; * Purpose : run through the various SCSI phases and do as the target &n; * &t;directs us to.  Operates on the currently connected command, &n; *&t;instance-&gt;connected.&n; *&n; * Inputs : instance, instance for which we are doing commands&n; *&n; * Side effects : SCSI things happen, the disconnected queue will be &n; *&t;modified if a command disconnects, *instance-&gt;connected will&n; *&t;change.&n; *&n; * XXX Note : we need to watch for bus free or a reset condition here &n; * &t;to recover from an unexpected bus free condition.&n; */
DECL|function|NCR5380_information_transfer
r_static
r_void
id|NCR5380_information_transfer
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
r_int
r_char
id|msgout
op_assign
id|NOP
suffix:semicolon
r_int
id|sink
op_assign
l_int|0
suffix:semicolon
r_int
id|len
comma
id|transfersize
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
r_char
id|phase
comma
id|tmp
comma
id|extended_msg
(braket
l_int|10
)braket
comma
id|old_phase
op_assign
l_int|0xff
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;connected
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|tmp
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
suffix:semicolon
multiline_comment|/* We only have a valid SCSI phase when REQ is asserted */
r_if
c_cond
(paren
id|tmp
op_amp
id|SR_REQ
)paren
(brace
id|phase
op_assign
(paren
id|tmp
op_amp
id|PHASE_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|phase
op_ne
id|old_phase
)paren
(brace
id|old_phase
op_assign
id|phase
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_INFORMATION)
id|NCR5380_print_phase
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|sink
op_logical_and
(paren
id|phase
op_ne
id|PHASE_MSGOUT
)paren
)paren
(brace
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
id|PHASE_SR_TO_TCR
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
op_or
id|ICR_ASSERT_ACK
)paren
suffix:semicolon
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
id|sink
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|phase
)paren
(brace
r_case
id|PHASE_DATAIN
suffix:colon
r_case
id|PHASE_DATAOUT
suffix:colon
macro_line|#if (NDEBUG &amp; NDEBUG_NO_DATAOUT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : NDEBUG_NO_DATAOUT set, attempted DATAOUT aborted&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|sink
op_assign
l_int|1
suffix:semicolon
id|msgout
op_assign
id|ABORT
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t;&t; * If there is no room left in the current buffer in the&n;&t;&t; * scatter-gather list, move onto the next one.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;SCp.this_residual
op_logical_and
id|cmd-&gt;SCp.buffers_residual
)paren
(brace
op_increment
id|cmd-&gt;SCp.buffer
suffix:semicolon
op_decrement
id|cmd-&gt;SCp.buffers_residual
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
id|cmd-&gt;SCp.buffer-&gt;address
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_INFORMATION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : %d bytes and %d buffers left&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;SCp.this_residual
comma
id|cmd-&gt;SCp.buffers_residual
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t;&t; * The prefered transfer method is going to be &n;&t;&t; * PSEUDO-DMA for systems that are strictly PIO,&n;&t;&t; * since we can let the hardware do the handshaking.&n;&t;&t; *&n;&t;&t; * For this to work, we need to know the transfersize&n;&t;&t; * ahead of time, since the pseudo-DMA code will sit&n;&t;&t; * in an unconditional loop.&n;&t;&t; */
macro_line|#if defined(PSEUDO_DMA) || defined(REAL_DMA_POLL)
macro_line|#ifdef NCR5380_dma_xfer_len
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;device-&gt;borken
op_logical_and
(paren
id|transfersize
op_assign
id|NCR5380_dma_xfer_len
c_func
(paren
id|instance
comma
id|cmd
)paren
)paren
op_ne
l_int|0
)paren
(brace
macro_line|#else
id|transfersize
op_assign
id|cmd-&gt;transfersize
suffix:semicolon
macro_line|#ifdef LIMIT_TRANSFERSIZE  /* If we have problems with interrupt service */
r_if
c_cond
(paren
id|transfersize
OG
l_int|512
)paren
(brace
id|transfersize
op_assign
l_int|512
suffix:semicolon
)brace
macro_line|#endif  /* LIMIT_TRANSFERSIZE */
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;device-&gt;borken
op_logical_and
id|transfersize
op_logical_and
id|cmd-&gt;SCp.this_residual
op_logical_and
op_logical_neg
(paren
id|cmd-&gt;SCp.this_residual
op_mod
id|transfersize
)paren
)paren
(brace
macro_line|#endif
id|len
op_assign
id|transfersize
suffix:semicolon
r_if
c_cond
(paren
id|NCR5380_transfer_dma
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
(paren
r_int
r_char
op_star
op_star
)paren
op_amp
id|cmd-&gt;SCp.ptr
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If the watchdog timer fires, all future accesses to this&n;&t;&t;&t; * device will use the polled-IO.&n;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;scsi%d : switching target %d lun %d to slow handshake&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|cmd-&gt;device-&gt;borken
op_assign
l_int|1
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
id|sink
op_assign
l_int|1
suffix:semicolon
id|msgout
op_assign
id|ABORT
suffix:semicolon
multiline_comment|/* XXX - need to source or sink data here, as appropriate */
)brace
r_else
id|cmd-&gt;SCp.this_residual
op_sub_assign
id|transfersize
op_minus
id|len
suffix:semicolon
)brace
r_else
macro_line|#endif /* defined(REAL_DMA) || defined(REAL_DMA_POLL) */
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
(paren
r_int
op_star
)paren
op_amp
id|cmd-&gt;SCp.this_residual
comma
(paren
r_int
r_char
op_star
op_star
)paren
op_amp
id|cmd-&gt;SCp.ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PHASE_MSGIN
suffix:colon
id|len
op_assign
l_int|1
suffix:semicolon
id|data
op_assign
op_amp
id|tmp
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
id|cmd-&gt;SCp.Message
op_assign
id|tmp
suffix:semicolon
r_switch
c_cond
(paren
id|tmp
)paren
(brace
multiline_comment|/*&n;&t;&t; * Linking lets us reduce the time required to get the &n;&t;&t; * next command out to the device, hopefully this will&n;&t;&t; * mean we don&squot;t waste another revolution due to the delays&n;&t;&t; * required by ARBITRATION and another SELECTION.&n;&t;&t; *&n;&t;&t; * In the current implementation proposal, low level drivers&n;&t;&t; * merely have to start the next command, pointed to by &n;&t;&t; * next_link, done() is called as with unlinked commands.&n;&t;&t; */
macro_line|#ifdef LINKED
r_case
id|LINKED_CMD_COMPLETE
suffix:colon
r_case
id|LINKED_FLG_CMD_COMPLETE
suffix:colon
multiline_comment|/* Accept message by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_LINKED) 
id|printk
c_func
(paren
l_string|&quot;scsi%d : target %d lun %d linked command complete.&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t;&t;     * Sanity check : A linked command should only terminate with&n;&t;&t;     * one of these messages if there are more linked commands&n;&t;&t;     * available.&n;&t;&t;     */
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;next_link
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : target %d lun %d linked command complete, no next_link&bslash;n&quot;
id|instance-&gt;host_no
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|sink
op_assign
l_int|1
suffix:semicolon
id|msgout
op_assign
id|ABORT
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|initialize_SCp
c_func
(paren
id|cmd-&gt;next_link
)paren
suffix:semicolon
multiline_comment|/* The next command is still part of this process */
id|cmd-&gt;next_link-&gt;tag
op_assign
id|cmd-&gt;tag
suffix:semicolon
id|cmd-&gt;result
op_assign
id|cmd-&gt;SCp.Status
op_or
(paren
id|cmd-&gt;SCp.Message
op_lshift
l_int|8
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_LINKED) 
id|printk
c_func
(paren
l_string|&quot;scsi%d : target %d lun %d linked request done, calling scsi_done().&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|cmd
op_assign
id|hostdata-&gt;connected
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* def LINKED */
r_case
id|ABORT
suffix:colon
r_case
id|COMMAND_COMPLETE
suffix:colon
multiline_comment|/* Accept message by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_QUEUES)
id|printk
c_func
(paren
l_string|&quot;scsi%d : command for target %d, lun %d completed&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;     * I&squot;m not sure what the correct thing to do here is : &n;&t;&t;     * &n;&t;&t;     * If the command that just executed is NOT a request &n;&t;&t;     * sense, the obvious thing to do is to set the result&n;&t;&t;     * code to the values of the stored parameters.&n;&t;&t;     * &n;&t;&t;     * If it was a REQUEST SENSE command, we need some way &n;&t;&t;     * to differentiate between the failure code of the original&n;&t;&t;     * and the failure code of the REQUEST sense - the obvious&n;&t;&t;     * case is success, where we fall through and leave the result&n;&t;&t;     * code unchanged.&n;&t;&t;     * &n;&t;&t;     * The non-obvious place is where the REQUEST SENSE failed &n;&t;&t;     */
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|REQUEST_SENSE
)paren
id|cmd-&gt;result
op_assign
id|cmd-&gt;SCp.Status
op_or
(paren
id|cmd-&gt;SCp.Message
op_lshift
l_int|8
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd-&gt;SCp.Status
op_ne
id|GOOD
)paren
id|cmd-&gt;result
op_assign
(paren
id|cmd-&gt;result
op_amp
l_int|0x00ffff
)paren
op_or
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
macro_line|#ifdef AUTOSENSE
r_if
c_cond
(paren
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|REQUEST_SENSE
)paren
op_logical_and
(paren
id|cmd-&gt;SCp.Status
op_eq
id|CHECK_CONDITION
)paren
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_AUTOSENSE) 
id|printk
c_func
(paren
l_string|&quot;scsi%d : performing request sense&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|REQUEST_SENSE
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|1
)braket
op_and_assign
l_int|0xe0
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.buffers_residual
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|cmd-&gt;sense_buffer
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|hostdata-&gt;issue_queue
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_QUEUES)
id|printk
c_func
(paren
l_string|&quot;scsi%d : REQUEST SENSE added to head of issue queue&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
macro_line|#endif /* def AUTOSENSE */
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;     * Restore phase bits to 0 so an interrupted selection, &n;&t;&t;     * arbitration can resume.&n;&t;&t;     */
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_BSY
)paren
op_logical_and
op_logical_neg
id|hostdata-&gt;connected
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|MESSAGE_REJECT
suffix:colon
multiline_comment|/* Accept message by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hostdata-&gt;last_message
)paren
(brace
r_case
id|HEAD_OF_QUEUE_TAG
suffix:colon
r_case
id|ORDERED_QUEUE_TAG
suffix:colon
r_case
id|SIMPLE_QUEUE_TAG
suffix:colon
id|cmd-&gt;device-&gt;tagged_queue
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_or_assign
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_case
id|DISCONNECT
suffix:colon
multiline_comment|/* Accept message by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|cmd-&gt;device-&gt;disconnect
op_assign
l_int|1
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|hostdata-&gt;disconnected_queue
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;disconnected_queue
op_assign
id|cmd
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_QUEUES)
id|printk
c_func
(paren
l_string|&quot;scsi%d : command for target %d lun %d was moved from connected to&quot;
l_string|&quot;  the disconnected_queue&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t;&t;     * Restore phase bits to 0 so an interrupted selection, &n;&t;&t;     * arbitration can resume.&n;&t;&t;     */
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Enable reselect interrupts */
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
multiline_comment|/* Wait for bus free to avoid nasty timeouts */
r_while
c_loop
(paren
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_BSY
)paren
op_logical_and
op_logical_neg
id|hostdata-&gt;connected
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* &n;&t;&t; * The SCSI data pointer is *IMPLICITLY* saved on a disconnect&n;&t;&t; * operation, in violation of the SCSI spec so we can safely &n;&t;&t; * ignore SAVE/RESTORE pointers calls.&n;&t;&t; *&n;&t;&t; * Unfortunately, some disks violate the SCSI spec and &n;&t;&t; * don&squot;t issue the required SAVE_POINTERS message before&n;&t;&t; * disconnecting, and we have to break spec to remain &n;&t;&t; * compatible.&n;&t;&t; */
r_case
id|SAVE_POINTERS
suffix:colon
r_case
id|RESTORE_POINTERS
suffix:colon
multiline_comment|/* Accept message by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EXTENDED_MESSAGE
suffix:colon
multiline_comment|/* &n; * Extended messages are sent in the following format :&n; * Byte &t;&n; * 0&t;&t;EXTENDED_MESSAGE == 1&n; * 1&t;&t;length (includes one byte for code, doesn&squot;t &n; *&t;&t;include first two bytes)&n; * 2 &t;&t;code&n; * 3..length+1&t;arguments&n; *&n; * Start the extended message buffer with the EXTENDED_MESSAGE&n; * byte, since print_msg() wants the whole thing.  &n; */
id|extended_msg
(braket
l_int|0
)braket
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
multiline_comment|/* Accept first byte by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_EXTENDED)
id|printk
c_func
(paren
l_string|&quot;scsi%d : receiving extended message&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|len
op_assign
l_int|2
suffix:semicolon
id|data
op_assign
id|extended_msg
op_plus
l_int|1
suffix:semicolon
id|phase
op_assign
id|PHASE_MSGIN
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_EXTENDED)
id|printk
c_func
(paren
l_string|&quot;scsi%d : length=%d, code=0x%02x&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
(paren
r_int
)paren
id|extended_msg
(braket
l_int|1
)braket
comma
(paren
r_int
)paren
id|extended_msg
(braket
l_int|2
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_and
id|extended_msg
(braket
l_int|1
)braket
op_le
(paren
r_sizeof
(paren
id|extended_msg
)paren
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* Accept third byte by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|len
op_assign
id|extended_msg
(braket
l_int|1
)braket
op_minus
l_int|1
suffix:semicolon
id|data
op_assign
id|extended_msg
op_plus
l_int|3
suffix:semicolon
id|phase
op_assign
id|PHASE_MSGIN
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_EXTENDED)
id|printk
c_func
(paren
l_string|&quot;scsi%d : message received, residual %d&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|extended_msg
(braket
l_int|2
)braket
)paren
(brace
r_case
id|EXTENDED_SDTR
suffix:colon
r_case
id|EXTENDED_WDTR
suffix:colon
r_case
id|EXTENDED_MODIFY_DATA_POINTER
suffix:colon
r_case
id|EXTENDED_EXTENDED_IDENTIFY
suffix:colon
id|tmp
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|len
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: error receiving extended message&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|tmp
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: extended message code %02x length %d is too long&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|extended_msg
(braket
l_int|2
)braket
comma
id|extended_msg
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|tmp
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Fall through to reject message */
multiline_comment|/* &n;  &t;&t; * If we get something weird that we aren&squot;t expecting, &n; &t;&t; * reject it.&n;&t;&t; */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: rejecting message &quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|print_msg
(paren
id|extended_msg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tmp
op_ne
id|EXTENDED_MESSAGE
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d: rejecting unknown message %02x from target %d, lun %d&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|tmp
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;scsi%d: rejecting unknown extended message code %02x, length %d from target %d, lun %d&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|extended_msg
(braket
l_int|1
)braket
comma
id|extended_msg
(braket
l_int|0
)braket
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|msgout
op_assign
id|MESSAGE_REJECT
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* switch (tmp) */
r_break
suffix:semicolon
r_case
id|PHASE_MSGOUT
suffix:colon
id|len
op_assign
l_int|1
suffix:semicolon
id|data
op_assign
op_amp
id|msgout
suffix:semicolon
id|hostdata-&gt;last_message
op_assign
id|msgout
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msgout
op_eq
id|ABORT
)paren
(brace
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|msgout
op_assign
id|NOP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PHASE_CMDOUT
suffix:colon
id|len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|data
op_assign
id|cmd-&gt;cmnd
suffix:semicolon
multiline_comment|/* &n;&t;&t; * XXX for performance reasons, on machines with a &n;&t;&t; * PSEUDO-DMA architecture we should probably &n;&t;&t; * use the dma transfer function.  &n;&t;&t; */
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
macro_line|#ifdef USLEEP
r_if
c_cond
(paren
op_logical_neg
id|disconnect
op_logical_and
id|should_disconnect
c_func
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
)paren
(brace
id|hostdata-&gt;time_expires
op_assign
id|jiffies
op_plus
id|USLEEP_SLEEP
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_USLEEP)
id|printk
c_func
(paren
l_string|&quot;scsi%d : issued command, sleeping until %ul&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|hostdata-&gt;time_expires
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_set_timer
(paren
id|instance
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* def USLEEP */
r_break
suffix:semicolon
r_case
id|PHASE_STATIN
suffix:colon
id|len
op_assign
l_int|1
suffix:semicolon
id|data
op_assign
op_amp
id|tmp
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
id|cmd-&gt;SCp.Status
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : unknown phase&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#ifdef NDEBUG
id|NCR5380_print
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* switch(phase) */
)brace
multiline_comment|/* if (tmp * SR_REQ) */
macro_line|#ifdef USLEEP
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|disconnect
op_logical_and
id|hostdata-&gt;time_expires
op_logical_and
id|jiffies
OG
id|hostdata-&gt;time_expires
)paren
(brace
id|hostdata-&gt;time_expires
op_assign
id|jiffies
op_plus
id|USLEEP_SLEEP
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_USLEEP)
id|printk
c_func
(paren
l_string|&quot;scsi%d : poll timed out, sleeping until %ul&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|hostdata-&gt;time_expires
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_set_timer
(paren
id|instance
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
multiline_comment|/* while (1) */
)brace
multiline_comment|/*&n; * Function : void NCR5380_reselect (struct Scsi_Host *instance)&n; *&n; * Purpose : does reselection, initializing the instance-&gt;connected &n; *&t;field to point to the Scsi_Cmnd for which the I_T_L or I_T_L_Q &n; *&t;nexus has been reestablished,&n; *&t;&n; * Inputs : instance - this instance of the NCR5380.&n; *&n; */
DECL|function|NCR5380_reselect
r_static
r_void
id|NCR5380_reselect
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
r_int
r_char
id|target_mask
suffix:semicolon
r_int
r_char
id|lun
comma
id|phase
suffix:semicolon
r_int
id|len
suffix:semicolon
macro_line|#ifdef SCSI2
r_int
r_char
id|tag
suffix:semicolon
macro_line|#endif
r_int
r_char
id|msg
(braket
l_int|3
)braket
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
id|Scsi_Cmnd
op_star
id|tmp
op_assign
l_int|NULL
comma
op_star
id|prev
suffix:semicolon
r_int
m_abort
op_assign
l_int|0
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
multiline_comment|/*&n;     * Disable arbitration, etc. since the host adapter obviously&n;     * lost, and tell an interrupted NCR5380_select() to restart.&n;     */
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|hostdata-&gt;restart_select
op_assign
l_int|1
suffix:semicolon
id|target_mask
op_assign
id|NCR5380_read
c_func
(paren
id|CURRENT_SCSI_DATA_REG
)paren
op_amp
op_complement
(paren
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_RESELECTION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : reselect&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;     * At this point, we have detected that our SCSI ID is on the bus,&n;     * SEL is true and BSY was false for at least one bus settle delay&n;     * (400 ns).&n;     *&n;     * We must assert BSY ourselves, until the target drops the SEL&n;     * signal.&n;     */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_BSY
)paren
suffix:semicolon
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_SEL
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
multiline_comment|/*&n;     * Wait for target to go into MSGIN.&n;     */
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
)paren
suffix:semicolon
id|len
op_assign
l_int|1
suffix:semicolon
id|data
op_assign
id|msg
suffix:semicolon
id|phase
op_assign
id|PHASE_MSGIN
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msg
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : expecting IDENTIFY message, got &quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|print_msg
c_func
(paren
id|msg
)paren
suffix:semicolon
m_abort
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Accept message by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|lun
op_assign
(paren
id|msg
(braket
l_int|0
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * We need to add code for SCSI-II to track which devices have&n;&t; * I_T_L_Q nexuses established, and which have simple I_T_L&n;&t; * nexuses so we can chose to do additional data transfer.&n; &t; */
macro_line|#ifdef SCSI2
macro_line|#error &quot;SCSI-II tagged queueing is not supported yet&quot;
macro_line|#endif
multiline_comment|/* &n;&t; * Find the command corresponding to the I_T_L or I_T_L_Q  nexus we &n;&t; * just reestablished, and remove it from the disconnected queue.&n;&t; */
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_queue
comma
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|tmp
suffix:semicolon
id|prev
op_assign
id|tmp
comma
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
r_if
c_cond
(paren
(paren
id|target_mask
op_eq
(paren
l_int|1
op_lshift
id|tmp-&gt;target
)paren
)paren
op_logical_and
(paren
id|lun
op_eq
id|tmp-&gt;lun
)paren
macro_line|#ifdef SCSI2
op_logical_and
(paren
id|tag
op_eq
id|tmp-&gt;tag
)paren
macro_line|#endif
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;host_scribble
op_assign
id|tmp-&gt;host_scribble
suffix:semicolon
r_else
id|hostdata-&gt;disconnected_queue
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
suffix:semicolon
id|tmp-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
macro_line|#ifdef SCSI2
id|printk
c_func
(paren
l_string|&quot;scsi%d : warning : target bitmask %02x lun %d tag %d not in disconnect_queue.&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|target_mask
comma
id|lun
comma
id|tag
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;scsi%d : warning : target bitmask %02x lun %d not in disconnect_queue.&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|target_mask
comma
id|lun
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t; * Since we have an established nexus that we can&squot;t do anything with,&n;&t; * we must abort it.  &n;&t; */
m_abort
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
m_abort
)paren
(brace
id|msg
(braket
l_int|0
)braket
op_assign
id|ABORT
suffix:semicolon
id|len
op_assign
l_int|1
suffix:semicolon
id|data
op_assign
id|msg
suffix:semicolon
id|phase
op_assign
id|PHASE_MSGOUT
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
)brace
r_else
(brace
id|hostdata-&gt;connected
op_assign
id|tmp
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_RESELECTION)
id|printk
l_string|&quot;scsi%d : nexus established, target = %d, lun = %d, tag = %d&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|tmp-&gt;target
comma
id|tmp-&gt;lun
comma
id|tmp-&gt;tag
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*&n; * Function : void NCR5380_dma_complete (struct Scsi_Host *instance)&n; *&n; * Purpose : called by interrupt handler when DMA finishes or a phase&n; *&t;mismatch occurs (which would finish the DMA transfer).  &n; *&n; * Inputs : instance - this instance of the NCR5380.&n; *&n; * Returns : pointer to the Scsi_Cmnd structure for which the I_T_L&n; * &t;nexus has been reestablished, on failure NULL is returned.&n; */
macro_line|#ifdef REAL_DMA
DECL|function|NCR5380_dma_complete
r_static
r_void
id|NCR5380_dma_complete
(paren
id|NCR5380_instance
op_star
id|instance
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
id|instance-&gt;hostdata
)paren
suffix:semicolon
r_int
id|transferred
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
multiline_comment|/*&n;     * XXX this might not be right.&n;     *&n;     * Wait for final byte to transfer, ie wait for ACK to go false.&n;     *&n;     * We should use the Last Byte Sent bit, unfortunately this is &n;     * not available on the 5380/5381 (only the various CMOS chips)&n;     */
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_ACK
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
multiline_comment|/*&n;     * The only places we should see a phase mismatch and have to send&n;     * data from the same set of pointers will be the data transfer&n;     * phases.  So, residual, requested length are only important here.&n;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;connected-&gt;SCp.phase
op_amp
id|SR_CD
)paren
)paren
(brace
id|transferred
op_assign
id|instance-&gt;dmalen
op_minus
id|NCR5380_dma_residual
c_func
(paren
)paren
suffix:semicolon
id|hostdata-&gt;connected-&gt;SCp.this_residual
op_sub_assign
id|transferred
suffix:semicolon
id|hostdata-&gt;connected-&gt;SCp.ptr
op_add_assign
id|transferred
suffix:semicolon
)brace
)brace
macro_line|#endif /* def REAL_DMA */
multiline_comment|/*&n; * Function : int NCR5380_abort (Scsi_Cmnd *cmd)&n; *&n; * Purpose : abort a command&n; *&n; * Inputs : cmd - the Scsi_Cmnd to abort, code - code to set the &n; * &t;host byte of the result field to, if zero DID_ABORTED is &n; *&t;used.&n; *&n; * Returns : 0 - success, -1 on failure.&n; *&n; * XXX - there is no way to abort the command that is currently &n; * &t; connected, you have to wait for it to complete.  If this is &n; *&t; a problem, we could implement longjmp() / setjmp(), setjmp()&n; * &t; called where the loop started in NCR5380_main().&n; */
macro_line|#ifndef NCR5380_abort
r_static
macro_line|#endif
DECL|function|NCR5380_abort
r_int
id|NCR5380_abort
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
op_assign
id|cmd-&gt;host
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|Scsi_Cmnd
op_star
id|tmp
comma
op_star
op_star
id|prev
suffix:semicolon
r_int
r_char
id|msg
comma
id|phase
comma
op_star
id|msgptr
suffix:semicolon
r_int
id|len
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : aborting command&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|print_Scsi_Cmnd
(paren
id|cmd
)paren
suffix:semicolon
id|NCR5380_print_status
(paren
id|instance
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_ABORT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : abort called&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        basr 0x%X, sr 0x%X&bslash;n&quot;
comma
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
comma
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0
multiline_comment|/*&n; * Case 1 : If the command is the currently executing command, &n; * we&squot;ll set the aborted flag and return control so that &n; * information transfer routine can exit cleanly.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;connected
op_eq
id|cmd
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_ABORT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : aborting connected command&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;aborted
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; * We should perform BSY checking, and make sure we haven&squot;t slipped&n; * into BUS FREE.&n; */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
multiline_comment|/* &n; * Since we can&squot;t change phases until we&squot;ve completed the current &n; * handshake, we have to source or sink a byte of data if the current&n; * phase is not MSGOUT.&n; */
multiline_comment|/* &n; * Return control to the executing NCR drive so we can clear the&n; * aborted flag and get back into our main loop.&n; */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* &n; * Case 2 : If the command hasn&squot;t been issued yet, we simply remove it &n; * &t;    from the issue queue.&n; */
r_for
c_loop
(paren
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
id|hostdata-&gt;issue_queue
)paren
comma
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|tmp
suffix:semicolon
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
id|tmp-&gt;host_scribble
)paren
comma
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
r_if
c_cond
(paren
id|cmd
op_eq
id|tmp
)paren
(brace
(paren
op_star
id|prev
)paren
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
suffix:semicolon
id|tmp-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_ABORT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : abort removed command from issue queue.&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|tmp
op_member_access_from_pointer
id|done
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
multiline_comment|/* &n; * Case 3 : If any commands are connected, we&squot;re going to fail the abort&n; *&t;    and let the high level SCSI driver retry at a later time or &n; *&t;    issue a reset.&n; *&n; *&t;    Timeouts, and therefore aborted commands, will be highly unlikely&n; *          and handling them cleanly in this situation would make the common&n; *&t;    case of noresets less efficient, and would pollute our code.  So,&n; *&t;    we fail.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;connected
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_ABORT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : abort failed, command connected.&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
multiline_comment|/*&n; * Case 4: If the command is currently disconnected from the bus, and &n; * &t;there are no connected commands, we reconnect the I_T_L or &n; *&t;I_T_L_Q nexus associated with it, go into message out, and send &n; *      an abort message.&n; *&n; * This case is especially ugly. In order to reestablish the nexus, we&n; * need to call NCR5380_select().  The easiest way to implement this &n; * function was to abort if the bus was busy, and let the interrupt&n; * handler triggered on the SEL for reselect take care of lost arbitrations&n; * where necessary, meaning interrupts need to be enabled.&n; *&n; * When interrupts are enabled, the queues may change - so we &n; * can&squot;t remove it from the disconnected queue before selecting it&n; * because that could cause a failure in hashing the nexus if that &n; * device reselected.&n; * &n; * Since the queues may change, we can&squot;t use the pointers from when we&n; * first locate it.&n; *&n; * So, we must first locate the command, and if NCR5380_select()&n; * succeeds, then issue the abort, relocate the command and remove&n; * it from the disconnected queue.&n; */
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_queue
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
r_if
c_cond
(paren
id|cmd
op_eq
id|tmp
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_ABORT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : aborting disconnected command.&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|NCR5380_select
(paren
id|instance
comma
id|cmd
comma
(paren
r_int
)paren
id|cmd-&gt;tag
)paren
)paren
r_return
id|SCSI_ABORT_BUSY
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_ABORT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : nexus reestablished.&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|msg
op_assign
id|ABORT
suffix:semicolon
id|msgptr
op_assign
op_amp
id|msg
suffix:semicolon
id|len
op_assign
l_int|1
suffix:semicolon
id|phase
op_assign
id|PHASE_MSGOUT
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
id|NCR5380_transfer_pio
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|msgptr
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
id|hostdata-&gt;disconnected_queue
)paren
comma
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_queue
suffix:semicolon
id|tmp
suffix:semicolon
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
id|tmp-&gt;host_scribble
)paren
comma
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
r_if
c_cond
(paren
id|cmd
op_eq
id|tmp
)paren
(brace
op_star
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
suffix:semicolon
id|tmp-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|tmp
op_member_access_from_pointer
id|done
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Case 5 : If we reached this point, the command was not found in any of &n; *&t;    the queues.&n; *&n; * We probably reached this point because of an unlikely race condition&n; * between the command completing successfully and the abortion code,&n; * so we won&squot;t panic, but we will notify the user in case something really&n; * broke.&n; */
id|sti
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : warning : SCSI command probably completed successfully&bslash;n&quot;
l_string|&quot;         before abortion&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : int NCR5380_reset (Scsi_Cmnd *cmd)&n; * &n; * Purpose : reset the SCSI bus.&n; *&n; * Returns : SCSI_RESET_WAKEUP&n; *&n; */
macro_line|#ifndef NCR5380_reset
r_static
macro_line|#endif
DECL|function|NCR5380_reset
r_int
id|NCR5380_reset
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|cmd-&gt;host
)paren
suffix:semicolon
id|NCR5380_print_status
(paren
id|cmd-&gt;host
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_RST
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|SCSI_RESET_WAKEUP
suffix:semicolon
)brace
eof
