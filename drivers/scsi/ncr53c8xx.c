multiline_comment|/******************************************************************************&n;**  Device driver for the PCI-SCSI NCR538XX controller family.&n;**&n;**  Copyright (C) 1994  Wolfgang Stanglmeier&n;**&n;**  This program is free software; you can redistribute it and/or modify&n;**  it under the terms of the GNU General Public License as published by&n;**  the Free Software Foundation; either version 2 of the License, or&n;**  (at your option) any later version.&n;**&n;**  This program is distributed in the hope that it will be useful,&n;**  but WITHOUT ANY WARRANTY; without even the implied warranty of&n;**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;**  GNU General Public License for more details.&n;**&n;**  You should have received a copy of the GNU General Public License&n;**  along with this program; if not, write to the Free Software&n;**  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;**&n;**-----------------------------------------------------------------------------&n;**&n;**  This driver has been ported to Linux from the FreeBSD NCR53C8XX driver&n;**  and is currently maintained by&n;**&n;**          Gerard Roudier              &lt;groudier@club-internet.fr&gt;&n;**&n;**  Being given that this driver originates from the FreeBSD version, and&n;**  in order to keep synergy on both, any suggested enhancements and corrections&n;**  received on Linux are automatically a potential candidate for the FreeBSD &n;**  version.&n;**&n;**  The original driver has been written for 386bsd and FreeBSD by&n;**          Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;&n;**          Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;&n;**&n;**  And has been ported to NetBSD by&n;**          Charles M. Hannum           &lt;mycroft@gnu.ai.mit.edu&gt;&n;**&n;**-----------------------------------------------------------------------------&n;**&n;**                     Brief history&n;**&n;**  December 10 1995 by Gerard Roudier:&n;**     Initial port to Linux.&n;**&n;**  June 23 1996 by Gerard Roudier:&n;**     Support for 64 bits architectures (Alpha).&n;**&n;**  November 30 1996 by Gerard Roudier:&n;**     Support for Fast-20 scsi.&n;**     Support for large DMA fifo and 128 dwords bursting.&n;**&n;**  February 27 1997 by Gerard Roudier:&n;**     Support for Fast-40 scsi.&n;**     Support for on-Board RAM.&n;**&n;**  May 3 1997 by Gerard Roudier:&n;**     Full support for scsi scripts instructions pre-fetching.&n;**&n;**  May 19 1997 by Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;:&n;**     Support for NvRAM detection and reading.&n;**&n;**  August 18 1997 by Cort &lt;cort@cs.nmt.edu&gt;:&n;**     Support for Power/PC (Big Endian).&n;**&n;**  June 20 1998 by Gerard Roudier &lt;groudier@club-internet.fr&gt;:&n;**     Support for up to 64 tags per lun.&n;**     O(1) everywhere (C and SCRIPTS) for normal cases.&n;**     Low PCI traffic for command handling when on-chip RAM is present.&n;**     Aggressive SCSI SCRIPTS optimizations.&n;**&n;*******************************************************************************&n;*/
multiline_comment|/*&n;**&t;May 11 2000, version 3.3b&n;**&n;**&t;Supported SCSI-II features:&n;**&t;    Synchronous negotiation&n;**&t;    Wide negotiation        (depends on the NCR Chip)&n;**&t;    Enable disconnection&n;**&t;    Tagged command queuing&n;**&t;    Parity checking&n;**&t;    Etc...&n;**&n;**&t;Supported NCR/SYMBIOS chips:&n;**&t;&t;53C810&t;&t;(8 bits, Fast SCSI-2, no rom BIOS) &n;**&t;&t;53C815&t;&t;(8 bits, Fast SCSI-2, on board rom BIOS)&n;**&t;&t;53C820&t;&t;(Wide,   Fast SCSI-2, no rom BIOS)&n;**&t;&t;53C825&t;&t;(Wide,   Fast SCSI-2, on board rom BIOS)&n;**&t;&t;53C860&t;&t;(8 bits, Fast 20,     no rom BIOS)&n;**&t;&t;53C875&t;&t;(Wide,   Fast 20,     on board rom BIOS)&n;**&t;&t;53C895&t;&t;(Wide,   Fast 40,     on board rom BIOS)&n;**&t;&t;53C895A&t;&t;(Wide,   Fast 40,     on board rom BIOS)&n;**&t;&t;53C896&t;&t;(Wide,   Fast 40,     on board rom BIOS)&n;**&t;&t;53C897&t;&t;(Wide,   Fast 40,     on board rom BIOS)&n;**&t;&t;53C1510D&t;(Wide,   Fast 40,     on board rom BIOS)&n;**&n;**&t;Other features:&n;**&t;&t;Memory mapped IO (linux-1.3.X and above only)&n;**&t;&t;Module&n;**&t;&t;Shared IRQ (since linux-1.3.72)&n;*/
multiline_comment|/*&n;**&t;Name and version of the driver&n;*/
DECL|macro|SCSI_NCR_DRIVER_NAME
mdefine_line|#define SCSI_NCR_DRIVER_NAME&t;&quot;ncr53c8xx - version 3.3b&quot;
DECL|macro|SCSI_NCR_DEBUG_FLAGS
mdefine_line|#define SCSI_NCR_DEBUG_FLAGS&t;(0)
multiline_comment|/*==========================================================&n;**&n;**      Include files&n;**&n;**==========================================================&n;*/
DECL|macro|LinuxVersionCode
mdefine_line|#define LinuxVersionCode(v, p, s) (((v)&lt;&lt;16)+((p)&lt;&lt;8)+(s))
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,3,17)
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#elif LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,93)
macro_line|#include &lt;asm/spinlock.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,35)
macro_line|#include &lt;linux/init.h&gt;
macro_line|#endif
macro_line|#ifndef&t;__init
DECL|macro|__init
mdefine_line|#define&t;__init
macro_line|#endif
macro_line|#ifndef&t;__initdata
DECL|macro|__initdata
mdefine_line|#define&t;__initdata
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &lt;= LinuxVersionCode(2,1,92)
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#endif
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &lt;linux/types.h&gt;
multiline_comment|/*&n;**&t;Define BITS_PER_LONG for earlier linux versions.&n;*/
macro_line|#ifndef&t;BITS_PER_LONG
macro_line|#if (~0UL) == 0xffffffffUL
DECL|macro|BITS_PER_LONG
mdefine_line|#define&t;BITS_PER_LONG&t;32
macro_line|#else
DECL|macro|BITS_PER_LONG
mdefine_line|#define&t;BITS_PER_LONG&t;64
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n;**&t;Define the BSD style u_int32 and u_int64 type.&n;**&t;Are in fact u_int32_t and u_int64_t :-)&n;*/
DECL|typedef|u_int32
r_typedef
id|u32
id|u_int32
suffix:semicolon
DECL|typedef|u_int64
r_typedef
id|u64
id|u_int64
suffix:semicolon
DECL|typedef|vm_offset_t
r_typedef
id|u_long
id|vm_offset_t
suffix:semicolon
macro_line|#include &quot;ncr53c8xx.h&quot;
multiline_comment|/*&n;**&t;Donnot compile integrity checking code for Linux-2.3.0 &n;**&t;and above since SCSI data structures are not ready yet.&n;*/
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,3,0)
DECL|macro|SCSI_NCR_INTEGRITY_CHECKING
mdefine_line|#define&t;SCSI_NCR_INTEGRITY_CHECKING
macro_line|#endif
DECL|macro|NAME53C
mdefine_line|#define NAME53C&t;&t;&t;&quot;ncr53c&quot;
DECL|macro|NAME53C8XX
mdefine_line|#define NAME53C8XX&t;&t;&quot;ncr53c8xx&quot;
DECL|macro|DRIVER_SMP_LOCK
mdefine_line|#define DRIVER_SMP_LOCK&t;&t;ncr53c8xx_lock
macro_line|#include &quot;sym53c8xx_comm.h&quot;
multiline_comment|/*==========================================================&n;**&n;**&t;The CCB done queue uses an array of CCB virtual &n;**&t;addresses. Empty entries are flagged using the bogus &n;**&t;virtual address 0xffffffff.&n;**&n;**&t;Since PCI ensures that only aligned DWORDs are accessed &n;**&t;atomically, 64 bit little-endian architecture requires &n;**&t;to test the high order DWORD of the entry to determine &n;**&t;if it is empty or valid.&n;**&n;**&t;BTW, I will make things differently as soon as I will &n;**&t;have a better idea, but this is simple and should work.&n;**&n;**==========================================================&n;*/
DECL|macro|SCSI_NCR_CCB_DONE_SUPPORT
mdefine_line|#define SCSI_NCR_CCB_DONE_SUPPORT
macro_line|#ifdef  SCSI_NCR_CCB_DONE_SUPPORT
DECL|macro|MAX_DONE
mdefine_line|#define MAX_DONE 24
DECL|macro|CCB_DONE_EMPTY
mdefine_line|#define CCB_DONE_EMPTY 0xffffffffUL
multiline_comment|/* All 32 bit architectures */
macro_line|#if BITS_PER_LONG == 32
DECL|macro|CCB_DONE_VALID
mdefine_line|#define CCB_DONE_VALID(cp)  (((u_long) cp) != CCB_DONE_EMPTY)
multiline_comment|/* All &gt; 32 bit (64 bit) architectures regardless endian-ness */
macro_line|#else
DECL|macro|CCB_DONE_VALID
mdefine_line|#define CCB_DONE_VALID(cp)  &bslash;&n;&t;((((u_long) cp) &amp; 0xffffffff00000000ul) &amp;&amp; &t;&bslash;&n;&t; (((u_long) cp) &amp; 0xfffffffful) != CCB_DONE_EMPTY)
macro_line|#endif
macro_line|#endif /* SCSI_NCR_CCB_DONE_SUPPORT */
multiline_comment|/*==========================================================&n;**&n;**&t;Configuration and Debugging&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**    SCSI address of this device.&n;**    The boot routines should have set it.&n;**    If not, use this.&n;*/
macro_line|#ifndef SCSI_NCR_MYADDR
DECL|macro|SCSI_NCR_MYADDR
mdefine_line|#define SCSI_NCR_MYADDR      (7)
macro_line|#endif
multiline_comment|/*&n;**    The maximum number of tags per logic unit.&n;**    Used only for disk devices that support tags.&n;*/
macro_line|#ifndef SCSI_NCR_MAX_TAGS
DECL|macro|SCSI_NCR_MAX_TAGS
mdefine_line|#define SCSI_NCR_MAX_TAGS    (8)
macro_line|#endif
multiline_comment|/*&n;**    TAGS are actually limited to 64 tags/lun.&n;**    We need to deal with power of 2, for alignment constraints.&n;*/
macro_line|#if&t;SCSI_NCR_MAX_TAGS &gt; 64
DECL|macro|MAX_TAGS
mdefine_line|#define&t;MAX_TAGS (64)
macro_line|#else
DECL|macro|MAX_TAGS
mdefine_line|#define&t;MAX_TAGS SCSI_NCR_MAX_TAGS
macro_line|#endif
DECL|macro|NO_TAG
mdefine_line|#define NO_TAG&t;(255)
multiline_comment|/*&n;**&t;Choose appropriate type for tag bitmap.&n;*/
macro_line|#if&t;MAX_TAGS &gt; 32
DECL|typedef|tagmap_t
r_typedef
id|u_int64
id|tagmap_t
suffix:semicolon
macro_line|#else
DECL|typedef|tagmap_t
r_typedef
id|u_int32
id|tagmap_t
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;**    Number of targets supported by the driver.&n;**    n permits target numbers 0..n-1.&n;**    Default is 16, meaning targets #0..#15.&n;**    #7 .. is myself.&n;*/
macro_line|#ifdef SCSI_NCR_MAX_TARGET
DECL|macro|MAX_TARGET
mdefine_line|#define MAX_TARGET  (SCSI_NCR_MAX_TARGET)
macro_line|#else
DECL|macro|MAX_TARGET
mdefine_line|#define MAX_TARGET  (16)
macro_line|#endif
multiline_comment|/*&n;**    Number of logic units supported by the driver.&n;**    n enables logic unit numbers 0..n-1.&n;**    The common SCSI devices require only&n;**    one lun, so take 1 as the default.&n;*/
macro_line|#ifdef SCSI_NCR_MAX_LUN
DECL|macro|MAX_LUN
mdefine_line|#define MAX_LUN    SCSI_NCR_MAX_LUN
macro_line|#else
DECL|macro|MAX_LUN
mdefine_line|#define MAX_LUN    (1)
macro_line|#endif
multiline_comment|/*&n;**    Asynchronous pre-scaler (ns). Shall be 40&n;*/
macro_line|#ifndef SCSI_NCR_MIN_ASYNC
DECL|macro|SCSI_NCR_MIN_ASYNC
mdefine_line|#define SCSI_NCR_MIN_ASYNC (40)
macro_line|#endif
multiline_comment|/*&n;**    The maximum number of jobs scheduled for starting.&n;**    There should be one slot per target, and one slot&n;**    for each tag of each target in use.&n;**    The calculation below is actually quite silly ...&n;*/
macro_line|#ifdef SCSI_NCR_CAN_QUEUE
DECL|macro|MAX_START
mdefine_line|#define MAX_START   (SCSI_NCR_CAN_QUEUE + 4)
macro_line|#else
DECL|macro|MAX_START
mdefine_line|#define MAX_START   (MAX_TARGET + 7 * MAX_TAGS)
macro_line|#endif
multiline_comment|/*&n;**   We limit the max number of pending IO to 250.&n;**   since we donnot want to allocate more than 1 &n;**   PAGE for &squot;scripth&squot;.&n;*/
macro_line|#if&t;MAX_START &gt; 250
DECL|macro|MAX_START
macro_line|#undef&t;MAX_START
DECL|macro|MAX_START
mdefine_line|#define&t;MAX_START 250
macro_line|#endif
multiline_comment|/*&n;**    The maximum number of segments a transfer is split into.&n;**    We support up to 127 segments for both read and write.&n;**    The data scripts are broken into 2 sub-scripts.&n;**    80 (MAX_SCATTERL) segments are moved from a sub-script &n;**    in on-chip RAM. This makes data transfers shorter than &n;**    80k (assuming 1k fs) as fast as possible.&n;*/
DECL|macro|MAX_SCATTER
mdefine_line|#define MAX_SCATTER (SCSI_NCR_MAX_SCATTER)
macro_line|#if (MAX_SCATTER &gt; 80)
DECL|macro|MAX_SCATTERL
mdefine_line|#define MAX_SCATTERL&t;80
DECL|macro|MAX_SCATTERH
mdefine_line|#define&t;MAX_SCATTERH&t;(MAX_SCATTER - MAX_SCATTERL)
macro_line|#else
DECL|macro|MAX_SCATTERL
mdefine_line|#define MAX_SCATTERL&t;(MAX_SCATTER-1)
DECL|macro|MAX_SCATTERH
mdefine_line|#define&t;MAX_SCATTERH&t;1
macro_line|#endif
multiline_comment|/*&n;**&t;other&n;*/
DECL|macro|NCR_SNOOP_TIMEOUT
mdefine_line|#define NCR_SNOOP_TIMEOUT (1000000)
multiline_comment|/*&n;**&t;Head of list of NCR boards&n;**&n;**&t;For kernel version &lt; 1.3.70, host is retrieved by its irq level.&n;**&t;For later kernels, the internal host control block address &n;**&t;(struct ncb) is used as device id parameter of the irq stuff.&n;*/
DECL|variable|first_host
r_static
r_struct
id|Scsi_Host
op_star
id|first_host
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|the_template
r_static
id|Scsi_Host_Template
op_star
id|the_template
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;**&t;Other definitions&n;*/
DECL|macro|ScsiResult
mdefine_line|#define ScsiResult(host_code, scsi_code) (((host_code) &lt;&lt; 16) + ((scsi_code) &amp; 0x7f))
r_static
r_void
id|ncr53c8xx_select_queue_depths
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|scsi_device
op_star
id|devlist
)paren
suffix:semicolon
r_static
r_void
id|ncr53c8xx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|ncr53c8xx_timeout
c_func
(paren
r_int
r_int
id|np
)paren
suffix:semicolon
DECL|macro|initverbose
mdefine_line|#define initverbose (driver_setup.verbose)
DECL|macro|bootverbose
mdefine_line|#define bootverbose (np-&gt;verbose)
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
DECL|variable|__initdata
r_static
id|u_char
id|Tekram_sync
(braket
l_int|16
)braket
id|__initdata
op_assign
(brace
l_int|25
comma
l_int|31
comma
l_int|37
comma
l_int|43
comma
l_int|50
comma
l_int|62
comma
l_int|75
comma
l_int|125
comma
l_int|12
comma
l_int|15
comma
l_int|18
comma
l_int|21
comma
l_int|6
comma
l_int|7
comma
l_int|9
comma
l_int|10
)brace
suffix:semicolon
macro_line|#endif /* SCSI_NCR_NVRAM_SUPPORT */
multiline_comment|/*==========================================================&n;**&n;**&t;Command control block states.&n;**&n;**==========================================================&n;*/
DECL|macro|HS_IDLE
mdefine_line|#define HS_IDLE&t;&t;(0)
DECL|macro|HS_BUSY
mdefine_line|#define HS_BUSY&t;&t;(1)
DECL|macro|HS_NEGOTIATE
mdefine_line|#define HS_NEGOTIATE&t;(2)&t;/* sync/wide data transfer*/
DECL|macro|HS_DISCONNECT
mdefine_line|#define HS_DISCONNECT&t;(3)&t;/* Disconnected by target */
DECL|macro|HS_DONEMASK
mdefine_line|#define HS_DONEMASK&t;(0x80)
DECL|macro|HS_COMPLETE
mdefine_line|#define HS_COMPLETE&t;(4|HS_DONEMASK)
DECL|macro|HS_SEL_TIMEOUT
mdefine_line|#define HS_SEL_TIMEOUT&t;(5|HS_DONEMASK)&t;/* Selection timeout      */
DECL|macro|HS_RESET
mdefine_line|#define HS_RESET&t;(6|HS_DONEMASK)&t;/* SCSI reset&t;          */
DECL|macro|HS_ABORTED
mdefine_line|#define HS_ABORTED&t;(7|HS_DONEMASK)&t;/* Transfer aborted       */
DECL|macro|HS_TIMEOUT
mdefine_line|#define HS_TIMEOUT&t;(8|HS_DONEMASK)&t;/* Software timeout       */
DECL|macro|HS_FAIL
mdefine_line|#define HS_FAIL&t;&t;(9|HS_DONEMASK)&t;/* SCSI or PCI bus errors */
DECL|macro|HS_UNEXPECTED
mdefine_line|#define HS_UNEXPECTED&t;(10|HS_DONEMASK)/* Unexpected disconnect  */
multiline_comment|/*&n;**&t;Invalid host status values used by the SCRIPTS processor &n;**&t;when the nexus is not fully identified.&n;**&t;Shall never appear in a CCB.&n;*/
DECL|macro|HS_INVALMASK
mdefine_line|#define HS_INVALMASK&t;(0x40)
DECL|macro|HS_SELECTING
mdefine_line|#define&t;HS_SELECTING&t;(0|HS_INVALMASK)
DECL|macro|HS_IN_RESELECT
mdefine_line|#define&t;HS_IN_RESELECT&t;(1|HS_INVALMASK)
DECL|macro|HS_STARTING
mdefine_line|#define&t;HS_STARTING&t;(2|HS_INVALMASK)
multiline_comment|/*&n;**&t;Flags set by the SCRIPT processor for commands &n;**&t;that have been skipped.&n;*/
DECL|macro|HS_SKIPMASK
mdefine_line|#define HS_SKIPMASK&t;(0x20)
multiline_comment|/*==========================================================&n;**&n;**&t;Software Interrupt Codes&n;**&n;**==========================================================&n;*/
DECL|macro|SIR_BAD_STATUS
mdefine_line|#define&t;SIR_BAD_STATUS&t;&t;(1)
DECL|macro|SIR_XXXXXXXXXX
mdefine_line|#define&t;SIR_XXXXXXXXXX&t;&t;(2)
DECL|macro|SIR_NEGO_SYNC
mdefine_line|#define&t;SIR_NEGO_SYNC&t;&t;(3)
DECL|macro|SIR_NEGO_WIDE
mdefine_line|#define&t;SIR_NEGO_WIDE&t;&t;(4)
DECL|macro|SIR_NEGO_FAILED
mdefine_line|#define&t;SIR_NEGO_FAILED&t;&t;(5)
DECL|macro|SIR_NEGO_PROTO
mdefine_line|#define&t;SIR_NEGO_PROTO&t;&t;(6)
DECL|macro|SIR_REJECT_RECEIVED
mdefine_line|#define&t;SIR_REJECT_RECEIVED&t;(7)
DECL|macro|SIR_REJECT_SENT
mdefine_line|#define&t;SIR_REJECT_SENT&t;&t;(8)
DECL|macro|SIR_IGN_RESIDUE
mdefine_line|#define&t;SIR_IGN_RESIDUE&t;&t;(9)
DECL|macro|SIR_MISSING_SAVE
mdefine_line|#define&t;SIR_MISSING_SAVE&t;(10)
DECL|macro|SIR_RESEL_NO_MSG_IN
mdefine_line|#define&t;SIR_RESEL_NO_MSG_IN&t;(11)
DECL|macro|SIR_RESEL_NO_IDENTIFY
mdefine_line|#define&t;SIR_RESEL_NO_IDENTIFY&t;(12)
DECL|macro|SIR_RESEL_BAD_LUN
mdefine_line|#define&t;SIR_RESEL_BAD_LUN&t;(13)
DECL|macro|SIR_RESEL_BAD_TARGET
mdefine_line|#define&t;SIR_RESEL_BAD_TARGET&t;(14)
DECL|macro|SIR_RESEL_BAD_I_T_L
mdefine_line|#define&t;SIR_RESEL_BAD_I_T_L&t;(15)
DECL|macro|SIR_RESEL_BAD_I_T_L_Q
mdefine_line|#define&t;SIR_RESEL_BAD_I_T_L_Q&t;(16)
DECL|macro|SIR_DONE_OVERFLOW
mdefine_line|#define&t;SIR_DONE_OVERFLOW&t;(17)
DECL|macro|SIR_MAX
mdefine_line|#define&t;SIR_MAX&t;&t;&t;(17)
multiline_comment|/*==========================================================&n;**&n;**&t;Extended error codes.&n;**&t;xerr_status field of struct ccb.&n;**&n;**==========================================================&n;*/
DECL|macro|XE_OK
mdefine_line|#define&t;XE_OK&t;&t;(0)
DECL|macro|XE_EXTRA_DATA
mdefine_line|#define&t;XE_EXTRA_DATA&t;(1)&t;/* unexpected data phase */
DECL|macro|XE_BAD_PHASE
mdefine_line|#define&t;XE_BAD_PHASE&t;(2)&t;/* illegal phase (4/5)   */
multiline_comment|/*==========================================================&n;**&n;**&t;Negotiation status.&n;**&t;nego_status field&t;of struct ccb.&n;**&n;**==========================================================&n;*/
DECL|macro|NS_NOCHANGE
mdefine_line|#define NS_NOCHANGE&t;(0)
DECL|macro|NS_SYNC
mdefine_line|#define NS_SYNC&t;&t;(1)
DECL|macro|NS_WIDE
mdefine_line|#define NS_WIDE&t;&t;(2)
DECL|macro|NS_PPR
mdefine_line|#define NS_PPR&t;&t;(4)
multiline_comment|/*==========================================================&n;**&n;**&t;&quot;Special features&quot; of targets.&n;**&t;quirks field&t;&t;of struct tcb.&n;**&t;actualquirks field&t;of struct ccb.&n;**&n;**==========================================================&n;*/
DECL|macro|QUIRK_AUTOSAVE
mdefine_line|#define&t;QUIRK_AUTOSAVE&t;(0x01)
DECL|macro|QUIRK_NOMSG
mdefine_line|#define&t;QUIRK_NOMSG&t;(0x02)
DECL|macro|QUIRK_NOSYNC
mdefine_line|#define QUIRK_NOSYNC&t;(0x10)
DECL|macro|QUIRK_NOWIDE16
mdefine_line|#define QUIRK_NOWIDE16&t;(0x20)
multiline_comment|/*==========================================================&n;**&n;**&t;Capability bits in Inquire response byte 7.&n;**&n;**==========================================================&n;*/
DECL|macro|INQ7_QUEUE
mdefine_line|#define&t;INQ7_QUEUE&t;(0x02)
DECL|macro|INQ7_SYNC
mdefine_line|#define&t;INQ7_SYNC&t;(0x10)
DECL|macro|INQ7_WIDE16
mdefine_line|#define&t;INQ7_WIDE16&t;(0x20)
multiline_comment|/*==========================================================&n;**&n;**&t;Misc.&n;**&n;**==========================================================&n;*/
DECL|macro|CCB_MAGIC
mdefine_line|#define CCB_MAGIC&t;(0xf2691ad2)
multiline_comment|/*==========================================================&n;**&n;**&t;Declaration of structs.&n;**&n;**==========================================================&n;*/
r_struct
id|tcb
suffix:semicolon
r_struct
id|lcb
suffix:semicolon
r_struct
id|ccb
suffix:semicolon
r_struct
id|ncb
suffix:semicolon
r_struct
id|script
suffix:semicolon
DECL|typedef|ncb_p
r_typedef
r_struct
id|ncb
op_star
id|ncb_p
suffix:semicolon
DECL|typedef|tcb_p
r_typedef
r_struct
id|tcb
op_star
id|tcb_p
suffix:semicolon
DECL|typedef|lcb_p
r_typedef
r_struct
id|lcb
op_star
id|lcb_p
suffix:semicolon
DECL|typedef|ccb_p
r_typedef
r_struct
id|ccb
op_star
id|ccb_p
suffix:semicolon
DECL|struct|link
r_struct
id|link
(brace
DECL|member|l_cmd
id|ncrcmd
id|l_cmd
suffix:semicolon
DECL|member|l_paddr
id|ncrcmd
id|l_paddr
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|usrcmd
r_struct
id|usrcmd
(brace
DECL|member|target
id|u_long
id|target
suffix:semicolon
DECL|member|lun
id|u_long
id|lun
suffix:semicolon
DECL|member|data
id|u_long
id|data
suffix:semicolon
DECL|member|cmd
id|u_long
id|cmd
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|UC_SETSYNC
mdefine_line|#define UC_SETSYNC      10
DECL|macro|UC_SETTAGS
mdefine_line|#define UC_SETTAGS&t;11
DECL|macro|UC_SETDEBUG
mdefine_line|#define UC_SETDEBUG&t;12
DECL|macro|UC_SETORDER
mdefine_line|#define UC_SETORDER&t;13
DECL|macro|UC_SETWIDE
mdefine_line|#define UC_SETWIDE&t;14
DECL|macro|UC_SETFLAG
mdefine_line|#define UC_SETFLAG&t;15
DECL|macro|UC_CLEARPROF
mdefine_line|#define UC_CLEARPROF&t;16
DECL|macro|UC_SETVERBOSE
mdefine_line|#define UC_SETVERBOSE&t;17
DECL|macro|UF_TRACE
mdefine_line|#define&t;UF_TRACE&t;(0x01)
DECL|macro|UF_NODISC
mdefine_line|#define&t;UF_NODISC&t;(0x02)
DECL|macro|UF_NOSCAN
mdefine_line|#define&t;UF_NOSCAN&t;(0x04)
multiline_comment|/*---------------------------------------&n;**&n;**&t;Timestamps for profiling&n;**&n;**---------------------------------------&n;*/
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
DECL|struct|tstamp
r_struct
id|tstamp
(brace
DECL|member|start
id|u_long
id|start
suffix:semicolon
DECL|member|end
id|u_long
id|end
suffix:semicolon
DECL|member|command
id|u_long
id|command
suffix:semicolon
DECL|member|status
id|u_long
id|status
suffix:semicolon
DECL|member|disconnect
id|u_long
id|disconnect
suffix:semicolon
DECL|member|reselect
id|u_long
id|reselect
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;profiling data (per device)&n;*/
DECL|struct|profile
r_struct
id|profile
(brace
DECL|member|num_trans
id|u_long
id|num_trans
suffix:semicolon
DECL|member|num_kbytes
id|u_long
id|num_kbytes
suffix:semicolon
DECL|member|rest_bytes
id|u_long
id|rest_bytes
suffix:semicolon
DECL|member|num_disc
id|u_long
id|num_disc
suffix:semicolon
DECL|member|num_break
id|u_long
id|num_break
suffix:semicolon
DECL|member|num_int
id|u_long
id|num_int
suffix:semicolon
DECL|member|num_fly
id|u_long
id|num_fly
suffix:semicolon
DECL|member|ms_setup
id|u_long
id|ms_setup
suffix:semicolon
DECL|member|ms_data
id|u_long
id|ms_data
suffix:semicolon
DECL|member|ms_disc
id|u_long
id|ms_disc
suffix:semicolon
DECL|member|ms_post
id|u_long
id|ms_post
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*========================================================================&n;**&n;**&t;Declaration of structs:&t;&t;target control block&n;**&n;**========================================================================&n;*/
DECL|struct|tcb
r_struct
id|tcb
(brace
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;During reselection the ncr jumps to this point with SFBR &n;&t;**&t;set to the encoded target number with bit 7 set.&n;&t;**&t;if it&squot;s not this target, jump to the next.&n;&t;**&n;&t;**&t;JUMP  IF (SFBR != #target#), @(next tcb)&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|jump_tcb
r_struct
id|link
id|jump_tcb
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Load the actual values for the sxfer and the scntl3&n;&t;**&t;register (sync/wide mode).&n;&t;**&n;&t;**&t;SCR_COPY (1), @(sval field of this tcb), @(sxfer  register)&n;&t;**&t;SCR_COPY (1), @(wval field of this tcb), @(scntl3 register)&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|getscr
id|ncrcmd
id|getscr
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Get the IDENTIFY message and load the LUN to SFBR.&n;&t;**&n;&t;**&t;CALL, &lt;RESEL_LUN&gt;&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|call_lun
r_struct
id|link
id|call_lun
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Now look for the right lun.&n;&t;**&n;&t;**&t;For i = 0 to 3&n;&t;**&t;&t;SCR_JUMP ^ IFTRUE(MASK(i, 3)), @(first lcb mod. i)&n;&t;**&n;&t;**&t;Recent chips will prefetch the 4 JUMPS using only 1 burst.&n;&t;**&t;It is kind of hashcoding.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|jump_lcb
r_struct
id|link
id|jump_lcb
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* JUMPs for reselection&t;*/
DECL|member|lp
id|lcb_p
id|lp
(braket
id|MAX_LUN
)braket
suffix:semicolon
multiline_comment|/* The lcb&squot;s of this tcb&t;*/
DECL|member|inq_done
id|u_char
id|inq_done
suffix:semicolon
multiline_comment|/* Target capabilities received&t;*/
DECL|member|inq_byte7
id|u_char
id|inq_byte7
suffix:semicolon
multiline_comment|/* Contains these capabilities&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Pointer to the ccb used for negotiation.&n;&t;**&t;Prevent from starting a negotiation for all queued commands &n;&t;**&t;when tagged command queuing is enabled.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|nego_cp
id|ccb_p
id|nego_cp
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;statistical data&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|transfers
id|u_long
id|transfers
suffix:semicolon
DECL|member|bytes
id|u_long
id|bytes
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;negotiation of wide and synch transfer and device quirks.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|minsync
multiline_comment|/*0*/
id|u_char
id|minsync
suffix:semicolon
DECL|member|sval
multiline_comment|/*1*/
id|u_char
id|sval
suffix:semicolon
DECL|member|period
multiline_comment|/*2*/
id|u_short
id|period
suffix:semicolon
DECL|member|maxoffs
multiline_comment|/*0*/
id|u_char
id|maxoffs
suffix:semicolon
DECL|member|quirks
multiline_comment|/*1*/
id|u_char
id|quirks
suffix:semicolon
DECL|member|widedone
multiline_comment|/*2*/
id|u_char
id|widedone
suffix:semicolon
DECL|member|wval
multiline_comment|/*3*/
id|u_char
id|wval
suffix:semicolon
macro_line|#ifdef SCSI_NCR_INTEGRITY_CHECKING
DECL|member|ic_min_sync
id|u_char
id|ic_min_sync
suffix:semicolon
DECL|member|ic_max_width
id|u_char
id|ic_max_width
suffix:semicolon
DECL|member|ic_maximums_set
id|u_char
id|ic_maximums_set
suffix:semicolon
DECL|member|ic_done
id|u_char
id|ic_done
suffix:semicolon
macro_line|#endif
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;User settable limits and options.&n;&t;**&t;These limits are read from the NVRAM if present.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|usrsync
id|u_char
id|usrsync
suffix:semicolon
DECL|member|usrwide
id|u_char
id|usrwide
suffix:semicolon
DECL|member|usrtags
id|u_char
id|usrtags
suffix:semicolon
DECL|member|usrflag
id|u_char
id|usrflag
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*========================================================================&n;**&n;**&t;Declaration of structs:&t;&t;lun control block&n;**&n;**========================================================================&n;*/
DECL|struct|lcb
r_struct
id|lcb
(brace
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;During reselection the ncr jumps to this point&n;&t;**&t;with SFBR set to the &quot;Identify&quot; message.&n;&t;**&t;if it&squot;s not this lun, jump to the next.&n;&t;**&n;&t;**&t;JUMP  IF (SFBR != #lun#), @(next lcb of this target)&n;&t;**&n;&t;**&t;It is this lun. Load TEMP with the nexus jumps table &n;&t;**&t;address and jump to RESEL_TAG (or RESEL_NOTAG).&n;&t;**&n;&t;**&t;&t;SCR_COPY (4), p_jump_ccb, TEMP,&n;&t;**&t;&t;SCR_JUMP, &lt;RESEL_TAG&gt;&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|jump_lcb
r_struct
id|link
id|jump_lcb
suffix:semicolon
DECL|member|load_jump_ccb
id|ncrcmd
id|load_jump_ccb
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|jump_tag
r_struct
id|link
id|jump_tag
suffix:semicolon
DECL|member|p_jump_ccb
id|ncrcmd
id|p_jump_ccb
suffix:semicolon
multiline_comment|/* Jump table bus address&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Jump table used by the script processor to directly jump &n;&t;**&t;to the CCB corresponding to the reselected nexus.&n;&t;**&t;Address is allocated on 256 bytes boundary in order to &n;&t;**&t;allow 8 bit calculation of the tag jump entry for up to &n;&t;**&t;64 possible tags.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|jump_ccb_0
id|u_int32
id|jump_ccb_0
suffix:semicolon
multiline_comment|/* Default table if no tags&t;*/
DECL|member|jump_ccb
id|u_int32
op_star
id|jump_ccb
suffix:semicolon
multiline_comment|/* Virtual address&t;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;CCB queue management.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|free_ccbq
id|XPT_QUEHEAD
id|free_ccbq
suffix:semicolon
multiline_comment|/* Queue of available CCBs&t;*/
DECL|member|busy_ccbq
id|XPT_QUEHEAD
id|busy_ccbq
suffix:semicolon
multiline_comment|/* Queue of busy CCBs&t;&t;*/
DECL|member|wait_ccbq
id|XPT_QUEHEAD
id|wait_ccbq
suffix:semicolon
multiline_comment|/* Queue of waiting for IO CCBs&t;*/
DECL|member|skip_ccbq
id|XPT_QUEHEAD
id|skip_ccbq
suffix:semicolon
multiline_comment|/* Queue of skipped CCBs&t;*/
DECL|member|actccbs
id|u_char
id|actccbs
suffix:semicolon
multiline_comment|/* Number of allocated CCBs&t;*/
DECL|member|busyccbs
id|u_char
id|busyccbs
suffix:semicolon
multiline_comment|/* CCBs busy for this lun&t;*/
DECL|member|queuedccbs
id|u_char
id|queuedccbs
suffix:semicolon
multiline_comment|/* CCBs queued to the controller*/
DECL|member|queuedepth
id|u_char
id|queuedepth
suffix:semicolon
multiline_comment|/* Queue depth for this lun&t;*/
DECL|member|scdev_depth
id|u_char
id|scdev_depth
suffix:semicolon
multiline_comment|/* SCSI device queue depth&t;*/
DECL|member|maxnxs
id|u_char
id|maxnxs
suffix:semicolon
multiline_comment|/* Max possible nexuses&t;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Control of tagged command queuing.&n;&t;**&t;Tags allocation is performed using a circular buffer.&n;&t;**&t;This avoids using a loop for tag allocation.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|ia_tag
id|u_char
id|ia_tag
suffix:semicolon
multiline_comment|/* Allocation index&t;&t;*/
DECL|member|if_tag
id|u_char
id|if_tag
suffix:semicolon
multiline_comment|/* Freeing index&t;&t;*/
DECL|member|cb_tags
id|u_char
id|cb_tags
(braket
id|MAX_TAGS
)braket
suffix:semicolon
multiline_comment|/* Circular tags buffer&t;*/
DECL|member|usetags
id|u_char
id|usetags
suffix:semicolon
multiline_comment|/* Command queuing is active&t;*/
DECL|member|maxtags
id|u_char
id|maxtags
suffix:semicolon
multiline_comment|/* Max nr of tags asked by user&t;*/
DECL|member|numtags
id|u_char
id|numtags
suffix:semicolon
multiline_comment|/* Current number of tags&t;*/
DECL|member|inq_byte7
id|u_char
id|inq_byte7
suffix:semicolon
multiline_comment|/* Store unit CmdQ capabitility&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;QUEUE FULL control and ORDERED tag control.&n;&t;**----------------------------------------------------------------&n;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;QUEUE FULL and ORDERED tag control.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|num_good
id|u_short
id|num_good
suffix:semicolon
multiline_comment|/* Nr of GOOD since QUEUE FULL&t;*/
DECL|member|tags_umap
id|tagmap_t
id|tags_umap
suffix:semicolon
multiline_comment|/* Used tags bitmap&t;&t;*/
DECL|member|tags_smap
id|tagmap_t
id|tags_smap
suffix:semicolon
multiline_comment|/* Tags in use at &squot;tag_stime&squot;&t;*/
DECL|member|tags_stime
id|u_long
id|tags_stime
suffix:semicolon
multiline_comment|/* Last time we set smap=umap&t;*/
DECL|member|held_ccb
id|ccb_p
id|held_ccb
suffix:semicolon
multiline_comment|/* CCB held for QUEUE FULL&t;*/
)brace
suffix:semicolon
multiline_comment|/*========================================================================&n;**&n;**      Declaration of structs:     the launch script.&n;**&n;**========================================================================&n;**&n;**&t;It is part of the CCB and is called by the scripts processor to &n;**&t;start or restart the data structure (nexus).&n;**&t;This 6 DWORDs mini script makes use of prefetching.&n;**&n;**------------------------------------------------------------------------&n;*/
DECL|struct|launch
r_struct
id|launch
(brace
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;SCR_COPY(4),&t;@(p_phys), @(dsa register)&n;&t;**&t;SCR_JUMP,&t;@(scheduler_point)&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|setup_dsa
id|ncrcmd
id|setup_dsa
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Copy &squot;phys&squot; address to dsa&t;*/
DECL|member|schedule
r_struct
id|link
id|schedule
suffix:semicolon
multiline_comment|/* Jump to scheduler point&t;*/
DECL|member|p_phys
id|ncrcmd
id|p_phys
suffix:semicolon
multiline_comment|/* &squot;phys&squot; header bus address&t;*/
)brace
suffix:semicolon
multiline_comment|/*========================================================================&n;**&n;**      Declaration of structs:     global HEADER.&n;**&n;**========================================================================&n;**&n;**&t;This substructure is copied from the ccb to a global address after &n;**&t;selection (or reselection) and copied back before disconnect.&n;**&n;**&t;These fields are accessible to the script processor.&n;**&n;**------------------------------------------------------------------------&n;*/
DECL|struct|head
r_struct
id|head
(brace
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Saved data pointer.&n;&t;**&t;Points to the position in the script responsible for the&n;&t;**&t;actual transfer transfer of data.&n;&t;**&t;It&squot;s written after reception of a SAVE_DATA_POINTER message.&n;&t;**&t;The goalpointer points after the last transfer command.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|savep
id|u_int32
id|savep
suffix:semicolon
DECL|member|lastp
id|u_int32
id|lastp
suffix:semicolon
DECL|member|goalp
id|u_int32
id|goalp
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Alternate data pointer.&n;&t;**&t;They are copied back to savep/lastp/goalp by the SCRIPTS &n;&t;**&t;when the direction is unknown and the device claims data out.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|wlastp
id|u_int32
id|wlastp
suffix:semicolon
DECL|member|wgoalp
id|u_int32
id|wgoalp
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;The virtual address of the ccb containing this header.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|cp
id|ccb_p
id|cp
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Space for some timestamps to gather profiling data.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|stamp
r_struct
id|tstamp
id|stamp
suffix:semicolon
macro_line|#endif
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Status fields.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|scr_st
id|u_char
id|scr_st
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* script status&t;&t;*/
DECL|member|status
id|u_char
id|status
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* host status. must be the &t;*/
multiline_comment|/*  last DWORD of the header.&t;*/
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;The status bytes are used by the host and the script processor.&n;**&n;**&t;The byte corresponding to the host_status must be stored in the &n;**&t;last DWORD of the CCB header since it is used for command &n;**&t;completion (ncr_wakeup()). Doing so, we are sure that the header &n;**&t;has been entirely copied back to the CCB when the host_status is &n;**&t;seen complete by the CPU.&n;**&n;**&t;The last four bytes (status[4]) are copied to the scratchb register&n;**&t;(declared as scr0..scr3 in ncr_reg.h) just after the select/reselect,&n;**&t;and copied back just after disconnecting.&n;**&t;Inside the script the XX_REG are used.&n;**&n;**&t;The first four bytes (scr_st[4]) are used inside the script by &n;**&t;&quot;COPY&quot; commands.&n;**&t;Because source and destination must have the same alignment&n;**&t;in a DWORD, the fields HAVE to be at the choosen offsets.&n;**&t;&t;xerr_st&t;&t;0&t;(0x34)&t;scratcha&n;**&t;&t;sync_st&t;&t;1&t;(0x05)&t;sxfer&n;**&t;&t;wide_st&t;&t;3&t;(0x03)&t;scntl3&n;*/
multiline_comment|/*&n;**&t;Last four bytes (script)&n;*/
DECL|macro|QU_REG
mdefine_line|#define  QU_REG&t;scr0
DECL|macro|HS_REG
mdefine_line|#define  HS_REG&t;scr1
DECL|macro|HS_PRT
mdefine_line|#define  HS_PRT&t;nc_scr1
DECL|macro|SS_REG
mdefine_line|#define  SS_REG&t;scr2
DECL|macro|SS_PRT
mdefine_line|#define  SS_PRT&t;nc_scr2
DECL|macro|PS_REG
mdefine_line|#define  PS_REG&t;scr3
multiline_comment|/*&n;**&t;Last four bytes (host)&n;*/
DECL|macro|actualquirks
mdefine_line|#define  actualquirks  phys.header.status[0]
DECL|macro|host_status
mdefine_line|#define  host_status   phys.header.status[1]
DECL|macro|scsi_status
mdefine_line|#define  scsi_status   phys.header.status[2]
DECL|macro|parity_status
mdefine_line|#define  parity_status phys.header.status[3]
multiline_comment|/*&n;**&t;First four bytes (script)&n;*/
DECL|macro|xerr_st
mdefine_line|#define  xerr_st       header.scr_st[0]
DECL|macro|sync_st
mdefine_line|#define  sync_st       header.scr_st[1]
DECL|macro|nego_st
mdefine_line|#define  nego_st       header.scr_st[2]
DECL|macro|wide_st
mdefine_line|#define  wide_st       header.scr_st[3]
multiline_comment|/*&n;**&t;First four bytes (host)&n;*/
DECL|macro|xerr_status
mdefine_line|#define  xerr_status   phys.xerr_st
DECL|macro|nego_status
mdefine_line|#define  nego_status   phys.nego_st
macro_line|#if 0
mdefine_line|#define  sync_status   phys.sync_st
mdefine_line|#define  wide_status   phys.wide_st
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**      Declaration of structs:     Data structure block&n;**&n;**==========================================================&n;**&n;**&t;During execution of a ccb by the script processor,&n;**&t;the DSA (data structure address) register points&n;**&t;to this substructure of the ccb.&n;**&t;This substructure contains the header with&n;**&t;the script-processor-changable data and&n;**&t;data blocks for the indirect move commands.&n;**&n;**----------------------------------------------------------&n;*/
DECL|struct|dsb
r_struct
id|dsb
(brace
multiline_comment|/*&n;&t;**&t;Header.&n;&t;*/
DECL|member|header
r_struct
id|head
id|header
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Table data for Script&n;&t;*/
DECL|member|select
r_struct
id|scr_tblsel
id|select
suffix:semicolon
DECL|member|smsg
r_struct
id|scr_tblmove
id|smsg
suffix:semicolon
DECL|member|cmd
r_struct
id|scr_tblmove
id|cmd
suffix:semicolon
DECL|member|sense
r_struct
id|scr_tblmove
id|sense
suffix:semicolon
DECL|member|data
r_struct
id|scr_tblmove
id|data
(braket
id|MAX_SCATTER
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*========================================================================&n;**&n;**      Declaration of structs:     Command control block.&n;**&n;**========================================================================&n;*/
DECL|struct|ccb
r_struct
id|ccb
(brace
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;This is the data structure which is pointed by the DSA &n;&t;**&t;register when it is executed by the script processor.&n;&t;**&t;It must be the first entry because it contains the header &n;&t;**&t;as first entry that must be cache line aligned.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|phys
r_struct
id|dsb
id|phys
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Mini-script used at CCB execution start-up.&n;&t;**&t;Load the DSA with the data structure address (phys) and &n;&t;**&t;jump to SELECT. Jump to CANCEL if CCB is to be canceled.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|start
r_struct
id|launch
id|start
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Mini-script used at CCB relection to restart the nexus.&n;&t;**&t;Load the DSA with the data structure address (phys) and &n;&t;**&t;jump to RESEL_DSA. Jump to ABORT if CCB is to be aborted.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|restart
r_struct
id|launch
id|restart
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;If a data transfer phase is terminated too early&n;&t;**&t;(after reception of a message (i.e. DISCONNECT)),&n;&t;**&t;we have to prepare a mini script to transfer&n;&t;**&t;the rest of the data.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|patch
id|ncrcmd
id|patch
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;The general SCSI driver provides a&n;&t;**&t;pointer to a control block.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|cmd
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
multiline_comment|/* SCSI command &t;&t;*/
DECL|member|cdb_buf
id|u_char
id|cdb_buf
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Copy of CDB&t;&t;&t;*/
DECL|member|sense_buf
id|u_char
id|sense_buf
(braket
l_int|64
)braket
suffix:semicolon
DECL|member|data_len
r_int
id|data_len
suffix:semicolon
multiline_comment|/* Total data length&t;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Message areas.&n;&t;**&t;We prepare a message to be sent after selection.&n;&t;**&t;We may use a second one if the command is rescheduled &n;&t;**&t;due to GETCC or QFULL.&n;&t;**      Contents are IDENTIFY and SIMPLE_TAG.&n;&t;**&t;While negotiating sync or wide transfer,&n;&t;**&t;a SDTR or WDTR message is appended.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|scsi_smsg
id|u_char
id|scsi_smsg
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|scsi_smsg2
id|u_char
id|scsi_smsg2
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Other fields.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|p_ccb
id|u_long
id|p_ccb
suffix:semicolon
multiline_comment|/* BUS address of this CCB&t;*/
DECL|member|sensecmd
id|u_char
id|sensecmd
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* Sense command&t;&t;*/
DECL|member|tag
id|u_char
id|tag
suffix:semicolon
multiline_comment|/* Tag for this transfer&t;*/
multiline_comment|/*  255 means no tag&t;&t;*/
DECL|member|target
id|u_char
id|target
suffix:semicolon
DECL|member|lun
id|u_char
id|lun
suffix:semicolon
DECL|member|queued
id|u_char
id|queued
suffix:semicolon
DECL|member|auto_sense
id|u_char
id|auto_sense
suffix:semicolon
DECL|member|link_ccb
id|ccb_p
id|link_ccb
suffix:semicolon
multiline_comment|/* Host adapter CCB chain&t;*/
DECL|member|link_ccbq
id|XPT_QUEHEAD
id|link_ccbq
suffix:semicolon
multiline_comment|/* Link to unit CCB queue&t;*/
DECL|member|startp
id|u_int32
id|startp
suffix:semicolon
multiline_comment|/* Initial data pointer&t;&t;*/
DECL|member|magic
id|u_long
id|magic
suffix:semicolon
multiline_comment|/* Free / busy  CCB flag&t;*/
)brace
suffix:semicolon
DECL|macro|CCB_PHYS
mdefine_line|#define CCB_PHYS(cp,lbl)&t;(cp-&gt;p_ccb + offsetof(struct ccb, lbl))
multiline_comment|/*========================================================================&n;**&n;**      Declaration of structs:     NCR device descriptor&n;**&n;**========================================================================&n;*/
DECL|struct|ncb
r_struct
id|ncb
(brace
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;The global header.&n;&t;**&t;It is accessible to both the host and the script processor.&n;&t;**&t;Must be cache line size aligned (32 for x86) in order to &n;&t;**&t;allow cache line bursting when it is copied to/from CCB.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|header
r_struct
id|head
id|header
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;CCBs management queues.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|waiting_list
id|Scsi_Cmnd
op_star
id|waiting_list
suffix:semicolon
multiline_comment|/* Commands waiting for a CCB&t;*/
multiline_comment|/*  when lcb is not allocated.&t;*/
DECL|member|done_list
id|Scsi_Cmnd
op_star
id|done_list
suffix:semicolon
multiline_comment|/* Commands waiting for done()  */
multiline_comment|/* callback to be invoked.      */
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,93)
DECL|member|smp_lock
id|spinlock_t
id|smp_lock
suffix:semicolon
multiline_comment|/* Lock for SMP threading       */
macro_line|#endif
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Chip and controller indentification.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|unit
r_int
id|unit
suffix:semicolon
multiline_comment|/* Unit number&t;&t;&t;*/
DECL|member|chip_name
r_char
id|chip_name
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Chip name&t;&t;&t;*/
DECL|member|inst_name
r_char
id|inst_name
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* ncb instance name&t;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Initial value of some IO register bits.&n;&t;**&t;These values are assumed to have been set by BIOS, and may &n;&t;**&t;be used for probing adapter implementation differences.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|sv_scntl0
DECL|member|sv_scntl3
DECL|member|sv_dmode
DECL|member|sv_dcntl
DECL|member|sv_ctest3
DECL|member|sv_ctest4
id|u_char
id|sv_scntl0
comma
id|sv_scntl3
comma
id|sv_dmode
comma
id|sv_dcntl
comma
id|sv_ctest3
comma
id|sv_ctest4
comma
DECL|member|sv_ctest5
DECL|member|sv_gpcntl
DECL|member|sv_stest2
DECL|member|sv_stest4
id|sv_ctest5
comma
id|sv_gpcntl
comma
id|sv_stest2
comma
id|sv_stest4
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Actual initial value of IO register bits used by the &n;&t;**&t;driver. They are loaded at initialisation according to  &n;&t;**&t;features that are to be enabled.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|rv_scntl0
DECL|member|rv_scntl3
DECL|member|rv_dmode
DECL|member|rv_dcntl
DECL|member|rv_ctest3
DECL|member|rv_ctest4
id|u_char
id|rv_scntl0
comma
id|rv_scntl3
comma
id|rv_dmode
comma
id|rv_dcntl
comma
id|rv_ctest3
comma
id|rv_ctest4
comma
DECL|member|rv_ctest5
DECL|member|rv_stest2
id|rv_ctest5
comma
id|rv_stest2
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Targets management.&n;&t;**&t;During reselection the ncr jumps to jump_tcb.&n;&t;**&t;The SFBR register is loaded with the encoded target id.&n;&t;**&t;For i = 0 to 3&n;&t;**&t;&t;SCR_JUMP ^ IFTRUE(MASK(i, 3)), @(next tcb mod. i)&n;&t;**&n;&t;**&t;Recent chips will prefetch the 4 JUMPS using only 1 burst.&n;&t;**&t;It is kind of hashcoding.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|jump_tcb
r_struct
id|link
id|jump_tcb
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* JUMPs for reselection&t;*/
DECL|member|target
r_struct
id|tcb
id|target
(braket
id|MAX_TARGET
)braket
suffix:semicolon
multiline_comment|/* Target data&t;&t;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Virtual and physical bus addresses of the chip.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|vaddr
id|vm_offset_t
id|vaddr
suffix:semicolon
multiline_comment|/* Virtual and bus address of&t;*/
DECL|member|paddr
id|vm_offset_t
id|paddr
suffix:semicolon
multiline_comment|/*  chip&squot;s IO registers.&t;*/
DECL|member|paddr2
id|vm_offset_t
id|paddr2
suffix:semicolon
multiline_comment|/* On-chip RAM bus address.&t;*/
r_volatile
multiline_comment|/* Pointer to volatile for &t;*/
DECL|member|reg
r_struct
id|ncr_reg
op_star
id|reg
suffix:semicolon
multiline_comment|/*  memory mapped IO.&t;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;SCRIPTS virtual and physical bus addresses.&n;&t;**&t;&squot;script&squot;  is loaded in the on-chip RAM if present.&n;&t;**&t;&squot;scripth&squot; stays in main memory.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|script0
r_struct
id|script
op_star
id|script0
suffix:semicolon
multiline_comment|/* Copies of script and scripth&t;*/
DECL|member|scripth0
r_struct
id|scripth
op_star
id|scripth0
suffix:semicolon
multiline_comment|/*  relocated for this ncb.&t;*/
DECL|member|scripth
r_struct
id|scripth
op_star
id|scripth
suffix:semicolon
multiline_comment|/* Actual scripth virt. address&t;*/
DECL|member|p_script
id|u_long
id|p_script
suffix:semicolon
multiline_comment|/* Actual script and scripth&t;*/
DECL|member|p_scripth
id|u_long
id|p_scripth
suffix:semicolon
multiline_comment|/*  bus addresses.&t;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;General controller parameters and configuration.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|pdev
id|pcidev_t
id|pdev
suffix:semicolon
DECL|member|device_id
id|u_short
id|device_id
suffix:semicolon
multiline_comment|/* PCI device id&t;&t;*/
DECL|member|revision_id
id|u_char
id|revision_id
suffix:semicolon
multiline_comment|/* PCI device revision id&t;*/
DECL|member|bus
id|u_char
id|bus
suffix:semicolon
multiline_comment|/* PCI BUS number&t;&t;*/
DECL|member|device_fn
id|u_char
id|device_fn
suffix:semicolon
multiline_comment|/* PCI BUS device and function&t;*/
DECL|member|base_io
id|u_long
id|base_io
suffix:semicolon
multiline_comment|/* IO space base address&t;*/
DECL|member|irq
id|u_int
id|irq
suffix:semicolon
multiline_comment|/* IRQ level&t;&t;&t;*/
DECL|member|features
id|u_int
id|features
suffix:semicolon
multiline_comment|/* Chip features map&t;&t;*/
DECL|member|myaddr
id|u_char
id|myaddr
suffix:semicolon
multiline_comment|/* SCSI id of the adapter&t;*/
DECL|member|maxburst
id|u_char
id|maxburst
suffix:semicolon
multiline_comment|/* log base 2 of dwords burst&t;*/
DECL|member|maxwide
id|u_char
id|maxwide
suffix:semicolon
multiline_comment|/* Maximum transfer width&t;*/
DECL|member|minsync
id|u_char
id|minsync
suffix:semicolon
multiline_comment|/* Minimum sync period factor&t;*/
DECL|member|maxsync
id|u_char
id|maxsync
suffix:semicolon
multiline_comment|/* Maximum sync period factor&t;*/
DECL|member|maxoffs
id|u_char
id|maxoffs
suffix:semicolon
multiline_comment|/* Max scsi offset&t;&t;*/
DECL|member|multiplier
id|u_char
id|multiplier
suffix:semicolon
multiline_comment|/* Clock multiplier (1,2,4)&t;*/
DECL|member|clock_divn
id|u_char
id|clock_divn
suffix:semicolon
multiline_comment|/* Number of clock divisors&t;*/
DECL|member|clock_khz
id|u_long
id|clock_khz
suffix:semicolon
multiline_comment|/* SCSI clock frequency in KHz&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Start queue management.&n;&t;**&t;It is filled up by the host processor and accessed by the &n;&t;**&t;SCRIPTS processor in order to start SCSI commands.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|squeueput
id|u_short
id|squeueput
suffix:semicolon
multiline_comment|/* Next free slot of the queue&t;*/
DECL|member|actccbs
id|u_short
id|actccbs
suffix:semicolon
multiline_comment|/* Number of allocated CCBs&t;*/
DECL|member|queuedccbs
id|u_short
id|queuedccbs
suffix:semicolon
multiline_comment|/* Number of CCBs in start queue*/
DECL|member|queuedepth
id|u_short
id|queuedepth
suffix:semicolon
multiline_comment|/* Start queue depth&t;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Timeout handler.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* Timer handler link header&t;*/
DECL|member|lasttime
id|u_long
id|lasttime
suffix:semicolon
DECL|member|settle_time
id|u_long
id|settle_time
suffix:semicolon
multiline_comment|/* Resetting the SCSI BUS&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Debugging and profiling.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|regdump
r_struct
id|ncr_reg
id|regdump
suffix:semicolon
multiline_comment|/* Register dump&t;&t;*/
DECL|member|regtime
id|u_long
id|regtime
suffix:semicolon
multiline_comment|/* Time it has been done&t;*/
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
DECL|member|profile
r_struct
id|profile
id|profile
suffix:semicolon
multiline_comment|/* Profiling data&t;&t;*/
DECL|member|disc_phys
id|u_int
id|disc_phys
suffix:semicolon
multiline_comment|/* Disconnection counters &t;*/
DECL|member|disc_ref
id|u_int
id|disc_ref
suffix:semicolon
macro_line|#endif
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Miscellaneous buffers accessed by the scripts-processor.&n;&t;**&t;They shall be DWORD aligned, because they may be read or &n;&t;**&t;written with a SCR_COPY script command.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|msgout
id|u_char
id|msgout
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Buffer for MESSAGE OUT &t;*/
DECL|member|msgin
id|u_char
id|msgin
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Buffer for MESSAGE IN&t;*/
DECL|member|lastmsg
id|u_int32
id|lastmsg
suffix:semicolon
multiline_comment|/* Last SCSI message sent&t;*/
DECL|member|scratch
id|u_char
id|scratch
suffix:semicolon
multiline_comment|/* Scratch for SCSI receive&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Miscellaneous configuration and status parameters.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|disc
id|u_char
id|disc
suffix:semicolon
multiline_comment|/* Diconnection allowed&t;&t;*/
DECL|member|scsi_mode
id|u_char
id|scsi_mode
suffix:semicolon
multiline_comment|/* Current SCSI BUS mode&t;*/
DECL|member|order
id|u_char
id|order
suffix:semicolon
multiline_comment|/* Tag order to use&t;&t;*/
DECL|member|verbose
id|u_char
id|verbose
suffix:semicolon
multiline_comment|/* Verbosity for this controller*/
DECL|member|ncr_cache
r_int
id|ncr_cache
suffix:semicolon
multiline_comment|/* Used for cache test at init.&t;*/
DECL|member|p_ncb
id|u_long
id|p_ncb
suffix:semicolon
multiline_comment|/* BUS address of this NCB&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Command completion handling.&n;&t;**----------------------------------------------------------------&n;&t;*/
macro_line|#ifdef SCSI_NCR_CCB_DONE_SUPPORT
DECL|member|ccb_done
r_struct
id|ccb
op_star
(paren
id|ccb_done
(braket
id|MAX_DONE
)braket
)paren
suffix:semicolon
DECL|member|ccb_done_ic
r_int
id|ccb_done_ic
suffix:semicolon
macro_line|#endif
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Fields that should be removed or changed.&n;&t;**----------------------------------------------------------------&n;&t;*/
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
DECL|member|ktime
id|u_long
id|ktime
suffix:semicolon
multiline_comment|/* Copy of kernel time&t;&t;*/
macro_line|#endif
DECL|member|ccb
r_struct
id|ccb
op_star
id|ccb
suffix:semicolon
multiline_comment|/* Global CCB&t;&t;&t;*/
DECL|member|user
r_struct
id|usrcmd
id|user
suffix:semicolon
multiline_comment|/* Command from user&t;&t;*/
DECL|member|release_stage
id|u_char
id|release_stage
suffix:semicolon
multiline_comment|/* Synchronisation stage on release  */
macro_line|#ifdef SCSI_NCR_INTEGRITY_CHECKING
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Fields that are used for integrity check&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|check_integrity
r_int
r_char
id|check_integrity
suffix:semicolon
multiline_comment|/* Enable midlayer integ.check on&n;&t;&t;&t;&t;&t;* bus scan. */
DECL|member|check_integ_par
r_int
r_char
id|check_integ_par
suffix:semicolon
multiline_comment|/* Set if par or Init. Det. error&n;&t;&t;&t;&t;&t; * used only during integ check */
macro_line|#endif
)brace
suffix:semicolon
DECL|macro|NCB_SCRIPT_PHYS
mdefine_line|#define NCB_SCRIPT_PHYS(np,lbl)&t; (np-&gt;p_script  + offsetof (struct script, lbl))
DECL|macro|NCB_SCRIPTH_PHYS
mdefine_line|#define NCB_SCRIPTH_PHYS(np,lbl) (np-&gt;p_scripth + offsetof (struct scripth,lbl))
multiline_comment|/*==========================================================&n;**&n;**&n;**      Script for NCR-Processor.&n;**&n;**&t;Use ncr_script_fill() to create the variable parts.&n;**&t;Use ncr_script_copy_and_bind() to make a copy and&n;**&t;bind to physical addresses.&n;**&n;**&n;**==========================================================&n;**&n;**&t;We have to know the offsets of all labels before&n;**&t;we reach them (for forward jumps).&n;**&t;Therefore we declare a struct here.&n;**&t;If you make changes inside the script,&n;**&t;DONT FORGET TO CHANGE THE LENGTHS HERE!&n;**&n;**----------------------------------------------------------&n;*/
multiline_comment|/*&n;**&t;Script fragments which are loaded into the on-chip RAM &n;**&t;of 825A, 875 and 895 chips.&n;*/
DECL|struct|script
r_struct
id|script
(brace
DECL|member|start
id|ncrcmd
id|start
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|startpos
id|ncrcmd
id|startpos
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|select
id|ncrcmd
id|select
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|select2
id|ncrcmd
id|select2
(braket
l_int|9
)braket
suffix:semicolon
DECL|member|loadpos
id|ncrcmd
id|loadpos
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|send_ident
id|ncrcmd
id|send_ident
(braket
l_int|9
)braket
suffix:semicolon
DECL|member|prepare
id|ncrcmd
id|prepare
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|prepare2
id|ncrcmd
id|prepare2
(braket
l_int|7
)braket
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
DECL|member|command
id|ncrcmd
id|command
(braket
l_int|9
)braket
suffix:semicolon
macro_line|#else
DECL|member|command
id|ncrcmd
id|command
(braket
l_int|6
)braket
suffix:semicolon
macro_line|#endif
DECL|member|dispatch
id|ncrcmd
id|dispatch
(braket
l_int|32
)braket
suffix:semicolon
DECL|member|clrack
id|ncrcmd
id|clrack
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|no_data
id|ncrcmd
id|no_data
(braket
l_int|17
)braket
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
DECL|member|status
id|ncrcmd
id|status
(braket
l_int|11
)braket
suffix:semicolon
macro_line|#else
DECL|member|status
id|ncrcmd
id|status
(braket
l_int|8
)braket
suffix:semicolon
macro_line|#endif
DECL|member|msg_in
id|ncrcmd
id|msg_in
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|msg_in2
id|ncrcmd
id|msg_in2
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|msg_bad
id|ncrcmd
id|msg_bad
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|setmsg
id|ncrcmd
id|setmsg
(braket
l_int|7
)braket
suffix:semicolon
DECL|member|cleanup
id|ncrcmd
id|cleanup
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|complete
id|ncrcmd
id|complete
(braket
l_int|9
)braket
suffix:semicolon
DECL|member|cleanup_ok
id|ncrcmd
id|cleanup_ok
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|cleanup0
id|ncrcmd
id|cleanup0
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#ifndef SCSI_NCR_CCB_DONE_SUPPORT
DECL|member|signal
id|ncrcmd
id|signal
(braket
l_int|12
)braket
suffix:semicolon
macro_line|#else
DECL|member|signal
id|ncrcmd
id|signal
(braket
l_int|9
)braket
suffix:semicolon
DECL|member|done_pos
id|ncrcmd
id|done_pos
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|done_plug
id|ncrcmd
id|done_plug
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|done_end
id|ncrcmd
id|done_end
(braket
l_int|7
)braket
suffix:semicolon
macro_line|#endif
DECL|member|save_dp
id|ncrcmd
id|save_dp
(braket
l_int|7
)braket
suffix:semicolon
DECL|member|restore_dp
id|ncrcmd
id|restore_dp
(braket
l_int|5
)braket
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
DECL|member|disconnect
id|ncrcmd
id|disconnect
(braket
l_int|28
)braket
suffix:semicolon
macro_line|#else
DECL|member|disconnect
id|ncrcmd
id|disconnect
(braket
l_int|17
)braket
suffix:semicolon
macro_line|#endif
DECL|member|msg_out
id|ncrcmd
id|msg_out
(braket
l_int|9
)braket
suffix:semicolon
DECL|member|msg_out_done
id|ncrcmd
id|msg_out_done
(braket
l_int|7
)braket
suffix:semicolon
DECL|member|idle
id|ncrcmd
id|idle
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|reselect
id|ncrcmd
id|reselect
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|reselected
id|ncrcmd
id|reselected
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|resel_dsa
id|ncrcmd
id|resel_dsa
(braket
l_int|6
)braket
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
DECL|member|loadpos1
id|ncrcmd
id|loadpos1
(braket
l_int|7
)braket
suffix:semicolon
macro_line|#else
DECL|member|loadpos1
id|ncrcmd
id|loadpos1
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#endif
DECL|member|resel_lun
id|ncrcmd
id|resel_lun
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|resel_tag
id|ncrcmd
id|resel_tag
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|jump_to_nexus
id|ncrcmd
id|jump_to_nexus
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|nexus_indirect
id|ncrcmd
id|nexus_indirect
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|resel_notag
id|ncrcmd
id|resel_notag
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|data_in
id|ncrcmd
id|data_in
(braket
id|MAX_SCATTERL
op_star
l_int|4
)braket
suffix:semicolon
DECL|member|data_in2
id|ncrcmd
id|data_in2
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|data_out
id|ncrcmd
id|data_out
(braket
id|MAX_SCATTERL
op_star
l_int|4
)braket
suffix:semicolon
DECL|member|data_out2
id|ncrcmd
id|data_out2
(braket
l_int|4
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;Script fragments which stay in main memory for all chips.&n;*/
DECL|struct|scripth
r_struct
id|scripth
(brace
DECL|member|tryloop
id|ncrcmd
id|tryloop
(braket
id|MAX_START
op_star
l_int|2
)braket
suffix:semicolon
DECL|member|tryloop2
id|ncrcmd
id|tryloop2
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#ifdef SCSI_NCR_CCB_DONE_SUPPORT
DECL|member|done_queue
id|ncrcmd
id|done_queue
(braket
id|MAX_DONE
op_star
l_int|5
)braket
suffix:semicolon
DECL|member|done_queue2
id|ncrcmd
id|done_queue2
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#endif
DECL|member|select_no_atn
id|ncrcmd
id|select_no_atn
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|cancel
id|ncrcmd
id|cancel
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|skip
id|ncrcmd
id|skip
(braket
l_int|9
)braket
suffix:semicolon
DECL|member|skip2
id|ncrcmd
id|skip2
(braket
l_int|19
)braket
suffix:semicolon
DECL|member|par_err_data_in
id|ncrcmd
id|par_err_data_in
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|par_err_other
id|ncrcmd
id|par_err_other
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_reject
id|ncrcmd
id|msg_reject
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|msg_ign_residue
id|ncrcmd
id|msg_ign_residue
(braket
l_int|24
)braket
suffix:semicolon
DECL|member|msg_extended
id|ncrcmd
id|msg_extended
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|msg_ext_2
id|ncrcmd
id|msg_ext_2
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|msg_wdtr
id|ncrcmd
id|msg_wdtr
(braket
l_int|14
)braket
suffix:semicolon
DECL|member|send_wdtr
id|ncrcmd
id|send_wdtr
(braket
l_int|7
)braket
suffix:semicolon
DECL|member|msg_ext_3
id|ncrcmd
id|msg_ext_3
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|msg_sdtr
id|ncrcmd
id|msg_sdtr
(braket
l_int|14
)braket
suffix:semicolon
DECL|member|send_sdtr
id|ncrcmd
id|send_sdtr
(braket
l_int|7
)braket
suffix:semicolon
DECL|member|nego_bad_phase
id|ncrcmd
id|nego_bad_phase
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_out_abort
id|ncrcmd
id|msg_out_abort
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|hdata_in
id|ncrcmd
id|hdata_in
(braket
id|MAX_SCATTERH
op_star
l_int|4
)braket
suffix:semicolon
DECL|member|hdata_in2
id|ncrcmd
id|hdata_in2
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|hdata_out
id|ncrcmd
id|hdata_out
(braket
id|MAX_SCATTERH
op_star
l_int|4
)braket
suffix:semicolon
DECL|member|hdata_out2
id|ncrcmd
id|hdata_out2
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|reset
id|ncrcmd
id|reset
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|aborttag
id|ncrcmd
id|aborttag
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|abort
id|ncrcmd
m_abort
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|abort_resel
id|ncrcmd
id|abort_resel
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|resend_ident
id|ncrcmd
id|resend_ident
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|clratn_go_on
id|ncrcmd
id|clratn_go_on
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|nxtdsp_go_on
id|ncrcmd
id|nxtdsp_go_on
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|sdata_in
id|ncrcmd
id|sdata_in
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|data_io
id|ncrcmd
id|data_io
(braket
l_int|18
)braket
suffix:semicolon
DECL|member|bad_identify
id|ncrcmd
id|bad_identify
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|bad_i_t_l
id|ncrcmd
id|bad_i_t_l
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|bad_i_t_l_q
id|ncrcmd
id|bad_i_t_l_q
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|bad_target
id|ncrcmd
id|bad_target
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|bad_status
id|ncrcmd
id|bad_status
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|start_ram
id|ncrcmd
id|start_ram
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|start_ram0
id|ncrcmd
id|start_ram0
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|sto_restart
id|ncrcmd
id|sto_restart
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|snooptest
id|ncrcmd
id|snooptest
(braket
l_int|9
)braket
suffix:semicolon
DECL|member|snoopend
id|ncrcmd
id|snoopend
(braket
l_int|2
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&n;**      Function headers.&n;**&n;**&n;**==========================================================&n;*/
r_static
r_void
id|ncr_alloc_ccb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
suffix:semicolon
r_static
r_void
id|ncr_complete
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
r_static
r_void
id|ncr_exception
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_free_ccb
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
r_static
r_void
id|ncr_init_ccb
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
r_static
r_void
id|ncr_init_tcb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
)paren
suffix:semicolon
r_static
id|lcb_p
id|ncr_alloc_lcb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
suffix:semicolon
r_static
id|lcb_p
id|ncr_setup_lcb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
comma
id|u_char
op_star
id|inq_data
)paren
suffix:semicolon
r_static
r_void
id|ncr_getclock
(paren
id|ncb_p
id|np
comma
r_int
id|mult
)paren
suffix:semicolon
r_static
r_void
id|ncr_selectclock
(paren
id|ncb_p
id|np
comma
id|u_char
id|scntl3
)paren
suffix:semicolon
r_static
id|ccb_p
id|ncr_get_ccb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
suffix:semicolon
r_static
r_void
id|ncr_init
(paren
id|ncb_p
id|np
comma
r_int
id|reset
comma
r_char
op_star
id|msg
comma
id|u_long
id|code
)paren
suffix:semicolon
r_static
r_int
id|ncr_int_sbmc
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_int
id|ncr_int_par
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_ma
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_sir
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_sto
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
id|u_long
id|ncr_lookup
(paren
r_char
op_star
id|id
)paren
suffix:semicolon
r_static
r_void
id|ncr_negotiate
(paren
r_struct
id|ncb
op_star
id|np
comma
r_struct
id|tcb
op_star
id|tp
)paren
suffix:semicolon
r_static
r_int
id|ncr_prepare_nego
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
op_star
id|msgptr
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_INTEGRITY_CHECKING
r_static
r_int
id|ncr_ic_nego
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
id|u_char
op_star
id|msgptr
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
r_static
r_void
id|ncb_profile
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|ncr_script_copy_and_bind
(paren
id|ncb_p
id|np
comma
id|ncrcmd
op_star
id|src
comma
id|ncrcmd
op_star
id|dst
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_void
id|ncr_script_fill
(paren
r_struct
id|script
op_star
id|scr
comma
r_struct
id|scripth
op_star
id|scripth
)paren
suffix:semicolon
r_static
r_int
id|ncr_scatter
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|ncr_getsync
(paren
id|ncb_p
id|np
comma
id|u_char
id|sfac
comma
id|u_char
op_star
id|fakp
comma
id|u_char
op_star
id|scntl3p
)paren
suffix:semicolon
r_static
r_void
id|ncr_setsync
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|scntl3
comma
id|u_char
id|sxfer
)paren
suffix:semicolon
r_static
r_void
id|ncr_setup_tags
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
suffix:semicolon
r_static
r_void
id|ncr_setwide
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|wide
comma
id|u_char
id|ack
)paren
suffix:semicolon
r_static
r_int
id|ncr_show_msg
(paren
id|u_char
op_star
id|msg
)paren
suffix:semicolon
r_static
r_void
id|ncr_print_msg
(paren
id|ccb_p
id|cp
comma
r_char
op_star
id|label
comma
id|u_char
op_star
id|msg
)paren
suffix:semicolon
r_static
r_int
id|ncr_snooptest
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_timeout
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_wakeup
(paren
id|ncb_p
id|np
comma
id|u_long
id|code
)paren
suffix:semicolon
r_static
r_void
id|ncr_wakeup_done
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_start_next_ccb
(paren
id|ncb_p
id|np
comma
id|lcb_p
id|lp
comma
r_int
id|maxn
)paren
suffix:semicolon
r_static
r_void
id|ncr_put_start_queue
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
r_static
r_void
id|ncr_start_reset
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_int
id|ncr_reset_scsi_bus
(paren
id|ncb_p
id|np
comma
r_int
id|enab_int
comma
r_int
id|settle_delay
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_USER_COMMAND_SUPPORT
r_static
r_void
id|ncr_usercmd
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|ncr_attach
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|unit
comma
id|ncr_device
op_star
id|device
)paren
suffix:semicolon
r_static
r_void
id|insert_into_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
id|Scsi_Cmnd
op_star
id|retrieve_from_waiting_list
c_func
(paren
r_int
id|to_remove
comma
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|process_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|sts
)paren
suffix:semicolon
DECL|macro|remove_from_waiting_list
mdefine_line|#define remove_from_waiting_list(np, cmd) &bslash;&n;&t;&t;retrieve_from_waiting_list(1, (np), (cmd))
DECL|macro|requeue_waiting_list
mdefine_line|#define requeue_waiting_list(np) process_waiting_list((np), DID_OK)
DECL|macro|reset_waiting_list
mdefine_line|#define reset_waiting_list(np) process_waiting_list((np), DID_RESET)
DECL|function|ncr_name
r_static
r_inline
r_char
op_star
id|ncr_name
(paren
id|ncb_p
id|np
)paren
(brace
r_return
id|np-&gt;inst_name
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      Scripts for NCR-Processor.&n;**&n;**      Use ncr_script_bind for binding to physical addresses.&n;**&n;**&n;**==========================================================&n;**&n;**&t;NADDR generates a reference to a field of the controller data.&n;**&t;PADDR generates a reference to another part of the script.&n;**&t;RADDR generates a reference to a script processor register.&n;**&t;FADDR generates a reference to a script processor register&n;**&t;&t;with offset.&n;**&n;**----------------------------------------------------------&n;*/
DECL|macro|RELOC_SOFTC
mdefine_line|#define&t;RELOC_SOFTC&t;0x40000000
DECL|macro|RELOC_LABEL
mdefine_line|#define&t;RELOC_LABEL&t;0x50000000
DECL|macro|RELOC_REGISTER
mdefine_line|#define&t;RELOC_REGISTER&t;0x60000000
macro_line|#if 0
mdefine_line|#define&t;RELOC_KVAR&t;0x70000000
macro_line|#endif
DECL|macro|RELOC_LABELH
mdefine_line|#define&t;RELOC_LABELH&t;0x80000000
DECL|macro|RELOC_MASK
mdefine_line|#define&t;RELOC_MASK&t;0xf0000000
DECL|macro|NADDR
mdefine_line|#define&t;NADDR(label)&t;(RELOC_SOFTC | offsetof(struct ncb, label))
DECL|macro|PADDR
mdefine_line|#define PADDR(label)    (RELOC_LABEL | offsetof(struct script, label))
DECL|macro|PADDRH
mdefine_line|#define PADDRH(label)   (RELOC_LABELH | offsetof(struct scripth, label))
DECL|macro|RADDR
mdefine_line|#define&t;RADDR(label)&t;(RELOC_REGISTER | REG(label))
DECL|macro|FADDR
mdefine_line|#define&t;FADDR(label,ofs)(RELOC_REGISTER | ((REG(label))+(ofs)))
macro_line|#if 0
mdefine_line|#define&t;KVAR(which)&t;(RELOC_KVAR | (which))
macro_line|#endif
macro_line|#if 0
mdefine_line|#define&t;SCRIPT_KVAR_JIFFIES&t;(0)
mdefine_line|#define&t;SCRIPT_KVAR_FIRST&t;&t;SCRIPT_KVAR_JIFFIES
mdefine_line|#define&t;SCRIPT_KVAR_LAST&t;&t;SCRIPT_KVAR_JIFFIES
multiline_comment|/*&n; * Kernel variables referenced in the scripts.&n; * THESE MUST ALL BE ALIGNED TO A 4-BYTE BOUNDARY.&n; */
r_static
r_void
op_star
id|script_kvars
(braket
)braket
id|__initdata
op_assign
(brace
(paren
r_void
op_star
)paren
op_amp
id|jiffies
)brace
suffix:semicolon
macro_line|#endif
DECL|variable|__initdata
r_static
r_struct
id|script
id|script0
id|__initdata
op_assign
(brace
multiline_comment|/*--------------------------&lt; START &gt;-----------------------*/
(brace
multiline_comment|/*&n;&t;**&t;This NOP will be patched with LED ON&n;&t;**&t;SCR_REG_REG (gpreg, SCR_AND, 0xfe)&n;&t;*/
id|SCR_NO_OP
comma
l_int|0
comma
multiline_comment|/*&n;&t;**      Clear SIGP.&n;&t;*/
id|SCR_FROM_REG
(paren
id|ctest2
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Then jump to a certain point in tryloop.&n;&t;**&t;Due to the lack of indirect addressing the code&n;&t;**&t;is self modifying here.&n;&t;*/
id|SCR_JUMP
comma
)brace
multiline_comment|/*-------------------------&lt; STARTPOS &gt;--------------------*/
comma
(brace
id|PADDRH
c_func
(paren
id|tryloop
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SELECT &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;DSA&t;contains the address of a scheduled&n;&t;**&t;&t;data structure.&n;&t;**&n;&t;**&t;SCRATCHA contains the address of the script,&n;&t;**&t;&t;which starts the next entry.&n;&t;**&n;&t;**&t;Set Initiator mode.&n;&t;**&n;&t;**&t;(Target mode is left as an exercise for the reader)&n;&t;*/
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_SELECTING
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**      And try to select this target.&n;&t;*/
id|SCR_SEL_TBL_ATN
op_xor
m_offsetof
(paren
r_struct
id|dsb
comma
id|select
)paren
comma
id|PADDR
(paren
id|reselect
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SELECT2 &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Now there are 4 possibilities:&n;&t;**&n;&t;**&t;(1) The ncr looses arbitration.&n;&t;**&t;This is ok, because it will try again,&n;&t;**&t;when the bus becomes idle.&n;&t;**&t;(But beware of the timeout function!)&n;&t;**&n;&t;**&t;(2) The ncr is reselected.&n;&t;**&t;Then the script processor takes the jump&n;&t;**&t;to the RESELECT label.&n;&t;**&n;&t;**&t;(3) The ncr wins arbitration.&n;&t;**&t;Then it will execute SCRIPTS instruction until &n;&t;**&t;the next instruction that checks SCSI phase.&n;&t;**&t;Then will stop and wait for selection to be &n;&t;**&t;complete or selection time-out to occur.&n;&t;**&t;As a result the SCRIPTS instructions until &n;&t;**&t;LOADPOS + 2 should be executed in parallel with &n;&t;**&t;the SCSI core performing selection.&n;&t;*/
multiline_comment|/*&n;&t;**&t;The M_REJECT problem seems to be due to a selection &n;&t;**&t;timing problem.&n;&t;**&t;Wait immediately for the selection to complete. &n;&t;**&t;(2.5x behaves so)&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Next time use the next slot.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|PADDR
(paren
id|startpos
)paren
comma
multiline_comment|/*&n;&t;**      The ncr doesn&squot;t have an indirect load&n;&t;**&t;or store command. So we have to&n;&t;**&t;copy part of the control block to a&n;&t;**&t;fixed place, where we can access it.&n;&t;**&n;&t;**&t;We patch the address part of a&n;&t;**&t;COPY command with the DSA-register.&n;&t;*/
id|SCR_COPY_F
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|dsa
)paren
comma
id|PADDR
(paren
id|loadpos
)paren
comma
multiline_comment|/*&n;&t;**&t;then we do the actual copy.&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|head
)paren
)paren
comma
multiline_comment|/*&n;&t;**&t;continued after the next label ...&n;&t;*/
)brace
multiline_comment|/*-------------------------&lt; LOADPOS &gt;---------------------*/
comma
(brace
l_int|0
comma
id|NADDR
(paren
id|header
)paren
comma
multiline_comment|/*&n;&t;**&t;Wait for the next phase or the selection&n;&t;**&t;to complete or time-out.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR
(paren
id|prepare
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEND_IDENT &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Selection complete.&n;&t;**&t;Send the IDENTIFY and SIMPLE_TAG messages&n;&t;**&t;(and the M_X_SYNC_REQ message)&n;&t;*/
id|SCR_MOVE_TBL
op_xor
id|SCR_MSG_OUT
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|smsg
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDRH
(paren
id|resend_ident
)paren
comma
id|SCR_LOAD_REG
(paren
id|scratcha
comma
l_int|0x80
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|lastmsg
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PREPARE &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**      load the savep (saved pointer) into&n;&t;**      the TEMP register (actual pointer)&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|header.savep
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
multiline_comment|/*&n;&t;**      Initialize the status registers&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|header.status
)paren
comma
id|RADDR
(paren
id|scr0
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PREPARE2 &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Initialize the msgout buffer with a NOOP message.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_NOOP
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|msgout
)paren
comma
macro_line|#if 0
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|msgin
)paren
comma
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Anticipate the COMMAND phase.&n;&t;**&t;This is the normal case for initial selection.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_COMMAND
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; COMMAND &gt;--------------------*/
comma
(brace
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
multiline_comment|/*&n;&t;**&t;... set a timestamp ...&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
id|u_long
)paren
)paren
comma
id|NADDR
(paren
id|ktime
)paren
comma
id|NADDR
(paren
id|header.stamp.command
)paren
comma
macro_line|#endif
multiline_comment|/*&n;&t;**&t;... and send the command&n;&t;*/
id|SCR_MOVE_TBL
op_xor
id|SCR_COMMAND
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|cmd
)paren
comma
multiline_comment|/*&n;&t;**&t;If status is still HS_NEGOTIATE, negotiation failed.&n;&t;**&t;We check this here, since we want to do that &n;&t;**&t;only once.&n;&t;*/
id|SCR_FROM_REG
(paren
id|HS_REG
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|HS_NEGOTIATE
)paren
)paren
comma
id|SIR_NEGO_FAILED
comma
)brace
multiline_comment|/*-----------------------&lt; DISPATCH &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;MSG_IN is the only phase that shall be &n;&t;**&t;entered at least once for each (re)selection.&n;&t;**&t;So we test it first.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|msg_in
)paren
comma
id|SCR_RETURN
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;DEL 397 - 53C875 Rev 3 - Part Number 609-0392410 - ITEM 4.&n;&t;**&t;Possible data corruption during Memory Write and Invalidate.&n;&t;**&t;This work-around resets the addressing logic prior to the &n;&t;**&t;start of the first MOVE of a DATA IN phase.&n;&t;**&t;(See README.ncr53c8xx for more information)&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|IF
(paren
id|SCR_DATA_IN
)paren
)paren
comma
l_int|20
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_STATUS
)paren
)paren
comma
id|PADDR
(paren
id|status
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_COMMAND
)paren
)paren
comma
id|PADDR
(paren
id|command
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR
(paren
id|msg_out
)paren
comma
multiline_comment|/*&n;&t;**      Discard one illegal phase byte, if required.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|XE_BAD_PHASE
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|xerr_st
)paren
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|IF
(paren
id|SCR_ILG_OUT
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_ILG_OUT
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|IF
(paren
id|SCR_ILG_IN
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_ILG_IN
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; CLRACK &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Terminate possible pending message phase.&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; NO_DATA &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;The target wants to tranfer too much data&n;&t;**&t;or in the wrong direction.&n;&t;**      Remember that in extended error.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|XE_EXTRA_DATA
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|xerr_st
)paren
comma
multiline_comment|/*&n;&t;**      Discard one data byte, if required.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_DATA_OUT
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|IF
(paren
id|SCR_DATA_IN
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_DATA_IN
comma
id|NADDR
(paren
id|scratch
)paren
comma
multiline_comment|/*&n;&t;**      .. and repeat as required.&n;&t;*/
id|SCR_CALL
comma
id|PADDR
(paren
id|dispatch
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|no_data
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; STATUS &gt;--------------------*/
comma
(brace
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
multiline_comment|/*&n;&t;**&t;set the timestamp.&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
id|u_long
)paren
)paren
comma
id|NADDR
(paren
id|ktime
)paren
comma
id|NADDR
(paren
id|header.stamp.status
)paren
comma
macro_line|#endif
multiline_comment|/*&n;&t;**&t;get the status&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_STATUS
comma
id|NADDR
(paren
id|scratch
)paren
comma
multiline_comment|/*&n;&t;**&t;save status to scsi_status.&n;&t;**&t;mark as complete.&n;&t;*/
id|SCR_TO_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_COMPLETE
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IN &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Get the first byte of the message&n;&t;**&t;and save it to SCRATCHA.&n;&t;**&n;&t;**&t;The script processor doesn&squot;t negate the&n;&t;**&t;ACK signal after this transfer.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|0
)braket
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IN2 &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Handle this message.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_COMPLETE
)paren
)paren
comma
id|PADDR
(paren
id|complete
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_DISCONNECT
)paren
)paren
comma
id|PADDR
(paren
id|disconnect
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_SAVE_DP
)paren
)paren
comma
id|PADDR
(paren
id|save_dp
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_RESTORE_DP
)paren
)paren
comma
id|PADDR
(paren
id|restore_dp
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_EXTENDED
)paren
)paren
comma
id|PADDRH
(paren
id|msg_extended
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_NOOP
)paren
)paren
comma
id|PADDR
(paren
id|clrack
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_REJECT
)paren
)paren
comma
id|PADDRH
(paren
id|msg_reject
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_IGN_RESIDUE
)paren
)paren
comma
id|PADDRH
(paren
id|msg_ign_residue
)paren
comma
multiline_comment|/*&n;&t;**&t;Rest of the messages left as&n;&t;**&t;an exercise ...&n;&t;**&n;&t;**&t;Unimplemented messages:&n;&t;**&t;fall through to MSG_BAD.&n;&t;*/
)brace
multiline_comment|/*-------------------------&lt; MSG_BAD &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;unimplemented message - reject it.&n;&t;*/
id|SCR_INT
comma
id|SIR_REJECT_SENT
comma
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_REJECT
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; SETMSG &gt;----------------------*/
comma
(brace
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; CLEANUP &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**      dsa:    Pointer to ccb&n;&t;**&t;      or xxxxxxFF (no ccb)&n;&t;**&n;&t;**      HS_REG:   Host-Status (&lt;&gt;0!)&n;&t;*/
id|SCR_FROM_REG
(paren
id|dsa
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
l_int|0xff
)paren
)paren
comma
id|PADDR
(paren
id|start
)paren
comma
multiline_comment|/*&n;&t;**      dsa is valid.&n;&t;**&t;complete the cleanup.&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|cleanup_ok
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; COMPLETE &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Complete message.&n;&t;**&n;&t;**&t;Copy TEMP register to LASTP in header.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|NADDR
(paren
id|header.lastp
)paren
comma
multiline_comment|/*&n;&t;**&t;When we terminate the cycle by clearing ACK,&n;&t;**&t;the target may disconnect immediately.&n;&t;**&n;&t;**&t;We don&squot;t want to be told of an&n;&t;**&t;&quot;unexpected disconnect&quot;,&n;&t;**&t;so we disable this feature.&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Terminate cycle ...&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;... and wait for the disconnect.&n;&t;*/
id|SCR_WAIT_DISC
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; CLEANUP_OK &gt;----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Save host status to header.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|scr0
)paren
comma
id|NADDR
(paren
id|header.status
)paren
comma
multiline_comment|/*&n;&t;**&t;and copy back the header to the ccb.&n;&t;*/
id|SCR_COPY_F
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|dsa
)paren
comma
id|PADDR
(paren
id|cleanup0
)paren
comma
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|head
)paren
)paren
comma
id|NADDR
(paren
id|header
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; CLEANUP0 &gt;--------------------*/
comma
(brace
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; SIGNAL &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;if job not completed ...&n;&t;*/
id|SCR_FROM_REG
(paren
id|HS_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;... start the next command.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0
comma
(paren
id|HS_DONEMASK
op_or
id|HS_SKIPMASK
)paren
)paren
)paren
comma
id|PADDR
c_func
(paren
id|start
)paren
comma
multiline_comment|/*&n;&t;**&t;If command resulted in not GOOD status,&n;&t;**&t;call the C code if needed.&n;&t;*/
id|SCR_FROM_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
id|SCR_CALL
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|S_GOOD
)paren
)paren
comma
id|PADDRH
(paren
id|bad_status
)paren
comma
macro_line|#ifndef&t;SCSI_NCR_CCB_DONE_SUPPORT
multiline_comment|/*&n;&t;**&t;... signal completion to the host&n;&t;*/
id|SCR_INT_FLY
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Auf zu neuen Schandtaten!&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
c_func
(paren
id|start
)paren
comma
macro_line|#else&t;/* defined SCSI_NCR_CCB_DONE_SUPPORT */
multiline_comment|/*&n;&t;**&t;... signal completion to the host&n;&t;*/
id|SCR_JUMP
comma
)brace
multiline_comment|/*------------------------&lt; DONE_POS &gt;---------------------*/
comma
(brace
id|PADDRH
(paren
id|done_queue
)paren
comma
)brace
multiline_comment|/*------------------------&lt; DONE_PLUG &gt;--------------------*/
comma
(brace
id|SCR_INT
comma
id|SIR_DONE_OVERFLOW
comma
)brace
multiline_comment|/*------------------------&lt; DONE_END &gt;---------------------*/
comma
(brace
id|SCR_INT_FLY
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|PADDR
(paren
id|done_pos
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|start
)paren
comma
macro_line|#endif&t;/* SCSI_NCR_CCB_DONE_SUPPORT */
)brace
multiline_comment|/*-------------------------&lt; SAVE_DP &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;SAVE_DP message:&n;&t;**&t;Copy TEMP register to SAVEP in header.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|NADDR
(paren
id|header.savep
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESTORE_DP &gt;---------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;RESTORE_DP message:&n;&t;**&t;Copy SAVEP in header to TEMP register.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|header.savep
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DISCONNECT &gt;---------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;DISCONNECTing  ...&n;&t;**&n;&t;**&t;disable the &quot;unexpected disconnect&quot; feature,&n;&t;**&t;and remove the ACK signal.&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Wait for the disconnect.&n;&t;*/
id|SCR_WAIT_DISC
comma
l_int|0
comma
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
multiline_comment|/*&n;&t;**&t;Profiling:&n;&t;**&t;Set a time stamp,&n;&t;**&t;and count the disconnects.&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
id|u_long
)paren
)paren
comma
id|NADDR
(paren
id|ktime
)paren
comma
id|NADDR
(paren
id|header.stamp.disconnect
)paren
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|disc_phys
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|SCR_REG_REG
(paren
id|scratcha
comma
id|SCR_ADD
comma
l_int|0x01
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|disc_phys
)paren
comma
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Status is: DISCONNECTED.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_DISCONNECT
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;If QUIRK_AUTOSAVE is set,&n;&t;**&t;do an &quot;save pointer&quot; operation.&n;&t;*/
id|SCR_FROM_REG
(paren
id|QU_REG
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|QUIRK_AUTOSAVE
comma
id|QUIRK_AUTOSAVE
)paren
)paren
comma
id|PADDR
(paren
id|cleanup_ok
)paren
comma
multiline_comment|/*&n;&t;**&t;like SAVE_DP message:&n;&t;**&t;Copy TEMP register to SAVEP in header.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|NADDR
(paren
id|header.savep
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|cleanup_ok
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_OUT &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;The target requests a message.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|NADDR
(paren
id|lastmsg
)paren
comma
multiline_comment|/*&n;&t;**&t;If it was no ABORT message ...&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_ABORT
)paren
)paren
comma
id|PADDRH
(paren
id|msg_out_abort
)paren
comma
multiline_comment|/*&n;&t;**&t;... wait for the next phase&n;&t;**&t;if it&squot;s a message out, send it again, ...&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR
(paren
id|msg_out
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_OUT_DONE &gt;--------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;... else clear the message ...&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_NOOP
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|msgout
)paren
comma
multiline_comment|/*&n;&t;**&t;... and process the next phase&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; IDLE &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Nothing to do?&n;&t;**&t;Wait for reselect.&n;&t;**&t;This NOP will be patched with LED OFF&n;&t;**&t;SCR_REG_REG (gpreg, SCR_OR, 0x01)&n;&t;*/
id|SCR_NO_OP
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; RESELECT &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;make the DSA invalid.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|dsa
comma
l_int|0xff
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_IN_RESELECT
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Sleep waiting for a reselection.&n;&t;**&t;If SIGP is set, special treatment.&n;&t;**&n;&t;**&t;Zu allem bereit ..&n;&t;*/
id|SCR_WAIT_RESEL
comma
id|PADDR
c_func
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESELECTED &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;This NOP will be patched with LED ON&n;&t;**&t;SCR_REG_REG (gpreg, SCR_AND, 0xfe)&n;&t;*/
id|SCR_NO_OP
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;... zu nichts zu gebrauchen ?&n;&t;**&n;&t;**      load the target id into the SFBR&n;&t;**&t;and jump to the control block.&n;&t;**&n;&t;**&t;Look at the declarations of&n;&t;**&t;- struct ncb&n;&t;**&t;- struct tcb&n;&t;**&t;- struct lcb&n;&t;**&t;- struct ccb&n;&t;**&t;to understand what&squot;s going on.&n;&t;*/
id|SCR_REG_SFBR
(paren
id|ssid
comma
id|SCR_AND
comma
l_int|0x8F
)paren
comma
l_int|0
comma
id|SCR_TO_REG
(paren
id|sdid
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|NADDR
(paren
id|jump_tcb
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_DSA &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Ack the IDENTIFY or TAG previously received.&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**      The ncr doesn&squot;t have an indirect load&n;&t;**&t;or store command. So we have to&n;&t;**&t;copy part of the control block to a&n;&t;**&t;fixed place, where we can access it.&n;&t;**&n;&t;**&t;We patch the address part of a&n;&t;**&t;COPY command with the DSA-register.&n;&t;*/
id|SCR_COPY_F
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|dsa
)paren
comma
id|PADDR
(paren
id|loadpos1
)paren
comma
multiline_comment|/*&n;&t;**&t;then we do the actual copy.&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|head
)paren
)paren
comma
multiline_comment|/*&n;&t;**&t;continued after the next label ...&n;&t;*/
)brace
multiline_comment|/*-------------------------&lt; LOADPOS1 &gt;-------------------*/
comma
(brace
l_int|0
comma
id|NADDR
(paren
id|header
)paren
comma
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
multiline_comment|/*&n;&t;**      Set a time stamp for this reselection&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
id|u_long
)paren
)paren
comma
id|NADDR
(paren
id|ktime
)paren
comma
id|NADDR
(paren
id|header.stamp.reselect
)paren
comma
macro_line|#endif
multiline_comment|/*&n;&t;**&t;The DSA contains the data structure address.&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|prepare
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_LUN &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;come back to this point&n;&t;**&t;to get an IDENTIFY message&n;&t;**&t;Wait for a msg_in phase.&n;&t;*/
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|SIR_RESEL_NO_MSG_IN
comma
multiline_comment|/*&n;&t;**&t;message phase.&n;&t;**&t;Read the data directly from the BUS DATA lines.&n;&t;**&t;This helps to support very old SCSI devices that &n;&t;**&t;may reselect without sending an IDENTIFY.&n;&t;*/
id|SCR_FROM_REG
(paren
id|sbdl
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;It should be an Identify message.&n;&t;*/
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_TAG &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Read IDENTIFY + SIMPLE + TAG using a single MOVE.&n;&t;**&t;Agressive optimization, is&squot;nt it?&n;&t;**&t;No need to test the SIMPLE TAG message, since the &n;&t;**&t;driver only supports conformant devices for tags. ;-)&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|3
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
)paren
comma
multiline_comment|/*&n;&t;**&t;Read the TAG from the SIDL.&n;&t;**&t;Still an aggressive optimization. ;-)&n;&t;**&t;Compute the CCB indirect jump address which &n;&t;**&t;is (#TAG*2 &amp; 0xfc) due to tag numbering using &n;&t;**&t;1,3,5..MAXTAGS*2+1 actual values.&n;&t;*/
id|SCR_REG_SFBR
(paren
id|sidl
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_SFBR_REG
(paren
id|temp
comma
id|SCR_AND
comma
l_int|0xfc
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; JUMP_TO_NEXUS &gt;-------------------*/
comma
(brace
id|SCR_COPY_F
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|PADDR
(paren
id|nexus_indirect
)paren
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; NEXUS_INDIRECT &gt;-------------------*/
comma
(brace
l_int|0
comma
id|RADDR
(paren
id|temp
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_NOTAG &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;No tag expected.&n;&t;**&t;Read an throw away the IDENTIFY.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|jump_to_nexus
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IN &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;**&t;Because the size depends on the&n;**&t;#define MAX_SCATTERL parameter,&n;**&t;it is filled in at runtime.&n;**&n;**  ##===========&lt; i=0; i&lt;MAX_SCATTERL &gt;=========&n;**  ||&t;SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN)),&n;**  ||&t;&t;PADDR (dispatch),&n;**  ||&t;SCR_MOVE_TBL ^ SCR_DATA_IN,&n;**  ||&t;&t;offsetof (struct dsb, data[ i]),&n;**  ##==========================================&n;**&n;**---------------------------------------------------------&n;*/
l_int|0
)brace
multiline_comment|/*-------------------------&lt; DATA_IN2 &gt;-------------------*/
comma
(brace
id|SCR_CALL
comma
id|PADDR
(paren
id|dispatch
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|no_data
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_OUT &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;**&t;Because the size depends on the&n;**&t;#define MAX_SCATTERL parameter,&n;**&t;it is filled in at runtime.&n;**&n;**  ##===========&lt; i=0; i&lt;MAX_SCATTERL &gt;=========&n;**  ||&t;SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT)),&n;**  ||&t;&t;PADDR (dispatch),&n;**  ||&t;SCR_MOVE_TBL ^ SCR_DATA_OUT,&n;**  ||&t;&t;offsetof (struct dsb, data[ i]),&n;**  ##==========================================&n;**&n;**---------------------------------------------------------&n;*/
l_int|0
)brace
multiline_comment|/*-------------------------&lt; DATA_OUT2 &gt;-------------------*/
comma
(brace
id|SCR_CALL
comma
id|PADDR
(paren
id|dispatch
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|no_data
)paren
comma
)brace
multiline_comment|/*--------------------------------------------------------*/
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_struct
id|scripth
id|scripth0
id|__initdata
op_assign
(brace
multiline_comment|/*-------------------------&lt; TRYLOOP &gt;---------------------*/
(brace
multiline_comment|/*&n;**&t;Start the next entry.&n;**&t;Called addresses point to the launch script in the CCB.&n;**&t;They are patched by the main processor.&n;**&n;**&t;Because the size depends on the&n;**&t;#define MAX_START parameter, it is filled&n;**&t;in at runtime.&n;**&n;**-----------------------------------------------------------&n;**&n;**  ##===========&lt; I=0; i&lt;MAX_START &gt;===========&n;**  ||&t;SCR_CALL,&n;**  ||&t;&t;PADDR (idle),&n;**  ##==========================================&n;**&n;**-----------------------------------------------------------&n;*/
l_int|0
)brace
multiline_comment|/*------------------------&lt; TRYLOOP2 &gt;---------------------*/
comma
(brace
id|SCR_JUMP
comma
id|PADDRH
c_func
(paren
id|tryloop
)paren
comma
macro_line|#ifdef SCSI_NCR_CCB_DONE_SUPPORT
)brace
multiline_comment|/*------------------------&lt; DONE_QUEUE &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;**&t;Copy the CCB address to the next done entry.&n;**&t;Because the size depends on the&n;**&t;#define MAX_DONE parameter, it is filled&n;**&t;in at runtime.&n;**&n;**-----------------------------------------------------------&n;**&n;**  ##===========&lt; I=0; i&lt;MAX_DONE &gt;===========&n;**  ||&t;SCR_COPY (sizeof(ccb_p)),&n;**  ||&t;&t;NADDR (header.cp),&n;**  ||&t;&t;NADDR (ccb_done[i]),&n;**  ||&t;SCR_CALL,&n;**  ||&t;&t;PADDR (done_end),&n;**  ##==========================================&n;**&n;**-----------------------------------------------------------&n;*/
l_int|0
)brace
multiline_comment|/*------------------------&lt; DONE_QUEUE2 &gt;------------------*/
comma
(brace
id|SCR_JUMP
comma
id|PADDRH
(paren
id|done_queue
)paren
comma
macro_line|#endif /* SCSI_NCR_CCB_DONE_SUPPORT */
)brace
multiline_comment|/*------------------------&lt; SELECT_NO_ATN &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Set Initiator mode.&n;&t;**      And try to select this target without ATN.&n;&t;*/
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_SELECTING
)paren
comma
l_int|0
comma
id|SCR_SEL_TBL
op_xor
m_offsetof
(paren
r_struct
id|dsb
comma
id|select
)paren
comma
id|PADDR
(paren
id|reselect
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|select2
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; CANCEL &gt;------------------------*/
comma
(brace
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|HS_ABORTED
)paren
comma
l_int|0
comma
id|SCR_JUMPR
comma
l_int|8
comma
)brace
multiline_comment|/*-------------------------&lt; SKIP &gt;------------------------*/
comma
(brace
id|SCR_LOAD_REG
(paren
id|scratcha
comma
l_int|0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;This entry has been canceled.&n;&t;**&t;Next time use the next slot.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|PADDR
(paren
id|startpos
)paren
comma
multiline_comment|/*&n;&t;**      The ncr doesn&squot;t have an indirect load&n;&t;**&t;or store command. So we have to&n;&t;**&t;copy part of the control block to a&n;&t;**&t;fixed place, where we can access it.&n;&t;**&n;&t;**&t;We patch the address part of a&n;&t;**&t;COPY command with the DSA-register.&n;&t;*/
id|SCR_COPY_F
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|dsa
)paren
comma
id|PADDRH
(paren
id|skip2
)paren
comma
multiline_comment|/*&n;&t;**&t;then we do the actual copy.&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|head
)paren
)paren
comma
multiline_comment|/*&n;&t;**&t;continued after the next label ...&n;&t;*/
)brace
multiline_comment|/*-------------------------&lt; SKIP2 &gt;---------------------*/
comma
(brace
l_int|0
comma
id|NADDR
(paren
id|header
)paren
comma
multiline_comment|/*&n;&t;**      Initialize the status registers&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|header.status
)paren
comma
id|RADDR
(paren
id|scr0
)paren
comma
multiline_comment|/*&n;&t;**&t;Force host status.&n;&t;*/
id|SCR_FROM_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
l_int|0
comma
id|HS_DONEMASK
)paren
)paren
comma
l_int|16
comma
id|SCR_REG_REG
(paren
id|HS_REG
comma
id|SCR_OR
comma
id|HS_SKIPMASK
)paren
comma
l_int|0
comma
id|SCR_JUMPR
comma
l_int|8
comma
id|SCR_TO_REG
(paren
id|HS_REG
)paren
comma
l_int|0
comma
id|SCR_LOAD_REG
(paren
id|SS_REG
comma
id|S_GOOD
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|cleanup_ok
)paren
comma
)brace
comma
multiline_comment|/*-------------------------&lt; PAR_ERR_DATA_IN &gt;---------------*/
(brace
multiline_comment|/*&n;&t;**&t;Ignore all data in byte, until next phase&n;&t;*/
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
comma
id|PADDRH
(paren
id|par_err_other
)paren
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_DATA_IN
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_JUMPR
comma
op_minus
l_int|24
comma
)brace
comma
multiline_comment|/*-------------------------&lt; PAR_ERR_OTHER &gt;------------------*/
(brace
multiline_comment|/*&n;&t;**&t;count it.&n;&t;*/
id|SCR_REG_REG
(paren
id|PS_REG
comma
id|SCR_ADD
comma
l_int|0x01
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;jump to dispatcher.&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_REJECT &gt;---------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;If a negotiation was in progress,&n;&t;**&t;negotiation failed.&n;&t;**&t;Otherwise, let the C code print &n;&t;**&t;some message.&n;&t;*/
id|SCR_FROM_REG
(paren
id|HS_REG
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|HS_NEGOTIATE
)paren
)paren
comma
id|SIR_REJECT_RECEIVED
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|HS_NEGOTIATE
)paren
)paren
comma
id|SIR_NEGO_FAILED
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IGN_RESIDUE &gt;----------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Terminate cycle&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get residue size.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|1
)braket
)paren
comma
multiline_comment|/*&n;&t;**&t;Size is 0 .. ignore message.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
l_int|0
)paren
)paren
comma
id|PADDR
(paren
id|clrack
)paren
comma
multiline_comment|/*&n;&t;**&t;Size is not 1 .. have to interrupt.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|1
)paren
)paren
comma
l_int|40
comma
multiline_comment|/*&n;&t;**&t;Check for residue byte in swide register&n;&t;*/
id|SCR_FROM_REG
(paren
id|scntl2
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|WSR
comma
id|WSR
)paren
)paren
comma
l_int|16
comma
multiline_comment|/*&n;&t;**&t;There IS data in the swide register.&n;&t;**&t;Discard it.&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_OR
comma
id|WSR
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
multiline_comment|/*&n;&t;**&t;Load again the size to the sfbr register.&n;&t;*/
id|SCR_FROM_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_INT
comma
id|SIR_IGN_RESIDUE
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_EXTENDED &gt;-------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Terminate cycle&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get length.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|1
)braket
)paren
comma
multiline_comment|/*&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
l_int|3
)paren
)paren
comma
id|PADDRH
(paren
id|msg_ext_3
)paren
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|2
)paren
)paren
comma
id|PADDR
(paren
id|msg_bad
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_EXT_2 &gt;----------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get extended message code.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|2
)braket
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_X_WIDE_REQ
)paren
)paren
comma
id|PADDRH
(paren
id|msg_wdtr
)paren
comma
multiline_comment|/*&n;&t;**&t;unknown extended message&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|msg_bad
)paren
)brace
multiline_comment|/*-------------------------&lt; MSG_WDTR &gt;-----------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get data bus width&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|3
)braket
)paren
comma
multiline_comment|/*&n;&t;**&t;let the host do the real work.&n;&t;*/
id|SCR_INT
comma
id|SIR_NEGO_WIDE
comma
multiline_comment|/*&n;&t;**&t;let the target fetch our answer.&n;&t;*/
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDRH
(paren
id|nego_bad_phase
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEND_WDTR &gt;----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Send the M_X_WIDE_REQ&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|4
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|NADDR
(paren
id|lastmsg
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|msg_out_done
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_EXT_3 &gt;----------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get extended message code.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|2
)braket
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_X_SYNC_REQ
)paren
)paren
comma
id|PADDRH
(paren
id|msg_sdtr
)paren
comma
multiline_comment|/*&n;&t;**&t;unknown extended message&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|msg_bad
)paren
)brace
multiline_comment|/*-------------------------&lt; MSG_SDTR &gt;-----------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get period and offset&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|2
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|3
)braket
)paren
comma
multiline_comment|/*&n;&t;**&t;let the host do the real work.&n;&t;*/
id|SCR_INT
comma
id|SIR_NEGO_SYNC
comma
multiline_comment|/*&n;&t;**&t;let the target fetch our answer.&n;&t;*/
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDRH
(paren
id|nego_bad_phase
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEND_SDTR &gt;-------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Send the M_X_SYNC_REQ&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|5
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|NADDR
(paren
id|lastmsg
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|msg_out_done
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; NEGO_BAD_PHASE &gt;------------*/
comma
(brace
id|SCR_INT
comma
id|SIR_NEGO_PROTO
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_OUT_ABORT &gt;-------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;After ABORT message,&n;&t;**&n;&t;**&t;expect an immediate disconnect, ...&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_WAIT_DISC
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;... and set the status to &quot;ABORTED&quot;&n;&t;*/
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_ABORTED
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|cleanup
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; HDATA_IN &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;**&t;Because the size depends on the&n;**&t;#define MAX_SCATTERH parameter,&n;**&t;it is filled in at runtime.&n;**&n;**  ##==&lt; i=MAX_SCATTERL; i&lt;MAX_SCATTERL+MAX_SCATTERH &gt;==&n;**  ||&t;SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN)),&n;**  ||&t;&t;PADDR (dispatch),&n;**  ||&t;SCR_MOVE_TBL ^ SCR_DATA_IN,&n;**  ||&t;&t;offsetof (struct dsb, data[ i]),&n;**  ##===================================================&n;**&n;**---------------------------------------------------------&n;*/
l_int|0
)brace
multiline_comment|/*-------------------------&lt; HDATA_IN2 &gt;------------------*/
comma
(brace
id|SCR_JUMP
comma
id|PADDR
(paren
id|data_in
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; HDATA_OUT &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;**&t;Because the size depends on the&n;**&t;#define MAX_SCATTERH parameter,&n;**&t;it is filled in at runtime.&n;**&n;**  ##==&lt; i=MAX_SCATTERL; i&lt;MAX_SCATTERL+MAX_SCATTERH &gt;==&n;**  ||&t;SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT)),&n;**  ||&t;&t;PADDR (dispatch),&n;**  ||&t;SCR_MOVE_TBL ^ SCR_DATA_OUT,&n;**  ||&t;&t;offsetof (struct dsb, data[ i]),&n;**  ##===================================================&n;**&n;**---------------------------------------------------------&n;*/
l_int|0
)brace
multiline_comment|/*-------------------------&lt; HDATA_OUT2 &gt;------------------*/
comma
(brace
id|SCR_JUMP
comma
id|PADDR
(paren
id|data_out
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESET &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**      Send a M_RESET message if bad IDENTIFY &n;&t;**&t;received on reselection.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_ABORT_TAG
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|abort_resel
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; ABORTTAG &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**      Abort a wrong tag received on reselection.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_ABORT_TAG
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|abort_resel
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; ABORT &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**      Abort a reselection when no active CCB.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_ABORT
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; ABORT_RESEL &gt;----------------*/
comma
(brace
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;and send it.&n;&t;**&t;we expect an immediate disconnect&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|NADDR
(paren
id|lastmsg
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_WAIT_DISC
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEND_IDENT &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;The target stays in MSG OUT phase after having acked &n;&t;**&t;Identify [+ Tag [+ Extended message ]]. Targets shall&n;&t;**&t;behave this way on parity error.&n;&t;**&t;We must send it again all the messages.&n;&t;*/
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
multiline_comment|/* Shall be asserted 2 deskew delays before the  */
l_int|0
comma
multiline_comment|/* 1rst ACK = 90 ns. Hope the NCR is&squot;nt too fast */
id|SCR_JUMP
comma
id|PADDR
(paren
id|send_ident
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; CLRATN_GO_ON &gt;-------------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
)brace
multiline_comment|/*-------------------------&lt; NXTDSP_GO_ON &gt;-------------------*/
comma
(brace
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; SDATA_IN &gt;-------------------*/
comma
(brace
id|SCR_CALL
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|sense
)paren
comma
id|SCR_CALL
comma
id|PADDR
(paren
id|dispatch
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|no_data
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IO &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;We jump here if the data direction was unknown at the &n;&t;**&t;time we had to queue the command to the scripts processor.&n;&t;**&t;Pointers had been set as follow in this situation:&n;&t;**&t;  savep   --&gt;   DATA_IO&n;&t;**&t;  lastp   --&gt;   start pointer when DATA_IN&n;&t;**&t;  goalp   --&gt;   goal  pointer when DATA_IN&n;&t;**&t;  wlastp  --&gt;   start pointer when DATA_OUT&n;&t;**&t;  wgoalp  --&gt;   goal  pointer when DATA_OUT&n;&t;**&t;This script sets savep/lastp/goalp according to the &n;&t;**&t;direction chosen by the target.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
l_int|32
comma
multiline_comment|/*&n;&t;**&t;Direction is DATA IN.&n;&t;**&t;Warning: we jump here, even when phase is DATA OUT.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|header.lastp
)paren
comma
id|NADDR
(paren
id|header.savep
)paren
comma
multiline_comment|/*&n;&t;**&t;Jump to the SCRIPTS according to actual direction.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|header.savep
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Direction is DATA OUT.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|header.wlastp
)paren
comma
id|NADDR
(paren
id|header.lastp
)paren
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|header.wgoalp
)paren
comma
id|NADDR
(paren
id|header.goalp
)paren
comma
id|SCR_JUMPR
comma
op_minus
l_int|64
comma
)brace
multiline_comment|/*-------------------------&lt; BAD_IDENTIFY &gt;---------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;If message phase but not an IDENTIFY,&n;&t;**&t;get some help from the C code.&n;&t;**&t;Old SCSI device may behave so.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0x80
comma
l_int|0x80
)paren
)paren
comma
l_int|16
comma
id|SCR_INT
comma
id|SIR_RESEL_NO_IDENTIFY
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|reset
)paren
comma
multiline_comment|/*&n;&t;**&t;Message is an IDENTIFY, but lun is unknown.&n;&t;**&t;Read the message, since we got it directly &n;&t;**&t;from the SCSI BUS data lines.&n;&t;**&t;Signal problem to C code for logging the event.&n;&t;**&t;Send a M_ABORT to clear all pending tasks.&n;&t;*/
id|SCR_INT
comma
id|SIR_RESEL_BAD_LUN
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
m_abort
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; BAD_I_T_L &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;We donnot have a task for that I_T_L.&n;&t;**&t;Signal problem to C code for logging the event.&n;&t;**&t;Send a M_ABORT message.&n;&t;*/
id|SCR_INT
comma
id|SIR_RESEL_BAD_I_T_L
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
m_abort
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; BAD_I_T_L_Q &gt;----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;We donnot have a task that matches the tag.&n;&t;**&t;Signal problem to C code for logging the event.&n;&t;**&t;Send a M_ABORTTAG message.&n;&t;*/
id|SCR_INT
comma
id|SIR_RESEL_BAD_I_T_L_Q
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|aborttag
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; BAD_TARGET &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;We donnot know the target that reselected us.&n;&t;**&t;Grab the first message if any (IDENTIFY).&n;&t;**&t;Signal problem to C code for logging the event.&n;&t;**&t;M_RESET message.&n;&t;*/
id|SCR_INT
comma
id|SIR_RESEL_BAD_TARGET
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|reset
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; BAD_STATUS &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;If command resulted in either QUEUE FULL,&n;&t;**&t;CHECK CONDITION or COMMAND TERMINATED,&n;&t;**&t;call the C code.&n;&t;*/
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|S_QUEUE_FULL
)paren
)paren
comma
id|SIR_BAD_STATUS
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|S_CHECK_COND
)paren
)paren
comma
id|SIR_BAD_STATUS
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|S_TERMINATED
)paren
)paren
comma
id|SIR_BAD_STATUS
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; START_RAM &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Load the script into on-chip RAM, &n;&t;**&t;and jump to start point.&n;&t;*/
id|SCR_COPY_F
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|PADDRH
(paren
id|start_ram0
)paren
comma
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|script
)paren
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; START_RAM0 &gt;--------------------*/
comma
(brace
l_int|0
comma
id|PADDR
(paren
id|start
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; STO_RESTART &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&n;&t;**&t;Repair start queue (e.g. next time use the next slot) &n;&t;**&t;and jump to start point.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|PADDR
(paren
id|startpos
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SNOOPTEST &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Read the variable.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
c_func
(paren
id|ncr_cache
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
multiline_comment|/*&n;&t;**&t;Write the variable.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|NADDR
c_func
(paren
id|ncr_cache
)paren
comma
multiline_comment|/*&n;&t;**&t;Read back the variable.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
c_func
(paren
id|ncr_cache
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SNOOPEND &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;And stop.&n;&t;*/
id|SCR_INT
comma
l_int|99
comma
)brace
multiline_comment|/*--------------------------------------------------------*/
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Fill in #define dependent parts of the script&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_script_fill
r_void
id|__init
id|ncr_script_fill
(paren
r_struct
id|script
op_star
id|scr
comma
r_struct
id|scripth
op_star
id|scrh
)paren
(brace
r_int
id|i
suffix:semicolon
id|ncrcmd
op_star
id|p
suffix:semicolon
id|p
op_assign
id|scrh-&gt;tryloop
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_START
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
id|SCR_CALL
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|idle
)paren
suffix:semicolon
)brace
suffix:semicolon
m_assert
(paren
(paren
id|u_long
)paren
id|p
op_eq
(paren
id|u_long
)paren
op_amp
id|scrh-&gt;tryloop
op_plus
r_sizeof
(paren
id|scrh-&gt;tryloop
)paren
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_CCB_DONE_SUPPORT
id|p
op_assign
id|scrh-&gt;done_queue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DONE
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
id|SCR_COPY
(paren
r_sizeof
(paren
id|ccb_p
)paren
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|NADDR
(paren
id|header.cp
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|NADDR
(paren
id|ccb_done
(braket
id|i
)braket
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_CALL
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|done_end
)paren
suffix:semicolon
)brace
m_assert
(paren
(paren
id|u_long
)paren
id|p
op_eq
(paren
id|u_long
)paren
op_amp
id|scrh-&gt;done_queue
op_plus
r_sizeof
(paren
id|scrh-&gt;done_queue
)paren
)paren
suffix:semicolon
macro_line|#endif /* SCSI_NCR_CCB_DONE_SUPPORT */
id|p
op_assign
id|scrh-&gt;hdata_in
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SCATTERH
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
id|SCR_CALL
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|dispatch
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_IN
suffix:semicolon
op_star
id|p
op_increment
op_assign
m_offsetof
(paren
r_struct
id|dsb
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
m_assert
(paren
(paren
id|u_long
)paren
id|p
op_eq
(paren
id|u_long
)paren
op_amp
id|scrh-&gt;hdata_in
op_plus
r_sizeof
(paren
id|scrh-&gt;hdata_in
)paren
)paren
suffix:semicolon
id|p
op_assign
id|scr-&gt;data_in
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|MAX_SCATTERH
suffix:semicolon
id|i
OL
id|MAX_SCATTERH
op_plus
id|MAX_SCATTERL
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
id|SCR_CALL
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|dispatch
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_IN
suffix:semicolon
op_star
id|p
op_increment
op_assign
m_offsetof
(paren
r_struct
id|dsb
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
m_assert
(paren
(paren
id|u_long
)paren
id|p
op_eq
(paren
id|u_long
)paren
op_amp
id|scr-&gt;data_in
op_plus
r_sizeof
(paren
id|scr-&gt;data_in
)paren
)paren
suffix:semicolon
id|p
op_assign
id|scrh-&gt;hdata_out
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SCATTERH
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
id|SCR_CALL
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|dispatch
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_OUT
suffix:semicolon
op_star
id|p
op_increment
op_assign
m_offsetof
(paren
r_struct
id|dsb
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
m_assert
(paren
(paren
id|u_long
)paren
id|p
op_eq
(paren
id|u_long
)paren
op_amp
id|scrh-&gt;hdata_out
op_plus
r_sizeof
(paren
id|scrh-&gt;hdata_out
)paren
)paren
suffix:semicolon
id|p
op_assign
id|scr-&gt;data_out
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|MAX_SCATTERH
suffix:semicolon
id|i
OL
id|MAX_SCATTERH
op_plus
id|MAX_SCATTERL
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
id|SCR_CALL
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|dispatch
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_OUT
suffix:semicolon
op_star
id|p
op_increment
op_assign
m_offsetof
(paren
r_struct
id|dsb
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
m_assert
(paren
(paren
id|u_long
)paren
id|p
op_eq
(paren
id|u_long
)paren
op_amp
id|scr-&gt;data_out
op_plus
r_sizeof
(paren
id|scr-&gt;data_out
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Copy and rebind a script.&n;**&n;**&n;**==========================================================&n;*/
r_static
r_void
id|__init
DECL|function|ncr_script_copy_and_bind
id|ncr_script_copy_and_bind
(paren
id|ncb_p
id|np
comma
id|ncrcmd
op_star
id|src
comma
id|ncrcmd
op_star
id|dst
comma
r_int
id|len
)paren
(brace
id|ncrcmd
id|opcode
comma
r_new
comma
id|old
comma
id|tmp1
comma
id|tmp2
suffix:semicolon
id|ncrcmd
op_star
id|start
comma
op_star
id|end
suffix:semicolon
r_int
id|relocs
suffix:semicolon
r_int
id|opchanged
op_assign
l_int|0
suffix:semicolon
id|start
op_assign
id|src
suffix:semicolon
id|end
op_assign
id|src
op_plus
id|len
op_div
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|src
OL
id|end
)paren
(brace
id|opcode
op_assign
op_star
id|src
op_increment
suffix:semicolon
op_star
id|dst
op_increment
op_assign
id|cpu_to_scr
c_func
(paren
id|opcode
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;If we forget to change the length&n;&t;&t;**&t;in struct script, a field will be&n;&t;&t;**&t;padded with 0. This is an illegal&n;&t;&t;**&t;command.&n;&t;&t;*/
r_if
c_cond
(paren
id|opcode
op_eq
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: ERROR0 IN SCRIPT at %d.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
r_int
)paren
(paren
id|src
op_minus
id|start
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|MDELAY
(paren
l_int|1000
)paren
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_SCRIPT
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%p:  &lt;%x&gt;&bslash;n&quot;
comma
(paren
id|src
op_minus
l_int|1
)paren
comma
(paren
r_int
)paren
id|opcode
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;We don&squot;t have to decode ALL commands&n;&t;&t;*/
r_switch
c_cond
(paren
id|opcode
op_rshift
l_int|28
)paren
(brace
r_case
l_int|0xc
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;COPY has TWO arguments.&n;&t;&t;&t;*/
id|relocs
op_assign
l_int|2
suffix:semicolon
id|tmp1
op_assign
id|src
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#ifdef&t;RELOC_KVAR
r_if
c_cond
(paren
(paren
id|tmp1
op_amp
id|RELOC_MASK
)paren
op_eq
id|RELOC_KVAR
)paren
id|tmp1
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|tmp2
op_assign
id|src
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#ifdef&t;RELOC_KVAR
r_if
c_cond
(paren
(paren
id|tmp2
op_amp
id|RELOC_MASK
)paren
op_eq
id|RELOC_KVAR
)paren
id|tmp2
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|tmp1
op_xor
id|tmp2
)paren
op_amp
l_int|3
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: ERROR1 IN SCRIPT at %d.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
r_int
)paren
(paren
id|src
op_minus
id|start
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|MDELAY
(paren
l_int|1000
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;**&t;If PREFETCH feature not enabled, remove &n;&t;&t;&t;**&t;the NO FLUSH bit if present.&n;&t;&t;&t;*/
r_if
c_cond
(paren
(paren
id|opcode
op_amp
id|SCR_NO_FLUSH
)paren
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_PFEN
)paren
)paren
(brace
id|dst
(braket
op_minus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|opcode
op_amp
op_complement
id|SCR_NO_FLUSH
)paren
suffix:semicolon
op_increment
id|opchanged
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x0
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;MOVE (absolute address)&n;&t;&t;&t;*/
id|relocs
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x8
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;JUMP / CALL&n;&t;&t;&t;**&t;dont&squot;t relocate if relative :-)&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|opcode
op_amp
l_int|0x00800000
)paren
id|relocs
op_assign
l_int|0
suffix:semicolon
r_else
id|relocs
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x4
suffix:colon
r_case
l_int|0x5
suffix:colon
r_case
l_int|0x6
suffix:colon
r_case
l_int|0x7
suffix:colon
id|relocs
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|relocs
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|relocs
)paren
(brace
r_while
c_loop
(paren
id|relocs
op_decrement
)paren
(brace
id|old
op_assign
op_star
id|src
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|old
op_amp
id|RELOC_MASK
)paren
(brace
r_case
id|RELOC_REGISTER
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|pcivtobus
c_func
(paren
id|np-&gt;paddr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RELOC_LABEL
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|np-&gt;p_script
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RELOC_LABELH
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|np-&gt;p_scripth
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RELOC_SOFTC
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|np-&gt;p_ncb
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef&t;RELOC_KVAR
r_case
id|RELOC_KVAR
suffix:colon
r_if
c_cond
(paren
(paren
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
OL
id|SCRIPT_KVAR_FIRST
)paren
op_logical_or
(paren
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
OG
id|SCRIPT_KVAR_LAST
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;ncr KVAR out of range&quot;
)paren
suffix:semicolon
r_new
op_assign
id|vtophys
c_func
(paren
id|script_kvars
(braket
id|old
op_amp
op_complement
id|RELOC_MASK
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
l_int|0
suffix:colon
multiline_comment|/* Don&squot;t relocate a 0 address. */
r_if
c_cond
(paren
id|old
op_eq
l_int|0
)paren
(brace
r_new
op_assign
id|old
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* fall through */
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;ncr_script_copy_and_bind: weird relocation %x&bslash;n&quot;
comma
id|old
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
id|dst
op_increment
op_assign
id|cpu_to_scr
c_func
(paren
r_new
)paren
suffix:semicolon
)brace
)brace
r_else
op_star
id|dst
op_increment
op_assign
id|cpu_to_scr
c_func
(paren
op_star
id|src
op_increment
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      Auto configuration:  attach and init a host adapter.&n;**&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**&t;Linux host data structure&n;**&n;**&t;The script area is allocated in the host data structure&n;**&t;because kmalloc() returns NULL during scsi initialisations&n;**&t;with Linux 1.2.X&n;*/
DECL|struct|host_data
r_struct
id|host_data
(brace
DECL|member|ncb
r_struct
id|ncb
op_star
id|ncb
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;Print something which allows to retrieve the controler type, unit,&n;**&t;target, lun concerned by a kernel message.&n;*/
DECL|function|PRINT_TARGET
r_static
r_void
id|PRINT_TARGET
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|target
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s-&lt;%d,*&gt;: &quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|target
)paren
suffix:semicolon
)brace
DECL|function|PRINT_LUN
r_static
r_void
id|PRINT_LUN
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|target
comma
r_int
id|lun
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s-&lt;%d,%d&gt;: &quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|target
comma
id|lun
)paren
suffix:semicolon
)brace
DECL|function|PRINT_ADDR
r_static
r_void
id|PRINT_ADDR
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|host_data
op_star
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
id|PRINT_LUN
c_func
(paren
id|host_data-&gt;ncb
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;NCR chip clock divisor table.&n;**&t;Divisors are multiplied by 10,000,000 in order to make &n;**&t;calculations more simple.&n;**&n;**==========================================================&n;*/
DECL|macro|_5M
mdefine_line|#define _5M 5000000
DECL|variable|div_10M
r_static
id|u_long
id|div_10M
(braket
)braket
op_assign
(brace
l_int|2
op_star
id|_5M
comma
l_int|3
op_star
id|_5M
comma
l_int|4
op_star
id|_5M
comma
l_int|6
op_star
id|_5M
comma
l_int|8
op_star
id|_5M
comma
l_int|12
op_star
id|_5M
comma
l_int|16
op_star
id|_5M
)brace
suffix:semicolon
multiline_comment|/*===============================================================&n;**&n;**&t;Prepare io register values used by ncr_init() according &n;**&t;to selected and supported features.&n;**&n;**&t;NCR chips allow burst lengths of 2, 4, 8, 16, 32, 64, 128 &n;**&t;transfers. 32,64,128 are only supported by 875 and 895 chips.&n;**&t;We use log base 2 (burst length) as internal code, with &n;**&t;value 0 meaning &quot;burst disabled&quot;.&n;**&n;**===============================================================&n;*/
multiline_comment|/*&n; *&t;Burst length from burst code.&n; */
DECL|macro|burst_length
mdefine_line|#define burst_length(bc) (!(bc))? 0 : 1 &lt;&lt; (bc)
multiline_comment|/*&n; *&t;Burst code from io register bits.&n; */
DECL|macro|burst_code
mdefine_line|#define burst_code(dmode, ctest4, ctest5) &bslash;&n;&t;(ctest4) &amp; 0x80? 0 : (((dmode) &amp; 0xc0) &gt;&gt; 6) + ((ctest5) &amp; 0x04) + 1
multiline_comment|/*&n; *&t;Set initial io register bits from burst code.&n; */
DECL|function|ncr_init_burst
r_static
r_inline
r_void
id|ncr_init_burst
c_func
(paren
id|ncb_p
id|np
comma
id|u_char
id|bc
)paren
(brace
id|np-&gt;rv_ctest4
op_and_assign
op_complement
l_int|0x80
suffix:semicolon
id|np-&gt;rv_dmode
op_and_assign
op_complement
(paren
l_int|0x3
op_lshift
l_int|6
)paren
suffix:semicolon
id|np-&gt;rv_ctest5
op_and_assign
op_complement
l_int|0x4
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc
)paren
(brace
id|np-&gt;rv_ctest4
op_or_assign
l_int|0x80
suffix:semicolon
)brace
r_else
(brace
op_decrement
id|bc
suffix:semicolon
id|np-&gt;rv_dmode
op_or_assign
(paren
(paren
id|bc
op_amp
l_int|0x3
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|np-&gt;rv_ctest5
op_or_assign
(paren
id|bc
op_amp
l_int|0x4
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
multiline_comment|/*&n;**&t;Get target set-up from Symbios format NVRAM.&n;*/
r_static
r_void
id|__init
DECL|function|ncr_Symbios_setup_target
id|ncr_Symbios_setup_target
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|target
comma
id|Symbios_nvram
op_star
id|nvram
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|Symbios_target
op_star
id|tn
op_assign
op_amp
id|nvram-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|tp-&gt;usrsync
op_assign
id|tn-&gt;sync_period
ques
c_cond
(paren
id|tn-&gt;sync_period
op_plus
l_int|3
)paren
op_div
l_int|4
suffix:colon
l_int|255
suffix:semicolon
id|tp-&gt;usrwide
op_assign
id|tn-&gt;bus_width
op_eq
l_int|0x10
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|tp-&gt;usrtags
op_assign
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_QUEUE_TAGS_ENABLED
)paren
ques
c_cond
id|MAX_TAGS
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_DISCONNECT_ENABLE
)paren
)paren
id|tp-&gt;usrflag
op_or_assign
id|UF_NODISC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_SCAN_AT_BOOT_TIME
)paren
)paren
id|tp-&gt;usrflag
op_or_assign
id|UF_NOSCAN
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Get target set-up from Tekram format NVRAM.&n;*/
r_static
r_void
id|__init
DECL|function|ncr_Tekram_setup_target
id|ncr_Tekram_setup_target
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|target
comma
id|Tekram_nvram
op_star
id|nvram
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_struct
id|Tekram_target
op_star
id|tn
op_assign
op_amp
id|nvram-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_SYNC_NEGO
)paren
(brace
id|i
op_assign
id|tn-&gt;sync_index
op_amp
l_int|0xf
suffix:semicolon
id|tp-&gt;usrsync
op_assign
id|Tekram_sync
(braket
id|i
)braket
suffix:semicolon
)brace
id|tp-&gt;usrwide
op_assign
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_WIDE_NEGO
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_TAGGED_COMMANDS
)paren
(brace
id|tp-&gt;usrtags
op_assign
l_int|2
op_lshift
id|nvram-&gt;max_tags_index
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_DISCONNECT_ENABLE
)paren
)paren
id|tp-&gt;usrflag
op_assign
id|UF_NODISC
suffix:semicolon
multiline_comment|/* If any device does not support parity, we will not use this option */
r_if
c_cond
(paren
op_logical_neg
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_PARITY_CHECK
)paren
)paren
id|np-&gt;rv_scntl0
op_and_assign
op_complement
l_int|0x0a
suffix:semicolon
multiline_comment|/* SCSI parity checking disabled */
)brace
macro_line|#endif /* SCSI_NCR_NVRAM_SUPPORT */
DECL|function|ncr_prepare_setting
r_static
r_int
id|__init
id|ncr_prepare_setting
c_func
(paren
id|ncb_p
id|np
comma
id|ncr_nvram
op_star
id|nvram
)paren
(brace
id|u_char
id|burst_max
suffix:semicolon
id|u_long
id|period
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Save assumed BIOS setting&n;&t;*/
id|np-&gt;sv_scntl0
op_assign
id|INB
c_func
(paren
id|nc_scntl0
)paren
op_amp
l_int|0x0a
suffix:semicolon
id|np-&gt;sv_scntl3
op_assign
id|INB
c_func
(paren
id|nc_scntl3
)paren
op_amp
l_int|0x07
suffix:semicolon
id|np-&gt;sv_dmode
op_assign
id|INB
c_func
(paren
id|nc_dmode
)paren
op_amp
l_int|0xce
suffix:semicolon
id|np-&gt;sv_dcntl
op_assign
id|INB
c_func
(paren
id|nc_dcntl
)paren
op_amp
l_int|0xa8
suffix:semicolon
id|np-&gt;sv_ctest3
op_assign
id|INB
c_func
(paren
id|nc_ctest3
)paren
op_amp
l_int|0x01
suffix:semicolon
id|np-&gt;sv_ctest4
op_assign
id|INB
c_func
(paren
id|nc_ctest4
)paren
op_amp
l_int|0x80
suffix:semicolon
id|np-&gt;sv_ctest5
op_assign
id|INB
c_func
(paren
id|nc_ctest5
)paren
op_amp
l_int|0x24
suffix:semicolon
id|np-&gt;sv_gpcntl
op_assign
id|INB
c_func
(paren
id|nc_gpcntl
)paren
suffix:semicolon
id|np-&gt;sv_stest2
op_assign
id|INB
c_func
(paren
id|nc_stest2
)paren
op_amp
l_int|0x20
suffix:semicolon
id|np-&gt;sv_stest4
op_assign
id|INB
c_func
(paren
id|nc_stest4
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Wide ?&n;&t;*/
id|np-&gt;maxwide
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_WIDE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Get the frequency of the chip&squot;s clock.&n;&t;**&t;Find the right value for scntl3.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_QUAD
)paren
id|np-&gt;multiplier
op_assign
l_int|4
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_DBLR
)paren
id|np-&gt;multiplier
op_assign
l_int|2
suffix:semicolon
r_else
id|np-&gt;multiplier
op_assign
l_int|1
suffix:semicolon
id|np-&gt;clock_khz
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_CLK80
)paren
ques
c_cond
l_int|80000
suffix:colon
l_int|40000
suffix:semicolon
id|np-&gt;clock_khz
op_mul_assign
id|np-&gt;multiplier
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;clock_khz
op_ne
l_int|40000
)paren
id|ncr_getclock
c_func
(paren
id|np
comma
id|np-&gt;multiplier
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Divisor to be used for async (timer pre-scaler).&n;&t; */
id|i
op_assign
id|np-&gt;clock_divn
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|i
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
l_int|10ul
op_star
id|SCSI_NCR_MIN_ASYNC
op_star
id|np-&gt;clock_khz
OG
id|div_10M
(braket
id|i
)braket
)paren
(brace
op_increment
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|np-&gt;rv_scntl3
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Minimum synchronous period factor supported by the chip.&n;&t; * Btw, &squot;period&squot; is in tenths of nanoseconds.&n;&t; */
id|period
op_assign
(paren
l_int|4
op_star
id|div_10M
(braket
l_int|0
)braket
op_plus
id|np-&gt;clock_khz
op_minus
l_int|1
)paren
op_div
id|np-&gt;clock_khz
suffix:semicolon
r_if
c_cond
(paren
id|period
op_le
l_int|250
)paren
id|np-&gt;minsync
op_assign
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
id|period
op_le
l_int|303
)paren
id|np-&gt;minsync
op_assign
l_int|11
suffix:semicolon
r_else
r_if
c_cond
(paren
id|period
op_le
l_int|500
)paren
id|np-&gt;minsync
op_assign
l_int|12
suffix:semicolon
r_else
id|np-&gt;minsync
op_assign
(paren
id|period
op_plus
l_int|40
op_minus
l_int|1
)paren
op_div
l_int|40
suffix:semicolon
multiline_comment|/*&n;&t; * Check against chip SCSI standard support (SCSI-2,ULTRA,ULTRA2).&n;&t; */
r_if
c_cond
(paren
id|np-&gt;minsync
OL
l_int|25
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
(paren
id|FE_ULTRA
op_or
id|FE_ULTRA2
)paren
)paren
)paren
id|np-&gt;minsync
op_assign
l_int|25
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;minsync
OL
l_int|12
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA2
)paren
)paren
id|np-&gt;minsync
op_assign
l_int|12
suffix:semicolon
multiline_comment|/*&n;&t; * Maximum synchronous period factor supported by the chip.&n;&t; */
id|period
op_assign
(paren
l_int|11
op_star
id|div_10M
(braket
id|np-&gt;clock_divn
op_minus
l_int|1
)braket
)paren
op_div
(paren
l_int|4
op_star
id|np-&gt;clock_khz
)paren
suffix:semicolon
id|np-&gt;maxsync
op_assign
id|period
OG
l_int|2540
ques
c_cond
l_int|254
suffix:colon
id|period
op_div
l_int|10
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Prepare initial value of other IO registers&n;&t;*/
macro_line|#if defined SCSI_NCR_TRUST_BIOS_SETTING
id|np-&gt;rv_scntl0
op_assign
id|np-&gt;sv_scntl0
suffix:semicolon
id|np-&gt;rv_dmode
op_assign
id|np-&gt;sv_dmode
suffix:semicolon
id|np-&gt;rv_dcntl
op_assign
id|np-&gt;sv_dcntl
suffix:semicolon
id|np-&gt;rv_ctest3
op_assign
id|np-&gt;sv_ctest3
suffix:semicolon
id|np-&gt;rv_ctest4
op_assign
id|np-&gt;sv_ctest4
suffix:semicolon
id|np-&gt;rv_ctest5
op_assign
id|np-&gt;sv_ctest5
suffix:semicolon
id|burst_max
op_assign
id|burst_code
c_func
(paren
id|np-&gt;sv_dmode
comma
id|np-&gt;sv_ctest4
comma
id|np-&gt;sv_ctest5
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/*&n;&t;**&t;Select burst length (dwords)&n;&t;*/
id|burst_max
op_assign
id|driver_setup.burst_max
suffix:semicolon
r_if
c_cond
(paren
id|burst_max
op_eq
l_int|255
)paren
id|burst_max
op_assign
id|burst_code
c_func
(paren
id|np-&gt;sv_dmode
comma
id|np-&gt;sv_ctest4
comma
id|np-&gt;sv_ctest5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|burst_max
OG
l_int|7
)paren
id|burst_max
op_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|burst_max
OG
id|np-&gt;maxburst
)paren
id|burst_max
op_assign
id|np-&gt;maxburst
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Select all supported special features&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_ERL
)paren
id|np-&gt;rv_dmode
op_or_assign
id|ERL
suffix:semicolon
multiline_comment|/* Enable Read Line */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_BOF
)paren
id|np-&gt;rv_dmode
op_or_assign
id|BOF
suffix:semicolon
multiline_comment|/* Burst Opcode Fetch */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_ERMP
)paren
id|np-&gt;rv_dmode
op_or_assign
id|ERMP
suffix:semicolon
multiline_comment|/* Enable Read Multiple */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_PFEN
)paren
id|np-&gt;rv_dcntl
op_or_assign
id|PFEN
suffix:semicolon
multiline_comment|/* Prefetch Enable */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_CLSE
)paren
id|np-&gt;rv_dcntl
op_or_assign
id|CLSE
suffix:semicolon
multiline_comment|/* Cache Line Size Enable */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_WRIE
)paren
id|np-&gt;rv_ctest3
op_or_assign
id|WRIE
suffix:semicolon
multiline_comment|/* Write and Invalidate */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_DFS
)paren
id|np-&gt;rv_ctest5
op_or_assign
id|DFS
suffix:semicolon
multiline_comment|/* Dma Fifo Size */
multiline_comment|/*&n;&t;**&t;Select some other&n;&t;*/
r_if
c_cond
(paren
id|driver_setup.master_parity
)paren
id|np-&gt;rv_ctest4
op_or_assign
id|MPEE
suffix:semicolon
multiline_comment|/* Master parity checking */
r_if
c_cond
(paren
id|driver_setup.scsi_parity
)paren
id|np-&gt;rv_scntl0
op_or_assign
l_int|0x0a
suffix:semicolon
multiline_comment|/*  full arb., ena parity, par-&gt;ATN  */
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
multiline_comment|/*&n;&t;**&t;Get parity checking, host ID and verbose mode from NVRAM&n;&t;**/
r_if
c_cond
(paren
id|nvram
)paren
(brace
r_switch
c_cond
(paren
id|nvram-&gt;type
)paren
(brace
r_case
id|SCSI_NCR_TEKRAM_NVRAM
suffix:colon
id|np-&gt;myaddr
op_assign
id|nvram-&gt;data.Tekram.host_id
op_amp
l_int|0x0f
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|nvram-&gt;data.Symbios.flags
op_amp
id|SYMBIOS_PARITY_ENABLE
)paren
)paren
id|np-&gt;rv_scntl0
op_and_assign
op_complement
l_int|0x0a
suffix:semicolon
id|np-&gt;myaddr
op_assign
id|nvram-&gt;data.Symbios.host_id
op_amp
l_int|0x0f
suffix:semicolon
r_if
c_cond
(paren
id|nvram-&gt;data.Symbios.flags
op_amp
id|SYMBIOS_VERBOSE_MSGS
)paren
id|np-&gt;verbose
op_add_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**  Get SCSI addr of host adapter (set by bios?).&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;myaddr
op_eq
l_int|255
)paren
(brace
id|np-&gt;myaddr
op_assign
id|INB
c_func
(paren
id|nc_scid
)paren
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;myaddr
)paren
id|np-&gt;myaddr
op_assign
id|SCSI_NCR_MYADDR
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_TRUST_BIOS_SETTING */
multiline_comment|/*&n;&t; *&t;Prepare initial io register bits for burst length&n;&t; */
id|ncr_init_burst
c_func
(paren
id|np
comma
id|burst_max
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set SCSI BUS mode.&n;&t;**&n;&t;**&t;- ULTRA2 chips (895/895A/896) report the current &n;&t;**&t;  BUS mode through the STEST4 IO register.&n;&t;**&t;- For previous generation chips (825/825A/875), &n;&t;**&t;  user has to tell us how to check against HVD, &n;&t;**&t;  since a 100% safe algorithm is not possible.&n;&t;*/
id|np-&gt;scsi_mode
op_assign
id|SMODE_SE
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA2
)paren
id|np-&gt;scsi_mode
op_assign
(paren
id|np-&gt;sv_stest4
op_amp
id|SMODE
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_DIFF
)paren
(brace
r_switch
c_cond
(paren
id|driver_setup.diff_support
)paren
(brace
r_case
l_int|4
suffix:colon
multiline_comment|/* Trust previous settings if present, then GPIO3 */
r_if
c_cond
(paren
id|np-&gt;sv_scntl3
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;sv_stest2
op_amp
l_int|0x20
)paren
id|np-&gt;scsi_mode
op_assign
id|SMODE_HVD
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|3
suffix:colon
multiline_comment|/* SYMBIOS controllers report HVD through GPIO3 */
r_if
c_cond
(paren
id|nvram
op_logical_and
id|nvram-&gt;type
op_ne
id|SCSI_NCR_SYMBIOS_NVRAM
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_gpreg
)paren
op_amp
l_int|0x08
)paren
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* Set HVD unconditionally */
id|np-&gt;scsi_mode
op_assign
id|SMODE_HVD
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* Trust previous settings for HVD */
r_if
c_cond
(paren
id|np-&gt;sv_stest2
op_amp
l_int|0x20
)paren
id|np-&gt;scsi_mode
op_assign
id|SMODE_HVD
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Don&squot;t care about HVD */
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|np-&gt;scsi_mode
op_eq
id|SMODE_HVD
)paren
id|np-&gt;rv_stest2
op_or_assign
l_int|0x20
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set LED support from SCRIPTS.&n;&t;**&t;Ignore this feature for boards known to use a &n;&t;**&t;specific GPIO wiring and for the 895A or 896 &n;&t;**&t;that drive the LED directly.&n;&t;**&t;Also probe initial setting of GPIO0 as output.&n;&t;*/
r_if
c_cond
(paren
(paren
id|driver_setup.led_pin
op_logical_or
(paren
id|nvram
op_logical_and
id|nvram-&gt;type
op_eq
id|SCSI_NCR_SYMBIOS_NVRAM
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_LEDC
)paren
op_logical_and
op_logical_neg
(paren
id|np-&gt;sv_gpcntl
op_amp
l_int|0x01
)paren
)paren
id|np-&gt;features
op_or_assign
id|FE_LED0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set irq mode.&n;&t;*/
r_switch
c_cond
(paren
id|driver_setup.irqm
op_amp
l_int|3
)paren
(brace
r_case
l_int|2
suffix:colon
id|np-&gt;rv_dcntl
op_or_assign
id|IRQM
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|np-&gt;rv_dcntl
op_or_assign
(paren
id|np-&gt;sv_dcntl
op_amp
id|IRQM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Configure targets according to driver setup.&n;&t;**&t;If NVRAM present get targets setup from NVRAM.&n;&t;**&t;Allow to override sync, wide and NOSCAN from &n;&t;**&t;boot command line.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|tp-&gt;usrsync
op_assign
l_int|255
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_if
c_cond
(paren
id|nvram
)paren
(brace
r_switch
c_cond
(paren
id|nvram-&gt;type
)paren
(brace
r_case
id|SCSI_NCR_TEKRAM_NVRAM
suffix:colon
id|ncr_Tekram_setup_target
c_func
(paren
id|np
comma
id|i
comma
op_amp
id|nvram-&gt;data.Tekram
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:colon
id|ncr_Symbios_setup_target
c_func
(paren
id|np
comma
id|i
comma
op_amp
id|nvram-&gt;data.Symbios
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x2
)paren
id|tp-&gt;usrsync
op_assign
id|driver_setup.default_sync
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x4
)paren
id|tp-&gt;usrwide
op_assign
id|driver_setup.max_wide
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x8
)paren
id|tp-&gt;usrflag
op_and_assign
op_complement
id|UF_NOSCAN
suffix:semicolon
)brace
r_else
(brace
macro_line|#else
r_if
c_cond
(paren
l_int|1
)paren
(brace
macro_line|#endif
id|tp-&gt;usrsync
op_assign
id|driver_setup.default_sync
suffix:semicolon
id|tp-&gt;usrwide
op_assign
id|driver_setup.max_wide
suffix:semicolon
id|tp-&gt;usrtags
op_assign
id|MAX_TAGS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver_setup.disconnection
)paren
id|np-&gt;target
(braket
id|i
)braket
dot
id|usrflag
op_assign
id|UF_NODISC
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;**&t;Announce all that stuff to user.&n;&t;*/
id|i
op_assign
id|nvram
ques
c_cond
id|nvram-&gt;type
suffix:colon
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %sID %d, Fast-%d%s%s&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|i
op_eq
id|SCSI_NCR_SYMBIOS_NVRAM
ques
c_cond
l_string|&quot;Symbios format NVRAM, &quot;
suffix:colon
(paren
id|i
op_eq
id|SCSI_NCR_TEKRAM_NVRAM
ques
c_cond
l_string|&quot;Tekram format NVRAM, &quot;
suffix:colon
l_string|&quot;&quot;
)paren
comma
id|np-&gt;myaddr
comma
id|np-&gt;minsync
OL
l_int|12
ques
c_cond
l_int|40
suffix:colon
(paren
id|np-&gt;minsync
OL
l_int|25
ques
c_cond
l_int|20
suffix:colon
l_int|10
)paren
comma
(paren
id|np-&gt;rv_scntl0
op_amp
l_int|0xa
)paren
ques
c_cond
l_string|&quot;, Parity Checking&quot;
suffix:colon
l_string|&quot;, NO Parity&quot;
comma
(paren
id|np-&gt;rv_stest2
op_amp
l_int|0x20
)paren
ques
c_cond
l_string|&quot;, Differential&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: initial SCNTL3/DMODE/DCNTL/CTEST3/4/5 = &quot;
l_string|&quot;(hex) %02x/%02x/%02x/%02x/%02x/%02x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;sv_scntl3
comma
id|np-&gt;sv_dmode
comma
id|np-&gt;sv_dcntl
comma
id|np-&gt;sv_ctest3
comma
id|np-&gt;sv_ctest4
comma
id|np-&gt;sv_ctest5
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: final   SCNTL3/DMODE/DCNTL/CTEST3/4/5 = &quot;
l_string|&quot;(hex) %02x/%02x/%02x/%02x/%02x/%02x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;rv_scntl3
comma
id|np-&gt;rv_dmode
comma
id|np-&gt;rv_dcntl
comma
id|np-&gt;rv_ctest3
comma
id|np-&gt;rv_ctest4
comma
id|np-&gt;rv_ctest5
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bootverbose
op_logical_and
id|np-&gt;paddr2
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: on-chip RAM at 0x%lx&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;paddr2
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Host attach and initialisations.&n;**&n;**&t;Allocate host data and ncb structure.&n;**&t;Request IO region and remap MMIO region.&n;**&t;Do chip initialization.&n;**&t;If all is OK, install interrupt handling and&n;**&t;start the timer daemon.&n;*/
r_static
r_int
id|__init
DECL|function|ncr_attach
id|ncr_attach
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|unit
comma
id|ncr_device
op_star
id|device
)paren
(brace
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
id|ncb_p
id|np
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
op_assign
l_int|0
suffix:semicolon
id|u_long
id|flags
op_assign
l_int|0
suffix:semicolon
id|ncr_nvram
op_star
id|nvram
op_assign
id|device-&gt;nvram
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ncr53c%s-%d: rev 0x%x on pci bus %d device %d function %d &quot;
macro_line|#ifdef __sparc__
l_string|&quot;irq %s&bslash;n&quot;
comma
macro_line|#else
l_string|&quot;irq %d&bslash;n&quot;
comma
macro_line|#endif
id|device-&gt;chip.name
comma
id|unit
comma
id|device-&gt;chip.revision_id
comma
id|device-&gt;slot.bus
comma
(paren
id|device-&gt;slot.device_fn
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
comma
id|device-&gt;slot.device_fn
op_amp
l_int|7
comma
macro_line|#ifdef __sparc__
id|__irq_itoa
c_func
(paren
id|device-&gt;slot.irq
)paren
)paren
suffix:semicolon
macro_line|#else
id|device-&gt;slot.irq
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Allocate host_data structure&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|instance
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
r_sizeof
(paren
op_star
id|host_data
)paren
)paren
)paren
)paren
r_goto
id|attach_error
suffix:semicolon
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate the host control block.&n;&t;*/
id|np
op_assign
id|__m_calloc_dma
c_func
(paren
id|device-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|ncb
)paren
comma
l_string|&quot;NCB&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np
)paren
r_goto
id|attach_error
suffix:semicolon
id|NCR_INIT_LOCK_NCB
c_func
(paren
id|np
)paren
suffix:semicolon
id|np-&gt;pdev
op_assign
id|device-&gt;pdev
suffix:semicolon
id|np-&gt;p_ncb
op_assign
id|vtobus
c_func
(paren
id|np
)paren
suffix:semicolon
id|host_data-&gt;ncb
op_assign
id|np
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate the default CCB.&n;&t;*/
id|np-&gt;ccb
op_assign
(paren
id|ccb_p
)paren
id|m_calloc_dma
c_func
(paren
r_sizeof
(paren
r_struct
id|ccb
)paren
comma
l_string|&quot;CCB&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;ccb
)paren
r_goto
id|attach_error
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Store input informations in the host data structure.&n;&t;*/
id|strncpy
c_func
(paren
id|np-&gt;chip_name
comma
id|device-&gt;chip.name
comma
r_sizeof
(paren
id|np-&gt;chip_name
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|np-&gt;unit
op_assign
id|unit
suffix:semicolon
id|np-&gt;verbose
op_assign
id|driver_setup.verbose
suffix:semicolon
id|sprintf
c_func
(paren
id|np-&gt;inst_name
comma
l_string|&quot;ncr53c%s-%d&quot;
comma
id|np-&gt;chip_name
comma
id|np-&gt;unit
)paren
suffix:semicolon
id|np-&gt;device_id
op_assign
id|device-&gt;chip.device_id
suffix:semicolon
id|np-&gt;revision_id
op_assign
id|device-&gt;chip.revision_id
suffix:semicolon
id|np-&gt;bus
op_assign
id|device-&gt;slot.bus
suffix:semicolon
id|np-&gt;device_fn
op_assign
id|device-&gt;slot.device_fn
suffix:semicolon
id|np-&gt;features
op_assign
id|device-&gt;chip.features
suffix:semicolon
id|np-&gt;clock_divn
op_assign
id|device-&gt;chip.nr_divisor
suffix:semicolon
id|np-&gt;maxoffs
op_assign
id|device-&gt;chip.offset_max
suffix:semicolon
id|np-&gt;maxburst
op_assign
id|device-&gt;chip.burst_max
suffix:semicolon
id|np-&gt;myaddr
op_assign
id|device-&gt;host_id
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate SCRIPTS areas.&n;&t;*/
id|np-&gt;script0
op_assign
(paren
r_struct
id|script
op_star
)paren
id|m_calloc_dma
c_func
(paren
r_sizeof
(paren
r_struct
id|script
)paren
comma
l_string|&quot;SCRIPT&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;script0
)paren
r_goto
id|attach_error
suffix:semicolon
id|np-&gt;scripth0
op_assign
(paren
r_struct
id|scripth
op_star
)paren
id|m_calloc_dma
c_func
(paren
r_sizeof
(paren
r_struct
id|scripth
)paren
comma
l_string|&quot;SCRIPTH&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;scripth0
)paren
r_goto
id|attach_error
suffix:semicolon
multiline_comment|/*&n;&t;**    Initialize timer structure&n;        **&n;        */
id|init_timer
c_func
(paren
op_amp
id|np-&gt;timer
)paren
suffix:semicolon
id|np-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|np
suffix:semicolon
id|np-&gt;timer.function
op_assign
id|ncr53c8xx_timeout
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Try to map the controller chip to&n;&t;**&t;virtual and physical memory.&n;&t;*/
id|np-&gt;paddr
op_assign
id|device-&gt;slot.base
suffix:semicolon
id|np-&gt;paddr2
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_RAM
)paren
ques
c_cond
id|device-&gt;slot.base_2
suffix:colon
l_int|0
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
id|np-&gt;vaddr
op_assign
id|remap_pci_mem
c_func
(paren
(paren
id|u_long
)paren
id|np-&gt;paddr
comma
(paren
id|u_long
)paren
l_int|128
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;vaddr
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: can&squot;t map memory mapped IO region&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: using memory mapped IO at virtual address 0x%lx&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|np-&gt;vaddr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Make the controller&squot;s registers available.&n;&t;**&t;Now the INB INW INL OUTB OUTW OUTL macros&n;&t;**&t;can be used safely.&n;&t;*/
id|np-&gt;reg
op_assign
(paren
r_struct
id|ncr_reg
op_star
)paren
id|np-&gt;vaddr
suffix:semicolon
macro_line|#endif /* !defined NCR_IOMAPPED */
multiline_comment|/*&n;&t;**&t;Try to map the controller chip into iospace.&n;&t;*/
id|request_region
c_func
(paren
id|device-&gt;slot.io_port
comma
l_int|128
comma
l_string|&quot;ncr53c8xx&quot;
)paren
suffix:semicolon
id|np-&gt;base_io
op_assign
id|device-&gt;slot.io_port
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_if
c_cond
(paren
id|nvram
)paren
(brace
r_switch
c_cond
(paren
id|nvram-&gt;type
)paren
(brace
r_case
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:colon
macro_line|#ifdef SCSI_NCR_DEBUG_NVRAM
id|ncr_display_Symbios_nvram
c_func
(paren
op_amp
id|nvram-&gt;data.Symbios
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|SCSI_NCR_TEKRAM_NVRAM
suffix:colon
macro_line|#ifdef SCSI_NCR_DEBUG_NVRAM
id|ncr_display_Tekram_nvram
c_func
(paren
op_amp
id|nvram-&gt;data.Tekram
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_default
suffix:colon
id|nvram
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SCSI_NCR_DEBUG_NVRAM
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: NVRAM: None or invalid data.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Do chip dependent initialization.&n;&t;*/
(paren
r_void
)paren
id|ncr_prepare_setting
c_func
(paren
id|np
comma
id|nvram
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;paddr2
op_logical_and
r_sizeof
(paren
r_struct
id|script
)paren
OG
l_int|4096
)paren
(brace
id|np-&gt;paddr2
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: script too large, NOT using on chip RAM.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Fill Linux host instance structure&n;&t;*/
id|instance-&gt;max_channel
op_assign
l_int|0
suffix:semicolon
id|instance-&gt;this_id
op_assign
id|np-&gt;myaddr
suffix:semicolon
id|instance-&gt;max_id
op_assign
id|np-&gt;maxwide
ques
c_cond
l_int|16
suffix:colon
l_int|8
suffix:semicolon
id|instance-&gt;max_lun
op_assign
id|SCSI_NCR_MAX_LUN
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,3,29)
id|instance-&gt;base
op_assign
(paren
r_int
r_int
)paren
id|np-&gt;reg
suffix:semicolon
macro_line|#else
id|instance-&gt;base
op_assign
(paren
r_char
op_star
)paren
id|np-&gt;reg
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|instance-&gt;irq
op_assign
id|device-&gt;slot.irq
suffix:semicolon
id|instance-&gt;unique_id
op_assign
id|device-&gt;slot.io_port
suffix:semicolon
id|instance-&gt;io_port
op_assign
id|device-&gt;slot.io_port
suffix:semicolon
id|instance-&gt;n_io_port
op_assign
l_int|128
suffix:semicolon
id|instance-&gt;dma_channel
op_assign
l_int|0
suffix:semicolon
id|instance-&gt;cmd_per_lun
op_assign
id|MAX_TAGS
suffix:semicolon
id|instance-&gt;can_queue
op_assign
(paren
id|MAX_START
op_minus
l_int|4
)paren
suffix:semicolon
id|instance-&gt;select_queue_depths
op_assign
id|ncr53c8xx_select_queue_depths
suffix:semicolon
macro_line|#ifdef SCSI_NCR_INTEGRITY_CHECKING
id|np-&gt;check_integrity
op_assign
l_int|0
suffix:semicolon
id|instance-&gt;check_integrity
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SCSI_NCR_ENABLE_INTEGRITY_CHECK
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver_setup.bus_check
op_amp
l_int|0x04
)paren
)paren
(brace
id|np-&gt;check_integrity
op_assign
l_int|1
suffix:semicolon
id|instance-&gt;check_integrity
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Patch script to physical addresses&n;&t;*/
id|ncr_script_fill
(paren
op_amp
id|script0
comma
op_amp
id|scripth0
)paren
suffix:semicolon
id|np-&gt;scripth
op_assign
id|np-&gt;scripth0
suffix:semicolon
id|np-&gt;p_scripth
op_assign
id|vtobus
c_func
(paren
id|np-&gt;scripth
)paren
suffix:semicolon
id|np-&gt;p_script
op_assign
(paren
id|np-&gt;paddr2
)paren
ques
c_cond
id|pcivtobus
c_func
(paren
id|np-&gt;paddr2
)paren
suffix:colon
id|vtobus
c_func
(paren
id|np-&gt;script0
)paren
suffix:semicolon
id|ncr_script_copy_and_bind
(paren
id|np
comma
(paren
id|ncrcmd
op_star
)paren
op_amp
id|script0
comma
(paren
id|ncrcmd
op_star
)paren
id|np-&gt;script0
comma
r_sizeof
(paren
r_struct
id|script
)paren
)paren
suffix:semicolon
id|ncr_script_copy_and_bind
(paren
id|np
comma
(paren
id|ncrcmd
op_star
)paren
op_amp
id|scripth0
comma
(paren
id|ncrcmd
op_star
)paren
id|np-&gt;scripth0
comma
r_sizeof
(paren
r_struct
id|scripth
)paren
)paren
suffix:semicolon
id|np-&gt;ccb-&gt;p_ccb
op_assign
id|vtobus
(paren
id|np-&gt;ccb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**    Patch the script for LED support.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_LED0
)paren
(brace
id|np-&gt;script0-&gt;idle
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_REG_REG
c_func
(paren
id|gpreg
comma
id|SCR_OR
comma
l_int|0x01
)paren
)paren
suffix:semicolon
id|np-&gt;script0-&gt;reselected
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_REG_REG
c_func
(paren
id|gpreg
comma
id|SCR_AND
comma
l_int|0xfe
)paren
)paren
suffix:semicolon
id|np-&gt;script0-&gt;start
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_REG_REG
c_func
(paren
id|gpreg
comma
id|SCR_AND
comma
l_int|0xfe
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Look for the target control block of this nexus.&n;&t;**&t;For i = 0 to 3&n;&t;**&t;&t;JUMP ^ IFTRUE (MASK (i, 3)), @(next_lcb)&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|np-&gt;jump_tcb
(braket
id|i
)braket
dot
id|l_cmd
op_assign
id|cpu_to_scr
c_func
(paren
(paren
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|i
comma
l_int|3
)paren
)paren
)paren
)paren
suffix:semicolon
id|np-&gt;jump_tcb
(braket
id|i
)braket
dot
id|l_paddr
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|bad_target
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Reset chip.&n;&t;*/
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|100
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Now check the cache handling of the pci chipset.&n;&t;*/
r_if
c_cond
(paren
id|ncr_snooptest
(paren
id|np
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;CACHE INCORRECTLY CONFIGURED.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Install the interrupt handler.&n;&t;*/
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|device-&gt;slot.irq
comma
id|ncr53c8xx_intr
comma
(paren
(paren
id|driver_setup.irqm
op_amp
l_int|0x10
)paren
ques
c_cond
l_int|0
suffix:colon
id|SA_SHIRQ
)paren
op_or
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,2,0)
(paren
(paren
id|driver_setup.irqm
op_amp
l_int|0x20
)paren
ques
c_cond
l_int|0
suffix:colon
id|SA_INTERRUPT
)paren
comma
macro_line|#else
l_int|0
comma
macro_line|#endif
l_string|&quot;ncr53c8xx&quot;
comma
id|np
)paren
)paren
(brace
macro_line|#ifdef __sparc__
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: request irq %s failure&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|__irq_itoa
c_func
(paren
id|device-&gt;slot.irq
)paren
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: request irq %d failure&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|device-&gt;slot.irq
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|attach_error
suffix:semicolon
)brace
id|np-&gt;irq
op_assign
id|device-&gt;slot.irq
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initialize the fixed part of the default ccb.&n;&t;*/
id|ncr_init_ccb
c_func
(paren
id|np
comma
id|np-&gt;ccb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;After SCSI devices have been opened, we cannot&n;&t;**&t;reset the bus safely, so we do it here.&n;&t;**&t;Interrupt handler does the real work.&n;&t;**&t;Process the reset exception,&n;&t;**&t;if interrupts are not enabled yet.&n;&t;**&t;Then enable disconnects.&n;&t;*/
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ncr_reset_scsi_bus
c_func
(paren
id|np
comma
l_int|0
comma
id|driver_setup.settle_delay
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: FATAL ERROR: CHECK SCSI BUS - CABLES, TERMINATION, DEVICE POWER etc.!&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
id|ncr_exception
(paren
id|np
)paren
suffix:semicolon
id|np-&gt;disc
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The middle-level SCSI driver does not&n;&t;**&t;wait for devices to settle.&n;&t;**&t;Wait synchronously if more than 2 seconds.&n;&t;*/
r_if
c_cond
(paren
id|driver_setup.settle_delay
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: waiting %d seconds for scsi devices to settle...&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|driver_setup.settle_delay
)paren
suffix:semicolon
id|MDELAY
(paren
l_int|1000
op_star
id|driver_setup.settle_delay
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Now let the generic SCSI driver&n;&t;**&t;look for the SCSI devices on the bus ..&n;&t;*/
multiline_comment|/*&n;&t;**&t;start the timeout daemon&n;&t;*/
id|np-&gt;lasttime
op_assign
l_int|0
suffix:semicolon
id|ncr_timeout
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**  use SIMPLE TAG messages by default&n;&t;*/
macro_line|#ifdef SCSI_NCR_ALWAYS_SIMPLE_TAG
id|np-&gt;order
op_assign
id|M_SIMPLE_TAG
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**  Done.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|the_template
)paren
(brace
id|the_template
op_assign
id|instance-&gt;hostt
suffix:semicolon
id|first_host
op_assign
id|instance
suffix:semicolon
)brace
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|attach_error
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|instance
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: detaching...&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np
)paren
r_goto
id|unregister
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
r_if
c_cond
(paren
id|np-&gt;vaddr
)paren
(brace
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: releasing memory mapped IO region %lx[%d]&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|np-&gt;vaddr
comma
l_int|128
)paren
suffix:semicolon
macro_line|#endif
id|unmap_pci_mem
c_func
(paren
(paren
id|vm_offset_t
)paren
id|np-&gt;vaddr
comma
(paren
id|u_long
)paren
l_int|128
)paren
suffix:semicolon
)brace
macro_line|#endif /* !NCR_IOMAPPED */
r_if
c_cond
(paren
id|np-&gt;base_io
)paren
(brace
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: releasing IO region %x[%d]&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;base_io
comma
l_int|128
)paren
suffix:semicolon
macro_line|#endif
id|release_region
c_func
(paren
id|np-&gt;base_io
comma
l_int|128
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|np-&gt;irq
)paren
(brace
macro_line|#ifdef DEBUG_NCR53C8XX
macro_line|#ifdef __sparc__
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: freeing irq %s&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|__irq_itoa
c_func
(paren
id|np-&gt;irq
)paren
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: freeing irq %d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;irq
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|free_irq
c_func
(paren
id|np-&gt;irq
comma
id|np
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|np-&gt;scripth0
)paren
id|m_free_dma
c_func
(paren
id|np-&gt;scripth0
comma
r_sizeof
(paren
r_struct
id|scripth
)paren
comma
l_string|&quot;SCRIPTH&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;script0
)paren
id|m_free_dma
c_func
(paren
id|np-&gt;script0
comma
r_sizeof
(paren
r_struct
id|script
)paren
comma
l_string|&quot;SCRIPT&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;ccb
)paren
id|m_free_dma
c_func
(paren
id|np-&gt;ccb
comma
r_sizeof
(paren
r_struct
id|ccb
)paren
comma
l_string|&quot;CCB&quot;
)paren
suffix:semicolon
id|m_free_dma
c_func
(paren
id|np
comma
r_sizeof
(paren
r_struct
id|ncb
)paren
comma
l_string|&quot;NCB&quot;
)paren
suffix:semicolon
id|unregister
suffix:colon
id|scsi_unregister
c_func
(paren
id|instance
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Done SCSI commands list management.&n;**&n;**&t;We donnot enter the scsi_done() callback immediately &n;**&t;after a command has been seen as completed but we &n;**&t;insert it into a list which is flushed outside any kind &n;**&t;of driver critical section.&n;**&t;This allows to do minimal stuff under interrupt and &n;**&t;inside critical sections and to also avoid locking up &n;**&t;on recursive calls to driver entry points under SMP.&n;**&t;In fact, the only kernel point which is entered by the &n;**&t;driver with a driver lock set is kmalloc(GFP_ATOMIC) &n;**&t;that shall not reenter the driver under any circumstances,&n;**&t;AFAIK.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_queue_done_cmd
r_static
r_inline
r_void
id|ncr_queue_done_cmd
c_func
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|unmap_scsi_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
(paren
r_char
op_star
)paren
id|np-&gt;done_list
suffix:semicolon
id|np-&gt;done_list
op_assign
id|cmd
suffix:semicolon
)brace
DECL|function|ncr_flush_done_cmds
r_static
r_inline
r_void
id|ncr_flush_done_cmds
c_func
(paren
id|Scsi_Cmnd
op_star
id|lcmd
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_while
c_loop
(paren
id|lcmd
)paren
(brace
id|cmd
op_assign
id|lcmd
suffix:semicolon
id|lcmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Prepare the next negotiation message for integrity check,&n;**&t;if needed.&n;**&n;**&t;Fill in the part of message buffer that contains the &n;**&t;negotiation and the nego_status field of the CCB.&n;**&t;Returns the size of the message in bytes.&n;**&n;**&n;**==========================================================&n;*/
macro_line|#ifdef SCSI_NCR_INTEGRITY_CHECKING
DECL|function|ncr_ic_nego
r_static
r_int
id|ncr_ic_nego
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
id|u_char
op_star
id|msgptr
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
r_int
id|msglen
op_assign
l_int|0
suffix:semicolon
r_int
id|nego
op_assign
l_int|0
suffix:semicolon
id|u_char
id|no_increase
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;inq_done
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;ic_maximums_set
)paren
(brace
id|tp-&gt;ic_maximums_set
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* check target and host adapter capabilities */
r_if
c_cond
(paren
(paren
id|tp-&gt;inq_byte7
op_amp
id|INQ7_WIDE16
)paren
op_logical_and
id|np-&gt;maxwide
op_logical_and
id|tp-&gt;usrwide
)paren
id|tp-&gt;ic_max_width
op_assign
l_int|1
suffix:semicolon
r_else
id|tp-&gt;ic_max_width
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;inq_byte7
op_amp
id|INQ7_SYNC
)paren
op_logical_and
id|tp-&gt;maxoffs
)paren
(brace
id|tp-&gt;ic_min_sync
op_assign
(paren
id|tp-&gt;minsync
OL
id|np-&gt;minsync
)paren
ques
c_cond
id|np-&gt;minsync
suffix:colon
id|tp-&gt;minsync
suffix:semicolon
)brace
r_else
id|tp-&gt;ic_min_sync
op_assign
l_int|255
suffix:semicolon
id|tp-&gt;period
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;widedone
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_IC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: cmd-&gt;ic_nego %d, 1st byte 0x%2X&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|cmd-&gt;ic_nego
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* First command from integrity check routine will request&n;&t;&t; * a PPR message.  Disable.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|cmd-&gt;ic_nego
op_amp
id|NS_PPR
)paren
op_eq
id|NS_PPR
)paren
id|cmd-&gt;ic_nego
op_and_assign
op_complement
id|NS_PPR
suffix:semicolon
multiline_comment|/* Previous command recorded a parity or an initiator&n;&t;&t; * detected error condition. Force bus to narrow for this&n;&t;&t; * target. Clear flag. Negotation on request sense.&n;&t;&t; * Note: kernel forces 2 bus resets :o( but clears itself out.&n;&t;&t; * Minor bug? in scsi_obsolete.c (ugly)&n;&t;&t; */
r_if
c_cond
(paren
id|np-&gt;check_integ_par
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Parity Error. Target set to narrow.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|tp-&gt;ic_max_width
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;widedone
op_assign
id|tp-&gt;period
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* In case of a bus reset, ncr_negotiate will reset &n;                 * the flags tp-&gt;widedone and tp-&gt;period to 0, forcing&n;&t;&t; * a new negotiation. &n;&t;&t; */
id|no_increase
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;widedone
op_eq
l_int|0
)paren
(brace
id|cmd-&gt;ic_nego
op_assign
id|NS_WIDE
suffix:semicolon
id|tp-&gt;widedone
op_assign
l_int|1
suffix:semicolon
id|no_increase
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tp-&gt;period
op_eq
l_int|0
)paren
(brace
id|cmd-&gt;ic_nego
op_assign
id|NS_SYNC
suffix:semicolon
id|tp-&gt;period
op_assign
l_int|1
suffix:semicolon
id|no_increase
op_assign
l_int|1
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd-&gt;ic_nego
)paren
(brace
r_case
id|NS_WIDE
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;negotiate wide transfers ?&n;&t;&t;&t;**&t;Do NOT negotiate if device only supports&n;&t;&t;&t;**&t;narrow.&t;&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;ic_max_width
op_or
id|np-&gt;check_integ_par
)paren
(brace
id|nego
op_assign
id|NS_WIDE
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|2
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_WIDE_REQ
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|cmd-&gt;ic_nego_width
op_amp
id|tp-&gt;ic_max_width
suffix:semicolon
)brace
r_else
id|cmd-&gt;ic_nego_width
op_and_assign
id|tp-&gt;ic_max_width
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_SYNC
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;negotiate synchronous transfers?&n;&t;&t;&t;**&t;Target must support sync transfers.&n;&t;&t;&t;**&n;&t;&t;&t;**&t;If period becomes longer than max, reset to async&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;inq_byte7
op_amp
id|INQ7_SYNC
)paren
(brace
id|nego
op_assign
id|NS_SYNC
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|3
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_SYNC_REQ
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;ic_nego_sync
)paren
(brace
r_case
l_int|2
suffix:colon
multiline_comment|/* increase the period */
r_if
c_cond
(paren
op_logical_neg
id|no_increase
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;ic_min_sync
op_le
l_int|0x0A
)paren
id|tp-&gt;ic_min_sync
op_assign
l_int|0x0C
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;ic_min_sync
op_le
l_int|0x0C
)paren
id|tp-&gt;ic_min_sync
op_assign
l_int|0x19
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;ic_min_sync
op_le
l_int|0x19
)paren
id|tp-&gt;ic_min_sync
op_mul_assign
l_int|2
suffix:semicolon
r_else
(brace
id|tp-&gt;ic_min_sync
op_assign
l_int|255
suffix:semicolon
id|cmd-&gt;ic_nego_sync
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;maxoffs
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;maxoffs
ques
c_cond
id|tp-&gt;ic_min_sync
suffix:colon
l_int|0
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;maxoffs
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* nego. to maximum */
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;maxoffs
ques
c_cond
id|tp-&gt;ic_min_sync
suffix:colon
l_int|0
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;maxoffs
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* nego to async */
r_default
suffix:colon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
r_else
id|cmd-&gt;ic_nego_sync
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_NOCHANGE
suffix:colon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|nego
suffix:semicolon
id|np-&gt;check_integ_par
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nego
)paren
(brace
id|tp-&gt;nego_cp
op_assign
id|cp
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|ncr_print_msg
c_func
(paren
id|cp
comma
id|nego
op_eq
id|NS_WIDE
ques
c_cond
l_string|&quot;wide/narrow msgout&quot;
suffix:colon
l_string|&quot;sync/async msgout&quot;
comma
id|msgptr
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
r_return
id|msglen
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_INTEGRITY_CHECKING */
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Prepare the next negotiation message if needed.&n;**&n;**&t;Fill in the part of message buffer that contains the &n;**&t;negotiation and the nego_status field of the CCB.&n;**&t;Returns the size of the message in bytes.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_prepare_nego
r_static
r_int
id|ncr_prepare_nego
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
op_star
id|msgptr
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
r_int
id|msglen
op_assign
l_int|0
suffix:semicolon
r_int
id|nego
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;inq_done
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;negotiate wide transfers ?&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;widedone
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;inq_byte7
op_amp
id|INQ7_WIDE16
)paren
(brace
id|nego
op_assign
id|NS_WIDE
suffix:semicolon
macro_line|#ifdef SCSI_NCR_INTEGRITY_CHECKING
r_if
c_cond
(paren
id|tp-&gt;ic_done
)paren
id|tp-&gt;usrwide
op_and_assign
id|tp-&gt;ic_max_width
suffix:semicolon
macro_line|#endif
)brace
r_else
id|tp-&gt;widedone
op_assign
l_int|1
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;negotiate synchronous transfers?&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|nego
op_logical_and
op_logical_neg
id|tp-&gt;period
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;inq_byte7
op_amp
id|INQ7_SYNC
)paren
(brace
id|nego
op_assign
id|NS_SYNC
suffix:semicolon
macro_line|#ifdef SCSI_NCR_INTEGRITY_CHECKING
r_if
c_cond
(paren
(paren
id|tp-&gt;ic_done
)paren
op_logical_and
(paren
id|tp-&gt;minsync
OL
id|tp-&gt;ic_min_sync
)paren
)paren
id|tp-&gt;minsync
op_assign
id|tp-&gt;ic_min_sync
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|tp-&gt;period
op_assign
l_int|0xffff
suffix:semicolon
id|PRINT_TARGET
c_func
(paren
id|np
comma
id|cp-&gt;target
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;target did not report SYNC.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
r_switch
c_cond
(paren
id|nego
)paren
(brace
r_case
id|NS_SYNC
suffix:colon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|3
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_SYNC_REQ
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;maxoffs
ques
c_cond
id|tp-&gt;minsync
suffix:colon
l_int|0
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;maxoffs
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_WIDE
suffix:colon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|2
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_WIDE_REQ
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;usrwide
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|nego
suffix:semicolon
r_if
c_cond
(paren
id|nego
)paren
(brace
id|tp-&gt;nego_cp
op_assign
id|cp
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|ncr_print_msg
c_func
(paren
id|cp
comma
id|nego
op_eq
id|NS_WIDE
ques
c_cond
l_string|&quot;wide msgout&quot;
suffix:colon
l_string|&quot;sync_msgout&quot;
comma
id|msgptr
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
r_return
id|msglen
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Start execution of a SCSI command.&n;**&t;This is called from the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_queue_command
r_static
r_int
id|ncr_queue_command
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/*&t;Scsi_Device        *device    = cmd-&gt;device; */
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cmd-&gt;target
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|tp-&gt;lp
(braket
id|cmd-&gt;lun
)braket
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
r_int
id|segments
suffix:semicolon
id|u_char
id|idmsg
comma
op_star
id|msgptr
suffix:semicolon
id|u_int
id|msglen
suffix:semicolon
r_int
id|direction
suffix:semicolon
id|u_int32
id|lastp
comma
id|goalp
suffix:semicolon
multiline_comment|/*---------------------------------------------&n;&t;**&n;&t;**      Some shortcuts ...&n;&t;**&n;&t;**---------------------------------------------&n;&t;*/
r_if
c_cond
(paren
(paren
id|cmd-&gt;target
op_eq
id|np-&gt;myaddr
)paren
op_logical_or
(paren
id|cmd-&gt;target
op_ge
id|MAX_TARGET
)paren
op_logical_or
(paren
id|cmd-&gt;lun
op_ge
id|MAX_LUN
)paren
)paren
(brace
r_return
id|DID_BAD_TARGET
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------&n;&t;**&n;&t;**&t;Complete the 1st TEST UNIT READY command&n;&t;**&t;with error condition if the device is &n;&t;**&t;flagged NOSCAN, in order to speed up &n;&t;**&t;the boot.&n;&t;**&n;&t;**---------------------------------------------&n;&t;*/
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_and
(paren
id|tp-&gt;usrflag
op_amp
id|UF_NOSCAN
)paren
)paren
(brace
id|tp-&gt;usrflag
op_and_assign
op_complement
id|UF_NOSCAN
suffix:semicolon
r_return
id|DID_BAD_TARGET
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;CMD=%x &quot;
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;Assign a ccb / bind cmd.&n;&t;**&t;If resetting, shorten settle_time if necessary&n;&t;**&t;in order to avoid spurious timeouts.&n;&t;**&t;If resetting or no free ccb,&n;&t;**&t;insert cmd into the waiting list.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;settle_time
op_logical_and
id|cmd-&gt;timeout_per_command
op_ge
id|HZ
)paren
(brace
id|u_long
id|tlimit
op_assign
id|ktime_get
c_func
(paren
id|cmd-&gt;timeout_per_command
op_minus
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ktime_dif
c_func
(paren
id|np-&gt;settle_time
comma
id|tlimit
)paren
OG
l_int|0
)paren
id|np-&gt;settle_time
op_assign
id|tlimit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|np-&gt;settle_time
op_logical_or
op_logical_neg
(paren
id|cp
op_assign
id|ncr_get_ccb
(paren
id|np
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
)paren
)paren
(brace
id|insert_into_waiting_list
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_return
id|DID_OK
suffix:semicolon
)brace
id|cp-&gt;cmd
op_assign
id|cmd
suffix:semicolon
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;Enable tagged queue if asked by scsi ioctl&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
macro_line|#if 0&t;/* This stuff was only usefull for linux-1.2.13 */
r_if
c_cond
(paren
id|lp
op_logical_and
op_logical_neg
id|lp-&gt;numtags
op_logical_and
id|cmd-&gt;device
op_logical_and
id|cmd-&gt;device-&gt;tagged_queue
)paren
(brace
id|lp-&gt;numtags
op_assign
id|tp-&gt;usrtags
suffix:semicolon
id|ncr_setup_tags
(paren
id|np
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;timestamp&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
id|bzero
(paren
op_amp
id|cp-&gt;phys.header.stamp
comma
r_sizeof
(paren
r_struct
id|tstamp
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.header.stamp.start
op_assign
id|jiffies
suffix:semicolon
macro_line|#endif
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Build the identify / tag / sdtr message&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
id|idmsg
op_assign
id|M_IDENTIFY
op_or
id|cmd-&gt;lun
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_member_access_from_pointer
id|tag
op_ne
id|NO_TAG
op_logical_or
(paren
id|cp
op_ne
id|np-&gt;ccb
op_logical_and
id|np-&gt;disc
op_logical_and
op_logical_neg
(paren
id|tp-&gt;usrflag
op_amp
id|UF_NODISC
)paren
)paren
)paren
id|idmsg
op_or_assign
l_int|0x40
suffix:semicolon
id|msgptr
op_assign
id|cp-&gt;scsi_smsg
suffix:semicolon
id|msglen
op_assign
l_int|0
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|idmsg
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;tag
op_ne
id|NO_TAG
)paren
(brace
r_char
id|order
op_assign
id|np-&gt;order
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Force ordered tag if necessary to avoid timeouts &n;&t;&t;**&t;and to preserve interactivity.&n;&t;&t;*/
r_if
c_cond
(paren
id|lp
op_logical_and
id|ktime_exp
c_func
(paren
id|lp-&gt;tags_stime
)paren
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;tags_smap
)paren
(brace
id|order
op_assign
id|M_ORDERED_TAG
suffix:semicolon
r_if
c_cond
(paren
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TAGS
)paren
op_logical_or
id|bootverbose
OG
l_int|2
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ordered tag forced.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|lp-&gt;tags_stime
op_assign
id|ktime_get
c_func
(paren
l_int|3
op_star
id|HZ
)paren
suffix:semicolon
id|lp-&gt;tags_smap
op_assign
id|lp-&gt;tags_umap
suffix:semicolon
)brace
r_if
c_cond
(paren
id|order
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;**&t;Ordered write ops, unordered read ops.&n;&t;&t;&t;*/
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x08
suffix:colon
multiline_comment|/* READ_SMALL (6) */
r_case
l_int|0x28
suffix:colon
multiline_comment|/* READ_BIG  (10) */
r_case
l_int|0xa8
suffix:colon
multiline_comment|/* READ_HUGE (12) */
id|order
op_assign
id|M_SIMPLE_TAG
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|order
op_assign
id|M_ORDERED_TAG
suffix:semicolon
)brace
)brace
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|order
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Actual tags are numbered 1,3,5,..2*MAXTAGS+1,&n;&t;&t;**&t;since we may have to deal with devices that have &n;&t;&t;**&t;problems with #TAG 0 or too great #TAG numbers.&n;&t;&t;*/
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
(paren
id|cp-&gt;tag
op_lshift
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Build the data descriptors&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
id|direction
op_assign
id|scsi_data_direction
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_ne
id|SCSI_DATA_NONE
)paren
(brace
id|segments
op_assign
id|ncr_scatter
(paren
id|np
comma
id|cp
comma
id|cp-&gt;cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|segments
OL
l_int|0
)paren
(brace
id|ncr_free_ccb
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_return
id|DID_ERROR
suffix:semicolon
)brace
)brace
r_else
(brace
id|cp-&gt;data_len
op_assign
l_int|0
suffix:semicolon
id|segments
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;negotiation required?&n;&t;**&n;&t;**&t;(nego_status is filled by ncr_prepare_nego())&n;&t;**&n;&t;**---------------------------------------------------&n;&t;*/
id|cp-&gt;nego_status
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SCSI_NCR_INTEGRITY_CHECKING
r_if
c_cond
(paren
(paren
id|np-&gt;check_integrity
op_logical_and
id|tp-&gt;ic_done
)paren
op_logical_or
op_logical_neg
id|np-&gt;check_integrity
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|tp-&gt;widedone
op_logical_or
op_logical_neg
id|tp-&gt;period
)paren
op_logical_and
op_logical_neg
id|tp-&gt;nego_cp
op_logical_and
id|lp
)paren
(brace
id|msglen
op_add_assign
id|ncr_prepare_nego
(paren
id|np
comma
id|cp
comma
id|msgptr
op_plus
id|msglen
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|np-&gt;check_integrity
op_logical_and
(paren
id|cmd-&gt;ic_in_progress
)paren
)paren
(brace
id|msglen
op_add_assign
id|ncr_ic_nego
(paren
id|np
comma
id|cp
comma
id|cmd
comma
id|msgptr
op_plus
id|msglen
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|np-&gt;check_integrity
op_logical_and
id|cmd-&gt;ic_complete
)paren
(brace
multiline_comment|/*&n;                 * Midlayer signal to the driver that all of the scsi commands&n;                 * for the integrity check have completed. Save the negotiated&n;                 * parameters (extracted from sval and wval). &n;                 */
(brace
id|u_char
id|idiv
suffix:semicolon
id|idiv
op_assign
(paren
id|tp-&gt;wval
op_rshift
l_int|4
)paren
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;sval
op_amp
l_int|0x1f
)paren
op_logical_and
id|idiv
)paren
id|tp-&gt;period
op_assign
(paren
(paren
(paren
id|tp-&gt;sval
op_rshift
l_int|5
)paren
op_plus
l_int|4
)paren
op_star
id|div_10M
(braket
id|idiv
op_minus
l_int|1
)braket
)paren
op_div
id|np-&gt;clock_khz
suffix:semicolon
r_else
id|tp-&gt;period
op_assign
l_int|0xffff
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * tp-&gt;period contains 10 times the transfer period, &n;&t;&t; * which itself is 4 * the requested negotiation rate.&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;period
op_le
l_int|250
)paren
id|tp-&gt;ic_min_sync
op_assign
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;period
op_le
l_int|303
)paren
id|tp-&gt;ic_min_sync
op_assign
l_int|11
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;period
op_le
l_int|500
)paren
id|tp-&gt;ic_min_sync
op_assign
l_int|12
suffix:semicolon
r_else
id|tp-&gt;ic_min_sync
op_assign
(paren
id|tp-&gt;period
op_plus
l_int|40
op_minus
l_int|1
)paren
op_div
l_int|40
suffix:semicolon
multiline_comment|/*&n;                 * Negotiation for this target it complete.&n;                 */
id|tp-&gt;ic_max_width
op_assign
(paren
id|tp-&gt;wval
op_amp
id|EWS
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|tp-&gt;ic_done
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;widedone
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Integrity Check Complete: &bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s %s SCSI&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|tp-&gt;sval
op_amp
l_int|0x1f
)paren
ques
c_cond
l_string|&quot;SYNC&quot;
suffix:colon
l_string|&quot;ASYNC&quot;
comma
id|tp-&gt;ic_max_width
ques
c_cond
l_string|&quot;WIDE&quot;
suffix:colon
l_string|&quot;NARROW&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;sval
op_amp
l_int|0x1f
)paren
(brace
id|u_long
id|mbs
op_assign
l_int|10000
op_star
(paren
id|tp-&gt;ic_max_width
op_plus
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %d.%d  MB/s&quot;
comma
(paren
r_int
)paren
(paren
id|mbs
op_div
id|tp-&gt;period
)paren
comma
(paren
r_int
)paren
(paren
id|mbs
op_mod
id|tp-&gt;period
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; (%d ns, %d offset)&bslash;n&quot;
comma
id|tp-&gt;period
op_div
l_int|10
comma
id|tp-&gt;sval
op_amp
l_int|0x1f
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot; %d MB/s. &bslash;n &quot;
comma
(paren
id|tp-&gt;ic_max_width
op_plus
l_int|1
)paren
op_star
l_int|5
)paren
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
(paren
op_logical_neg
id|tp-&gt;widedone
op_logical_or
op_logical_neg
id|tp-&gt;period
)paren
op_logical_and
op_logical_neg
id|tp-&gt;nego_cp
op_logical_and
id|lp
)paren
(brace
id|msglen
op_add_assign
id|ncr_prepare_nego
(paren
id|np
comma
id|cp
comma
id|msgptr
op_plus
id|msglen
)paren
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_INTEGRITY_CHECKING */
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Determine xfer direction.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;data_len
)paren
id|direction
op_assign
id|SCSI_DATA_NONE
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If data direction is UNKNOWN, speculate DATA_READ &n;&t;**&t;but prepare alternate pointers for WRITE in case &n;&t;**&t;of our speculation will be just wrong.&n;&t;**&t;SCRIPTS will swap values if needed.&n;&t;*/
r_switch
c_cond
(paren
id|direction
)paren
(brace
r_case
id|SCSI_DATA_UNKNOWN
suffix:colon
r_case
id|SCSI_DATA_WRITE
suffix:colon
id|goalp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|data_out2
)paren
op_plus
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|segments
op_le
id|MAX_SCATTERL
)paren
id|lastp
op_assign
id|goalp
op_minus
l_int|8
op_minus
(paren
id|segments
op_star
l_int|16
)paren
suffix:semicolon
r_else
(brace
id|lastp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|hdata_out2
)paren
suffix:semicolon
id|lastp
op_sub_assign
(paren
id|segments
op_minus
id|MAX_SCATTERL
)paren
op_star
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|direction
op_ne
id|SCSI_DATA_UNKNOWN
)paren
r_break
suffix:semicolon
id|cp-&gt;phys.header.wgoalp
op_assign
id|cpu_to_scr
c_func
(paren
id|goalp
)paren
suffix:semicolon
id|cp-&gt;phys.header.wlastp
op_assign
id|cpu_to_scr
c_func
(paren
id|lastp
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SCSI_DATA_READ
suffix:colon
id|goalp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|data_in2
)paren
op_plus
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|segments
op_le
id|MAX_SCATTERL
)paren
id|lastp
op_assign
id|goalp
op_minus
l_int|8
op_minus
(paren
id|segments
op_star
l_int|16
)paren
suffix:semicolon
r_else
(brace
id|lastp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|hdata_in2
)paren
suffix:semicolon
id|lastp
op_sub_assign
(paren
id|segments
op_minus
id|MAX_SCATTERL
)paren
op_star
l_int|16
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_case
id|SCSI_DATA_NONE
suffix:colon
id|lastp
op_assign
id|goalp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|no_data
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Set all pointers values needed by SCRIPTS.&n;&t;**&t;If direction is unknown, start at data_io.&n;&t;*/
id|cp-&gt;phys.header.lastp
op_assign
id|cpu_to_scr
c_func
(paren
id|lastp
)paren
suffix:semicolon
id|cp-&gt;phys.header.goalp
op_assign
id|cpu_to_scr
c_func
(paren
id|goalp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|SCSI_DATA_UNKNOWN
)paren
id|cp-&gt;phys.header.savep
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|data_io
)paren
)paren
suffix:semicolon
r_else
id|cp-&gt;phys.header.savep
op_assign
id|cpu_to_scr
c_func
(paren
id|lastp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Save the initial data pointer in order to be able &n;&t;**&t;to redo the command.&n;&t;*/
id|cp-&gt;startp
op_assign
id|cp-&gt;phys.header.savep
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;fill in ccb&n;&t;**&n;&t;**----------------------------------------------------&n;&t;**&n;&t;**&n;&t;**&t;physical -&gt; virtual backlink&n;&t;**&t;Generic SCSI command&n;&t;*/
multiline_comment|/*&n;&t;**&t;Startqueue&n;&t;*/
id|cp-&gt;start.schedule.l_paddr
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|select
)paren
)paren
suffix:semicolon
id|cp-&gt;restart.schedule.l_paddr
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|resel_dsa
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;select&n;&t;*/
id|cp-&gt;phys.select.sel_id
op_assign
id|cmd-&gt;target
suffix:semicolon
id|cp-&gt;phys.select.sel_scntl3
op_assign
id|tp-&gt;wval
suffix:semicolon
id|cp-&gt;phys.select.sel_sxfer
op_assign
id|tp-&gt;sval
suffix:semicolon
multiline_comment|/*&n;&t;**&t;message&n;&t;*/
id|cp-&gt;phys.smsg.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|scsi_smsg
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.smsg.size
op_assign
id|cpu_to_scr
c_func
(paren
id|msglen
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;command&n;&t;*/
id|memcpy
c_func
(paren
id|cp-&gt;cdb_buf
comma
id|cmd-&gt;cmnd
comma
id|MIN
c_func
(paren
id|cmd-&gt;cmd_len
comma
r_sizeof
(paren
id|cp-&gt;cdb_buf
)paren
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.cmd.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|cdb_buf
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.cmd.size
op_assign
id|cpu_to_scr
c_func
(paren
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;status&n;&t;*/
id|cp-&gt;actualquirks
op_assign
id|tp-&gt;quirks
suffix:semicolon
id|cp-&gt;host_status
op_assign
id|cp-&gt;nego_status
ques
c_cond
id|HS_NEGOTIATE
suffix:colon
id|HS_BUSY
suffix:semicolon
id|cp-&gt;scsi_status
op_assign
id|S_ILLEGAL
suffix:semicolon
id|cp-&gt;parity_status
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;xerr_status
op_assign
id|XE_OK
suffix:semicolon
macro_line|#if 0
id|cp-&gt;sync_status
op_assign
id|tp-&gt;sval
suffix:semicolon
id|cp-&gt;wide_status
op_assign
id|tp-&gt;wval
suffix:semicolon
macro_line|#endif
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Critical region: start this job.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
multiline_comment|/*&n;&t;**&t;activate this job.&n;&t;*/
id|cp-&gt;magic
op_assign
id|CCB_MAGIC
suffix:semicolon
multiline_comment|/*&n;&t;**&t;insert next CCBs into start queue.&n;&t;**&t;2 max at a time is enough to flush the CCB wait queue.&n;&t;*/
id|cp-&gt;auto_sense
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lp
)paren
id|ncr_start_next_ccb
c_func
(paren
id|np
comma
id|lp
comma
l_int|2
)paren
suffix:semicolon
r_else
id|ncr_put_start_queue
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Command is successfully queued.&n;&t;*/
r_return
id|DID_OK
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Insert a CCB into the start queue and wake up the &n;**&t;SCRIPTS processor.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_start_next_ccb
r_static
r_void
id|ncr_start_next_ccb
c_func
(paren
id|ncb_p
id|np
comma
id|lcb_p
id|lp
comma
r_int
id|maxn
)paren
(brace
id|XPT_QUEHEAD
op_star
id|qp
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;held_ccb
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|maxn
op_decrement
op_logical_and
id|lp-&gt;queuedccbs
OL
id|lp-&gt;queuedepth
)paren
(brace
id|qp
op_assign
id|xpt_remque_head
c_func
(paren
op_amp
id|lp-&gt;wait_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qp
)paren
r_break
suffix:semicolon
op_increment
id|lp-&gt;queuedccbs
suffix:semicolon
id|cp
op_assign
id|xpt_que_entry
c_func
(paren
id|qp
comma
r_struct
id|ccb
comma
id|link_ccbq
)paren
suffix:semicolon
id|xpt_insque_tail
c_func
(paren
id|qp
comma
op_amp
id|lp-&gt;busy_ccbq
)paren
suffix:semicolon
id|lp-&gt;jump_ccb
(braket
id|cp-&gt;tag
op_eq
id|NO_TAG
ques
c_cond
l_int|0
suffix:colon
id|cp-&gt;tag
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|restart
)paren
)paren
suffix:semicolon
id|ncr_put_start_queue
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
)brace
)brace
DECL|function|ncr_put_start_queue
r_static
r_void
id|ncr_put_start_queue
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
id|u_short
id|qidx
suffix:semicolon
multiline_comment|/*&n;&t;**&t;insert into start queue.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;squeueput
)paren
id|np-&gt;squeueput
op_assign
l_int|1
suffix:semicolon
id|qidx
op_assign
id|np-&gt;squeueput
op_plus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|qidx
op_ge
id|MAX_START
op_plus
id|MAX_START
)paren
id|qidx
op_assign
l_int|1
suffix:semicolon
id|np-&gt;scripth-&gt;tryloop
(braket
id|qidx
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
)paren
suffix:semicolon
id|MEMORY_BARRIER
c_func
(paren
)paren
suffix:semicolon
id|np-&gt;scripth-&gt;tryloop
(braket
id|np-&gt;squeueput
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|start
)paren
)paren
suffix:semicolon
id|np-&gt;squeueput
op_assign
id|qidx
suffix:semicolon
op_increment
id|np-&gt;queuedccbs
suffix:semicolon
id|cp-&gt;queued
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_QUEUE
)paren
id|printk
(paren
l_string|&quot;%s: queuepos=%d.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|np-&gt;squeueput
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Script processor may be waiting for reselect.&n;&t;**&t;Wake it up.&n;&t;*/
id|MEMORY_BARRIER
c_func
(paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Start reset process.&n;**&t;If reset in progress do nothing.&n;**&t;The interrupt handler will reinitialize the chip.&n;**&t;The timeout handler will wait for settle_time before &n;**&t;clearing it and so resuming command processing.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_start_reset
r_static
r_void
id|ncr_start_reset
c_func
(paren
id|ncb_p
id|np
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;settle_time
)paren
(brace
(paren
r_void
)paren
id|ncr_reset_scsi_bus
c_func
(paren
id|np
comma
l_int|1
comma
id|driver_setup.settle_delay
)paren
suffix:semicolon
)brace
)brace
DECL|function|ncr_reset_scsi_bus
r_static
r_int
id|ncr_reset_scsi_bus
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|enab_int
comma
r_int
id|settle_delay
)paren
(brace
id|u_int32
id|term
suffix:semicolon
r_int
id|retv
op_assign
l_int|0
suffix:semicolon
id|np-&gt;settle_time
op_assign
id|ktime_get
c_func
(paren
id|settle_delay
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: resetting, &quot;
l_string|&quot;command processing suspended for %d seconds&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|settle_delay
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|100
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|2000
)paren
suffix:semicolon
multiline_comment|/* The 895 needs time for the bus mode to settle */
r_if
c_cond
(paren
id|enab_int
)paren
id|OUTW
(paren
id|nc_sien
comma
id|RST
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Enable Tolerant, reset IRQD if present and &n;&t;**&t;properly set IRQ mode, prior to resetting the bus.&n;&t;*/
id|OUTB
(paren
id|nc_stest3
comma
id|TE
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_dcntl
comma
(paren
id|np-&gt;rv_dcntl
op_amp
id|IRQM
)paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_scntl1
comma
id|CRST
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|200
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver_setup.bus_check
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Check for no terminators or SCSI bus shorts to ground.&n;&t;**&t;Read SCSI data bus, data parity bits and control signals.&n;&t;**&t;We are expecting RESET to be TRUE and other signals to be &n;&t;**&t;FALSE.&n;&t;*/
id|term
op_assign
id|INB
c_func
(paren
id|nc_sstat0
)paren
suffix:semicolon
id|term
op_assign
(paren
(paren
id|term
op_amp
l_int|2
)paren
op_lshift
l_int|7
)paren
op_plus
(paren
(paren
id|term
op_amp
l_int|1
)paren
op_lshift
l_int|17
)paren
suffix:semicolon
multiline_comment|/* rst sdp0 */
id|term
op_or_assign
(paren
(paren
id|INB
c_func
(paren
id|nc_sstat2
)paren
op_amp
l_int|0x01
)paren
op_lshift
l_int|26
)paren
op_or
multiline_comment|/* sdp1     */
(paren
(paren
id|INW
c_func
(paren
id|nc_sbdl
)paren
op_amp
l_int|0xff
)paren
op_lshift
l_int|9
)paren
op_or
multiline_comment|/* d7-0     */
(paren
(paren
id|INW
c_func
(paren
id|nc_sbdl
)paren
op_amp
l_int|0xff00
)paren
op_lshift
l_int|10
)paren
op_or
multiline_comment|/* d15-8    */
id|INB
c_func
(paren
id|nc_sbcl
)paren
suffix:semicolon
multiline_comment|/* req ack bsy sel atn msg cd io    */
r_if
c_cond
(paren
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_WIDE
)paren
)paren
id|term
op_and_assign
l_int|0x3ffff
suffix:semicolon
r_if
c_cond
(paren
id|term
op_ne
(paren
l_int|2
op_lshift
l_int|7
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: suspicious SCSI data while resetting the BUS.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %sdp0,d7-0,rst,req,ack,bsy,sel,atn,msg,c/d,i/o = &quot;
l_string|&quot;0x%lx, expecting 0x%lx&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|np-&gt;features
op_amp
id|FE_WIDE
)paren
ques
c_cond
l_string|&quot;dp1,d15-8,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|u_long
)paren
id|term
comma
(paren
id|u_long
)paren
(paren
l_int|2
op_lshift
l_int|7
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.bus_check
op_eq
l_int|1
)paren
id|retv
op_assign
l_int|1
suffix:semicolon
)brace
id|out
suffix:colon
id|OUTB
(paren
id|nc_scntl1
comma
l_int|0
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Reset the SCSI BUS.&n;**&t;This is called from the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_reset_bus
r_static
r_int
id|ncr_reset_bus
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|sync_reset
)paren
(brace
multiline_comment|/*&t;Scsi_Device        *device    = cmd-&gt;device; */
id|ccb_p
id|cp
suffix:semicolon
r_int
id|found
suffix:semicolon
multiline_comment|/*&n; * Return immediately if reset is in progress.&n; */
r_if
c_cond
(paren
id|np-&gt;settle_time
)paren
(brace
r_return
id|SCSI_RESET_PUNT
suffix:semicolon
)brace
multiline_comment|/*&n; * Start the reset process.&n; * The script processor is then assumed to be stopped.&n; * Commands will now be queued in the waiting list until a settle &n; * delay of 2 seconds will be completed.&n; */
id|ncr_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n; * First, look in the wakeup list&n; */
r_for
c_loop
(paren
id|found
op_assign
l_int|0
comma
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;look for the ccb of this command.&n;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_IDLE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cmd
op_eq
id|cmd
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Then, look in the waiting list&n; */
r_if
c_cond
(paren
op_logical_neg
id|found
op_logical_and
id|retrieve_from_waiting_list
c_func
(paren
l_int|0
comma
id|np
comma
id|cmd
)paren
)paren
id|found
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Wake-up all awaiting commands with DID_RESET.&n; */
id|reset_waiting_list
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n; * Wake-up all pending commands with HS_RESET -&gt; DID_RESET.&n; */
id|ncr_wakeup
c_func
(paren
id|np
comma
id|HS_RESET
)paren
suffix:semicolon
multiline_comment|/*&n; * If the involved command was not in a driver queue, and the &n; * scsi driver told us reset is synchronous, and the command is not &n; * currently in the waiting list, complete it with DID_RESET status,&n; * in order to keep it alive.&n; */
r_if
c_cond
(paren
op_logical_neg
id|found
op_logical_and
id|sync_reset
op_logical_and
op_logical_neg
id|retrieve_from_waiting_list
c_func
(paren
l_int|0
comma
id|np
comma
id|cmd
)paren
)paren
(brace
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_RESET
comma
l_int|0
)paren
suffix:semicolon
id|ncr_queue_done_cmd
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
)brace
r_return
id|SCSI_RESET_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Abort an SCSI command.&n;**&t;This is called from the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_abort_command
r_static
r_int
id|ncr_abort_command
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/*&t;Scsi_Device        *device    = cmd-&gt;device; */
id|ccb_p
id|cp
suffix:semicolon
r_int
id|found
suffix:semicolon
r_int
id|retv
suffix:semicolon
multiline_comment|/*&n; * First, look for the scsi command in the waiting list&n; */
r_if
c_cond
(paren
id|remove_from_waiting_list
c_func
(paren
id|np
comma
id|cmd
)paren
)paren
(brace
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_ABORT
comma
l_int|0
)paren
suffix:semicolon
id|ncr_queue_done_cmd
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Then, look in the wakeup list&n; */
r_for
c_loop
(paren
id|found
op_assign
l_int|0
comma
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;look for the ccb of this command.&n;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_IDLE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cmd
op_eq
id|cmd
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
r_if
c_cond
(paren
id|np-&gt;settle_time
)paren
(brace
r_return
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;If the CCB is active, patch schedule jumps for the &n;&t;**&t;script to abort the command.&n;&t;*/
r_switch
c_cond
(paren
id|cp-&gt;host_status
)paren
(brace
r_case
id|HS_BUSY
suffix:colon
r_case
id|HS_NEGOTIATE
suffix:colon
id|printk
(paren
l_string|&quot;%s: abort ccb=%p (cancel)&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|cp
)paren
suffix:semicolon
id|cp-&gt;start.schedule.l_paddr
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|cancel
)paren
)paren
suffix:semicolon
id|retv
op_assign
id|SCSI_ABORT_PENDING
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HS_DISCONNECT
suffix:colon
id|cp-&gt;restart.schedule.l_paddr
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
m_abort
)paren
)paren
suffix:semicolon
id|retv
op_assign
id|SCSI_ABORT_PENDING
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|retv
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**      If there are no requests, the script&n;&t;**      processor will sleep on SEL_WAIT_RESEL.&n;&t;**      Let&squot;s wake it up, since it may have to work.&n;&t;*/
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Linux release module stuff.&n;**&n;**&t;Called before unloading the module&n;**&t;Detach the host.&n;**&t;We have to free resources and halt the NCR chip&n;**&n;**==========================================================&n;*/
macro_line|#ifdef MODULE
DECL|function|ncr_detach
r_static
r_int
id|ncr_detach
c_func
(paren
id|ncb_p
id|np
)paren
(brace
id|ccb_p
id|cp
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
r_int
id|target
comma
id|lun
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: releasing host resources&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;**&t;Stop the ncr_timeout process&n;**&t;Set release_stage to 1 and wait that ncr_timeout() set it to 2.&n;*/
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
l_string|&quot;%s: stopping the timer&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
macro_line|#endif
id|np-&gt;release_stage
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|50
suffix:semicolon
id|i
op_logical_and
id|np-&gt;release_stage
op_ne
l_int|2
suffix:semicolon
id|i
op_decrement
)paren
id|MDELAY
(paren
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;release_stage
op_ne
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;%s: the timer seems to be already stopped&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_else
id|np-&gt;release_stage
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;**&t;Disable chip interrupts&n;*/
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
l_string|&quot;%s: disabling chip interrupts&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
macro_line|#endif
id|OUTW
(paren
id|nc_sien
comma
l_int|0
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_dien
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;**&t;Free irq&n;*/
macro_line|#ifdef DEBUG_NCR53C8XX
macro_line|#ifdef __sparc__
id|printk
c_func
(paren
l_string|&quot;%s: freeing irq %s&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|__irq_itoa
c_func
(paren
id|np-&gt;irq
)paren
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;%s: freeing irq %d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;irq
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|free_irq
c_func
(paren
id|np-&gt;irq
comma
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Reset NCR chip&n;&t;**&t;Restore bios setting for automatic clock detection.&n;&t;*/
id|printk
c_func
(paren
l_string|&quot;%s: resetting chip&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|100
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_dmode
comma
id|np-&gt;sv_dmode
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_dcntl
comma
id|np-&gt;sv_dcntl
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_ctest3
comma
id|np-&gt;sv_ctest3
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_ctest4
comma
id|np-&gt;sv_ctest4
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_ctest5
comma
id|np-&gt;sv_ctest5
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_gpcntl
comma
id|np-&gt;sv_gpcntl
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest2
comma
id|np-&gt;sv_stest2
)paren
suffix:semicolon
id|ncr_selectclock
c_func
(paren
id|np
comma
id|np-&gt;sv_scntl3
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Release Memory mapped IO region and IO mapped region&n;&t;*/
macro_line|#ifndef NCR_IOMAPPED
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
l_string|&quot;%s: releasing memory mapped IO region %lx[%d]&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|np-&gt;vaddr
comma
l_int|128
)paren
suffix:semicolon
macro_line|#endif
id|unmap_pci_mem
c_func
(paren
(paren
id|vm_offset_t
)paren
id|np-&gt;vaddr
comma
(paren
id|u_long
)paren
l_int|128
)paren
suffix:semicolon
macro_line|#endif /* !NCR_IOMAPPED */
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
l_string|&quot;%s: releasing IO region %x[%d]&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;base_io
comma
l_int|128
)paren
suffix:semicolon
macro_line|#endif
id|release_region
c_func
(paren
id|np-&gt;base_io
comma
l_int|128
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Free allocated ccb(s)&n;&t;*/
r_while
c_loop
(paren
(paren
id|cp
op_assign
id|np-&gt;ccb-&gt;link_ccb
)paren
op_ne
l_int|NULL
)paren
(brace
id|np-&gt;ccb-&gt;link_ccb
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_status
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: shall free an active ccb (host_status=%d)&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|cp-&gt;host_status
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
l_string|&quot;%s: freeing ccb (%lx)&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|cp
)paren
suffix:semicolon
macro_line|#endif
id|m_free_dma
c_func
(paren
id|cp
comma
r_sizeof
(paren
op_star
id|cp
)paren
comma
l_string|&quot;CCB&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Free allocated tp(s)&n;&t;*/
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
OL
id|MAX_TARGET
suffix:semicolon
id|target
op_increment
)paren
(brace
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
id|MAX_LUN
suffix:semicolon
id|lun
op_increment
)paren
(brace
id|lp
op_assign
id|tp-&gt;lp
(braket
id|lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lp
)paren
(brace
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
l_string|&quot;%s: freeing lp (%lx)&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|lp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|lp-&gt;jump_ccb
op_ne
op_amp
id|lp-&gt;jump_ccb_0
)paren
id|m_free_dma
c_func
(paren
id|lp-&gt;jump_ccb
comma
l_int|256
comma
l_string|&quot;JUMP_CCB&quot;
)paren
suffix:semicolon
id|m_free_dma
c_func
(paren
id|lp
comma
r_sizeof
(paren
op_star
id|lp
)paren
comma
l_string|&quot;LCB&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|np-&gt;scripth0
)paren
id|m_free_dma
c_func
(paren
id|np-&gt;scripth0
comma
r_sizeof
(paren
r_struct
id|scripth
)paren
comma
l_string|&quot;SCRIPTH&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;script0
)paren
id|m_free_dma
c_func
(paren
id|np-&gt;script0
comma
r_sizeof
(paren
r_struct
id|script
)paren
comma
l_string|&quot;SCRIPT&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;ccb
)paren
id|m_free_dma
c_func
(paren
id|np-&gt;ccb
comma
r_sizeof
(paren
r_struct
id|ccb
)paren
comma
l_string|&quot;CCB&quot;
)paren
suffix:semicolon
id|m_free_dma
c_func
(paren
id|np
comma
r_sizeof
(paren
r_struct
id|ncb
)paren
comma
l_string|&quot;NCB&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: host resources successfully released&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Complete execution of a SCSI command.&n;**&t;Signal completion to the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_complete
r_void
id|ncr_complete
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Sanity check&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|cp
op_logical_or
id|cp-&gt;magic
op_ne
id|CCB_MAGIC
op_logical_or
op_logical_neg
id|cp-&gt;cmd
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;timestamp&n;&t;**&t;Optional, spare some CPU time&n;&t;*/
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
id|ncb_profile
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;CCB=%lx STAT=%x/%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cp
comma
id|cp-&gt;host_status
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Get command, target and lun pointers.&n;&t;*/
id|cmd
op_assign
id|cp-&gt;cmd
suffix:semicolon
id|cp-&gt;cmd
op_assign
l_int|NULL
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cmd-&gt;target
)braket
suffix:semicolon
id|lp
op_assign
id|tp-&gt;lp
(braket
id|cmd-&gt;lun
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;We donnot queue more than 1 ccb per target &n;&t;**&t;with negotiation at any time. If this ccb was &n;&t;**&t;used for negotiation, clear this info in the tcb.&n;&t;*/
r_if
c_cond
(paren
id|cp
op_eq
id|tp-&gt;nego_cp
)paren
id|tp-&gt;nego_cp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If auto-sense performed, change scsi status.&n;&t;*/
r_if
c_cond
(paren
id|cp-&gt;auto_sense
)paren
(brace
id|cp-&gt;scsi_status
op_assign
id|cp-&gt;auto_sense
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;If we were recovering from queue full or performing &n;&t;**&t;auto-sense, requeue skipped CCBs to the wait queue.&n;&t;*/
r_if
c_cond
(paren
id|lp
op_logical_and
id|lp-&gt;held_ccb
)paren
(brace
r_if
c_cond
(paren
id|cp
op_eq
id|lp-&gt;held_ccb
)paren
(brace
id|xpt_que_splice
c_func
(paren
op_amp
id|lp-&gt;skip_ccbq
comma
op_amp
id|lp-&gt;wait_ccbq
)paren
suffix:semicolon
id|xpt_que_init
c_func
(paren
op_amp
id|lp-&gt;skip_ccbq
)paren
suffix:semicolon
id|lp-&gt;held_ccb
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;**&t;Check for parity errors.&n;&t;*/
r_if
c_cond
(paren
id|cp-&gt;parity_status
OG
l_int|1
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;%d parity error(s).&bslash;n&quot;
comma
id|cp-&gt;parity_status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Check for extended errors.&n;&t;*/
r_if
c_cond
(paren
id|cp-&gt;xerr_status
op_ne
id|XE_OK
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cp-&gt;xerr_status
)paren
(brace
r_case
id|XE_EXTRA_DATA
suffix:colon
id|printk
(paren
l_string|&quot;extraneous data discarded.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XE_BAD_PHASE
suffix:colon
id|printk
(paren
l_string|&quot;illegal scsi phase (4/5).&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;extended error %d.&bslash;n&quot;
comma
id|cp-&gt;xerr_status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
id|cp-&gt;host_status
op_assign
id|HS_FAIL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Print out any error for debugging purpose.&n;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
(paren
id|DEBUG_RESULT
op_or
id|DEBUG_TINY
)paren
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;host_status
op_ne
id|HS_COMPLETE
op_logical_or
id|cp-&gt;scsi_status
op_ne
id|S_GOOD
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ERROR: cmd=%x host_status=%x scsi_status=%x&bslash;n&quot;
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
id|cp-&gt;host_status
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;**&t;Check the status.&n;&t;*/
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
id|S_GOOD
op_logical_or
id|cp-&gt;scsi_status
op_eq
id|S_COND_MET
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;All went well (GOOD status).&n;&t;&t;**&t;CONDITION MET status is returned on &n;                **&t;`Pre-Fetch&squot; or `Search data&squot; success.&n;                */
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_OK
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;@RESID@&n;&t;&t;**&t;Could dig out the correct value for resid,&n;&t;&t;**&t;but it would be quite complicated.&n;&t;&t;*/
multiline_comment|/* if (cp-&gt;phys.header.lastp != cp-&gt;phys.header.goalp) */
multiline_comment|/*&n;&t;&t;**&t;Allocate the lcb if not yet.&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
id|ncr_alloc_lcb
(paren
id|np
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;On standard INQUIRY response (EVPD and CmDt &n;&t;&t;**&t;not set), setup logical unit according to &n;&t;&t;**&t;announced capabilities (we need the 1rst 7 bytes).&n;&t;&t;*/
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
l_int|0x12
op_logical_and
op_logical_neg
(paren
id|cmd-&gt;cmnd
(braket
l_int|1
)braket
op_amp
l_int|0x3
)paren
op_logical_and
id|cmd-&gt;cmnd
(braket
l_int|4
)braket
op_ge
l_int|7
op_logical_and
op_logical_neg
id|cmd-&gt;use_sg
)paren
(brace
id|sync_scsi_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/* SYNC the data */
id|ncr_setup_lcb
(paren
id|np
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
(paren
r_char
op_star
)paren
id|cmd-&gt;request_buffer
)paren
suffix:semicolon
)brace
id|tp-&gt;bytes
op_add_assign
id|cp-&gt;data_len
suffix:semicolon
id|tp-&gt;transfers
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;If tags was reduced due to queue full,&n;&t;&t;**&t;increase tags if 1000 good status received.&n;&t;&t;*/
r_if
c_cond
(paren
id|lp
op_logical_and
id|lp-&gt;usetags
op_logical_and
id|lp-&gt;numtags
OL
id|lp-&gt;maxtags
)paren
(brace
op_increment
id|lp-&gt;num_good
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;num_good
op_ge
l_int|1000
)paren
(brace
id|lp-&gt;num_good
op_assign
l_int|0
suffix:semicolon
op_increment
id|lp-&gt;numtags
suffix:semicolon
id|ncr_setup_tags
(paren
id|np
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
id|S_CHECK_COND
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**   Check condition code&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_OK
comma
id|S_CHECK_COND
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Copy back sense data to caller&squot;s buffer.&n;&t;&t;*/
id|memcpy
c_func
(paren
id|cmd-&gt;sense_buffer
comma
id|cp-&gt;sense_buf
comma
id|MIN
c_func
(paren
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
comma
r_sizeof
(paren
id|cp-&gt;sense_buf
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
(paren
id|DEBUG_RESULT
op_or
id|DEBUG_TINY
)paren
)paren
(brace
id|u_char
op_star
id|p
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|cmd-&gt;sense_buffer
suffix:semicolon
r_int
id|i
suffix:semicolon
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;sense data:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|14
suffix:semicolon
id|i
op_increment
)paren
id|printk
(paren
l_string|&quot; %x&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
id|S_CONFLICT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**   Reservation Conflict condition code&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_OK
comma
id|S_CONFLICT
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
id|S_BUSY
op_logical_or
id|cp-&gt;scsi_status
op_eq
id|S_QUEUE_FULL
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**   Target is busy.&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_OK
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_SEL_TIMEOUT
)paren
op_logical_or
(paren
id|cp-&gt;host_status
op_eq
id|HS_TIMEOUT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**   No response&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_TIME_OUT
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_RESET
)paren
(brace
multiline_comment|/*&n;&t;&t;**   SCSI bus reset&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_RESET
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_ABORTED
)paren
(brace
multiline_comment|/*&n;&t;&t;**   Transfer aborted&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_ABORT
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;**  Other protocol messes&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;COMMAND FAILED (%x %x) @%p.&bslash;n&quot;
comma
id|cp-&gt;host_status
comma
id|cp-&gt;scsi_status
comma
id|cp
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_ERROR
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;trace output&n;&t;*/
r_if
c_cond
(paren
id|tp-&gt;usrflag
op_amp
id|UF_TRACE
)paren
(brace
id|u_char
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot; CMD:&quot;
)paren
suffix:semicolon
id|p
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cmd-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
id|printk
(paren
l_string|&quot; %x&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
(brace
r_switch
c_cond
(paren
id|cp-&gt;scsi_status
)paren
(brace
r_case
id|S_GOOD
suffix:colon
id|printk
(paren
l_string|&quot;  GOOD&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_CHECK_COND
suffix:colon
id|printk
(paren
l_string|&quot;  SENSE:&quot;
)paren
suffix:semicolon
id|p
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|cmd-&gt;sense_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|14
suffix:semicolon
id|i
op_increment
)paren
id|printk
(paren
l_string|&quot; %x&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;  STAT: %x&bslash;n&quot;
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
id|printk
(paren
l_string|&quot;  HOSTERROR: %x&quot;
comma
id|cp-&gt;host_status
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Free this ccb&n;&t;*/
id|ncr_free_ccb
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;requeue awaiting scsi commands for this lun.&n;&t;*/
r_if
c_cond
(paren
id|lp
op_logical_and
id|lp-&gt;queuedccbs
OL
id|lp-&gt;queuedepth
op_logical_and
op_logical_neg
id|xpt_que_empty
c_func
(paren
op_amp
id|lp-&gt;wait_ccbq
)paren
)paren
id|ncr_start_next_ccb
c_func
(paren
id|np
comma
id|lp
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;requeue awaiting scsi commands for this controller.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;waiting_list
)paren
id|requeue_waiting_list
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;signal completion to generic driver.&n;&t;*/
id|ncr_queue_done_cmd
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Signal all (or one) control block done.&n;**&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**&t;This CCB has been skipped by the NCR.&n;**&t;Queue it in the correponding unit queue.&n;*/
DECL|function|ncr_ccb_skipped
r_static
r_void
id|ncr_ccb_skipped
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|tp-&gt;lp
(braket
id|cp-&gt;lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lp
op_logical_and
id|cp
op_ne
id|np-&gt;ccb
)paren
(brace
id|cp-&gt;host_status
op_and_assign
op_complement
id|HS_SKIPMASK
suffix:semicolon
id|cp-&gt;start.schedule.l_paddr
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|select
)paren
)paren
suffix:semicolon
id|xpt_remque
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
)paren
suffix:semicolon
id|xpt_insque_tail
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|lp-&gt;skip_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;queued
)paren
(brace
op_decrement
id|lp-&gt;queuedccbs
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cp-&gt;queued
)paren
(brace
op_decrement
id|np-&gt;queuedccbs
suffix:semicolon
id|cp-&gt;queued
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;**&t;The NCR has completed CCBs.&n;**&t;Look at the DONE QUEUE if enabled, otherwise scan all CCBs&n;*/
DECL|function|ncr_wakeup_done
r_void
id|ncr_wakeup_done
(paren
id|ncb_p
id|np
)paren
(brace
id|ccb_p
id|cp
suffix:semicolon
macro_line|#ifdef SCSI_NCR_CCB_DONE_SUPPORT
r_int
id|i
comma
id|j
suffix:semicolon
id|i
op_assign
id|np-&gt;ccb_done_ic
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|j
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|j
op_ge
id|MAX_DONE
)paren
id|j
op_assign
l_int|0
suffix:semicolon
id|cp
op_assign
id|np-&gt;ccb_done
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CCB_DONE_VALID
c_func
(paren
id|cp
)paren
)paren
r_break
suffix:semicolon
id|np-&gt;ccb_done
(braket
id|j
)braket
op_assign
(paren
id|ccb_p
)paren
id|CCB_DONE_EMPTY
suffix:semicolon
id|np-&gt;scripth-&gt;done_queue
(braket
l_int|5
op_star
id|j
op_plus
l_int|4
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|done_plug
)paren
)paren
suffix:semicolon
id|MEMORY_BARRIER
c_func
(paren
)paren
suffix:semicolon
id|np-&gt;scripth-&gt;done_queue
(braket
l_int|5
op_star
id|i
op_plus
l_int|4
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|done_end
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_status
op_amp
id|HS_DONEMASK
)paren
id|ncr_complete
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_amp
id|HS_SKIPMASK
)paren
id|ncr_ccb_skipped
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
id|i
op_assign
id|j
suffix:semicolon
)brace
id|np-&gt;ccb_done_ic
op_assign
id|i
suffix:semicolon
macro_line|#else
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
r_while
c_loop
(paren
id|cp
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;host_status
op_amp
id|HS_DONEMASK
)paren
id|ncr_complete
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_amp
id|HS_SKIPMASK
)paren
id|ncr_ccb_skipped
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n;**&t;Complete all active CCBs.&n;*/
DECL|function|ncr_wakeup
r_void
id|ncr_wakeup
(paren
id|ncb_p
id|np
comma
id|u_long
id|code
)paren
(brace
id|ccb_p
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
r_while
c_loop
(paren
id|cp
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;host_status
op_ne
id|HS_IDLE
)paren
(brace
id|cp-&gt;host_status
op_assign
id|code
suffix:semicolon
id|ncr_complete
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
)brace
id|cp
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
)brace
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Start NCR chip.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_init
r_void
id|ncr_init
(paren
id|ncb_p
id|np
comma
r_int
id|reset
comma
r_char
op_star
id|msg
comma
id|u_long
id|code
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Reset chip if asked, otherwise just clear fifos.&n; &t;*/
r_if
c_cond
(paren
id|reset
)paren
(brace
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_else
(brace
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
id|OUTONB
(paren
id|nc_ctest3
comma
id|CLF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Message.&n;&t;*/
r_if
c_cond
(paren
id|msg
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: restart (%s).&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|msg
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Clear Start Queue&n;&t;*/
id|np-&gt;queuedepth
op_assign
id|MAX_START
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* 1 entry needed as end marker */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|MAX_START
op_plus
id|MAX_START
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
id|np-&gt;scripth0-&gt;tryloop
(braket
id|i
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Start at first entry.&n;&t;*/
id|np-&gt;squeueput
op_assign
l_int|0
suffix:semicolon
id|np-&gt;script0-&gt;startpos
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|tryloop
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Clear Done Queue&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DONE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|np-&gt;ccb_done
(braket
id|i
)braket
op_assign
(paren
id|ccb_p
)paren
id|CCB_DONE_EMPTY
suffix:semicolon
id|np-&gt;scripth0-&gt;done_queue
(braket
l_int|5
op_star
id|i
op_plus
l_int|4
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|done_end
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Start at first entry.&n;&t;*/
id|np-&gt;script0-&gt;done_pos
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|done_queue
)paren
)paren
suffix:semicolon
id|np-&gt;ccb_done_ic
op_assign
id|MAX_DONE
op_minus
l_int|1
suffix:semicolon
id|np-&gt;scripth0-&gt;done_queue
(braket
l_int|5
op_star
(paren
id|MAX_DONE
op_minus
l_int|1
)paren
op_plus
l_int|4
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|done_plug
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Wakeup all pending jobs.&n;&t;*/
id|ncr_wakeup
(paren
id|np
comma
id|code
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Init chip.&n;&t;*/
id|OUTB
(paren
id|nc_istat
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/*  Remove Reset, abort */
id|UDELAY
(paren
l_int|2000
)paren
suffix:semicolon
multiline_comment|/* The 895 needs time for the bus mode to settle */
id|OUTB
(paren
id|nc_scntl0
comma
id|np-&gt;rv_scntl0
op_or
l_int|0xc0
)paren
suffix:semicolon
multiline_comment|/*  full arb., ena parity, par-&gt;ATN  */
id|OUTB
(paren
id|nc_scntl1
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/*  odd parity, and remove CRST!! */
id|ncr_selectclock
c_func
(paren
id|np
comma
id|np-&gt;rv_scntl3
)paren
suffix:semicolon
multiline_comment|/* Select SCSI clock */
id|OUTB
(paren
id|nc_scid
comma
id|RRE
op_or
id|np-&gt;myaddr
)paren
suffix:semicolon
multiline_comment|/* Adapter SCSI address */
id|OUTW
(paren
id|nc_respid
comma
l_int|1ul
op_lshift
id|np-&gt;myaddr
)paren
suffix:semicolon
multiline_comment|/* Id to respond to */
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
)paren
suffix:semicolon
multiline_comment|/*  Signal Process */
id|OUTB
(paren
id|nc_dmode
comma
id|np-&gt;rv_dmode
)paren
suffix:semicolon
multiline_comment|/* Burst length, dma mode */
id|OUTB
(paren
id|nc_ctest5
comma
id|np-&gt;rv_ctest5
)paren
suffix:semicolon
multiline_comment|/* Large fifo + large burst */
id|OUTB
(paren
id|nc_dcntl
comma
id|NOCOM
op_or
id|np-&gt;rv_dcntl
)paren
suffix:semicolon
multiline_comment|/* Protect SFBR */
id|OUTB
(paren
id|nc_ctest3
comma
id|np-&gt;rv_ctest3
)paren
suffix:semicolon
multiline_comment|/* Write and invalidate */
id|OUTB
(paren
id|nc_ctest4
comma
id|np-&gt;rv_ctest4
)paren
suffix:semicolon
multiline_comment|/* Master parity checking */
id|OUTB
(paren
id|nc_stest2
comma
id|EXT
op_or
id|np-&gt;rv_stest2
)paren
suffix:semicolon
multiline_comment|/* Extended Sreq/Sack filtering */
id|OUTB
(paren
id|nc_stest3
comma
id|TE
)paren
suffix:semicolon
multiline_comment|/* TolerANT enable */
id|OUTB
(paren
id|nc_stime0
comma
l_int|0x0c
)paren
suffix:semicolon
multiline_comment|/* HTH disabled  STO 0.25 sec */
multiline_comment|/*&n;&t;**&t;Disable disconnects.&n;&t;*/
id|np-&gt;disc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**    Enable GPIO0 pin for writing if LED support.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_LED0
)paren
(brace
id|OUTOFFB
(paren
id|nc_gpcntl
comma
l_int|0x01
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**      enable ints&n;&t;*/
id|OUTW
(paren
id|nc_sien
comma
id|STO
op_or
id|HTH
op_or
id|MA
op_or
id|SGE
op_or
id|UDC
op_or
id|RST
op_or
id|PAR
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_dien
comma
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|SSI
op_or
id|SIR
op_or
id|IID
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;For 895/6 enable SBMC interrupt and save current SCSI bus mode.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA2
)paren
(brace
id|OUTONW
(paren
id|nc_sien
comma
id|SBMC
)paren
suffix:semicolon
id|np-&gt;scsi_mode
op_assign
id|INB
(paren
id|nc_stest4
)paren
op_amp
id|SMODE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;DEL 441 - 53C876 Rev 5 - Part Number 609-0392787/2788 - ITEM 2.&n;&t;**&t;Disable overlapped arbitration.&n;&t;**&t;All 896 chips are also affected by this errata.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_NCR_53C875
)paren
id|OUTB
(paren
id|nc_ctest0
comma
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_NCR_53C896
)paren
id|OUTB
(paren
id|nc_ccntl0
comma
id|DPR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Fill in target structure.&n;&t;**&t;Reinitialize usrsync.&n;&t;**&t;Reinitialize usrwide.&n;&t;**&t;Prepare sync negotiation according to actual SCSI bus mode.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|tp-&gt;sval
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;wval
op_assign
id|np-&gt;rv_scntl3
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;usrsync
op_ne
l_int|255
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;usrsync
op_le
id|np-&gt;maxsync
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;usrsync
OL
id|np-&gt;minsync
)paren
(brace
id|tp-&gt;usrsync
op_assign
id|np-&gt;minsync
suffix:semicolon
)brace
)brace
r_else
id|tp-&gt;usrsync
op_assign
l_int|255
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;usrwide
OG
id|np-&gt;maxwide
)paren
id|tp-&gt;usrwide
op_assign
id|np-&gt;maxwide
suffix:semicolon
id|ncr_negotiate
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    Start script processor.&n;&t;*/
id|MEMORY_BARRIER
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;paddr2
)paren
(brace
r_if
c_cond
(paren
id|bootverbose
)paren
id|printk
(paren
l_string|&quot;%s: Downloading SCSI SCRIPTS.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_scratcha
comma
id|vtobus
c_func
(paren
id|np-&gt;script0
)paren
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|start_ram
)paren
)paren
suffix:semicolon
)brace
r_else
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|start
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Prepare the negotiation values for wide and&n;**&t;synchronous transfers.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_negotiate
r_static
r_void
id|ncr_negotiate
(paren
r_struct
id|ncb
op_star
id|np
comma
r_struct
id|tcb
op_star
id|tp
)paren
(brace
multiline_comment|/*&n;&t;**&t;minsync unit is 4ns !&n;&t;*/
id|u_long
id|minsync
op_assign
id|tp-&gt;usrsync
suffix:semicolon
multiline_comment|/*&n;&t;**&t;SCSI bus mode limit&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;scsi_mode
op_logical_and
id|np-&gt;scsi_mode
op_eq
id|SMODE_SE
)paren
(brace
r_if
c_cond
(paren
id|minsync
OL
l_int|12
)paren
id|minsync
op_assign
l_int|12
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;our limit ..&n;&t;*/
r_if
c_cond
(paren
id|minsync
OL
id|np-&gt;minsync
)paren
id|minsync
op_assign
id|np-&gt;minsync
suffix:semicolon
multiline_comment|/*&n;&t;**&t;divider limit&n;&t;*/
r_if
c_cond
(paren
id|minsync
OG
id|np-&gt;maxsync
)paren
id|minsync
op_assign
l_int|255
suffix:semicolon
id|tp-&gt;minsync
op_assign
id|minsync
suffix:semicolon
id|tp-&gt;maxoffs
op_assign
(paren
id|minsync
OL
l_int|255
ques
c_cond
id|np-&gt;maxoffs
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;period=0: has to negotiate sync transfer&n;&t;*/
id|tp-&gt;period
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;widedone=0: has to negotiate wide transfer&n;&t;*/
id|tp-&gt;widedone
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Get clock factor and sync divisor for a given &n;**&t;synchronous factor period.&n;**&t;Returns the clock factor (in sxfer) and scntl3 &n;**&t;synchronous divisor field.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_getsync
r_static
r_void
id|ncr_getsync
c_func
(paren
id|ncb_p
id|np
comma
id|u_char
id|sfac
comma
id|u_char
op_star
id|fakp
comma
id|u_char
op_star
id|scntl3p
)paren
(brace
id|u_long
id|clk
op_assign
id|np-&gt;clock_khz
suffix:semicolon
multiline_comment|/* SCSI clock frequency in kHz&t;*/
r_int
id|div
op_assign
id|np-&gt;clock_divn
suffix:semicolon
multiline_comment|/* Number of divisors supported&t;*/
id|u_long
id|fak
suffix:semicolon
multiline_comment|/* Sync factor in sxfer&t;&t;*/
id|u_long
id|per
suffix:semicolon
multiline_comment|/* Period in tenths of ns&t;*/
id|u_long
id|kpc
suffix:semicolon
multiline_comment|/* (per * clk)&t;&t;&t;*/
multiline_comment|/*&n;&t;**&t;Compute the synchronous period in tenths of nano-seconds&n;&t;*/
r_if
c_cond
(paren
id|sfac
op_le
l_int|10
)paren
id|per
op_assign
l_int|250
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sfac
op_eq
l_int|11
)paren
id|per
op_assign
l_int|303
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sfac
op_eq
l_int|12
)paren
id|per
op_assign
l_int|500
suffix:semicolon
r_else
id|per
op_assign
l_int|40
op_star
id|sfac
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Look for the greatest clock divisor that allows an &n;&t;**&t;input speed faster than the period.&n;&t;*/
id|kpc
op_assign
id|per
op_star
id|clk
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|div
op_ge
l_int|0
)paren
r_if
c_cond
(paren
id|kpc
op_ge
(paren
id|div_10M
(braket
id|div
)braket
op_lshift
l_int|2
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Calculate the lowest clock factor that allows an output &n;&t;**&t;speed not faster than the period.&n;&t;*/
id|fak
op_assign
(paren
id|kpc
op_minus
l_int|1
)paren
op_div
id|div_10M
(braket
id|div
)braket
op_plus
l_int|1
suffix:semicolon
macro_line|#if 0&t;/* This optimization does not seem very usefull */
id|per
op_assign
(paren
id|fak
op_star
id|div_10M
(braket
id|div
)braket
)paren
op_div
id|clk
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Why not to try the immediate lower divisor and to choose &n;&t;**&t;the one that allows the fastest output speed ?&n;&t;**&t;We dont want input speed too much greater than output speed.&n;&t;*/
r_if
c_cond
(paren
id|div
op_ge
l_int|1
op_logical_and
id|fak
OL
l_int|8
)paren
(brace
id|u_long
id|fak2
comma
id|per2
suffix:semicolon
id|fak2
op_assign
(paren
id|kpc
op_minus
l_int|1
)paren
op_div
id|div_10M
(braket
id|div
op_minus
l_int|1
)braket
op_plus
l_int|1
suffix:semicolon
id|per2
op_assign
(paren
id|fak2
op_star
id|div_10M
(braket
id|div
op_minus
l_int|1
)braket
)paren
op_div
id|clk
suffix:semicolon
r_if
c_cond
(paren
id|per2
OL
id|per
op_logical_and
id|fak2
op_le
l_int|8
)paren
(brace
id|fak
op_assign
id|fak2
suffix:semicolon
id|per
op_assign
id|per2
suffix:semicolon
op_decrement
id|div
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|fak
OL
l_int|4
)paren
id|fak
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* Should never happen, too bad ... */
multiline_comment|/*&n;&t;**&t;Compute and return sync parameters for the ncr&n;&t;*/
op_star
id|fakp
op_assign
id|fak
op_minus
l_int|4
suffix:semicolon
op_star
id|scntl3p
op_assign
(paren
(paren
id|div
op_plus
l_int|1
)paren
op_lshift
l_int|4
)paren
op_plus
(paren
id|sfac
OL
l_int|25
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Set actual values, sync status and patch all ccbs of &n;**&t;a target according to new sync/wide agreement.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_set_sync_wide_status
r_static
r_void
id|ncr_set_sync_wide_status
(paren
id|ncb_p
id|np
comma
id|u_char
id|target
)paren
(brace
id|ccb_p
id|cp
suffix:semicolon
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;set actual value and sync_status&n;&t;*/
id|OUTB
(paren
id|nc_sxfer
comma
id|tp-&gt;sval
)paren
suffix:semicolon
id|np-&gt;sync_st
op_assign
id|tp-&gt;sval
suffix:semicolon
id|OUTB
(paren
id|nc_scntl3
comma
id|tp-&gt;wval
)paren
suffix:semicolon
id|np-&gt;wide_st
op_assign
id|tp-&gt;wval
suffix:semicolon
multiline_comment|/*&n;&t;**&t;patch ALL ccbs of this target.&n;&t;*/
r_for
c_loop
(paren
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;cmd
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cmd-&gt;target
op_ne
id|target
)paren
r_continue
suffix:semicolon
macro_line|#if 0
id|cp-&gt;sync_status
op_assign
id|tp-&gt;sval
suffix:semicolon
id|cp-&gt;wide_status
op_assign
id|tp-&gt;wval
suffix:semicolon
macro_line|#endif
id|cp-&gt;phys.select.sel_scntl3
op_assign
id|tp-&gt;wval
suffix:semicolon
id|cp-&gt;phys.select.sel_sxfer
op_assign
id|tp-&gt;sval
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Switch sync mode for current job and it&squot;s target&n;**&n;**==========================================================&n;*/
DECL|function|ncr_setsync
r_static
r_void
id|ncr_setsync
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|scntl3
comma
id|u_char
id|sxfer
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|u_char
id|target
op_assign
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|u_char
id|idiv
suffix:semicolon
m_assert
(paren
id|cp
op_logical_and
id|cp-&gt;cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
suffix:semicolon
id|cmd
op_assign
id|cp-&gt;cmd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
r_return
suffix:semicolon
m_assert
(paren
id|target
op_eq
(paren
id|cmd-&gt;target
op_amp
l_int|0xf
)paren
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scntl3
op_logical_or
op_logical_neg
(paren
id|sxfer
op_amp
l_int|0x1f
)paren
)paren
id|scntl3
op_assign
id|np-&gt;rv_scntl3
suffix:semicolon
id|scntl3
op_assign
(paren
id|scntl3
op_amp
l_int|0xf0
)paren
op_or
(paren
id|tp-&gt;wval
op_amp
id|EWS
)paren
op_or
(paren
id|np-&gt;rv_scntl3
op_amp
l_int|0x07
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Deduce the value of controller sync period from scntl3.&n;&t;**&t;period is in tenths of nano-seconds.&n;&t;*/
id|idiv
op_assign
(paren
(paren
id|scntl3
op_rshift
l_int|4
)paren
op_amp
l_int|0x7
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sxfer
op_amp
l_int|0x1f
)paren
op_logical_and
id|idiv
)paren
id|tp-&gt;period
op_assign
(paren
(paren
(paren
id|sxfer
op_rshift
l_int|5
)paren
op_plus
l_int|4
)paren
op_star
id|div_10M
(braket
id|idiv
op_minus
l_int|1
)braket
)paren
op_div
id|np-&gt;clock_khz
suffix:semicolon
r_else
id|tp-&gt;period
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/*&n;&t;**&t; Stop there if sync parameters are unchanged&n;&t;*/
r_if
c_cond
(paren
id|tp-&gt;sval
op_eq
id|sxfer
op_logical_and
id|tp-&gt;wval
op_eq
id|scntl3
)paren
r_return
suffix:semicolon
id|tp-&gt;sval
op_assign
id|sxfer
suffix:semicolon
id|tp-&gt;wval
op_assign
id|scntl3
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Bells and whistles   ;-)&n;&t;*/
id|PRINT_TARGET
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sxfer
op_amp
l_int|0x01f
)paren
(brace
r_int
id|f10
op_assign
l_int|100000
op_lshift
(paren
id|tp-&gt;widedone
ques
c_cond
id|tp-&gt;widedone
op_minus
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_int
id|mb10
op_assign
(paren
id|f10
op_plus
id|tp-&gt;period
op_div
l_int|2
)paren
op_div
id|tp-&gt;period
suffix:semicolon
r_char
op_star
id|scsi
suffix:semicolon
multiline_comment|/*&n;&t;&t;**  Disable extended Sreq/Sack filtering&n;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;period
op_le
l_int|2000
)paren
id|OUTOFFB
(paren
id|nc_stest2
comma
id|EXT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Bells and whistles   ;-)&n;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;period
OL
l_int|500
)paren
id|scsi
op_assign
l_string|&quot;FAST-40&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;period
OL
l_int|1000
)paren
id|scsi
op_assign
l_string|&quot;FAST-20&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;period
OL
l_int|2000
)paren
id|scsi
op_assign
l_string|&quot;FAST-10&quot;
suffix:semicolon
r_else
id|scsi
op_assign
l_string|&quot;FAST-5&quot;
suffix:semicolon
id|printk
(paren
l_string|&quot;%s %sSCSI %d.%d MB/s (%d ns, offset %d)&bslash;n&quot;
comma
id|scsi
comma
id|tp-&gt;widedone
OG
l_int|1
ques
c_cond
l_string|&quot;WIDE &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|mb10
op_div
l_int|10
comma
id|mb10
op_mod
l_int|10
comma
id|tp-&gt;period
op_div
l_int|10
comma
id|sxfer
op_amp
l_int|0x1f
)paren
suffix:semicolon
)brace
r_else
id|printk
(paren
l_string|&quot;%sasynchronous.&bslash;n&quot;
comma
id|tp-&gt;widedone
OG
l_int|1
ques
c_cond
l_string|&quot;wide &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;set actual value and sync_status&n;&t;**&t;patch ALL ccbs of this target.&n;&t;*/
id|ncr_set_sync_wide_status
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Switch wide mode for current job and it&squot;s target&n;**&t;SCSI specs say: a SCSI device that accepts a WDTR &n;**&t;message shall reset the synchronous agreement to &n;**&t;asynchronous mode.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_setwide
r_static
r_void
id|ncr_setwide
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|wide
comma
id|u_char
id|ack
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|u_short
id|target
op_assign
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|u_char
id|scntl3
suffix:semicolon
id|u_char
id|sxfer
suffix:semicolon
m_assert
(paren
id|cp
op_logical_and
id|cp-&gt;cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
suffix:semicolon
id|cmd
op_assign
id|cp-&gt;cmd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
r_return
suffix:semicolon
m_assert
(paren
id|target
op_eq
(paren
id|cmd-&gt;target
op_amp
l_int|0xf
)paren
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|tp-&gt;widedone
op_assign
id|wide
op_plus
l_int|1
suffix:semicolon
id|scntl3
op_assign
(paren
id|tp-&gt;wval
op_amp
(paren
op_complement
id|EWS
)paren
)paren
op_or
(paren
id|wide
ques
c_cond
id|EWS
suffix:colon
l_int|0
)paren
suffix:semicolon
id|sxfer
op_assign
id|ack
ques
c_cond
l_int|0
suffix:colon
id|tp-&gt;sval
suffix:semicolon
multiline_comment|/*&n;&t;**&t; Stop there if sync/wide parameters are unchanged&n;&t;*/
r_if
c_cond
(paren
id|tp-&gt;sval
op_eq
id|sxfer
op_logical_and
id|tp-&gt;wval
op_eq
id|scntl3
)paren
r_return
suffix:semicolon
id|tp-&gt;sval
op_assign
id|sxfer
suffix:semicolon
id|tp-&gt;wval
op_assign
id|scntl3
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Bells and whistles   ;-)&n;&t;*/
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
(brace
id|PRINT_TARGET
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scntl3
op_amp
id|EWS
)paren
id|printk
(paren
l_string|&quot;WIDE SCSI (16 bit) enabled.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;WIDE SCSI disabled.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;set actual value and sync_status&n;&t;**&t;patch ALL ccbs of this target.&n;&t;*/
id|ncr_set_sync_wide_status
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Switch tagged mode for a target.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_setup_tags
r_static
r_void
id|ncr_setup_tags
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|tn
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|tp-&gt;lp
(braket
id|ln
)braket
suffix:semicolon
id|u_char
id|reqtags
comma
id|maxdepth
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Just in case ...&n;&t;*/
r_if
c_cond
(paren
(paren
op_logical_neg
id|tp
)paren
op_logical_or
(paren
op_logical_neg
id|lp
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If SCSI device queue depth is not yet set, leave here.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;scdev_depth
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Donnot allow more tags than the SCSI driver can queue &n;&t;**&t;for this device.&n;&t;**&t;Donnot allow more tags than we can handle.&n;&t;*/
id|maxdepth
op_assign
id|lp-&gt;scdev_depth
suffix:semicolon
r_if
c_cond
(paren
id|maxdepth
OG
id|lp-&gt;maxnxs
)paren
id|maxdepth
op_assign
id|lp-&gt;maxnxs
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;maxtags
OG
id|maxdepth
)paren
id|lp-&gt;maxtags
op_assign
id|maxdepth
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;numtags
OG
id|maxdepth
)paren
id|lp-&gt;numtags
op_assign
id|maxdepth
suffix:semicolon
multiline_comment|/*&n;&t;**&t;only devices conformant to ANSI Version &gt;= 2&n;&t;**&t;only devices capable of tagged commands&n;&t;**&t;only if enabled by user ..&n;&t;*/
r_if
c_cond
(paren
(paren
id|lp-&gt;inq_byte7
op_amp
id|INQ7_QUEUE
)paren
op_logical_and
id|lp-&gt;numtags
OG
l_int|1
)paren
(brace
id|reqtags
op_assign
id|lp-&gt;numtags
suffix:semicolon
)brace
r_else
(brace
id|reqtags
op_assign
l_int|1
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Update max number of tags&n;&t;*/
id|lp-&gt;numtags
op_assign
id|reqtags
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;numtags
OG
id|lp-&gt;maxtags
)paren
id|lp-&gt;maxtags
op_assign
id|lp-&gt;numtags
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If we want to switch tag mode, we must wait &n;&t;**&t;for no CCB to be active.&n;&t;*/
r_if
c_cond
(paren
id|reqtags
OG
l_int|1
op_logical_and
id|lp-&gt;usetags
)paren
(brace
multiline_comment|/* Stay in tagged mode    */
r_if
c_cond
(paren
id|lp-&gt;queuedepth
op_eq
id|reqtags
)paren
multiline_comment|/* Already announced&t;   */
r_return
suffix:semicolon
id|lp-&gt;queuedepth
op_assign
id|reqtags
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reqtags
op_le
l_int|1
op_logical_and
op_logical_neg
id|lp-&gt;usetags
)paren
(brace
multiline_comment|/* Stay in untagged mode  */
id|lp-&gt;queuedepth
op_assign
id|reqtags
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Want to switch tag mode */
r_if
c_cond
(paren
id|lp-&gt;busyccbs
)paren
multiline_comment|/* If not yet safe, return */
r_return
suffix:semicolon
id|lp-&gt;queuedepth
op_assign
id|reqtags
suffix:semicolon
id|lp-&gt;usetags
op_assign
id|reqtags
OG
l_int|1
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Patch the lun mini-script, according to tag mode.&n;&t;*/
id|lp-&gt;jump_tag.l_paddr
op_assign
id|lp-&gt;usetags
ques
c_cond
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
c_func
(paren
id|np
comma
id|resel_tag
)paren
)paren
suffix:colon
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
c_func
(paren
id|np
comma
id|resel_notag
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Announce change to user.&n;&t;*/
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;usetags
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tagged command queue depth set to %d&bslash;n&quot;
comma
id|reqtags
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;tagged command queueing disabled&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*----------------------------------------------------&n;**&n;**&t;handle user commands&n;**&n;**----------------------------------------------------&n;*/
macro_line|#ifdef SCSI_NCR_USER_COMMAND_SUPPORT
DECL|function|ncr_usercmd
r_static
r_void
id|ncr_usercmd
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|t
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
r_switch
c_cond
(paren
id|np-&gt;user.cmd
)paren
(brace
r_case
l_int|0
suffix:colon
r_return
suffix:semicolon
r_case
id|UC_SETSYNC
suffix:colon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|np-&gt;user.target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|t
)braket
suffix:semicolon
id|tp-&gt;usrsync
op_assign
id|np-&gt;user.data
suffix:semicolon
id|ncr_negotiate
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETTAGS
suffix:colon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
r_int
id|ln
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|np-&gt;user.target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|np-&gt;target
(braket
id|t
)braket
dot
id|usrtags
op_assign
id|np-&gt;user.data
suffix:semicolon
r_for
c_loop
(paren
id|ln
op_assign
l_int|0
suffix:semicolon
id|ln
OL
id|MAX_LUN
suffix:semicolon
id|ln
op_increment
)paren
(brace
id|lcb_p
id|lp
op_assign
id|np-&gt;target
(braket
id|t
)braket
dot
id|lp
(braket
id|ln
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_continue
suffix:semicolon
id|lp-&gt;maxtags
op_assign
id|lp-&gt;numtags
op_assign
id|np-&gt;user.data
suffix:semicolon
id|ncr_setup_tags
(paren
id|np
comma
id|t
comma
id|ln
)paren
suffix:semicolon
)brace
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETDEBUG
suffix:colon
macro_line|#ifdef SCSI_NCR_DEBUG_INFO_SUPPORT
id|ncr_debug
op_assign
id|np-&gt;user.data
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|UC_SETORDER
suffix:colon
id|np-&gt;order
op_assign
id|np-&gt;user.data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETVERBOSE
suffix:colon
id|np-&gt;verbose
op_assign
id|np-&gt;user.data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETWIDE
suffix:colon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
id|u_long
id|size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|np-&gt;user.target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|t
)braket
suffix:semicolon
id|size
op_assign
id|np-&gt;user.data
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|np-&gt;maxwide
)paren
id|size
op_assign
id|np-&gt;maxwide
suffix:semicolon
id|tp-&gt;usrwide
op_assign
id|size
suffix:semicolon
id|ncr_negotiate
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETFLAG
suffix:colon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|np-&gt;user.target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|t
)braket
suffix:semicolon
id|tp-&gt;usrflag
op_assign
id|np-&gt;user.data
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
r_case
id|UC_CLEARPROF
suffix:colon
id|bzero
c_func
(paren
op_amp
id|np-&gt;profile
comma
r_sizeof
(paren
id|np-&gt;profile
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
)brace
id|np-&gt;user.cmd
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;ncr timeout handler.&n;**&n;**&n;**==========================================================&n;**&n;**&t;Misused to keep the driver running when&n;**&t;interrupts are not configured correctly.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_timeout
r_static
r_void
id|ncr_timeout
(paren
id|ncb_p
id|np
)paren
(brace
id|u_long
id|thistime
op_assign
id|ktime_get
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If release process in progress, let&squot;s go&n;&t;**&t;Set the release stage from 1 to 2 to synchronize&n;&t;**&t;with the release process.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;release_stage
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;release_stage
op_eq
l_int|1
)paren
id|np-&gt;release_stage
op_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
id|np-&gt;ktime
op_assign
id|thistime
suffix:semicolon
id|np-&gt;timer.expires
op_assign
id|ktime_get
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#else
id|np-&gt;timer.expires
op_assign
id|ktime_get
c_func
(paren
id|SCSI_NCR_TIMER_INTERVAL
)paren
suffix:semicolon
macro_line|#endif
id|add_timer
c_func
(paren
op_amp
id|np-&gt;timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If we are resetting the ncr, wait for settle_time before &n;&t;**&t;clearing it. Then command processing will be resumed.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;settle_time
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;settle_time
op_le
id|thistime
)paren
(brace
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: command processing resumed&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;settle_time
op_assign
l_int|0
suffix:semicolon
id|np-&gt;disc
op_assign
l_int|1
suffix:semicolon
id|requeue_waiting_list
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Since the generic scsi driver only allows us 0.5 second &n;&t;**&t;to perform abort of a command, we must look at ccbs about &n;&t;**&t;every 0.25 second.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;lasttime
op_plus
l_int|4
op_star
id|HZ
OL
id|thistime
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;block ncr interrupts&n;&t;&t;*/
id|np-&gt;lasttime
op_assign
id|thistime
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
multiline_comment|/*&n;&t;&t;**&t;Reset profile data to avoid ugly overflow&n;&t;&t;**&t;(Limited to 1024 GB for 32 bit architecture)&n;&t;&t;*/
r_if
c_cond
(paren
id|np-&gt;profile.num_kbytes
OG
(paren
op_complement
l_int|0UL
op_rshift
l_int|2
)paren
)paren
id|bzero
c_func
(paren
op_amp
id|np-&gt;profile
comma
r_sizeof
(paren
id|np-&gt;profile
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef SCSI_NCR_BROKEN_INTR
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_istat
)paren
op_amp
(paren
id|INTF
op_or
id|SIP
op_or
id|DIP
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;Process pending interrupts.&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;{&quot;
)paren
suffix:semicolon
id|ncr_exception
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_BROKEN_INTR */
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;log message for real hard errors&n;**&n;**&t;&quot;ncr0 targ 0?: ERROR (ds:si) (so-si-sd) (sxfer/scntl3) @ name (dsp:dbc).&quot;&n;**&t;&quot;&t;      reg: r0 r1 r2 r3 r4 r5 r6 ..... rf.&quot;&n;**&n;**&t;exception register:&n;**&t;&t;ds:&t;dstat&n;**&t;&t;si:&t;sist&n;**&n;**&t;SCSI bus lines:&n;**&t;&t;so:&t;control lines as driver by NCR.&n;**&t;&t;si:&t;control lines as seen by NCR.&n;**&t;&t;sd:&t;scsi data lines as seen by NCR.&n;**&n;**&t;wide/fastmode:&n;**&t;&t;sxfer:&t;(see the manual)&n;**&t;&t;scntl3:&t;(see the manual)&n;**&n;**&t;current script command:&n;**&t;&t;dsp:&t;script address (relative to start of script).&n;**&t;&t;dbc:&t;first word of script command.&n;**&n;**&t;First 16 register of the chip:&n;**&t;&t;r0..rf&n;**&n;**==========================================================&n;*/
DECL|function|ncr_log_hard_error
r_static
r_void
id|ncr_log_hard_error
c_func
(paren
id|ncb_p
id|np
comma
id|u_short
id|sist
comma
id|u_char
id|dstat
)paren
(brace
id|u_int32
id|dsp
suffix:semicolon
r_int
id|script_ofs
suffix:semicolon
r_int
id|script_size
suffix:semicolon
r_char
op_star
id|script_name
suffix:semicolon
id|u_char
op_star
id|script_base
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dsp
OG
id|np-&gt;p_script
op_logical_and
id|dsp
op_le
id|np-&gt;p_script
op_plus
r_sizeof
(paren
r_struct
id|script
)paren
)paren
(brace
id|script_ofs
op_assign
id|dsp
op_minus
id|np-&gt;p_script
suffix:semicolon
id|script_size
op_assign
r_sizeof
(paren
r_struct
id|script
)paren
suffix:semicolon
id|script_base
op_assign
(paren
id|u_char
op_star
)paren
id|np-&gt;script0
suffix:semicolon
id|script_name
op_assign
l_string|&quot;script&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|np-&gt;p_scripth
OL
id|dsp
op_logical_and
id|dsp
op_le
id|np-&gt;p_scripth
op_plus
r_sizeof
(paren
r_struct
id|scripth
)paren
)paren
(brace
id|script_ofs
op_assign
id|dsp
op_minus
id|np-&gt;p_scripth
suffix:semicolon
id|script_size
op_assign
r_sizeof
(paren
r_struct
id|scripth
)paren
suffix:semicolon
id|script_base
op_assign
(paren
id|u_char
op_star
)paren
id|np-&gt;scripth0
suffix:semicolon
id|script_name
op_assign
l_string|&quot;scripth&quot;
suffix:semicolon
)brace
r_else
(brace
id|script_ofs
op_assign
id|dsp
suffix:semicolon
id|script_size
op_assign
l_int|0
suffix:semicolon
id|script_base
op_assign
l_int|0
suffix:semicolon
id|script_name
op_assign
l_string|&quot;mem&quot;
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0x0f
comma
id|dstat
comma
id|sist
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_socl
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sbcl
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sbdl
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sxfer
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_scntl3
)paren
comma
id|script_name
comma
id|script_ofs
comma
(paren
r_int
)paren
id|INL
(paren
id|nc_dbc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|script_ofs
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
r_int
)paren
id|script_ofs
OL
id|script_size
)paren
(brace
id|printk
(paren
l_string|&quot;%s: script cmd = %08x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|scr_to_cpu
c_func
(paren
(paren
r_int
)paren
op_star
(paren
id|ncrcmd
op_star
)paren
(paren
id|script_base
op_plus
id|script_ofs
)paren
)paren
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;%s: regdump:&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|printk
(paren
l_string|&quot; %02x&quot;
comma
(paren
r_int
)paren
id|INB_OFF
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*============================================================&n;**&n;**&t;ncr chip exception handler.&n;**&n;**============================================================&n;**&n;**&t;In normal cases, interrupt conditions occur one at a &n;**&t;time. The ncr is able to stack in some extra registers &n;**&t;other interrupts that will occurs after the first one.&n;**&t;But severall interrupts may occur at the same time.&n;**&n;**&t;We probably should only try to deal with the normal &n;**&t;case, but it seems that multiple interrupts occur in &n;**&t;some cases that are not abnormal at all.&n;**&n;**&t;The most frequent interrupt condition is Phase Mismatch.&n;**&t;We should want to service this interrupt quickly.&n;**&t;A SCSI parity error may be delivered at the same time.&n;**&t;The SIR interrupt is not very frequent in this driver, &n;**&t;since the INTFLY is likely used for command completion &n;**&t;signaling.&n;**&t;The Selection Timeout interrupt may be triggered with &n;**&t;IID and/or UDC.&n;**&t;The SBMC interrupt (SCSI Bus Mode Change) may probably &n;**&t;occur at any time.&n;**&n;**&t;This handler try to deal as cleverly as possible with all&n;**&t;the above.&n;**&n;**============================================================&n;*/
DECL|function|ncr_exception
r_void
id|ncr_exception
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|istat
comma
id|dstat
suffix:semicolon
id|u_short
id|sist
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;**&t;interrupt on the fly ?&n;&t;**&t;Since the global header may be copied back to a CCB &n;&t;**&t;using a posted PCI memory write, the last operation on &n;&t;**&t;the istat register is a READ in order to flush posted &n;&t;**&t;PCI write commands.&n;&t;*/
id|istat
op_assign
id|INB
(paren
id|nc_istat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|istat
op_amp
id|INTF
)paren
(brace
id|OUTB
(paren
id|nc_istat
comma
(paren
id|istat
op_amp
id|SIGP
)paren
op_or
id|INTF
)paren
suffix:semicolon
id|istat
op_assign
id|INB
(paren
id|nc_istat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;F &quot;
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
id|np-&gt;profile.num_fly
op_increment
suffix:semicolon
macro_line|#endif
id|ncr_wakeup_done
(paren
id|np
)paren
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|istat
op_amp
(paren
id|SIP
op_or
id|DIP
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
id|np-&gt;profile.num_int
op_increment
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|istat
op_amp
id|CABRT
)paren
id|OUTB
(paren
id|nc_istat
comma
id|CABRT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Steinbach&squot;s Guideline for Systems Programming:&n;&t;**&t;Never test for an error condition you don&squot;t know how to handle.&n;&t;*/
id|sist
op_assign
(paren
id|istat
op_amp
id|SIP
)paren
ques
c_cond
id|INW
(paren
id|nc_sist
)paren
suffix:colon
l_int|0
suffix:semicolon
id|dstat
op_assign
(paren
id|istat
op_amp
id|DIP
)paren
ques
c_cond
id|INB
(paren
id|nc_dstat
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;&lt;%d|%x:%x|%x:%x&gt;&quot;
comma
(paren
r_int
)paren
id|INB
c_func
(paren
id|nc_scr0
)paren
comma
id|dstat
comma
id|sist
comma
(paren
r_int
)paren
id|INL
c_func
(paren
id|nc_dsp
)paren
comma
(paren
r_int
)paren
id|INL
c_func
(paren
id|nc_dbc
)paren
)paren
suffix:semicolon
multiline_comment|/*========================================================&n;&t;**&t;First, interrupts we want to service cleanly.&n;&t;**&n;&t;**&t;Phase mismatch is the most frequent interrupt, and &n;&t;**&t;so we have to service it as quickly and as cleanly &n;&t;**&t;as possible.&n;&t;**&t;Programmed interrupts are rarely used in this driver,&n;&t;**&t;but we must handle them cleanly anyway.&n;&t;**&t;We try to deal with PAR and SBMC combined with &n;&t;**&t;some other interrupt(s).&n;&t;**=========================================================&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|sist
op_amp
(paren
id|STO
op_or
id|GEN
op_or
id|HTH
op_or
id|SGE
op_or
id|UDC
op_or
id|RST
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|IID
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|sist
op_amp
id|SBMC
)paren
op_logical_and
id|ncr_int_sbmc
(paren
id|np
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sist
op_amp
id|PAR
)paren
op_logical_and
id|ncr_int_par
(paren
id|np
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|sist
op_amp
id|MA
)paren
(brace
id|ncr_int_ma
(paren
id|np
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dstat
op_amp
id|SIR
)paren
(brace
id|ncr_int_sir
(paren
id|np
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**  DEL 397 - 53C875 Rev 3 - Part Number 609-0392410 - ITEM 2.&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|sist
op_amp
(paren
id|SBMC
op_or
id|PAR
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
id|SSI
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unknown interrupt(s) ignored, &quot;
l_string|&quot;ISTAT=%x DSTAT=%x SIST=%x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|istat
comma
id|dstat
comma
id|sist
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|OUTONB
(paren
id|nc_dcntl
comma
(paren
id|STD
op_or
id|NOCOM
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*========================================================&n;&t;**&t;Now, interrupts that need some fixing up.&n;&t;**&t;Order and multiple interrupts is so less important.&n;&t;**&n;&t;**&t;If SRST has been asserted, we just reset the chip.&n;&t;**&n;&t;**&t;Selection is intirely handled by the chip. If the &n;&t;**&t;chip says STO, we trust it. Seems some other &n;&t;**&t;interrupts may occur at the same time (UDC, IID), so &n;&t;**&t;we ignore them. In any case we do enough fix-up &n;&t;**&t;in the service routine.&n;&t;**&t;We just exclude some fatal dma errors.&n;&t;**=========================================================&n;&t;*/
r_if
c_cond
(paren
id|sist
op_amp
id|RST
)paren
(brace
id|ncr_init
(paren
id|np
comma
l_int|1
comma
id|bootverbose
ques
c_cond
l_string|&quot;scsi reset&quot;
suffix:colon
l_int|NULL
comma
id|HS_RESET
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sist
op_amp
id|STO
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;**&t;DEL 397 - 53C875 Rev 3 - Part Number 609-0392410 - ITEM 1.&n;&t;*/
id|OUTONB
(paren
id|nc_ctest3
comma
id|CLF
)paren
suffix:semicolon
id|ncr_int_sto
(paren
id|np
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*=========================================================&n;&t;**&t;Now, interrupts we are not able to recover cleanly.&n;&t;**&t;(At least for the moment).&n;&t;**&n;&t;**&t;Do the register dump.&n;&t;**&t;Log message for real hard errors.&n;&t;**&t;Clear all fifos.&n;&t;**&t;For MDPE, BF, ABORT, IID, SGE and HTH we reset the &n;&t;**&t;BUS and the chip.&n;&t;**&t;We are more soft for UDC.&n;&t;**=========================================================&n;&t;*/
r_if
c_cond
(paren
id|ktime_exp
c_func
(paren
id|np-&gt;regtime
)paren
)paren
(brace
id|np-&gt;regtime
op_assign
id|ktime_get
c_func
(paren
l_int|10
op_star
id|HZ
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|np-&gt;regdump
)paren
suffix:semicolon
id|i
op_increment
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|np-&gt;regdump
)paren
(braket
id|i
)braket
op_assign
id|INB_OFF
c_func
(paren
id|i
)paren
suffix:semicolon
id|np-&gt;regdump.nc_dstat
op_assign
id|dstat
suffix:semicolon
id|np-&gt;regdump.nc_sist
op_assign
id|sist
suffix:semicolon
)brace
suffix:semicolon
id|ncr_log_hard_error
c_func
(paren
id|np
comma
id|sist
comma
id|dstat
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: have to clear fifos.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
id|OUTONB
(paren
id|nc_ctest3
comma
id|CLF
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sist
op_amp
(paren
id|SGE
)paren
)paren
op_logical_or
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|IID
)paren
)paren
)paren
(brace
id|ncr_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|sist
op_amp
id|HTH
)paren
(brace
id|printk
(paren
l_string|&quot;%s: handshake timeout&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|ncr_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|sist
op_amp
id|UDC
)paren
(brace
id|printk
(paren
l_string|&quot;%s: unexpected disconnect&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
(paren
id|HS_PRT
comma
id|HS_UNEXPECTED
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|cleanup
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*=========================================================&n;&t;**&t;We just miss the cause of the interrupt. :(&n;&t;**&t;Print a message. The timeout will do the real work.&n;&t;**=========================================================&n;&t;*/
id|printk
(paren
l_string|&quot;%s: unknown interrupt&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip exception handler for selection timeout&n;**&n;**==========================================================&n;**&n;**&t;There seems to be a bug in the 53c810.&n;**&t;Although a STO-Interrupt is pending,&n;**&t;it continues executing script commands.&n;**&t;But it will fail and interrupt (IID) on&n;**&t;the next instruction where it&squot;s looking&n;**&t;for a valid phase.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_sto
r_void
id|ncr_int_sto
(paren
id|ncb_p
id|np
)paren
(brace
id|u_long
id|dsa
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;T&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;look for ccb and set the status.&n;&t;*/
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
r_while
c_loop
(paren
id|cp
op_logical_and
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|phys
)paren
op_ne
id|dsa
)paren
)paren
id|cp
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
r_if
c_cond
(paren
id|cp
)paren
(brace
id|cp
op_member_access_from_pointer
id|host_status
op_assign
id|HS_SEL_TIMEOUT
suffix:semicolon
id|ncr_complete
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;repair start queue and jump to start point.&n;&t;*/
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|sto_restart
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip exception handler for SCSI bus mode change&n;**&n;**==========================================================&n;**&n;**&t;spi2-r12 11.2.3 says a transceiver mode change must &n;**&t;generate a reset event and a device that detects a reset &n;**&t;event shall initiate a hard reset. It says also that a&n;**&t;device that detects a mode change shall set data transfer &n;**&t;mode to eight bit asynchronous, etc...&n;**&t;So, just resetting should be enough.&n;**&t; &n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_sbmc
r_static
r_int
id|ncr_int_sbmc
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|scsi_mode
op_assign
id|INB
(paren
id|nc_stest4
)paren
op_amp
id|SMODE
suffix:semicolon
r_if
c_cond
(paren
id|scsi_mode
op_ne
id|np-&gt;scsi_mode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: SCSI bus mode change from %x to %x.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;scsi_mode
comma
id|scsi_mode
)paren
suffix:semicolon
id|np-&gt;scsi_mode
op_assign
id|scsi_mode
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Suspend command processing for 1 second and &n;&t;&t;**&t;reinitialize all except the chip.&n;&t;&t;*/
id|np-&gt;settle_time
op_assign
id|ktime_get
c_func
(paren
l_int|1
op_star
id|HZ
)paren
suffix:semicolon
id|ncr_init
(paren
id|np
comma
l_int|0
comma
id|bootverbose
ques
c_cond
l_string|&quot;scsi mode change&quot;
suffix:colon
l_int|NULL
comma
id|HS_RESET
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip exception handler for SCSI parity error.&n;**&n;**==========================================================&n;**&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_par
r_static
r_int
id|ncr_int_par
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|hsts
op_assign
id|INB
(paren
id|HS_PRT
)paren
suffix:semicolon
id|u_int32
id|dbc
op_assign
id|INL
(paren
id|nc_dbc
)paren
suffix:semicolon
id|u_char
id|sstat1
op_assign
id|INB
(paren
id|nc_sstat1
)paren
suffix:semicolon
r_int
id|phase
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|msg
op_assign
op_minus
l_int|1
suffix:semicolon
id|u_int32
id|jmp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: SCSI parity error detected: SCR1=%d DBC=%x SSTAT1=%x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|hsts
comma
id|dbc
comma
id|sstat1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Ignore the interrupt if the NCR is not connected &n;&t; *&t;to the SCSI bus, since the right work should have  &n;&t; *&t;been done on unexpected disconnection handling.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|INB
(paren
id|nc_scntl1
)paren
op_amp
id|ISCON
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If the nexus is not clearly identified, reset the bus.&n;&t; *&t;We will try to do better later.&n;&t; */
r_if
c_cond
(paren
id|hsts
op_amp
id|HS_INVALMASK
)paren
r_goto
id|reset_all
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If the SCSI parity error occurs in MSG IN phase, prepare a &n;&t; *&t;MSG PARITY message. Otherwise, prepare a INITIATOR DETECTED &n;&t; *&t;ERROR message and let the device decide to retry the command &n;&t; *&t;or to terminate with check condition. If we were in MSG IN &n;&t; *&t;phase waiting for the response of a negotiation, we will &n;&t; *&t;get SIR_NEGO_FAILED at dispatch.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dbc
op_amp
l_int|0xc0000000
)paren
)paren
id|phase
op_assign
(paren
id|dbc
op_rshift
l_int|24
)paren
op_amp
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|phase
op_eq
l_int|7
)paren
id|msg
op_assign
id|M_PARITY
suffix:semicolon
r_else
id|msg
op_assign
id|M_ID_ERROR
suffix:semicolon
macro_line|#ifdef SCSI_NCR_INTEGRITY_CHECKING
multiline_comment|/*&n;&t;**      Save error message. For integrity check use only.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;check_integrity
)paren
id|np-&gt;check_integ_par
op_assign
id|msg
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;If the NCR stopped on a MOVE ^ DATA_IN, we jump to a &n;&t; *&t;script that will ignore all data in bytes until phase &n;&t; *&t;change, since we are not sure the chip will wait the phase &n;&t; *&t;change prior to delivering the interrupt.&n;&t; */
r_if
c_cond
(paren
id|phase
op_eq
l_int|1
)paren
id|jmp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|par_err_data_in
)paren
suffix:semicolon
r_else
id|jmp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|par_err_other
)paren
suffix:semicolon
id|OUTONB
(paren
id|nc_ctest3
comma
id|CLF
)paren
suffix:semicolon
multiline_comment|/* clear dma fifo  */
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
multiline_comment|/* clear scsi fifo */
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|msg
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|jmp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|reset_all
suffix:colon
id|ncr_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;ncr chip exception handler for phase errors.&n;**&n;**&n;**==========================================================&n;**&n;**&t;We have to construct a new transfer descriptor,&n;**&t;to transfer the rest of the current block.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_ma
r_static
r_void
id|ncr_int_ma
(paren
id|ncb_p
id|np
)paren
(brace
id|u_int32
id|dbc
suffix:semicolon
id|u_int32
id|rest
suffix:semicolon
id|u_int32
id|dsp
suffix:semicolon
id|u_int32
id|dsa
suffix:semicolon
id|u_int32
id|nxtdsp
suffix:semicolon
id|u_int32
id|newtmp
suffix:semicolon
id|u_int32
op_star
id|vdsp
suffix:semicolon
id|u_int32
id|oadr
comma
id|olen
suffix:semicolon
id|u_int32
op_star
id|tblp
suffix:semicolon
id|ncrcmd
op_star
id|newcmd
suffix:semicolon
id|u_char
id|cmd
comma
id|sbcl
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
id|dbc
op_assign
id|INL
(paren
id|nc_dbc
)paren
suffix:semicolon
id|sbcl
op_assign
id|INB
(paren
id|nc_sbcl
)paren
suffix:semicolon
id|cmd
op_assign
id|dbc
op_rshift
l_int|24
suffix:semicolon
id|rest
op_assign
id|dbc
op_amp
l_int|0xffffff
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Take into account dma fifo and various buffers and latches,&n;&t;**&t;only if the interrupted phase is an OUTPUT phase.&n;&t;*/
r_if
c_cond
(paren
(paren
id|cmd
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|u_char
id|ctest5
comma
id|ss0
comma
id|ss2
suffix:semicolon
id|u_short
id|delta
suffix:semicolon
id|ctest5
op_assign
(paren
id|np-&gt;rv_ctest5
op_amp
id|DFS
)paren
ques
c_cond
id|INB
(paren
id|nc_ctest5
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ctest5
op_amp
id|DFS
)paren
id|delta
op_assign
(paren
(paren
(paren
id|ctest5
op_lshift
l_int|8
)paren
op_or
(paren
id|INB
(paren
id|nc_dfifo
)paren
op_amp
l_int|0xff
)paren
)paren
op_minus
id|rest
)paren
op_amp
l_int|0x3ff
suffix:semicolon
r_else
id|delta
op_assign
(paren
id|INB
(paren
id|nc_dfifo
)paren
op_minus
id|rest
)paren
op_amp
l_int|0x7f
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;The data in the dma fifo has not been transfered to&n;&t;&t;**&t;the target -&gt; add the amount to the rest&n;&t;&t;**&t;and clear the data.&n;&t;&t;**&t;Check the sstat2 register in case of wide transfer.&n;&t;&t;*/
id|rest
op_add_assign
id|delta
suffix:semicolon
id|ss0
op_assign
id|INB
(paren
id|nc_sstat0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss0
op_amp
id|OLF
)paren
id|rest
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ss0
op_amp
id|ORF
)paren
id|rest
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_scntl3
)paren
op_amp
id|EWS
)paren
(brace
id|ss2
op_assign
id|INB
(paren
id|nc_sstat2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss2
op_amp
id|OLF1
)paren
id|rest
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ss2
op_amp
id|ORF1
)paren
id|rest
op_increment
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
(paren
id|DEBUG_TINY
op_or
id|DEBUG_PHASE
)paren
)paren
id|printk
(paren
l_string|&quot;P%x%x RL=%d D=%d SS0=%x &quot;
comma
id|cmd
op_amp
l_int|7
comma
id|sbcl
op_amp
l_int|7
comma
(paren
r_int
)paren
id|rest
comma
(paren
r_int
)paren
id|delta
comma
id|ss0
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
(paren
id|DEBUG_TINY
op_or
id|DEBUG_PHASE
)paren
)paren
id|printk
(paren
l_string|&quot;P%x%x RL=%d &quot;
comma
id|cmd
op_amp
l_int|7
comma
id|sbcl
op_amp
l_int|7
comma
id|rest
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Clear fifos.&n;&t;*/
id|OUTONB
(paren
id|nc_ctest3
comma
id|CLF
)paren
suffix:semicolon
multiline_comment|/* clear dma fifo  */
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
multiline_comment|/* clear scsi fifo */
multiline_comment|/*&n;&t;**&t;locate matching cp.&n;&t;**&t;if the interrupted phase is DATA IN or DATA OUT,&n;&t;**&t;trust the global header.&n;&t;*/
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cmd
op_amp
l_int|6
)paren
)paren
(brace
id|cp
op_assign
id|np-&gt;header.cp
suffix:semicolon
r_if
c_cond
(paren
id|CCB_PHYS
c_func
(paren
id|cp
comma
id|phys
)paren
op_ne
id|dsa
)paren
id|cp
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
r_while
c_loop
(paren
id|cp
op_logical_and
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|phys
)paren
op_ne
id|dsa
)paren
)paren
id|cp
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;try to find the interrupted script command,&n;&t;**&t;and the address at which to continue.&n;&t;*/
id|vdsp
op_assign
l_int|0
suffix:semicolon
id|nxtdsp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dsp
OG
id|np-&gt;p_script
op_logical_and
id|dsp
op_le
id|np-&gt;p_script
op_plus
r_sizeof
(paren
r_struct
id|script
)paren
)paren
(brace
id|vdsp
op_assign
(paren
id|u_int32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|np-&gt;script0
op_plus
(paren
id|dsp
op_minus
id|np-&gt;p_script
op_minus
l_int|8
)paren
)paren
suffix:semicolon
id|nxtdsp
op_assign
id|dsp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dsp
OG
id|np-&gt;p_scripth
op_logical_and
id|dsp
op_le
id|np-&gt;p_scripth
op_plus
r_sizeof
(paren
r_struct
id|scripth
)paren
)paren
(brace
id|vdsp
op_assign
(paren
id|u_int32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|np-&gt;scripth0
op_plus
(paren
id|dsp
op_minus
id|np-&gt;p_scripth
op_minus
l_int|8
)paren
)paren
suffix:semicolon
id|nxtdsp
op_assign
id|dsp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cp
)paren
(brace
r_if
c_cond
(paren
id|dsp
op_eq
id|CCB_PHYS
(paren
id|cp
comma
id|patch
(braket
l_int|2
)braket
)paren
)paren
(brace
id|vdsp
op_assign
op_amp
id|cp-&gt;patch
(braket
l_int|0
)braket
suffix:semicolon
id|nxtdsp
op_assign
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dsp
op_eq
id|CCB_PHYS
(paren
id|cp
comma
id|patch
(braket
l_int|6
)braket
)paren
)paren
(brace
id|vdsp
op_assign
op_amp
id|cp-&gt;patch
(braket
l_int|4
)braket
suffix:semicolon
id|nxtdsp
op_assign
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;**&t;log the information&n;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
(brace
id|printk
(paren
l_string|&quot;&bslash;nCP=%p CP2=%p DSP=%x NXT=%x VDSP=%p CMD=%x &quot;
comma
id|cp
comma
id|np-&gt;header.cp
comma
(paren
r_int
)paren
id|dsp
comma
(paren
r_int
)paren
id|nxtdsp
comma
id|vdsp
comma
id|cmd
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;cp=0 means that the DSA does not point to a valid control &n;&t;**&t;block. This should not happen since we donnot use multi-byte &n;&t;**&t;move while we are being reselected ot after command complete.&n;&t;**&t;We are not able to recover from such a phase error.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
(brace
id|printk
(paren
l_string|&quot;%s: SCSI phase error fixup: &quot;
l_string|&quot;CCB already dequeued (0x%08lx)&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|np-&gt;header.cp
)paren
suffix:semicolon
r_goto
id|reset_all
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;get old startaddress and old length.&n;&t;*/
id|oadr
op_assign
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_amp
l_int|0x10
)paren
(brace
multiline_comment|/* Table indirect */
id|tblp
op_assign
(paren
id|u_int32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|cp-&gt;phys
op_plus
id|oadr
)paren
suffix:semicolon
id|olen
op_assign
id|scr_to_cpu
c_func
(paren
id|tblp
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|oadr
op_assign
id|scr_to_cpu
c_func
(paren
id|tblp
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|tblp
op_assign
(paren
id|u_int32
op_star
)paren
l_int|0
suffix:semicolon
id|olen
op_assign
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|0
)braket
)paren
op_amp
l_int|0xffffff
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
(brace
id|printk
(paren
l_string|&quot;OCMD=%x&bslash;nTBLP=%p OLEN=%x OADR=%x&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|0
)braket
)paren
op_rshift
l_int|24
)paren
comma
id|tblp
comma
(paren
r_int
)paren
id|olen
comma
(paren
r_int
)paren
id|oadr
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;check cmd against assumed interrupted script command.&n;&t;*/
r_if
c_cond
(paren
id|cmd
op_ne
(paren
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|0
)braket
)paren
op_rshift
l_int|24
)paren
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;internal error: cmd=%02x != %02x=(vdsp[0] &gt;&gt; 24)&bslash;n&quot;
comma
(paren
r_int
)paren
id|cmd
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|0
)braket
)paren
op_rshift
l_int|24
)paren
suffix:semicolon
r_goto
id|reset_all
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;cp != np-&gt;header.cp means that the header of the CCB &n;&t;**&t;currently being processed has not yet been copied to &n;&t;**&t;the global header area. That may happen if the device did &n;&t;**&t;not accept all our messages after having been selected.&n;&t;*/
r_if
c_cond
(paren
id|cp
op_ne
id|np-&gt;header.cp
)paren
(brace
id|printk
(paren
l_string|&quot;%s: SCSI phase error fixup: &quot;
l_string|&quot;CCB address mismatch (0x%08lx != 0x%08lx)&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|cp
comma
(paren
id|u_long
)paren
id|np-&gt;header.cp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;if old phase not dataphase, leave here.&n;&t;*/
r_if
c_cond
(paren
id|cmd
op_amp
l_int|0x06
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;phase change %x-%x %d@%08x resid=%d.&bslash;n&quot;
comma
id|cmd
op_amp
l_int|7
comma
id|sbcl
op_amp
l_int|7
comma
(paren
r_int
)paren
id|olen
comma
(paren
r_int
)paren
id|oadr
comma
(paren
r_int
)paren
id|rest
)paren
suffix:semicolon
r_goto
id|unexpected_phase
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;choose the correct patch area.&n;&t;**&t;if savep points to one, choose the other.&n;&t;*/
id|newcmd
op_assign
id|cp-&gt;patch
suffix:semicolon
id|newtmp
op_assign
id|CCB_PHYS
(paren
id|cp
comma
id|patch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newtmp
op_eq
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.header.savep
)paren
)paren
(brace
id|newcmd
op_assign
op_amp
id|cp-&gt;patch
(braket
l_int|4
)braket
suffix:semicolon
id|newtmp
op_assign
id|CCB_PHYS
(paren
id|cp
comma
id|patch
(braket
l_int|4
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;fillin the commands&n;&t;*/
id|newcmd
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
(paren
(paren
id|cmd
op_amp
l_int|0x0f
)paren
op_lshift
l_int|24
)paren
op_or
id|rest
)paren
suffix:semicolon
id|newcmd
(braket
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|oadr
op_plus
id|olen
op_minus
id|rest
)paren
suffix:semicolon
id|newcmd
(braket
l_int|2
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_JUMP
)paren
suffix:semicolon
id|newcmd
(braket
l_int|3
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|nxtdsp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;newcmd[%d] %x %x %x %x.&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|newcmd
op_minus
id|cp-&gt;patch
)paren
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|newcmd
(braket
l_int|0
)braket
)paren
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|newcmd
(braket
l_int|1
)braket
)paren
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|newcmd
(braket
l_int|2
)braket
)paren
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|newcmd
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;fake the return address (to the patch).&n;&t;**&t;and restart script processor at dispatcher.&n;&t;*/
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
id|np-&gt;profile.num_break
op_increment
suffix:semicolon
macro_line|#endif
id|OUTL
(paren
id|nc_temp
comma
id|newtmp
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|dispatch
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Unexpected phase changes that occurs when the current phase &n;&t;**&t;is not a DATA IN or DATA OUT phase are due to error conditions.&n;&t;**&t;Such event may only happen when the SCRIPTS is using a &n;&t;**&t;multibyte SCSI MOVE.&n;&t;**&n;&t;**&t;Phase change&t;&t;Some possible cause&n;&t;**&n;&t;**&t;COMMAND  --&gt; MSG IN&t;SCSI parity error detected by target.&n;&t;**&t;COMMAND  --&gt; STATUS&t;Bad command or refused by target.&n;&t;**&t;MSG OUT  --&gt; MSG IN     Message rejected by target.&n;&t;**&t;MSG OUT  --&gt; COMMAND    Bogus target that discards extended&n;&t;**&t;&t;&t;&t;negotiation messages.&n;&t;**&n;&t;**&t;The code below does not care of the new phase and so &n;&t;**&t;trusts the target. Why to annoy it ?&n;&t;**&t;If the interrupted phase is COMMAND phase, we restart at&n;&t;**&t;dispatcher.&n;&t;**&t;If a target does not get all the messages after selection, &n;&t;**&t;the code assumes blindly that the target discards extended &n;&t;**&t;messages and clears the negotiation status.&n;&t;**&t;If the target does not want all our response to negotiation,&n;&t;**&t;we force a SIR_NEGO_PROTO interrupt (it is a hack that avoids &n;&t;**&t;bloat for such a should_not_happen situation).&n;&t;**&t;In all other situation, we reset the BUS.&n;&t;**&t;Are these assumptions reasonnable ? (Wait and see ...)&n;&t;*/
id|unexpected_phase
suffix:colon
id|dsp
op_sub_assign
l_int|8
suffix:semicolon
id|nxtdsp
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
op_amp
l_int|7
)paren
(brace
r_case
l_int|2
suffix:colon
multiline_comment|/* COMMAND phase */
id|nxtdsp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|dispatch
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if 0
r_case
l_int|3
suffix:colon
multiline_comment|/* STATUS  phase */
id|nxtdsp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|dispatch
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
l_int|6
suffix:colon
multiline_comment|/* MSG OUT phase */
id|np-&gt;scripth-&gt;nxtdsp_go_on
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|dsp
op_plus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dsp
op_eq
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|send_ident
)paren
)paren
(brace
id|cp-&gt;host_status
op_assign
id|HS_BUSY
suffix:semicolon
id|nxtdsp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|clratn_go_on
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dsp
op_eq
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|send_wdtr
)paren
op_logical_or
id|dsp
op_eq
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|send_sdtr
)paren
)paren
(brace
id|nxtdsp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|nego_bad_phase
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#if 0
r_case
l_int|7
suffix:colon
multiline_comment|/* MSG IN  phase */
id|nxtdsp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|clrack
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|nxtdsp
)paren
(brace
id|OUTL
(paren
id|nc_dsp
comma
id|nxtdsp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|reset_all
suffix:colon
id|ncr_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
DECL|function|ncr_sir_to_redo
r_static
r_void
id|ncr_sir_to_redo
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|num
comma
id|ccb_p
id|cp
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
op_assign
id|cp-&gt;cmd
suffix:semicolon
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cmd-&gt;target
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|tp-&gt;lp
(braket
id|cmd-&gt;lun
)braket
suffix:semicolon
id|XPT_QUEHEAD
op_star
id|qp
suffix:semicolon
id|ccb_p
id|cp2
suffix:semicolon
r_int
id|disc_cnt
op_assign
l_int|0
suffix:semicolon
r_int
id|busy_cnt
op_assign
l_int|0
suffix:semicolon
id|u_int32
id|startp
suffix:semicolon
id|u_char
id|s_status
op_assign
id|INB
(paren
id|SS_PRT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Let the SCRIPTS processor skip all not yet started CCBs,&n;&t;**&t;and count disconnected CCBs. Since the busy queue is in &n;&t;**&t;the same order as the chip start queue, disconnected CCBs &n;&t;**&t;are before cp and busy ones after.&n;&t;*/
r_if
c_cond
(paren
id|lp
)paren
(brace
id|qp
op_assign
id|lp-&gt;busy_ccbq.blink
suffix:semicolon
r_while
c_loop
(paren
id|qp
op_ne
op_amp
id|lp-&gt;busy_ccbq
)paren
(brace
id|cp2
op_assign
id|xpt_que_entry
c_func
(paren
id|qp
comma
r_struct
id|ccb
comma
id|link_ccbq
)paren
suffix:semicolon
id|qp
op_assign
id|qp-&gt;blink
suffix:semicolon
op_increment
id|busy_cnt
suffix:semicolon
r_if
c_cond
(paren
id|cp2
op_eq
id|cp
)paren
r_break
suffix:semicolon
id|cp2-&gt;start.schedule.l_paddr
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|skip
)paren
)paren
suffix:semicolon
)brace
id|lp-&gt;held_ccb
op_assign
id|cp
suffix:semicolon
multiline_comment|/* Requeue when this one completes */
id|disc_cnt
op_assign
id|lp-&gt;queuedccbs
op_minus
id|busy_cnt
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|s_status
)paren
(brace
r_default
suffix:colon
(brace
)brace
multiline_comment|/* Just for safety, should never happen */
r_case
id|S_QUEUE_FULL
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;Decrease number of tags to the number of &n;&t;&t;**&t;disconnected commands.&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|1
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;QUEUE FULL! %d busy, %d disconnected CCBs&bslash;n&quot;
comma
id|busy_cnt
comma
id|disc_cnt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|disc_cnt
OL
id|lp-&gt;numtags
)paren
(brace
id|lp-&gt;numtags
op_assign
id|disc_cnt
OG
l_int|2
ques
c_cond
id|disc_cnt
suffix:colon
l_int|2
suffix:semicolon
id|lp-&gt;num_good
op_assign
l_int|0
suffix:semicolon
id|ncr_setup_tags
(paren
id|np
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Requeue the command to the start queue.&n;&t;&t;**&t;If any disconnected commands,&n;&t;&t;**&t;&t;Clear SIGP.&n;&t;&t;**&t;&t;Jump to reselect.&n;&t;&t;*/
id|cp-&gt;phys.header.savep
op_assign
id|cp-&gt;startp
suffix:semicolon
id|cp-&gt;host_status
op_assign
id|HS_BUSY
suffix:semicolon
id|cp-&gt;scsi_status
op_assign
id|S_ILLEGAL
suffix:semicolon
id|ncr_put_start_queue
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|disc_cnt
)paren
id|INB
(paren
id|nc_ctest2
)paren
suffix:semicolon
multiline_comment|/* Clear SIGP */
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|reselect
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|S_TERMINATED
suffix:colon
r_case
id|S_CHECK_COND
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;If we were requesting sense, give up.&n;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;auto_sense
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Device returned CHECK CONDITION status.&n;&t;&t;**&t;Prepare all needed data strutures for getting &n;&t;&t;**&t;sense data.&n;&t;&t;**&n;&t;&t;**&t;identify message&n;&t;&t;*/
id|cp-&gt;scsi_smsg2
(braket
l_int|0
)braket
op_assign
id|M_IDENTIFY
op_or
id|cmd-&gt;lun
suffix:semicolon
id|cp-&gt;phys.smsg.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|scsi_smsg2
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.smsg.size
op_assign
id|cpu_to_scr
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;sense command&n;&t;&t;*/
id|cp-&gt;phys.cmd.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|sensecmd
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.cmd.size
op_assign
id|cpu_to_scr
c_func
(paren
l_int|6
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;patch requested size into sense command&n;&t;&t;*/
id|cp-&gt;sensecmd
(braket
l_int|0
)braket
op_assign
l_int|0x03
suffix:semicolon
id|cp-&gt;sensecmd
(braket
l_int|1
)braket
op_assign
id|cmd-&gt;lun
op_lshift
l_int|5
suffix:semicolon
id|cp-&gt;sensecmd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|cp-&gt;sense_buf
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;sense data&n;&t;&t;*/
id|bzero
c_func
(paren
id|cp-&gt;sense_buf
comma
r_sizeof
(paren
id|cp-&gt;sense_buf
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.sense.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_PHYS
c_func
(paren
id|cp
comma
id|sense_buf
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.sense.size
op_assign
id|cpu_to_scr
c_func
(paren
r_sizeof
(paren
id|cp-&gt;sense_buf
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;requeue the command.&n;&t;&t;*/
id|startp
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|sdata_in
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.header.savep
op_assign
id|startp
suffix:semicolon
id|cp-&gt;phys.header.goalp
op_assign
id|startp
op_plus
l_int|24
suffix:semicolon
id|cp-&gt;phys.header.lastp
op_assign
id|startp
suffix:semicolon
id|cp-&gt;phys.header.wgoalp
op_assign
id|startp
op_plus
l_int|24
suffix:semicolon
id|cp-&gt;phys.header.wlastp
op_assign
id|startp
suffix:semicolon
id|cp-&gt;host_status
op_assign
id|HS_BUSY
suffix:semicolon
id|cp-&gt;scsi_status
op_assign
id|S_ILLEGAL
suffix:semicolon
id|cp-&gt;auto_sense
op_assign
id|s_status
suffix:semicolon
id|cp-&gt;start.schedule.l_paddr
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|select
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Select without ATN for quirky devices.&n;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;quirks
op_amp
id|QUIRK_NOMSG
)paren
id|cp-&gt;start.schedule.l_paddr
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|select_no_atn
)paren
)paren
suffix:semicolon
id|ncr_put_start_queue
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|start
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|out
suffix:colon
id|OUTONB
(paren
id|nc_dcntl
comma
(paren
id|STD
op_or
id|NOCOM
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      ncr chip exception handler for programmed interrupts.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_show_msg
r_static
r_int
id|ncr_show_msg
(paren
id|u_char
op_star
id|msg
)paren
(brace
id|u_char
id|i
suffix:semicolon
id|printk
(paren
l_string|&quot;%x&quot;
comma
op_star
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|msg
op_eq
id|M_EXTENDED
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_minus
l_int|1
OG
id|msg
(braket
l_int|1
)braket
)paren
r_break
suffix:semicolon
id|printk
(paren
l_string|&quot;-%x&quot;
comma
id|msg
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
id|i
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
op_star
id|msg
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
(brace
id|printk
(paren
l_string|&quot;-%x&quot;
comma
id|msg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
(paren
l_int|2
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|ncr_print_msg
r_static
r_void
id|ncr_print_msg
(paren
id|ccb_p
id|cp
comma
r_char
op_star
id|label
comma
id|u_char
op_star
id|msg
)paren
(brace
r_if
c_cond
(paren
id|cp
)paren
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|label
)paren
id|printk
c_func
(paren
l_string|&quot;%s: &quot;
comma
id|label
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|msg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|ncr_int_sir
r_void
id|ncr_int_sir
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|scntl3
suffix:semicolon
id|u_char
id|chg
comma
id|ofs
comma
id|per
comma
id|fak
comma
id|wide
suffix:semicolon
id|u_char
id|num
op_assign
id|INB
(paren
id|nc_dsps
)paren
suffix:semicolon
id|ccb_p
id|cp
op_assign
l_int|0
suffix:semicolon
id|u_long
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|u_char
id|target
op_assign
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;I#%d&quot;
comma
id|num
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|num
)paren
(brace
r_case
id|SIR_RESEL_NO_MSG_IN
suffix:colon
r_case
id|SIR_RESEL_NO_IDENTIFY
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;If devices reselecting without sending an IDENTIFY &n;&t;&t;**&t;message still exist, this should help.&n;&t;&t;**&t;We just assume lun=0, 1 CCB, no tag.&n;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;lp
(braket
l_int|0
)braket
)paren
(brace
id|OUTL
(paren
id|nc_dsp
comma
id|scr_to_cpu
c_func
(paren
id|tp-&gt;lp
(braket
l_int|0
)braket
op_member_access_from_pointer
id|jump_ccb
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_case
id|SIR_RESEL_BAD_TARGET
suffix:colon
multiline_comment|/* Will send a TARGET RESET message */
r_case
id|SIR_RESEL_BAD_LUN
suffix:colon
multiline_comment|/* Will send a TARGET RESET message */
r_case
id|SIR_RESEL_BAD_I_T_L_Q
suffix:colon
multiline_comment|/* Will send an ABORT TAG message   */
r_case
id|SIR_RESEL_BAD_I_T_L
suffix:colon
multiline_comment|/* Will send an ABORT message&t;    */
id|printk
(paren
l_string|&quot;%s:%d: SIR %d, &quot;
l_string|&quot;incorrect nexus identification on reselection&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|target
comma
id|num
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
id|SIR_DONE_OVERFLOW
suffix:colon
id|printk
(paren
l_string|&quot;%s:%d: SIR %d, &quot;
l_string|&quot;CCB done queue overflow&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|target
comma
id|num
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
id|SIR_BAD_STATUS
suffix:colon
id|cp
op_assign
id|np-&gt;header.cp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
op_logical_or
id|CCB_PHYS
(paren
id|cp
comma
id|phys
)paren
op_ne
id|dsa
)paren
r_goto
id|out
suffix:semicolon
id|ncr_sir_to_redo
c_func
(paren
id|np
comma
id|num
comma
id|cp
)paren
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;lookup the ccb&n;&t;&t;*/
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
r_while
c_loop
(paren
id|cp
op_logical_and
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|phys
)paren
op_ne
id|dsa
)paren
)paren
id|cp
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
m_assert
(paren
id|cp
op_logical_and
id|cp
op_eq
id|np-&gt;header.cp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
op_logical_or
id|cp
op_ne
id|np-&gt;header.cp
)paren
r_goto
id|out
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|num
)paren
(brace
multiline_comment|/*-----------------------------------------------------------------------------&n;**&n;**&t;Was Sie schon immer ueber transfermode negotiation wissen wollten ...&n;**&n;**&t;We try to negotiate sync and wide transfer only after&n;**&t;a successfull inquire command. We look at byte 7 of the&n;**&t;inquire data to determine the capabilities of the target.&n;**&n;**&t;When we try to negotiate, we append the negotiation message&n;**&t;to the identify and (maybe) simple tag message.&n;**&t;The host status field is set to HS_NEGOTIATE to mark this&n;**&t;situation.&n;**&n;**&t;If the target doesn&squot;t answer this message immidiately&n;**&t;(as required by the standard), the SIR_NEGO_FAIL interrupt&n;**&t;will be raised eventually.&n;**&t;The handler removes the HS_NEGOTIATE status, and sets the&n;**&t;negotiated value to the default (async / nowide).&n;**&n;**&t;If we receive a matching answer immediately, we check it&n;**&t;for validity, and set the values.&n;**&n;**&t;If we receive a Reject message immediately, we assume the&n;**&t;negotiation has failed, and fall back to standard values.&n;**&n;**&t;If we receive a negotiation message while not in HS_NEGOTIATE&n;**&t;state, it&squot;s a target initiated negotiation. We prepare a&n;**&t;(hopefully) valid answer, set our parameters, and send back &n;**&t;this answer to the target.&n;**&n;**&t;If the target doesn&squot;t fetch the answer (no message out phase),&n;**&t;we assume the negotiation has failed, and fall back to default&n;**&t;settings.&n;**&n;**&t;When we set the values, we adjust them in all ccbs belonging &n;**&t;to this target, in the controller&squot;s register, and in the &quot;phys&quot;&n;**&t;field of the controller&squot;s struct ncb.&n;**&n;**&t;Possible cases:&t;&t;   hs  sir   msg_in value  send   goto&n;**&t;We try to negotiate:&n;**&t;-&gt; target doesnt&squot;t msgin   NEG FAIL  noop   defa.  -      dispatch&n;**&t;-&gt; target rejected our msg NEG FAIL  reject defa.  -      dispatch&n;**&t;-&gt; target answered  (ok)   NEG SYNC  sdtr   set    -      clrack&n;**&t;-&gt; target answered (!ok)   NEG SYNC  sdtr   defa.  REJ---&gt;msg_bad&n;**&t;-&gt; target answered  (ok)   NEG WIDE  wdtr   set    -      clrack&n;**&t;-&gt; target answered (!ok)   NEG WIDE  wdtr   defa.  REJ---&gt;msg_bad&n;**&t;-&gt; any other msgin&t;   NEG FAIL  noop   defa.  -      dispatch&n;**&n;**&t;Target tries to negotiate:&n;**&t;-&gt; incoming message&t;   --- SYNC  sdtr   set    SDTR   -&n;**&t;-&gt; incoming message&t;   --- WIDE  wdtr   set    WDTR   -&n;**      We sent our answer:&n;**&t;-&gt; target doesn&squot;t msgout   --- PROTO ?      defa.  -      dispatch&n;**&n;**-----------------------------------------------------------------------------&n;*/
r_case
id|SIR_NEGO_FAILED
suffix:colon
multiline_comment|/*-------------------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;Negotiation failed.&n;&t;&t;**&t;Target doesn&squot;t send an answer message,&n;&t;&t;**&t;or target rejected our message.&n;&t;&t;**&n;&t;&t;**      Remove negotiation request.&n;&t;&t;**&n;&t;&t;**-------------------------------------------------------&n;&t;&t;*/
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SIR_NEGO_PROTO
suffix:colon
multiline_comment|/*-------------------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;Negotiation failed.&n;&t;&t;**&t;Target doesn&squot;t fetch the answer message.&n;&t;&t;**&n;&t;&t;**-------------------------------------------------------&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;negotiation failed sir=%x status=%x.&bslash;n&quot;
comma
id|num
comma
id|cp-&gt;nego_status
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;any error in negotiation:&n;&t;&t;**&t;fall back to default mode.&n;&t;&t;*/
r_switch
c_cond
(paren
id|cp-&gt;nego_status
)paren
(brace
r_case
id|NS_SYNC
suffix:colon
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0xe0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_WIDE
suffix:colon
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|cp-&gt;nego_status
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIR_NEGO_SYNC
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;Synchronous request message received.&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;sync msgin: &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgin
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;get requested values.&n;&t;&t;*/
id|chg
op_assign
l_int|0
suffix:semicolon
id|per
op_assign
id|np-&gt;msgin
(braket
l_int|3
)braket
suffix:semicolon
id|ofs
op_assign
id|np-&gt;msgin
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_eq
l_int|0
)paren
id|per
op_assign
l_int|255
suffix:semicolon
multiline_comment|/*&n;&t;&t;**      if target sends SDTR message,&n;&t;&t;**&t;      it CAN transfer synch.&n;&t;&t;*/
r_if
c_cond
(paren
id|ofs
)paren
id|tp-&gt;inq_byte7
op_or_assign
id|INQ7_SYNC
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;check values against driver limits.&n;&t;&t;*/
r_if
c_cond
(paren
id|per
OL
id|np-&gt;minsync
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|per
op_assign
id|np-&gt;minsync
suffix:semicolon
)brace
r_if
c_cond
(paren
id|per
OL
id|tp-&gt;minsync
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|per
op_assign
id|tp-&gt;minsync
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ofs
OG
id|tp-&gt;maxoffs
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|ofs
op_assign
id|tp-&gt;maxoffs
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Check against controller limits.&n;&t;&t;*/
id|fak
op_assign
l_int|7
suffix:semicolon
id|scntl3
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_ne
l_int|0
)paren
(brace
id|ncr_getsync
c_func
(paren
id|np
comma
id|per
comma
op_amp
id|fak
comma
op_amp
id|scntl3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fak
OG
l_int|7
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|ofs
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ofs
op_eq
l_int|0
)paren
(brace
id|fak
op_assign
l_int|7
suffix:semicolon
id|per
op_assign
l_int|0
suffix:semicolon
id|scntl3
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;minsync
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;sync: per=%d scntl3=0x%x ofs=%d fak=%d chg=%d.&bslash;n&quot;
comma
id|per
comma
id|scntl3
comma
id|ofs
comma
id|fak
comma
id|chg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INB
(paren
id|HS_PRT
)paren
op_eq
id|HS_NEGOTIATE
)paren
(brace
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cp-&gt;nego_status
)paren
(brace
r_case
id|NS_SYNC
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;**      This was an answer message&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|chg
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;**&t;Answer wasn&squot;t acceptable.&n;&t;&t;&t;&t;&t;*/
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0xe0
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;**&t;Answer is ok.&n;&t;&t;&t;&t;&t;*/
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
id|scntl3
comma
(paren
id|fak
op_lshift
l_int|5
)paren
op_or
id|ofs
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
r_case
id|NS_WIDE
suffix:colon
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;It was a request. Set value and&n;&t;&t;**      prepare an answer message&n;&t;&t;*/
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
id|scntl3
comma
(paren
id|fak
op_lshift
l_int|5
)paren
op_or
id|ofs
)paren
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|1
)braket
op_assign
l_int|3
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|2
)braket
op_assign
id|M_X_SYNC_REQ
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|3
)braket
op_assign
id|per
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|4
)braket
op_assign
id|ofs
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|NS_SYNC
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;sync msgout: &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgout
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ofs
)paren
(brace
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIR_NEGO_WIDE
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;Wide request message received.&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;wide msgin: &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgin
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;get requested values.&n;&t;&t;*/
id|chg
op_assign
l_int|0
suffix:semicolon
id|wide
op_assign
id|np-&gt;msgin
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;**      if target sends WDTR message,&n;&t;&t;**&t;      it CAN transfer wide.&n;&t;&t;*/
r_if
c_cond
(paren
id|wide
)paren
id|tp-&gt;inq_byte7
op_or_assign
id|INQ7_WIDE16
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;check values against driver limits.&n;&t;&t;*/
r_if
c_cond
(paren
id|wide
OG
id|tp-&gt;usrwide
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|wide
op_assign
id|tp-&gt;usrwide
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;wide: wide=%d chg=%d.&bslash;n&quot;
comma
id|wide
comma
id|chg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INB
(paren
id|HS_PRT
)paren
op_eq
id|HS_NEGOTIATE
)paren
(brace
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cp-&gt;nego_status
)paren
(brace
r_case
id|NS_WIDE
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;**      This was an answer message&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|chg
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;**&t;Answer wasn&squot;t acceptable.&n;&t;&t;&t;&t;&t;*/
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;**&t;Answer is ok.&n;&t;&t;&t;&t;&t;*/
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
id|wide
comma
l_int|1
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
r_case
id|NS_SYNC
suffix:colon
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0xe0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;It was a request, set value and&n;&t;&t;**      prepare an answer message&n;&t;&t;*/
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
id|wide
comma
l_int|1
)paren
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|2
)braket
op_assign
id|M_X_WIDE_REQ
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|3
)braket
op_assign
id|wide
suffix:semicolon
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|NS_WIDE
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;wide msgout: &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgin
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/*--------------------------------------------------------------------&n;**&n;**&t;Processing of special messages&n;**&n;**--------------------------------------------------------------------&n;*/
r_case
id|SIR_REJECT_RECEIVED
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;We received a M_REJECT message.&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;M_REJECT received (%x:%x).&bslash;n&quot;
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|np-&gt;lastmsg
)paren
comma
id|np-&gt;msgout
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIR_REJECT_SENT
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;We received an unknown message&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;M_REJECT sent for &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgin
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*--------------------------------------------------------------------&n;**&n;**&t;Processing of special messages&n;**&n;**--------------------------------------------------------------------&n;*/
r_case
id|SIR_IGN_RESIDUE
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;We received an IGNORE RESIDUE message,&n;&t;&t;**&t;which couldn&squot;t be handled by the script.&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;M_IGN_RESIDUE received, but not yet implemented.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if 0
r_case
id|SIR_MISSING_SAVE
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;We received an DISCONNECT message,&n;&t;&t;**&t;but the datapointer wasn&squot;t saved before.&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;M_DISCONNECT received, but datapointer not saved: &quot;
l_string|&quot;data=%x save=%x goal=%x.&bslash;n&quot;
comma
(paren
r_int
)paren
id|INL
(paren
id|nc_temp
)paren
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|np-&gt;header.savep
)paren
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|np-&gt;header.goalp
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
id|out
suffix:colon
id|OUTONB
(paren
id|nc_dcntl
comma
(paren
id|STD
op_or
id|NOCOM
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Aquire a control block&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_get_ccb
r_static
id|ccb_p
id|ncr_get_ccb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|tn
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|tp-&gt;lp
(braket
id|ln
)braket
suffix:semicolon
id|u_char
id|tag
op_assign
id|NO_TAG
suffix:semicolon
id|ccb_p
id|cp
op_assign
(paren
id|ccb_p
)paren
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Lun structure available ?&n;&t;*/
r_if
c_cond
(paren
id|lp
)paren
(brace
id|XPT_QUEHEAD
op_star
id|qp
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Keep from using more tags than we can handle.&n;&t;&t;*/
r_if
c_cond
(paren
id|lp-&gt;usetags
op_logical_and
id|lp-&gt;busyccbs
op_ge
id|lp-&gt;maxnxs
)paren
r_return
(paren
id|ccb_p
)paren
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Allocate a new CCB if needed.&n;&t;&t;*/
r_if
c_cond
(paren
id|xpt_que_empty
c_func
(paren
op_amp
id|lp-&gt;free_ccbq
)paren
)paren
id|ncr_alloc_ccb
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Tune tag mode if asked by user.&n;&t;&t;*/
r_if
c_cond
(paren
id|lp-&gt;queuedepth
op_ne
id|lp-&gt;numtags
)paren
(brace
id|ncr_setup_tags
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Look for free CCB&n;&t;&t;*/
id|qp
op_assign
id|xpt_remque_head
c_func
(paren
op_amp
id|lp-&gt;free_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qp
)paren
(brace
id|cp
op_assign
id|xpt_que_entry
c_func
(paren
id|qp
comma
r_struct
id|ccb
comma
id|link_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;magic
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ccb free list corrupted (@%p)&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
id|cp
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|xpt_insque_tail
c_func
(paren
id|qp
comma
op_amp
id|lp-&gt;wait_ccbq
)paren
suffix:semicolon
op_increment
id|lp-&gt;busyccbs
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;**&t;If a CCB is available,&n;&t;&t;**&t;Get a tag for this nexus if required.&n;&t;&t;*/
r_if
c_cond
(paren
id|cp
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;usetags
)paren
id|tag
op_assign
id|lp-&gt;cb_tags
(braket
id|lp-&gt;ia_tag
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;actccbs
OG
l_int|0
)paren
r_return
(paren
id|ccb_p
)paren
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;if nothing available, take the default.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Wait until available.&n;&t;*/
macro_line|#if 0
r_while
c_loop
(paren
id|cp-&gt;magic
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|SCSI_NOSLEEP
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|tsleep
(paren
(paren
id|caddr_t
)paren
id|cp
comma
id|PRIBIO
op_or
id|PCATCH
comma
l_string|&quot;ncr&quot;
comma
l_int|0
)paren
)paren
r_break
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cp-&gt;magic
)paren
r_return
(paren
(paren
id|ccb_p
)paren
l_int|0
)paren
suffix:semicolon
id|cp-&gt;magic
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Move to next available tag if tag used.&n;&t;*/
r_if
c_cond
(paren
id|lp
)paren
(brace
r_if
c_cond
(paren
id|tag
op_ne
id|NO_TAG
)paren
(brace
op_increment
id|lp-&gt;ia_tag
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;ia_tag
op_eq
id|MAX_TAGS
)paren
id|lp-&gt;ia_tag
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tags_umap
op_or_assign
(paren
(paren
(paren
id|tagmap_t
)paren
l_int|1
)paren
op_lshift
id|tag
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;**&t;Remember all informations needed to free this CCB.&n;&t;*/
id|cp-&gt;tag
op_assign
id|tag
suffix:semicolon
id|cp-&gt;target
op_assign
id|tn
suffix:semicolon
id|cp-&gt;lun
op_assign
id|ln
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TAGS
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ccb @%p using tag %d.&bslash;n&quot;
comma
id|cp
comma
id|tag
)paren
suffix:semicolon
)brace
r_return
id|cp
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Release one control block&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_free_ccb
r_static
r_void
id|ncr_free_ccb
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|tp-&gt;lp
(braket
id|cp-&gt;lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TAGS
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ccb @%p freeing tag %d.&bslash;n&quot;
comma
id|cp
comma
id|cp-&gt;tag
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;If lun control block available,&n;&t;**&t;decrement active commands and increment credit, &n;&t;**&t;free the tag if any and remove the JUMP for reselect.&n;&t;*/
r_if
c_cond
(paren
id|lp
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;tag
op_ne
id|NO_TAG
)paren
(brace
id|lp-&gt;cb_tags
(braket
id|lp-&gt;if_tag
op_increment
)braket
op_assign
id|cp-&gt;tag
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;if_tag
op_eq
id|MAX_TAGS
)paren
id|lp-&gt;if_tag
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tags_umap
op_and_assign
op_complement
(paren
(paren
(paren
id|tagmap_t
)paren
l_int|1
)paren
op_lshift
id|cp-&gt;tag
)paren
suffix:semicolon
id|lp-&gt;tags_smap
op_and_assign
id|lp-&gt;tags_umap
suffix:semicolon
id|lp-&gt;jump_ccb
(braket
id|cp-&gt;tag
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
c_func
(paren
id|np
comma
id|bad_i_t_l_q
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;jump_ccb
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
c_func
(paren
id|np
comma
id|bad_i_t_l
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;**&t;Make this CCB available.&n;&t;*/
r_if
c_cond
(paren
id|lp
)paren
(brace
r_if
c_cond
(paren
id|cp
op_ne
id|np-&gt;ccb
)paren
(brace
id|xpt_remque
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
)paren
suffix:semicolon
id|xpt_insque_head
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|lp-&gt;free_ccbq
)paren
suffix:semicolon
)brace
op_decrement
id|lp-&gt;busyccbs
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;queued
)paren
(brace
op_decrement
id|lp-&gt;queuedccbs
suffix:semicolon
)brace
)brace
id|cp
op_member_access_from_pointer
id|host_status
op_assign
id|HS_IDLE
suffix:semicolon
id|cp
op_member_access_from_pointer
id|magic
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;queued
)paren
(brace
op_decrement
id|np-&gt;queuedccbs
suffix:semicolon
id|cp-&gt;queued
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|cp
op_eq
id|np-&gt;ccb
)paren
id|wakeup
(paren
(paren
id|caddr_t
)paren
id|cp
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|macro|ncr_reg_bus_addr
mdefine_line|#define ncr_reg_bus_addr(r) &bslash;&n;&t;(pcivtobus(np-&gt;paddr) + offsetof (struct ncr_reg, r))
multiline_comment|/*------------------------------------------------------------------------&n;**&t;Initialize the fixed part of a CCB structure.&n;**------------------------------------------------------------------------&n;**------------------------------------------------------------------------&n;*/
DECL|function|ncr_init_ccb
r_static
r_void
id|ncr_init_ccb
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
id|ncrcmd
id|copy_4
op_assign
id|np-&gt;features
op_amp
id|FE_PFEN
ques
c_cond
id|SCR_COPY
c_func
(paren
l_int|4
)paren
suffix:colon
id|SCR_COPY_F
c_func
(paren
l_int|4
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Remember virtual and bus address of this ccb.&n;&t;*/
id|cp-&gt;p_ccb
op_assign
id|vtobus
c_func
(paren
id|cp
)paren
suffix:semicolon
id|cp-&gt;phys.header.cp
op_assign
id|cp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;This allows xpt_remque to work for the default ccb.&n;&t;*/
id|xpt_que_init
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initialyze the start and restart launch script.&n;&t;**&n;&t;**&t;COPY(4) @(...p_phys), @(dsa)&n;&t;**&t;JUMP @(sched_point)&n;&t;*/
id|cp-&gt;start.setup_dsa
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|copy_4
)paren
suffix:semicolon
id|cp-&gt;start.setup_dsa
(braket
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_PHYS
c_func
(paren
id|cp
comma
id|start.p_phys
)paren
)paren
suffix:semicolon
id|cp-&gt;start.setup_dsa
(braket
l_int|2
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|ncr_reg_bus_addr
c_func
(paren
id|nc_dsa
)paren
)paren
suffix:semicolon
id|cp-&gt;start.schedule.l_cmd
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_JUMP
)paren
suffix:semicolon
id|cp-&gt;start.p_phys
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_PHYS
c_func
(paren
id|cp
comma
id|phys
)paren
)paren
suffix:semicolon
id|bcopy
c_func
(paren
op_amp
id|cp-&gt;start
comma
op_amp
id|cp-&gt;restart
comma
r_sizeof
(paren
id|cp-&gt;restart
)paren
)paren
suffix:semicolon
id|cp-&gt;start.schedule.l_paddr
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
)paren
suffix:semicolon
id|cp-&gt;restart.schedule.l_paddr
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
m_abort
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------------&n;**&t;Allocate a CCB and initialize its fixed part.&n;**------------------------------------------------------------------------&n;**------------------------------------------------------------------------&n;*/
DECL|function|ncr_alloc_ccb
r_static
r_void
id|ncr_alloc_ccb
c_func
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|tn
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|tp-&gt;lp
(braket
id|ln
)braket
suffix:semicolon
id|ccb_p
id|cp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate memory for this CCB.&n;&t;*/
id|cp
op_assign
id|m_calloc_dma
c_func
(paren
r_sizeof
(paren
r_struct
id|ccb
)paren
comma
l_string|&quot;CCB&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Count it and initialyze it.&n;&t;*/
id|lp-&gt;actccbs
op_increment
suffix:semicolon
id|np-&gt;actccbs
op_increment
suffix:semicolon
id|bzero
(paren
id|cp
comma
r_sizeof
(paren
op_star
id|cp
)paren
)paren
suffix:semicolon
id|ncr_init_ccb
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Chain into wakeup list and free ccb queue and take it &n;&t;**&t;into account for tagged commands.&n;&t;*/
id|cp-&gt;link_ccb
op_assign
id|np-&gt;ccb-&gt;link_ccb
suffix:semicolon
id|np-&gt;ccb-&gt;link_ccb
op_assign
id|cp
suffix:semicolon
id|xpt_insque_head
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|lp-&gt;free_ccbq
)paren
suffix:semicolon
id|ncr_setup_tags
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      Allocation of resources for Targets/Luns/Tags.&n;**&n;**&n;**==========================================================&n;*/
multiline_comment|/*------------------------------------------------------------------------&n;**&t;Target control block initialisation.&n;**------------------------------------------------------------------------&n;**&t;This data structure is fully initialized after a SCSI command &n;**&t;has been successfully completed for this target.&n;**&t;It contains a SCRIPT that is called on target reselection.&n;**------------------------------------------------------------------------&n;*/
DECL|function|ncr_init_tcb
r_static
r_void
id|ncr_init_tcb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|tn
)braket
suffix:semicolon
id|ncrcmd
id|copy_1
op_assign
id|np-&gt;features
op_amp
id|FE_PFEN
ques
c_cond
id|SCR_COPY
c_func
(paren
l_int|1
)paren
suffix:colon
id|SCR_COPY_F
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_int
id|th
op_assign
id|tn
op_amp
l_int|3
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Jump to next tcb if SFBR does not match this target.&n;&t;**&t;JUMP  IF (SFBR != #target#), @(next tcb)&n;&t;*/
id|tp-&gt;jump_tcb.l_cmd
op_assign
id|cpu_to_scr
c_func
(paren
(paren
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|0x80
op_plus
id|tn
)paren
)paren
)paren
)paren
suffix:semicolon
id|tp-&gt;jump_tcb.l_paddr
op_assign
id|np-&gt;jump_tcb
(braket
id|th
)braket
dot
id|l_paddr
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Load the synchronous transfer register.&n;&t;**&t;COPY @(tp-&gt;sval), @(sxfer)&n;&t;*/
id|tp-&gt;getscr
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|copy_1
)paren
suffix:semicolon
id|tp-&gt;getscr
(braket
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
(paren
op_amp
id|tp-&gt;sval
)paren
)paren
suffix:semicolon
id|tp-&gt;getscr
(braket
l_int|2
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|ncr_reg_bus_addr
c_func
(paren
id|nc_sxfer
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Load the timing register.&n;&t;**&t;COPY @(tp-&gt;wval), @(scntl3)&n;&t;*/
id|tp-&gt;getscr
(braket
l_int|3
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|copy_1
)paren
suffix:semicolon
id|tp-&gt;getscr
(braket
l_int|4
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
(paren
op_amp
id|tp-&gt;wval
)paren
)paren
suffix:semicolon
id|tp-&gt;getscr
(braket
l_int|5
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|ncr_reg_bus_addr
c_func
(paren
id|nc_scntl3
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Get the IDENTIFY message and the lun.&n;&t;**&t;CALL @script(resel_lun)&n;&t;*/
id|tp-&gt;call_lun.l_cmd
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_CALL
)paren
suffix:semicolon
id|tp-&gt;call_lun.l_paddr
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|resel_lun
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Look for the lun control block of this nexus.&n;&t;**&t;For i = 0 to 3&n;&t;**&t;&t;JUMP ^ IFTRUE (MASK (i, 3)), @(next_lcb)&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tp-&gt;jump_lcb
(braket
id|i
)braket
dot
id|l_cmd
op_assign
id|cpu_to_scr
c_func
(paren
(paren
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|i
comma
l_int|3
)paren
)paren
)paren
)paren
suffix:semicolon
id|tp-&gt;jump_lcb
(braket
id|i
)braket
dot
id|l_paddr
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|bad_identify
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Link this target control block to the JUMP chain.&n;&t;*/
id|np-&gt;jump_tcb
(braket
id|th
)braket
dot
id|l_paddr
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
(paren
op_amp
id|tp-&gt;jump_tcb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;These assert&squot;s should be moved at driver initialisations.&n;&t;*/
m_assert
(paren
(paren
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_sxfer
)paren
op_xor
m_offsetof
(paren
r_struct
id|tcb
comma
id|sval
)paren
)paren
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
suffix:semicolon
m_assert
(paren
(paren
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_scntl3
)paren
op_xor
m_offsetof
(paren
r_struct
id|tcb
comma
id|wval
)paren
)paren
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------------&n;**&t;Lun control block allocation and initialization.&n;**------------------------------------------------------------------------&n;**&t;This data structure is allocated and initialized after a SCSI &n;**&t;command has been successfully completed for this target/lun.&n;**------------------------------------------------------------------------&n;*/
DECL|function|ncr_alloc_lcb
r_static
id|lcb_p
id|ncr_alloc_lcb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|tn
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|tp-&gt;lp
(braket
id|ln
)braket
suffix:semicolon
id|ncrcmd
id|copy_4
op_assign
id|np-&gt;features
op_amp
id|FE_PFEN
ques
c_cond
id|SCR_COPY
c_func
(paren
l_int|4
)paren
suffix:colon
id|SCR_COPY_F
c_func
(paren
l_int|4
)paren
suffix:semicolon
r_int
id|lh
op_assign
id|ln
op_amp
l_int|3
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Already done, return.&n;&t;*/
r_if
c_cond
(paren
id|lp
)paren
r_return
id|lp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate the lcb.&n;&t;*/
id|lp
op_assign
id|m_calloc_dma
c_func
(paren
r_sizeof
(paren
r_struct
id|lcb
)paren
comma
l_string|&quot;LCB&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_goto
id|fail
suffix:semicolon
id|bzero
c_func
(paren
id|lp
comma
r_sizeof
(paren
op_star
id|lp
)paren
)paren
suffix:semicolon
id|tp-&gt;lp
(braket
id|ln
)braket
op_assign
id|lp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initialize the target control block if not yet.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;jump_tcb.l_cmd
)paren
id|ncr_init_tcb
c_func
(paren
id|np
comma
id|tn
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initialize the CCB queue headers.&n;&t;*/
id|xpt_que_init
c_func
(paren
op_amp
id|lp-&gt;free_ccbq
)paren
suffix:semicolon
id|xpt_que_init
c_func
(paren
op_amp
id|lp-&gt;busy_ccbq
)paren
suffix:semicolon
id|xpt_que_init
c_func
(paren
op_amp
id|lp-&gt;wait_ccbq
)paren
suffix:semicolon
id|xpt_que_init
c_func
(paren
op_amp
id|lp-&gt;skip_ccbq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set max CCBs to 1 and use the default 1 entry &n;&t;**&t;jump table by default.&n;&t;*/
id|lp-&gt;maxnxs
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;jump_ccb
op_assign
op_amp
id|lp-&gt;jump_ccb_0
suffix:semicolon
id|lp-&gt;p_jump_ccb
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|lp-&gt;jump_ccb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initilialyze the reselect script:&n;&t;**&n;&t;**&t;Jump to next lcb if SFBR does not match this lun.&n;&t;**&t;Load TEMP with the CCB direct jump table bus address.&n;&t;**&t;Get the SIMPLE TAG message and the tag.&n;&t;**&n;&t;**&t;JUMP  IF (SFBR != #lun#), @(next lcb)&n;&t;**&t;COPY @(lp-&gt;p_jump_ccb),&t;  @(temp)&n;&t;**&t;JUMP @script(resel_notag)&n;&t;*/
id|lp-&gt;jump_lcb.l_cmd
op_assign
id|cpu_to_scr
c_func
(paren
(paren
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
l_int|0x80
op_plus
id|ln
comma
l_int|0xff
)paren
)paren
)paren
)paren
suffix:semicolon
id|lp-&gt;jump_lcb.l_paddr
op_assign
id|tp-&gt;jump_lcb
(braket
id|lh
)braket
dot
id|l_paddr
suffix:semicolon
id|lp-&gt;load_jump_ccb
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|copy_4
)paren
suffix:semicolon
id|lp-&gt;load_jump_ccb
(braket
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
(paren
op_amp
id|lp-&gt;p_jump_ccb
)paren
)paren
suffix:semicolon
id|lp-&gt;load_jump_ccb
(braket
l_int|2
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|ncr_reg_bus_addr
c_func
(paren
id|nc_temp
)paren
)paren
suffix:semicolon
id|lp-&gt;jump_tag.l_cmd
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_JUMP
)paren
suffix:semicolon
id|lp-&gt;jump_tag.l_paddr
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|resel_notag
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Link this lun control block to the JUMP chain.&n;&t;*/
id|tp-&gt;jump_lcb
(braket
id|lh
)braket
dot
id|l_paddr
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
(paren
op_amp
id|lp-&gt;jump_lcb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initialize command queuing control.&n;&t;*/
id|lp-&gt;busyccbs
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;queuedccbs
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;queuedepth
op_assign
l_int|1
suffix:semicolon
id|fail
suffix:colon
r_return
id|lp
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------------&n;**&t;Lun control block setup on INQUIRY data received.&n;**------------------------------------------------------------------------&n;**&t;We only support WIDE, SYNC for targets and CMDQ for logical units.&n;**&t;This setup is done on each INQUIRY since we are expecting user &n;**&t;will play with CHANGE DEFINITION commands. :-)&n;**------------------------------------------------------------------------&n;*/
DECL|function|ncr_setup_lcb
r_static
id|lcb_p
id|ncr_setup_lcb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
comma
id|u_char
op_star
id|inq_data
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|tn
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|tp-&gt;lp
(braket
id|ln
)braket
suffix:semicolon
id|u_char
id|inq_byte7
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If no lcb, try to allocate it.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|lp
op_logical_and
op_logical_neg
(paren
id|lp
op_assign
id|ncr_alloc_lcb
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
)paren
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Get device quirks from a speciality table.&n;&t;*/
id|tp-&gt;quirks
op_assign
id|ncr_lookup
(paren
id|inq_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;quirks
op_logical_and
id|bootverbose
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;quirks=%x.&bslash;n&quot;
comma
id|tp-&gt;quirks
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Evaluate trustable target/unit capabilities.&n;&t;**&t;We only believe device version &gt;= SCSI-2 that &n;&t;**&t;use appropriate response data format (2).&n;&t;**&t;But it seems that some CCS devices also &n;&t;**&t;support SYNC and I donnot want to frustrate &n;&t;**&t;anybody. ;-)&n;&t;*/
id|inq_byte7
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inq_data
(braket
l_int|2
)braket
op_amp
l_int|0x7
)paren
op_ge
l_int|2
op_logical_and
(paren
id|inq_data
(braket
l_int|3
)braket
op_amp
l_int|0xf
)paren
op_eq
l_int|2
)paren
id|inq_byte7
op_assign
id|inq_data
(braket
l_int|7
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|inq_data
(braket
l_int|2
)braket
op_amp
l_int|0x7
)paren
op_eq
l_int|1
op_logical_and
(paren
id|inq_data
(braket
l_int|3
)braket
op_amp
l_int|0xf
)paren
op_eq
l_int|1
)paren
id|inq_byte7
op_assign
id|INQ7_SYNC
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Throw away announced LUN capabilities if we are told &n;&t;**&t;that there is no real device supported by the logical unit.&n;&t;*/
r_if
c_cond
(paren
(paren
id|inq_data
(braket
l_int|0
)braket
op_amp
l_int|0xe0
)paren
OG
l_int|0x20
op_logical_or
(paren
id|inq_data
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
op_eq
l_int|0x1f
)paren
id|inq_byte7
op_and_assign
(paren
id|INQ7_SYNC
op_or
id|INQ7_WIDE16
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If user is wanting SYNC, force this feature.&n;&t;*/
r_if
c_cond
(paren
id|driver_setup.force_sync_nego
)paren
id|inq_byte7
op_or_assign
id|INQ7_SYNC
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Prepare negotiation if SIP capabilities have changed.&n;&t;*/
id|tp-&gt;inq_done
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inq_byte7
op_xor
id|tp-&gt;inq_byte7
)paren
op_amp
(paren
id|INQ7_SYNC
op_or
id|INQ7_WIDE16
)paren
)paren
(brace
id|tp-&gt;inq_byte7
op_assign
id|inq_byte7
suffix:semicolon
id|ncr_negotiate
c_func
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;If unit supports tagged commands, allocate the &n;&t;**&t;CCB JUMP table if not yet.&n;&t;*/
r_if
c_cond
(paren
(paren
id|inq_byte7
op_amp
id|INQ7_QUEUE
)paren
op_logical_and
id|lp-&gt;jump_ccb
op_eq
op_amp
id|lp-&gt;jump_ccb_0
)paren
(brace
r_int
id|i
suffix:semicolon
id|lp-&gt;jump_ccb
op_assign
id|m_calloc_dma
c_func
(paren
l_int|256
comma
l_string|&quot;JUMP_CCB&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;jump_ccb
)paren
(brace
id|lp-&gt;jump_ccb
op_assign
op_amp
id|lp-&gt;jump_ccb_0
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|lp-&gt;p_jump_ccb
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|lp-&gt;jump_ccb
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
id|lp-&gt;jump_ccb
(braket
id|i
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|bad_i_t_l_q
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TAGS
suffix:semicolon
id|i
op_increment
)paren
id|lp-&gt;cb_tags
(braket
id|i
)braket
op_assign
id|i
suffix:semicolon
id|lp-&gt;maxnxs
op_assign
id|MAX_TAGS
suffix:semicolon
id|lp-&gt;tags_stime
op_assign
id|ktime_get
c_func
(paren
l_int|3
op_star
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Adjust tagged queueing status if needed.&n;&t;*/
r_if
c_cond
(paren
(paren
id|inq_byte7
op_xor
id|lp-&gt;inq_byte7
)paren
op_amp
id|INQ7_QUEUE
)paren
(brace
id|lp-&gt;inq_byte7
op_assign
id|inq_byte7
suffix:semicolon
id|lp-&gt;numtags
op_assign
id|lp-&gt;maxtags
suffix:semicolon
id|ncr_setup_tags
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
)brace
id|fail
suffix:colon
r_return
id|lp
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Build Scatter Gather Block&n;**&n;**&n;**==========================================================&n;**&n;**&t;The transfer area may be scattered among&n;**&t;several non adjacent physical pages.&n;**&n;**&t;We may use MAX_SCATTER blocks.&n;**&n;**----------------------------------------------------------&n;*/
multiline_comment|/*&n;**&t;We try to reduce the number of interrupts caused&n;**&t;by unexpected phase changes due to disconnects.&n;**&t;A typical harddisk may disconnect before ANY block.&n;**&t;If we wanted to avoid unexpected phase changes at all&n;**&t;we had to use a break point every 512 bytes.&n;**&t;Of course the number of scatter/gather blocks is&n;**&t;limited.&n;**&t;Under Linux, the scatter/gatter blocks are provided by &n;**&t;the generic driver. We just have to copy addresses and &n;**&t;sizes to the data segment array.&n;*/
DECL|function|ncr_scatter
r_static
r_int
id|ncr_scatter
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|scr_tblmove
op_star
id|data
suffix:semicolon
r_int
id|segment
op_assign
l_int|0
suffix:semicolon
r_int
id|use_sg
op_assign
(paren
r_int
)paren
id|cmd-&gt;use_sg
suffix:semicolon
id|data
op_assign
id|cp-&gt;phys.data
suffix:semicolon
id|cp-&gt;data_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_sg
)paren
(brace
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
)paren
(brace
id|u_long
id|baddr
op_assign
id|map_scsi_single_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
id|data
op_assign
op_amp
id|data
(braket
id|MAX_SCATTER
op_minus
l_int|1
)braket
suffix:semicolon
id|data
(braket
l_int|0
)braket
dot
id|addr
op_assign
id|cpu_to_scr
c_func
(paren
id|baddr
)paren
suffix:semicolon
id|data
(braket
l_int|0
)braket
dot
id|size
op_assign
id|cpu_to_scr
c_func
(paren
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
id|cp-&gt;data_len
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|segment
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|use_sg
op_le
id|MAX_SCATTER
)paren
(brace
r_struct
id|scatterlist
op_star
id|scatter
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
id|use_sg
op_assign
id|map_scsi_sg_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
id|data
op_assign
op_amp
id|data
(braket
id|MAX_SCATTER
op_minus
id|use_sg
)braket
suffix:semicolon
r_while
c_loop
(paren
id|segment
OL
id|use_sg
)paren
(brace
id|u_long
id|baddr
op_assign
id|scsi_sg_dma_address
c_func
(paren
op_amp
id|scatter
(braket
id|segment
)braket
)paren
suffix:semicolon
r_int
r_int
id|len
op_assign
id|scsi_sg_dma_len
c_func
(paren
op_amp
id|scatter
(braket
id|segment
)braket
)paren
suffix:semicolon
id|data
(braket
id|segment
)braket
dot
id|addr
op_assign
id|cpu_to_scr
c_func
(paren
id|baddr
)paren
suffix:semicolon
id|data
(braket
id|segment
)braket
dot
id|size
op_assign
id|cpu_to_scr
c_func
(paren
id|len
)paren
suffix:semicolon
id|cp-&gt;data_len
op_add_assign
id|len
suffix:semicolon
op_increment
id|segment
suffix:semicolon
)brace
)brace
r_else
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|segment
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Test the pci bus snoop logic :-(&n;**&n;**&t;Has to be called with interrupts disabled.&n;**&n;**&n;**==========================================================&n;*/
macro_line|#ifndef NCR_IOMAPPED
DECL|function|ncr_regtest
r_static
r_int
id|__init
id|ncr_regtest
(paren
r_struct
id|ncb
op_star
id|np
)paren
(brace
r_register
r_volatile
id|u_int32
id|data
suffix:semicolon
multiline_comment|/*&n;&t;**&t;ncr registers may NOT be cached.&n;&t;**&t;write 0xffffffff to a read only register area,&n;&t;**&t;and try to read it back.&n;&t;*/
id|data
op_assign
l_int|0xffffffff
suffix:semicolon
id|OUTL_OFF
c_func
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_dstat
)paren
comma
id|data
)paren
suffix:semicolon
id|data
op_assign
id|INL_OFF
c_func
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_dstat
)paren
)paren
suffix:semicolon
macro_line|#if 1
r_if
c_cond
(paren
id|data
op_eq
l_int|0xffffffff
)paren
(brace
macro_line|#else
r_if
c_cond
(paren
(paren
id|data
op_amp
l_int|0xe2f0fffd
)paren
op_ne
l_int|0x02000080
)paren
(brace
macro_line|#endif
id|printk
(paren
l_string|&quot;CACHE TEST FAILED: reg dstat-sstat2 readback %x.&bslash;n&quot;
comma
(paren
r_int
)paren
id|data
)paren
suffix:semicolon
r_return
(paren
l_int|0x10
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|ncr_snooptest
r_static
r_int
id|__init
id|ncr_snooptest
(paren
r_struct
id|ncb
op_star
id|np
)paren
(brace
id|u_int32
id|ncr_rd
comma
id|ncr_wr
comma
id|ncr_bk
comma
id|host_rd
comma
id|host_wr
comma
id|pc
suffix:semicolon
r_int
id|i
comma
id|err
op_assign
l_int|0
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
r_if
c_cond
(paren
id|np-&gt;reg
)paren
(brace
id|err
op_or_assign
id|ncr_regtest
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
(paren
id|err
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**&t;init&n;&t;*/
id|pc
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|snooptest
)paren
suffix:semicolon
id|host_wr
op_assign
l_int|1
suffix:semicolon
id|ncr_wr
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set memory and register.&n;&t;*/
id|np-&gt;ncr_cache
op_assign
id|cpu_to_scr
c_func
(paren
id|host_wr
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_temp
comma
id|ncr_wr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Start script (exchange values)&n;&t;*/
id|OUTL
(paren
id|nc_dsp
comma
id|pc
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Wait &squot;til done (with timeout)&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NCR_SNOOP_TIMEOUT
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_istat
)paren
op_amp
(paren
id|INTF
op_or
id|SIP
op_or
id|DIP
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Save termination position.&n;&t;*/
id|pc
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Read memory and register.&n;&t;*/
id|host_rd
op_assign
id|scr_to_cpu
c_func
(paren
id|np-&gt;ncr_cache
)paren
suffix:semicolon
id|ncr_rd
op_assign
id|INL
(paren
id|nc_scratcha
)paren
suffix:semicolon
id|ncr_bk
op_assign
id|INL
(paren
id|nc_temp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Reset ncr chip&n;&t;*/
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|100
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;check for timeout&n;&t;*/
r_if
c_cond
(paren
id|i
op_ge
id|NCR_SNOOP_TIMEOUT
)paren
(brace
id|printk
(paren
l_string|&quot;CACHE TEST FAILED: timeout.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0x20
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Check termination position.&n;&t;*/
r_if
c_cond
(paren
id|pc
op_ne
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|snoopend
)paren
op_plus
l_int|8
)paren
(brace
id|printk
(paren
l_string|&quot;CACHE TEST FAILED: script execution failed.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;start=%08lx, pc=%08lx, end=%08lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|snooptest
)paren
comma
(paren
id|u_long
)paren
id|pc
comma
(paren
id|u_long
)paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|snoopend
)paren
op_plus
l_int|8
)paren
suffix:semicolon
r_return
(paren
l_int|0x40
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Show results.&n;&t;*/
r_if
c_cond
(paren
id|host_wr
op_ne
id|ncr_rd
)paren
(brace
id|printk
(paren
l_string|&quot;CACHE TEST FAILED: host wrote %d, ncr read %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|host_wr
comma
(paren
r_int
)paren
id|ncr_rd
)paren
suffix:semicolon
id|err
op_or_assign
l_int|1
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|host_rd
op_ne
id|ncr_wr
)paren
(brace
id|printk
(paren
l_string|&quot;CACHE TEST FAILED: ncr wrote %d, host read %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|ncr_wr
comma
(paren
r_int
)paren
id|host_rd
)paren
suffix:semicolon
id|err
op_or_assign
l_int|2
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|ncr_bk
op_ne
id|ncr_wr
)paren
(brace
id|printk
(paren
l_string|&quot;CACHE TEST FAILED: ncr wrote %d, read back %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|ncr_wr
comma
(paren
r_int
)paren
id|ncr_bk
)paren
suffix:semicolon
id|err
op_or_assign
l_int|4
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Profiling the drivers and targets performance.&n;**&n;**&n;**==========================================================&n;*/
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
multiline_comment|/*&n;**&t;Compute the difference in jiffies ticks.&n;*/
DECL|macro|ncr_delta
mdefine_line|#define ncr_delta(from, to) &bslash;&n;&t;( ((to) &amp;&amp; (from))? (to) - (from) : -1 )
DECL|macro|PROFILE
mdefine_line|#define PROFILE  cp-&gt;phys.header.stamp
DECL|function|ncb_profile
r_static
r_void
id|ncb_profile
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
r_int
id|co
comma
id|st
comma
id|en
comma
id|di
comma
id|re
comma
id|post
comma
id|work
comma
id|disc
suffix:semicolon
id|u_int
id|diff
suffix:semicolon
id|PROFILE.end
op_assign
id|jiffies
suffix:semicolon
id|st
op_assign
id|ncr_delta
(paren
id|PROFILE.start
comma
id|PROFILE.status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
OL
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* status  not reached  */
id|co
op_assign
id|ncr_delta
(paren
id|PROFILE.start
comma
id|PROFILE.command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|co
OL
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* command not executed */
id|en
op_assign
id|ncr_delta
(paren
id|PROFILE.start
comma
id|PROFILE.end
)paren
comma
id|di
op_assign
id|ncr_delta
(paren
id|PROFILE.start
comma
id|PROFILE.disconnect
)paren
comma
id|re
op_assign
id|ncr_delta
(paren
id|PROFILE.start
comma
id|PROFILE.reselect
)paren
suffix:semicolon
id|post
op_assign
id|en
op_minus
id|st
suffix:semicolon
multiline_comment|/*&n;&t;**&t;@PROFILE@  Disconnect time invalid if multiple disconnects&n;&t;*/
r_if
c_cond
(paren
id|di
op_ge
l_int|0
)paren
id|disc
op_assign
id|re
op_minus
id|di
suffix:semicolon
r_else
id|disc
op_assign
l_int|0
suffix:semicolon
id|work
op_assign
(paren
id|st
op_minus
id|co
)paren
op_minus
id|disc
suffix:semicolon
id|diff
op_assign
(paren
id|scr_to_cpu
c_func
(paren
id|np-&gt;disc_phys
)paren
op_minus
id|np-&gt;disc_ref
)paren
op_amp
l_int|0xff
suffix:semicolon
id|np-&gt;disc_ref
op_add_assign
id|diff
suffix:semicolon
id|np-&gt;profile.num_trans
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cmd
)paren
(brace
id|np-&gt;profile.num_kbytes
op_add_assign
(paren
id|cp-&gt;cmd-&gt;request_bufflen
op_rshift
l_int|10
)paren
suffix:semicolon
id|np-&gt;profile.rest_bytes
op_add_assign
(paren
id|cp-&gt;cmd-&gt;request_bufflen
op_amp
(paren
l_int|0x400
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;profile.rest_bytes
op_ge
l_int|0x400
)paren
(brace
op_increment
id|np-&gt;profile.num_kbytes
suffix:semicolon
id|np-&gt;profile.rest_bytes
op_sub_assign
l_int|0x400
suffix:semicolon
)brace
)brace
id|np-&gt;profile.num_disc
op_add_assign
id|diff
suffix:semicolon
id|np-&gt;profile.ms_setup
op_add_assign
id|co
suffix:semicolon
id|np-&gt;profile.ms_data
op_add_assign
id|work
suffix:semicolon
id|np-&gt;profile.ms_disc
op_add_assign
id|disc
suffix:semicolon
id|np-&gt;profile.ms_post
op_add_assign
id|post
suffix:semicolon
)brace
DECL|macro|PROFILE
macro_line|#undef PROFILE
macro_line|#endif /* SCSI_NCR_PROFILE_SUPPORT */
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Device lookup.&n;**&n;**&t;@GENSCSI@ should be integrated to scsiconf.c&n;**&n;**&n;**==========================================================&n;*/
DECL|struct|table_entry
r_struct
id|table_entry
(brace
DECL|member|manufacturer
r_char
op_star
id|manufacturer
suffix:semicolon
DECL|member|model
r_char
op_star
id|model
suffix:semicolon
DECL|member|version
r_char
op_star
id|version
suffix:semicolon
DECL|member|info
id|u_long
id|info
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|device_tab
r_static
r_struct
id|table_entry
id|device_tab
(braket
)braket
op_assign
(brace
macro_line|#if 0
(brace
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
id|QUIRK_NOMSG
)brace
comma
macro_line|#endif
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;SDT-5000&quot;
comma
l_string|&quot;3.17&quot;
comma
id|QUIRK_NOMSG
)brace
comma
(brace
l_string|&quot;WangDAT&quot;
comma
l_string|&quot;Model 2600&quot;
comma
l_string|&quot;01.7&quot;
comma
id|QUIRK_NOMSG
)brace
comma
(brace
l_string|&quot;WangDAT&quot;
comma
l_string|&quot;Model 3200&quot;
comma
l_string|&quot;02.2&quot;
comma
id|QUIRK_NOMSG
)brace
comma
(brace
l_string|&quot;WangDAT&quot;
comma
l_string|&quot;Model 1300&quot;
comma
l_string|&quot;02.4&quot;
comma
id|QUIRK_NOMSG
)brace
comma
(brace
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_int|0
)brace
multiline_comment|/* catch all: must be last entry. */
)brace
suffix:semicolon
DECL|function|ncr_lookup
r_static
id|u_long
id|ncr_lookup
c_func
(paren
r_char
op_star
id|id
)paren
(brace
r_struct
id|table_entry
op_star
id|p
op_assign
id|device_tab
suffix:semicolon
r_char
op_star
id|d
comma
op_star
id|r
comma
id|c
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|p
op_increment
)paren
(brace
id|d
op_assign
id|id
op_plus
l_int|8
suffix:semicolon
id|r
op_assign
id|p-&gt;manufacturer
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|r
op_increment
)paren
)paren
r_if
c_cond
(paren
id|c
op_ne
op_star
id|d
op_increment
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
r_continue
suffix:semicolon
id|d
op_assign
id|id
op_plus
l_int|16
suffix:semicolon
id|r
op_assign
id|p-&gt;model
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|r
op_increment
)paren
)paren
r_if
c_cond
(paren
id|c
op_ne
op_star
id|d
op_increment
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
r_continue
suffix:semicolon
id|d
op_assign
id|id
op_plus
l_int|32
suffix:semicolon
id|r
op_assign
id|p-&gt;version
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|r
op_increment
)paren
)paren
r_if
c_cond
(paren
id|c
op_ne
op_star
id|d
op_increment
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
r_continue
suffix:semicolon
r_return
(paren
id|p-&gt;info
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Determine the ncr&squot;s clock frequency.&n;**&t;This is essential for the negotiation&n;**&t;of the synchronous transfer rate.&n;**&n;**==========================================================&n;**&n;**&t;Note: we have to return the correct value.&n;**&t;THERE IS NO SAVE DEFAULT VALUE.&n;**&n;**&t;Most NCR/SYMBIOS boards are delivered with a 40 Mhz clock.&n;**&t;53C860 and 53C875 rev. 1 support fast20 transfers but &n;**&t;do not have a clock doubler and so are provided with a &n;**&t;80 MHz clock. All other fast20 boards incorporate a doubler &n;**&t;and so should be delivered with a 40 MHz clock.&n;**&t;The future fast40 chips (895/895) use a 40 Mhz base clock &n;**&t;and provide a clock quadrupler (160 Mhz). The code below &n;**&t;tries to deal as cleverly as possible with all this stuff.&n;**&n;**----------------------------------------------------------&n;*/
multiline_comment|/*&n; *&t;Select NCR SCSI clock frequency&n; */
DECL|function|ncr_selectclock
r_static
r_void
id|ncr_selectclock
c_func
(paren
id|ncb_p
id|np
comma
id|u_char
id|scntl3
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;multiplier
OL
l_int|2
)paren
(brace
id|OUTB
c_func
(paren
id|nc_scntl3
comma
id|scntl3
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
id|printk
(paren
l_string|&quot;%s: enabling clock multiplier&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest1
comma
id|DBLEN
)paren
suffix:semicolon
multiline_comment|/* Enable clock multiplier&t;&t;  */
r_if
c_cond
(paren
id|np-&gt;multiplier
OG
l_int|2
)paren
(brace
multiline_comment|/* Poll bit 5 of stest4 for quadrupler */
r_int
id|i
op_assign
l_int|20
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|INB
c_func
(paren
id|nc_stest4
)paren
op_amp
id|LCKFRQ
)paren
op_logical_and
op_decrement
id|i
OG
l_int|0
)paren
id|UDELAY
(paren
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;%s: the chip cannot lock the frequency&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Wait 20 micro-seconds for doubler&t;*/
id|UDELAY
(paren
l_int|20
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest3
comma
id|HSC
)paren
suffix:semicolon
multiline_comment|/* Halt the scsi clock&t;&t;*/
id|OUTB
c_func
(paren
id|nc_scntl3
comma
id|scntl3
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest1
comma
(paren
id|DBLEN
op_or
id|DBLSEL
)paren
)paren
suffix:semicolon
multiline_comment|/* Select clock multiplier&t;*/
id|OUTB
c_func
(paren
id|nc_stest3
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* Restart scsi clock &t;&t;*/
)brace
multiline_comment|/*&n; *&t;calculate NCR SCSI clock frequency (in KHz)&n; */
DECL|function|ncrgetfreq
r_static
r_int
id|__init
id|ncrgetfreq
(paren
id|ncb_p
id|np
comma
r_int
id|gen
)paren
(brace
r_int
id|ms
op_assign
l_int|0
suffix:semicolon
r_char
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Measure GEN timer delay in order &n;&t; * to calculate SCSI clock frequency&n;&t; *&n;&t; * This code will never execute too&n;&t; * many loop iterations (if DELAY is &n;&t; * reasonably correct). It could get&n;&t; * too low a delay (too high a freq.)&n;&t; * if the CPU is slow executing the &n;&t; * loop for some reason (an NMI, for&n;&t; * example). For this reason we will&n;&t; * if multiple measurements are to be &n;&t; * performed trust the higher delay &n;&t; * (lower frequency returned).&n;&t; */
id|OUTB
(paren
id|nc_stest1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* make sure clock doubler is OFF */
id|OUTW
(paren
id|nc_sien
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* mask all scsi interrupts */
(paren
r_void
)paren
id|INW
(paren
id|nc_sist
)paren
suffix:semicolon
multiline_comment|/* clear pending scsi interrupt */
id|OUTB
(paren
id|nc_dien
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* mask all dma interrupts */
(paren
r_void
)paren
id|INW
(paren
id|nc_sist
)paren
suffix:semicolon
multiline_comment|/* another one, just to be sure :) */
id|OUTB
(paren
id|nc_scntl3
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* set pre-scaler to divide by 3 */
id|OUTB
(paren
id|nc_stime1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* disable general purpose timer */
id|OUTB
(paren
id|nc_stime1
comma
id|gen
)paren
suffix:semicolon
multiline_comment|/* set to nominal delay of 1&lt;&lt;gen * 125us */
r_while
c_loop
(paren
op_logical_neg
(paren
id|INW
c_func
(paren
id|nc_sist
)paren
op_amp
id|GEN
)paren
op_logical_and
id|ms
op_increment
OL
l_int|100000
)paren
(brace
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|10
suffix:semicolon
id|count
op_increment
)paren
id|UDELAY
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* count ms */
)brace
id|OUTB
(paren
id|nc_stime1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* disable general purpose timer */
multiline_comment|/*&n; &t; * set prescaler to divide by whatever 0 means&n; &t; * 0 ought to choose divide by 2, but appears&n; &t; * to set divide by 3.5 mode in my 53c810 ...&n; &t; */
id|OUTB
(paren
id|nc_scntl3
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
id|printk
(paren
l_string|&quot;%s: Delay (GEN=%d): %u msec&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|gen
comma
id|ms
)paren
suffix:semicolon
multiline_comment|/*&n; &t; * adjust for prescaler, and convert into KHz &n;  &t; */
r_return
id|ms
ques
c_cond
(paren
(paren
l_int|1
op_lshift
id|gen
)paren
op_star
l_int|4340
)paren
op_div
id|ms
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get/probe NCR SCSI clock frequency&n; */
DECL|function|ncr_getclock
r_static
r_void
id|__init
id|ncr_getclock
(paren
id|ncb_p
id|np
comma
r_int
id|mult
)paren
(brace
r_int
r_char
id|scntl3
op_assign
id|INB
c_func
(paren
id|nc_scntl3
)paren
suffix:semicolon
r_int
r_char
id|stest1
op_assign
id|INB
c_func
(paren
id|nc_stest1
)paren
suffix:semicolon
r_int
id|f1
suffix:semicolon
id|np-&gt;multiplier
op_assign
l_int|1
suffix:semicolon
id|f1
op_assign
l_int|40000
suffix:semicolon
multiline_comment|/*&n;&t;**&t;True with 875 or 895 with clock multiplier selected&n;&t;*/
r_if
c_cond
(paren
id|mult
OG
l_int|1
op_logical_and
(paren
id|stest1
op_amp
(paren
id|DBLEN
op_plus
id|DBLSEL
)paren
)paren
op_eq
id|DBLEN
op_plus
id|DBLSEL
)paren
(brace
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
id|printk
(paren
l_string|&quot;%s: clock multiplier found&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;multiplier
op_assign
id|mult
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;If multiplier not found or scntl3 not 7,5,3,&n;&t;**&t;reset chip and get frequency from general purpose timer.&n;&t;**&t;Otherwise trust scntl3 BIOS setting.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;multiplier
op_ne
id|mult
op_logical_or
(paren
id|scntl3
op_amp
l_int|7
)paren
OL
l_int|3
op_logical_or
op_logical_neg
(paren
id|scntl3
op_amp
l_int|1
)paren
)paren
(brace
r_int
id|f2
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|5
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncrgetfreq
(paren
id|np
comma
l_int|11
)paren
suffix:semicolon
multiline_comment|/* throw away first result */
id|f1
op_assign
id|ncrgetfreq
(paren
id|np
comma
l_int|11
)paren
suffix:semicolon
id|f2
op_assign
id|ncrgetfreq
(paren
id|np
comma
l_int|11
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
id|printk
(paren
l_string|&quot;%s: NCR clock is %uKHz, %uKHz&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|f1
comma
id|f2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f1
OG
id|f2
)paren
id|f1
op_assign
id|f2
suffix:semicolon
multiline_comment|/* trust lower result&t;*/
r_if
c_cond
(paren
id|f1
OL
l_int|45000
)paren
id|f1
op_assign
l_int|40000
suffix:semicolon
r_else
r_if
c_cond
(paren
id|f1
OL
l_int|55000
)paren
id|f1
op_assign
l_int|50000
suffix:semicolon
r_else
id|f1
op_assign
l_int|80000
suffix:semicolon
r_if
c_cond
(paren
id|f1
template_param
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
id|printk
(paren
l_string|&quot;%s: clock multiplier assumed&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;multiplier
op_assign
id|mult
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|scntl3
op_amp
l_int|7
)paren
op_eq
l_int|3
)paren
id|f1
op_assign
l_int|40000
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|scntl3
op_amp
l_int|7
)paren
op_eq
l_int|5
)paren
id|f1
op_assign
l_int|80000
suffix:semicolon
r_else
id|f1
op_assign
l_int|160000
suffix:semicolon
id|f1
op_div_assign
id|np-&gt;multiplier
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Compute controller synchronous parameters.&n;&t;*/
id|f1
op_mul_assign
id|np-&gt;multiplier
suffix:semicolon
id|np-&gt;clock_khz
op_assign
id|f1
suffix:semicolon
)brace
multiline_comment|/*===================== LINUX ENTRY POINTS SECTION ==========================*/
multiline_comment|/*&n;**   Linux select queue depths function&n;*/
DECL|function|ncr53c8xx_select_queue_depths
r_static
r_void
id|ncr53c8xx_select_queue_depths
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|scsi_device
op_star
id|devlist
)paren
(brace
r_struct
id|scsi_device
op_star
id|device
suffix:semicolon
r_for
c_loop
(paren
id|device
op_assign
id|devlist
suffix:semicolon
id|device
suffix:semicolon
id|device
op_assign
id|device-&gt;next
)paren
(brace
id|ncb_p
id|np
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
r_int
id|numtags
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;host
op_ne
id|host
)paren
r_continue
suffix:semicolon
id|np
op_assign
(paren
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
)paren
op_member_access_from_pointer
id|ncb
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|device-&gt;id
)braket
suffix:semicolon
id|lp
op_assign
id|tp-&gt;lp
(braket
id|device-&gt;lun
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Select queue depth from driver setup.&n;&t;&t;**&t;Donnot use more than configured by user.&n;&t;&t;**&t;Use at least 2.&n;&t;&t;**&t;Donnot use more than our maximum.&n;&t;&t;*/
id|numtags
op_assign
id|device_queue_depth
c_func
(paren
id|np-&gt;unit
comma
id|device-&gt;id
comma
id|device-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|numtags
OG
id|tp-&gt;usrtags
)paren
id|numtags
op_assign
id|tp-&gt;usrtags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;tagged_supported
)paren
id|numtags
op_assign
l_int|1
suffix:semicolon
id|device-&gt;queue_depth
op_assign
id|numtags
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;queue_depth
OL
l_int|2
)paren
id|device-&gt;queue_depth
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;queue_depth
OG
id|MAX_TAGS
)paren
id|device-&gt;queue_depth
op_assign
id|MAX_TAGS
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Since the queue depth is not tunable under Linux,&n;&t;&t;**&t;we need to know this value in order not to &n;&t;&t;**&t;announce stupid things to user.&n;&t;&t;*/
r_if
c_cond
(paren
id|lp
)paren
(brace
id|lp-&gt;numtags
op_assign
id|lp-&gt;maxtags
op_assign
id|numtags
suffix:semicolon
id|lp-&gt;scdev_depth
op_assign
id|device-&gt;queue_depth
suffix:semicolon
)brace
id|ncr_setup_tags
(paren
id|np
comma
id|device-&gt;id
comma
id|device-&gt;lun
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx_select_queue_depth: host=%d, id=%d, lun=%d, depth=%d&bslash;n&quot;
comma
id|np-&gt;unit
comma
id|device-&gt;id
comma
id|device-&gt;lun
comma
id|device-&gt;queue_depth
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*&n;**   Linux entry point of queuecommand() function&n;*/
DECL|function|ncr53c8xx_queue_command
r_int
id|ncr53c8xx_queue_command
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
id|ncb_p
id|np
op_assign
(paren
(paren
r_struct
id|host_data
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
)paren
op_member_access_from_pointer
id|ncb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|sts
suffix:semicolon
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx_queue_command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef SCSI_NCR_DYNAMIC_DMA_MAPPING
id|cmd-&gt;__data_mapped
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;__data_mapping
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sts
op_assign
id|ncr_queue_command
c_func
(paren
id|np
comma
id|cmd
)paren
)paren
op_ne
id|DID_OK
)paren
(brace
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|sts
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : command not queued - result=%d&bslash;n&quot;
comma
id|sts
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef DEBUG_NCR53C8XX
r_else
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : command successfully queued&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
op_ne
id|DID_OK
)paren
(brace
id|unmap_scsi_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
r_return
id|sts
suffix:semicolon
)brace
multiline_comment|/*&n;**   Linux entry point of the interrupt handler.&n;**   Since linux versions &gt; 1.3.70, we trust the kernel for &n;**   passing the internal host descriptor as &squot;dev_id&squot;.&n;**   Otherwise, we scan the host list and call the interrupt &n;**   routine for each host that uses this IRQ.&n;*/
DECL|function|ncr53c8xx_intr
r_static
r_void
id|ncr53c8xx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ncb_p
id|np
op_assign
(paren
id|ncb_p
)paren
id|dev_id
suffix:semicolon
id|Scsi_Cmnd
op_star
id|done_list
suffix:semicolon
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : interrupt received&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;[&quot;
)paren
suffix:semicolon
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_exception
c_func
(paren
id|np
)paren
suffix:semicolon
id|done_list
op_assign
id|np-&gt;done_list
suffix:semicolon
id|np-&gt;done_list
op_assign
l_int|0
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done_list
)paren
(brace
id|NCR_LOCK_SCSI_DONE
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_flush_done_cmds
c_func
(paren
id|done_list
)paren
suffix:semicolon
id|NCR_UNLOCK_SCSI_DONE
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;**   Linux entry point of the timer handler&n;*/
DECL|function|ncr53c8xx_timeout
r_static
r_void
id|ncr53c8xx_timeout
c_func
(paren
r_int
r_int
id|npref
)paren
(brace
id|ncb_p
id|np
op_assign
(paren
id|ncb_p
)paren
id|npref
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|Scsi_Cmnd
op_star
id|done_list
suffix:semicolon
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_timeout
c_func
(paren
(paren
id|ncb_p
)paren
id|np
)paren
suffix:semicolon
id|done_list
op_assign
id|np-&gt;done_list
suffix:semicolon
id|np-&gt;done_list
op_assign
l_int|0
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done_list
)paren
(brace
id|NCR_LOCK_SCSI_DONE
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_flush_done_cmds
c_func
(paren
id|done_list
)paren
suffix:semicolon
id|NCR_UNLOCK_SCSI_DONE
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;**   Linux entry point of reset() function&n;*/
macro_line|#if defined SCSI_RESET_SYNCHRONOUS &amp;&amp; defined SCSI_RESET_ASYNCHRONOUS
DECL|function|ncr53c8xx_reset
r_int
id|ncr53c8xx_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_int
id|reset_flags
)paren
macro_line|#else
r_int
id|ncr53c8xx_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
macro_line|#endif
(brace
id|ncb_p
id|np
op_assign
(paren
(paren
r_struct
id|host_data
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
)paren
op_member_access_from_pointer
id|ncb
suffix:semicolon
r_int
id|sts
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|Scsi_Cmnd
op_star
id|done_list
suffix:semicolon
macro_line|#if defined SCSI_RESET_SYNCHRONOUS &amp;&amp; defined SCSI_RESET_ASYNCHRONOUS
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx_reset: pid=%lu reset_flags=%x serial_number=%ld serial_number_at_timeout=%ld&bslash;n&quot;
comma
id|cmd-&gt;pid
comma
id|reset_flags
comma
id|cmd-&gt;serial_number
comma
id|cmd-&gt;serial_number_at_timeout
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx_reset: command pid %lu&bslash;n&quot;
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
macro_line|#endif
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have to just ignore reset requests in some situations.&n;&t; */
macro_line|#if defined SCSI_RESET_NOT_RUNNING
r_if
c_cond
(paren
id|cmd-&gt;serial_number
op_ne
id|cmd-&gt;serial_number_at_timeout
)paren
(brace
id|sts
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * If the mid-level driver told us reset is synchronous, it seems &n;&t; * that we must call the done() callback for the involved command, &n;&t; * even if this command was not queued to the low-level driver, &n;&t; * before returning SCSI_RESET_SUCCESS.&n;&t; */
macro_line|#if defined SCSI_RESET_SYNCHRONOUS &amp;&amp; defined SCSI_RESET_ASYNCHRONOUS
id|sts
op_assign
id|ncr_reset_bus
c_func
(paren
id|np
comma
id|cmd
comma
(paren
id|reset_flags
op_amp
(paren
id|SCSI_RESET_SYNCHRONOUS
op_or
id|SCSI_RESET_ASYNCHRONOUS
)paren
)paren
op_eq
id|SCSI_RESET_SYNCHRONOUS
)paren
suffix:semicolon
macro_line|#else
id|sts
op_assign
id|ncr_reset_bus
c_func
(paren
id|np
comma
id|cmd
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Since we always reset the controller, when we return success, &n;&t; * we add this information to the return code.&n;&t; */
macro_line|#if defined SCSI_RESET_HOST_RESET
r_if
c_cond
(paren
id|sts
op_eq
id|SCSI_RESET_SUCCESS
)paren
id|sts
op_or_assign
id|SCSI_RESET_HOST_RESET
suffix:semicolon
macro_line|#endif
id|out
suffix:colon
id|done_list
op_assign
id|np-&gt;done_list
suffix:semicolon
id|np-&gt;done_list
op_assign
l_int|0
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_flush_done_cmds
c_func
(paren
id|done_list
)paren
suffix:semicolon
r_return
id|sts
suffix:semicolon
)brace
multiline_comment|/*&n;**   Linux entry point of abort() function&n;*/
DECL|function|ncr53c8xx_abort
r_int
id|ncr53c8xx_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|ncb_p
id|np
op_assign
(paren
(paren
r_struct
id|host_data
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
)paren
op_member_access_from_pointer
id|ncb
suffix:semicolon
r_int
id|sts
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|Scsi_Cmnd
op_star
id|done_list
suffix:semicolon
macro_line|#if defined SCSI_RESET_SYNCHRONOUS &amp;&amp; defined SCSI_RESET_ASYNCHRONOUS
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx_abort: pid=%lu serial_number=%ld serial_number_at_timeout=%ld&bslash;n&quot;
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;serial_number
comma
id|cmd-&gt;serial_number_at_timeout
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx_abort: command pid %lu&bslash;n&quot;
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
macro_line|#endif
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
macro_line|#if defined SCSI_RESET_SYNCHRONOUS &amp;&amp; defined SCSI_RESET_ASYNCHRONOUS
multiline_comment|/*&n;&t; * We have to just ignore abort requests in some situations.&n;&t; */
r_if
c_cond
(paren
id|cmd-&gt;serial_number
op_ne
id|cmd-&gt;serial_number_at_timeout
)paren
(brace
id|sts
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#endif
id|sts
op_assign
id|ncr_abort_command
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
id|out
suffix:colon
id|done_list
op_assign
id|np-&gt;done_list
suffix:semicolon
id|np-&gt;done_list
op_assign
l_int|0
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_flush_done_cmds
c_func
(paren
id|done_list
)paren
suffix:semicolon
r_return
id|sts
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|ncr53c8xx_release
r_int
id|ncr53c8xx_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : release&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|ncr_detach
c_func
(paren
(paren
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
)paren
op_member_access_from_pointer
id|ncb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;**&t;Scsi command waiting list management.&n;**&n;**&t;It may happen that we cannot insert a scsi command into the start queue,&n;**&t;in the following circumstances.&n;** &t;&t;Too few preallocated ccb(s), &n;**&t;&t;maxtags &lt; cmd_per_lun of the Linux host control block,&n;**&t;&t;etc...&n;**&t;Such scsi commands are inserted into a waiting list.&n;**&t;When a scsi command complete, we try to requeue the commands of the&n;**&t;waiting list.&n;*/
DECL|macro|next_wcmd
mdefine_line|#define next_wcmd host_scribble
DECL|function|insert_into_waiting_list
r_static
r_void
id|insert_into_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|Scsi_Cmnd
op_star
id|wcmd
suffix:semicolon
macro_line|#ifdef DEBUG_WAITING_LIST
id|printk
c_func
(paren
l_string|&quot;%s: cmd %lx inserted into waiting list&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|cmd-&gt;next_wcmd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|wcmd
op_assign
id|np-&gt;waiting_list
)paren
)paren
id|np-&gt;waiting_list
op_assign
id|cmd
suffix:semicolon
r_else
(brace
r_while
c_loop
(paren
(paren
id|wcmd-&gt;next_wcmd
)paren
op_ne
l_int|0
)paren
id|wcmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|wcmd-&gt;next_wcmd
suffix:semicolon
id|wcmd-&gt;next_wcmd
op_assign
(paren
r_char
op_star
)paren
id|cmd
suffix:semicolon
)brace
)brace
DECL|function|retrieve_from_waiting_list
r_static
id|Scsi_Cmnd
op_star
id|retrieve_from_waiting_list
c_func
(paren
r_int
id|to_remove
comma
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|Scsi_Cmnd
op_star
op_star
id|pcmd
op_assign
op_amp
id|np-&gt;waiting_list
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pcmd
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_eq
op_star
id|pcmd
)paren
(brace
r_if
c_cond
(paren
id|to_remove
)paren
(brace
op_star
id|pcmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;next_wcmd
suffix:semicolon
id|cmd-&gt;next_wcmd
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_WAITING_LIST
id|printk
c_func
(paren
l_string|&quot;%s: cmd %lx retrieved from waiting list&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|cmd
)paren
suffix:semicolon
macro_line|#endif
r_return
id|cmd
suffix:semicolon
)brace
id|pcmd
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
op_star
id|pcmd
)paren
op_member_access_from_pointer
id|next_wcmd
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|process_waiting_list
r_static
r_void
id|process_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|sts
)paren
(brace
id|Scsi_Cmnd
op_star
id|waiting_list
comma
op_star
id|wcmd
suffix:semicolon
id|waiting_list
op_assign
id|np-&gt;waiting_list
suffix:semicolon
id|np-&gt;waiting_list
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_WAITING_LIST
r_if
c_cond
(paren
id|waiting_list
)paren
id|printk
c_func
(paren
l_string|&quot;%s: waiting_list=%lx processing sts=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|waiting_list
comma
id|sts
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
(paren
id|wcmd
op_assign
id|waiting_list
)paren
op_ne
l_int|0
)paren
(brace
id|waiting_list
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|wcmd-&gt;next_wcmd
suffix:semicolon
id|wcmd-&gt;next_wcmd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sts
op_eq
id|DID_OK
)paren
(brace
macro_line|#ifdef DEBUG_WAITING_LIST
id|printk
c_func
(paren
l_string|&quot;%s: cmd %lx trying to requeue&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|wcmd
)paren
suffix:semicolon
macro_line|#endif
id|sts
op_assign
id|ncr_queue_command
c_func
(paren
id|np
comma
id|wcmd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sts
op_ne
id|DID_OK
)paren
(brace
macro_line|#ifdef DEBUG_WAITING_LIST
id|printk
c_func
(paren
l_string|&quot;%s: cmd %lx done forced sts=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|wcmd
comma
id|sts
)paren
suffix:semicolon
macro_line|#endif
id|wcmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|sts
comma
l_int|0
)paren
suffix:semicolon
id|ncr_queue_done_cmd
c_func
(paren
id|np
comma
id|wcmd
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|macro|next_wcmd
macro_line|#undef next_wcmd
macro_line|#ifdef SCSI_NCR_PROC_INFO_SUPPORT
multiline_comment|/*=========================================================================&n;**&t;Proc file system stuff&n;**&n;**&t;A read operation returns profile information.&n;**&t;A write operation is a control command.&n;**&t;The string is parsed in the driver code and the command is passed &n;**&t;to the ncr_usercmd() function.&n;**=========================================================================&n;*/
macro_line|#ifdef SCSI_NCR_USER_COMMAND_SUPPORT
DECL|macro|is_digit
mdefine_line|#define is_digit(c)&t;((c) &gt;= &squot;0&squot; &amp;&amp; (c) &lt;= &squot;9&squot;)
DECL|macro|digit_to_bin
mdefine_line|#define digit_to_bin(c)&t;((c) - &squot;0&squot;)
DECL|macro|is_space
mdefine_line|#define is_space(c)&t;((c) == &squot; &squot; || (c) == &squot;&bslash;t&squot;)
DECL|function|skip_spaces
r_static
r_int
id|skip_spaces
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
)paren
(brace
r_int
id|cnt
comma
id|c
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
id|len
suffix:semicolon
id|cnt
OG
l_int|0
op_logical_and
(paren
id|c
op_assign
op_star
id|ptr
op_increment
)paren
op_logical_and
id|is_space
c_func
(paren
id|c
)paren
suffix:semicolon
id|cnt
op_decrement
)paren
suffix:semicolon
r_return
(paren
id|len
op_minus
id|cnt
)paren
suffix:semicolon
)brace
DECL|function|get_int_arg
r_static
r_int
id|get_int_arg
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
comma
id|u_long
op_star
id|pv
)paren
(brace
r_int
id|cnt
comma
id|c
suffix:semicolon
id|u_long
id|v
suffix:semicolon
r_for
c_loop
(paren
id|v
op_assign
l_int|0
comma
id|cnt
op_assign
id|len
suffix:semicolon
id|cnt
OG
l_int|0
op_logical_and
(paren
id|c
op_assign
op_star
id|ptr
op_increment
)paren
op_logical_and
id|is_digit
c_func
(paren
id|c
)paren
suffix:semicolon
id|cnt
op_decrement
)paren
(brace
id|v
op_assign
(paren
id|v
op_star
l_int|10
)paren
op_plus
id|digit_to_bin
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pv
)paren
op_star
id|pv
op_assign
id|v
suffix:semicolon
r_return
(paren
id|len
op_minus
id|cnt
)paren
suffix:semicolon
)brace
DECL|function|is_keyword
r_static
r_int
id|is_keyword
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
comma
r_char
op_star
id|verb
)paren
(brace
r_int
id|verb_len
op_assign
id|strlen
c_func
(paren
id|verb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|strlen
c_func
(paren
id|verb
)paren
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|verb
comma
id|ptr
comma
id|verb_len
)paren
)paren
r_return
id|verb_len
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SKIP_SPACES
mdefine_line|#define SKIP_SPACES(min_spaces)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if ((arg_len = skip_spaces(ptr, len)) &lt; (min_spaces))&t;&t;&bslash;&n;&t;&t;return -EINVAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ptr += arg_len; len -= arg_len;
DECL|macro|GET_INT_ARG
mdefine_line|#define GET_INT_ARG(v)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (!(arg_len = get_int_arg(ptr, len, &amp;(v))))&t;&t;&t;&bslash;&n;&t;&t;return -EINVAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ptr += arg_len; len -= arg_len;
multiline_comment|/*&n;**&t;Parse a control command&n;*/
DECL|function|ncr_user_command
r_static
r_int
id|ncr_user_command
c_func
(paren
id|ncb_p
id|np
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_char
op_star
id|ptr
op_assign
id|buffer
suffix:semicolon
r_int
id|len
op_assign
id|length
suffix:semicolon
r_struct
id|usrcmd
op_star
id|uc
op_assign
op_amp
id|np-&gt;user
suffix:semicolon
r_int
id|arg_len
suffix:semicolon
id|u_long
id|target
suffix:semicolon
id|bzero
c_func
(paren
id|uc
comma
r_sizeof
(paren
op_star
id|uc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
op_logical_and
id|ptr
(braket
id|len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
op_decrement
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setsync&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETSYNC
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;settags&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETTAGS
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setorder&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETORDER
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setverbose&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETVERBOSE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setwide&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETWIDE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setdebug&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETDEBUG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setflag&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETFLAG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;clearprof&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_CLEARPROF
suffix:semicolon
r_else
id|arg_len
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;ncr_user_command: arg_len=%d, cmd=%ld&bslash;n&quot;
comma
id|arg_len
comma
id|uc-&gt;cmd
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|arg_len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETSYNC
suffix:colon
r_case
id|UC_SETTAGS
suffix:colon
r_case
id|UC_SETWIDE
suffix:colon
r_case
id|UC_SETFLAG
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;all&quot;
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
id|uc-&gt;target
op_assign
op_complement
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|GET_INT_ARG
c_func
(paren
id|target
)paren
suffix:semicolon
id|uc-&gt;target
op_assign
(paren
l_int|1
op_lshift
id|target
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;ncr_user_command: target=%ld&bslash;n&quot;
comma
id|target
)paren
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETVERBOSE
suffix:colon
r_case
id|UC_SETSYNC
suffix:colon
r_case
id|UC_SETTAGS
suffix:colon
r_case
id|UC_SETWIDE
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|GET_INT_ARG
c_func
(paren
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;ncr_user_command: data=%ld&bslash;n&quot;
comma
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|UC_SETORDER
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;simple&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
id|M_SIMPLE_TAG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;ordered&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
id|M_ORDERED_TAG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;default&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
l_int|0
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETDEBUG
suffix:colon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;alloc&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_ALLOC
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;phase&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_PHASE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;queue&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_QUEUE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;result&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_RESULT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;scatter&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_SCATTER
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;script&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_SCRIPT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;tiny&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TINY
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;timing&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TIMING
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;nego&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_NEGO
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;tags&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TAGS
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;ncr_user_command: data=%ld&bslash;n&quot;
comma
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|UC_SETFLAG
suffix:colon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;trace&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|UF_TRACE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;no_disc&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|UF_NODISC
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
(brace
r_int
id|flags
suffix:semicolon
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_usercmd
(paren
id|np
)paren
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|length
suffix:semicolon
)brace
macro_line|#endif&t;/* SCSI_NCR_USER_COMMAND_SUPPORT */
macro_line|#ifdef SCSI_NCR_USER_INFO_SUPPORT
multiline_comment|/*&n;**&t;Copy formatted profile information into the input buffer.&n;*/
DECL|macro|to_ms
mdefine_line|#define to_ms(t) ((t) * 1000 / HZ)
DECL|function|ncr_host_info
r_static
r_int
id|ncr_host_info
c_func
(paren
id|ncb_p
id|np
comma
r_char
op_star
id|ptr
comma
id|off_t
id|offset
comma
r_int
id|len
)paren
(brace
r_struct
id|info_str
id|info
suffix:semicolon
id|info.buffer
op_assign
id|ptr
suffix:semicolon
id|info.length
op_assign
id|len
suffix:semicolon
id|info.offset
op_assign
id|offset
suffix:semicolon
id|info.pos
op_assign
l_int|0
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  Chip NCR53C%s, device id 0x%x, &quot;
l_string|&quot;revision id 0x%x&bslash;n&quot;
comma
id|np-&gt;chip_name
comma
id|np-&gt;device_id
comma
id|np-&gt;revision_id
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  On PCI bus %d, device %d, function %d, &quot;
macro_line|#ifdef __sparc__
l_string|&quot;IRQ %s&bslash;n&quot;
comma
macro_line|#else
l_string|&quot;IRQ %d&bslash;n&quot;
comma
macro_line|#endif
id|np-&gt;bus
comma
(paren
id|np-&gt;device_fn
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
comma
id|np-&gt;device_fn
op_amp
l_int|7
comma
macro_line|#ifdef __sparc__
id|__irq_itoa
c_func
(paren
id|np-&gt;irq
)paren
)paren
suffix:semicolon
macro_line|#else
(paren
r_int
)paren
id|np-&gt;irq
)paren
suffix:semicolon
macro_line|#endif
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  Synchronous period factor %d, &quot;
l_string|&quot;max commands per lun %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|np-&gt;minsync
comma
id|MAX_TAGS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.debug
op_logical_or
id|driver_setup.verbose
OG
l_int|1
)paren
(brace
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  Debug flags 0x%x, verbosity level %d&bslash;n&quot;
comma
id|driver_setup.debug
comma
id|driver_setup.verbose
)paren
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Profiling information:&bslash;n&quot;
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_trans&quot;
comma
id|np-&gt;profile.num_trans
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_kbytes&quot;
comma
id|np-&gt;profile.num_kbytes
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_disc&quot;
comma
id|np-&gt;profile.num_disc
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_break&quot;
comma
id|np-&gt;profile.num_break
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_int&quot;
comma
id|np-&gt;profile.num_int
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_fly&quot;
comma
id|np-&gt;profile.num_fly
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;ms_setup&quot;
comma
id|to_ms
c_func
(paren
id|np-&gt;profile.ms_setup
)paren
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;ms_data&quot;
comma
id|to_ms
c_func
(paren
id|np-&gt;profile.ms_data
)paren
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;ms_disc&quot;
comma
id|to_ms
c_func
(paren
id|np-&gt;profile.ms_disc
)paren
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;ms_post&quot;
comma
id|to_ms
c_func
(paren
id|np-&gt;profile.ms_post
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|info.pos
OG
id|info.offset
ques
c_cond
id|info.pos
op_minus
id|info.offset
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_USER_INFO_SUPPORT */
multiline_comment|/*&n;**&t;Entry point of the scsi proc fs of the driver.&n;**&t;- func = 0 means read  (returns profile data)&n;**&t;- func = 1 means write (parse user control command)&n;*/
DECL|function|ncr53c8xx_proc_info
r_static
r_int
id|ncr53c8xx_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|func
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
id|ncb_p
id|ncb
op_assign
l_int|0
suffix:semicolon
r_int
id|retv
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx_proc_info: hostno=%d, func=%d&bslash;n&quot;
comma
id|hostno
comma
id|func
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|host
op_assign
id|first_host
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|host-&gt;hostt
op_eq
id|the_template
op_logical_and
id|host-&gt;host_no
op_eq
id|hostno
)paren
(brace
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|ncb
op_assign
id|host_data-&gt;ncb
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ncb
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|func
)paren
(brace
macro_line|#ifdef&t;SCSI_NCR_USER_COMMAND_SUPPORT
id|retv
op_assign
id|ncr_user_command
c_func
(paren
id|ncb
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
macro_line|#else
id|retv
op_assign
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
id|start
)paren
op_star
id|start
op_assign
id|buffer
suffix:semicolon
macro_line|#ifdef SCSI_NCR_USER_INFO_SUPPORT
id|retv
op_assign
id|ncr_host_info
c_func
(paren
id|ncb
comma
id|buffer
comma
id|offset
comma
id|length
)paren
suffix:semicolon
macro_line|#else
id|retv
op_assign
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/*=========================================================================&n;**&t;End of proc file system stuff&n;**=========================================================================&n;*/
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;/proc directory entry.&n;**&n;**==========================================================&n;*/
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,3,27)
DECL|variable|proc_scsi_ncr53c8xx
r_static
r_struct
id|proc_dir_entry
id|proc_scsi_ncr53c8xx
op_assign
(brace
id|PROC_SCSI_NCR53C8XX
comma
l_int|9
comma
id|NAME53C8XX
comma
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
l_int|2
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;Boot command line.&n;**&n;**==========================================================&n;*/
macro_line|#ifdef&t;MODULE
DECL|variable|ncr53c8xx
r_char
op_star
id|ncr53c8xx
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* command line passed by insmod */
macro_line|# if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,30)
id|MODULE_PARM
c_func
(paren
id|ncr53c8xx
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
macro_line|# endif
macro_line|#endif
DECL|function|ncr53c8xx_setup
r_int
id|__init
id|ncr53c8xx_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_return
id|sym53c8xx__setup
c_func
(paren
id|str
)paren
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,3,13)
macro_line|#ifndef MODULE
id|__setup
c_func
(paren
l_string|&quot;ncr53c8xx=&quot;
comma
id|ncr53c8xx_setup
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/*===================================================================&n;**&n;**   SYM53C8XX supported device list&n;**&n;**===================================================================&n;*/
DECL|variable|__initdata
r_static
id|u_short
id|ncr_chip_ids
(braket
)braket
id|__initdata
op_assign
(brace
id|PCI_DEVICE_ID_NCR_53C810
comma
id|PCI_DEVICE_ID_NCR_53C815
comma
id|PCI_DEVICE_ID_NCR_53C820
comma
id|PCI_DEVICE_ID_NCR_53C825
comma
id|PCI_DEVICE_ID_NCR_53C860
comma
id|PCI_DEVICE_ID_NCR_53C875
comma
id|PCI_DEVICE_ID_NCR_53C875J
comma
id|PCI_DEVICE_ID_NCR_53C885
comma
id|PCI_DEVICE_ID_NCR_53C895
comma
id|PCI_DEVICE_ID_NCR_53C896
comma
id|PCI_DEVICE_ID_NCR_53C895A
comma
id|PCI_DEVICE_ID_NCR_53C1510D
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&t;Chip detection entry point.&n;**&n;**==========================================================&n;*/
DECL|function|ncr53c8xx_detect
r_int
id|__init
id|ncr53c8xx_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
multiline_comment|/*&n;&t;**    Initialize driver general stuff.&n;&t;*/
macro_line|#ifdef SCSI_NCR_PROC_INFO_SUPPORT
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,3,27)
id|tpnt-&gt;proc_dir
op_assign
op_amp
id|proc_scsi_ncr53c8xx
suffix:semicolon
macro_line|#else
id|tpnt-&gt;proc_name
op_assign
id|NAME53C8XX
suffix:semicolon
macro_line|#endif
id|tpnt-&gt;proc_info
op_assign
id|ncr53c8xx_proc_info
suffix:semicolon
macro_line|#endif
macro_line|#if&t;defined(SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT) &amp;&amp; defined(MODULE)
r_if
c_cond
(paren
id|ncr53c8xx
)paren
id|ncr53c8xx_setup
c_func
(paren
id|ncr53c8xx
)paren
suffix:semicolon
macro_line|#endif
r_return
id|sym53c8xx__detect
c_func
(paren
id|tpnt
comma
id|ncr_chip_ids
comma
r_sizeof
(paren
id|ncr_chip_ids
)paren
op_div
r_sizeof
(paren
id|ncr_chip_ids
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**   Entry point for info() function&n;**&n;**==========================================================&n;*/
DECL|function|ncr53c8xx_info
r_const
r_char
op_star
id|ncr53c8xx_info
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_return
id|SCSI_NCR_DRIVER_NAME
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Module stuff&n;*/
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|NCR53C8XX
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
eof
