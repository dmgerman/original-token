multiline_comment|/******************************************************************************&n;**  Device driver for the PCI-SCSI NCR538XX controller family.&n;**&n;**  Copyright (C) 1994  Wolfgang Stanglmeier&n;**&n;**  This program is free software; you can redistribute it and/or modify&n;**  it under the terms of the GNU General Public License as published by&n;**  the Free Software Foundation; either version 2 of the License, or&n;**  (at your option) any later version.&n;**&n;**  This program is distributed in the hope that it will be useful,&n;**  but WITHOUT ANY WARRANTY; without even the implied warranty of&n;**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;**  GNU General Public License for more details.&n;**&n;**  You should have received a copy of the GNU General Public License&n;**  along with this program; if not, write to the Free Software&n;**  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;**&n;**-----------------------------------------------------------------------------&n;**&n;**  This driver has been ported to Linux from the FreeBSD NCR53C8XX driver&n;**  and is currently maintained by&n;**&n;**          Gerard Roudier              &lt;groudier@club-internet.fr&gt;&n;**&n;**  Being given that this driver originates from the FreeBSD version, and&n;**  in order to keep synergy on both, any suggested enhancements and corrections&n;**  received on Linux are automatically a potential candidate for the FreeBSD &n;**  version.&n;**&n;**  The original driver has been written for 386bsd and FreeBSD by&n;**          Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;&n;**          Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;&n;**&n;**  And has been ported to NetBSD by&n;**          Charles M. Hannum           &lt;mycroft@gnu.ai.mit.edu&gt;&n;**&n;*******************************************************************************&n;*/
multiline_comment|/*&n;**&t;23 June 1996, version 1.12&n;**&n;**&t;Supported SCSI-II features:&n;**&t;    Synchronous negotiation&n;**&t;    Wide negotiation        (depends on the NCR Chip)&n;**&t;    Enable disconnection&n;**&t;    Tagged command queuing&n;**&t;    Parity checking&n;**&t;    Etc...&n;**&n;**&t;Supported NCR chips:&n;**&t;&t;53C810&t;&t;(NCR BIOS in flash-bios required) &n;**&t;&t;53C815&t;&t;(~53C810 with on board rom BIOS)&n;**&t;&t;53C820&t;&t;(Wide, NCR BIOS in flash bios required)&n;**&t;&t;53C825&t;&t;(Wide, ~53C820 with on board rom BIOS)&n;**&n;**&t;Other features:&n;**&t;&t;Memory mapped IO (linux-1.3.X only)&n;**&t;&t;Module&n;**&t;&t;Shared IRQ (since linux-1.3.72)&n;*/
DECL|macro|SCSI_NCR_DEBUG
mdefine_line|#define SCSI_NCR_DEBUG
DECL|macro|SCSI_NCR_DEBUG_FLAGS
mdefine_line|#define SCSI_NCR_DEBUG_FLAGS&t;(0)&t;&t;
DECL|macro|NCR_DATE
mdefine_line|#define NCR_DATE &quot;pl23 95/09/07&quot;
DECL|macro|NCR_VERSION
mdefine_line|#define NCR_VERSION&t;(2)
DECL|macro|NCR_GETCC_WITHMSG
mdefine_line|#define NCR_GETCC_WITHMSG
multiline_comment|/*==========================================================&n;**&n;**      Include files&n;**&n;**==========================================================&n;*/
DECL|macro|LinuxVersionCode
mdefine_line|#define LinuxVersionCode(v, p, s) (((v)&lt;&lt;16)+((p)&lt;&lt;8)+(s))
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,0)
macro_line|#include &quot;linux/blk.h&quot;
macro_line|#else
macro_line|#include &quot;../block/blk.h&quot;
macro_line|#endif
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &lt;linux/types.h&gt;
multiline_comment|/*&n;**&t;Define the BSD style u_int32 type&n;*/
DECL|typedef|u_int32
r_typedef
id|u32
id|u_int32
suffix:semicolon
macro_line|#include &quot;ncr53c8xx.h&quot;
multiline_comment|/*==========================================================&n;**&n;**&t;Configuration and Debugging&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**&t;Proc info and user command support&n;*/
macro_line|#ifdef SCSI_NCR_PROC_INFO_SUPPORT
DECL|macro|SCSI_NCR_PROFILE
mdefine_line|#define SCSI_NCR_PROFILE
DECL|macro|SCSI_NCR_USER_COMMAND
mdefine_line|#define SCSI_NCR_USER_COMMAND
macro_line|#endif
multiline_comment|/*&n;**    SCSI address of this device.&n;**    The boot routines should have set it.&n;**    If not, use this.&n;*/
macro_line|#ifndef SCSI_NCR_MYADDR
DECL|macro|SCSI_NCR_MYADDR
mdefine_line|#define SCSI_NCR_MYADDR      (7)
macro_line|#endif
multiline_comment|/*&n;**    The maximal synchronous frequency in kHz.&n;**    (0=asynchronous)&n;*/
macro_line|#ifndef SCSI_NCR_MAX_SYNC
DECL|macro|SCSI_NCR_MAX_SYNC
mdefine_line|#define SCSI_NCR_MAX_SYNC   (10000)
macro_line|#endif
multiline_comment|/*&n;**    The maximal bus with (in log2 byte)&n;**    (0=8 bit, 1=16 bit)&n;*/
macro_line|#ifndef SCSI_NCR_MAX_WIDE
DECL|macro|SCSI_NCR_MAX_WIDE
mdefine_line|#define SCSI_NCR_MAX_WIDE   (1)
macro_line|#endif
multiline_comment|/*&n;**    The maximum number of tags per logic unit.&n;**    Used only for disk devices that support tags.&n;*/
macro_line|#ifndef SCSI_NCR_MAX_TAGS
DECL|macro|SCSI_NCR_MAX_TAGS
mdefine_line|#define SCSI_NCR_MAX_TAGS    (4)
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**      Configuration and Debugging&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**    Number of targets supported by the driver.&n;**    n permits target numbers 0..n-1.&n;**    Default is 7, meaning targets #0..#6.&n;**    #7 .. is myself.&n;*/
macro_line|#ifdef SCSI_NCR_MAX_TARGET
DECL|macro|MAX_TARGET
mdefine_line|#define MAX_TARGET  (SCSI_NCR_MAX_TARGET)
macro_line|#else
DECL|macro|MAX_TARGET
mdefine_line|#define MAX_TARGET  (16)
macro_line|#endif
multiline_comment|/*&n;**    Number of logic units supported by the driver.&n;**    n enables logic unit numbers 0..n-1.&n;**    The common SCSI devices require only&n;**    one lun, so take 1 as the default.&n;*/
macro_line|#ifdef SCSI_NCR_MAX_LUN
DECL|macro|MAX_LUN
mdefine_line|#define MAX_LUN    SCSI_NCR_MAX_LUN
macro_line|#else
DECL|macro|MAX_LUN
mdefine_line|#define MAX_LUN    (1)
macro_line|#endif
multiline_comment|/*&n;**    The maximum number of jobs scheduled for starting.&n;**    There should be one slot per target, and one slot&n;**    for each tag of each target in use.&n;**    The calculation below is actually quite silly ...&n;*/
macro_line|#ifdef SCSI_NCR_CAN_QUEUE
DECL|macro|MAX_START
mdefine_line|#define MAX_START   (SCSI_NCR_CAN_QUEUE + 4)
macro_line|#else
DECL|macro|MAX_START
mdefine_line|#define MAX_START   (MAX_TARGET + 7 * SCSI_NCR_MAX_TAGS)
macro_line|#endif
multiline_comment|/*&n;**    The maximum number of segments a transfer is split into.&n;*/
DECL|macro|MAX_SCATTER
mdefine_line|#define MAX_SCATTER (SCSI_NCR_MAX_SCATTER)
multiline_comment|/*&n;**    The maximum transfer length (should be &gt;= 64k).&n;**    MUST NOT be greater than (MAX_SCATTER-1) * NBPG.&n;*/
macro_line|#if 0
mdefine_line|#define MAX_SIZE  ((MAX_SCATTER-1) * (long) NBPG)
macro_line|#endif
multiline_comment|/*&n;**&t;other&n;*/
DECL|macro|NCR_SNOOP_TIMEOUT
mdefine_line|#define NCR_SNOOP_TIMEOUT (1000000)
macro_line|#ifdef SCSI_NCR_IOMAPPED
DECL|macro|NCR_IOMAPPED
mdefine_line|#define NCR_IOMAPPED
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;Defines for Linux.&n;**&n;**&t;Linux and Bsd kernel functions are quite different.&n;**&t;These defines allow a minimum change of the original&n;**&t;code.&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n; **&t;Obvious definitions&n; */
DECL|macro|printf
mdefine_line|#define printf&t;&t;printk
DECL|macro|u_char
mdefine_line|#define u_char&t;&t;unsigned char
DECL|macro|u_short
mdefine_line|#define u_short&t;&t;unsigned short
DECL|macro|u_int
mdefine_line|#define u_int&t;&t;unsigned int
DECL|macro|u_long
mdefine_line|#define u_long&t;&t;unsigned long
DECL|typedef|vm_offset_t
r_typedef
id|u_long
id|vm_offset_t
suffix:semicolon
DECL|typedef|vm_size_t
r_typedef
r_int
id|vm_size_t
suffix:semicolon
DECL|macro|bcopy
mdefine_line|#define bcopy(s, d, n)&t;memcpy((d), (s), (n))
DECL|macro|bzero
mdefine_line|#define bzero(d, n)&t;memset((d), 0, (n))
macro_line|#ifndef offsetof
DECL|macro|offsetof
mdefine_line|#define offsetof(t, m)&t;((size_t) (&amp;((t *)0)-&gt;m))
macro_line|#endif
multiline_comment|/*&n;**&t;Address translation&n;**&n;**&t;On Linux 1.3.X, virt_to_bus() must be used to translate&n;**&t;virtual memory addresses of the kernel data segment into&n;**&t;IO bus adresses.&n;**&t;On i386 architecture, IO bus addresses match the physical&n;**&t;addresses. But on Alpha architecture they are different.&n;**&t;In the original Bsd driver, vtophys() is called to translate&n;**&t;data addresses to IO bus addresses. In order to minimize&n;**&t;change, I decide to define vtophys() as virt_to_bus().&n;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,0)
DECL|macro|vtophys
mdefine_line|#define vtophys(p)&t;virt_to_bus(p)
multiline_comment|/*&n;**&t;Memory mapped IO&n;**&n;**&t;Linux 1.3.X allow to remap physical pages addresses greater than&n;**&t;the highest physical memory address to kernel virtual pages.&n;**&t;We must use vremap() to map the page and vfree() to unmap it.&n;**&t;The memory base of ncr chips is set by the bios at a high physical&n;**&t;address. Also we can map it, and MMIO is possible.&n;*/
DECL|function|remap_pci_mem
r_static
r_inline
id|vm_offset_t
id|remap_pci_mem
c_func
(paren
id|u_long
id|base
comma
id|u_long
id|size
)paren
(brace
id|u_long
id|page_base
op_assign
(paren
(paren
id|u_long
)paren
id|base
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|u_long
id|page_offs
op_assign
(paren
(paren
id|u_long
)paren
id|base
)paren
op_minus
id|page_base
suffix:semicolon
id|u_long
id|page_remapped
op_assign
(paren
id|u_long
)paren
id|vremap
c_func
(paren
id|page_base
comma
id|page_offs
op_plus
id|size
)paren
suffix:semicolon
r_return
(paren
id|vm_offset_t
)paren
(paren
id|page_remapped
ques
c_cond
(paren
id|page_remapped
op_plus
id|page_offs
)paren
suffix:colon
l_int|0UL
)paren
suffix:semicolon
)brace
DECL|function|unmap_pci_mem
r_static
r_inline
r_void
id|unmap_pci_mem
c_func
(paren
id|vm_offset_t
id|vaddr
comma
id|u_long
id|size
)paren
(brace
r_if
c_cond
(paren
id|vaddr
)paren
id|vfree
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|vaddr
op_amp
id|PAGE_MASK
)paren
)paren
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/*&n;**&t;Linux 1.2.X assumes that addresses (virtual, physical, bus)&n;**&t;are the same.&n;**&n;**&t;I have not found how to do MMIO. It seems that only processes can&n;**&t;map high physical pages to virtual (Xservers can do MMIO).&n;*/
DECL|macro|vtophys
mdefine_line|#define vtophys(p)&t;((u_long) (p))
macro_line|#endif
DECL|function|DELAY
r_static
r_void
id|DELAY
c_func
(paren
r_int
id|us
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|us
OG
l_int|1000
suffix:semicolon
id|us
op_sub_assign
l_int|1000
)paren
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|us
)paren
id|udelay
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Internal data structure allocation.&n;**&n;**&t;Linux scsi memory poor pool is adjusted for the need of&n;**&t;middle-level scsi driver.&n;**&t;We allocate our control blocks in the kernel memory pool&n;**&t;to avoid scsi pool shortage.&n;**&t;I notice that kmalloc() returns NULL during host attach under&n;**&t;Linux 1.2.13. But this ncr driver is reliable enough to&n;**&t;accomodate with this joke.&n;**/
DECL|function|m_alloc
r_static
r_inline
r_void
op_star
id|m_alloc
c_func
(paren
r_int
id|size
)paren
(brace
r_void
op_star
id|ptr
op_assign
(paren
r_void
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|ptr
)paren
op_amp
l_int|3
)paren
id|panic
c_func
(paren
l_string|&quot;ncr53c8xx: kmalloc returns misaligned address %lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ptr
)paren
suffix:semicolon
r_return
id|ptr
suffix:semicolon
)brace
DECL|function|m_free
r_static
r_inline
r_void
id|m_free
c_func
(paren
r_void
op_star
id|ptr
comma
r_int
id|size
)paren
(brace
id|kfree
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Transfer direction&n;**&n;**&t;The middle scsi driver of Linux does not provide the transfer&n;**&t;direction in the command structure.&n;**&t;FreeBsd ncr driver require this information.&n;**&n;**&t;I spent some hours to read the scsi2 documentation to see if&n;**&t;it was possible to deduce the direction of transfer from the opcode&n;**&t;of the command. It seems that it&squot;s OK.&n;**&t;guess_xfer_direction() seems to work. If it&squot;s wrong we will&n;**&t;get a phase mismatch on some opcode.&n;*/
DECL|macro|XferNone
mdefine_line|#define XferNone&t;0
DECL|macro|XferIn
mdefine_line|#define XferIn&t;&t;1
DECL|macro|XferOut
mdefine_line|#define XferOut&t;&t;2
DECL|macro|XferBoth
mdefine_line|#define XferBoth&t;3
r_static
r_int
id|guess_xfer_direction
c_func
(paren
r_int
id|opcode
)paren
suffix:semicolon
multiline_comment|/*&n;**&t;Head of list of NCR boards&n;**&n;**&t;Host is retrieved by its irq level.&n;*/
DECL|variable|first_host
r_static
r_struct
id|Scsi_Host
op_star
id|first_host
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|the_template
r_static
id|Scsi_Host_Template
op_star
id|the_template
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;**&t;/proc directory entry and proc_info function&n;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,0)
DECL|variable|proc_scsi_ncr53c8xx
r_struct
id|proc_dir_entry
id|proc_scsi_ncr53c8xx
op_assign
(brace
id|PROC_SCSI_NCR53C8XX
comma
l_int|9
comma
l_string|&quot;ncr53c8xx&quot;
comma
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
l_int|2
)brace
suffix:semicolon
macro_line|# ifdef SCSI_NCR_PROC_INFO_SUPPORT
r_int
id|ncr53c8xx_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|func
)paren
suffix:semicolon
macro_line|# endif
macro_line|#endif
multiline_comment|/*&n;**&t;Table of target capabilities.&n;**&n;**&t;This bitmap is anded with the byte 7 of inquiry data on completion of&n;**&t;INQUIRY command.&n;** &t;The driver never see zeroed bits and will ignore the corresponding&n;**&t;capabilities of the target.&n;*/
r_static
r_struct
(brace
DECL|member|and_map
r_int
r_char
id|and_map
(braket
id|MAX_TARGET
)braket
suffix:semicolon
DECL|variable|target_capabilities
)brace
id|target_capabilities
(braket
id|SCSI_NCR_MAX_HOST
)braket
op_assign
(brace
id|NCR53C8XX_TARGET_CAPABILITIES
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;Other Linux definitions&n;*/
DECL|macro|ScsiResult
mdefine_line|#define ScsiResult(host_code, scsi_code) (((host_code) &lt;&lt; 16) + ((scsi_code) &amp; 0x7f))
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,70)
r_static
r_void
id|ncr53c8xx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
macro_line|#else
r_static
r_void
id|ncr53c8xx_intr
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|ncr53c8xx_timeout
c_func
(paren
r_int
r_int
id|np
)paren
suffix:semicolon
DECL|macro|bootverbose
mdefine_line|#define bootverbose 1
multiline_comment|/*==========================================================&n;**&n;**&t;Debugging tags&n;**&n;**==========================================================&n;*/
DECL|macro|DEBUG_ALLOC
mdefine_line|#define DEBUG_ALLOC    (0x0001)
DECL|macro|DEBUG_PHASE
mdefine_line|#define DEBUG_PHASE    (0x0002)
DECL|macro|DEBUG_POLL
mdefine_line|#define DEBUG_POLL     (0x0004)
DECL|macro|DEBUG_QUEUE
mdefine_line|#define DEBUG_QUEUE    (0x0008)
DECL|macro|DEBUG_RESULT
mdefine_line|#define DEBUG_RESULT   (0x0010)
DECL|macro|DEBUG_SCATTER
mdefine_line|#define DEBUG_SCATTER  (0x0020)
DECL|macro|DEBUG_SCRIPT
mdefine_line|#define DEBUG_SCRIPT   (0x0040)
DECL|macro|DEBUG_TINY
mdefine_line|#define DEBUG_TINY     (0x0080)
DECL|macro|DEBUG_TIMING
mdefine_line|#define DEBUG_TIMING   (0x0100)
DECL|macro|DEBUG_NEGO
mdefine_line|#define DEBUG_NEGO     (0x0200)
DECL|macro|DEBUG_TAGS
mdefine_line|#define DEBUG_TAGS     (0x0400)
DECL|macro|DEBUG_FREEZE
mdefine_line|#define DEBUG_FREEZE   (0x0800)
DECL|macro|DEBUG_RESTART
mdefine_line|#define DEBUG_RESTART  (0x1000)
multiline_comment|/*&n;**    Enable/Disable debug messages.&n;**    Can be changed at runtime too.&n;*/
macro_line|#ifdef SCSI_NCR_DEBUG
DECL|macro|DEBUG_FLAGS
mdefine_line|#define DEBUG_FLAGS ncr_debug
macro_line|#else
DECL|macro|DEBUG_FLAGS
mdefine_line|#define DEBUG_FLAGS&t;SCSI_NCR_DEBUG_FLAGS
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;assert ()&n;**&n;**==========================================================&n;**&n;**&t;modified copy from 386bsd:/usr/include/sys/assert.h&n;**&n;**----------------------------------------------------------&n;*/
DECL|macro|assert
mdefine_line|#define&t;assert(expression) { &bslash;&n;&t;if (!(expression)) { &bslash;&n;&t;&t;(void)printf(&bslash;&n;&t;&t;&t;&quot;assertion &bslash;&quot;%s&bslash;&quot; failed: file &bslash;&quot;%s&bslash;&quot;, line %d&bslash;n&quot;, &bslash;&n;&t;&t;&t;#expression, &bslash;&n;&t;&t;&t;__FILE__, __LINE__); &bslash;&n;&t;} &bslash;&n;}
multiline_comment|/*==========================================================&n;**&n;**&t;Access to the controller chip.&n;**&n;**&t;If NCR_IOMAPPED is defined, only IO are used by the driver.&n;**&t;Else, we begins initialisations by using MMIO.&n;**&t;&t;If cache test fails, we retry using IO mapped.&n;**&t;The flag &quot;use_mmio&quot; in the ncb structure is set to 1 if&n;**&t;mmio is possible.&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**&t;IO mapped input / ouput&n;*/
DECL|macro|IOM_INB
mdefine_line|#define&t;IOM_INB(r)         inb (np-&gt;port + offsetof(struct ncr_reg, r))
DECL|macro|IOM_INB_OFF
mdefine_line|#define&t;IOM_INB_OFF(o)     inb (np-&gt;port + (o))
DECL|macro|IOM_INW
mdefine_line|#define&t;IOM_INW(r)         inw (np-&gt;port + offsetof(struct ncr_reg, r))
DECL|macro|IOM_INL
mdefine_line|#define&t;IOM_INL(r)         inl (np-&gt;port + offsetof(struct ncr_reg, r))
DECL|macro|IOM_INL_OFF
mdefine_line|#define&t;IOM_INL_OFF(o)     inl (np-&gt;port + (o))
DECL|macro|IOM_OUTB
mdefine_line|#define&t;IOM_OUTB(r, val)     outb ((val), np-&gt;port+offsetof(struct ncr_reg,r))
DECL|macro|IOM_OUTW
mdefine_line|#define&t;IOM_OUTW(r, val)     outw ((val), np-&gt;port+offsetof(struct ncr_reg,r))
DECL|macro|IOM_OUTL
mdefine_line|#define&t;IOM_OUTL(r, val)     outl ((val), np-&gt;port+offsetof(struct ncr_reg,r))
DECL|macro|IOM_OUTL_OFF
mdefine_line|#define&t;IOM_OUTL_OFF(o, val) outl ((val), np-&gt;port + (o))
multiline_comment|/*&n;**&t;MEMORY mapped IO input / output&n;*/
DECL|macro|MMIO_INB
mdefine_line|#define MMIO_INB(r)        readb(&amp;np-&gt;reg_remapped-&gt;r)
DECL|macro|MMIO_INB_OFF
mdefine_line|#define MMIO_INB_OFF(o)    readb((char *)np-&gt;reg_remapped + (o))
DECL|macro|MMIO_INW
mdefine_line|#define MMIO_INW(r)        readw(&amp;np-&gt;reg_remapped-&gt;r)
DECL|macro|MMIO_INL
mdefine_line|#define MMIO_INL(r)        readl(&amp;np-&gt;reg_remapped-&gt;r)
DECL|macro|MMIO_INL_OFF
mdefine_line|#define MMIO_INL_OFF(o)    readl((char *)np-&gt;reg_remapped + (o))
DECL|macro|MMIO_OUTB
mdefine_line|#define MMIO_OUTB(r, val)     writeb((val), &amp;np-&gt;reg_remapped-&gt;r)
DECL|macro|MMIO_OUTW
mdefine_line|#define MMIO_OUTW(r, val)     writew((val), &amp;np-&gt;reg_remapped-&gt;r)
DECL|macro|MMIO_OUTL
mdefine_line|#define MMIO_OUTL(r, val)     writel((val), &amp;np-&gt;reg_remapped-&gt;r)
DECL|macro|MMIO_OUTL_OFF
mdefine_line|#define MMIO_OUTL_OFF(o, val) writel((val), (char *)np-&gt;reg_remapped + (o))
multiline_comment|/*&n;**&t;IO mapped only input / output&n;*/
macro_line|#ifdef NCR_IOMAPPED
DECL|macro|INB
mdefine_line|#define INB(r)             IOM_INB(r)
DECL|macro|INB_OFF
mdefine_line|#define INB_OFF(o)         IOM_INB_OFF(o)
DECL|macro|INW
mdefine_line|#define INW(r)             IOM_INW(r)
DECL|macro|INL
mdefine_line|#define INL(r)             IOM_INL(r)
DECL|macro|INL_OFF
mdefine_line|#define INL_OFF(r)         IOM_INL_OFF(o)
DECL|macro|OUTB
mdefine_line|#define OUTB(r, val)       IOM_OUTB(r, val)
DECL|macro|OUTW
mdefine_line|#define OUTW(r, val)       IOM_OUTW(r, val)
DECL|macro|OUTL
mdefine_line|#define OUTL(r, val)       IOM_OUTL(r, val)
DECL|macro|OUTL_OFF
mdefine_line|#define OUTL_OFF(o, val)   IOM_OUTL_OFF(o, val)
multiline_comment|/*&n;**&t;IO mapped or MEMORY mapped depending on flag &quot;use_mmio&quot;&n;*/
macro_line|#else
DECL|macro|INB
mdefine_line|#define&t;INB(r)             (np-&gt;use_mmio ? MMIO_INB(r) : IOM_INB(r))
DECL|macro|INB_OFF
mdefine_line|#define&t;INB_OFF(o)         (np-&gt;use_mmio ? MMIO_INB_OFF(o) : IOM_INB_OFF(o))
DECL|macro|INW
mdefine_line|#define&t;INW(r)             (np-&gt;use_mmio ? MMIO_INW(r) : IOM_INW(r))
DECL|macro|INL
mdefine_line|#define&t;INL(r)             (np-&gt;use_mmio ? MMIO_INL(r) : IOM_INL(r))
DECL|macro|INL_OFF
mdefine_line|#define&t;INL_OFF(o)         (np-&gt;use_mmio ? MMIO_INL_OFF(o) : IOM_INL_OFF(o))
DECL|macro|OUTB
mdefine_line|#define&t;OUTB(r, val)       (np-&gt;use_mmio ? MMIO_OUTB(r, val) : IOM_OUTB(r, val))
DECL|macro|OUTW
mdefine_line|#define&t;OUTW(r, val)       (np-&gt;use_mmio ? MMIO_OUTW(r, val) : IOM_OUTW(r, val))
DECL|macro|OUTL
mdefine_line|#define&t;OUTL(r, val)       (np-&gt;use_mmio ? MMIO_OUTL(r, val) : IOM_OUTL(r, val))
DECL|macro|OUTL_OFF
mdefine_line|#define&t;OUTL_OFF(o, val)   (np-&gt;use_mmio ? MMIO_OUTL_OFF(o, val) : IOM_OUTL_OFF(o, val))
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;Command control block states.&n;**&n;**==========================================================&n;*/
DECL|macro|HS_IDLE
mdefine_line|#define HS_IDLE&t;&t;(0)
DECL|macro|HS_BUSY
mdefine_line|#define HS_BUSY&t;&t;(1)
DECL|macro|HS_NEGOTIATE
mdefine_line|#define HS_NEGOTIATE&t;(2)&t;/* sync/wide data transfer*/
DECL|macro|HS_DISCONNECT
mdefine_line|#define HS_DISCONNECT&t;(3)&t;/* Disconnected by target */
DECL|macro|HS_COMPLETE
mdefine_line|#define HS_COMPLETE&t;(4)
DECL|macro|HS_SEL_TIMEOUT
mdefine_line|#define HS_SEL_TIMEOUT&t;(5)&t;/* Selection timeout      */
DECL|macro|HS_RESET
mdefine_line|#define HS_RESET&t;(6)&t;/* SCSI reset&t;     */
DECL|macro|HS_ABORTED
mdefine_line|#define HS_ABORTED&t;(7)&t;/* Transfer aborted       */
DECL|macro|HS_TIMEOUT
mdefine_line|#define HS_TIMEOUT&t;(8)&t;/* Software timeout       */
DECL|macro|HS_FAIL
mdefine_line|#define HS_FAIL&t;&t;(9)&t;/* SCSI or PCI bus errors */
DECL|macro|HS_UNEXPECTED
mdefine_line|#define HS_UNEXPECTED&t;(10)&t;/* Unexpected disconnect  */
DECL|macro|HS_DONEMASK
mdefine_line|#define HS_DONEMASK&t;(0xfc)
multiline_comment|/*==========================================================&n;**&n;**&t;Software Interrupt Codes&n;**&n;**==========================================================&n;*/
DECL|macro|SIR_SENSE_RESTART
mdefine_line|#define&t;SIR_SENSE_RESTART&t;(1)
DECL|macro|SIR_SENSE_FAILED
mdefine_line|#define&t;SIR_SENSE_FAILED&t;(2)
DECL|macro|SIR_STALL_RESTART
mdefine_line|#define&t;SIR_STALL_RESTART&t;(3)
DECL|macro|SIR_STALL_QUEUE
mdefine_line|#define&t;SIR_STALL_QUEUE&t;&t;(4)
DECL|macro|SIR_NEGO_SYNC
mdefine_line|#define&t;SIR_NEGO_SYNC&t;&t;(5)
DECL|macro|SIR_NEGO_WIDE
mdefine_line|#define&t;SIR_NEGO_WIDE&t;&t;(6)
DECL|macro|SIR_NEGO_FAILED
mdefine_line|#define&t;SIR_NEGO_FAILED&t;&t;(7)
DECL|macro|SIR_NEGO_PROTO
mdefine_line|#define&t;SIR_NEGO_PROTO&t;&t;(8)
DECL|macro|SIR_REJECT_RECEIVED
mdefine_line|#define&t;SIR_REJECT_RECEIVED&t;(9)
DECL|macro|SIR_REJECT_SENT
mdefine_line|#define&t;SIR_REJECT_SENT&t;&t;(10)
DECL|macro|SIR_IGN_RESIDUE
mdefine_line|#define&t;SIR_IGN_RESIDUE&t;&t;(11)
DECL|macro|SIR_MISSING_SAVE
mdefine_line|#define&t;SIR_MISSING_SAVE&t;(12)
DECL|macro|SIR_MAX
mdefine_line|#define&t;SIR_MAX&t;&t;&t;(12)
multiline_comment|/*==========================================================&n;**&n;**&t;Extended error codes.&n;**&t;xerr_status field of struct ccb.&n;**&n;**==========================================================&n;*/
DECL|macro|XE_OK
mdefine_line|#define&t;XE_OK&t;&t;(0)
DECL|macro|XE_EXTRA_DATA
mdefine_line|#define&t;XE_EXTRA_DATA&t;(1)&t;/* unexpected data phase */
DECL|macro|XE_BAD_PHASE
mdefine_line|#define&t;XE_BAD_PHASE&t;(2)&t;/* illegal phase (4/5)   */
multiline_comment|/*==========================================================&n;**&n;**&t;Negotiation status.&n;**&t;nego_status field&t;of struct ccb.&n;**&n;**==========================================================&n;*/
DECL|macro|NS_SYNC
mdefine_line|#define NS_SYNC&t;&t;(1)
DECL|macro|NS_WIDE
mdefine_line|#define NS_WIDE&t;&t;(2)
multiline_comment|/*==========================================================&n;**&n;**&t;&quot;Special features&quot; of targets.&n;**&t;quirks field&t;&t;of struct tcb.&n;**&t;actualquirks field&t;of struct ccb.&n;**&n;**==========================================================&n;*/
DECL|macro|QUIRK_AUTOSAVE
mdefine_line|#define&t;QUIRK_AUTOSAVE&t;(0x01)
DECL|macro|QUIRK_NOMSG
mdefine_line|#define&t;QUIRK_NOMSG&t;(0x02)
DECL|macro|QUIRK_NOSYNC
mdefine_line|#define QUIRK_NOSYNC&t;(0x10)
DECL|macro|QUIRK_NOWIDE16
mdefine_line|#define QUIRK_NOWIDE16&t;(0x20)
DECL|macro|QUIRK_UPDATE
mdefine_line|#define&t;QUIRK_UPDATE&t;(0x80)
multiline_comment|/*==========================================================&n;**&n;**&t;Capability bits in Inquire response byte 7.&n;**&n;**==========================================================&n;*/
DECL|macro|INQ7_QUEUE
mdefine_line|#define&t;INQ7_QUEUE&t;(0x02)
DECL|macro|INQ7_SYNC
mdefine_line|#define&t;INQ7_SYNC&t;(0x10)
DECL|macro|INQ7_WIDE16
mdefine_line|#define&t;INQ7_WIDE16&t;(0x20)
multiline_comment|/*==========================================================&n;**&n;**&t;Misc.&n;**&n;**==========================================================&n;*/
DECL|macro|CCB_MAGIC
mdefine_line|#define CCB_MAGIC&t;(0xf2691ad2)
DECL|macro|MAX_TAGS
mdefine_line|#define&t;MAX_TAGS&t;(16)&t;&t;/* hard limit */
multiline_comment|/*==========================================================&n;**&n;**&t;Declaration of structs.&n;**&n;**==========================================================&n;*/
r_struct
id|tcb
suffix:semicolon
r_struct
id|lcb
suffix:semicolon
r_struct
id|ccb
suffix:semicolon
r_struct
id|ncb
suffix:semicolon
r_struct
id|script
suffix:semicolon
DECL|typedef|ncb_p
r_typedef
r_struct
id|ncb
op_star
id|ncb_p
suffix:semicolon
DECL|typedef|tcb_p
r_typedef
r_struct
id|tcb
op_star
id|tcb_p
suffix:semicolon
DECL|typedef|lcb_p
r_typedef
r_struct
id|lcb
op_star
id|lcb_p
suffix:semicolon
DECL|typedef|ccb_p
r_typedef
r_struct
id|ccb
op_star
id|ccb_p
suffix:semicolon
DECL|struct|link
r_struct
id|link
(brace
DECL|member|l_cmd
id|ncrcmd
id|l_cmd
suffix:semicolon
DECL|member|l_paddr
id|ncrcmd
id|l_paddr
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|usrcmd
r_struct
id|usrcmd
(brace
DECL|member|target
id|u_long
id|target
suffix:semicolon
DECL|member|lun
id|u_long
id|lun
suffix:semicolon
DECL|member|data
id|u_long
id|data
suffix:semicolon
DECL|member|cmd
id|u_long
id|cmd
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|UC_SETSYNC
mdefine_line|#define UC_SETSYNC      10
DECL|macro|UC_SETTAGS
mdefine_line|#define UC_SETTAGS&t;11
DECL|macro|UC_SETDEBUG
mdefine_line|#define UC_SETDEBUG&t;12
DECL|macro|UC_SETORDER
mdefine_line|#define UC_SETORDER&t;13
DECL|macro|UC_SETWIDE
mdefine_line|#define UC_SETWIDE&t;14
DECL|macro|UC_SETFLAG
mdefine_line|#define UC_SETFLAG&t;15
DECL|macro|UC_CLEARPROF
mdefine_line|#define UC_CLEARPROF&t;16
DECL|macro|UF_TRACE
mdefine_line|#define&t;UF_TRACE&t;(0x01)
multiline_comment|/*---------------------------------------&n;**&n;**&t;Timestamps for profiling&n;**&n;**---------------------------------------&n;*/
DECL|struct|tstamp
r_struct
id|tstamp
(brace
DECL|member|start
id|u_long
id|start
suffix:semicolon
DECL|member|end
id|u_long
id|end
suffix:semicolon
DECL|member|select
id|u_long
id|select
suffix:semicolon
DECL|member|command
id|u_long
id|command
suffix:semicolon
DECL|member|data
id|u_long
id|data
suffix:semicolon
DECL|member|status
id|u_long
id|status
suffix:semicolon
DECL|member|disconnect
id|u_long
id|disconnect
suffix:semicolon
DECL|member|reselect
id|u_long
id|reselect
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;profiling data (per device)&n;*/
DECL|struct|profile
r_struct
id|profile
(brace
DECL|member|num_trans
id|u_long
id|num_trans
suffix:semicolon
DECL|member|num_kbytes
id|u_long
id|num_kbytes
suffix:semicolon
DECL|member|rest_bytes
id|u_long
id|rest_bytes
suffix:semicolon
DECL|member|num_disc
id|u_long
id|num_disc
suffix:semicolon
DECL|member|num_break
id|u_long
id|num_break
suffix:semicolon
DECL|member|num_int
id|u_long
id|num_int
suffix:semicolon
DECL|member|num_fly
id|u_long
id|num_fly
suffix:semicolon
DECL|member|ms_setup
id|u_long
id|ms_setup
suffix:semicolon
DECL|member|ms_data
id|u_long
id|ms_data
suffix:semicolon
DECL|member|ms_disc
id|u_long
id|ms_disc
suffix:semicolon
DECL|member|ms_post
id|u_long
id|ms_post
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&t;Declaration of structs:&t;&t;target control block&n;**&n;**==========================================================&n;*/
DECL|struct|tcb
r_struct
id|tcb
(brace
multiline_comment|/*&n;&t;**&t;during reselection the ncr jumps to this point&n;&t;**&t;with SFBR set to the encoded target number&n;&t;**&t;with bit 7 set.&n;&t;**&t;if it&squot;s not this target, jump to the next.&n;&t;**&n;&t;**&t;JUMP  IF (SFBR != #target#)&n;&t;**&t;@(next tcb)&n;&t;*/
DECL|member|jump_tcb
r_struct
id|link
id|jump_tcb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;load the actual values for the sxfer and the scntl3&n;&t;**&t;register (sync/wide mode).&n;&t;**&n;&t;**&t;SCR_COPY (1);&n;&t;**&t;@(sval field of this tcb)&n;&t;**&t;@(sxfer register)&n;&t;**&t;SCR_COPY (1);&n;&t;**&t;@(wval field of this tcb)&n;&t;**&t;@(scntl3 register)&n;&t;*/
DECL|member|getscr
id|ncrcmd
id|getscr
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;if next message is &quot;identify&quot;&n;&t;**&t;then load the message to SFBR,&n;&t;**&t;else load 0 to SFBR.&n;&t;**&n;&t;**&t;CALL&n;&t;**&t;&lt;RESEL_LUN&gt;&n;&t;*/
DECL|member|call_lun
r_struct
id|link
id|call_lun
suffix:semicolon
multiline_comment|/*&n;&t;**&t;now look for the right lun.&n;&t;**&n;&t;**&t;JUMP&n;&t;**&t;@(first ccb of this lun)&n;&t;*/
DECL|member|jump_lcb
r_struct
id|link
id|jump_lcb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;pointer to interrupted getcc ccb&n;&t;*/
DECL|member|hold_cp
id|ccb_p
id|hold_cp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;statistical data&n;&t;*/
DECL|member|transfers
id|u_long
id|transfers
suffix:semicolon
DECL|member|bytes
id|u_long
id|bytes
suffix:semicolon
multiline_comment|/*&n;&t;**&t;user settable limits for sync transfer&n;&t;**&t;and tagged commands.&n;&t;*/
DECL|member|usrsync
id|u_char
id|usrsync
suffix:semicolon
DECL|member|usrtags
id|u_char
id|usrtags
suffix:semicolon
DECL|member|usrwide
id|u_char
id|usrwide
suffix:semicolon
DECL|member|usrflag
id|u_char
id|usrflag
suffix:semicolon
multiline_comment|/*&n;&t;**&t;negotiation of wide and synch transfer.&n;&t;**&t;device quirks.&n;&t;*/
DECL|member|minsync
multiline_comment|/*0*/
id|u_char
id|minsync
suffix:semicolon
DECL|member|sval
multiline_comment|/*1*/
id|u_char
id|sval
suffix:semicolon
DECL|member|period
multiline_comment|/*2*/
id|u_short
id|period
suffix:semicolon
DECL|member|maxoffs
multiline_comment|/*0*/
id|u_char
id|maxoffs
suffix:semicolon
DECL|member|quirks
multiline_comment|/*1*/
id|u_char
id|quirks
suffix:semicolon
DECL|member|widedone
multiline_comment|/*2*/
id|u_char
id|widedone
suffix:semicolon
DECL|member|wval
multiline_comment|/*3*/
id|u_char
id|wval
suffix:semicolon
multiline_comment|/*&n;&t;**&t;inquire data&n;&t;*/
DECL|macro|MAX_INQUIRE
mdefine_line|#define MAX_INQUIRE 36
DECL|member|inqdata
id|u_char
id|inqdata
(braket
id|MAX_INQUIRE
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;the lcb&squot;s of this tcb&n;&t;*/
DECL|member|lp
id|lcb_p
id|lp
(braket
id|MAX_LUN
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&t;Declaration of structs:&t;&t;lun control block&n;**&n;**==========================================================&n;*/
DECL|struct|lcb
r_struct
id|lcb
(brace
multiline_comment|/*&n;&t;**&t;during reselection the ncr jumps to this point&n;&t;**&t;with SFBR set to the &quot;Identify&quot; message.&n;&t;**&t;if it&squot;s not this lun, jump to the next.&n;&t;**&n;&t;**&t;JUMP  IF (SFBR != #lun#)&n;&t;**&t;@(next lcb of this target)&n;&t;*/
DECL|member|jump_lcb
r_struct
id|link
id|jump_lcb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;if next message is &quot;simple tag&quot;,&n;&t;**&t;then load the tag to SFBR,&n;&t;**&t;else load 0 to SFBR.&n;&t;**&n;&t;**&t;CALL&n;&t;**&t;&lt;RESEL_TAG&gt;&n;&t;*/
DECL|member|call_tag
r_struct
id|link
id|call_tag
suffix:semicolon
multiline_comment|/*&n;&t;**&t;now look for the right ccb.&n;&t;**&n;&t;**&t;JUMP&n;&t;**&t;@(first ccb of this lun)&n;&t;*/
DECL|member|jump_ccb
r_struct
id|link
id|jump_ccb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;start of the ccb chain&n;&t;*/
DECL|member|next_ccb
id|ccb_p
id|next_ccb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Control of tagged queueing&n;&t;*/
DECL|member|reqccbs
id|u_char
id|reqccbs
suffix:semicolon
DECL|member|actccbs
id|u_char
id|actccbs
suffix:semicolon
DECL|member|reqlink
id|u_char
id|reqlink
suffix:semicolon
DECL|member|actlink
id|u_char
id|actlink
suffix:semicolon
DECL|member|usetags
id|u_char
id|usetags
suffix:semicolon
DECL|member|lasttag
id|u_char
id|lasttag
suffix:semicolon
multiline_comment|/*-----------------------------------------------&n;&t;**&t;Flag to force M_ORDERED_TAG on next command&n;&t;**&t;in order to avoid spurious timeout when&n;&t;**&t;M_SIMPLE_TAG is used for all operations.&n;&t;**-----------------------------------------------&n;&t;*/
DECL|member|force_ordered_tag
id|u_char
id|force_ordered_tag
suffix:semicolon
DECL|macro|NCR_TIMEOUT_INCREASE
mdefine_line|#define NCR_TIMEOUT_INCREASE&t;(5*HZ)
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**      Declaration of structs:     COMMAND control block&n;**&n;**==========================================================&n;**&n;**&t;This substructure is copied from the ccb to a&n;**&t;global address after selection (or reselection)&n;**&t;and copied back before disconnect.&n;**&n;**&t;These fields are accessible to the script processor.&n;**&n;**----------------------------------------------------------&n;*/
DECL|struct|head
r_struct
id|head
(brace
multiline_comment|/*&n;&t;**&t;Execution of a ccb starts at this point.&n;&t;**&t;It&squot;s a jump to the &quot;SELECT&quot; label&n;&t;**&t;of the script.&n;&t;**&n;&t;**&t;After successful selection the script&n;&t;**&t;processor overwrites it with a jump to&n;&t;**&t;the IDLE label of the script.&n;&t;*/
DECL|member|launch
r_struct
id|link
id|launch
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Saved data pointer.&n;&t;**&t;Points to the position in the script&n;&t;**&t;responsible for the actual transfer&n;&t;**&t;of data.&n;&t;**&t;It&squot;s written after reception of a&n;&t;**&t;&quot;SAVE_DATA_POINTER&quot; message.&n;&t;**&t;The goalpointer points after&n;&t;**&t;the last transfer command.&n;&t;*/
DECL|member|savep
id|u_long
id|savep
suffix:semicolon
DECL|member|lastp
id|u_long
id|lastp
suffix:semicolon
DECL|member|goalp
id|u_long
id|goalp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The virtual address of the ccb&n;&t;**&t;containing this header.&n;&t;*/
DECL|member|cp
id|ccb_p
id|cp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;space for some timestamps to gather&n;&t;**&t;profiling data about devices and this driver.&n;&t;*/
DECL|member|stamp
r_struct
id|tstamp
id|stamp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;status fields.&n;&t;*/
DECL|member|status
id|u_char
id|status
(braket
l_int|8
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;The status bytes are used by the host and the script processor.&n;**&n;**&t;The first four byte are copied to the scratchb register&n;**&t;(declared as scr0..scr3 in ncr_reg.h) just after the select/reselect,&n;**&t;and copied back just after disconnecting.&n;**&t;Inside the script the XX_REG are used.&n;**&n;**&t;The last four bytes are used inside the script by &quot;COPY&quot; commands.&n;**&t;Because source and destination must have the same alignment&n;**&t;in a longword, the fields HAVE to be at the choosen offsets.&n;**&t;&t;xerr_st&t;(4)&t;0&t;(0x34)&t;scratcha&n;**&t;&t;sync_st&t;(5)&t;1&t;(0x05)&t;sxfer&n;**&t;&t;wide_st&t;(7)&t;3&t;(0x03)&t;scntl3&n;*/
multiline_comment|/*&n;**&t;First four bytes (script)&n;*/
DECL|macro|QU_REG
mdefine_line|#define  QU_REG&t;scr0
DECL|macro|HS_REG
mdefine_line|#define  HS_REG&t;scr1
DECL|macro|HS_PRT
mdefine_line|#define  HS_PRT&t;nc_scr1
DECL|macro|SS_REG
mdefine_line|#define  SS_REG&t;scr2
DECL|macro|PS_REG
mdefine_line|#define  PS_REG&t;scr3
multiline_comment|/*&n;**&t;First four bytes (host)&n;*/
DECL|macro|actualquirks
mdefine_line|#define  actualquirks  phys.header.status[0]
DECL|macro|host_status
mdefine_line|#define  host_status   phys.header.status[1]
DECL|macro|scsi_status
mdefine_line|#define  scsi_status   phys.header.status[2]
DECL|macro|parity_status
mdefine_line|#define  parity_status phys.header.status[3]
multiline_comment|/*&n;**&t;Last four bytes (script)&n;*/
DECL|macro|xerr_st
mdefine_line|#define  xerr_st       header.status[4]&t;/* MUST be ==0 mod 4 */
DECL|macro|sync_st
mdefine_line|#define  sync_st       header.status[5]&t;/* MUST be ==1 mod 4 */
DECL|macro|nego_st
mdefine_line|#define  nego_st       header.status[6]
DECL|macro|wide_st
mdefine_line|#define  wide_st       header.status[7]&t;/* MUST be ==3 mod 4 */
multiline_comment|/*&n;**&t;Last four bytes (host)&n;*/
DECL|macro|xerr_status
mdefine_line|#define  xerr_status   phys.xerr_st
DECL|macro|sync_status
mdefine_line|#define  sync_status   phys.sync_st
DECL|macro|nego_status
mdefine_line|#define  nego_status   phys.nego_st
DECL|macro|wide_status
mdefine_line|#define  wide_status   phys.wide_st
multiline_comment|/*==========================================================&n;**&n;**      Declaration of structs:     Data structure block&n;**&n;**==========================================================&n;**&n;**&t;During execution of a ccb by the script processor,&n;**&t;the DSA (data structure address) register points&n;**&t;to this substructure of the ccb.&n;**&t;This substructure contains the header with&n;**&t;the script-processor-changable data and&n;**&t;data blocks for the indirect move commands.&n;**&n;**----------------------------------------------------------&n;*/
DECL|struct|dsb
r_struct
id|dsb
(brace
multiline_comment|/*&n;&t;**&t;Header.&n;&t;**&t;Has to be the first entry,&n;&t;**&t;because it&squot;s jumped to by the&n;&t;**&t;script processor&n;&t;*/
DECL|member|header
r_struct
id|head
id|header
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Table data for Script&n;&t;*/
DECL|member|select
r_struct
id|scr_tblsel
id|select
suffix:semicolon
DECL|member|smsg
r_struct
id|scr_tblmove
id|smsg
suffix:semicolon
DECL|member|smsg2
r_struct
id|scr_tblmove
id|smsg2
suffix:semicolon
DECL|member|cmd
r_struct
id|scr_tblmove
id|cmd
suffix:semicolon
DECL|member|scmd
r_struct
id|scr_tblmove
id|scmd
suffix:semicolon
DECL|member|sense
r_struct
id|scr_tblmove
id|sense
suffix:semicolon
DECL|member|data
r_struct
id|scr_tblmove
id|data
(braket
id|MAX_SCATTER
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**      Declaration of structs:     Command control block.&n;**&n;**==========================================================&n;**&n;**&t;During execution of a ccb by the script processor,&n;**&t;the DSA (data structure address) register points&n;**&t;to this substructure of the ccb.&n;**&t;This substructure contains the header with&n;**&t;the script-processor-changable data and then&n;**&t;data blocks for the indirect move commands.&n;**&n;**----------------------------------------------------------&n;*/
DECL|struct|ccb
r_struct
id|ccb
(brace
multiline_comment|/*&n;&t;**&t;during reselection the ncr jumps to this point.&n;&t;**&t;If a &quot;SIMPLE_TAG&quot; message was received,&n;&t;**&t;then SFBR is set to the tag.&n;&t;**&t;else SFBR is set to 0&n;&t;**&t;If looking for another tag, jump to the next ccb.&n;&t;**&n;&t;**&t;JUMP  IF (SFBR != #TAG#)&n;&t;**&t;@(next ccb of this lun)&n;&t;*/
DECL|member|jump_ccb
r_struct
id|link
id|jump_ccb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;After execution of this call, the return address&n;&t;**&t;(in  the TEMP register) points to the following&n;&t;**&t;data structure block.&n;&t;**&t;So copy it to the DSA register, and start&n;&t;**&t;processing of this data structure.&n;&t;**&n;&t;**&t;CALL&n;&t;**&t;&lt;RESEL_TMP&gt;&n;&t;*/
DECL|member|call_tmp
r_struct
id|link
id|call_tmp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;This is the data structure which is&n;&t;**&t;to be executed by the script processor.&n;&t;*/
DECL|member|phys
r_struct
id|dsb
id|phys
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If a data transfer phase is terminated too early&n;&t;**&t;(after reception of a message (i.e. DISCONNECT)),&n;&t;**&t;we have to prepare a mini script to transfer&n;&t;**&t;the rest of the data.&n;&t;*/
DECL|member|patch
id|ncrcmd
id|patch
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The general SCSI driver provides a&n;&t;**&t;pointer to a control block.&n;&t;*/
DECL|member|cmd
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
DECL|member|data_len
r_int
id|data_len
suffix:semicolon
multiline_comment|/*&n;&t;**&t;We prepare a message to be sent after selection,&n;&t;**&t;and a second one to be sent after getcc selection.&n;&t;**      Contents are IDENTIFY and SIMPLE_TAG.&n;&t;**&t;While negotiating sync or wide transfer,&n;&t;**&t;a SDTM or WDTM message is appended.&n;&t;*/
DECL|member|scsi_smsg
id|u_char
id|scsi_smsg
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|scsi_smsg2
id|u_char
id|scsi_smsg2
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Lock this ccb.&n;&t;**&t;Flag is used while looking for a free ccb.&n;&t;*/
DECL|member|magic
id|u_long
id|magic
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Physical address of this instance of ccb&n;&t;*/
DECL|member|p_ccb
id|u_long
id|p_ccb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Completion time out for this job.&n;&t;**&t;It&squot;s set to time of start + allowed number of seconds.&n;&t;*/
DECL|member|tlimit
id|u_long
id|tlimit
suffix:semicolon
multiline_comment|/*&n;&t;**&t;All ccbs of one hostadapter are chained.&n;&t;*/
DECL|member|link_ccb
id|ccb_p
id|link_ccb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;All ccbs of one target/lun are chained.&n;&t;*/
DECL|member|next_ccb
id|ccb_p
id|next_ccb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Sense command&n;&t;*/
DECL|member|sensecmd
id|u_char
id|sensecmd
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Tag for this transfer.&n;&t;**&t;It&squot;s patched into jump_ccb.&n;&t;**&t;If it&squot;s not zero, a SIMPLE_TAG&n;&t;**&t;message is included in smsg.&n;&t;*/
DECL|member|tag
id|u_char
id|tag
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|CCB_PHYS
mdefine_line|#define CCB_PHYS(cp,lbl)&t;(cp-&gt;p_ccb + offsetof(struct ccb, lbl))
multiline_comment|/*==========================================================&n;**&n;**      Declaration of structs:     NCR device descriptor&n;**&n;**==========================================================&n;*/
DECL|struct|ncb
r_struct
id|ncb
(brace
multiline_comment|/*-----------------------------------------------&n;&t;**&t;Specific Linux fields&n;&t;**-----------------------------------------------&n;&t;*/
DECL|member|unit
r_int
id|unit
suffix:semicolon
multiline_comment|/* Unit number                       */
DECL|member|chip
r_int
id|chip
suffix:semicolon
multiline_comment|/* Chip number                       */
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* Timer link header                 */
DECL|member|ncr_cache
r_int
id|ncr_cache
suffix:semicolon
multiline_comment|/* Cache test variable               */
DECL|member|release_stage
r_int
id|release_stage
suffix:semicolon
multiline_comment|/* Synchronisation stage on release  */
DECL|member|waiting_list
id|Scsi_Cmnd
op_star
id|waiting_list
suffix:semicolon
multiline_comment|/* Waiting list header for commands  */
multiline_comment|/* that we can&squot;t put into the squeue */
macro_line|#ifndef NCR_IOMAPPED
r_volatile
r_struct
id|ncr_reg
op_star
DECL|member|reg_remapped
id|reg_remapped
suffix:semicolon
multiline_comment|/* Virtual address of the memory     */
multiline_comment|/* base of the ncr chip              */
DECL|member|use_mmio
r_int
id|use_mmio
suffix:semicolon
multiline_comment|/* Indicate mmio is OK               */
macro_line|#endif
multiline_comment|/*-----------------------------------------------&n;&t;**&t;Added field to support differences&n;&t;**&t;between ncr chips.&n;&t;**-----------------------------------------------&n;&t;*/
DECL|member|device_id
id|u_short
id|device_id
suffix:semicolon
DECL|member|revision_id
id|u_char
id|revision_id
suffix:semicolon
DECL|macro|ChipDevice
mdefine_line|#define ChipDevice&t;((np)-&gt;device_id)
DECL|macro|ChipVersion
mdefine_line|#define ChipVersion&t;((np)-&gt;revision_id &amp; 0xf0)
multiline_comment|/*-----------------------------------------------&n;&t;**&t;Scripts ..&n;&t;**-----------------------------------------------&n;&t;**&n;&t;**&t;During reselection the ncr jumps to this point.&n;&t;**&t;The SFBR register is loaded with the encoded target id.&n;&t;**&n;&t;**&t;Jump to the first target.&n;&t;**&n;&t;**&t;JUMP&n;&t;**&t;@(next tcb)&n;&t;*/
DECL|member|jump_tcb
r_struct
id|link
id|jump_tcb
suffix:semicolon
multiline_comment|/*-----------------------------------------------&n;&t;**&t;Configuration ..&n;&t;**-----------------------------------------------&n;&t;**&n;&t;**&t;virtual and physical addresses&n;&t;**&t;of the 53c810 chip.&n;&t;*/
DECL|member|vaddr
id|vm_offset_t
id|vaddr
suffix:semicolon
DECL|member|paddr
id|vm_offset_t
id|paddr
suffix:semicolon
multiline_comment|/*&n;&t;**&t;pointer to the chip&squot;s registers.&n;&t;*/
r_volatile
DECL|member|reg
r_struct
id|ncr_reg
op_star
id|reg
suffix:semicolon
multiline_comment|/*&n;&t;**&t;A copy of the script, relocated for this ncb.&n;&t;*/
DECL|member|script
r_struct
id|script
op_star
id|script
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Physical address of this instance of ncb-&gt;script&n;&t;*/
DECL|member|p_script
id|u_long
id|p_script
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The SCSI address of the host adapter.&n;&t;*/
DECL|member|myaddr
id|u_char
id|myaddr
suffix:semicolon
multiline_comment|/*&n;&t;**&t;timing parameters&n;&t;*/
DECL|member|ns_async
id|u_char
id|ns_async
suffix:semicolon
DECL|member|ns_sync
id|u_char
id|ns_sync
suffix:semicolon
DECL|member|rv_scntl3
id|u_char
id|rv_scntl3
suffix:semicolon
multiline_comment|/*-----------------------------------------------&n;&t;**&t;Link to the generic SCSI driver&n;&t;**-----------------------------------------------&n;&t;*/
multiline_comment|/* struct scsi_link&t;sc_link; */
multiline_comment|/*-----------------------------------------------&n;&t;**&t;Job control&n;&t;**-----------------------------------------------&n;&t;**&n;&t;**&t;Commands from user&n;&t;*/
DECL|member|user
r_struct
id|usrcmd
id|user
suffix:semicolon
DECL|member|order
id|u_char
id|order
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Target data&n;&t;*/
DECL|member|target
r_struct
id|tcb
id|target
(braket
id|MAX_TARGET
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Start queue.&n;&t;*/
DECL|member|squeue
id|u_long
id|squeue
(braket
id|MAX_START
)braket
suffix:semicolon
DECL|member|squeueput
id|u_short
id|squeueput
suffix:semicolon
DECL|member|actccbs
id|u_short
id|actccbs
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Timeout handler&n;&t;*/
DECL|member|heartbeat
id|u_long
id|heartbeat
suffix:semicolon
DECL|member|ticks
id|u_short
id|ticks
suffix:semicolon
DECL|member|latetime
id|u_short
id|latetime
suffix:semicolon
DECL|member|lasttime
id|u_long
id|lasttime
suffix:semicolon
multiline_comment|/*-----------------------------------------------&n;&t;**&t;Debug and profiling&n;&t;**-----------------------------------------------&n;&t;**&n;&t;**&t;register dump&n;&t;*/
DECL|member|regdump
r_struct
id|ncr_reg
id|regdump
suffix:semicolon
DECL|member|regtime
id|u_long
id|regtime
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Profiling data&n;&t;*/
DECL|member|profile
r_struct
id|profile
id|profile
suffix:semicolon
DECL|member|disc_phys
id|u_long
id|disc_phys
suffix:semicolon
DECL|member|disc_ref
id|u_long
id|disc_ref
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The global header.&n;&t;**&t;Accessible to both the host and the&n;&t;**&t;script-processor.&n;&t;*/
DECL|member|header
r_struct
id|head
id|header
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The global control block.&n;&t;**&t;It&squot;s used only during the configuration phase.&n;&t;**&t;A target control block will be created&n;&t;**&t;after the first successful transfer.&n;&t;*/
DECL|member|ccb
r_struct
id|ccb
id|ccb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;message buffers.&n;&t;**&t;Should be longword aligned,&n;&t;**&t;because they&squot;re written with a&n;&t;**&t;COPY script command.&n;&t;*/
DECL|member|msgout
id|u_char
id|msgout
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|msgin
id|u_char
id|msgin
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|lastmsg
id|u_long
id|lastmsg
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Buffer for STATUS_IN phase.&n;&t;*/
DECL|member|scratch
id|u_char
id|scratch
suffix:semicolon
multiline_comment|/*&n;&t;**&t;controller chip dependent maximal transfer width.&n;&t;*/
DECL|member|maxwide
id|u_char
id|maxwide
suffix:semicolon
multiline_comment|/*&n;&t;**&t;option for M_IDENTIFY message: enables disconnecting&n;&t;*/
DECL|member|disc
id|u_char
id|disc
suffix:semicolon
multiline_comment|/*&n;&t;**&t;address of the ncr control registers in io space&n;&t;*/
DECL|member|port
id|u_int
id|port
suffix:semicolon
multiline_comment|/*&n;&t;**&t;irq level&n;&t;*/
DECL|member|irq
id|u_short
id|irq
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|NCB_SCRIPT_PHYS
mdefine_line|#define NCB_SCRIPT_PHYS(np,lbl)&t;(np-&gt;p_script + offsetof (struct script, lbl))
multiline_comment|/*==========================================================&n;**&n;**&n;**      Script for NCR-Processor.&n;**&n;**&t;Use ncr_script_fill() to create the variable parts.&n;**&t;Use ncr_script_copy_and_bind() to make a copy and&n;**&t;bind to physical addresses.&n;**&n;**&n;**==========================================================&n;**&n;**&t;We have to know the offsets of all labels before&n;**&t;we reach them (for forward jumps).&n;**&t;Therefore we declare a struct here.&n;**&t;If you make changes inside the script,&n;**&t;DONT FORGET TO CHANGE THE LENGTHS HERE!&n;**&n;**----------------------------------------------------------&n;*/
DECL|struct|script
r_struct
id|script
(brace
DECL|member|start
id|ncrcmd
id|start
(braket
l_int|7
)braket
suffix:semicolon
DECL|member|start0
id|ncrcmd
id|start0
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|start1
id|ncrcmd
id|start1
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|startpos
id|ncrcmd
id|startpos
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|tryloop
id|ncrcmd
id|tryloop
(braket
id|MAX_START
op_star
l_int|5
op_plus
l_int|2
)braket
suffix:semicolon
DECL|member|trysel
id|ncrcmd
id|trysel
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|skip
id|ncrcmd
id|skip
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|skip2
id|ncrcmd
id|skip2
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|idle
id|ncrcmd
id|idle
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|select
id|ncrcmd
id|select
(braket
l_int|22
)braket
suffix:semicolon
DECL|member|prepare
id|ncrcmd
id|prepare
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|loadpos
id|ncrcmd
id|loadpos
(braket
l_int|14
)braket
suffix:semicolon
DECL|member|prepare2
id|ncrcmd
id|prepare2
(braket
l_int|24
)braket
suffix:semicolon
DECL|member|setmsg
id|ncrcmd
id|setmsg
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|clrack
id|ncrcmd
id|clrack
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|dispatch
id|ncrcmd
id|dispatch
(braket
l_int|33
)braket
suffix:semicolon
DECL|member|no_data
id|ncrcmd
id|no_data
(braket
l_int|17
)braket
suffix:semicolon
DECL|member|checkatn
id|ncrcmd
id|checkatn
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|command
id|ncrcmd
id|command
(braket
l_int|15
)braket
suffix:semicolon
DECL|member|status
id|ncrcmd
id|status
(braket
l_int|27
)braket
suffix:semicolon
DECL|member|msg_in
id|ncrcmd
id|msg_in
(braket
l_int|26
)braket
suffix:semicolon
DECL|member|msg_bad
id|ncrcmd
id|msg_bad
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|msg_parity
id|ncrcmd
id|msg_parity
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|msg_reject
id|ncrcmd
id|msg_reject
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|msg_ign_residue
id|ncrcmd
id|msg_ign_residue
(braket
l_int|32
)braket
suffix:semicolon
DECL|member|msg_extended
id|ncrcmd
id|msg_extended
(braket
l_int|18
)braket
suffix:semicolon
DECL|member|msg_ext_2
id|ncrcmd
id|msg_ext_2
(braket
l_int|18
)braket
suffix:semicolon
DECL|member|msg_wdtr
id|ncrcmd
id|msg_wdtr
(braket
l_int|27
)braket
suffix:semicolon
DECL|member|msg_ext_3
id|ncrcmd
id|msg_ext_3
(braket
l_int|18
)braket
suffix:semicolon
DECL|member|msg_sdtr
id|ncrcmd
id|msg_sdtr
(braket
l_int|27
)braket
suffix:semicolon
DECL|member|complete
id|ncrcmd
id|complete
(braket
l_int|13
)braket
suffix:semicolon
DECL|member|cleanup
id|ncrcmd
id|cleanup
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|cleanup0
id|ncrcmd
id|cleanup0
(braket
l_int|11
)braket
suffix:semicolon
DECL|member|signal
id|ncrcmd
id|signal
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|save_dp
id|ncrcmd
id|save_dp
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|restore_dp
id|ncrcmd
id|restore_dp
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|disconnect
id|ncrcmd
id|disconnect
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|disconnect0
id|ncrcmd
id|disconnect0
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|disconnect1
id|ncrcmd
id|disconnect1
(braket
l_int|23
)braket
suffix:semicolon
DECL|member|msg_out
id|ncrcmd
id|msg_out
(braket
l_int|9
)braket
suffix:semicolon
DECL|member|msg_out_done
id|ncrcmd
id|msg_out_done
(braket
l_int|7
)braket
suffix:semicolon
DECL|member|msg_out_abort
id|ncrcmd
id|msg_out_abort
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|getcc
id|ncrcmd
id|getcc
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|getcc1
id|ncrcmd
id|getcc1
(braket
l_int|5
)braket
suffix:semicolon
macro_line|#ifdef NCR_GETCC_WITHMSG
DECL|member|getcc2
id|ncrcmd
id|getcc2
(braket
l_int|33
)braket
suffix:semicolon
macro_line|#else
DECL|member|getcc2
id|ncrcmd
id|getcc2
(braket
l_int|14
)braket
suffix:semicolon
macro_line|#endif
DECL|member|getcc3
id|ncrcmd
id|getcc3
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|badgetcc
id|ncrcmd
id|badgetcc
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|reselect
id|ncrcmd
id|reselect
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|reselect2
id|ncrcmd
id|reselect2
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|resel_tmp
id|ncrcmd
id|resel_tmp
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|resel_lun
id|ncrcmd
id|resel_lun
(braket
l_int|18
)braket
suffix:semicolon
DECL|member|resel_tag
id|ncrcmd
id|resel_tag
(braket
l_int|24
)braket
suffix:semicolon
DECL|member|data_in
id|ncrcmd
id|data_in
(braket
id|MAX_SCATTER
op_star
l_int|4
op_plus
l_int|7
)braket
suffix:semicolon
DECL|member|data_out
id|ncrcmd
id|data_out
(braket
id|MAX_SCATTER
op_star
l_int|4
op_plus
l_int|7
)braket
suffix:semicolon
DECL|member|aborttag
id|ncrcmd
id|aborttag
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|abort
id|ncrcmd
m_abort
(braket
l_int|22
)braket
suffix:semicolon
DECL|member|snooptest
id|ncrcmd
id|snooptest
(braket
l_int|9
)braket
suffix:semicolon
DECL|member|snoopend
id|ncrcmd
id|snoopend
(braket
l_int|2
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&n;**      Function headers.&n;**&n;**&n;**==========================================================&n;*/
r_static
r_void
id|ncr_alloc_ccb
(paren
id|ncb_p
id|np
comma
id|u_long
id|t
comma
id|u_long
id|l
)paren
suffix:semicolon
r_static
r_void
id|ncr_complete
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
r_static
r_void
id|ncr_exception
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_free_ccb
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
r_static
r_void
id|ncr_getclock
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
id|ccb_p
id|ncr_get_ccb
(paren
id|ncb_p
id|np
comma
id|u_long
id|t
comma
id|u_long
id|l
)paren
suffix:semicolon
r_static
r_void
id|ncr_init
(paren
id|ncb_p
id|np
comma
r_char
op_star
id|msg
comma
id|u_long
id|code
)paren
suffix:semicolon
r_static
r_int
id|ncr_intr
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_ma
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_sir
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_sto
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
id|u_long
id|ncr_lookup
(paren
r_char
op_star
id|id
)paren
suffix:semicolon
r_static
r_void
id|ncr_negotiate
(paren
r_struct
id|ncb
op_star
id|np
comma
r_struct
id|tcb
op_star
id|tp
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE
r_static
r_int
id|ncr_delta
(paren
id|u_long
id|from
comma
id|u_long
id|to
)paren
suffix:semicolon
r_static
r_void
id|ncb_profile
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|ncr_script_copy_and_bind
(paren
r_struct
id|script
op_star
id|script
comma
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_script_fill
(paren
r_struct
id|script
op_star
id|scr
)paren
suffix:semicolon
r_static
r_int
id|ncr_scatter
(paren
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|ncr_setmaxtags
(paren
id|ncb_p
id|np
comma
id|tcb_p
id|tp
comma
id|u_long
id|usrtags
)paren
suffix:semicolon
r_static
r_void
id|ncr_setsync
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|sxfer
)paren
suffix:semicolon
r_static
r_void
id|ncr_settags
(paren
id|tcb_p
id|tp
comma
id|lcb_p
id|lp
)paren
suffix:semicolon
r_static
r_void
id|ncr_setwide
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|wide
)paren
suffix:semicolon
r_static
r_int
id|ncr_show_msg
(paren
id|u_char
op_star
id|msg
)paren
suffix:semicolon
r_static
r_int
id|ncr_snooptest
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_timeout
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_wakeup
(paren
id|ncb_p
id|np
comma
id|u_long
id|code
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_USER_COMMAND
r_static
r_void
id|ncr_usercmd
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|ncr_attach
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|unit
comma
id|u_short
id|device_id
comma
id|u_char
id|revision_id
comma
r_int
id|chip
comma
id|u_int
id|base
comma
id|u_int
id|io_port
comma
r_int
id|irq
comma
r_int
id|bus
comma
id|u_char
id|device_fn
)paren
suffix:semicolon
r_static
r_void
id|insert_into_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
id|Scsi_Cmnd
op_star
id|remove_from_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|process_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|sts
)paren
suffix:semicolon
DECL|macro|requeue_waiting_list
mdefine_line|#define requeue_waiting_list(np) process_waiting_list((np), DID_OK)
DECL|macro|abort_waiting_list
mdefine_line|#define abort_waiting_list(np) process_waiting_list((np), DID_ABORT)
DECL|macro|reset_waiting_list
mdefine_line|#define reset_waiting_list(np) process_waiting_list((np), DID_RESET)
multiline_comment|/*==========================================================&n;**&n;**&n;**      Global static data.&n;**&n;**&n;**==========================================================&n;*/
macro_line|#if 0
r_static
r_char
id|ident
(braket
)braket
op_assign
l_string|&quot;&bslash;n$Id: ncr.c,v 1.67 1996/03/11 19:36:07 se Exp $&bslash;n&quot;
suffix:semicolon
r_static
id|u_long
id|ncr_version
op_assign
id|NCR_VERSION
op_star
l_int|11
op_plus
(paren
id|u_long
)paren
r_sizeof
(paren
r_struct
id|ncb
)paren
op_star
l_int|7
op_plus
(paren
id|u_long
)paren
r_sizeof
(paren
r_struct
id|ccb
)paren
op_star
l_int|5
op_plus
(paren
id|u_long
)paren
r_sizeof
(paren
r_struct
id|lcb
)paren
op_star
l_int|3
op_plus
(paren
id|u_long
)paren
r_sizeof
(paren
r_struct
id|tcb
)paren
op_star
l_int|2
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SCSI_NCR_DEBUG
DECL|variable|ncr_debug
r_static
r_int
id|ncr_debug
op_assign
id|SCSI_NCR_DEBUG_FLAGS
suffix:semicolon
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&n;**      Global static data:&t;auto configure&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_name
r_static
r_char
op_star
id|ncr_name
(paren
id|ncb_p
id|np
)paren
(brace
r_static
r_char
id|name
(braket
l_int|10
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;ncr53c%d-%d&quot;
comma
id|np-&gt;chip
comma
id|np-&gt;unit
)paren
suffix:semicolon
r_return
(paren
id|name
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      Scripts for NCR-Processor.&n;**&n;**      Use ncr_script_bind for binding to physical addresses.&n;**&n;**&n;**==========================================================&n;**&n;**&t;NADDR generates a reference to a field of the controller data.&n;**&t;PADDR generates a reference to another part of the script.&n;**&t;RADDR generates a reference to a script processor register.&n;**&t;FADDR generates a reference to a script processor register&n;**&t;&t;with offset.&n;**&n;**----------------------------------------------------------&n;*/
DECL|macro|RELOC_SOFTC
mdefine_line|#define&t;RELOC_SOFTC&t;0x40000000
DECL|macro|RELOC_LABEL
mdefine_line|#define&t;RELOC_LABEL&t;0x50000000
DECL|macro|RELOC_REGISTER
mdefine_line|#define&t;RELOC_REGISTER&t;0x60000000
DECL|macro|RELOC_KVAR
mdefine_line|#define&t;RELOC_KVAR&t;0x70000000
DECL|macro|RELOC_MASK
mdefine_line|#define&t;RELOC_MASK&t;0xf0000000
DECL|macro|NADDR
mdefine_line|#define&t;NADDR(label)&t;(RELOC_SOFTC | offsetof(struct ncb, label))
DECL|macro|PADDR
mdefine_line|#define PADDR(label)    (RELOC_LABEL | offsetof(struct script, label))
DECL|macro|RADDR
mdefine_line|#define&t;RADDR(label)&t;(RELOC_REGISTER | REG(label))
DECL|macro|FADDR
mdefine_line|#define&t;FADDR(label,ofs)(RELOC_REGISTER | ((REG(label))+(ofs)))
DECL|macro|KVAR
mdefine_line|#define&t;KVAR(which)&t;(RELOC_KVAR | (which))
DECL|macro|SCRIPT_KVAR_JIFFIES
mdefine_line|#define&t;SCRIPT_KVAR_JIFFIES&t;(0)
DECL|macro|SCRIPT_KVAR_FIRST
mdefine_line|#define&t;SCRIPT_KVAR_FIRST&t;&t;SCRIPT_KVAR_JIFFIES
DECL|macro|SCRIPT_KVAR_LAST
mdefine_line|#define&t;SCRIPT_KVAR_LAST&t;&t;SCRIPT_KVAR_JIFFIES
multiline_comment|/*&n; * Kernel variables referenced in the scripts.&n; * THESE MUST ALL BE ALIGNED TO A 4-BYTE BOUNDARY.&n; */
DECL|variable|script_kvars
r_static
r_void
op_star
id|script_kvars
(braket
)braket
op_assign
(brace
(paren
r_void
op_star
)paren
op_amp
id|jiffies
)brace
suffix:semicolon
DECL|variable|script0
r_static
r_struct
id|script
id|script0
op_assign
(brace
multiline_comment|/*--------------------------&lt; START &gt;-----------------------*/
(brace
multiline_comment|/*&n;&t;**&t;Claim to be still alive ...&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
(paren
(paren
r_struct
id|ncb
op_star
)paren
l_int|0
)paren
op_member_access_from_pointer
id|heartbeat
)paren
)paren
comma
id|KVAR
c_func
(paren
id|SCRIPT_KVAR_JIFFIES
)paren
comma
id|NADDR
(paren
id|heartbeat
)paren
comma
multiline_comment|/*&n;&t;**      Make data structure address invalid.&n;&t;**      clear SIGP.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|dsa
comma
l_int|0xff
)paren
comma
l_int|0
comma
id|SCR_FROM_REG
(paren
id|ctest2
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; START0 &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Hook for interrupted GetConditionCode.&n;&t;**&t;Will be patched to ... IFTRUE by&n;&t;**&t;the interrupt handler.&n;&t;*/
id|SCR_INT
op_xor
id|IFFALSE
(paren
l_int|0
)paren
comma
id|SIR_SENSE_RESTART
comma
)brace
multiline_comment|/*-------------------------&lt; START1 &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Hook for stalled start queue.&n;&t;**&t;Will be patched to IFTRUE by the interrupt handler.&n;&t;*/
id|SCR_INT
op_xor
id|IFFALSE
(paren
l_int|0
)paren
comma
id|SIR_STALL_RESTART
comma
multiline_comment|/*&n;&t;**&t;Then jump to a certain point in tryloop.&n;&t;**&t;Due to the lack of indirect addressing the code&n;&t;**&t;is self modifying here.&n;&t;*/
id|SCR_JUMP
comma
)brace
multiline_comment|/*-------------------------&lt; STARTPOS &gt;--------------------*/
comma
(brace
id|PADDR
c_func
(paren
id|tryloop
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; TRYLOOP &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;**&t;Load an entry of the start queue into dsa&n;**&t;and try to start it by jumping to TRYSEL.&n;**&n;**&t;Because the size depends on the&n;**&t;#define MAX_START parameter, it is filled&n;**&t;in at runtime.&n;**&n;**-----------------------------------------------------------&n;**&n;**  ##===========&lt; I=0; i&lt;MAX_START &gt;===========&n;**  ||&t;SCR_COPY (4),&n;**  ||&t;&t;NADDR (squeue[i]),&n;**  ||&t;&t;RADDR (dsa),&n;**  ||&t;SCR_CALL,&n;**  ||&t;&t;PADDR (trysel),&n;**  ##==========================================&n;**&n;**&t;SCR_JUMP,&n;**&t;&t;PADDR(tryloop),&n;**&n;**-----------------------------------------------------------&n;*/
l_int|0
)brace
multiline_comment|/*-------------------------&lt; TRYSEL &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Now:&n;&t;**&t;DSA: Address of a Data Structure&n;&t;**&t;or   Address of the IDLE-Label.&n;&t;**&n;&t;**&t;TEMP:&t;Address of a script, which tries to&n;&t;**&t;&t;start the NEXT entry.&n;&t;**&n;&t;**&t;Save the TEMP register into the SCRATCHA register.&n;&t;**&t;Then copy the DSA to TEMP and RETURN.&n;&t;**&t;This is kind of an indirect jump.&n;&t;**&t;(The script processor has NO stack, so the&n;&t;**&t;CALL is actually a jump and link, and the&n;&t;**&t;RETURN is an indirect jump.)&n;&t;**&n;&t;**&t;If the slot was empty, DSA contains the address&n;&t;**&t;of the IDLE part of this script. The processor&n;&t;**&t;jumps to IDLE and waits for a reselect.&n;&t;**&t;It will wake up and try the same slot again&n;&t;**&t;after the SIGP bit becomes set by the host.&n;&t;**&n;&t;**&t;If the slot was not empty, DSA contains&n;&t;**&t;the address of the phys-part of a ccb.&n;&t;**&t;The processor jumps to this address.&n;&t;**&t;phys starts with head,&n;&t;**&t;head starts with launch,&n;&t;**&t;so actually the processor jumps to&n;&t;**&t;the lauch part.&n;&t;**&t;If the entry is scheduled for execution,&n;&t;**&t;then launch contains a jump to SELECT.&n;&t;**&t;If it&squot;s not scheduled, it contains a jump to IDLE.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|dsa
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|SCR_RETURN
comma
l_int|0
)brace
multiline_comment|/*-------------------------&lt; SKIP &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;This entry has been canceled.&n;&t;**&t;Next time use the next slot.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|PADDR
(paren
id|startpos
)paren
comma
multiline_comment|/*&n;&t;**&t;patch the launch field.&n;&t;**&t;should look like an idle process.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|dsa
)paren
comma
id|PADDR
(paren
id|skip2
)paren
comma
id|SCR_COPY
(paren
l_int|8
)paren
comma
id|PADDR
(paren
id|idle
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SKIP2 &gt;-----------------------*/
comma
(brace
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
c_func
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; IDLE &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Nothing to do?&n;&t;**&t;Wait for reselect.&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
c_func
(paren
id|reselect
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SELECT &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;DSA&t;contains the address of a scheduled&n;&t;**&t;&t;data structure.&n;&t;**&n;&t;**&t;SCRATCHA contains the address of the script,&n;&t;**&t;&t;which starts the next entry.&n;&t;**&n;&t;**&t;Set Initiator mode.&n;&t;**&n;&t;**&t;(Target mode is left as an exercise for the reader)&n;&t;*/
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
l_int|0xff
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**      And try to select this target.&n;&t;*/
id|SCR_SEL_TBL_ATN
op_xor
m_offsetof
(paren
r_struct
id|dsb
comma
id|select
)paren
comma
id|PADDR
(paren
id|reselect
)paren
comma
multiline_comment|/*&n;&t;**&t;Now there are 4 possibilities:&n;&t;**&n;&t;**&t;(1) The ncr looses arbitration.&n;&t;**&t;This is ok, because it will try again,&n;&t;**&t;when the bus becomes idle.&n;&t;**&t;(But beware of the timeout function!)&n;&t;**&n;&t;**&t;(2) The ncr is reselected.&n;&t;**&t;Then the script processor takes the jump&n;&t;**&t;to the RESELECT label.&n;&t;**&n;&t;**&t;(3) The ncr completes the selection.&n;&t;**&t;Then it will execute the next statement.&n;&t;**&n;&t;**&t;(4) There is a selection timeout.&n;&t;**&t;Then the ncr should interrupt the host and stop.&n;&t;**&t;Unfortunately, it seems to continue execution&n;&t;**&t;of the script. But it will fail with an&n;&t;**&t;IID-interrupt on the next WHEN.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Save target id to ctest0 register&n;&t;*/
id|SCR_FROM_REG
(paren
id|sdid
)paren
comma
l_int|0
comma
id|SCR_TO_REG
(paren
id|ctest0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Send the IDENTIFY and SIMPLE_TAG messages&n;&t;**&t;(and the M_X_SYNC_REQ message)&n;&t;*/
id|SCR_MOVE_TBL
op_xor
id|SCR_MSG_OUT
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|smsg
)paren
comma
macro_line|#ifdef undef /* XXX better fail than try to deal with this ... */
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
op_minus
l_int|16
comma
macro_line|#endif
id|SCR_CLR
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|sfbr
)paren
comma
id|NADDR
(paren
id|lastmsg
)paren
comma
multiline_comment|/*&n;&t;**&t;Selection complete.&n;&t;**&t;Next time use the next slot.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|PADDR
(paren
id|startpos
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PREPARE &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**      The ncr doesn&squot;t have an indirect load&n;&t;**&t;or store command. So we have to&n;&t;**&t;copy part of the control block to a&n;&t;**&t;fixed place, where we can access it.&n;&t;**&n;&t;**&t;We patch the address part of a&n;&t;**&t;COPY command with the DSA-register.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|dsa
)paren
comma
id|PADDR
(paren
id|loadpos
)paren
comma
multiline_comment|/*&n;&t;**&t;then we do the actual copy.&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|head
)paren
)paren
comma
multiline_comment|/*&n;&t;**&t;continued after the next label ...&n;&t;*/
)brace
multiline_comment|/*-------------------------&lt; LOADPOS &gt;---------------------*/
comma
(brace
l_int|0
comma
id|NADDR
(paren
id|header
)paren
comma
multiline_comment|/*&n;&t;**      Mark this ccb as not scheduled.&n;&t;*/
id|SCR_COPY
(paren
l_int|8
)paren
comma
id|PADDR
(paren
id|idle
)paren
comma
id|NADDR
(paren
id|header.launch
)paren
comma
multiline_comment|/*&n;&t;**      Set a time stamp for this selection&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
id|u_long
)paren
)paren
comma
id|KVAR
c_func
(paren
id|SCRIPT_KVAR_JIFFIES
)paren
comma
id|NADDR
(paren
id|header.stamp.select
)paren
comma
multiline_comment|/*&n;&t;**      load the savep (saved pointer) into&n;&t;**      the TEMP register (actual pointer)&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|header.savep
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
multiline_comment|/*&n;&t;**      Initialize the status registers&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|header.status
)paren
comma
id|RADDR
(paren
id|scr0
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PREPARE2 &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t;**      Load the synchronous mode register&n;&t;*/
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|NADDR
(paren
id|sync_st
)paren
comma
id|RADDR
(paren
id|sxfer
)paren
comma
multiline_comment|/*&n;&t;**      Load the wide mode and timing register&n;&t;*/
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|NADDR
(paren
id|wide_st
)paren
comma
id|RADDR
(paren
id|scntl3
)paren
comma
multiline_comment|/*&n;&t;**&t;Initialize the msgout buffer with a NOOP message.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_NOOP
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|msgin
)paren
comma
multiline_comment|/*&n;&t;**&t;Message in phase ?&n;&t;*/
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;Extended or reject message ?&n;&t;*/
id|SCR_FROM_REG
(paren
id|sbdl
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_EXTENDED
)paren
)paren
comma
id|PADDR
(paren
id|msg_in
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_REJECT
)paren
)paren
comma
id|PADDR
(paren
id|msg_reject
)paren
comma
multiline_comment|/*&n;&t;**&t;normal processing&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SETMSG &gt;----------------------*/
comma
(brace
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; CLRACK &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Terminate possible pending message phase.&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-----------------------&lt; DISPATCH &gt;----------------------*/
comma
(brace
id|SCR_FROM_REG
(paren
id|HS_REG
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|HS_NEGOTIATE
)paren
)paren
comma
id|SIR_NEGO_FAILED
comma
multiline_comment|/*&n;&t;**&t;remove bogus output signals&n;&t;*/
id|SCR_REG_REG
(paren
id|socl
comma
id|SCR_AND
comma
id|CACK
op_or
id|CATN
)paren
comma
l_int|0
comma
id|SCR_RETURN
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
l_int|0
comma
id|SCR_RETURN
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_DATA_IN
)paren
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR
(paren
id|msg_out
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|msg_in
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_COMMAND
)paren
)paren
comma
id|PADDR
(paren
id|command
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_STATUS
)paren
)paren
comma
id|PADDR
(paren
id|status
)paren
comma
multiline_comment|/*&n;&t;**      Discard one illegal phase byte, if required.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|XE_BAD_PHASE
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|xerr_st
)paren
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|IF
(paren
id|SCR_ILG_OUT
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_ILG_OUT
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|IF
(paren
id|SCR_ILG_IN
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_ILG_IN
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; NO_DATA &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;The target wants to tranfer too much data&n;&t;**&t;or in the wrong direction.&n;&t;**      Remember that in extended error.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|XE_EXTRA_DATA
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|xerr_st
)paren
comma
multiline_comment|/*&n;&t;**      Discard one data byte, if required.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_DATA_OUT
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|IF
(paren
id|SCR_DATA_IN
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_DATA_IN
comma
id|NADDR
(paren
id|scratch
)paren
comma
multiline_comment|/*&n;&t;**      .. and repeat as required.&n;&t;*/
id|SCR_CALL
comma
id|PADDR
(paren
id|dispatch
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|no_data
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; CHECKATN &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;If AAP (bit 1 of scntl0 register) is set&n;&t;**&t;and a parity error is detected,&n;&t;**&t;the script processor asserts ATN.&n;&t;**&n;&t;**&t;The target should switch to a MSG_OUT phase&n;&t;**&t;to get the message.&n;&t;*/
id|SCR_FROM_REG
(paren
id|socl
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|CATN
comma
id|CATN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;count it&n;&t;*/
id|SCR_REG_REG
(paren
id|PS_REG
comma
id|SCR_ADD
comma
l_int|1
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Prepare a M_ID_ERROR message&n;&t;**&t;(initiator detected error).&n;&t;**&t;The target should retry the transfer.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_ID_ERROR
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|setmsg
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; COMMAND &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;If this is not a GETCC transfer ...&n;&t;*/
id|SCR_FROM_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|S_CHECK_COND
)paren
)paren
comma
l_int|28
comma
multiline_comment|/*&n;&t;**&t;... set a timestamp ...&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
id|u_long
)paren
)paren
comma
id|KVAR
c_func
(paren
id|SCRIPT_KVAR_JIFFIES
)paren
comma
id|NADDR
(paren
id|header.stamp.command
)paren
comma
multiline_comment|/*&n;&t;**&t;... and send the command&n;&t;*/
id|SCR_MOVE_TBL
op_xor
id|SCR_COMMAND
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|cmd
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;Send the GETCC command&n;&t;*/
multiline_comment|/*&gt;&gt;&gt;*/
id|SCR_MOVE_TBL
op_xor
id|SCR_COMMAND
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|scmd
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; STATUS &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;set the timestamp.&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
id|u_long
)paren
)paren
comma
id|KVAR
c_func
(paren
id|SCRIPT_KVAR_JIFFIES
)paren
comma
id|NADDR
(paren
id|header.stamp.status
)paren
comma
multiline_comment|/*&n;&t;**&t;If this is a GETCC transfer,&n;&t;*/
id|SCR_FROM_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|S_CHECK_COND
)paren
)paren
comma
l_int|40
comma
multiline_comment|/*&n;&t;**&t;get the status&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_STATUS
comma
id|NADDR
(paren
id|scratch
)paren
comma
multiline_comment|/*&n;&t;**&t;Save status to scsi_status.&n;&t;**&t;Mark as complete.&n;&t;**&t;And wait for disconnect.&n;&t;*/
id|SCR_TO_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|SS_REG
comma
id|SCR_OR
comma
id|S_SENSE
)paren
comma
l_int|0
comma
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_COMPLETE
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|checkatn
)paren
comma
multiline_comment|/*&n;&t;**&t;If it was no GETCC transfer,&n;&t;**&t;save the status to scsi_status.&n;&t;*/
multiline_comment|/*&gt;&gt;&gt;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_STATUS
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_TO_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;if it was no check condition ...&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|S_CHECK_COND
)paren
)paren
comma
id|PADDR
(paren
id|checkatn
)paren
comma
multiline_comment|/*&n;&t;**&t;... mark as complete.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_COMPLETE
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|checkatn
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IN &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Get the first byte of the message&n;&t;**&t;and save it to SCRATCHA.&n;&t;**&n;&t;**&t;The script processor doesn&squot;t negate the&n;&t;**&t;ACK signal after this transfer.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|0
)braket
)paren
comma
multiline_comment|/*&n;&t;**&t;Check for message parity error.&n;&t;*/
id|SCR_TO_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_FROM_REG
(paren
id|socl
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|CATN
comma
id|CATN
)paren
)paren
comma
id|PADDR
(paren
id|msg_parity
)paren
comma
id|SCR_FROM_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Parity was ok, handle this message.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_COMPLETE
)paren
)paren
comma
id|PADDR
(paren
id|complete
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_SAVE_DP
)paren
)paren
comma
id|PADDR
(paren
id|save_dp
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_RESTORE_DP
)paren
)paren
comma
id|PADDR
(paren
id|restore_dp
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_DISCONNECT
)paren
)paren
comma
id|PADDR
(paren
id|disconnect
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_EXTENDED
)paren
)paren
comma
id|PADDR
(paren
id|msg_extended
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_NOOP
)paren
)paren
comma
id|PADDR
(paren
id|clrack
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_REJECT
)paren
)paren
comma
id|PADDR
(paren
id|msg_reject
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_IGN_RESIDUE
)paren
)paren
comma
id|PADDR
(paren
id|msg_ign_residue
)paren
comma
multiline_comment|/*&n;&t;**&t;Rest of the messages left as&n;&t;**&t;an exercise ...&n;&t;**&n;&t;**&t;Unimplemented messages:&n;&t;**&t;fall through to MSG_BAD.&n;&t;*/
)brace
multiline_comment|/*-------------------------&lt; MSG_BAD &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;unimplemented message - reject it.&n;&t;*/
id|SCR_INT
comma
id|SIR_REJECT_SENT
comma
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_REJECT
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|setmsg
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_PARITY &gt;---------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;count it&n;&t;*/
id|SCR_REG_REG
(paren
id|PS_REG
comma
id|SCR_ADD
comma
l_int|0x01
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;send a &quot;message parity error&quot; message.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_PARITY
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|setmsg
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_REJECT &gt;---------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;If a negotiation was in progress,&n;&t;**&t;negotiation failed.&n;&t;*/
id|SCR_FROM_REG
(paren
id|HS_REG
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|HS_NEGOTIATE
)paren
)paren
comma
id|SIR_NEGO_FAILED
comma
multiline_comment|/*&n;&t;**&t;else make host log this message&n;&t;*/
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|HS_NEGOTIATE
)paren
)paren
comma
id|SIR_REJECT_RECEIVED
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IGN_RESIDUE &gt;----------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Terminate cycle&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get residue size.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|1
)braket
)paren
comma
multiline_comment|/*&n;&t;**&t;Check for message parity error.&n;&t;*/
id|SCR_TO_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_FROM_REG
(paren
id|socl
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|CATN
comma
id|CATN
)paren
)paren
comma
id|PADDR
(paren
id|msg_parity
)paren
comma
id|SCR_FROM_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Size is 0 .. ignore message.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
l_int|0
)paren
)paren
comma
id|PADDR
(paren
id|clrack
)paren
comma
multiline_comment|/*&n;&t;**&t;Size is not 1 .. have to interrupt.&n;&t;*/
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|1
)paren
)paren
comma
l_int|40
comma
multiline_comment|/*&n;&t;**&t;Check for residue byte in swide register&n;&t;*/
id|SCR_FROM_REG
(paren
id|scntl2
)paren
comma
l_int|0
comma
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|WSR
comma
id|WSR
)paren
)paren
comma
l_int|16
comma
multiline_comment|/*&n;&t;**&t;There IS data in the swide register.&n;&t;**&t;Discard it.&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_OR
comma
id|WSR
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
multiline_comment|/*&n;&t;**&t;Load again the size to the sfbr register.&n;&t;*/
multiline_comment|/*&gt;&gt;&gt;*/
id|SCR_FROM_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
multiline_comment|/*&gt;&gt;&gt;*/
id|SCR_INT
comma
id|SIR_IGN_RESIDUE
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_EXTENDED &gt;-------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Terminate cycle&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get length.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|1
)braket
)paren
comma
multiline_comment|/*&n;&t;**&t;Check for message parity error.&n;&t;*/
id|SCR_TO_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_FROM_REG
(paren
id|socl
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|CATN
comma
id|CATN
)paren
)paren
comma
id|PADDR
(paren
id|msg_parity
)paren
comma
id|SCR_FROM_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
l_int|3
)paren
)paren
comma
id|PADDR
(paren
id|msg_ext_3
)paren
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|2
)paren
)paren
comma
id|PADDR
(paren
id|msg_bad
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_EXT_2 &gt;----------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get extended message code.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|2
)braket
)paren
comma
multiline_comment|/*&n;&t;**&t;Check for message parity error.&n;&t;*/
id|SCR_TO_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_FROM_REG
(paren
id|socl
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|CATN
comma
id|CATN
)paren
)paren
comma
id|PADDR
(paren
id|msg_parity
)paren
comma
id|SCR_FROM_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_X_WIDE_REQ
)paren
)paren
comma
id|PADDR
(paren
id|msg_wdtr
)paren
comma
multiline_comment|/*&n;&t;**&t;unknown extended message&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|msg_bad
)paren
)brace
multiline_comment|/*-------------------------&lt; MSG_WDTR &gt;-----------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get data bus width&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|3
)braket
)paren
comma
id|SCR_FROM_REG
(paren
id|socl
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|CATN
comma
id|CATN
)paren
)paren
comma
id|PADDR
(paren
id|msg_parity
)paren
comma
multiline_comment|/*&n;&t;**&t;let the host do the real work.&n;&t;*/
id|SCR_INT
comma
id|SIR_NEGO_WIDE
comma
multiline_comment|/*&n;&t;**&t;let the target fetch our answer.&n;&t;*/
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|SIR_NEGO_PROTO
comma
multiline_comment|/*&n;&t;**&t;Send the M_X_WIDE_REQ&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|4
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_CLR
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|sfbr
)paren
comma
id|NADDR
(paren
id|lastmsg
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|msg_out_done
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_EXT_3 &gt;----------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get extended message code.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|2
)braket
)paren
comma
multiline_comment|/*&n;&t;**&t;Check for message parity error.&n;&t;*/
id|SCR_TO_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_FROM_REG
(paren
id|socl
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|CATN
comma
id|CATN
)paren
)paren
comma
id|PADDR
(paren
id|msg_parity
)paren
comma
id|SCR_FROM_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_X_SYNC_REQ
)paren
)paren
comma
id|PADDR
(paren
id|msg_sdtr
)paren
comma
multiline_comment|/*&n;&t;**&t;unknown extended message&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|msg_bad
)paren
)brace
multiline_comment|/*-------------------------&lt; MSG_SDTR &gt;-----------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get period and offset&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|2
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|3
)braket
)paren
comma
id|SCR_FROM_REG
(paren
id|socl
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|CATN
comma
id|CATN
)paren
)paren
comma
id|PADDR
(paren
id|msg_parity
)paren
comma
multiline_comment|/*&n;&t;**&t;let the host do the real work.&n;&t;*/
id|SCR_INT
comma
id|SIR_NEGO_SYNC
comma
multiline_comment|/*&n;&t;**&t;let the target fetch our answer.&n;&t;*/
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|SIR_NEGO_PROTO
comma
multiline_comment|/*&n;&t;**&t;Send the M_X_SYNC_REQ&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|5
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_CLR
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|sfbr
)paren
comma
id|NADDR
(paren
id|lastmsg
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|msg_out_done
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; COMPLETE &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Complete message.&n;&t;**&n;&t;**&t;If it&squot;s not the get condition code,&n;&t;**&t;copy TEMP register to LASTP in header.&n;&t;*/
id|SCR_FROM_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|S_SENSE
comma
id|S_SENSE
)paren
)paren
comma
l_int|12
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|NADDR
(paren
id|header.lastp
)paren
comma
multiline_comment|/*&gt;&gt;&gt;*/
multiline_comment|/*&n;&t;**&t;When we terminate the cycle by clearing ACK,&n;&t;**&t;the target may disconnect immediately.&n;&t;**&n;&t;**&t;We don&squot;t want to be told of an&n;&t;**&t;&quot;unexpected disconnect&quot;,&n;&t;**&t;so we disable this feature.&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Terminate cycle ...&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;... and wait for the disconnect.&n;&t;*/
id|SCR_WAIT_DISC
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; CLEANUP &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**      dsa:    Pointer to ccb&n;&t;**&t;      or xxxxxxFF (no ccb)&n;&t;**&n;&t;**      HS_REG:   Host-Status (&lt;&gt;0!)&n;&t;*/
id|SCR_FROM_REG
(paren
id|dsa
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
l_int|0xff
)paren
)paren
comma
id|PADDR
(paren
id|signal
)paren
comma
multiline_comment|/*&n;&t;**      dsa is valid.&n;&t;**&t;save the status registers&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|scr0
)paren
comma
id|NADDR
(paren
id|header.status
)paren
comma
multiline_comment|/*&n;&t;**&t;and copy back the header to the ccb.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|dsa
)paren
comma
id|PADDR
(paren
id|cleanup0
)paren
comma
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|head
)paren
)paren
comma
id|NADDR
(paren
id|header
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; CLEANUP0 &gt;--------------------*/
comma
(brace
l_int|0
comma
multiline_comment|/*&n;&t;**&t;If command resulted in &quot;check condition&quot;&n;&t;**&t;status and is not yet completed,&n;&t;**&t;try to get the condition code.&n;&t;*/
id|SCR_FROM_REG
(paren
id|HS_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
l_int|0
comma
id|HS_DONEMASK
)paren
)paren
comma
l_int|16
comma
id|SCR_FROM_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|S_CHECK_COND
)paren
)paren
comma
id|PADDR
c_func
(paren
id|getcc2
)paren
comma
multiline_comment|/*&n;&t;**&t;And make the DSA register invalid.&n;&t;*/
multiline_comment|/*&gt;&gt;&gt;*/
id|SCR_LOAD_REG
(paren
id|dsa
comma
l_int|0xff
)paren
comma
multiline_comment|/* invalid */
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; SIGNAL &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;if status = queue full,&n;&t;**&t;reinsert in startqueue and stall queue.&n;&t;*/
id|SCR_FROM_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|S_QUEUE_FULL
)paren
)paren
comma
id|SIR_STALL_QUEUE
comma
multiline_comment|/*&n;&t;**&t;if job completed ...&n;&t;*/
id|SCR_FROM_REG
(paren
id|HS_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;... signal completion to the host&n;&t;*/
id|SCR_INT_FLY
op_xor
id|IFFALSE
(paren
id|MASK
(paren
l_int|0
comma
id|HS_DONEMASK
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Auf zu neuen Schandtaten!&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
c_func
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SAVE_DP &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;SAVE_DP message:&n;&t;**&t;Copy TEMP register to SAVEP in header.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|NADDR
(paren
id|header.savep
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESTORE_DP &gt;---------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;RESTORE_DP message:&n;&t;**&t;Copy SAVEP in header to TEMP register.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|header.savep
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DISCONNECT &gt;---------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;If QUIRK_AUTOSAVE is set,&n;&t;**&t;do an &quot;save pointer&quot; operation.&n;&t;*/
id|SCR_FROM_REG
(paren
id|QU_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|QUIRK_AUTOSAVE
comma
id|QUIRK_AUTOSAVE
)paren
)paren
comma
l_int|12
comma
multiline_comment|/*&n;&t;**&t;like SAVE_DP message:&n;&t;**&t;Copy TEMP register to SAVEP in header.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|NADDR
(paren
id|header.savep
)paren
comma
multiline_comment|/*&gt;&gt;&gt;*/
multiline_comment|/*&n;&t;**&t;Check if temp==savep or temp==goalp:&n;&t;**&t;if not, log a missing save pointer message.&n;&t;**&t;In fact, it&squot;s a comparison mod 256.&n;&t;**&n;&t;**&t;Hmmm, I hadn&squot;t thought that I would be urged to&n;&t;**&t;write this kind of ugly self modifying code.&n;&t;**&n;&t;**&t;It&squot;s unbelievable, but the ncr53c8xx isn&squot;t able&n;&t;**&t;to subtract one register from another.&n;&t;*/
id|SCR_FROM_REG
(paren
id|temp
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;You are not expected to understand this ..&n;&t;**&n;&t;**&t;CAUTION: only little endian architectures supported! XXX&n;&t;*/
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|NADDR
(paren
id|header.savep
)paren
comma
id|PADDR
(paren
id|disconnect0
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DISCONNECT0 &gt;--------------*/
comma
(brace
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|DATA
(paren
l_int|1
)paren
)paren
comma
l_int|20
comma
multiline_comment|/*&n;&t;**&t;neither this&n;&t;*/
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|NADDR
(paren
id|header.goalp
)paren
comma
id|PADDR
(paren
id|disconnect1
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DISCONNECT1 &gt;--------------*/
comma
(brace
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|1
)paren
)paren
comma
id|SIR_MISSING_SAVE
comma
multiline_comment|/*&gt;&gt;&gt;*/
multiline_comment|/*&n;&t;**&t;DISCONNECTing  ...&n;&t;**&n;&t;**&t;disable the &quot;unexpected disconnect&quot; feature,&n;&t;**&t;and remove the ACK signal.&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Wait for the disconnect.&n;&t;*/
id|SCR_WAIT_DISC
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Profiling:&n;&t;**&t;Set a time stamp,&n;&t;**&t;and count the disconnects.&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
id|u_long
)paren
)paren
comma
id|KVAR
c_func
(paren
id|SCRIPT_KVAR_JIFFIES
)paren
comma
id|NADDR
(paren
id|header.stamp.disconnect
)paren
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|disc_phys
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|SCR_REG_REG
(paren
id|temp
comma
id|SCR_ADD
comma
l_int|0x01
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|NADDR
(paren
id|disc_phys
)paren
comma
multiline_comment|/*&n;&t;**&t;Status is: DISCONNECTED.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_DISCONNECT
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|cleanup
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_OUT &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;The target requests a message.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|sfbr
)paren
comma
id|NADDR
(paren
id|lastmsg
)paren
comma
multiline_comment|/*&n;&t;**&t;If it was no ABORT message ...&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_ABORT
)paren
)paren
comma
id|PADDR
(paren
id|msg_out_abort
)paren
comma
multiline_comment|/*&n;&t;**&t;... wait for the next phase&n;&t;**&t;if it&squot;s a message out, send it again, ...&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR
(paren
id|msg_out
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_OUT_DONE &gt;--------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;... else clear the message ...&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_NOOP
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|msgout
)paren
comma
multiline_comment|/*&n;&t;**&t;... and process the next phase&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_OUT_ABORT &gt;-------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;After ABORT message,&n;&t;**&n;&t;**&t;expect an immediate disconnect, ...&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_WAIT_DISC
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;... and set the status to &quot;ABORTED&quot;&n;&t;*/
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_ABORTED
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|cleanup
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; GETCC &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;The ncr doesn&squot;t have an indirect load&n;&t;**&t;or store command. So we have to&n;&t;**&t;copy part of the control block to a&n;&t;**&t;fixed place, where we can modify it.&n;&t;**&n;&t;**&t;We patch the address part of a COPY command&n;&t;**&t;with the address of the dsa register ...&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|dsa
)paren
comma
id|PADDR
(paren
id|getcc1
)paren
comma
multiline_comment|/*&n;&t;**&t;... then we do the actual copy.&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|head
)paren
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; GETCC1 &gt;----------------------*/
comma
(brace
l_int|0
comma
id|NADDR
(paren
id|header
)paren
comma
multiline_comment|/*&n;&t;**&t;Initialize the status registers&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|header.status
)paren
comma
id|RADDR
(paren
id|scr0
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; GETCC2 &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Get the condition code from a target.&n;&t;**&n;&t;**&t;DSA points to a data structure.&n;&t;**&t;Set TEMP to the script location&n;&t;**&t;that receives the condition code.&n;&t;**&n;&t;**&t;Because there is no script command&n;&t;**&t;to load a longword into a register,&n;&t;**&t;we use a CALL command.&n;&t;*/
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_CALLR
comma
l_int|24
comma
multiline_comment|/*&n;&t;**&t;Get the condition code.&n;&t;*/
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|sense
)paren
comma
multiline_comment|/*&n;&t;**&t;No data phase may follow!&n;&t;*/
id|SCR_CALL
comma
id|PADDR
(paren
id|checkatn
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|no_data
)paren
comma
multiline_comment|/*&gt;&gt;&gt;*/
multiline_comment|/*&n;&t;**&t;The CALL jumps to this point.&n;&t;**&t;Prepare for a RESTORE_POINTER message.&n;&t;**&t;Save the TEMP register into the saved pointer.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|NADDR
(paren
id|header.savep
)paren
comma
multiline_comment|/*&n;&t;**&t;Load scratcha, because in case of a selection timeout,&n;&t;**&t;the host will expect a new value for startpos in&n;&t;**&t;the scratcha register.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|PADDR
(paren
id|startpos
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
macro_line|#ifdef NCR_GETCC_WITHMSG
multiline_comment|/*&n;&t;**&t;If QUIRK_NOMSG is set, select without ATN.&n;&t;**&t;and don&squot;t send a message.&n;&t;*/
id|SCR_FROM_REG
(paren
id|QU_REG
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|QUIRK_NOMSG
comma
id|QUIRK_NOMSG
)paren
)paren
comma
id|PADDR
c_func
(paren
id|getcc3
)paren
comma
multiline_comment|/*&n;&t;**&t;Then try to connect to the target.&n;&t;**&t;If we are reselected, special treatment&n;&t;**&t;of the current job is required before&n;&t;**&t;accepting the reselection.&n;&t;*/
id|SCR_SEL_TBL_ATN
op_xor
m_offsetof
(paren
r_struct
id|dsb
comma
id|select
)paren
comma
id|PADDR
c_func
(paren
id|badgetcc
)paren
comma
multiline_comment|/*&n;&t;**&t;save target id.&n;&t;*/
id|SCR_FROM_REG
(paren
id|sdid
)paren
comma
l_int|0
comma
id|SCR_TO_REG
(paren
id|ctest0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Send the IDENTIFY message.&n;&t;**&t;In case of short transfer, remove ATN.&n;&t;*/
id|SCR_MOVE_TBL
op_xor
id|SCR_MSG_OUT
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|smsg2
)paren
comma
id|SCR_CLR
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;save the first byte of the message.&n;&t;*/
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|sfbr
)paren
comma
id|NADDR
(paren
id|lastmsg
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|prepare2
)paren
comma
macro_line|#endif
)brace
multiline_comment|/*-------------------------&lt; GETCC3 &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Try to connect to the target.&n;&t;**&t;If we are reselected, special treatment&n;&t;**&t;of the current job is required before&n;&t;**&t;accepting the reselection.&n;&t;**&n;&t;**&t;Silly target won&squot;t accept a message.&n;&t;**&t;Select without ATN.&n;&t;*/
id|SCR_SEL_TBL
op_xor
m_offsetof
(paren
r_struct
id|dsb
comma
id|select
)paren
comma
id|PADDR
c_func
(paren
id|badgetcc
)paren
comma
multiline_comment|/*&n;&t;**&t;save target id.&n;&t;*/
id|SCR_FROM_REG
(paren
id|sdid
)paren
comma
l_int|0
comma
id|SCR_TO_REG
(paren
id|ctest0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Force error if selection timeout&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;don&squot;t negotiate.&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|prepare2
)paren
comma
)brace
multiline_comment|/*------------------------&lt; BADGETCC &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;If SIGP was set, clear it and try again.&n;&t;*/
id|SCR_FROM_REG
(paren
id|ctest2
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|CSIGP
comma
id|CSIGP
)paren
)paren
comma
id|PADDR
(paren
id|getcc2
)paren
comma
id|SCR_INT
comma
id|SIR_SENSE_FAILED
comma
)brace
multiline_comment|/*-------------------------&lt; RESELECT &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;make the DSA invalid.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|dsa
comma
l_int|0xff
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Sleep waiting for a reselection.&n;&t;**&t;If SIGP is set, special treatment.&n;&t;**&n;&t;**&t;Zu allem bereit ..&n;&t;*/
id|SCR_WAIT_RESEL
comma
id|PADDR
c_func
(paren
id|reselect2
)paren
comma
multiline_comment|/*&n;&t;**&t;... zu nichts zu gebrauchen ?&n;&t;**&n;&t;**      load the target id into the SFBR&n;&t;**&t;and jump to the control block.&n;&t;**&n;&t;**&t;Look at the declarations of&n;&t;**&t;- struct ncb&n;&t;**&t;- struct tcb&n;&t;**&t;- struct lcb&n;&t;**&t;- struct ccb&n;&t;**&t;to understand what&squot;s going on.&n;&t;*/
id|SCR_REG_SFBR
(paren
id|ssid
comma
id|SCR_AND
comma
l_int|0x87
)paren
comma
l_int|0
comma
id|SCR_TO_REG
(paren
id|ctest0
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|NADDR
(paren
id|jump_tcb
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESELECT2 &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;If it&squot;s not connected :(&n;&t;**&t;-&gt; interrupted by SIGP bit.&n;&t;**&t;Jump to start.&n;&t;*/
id|SCR_FROM_REG
(paren
id|ctest2
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|CSIGP
comma
id|CSIGP
)paren
)paren
comma
id|PADDR
(paren
id|start
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|reselect
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_TMP &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;The return address in TEMP&n;&t;**&t;is in fact the data structure address,&n;&t;**&t;so copy it to the DSA register.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|RADDR
(paren
id|dsa
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|prepare
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_LUN &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;come back to this point&n;&t;**&t;to get an IDENTIFY message&n;&t;**&t;Wait for a msg_in phase.&n;&t;*/
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
l_int|48
comma
multiline_comment|/*&n;&t;**&t;message phase&n;&t;**&t;It&squot;s not a sony, it&squot;s a trick:&n;&t;**&t;read the data without acknowledging it.&n;&t;*/
id|SCR_FROM_REG
(paren
id|sbdl
)paren
comma
l_int|0
comma
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|M_IDENTIFY
comma
l_int|0x98
)paren
)paren
comma
l_int|32
comma
multiline_comment|/*&n;&t;**&t;It WAS an Identify message.&n;&t;**&t;get it and ack it!&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Mask out the lun.&n;&t;*/
id|SCR_REG_REG
(paren
id|sfbr
comma
id|SCR_AND
comma
l_int|0x07
)paren
comma
l_int|0
comma
id|SCR_RETURN
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;No message phase or no IDENTIFY message:&n;&t;**&t;return 0.&n;&t;*/
multiline_comment|/*&gt;&gt;&gt;*/
id|SCR_LOAD_SFBR
(paren
l_int|0
)paren
comma
l_int|0
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_TAG &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;come back to this point&n;&t;**&t;to get a SIMPLE_TAG message&n;&t;**&t;Wait for a MSG_IN phase.&n;&t;*/
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
l_int|64
comma
multiline_comment|/*&n;&t;**&t;message phase&n;&t;**&t;It&squot;s a trick - read the data&n;&t;**&t;without acknowledging it.&n;&t;*/
id|SCR_FROM_REG
(paren
id|sbdl
)paren
comma
l_int|0
comma
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|M_SIMPLE_TAG
)paren
)paren
comma
l_int|48
comma
multiline_comment|/*&n;&t;**&t;It WAS a SIMPLE_TAG message.&n;&t;**&t;get it and ack it!&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Wait for the second byte (the tag)&n;&t;*/
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
l_int|24
comma
multiline_comment|/*&n;&t;**&t;Get it and ack it!&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_CARRY
)paren
comma
l_int|0
comma
id|SCR_RETURN
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;No message phase or no SIMPLE_TAG message&n;&t;**&t;or no second byte: return 0.&n;&t;*/
multiline_comment|/*&gt;&gt;&gt;*/
id|SCR_LOAD_SFBR
(paren
l_int|0
)paren
comma
l_int|0
comma
id|SCR_SET
(paren
id|SCR_CARRY
)paren
comma
l_int|0
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IN &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;**&t;Because the size depends on the&n;**&t;#define MAX_SCATTER parameter,&n;**&t;it is filled in at runtime.&n;**&n;**&t;SCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_IN)),&n;**&t;&t;PADDR (no_data),&n;**&t;SCR_COPY (sizeof (u_long)),&n;**&t;&t;KVAR(SCRIPT_KVAR_JIFFIES),&n;**&t;&t;NADDR (header.stamp.data),&n;**&t;SCR_MOVE_TBL ^ SCR_DATA_IN,&n;**&t;&t;offsetof (struct dsb, data[ 0]),&n;**&n;**  ##===========&lt; i=1; i&lt;MAX_SCATTER &gt;=========&n;**  ||&t;SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN)),&n;**  ||&t;&t;PADDR (checkatn),&n;**  ||&t;SCR_MOVE_TBL ^ SCR_DATA_IN,&n;**  ||&t;&t;offsetof (struct dsb, data[ i]),&n;**  ##==========================================&n;**&n;**&t;SCR_CALL,&n;**&t;&t;PADDR (checkatn),&n;**&t;SCR_JUMP,&n;**&t;&t;PADDR (no_data),&n;*/
l_int|0
)brace
multiline_comment|/*-------------------------&lt; DATA_OUT &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;**&t;Because the size depends on the&n;**&t;#define MAX_SCATTER parameter,&n;**&t;it is filled in at runtime.&n;**&n;**&t;SCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_IN)),&n;**&t;&t;PADDR (no_data),&n;**&t;SCR_COPY (sizeof (u_long)),&n;**&t;&t;KVAR(SCRIPT_KVAR_JIFFIES),&n;**&t;&t;NADDR (header.stamp.data),&n;**&t;SCR_MOVE_TBL ^ SCR_DATA_OUT,&n;**&t;&t;offsetof (struct dsb, data[ 0]),&n;**&n;**  ##===========&lt; i=1; i&lt;MAX_SCATTER &gt;=========&n;**  ||&t;SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT)),&n;**  ||&t;&t;PADDR (dispatch),&n;**  ||&t;SCR_MOVE_TBL ^ SCR_DATA_OUT,&n;**  ||&t;&t;offsetof (struct dsb, data[ i]),&n;**  ##==========================================&n;**&n;**&t;SCR_CALL,&n;**&t;&t;PADDR (dispatch),&n;**&t;SCR_JUMP,&n;**&t;&t;PADDR (no_data),&n;**&n;**---------------------------------------------------------&n;*/
l_int|0
multiline_comment|/* was (u_long)&amp;ident ? */
)brace
multiline_comment|/*-------------------------&lt; ABORTTAG &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**      Abort a bad reselection.&n;&t;**&t;Set the message to ABORT vs. ABORT_TAG&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_ABORT_TAG
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|CARRYSET
)paren
comma
l_int|8
comma
)brace
multiline_comment|/*-------------------------&lt; ABORT &gt;----------------------*/
comma
(brace
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_ABORT
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;and send it.&n;&t;**&t;we expect an immediate disconnect&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|sfbr
)paren
comma
id|NADDR
(paren
id|lastmsg
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_WAIT_DISC
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SNOOPTEST &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Read the variable.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
c_func
(paren
id|ncr_cache
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
multiline_comment|/*&n;&t;**&t;Write the variable.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|NADDR
c_func
(paren
id|ncr_cache
)paren
comma
multiline_comment|/*&n;&t;**&t;Read back the variable.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
c_func
(paren
id|ncr_cache
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SNOOPEND &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;And stop.&n;&t;*/
id|SCR_INT
comma
l_int|99
comma
)brace
multiline_comment|/*--------------------------------------------------------*/
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Fill in #define dependent parts of the script&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_script_fill
r_void
id|ncr_script_fill
(paren
r_struct
id|script
op_star
id|scr
)paren
(brace
r_int
id|i
suffix:semicolon
id|ncrcmd
op_star
id|p
suffix:semicolon
id|p
op_assign
id|scr-&gt;tryloop
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_START
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
id|SCR_COPY
(paren
l_int|4
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|NADDR
(paren
id|squeue
(braket
id|i
)braket
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|RADDR
(paren
id|dsa
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_CALL
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|trysel
)paren
suffix:semicolon
)brace
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_JUMP
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
c_func
(paren
id|tryloop
)paren
suffix:semicolon
m_assert
(paren
(paren
id|u_long
)paren
id|p
op_eq
(paren
id|u_long
)paren
op_amp
id|scr-&gt;tryloop
op_plus
r_sizeof
(paren
id|scr-&gt;tryloop
)paren
)paren
suffix:semicolon
id|p
op_assign
id|scr-&gt;data_in
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|no_data
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_COPY
(paren
r_sizeof
(paren
id|u_long
)paren
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|KVAR
c_func
(paren
id|SCRIPT_KVAR_JIFFIES
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|NADDR
(paren
id|header.stamp.data
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_IN
suffix:semicolon
op_star
id|p
op_increment
op_assign
m_offsetof
(paren
r_struct
id|dsb
comma
id|data
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|MAX_SCATTER
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
id|SCR_CALL
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|checkatn
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_IN
suffix:semicolon
op_star
id|p
op_increment
op_assign
m_offsetof
(paren
r_struct
id|dsb
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_CALL
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|checkatn
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_JUMP
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|no_data
)paren
suffix:semicolon
m_assert
(paren
(paren
id|u_long
)paren
id|p
op_eq
(paren
id|u_long
)paren
op_amp
id|scr-&gt;data_in
op_plus
r_sizeof
(paren
id|scr-&gt;data_in
)paren
)paren
suffix:semicolon
id|p
op_assign
id|scr-&gt;data_out
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|no_data
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_COPY
(paren
r_sizeof
(paren
id|u_long
)paren
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|KVAR
c_func
(paren
id|SCRIPT_KVAR_JIFFIES
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|NADDR
(paren
id|header.stamp.data
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_OUT
suffix:semicolon
op_star
id|p
op_increment
op_assign
m_offsetof
(paren
r_struct
id|dsb
comma
id|data
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|MAX_SCATTER
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
id|SCR_CALL
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|dispatch
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_OUT
suffix:semicolon
op_star
id|p
op_increment
op_assign
m_offsetof
(paren
r_struct
id|dsb
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_CALL
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|dispatch
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_JUMP
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|no_data
)paren
suffix:semicolon
m_assert
(paren
(paren
id|u_long
)paren
id|p
op_eq
(paren
id|u_long
)paren
op_amp
id|scr-&gt;data_out
op_plus
r_sizeof
(paren
id|scr-&gt;data_out
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Copy and rebind a script.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_script_copy_and_bind
r_static
r_void
id|ncr_script_copy_and_bind
(paren
r_struct
id|script
op_star
id|script
comma
id|ncb_p
id|np
)paren
(brace
id|ncrcmd
id|opcode
comma
r_new
comma
id|old
comma
id|tmp1
comma
id|tmp2
suffix:semicolon
id|ncrcmd
op_star
id|src
comma
op_star
id|dst
comma
op_star
id|start
comma
op_star
id|end
suffix:semicolon
r_int
id|relocs
suffix:semicolon
id|np-&gt;p_script
op_assign
id|vtophys
c_func
(paren
id|np-&gt;script
)paren
suffix:semicolon
id|src
op_assign
id|script-&gt;start
suffix:semicolon
id|dst
op_assign
id|np-&gt;script-&gt;start
suffix:semicolon
id|start
op_assign
id|src
suffix:semicolon
id|end
op_assign
id|src
op_plus
(paren
r_sizeof
(paren
r_struct
id|script
)paren
op_div
l_int|4
)paren
suffix:semicolon
r_while
c_loop
(paren
id|src
OL
id|end
)paren
(brace
op_star
id|dst
op_increment
op_assign
id|opcode
op_assign
op_star
id|src
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;If we forget to change the length&n;&t;&t;**&t;in struct script, a field will be&n;&t;&t;**&t;padded with 0. This is an illegal&n;&t;&t;**&t;command.&n;&t;&t;*/
r_if
c_cond
(paren
id|opcode
op_eq
l_int|0
)paren
(brace
id|printf
(paren
l_string|&quot;%s: ERROR0 IN SCRIPT at %d.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
r_int
)paren
(paren
id|src
op_minus
id|start
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|DELAY
(paren
l_int|1000000
)paren
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_SCRIPT
)paren
id|printf
(paren
l_string|&quot;%p:  &lt;%x&gt;&bslash;n&quot;
comma
(paren
id|src
op_minus
l_int|1
)paren
comma
(paren
r_int
)paren
id|opcode
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;We don&squot;t have to decode ALL commands&n;&t;&t;*/
r_switch
c_cond
(paren
id|opcode
op_rshift
l_int|28
)paren
(brace
r_case
l_int|0xc
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;COPY has TWO arguments.&n;&t;&t;&t;*/
id|relocs
op_assign
l_int|2
suffix:semicolon
id|tmp1
op_assign
id|src
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp1
op_amp
id|RELOC_MASK
)paren
op_eq
id|RELOC_KVAR
)paren
id|tmp1
op_assign
l_int|0
suffix:semicolon
id|tmp2
op_assign
id|src
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp2
op_amp
id|RELOC_MASK
)paren
op_eq
id|RELOC_KVAR
)paren
id|tmp2
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp1
op_xor
id|tmp2
)paren
op_amp
l_int|3
)paren
(brace
id|printf
(paren
l_string|&quot;%s: ERROR1 IN SCRIPT at %d.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
r_int
)paren
(paren
id|src
op_minus
id|start
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|DELAY
(paren
l_int|1000000
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x0
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;MOVE (absolute address)&n;&t;&t;&t;*/
id|relocs
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x8
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;JUMP / CALL&n;&t;&t;&t;**&t;dont&squot;t relocate if relative :-)&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|opcode
op_amp
l_int|0x00800000
)paren
id|relocs
op_assign
l_int|0
suffix:semicolon
r_else
id|relocs
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x4
suffix:colon
r_case
l_int|0x5
suffix:colon
r_case
l_int|0x6
suffix:colon
r_case
l_int|0x7
suffix:colon
id|relocs
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|relocs
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|relocs
)paren
(brace
r_while
c_loop
(paren
id|relocs
op_decrement
)paren
(brace
id|old
op_assign
op_star
id|src
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|old
op_amp
id|RELOC_MASK
)paren
(brace
r_case
id|RELOC_REGISTER
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|np-&gt;paddr
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RELOC_LABEL
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|np-&gt;p_script
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RELOC_SOFTC
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|vtophys
c_func
(paren
id|np
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RELOC_KVAR
suffix:colon
r_if
c_cond
(paren
(paren
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
OL
id|SCRIPT_KVAR_FIRST
)paren
op_logical_or
(paren
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
OG
id|SCRIPT_KVAR_LAST
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;ncr KVAR out of range&quot;
)paren
suffix:semicolon
r_new
op_assign
id|vtophys
c_func
(paren
id|script_kvars
(braket
id|old
op_amp
op_complement
id|RELOC_MASK
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* Don&squot;t relocate a 0 address. */
r_if
c_cond
(paren
id|old
op_eq
l_int|0
)paren
(brace
r_new
op_assign
id|old
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* fall through */
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;ncr_script_copy_and_bind: weird relocation %x&bslash;n&quot;
comma
id|old
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
id|dst
op_increment
op_assign
r_new
suffix:semicolon
)brace
)brace
r_else
op_star
id|dst
op_increment
op_assign
op_star
id|src
op_increment
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      Auto configuration:  attach and init a host adapter.&n;**&n;**&n;**==========================================================&n;*/
DECL|macro|MIN_ASYNC_PD
mdefine_line|#define&t;MIN_ASYNC_PD&t;40
DECL|macro|MIN_SYNC_PD
mdefine_line|#define&t;MIN_SYNC_PD&t;20
multiline_comment|/*&n;**&t;Linux host data structure&n;**&n;**&t;The script area is allocated in the host data structure&n;**&t;because kmalloc() returns NULL during scsi initialisations&n;**&t;with Linux 1.2.X&n;*/
DECL|struct|host_data
r_struct
id|host_data
(brace
DECL|member|ncb_data
r_struct
id|ncb
id|ncb_data
suffix:semicolon
DECL|member|script_data
r_struct
id|script
id|script_data
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;Print something which allow to retreive the controler type, unit,&n;**&t;target, lun concerned by a kernel message.&n;*/
DECL|macro|PRINT_LUN
mdefine_line|#define PRINT_LUN(np, target, lun) &bslash;&n;printf(&quot;%s-&lt;target %d, lun %d&gt;: &quot;, ncr_name(np), (int) (target), (int) (lun))
DECL|function|PRINT_ADDR
r_static
r_inline
r_void
id|PRINT_ADDR
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|host_data
op_star
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
id|ncb_p
id|np
op_assign
op_amp
id|host_data-&gt;ncb_data
suffix:semicolon
r_if
c_cond
(paren
id|np
)paren
id|PRINT_LUN
c_func
(paren
id|np
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Host attach and initialisations.&n;**&n;**&t;Allocate host data and ncb structure.&n;**&t;Request IO region and remap MMIO region.&n;**&t;Do chip initialization.&n;**&t;Try with mmio.&n;**&t;If mmio not possible (misconfigured cache),&n;**&t;retry with io mapped.&n;**&t;If all is OK, install interrupt handling and&n;**&t;start the timer daemon.&n;*/
DECL|function|ncr_attach
r_static
r_int
id|ncr_attach
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|unit
comma
id|ushort
id|device_id
comma
id|u_char
id|revision_id
comma
r_int
id|chip
comma
id|u_int
id|base
comma
id|u_int
id|io_port
comma
r_int
id|irq
comma
r_int
id|bus
comma
id|u_char
id|device_fn
)paren
(brace
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
id|ncb_p
id|np
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
op_assign
l_int|0
suffix:semicolon
id|u_long
id|flags
op_assign
l_int|0
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ncr_attach: unit=%d chip=%d base=%x, io_port=%x, irq=%d&bslash;n&quot;
comma
id|unit
comma
id|chip
comma
id|base
comma
id|io_port
comma
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate host_data structure&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|instance
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
r_sizeof
(paren
op_star
id|host_data
)paren
)paren
)paren
)paren
r_goto
id|attach_error
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initialize structure.&n;&t;*/
id|instance-&gt;irq
op_assign
id|irq
suffix:semicolon
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|np
op_assign
op_amp
id|host_data-&gt;ncb_data
suffix:semicolon
id|bzero
(paren
id|np
comma
r_sizeof
(paren
op_star
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;unit
op_assign
id|unit
suffix:semicolon
id|np-&gt;chip
op_assign
id|chip
suffix:semicolon
id|np-&gt;device_id
op_assign
id|device_id
suffix:semicolon
id|np-&gt;revision_id
op_assign
id|revision_id
suffix:semicolon
id|np-&gt;script
op_assign
op_amp
id|host_data-&gt;script_data
suffix:semicolon
multiline_comment|/*&n;&t;**    Initialize timer structure&n;        **&n;        */
id|init_timer
c_func
(paren
op_amp
id|np-&gt;timer
)paren
suffix:semicolon
id|np-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|np
suffix:semicolon
id|np-&gt;timer.function
op_assign
id|ncr53c8xx_timeout
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Try to map the controller chip to&n;&t;**&t;virtual and physical memory.&n;&t;*/
id|np-&gt;paddr
op_assign
id|base
suffix:semicolon
id|np-&gt;vaddr
op_assign
id|base
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
id|np-&gt;reg_remapped
op_assign
(paren
r_struct
id|ncr_reg
op_star
)paren
id|remap_pci_mem
c_func
(paren
(paren
id|u_long
)paren
id|base
comma
(paren
id|u_long
)paren
l_int|128
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;reg_remapped
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: can&squot;t map memory mapped IO region&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;use_mmio
op_assign
l_int|0
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;%s: using memory mapped IO at virtual address 0x%lx&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|np-&gt;reg_remapped
)paren
suffix:semicolon
id|np-&gt;use_mmio
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Try to map the controller chip into iospace.&n;&t;*/
id|request_region
c_func
(paren
id|io_port
comma
l_int|128
comma
l_string|&quot;ncr53c8xx&quot;
)paren
suffix:semicolon
id|np-&gt;port
op_assign
id|io_port
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Do chip dependent initialization.&n;&t;*/
r_switch
c_cond
(paren
id|device_id
)paren
(brace
r_case
id|PCI_DEVICE_ID_NCR_53C825
suffix:colon
r_case
id|PCI_DEVICE_ID_NCR_53C875
suffix:colon
id|np-&gt;maxwide
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|np-&gt;maxwide
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Fill Linux host instance structure&n;&t;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,0)
id|instance-&gt;max_channel
op_assign
l_int|0
suffix:semicolon
id|instance-&gt;max_id
op_assign
id|np-&gt;maxwide
ques
c_cond
l_int|16
suffix:colon
l_int|8
suffix:semicolon
id|instance-&gt;max_lun
op_assign
id|SCSI_NCR_MAX_LUN
suffix:semicolon
macro_line|#endif
macro_line|#ifndef NCR_IOMAPPED
id|instance-&gt;base
op_assign
(paren
r_char
op_star
)paren
id|np-&gt;reg_remapped
suffix:semicolon
macro_line|#endif
id|instance-&gt;io_port
op_assign
id|io_port
suffix:semicolon
id|instance-&gt;n_io_port
op_assign
l_int|128
suffix:semicolon
id|instance-&gt;dma_channel
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Patch script to physical addresses&n;&t;*/
id|ncr_script_fill
(paren
op_amp
id|script0
)paren
suffix:semicolon
id|ncr_script_copy_and_bind
(paren
op_amp
id|script0
comma
id|np
)paren
suffix:semicolon
id|np-&gt;ccb.p_ccb
op_assign
id|vtophys
(paren
op_amp
id|np-&gt;ccb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;init data structure&n;&t;*/
id|np-&gt;jump_tcb.l_cmd
op_assign
id|SCR_JUMP
suffix:semicolon
id|np-&gt;jump_tcb.l_paddr
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
m_abort
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Make the controller&squot;s registers available.&n;&t;**&t;Now the INB INW INL OUTB OUTW OUTL macros&n;&t;**&t;can be used safely.&n;&t;*/
id|np-&gt;reg
op_assign
(paren
r_struct
id|ncr_reg
op_star
)paren
id|np-&gt;vaddr
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
id|retry_chip_init
suffix:colon
macro_line|#endif
multiline_comment|/*&n;&t;**  Get SCSI addr of host adapter (set by bios?).&n;&t;*/
id|np-&gt;myaddr
op_assign
id|INB
c_func
(paren
id|nc_scid
)paren
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;myaddr
)paren
id|np-&gt;myaddr
op_assign
id|SCSI_NCR_MYADDR
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Get the value of the chip&squot;s clock.&n;&t;**&t;Find the right value for scntl3.&n;&t;*/
id|ncr_getclock
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Reset chip.&n;&t;*/
id|OUTW
(paren
id|nc_sien
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Disable scsi interrupts */
id|OUTB
(paren
id|nc_dien
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Disable dma interrupts */
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|DELAY
(paren
l_int|1000
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Reset chip, once again.&n;&t;*/
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|DELAY
(paren
l_int|1000
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Now check the cache handling of the pci chipset.&n;&t;*/
r_if
c_cond
(paren
id|ncr_snooptest
(paren
id|np
)paren
)paren
(brace
macro_line|#ifndef NCR_IOMAPPED
r_if
c_cond
(paren
id|np-&gt;use_mmio
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: cache misconfigured, retrying with IO mapped at 0x%lx&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|np-&gt;port
)paren
suffix:semicolon
id|np-&gt;use_mmio
op_assign
l_int|0
suffix:semicolon
r_goto
id|retry_chip_init
suffix:semicolon
)brace
macro_line|#endif
id|printf
(paren
l_string|&quot;CACHE INCORRECTLY CONFIGURED.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Install the interrupt handler.&n;&t;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,70)
macro_line|#   ifdef SCSI_NCR_SHARE_IRQ
id|printf
c_func
(paren
l_string|&quot;%s: requesting shared irq %d (dev_id=0x%lx)&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|irq
comma
(paren
id|u_long
)paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|irq
comma
id|ncr53c8xx_intr
comma
id|SA_SHIRQ
comma
l_string|&quot;53c8xx&quot;
comma
id|np
)paren
)paren
(brace
macro_line|#   else
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|irq
comma
id|ncr53c8xx_intr
comma
id|SA_INTERRUPT
comma
l_string|&quot;53c8xx&quot;
comma
l_int|NULL
)paren
)paren
(brace
macro_line|#   endif
macro_line|#else
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|irq
comma
id|ncr53c8xx_intr
comma
id|SA_INTERRUPT
comma
l_string|&quot;53c8xx&quot;
)paren
)paren
(brace
macro_line|#endif
id|printf
c_func
(paren
l_string|&quot;%s: request irq %d failure&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|irq
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
id|np-&gt;irq
op_assign
id|irq
suffix:semicolon
multiline_comment|/*&n;&t;**&t;After SCSI devices have been opened, we cannot&n;&t;**&t;reset the bus safely, so we do it here.&n;&t;**&t;Interrupt handler does the real work.&n;&t;*/
id|OUTB
(paren
id|nc_scntl1
comma
id|CRST
)paren
suffix:semicolon
id|DELAY
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Process the reset exception,&n;&t;**&t;if interrupts are not enabled yet.&n;&t;**&t;Then enable disconnects.&n;&t;*/
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ncr_exception
(paren
id|np
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifndef SCSI_NCR_NO_DISCONNECT
id|np-&gt;disc
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;The middle-level SCSI driver does not&n;&t;**&t;wait devices to settle.&n;&t;*/
macro_line|#ifdef SCSI_NCR_SETTLE_TIME
macro_line|#if    SCSI_NCR_SETTLE_TIME &gt; 2
id|printf
c_func
(paren
l_string|&quot;%s: waiting for scsi devices to settle...&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if    SCSI_NCR_SETTLE_TIME &gt; 0
id|DELAY
c_func
(paren
id|SCSI_NCR_SETTLE_TIME
op_star
l_int|1000000
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Now let the generic SCSI driver&n;&t;**&t;look for the SCSI devices on the bus ..&n;&t;*/
multiline_comment|/*&n;&t;**&t;start the timeout daemon&n;&t;*/
id|ncr_timeout
(paren
id|np
)paren
suffix:semicolon
id|np-&gt;lasttime
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**  use SIMPLE TAG messages by default&n;&t;*/
macro_line|#ifdef SCSI_NCR_ALWAYS_SIMPLE_TAG
id|np-&gt;order
op_assign
id|M_SIMPLE_TAG
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**  Done.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|the_template
)paren
(brace
id|the_template
op_assign
id|instance-&gt;hostt
suffix:semicolon
id|first_host
op_assign
id|instance
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|attach_error
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|instance
)paren
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
r_if
c_cond
(paren
id|np-&gt;reg_remapped
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: releasing memory mapped IO region %lx[%d]&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|np-&gt;reg_remapped
comma
l_int|128
)paren
suffix:semicolon
id|unmap_pci_mem
c_func
(paren
(paren
id|vm_offset_t
)paren
id|np-&gt;reg_remapped
comma
(paren
id|u_long
)paren
l_int|128
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|np-&gt;port
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: releasing IO region %x[%d]&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;port
comma
l_int|128
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|np-&gt;port
comma
l_int|128
)paren
suffix:semicolon
)brace
id|scsi_unregister
c_func
(paren
id|instance
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Process pending device interrupts.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_intr
r_int
id|ncr_intr
c_func
(paren
id|np
)paren
id|ncb_p
id|np
suffix:semicolon
(brace
r_int
id|n
op_assign
l_int|0
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;[&quot;
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PARANOIA
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_istat
)paren
op_amp
(paren
id|INTF
op_or
id|SIP
op_or
id|DIP
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;Repeat until no outstanding ints&n;&t;&t;*/
r_do
(brace
macro_line|#endif
id|ncr_exception
(paren
id|np
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PARANOIA
)brace
r_while
c_loop
(paren
id|INB
c_func
(paren
id|nc_istat
)paren
op_amp
(paren
id|INTF
op_or
id|SIP
op_or
id|DIP
)paren
)paren
suffix:semicolon
id|n
op_assign
l_int|1
suffix:semicolon
id|np-&gt;ticks
op_assign
l_int|5
op_star
id|HZ
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
id|n
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Start execution of a SCSI command.&n;**&t;This is called from the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_queue_command
r_int
id|ncr_queue_command
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;host
suffix:semicolon
multiline_comment|/*&t;Scsi_Device        *device    = cmd-&gt;device; */
r_struct
id|host_data
op_star
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|ncb_p
id|np
op_assign
op_amp
id|host_data-&gt;ncb_data
suffix:semicolon
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cmd-&gt;target
)braket
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
r_int
id|segments
suffix:semicolon
id|u_char
id|qidx
comma
id|nego
comma
id|idmsg
comma
op_star
id|msgptr
suffix:semicolon
id|u_long
id|msglen
comma
id|msglen2
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
r_int
id|xfer_direction
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*---------------------------------------------&n;&t;**&n;&t;**   Reset SCSI bus&n;&t;**&n;&t;**&t;Interrupt handler does the real work.&n;&t;**&n;&t;**---------------------------------------------&n;&t;*/
macro_line|#if 0
r_if
c_cond
(paren
id|flags
op_amp
id|SCSI_RESET
)paren
(brace
id|OUTB
(paren
id|nc_scntl1
comma
id|CRST
)paren
suffix:semicolon
id|DELAY
(paren
l_int|1000
)paren
suffix:semicolon
r_return
id|COMPLETE
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*---------------------------------------------&n;&t;**&n;&t;**      Some shortcuts ...&n;&t;**&n;&t;**---------------------------------------------&n;&t;*/
r_if
c_cond
(paren
(paren
id|cmd-&gt;target
op_eq
id|np-&gt;myaddr
)paren
op_logical_or
(paren
id|cmd-&gt;target
op_ge
id|MAX_TARGET
)paren
op_logical_or
(paren
id|cmd-&gt;lun
op_ge
id|MAX_LUN
)paren
)paren
(brace
r_return
id|DID_BAD_TARGET
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;CMD=%x &quot;
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;Assign a ccb / bind cmd&n;&t;**&t;If no free ccb, insert cmd into the waiting list.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cp
op_assign
id|ncr_get_ccb
(paren
id|np
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
)paren
)paren
(brace
id|insert_into_waiting_list
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|DID_OK
suffix:semicolon
)brace
id|cp-&gt;cmd
op_assign
id|cmd
suffix:semicolon
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;Enable tagged queue if asked by user&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
macro_line|#ifdef SCSI_NCR_TAGGED_QUEUE_DISABLED
r_if
c_cond
(paren
id|cmd-&gt;device
op_logical_and
id|cmd-&gt;device-&gt;tagged_queue
op_logical_and
(paren
id|lp
op_assign
id|tp-&gt;lp
(braket
id|cmd-&gt;lun
)braket
)paren
op_logical_and
(paren
op_logical_neg
id|lp-&gt;usetags
)paren
)paren
(brace
id|ncr_setmaxtags
(paren
id|np
comma
id|tp
comma
id|SCSI_NCR_MAX_TAGS
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;timestamp&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
id|bzero
(paren
op_amp
id|cp-&gt;phys.header.stamp
comma
r_sizeof
(paren
r_struct
id|tstamp
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.header.stamp.start
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Get device quirks from a speciality table.&n;&t;**&n;&t;**&t;@GENSCSI@&n;&t;**&t;This should be a part of the device table&n;&t;**&t;in &quot;scsi_conf.c&quot;.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
r_if
c_cond
(paren
id|tp-&gt;quirks
op_amp
id|QUIRK_UPDATE
)paren
(brace
id|tp-&gt;quirks
op_assign
id|ncr_lookup
(paren
(paren
r_char
op_star
)paren
op_amp
id|tp-&gt;inqdata
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#ifndef NCR_GETCC_WITHMSG
r_if
c_cond
(paren
id|tp-&gt;quirks
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;quirks=%x.&bslash;n&quot;
comma
id|tp-&gt;quirks
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;negotiation required?&n;&t;**&n;&t;**&t;Only SCSI-II devices.&n;&t;**&t;To negotiate with SCSI-I devices is dangerous, since&n;&t;**&t;Synchronous Negotiation protocol is optional, and&n;&t;**&t;INQUIRY data do not contains capabilities in byte 7.&n;&t;**----------------------------------------------------&n;&t;*/
id|nego
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;lun
op_eq
l_int|0
op_logical_and
(paren
id|tp-&gt;inqdata
(braket
l_int|2
)braket
op_amp
l_int|0x7
)paren
op_ge
l_int|2
op_logical_and
id|tp-&gt;inqdata
(braket
l_int|7
)braket
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;negotiate wide transfers ?&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;widedone
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;inqdata
(braket
l_int|7
)braket
op_amp
id|INQ7_WIDE16
)paren
(brace
id|nego
op_assign
id|NS_WIDE
suffix:semicolon
)brace
r_else
id|tp-&gt;widedone
op_assign
l_int|1
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;negotiate synchronous transfers?&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|nego
op_logical_and
op_logical_neg
id|tp-&gt;period
)paren
(brace
r_if
c_cond
(paren
id|SCSI_NCR_MAX_SYNC
macro_line|#if defined (CDROM_ASYNC)
op_logical_and
(paren
(paren
id|tp-&gt;inqdata
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
op_ne
l_int|5
)paren
macro_line|#endif
op_logical_and
(paren
id|tp-&gt;inqdata
(braket
l_int|7
)braket
op_amp
id|INQ7_SYNC
)paren
)paren
(brace
id|nego
op_assign
id|NS_SYNC
suffix:semicolon
)brace
r_else
(brace
id|tp-&gt;period
op_assign
l_int|0xffff
suffix:semicolon
id|tp-&gt;sval
op_assign
l_int|0xe0
suffix:semicolon
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;asynchronous.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;choose a new tag ...&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
r_if
c_cond
(paren
(paren
id|lp
op_assign
id|tp-&gt;lp
(braket
id|cmd-&gt;lun
)braket
)paren
op_logical_and
(paren
id|lp-&gt;usetags
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;assign a tag to this ccb!&n;&t;&t;*/
r_while
c_loop
(paren
op_logical_neg
id|cp-&gt;tag
)paren
(brace
id|ccb_p
id|cp2
op_assign
id|lp-&gt;next_ccb
suffix:semicolon
id|lp-&gt;lasttag
op_assign
id|lp-&gt;lasttag
op_mod
l_int|255
op_plus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|cp2
op_logical_and
id|cp2-&gt;tag
op_ne
id|lp-&gt;lasttag
)paren
id|cp2
op_assign
id|cp2-&gt;next_ccb
suffix:semicolon
r_if
c_cond
(paren
id|cp2
)paren
r_continue
suffix:semicolon
id|cp-&gt;tag
op_assign
id|lp-&gt;lasttag
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TAGS
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;using tag #%d.&bslash;n&quot;
comma
id|cp-&gt;tag
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|cp-&gt;tag
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Build the identify / tag / sdtr message&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
id|idmsg
op_assign
id|M_IDENTIFY
op_or
id|cmd-&gt;lun
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cp
op_ne
op_amp
id|np-&gt;ccb
)paren
op_logical_and
(paren
id|np-&gt;disc
)paren
)paren
id|idmsg
op_or_assign
l_int|0x40
suffix:semicolon
id|msgptr
op_assign
id|cp-&gt;scsi_smsg
suffix:semicolon
id|msglen
op_assign
l_int|0
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|idmsg
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;tag
)paren
(brace
r_char
id|tag
suffix:semicolon
id|tag
op_assign
id|np-&gt;order
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;Ordered write ops, unordered read ops.&n;&t;&t;*/
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x08
suffix:colon
multiline_comment|/* READ_SMALL (6) */
r_case
l_int|0x28
suffix:colon
multiline_comment|/* READ_BIG  (10) */
r_case
l_int|0xa8
suffix:colon
multiline_comment|/* READ_HUGE (12) */
id|tag
op_assign
id|M_SIMPLE_TAG
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|tag
op_assign
id|M_ORDERED_TAG
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;    **&t;Have to force ordered tag to avoid timeouts&n;&t;    */
r_if
c_cond
(paren
(paren
id|lp
op_assign
id|tp-&gt;lp
(braket
id|cmd-&gt;lun
)braket
)paren
op_logical_and
(paren
id|lp-&gt;force_ordered_tag
)paren
)paren
(brace
id|tag
op_assign
id|M_ORDERED_TAG
suffix:semicolon
id|lp-&gt;force_ordered_tag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TAGS
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;Ordered Queue Tag forced&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tag
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|cp
op_member_access_from_pointer
id|tag
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|nego
)paren
(brace
r_case
id|NS_SYNC
suffix:colon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|3
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_SYNC_REQ
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;maxoffs
ques
c_cond
id|tp-&gt;minsync
suffix:colon
l_int|0
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;maxoffs
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;sync msgout: &quot;
)paren
suffix:semicolon
id|ncr_show_msg
(paren
op_amp
id|cp-&gt;scsi_smsg
(braket
id|msglen
op_minus
l_int|5
)braket
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_WIDE
suffix:colon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|2
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_WIDE_REQ
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;usrwide
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;wide msgout: &quot;
)paren
suffix:semicolon
id|ncr_show_msg
(paren
op_amp
id|cp-&gt;scsi_smsg
(braket
id|msglen
op_minus
l_int|4
)braket
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Build the identify message for getcc.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
id|cp
op_member_access_from_pointer
id|scsi_smsg2
(braket
l_int|0
)braket
op_assign
id|idmsg
suffix:semicolon
id|msglen2
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Build the data descriptors&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
id|segments
op_assign
id|ncr_scatter
(paren
id|cp
comma
id|cp-&gt;cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|segments
OL
l_int|0
)paren
(brace
id|ncr_free_ccb
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|DID_ERROR
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Guess xfer direction.&n;&t;**&t;Spare some CPU by testing here frequently opcode.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
r_switch
c_cond
(paren
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x08
suffix:colon
multiline_comment|/*&t;READ(6)&t;&t;&t;&t;08 */
r_case
l_int|0x28
suffix:colon
multiline_comment|/*&t;READ(10)&t;&t;&t;28 */
id|xfer_direction
op_assign
id|XferIn
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0A
suffix:colon
multiline_comment|/*&t;WRITE(6)&t;&t;&t;0A */
r_case
l_int|0x2A
suffix:colon
multiline_comment|/*&t;WRITE(10)&t;&t;&t;2A */
id|xfer_direction
op_assign
id|XferOut
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|xfer_direction
op_assign
id|guess_xfer_direction
c_func
(paren
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Set the SAVED_POINTER.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
r_switch
c_cond
(paren
id|xfer_direction
)paren
(brace
r_default
suffix:colon
r_case
id|XferIn
suffix:colon
id|cp-&gt;phys.header.savep
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|data_in
)paren
suffix:semicolon
id|cp-&gt;phys.header.goalp
op_assign
id|cp-&gt;phys.header.savep
op_plus
l_int|20
op_plus
id|segments
op_star
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XferOut
suffix:colon
id|cp-&gt;phys.header.savep
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|data_out
)paren
suffix:semicolon
id|cp-&gt;phys.header.goalp
op_assign
id|cp-&gt;phys.header.savep
op_plus
l_int|20
op_plus
id|segments
op_star
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XferNone
suffix:colon
id|cp-&gt;phys.header.savep
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|no_data
)paren
suffix:semicolon
id|cp-&gt;phys.header.goalp
op_assign
id|cp-&gt;phys.header.savep
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cp-&gt;phys.header.lastp
op_assign
id|cp-&gt;phys.header.savep
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;fill in ccb&n;&t;**&n;&t;**----------------------------------------------------&n;&t;**&n;&t;**&n;&t;**&t;physical -&gt; virtual backlink&n;&t;**&t;Generic SCSI command&n;&t;*/
id|cp-&gt;phys.header.cp
op_assign
id|cp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Startqueue&n;&t;*/
id|cp-&gt;phys.header.launch.l_paddr
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|select
)paren
suffix:semicolon
id|cp-&gt;phys.header.launch.l_cmd
op_assign
id|SCR_JUMP
suffix:semicolon
multiline_comment|/*&n;&t;**&t;select&n;&t;*/
id|cp-&gt;phys.select.sel_id
op_assign
id|cmd-&gt;target
suffix:semicolon
id|cp-&gt;phys.select.sel_scntl3
op_assign
id|tp-&gt;wval
suffix:semicolon
id|cp-&gt;phys.select.sel_sxfer
op_assign
id|tp-&gt;sval
suffix:semicolon
multiline_comment|/*&n;&t;**&t;message&n;&t;*/
id|cp-&gt;phys.smsg.addr
op_assign
id|CCB_PHYS
(paren
id|cp
comma
id|scsi_smsg
)paren
suffix:semicolon
id|cp-&gt;phys.smsg.size
op_assign
id|msglen
suffix:semicolon
id|cp-&gt;phys.smsg2.addr
op_assign
id|CCB_PHYS
(paren
id|cp
comma
id|scsi_smsg2
)paren
suffix:semicolon
id|cp-&gt;phys.smsg2.size
op_assign
id|msglen2
suffix:semicolon
multiline_comment|/*&n;&t;**&t;command&n;&t;*/
id|cp-&gt;phys.cmd.addr
op_assign
id|vtophys
(paren
op_amp
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|cp-&gt;phys.cmd.size
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
multiline_comment|/*&n;&t;**&t;sense command&n;&t;*/
id|cp-&gt;phys.scmd.addr
op_assign
id|CCB_PHYS
(paren
id|cp
comma
id|sensecmd
)paren
suffix:semicolon
id|cp-&gt;phys.scmd.size
op_assign
l_int|6
suffix:semicolon
multiline_comment|/*&n;&t;**&t;patch requested size into sense command&n;&t;*/
id|cp-&gt;sensecmd
(braket
l_int|0
)braket
op_assign
l_int|0x03
suffix:semicolon
id|cp-&gt;sensecmd
(braket
l_int|1
)braket
op_assign
id|cmd-&gt;lun
op_lshift
l_int|5
suffix:semicolon
id|cp-&gt;sensecmd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;sense data&n;&t;*/
id|cp-&gt;phys.sense.addr
op_assign
id|vtophys
(paren
op_amp
id|cmd-&gt;sense_buffer
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|cp-&gt;phys.sense.size
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;status&n;&t;*/
id|cp-&gt;actualquirks
op_assign
id|tp-&gt;quirks
suffix:semicolon
id|cp-&gt;host_status
op_assign
id|nego
ques
c_cond
id|HS_NEGOTIATE
suffix:colon
id|HS_BUSY
suffix:semicolon
id|cp-&gt;scsi_status
op_assign
id|S_ILLEGAL
suffix:semicolon
id|cp-&gt;parity_status
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;xerr_status
op_assign
id|XE_OK
suffix:semicolon
id|cp-&gt;sync_status
op_assign
id|tp-&gt;sval
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|nego
suffix:semicolon
id|cp-&gt;wide_status
op_assign
id|tp-&gt;wval
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Critical region: start this job.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
multiline_comment|/*&n;&t;**&t;reselect pattern and activate this job.&n;&t;*/
id|cp-&gt;jump_ccb.l_cmd
op_assign
(paren
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|cp-&gt;tag
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Compute a time limit bigger than the middle-level driver one */
r_if
c_cond
(paren
id|cmd-&gt;timeout_per_command
OG
l_int|0
)paren
id|cp-&gt;tlimit
op_assign
id|jiffies
op_plus
id|cmd-&gt;timeout_per_command
op_plus
id|NCR_TIMEOUT_INCREASE
suffix:semicolon
r_else
id|cp-&gt;tlimit
op_assign
id|jiffies
op_plus
l_int|3600
op_star
id|HZ
suffix:semicolon
multiline_comment|/* No timeout=one hour */
id|cp-&gt;magic
op_assign
id|CCB_MAGIC
suffix:semicolon
multiline_comment|/*&n;&t;**&t;insert into start queue.&n;&t;*/
id|qidx
op_assign
id|np-&gt;squeueput
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|qidx
op_ge
id|MAX_START
)paren
id|qidx
op_assign
l_int|0
suffix:semicolon
id|np-&gt;squeue
(braket
id|qidx
)braket
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
suffix:semicolon
id|np-&gt;squeue
(braket
id|np-&gt;squeueput
)braket
op_assign
id|CCB_PHYS
(paren
id|cp
comma
id|phys
)paren
suffix:semicolon
id|np-&gt;squeueput
op_assign
id|qidx
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_QUEUE
)paren
(brace
id|printf
(paren
l_string|&quot;%s: queuepos=%d tryoffset=%d.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|np-&gt;squeueput
comma
(paren
r_int
)paren
(paren
id|np-&gt;script-&gt;startpos
(braket
l_int|0
)braket
op_minus
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|tryloop
)paren
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Script processor may be waiting for reselect.&n;&t;**&t;Wake it up.&n;&t;*/
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;and reenable interrupts&n;&t;*/
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Command is successfully queued.&n;&t;*/
r_return
id|DID_OK
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Reset the SCSI BUS.&n;**&t;This is called from the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_reset_bus
r_int
id|ncr_reset_bus
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;host
suffix:semicolon
multiline_comment|/*&t;Scsi_Device        *device    = cmd-&gt;device; */
r_struct
id|host_data
op_star
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|ncb_p
id|np
op_assign
op_amp
id|host_data-&gt;ncb_data
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|reset_waiting_list
c_func
(paren
id|np
)paren
suffix:semicolon
id|ncr_init
c_func
(paren
id|np
comma
l_string|&quot;scsi bus reset&quot;
comma
id|HS_RESET
)paren
suffix:semicolon
macro_line|#ifndef SCSI_NCR_NO_DISCONNECT
id|np-&gt;disc
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_RESET_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Abort an SCSI command.&n;**&t;This is called from the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_abort_command
r_int
id|ncr_abort_command
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;host
suffix:semicolon
multiline_comment|/*&t;Scsi_Device        *device    = cmd-&gt;device; */
r_struct
id|host_data
op_star
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|ncb_p
id|np
op_assign
op_amp
id|host_data-&gt;ncb_data
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
r_int
id|found
suffix:semicolon
r_int
id|retv
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n; * First, look for the scsi command in the waiting list&n; */
r_if
c_cond
(paren
id|remove_from_waiting_list
c_func
(paren
id|np
comma
id|cmd
)paren
)paren
(brace
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_ABORT
comma
l_int|0
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Then, look in the wakeup list&n; */
r_for
c_loop
(paren
id|found
op_assign
l_int|0
comma
id|cp
op_assign
op_amp
id|np-&gt;ccb
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;look for the ccb of this command.&n;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_IDLE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cmd
op_eq
id|cmd
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Disable reselect.&n;&t;**      Remove it from startqueue.&n;&t;*/
id|cp-&gt;jump_ccb.l_cmd
op_assign
(paren
id|SCR_JUMP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;phys.header.launch.l_paddr
op_eq
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|select
)paren
)paren
(brace
id|printf
(paren
l_string|&quot;%s: abort ccb=%p (skip)&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|cp
)paren
suffix:semicolon
id|cp-&gt;phys.header.launch.l_paddr
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|skip
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cp-&gt;host_status
)paren
(brace
r_case
id|HS_BUSY
suffix:colon
r_case
id|HS_NEGOTIATE
suffix:colon
multiline_comment|/*&n;&t;&t;** still in start queue ?&n;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;phys.header.launch.l_paddr
op_eq
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|skip
)paren
)paren
(brace
id|retv
op_assign
id|SCSI_ABORT_BUSY
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* fall through */
r_case
id|HS_DISCONNECT
suffix:colon
id|cp-&gt;host_status
op_assign
id|HS_ABORTED
suffix:semicolon
id|cp-&gt;tag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;wakeup this ccb.&n;&t;&t;*/
id|ncr_complete
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
id|retv
op_assign
id|SCSI_ABORT_SUCCESS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|cp-&gt;tag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;wakeup this ccb.&n;&t;&t;*/
id|ncr_complete
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
id|retv
op_assign
id|SCSI_ABORT_SUCCESS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Linux release module stuff.&n;**&n;**&t;Called before unloading the module&n;**&t;Detach the host.&n;**&t;We have to free resources and halt the NCR chip&n;**&n;**==========================================================&n;*/
macro_line|#ifdef MODULE
DECL|function|ncr_detach
r_static
r_int
id|ncr_detach
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|irq
)paren
(brace
id|ccb_p
id|cp
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
r_int
id|target
comma
id|lun
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: releasing host resources&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;**&t;Stop the ncr_timeout process&n;**&t;Set release_stage to 1 and wait that ncr_timeout() set it to 2.&n;*/
macro_line|#ifdef DEBUG
id|printf
c_func
(paren
l_string|&quot;%s: stopping the timer&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
macro_line|#endif
id|np-&gt;release_stage
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|50
suffix:semicolon
id|i
op_logical_and
id|np-&gt;release_stage
op_ne
l_int|2
suffix:semicolon
id|i
op_decrement
)paren
id|DELAY
c_func
(paren
l_int|100000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;release_stage
op_ne
l_int|2
)paren
id|printf
c_func
(paren
l_string|&quot;%s: the timer seems to be already stopped&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_else
id|np-&gt;release_stage
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;**&t;Disable chip interrupts&n;*/
macro_line|#ifdef DEBUG
id|printf
c_func
(paren
l_string|&quot;%s: disabling chip interrupts&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
macro_line|#endif
id|OUTW
(paren
id|nc_sien
comma
l_int|0
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_dien
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;**&t;Free irq&n;*/
macro_line|#ifdef DEBUG
id|printf
c_func
(paren
l_string|&quot;%s: freeing irq %d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,70)
macro_line|#   ifdef SCSI_NCR_SHARE_IRQ
id|free_irq
c_func
(paren
id|irq
comma
id|np
)paren
suffix:semicolon
macro_line|#   else
id|free_irq
c_func
(paren
id|irq
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#   endif
macro_line|#else
id|free_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Reset NCR chip&n;&t;*/
id|printf
c_func
(paren
l_string|&quot;%s: resetting chip&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|DELAY
(paren
l_int|1000
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Release Memory mapped IO region and IO mapped region&n;&t;*/
macro_line|#ifndef NCR_IOMAPPED
macro_line|#ifdef DEBUG
id|printf
c_func
(paren
l_string|&quot;%s: releasing memory mapped IO region %lx[%d]&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|np-&gt;reg_remapped
comma
l_int|128
)paren
suffix:semicolon
macro_line|#endif
id|unmap_pci_mem
c_func
(paren
(paren
id|vm_offset_t
)paren
id|np-&gt;reg_remapped
comma
(paren
id|u_long
)paren
l_int|128
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG
id|printf
c_func
(paren
l_string|&quot;%s: releasing IO region %x[%d]&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;port
comma
l_int|128
)paren
suffix:semicolon
macro_line|#endif
id|release_region
c_func
(paren
id|np-&gt;port
comma
l_int|128
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Free allocated ccb(s)&n;&t;*/
r_while
c_loop
(paren
(paren
id|cp
op_assign
id|np-&gt;ccb.link_ccb
)paren
op_ne
l_int|NULL
)paren
(brace
id|np-&gt;ccb.link_ccb
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_status
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: shall free an active ccb (host_status=%d)&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|cp-&gt;host_status
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printf
c_func
(paren
l_string|&quot;%s: freeing ccb (%lx)&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|cp
)paren
suffix:semicolon
macro_line|#endif
id|m_free
c_func
(paren
id|cp
comma
r_sizeof
(paren
op_star
id|cp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Free allocated tp(s)&n;&t;*/
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
OL
id|MAX_TARGET
suffix:semicolon
id|target
op_increment
)paren
(brace
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
id|MAX_LUN
suffix:semicolon
id|lun
op_increment
)paren
(brace
id|lp
op_assign
id|tp-&gt;lp
(braket
id|lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lp
)paren
(brace
macro_line|#ifdef DEBUG
id|printf
c_func
(paren
l_string|&quot;%s: freeing lp (%lx)&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|lp
)paren
suffix:semicolon
macro_line|#endif
id|m_free
c_func
(paren
id|lp
comma
r_sizeof
(paren
op_star
id|lp
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;%s: host resources successfully released&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Complete execution of a SCSI command.&n;**&t;Signal completion to the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_complete
r_void
id|ncr_complete
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Sanity check&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|cp
op_logical_or
(paren
id|cp-&gt;magic
op_ne
id|CCB_MAGIC
)paren
op_logical_or
op_logical_neg
id|cp-&gt;cmd
)paren
r_return
suffix:semicolon
id|cp-&gt;magic
op_assign
l_int|1
suffix:semicolon
id|cp-&gt;tlimit
op_assign
l_int|0
suffix:semicolon
id|cmd
op_assign
id|cp-&gt;cmd
suffix:semicolon
multiline_comment|/*&n;&t;**&t;No Reselect anymore.&n;&t;*/
id|cp-&gt;jump_ccb.l_cmd
op_assign
(paren
id|SCR_JUMP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;No starting.&n;&t;*/
id|cp-&gt;phys.header.launch.l_paddr
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;timestamp&n;&t;**&t;Optional, spare some CPU time&n;&t;*/
macro_line|#ifdef SCSI_NCR_PROFILE
id|ncb_profile
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;CCB=%lx STAT=%x/%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cp
op_amp
l_int|0xfff
comma
id|cp-&gt;host_status
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
id|cmd
op_assign
id|cp-&gt;cmd
suffix:semicolon
id|cp-&gt;cmd
op_assign
l_int|NULL
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cmd-&gt;target
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Check for parity errors.&n;&t;*/
r_if
c_cond
(paren
id|cp-&gt;parity_status
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;%d parity error(s), fallback.&bslash;n&quot;
comma
id|cp-&gt;parity_status
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;fallback to asynch transfer.&n;&t;&t;*/
id|tp-&gt;usrsync
op_assign
l_int|255
suffix:semicolon
id|tp-&gt;period
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Check for extended errors.&n;&t;*/
r_if
c_cond
(paren
id|cp-&gt;xerr_status
op_ne
id|XE_OK
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cp-&gt;xerr_status
)paren
(brace
r_case
id|XE_EXTRA_DATA
suffix:colon
id|printf
(paren
l_string|&quot;extraneous data discarded.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XE_BAD_PHASE
suffix:colon
id|printf
(paren
l_string|&quot;illegal scsi phase (4/5).&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
(paren
l_string|&quot;extended error %d.&bslash;n&quot;
comma
id|cp-&gt;xerr_status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
id|cp-&gt;host_status
op_assign
id|HS_FAIL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Check the status.&n;&t;*/
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
id|S_GOOD
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;All went well.&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_OK
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** if (cp-&gt;phys.header.lastp != cp-&gt;phys.header.goalp)...&n;&t;&t;**&n;&t;&t;**&t;@RESID@&n;&t;&t;**&t;Could dig out the correct value for resid,&n;&t;&t;**&t;but it would be quite complicated.&n;&t;&t;**&n;&t;&t;**&t;The ah1542.c driver sets it to 0 too ...&n;&t;&t;*/
multiline_comment|/*&n;&t;&t;**&t;Try to assign a ccb to this nexus&n;&t;&t;*/
id|ncr_alloc_ccb
(paren
id|np
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;On inquire cmd (0x12) save some data.&n;&t;&t;**&t;Clear questionnable capacities.&n;&t;&t;*/
r_if
c_cond
(paren
id|cmd-&gt;lun
op_eq
l_int|0
op_logical_and
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
l_int|0x12
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;unit
OL
id|SCSI_NCR_MAX_HOST
)paren
(brace
macro_line|#ifdef SCSI_NCR_FORCE_SYNC_NEGO
(paren
(paren
r_char
op_star
)paren
id|cmd-&gt;request_buffer
)paren
(braket
l_int|7
)braket
op_or_assign
id|INQ7_SYNC
suffix:semicolon
macro_line|#endif
(paren
(paren
r_char
op_star
)paren
id|cmd-&gt;request_buffer
)paren
(braket
l_int|7
)braket
op_and_assign
(paren
id|target_capabilities
(braket
id|np-&gt;unit
)braket
dot
id|and_map
(braket
id|cmd-&gt;target
)braket
)paren
suffix:semicolon
)brace
id|bcopy
(paren
id|cmd-&gt;request_buffer
comma
op_amp
id|tp-&gt;inqdata
comma
r_sizeof
(paren
id|tp-&gt;inqdata
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;**&t;set number of tags&n;&t;&t;&t;*/
id|lp
op_assign
id|tp-&gt;lp
(braket
id|cmd-&gt;lun
)braket
suffix:semicolon
macro_line|#ifndef SCSI_NCR_TAGGED_QUEUE_DISABLED
r_if
c_cond
(paren
id|lp
op_logical_and
op_logical_neg
id|lp-&gt;usetags
)paren
(brace
id|ncr_setmaxtags
(paren
id|np
comma
id|tp
comma
id|SCSI_NCR_MAX_TAGS
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t;**&t;prepare negotiation of synch and wide.&n;&t;&t;&t;*/
id|ncr_negotiate
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;**&t;force quirks update before next command start&n;&t;&t;&t;*/
id|tp-&gt;quirks
op_or_assign
id|QUIRK_UPDATE
suffix:semicolon
)brace
id|tp-&gt;bytes
op_add_assign
id|cp-&gt;data_len
suffix:semicolon
id|tp-&gt;transfers
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
(paren
id|S_SENSE
op_or
id|S_GOOD
)paren
op_logical_or
id|cp-&gt;scsi_status
op_eq
(paren
id|S_SENSE
op_or
id|S_CHECK_COND
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**   Check condition code&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_OK
comma
id|S_CHECK_COND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
(paren
id|DEBUG_RESULT
op_or
id|DEBUG_TINY
)paren
)paren
(brace
id|u_char
op_star
id|p
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|cmd-&gt;sense_buffer
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printf
(paren
l_string|&quot;&bslash;n%s: sense data:&quot;
comma
id|ncr_name
(paren
id|np
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|14
suffix:semicolon
id|i
op_increment
)paren
id|printf
(paren
l_string|&quot; %x&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
id|S_BUSY
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**   Target is busy.&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_OK
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_SEL_TIMEOUT
)paren
op_logical_or
(paren
id|cp-&gt;host_status
op_eq
id|HS_TIMEOUT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**   No response&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_TIME_OUT
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_RESET
)paren
(brace
multiline_comment|/*&n;&t;&t;**   SCSI bus reset&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_RESET
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_ABORTED
)paren
(brace
multiline_comment|/*&n;&t;&t;**   Transfer aborted&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_ABORT
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;**  Other protocol messes&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;COMMAND FAILED (%x %x) @%p.&bslash;n&quot;
comma
id|cp-&gt;host_status
comma
id|cp-&gt;scsi_status
comma
id|cp
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_ERROR
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;trace output&n;&t;*/
r_if
c_cond
(paren
id|tp-&gt;usrflag
op_amp
id|UF_TRACE
)paren
(brace
id|u_char
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot; CMD:&quot;
)paren
suffix:semicolon
id|p
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cmd-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
id|printf
(paren
l_string|&quot; %x&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
(brace
r_switch
c_cond
(paren
id|cp-&gt;scsi_status
)paren
(brace
r_case
id|S_GOOD
suffix:colon
id|printf
(paren
l_string|&quot;  GOOD&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_CHECK_COND
suffix:colon
id|printf
(paren
l_string|&quot;  SENSE:&quot;
)paren
suffix:semicolon
id|p
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|cmd-&gt;sense_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|14
suffix:semicolon
id|i
op_increment
)paren
id|printf
(paren
l_string|&quot; %x&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
(paren
l_string|&quot;  STAT: %x&bslash;n&quot;
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
id|printf
(paren
l_string|&quot;  HOSTERROR: %x&quot;
comma
id|cp-&gt;host_status
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Free this ccb&n;&t;*/
id|ncr_free_ccb
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;requeue awaiting scsi commands&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;waiting_list
)paren
id|requeue_waiting_list
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;signal completion to generic driver.&n;&t;*/
id|cmd-&gt;scsi_done
(paren
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Signal all (or one) control block done.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_wakeup
r_void
id|ncr_wakeup
(paren
id|ncb_p
id|np
comma
id|u_long
id|code
)paren
(brace
multiline_comment|/*&n;&t;**&t;Starting at the default ccb and following&n;&t;**&t;the links, complete all jobs with a&n;&t;**&t;host_status greater than &quot;disconnect&quot;.&n;&t;**&n;&t;**&t;If the &quot;code&quot; parameter is not zero,&n;&t;**&t;complete all jobs that are not IDLE.&n;&t;*/
id|ccb_p
id|cp
op_assign
op_amp
id|np-&gt;ccb
suffix:semicolon
r_while
c_loop
(paren
id|cp
)paren
(brace
r_switch
c_cond
(paren
id|cp-&gt;host_status
)paren
(brace
r_case
id|HS_IDLE
suffix:colon
r_break
suffix:semicolon
r_case
id|HS_DISCONNECT
suffix:colon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
(brace
id|printf
(paren
l_string|&quot;D&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* fall through */
r_case
id|HS_BUSY
suffix:colon
r_case
id|HS_NEGOTIATE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|code
)paren
r_break
suffix:semicolon
id|cp-&gt;host_status
op_assign
id|code
suffix:semicolon
multiline_comment|/* fall through */
r_default
suffix:colon
id|ncr_complete
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|cp
op_assign
id|cp
op_member_access_from_pointer
id|link_ccb
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Start NCR chip.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_init
r_void
id|ncr_init
(paren
id|ncb_p
id|np
comma
r_char
op_star
id|msg
comma
id|u_long
id|code
)paren
(brace
r_int
id|i
suffix:semicolon
id|u_long
id|usrsync
suffix:semicolon
id|u_char
id|usrwide
suffix:semicolon
macro_line|#if 0
id|u_char
id|burstlen
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Reset chip.&n;&t;*/
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|DELAY
(paren
l_int|10000
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Message.&n;&t;*/
r_if
c_cond
(paren
id|msg
)paren
id|printf
(paren
l_string|&quot;%s: restart (%s).&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|msg
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Clear Start Queue&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_START
suffix:semicolon
id|i
op_increment
)paren
id|np
op_member_access_from_pointer
id|squeue
(braket
id|i
)braket
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Start at first entry.&n;&t;*/
id|np-&gt;squeueput
op_assign
l_int|0
suffix:semicolon
id|np-&gt;script-&gt;startpos
(braket
l_int|0
)braket
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|tryloop
)paren
suffix:semicolon
id|np-&gt;script-&gt;start0
(braket
l_int|0
)braket
op_assign
id|SCR_INT
op_xor
id|IFFALSE
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Wakeup all pending jobs.&n;&t;*/
id|ncr_wakeup
(paren
id|np
comma
id|code
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Init chip.&n;&t;*/
multiline_comment|/**&t;NCR53C810&t;&t;&t;**/
r_if
c_cond
(paren
id|ChipDevice
op_eq
id|PCI_DEVICE_ID_NCR_53C810
op_logical_and
id|ChipVersion
op_eq
l_int|0
)paren
(brace
id|OUTB
c_func
(paren
id|nc_dmode
comma
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/* Set 8-transfer burst */
)brace
r_else
multiline_comment|/**&t;NCR53C815&t;&t;&t;**/
r_if
c_cond
(paren
id|ChipDevice
op_eq
id|PCI_DEVICE_ID_NCR_53C815
)paren
(brace
id|OUTB
c_func
(paren
id|nc_dmode
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* Set 2-transfer burst */
)brace
r_else
multiline_comment|/**&t;NCR53C825&t;&t;&t;**/
r_if
c_cond
(paren
id|ChipDevice
op_eq
id|PCI_DEVICE_ID_NCR_53C825
op_logical_and
id|ChipVersion
op_eq
l_int|0
)paren
(brace
id|OUTB
c_func
(paren
id|nc_dmode
comma
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/* Set 8-transfer burst */
)brace
r_else
multiline_comment|/**&t;NCR53C810A or NCR53C860&t;&t;**/
r_if
c_cond
(paren
(paren
id|ChipDevice
op_eq
id|PCI_DEVICE_ID_NCR_53C810
op_logical_and
id|ChipVersion
op_ge
l_int|0x10
)paren
op_logical_or
id|ChipDevice
op_eq
id|PCI_DEVICE_ID_NCR_53C860
)paren
(brace
id|OUTB
c_func
(paren
id|nc_dmode
comma
l_int|0xc0
)paren
suffix:semicolon
multiline_comment|/* Set 16-transfer burst */
macro_line|#if 0
id|OUTB
c_func
(paren
id|nc_ctest3
comma
l_int|0x01
)paren
suffix:semicolon
multiline_comment|/* Set write and invalidate */
id|OUTB
c_func
(paren
id|nc_dcntl
comma
l_int|0xa1
)paren
suffix:semicolon
multiline_comment|/* Cache line size enable, */
multiline_comment|/* pre-fetch enable and 700 comp */
macro_line|#endif
)brace
r_else
multiline_comment|/**&t;NCR53C825A or NCR53C875&t;&t;**/
r_if
c_cond
(paren
(paren
id|ChipDevice
op_eq
id|PCI_DEVICE_ID_NCR_53C825
op_logical_and
id|ChipVersion
op_ge
l_int|0x10
)paren
op_logical_or
id|ChipDevice
op_eq
id|PCI_DEVICE_ID_NCR_53C875
)paren
(brace
id|OUTB
c_func
(paren
id|nc_dmode
comma
l_int|0xc0
)paren
suffix:semicolon
multiline_comment|/* Set 16-transfer burst */
id|OUTB
c_func
(paren
id|nc_ctest5
comma
l_int|0x04
)paren
suffix:semicolon
multiline_comment|/* Set DMA FIFO to 88 */
macro_line|#if 0
id|OUTB
c_func
(paren
id|nc_ctest5
comma
l_int|0x24
)paren
suffix:semicolon
multiline_comment|/* Set DMA FIFO to 536 */
id|OUTB
c_func
(paren
id|nc_dmode
comma
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/* Set 64-transfer burst */
id|OUTB
c_func
(paren
id|nc_ctest3
comma
l_int|0x01
)paren
suffix:semicolon
multiline_comment|/* Set write and invalidate */
id|OUTB
c_func
(paren
id|nc_dcntl
comma
l_int|0x81
)paren
suffix:semicolon
multiline_comment|/* Cache line size enable and 700 comp*/
macro_line|#endif
)brace
multiline_comment|/**&t;OTHERS&t;&t;&t;&t;**/
r_else
(brace
id|OUTB
c_func
(paren
id|nc_dmode
comma
l_int|0xc0
)paren
suffix:semicolon
multiline_comment|/* Set 16-transfer burst */
)brace
macro_line|#if 0
id|burstlen
op_assign
l_int|0xc0
suffix:semicolon
macro_line|#endif
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*  Remove Reset, abort ...&t;     */
macro_line|#ifdef SCSI_NCR_DISABLE_PARITY_CHECK
id|OUTB
(paren
id|nc_scntl0
comma
l_int|0xc0
)paren
suffix:semicolon
multiline_comment|/*  full arb., (no parity)           */
macro_line|#else
id|OUTB
(paren
id|nc_scntl0
comma
l_int|0xca
)paren
suffix:semicolon
multiline_comment|/*  full arb., ena parity, par-&gt;ATN  */
macro_line|#endif
id|OUTB
(paren
id|nc_scntl1
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/*  odd parity, and remove CRST!!    */
id|OUTB
(paren
id|nc_scntl3
comma
id|np-&gt;rv_scntl3
)paren
suffix:semicolon
multiline_comment|/*  timing prescaler&t;&t;     */
id|OUTB
(paren
id|nc_scid
comma
id|RRE
op_or
id|np-&gt;myaddr
)paren
suffix:semicolon
multiline_comment|/*  host adapter SCSI address       */
id|OUTW
(paren
id|nc_respid
comma
l_int|1ul
op_lshift
id|np-&gt;myaddr
)paren
suffix:semicolon
multiline_comment|/*  id to respond to&t;&t;     */
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
)paren
suffix:semicolon
multiline_comment|/*  Signal Process&t;&t;     */
macro_line|#if 0
id|OUTB
(paren
id|nc_dmode
comma
id|burstlen
)paren
suffix:semicolon
multiline_comment|/*  Burst length = 2 .. 16 transfers */
macro_line|#endif
id|OUTB
(paren
id|nc_dcntl
comma
id|NOCOM
)paren
suffix:semicolon
multiline_comment|/*  no single step mode, protect SFBR*/
macro_line|#ifdef SCSI_NCR_DISABLE_MPARITY_CHECK
id|OUTB
(paren
id|nc_ctest4
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/*  disable master parity checking   */
macro_line|#else
id|OUTB
(paren
id|nc_ctest4
comma
l_int|0x08
)paren
suffix:semicolon
multiline_comment|/*  enable master parity checking    */
macro_line|#endif
id|OUTB
(paren
id|nc_stest2
comma
id|EXT
)paren
suffix:semicolon
multiline_comment|/*  Extended Sreq/Sack filtering     */
id|OUTB
(paren
id|nc_stest3
comma
id|TE
)paren
suffix:semicolon
multiline_comment|/*  TolerANT enable&t;&t;     */
id|OUTB
(paren
id|nc_stime0
comma
l_int|0x0d
)paren
suffix:semicolon
multiline_comment|/*  HTH = disable  STO = 0.4 sec.    */
multiline_comment|/*  0.25 sec recommended for scsi 1  */
multiline_comment|/*&n;&t;**&t;Reinitialize usrsync.&n;&t;**&t;Have to renegotiate synch mode.&n;&t;*/
id|usrsync
op_assign
l_int|255
suffix:semicolon
macro_line|#ifndef SCSI_NCR_FORCE_ASYNCHRONOUS
r_if
c_cond
(paren
id|SCSI_NCR_MAX_SYNC
)paren
(brace
id|u_long
id|period
suffix:semicolon
id|period
op_assign
l_int|1000000
op_div
id|SCSI_NCR_MAX_SYNC
suffix:semicolon
multiline_comment|/* ns = 10e6 / kHz */
r_if
c_cond
(paren
id|period
op_le
l_int|11
op_star
id|np-&gt;ns_sync
)paren
(brace
r_if
c_cond
(paren
id|period
OL
l_int|4
op_star
id|np-&gt;ns_sync
)paren
id|usrsync
op_assign
id|np-&gt;ns_sync
suffix:semicolon
r_else
id|usrsync
op_assign
id|period
op_div
l_int|4
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Reinitialize usrwide.&n;&t;**&t;Have to renegotiate wide mode.&n;&t;*/
id|usrwide
op_assign
(paren
id|SCSI_NCR_MAX_WIDE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usrwide
OG
id|np-&gt;maxwide
)paren
id|usrwide
op_assign
id|np-&gt;maxwide
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Disable disconnects.&n;&t;*/
id|np-&gt;disc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Fill in target structure.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|tp-&gt;sval
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;wval
op_assign
id|np-&gt;rv_scntl3
suffix:semicolon
id|tp-&gt;usrsync
op_assign
id|usrsync
suffix:semicolon
id|tp-&gt;usrwide
op_assign
id|usrwide
suffix:semicolon
id|ncr_negotiate
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**      enable ints&n;&t;*/
id|OUTW
(paren
id|nc_sien
comma
id|STO
op_or
id|HTH
op_or
id|MA
op_or
id|SGE
op_or
id|UDC
op_or
id|RST
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_dien
comma
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|SSI
op_or
id|SIR
op_or
id|IID
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**    Start script processor.&n;&t;*/
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|start
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Prepare the negotiation values for wide and&n;**&t;synchronous transfers.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_negotiate
r_static
r_void
id|ncr_negotiate
(paren
r_struct
id|ncb
op_star
id|np
comma
r_struct
id|tcb
op_star
id|tp
)paren
(brace
multiline_comment|/*&n;&t;**&t;minsync unit is 4ns !&n;&t;*/
id|u_long
id|minsync
op_assign
id|tp-&gt;usrsync
suffix:semicolon
r_if
c_cond
(paren
id|minsync
OL
l_int|25
)paren
id|minsync
op_assign
l_int|25
suffix:semicolon
multiline_comment|/*&n;&t;**&t;if not scsi 2&n;&t;**&t;don&squot;t believe FAST!&n;&t;*/
r_if
c_cond
(paren
(paren
id|minsync
OL
l_int|50
)paren
op_logical_and
(paren
id|tp-&gt;inqdata
(braket
l_int|2
)braket
op_amp
l_int|0x0f
)paren
OL
l_int|2
)paren
id|minsync
op_assign
l_int|50
suffix:semicolon
multiline_comment|/*&n;&t;**&t;our limit ..&n;&t;*/
r_if
c_cond
(paren
id|minsync
OL
id|np-&gt;ns_sync
)paren
id|minsync
op_assign
id|np-&gt;ns_sync
suffix:semicolon
multiline_comment|/*&n;&t;**&t;divider limit&n;&t;*/
r_if
c_cond
(paren
id|minsync
OG
(paren
id|np-&gt;ns_sync
op_star
l_int|11
)paren
op_div
l_int|4
)paren
id|minsync
op_assign
l_int|255
suffix:semicolon
id|tp-&gt;minsync
op_assign
id|minsync
suffix:semicolon
id|tp-&gt;maxoffs
op_assign
(paren
id|minsync
OL
l_int|255
ques
c_cond
l_int|8
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;period=0: has to negotiate sync transfer&n;&t;*/
id|tp-&gt;period
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;widedone=0: has to negotiate wide transfer&n;&t;*/
id|tp-&gt;widedone
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Switch sync mode for current job and it&squot;s target&n;**&n;**==========================================================&n;*/
DECL|function|ncr_setsync
r_static
r_void
id|ncr_setsync
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|sxfer
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|u_char
id|target
op_assign
id|INB
(paren
id|nc_ctest0
)paren
op_amp
l_int|7
suffix:semicolon
m_assert
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
suffix:semicolon
id|cmd
op_assign
id|cp-&gt;cmd
suffix:semicolon
m_assert
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
r_return
suffix:semicolon
m_assert
(paren
id|target
op_eq
(paren
id|cmd-&gt;target
op_amp
l_int|0xf
)paren
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|tp-&gt;period
op_assign
id|sxfer
op_amp
l_int|0xf
ques
c_cond
(paren
(paren
id|sxfer
op_rshift
l_int|5
)paren
op_plus
l_int|4
)paren
op_star
id|np-&gt;ns_sync
suffix:colon
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;sval
op_eq
id|sxfer
)paren
r_return
suffix:semicolon
id|tp-&gt;sval
op_assign
id|sxfer
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Bells and whistles   ;-)&n;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sxfer
op_amp
l_int|0x0f
)paren
(brace
multiline_comment|/*&n;&t;&t;**  Disable extended Sreq/Sack filtering&n;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;period
op_le
l_int|200
)paren
id|OUTB
(paren
id|nc_stest2
comma
l_int|0
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;%s%dns (%d Mb/sec) offset %d.&bslash;n&quot;
comma
id|tp-&gt;period
OL
l_int|200
ques
c_cond
l_string|&quot;FAST SCSI-2 &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|tp-&gt;period
comma
(paren
(paren
(paren
id|tp-&gt;wval
op_amp
id|EWS
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
)paren
op_star
l_int|1000
op_plus
id|tp-&gt;period
op_div
l_int|2
)paren
op_div
id|tp-&gt;period
comma
id|sxfer
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
r_else
id|printf
(paren
l_string|&quot;asynchronous.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;set actual value and sync_status&n;&t;*/
id|OUTB
(paren
id|nc_sxfer
comma
id|sxfer
)paren
suffix:semicolon
id|np-&gt;sync_st
op_assign
id|sxfer
suffix:semicolon
multiline_comment|/*&n;&t;**&t;patch ALL ccbs of this target.&n;&t;*/
r_for
c_loop
(paren
id|cp
op_assign
op_amp
id|np-&gt;ccb
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;cmd
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cmd-&gt;target
op_ne
id|target
)paren
r_continue
suffix:semicolon
id|cp-&gt;sync_status
op_assign
id|sxfer
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Switch wide mode for current job and it&squot;s target&n;**&n;**==========================================================&n;*/
DECL|function|ncr_setwide
r_static
r_void
id|ncr_setwide
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|wide
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|u_short
id|target
op_assign
id|INB
(paren
id|nc_ctest0
)paren
op_amp
l_int|7
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|u_char
id|scntl3
op_assign
id|np-&gt;rv_scntl3
op_or
(paren
id|wide
ques
c_cond
id|EWS
suffix:colon
l_int|0
)paren
suffix:semicolon
m_assert
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
suffix:semicolon
id|cmd
op_assign
id|cp-&gt;cmd
suffix:semicolon
m_assert
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
r_return
suffix:semicolon
m_assert
(paren
id|target
op_eq
(paren
id|cmd-&gt;target
op_amp
l_int|0xf
)paren
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|tp-&gt;widedone
op_assign
id|wide
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;wval
op_eq
id|scntl3
)paren
r_return
suffix:semicolon
id|tp-&gt;wval
op_assign
id|scntl3
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Bells and whistles   ;-)&n;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scntl3
op_amp
id|EWS
)paren
id|printf
(paren
l_string|&quot;WIDE SCSI (16 bit) enabled.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printf
(paren
l_string|&quot;WIDE SCSI disabled.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;set actual value and sync_status&n;&t;*/
id|OUTB
(paren
id|nc_scntl3
comma
id|scntl3
)paren
suffix:semicolon
id|np-&gt;wide_st
op_assign
id|scntl3
suffix:semicolon
multiline_comment|/*&n;&t;**&t;patch ALL ccbs of this target.&n;&t;*/
r_for
c_loop
(paren
id|cp
op_assign
op_amp
id|np-&gt;ccb
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;cmd
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cmd-&gt;target
op_ne
id|target
)paren
r_continue
suffix:semicolon
id|cp-&gt;wide_status
op_assign
id|scntl3
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Switch tagged mode for a target.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_setmaxtags
r_static
r_void
id|ncr_setmaxtags
(paren
id|ncb_p
id|np
comma
id|tcb_p
id|tp
comma
id|u_long
id|usrtags
)paren
(brace
r_int
id|l
suffix:semicolon
id|tp-&gt;usrtags
op_assign
id|usrtags
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|MAX_LUN
suffix:semicolon
id|l
op_increment
)paren
(brace
id|lcb_p
id|lp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp
)paren
r_break
suffix:semicolon
id|lp
op_assign
id|tp-&gt;lp
(braket
id|l
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_continue
suffix:semicolon
id|ncr_settags
(paren
id|tp
comma
id|lp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;usetags
OG
l_int|0
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|tp
op_minus
id|np-&gt;target
comma
id|l
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;using tagged command queueing, up to %d cmds/lun&bslash;n&quot;
comma
id|lp-&gt;usetags
)paren
suffix:semicolon
)brace
)brace
suffix:semicolon
)brace
DECL|function|ncr_settags
r_static
r_void
id|ncr_settags
(paren
id|tcb_p
id|tp
comma
id|lcb_p
id|lp
)paren
(brace
id|u_char
id|reqtags
comma
id|tmp
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|tp
)paren
op_logical_or
(paren
op_logical_neg
id|lp
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;only devices conformant to ANSI Version &gt;= 2&n;&t;**&t;only devices capable of tagges commands&n;&t;**&t;only disk devices&n;&t;**&t;only if enabled by user ..&n;&t;*/
r_if
c_cond
(paren
(paren
id|tp-&gt;inqdata
(braket
l_int|2
)braket
op_amp
l_int|0x7
)paren
op_ge
l_int|2
op_logical_and
(paren
id|tp-&gt;inqdata
(braket
l_int|7
)braket
op_amp
id|INQ7_QUEUE
)paren
op_logical_and
(paren
(paren
id|tp-&gt;inqdata
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
op_eq
l_int|0x00
)paren
op_logical_and
id|tp-&gt;usrtags
)paren
(brace
id|reqtags
op_assign
id|tp-&gt;usrtags
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;actlink
op_le
l_int|1
)paren
id|lp-&gt;usetags
op_assign
id|reqtags
suffix:semicolon
)brace
r_else
(brace
id|reqtags
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;actlink
op_le
l_int|1
)paren
id|lp-&gt;usetags
op_assign
l_int|0
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;don&squot;t announce more than available.&n;&t;*/
id|tmp
op_assign
id|lp-&gt;actccbs
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OG
id|reqtags
)paren
id|tmp
op_assign
id|reqtags
suffix:semicolon
id|lp-&gt;reqlink
op_assign
id|tmp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;don&squot;t discard if announced.&n;&t;*/
id|tmp
op_assign
id|lp-&gt;actlink
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
id|reqtags
)paren
id|tmp
op_assign
id|reqtags
suffix:semicolon
id|lp-&gt;reqccbs
op_assign
id|tmp
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------&n;**&n;**&t;handle user commands&n;**&n;**----------------------------------------------------&n;*/
macro_line|#ifdef SCSI_NCR_USER_COMMAND
DECL|function|ncr_usercmd
r_static
r_void
id|ncr_usercmd
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|t
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
r_switch
c_cond
(paren
id|np-&gt;user.cmd
)paren
(brace
r_case
l_int|0
suffix:colon
r_return
suffix:semicolon
r_case
id|UC_SETSYNC
suffix:colon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|np-&gt;user.target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|t
)braket
suffix:semicolon
id|tp-&gt;usrsync
op_assign
id|np-&gt;user.data
suffix:semicolon
id|ncr_negotiate
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETTAGS
suffix:colon
r_if
c_cond
(paren
id|np-&gt;user.data
OG
id|SCSI_NCR_MAX_TAGS
)paren
id|np-&gt;user.data
op_assign
id|SCSI_NCR_MAX_TAGS
suffix:semicolon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|np-&gt;user.target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|ncr_setmaxtags
(paren
id|np
comma
op_amp
id|np-&gt;target
(braket
id|t
)braket
comma
id|np-&gt;user.data
)paren
suffix:semicolon
)brace
suffix:semicolon
id|np-&gt;disc
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETDEBUG
suffix:colon
macro_line|#ifdef SCSI_NCR_DEBUG
id|ncr_debug
op_assign
id|np-&gt;user.data
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|UC_SETORDER
suffix:colon
id|np-&gt;order
op_assign
id|np-&gt;user.data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETWIDE
suffix:colon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
id|u_long
id|size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|np-&gt;user.target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|t
)braket
suffix:semicolon
id|size
op_assign
id|np-&gt;user.data
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|np-&gt;maxwide
)paren
id|size
op_assign
id|np-&gt;maxwide
suffix:semicolon
id|tp-&gt;usrwide
op_assign
id|size
suffix:semicolon
id|ncr_negotiate
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETFLAG
suffix:colon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|np-&gt;user.target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|t
)braket
suffix:semicolon
id|tp-&gt;usrflag
op_assign
id|np-&gt;user.data
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_CLEARPROF
suffix:colon
id|bzero
c_func
(paren
op_amp
id|np-&gt;profile
comma
r_sizeof
(paren
id|np-&gt;profile
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|np-&gt;user.cmd
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;ncr timeout handler.&n;**&n;**&n;**==========================================================&n;**&n;**&t;Misused to keep the driver running when&n;**&t;interrupts are not configured correctly.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_timeout
r_static
r_void
id|ncr_timeout
(paren
id|ncb_p
id|np
)paren
(brace
id|u_long
id|thistime
op_assign
id|jiffies
suffix:semicolon
id|u_long
id|count
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|t
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If release process in progress, let&squot;s go&n;&t;**&t;Set the release stage from 1 to 2 to synchronize&n;&t;**&t;with the release process.&n;&t;**/
r_if
c_cond
(paren
id|np-&gt;release_stage
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;release_stage
op_eq
l_int|1
)paren
id|np-&gt;release_stage
op_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
id|np-&gt;timer.expires
op_assign
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,0)
id|jiffies
op_plus
macro_line|#endif
id|SCSI_NCR_TIMER_INTERVAL
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|np-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;lasttime
op_plus
id|HZ
OL
id|thistime
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;block ncr interrupts&n;&t;&t;*/
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|np-&gt;lasttime
op_assign
id|thistime
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Reset profile data to avoid ugly overflow&n;&t;&t;**&t;(Limited to 1024 GB for 32 bit architecture)&n;&t;&t;*/
r_if
c_cond
(paren
id|np-&gt;profile.num_kbytes
OG
(paren
op_complement
l_int|0UL
op_rshift
l_int|2
)paren
)paren
id|bzero
c_func
(paren
op_amp
id|np-&gt;profile
comma
r_sizeof
(paren
id|np-&gt;profile
)paren
)paren
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;handle ncr chip timeouts&n;&t;&t;**&n;&t;&t;**&t;Assumption:&n;&t;&t;**&t;We have a chance to arbitrate for the&n;&t;&t;**&t;SCSI bus at least every 10 seconds.&n;&t;&t;**&n;&t;&t;**----------------------------------------------------&n;&t;&t;*/
id|t
op_assign
(paren
id|thistime
op_minus
id|np-&gt;heartbeat
)paren
op_div
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|t
OL
l_int|2
)paren
id|np-&gt;latetime
op_assign
l_int|0
suffix:semicolon
r_else
id|np-&gt;latetime
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;latetime
OG
l_int|5
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;**      If there are no requests, the script&n;&t;&t;&t;**      processor will sleep on SEL_WAIT_RESEL.&n;&t;&t;&t;**      But we have to check whether it died.&n;&t;&t;&t;**      Let&squot;s wake it up.&n;&t;&t;&t;*/
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|np-&gt;latetime
OG
l_int|10
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;**&t;Although we tried to wake it up,&n;&t;&t;&t;**&t;the script processor didn&squot;t respond.&n;&t;&t;&t;**&n;&t;&t;&t;**&t;May be a target is hanging,&n;&t;&t;&t;**&t;or another initator lets a tape device&n;&t;&t;&t;**&t;rewind with disconnect disabled :-(&n;&t;&t;&t;**&n;&t;&t;&t;**&t;We won&squot;t accept that.&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|INB
(paren
id|nc_sbcl
)paren
op_amp
id|CBSY
)paren
id|OUTB
(paren
id|nc_scntl1
comma
id|CRST
)paren
suffix:semicolon
id|DELAY
(paren
l_int|1000
)paren
suffix:semicolon
id|ncr_init
(paren
id|np
comma
l_string|&quot;ncr dead ?&quot;
comma
id|HS_TIMEOUT
)paren
suffix:semicolon
macro_line|#ifndef SCSI_NCR_NO_DISCONNECT
id|np-&gt;disc
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|np-&gt;heartbeat
op_assign
id|thistime
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;should handle ccb timeouts&n;&t;&t;**&t;Let the middle scsi driver manage timeouts.&n;&t;&t;**----------------------------------------------------&n;&t;&t;*/
r_for
c_loop
(paren
id|cp
op_assign
op_amp
id|np-&gt;ccb
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;**&t;look for timed out ccbs.&n;&t;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;host_status
)paren
r_continue
suffix:semicolon
id|count
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;**&t;Have to force ordered tag to avoid timeouts&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;cmd
op_logical_and
id|cp-&gt;tlimit
op_le
id|thistime
op_plus
id|NCR_TIMEOUT_INCREASE
op_plus
id|SCSI_NCR_TIMEOUT_ALERT
)paren
(brace
id|lcb_p
id|lp
suffix:semicolon
id|lp
op_assign
id|np-&gt;target
(braket
id|cp-&gt;cmd-&gt;target
)braket
dot
id|lp
(braket
id|cp-&gt;cmd-&gt;lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lp
op_logical_and
op_logical_neg
id|lp-&gt;force_ordered_tag
)paren
(brace
id|lp-&gt;force_ordered_tag
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;**&t;Let the middle scsi driver manage timeouts&n;*/
macro_line|#if 0
r_if
c_cond
(paren
id|cp-&gt;tlimit
OG
id|thistime
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;**&t;Disable reselect.&n;&t;&t;&t;**      Remove it from startqueue.&n;&t;&t;&t;*/
id|cp-&gt;jump_ccb.l_cmd
op_assign
(paren
id|SCR_JUMP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;phys.header.launch.l_paddr
op_eq
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|select
)paren
)paren
(brace
id|printf
(paren
l_string|&quot;%s: timeout ccb=%p (skip)&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|cp
)paren
suffix:semicolon
id|cp-&gt;phys.header.launch.l_paddr
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|skip
)paren
suffix:semicolon
)brace
suffix:semicolon
r_switch
c_cond
(paren
id|cp-&gt;host_status
)paren
(brace
r_case
id|HS_BUSY
suffix:colon
r_case
id|HS_NEGOTIATE
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;** still in start queue ?&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;phys.header.launch.l_paddr
op_eq
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|skip
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|HS_DISCONNECT
suffix:colon
id|cp-&gt;host_status
op_assign
id|HS_TIMEOUT
suffix:semicolon
)brace
suffix:semicolon
id|cp-&gt;tag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;**&t;wakeup this ccb.&n;&t;&t;&t;*/
id|ncr_complete
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
macro_line|#endif
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_BROKEN_INTR
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_istat
)paren
op_amp
(paren
id|INTF
op_or
id|SIP
op_or
id|DIP
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;Process pending interrupts.&n;&t;&t;*/
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;{&quot;
)paren
suffix:semicolon
id|ncr_exception
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_BROKEN_INTR */
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;ncr chip exception handler.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_exception
r_void
id|ncr_exception
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|istat
comma
id|dstat
suffix:semicolon
id|u_short
id|sist
suffix:semicolon
id|u_int32
id|dsp
comma
id|dsa
suffix:semicolon
r_int
id|script_ofs
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;**&t;interrupt on the fly ?&n;&t;*/
r_while
c_loop
(paren
(paren
id|istat
op_assign
id|INB
(paren
id|nc_istat
)paren
)paren
op_amp
id|INTF
)paren
(brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;F&quot;
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
(paren
id|istat
op_amp
id|SIGP
)paren
op_or
id|INTF
)paren
suffix:semicolon
id|np-&gt;profile.num_fly
op_increment
suffix:semicolon
id|ncr_wakeup
(paren
id|np
comma
l_int|0
)paren
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|istat
op_amp
(paren
id|SIP
op_or
id|DIP
)paren
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Steinbach&squot;s Guideline for Systems Programming:&n;&t;**&t;Never test for an error condition you don&squot;t know how to handle.&n;&t;*/
id|dstat
op_assign
id|INB
(paren
id|nc_dstat
)paren
suffix:semicolon
id|sist
op_assign
id|INW
(paren
id|nc_sist
)paren
suffix:semicolon
id|np-&gt;profile.num_int
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;&lt;%d|%x:%x|%x:%x&gt;&quot;
comma
(paren
r_int
)paren
id|INB
c_func
(paren
id|nc_scr0
)paren
comma
id|dstat
comma
id|sist
comma
(paren
r_int
)paren
id|INL
c_func
(paren
id|nc_dsp
)paren
comma
(paren
r_int
)paren
id|INL
c_func
(paren
id|nc_dbc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dstat
op_eq
id|DFE
)paren
op_logical_and
(paren
id|sist
op_eq
id|PAR
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&t;First the normal cases.&n;**&n;**==========================================================&n;*/
multiline_comment|/*-------------------------------------------&n;&t;**&t;SCSI reset&n;&t;**-------------------------------------------&n;&t;*/
r_if
c_cond
(paren
id|sist
op_amp
id|RST
)paren
(brace
id|ncr_init
(paren
id|np
comma
id|bootverbose
ques
c_cond
l_string|&quot;scsi reset&quot;
suffix:colon
l_int|NULL
comma
id|HS_RESET
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*-------------------------------------------&n;&t;**&t;selection timeout&n;&t;**&n;&t;**&t;IID excluded from dstat mask!&n;&t;**&t;(chip bug)&n;&t;**-------------------------------------------&n;&t;*/
r_if
c_cond
(paren
(paren
id|sist
op_amp
id|STO
)paren
op_logical_and
op_logical_neg
(paren
id|sist
op_amp
(paren
id|GEN
op_or
id|HTH
op_or
id|MA
op_or
id|SGE
op_or
id|UDC
op_or
id|RST
op_or
id|PAR
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|SIR
)paren
)paren
)paren
(brace
id|ncr_int_sto
(paren
id|np
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*-------------------------------------------&n;&t;**      Phase mismatch.&n;&t;**-------------------------------------------&n;&t;*/
r_if
c_cond
(paren
(paren
id|sist
op_amp
id|MA
)paren
op_logical_and
op_logical_neg
(paren
id|sist
op_amp
(paren
id|STO
op_or
id|GEN
op_or
id|HTH
op_or
id|SGE
op_or
id|UDC
op_or
id|RST
op_or
id|PAR
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|SIR
op_or
id|IID
)paren
)paren
)paren
(brace
id|ncr_int_ma
(paren
id|np
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*----------------------------------------&n;&t;**&t;move command with length 0&n;&t;**----------------------------------------&n;&t;*/
r_if
c_cond
(paren
(paren
id|dstat
op_amp
id|IID
)paren
op_logical_and
op_logical_neg
(paren
id|sist
op_amp
(paren
id|STO
op_or
id|GEN
op_or
id|HTH
op_or
id|MA
op_or
id|SGE
op_or
id|UDC
op_or
id|RST
op_or
id|PAR
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|SIR
)paren
)paren
op_logical_and
(paren
(paren
id|INL
c_func
(paren
id|nc_dbc
)paren
op_amp
l_int|0xf8000000
)paren
op_eq
id|SCR_MOVE_TBL
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**      Target wants more data than available.&n;&t;&t;**&t;The &quot;no_data&quot; script will do it.&n;&t;&t;*/
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|no_data
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*-------------------------------------------&n;&t;**&t;Programmed interrupt&n;&t;**-------------------------------------------&n;&t;*/
r_if
c_cond
(paren
(paren
id|dstat
op_amp
id|SIR
)paren
op_logical_and
op_logical_neg
(paren
id|sist
op_amp
(paren
id|STO
op_or
id|GEN
op_or
id|HTH
op_or
id|MA
op_or
id|SGE
op_or
id|UDC
op_or
id|RST
op_or
id|PAR
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|IID
)paren
)paren
op_logical_and
(paren
id|INB
c_func
(paren
id|nc_dsps
)paren
op_le
id|SIR_MAX
)paren
)paren
(brace
id|ncr_int_sir
(paren
id|np
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*========================================&n;&t;**&t;do the register dump&n;&t;**========================================&n;&t;*/
r_if
c_cond
(paren
id|jiffies
op_minus
id|np-&gt;regtime
OG
l_int|10
op_star
id|HZ
)paren
(brace
r_int
id|i
suffix:semicolon
id|np-&gt;regtime
op_assign
id|jiffies
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|np-&gt;regdump
)paren
suffix:semicolon
id|i
op_increment
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|np-&gt;regdump
)paren
(braket
id|i
)braket
op_assign
id|INB_OFF
c_func
(paren
id|i
)paren
suffix:semicolon
id|np-&gt;regdump.nc_dstat
op_assign
id|dstat
suffix:semicolon
id|np-&gt;regdump.nc_sist
op_assign
id|sist
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*=========================================&n;&t;**&t;log message for real hard errors&n;&t;**=========================================&n;&n;&t;&quot;ncr0 targ 0?: ERROR (ds:si) (so-si-sd) (sxfer/scntl3) @ (dsp:dbc).&quot;&n;&t;&quot;&t;      reg: r0 r1 r2 r3 r4 r5 r6 ..... rf.&quot;&n;&n;&t;exception register:&n;&t;&t;ds:&t;dstat&n;&t;&t;si:&t;sist&n;&n;&t;SCSI bus lines:&n;&t;&t;so:&t;control lines as driver by NCR.&n;&t;&t;si:&t;control lines as seen by NCR.&n;&t;&t;sd:&t;scsi data lines as seen by NCR.&n;&n;&t;wide/fastmode:&n;&t;&t;sxfer:&t;(see the manual)&n;&t;&t;scntl3:&t;(see the manual)&n;&n;&t;current script command:&n;&t;&t;dsp:&t;script adress (relative to start of script).&n;&t;&t;dbc:&t;first word of script command.&n;&n;&t;First 16 register of the chip:&n;&t;&t;r0..rf&n;&n;&t;=============================================&n;&t;*/
id|dsp
op_assign
(paren
r_int
)paren
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
id|dsa
op_assign
(paren
r_int
)paren
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|script_ofs
op_assign
id|dsp
op_minus
id|np-&gt;p_script
suffix:semicolon
id|printf
(paren
l_string|&quot;%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%x:%08x).&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_ctest0
)paren
op_amp
l_int|0x0f
comma
id|dstat
comma
id|sist
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_socl
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sbcl
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sbdl
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sxfer
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_scntl3
)paren
comma
id|script_ofs
comma
(paren
r_int
)paren
id|INL
(paren
id|nc_dbc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|script_ofs
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
r_int
)paren
id|script_ofs
OL
r_sizeof
(paren
r_struct
id|script
)paren
)paren
(brace
id|printf
(paren
l_string|&quot;&bslash;tscript cmd = %08x&bslash;n&quot;
comma
(paren
r_int
)paren
op_star
(paren
id|ncrcmd
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|np-&gt;script
op_plus
id|script_ofs
)paren
)paren
suffix:semicolon
)brace
id|printf
(paren
l_string|&quot;&bslash;treg:&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|printf
(paren
l_string|&quot; %02x&quot;
comma
(paren
r_int
)paren
id|INB_OFF
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*----------------------------------------&n;&t;**&t;clean up the dma fifo&n;&t;**----------------------------------------&n;&t;*/
r_if
c_cond
(paren
(paren
id|INB
c_func
(paren
id|nc_sstat0
)paren
op_amp
(paren
id|ILF
op_or
id|ORF
op_or
id|OLF
)paren
)paren
op_logical_or
(paren
id|INB
c_func
(paren
id|nc_sstat1
)paren
op_amp
(paren
id|FF3210
)paren
)paren
op_logical_or
(paren
id|INB
c_func
(paren
id|nc_sstat2
)paren
op_amp
(paren
id|ILF1
op_or
id|ORF1
op_or
id|OLF1
)paren
)paren
op_logical_or
multiline_comment|/* wide .. */
op_logical_neg
(paren
id|dstat
op_amp
id|DFE
)paren
)paren
(brace
id|printf
(paren
l_string|&quot;%s: have to clear fifos.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
multiline_comment|/* clear scsi fifo */
id|OUTB
(paren
id|nc_ctest3
comma
id|CLF
)paren
suffix:semicolon
multiline_comment|/* clear dma fifo  */
)brace
multiline_comment|/*----------------------------------------&n;&t;**&t;handshake timeout&n;&t;**----------------------------------------&n;&t;*/
r_if
c_cond
(paren
id|sist
op_amp
id|HTH
)paren
(brace
id|printf
(paren
l_string|&quot;%s: handshake timeout&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_scntl1
comma
id|CRST
)paren
suffix:semicolon
id|DELAY
(paren
l_int|1000
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_scntl1
comma
l_int|0x00
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_scr0
comma
id|HS_FAIL
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|cleanup
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------&n;&t;**&t;unexpected disconnect&n;&t;**----------------------------------------&n;&t;*/
r_if
c_cond
(paren
(paren
id|sist
op_amp
id|UDC
)paren
op_logical_and
op_logical_neg
(paren
id|sist
op_amp
(paren
id|STO
op_or
id|GEN
op_or
id|HTH
op_or
id|MA
op_or
id|SGE
op_or
id|RST
op_or
id|PAR
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|SIR
op_or
id|IID
)paren
)paren
)paren
(brace
id|OUTB
(paren
id|nc_scr0
comma
id|HS_UNEXPECTED
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|cleanup
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*----------------------------------------&n;&t;**&t;cannot disconnect&n;&t;**----------------------------------------&n;&t;*/
r_if
c_cond
(paren
(paren
id|dstat
op_amp
id|IID
)paren
op_logical_and
op_logical_neg
(paren
id|sist
op_amp
(paren
id|STO
op_or
id|GEN
op_or
id|HTH
op_or
id|MA
op_or
id|SGE
op_or
id|UDC
op_or
id|RST
op_or
id|PAR
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|SIR
)paren
)paren
op_logical_and
(paren
(paren
id|INL
c_func
(paren
id|nc_dbc
)paren
op_amp
l_int|0xf8000000
)paren
op_eq
id|SCR_WAIT_DISC
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**      Unexpected data cycle while waiting for disconnect.&n;&t;&t;*/
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_sstat2
)paren
op_amp
id|LDSC
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;**&t;It&squot;s an early reconnect.&n;&t;&t;&t;**&t;Let&squot;s continue ...&n;&t;&t;&t;*/
id|OUTB
(paren
id|nc_dcntl
comma
(paren
id|STD
op_or
id|NOCOM
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;**&t;info message&n;&t;&t;&t;*/
id|printf
(paren
l_string|&quot;%s: INFO: LDSC while IID.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
id|printf
(paren
l_string|&quot;%s: target %d doesn&squot;t release the bus.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_ctest0
)paren
op_amp
l_int|0x0f
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;return without restarting the NCR.&n;&t;&t;**&t;timeout will do the real work.&n;&t;&t;*/
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*----------------------------------------&n;&t;**&t;single step&n;&t;**----------------------------------------&n;&t;*/
r_if
c_cond
(paren
(paren
id|dstat
op_amp
id|SSI
)paren
op_logical_and
op_logical_neg
(paren
id|sist
op_amp
(paren
id|STO
op_or
id|GEN
op_or
id|HTH
op_or
id|MA
op_or
id|SGE
op_or
id|UDC
op_or
id|RST
op_or
id|PAR
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|SIR
op_or
id|IID
)paren
)paren
)paren
(brace
id|OUTB
(paren
id|nc_dcntl
comma
(paren
id|STD
op_or
id|NOCOM
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;@RECOVER@ HTH, SGE, ABRT.&n;**&n;**&t;We should try to recover from these interrupts.&n;**&t;They may occur if there are problems with synch transfers, or &n;**&t;if targets are switched on or off while the driver is running.&n;*/
r_if
c_cond
(paren
id|sist
op_amp
id|SGE
)paren
(brace
id|OUTB
(paren
id|nc_ctest3
comma
id|CLF
)paren
suffix:semicolon
multiline_comment|/* clear scsi offsets */
)brace
multiline_comment|/*&n;&t;**&t;Freeze controller to be able to read the messages.&n;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_FREEZE
)paren
(brace
r_int
r_char
id|val
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x60
suffix:semicolon
id|i
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|i
op_mod
l_int|16
)paren
(brace
r_case
l_int|0
suffix:colon
id|printf
(paren
l_string|&quot;%s: reg[%d0]: &quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|i
op_div
l_int|16
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_case
l_int|8
suffix:colon
r_case
l_int|12
suffix:colon
id|printf
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|val
op_assign
id|INB_OFF
c_func
(paren
id|i
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot; %x%x&quot;
comma
id|val
op_div
l_int|16
comma
id|val
op_mod
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_mod
l_int|16
op_eq
l_int|15
)paren
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|del_timer
c_func
(paren
op_amp
id|np-&gt;timer
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;%s: halted!&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;don&squot;t restart controller ...&n;&t;&t;*/
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef NCR_FREEZE
multiline_comment|/*&n;&t;**&t;Freeze system to be able to read the messages.&n;&t;*/
id|printf
(paren
l_string|&quot;ncr: fatal error: system halted - press reset to reboot ...&quot;
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;sorry, have to kill ALL jobs ...&n;&t;*/
id|ncr_init
(paren
id|np
comma
l_string|&quot;fatal error&quot;
comma
id|HS_FAIL
)paren
suffix:semicolon
macro_line|#ifndef SCSI_NCR_NO_DISCONNECT
id|np-&gt;disc
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip exception handler for selection timeout&n;**&n;**==========================================================&n;**&n;**&t;There seems to be a bug in the 53c810.&n;**&t;Although a STO-Interrupt is pending,&n;**&t;it continues executing script commands.&n;**&t;But it will fail and interrupt (IID) on&n;**&t;the next instruction where it&squot;s looking&n;**&t;for a valid phase.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_sto
r_void
id|ncr_int_sto
(paren
id|ncb_p
id|np
)paren
(brace
id|u_long
id|dsa
comma
id|scratcha
comma
id|diff
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;T&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;look for ccb and set the status.&n;&t;*/
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|cp
op_assign
op_amp
id|np-&gt;ccb
suffix:semicolon
r_while
c_loop
(paren
id|cp
op_logical_and
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|phys
)paren
op_ne
id|dsa
)paren
)paren
id|cp
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
r_if
c_cond
(paren
id|cp
)paren
(brace
id|cp
op_member_access_from_pointer
id|host_status
op_assign
id|HS_SEL_TIMEOUT
suffix:semicolon
id|ncr_complete
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;repair start queue&n;&t;*/
id|scratcha
op_assign
id|INL
(paren
id|nc_scratcha
)paren
suffix:semicolon
id|diff
op_assign
id|scratcha
op_minus
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|tryloop
)paren
suffix:semicolon
multiline_comment|/*&t;assert ((diff &lt;= MAX_START * 20) &amp;&amp; !(diff % 20));*/
r_if
c_cond
(paren
(paren
id|diff
op_le
id|MAX_START
op_star
l_int|20
)paren
op_logical_and
op_logical_neg
(paren
id|diff
op_mod
l_int|20
)paren
)paren
(brace
id|np-&gt;script-&gt;startpos
(braket
l_int|0
)braket
op_assign
id|scratcha
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|start
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
id|ncr_init
(paren
id|np
comma
l_string|&quot;selection timeout&quot;
comma
id|HS_FAIL
)paren
suffix:semicolon
macro_line|#ifndef SCSI_NCR_NO_DISCONNECT
id|np-&gt;disc
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;ncr chip exception handler for phase errors.&n;**&n;**&n;**==========================================================&n;**&n;**&t;We have to construct a new transfer descriptor,&n;**&t;to transfer the rest of the current block.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_ma
r_static
r_void
id|ncr_int_ma
(paren
id|ncb_p
id|np
)paren
(brace
id|u_int32
id|dbc
suffix:semicolon
id|u_int32
id|rest
suffix:semicolon
id|u_int32
id|dsa
suffix:semicolon
id|u_int32
id|dsp
suffix:semicolon
id|u_int32
id|nxtdsp
suffix:semicolon
id|u_int32
op_star
id|vdsp
suffix:semicolon
id|u_int32
id|oadr
comma
id|olen
suffix:semicolon
id|u_int32
op_star
id|tblp
suffix:semicolon
id|ncrcmd
op_star
id|newcmd
suffix:semicolon
id|u_char
id|cmd
comma
id|sbcl
comma
id|delta
comma
id|ss0
comma
id|ss2
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|dbc
op_assign
id|INL
(paren
id|nc_dbc
)paren
suffix:semicolon
id|ss0
op_assign
id|INB
(paren
id|nc_sstat0
)paren
suffix:semicolon
id|ss2
op_assign
id|INB
(paren
id|nc_sstat2
)paren
suffix:semicolon
id|sbcl
op_assign
id|INB
(paren
id|nc_sbcl
)paren
suffix:semicolon
id|cmd
op_assign
id|dbc
op_rshift
l_int|24
suffix:semicolon
id|rest
op_assign
id|dbc
op_amp
l_int|0xffffff
suffix:semicolon
id|delta
op_assign
(paren
id|INB
(paren
id|nc_dfifo
)paren
op_minus
id|rest
)paren
op_amp
l_int|0x7f
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The data in the dma fifo has not been transfered to&n;&t;**&t;the target -&gt; add the amount to the rest&n;&t;**&t;and clear the data.&n;&t;**&t;Check the sstat2 register in case of wide transfer.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|INB
c_func
(paren
id|nc_dstat
)paren
op_amp
id|DFE
)paren
)paren
id|rest
op_add_assign
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|ss0
op_amp
id|OLF
)paren
id|rest
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ss0
op_amp
id|ORF
)paren
id|rest
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_scntl3
)paren
op_amp
id|EWS
)paren
(brace
r_if
c_cond
(paren
id|ss2
op_amp
id|OLF1
)paren
id|rest
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ss2
op_amp
id|ORF1
)paren
id|rest
op_increment
suffix:semicolon
)brace
suffix:semicolon
id|OUTB
(paren
id|nc_ctest3
comma
id|CLF
)paren
suffix:semicolon
multiline_comment|/* clear dma fifo  */
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
multiline_comment|/* clear scsi fifo */
multiline_comment|/*&n;&t;**&t;locate matching cp&n;&t;*/
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|cp
op_assign
op_amp
id|np-&gt;ccb
suffix:semicolon
r_while
c_loop
(paren
id|cp
op_logical_and
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|phys
)paren
op_ne
id|dsa
)paren
)paren
id|cp
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
(brace
id|printf
(paren
l_string|&quot;%s: SCSI phase error fixup: CCB already dequeued (0x%08lx)&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|np-&gt;header.cp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cp
op_ne
id|np-&gt;header.cp
)paren
(brace
id|printf
(paren
l_string|&quot;%s: SCSI phase error fixup: CCB address mismatch (0x%08lx != 0x%08lx)&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|cp
comma
(paren
id|u_long
)paren
id|np-&gt;header.cp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;find the interrupted script command,&n;&t;**&t;and the address at which to continue.&n;&t;*/
r_if
c_cond
(paren
id|dsp
op_eq
id|vtophys
(paren
op_amp
id|cp-&gt;patch
(braket
l_int|2
)braket
)paren
)paren
(brace
id|vdsp
op_assign
op_amp
id|cp-&gt;patch
(braket
l_int|0
)braket
suffix:semicolon
id|nxtdsp
op_assign
id|vdsp
(braket
l_int|3
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dsp
op_eq
id|vtophys
(paren
op_amp
id|cp-&gt;patch
(braket
l_int|6
)braket
)paren
)paren
(brace
id|vdsp
op_assign
op_amp
id|cp-&gt;patch
(braket
l_int|4
)braket
suffix:semicolon
id|nxtdsp
op_assign
id|vdsp
(braket
l_int|3
)braket
suffix:semicolon
)brace
r_else
(brace
id|vdsp
op_assign
(paren
id|u_int32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|np-&gt;script
op_minus
id|np-&gt;p_script
op_plus
id|dsp
op_minus
l_int|8
)paren
suffix:semicolon
id|nxtdsp
op_assign
id|dsp
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;log the information&n;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
(paren
id|DEBUG_TINY
op_or
id|DEBUG_PHASE
)paren
)paren
(brace
id|printf
(paren
l_string|&quot;P%x%x &quot;
comma
id|cmd
op_amp
l_int|7
comma
id|sbcl
op_amp
l_int|7
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;RL=%d D=%d SS0=%x &quot;
comma
(paren
r_int
)paren
id|rest
comma
(paren
r_int
)paren
id|delta
comma
id|ss0
)paren
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
(brace
id|printf
(paren
l_string|&quot;&bslash;nCP=%p CP2=%p DSP=%x NXT=%x VDSP=%p CMD=%x &quot;
comma
id|cp
comma
id|np-&gt;header.cp
comma
(paren
r_int
)paren
id|dsp
comma
(paren
r_int
)paren
id|nxtdsp
comma
id|vdsp
comma
id|cmd
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;get old startaddress and old length.&n;&t;*/
id|oadr
op_assign
id|vdsp
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_amp
l_int|0x10
)paren
(brace
multiline_comment|/* Table indirect */
id|tblp
op_assign
(paren
id|u_int32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|cp-&gt;phys
op_plus
id|oadr
)paren
suffix:semicolon
id|olen
op_assign
id|tblp
(braket
l_int|0
)braket
suffix:semicolon
id|oadr
op_assign
id|tblp
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_else
(brace
id|tblp
op_assign
(paren
id|u_int32
op_star
)paren
l_int|0
suffix:semicolon
id|olen
op_assign
id|vdsp
(braket
l_int|0
)braket
op_amp
l_int|0xffffff
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
(brace
id|printf
(paren
l_string|&quot;OCMD=%x&bslash;nTBLP=%p OLEN=%x OADR=%x&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|vdsp
(braket
l_int|0
)braket
op_rshift
l_int|24
)paren
comma
id|tblp
comma
(paren
r_int
)paren
id|olen
comma
(paren
r_int
)paren
id|oadr
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;if old phase not dataphase, leave here.&n;&t;*/
r_if
c_cond
(paren
id|cmd
op_ne
(paren
id|vdsp
(braket
l_int|0
)braket
op_rshift
l_int|24
)paren
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;internal error: cmd=%02x != %02x=(vdsp[0] &gt;&gt; 24)&bslash;n&quot;
comma
(paren
r_int
)paren
id|cmd
comma
(paren
r_int
)paren
id|vdsp
(braket
l_int|0
)braket
op_rshift
l_int|24
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_amp
l_int|0x06
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;phase change %x-%x %d@%08x resid=%d.&bslash;n&quot;
comma
id|cmd
op_amp
l_int|7
comma
id|sbcl
op_amp
l_int|7
comma
(paren
r_int
)paren
id|olen
comma
(paren
r_int
)paren
id|oadr
comma
(paren
r_int
)paren
id|rest
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_dcntl
comma
(paren
id|STD
op_or
id|NOCOM
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;choose the correct patch area.&n;&t;**&t;if savep points to one, choose the other.&n;&t;*/
id|newcmd
op_assign
id|cp-&gt;patch
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;phys.header.savep
op_eq
id|vtophys
(paren
id|newcmd
)paren
)paren
id|newcmd
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t;**&t;fillin the commands&n;&t;*/
id|newcmd
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|cmd
op_amp
l_int|0x0f
)paren
op_lshift
l_int|24
)paren
op_or
id|rest
suffix:semicolon
id|newcmd
(braket
l_int|1
)braket
op_assign
id|oadr
op_plus
id|olen
op_minus
id|rest
suffix:semicolon
id|newcmd
(braket
l_int|2
)braket
op_assign
id|SCR_JUMP
suffix:semicolon
id|newcmd
(braket
l_int|3
)braket
op_assign
id|nxtdsp
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;newcmd[%d] %x %x %x %x.&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|newcmd
op_minus
id|cp-&gt;patch
)paren
comma
(paren
r_int
)paren
id|newcmd
(braket
l_int|0
)braket
comma
(paren
r_int
)paren
id|newcmd
(braket
l_int|1
)braket
comma
(paren
r_int
)paren
id|newcmd
(braket
l_int|2
)braket
comma
(paren
r_int
)paren
id|newcmd
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;fake the return address (to the patch).&n;&t;**&t;and restart script processor at dispatcher.&n;&t;*/
id|np-&gt;profile.num_break
op_increment
suffix:semicolon
id|OUTL
(paren
id|nc_temp
comma
id|vtophys
(paren
id|newcmd
)paren
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|dispatch
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      ncr chip exception handler for programmed interrupts.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_show_msg
r_static
r_int
id|ncr_show_msg
(paren
id|u_char
op_star
id|msg
)paren
(brace
id|u_char
id|i
suffix:semicolon
id|printf
(paren
l_string|&quot;%x&quot;
comma
op_star
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|msg
op_eq
id|M_EXTENDED
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_minus
l_int|1
OG
id|msg
(braket
l_int|1
)braket
)paren
r_break
suffix:semicolon
id|printf
(paren
l_string|&quot;-%x&quot;
comma
id|msg
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
id|i
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
op_star
id|msg
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
(brace
id|printf
(paren
l_string|&quot;-%x&quot;
comma
id|msg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
(paren
l_int|2
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|ncr_int_sir
r_void
id|ncr_int_sir
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|chg
comma
id|ofs
comma
id|per
comma
id|fak
comma
id|wide
suffix:semicolon
id|u_char
id|num
op_assign
id|INB
(paren
id|nc_dsps
)paren
suffix:semicolon
id|ccb_p
id|cp
op_assign
l_int|0
suffix:semicolon
id|u_long
id|dsa
suffix:semicolon
id|u_char
id|target
op_assign
id|INB
(paren
id|nc_ctest0
)paren
op_amp
l_int|7
suffix:semicolon
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;I#%d&quot;
comma
id|num
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|num
)paren
(brace
r_case
id|SIR_SENSE_RESTART
suffix:colon
r_case
id|SIR_STALL_RESTART
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;lookup the ccb&n;&t;&t;*/
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|cp
op_assign
op_amp
id|np-&gt;ccb
suffix:semicolon
r_while
c_loop
(paren
id|cp
op_logical_and
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|phys
)paren
op_ne
id|dsa
)paren
)paren
id|cp
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
m_assert
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_goto
id|out
suffix:semicolon
m_assert
(paren
id|cp
op_eq
id|np-&gt;header.cp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_ne
id|np-&gt;header.cp
)paren
r_goto
id|out
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|num
)paren
(brace
multiline_comment|/*--------------------------------------------------------------------&n;**&n;**&t;Processing of interrupted getcc selects&n;**&n;**--------------------------------------------------------------------&n;*/
r_case
id|SIR_SENSE_RESTART
suffix:colon
multiline_comment|/*------------------------------------------&n;&t;&t;**&t;Script processor is idle.&n;&t;&t;**&t;Look for interrupted &quot;check cond&quot;&n;&t;&t;**------------------------------------------&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_RESTART
)paren
id|printf
(paren
l_string|&quot;%s: int#%d&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|num
)paren
suffix:semicolon
id|cp
op_assign
(paren
id|ccb_p
)paren
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_RESTART
)paren
id|printf
(paren
l_string|&quot; t%d&quot;
comma
id|i
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_RESTART
)paren
id|printf
(paren
l_string|&quot;+&quot;
)paren
suffix:semicolon
id|cp
op_assign
id|tp-&gt;hold_cp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_RESTART
)paren
id|printf
(paren
l_string|&quot;+&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_BUSY
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
id|S_CHECK_COND
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_RESTART
)paren
id|printf
(paren
l_string|&quot;- (remove)&quot;
)paren
suffix:semicolon
id|tp-&gt;hold_cp
op_assign
id|cp
op_assign
(paren
id|ccb_p
)paren
l_int|0
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|cp
)paren
(brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_RESTART
)paren
id|printf
(paren
l_string|&quot;+ restart job ..&bslash;n&quot;
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsa
comma
id|CCB_PHYS
(paren
id|cp
comma
id|phys
)paren
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|getcc
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;no job, resume normal processing&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_RESTART
)paren
id|printf
(paren
l_string|&quot; -- remove trap&bslash;n&quot;
)paren
suffix:semicolon
id|np-&gt;script-&gt;start0
(braket
l_int|0
)braket
op_assign
id|SCR_INT
op_xor
id|IFFALSE
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIR_SENSE_FAILED
suffix:colon
multiline_comment|/*-------------------------------------------&n;&t;&t;**&t;While trying to select for&n;&t;&t;**&t;getting the condition code,&n;&t;&t;**&t;a target reselected us.&n;&t;&t;**-------------------------------------------&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_RESTART
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;in getcc reselect by t%d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|INB
c_func
(paren
id|nc_ssid
)paren
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Mark this job&n;&t;&t;*/
id|cp-&gt;host_status
op_assign
id|HS_BUSY
suffix:semicolon
id|cp-&gt;scsi_status
op_assign
id|S_CHECK_COND
suffix:semicolon
id|np-&gt;target
(braket
id|cp-&gt;cmd-&gt;target
)braket
dot
id|hold_cp
op_assign
id|cp
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;And patch code to restart it.&n;&t;&t;*/
id|np-&gt;script-&gt;start0
(braket
l_int|0
)braket
op_assign
id|SCR_INT
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*-----------------------------------------------------------------------------&n;**&n;**&t;Was Sie schon immer ueber transfermode negotiation wissen wollten ...&n;**&n;**&t;We try to negotiate sync and wide transfer only after&n;**&t;a successfull inquire command. We look at byte 7 of the&n;**&t;inquire data to determine the capabilities of the target.&n;**&n;**&t;When we try to negotiate, we append the negotiation message&n;**&t;to the identify and (maybe) simple tag message.&n;**&t;The host status field is set to HS_NEGOTIATE to mark this&n;**&t;situation.&n;**&n;**&t;If the target doesn&squot;t answer this message immidiately&n;**&t;(as required by the standard), the SIR_NEGO_FAIL interrupt&n;**&t;will be raised eventually.&n;**&t;The handler removes the HS_NEGOTIATE status, and sets the&n;**&t;negotiated value to the default (async / nowide).&n;**&n;**&t;If we receive a matching answer immediately, we check it&n;**&t;for validity, and set the values.&n;**&n;**&t;If we receive a Reject message immediately, we assume the&n;**&t;negotiation has failed, and fall back to standard values.&n;**&n;**&t;If we receive a negotiation message while not in HS_NEGOTIATE&n;**&t;state, it&squot;s a target initiated negotiation. We prepare a&n;**&t;(hopefully) valid answer, set our parameters, and send back &n;**&t;this answer to the target.&n;**&n;**&t;If the target doesn&squot;t fetch the answer (no message out phase),&n;**&t;we assume the negotiation has failed, and fall back to default&n;**&t;settings.&n;**&n;**&t;When we set the values, we adjust them in all ccbs belonging &n;**&t;to this target, in the controller&squot;s register, and in the &quot;phys&quot;&n;**&t;field of the controller&squot;s struct ncb.&n;**&n;**&t;Possible cases:&t;&t;   hs  sir   msg_in value  send   goto&n;**&t;We try try to negotiate:&n;**&t;-&gt; target doesnt&squot;t msgin   NEG FAIL  noop   defa.  -      dispatch&n;**&t;-&gt; target rejected our msg NEG FAIL  reject defa.  -      dispatch&n;**&t;-&gt; target answered  (ok)   NEG SYNC  sdtr   set    -      clrack&n;**&t;-&gt; target answered (!ok)   NEG SYNC  sdtr   defa.  REJ---&gt;msg_bad&n;**&t;-&gt; target answered  (ok)   NEG WIDE  wdtr   set    -      clrack&n;**&t;-&gt; target answered (!ok)   NEG WIDE  wdtr   defa.  REJ---&gt;msg_bad&n;**&t;-&gt; any other msgin&t;   NEG FAIL  noop   defa.  -      dispatch&n;**&n;**&t;Target tries to negotiate:&n;**&t;-&gt; incoming message&t;   --- SYNC  sdtr   set    SDTR   -&n;**&t;-&gt; incoming message&t;   --- WIDE  wdtr   set    WDTR   -&n;**      We sent our answer:&n;**&t;-&gt; target doesn&squot;t msgout   --- PROTO ?      defa.  -      dispatch&n;**&n;**-----------------------------------------------------------------------------&n;*/
r_case
id|SIR_NEGO_FAILED
suffix:colon
multiline_comment|/*-------------------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;Negotiation failed.&n;&t;&t;**&t;Target doesn&squot;t send an answer message,&n;&t;&t;**&t;or target rejected our message.&n;&t;&t;**&n;&t;&t;**      Remove negotiation request.&n;&t;&t;**&n;&t;&t;**-------------------------------------------------------&n;&t;&t;*/
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SIR_NEGO_PROTO
suffix:colon
multiline_comment|/*-------------------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;Negotiation failed.&n;&t;&t;**&t;Target doesn&squot;t fetch the answer message.&n;&t;&t;**&n;&t;&t;**-------------------------------------------------------&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;negotiation failed sir=%x status=%x.&bslash;n&quot;
comma
id|num
comma
id|cp-&gt;nego_status
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;any error in negotiation:&n;&t;&t;**&t;fall back to default mode.&n;&t;&t;*/
r_switch
c_cond
(paren
id|cp-&gt;nego_status
)paren
(brace
r_case
id|NS_SYNC
suffix:colon
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
l_int|0xe0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_WIDE
suffix:colon
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|cp-&gt;nego_status
op_assign
l_int|0
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|dispatch
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIR_NEGO_SYNC
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;Synchronous request message received.&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;sync msgin: &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgin
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;get requested values.&n;&t;&t;*/
id|chg
op_assign
l_int|0
suffix:semicolon
id|per
op_assign
id|np-&gt;msgin
(braket
l_int|3
)braket
suffix:semicolon
id|ofs
op_assign
id|np-&gt;msgin
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_eq
l_int|0
)paren
id|per
op_assign
l_int|255
suffix:semicolon
multiline_comment|/*&n;&t;&t;**      if target sends SDTR message,&n;&t;&t;**&t;      it CAN transfer synch.&n;&t;&t;*/
r_if
c_cond
(paren
id|ofs
)paren
id|tp-&gt;inqdata
(braket
l_int|7
)braket
op_or_assign
id|INQ7_SYNC
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;check values against driver limits.&n;&t;&t;*/
r_if
c_cond
(paren
id|per
OL
id|np-&gt;ns_sync
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|per
op_assign
id|np-&gt;ns_sync
suffix:semicolon
)brace
r_if
c_cond
(paren
id|per
OL
id|tp-&gt;minsync
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|per
op_assign
id|tp-&gt;minsync
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ofs
OG
id|tp-&gt;maxoffs
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|ofs
op_assign
id|tp-&gt;maxoffs
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Check against controller limits.&n;&t;&t;*/
id|fak
op_assign
(paren
l_int|4ul
op_star
id|per
op_minus
l_int|1
)paren
op_div
id|np-&gt;ns_sync
op_minus
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_logical_and
(paren
id|fak
OG
l_int|7
)paren
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|ofs
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ofs
)paren
id|fak
op_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;sync: per=%d ofs=%d fak=%d chg=%d.&bslash;n&quot;
comma
id|per
comma
id|ofs
comma
id|fak
comma
id|chg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INB
(paren
id|HS_PRT
)paren
op_eq
id|HS_NEGOTIATE
)paren
(brace
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cp-&gt;nego_status
)paren
(brace
r_case
id|NS_SYNC
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;**      This was an answer message&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|chg
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;**&t;Answer wasn&squot;t acceptable.&n;&t;&t;&t;&t;&t;*/
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
l_int|0xe0
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;**&t;Answer is ok.&n;&t;&t;&t;&t;&t;*/
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
(paren
id|fak
op_lshift
l_int|5
)paren
op_or
id|ofs
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
r_case
id|NS_WIDE
suffix:colon
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;It was a request.&n;&t;&t;**      Check against the table of target capabilities.&n;&t;&t;**      If target not capable force M_REJECT and asynchronous.&n;&t;&t;*/
r_if
c_cond
(paren
id|np-&gt;unit
OL
id|SCSI_NCR_MAX_HOST
)paren
(brace
id|tp-&gt;inqdata
(braket
l_int|7
)braket
op_and_assign
(paren
id|target_capabilities
(braket
id|np-&gt;unit
)braket
dot
id|and_map
(braket
id|target
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tp-&gt;inqdata
(braket
l_int|7
)braket
op_amp
id|INQ7_SYNC
)paren
)paren
(brace
id|ofs
op_assign
l_int|0
suffix:semicolon
id|fak
op_assign
l_int|7
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;**&t;It was a request. Set value and&n;&t;&t;**      prepare an answer message&n;&t;&t;*/
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
(paren
id|fak
op_lshift
l_int|5
)paren
op_or
id|ofs
)paren
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|1
)braket
op_assign
l_int|3
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|2
)braket
op_assign
id|M_X_SYNC_REQ
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|3
)braket
op_assign
id|per
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|4
)braket
op_assign
id|ofs
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|NS_SYNC
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;sync msgout: &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgin
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ofs
)paren
(brace
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIR_NEGO_WIDE
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;Wide request message received.&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;wide msgin: &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgin
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;get requested values.&n;&t;&t;*/
id|chg
op_assign
l_int|0
suffix:semicolon
id|wide
op_assign
id|np-&gt;msgin
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;**      if target sends WDTR message,&n;&t;&t;**&t;      it CAN transfer wide.&n;&t;&t;*/
r_if
c_cond
(paren
id|wide
)paren
id|tp-&gt;inqdata
(braket
l_int|7
)braket
op_or_assign
id|INQ7_WIDE16
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;check values against driver limits.&n;&t;&t;*/
r_if
c_cond
(paren
id|wide
OG
id|tp-&gt;usrwide
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|wide
op_assign
id|tp-&gt;usrwide
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;wide: wide=%d chg=%d.&bslash;n&quot;
comma
id|wide
comma
id|chg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INB
(paren
id|HS_PRT
)paren
op_eq
id|HS_NEGOTIATE
)paren
(brace
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cp-&gt;nego_status
)paren
(brace
r_case
id|NS_WIDE
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;**      This was an answer message&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|chg
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;**&t;Answer wasn&squot;t acceptable.&n;&t;&t;&t;&t;&t;*/
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
l_int|0
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;**&t;Answer is ok.&n;&t;&t;&t;&t;&t;*/
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
id|wide
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
r_case
id|NS_SYNC
suffix:colon
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
l_int|0xe0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;It was a request, set value and&n;&t;&t;**      prepare an answer message&n;&t;&t;*/
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
id|wide
)paren
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|2
)braket
op_assign
id|M_X_WIDE_REQ
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|3
)braket
op_assign
id|wide
suffix:semicolon
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|NS_WIDE
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;wide msgout: &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgin
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/*--------------------------------------------------------------------&n;**&n;**&t;Processing of special messages&n;**&n;**--------------------------------------------------------------------&n;*/
r_case
id|SIR_REJECT_RECEIVED
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;We received a M_REJECT message.&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;M_REJECT received (%x:%x).&bslash;n&quot;
comma
(paren
r_int
)paren
id|np-&gt;lastmsg
comma
id|np-&gt;msgout
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIR_REJECT_SENT
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;We received an unknown message&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;M_REJECT sent for &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgin
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*--------------------------------------------------------------------&n;**&n;**&t;Processing of special messages&n;**&n;**--------------------------------------------------------------------&n;*/
r_case
id|SIR_IGN_RESIDUE
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;We received an IGNORE RESIDUE message,&n;&t;&t;**&t;which couldn&squot;t be handled by the script.&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;M_IGN_RESIDUE received, but not yet implemented.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIR_MISSING_SAVE
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;We received an DISCONNECT message,&n;&t;&t;**&t;but the datapointer wasn&squot;t saved before.&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;M_DISCONNECT received, but datapointer not saved:&bslash;n&quot;
l_string|&quot;&bslash;tdata=%x save=%x goal=%x.&bslash;n&quot;
comma
(paren
r_int
)paren
id|INL
(paren
id|nc_temp
)paren
comma
(paren
r_int
)paren
id|np-&gt;header.savep
comma
(paren
r_int
)paren
id|np-&gt;header.goalp
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*--------------------------------------------------------------------&n;**&n;**&t;Processing of a &quot;S_QUEUE_FULL&quot; status.&n;**&n;**&t;The current command has been rejected,&n;**&t;because there are too many in the command queue.&n;**&t;We have started too many commands for that target.&n;**&n;**&t;If possible, reinsert at head of queue.&n;**&t;Stall queue until there are no disconnected jobs&n;**&t;(ncr is REALLY idle). Then restart processing.&n;**&n;**&t;We should restart the current job after the controller&n;**&t;has become idle. But this is not yet implemented.&n;**&n;**--------------------------------------------------------------------&n;*/
r_case
id|SIR_STALL_QUEUE
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;Stall the start queue.&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;queue full.&bslash;n&quot;
)paren
suffix:semicolon
id|np-&gt;script-&gt;start1
(braket
l_int|0
)braket
op_assign
id|SCR_INT
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Try to disable tagged transfers.&n;&t;&t;*/
id|ncr_setmaxtags
(paren
id|np
comma
op_amp
id|np-&gt;target
(braket
id|target
)braket
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** @QUEUE@&n;&t;&t;**&n;&t;&t;**&t;Should update the launch field of the&n;&t;&t;**&t;current job to be able to restart it.&n;&t;&t;**&t;Then prepend it to the start queue.&n;&t;&t;*/
multiline_comment|/* fall through */
r_case
id|SIR_STALL_RESTART
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;Enable selecting again,&n;&t;&t;**&t;if NO disconnected jobs.&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
multiline_comment|/*&n;&t;&t;**&t;Look for a disconnected job.&n;&t;&t;*/
id|cp
op_assign
op_amp
id|np-&gt;ccb
suffix:semicolon
r_while
c_loop
(paren
id|cp
op_logical_and
id|cp-&gt;host_status
op_ne
id|HS_DISCONNECT
)paren
id|cp
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;if there is one, ...&n;&t;&t;*/
r_if
c_cond
(paren
id|cp
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;**&t;wait for reselection&n;&t;&t;&t;*/
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|reselect
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;else remove the interrupt.&n;&t;&t;*/
id|printf
(paren
l_string|&quot;%s: queue empty.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;script-&gt;start1
(braket
l_int|0
)braket
op_assign
id|SCR_INT
op_xor
id|IFFALSE
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|out
suffix:colon
id|OUTB
(paren
id|nc_dcntl
comma
(paren
id|STD
op_or
id|NOCOM
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Aquire a control block&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_get_ccb
r_static
id|ccb_p
id|ncr_get_ccb
(paren
id|ncb_p
id|np
comma
id|u_long
id|target
comma
id|u_long
id|lun
)paren
(brace
id|lcb_p
id|lp
suffix:semicolon
id|ccb_p
id|cp
op_assign
(paren
id|ccb_p
)paren
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Lun structure available ?&n;&t;*/
id|lp
op_assign
id|np-&gt;target
(braket
id|target
)braket
dot
id|lp
(braket
id|lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lp
)paren
(brace
id|cp
op_assign
id|lp-&gt;next_ccb
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Look for free CCB&n;&t;&t;*/
r_while
c_loop
(paren
id|cp
op_logical_and
id|cp-&gt;magic
)paren
id|cp
op_assign
id|cp-&gt;next_ccb
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;if nothing available, take the default.&n;&t;**&t;DANGEROUS, because this ccb is not suitable for&n;&t;**&t;reselection.&n;&t;**&t;If lp-&gt;actccbs &gt; 0 wait for a suitable ccb to be free.&n;&t;*/
r_if
c_cond
(paren
(paren
op_logical_neg
id|cp
)paren
op_logical_and
id|lp
op_logical_and
id|lp-&gt;actccbs
OG
l_int|0
)paren
r_return
(paren
(paren
id|ccb_p
)paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
id|cp
op_assign
op_amp
id|np-&gt;ccb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Wait until available.&n;&t;*/
macro_line|#if 0
r_while
c_loop
(paren
id|cp-&gt;magic
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|SCSI_NOSLEEP
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|tsleep
(paren
(paren
id|caddr_t
)paren
id|cp
comma
id|PRIBIO
op_or
id|PCATCH
comma
l_string|&quot;ncr&quot;
comma
l_int|0
)paren
)paren
r_break
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cp-&gt;magic
)paren
r_return
(paren
(paren
id|ccb_p
)paren
l_int|0
)paren
suffix:semicolon
id|cp-&gt;magic
op_assign
l_int|1
suffix:semicolon
r_return
(paren
id|cp
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Release one control block&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_free_ccb
r_void
id|ncr_free_ccb
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
multiline_comment|/*&n;&t;**    sanity&n;&t;*/
m_assert
(paren
id|cp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|cp
op_member_access_from_pointer
id|host_status
op_assign
id|HS_IDLE
suffix:semicolon
id|cp
op_member_access_from_pointer
id|magic
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|cp
op_eq
op_amp
id|np-&gt;ccb
)paren
id|wakeup
(paren
(paren
id|caddr_t
)paren
id|cp
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      Allocation of resources for Targets/Luns/Tags.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_alloc_ccb
r_static
r_void
id|ncr_alloc_ccb
(paren
id|ncb_p
id|np
comma
id|u_long
id|target
comma
id|u_long
id|lun
)paren
(brace
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
m_assert
(paren
id|np
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
op_ge
id|MAX_TARGET
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|lun
op_ge
id|MAX_LUN
)paren
r_return
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;jump_tcb.l_cmd
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;initialize it.&n;&t;&t;*/
id|tp-&gt;jump_tcb.l_cmd
op_assign
(paren
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|0x80
op_plus
id|target
)paren
)paren
)paren
suffix:semicolon
id|tp-&gt;jump_tcb.l_paddr
op_assign
id|np-&gt;jump_tcb.l_paddr
suffix:semicolon
id|tp-&gt;getscr
(braket
l_int|0
)braket
op_assign
id|SCR_COPY
(paren
l_int|1
)paren
suffix:semicolon
id|tp-&gt;getscr
(braket
l_int|1
)braket
op_assign
id|vtophys
(paren
op_amp
id|tp-&gt;sval
)paren
suffix:semicolon
id|tp-&gt;getscr
(braket
l_int|2
)braket
op_assign
id|np-&gt;paddr
op_plus
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_sxfer
)paren
suffix:semicolon
id|tp-&gt;getscr
(braket
l_int|3
)braket
op_assign
id|SCR_COPY
(paren
l_int|1
)paren
suffix:semicolon
id|tp-&gt;getscr
(braket
l_int|4
)braket
op_assign
id|vtophys
(paren
op_amp
id|tp-&gt;wval
)paren
suffix:semicolon
id|tp-&gt;getscr
(braket
l_int|5
)braket
op_assign
id|np-&gt;paddr
op_plus
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_scntl3
)paren
suffix:semicolon
m_assert
(paren
(paren
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_sxfer
)paren
op_xor
m_offsetof
(paren
r_struct
id|tcb
comma
id|sval
)paren
)paren
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
suffix:semicolon
m_assert
(paren
(paren
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_scntl3
)paren
op_xor
m_offsetof
(paren
r_struct
id|tcb
comma
id|wval
)paren
)paren
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|tp-&gt;call_lun.l_cmd
op_assign
(paren
id|SCR_CALL
)paren
suffix:semicolon
id|tp-&gt;call_lun.l_paddr
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|resel_lun
)paren
suffix:semicolon
id|tp-&gt;jump_lcb.l_cmd
op_assign
(paren
id|SCR_JUMP
)paren
suffix:semicolon
id|tp-&gt;jump_lcb.l_paddr
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
m_abort
)paren
suffix:semicolon
id|np-&gt;jump_tcb.l_paddr
op_assign
id|vtophys
(paren
op_amp
id|tp-&gt;jump_tcb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Logic unit control block&n;&t;*/
id|lp
op_assign
id|tp-&gt;lp
(braket
id|lun
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;Allocate a lcb&n;&t;&t;*/
id|lp
op_assign
(paren
id|lcb_p
)paren
id|m_alloc
(paren
r_sizeof
(paren
r_struct
id|lcb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_ALLOC
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;new lcb @%p.&bslash;n&quot;
comma
id|lp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Initialize it&n;&t;&t;*/
id|bzero
(paren
id|lp
comma
r_sizeof
(paren
op_star
id|lp
)paren
)paren
suffix:semicolon
id|lp-&gt;jump_lcb.l_cmd
op_assign
(paren
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|lun
)paren
)paren
)paren
suffix:semicolon
id|lp-&gt;jump_lcb.l_paddr
op_assign
id|tp-&gt;jump_lcb.l_paddr
suffix:semicolon
id|lp-&gt;call_tag.l_cmd
op_assign
(paren
id|SCR_CALL
)paren
suffix:semicolon
id|lp-&gt;call_tag.l_paddr
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|resel_tag
)paren
suffix:semicolon
id|lp-&gt;jump_ccb.l_cmd
op_assign
(paren
id|SCR_JUMP
)paren
suffix:semicolon
id|lp-&gt;jump_ccb.l_paddr
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|aborttag
)paren
suffix:semicolon
id|lp-&gt;actlink
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;**   Chain into LUN list&n;&t;&t;*/
id|tp-&gt;jump_lcb.l_paddr
op_assign
id|vtophys
(paren
op_amp
id|lp-&gt;jump_lcb
)paren
suffix:semicolon
id|tp-&gt;lp
(braket
id|lun
)braket
op_assign
id|lp
suffix:semicolon
macro_line|#ifndef SCSI_NCR_TAGGED_QUEUE_DISABLED
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;usetags
)paren
(brace
id|ncr_setmaxtags
(paren
id|np
comma
id|tp
comma
id|SCSI_NCR_MAX_TAGS
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n;&t;**&t;Allocate ccbs up to lp-&gt;reqccbs.&n;&t;**&n;&t;**&t;This modification will be reworked in a future release.&n;&t;*/
id|loop_alloc_ccb
suffix:colon
multiline_comment|/*&n;&t;**&t;Limit possible number of ccbs.&n;&t;**&n;&t;**&t;If tagged command queueing is enabled,&n;&t;**&t;can use more than one ccb.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;actccbs
op_ge
id|MAX_START
op_minus
l_int|2
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;actccbs
op_logical_and
(paren
id|lp-&gt;actccbs
op_ge
id|lp-&gt;reqccbs
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate a ccb&n;&t;*/
id|cp
op_assign
(paren
id|ccb_p
)paren
id|m_alloc
(paren
r_sizeof
(paren
r_struct
id|ccb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_ALLOC
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;new ccb @%p.&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Count it&n;&t;*/
id|lp-&gt;actccbs
op_increment
suffix:semicolon
id|np-&gt;actccbs
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initialize it&n;&t;*/
id|bzero
(paren
id|cp
comma
r_sizeof
(paren
op_star
id|cp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Fill in physical addresses&n;&t;*/
id|cp-&gt;p_ccb
op_assign
id|vtophys
(paren
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Chain into reselect list&n;&t;*/
id|cp-&gt;jump_ccb.l_cmd
op_assign
id|SCR_JUMP
suffix:semicolon
id|cp-&gt;jump_ccb.l_paddr
op_assign
id|lp-&gt;jump_ccb.l_paddr
suffix:semicolon
id|lp-&gt;jump_ccb.l_paddr
op_assign
id|CCB_PHYS
(paren
id|cp
comma
id|jump_ccb
)paren
suffix:semicolon
id|cp-&gt;call_tmp.l_cmd
op_assign
id|SCR_CALL
suffix:semicolon
id|cp-&gt;call_tmp.l_paddr
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|resel_tmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Chain into wakeup list&n;&t;*/
id|cp-&gt;link_ccb
op_assign
id|np-&gt;ccb.link_ccb
suffix:semicolon
id|np-&gt;ccb.link_ccb
op_assign
id|cp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Chain into CCB list&n;&t;*/
id|cp-&gt;next_ccb
op_assign
id|lp-&gt;next_ccb
suffix:semicolon
id|lp-&gt;next_ccb
op_assign
id|cp
suffix:semicolon
r_goto
id|loop_alloc_ccb
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Build Scatter Gather Block&n;**&n;**&n;**==========================================================&n;**&n;**&t;The transfer area may be scattered among&n;**&t;several non adjacent physical pages.&n;**&n;**&t;We may use MAX_SCATTER blocks.&n;**&n;**----------------------------------------------------------&n;*/
multiline_comment|/*&t;FreeBSD driver important comments&n;**&t;---------------------------------&n;**&t;We try to reduce the number of interrupts caused&n;**&t;by unexpected phase changes due to disconnects.&n;**&t;A typical harddisk may disconnect before ANY block.&n;**&t;If we wanted to avoid unexpected phase changes at all&n;**&t;we had to use a break point every 512 bytes.&n;**&t;Of course the number of scatter/gather blocks is&n;**&t;limited.&n;*/
multiline_comment|/*&n;**&t;The scatterlist passed by the linux middle-level scsi drivers&n;**&t;may contain blocks of any size (Generaly &lt; 1024 bytes blocks,&n;**&t;can be 4096 with a 4K fs).&n;*/
macro_line|#if defined(SCSI_NCR_SEGMENT_SIZE)
DECL|function|ncr_scatter
r_static
r_int
id|ncr_scatter
c_func
(paren
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|scatterlist
op_star
id|scatter
suffix:semicolon
r_struct
id|dsb
op_star
id|phys
suffix:semicolon
r_register
id|u_short
id|segment
op_assign
l_int|0
suffix:semicolon
r_register
id|u_short
id|o_segment
op_assign
l_int|0
suffix:semicolon
id|u_short
id|chunk
comma
id|chunk_min
suffix:semicolon
id|u_long
id|segaddr
suffix:semicolon
r_int
id|segsize
suffix:semicolon
r_int
id|datalen
suffix:semicolon
id|phys
op_assign
op_amp
id|cp-&gt;phys
suffix:semicolon
id|cp-&gt;data_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Compute a good value for chunk size&n;&t;**&t;If SCSI_NCR_SEGMENT_SIZE is OK, we will try to use it. &n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;use_sg
)paren
id|cp-&gt;data_len
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
r_else
(brace
id|scatter
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
r_for
c_loop
(paren
id|segment
op_assign
l_int|0
suffix:semicolon
id|segment
OL
id|cmd-&gt;use_sg
suffix:semicolon
id|segment
op_increment
)paren
id|cp-&gt;data_len
op_add_assign
id|scatter
(braket
id|segment
)braket
dot
id|length
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;data_len
)paren
(brace
id|bzero
(paren
op_amp
id|phys-&gt;data
comma
r_sizeof
(paren
id|phys-&gt;data
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|chunk_min
op_assign
id|cp-&gt;data_len
op_div
id|MAX_SCATTER
suffix:semicolon
r_for
c_loop
(paren
id|chunk
op_assign
id|SCSI_NCR_SEGMENT_SIZE
suffix:semicolon
id|chunk
OL
id|chunk_min
suffix:semicolon
id|chunk
op_add_assign
id|chunk
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If the linux scsi command is not a scatterlist,&n;&t;**&t;the computed chunk size is OK.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;use_sg
)paren
(brace
id|bzero
(paren
op_amp
id|phys-&gt;data
comma
r_sizeof
(paren
id|phys-&gt;data
)paren
)paren
suffix:semicolon
id|datalen
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|segaddr
op_assign
id|vtophys
c_func
(paren
id|cmd-&gt;request_buffer
)paren
suffix:semicolon
id|segsize
op_assign
id|chunk
suffix:semicolon
id|o_segment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_SCATTER
)paren
id|printf
c_func
(paren
l_string|&quot;ncr53c8xx: re-scattering physical=0x%x size=%d chunk=%d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|segaddr
comma
(paren
r_int
)paren
id|datalen
comma
(paren
r_int
)paren
id|chunk
)paren
suffix:semicolon
r_while
c_loop
(paren
id|datalen
op_logical_and
(paren
id|o_segment
OL
id|MAX_SCATTER
)paren
)paren
(brace
r_if
c_cond
(paren
id|segsize
OG
id|datalen
)paren
id|segsize
op_assign
id|datalen
suffix:semicolon
id|phys-&gt;data
(braket
id|o_segment
)braket
dot
id|addr
op_assign
id|segaddr
suffix:semicolon
id|phys-&gt;data
(braket
id|o_segment
)braket
dot
id|size
op_assign
id|segsize
suffix:semicolon
id|datalen
op_sub_assign
id|segsize
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_SCATTER
)paren
(brace
id|printf
(paren
l_string|&quot;ncr53c8xx:     seg #%d  addr=%lx  size=%d  (rest=%d).&bslash;n&quot;
comma
id|o_segment
comma
id|segaddr
comma
(paren
r_int
)paren
id|segsize
comma
(paren
r_int
)paren
id|datalen
)paren
suffix:semicolon
)brace
id|segaddr
op_add_assign
id|segsize
suffix:semicolon
id|o_segment
op_increment
suffix:semicolon
)brace
r_return
id|datalen
ques
c_cond
op_minus
l_int|1
suffix:colon
id|o_segment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Else, the computed chunk size is not so good&n;&t;**&t;and we have to iterate.&n;&t;**&t;Rescatter the Linux scatterlist into the data block descriptor.&n;&t;**&t;Loop if necessary, beginning with the not so good chunk size and&n;&t;**&t;doubling it if the scatter process fails.&n;&t;*/
id|scatter
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
r_for
c_loop
(paren
id|segment
op_assign
l_int|0
suffix:semicolon
id|segment
OL
id|cmd-&gt;use_sg
suffix:semicolon
id|chunk
op_add_assign
id|chunk
)paren
(brace
id|o_segment
op_assign
l_int|0
suffix:semicolon
id|bzero
(paren
op_amp
id|phys-&gt;data
comma
r_sizeof
(paren
id|phys-&gt;data
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|segment
op_assign
l_int|0
suffix:semicolon
id|segment
OL
id|cmd-&gt;use_sg
suffix:semicolon
id|segment
op_increment
)paren
(brace
id|datalen
op_assign
id|scatter
(braket
id|segment
)braket
dot
id|length
suffix:semicolon
id|segaddr
op_assign
id|vtophys
c_func
(paren
id|scatter
(braket
id|segment
)braket
dot
id|address
)paren
suffix:semicolon
id|segsize
op_assign
id|chunk
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_SCATTER
)paren
id|printf
c_func
(paren
l_string|&quot;ncr53c8xx: re-scattering physical=0x%x size=%d chunk=%d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|segaddr
comma
(paren
r_int
)paren
id|datalen
comma
(paren
r_int
)paren
id|chunk
)paren
suffix:semicolon
r_while
c_loop
(paren
id|datalen
op_logical_and
(paren
id|o_segment
OL
id|MAX_SCATTER
)paren
)paren
(brace
r_if
c_cond
(paren
id|segsize
OG
id|datalen
)paren
id|segsize
op_assign
id|datalen
suffix:semicolon
id|phys-&gt;data
(braket
id|o_segment
)braket
dot
id|addr
op_assign
id|segaddr
suffix:semicolon
id|phys-&gt;data
(braket
id|o_segment
)braket
dot
id|size
op_assign
id|segsize
suffix:semicolon
id|datalen
op_sub_assign
id|segsize
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_SCATTER
)paren
(brace
id|printf
(paren
l_string|&quot;ncr53c8xx:     seg #%d  addr=%lx  size=%d  (rest=%d).&bslash;n&quot;
comma
id|o_segment
comma
id|segaddr
comma
(paren
r_int
)paren
id|segsize
comma
(paren
r_int
)paren
id|datalen
)paren
suffix:semicolon
)brace
id|segaddr
op_add_assign
id|segsize
suffix:semicolon
id|o_segment
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|datalen
)paren
r_break
suffix:semicolon
)brace
)brace
r_return
id|segment
OL
id|cmd-&gt;use_sg
ques
c_cond
op_minus
l_int|1
suffix:colon
id|o_segment
suffix:semicolon
)brace
macro_line|#else /* !defined SCSI_NCR_SEGMENT_SIZE */
DECL|function|ncr_scatter
r_static
r_int
id|ncr_scatter
c_func
(paren
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|dsb
op_star
id|phys
op_assign
op_amp
id|cp-&gt;phys
suffix:semicolon
id|u_short
id|segment
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;data_len
op_assign
l_int|0
suffix:semicolon
id|bzero
(paren
op_amp
id|phys-&gt;data
comma
r_sizeof
(paren
id|phys-&gt;data
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;use_sg
)paren
(brace
id|phys-&gt;data
(braket
id|segment
)braket
dot
id|addr
op_assign
id|vtophys
c_func
(paren
id|cmd-&gt;request_buffer
)paren
suffix:semicolon
id|phys-&gt;data
(braket
id|segment
)braket
dot
id|size
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|cp-&gt;data_len
op_add_assign
id|phys-&gt;data
(braket
id|segment
)braket
dot
id|size
suffix:semicolon
id|segment
op_increment
suffix:semicolon
r_return
id|segment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|segment
OL
id|cmd-&gt;use_sg
op_logical_and
id|segment
OL
id|MAX_SCATTER
)paren
(brace
r_struct
id|scatterlist
op_star
id|scatter
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
id|phys-&gt;data
(braket
id|segment
)braket
dot
id|addr
op_assign
id|vtophys
c_func
(paren
id|scatter
(braket
id|segment
)braket
dot
id|address
)paren
suffix:semicolon
id|phys-&gt;data
(braket
id|segment
)braket
dot
id|size
op_assign
id|scatter
(braket
id|segment
)braket
dot
id|length
suffix:semicolon
id|cp-&gt;data_len
op_add_assign
id|phys-&gt;data
(braket
id|segment
)braket
dot
id|size
suffix:semicolon
op_increment
id|segment
suffix:semicolon
)brace
r_return
id|segment
OL
id|cmd-&gt;use_sg
ques
c_cond
op_minus
l_int|1
suffix:colon
id|segment
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_SEGMENT_SIZE */
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Test the pci bus snoop logic :-(&n;**&n;**&t;Has to be called with interrupts disabled.&n;**&n;**&n;**==========================================================&n;*/
macro_line|#ifndef NCR_IOMAPPED
DECL|function|ncr_regtest
r_static
r_int
id|ncr_regtest
(paren
r_struct
id|ncb
op_star
id|np
)paren
(brace
r_register
r_volatile
id|u_long
id|data
suffix:semicolon
multiline_comment|/*&n;&t;**&t;ncr registers may NOT be cached.&n;&t;**&t;write 0xffffffff to a read only register area,&n;&t;**&t;and try to read it back.&n;&t;*/
id|data
op_assign
l_int|0xffffffff
suffix:semicolon
id|OUTL_OFF
c_func
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_dstat
)paren
comma
id|data
)paren
suffix:semicolon
id|data
op_assign
id|INL_OFF
c_func
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_dstat
)paren
)paren
suffix:semicolon
macro_line|#if 1
r_if
c_cond
(paren
id|data
op_eq
l_int|0xffffffff
)paren
(brace
macro_line|#else
r_if
c_cond
(paren
(paren
id|data
op_amp
l_int|0xe2f0fffd
)paren
op_ne
l_int|0x02000080
)paren
(brace
macro_line|#endif
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: reg dstat-sstat2 readback %x.&bslash;n&quot;
comma
(paren
r_int
)paren
id|data
)paren
suffix:semicolon
r_return
(paren
l_int|0x10
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|ncr_snooptest
r_static
r_int
id|ncr_snooptest
(paren
r_struct
id|ncb
op_star
id|np
)paren
(brace
id|u_long
id|ncr_rd
comma
id|ncr_wr
comma
id|ncr_bk
comma
id|host_rd
comma
id|host_wr
comma
id|pc
comma
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
r_if
c_cond
(paren
id|np-&gt;use_mmio
)paren
(brace
id|err
op_or_assign
id|ncr_regtest
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
(paren
id|err
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**&t;init&n;&t;*/
id|pc
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|snooptest
)paren
suffix:semicolon
id|host_wr
op_assign
l_int|1
suffix:semicolon
id|ncr_wr
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set memory and register.&n;&t;*/
id|np-&gt;ncr_cache
op_assign
id|host_wr
suffix:semicolon
id|OUTL
(paren
id|nc_temp
comma
id|ncr_wr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Start script (exchange values)&n;&t;*/
id|OUTL
(paren
id|nc_dsp
comma
id|pc
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Wait &squot;til done (with timeout)&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NCR_SNOOP_TIMEOUT
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_istat
)paren
op_amp
(paren
id|INTF
op_or
id|SIP
op_or
id|DIP
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Save termination position.&n;&t;*/
id|pc
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Read memory and register.&n;&t;*/
id|host_rd
op_assign
id|np-&gt;ncr_cache
suffix:semicolon
id|ncr_rd
op_assign
id|INL
(paren
id|nc_scratcha
)paren
suffix:semicolon
id|ncr_bk
op_assign
id|INL
(paren
id|nc_temp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Reset ncr chip&n;&t;*/
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|DELAY
(paren
l_int|1000
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;check for timeout&n;&t;*/
r_if
c_cond
(paren
id|i
op_ge
id|NCR_SNOOP_TIMEOUT
)paren
(brace
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: timeout.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0x20
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Check termination position.&n;&t;*/
r_if
c_cond
(paren
id|pc
op_ne
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|snoopend
)paren
op_plus
l_int|8
)paren
(brace
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: script execution failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0x40
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Show results.&n;&t;*/
r_if
c_cond
(paren
id|host_wr
op_ne
id|ncr_rd
)paren
(brace
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: host wrote %d, ncr read %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|host_wr
comma
(paren
r_int
)paren
id|ncr_rd
)paren
suffix:semicolon
id|err
op_or_assign
l_int|1
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|host_rd
op_ne
id|ncr_wr
)paren
(brace
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: ncr wrote %d, host read %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|ncr_wr
comma
(paren
r_int
)paren
id|host_rd
)paren
suffix:semicolon
id|err
op_or_assign
l_int|2
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|ncr_bk
op_ne
id|ncr_wr
)paren
(brace
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: ncr wrote %d, read back %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|ncr_wr
comma
(paren
r_int
)paren
id|ncr_bk
)paren
suffix:semicolon
id|err
op_or_assign
l_int|4
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Profiling the drivers and targets performance.&n;**&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**&t;Compute the difference in milliseconds.&n;**/
macro_line|#ifdef SCSI_NCR_PROFILE
DECL|function|ncr_delta
r_static
r_int
id|ncr_delta
(paren
id|u_long
id|from
comma
id|u_long
id|to
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|from
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|to
)paren
r_return
(paren
op_minus
l_int|2
)paren
suffix:semicolon
r_return
(paren
(paren
id|to
op_minus
id|from
)paren
op_star
l_int|1000
op_div
id|HZ
)paren
suffix:semicolon
)brace
DECL|macro|PROFILE
mdefine_line|#define PROFILE  cp-&gt;phys.header.stamp
DECL|function|ncb_profile
r_static
r_void
id|ncb_profile
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
r_int
id|co
comma
id|da
comma
id|st
comma
id|en
comma
id|di
comma
id|se
comma
id|post
comma
id|work
comma
id|disc
suffix:semicolon
id|u_long
id|diff
suffix:semicolon
id|PROFILE.end
op_assign
id|jiffies
suffix:semicolon
id|st
op_assign
id|ncr_delta
(paren
id|PROFILE.start
comma
id|PROFILE.status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
OL
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* status  not reached  */
id|da
op_assign
id|ncr_delta
(paren
id|PROFILE.start
comma
id|PROFILE.data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|da
OL
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* No data transfer phase */
id|co
op_assign
id|ncr_delta
(paren
id|PROFILE.start
comma
id|PROFILE.command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|co
OL
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* command not executed */
id|en
op_assign
id|ncr_delta
(paren
id|PROFILE.start
comma
id|PROFILE.end
)paren
comma
id|di
op_assign
id|ncr_delta
(paren
id|PROFILE.start
comma
id|PROFILE.disconnect
)paren
comma
id|se
op_assign
id|ncr_delta
(paren
id|PROFILE.start
comma
id|PROFILE.select
)paren
suffix:semicolon
id|post
op_assign
id|en
op_minus
id|st
suffix:semicolon
multiline_comment|/*&n;&t;**&t;@PROFILE@  Disconnect time invalid if multiple disconnects&n;&t;*/
r_if
c_cond
(paren
id|di
op_ge
l_int|0
)paren
id|disc
op_assign
id|se
op_minus
id|di
suffix:semicolon
r_else
id|disc
op_assign
l_int|0
suffix:semicolon
id|work
op_assign
(paren
id|st
op_minus
id|co
)paren
op_minus
id|disc
suffix:semicolon
id|diff
op_assign
(paren
id|np-&gt;disc_phys
op_minus
id|np-&gt;disc_ref
)paren
op_amp
l_int|0xff
suffix:semicolon
id|np-&gt;disc_ref
op_add_assign
id|diff
suffix:semicolon
id|np-&gt;profile.num_trans
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cmd
)paren
(brace
id|np-&gt;profile.num_kbytes
op_add_assign
(paren
id|cp-&gt;cmd-&gt;request_bufflen
op_rshift
l_int|10
)paren
suffix:semicolon
id|np-&gt;profile.rest_bytes
op_add_assign
(paren
id|cp-&gt;cmd-&gt;request_bufflen
op_amp
(paren
l_int|0x400
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;profile.rest_bytes
op_ge
l_int|0x400
)paren
(brace
op_increment
id|np-&gt;profile.num_kbytes
suffix:semicolon
id|np-&gt;profile.rest_bytes
op_sub_assign
l_int|0x400
suffix:semicolon
)brace
)brace
id|np-&gt;profile.num_disc
op_add_assign
id|diff
suffix:semicolon
id|np-&gt;profile.ms_setup
op_add_assign
id|co
suffix:semicolon
id|np-&gt;profile.ms_data
op_add_assign
id|work
suffix:semicolon
id|np-&gt;profile.ms_disc
op_add_assign
id|disc
suffix:semicolon
id|np-&gt;profile.ms_post
op_add_assign
id|post
suffix:semicolon
)brace
DECL|macro|PROFILE
macro_line|#undef PROFILE
macro_line|#endif /* SCSI_NCR_PROFILE */
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Device lookup.&n;**&n;**&t;@GENSCSI@ should be integrated to scsiconf.c&n;**&n;**&n;**==========================================================&n;*/
DECL|struct|table_entry
r_struct
id|table_entry
(brace
DECL|member|manufacturer
r_char
op_star
id|manufacturer
suffix:semicolon
DECL|member|model
r_char
op_star
id|model
suffix:semicolon
DECL|member|version
r_char
op_star
id|version
suffix:semicolon
DECL|member|info
id|u_long
id|info
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|device_tab
r_static
r_struct
id|table_entry
id|device_tab
(braket
)braket
op_assign
(brace
macro_line|#ifdef NCR_GETCC_WITHMSG
(brace
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
id|QUIRK_NOMSG
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;SDT-5000&quot;
comma
l_string|&quot;3.17&quot;
comma
id|QUIRK_NOMSG
)brace
comma
(brace
l_string|&quot;WangDAT&quot;
comma
l_string|&quot;Model 2600&quot;
comma
l_string|&quot;01.7&quot;
comma
id|QUIRK_NOMSG
)brace
comma
(brace
l_string|&quot;WangDAT&quot;
comma
l_string|&quot;Model 3200&quot;
comma
l_string|&quot;02.2&quot;
comma
id|QUIRK_NOMSG
)brace
comma
(brace
l_string|&quot;WangDAT&quot;
comma
l_string|&quot;Model 1300&quot;
comma
l_string|&quot;02.4&quot;
comma
id|QUIRK_NOMSG
)brace
comma
macro_line|#endif
(brace
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_int|0
)brace
multiline_comment|/* catch all: must be last entry. */
)brace
suffix:semicolon
DECL|function|ncr_lookup
r_static
id|u_long
id|ncr_lookup
c_func
(paren
r_char
op_star
id|id
)paren
(brace
r_struct
id|table_entry
op_star
id|p
op_assign
id|device_tab
suffix:semicolon
r_char
op_star
id|d
comma
op_star
id|r
comma
id|c
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|p
op_increment
)paren
(brace
id|d
op_assign
id|id
op_plus
l_int|8
suffix:semicolon
id|r
op_assign
id|p-&gt;manufacturer
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|r
op_increment
)paren
)paren
r_if
c_cond
(paren
id|c
op_ne
op_star
id|d
op_increment
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
r_continue
suffix:semicolon
id|d
op_assign
id|id
op_plus
l_int|16
suffix:semicolon
id|r
op_assign
id|p-&gt;model
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|r
op_increment
)paren
)paren
r_if
c_cond
(paren
id|c
op_ne
op_star
id|d
op_increment
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
r_continue
suffix:semicolon
id|d
op_assign
id|id
op_plus
l_int|32
suffix:semicolon
id|r
op_assign
id|p-&gt;version
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|r
op_increment
)paren
)paren
r_if
c_cond
(paren
id|c
op_ne
op_star
id|d
op_increment
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
r_continue
suffix:semicolon
r_return
(paren
id|p-&gt;info
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Determine the ncr&squot;s clock frequency.&n;**&t;This is important for the negotiation&n;**&t;of the synchronous transfer rate.&n;**&n;**==========================================================&n;**&n;**&t;Note: we have to return the correct value.&n;**&t;THERE IS NO SAVE DEFAULT VALUE.&n;**&n;**&t;We assume that all NCR based boards are delivered&n;**&t;with a 40Mhz clock. Because we have to divide&n;**&t;by an integer value greater than 3, only clock&n;**&t;frequencies of 40Mhz (/4) or 50MHz (/5) permit&n;**&t;the FAST-SCSI rate of 10MHz.&n;**&n;**----------------------------------------------------------&n;*/
macro_line|#ifndef NCR_CLOCK
DECL|macro|NCR_CLOCK
macro_line|#&t;define NCR_CLOCK 40
macro_line|#endif /* NCR_CLOCK */
DECL|function|ncr_getclock
r_static
r_void
id|ncr_getclock
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|tbl
(braket
l_int|5
)braket
op_assign
(brace
l_int|6
comma
l_int|2
comma
l_int|3
comma
l_int|4
comma
l_int|6
)brace
suffix:semicolon
id|u_char
id|f
suffix:semicolon
id|u_char
id|ns_clock
op_assign
(paren
l_int|1000
op_div
id|NCR_CLOCK
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Compute the best value for scntl3.&n;&t;*/
id|f
op_assign
(paren
l_int|2
op_star
id|MIN_SYNC_PD
op_minus
l_int|1
)paren
op_div
id|ns_clock
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f
)paren
id|f
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|f
OG
l_int|4
)paren
id|f
op_assign
l_int|4
suffix:semicolon
id|np
op_member_access_from_pointer
id|ns_sync
op_assign
(paren
id|ns_clock
op_star
id|tbl
(braket
id|f
)braket
)paren
op_div
l_int|2
suffix:semicolon
id|np
op_member_access_from_pointer
id|rv_scntl3
op_assign
id|f
op_lshift
l_int|4
suffix:semicolon
id|f
op_assign
(paren
l_int|2
op_star
id|MIN_ASYNC_PD
op_minus
l_int|1
)paren
op_div
id|ns_clock
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f
)paren
id|f
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|f
OG
l_int|4
)paren
id|f
op_assign
l_int|4
suffix:semicolon
id|np
op_member_access_from_pointer
id|ns_async
op_assign
(paren
id|ns_clock
op_star
id|tbl
(braket
id|f
)braket
)paren
op_div
l_int|2
suffix:semicolon
id|np
op_member_access_from_pointer
id|rv_scntl3
op_or_assign
id|f
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TIMING
)paren
id|printf
(paren
l_string|&quot;%s: sclk=%d async=%d sync=%d (ns) scntl3=0x%x&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|ns_clock
comma
id|np-&gt;ns_async
comma
id|np-&gt;ns_sync
comma
id|np-&gt;rv_scntl3
)paren
suffix:semicolon
)brace
multiline_comment|/*===================== LINUX ENTRY POINTS SECTION ==========================*/
macro_line|#ifndef uchar
DECL|macro|uchar
mdefine_line|#define uchar unsigned char
macro_line|#endif
macro_line|#ifndef ushort
DECL|macro|ushort
mdefine_line|#define ushort unsigned short
macro_line|#endif
macro_line|#ifndef ulong
DECL|macro|ulong
mdefine_line|#define ulong unsigned long
macro_line|#endif
r_static
r_int
id|ncr53c8xx_pci_init
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|unit
comma
r_int
id|board
comma
r_int
id|chip
comma
id|uchar
id|bus
comma
id|uchar
id|device_fn
comma
r_int
id|options
)paren
suffix:semicolon
multiline_comment|/*&n;**   NCR53C8XX devices description table&n;*/
r_static
r_struct
(brace
DECL|member|pci_device_id
id|ushort
id|pci_device_id
suffix:semicolon
DECL|member|chip
r_int
id|chip
suffix:semicolon
DECL|member|max_revision
r_int
id|max_revision
suffix:semicolon
DECL|member|min_revision
r_int
id|min_revision
suffix:semicolon
DECL|variable|pci_chip_ids
)brace
id|pci_chip_ids
(braket
)braket
op_assign
(brace
(brace
id|PCI_DEVICE_ID_NCR_53C810
comma
l_int|810
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/*   {PCI_DEVICE_ID_NCR_53C810AP, 810, -1, -1}, */
(brace
id|PCI_DEVICE_ID_NCR_53C815
comma
l_int|815
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
(brace
id|PCI_DEVICE_ID_NCR_53C820
comma
l_int|820
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
(brace
id|PCI_DEVICE_ID_NCR_53C825
comma
l_int|825
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
(brace
id|PCI_DEVICE_ID_NCR_53C860
comma
l_int|860
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
(brace
id|PCI_DEVICE_ID_NCR_53C875
comma
l_int|875
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
)brace
suffix:semicolon
DECL|macro|NPCI_CHIP_IDS
mdefine_line|#define NPCI_CHIP_IDS (sizeof (pci_chip_ids) / sizeof(pci_chip_ids[0]))
multiline_comment|/*&n;**   Linux entry point for NCR53C8XX devices detection routine.&n;**&n;**   Called by the middle-level scsi drivers at initialization time,&n;**   or at module installation.&n;**&n;**   Read the PCI configuration and try to attach each&n;**   detected NCR board.&n;**&n;**   Returns the number of boards successfully attached.&n;*/
DECL|function|ncr53c8xx_detect
r_int
id|ncr53c8xx_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Number of boards detected */
id|uchar
id|pci_bus
comma
id|pci_device_fn
suffix:semicolon
r_int
id|pci_index
suffix:semicolon
multiline_comment|/* Device index to PCI BIOS calls */
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,0)
id|tpnt-&gt;proc_dir
op_assign
op_amp
id|proc_scsi_ncr53c8xx
suffix:semicolon
macro_line|# ifdef SCSI_NCR_PROC_INFO_SUPPORT
id|tpnt-&gt;proc_info
op_assign
id|ncr53c8xx_proc_info
suffix:semicolon
macro_line|# endif
macro_line|#endif
r_if
c_cond
(paren
id|pcibios_present
c_func
(paren
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NPCI_CHIP_IDS
suffix:semicolon
op_increment
id|i
)paren
r_for
c_loop
(paren
id|pci_index
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|pcibios_find_device
c_func
(paren
id|PCI_VENDOR_ID_NCR
comma
id|pci_chip_ids
(braket
id|i
)braket
dot
id|pci_device_id
comma
id|pci_index
comma
op_amp
id|pci_bus
comma
op_amp
id|pci_device_fn
)paren
suffix:semicolon
op_increment
id|pci_index
)paren
r_if
c_cond
(paren
op_logical_neg
id|ncr53c8xx_pci_init
c_func
(paren
id|tpnt
comma
id|count
comma
l_int|0
comma
id|pci_chip_ids
(braket
id|i
)braket
dot
id|chip
comma
id|pci_bus
comma
id|pci_device_fn
comma
multiline_comment|/* no options */
l_int|0
)paren
)paren
op_increment
id|count
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n;**   Read the PCI configuration of a found NCR board and&n;**   try yo attach it.&n;*/
DECL|function|ncr53c8xx_pci_init
r_static
r_int
id|ncr53c8xx_pci_init
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|unit
comma
r_int
id|board
comma
r_int
id|chip
comma
id|uchar
id|bus
comma
id|uchar
id|device_fn
comma
r_int
id|options
)paren
(brace
id|ushort
id|vendor_id
comma
id|device_id
comma
id|command
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,0)
id|uint
id|base
comma
id|io_port
suffix:semicolon
macro_line|#else
id|ulong
id|base
comma
id|io_port
suffix:semicolon
macro_line|#endif
id|uchar
id|irq
comma
id|revision
suffix:semicolon
r_int
id|error
comma
id|expected_chip
suffix:semicolon
r_int
id|expected_id
op_assign
op_minus
l_int|1
comma
id|max_revision
op_assign
op_minus
l_int|1
comma
id|min_revision
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : at PCI bus %d, device %d, function %d&bslash;n&quot;
comma
id|bus
comma
(paren
r_int
)paren
(paren
id|device_fn
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
comma
(paren
r_int
)paren
id|device_fn
op_amp
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibios_present
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : not initializing due to lack of PCI BIOS,&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_VENDOR_ID
comma
op_amp
id|vendor_id
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_DEVICE_ID
comma
op_amp
id|device_id
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_COMMAND
comma
op_amp
id|command
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_BASE_ADDRESS_0
comma
op_amp
id|io_port
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_BASE_ADDRESS_1
comma
op_amp
id|base
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_byte
(paren
id|bus
comma
id|device_fn
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|revision
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_byte
(paren
id|bus
comma
id|device_fn
comma
id|PCI_INTERRUPT_LINE
comma
op_amp
id|irq
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : error %s not initializing due to error reading configuration space&bslash;n&quot;
comma
id|pcibios_strerror
c_func
(paren
id|error
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vendor_id
op_ne
id|PCI_VENDOR_ID_NCR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : not initializing, 0x%04x is not NCR vendor ID&bslash;n&quot;
comma
(paren
r_int
)paren
id|vendor_id
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|command
op_amp
id|PCI_COMMAND_IO
)paren
(brace
r_if
c_cond
(paren
(paren
id|io_port
op_amp
l_int|3
)paren
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : disabling I/O mapping since base address 0 (0x%x)&bslash;n&quot;
l_string|&quot;            bits 0..1 indicate a non-IO mapping&bslash;n&quot;
comma
(paren
r_int
)paren
id|io_port
)paren
suffix:semicolon
id|io_port
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|io_port
op_and_assign
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
)brace
r_else
id|io_port
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|command
op_amp
id|PCI_COMMAND_MEMORY
)paren
(brace
r_if
c_cond
(paren
(paren
id|base
op_amp
id|PCI_BASE_ADDRESS_SPACE
)paren
op_ne
id|PCI_BASE_ADDRESS_SPACE_MEMORY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : disabling memory mapping since base address 1&bslash;n&quot;
l_string|&quot;            contains a non-memory mapping&bslash;n&quot;
)paren
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|base
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
)brace
r_else
id|base
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io_port
op_logical_and
op_logical_neg
id|base
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : not initializing, both I/O and memory mappings disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|command
op_amp
id|PCI_COMMAND_MASTER
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;ncr53c8xx : not initializing, BUS MASTERING was disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NPCI_CHIP_IDS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|device_id
op_eq
id|pci_chip_ids
(braket
id|i
)braket
dot
id|pci_device_id
)paren
(brace
id|max_revision
op_assign
id|pci_chip_ids
(braket
id|i
)braket
dot
id|max_revision
suffix:semicolon
id|min_revision
op_assign
id|pci_chip_ids
(braket
id|i
)braket
dot
id|min_revision
suffix:semicolon
id|expected_chip
op_assign
id|pci_chip_ids
(braket
id|i
)braket
dot
id|chip
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chip
op_eq
id|pci_chip_ids
(braket
id|i
)braket
dot
id|chip
)paren
id|expected_id
op_assign
id|pci_chip_ids
(braket
id|i
)braket
dot
id|pci_device_id
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chip
op_logical_and
id|device_id
op_ne
id|expected_id
)paren
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : warning : device id of 0x%04x doesn&squot;t&bslash;n&quot;
l_string|&quot;            match expected 0x%04x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|device_id
comma
(paren
r_int
r_int
)paren
id|expected_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_revision
op_ne
op_minus
l_int|1
op_logical_and
id|revision
OG
id|max_revision
)paren
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : warning : revision %d is greater than expected.&bslash;n&quot;
comma
(paren
r_int
)paren
id|revision
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|min_revision
op_ne
op_minus
l_int|1
op_logical_and
id|revision
OL
id|min_revision
)paren
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : warning : revision %d is lower than expected.&bslash;n&quot;
comma
(paren
r_int
)paren
id|revision
)paren
suffix:semicolon
r_if
c_cond
(paren
id|io_port
op_logical_and
id|check_region
(paren
id|io_port
comma
l_int|128
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : IO region 0x%x to 0x%x is in use&bslash;n&quot;
comma
(paren
r_int
)paren
id|io_port
comma
(paren
r_int
)paren
(paren
id|io_port
op_plus
l_int|127
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|ncr_attach
(paren
id|tpnt
comma
id|unit
comma
id|device_id
comma
id|revision
comma
id|chip
comma
id|base
comma
id|io_port
comma
(paren
r_int
)paren
id|irq
comma
id|bus
comma
(paren
id|uchar
)paren
id|device_fn
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;**   Linux entry point of queuecommand() function&n;*/
DECL|function|ncr53c8xx_queue_command
r_int
id|ncr53c8xx_queue_command
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
id|sts
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx_queue_command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|sts
op_assign
id|ncr_queue_command
c_func
(paren
id|cmd
comma
id|done
)paren
)paren
op_ne
id|DID_OK
)paren
(brace
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|sts
comma
l_int|0
)paren
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : command not queued - result=%d&bslash;n&quot;
comma
id|sts
)paren
suffix:semicolon
macro_line|#endif
r_return
id|sts
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : command successfully queued&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|sts
suffix:semicolon
)brace
multiline_comment|/*&n;**   Linux entry point of the interrupt handler&n;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,70)
DECL|function|ncr53c8xx_intr
r_static
r_void
id|ncr53c8xx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
macro_line|#else
r_static
r_void
id|ncr53c8xx_intr
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
macro_line|#endif
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : interrupt received&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|host
op_assign
id|first_host
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|host-&gt;hostt
op_eq
id|the_template
op_logical_and
id|host-&gt;irq
op_eq
id|irq
)paren
(brace
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,70)
macro_line|#   ifdef SCSI_NCR_SHARE_IRQ
r_if
c_cond
(paren
id|dev_id
op_eq
op_amp
id|host_data-&gt;ncb_data
)paren
id|ncr_intr
c_func
(paren
op_amp
id|host_data-&gt;ncb_data
)paren
suffix:semicolon
macro_line|#   endif
macro_line|#endif
id|ncr_intr
c_func
(paren
op_amp
id|host_data-&gt;ncb_data
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;**   Linux entry point of the timer handler&n;*/
DECL|function|ncr53c8xx_timeout
r_static
r_void
id|ncr53c8xx_timeout
c_func
(paren
r_int
r_int
id|np
)paren
(brace
id|ncr_timeout
c_func
(paren
(paren
id|ncb_p
)paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;**   Linux entry point of reset() function&n;*/
macro_line|#if&t;LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,98)
DECL|function|ncr53c8xx_reset
r_int
id|ncr53c8xx_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_int
id|reset_flags
)paren
macro_line|#else
r_int
id|ncr53c8xx_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
macro_line|#endif
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx_reset : reset call&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ncr_reset_bus
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;**   Linux entry point of abort() function&n;*/
DECL|function|ncr53c8xx_abort
r_int
id|ncr53c8xx_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx_abort : abort call&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ncr_abort_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|ncr53c8xx_release
r_int
id|ncr53c8xx_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : release&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|host
op_assign
id|first_host
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|host-&gt;hostt
op_eq
id|the_template
)paren
(brace
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|ncr_detach
c_func
(paren
op_amp
id|host_data-&gt;ncb_data
comma
id|host-&gt;irq
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;**&t;Scsi command waiting list management.&n;**&n;**&t;It may happen that we cannot insert a scsi command into the start queue,&n;**&t;in the following circumstances.&n;** &t;&t;Too few preallocated ccb(s), &n;**&t;&t;maxtags &lt; cmd_per_lun of the Linux host control block,&n;**&t;&t;etc...&n;**&t;Such scsi commands are inserted into a waiting list.&n;**&t;When a scsi command complete, we try to requeue the commands of the&n;**&t;waiting list.&n;*/
DECL|macro|next_wcmd
mdefine_line|#define next_wcmd host_scribble
DECL|function|insert_into_waiting_list
r_static
r_void
id|insert_into_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|Scsi_Cmnd
op_star
id|wcmd
suffix:semicolon
macro_line|#ifdef DEBUG_WAITING_LIST
id|printf
c_func
(paren
l_string|&quot;%s: cmd %lx inserted into waiting list&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|cmd-&gt;next_wcmd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|wcmd
op_assign
id|np-&gt;waiting_list
)paren
)paren
id|np-&gt;waiting_list
op_assign
id|cmd
suffix:semicolon
r_else
(brace
r_while
c_loop
(paren
(paren
id|wcmd-&gt;next_wcmd
)paren
op_ne
l_int|0
)paren
id|wcmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|wcmd-&gt;next_wcmd
suffix:semicolon
id|wcmd-&gt;next_wcmd
op_assign
(paren
r_char
op_star
)paren
id|cmd
suffix:semicolon
)brace
)brace
DECL|function|remove_from_waiting_list
r_static
id|Scsi_Cmnd
op_star
id|remove_from_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|Scsi_Cmnd
op_star
id|wcmd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|wcmd
op_assign
id|np-&gt;waiting_list
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|wcmd-&gt;next_wcmd
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_eq
(paren
id|Scsi_Cmnd
op_star
)paren
id|wcmd-&gt;next_wcmd
)paren
(brace
id|wcmd-&gt;next_wcmd
op_assign
id|cmd-&gt;next_wcmd
suffix:semicolon
id|cmd-&gt;next_wcmd
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_WAITING_LIST
id|printf
c_func
(paren
l_string|&quot;%s: cmd %lx removed from waiting list&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|cmd
)paren
suffix:semicolon
macro_line|#endif
r_return
id|cmd
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|process_waiting_list
r_static
r_void
id|process_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|sts
)paren
(brace
id|Scsi_Cmnd
op_star
id|waiting_list
comma
op_star
id|wcmd
suffix:semicolon
id|waiting_list
op_assign
id|np-&gt;waiting_list
suffix:semicolon
id|np-&gt;waiting_list
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_WAITING_LIST
r_if
c_cond
(paren
id|waiting_list
)paren
id|printf
c_func
(paren
l_string|&quot;%s: waiting_list=%lx processing sts=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|waiting_list
comma
id|sts
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
(paren
id|wcmd
op_assign
id|waiting_list
)paren
op_ne
l_int|0
)paren
(brace
id|waiting_list
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|wcmd-&gt;next_wcmd
suffix:semicolon
id|wcmd-&gt;next_wcmd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sts
op_eq
id|DID_OK
)paren
(brace
macro_line|#ifdef DEBUG_WAITING_LIST
id|printf
c_func
(paren
l_string|&quot;%s: cmd %lx trying to requeue&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|wcmd
)paren
suffix:semicolon
macro_line|#endif
id|sts
op_assign
id|ncr_queue_command
c_func
(paren
id|wcmd
comma
id|wcmd-&gt;scsi_done
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sts
op_ne
id|DID_OK
)paren
(brace
macro_line|#ifdef DEBUG_WAITING_LIST
id|printf
c_func
(paren
l_string|&quot;%s: cmd %lx done forced sts=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|wcmd
comma
id|sts
)paren
suffix:semicolon
macro_line|#endif
id|wcmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|sts
comma
l_int|0
)paren
suffix:semicolon
id|wcmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|wcmd
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|macro|next_wcmd
macro_line|#undef next_wcmd
multiline_comment|/*&n;**&t;In order to patch the SCSI script for SAVE/RESTORE DATA POINTER,&n;**&t;we need the direction of transfer.&n;**&t;Linux middle-level scsi driver does not provide this information.&n;**&t;So we have to guess it.&n;**&t;My documentation about SCSI-II standard is old. Probably some opcode&n;**&t;are missing.&n;**&t;If I do&squot;nt know the command code, I assume input transfer direction.&n;*/
DECL|function|guess_xfer_direction
r_static
r_int
id|guess_xfer_direction
c_func
(paren
r_int
id|opcode
)paren
(brace
r_int
id|d
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
l_int|0x00
suffix:colon
multiline_comment|/*&t;TEST UNIT READY&t;&t;&t;00 */
r_case
l_int|0x08
suffix:colon
multiline_comment|/*&t;READ(6)&t;&t;&t;&t;08 */
r_case
l_int|0x12
suffix:colon
multiline_comment|/*&t;INQUIRY&t;&t;&t;&t;12 */
r_case
l_int|0x4D
suffix:colon
multiline_comment|/*&t;LOG SENSE&t;&t;&t;4D */
r_case
l_int|0x5A
suffix:colon
multiline_comment|/*&t;MODE SENSE(10)&t;&t;&t;5A */
r_case
l_int|0x1A
suffix:colon
multiline_comment|/*&t;MODE SENSE(6)&t;&t;&t;1A */
r_case
l_int|0x28
suffix:colon
multiline_comment|/*&t;READ(10)&t;&t;&t;28 */
r_case
l_int|0xA8
suffix:colon
multiline_comment|/*&t;READ(12)&t;&t;&t;A8 */
r_case
l_int|0x3C
suffix:colon
multiline_comment|/*&t;READ BUFFER&t;&t;&t;3C */
r_case
l_int|0x1C
suffix:colon
multiline_comment|/*&t;RECEIVE DIAGNOSTIC RESULTS&t;1C */
r_case
l_int|0xB7
suffix:colon
multiline_comment|/*&t;READ DEFECT DATA(12)&t;&t;B7 */
r_case
l_int|0xB8
suffix:colon
multiline_comment|/*&t;READ ELEMENT STATUS&t;&t;B8 */
multiline_comment|/*&t;GET WINDOW&t;&t;&t;25 */
r_case
l_int|0x25
suffix:colon
multiline_comment|/*&t;READ CAPACITY&t;&t;&t;25 */
r_case
l_int|0x29
suffix:colon
multiline_comment|/*&t;READ GENERATION&t;&t;&t;29 */
r_case
l_int|0x3E
suffix:colon
multiline_comment|/*&t;READ LONG&t;&t;&t;3E */
multiline_comment|/*&t;GET DATA BUFFER STATUS&t;&t;34 */
multiline_comment|/*&t;PRE-FETCH&t;&t;&t;34 */
r_case
l_int|0x34
suffix:colon
multiline_comment|/*&t;READ POSITION&t;&t;&t;34 */
r_case
l_int|0x03
suffix:colon
multiline_comment|/*&t;REQUEST SENSE&t;&t;&t;03 */
r_case
l_int|0x05
suffix:colon
multiline_comment|/*&t;READ BLOCK LIMITS&t;&t;05 */
r_case
l_int|0x0F
suffix:colon
multiline_comment|/*&t;READ REVERSE&t;&t;&t;0F */
r_case
l_int|0x14
suffix:colon
multiline_comment|/*&t;RECOVER BUFFERED DATA&t;&t;14 */
r_case
l_int|0x2D
suffix:colon
multiline_comment|/*&t;READ UPDATED BLOCK&t;&t;2D */
r_case
l_int|0x37
suffix:colon
multiline_comment|/*&t;READ DEFECT DATA(10)&t;&t;37 */
r_case
l_int|0x42
suffix:colon
multiline_comment|/*&t;READ SUB-CHANNEL&t;&t;42 */
r_case
l_int|0x43
suffix:colon
multiline_comment|/*&t;READ TOC&t;&t;&t;43 */
r_case
l_int|0x44
suffix:colon
multiline_comment|/*&t;READ HEADER&t;&t;&t;44 */
r_case
l_int|0xC7
suffix:colon
multiline_comment|/*  ???                  ???        C7 */
id|d
op_assign
id|XferIn
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x39
suffix:colon
multiline_comment|/*&t;COMPARE&t;&t;&t;&t;39 */
r_case
l_int|0x3A
suffix:colon
multiline_comment|/*&t;COPY AND VERIFY&t;&t;&t;3A */
multiline_comment|/*&t;PRINT&t;&t;&t;&t;0A */
multiline_comment|/*&t;SEND MESSAGE(6)&t;&t;&t;0A */
r_case
l_int|0x0A
suffix:colon
multiline_comment|/*&t;WRITE(6)&t;&t;&t;0A */
r_case
l_int|0x18
suffix:colon
multiline_comment|/*&t;COPY&t;&t;&t;&t;18 */
r_case
l_int|0x4C
suffix:colon
multiline_comment|/*&t;LOG SELECT&t;&t;&t;4C */
r_case
l_int|0x55
suffix:colon
multiline_comment|/*&t;MODE SELECT(10)&t;&t;&t;55 */
r_case
l_int|0x3B
suffix:colon
multiline_comment|/*&t;WRITE BUFFER&t;&t;&t;3B */
r_case
l_int|0x1D
suffix:colon
multiline_comment|/*&t;SEND DIAGNOSTIC&t;&t;&t;1D */
r_case
l_int|0x40
suffix:colon
multiline_comment|/*&t;CHANGE DEFINITION&t;&t;40 */
multiline_comment|/*&t;SEND MESSAGE(12)&t;&t;AA */
r_case
l_int|0xAA
suffix:colon
multiline_comment|/*&t;WRITE(12)&t;&t;&t;AA */
r_case
l_int|0xB6
suffix:colon
multiline_comment|/*&t;SEND VOLUME TAG&t;&t;&t;B6 */
r_case
l_int|0x3F
suffix:colon
multiline_comment|/*&t;WRITE LONG&t;&t;&t;3F */
r_case
l_int|0x04
suffix:colon
multiline_comment|/*&t;FORMAT UNIT&t;&t;&t;04 */
multiline_comment|/*&t;INITIALIZE ELEMENT STATUS&t;07 */
r_case
l_int|0x07
suffix:colon
multiline_comment|/*&t;REASSIGN BLOCKS&t;&t;&t;07 */
r_case
l_int|0x15
suffix:colon
multiline_comment|/*&t;MODE SELECT(6)&t;&t;&t;15 */
r_case
l_int|0x24
suffix:colon
multiline_comment|/*&t;SET WINDOW&t;&t;&t;24 */
r_case
l_int|0x2A
suffix:colon
multiline_comment|/*&t;WRITE(10)&t;&t;&t;2A */
r_case
l_int|0x2E
suffix:colon
multiline_comment|/*&t;WRITE AND VERIFY(10)&t;&t;2E */
r_case
l_int|0xAE
suffix:colon
multiline_comment|/*&t;WRITE AND VERIFY(12)&t;&t;AE */
r_case
l_int|0xB0
suffix:colon
multiline_comment|/*&t;SEARCH DATA HIGH(12)&t;&t;B0 */
r_case
l_int|0xB1
suffix:colon
multiline_comment|/*&t;SEARCH DATA EQUAL(12)&t;&t;B1 */
r_case
l_int|0xB2
suffix:colon
multiline_comment|/*&t;SEARCH DATA LOW(12)&t;&t;B2 */
multiline_comment|/*&t;OBJECT POSITION&t;&t;&t;31 */
r_case
l_int|0x30
suffix:colon
multiline_comment|/*&t;SEARCH DATA HIGH(10)&t;&t;30 */
r_case
l_int|0x31
suffix:colon
multiline_comment|/*&t;SEARCH DATA EQUAL(10)&t;&t;31 */
r_case
l_int|0x32
suffix:colon
multiline_comment|/*&t;SEARCH DATA LOW(10)&t;&t;32 */
r_case
l_int|0x38
suffix:colon
multiline_comment|/*&t;MEDIUM SCAN&t;&t;&t;38 */
r_case
l_int|0x3D
suffix:colon
multiline_comment|/*&t;UPDATE BLOCK&t;&t;&t;3D */
r_case
l_int|0x41
suffix:colon
multiline_comment|/*&t;WRITE SAME&t;&t;&t;41 */
multiline_comment|/*&t;LOAD UNLOAD&t;&t;&t;1B */
multiline_comment|/*&t;SCAN&t;&t;&t;&t;1B */
r_case
l_int|0x1B
suffix:colon
multiline_comment|/*&t;START STOP UNIT&t;&t;&t;1B */
id|d
op_assign
id|XferOut
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
multiline_comment|/*&t;REZERO UNIT&t;&t;&t;01 */
multiline_comment|/*&t;SEEK(6)&t;&t;&t;&t;0B */
r_case
l_int|0x0B
suffix:colon
multiline_comment|/*&t;SLEW AND PRINT&t;&t;&t;0B */
multiline_comment|/*&t;SYNCHRONIZE BUFFER&t;&t;10 */
r_case
l_int|0x10
suffix:colon
multiline_comment|/*&t;WRITE FILEMARKS&t;&t;&t;10 */
r_case
l_int|0x11
suffix:colon
multiline_comment|/*&t;SPACE&t;&t;&t;&t;11 */
r_case
l_int|0x13
suffix:colon
multiline_comment|/*&t;VERIFY&t;&t;&t;&t;13 */
r_case
l_int|0x16
suffix:colon
multiline_comment|/*&t;RESERVE UNIT&t;&t;&t;16 */
r_case
l_int|0x17
suffix:colon
multiline_comment|/*&t;RELEASE UNIT&t;&t;&t;17 */
r_case
l_int|0x19
suffix:colon
multiline_comment|/*&t;ERASE&t;&t;&t;&t;19 */
multiline_comment|/*&t;LOCATE&t;&t;&t;&t;2B */
multiline_comment|/*&t;POSITION TO ELEMENT&t;&t;2B */
r_case
l_int|0x2B
suffix:colon
multiline_comment|/*&t;SEEK(10)&t;&t;&t;2B */
r_case
l_int|0x1E
suffix:colon
multiline_comment|/*&t;PREVENT ALLOW MEDIUM REMOVAL&t;1E */
r_case
l_int|0x2C
suffix:colon
multiline_comment|/*&t;ERASE(10)&t;&t;&t;2C */
r_case
l_int|0xAC
suffix:colon
multiline_comment|/*&t;ERASE(12)&t;&t;&t;AC */
r_case
l_int|0x2F
suffix:colon
multiline_comment|/*&t;VERIFY(10)&t;&t;&t;2F */
r_case
l_int|0xAF
suffix:colon
multiline_comment|/*&t;VERIFY(12)&t;&t;&t;AF */
r_case
l_int|0x33
suffix:colon
multiline_comment|/*&t;SET LIMITS(10)&t;&t;&t;33 */
r_case
l_int|0xB3
suffix:colon
multiline_comment|/*&t;SET LIMITS(12)&t;&t;&t;B3 */
r_case
l_int|0x35
suffix:colon
multiline_comment|/*&t;SYNCHRONIZE CACHE&t;&t;35 */
r_case
l_int|0x36
suffix:colon
multiline_comment|/*&t;LOCK UNLOCK CACHE&t;&t;36 */
r_case
l_int|0x45
suffix:colon
multiline_comment|/*&t;PLAY AUDIO(10)&t;&t;&t;45 */
r_case
l_int|0x47
suffix:colon
multiline_comment|/*&t;PLAY AUDIO MSF&t;&t;&t;47 */
r_case
l_int|0x48
suffix:colon
multiline_comment|/*&t;PLAY AUDIO TRACK/INDEX&t;&t;48 */
r_case
l_int|0x49
suffix:colon
multiline_comment|/*&t;PLAY TRACK RELATIVE(10)&t;&t;49 */
r_case
l_int|0xA9
suffix:colon
multiline_comment|/*&t;PLAY TRACK RELATIVE(12)&t;&t;A9 */
r_case
l_int|0x4B
suffix:colon
multiline_comment|/*&t;PAUSE/RESUME&t;&t;&t;4B */
multiline_comment|/*&t;MOVE MEDIUM&t;&t;&t;A5 */
r_case
l_int|0xA5
suffix:colon
multiline_comment|/*&t;PLAY AUDIO(12)&t;&t;&t;A5 */
r_case
l_int|0xA6
suffix:colon
multiline_comment|/*&t;EXCHANGE MEDIUM&t;&t;&t;A6 */
r_case
l_int|0xB5
suffix:colon
multiline_comment|/*&t;REQUEST VOLUME ELEMENT ADDRESS&t;B5 */
id|d
op_assign
id|XferNone
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|d
op_assign
id|XferIn
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|d
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_PROC_INFO_SUPPORT
multiline_comment|/*=========================================================================&n;**&t;Proc file system stuff&n;**&n;**&t;A read operation returns profile information.&n;**&t;A write operation is a control command.&n;**&t;The string is parsed in the driver code and the command is passed &n;**&t;to the ncr_usercmd() function.&n;**=========================================================================&n;*/
DECL|macro|is_digit
mdefine_line|#define is_digit(c)&t;((c) &gt;= &squot;0&squot; &amp;&amp; (c) &lt;= &squot;9&squot;)
DECL|macro|digit_to_bin
mdefine_line|#define digit_to_bin(c)&t;((c) - &squot;0&squot;)
DECL|macro|is_space
mdefine_line|#define is_space(c)&t;((c) == &squot; &squot; || (c) == &squot;&bslash;t&squot;)
DECL|function|skip_spaces
r_static
r_int
id|skip_spaces
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
)paren
(brace
r_int
id|cnt
comma
id|c
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
id|len
suffix:semicolon
id|cnt
OG
l_int|0
op_logical_and
(paren
id|c
op_assign
op_star
id|ptr
op_increment
)paren
op_logical_and
id|is_space
c_func
(paren
id|c
)paren
suffix:semicolon
id|cnt
op_decrement
)paren
suffix:semicolon
r_return
(paren
id|len
op_minus
id|cnt
)paren
suffix:semicolon
)brace
DECL|function|get_int_arg
r_static
r_int
id|get_int_arg
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
comma
id|u_long
op_star
id|pv
)paren
(brace
r_int
id|cnt
comma
id|c
suffix:semicolon
id|u_long
id|v
suffix:semicolon
r_for
c_loop
(paren
id|v
op_assign
l_int|0
comma
id|cnt
op_assign
id|len
suffix:semicolon
id|cnt
OG
l_int|0
op_logical_and
(paren
id|c
op_assign
op_star
id|ptr
op_increment
)paren
op_logical_and
id|is_digit
c_func
(paren
id|c
)paren
suffix:semicolon
id|cnt
op_decrement
)paren
(brace
id|v
op_assign
(paren
id|v
op_star
l_int|10
)paren
op_plus
id|digit_to_bin
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pv
)paren
op_star
id|pv
op_assign
id|v
suffix:semicolon
r_return
(paren
id|len
op_minus
id|cnt
)paren
suffix:semicolon
)brace
DECL|function|is_keyword
r_static
r_int
id|is_keyword
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
comma
r_char
op_star
id|verb
)paren
(brace
r_int
id|verb_len
op_assign
id|strlen
c_func
(paren
id|verb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|strlen
c_func
(paren
id|verb
)paren
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|verb
comma
id|ptr
comma
id|verb_len
)paren
)paren
r_return
id|verb_len
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SKIP_SPACES
mdefine_line|#define SKIP_SPACES(min_spaces)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if ((arg_len = skip_spaces(ptr, len)) &lt; (min_spaces))&t;&t;&bslash;&n;&t;&t;return -EINVAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ptr += arg_len; len -= arg_len;
DECL|macro|GET_INT_ARG
mdefine_line|#define GET_INT_ARG(v)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (!(arg_len = get_int_arg(ptr, len, &amp;(v))))&t;&t;&t;&bslash;&n;&t;&t;return -EINVAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ptr += arg_len; len -= arg_len;
multiline_comment|/*&n;**&t;Parse a control command&n;*/
DECL|function|ncr_user_command
r_static
r_int
id|ncr_user_command
c_func
(paren
id|ncb_p
id|np
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_char
op_star
id|ptr
op_assign
id|buffer
suffix:semicolon
r_int
id|len
op_assign
id|length
suffix:semicolon
r_struct
id|usrcmd
op_star
id|uc
op_assign
op_amp
id|np-&gt;user
suffix:semicolon
r_int
id|arg_len
suffix:semicolon
id|u_long
id|target
suffix:semicolon
id|bzero
c_func
(paren
id|uc
comma
r_sizeof
(paren
op_star
id|uc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
op_logical_and
id|ptr
(braket
id|len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
op_decrement
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setsync&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETSYNC
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;settags&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETTAGS
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setorder&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETORDER
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setwide&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETWIDE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setdebug&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETDEBUG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setflag&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETFLAG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;clearprof&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_CLEARPROF
suffix:semicolon
r_else
id|arg_len
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printf
c_func
(paren
l_string|&quot;ncr_user_command: arg_len=%d, cmd=%ld&bslash;n&quot;
comma
id|arg_len
comma
id|uc-&gt;cmd
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|arg_len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETSYNC
suffix:colon
r_case
id|UC_SETTAGS
suffix:colon
r_case
id|UC_SETWIDE
suffix:colon
r_case
id|UC_SETFLAG
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|GET_INT_ARG
c_func
(paren
id|target
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printf
c_func
(paren
l_string|&quot;ncr_user_command: target=%ld&bslash;n&quot;
comma
id|target
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|target
OG
id|MAX_TARGET
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|uc-&gt;target
op_assign
(paren
l_int|1
op_lshift
id|target
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETSYNC
suffix:colon
r_case
id|UC_SETTAGS
suffix:colon
r_case
id|UC_SETWIDE
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|GET_INT_ARG
c_func
(paren
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printf
c_func
(paren
l_string|&quot;ncr_user_command: data=%ld&bslash;n&quot;
comma
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|UC_SETORDER
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;simple&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
id|M_SIMPLE_TAG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;ordered&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
id|M_ORDERED_TAG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;default&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
l_int|0
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETDEBUG
suffix:colon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;alloc&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_ALLOC
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;poll&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_POLL
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;queue&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_QUEUE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;result&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_RESULT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;scatter&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_SCATTER
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;script&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_SCRIPT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;tiny&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TINY
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;nego&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_NEGO
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;tags&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TAGS
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;freeze&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_FREEZE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;restart&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_RESTART
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_PROC_INFO
id|printf
c_func
(paren
l_string|&quot;ncr_user_command: data=%ld&bslash;n&quot;
comma
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|UC_SETFLAG
suffix:colon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;trace&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|UF_TRACE
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Not allow to disable tagged queue&n;&t;*/
r_if
c_cond
(paren
id|uc-&gt;cmd
op_eq
id|UC_SETTAGS
op_logical_and
id|uc-&gt;data
OL
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#ifdef SCSI_NCR_USER_COMMAND
r_else
(brace
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ncr_usercmd
(paren
id|np
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|length
suffix:semicolon
)brace
DECL|struct|info_str
r_struct
id|info_str
(brace
DECL|member|buffer
r_char
op_star
id|buffer
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|pos
r_int
id|pos
suffix:semicolon
)brace
suffix:semicolon
DECL|function|copy_mem_info
r_static
r_void
id|copy_mem_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OG
id|info-&gt;length
)paren
id|len
op_assign
id|info-&gt;length
op_minus
id|info-&gt;pos
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OL
id|info-&gt;offset
)paren
(brace
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;pos
OL
id|info-&gt;offset
)paren
(brace
id|data
op_add_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|info-&gt;buffer
op_plus
id|info-&gt;pos
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
)brace
)brace
DECL|function|copy_info
r_static
r_int
id|copy_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_char
id|buf
(braket
l_int|81
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|len
op_assign
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
id|copy_mem_info
c_func
(paren
id|info
comma
id|buf
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Copy formatted profile informations into the input buffer.&n;*/
DECL|function|ncr_host_info
r_static
r_int
id|ncr_host_info
c_func
(paren
id|ncb_p
id|np
comma
r_char
op_star
id|ptr
comma
id|off_t
id|offset
comma
r_int
id|len
)paren
(brace
r_struct
id|info_str
id|info
suffix:semicolon
id|info.buffer
op_assign
id|ptr
suffix:semicolon
id|info.length
op_assign
id|len
suffix:semicolon
id|info.offset
op_assign
id|offset
suffix:semicolon
id|info.pos
op_assign
l_int|0
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;General informations:&bslash;n&quot;
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  Chip NCR53C%03d, &quot;
comma
id|np-&gt;chip
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;device id 0x%x, &quot;
comma
id|np-&gt;device_id
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;revision id 0x%x&bslash;n&quot;
comma
id|np-&gt;revision_id
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  IO port address 0x%lx, &quot;
comma
(paren
id|u_long
)paren
id|np-&gt;port
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;IRQ number %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|np-&gt;irq
)paren
suffix:semicolon
macro_line|#ifndef SCSI_NCR_IOMAPPED
r_if
c_cond
(paren
id|np-&gt;use_mmio
)paren
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  Using memory mapped IO at virtual address 0x%lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
id|np-&gt;reg_remapped
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SCSI_NCR_PROFILE
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Profiling informations:&bslash;n&quot;
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_trans&quot;
comma
id|np-&gt;profile.num_trans
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_kbytes&quot;
comma
id|np-&gt;profile.num_kbytes
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_disc&quot;
comma
id|np-&gt;profile.num_disc
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_break&quot;
comma
id|np-&gt;profile.num_break
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_int&quot;
comma
id|np-&gt;profile.num_int
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_fly&quot;
comma
id|np-&gt;profile.num_fly
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;ms_setup&quot;
comma
id|np-&gt;profile.ms_setup
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;ms_data&quot;
comma
id|np-&gt;profile.ms_data
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;ms_disc&quot;
comma
id|np-&gt;profile.ms_disc
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;ms_post&quot;
comma
id|np-&gt;profile.ms_post
)paren
suffix:semicolon
macro_line|#endif
r_return
id|info.pos
OG
id|info.offset
ques
c_cond
id|info.pos
op_minus
id|info.offset
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Entry point of the scsi proc fs of the driver.&n;**&t;- func = 0 means read  (returns profile data)&n;**&t;- func = 1 means write (parse user control command)&n;*/
DECL|function|ncr53c8xx_proc_info
r_int
id|ncr53c8xx_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|func
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
id|ncb_p
id|ncb
op_assign
l_int|0
suffix:semicolon
r_int
id|retv
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printf
c_func
(paren
l_string|&quot;ncr53c8xx_proc_info: hostno=%d, func=%d&bslash;n&quot;
comma
id|hostno
comma
id|func
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|host
op_assign
id|first_host
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|host-&gt;hostt
op_eq
id|the_template
op_logical_and
id|host-&gt;host_no
op_eq
id|hostno
)paren
(brace
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|ncb
op_assign
op_amp
id|host_data-&gt;ncb_data
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ncb
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|func
)paren
(brace
id|retv
op_assign
id|ncr_user_command
c_func
(paren
id|ncb
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printf
c_func
(paren
l_string|&quot;ncr_user_command: retv=%d&bslash;n&quot;
comma
id|retv
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
op_star
id|start
)paren
op_star
id|start
op_assign
id|buffer
suffix:semicolon
id|retv
op_assign
id|ncr_host_info
c_func
(paren
id|ncb
comma
id|buffer
comma
id|offset
comma
id|length
)paren
suffix:semicolon
)brace
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/*=========================================================================&n;**&t;End of proc file system stuff&n;**=========================================================================&n;*/
macro_line|#endif
multiline_comment|/*&n;**&t;Module stuff&n;*/
macro_line|#ifdef MODULE
DECL|variable|driver_template
id|Scsi_Host_Template
id|driver_template
op_assign
id|NCR53C8XX
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
macro_line|#endif
eof
