multiline_comment|/******************************************************************************&n;**  Device driver for the PCI-SCSI NCR538XX controller family.&n;**&n;**  Copyright (C) 1994  Wolfgang Stanglmeier&n;**&n;**  This program is free software; you can redistribute it and/or modify&n;**  it under the terms of the GNU General Public License as published by&n;**  the Free Software Foundation; either version 2 of the License, or&n;**  (at your option) any later version.&n;**&n;**  This program is distributed in the hope that it will be useful,&n;**  but WITHOUT ANY WARRANTY; without even the implied warranty of&n;**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;**  GNU General Public License for more details.&n;**&n;**  You should have received a copy of the GNU General Public License&n;**  along with this program; if not, write to the Free Software&n;**  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;**&n;**-----------------------------------------------------------------------------&n;**&n;**  This driver has been ported to Linux from the FreeBSD NCR53C8XX driver&n;**  and is currently maintained by&n;**&n;**          Gerard Roudier              &lt;groudier@club-internet.fr&gt;&n;**&n;**  Being given that this driver originates from the FreeBSD version, and&n;**  in order to keep synergy on both, any suggested enhancements and corrections&n;**  received on Linux are automatically a potential candidate for the FreeBSD &n;**  version.&n;**&n;**  The original driver has been written for 386bsd and FreeBSD by&n;**          Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;&n;**          Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;&n;**&n;**  And has been ported to NetBSD by&n;**          Charles M. Hannum           &lt;mycroft@gnu.ai.mit.edu&gt;&n;**&n;**-----------------------------------------------------------------------------&n;**&n;**                     Brief history&n;**&n;**  December 10 1995 by Gerard Roudier:&n;**     Initial port to Linux.&n;**&n;**  June 23 1996 by Gerard Roudier:&n;**     Support for 64 bits architectures (Alpha).&n;**&n;**  November 30 1996 by Gerard Roudier:&n;**     Support for Fast-20 scsi.&n;**     Support for large DMA fifo and 128 dwords bursting.&n;**&n;**  February 27 1997 by Gerard Roudier:&n;**     Support for Fast-40 scsi.&n;**     Support for on-Board RAM.&n;**&n;**  May 3 1997 by Gerard Roudier:&n;**     Full support for scsi scripts instructions pre-fetching.&n;**&n;**  May 19 1997 by Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;:&n;**     Support for NvRAM detection and reading.&n;**&n;*******************************************************************************&n;*/
multiline_comment|/*&n;**&t;26 July 1997, version 2.4&n;**&n;**&t;Supported SCSI-II features:&n;**&t;    Synchronous negotiation&n;**&t;    Wide negotiation        (depends on the NCR Chip)&n;**&t;    Enable disconnection&n;**&t;    Tagged command queuing&n;**&t;    Parity checking&n;**&t;    Etc...&n;**&n;**&t;Supported NCR chips:&n;**&t;&t;53C810&t;&t;(8 bits, Fast SCSI-2, no rom BIOS) &n;**&t;&t;53C815&t;&t;(8 bits, Fast SCSI-2, on board rom BIOS)&n;**&t;&t;53C820&t;&t;(Wide,   Fast SCSI-2, no rom BIOS)&n;**&t;&t;53C825&t;&t;(Wide,   Fast SCSI-2, on board rom BIOS)&n;**&t;&t;53C860&t;&t;(8 bits, Fast 20,     no rom BIOS)&n;**&t;&t;53C875&t;&t;(Wide,   Fast 20,     on board rom BIOS)&n;**&t;&t;53C895&t;&t;(Wide,   Fast 40,     on board rom BIOS)&n;**&n;**&t;Other features:&n;**&t;&t;Memory mapped IO (linux-1.3.X and above only)&n;**&t;&t;Module&n;**&t;&t;Shared IRQ (since linux-1.3.72)&n;*/
DECL|macro|SCSI_NCR_DEBUG_FLAGS
mdefine_line|#define SCSI_NCR_DEBUG_FLAGS&t;(0)&t;&t;
DECL|macro|NCR_GETCC_WITHMSG
mdefine_line|#define NCR_GETCC_WITHMSG
multiline_comment|/*==========================================================&n;**&n;**      Include files&n;**&n;**==========================================================&n;*/
DECL|macro|LinuxVersionCode
mdefine_line|#define LinuxVersionCode(v, p, s) (((v)&lt;&lt;16)+((p)&lt;&lt;8)+(s))
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,0)
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#else
macro_line|#include &quot;../block/blk.h&quot;
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,35)
macro_line|#include &lt;linux/init.h&gt;
macro_line|#else
macro_line|#ifndef&t;__initdata
DECL|macro|__initdata
mdefine_line|#define&t;__initdata
macro_line|#endif
macro_line|#ifndef&t;__initfunc
DECL|macro|__initfunc
mdefine_line|#define&t;__initfunc(__arginit) __arginit
macro_line|#endif
macro_line|#endif
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &lt;linux/types.h&gt;
multiline_comment|/*&n;**&t;Define the BSD style u_int32 type&n;*/
DECL|typedef|u_int32
r_typedef
id|u32
id|u_int32
suffix:semicolon
macro_line|#include &quot;ncr53c8xx.h&quot;
multiline_comment|/*==========================================================&n;**&n;**&t;Configuration and Debugging&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**    SCSI address of this device.&n;**    The boot routines should have set it.&n;**    If not, use this.&n;*/
macro_line|#ifndef SCSI_NCR_MYADDR
DECL|macro|SCSI_NCR_MYADDR
mdefine_line|#define SCSI_NCR_MYADDR      (7)
macro_line|#endif
multiline_comment|/*&n;**    The maximum number of tags per logic unit.&n;**    Used only for disk devices that support tags.&n;*/
macro_line|#ifndef SCSI_NCR_MAX_TAGS
DECL|macro|SCSI_NCR_MAX_TAGS
mdefine_line|#define SCSI_NCR_MAX_TAGS    (4)
macro_line|#endif
multiline_comment|/*&n;**    Number of targets supported by the driver.&n;**    n permits target numbers 0..n-1.&n;**    Default is 7, meaning targets #0..#6.&n;**    #7 .. is myself.&n;*/
macro_line|#ifdef SCSI_NCR_MAX_TARGET
DECL|macro|MAX_TARGET
mdefine_line|#define MAX_TARGET  (SCSI_NCR_MAX_TARGET)
macro_line|#else
DECL|macro|MAX_TARGET
mdefine_line|#define MAX_TARGET  (16)
macro_line|#endif
multiline_comment|/*&n;**    Number of logic units supported by the driver.&n;**    n enables logic unit numbers 0..n-1.&n;**    The common SCSI devices require only&n;**    one lun, so take 1 as the default.&n;*/
macro_line|#ifdef SCSI_NCR_MAX_LUN
DECL|macro|MAX_LUN
mdefine_line|#define MAX_LUN    SCSI_NCR_MAX_LUN
macro_line|#else
DECL|macro|MAX_LUN
mdefine_line|#define MAX_LUN    (1)
macro_line|#endif
multiline_comment|/*&n;**    Asynchronous pre-scaler (ns). Shall be 40&n;*/
macro_line|#ifndef SCSI_NCR_MIN_ASYNC
DECL|macro|SCSI_NCR_MIN_ASYNC
mdefine_line|#define SCSI_NCR_MIN_ASYNC (40)
macro_line|#endif
multiline_comment|/*&n;**    The maximum number of jobs scheduled for starting.&n;**    There should be one slot per target, and one slot&n;**    for each tag of each target in use.&n;**    The calculation below is actually quite silly ...&n;*/
macro_line|#ifdef SCSI_NCR_CAN_QUEUE
DECL|macro|MAX_START
mdefine_line|#define MAX_START   (SCSI_NCR_CAN_QUEUE + 4)
macro_line|#else
DECL|macro|MAX_START
mdefine_line|#define MAX_START   (MAX_TARGET + 7 * SCSI_NCR_MAX_TAGS)
macro_line|#endif
multiline_comment|/*&n;**    The maximum number of segments a transfer is split into.&n;*/
DECL|macro|MAX_SCATTER
mdefine_line|#define MAX_SCATTER (SCSI_NCR_MAX_SCATTER)
multiline_comment|/*&n;**    Io mapped or memory mapped.&n;*/
macro_line|#if defined(SCSI_NCR_IOMAPPED)
DECL|macro|NCR_IOMAPPED
mdefine_line|#define NCR_IOMAPPED
macro_line|#endif
multiline_comment|/*&n;**&t;other&n;*/
DECL|macro|NCR_SNOOP_TIMEOUT
mdefine_line|#define NCR_SNOOP_TIMEOUT (1000000)
multiline_comment|/*==========================================================&n;**&n;**&t;Defines for Linux.&n;**&n;**&t;Linux and Bsd kernel functions are quite different.&n;**&t;These defines allow a minimum change of the original&n;**&t;code.&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n; **&t;Obvious definitions&n; */
DECL|macro|printf
mdefine_line|#define printf&t;&t;printk
DECL|macro|u_char
mdefine_line|#define u_char&t;&t;unsigned char
DECL|macro|u_short
mdefine_line|#define u_short&t;&t;unsigned short
DECL|macro|u_int
mdefine_line|#define u_int&t;&t;unsigned int
DECL|macro|u_long
mdefine_line|#define u_long&t;&t;unsigned long
DECL|typedef|vm_offset_t
r_typedef
id|u_long
id|vm_offset_t
suffix:semicolon
DECL|typedef|vm_size_t
r_typedef
r_int
id|vm_size_t
suffix:semicolon
DECL|macro|bcopy
mdefine_line|#define bcopy(s, d, n)&t;memcpy((d), (s), (n))
DECL|macro|bzero
mdefine_line|#define bzero(d, n)&t;memset((d), 0, (n))
macro_line|#ifndef offsetof
DECL|macro|offsetof
mdefine_line|#define offsetof(t, m)&t;((size_t) (&amp;((t *)0)-&gt;m))
macro_line|#endif
multiline_comment|/*&n;**&t;Address translation&n;**&n;**&t;On Linux 1.3.X, virt_to_bus() must be used to translate&n;**&t;virtual memory addresses of the kernel data segment into&n;**&t;IO bus adresses.&n;**&t;On i386 architecture, IO bus addresses match the physical&n;**&t;addresses. But on other architectures they can be different.&n;**&t;In the original Bsd driver, vtophys() is called to translate&n;**&t;data addresses to IO bus addresses. In order to minimize&n;**&t;change, I decide to define vtophys() as virt_to_bus().&n;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,0)
DECL|macro|vtophys
mdefine_line|#define vtophys(p)&t;virt_to_bus(p)
multiline_comment|/*&n;**&t;Memory mapped IO&n;**&n;**&t;Since linux-2.1, we must use ioremap() to map the io memory space.&n;**&t;iounmap() to unmap it. That allows portability.&n;**&t;Linux 1.3.X and 2.0.X allow to remap physical pages addresses greater &n;**&t;than the highest physical memory address to kernel virtual pages with &n;**&t;vremap() / vfree(). That was not portable but worked with i386 &n;**&t;architecture.&n;*/
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
id|vm_offset_t
id|remap_pci_mem
c_func
(paren
id|u_long
id|base
comma
id|u_long
id|size
)paren
)paren
(brace
id|u_long
id|page_base
op_assign
(paren
(paren
id|u_long
)paren
id|base
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|u_long
id|page_offs
op_assign
(paren
(paren
id|u_long
)paren
id|base
)paren
op_minus
id|page_base
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,0)
id|u_long
id|page_remapped
op_assign
(paren
id|u_long
)paren
id|ioremap
c_func
(paren
id|page_base
comma
id|page_offs
op_plus
id|size
)paren
suffix:semicolon
macro_line|#else
id|u_long
id|page_remapped
op_assign
(paren
id|u_long
)paren
id|vremap
c_func
(paren
id|page_base
comma
id|page_offs
op_plus
id|size
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|vm_offset_t
)paren
(paren
id|page_remapped
ques
c_cond
(paren
id|page_remapped
op_plus
id|page_offs
)paren
suffix:colon
l_int|0UL
)paren
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|unmap_pci_mem
c_func
(paren
id|vm_offset_t
id|vaddr
comma
id|u_long
id|size
)paren
)paren
(brace
r_if
c_cond
(paren
id|vaddr
)paren
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,0)
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|vaddr
op_amp
id|PAGE_MASK
)paren
)paren
suffix:semicolon
macro_line|#else
id|vfree
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|vaddr
op_amp
id|PAGE_MASK
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#else /* linux-1.2.13 */
multiline_comment|/*&n;**&t;Linux 1.2.X assumes that addresses (virtual, physical, bus)&n;**&t;are the same.&n;**&n;**&t;I have not found how to do MMIO. It seems that only processes can&n;**&t;map high physical pages to virtual (Xservers can do MMIO).&n;*/
DECL|macro|vtophys
mdefine_line|#define vtophys(p)&t;((u_long) (p))
macro_line|#endif
multiline_comment|/*&n;**&t;Insert a delay in micro-seconds.&n;*/
DECL|function|DELAY
r_static
r_void
id|DELAY
c_func
(paren
r_int
id|us
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|us
OG
l_int|1000
suffix:semicolon
id|us
op_sub_assign
l_int|1000
)paren
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|us
)paren
id|udelay
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Internal data structure allocation.&n;**&n;**&t;Linux scsi memory poor pool is adjusted for the need of&n;**&t;middle-level scsi driver.&n;**&t;We allocate our control blocks in the kernel memory pool&n;**&t;to avoid scsi pool shortage.&n;**&t;I notice that kmalloc() returns NULL during host attach under&n;**&t;Linux 1.2.13. But this ncr driver is reliable enough to&n;**&t;accomodate with this joke.&n;**&n;**&t;kmalloc() only ensure 8 bytes boundary alignment.&n;**&t;The NCR need better alignment for cache line bursting.&n;**&t;The global header is moved betewen the NCB and CCBs and need &n;**&t;origin and destination addresses to have same lower four bits.&n;**&n;**&t;We use 32 boundary alignment for NCB and CCBs and offset multiple &n;**&t;of 32 for global header fields. That&squot;s too much but at least enough.&n;*/
DECL|macro|ALIGN_SIZE
mdefine_line|#define ALIGN_SIZE(shift)&t;(1UL &lt;&lt; shift)
DECL|macro|ALIGN_MASK
mdefine_line|#define ALIGN_MASK(shift)&t;(~(ALIGN_SIZE(shift)-1))
DECL|macro|NCB_ALIGN_SHIFT
mdefine_line|#define NCB_ALIGN_SHIFT&t;&t;5
DECL|macro|CCB_ALIGN_SHIFT
mdefine_line|#define CCB_ALIGN_SHIFT&t;&t;5
DECL|macro|LCB_ALIGN_SHIFT
mdefine_line|#define LCB_ALIGN_SHIFT&t;&t;5
DECL|macro|SCR_ALIGN_SHIFT
mdefine_line|#define SCR_ALIGN_SHIFT&t;&t;5
DECL|macro|NCB_ALIGN_SIZE
mdefine_line|#define NCB_ALIGN_SIZE&t;&t;ALIGN_SIZE(NCB_ALIGN_SHIFT)
DECL|macro|NCB_ALIGN_MASK
mdefine_line|#define NCB_ALIGN_MASK&t;&t;ALIGN_MASK(NCB_ALIGN_SHIFT)
DECL|macro|CCB_ALIGN_SIZE
mdefine_line|#define CCB_ALIGN_SIZE&t;&t;ALIGN_SIZE(CCB_ALIGN_SHIFT)
DECL|macro|CCB_ALIGN_MASK
mdefine_line|#define CCB_ALIGN_MASK&t;&t;ALIGN_MASK(CCB_ALIGN_SHIFT)
DECL|macro|SCR_ALIGN_SIZE
mdefine_line|#define SCR_ALIGN_SIZE&t;&t;ALIGN_SIZE(SCR_ALIGN_SHIFT)
DECL|macro|SCR_ALIGN_MASK
mdefine_line|#define SCR_ALIGN_MASK&t;&t;ALIGN_MASK(SCR_ALIGN_SHIFT)
DECL|function|m_alloc
r_static
r_void
op_star
id|m_alloc
c_func
(paren
r_int
id|size
comma
r_int
id|a_shift
)paren
(brace
id|u_long
id|addr
suffix:semicolon
r_void
op_star
id|ptr
suffix:semicolon
id|u_long
id|a_size
comma
id|a_mask
suffix:semicolon
r_if
c_cond
(paren
id|a_shift
OL
l_int|3
)paren
id|a_shift
op_assign
l_int|3
suffix:semicolon
id|a_size
op_assign
id|ALIGN_SIZE
c_func
(paren
id|a_shift
)paren
suffix:semicolon
id|a_mask
op_assign
id|ALIGN_MASK
c_func
(paren
id|a_shift
)paren
suffix:semicolon
id|ptr
op_assign
(paren
r_void
op_star
)paren
id|kmalloc
c_func
(paren
id|size
op_plus
id|a_size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
(brace
id|addr
op_assign
(paren
(paren
(paren
id|u_long
)paren
id|ptr
)paren
op_plus
id|a_size
)paren
op_amp
id|a_mask
suffix:semicolon
op_star
(paren
(paren
r_void
op_star
op_star
)paren
(paren
id|addr
op_minus
r_sizeof
(paren
r_void
op_star
)paren
)paren
)paren
op_assign
id|ptr
suffix:semicolon
id|ptr
op_assign
(paren
r_void
op_star
)paren
id|addr
suffix:semicolon
)brace
r_return
id|ptr
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|m_free
r_static
r_void
id|m_free
c_func
(paren
r_void
op_star
id|ptr
comma
r_int
id|size
)paren
(brace
id|u_long
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
(brace
id|addr
op_assign
(paren
id|u_long
)paren
id|ptr
suffix:semicolon
id|ptr
op_assign
op_star
(paren
(paren
r_void
op_star
op_star
)paren
(paren
id|addr
op_minus
r_sizeof
(paren
r_void
op_star
)paren
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;**&t;Transfer direction&n;**&n;**&t;Low-level scsi drivers under Linux do not receive the expected &n;**&t;data transfer direction from upper scsi drivers.&n;**&t;The driver will only check actual data direction for common &n;**&t;scsi opcodes. Other ones may cause problem, since they may &n;**&t;depend on device type or be vendor specific.&n;**&t;I would prefer to never trust the device for data direction, &n;**&t;but that is not possible.&n;**&n;**&t;The original driver requires the expected direction to be known.&n;**&t;The Linux version of the driver has been enhanced in order to &n;**&t;be able to transfer data in the direction choosen by the target. &n;*/
DECL|macro|XferNone
mdefine_line|#define XferNone&t;0
DECL|macro|XferIn
mdefine_line|#define XferIn&t;&t;1
DECL|macro|XferOut
mdefine_line|#define XferOut&t;&t;2
DECL|macro|XferBoth
mdefine_line|#define XferBoth&t;3
r_static
r_int
id|guess_xfer_direction
c_func
(paren
r_int
id|opcode
)paren
suffix:semicolon
multiline_comment|/*&n;**&t;Head of list of NCR boards&n;**&n;**&t;Host is retrieved by its irq level.&n;**&t;If interrupts are shared, the internal host control block &n;**&t;address (struct ncb) is used as device id.&n;*/
DECL|variable|first_host
r_static
r_struct
id|Scsi_Host
op_star
id|first_host
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|the_template
r_static
id|Scsi_Host_Template
op_star
id|the_template
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;**&t;/proc directory entry and proc_info function&n;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,0)
DECL|variable|proc_scsi_ncr53c8xx
r_struct
id|proc_dir_entry
id|proc_scsi_ncr53c8xx
op_assign
(brace
id|PROC_SCSI_NCR53C8XX
comma
l_int|9
comma
l_string|&quot;ncr53c8xx&quot;
comma
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
l_int|2
)brace
suffix:semicolon
macro_line|# ifdef SCSI_NCR_PROC_INFO_SUPPORT
r_int
id|ncr53c8xx_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|func
)paren
suffix:semicolon
macro_line|# endif
macro_line|#endif
multiline_comment|/*&n;**&t;Table of target capabilities.&n;**&n;**&t;This bitmap is anded with the byte 7 of inquiry data on completion of&n;**&t;INQUIRY command.&n;** &t;The driver never see zeroed bits and will ignore the corresponding&n;**&t;capabilities of the target.&n;*/
r_static
r_struct
(brace
DECL|member|and_map
r_int
r_char
id|and_map
(braket
id|MAX_TARGET
)braket
suffix:semicolon
DECL|variable|target_capabilities
)brace
id|target_capabilities
(braket
id|SCSI_NCR_MAX_HOST
)braket
op_assign
(brace
id|NCR53C8XX_TARGET_CAPABILITIES
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;Driver setup.&n;**&n;**&t;This structure is initialized from linux config options.&n;**&t;It can be overridden at boot-up by the boot command line.&n;*/
DECL|struct|ncr_driver_setup
r_struct
id|ncr_driver_setup
(brace
DECL|member|master_parity
r_int
id|master_parity
suffix:colon
l_int|1
suffix:semicolon
DECL|member|scsi_parity
r_int
id|scsi_parity
suffix:colon
l_int|1
suffix:semicolon
DECL|member|disconnection
r_int
id|disconnection
suffix:colon
l_int|1
suffix:semicolon
DECL|member|special_features
r_int
id|special_features
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ultra_scsi
r_int
id|ultra_scsi
suffix:colon
l_int|2
suffix:semicolon
DECL|member|force_sync_nego
r_int
id|force_sync_nego
suffix:colon
l_int|1
suffix:semicolon
DECL|member|reverse_probe
r_int
id|reverse_probe
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pci_fix_up
r_int
id|pci_fix_up
suffix:colon
l_int|4
suffix:semicolon
DECL|member|use_nvram
id|u_char
id|use_nvram
suffix:semicolon
DECL|member|verbose
id|u_char
id|verbose
suffix:semicolon
DECL|member|default_tags
id|u_char
id|default_tags
suffix:semicolon
DECL|member|default_sync
id|u_short
id|default_sync
suffix:semicolon
DECL|member|debug
id|u_short
id|debug
suffix:semicolon
DECL|member|burst_max
id|u_char
id|burst_max
suffix:semicolon
DECL|member|led_pin
id|u_char
id|led_pin
suffix:semicolon
DECL|member|max_wide
id|u_char
id|max_wide
suffix:semicolon
DECL|member|settle_delay
id|u_char
id|settle_delay
suffix:semicolon
DECL|member|diff_support
id|u_char
id|diff_support
suffix:semicolon
DECL|member|irqm
id|u_char
id|irqm
suffix:semicolon
)brace
suffix:semicolon
r_static
r_struct
id|ncr_driver_setup
DECL|variable|driver_setup
id|driver_setup
op_assign
id|SCSI_NCR_DRIVER_SETUP
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT
r_static
r_struct
id|ncr_driver_setup
DECL|variable|__initdata
id|driver_safe_setup
id|__initdata
op_assign
id|SCSI_NCR_DRIVER_SAFE_SETUP
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;**&t;Other Linux definitions&n;*/
DECL|macro|ScsiResult
mdefine_line|#define ScsiResult(host_code, scsi_code) (((host_code) &lt;&lt; 16) + ((scsi_code) &amp; 0x7f))
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,0,0)
r_static
r_void
id|ncr53c8xx_select_queue_depths
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|scsi_device
op_star
id|devlist
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,70)
r_static
r_void
id|ncr53c8xx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
macro_line|#else
r_static
r_void
id|ncr53c8xx_intr
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|ncr53c8xx_timeout
c_func
(paren
r_int
r_int
id|np
)paren
suffix:semicolon
DECL|macro|initverbose
mdefine_line|#define initverbose (driver_setup.verbose)
DECL|macro|bootverbose
mdefine_line|#define bootverbose (np-&gt;verbose)
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
multiline_comment|/*&n;**&t;Symbios NvRAM data format&n;*/
DECL|macro|SYMBIOS_NVRAM_SIZE
mdefine_line|#define SYMBIOS_NVRAM_SIZE 368
DECL|macro|SYMBIOS_NVRAM_ADDRESS
mdefine_line|#define SYMBIOS_NVRAM_ADDRESS 0x100
DECL|struct|Symbios_nvram
r_struct
id|Symbios_nvram
(brace
multiline_comment|/* Header 6 bytes */
DECL|member|start_marker
id|u_short
id|start_marker
suffix:semicolon
multiline_comment|/* 0x0000 */
DECL|member|byte_count
id|u_short
id|byte_count
suffix:semicolon
multiline_comment|/* excluding header/trailer */
DECL|member|checksum
id|u_short
id|checksum
suffix:semicolon
multiline_comment|/* Controller set up 20 bytes */
DECL|member|word0
id|u_short
id|word0
suffix:semicolon
multiline_comment|/* 0x3000 */
DECL|member|word2
id|u_short
id|word2
suffix:semicolon
multiline_comment|/* 0x0000 */
DECL|member|word4
id|u_short
id|word4
suffix:semicolon
multiline_comment|/* 0x0000 */
DECL|member|flags
id|u_short
id|flags
suffix:semicolon
DECL|macro|SYMBIOS_SCAM_ENABLE
mdefine_line|#define SYMBIOS_SCAM_ENABLE&t;(1)
DECL|macro|SYMBIOS_PARITY_ENABLE
mdefine_line|#define SYMBIOS_PARITY_ENABLE&t;(1&lt;&lt;1)
DECL|macro|SYMBIOS_VERBOSE_MSGS
mdefine_line|#define SYMBIOS_VERBOSE_MSGS&t;(1&lt;&lt;2)
DECL|member|flags1
id|u_short
id|flags1
suffix:semicolon
DECL|macro|SYMBIOS_SCAN_HI_LO
mdefine_line|#define SYMBIOS_SCAN_HI_LO&t;(1)
DECL|member|word10
id|u_short
id|word10
suffix:semicolon
multiline_comment|/* 0x00 */
DECL|member|word12
id|u_short
id|word12
suffix:semicolon
multiline_comment|/* 0x00 */
DECL|member|host_id
id|u_char
id|host_id
suffix:semicolon
DECL|member|byte15
id|u_char
id|byte15
suffix:semicolon
multiline_comment|/* 0x04 */
DECL|member|word16
id|u_short
id|word16
suffix:semicolon
multiline_comment|/* 0x0410 */
DECL|member|word18
id|u_short
id|word18
suffix:semicolon
multiline_comment|/* 0x0000 */
multiline_comment|/* Boot order 14 bytes * 4 */
DECL|struct|Symbios_host
r_struct
id|Symbios_host
(brace
DECL|member|word0
id|u_char
id|word0
suffix:semicolon
multiline_comment|/* 0x0004:ok / 0x0000:nok */
DECL|member|device_id
id|u_short
id|device_id
suffix:semicolon
multiline_comment|/* PCI device id */
DECL|member|vendor_id
id|u_short
id|vendor_id
suffix:semicolon
multiline_comment|/* PCI vendor id */
DECL|member|byte6
id|u_char
id|byte6
suffix:semicolon
multiline_comment|/* 0x00 */
DECL|member|device_fn
id|u_char
id|device_fn
suffix:semicolon
multiline_comment|/* PCI device/function number &lt;&lt; 3*/
DECL|member|word8
id|u_short
id|word8
suffix:semicolon
DECL|member|flags
id|u_short
id|flags
suffix:semicolon
DECL|macro|SYMBIOS_INIT_SCAN_AT_BOOT
mdefine_line|#define&t;SYMBIOS_INIT_SCAN_AT_BOOT&t;(1)
DECL|member|io_port
id|u_short
id|io_port
suffix:semicolon
multiline_comment|/* PCI io_port address */
DECL|member|host
)brace
id|host
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Targets 8 bytes * 16 */
DECL|struct|Symbios_target
r_struct
id|Symbios_target
(brace
DECL|member|flags
id|u_short
id|flags
suffix:semicolon
DECL|macro|SYMBIOS_DISCONNECT_ENABLE
mdefine_line|#define SYMBIOS_DISCONNECT_ENABLE&t;(1)
DECL|macro|SYMBIOS_SCAN_AT_BOOT_TIME
mdefine_line|#define SYMBIOS_SCAN_AT_BOOT_TIME&t;(1&lt;&lt;1)
DECL|macro|SYMBIOS_SCAN_LUNS
mdefine_line|#define SYMBIOS_SCAN_LUNS&t;&t;(1&lt;&lt;2)
DECL|macro|SYMBIOS_QUEUE_TAGS_ENABLED
mdefine_line|#define SYMBIOS_QUEUE_TAGS_ENABLED&t;(1&lt;&lt;3)
DECL|member|bus_width
id|u_char
id|bus_width
suffix:semicolon
multiline_comment|/* 0x08/0x10 */
DECL|member|sync_offset
id|u_char
id|sync_offset
suffix:semicolon
DECL|member|sync_period
id|u_char
id|sync_period
suffix:semicolon
multiline_comment|/* 4*period factor */
DECL|member|byte6
id|u_char
id|byte6
suffix:semicolon
multiline_comment|/* 0x00 */
DECL|member|timeout
id|u_short
id|timeout
suffix:semicolon
DECL|member|target
)brace
id|target
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|spare_devices
id|u_char
id|spare_devices
(braket
l_int|19
op_star
l_int|8
)braket
suffix:semicolon
DECL|member|trailer
id|u_char
id|trailer
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* 0xfe 0xfe 0x00 0x00 0x00 0x00 */
)brace
suffix:semicolon
DECL|typedef|Symbios_nvram
r_typedef
r_struct
id|Symbios_nvram
id|Symbios_nvram
suffix:semicolon
DECL|typedef|Symbios_host
r_typedef
r_struct
id|Symbios_host
id|Symbios_host
suffix:semicolon
DECL|typedef|Symbios_target
r_typedef
r_struct
id|Symbios_target
id|Symbios_target
suffix:semicolon
multiline_comment|/*&n;**&t;Tekram NvRAM data format.&n;*/
DECL|macro|TEKRAM_NVRAM_SIZE
mdefine_line|#define TEKRAM_NVRAM_SIZE 64
DECL|macro|TEKRAM_NVRAM_ADDRESS
mdefine_line|#define TEKRAM_NVRAM_ADDRESS 0
DECL|struct|Tekram_nvram
r_struct
id|Tekram_nvram
(brace
DECL|struct|Tekram_target
r_struct
id|Tekram_target
(brace
DECL|member|flags
id|u_char
id|flags
suffix:semicolon
DECL|macro|TEKRAM_PARITY_CHECK
mdefine_line|#define&t;TEKRAM_PARITY_CHECK&t;&t;(1)
DECL|macro|TEKRAM_SYNC_NEGO
mdefine_line|#define TEKRAM_SYNC_NEGO&t;&t;(1&lt;&lt;1)
DECL|macro|TEKRAM_DISCONNECT_ENABLE
mdefine_line|#define TEKRAM_DISCONNECT_ENABLE&t;(1&lt;&lt;2)
DECL|macro|TEKRAM_START_CMD
mdefine_line|#define&t;TEKRAM_START_CMD&t;&t;(1&lt;&lt;3)
DECL|macro|TEKRAM_TAGGED_COMMANDS
mdefine_line|#define TEKRAM_TAGGED_COMMANDS&t;&t;(1&lt;&lt;4)
DECL|macro|TEKRAM_WIDE_NEGO
mdefine_line|#define TEKRAM_WIDE_NEGO&t;&t;(1&lt;&lt;5)
DECL|member|sync_index
id|u_char
id|sync_index
suffix:semicolon
DECL|member|word2
id|u_short
id|word2
suffix:semicolon
DECL|member|target
)brace
id|target
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|host_id
id|u_char
id|host_id
suffix:semicolon
DECL|member|flags
id|u_char
id|flags
suffix:semicolon
DECL|macro|TEKRAM_MORE_THAN_2_DRIVES
mdefine_line|#define TEKRAM_MORE_THAN_2_DRIVES&t;(1)
DECL|macro|TEKRAM_DRIVES_SUP_1GB
mdefine_line|#define TEKRAM_DRIVES_SUP_1GB&t;&t;(1&lt;&lt;1)
DECL|macro|TEKRAM_RESET_ON_POWER_ON
mdefine_line|#define&t;TEKRAM_RESET_ON_POWER_ON&t;(1&lt;&lt;2)
DECL|macro|TEKRAM_ACTIVE_NEGATION
mdefine_line|#define TEKRAM_ACTIVE_NEGATION&t;&t;(1&lt;&lt;3)
DECL|macro|TEKRAM_IMMEDIATE_SEEK
mdefine_line|#define TEKRAM_IMMEDIATE_SEEK&t;&t;(1&lt;&lt;4)
DECL|macro|TEKRAM_SCAN_LUNS
mdefine_line|#define&t;TEKRAM_SCAN_LUNS&t;&t;(1&lt;&lt;5)
DECL|macro|TEKRAM_REMOVABLE_FLAGS
mdefine_line|#define&t;TEKRAM_REMOVABLE_FLAGS&t;&t;(3&lt;&lt;6)&t;/* 0: disable; 1: boot device; 2:all */
DECL|member|boot_delay_index
id|u_char
id|boot_delay_index
suffix:semicolon
DECL|member|max_tags_index
id|u_char
id|max_tags_index
suffix:semicolon
DECL|member|flags1
id|u_short
id|flags1
suffix:semicolon
DECL|macro|TEKRAM_F2_F6_ENABLED
mdefine_line|#define TEKRAM_F2_F6_ENABLED&t;&t;(1)
DECL|member|spare
id|u_short
id|spare
(braket
l_int|29
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|Tekram_nvram
r_typedef
r_struct
id|Tekram_nvram
id|Tekram_nvram
suffix:semicolon
DECL|typedef|Tekram_target
r_typedef
r_struct
id|Tekram_target
id|Tekram_target
suffix:semicolon
DECL|variable|__initdata
r_static
id|u_char
id|Tekram_sync
(braket
l_int|12
)braket
id|__initdata
op_assign
(brace
l_int|25
comma
l_int|31
comma
l_int|37
comma
l_int|43
comma
l_int|50
comma
l_int|62
comma
l_int|75
comma
l_int|125
comma
l_int|12
comma
l_int|15
comma
l_int|18
comma
l_int|21
)brace
suffix:semicolon
macro_line|#endif /* SCSI_NCR_NVRAM_SUPPORT */
multiline_comment|/*&n;**&t;Structures used by ncr53c8xx_detect/ncr53c8xx_pci_init to &n;**&t;transmit device configuration to the ncr_attach() function.&n;*/
r_typedef
r_struct
(brace
DECL|member|bus
r_int
id|bus
suffix:semicolon
DECL|member|device_fn
id|u_char
id|device_fn
suffix:semicolon
DECL|member|base
id|u_int
id|base
suffix:semicolon
DECL|member|io_port
id|u_int
id|io_port
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* port and reg fields to use INB, OUTB macros */
DECL|member|port
id|u_int
id|port
suffix:semicolon
DECL|member|reg
r_volatile
r_struct
id|ncr_reg
op_star
id|reg
suffix:semicolon
DECL|typedef|ncr_slot
)brace
id|ncr_slot
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|type
r_int
id|type
suffix:semicolon
DECL|macro|SCSI_NCR_SYMBIOS_NVRAM
mdefine_line|#define&t;SCSI_NCR_SYMBIOS_NVRAM&t;(1)
DECL|macro|SCSI_NCR_TEKRAM_NVRAM
mdefine_line|#define&t;SCSI_NCR_TEKRAM_NVRAM&t;(2)
macro_line|#ifdef&t;SCSI_NCR_NVRAM_SUPPORT
r_union
(brace
DECL|member|Symbios
id|Symbios_nvram
id|Symbios
suffix:semicolon
DECL|member|Tekram
id|Tekram_nvram
id|Tekram
suffix:semicolon
DECL|member|data
)brace
id|data
suffix:semicolon
macro_line|#endif
DECL|typedef|ncr_nvram
)brace
id|ncr_nvram
suffix:semicolon
multiline_comment|/*&n;**&t;Structure used by ncr53c8xx_detect/ncr53c8xx_pci_init&n;**&t;to save data on each detected board for ncr_attach().&n;*/
r_typedef
r_struct
(brace
DECL|member|slot
id|ncr_slot
id|slot
suffix:semicolon
DECL|member|chip
id|ncr_chip
id|chip
suffix:semicolon
DECL|member|nvram
id|ncr_nvram
op_star
id|nvram
suffix:semicolon
DECL|member|attached
r_int
id|attached
suffix:semicolon
DECL|typedef|ncr_device
)brace
id|ncr_device
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&t;Debugging tags&n;**&n;**==========================================================&n;*/
DECL|macro|DEBUG_ALLOC
mdefine_line|#define DEBUG_ALLOC    (0x0001)
DECL|macro|DEBUG_PHASE
mdefine_line|#define DEBUG_PHASE    (0x0002)
DECL|macro|DEBUG_POLL
mdefine_line|#define DEBUG_POLL     (0x0004)
DECL|macro|DEBUG_QUEUE
mdefine_line|#define DEBUG_QUEUE    (0x0008)
DECL|macro|DEBUG_RESULT
mdefine_line|#define DEBUG_RESULT   (0x0010)
DECL|macro|DEBUG_SCATTER
mdefine_line|#define DEBUG_SCATTER  (0x0020)
DECL|macro|DEBUG_SCRIPT
mdefine_line|#define DEBUG_SCRIPT   (0x0040)
DECL|macro|DEBUG_TINY
mdefine_line|#define DEBUG_TINY     (0x0080)
DECL|macro|DEBUG_TIMING
mdefine_line|#define DEBUG_TIMING   (0x0100)
DECL|macro|DEBUG_NEGO
mdefine_line|#define DEBUG_NEGO     (0x0200)
DECL|macro|DEBUG_TAGS
mdefine_line|#define DEBUG_TAGS     (0x0400)
DECL|macro|DEBUG_FREEZE
mdefine_line|#define DEBUG_FREEZE   (0x0800)
DECL|macro|DEBUG_RESTART
mdefine_line|#define DEBUG_RESTART  (0x1000)
multiline_comment|/*&n;**    Enable/Disable debug messages.&n;**    Can be changed at runtime too.&n;*/
macro_line|#ifdef SCSI_NCR_DEBUG_INFO_SUPPORT
DECL|macro|DEBUG_FLAGS
mdefine_line|#define DEBUG_FLAGS ncr_debug
macro_line|#else
DECL|macro|DEBUG_FLAGS
mdefine_line|#define DEBUG_FLAGS&t;SCSI_NCR_DEBUG_FLAGS
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;assert ()&n;**&n;**==========================================================&n;**&n;**&t;modified copy from 386bsd:/usr/include/sys/assert.h&n;**&n;**----------------------------------------------------------&n;*/
DECL|macro|assert
mdefine_line|#define&t;assert(expression) { &bslash;&n;&t;if (!(expression)) { &bslash;&n;&t;&t;(void)printf(&bslash;&n;&t;&t;&t;&quot;assertion &bslash;&quot;%s&bslash;&quot; failed: file &bslash;&quot;%s&bslash;&quot;, line %d&bslash;n&quot;, &bslash;&n;&t;&t;&t;#expression, &bslash;&n;&t;&t;&t;__FILE__, __LINE__); &bslash;&n;&t;} &bslash;&n;}
multiline_comment|/*==========================================================&n;**&n;**&t;Access to the controller chip.&n;**&n;**&t;If NCR_IOMAPPED is defined, only IO are used by the driver.&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**&t;IO mapped only input / ouput&n;*/
DECL|macro|IOM_INB
mdefine_line|#define&t;IOM_INB(r)&t;&t;inb (np-&gt;port + offsetof(struct ncr_reg, r))
DECL|macro|IOM_INB_OFF
mdefine_line|#define&t;IOM_INB_OFF(o)&t;&t;inb (np-&gt;port + (o))
DECL|macro|IOM_INW
mdefine_line|#define&t;IOM_INW(r)&t;&t;inw (np-&gt;port + offsetof(struct ncr_reg, r))
DECL|macro|IOM_INL
mdefine_line|#define&t;IOM_INL(r)&t;&t;inl (np-&gt;port + offsetof(struct ncr_reg, r))
DECL|macro|IOM_INL_OFF
mdefine_line|#define&t;IOM_INL_OFF(o)&t;&t;inl (np-&gt;port + (o))
DECL|macro|IOM_OUTB
mdefine_line|#define&t;IOM_OUTB(r, val)&t;outb ((val), np-&gt;port+offsetof(struct ncr_reg,r))
DECL|macro|IOM_OUTW
mdefine_line|#define&t;IOM_OUTW(r, val)&t;outw ((val), np-&gt;port+offsetof(struct ncr_reg,r))
DECL|macro|IOM_OUTL
mdefine_line|#define&t;IOM_OUTL(r, val)&t;outl ((val), np-&gt;port+offsetof(struct ncr_reg,r))
DECL|macro|IOM_OUTL_OFF
mdefine_line|#define&t;IOM_OUTL_OFF(o, val)&t;outl ((val), np-&gt;port + (o))
multiline_comment|/*&n;**&t;MEMORY mapped IO input / output&n;*/
DECL|macro|MMIO_INB
mdefine_line|#define MMIO_INB(r)&t;&t;readb(&amp;np-&gt;reg-&gt;r)
DECL|macro|MMIO_INB_OFF
mdefine_line|#define MMIO_INB_OFF(o)&t;&t;readb((char *)np-&gt;reg + (o))
DECL|macro|MMIO_INW
mdefine_line|#define MMIO_INW(r)&t;&t;readw(&amp;np-&gt;reg-&gt;r)
DECL|macro|MMIO_INL
mdefine_line|#define MMIO_INL(r)&t;&t;readl(&amp;np-&gt;reg-&gt;r)
DECL|macro|MMIO_INL_OFF
mdefine_line|#define MMIO_INL_OFF(o)&t;&t;readl((char *)np-&gt;reg + (o))
DECL|macro|MMIO_OUTB
mdefine_line|#define MMIO_OUTB(r, val)&t;writeb((val), &amp;np-&gt;reg-&gt;r)
DECL|macro|MMIO_OUTW
mdefine_line|#define MMIO_OUTW(r, val)&t;writew((val), &amp;np-&gt;reg-&gt;r)
DECL|macro|MMIO_OUTL
mdefine_line|#define MMIO_OUTL(r, val)&t;writel((val), &amp;np-&gt;reg-&gt;r)
DECL|macro|MMIO_OUTL_OFF
mdefine_line|#define MMIO_OUTL_OFF(o, val)&t;writel((val), (char *)np-&gt;reg + (o))
multiline_comment|/*&n;**&t;IO mapped input / output&n;*/
macro_line|#if defined(NCR_IOMAPPED)
DECL|macro|INB
mdefine_line|#define INB(r)             IOM_INB(r)
DECL|macro|INB_OFF
mdefine_line|#define INB_OFF(o)         IOM_INB_OFF(o)
DECL|macro|INW
mdefine_line|#define INW(r)             IOM_INW(r)
DECL|macro|INL
mdefine_line|#define INL(r)             IOM_INL(r)
DECL|macro|INL_OFF
mdefine_line|#define INL_OFF(o)         IOM_INL_OFF(o)
DECL|macro|OUTB
mdefine_line|#define OUTB(r, val)       IOM_OUTB(r, val)
DECL|macro|OUTW
mdefine_line|#define OUTW(r, val)       IOM_OUTW(r, val)
DECL|macro|OUTL
mdefine_line|#define OUTL(r, val)       IOM_OUTL(r, val)
DECL|macro|OUTL_OFF
mdefine_line|#define OUTL_OFF(o, val)   IOM_OUTL_OFF(o, val)
multiline_comment|/*&n;**&t;MEMORY mapped only input / output&n;*/
macro_line|#else
DECL|macro|INB
mdefine_line|#define INB(r)             MMIO_INB(r)
DECL|macro|INB_OFF
mdefine_line|#define INB_OFF(o)         MMIO_INB_OFF(o)
DECL|macro|INW
mdefine_line|#define INW(r)             MMIO_INW(r)
DECL|macro|INL
mdefine_line|#define INL(r)             MMIO_INL(r)
DECL|macro|INL_OFF
mdefine_line|#define INL_OFF(o)         MMIO_INL_OFF(o)
DECL|macro|OUTB
mdefine_line|#define OUTB(r, val)       MMIO_OUTB(r, val)
DECL|macro|OUTW
mdefine_line|#define OUTW(r, val)       MMIO_OUTW(r, val)
DECL|macro|OUTL
mdefine_line|#define OUTL(r, val)       MMIO_OUTL(r, val)
DECL|macro|OUTL_OFF
mdefine_line|#define OUTL_OFF(o, val)   MMIO_OUTL_OFF(o, val)
macro_line|#endif
multiline_comment|/*&n;**&t;Set bit field ON, OFF &n;*/
DECL|macro|OUTONB
mdefine_line|#define OUTONB(r, m)&t;OUTB(r, INB(r) | (m))
DECL|macro|OUTOFFB
mdefine_line|#define OUTOFFB(r, m)&t;OUTB(r, INB(r) &amp; ~(m))
DECL|macro|OUTONW
mdefine_line|#define OUTONW(r, m)&t;OUTW(r, INW(r) | (m))
DECL|macro|OUTOFFW
mdefine_line|#define OUTOFFW(r, m)&t;OUTW(r, INW(r) &amp; ~(m))
DECL|macro|OUTONL
mdefine_line|#define OUTONL(r, m)&t;OUTL(r, INL(r) | (m))
DECL|macro|OUTOFFL
mdefine_line|#define OUTOFFL(r, m)&t;OUTL(r, INL(r) &amp; ~(m))
multiline_comment|/*==========================================================&n;**&n;**&t;Command control block states.&n;**&n;**==========================================================&n;*/
DECL|macro|HS_IDLE
mdefine_line|#define HS_IDLE&t;&t;(0)
DECL|macro|HS_BUSY
mdefine_line|#define HS_BUSY&t;&t;(1)
DECL|macro|HS_NEGOTIATE
mdefine_line|#define HS_NEGOTIATE&t;(2)&t;/* sync/wide data transfer*/
DECL|macro|HS_DISCONNECT
mdefine_line|#define HS_DISCONNECT&t;(3)&t;/* Disconnected by target */
DECL|macro|HS_COMPLETE
mdefine_line|#define HS_COMPLETE&t;(4)
DECL|macro|HS_SEL_TIMEOUT
mdefine_line|#define HS_SEL_TIMEOUT&t;(5)&t;/* Selection timeout      */
DECL|macro|HS_RESET
mdefine_line|#define HS_RESET&t;(6)&t;/* SCSI reset&t;     */
DECL|macro|HS_ABORTED
mdefine_line|#define HS_ABORTED&t;(7)&t;/* Transfer aborted       */
DECL|macro|HS_TIMEOUT
mdefine_line|#define HS_TIMEOUT&t;(8)&t;/* Software timeout       */
DECL|macro|HS_FAIL
mdefine_line|#define HS_FAIL&t;&t;(9)&t;/* SCSI or PCI bus errors */
DECL|macro|HS_UNEXPECTED
mdefine_line|#define HS_UNEXPECTED&t;(10)&t;/* Unexpected disconnect  */
DECL|macro|HS_DONEMASK
mdefine_line|#define HS_DONEMASK&t;(0xfc)
multiline_comment|/*==========================================================&n;**&n;**&t;Software Interrupt Codes&n;**&n;**==========================================================&n;*/
DECL|macro|SIR_SENSE_RESTART
mdefine_line|#define&t;SIR_SENSE_RESTART&t;(1)
DECL|macro|SIR_SENSE_FAILED
mdefine_line|#define&t;SIR_SENSE_FAILED&t;(2)
DECL|macro|SIR_STALL_RESTART
mdefine_line|#define&t;SIR_STALL_RESTART&t;(3)
DECL|macro|SIR_STALL_QUEUE
mdefine_line|#define&t;SIR_STALL_QUEUE&t;&t;(4)
DECL|macro|SIR_NEGO_SYNC
mdefine_line|#define&t;SIR_NEGO_SYNC&t;&t;(5)
DECL|macro|SIR_NEGO_WIDE
mdefine_line|#define&t;SIR_NEGO_WIDE&t;&t;(6)
DECL|macro|SIR_NEGO_FAILED
mdefine_line|#define&t;SIR_NEGO_FAILED&t;&t;(7)
DECL|macro|SIR_NEGO_PROTO
mdefine_line|#define&t;SIR_NEGO_PROTO&t;&t;(8)
DECL|macro|SIR_REJECT_RECEIVED
mdefine_line|#define&t;SIR_REJECT_RECEIVED&t;(9)
DECL|macro|SIR_REJECT_SENT
mdefine_line|#define&t;SIR_REJECT_SENT&t;&t;(10)
DECL|macro|SIR_IGN_RESIDUE
mdefine_line|#define&t;SIR_IGN_RESIDUE&t;&t;(11)
DECL|macro|SIR_MISSING_SAVE
mdefine_line|#define&t;SIR_MISSING_SAVE&t;(12)
DECL|macro|SIR_DATA_IO_IS_OUT
mdefine_line|#define&t;SIR_DATA_IO_IS_OUT&t;(13)
DECL|macro|SIR_DATA_IO_IS_IN
mdefine_line|#define&t;SIR_DATA_IO_IS_IN&t;(14)
DECL|macro|SIR_MAX
mdefine_line|#define&t;SIR_MAX&t;&t;&t;(14)
multiline_comment|/*==========================================================&n;**&n;**&t;Extended error codes.&n;**&t;xerr_status field of struct ccb.&n;**&n;**==========================================================&n;*/
DECL|macro|XE_OK
mdefine_line|#define&t;XE_OK&t;&t;(0)
DECL|macro|XE_EXTRA_DATA
mdefine_line|#define&t;XE_EXTRA_DATA&t;(1)&t;/* unexpected data phase */
DECL|macro|XE_BAD_PHASE
mdefine_line|#define&t;XE_BAD_PHASE&t;(2)&t;/* illegal phase (4/5)   */
multiline_comment|/*==========================================================&n;**&n;**&t;Negotiation status.&n;**&t;nego_status field&t;of struct ccb.&n;**&n;**==========================================================&n;*/
DECL|macro|NS_SYNC
mdefine_line|#define NS_SYNC&t;&t;(1)
DECL|macro|NS_WIDE
mdefine_line|#define NS_WIDE&t;&t;(2)
multiline_comment|/*==========================================================&n;**&n;**&t;&quot;Special features&quot; of targets.&n;**&t;quirks field&t;&t;of struct tcb.&n;**&t;actualquirks field&t;of struct ccb.&n;**&n;**==========================================================&n;*/
DECL|macro|QUIRK_AUTOSAVE
mdefine_line|#define&t;QUIRK_AUTOSAVE&t;(0x01)
DECL|macro|QUIRK_NOMSG
mdefine_line|#define&t;QUIRK_NOMSG&t;(0x02)
DECL|macro|QUIRK_NOSYNC
mdefine_line|#define QUIRK_NOSYNC&t;(0x10)
DECL|macro|QUIRK_NOWIDE16
mdefine_line|#define QUIRK_NOWIDE16&t;(0x20)
DECL|macro|QUIRK_UPDATE
mdefine_line|#define&t;QUIRK_UPDATE&t;(0x80)
multiline_comment|/*==========================================================&n;**&n;**&t;Capability bits in Inquire response byte 7.&n;**&n;**==========================================================&n;*/
DECL|macro|INQ7_QUEUE
mdefine_line|#define&t;INQ7_QUEUE&t;(0x02)
DECL|macro|INQ7_SYNC
mdefine_line|#define&t;INQ7_SYNC&t;(0x10)
DECL|macro|INQ7_WIDE16
mdefine_line|#define&t;INQ7_WIDE16&t;(0x20)
multiline_comment|/*==========================================================&n;**&n;**&t;Misc.&n;**&n;**==========================================================&n;*/
DECL|macro|CCB_MAGIC
mdefine_line|#define CCB_MAGIC&t;(0xf2691ad2)
multiline_comment|/*==========================================================&n;**&n;**&t;Declaration of structs.&n;**&n;**==========================================================&n;*/
r_struct
id|tcb
suffix:semicolon
r_struct
id|lcb
suffix:semicolon
r_struct
id|ccb
suffix:semicolon
r_struct
id|ncb
suffix:semicolon
r_struct
id|script
suffix:semicolon
DECL|typedef|ncb_p
r_typedef
r_struct
id|ncb
op_star
id|ncb_p
suffix:semicolon
DECL|typedef|tcb_p
r_typedef
r_struct
id|tcb
op_star
id|tcb_p
suffix:semicolon
DECL|typedef|lcb_p
r_typedef
r_struct
id|lcb
op_star
id|lcb_p
suffix:semicolon
DECL|typedef|ccb_p
r_typedef
r_struct
id|ccb
op_star
id|ccb_p
suffix:semicolon
DECL|struct|link
r_struct
id|link
(brace
DECL|member|l_cmd
id|ncrcmd
id|l_cmd
suffix:semicolon
DECL|member|l_paddr
id|ncrcmd
id|l_paddr
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|usrcmd
r_struct
id|usrcmd
(brace
DECL|member|target
id|u_long
id|target
suffix:semicolon
DECL|member|lun
id|u_long
id|lun
suffix:semicolon
DECL|member|data
id|u_long
id|data
suffix:semicolon
DECL|member|cmd
id|u_long
id|cmd
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|UC_SETSYNC
mdefine_line|#define UC_SETSYNC      10
DECL|macro|UC_SETTAGS
mdefine_line|#define UC_SETTAGS&t;11
DECL|macro|UC_SETDEBUG
mdefine_line|#define UC_SETDEBUG&t;12
DECL|macro|UC_SETORDER
mdefine_line|#define UC_SETORDER&t;13
DECL|macro|UC_SETWIDE
mdefine_line|#define UC_SETWIDE&t;14
DECL|macro|UC_SETFLAG
mdefine_line|#define UC_SETFLAG&t;15
DECL|macro|UC_CLEARPROF
mdefine_line|#define UC_CLEARPROF&t;16
macro_line|#ifdef&t;SCSI_NCR_DEBUG_ERROR_RECOVERY_SUPPORT
DECL|macro|UC_DEBUG_ERROR_RECOVERY
mdefine_line|#define UC_DEBUG_ERROR_RECOVERY 17
macro_line|#endif
DECL|macro|UF_TRACE
mdefine_line|#define&t;UF_TRACE&t;(0x01)
DECL|macro|UF_NODISC
mdefine_line|#define&t;UF_NODISC&t;(0x02)
DECL|macro|UF_NOSCAN
mdefine_line|#define&t;UF_NOSCAN&t;(0x04)
multiline_comment|/*---------------------------------------&n;**&n;**&t;Timestamps for profiling&n;**&n;**---------------------------------------&n;*/
DECL|struct|tstamp
r_struct
id|tstamp
(brace
DECL|member|start
id|u_long
id|start
suffix:semicolon
DECL|member|end
id|u_long
id|end
suffix:semicolon
DECL|member|select
id|u_long
id|select
suffix:semicolon
DECL|member|command
id|u_long
id|command
suffix:semicolon
DECL|member|status
id|u_long
id|status
suffix:semicolon
DECL|member|disconnect
id|u_long
id|disconnect
suffix:semicolon
DECL|member|reselect
id|u_long
id|reselect
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;profiling data (per device)&n;*/
DECL|struct|profile
r_struct
id|profile
(brace
DECL|member|num_trans
id|u_long
id|num_trans
suffix:semicolon
DECL|member|num_kbytes
id|u_long
id|num_kbytes
suffix:semicolon
DECL|member|rest_bytes
id|u_long
id|rest_bytes
suffix:semicolon
DECL|member|num_disc
id|u_long
id|num_disc
suffix:semicolon
DECL|member|num_break
id|u_long
id|num_break
suffix:semicolon
DECL|member|num_int
id|u_long
id|num_int
suffix:semicolon
DECL|member|num_fly
id|u_long
id|num_fly
suffix:semicolon
DECL|member|ms_setup
id|u_long
id|ms_setup
suffix:semicolon
DECL|member|ms_data
id|u_long
id|ms_data
suffix:semicolon
DECL|member|ms_disc
id|u_long
id|ms_disc
suffix:semicolon
DECL|member|ms_post
id|u_long
id|ms_post
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&t;Declaration of structs:&t;&t;target control block&n;**&n;**==========================================================&n;*/
DECL|struct|tcb
r_struct
id|tcb
(brace
multiline_comment|/*&n;&t;**&t;during reselection the ncr jumps to this point&n;&t;**&t;with SFBR set to the encoded target number&n;&t;**&t;with bit 7 set.&n;&t;**&t;if it&squot;s not this target, jump to the next.&n;&t;**&n;&t;**&t;JUMP  IF (SFBR != #target#)&n;&t;**&t;@(next tcb)&n;&t;*/
DECL|member|jump_tcb
r_struct
id|link
id|jump_tcb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;load the actual values for the sxfer and the scntl3&n;&t;**&t;register (sync/wide mode).&n;&t;**&n;&t;**&t;SCR_COPY (1);&n;&t;**&t;@(sval field of this tcb)&n;&t;**&t;@(sxfer register)&n;&t;**&t;SCR_COPY (1);&n;&t;**&t;@(wval field of this tcb)&n;&t;**&t;@(scntl3 register)&n;&t;*/
DECL|member|getscr
id|ncrcmd
id|getscr
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;if next message is &quot;identify&quot;&n;&t;**&t;then load the message to SFBR,&n;&t;**&t;else load 0 to SFBR.&n;&t;**&n;&t;**&t;CALL&n;&t;**&t;&lt;RESEL_LUN&gt;&n;&t;*/
DECL|member|call_lun
r_struct
id|link
id|call_lun
suffix:semicolon
multiline_comment|/*&n;&t;**&t;now look for the right lun.&n;&t;**&n;&t;**&t;JUMP&n;&t;**&t;@(first ccb of this lun)&n;&t;*/
DECL|member|jump_lcb
r_struct
id|link
id|jump_lcb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;pointer to interrupted getcc ccb&n;&t;*/
DECL|member|hold_cp
id|ccb_p
id|hold_cp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;pointer to ccb used for negotiating.&n;&t;**&t;Avoid to start a nego for all queued commands &n;&t;**&t;when tagged command queuing is enabled.&n;&t;*/
DECL|member|nego_cp
id|ccb_p
id|nego_cp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;statistical data&n;&t;*/
DECL|member|transfers
id|u_long
id|transfers
suffix:semicolon
DECL|member|bytes
id|u_long
id|bytes
suffix:semicolon
multiline_comment|/*&n;&t;**&t;user settable limits for sync transfer&n;&t;**&t;and tagged commands.&n;&t;**&t;These limits are read from the NVRAM if present.&n;&t;*/
DECL|member|usrsync
id|u_char
id|usrsync
suffix:semicolon
DECL|member|usrwide
id|u_char
id|usrwide
suffix:semicolon
DECL|member|usrtags
id|u_char
id|usrtags
suffix:semicolon
DECL|member|usrflag
id|u_char
id|usrflag
suffix:semicolon
DECL|member|numtags
id|u_char
id|numtags
suffix:semicolon
DECL|member|maxtags
id|u_char
id|maxtags
suffix:semicolon
DECL|member|num_good
id|u_short
id|num_good
suffix:semicolon
multiline_comment|/*&n;&t;**&t;negotiation of wide and synch transfer.&n;&t;**&t;device quirks.&n;&t;*/
DECL|member|minsync
multiline_comment|/*0*/
id|u_char
id|minsync
suffix:semicolon
DECL|member|sval
multiline_comment|/*1*/
id|u_char
id|sval
suffix:semicolon
DECL|member|period
multiline_comment|/*2*/
id|u_short
id|period
suffix:semicolon
DECL|member|maxoffs
multiline_comment|/*0*/
id|u_char
id|maxoffs
suffix:semicolon
DECL|member|quirks
multiline_comment|/*1*/
id|u_char
id|quirks
suffix:semicolon
DECL|member|widedone
multiline_comment|/*2*/
id|u_char
id|widedone
suffix:semicolon
DECL|member|wval
multiline_comment|/*3*/
id|u_char
id|wval
suffix:semicolon
multiline_comment|/*&n;&t;**&t;inquire data&n;&t;*/
DECL|macro|MAX_INQUIRE
mdefine_line|#define MAX_INQUIRE 36
DECL|member|inqdata
id|u_char
id|inqdata
(braket
id|MAX_INQUIRE
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;the lcb&squot;s of this tcb&n;&t;*/
DECL|member|lp
id|lcb_p
id|lp
(braket
id|MAX_LUN
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&t;Declaration of structs:&t;&t;lun control block&n;**&n;**==========================================================&n;*/
DECL|struct|lcb
r_struct
id|lcb
(brace
multiline_comment|/*&n;&t;**&t;during reselection the ncr jumps to this point&n;&t;**&t;with SFBR set to the &quot;Identify&quot; message.&n;&t;**&t;if it&squot;s not this lun, jump to the next.&n;&t;**&n;&t;**&t;JUMP  IF (SFBR != #lun#)&n;&t;**&t;@(next lcb of this target)&n;&t;*/
DECL|member|jump_lcb
r_struct
id|link
id|jump_lcb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;if next message is &quot;simple tag&quot;,&n;&t;**&t;then load the tag to SFBR,&n;&t;**&t;else load 0 to SFBR.&n;&t;**&n;&t;**&t;CALL&n;&t;**&t;&lt;RESEL_TAG&gt;&n;&t;*/
DECL|member|call_tag
r_struct
id|link
id|call_tag
suffix:semicolon
multiline_comment|/*&n;&t;**&t;now look for the right ccb.&n;&t;**&n;&t;**&t;JUMP&n;&t;**&t;@(first ccb of this lun)&n;&t;*/
DECL|member|jump_ccb
r_struct
id|link
id|jump_ccb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;start of the ccb chain&n;&t;*/
DECL|member|next_ccb
id|ccb_p
id|next_ccb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Control of tagged queueing&n;&t;*/
DECL|member|reqccbs
id|u_char
id|reqccbs
suffix:semicolon
DECL|member|actccbs
id|u_char
id|actccbs
suffix:semicolon
DECL|member|reqlink
id|u_char
id|reqlink
suffix:semicolon
DECL|member|actlink
id|u_char
id|actlink
suffix:semicolon
DECL|member|usetags
id|u_char
id|usetags
suffix:semicolon
DECL|member|lasttag
id|u_char
id|lasttag
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Linux specific fields:&n;&t;**&t;Number of active commands and current credit.&n;&t;**&t;Should be managed by the generic scsi driver&n;&t;*/
DECL|member|active
id|u_char
id|active
suffix:semicolon
DECL|member|opennings
id|u_char
id|opennings
suffix:semicolon
multiline_comment|/*-----------------------------------------------&n;&t;**&t;Flag to force M_ORDERED_TAG on next command&n;&t;**&t;in order to avoid spurious timeout when&n;&t;**&t;M_SIMPLE_TAG is used for all operations.&n;&t;**-----------------------------------------------&n;&t;*/
DECL|member|force_ordered_tag
id|u_char
id|force_ordered_tag
suffix:semicolon
DECL|macro|NCR_TIMEOUT_INCREASE
mdefine_line|#define NCR_TIMEOUT_INCREASE&t;(5*HZ)
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**      Declaration of structs:     COMMAND control block&n;**&n;**==========================================================&n;**&n;**&t;This substructure is copied from the ccb to a&n;**&t;global address after selection (or reselection)&n;**&t;and copied back before disconnect.&n;**&n;**&t;These fields are accessible to the script processor.&n;**&n;**----------------------------------------------------------&n;*/
DECL|struct|head
r_struct
id|head
(brace
multiline_comment|/*&n;&t;**&t;Execution of a ccb starts at this point.&n;&t;**&t;It&squot;s a jump to the &quot;SELECT&quot; label&n;&t;**&t;of the script.&n;&t;**&n;&t;**&t;After successful selection the script&n;&t;**&t;processor overwrites it with a jump to&n;&t;**&t;the IDLE label of the script.&n;&t;*/
DECL|member|launch
r_struct
id|link
id|launch
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Saved data pointer.&n;&t;**&t;Points to the position in the script&n;&t;**&t;responsible for the actual transfer&n;&t;**&t;of data.&n;&t;**&t;It&squot;s written after reception of a&n;&t;**&t;&quot;SAVE_DATA_POINTER&quot; message.&n;&t;**&t;The goalpointer points after&n;&t;**&t;the last transfer command.&n;&t;*/
DECL|member|savep
id|u_int32
id|savep
suffix:semicolon
DECL|member|lastp
id|u_int32
id|lastp
suffix:semicolon
DECL|member|goalp
id|u_int32
id|goalp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The virtual address of the ccb&n;&t;**&t;containing this header.&n;&t;*/
DECL|member|cp
id|ccb_p
id|cp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;space for some timestamps to gather&n;&t;**&t;profiling data about devices and this driver.&n;&t;*/
DECL|member|stamp
r_struct
id|tstamp
id|stamp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;status fields.&n;&t;*/
DECL|member|status
id|u_char
id|status
(braket
l_int|8
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;The status bytes are used by the host and the script processor.&n;**&n;**&t;The first four byte are copied to the scratchb register&n;**&t;(declared as scr0..scr3 in ncr_reg.h) just after the select/reselect,&n;**&t;and copied back just after disconnecting.&n;**&t;Inside the script the XX_REG are used.&n;**&n;**&t;The last four bytes are used inside the script by &quot;COPY&quot; commands.&n;**&t;Because source and destination must have the same alignment&n;**&t;in a longword, the fields HAVE to be at the choosen offsets.&n;**&t;&t;xerr_st&t;(4)&t;0&t;(0x34)&t;scratcha&n;**&t;&t;sync_st&t;(5)&t;1&t;(0x05)&t;sxfer&n;**&t;&t;wide_st&t;(7)&t;3&t;(0x03)&t;scntl3&n;*/
multiline_comment|/*&n;**&t;First four bytes (script)&n;*/
DECL|macro|QU_REG
mdefine_line|#define  QU_REG&t;scr0
DECL|macro|HS_REG
mdefine_line|#define  HS_REG&t;scr1
DECL|macro|HS_PRT
mdefine_line|#define  HS_PRT&t;nc_scr1
DECL|macro|SS_REG
mdefine_line|#define  SS_REG&t;scr2
DECL|macro|PS_REG
mdefine_line|#define  PS_REG&t;scr3
multiline_comment|/*&n;**&t;First four bytes (host)&n;*/
DECL|macro|actualquirks
mdefine_line|#define  actualquirks  phys.header.status[0]
DECL|macro|host_status
mdefine_line|#define  host_status   phys.header.status[1]
DECL|macro|scsi_status
mdefine_line|#define  scsi_status   phys.header.status[2]
DECL|macro|parity_status
mdefine_line|#define  parity_status phys.header.status[3]
multiline_comment|/*&n;**&t;Last four bytes (script)&n;*/
DECL|macro|xerr_st
mdefine_line|#define  xerr_st       header.status[4]&t;/* MUST be ==0 mod 4 */
DECL|macro|sync_st
mdefine_line|#define  sync_st       header.status[5]&t;/* MUST be ==1 mod 4 */
DECL|macro|nego_st
mdefine_line|#define  nego_st       header.status[6]
DECL|macro|wide_st
mdefine_line|#define  wide_st       header.status[7]&t;/* MUST be ==3 mod 4 */
multiline_comment|/*&n;**&t;Last four bytes (host)&n;*/
DECL|macro|xerr_status
mdefine_line|#define  xerr_status   phys.xerr_st
DECL|macro|sync_status
mdefine_line|#define  sync_status   phys.sync_st
DECL|macro|nego_status
mdefine_line|#define  nego_status   phys.nego_st
DECL|macro|wide_status
mdefine_line|#define  wide_status   phys.wide_st
multiline_comment|/*==========================================================&n;**&n;**      Declaration of structs:     Data structure block&n;**&n;**==========================================================&n;**&n;**&t;During execution of a ccb by the script processor,&n;**&t;the DSA (data structure address) register points&n;**&t;to this substructure of the ccb.&n;**&t;This substructure contains the header with&n;**&t;the script-processor-changable data and&n;**&t;data blocks for the indirect move commands.&n;**&n;**----------------------------------------------------------&n;*/
DECL|struct|dsb
r_struct
id|dsb
(brace
multiline_comment|/*&n;&t;**&t;Header.&n;&t;**&t;Has to be the first entry,&n;&t;**&t;because it&squot;s jumped to by the&n;&t;**&t;script processor&n;&t;*/
DECL|member|header
r_struct
id|head
id|header
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Table data for Script&n;&t;*/
DECL|member|select
r_struct
id|scr_tblsel
id|select
suffix:semicolon
DECL|member|smsg
r_struct
id|scr_tblmove
id|smsg
suffix:semicolon
DECL|member|smsg2
r_struct
id|scr_tblmove
id|smsg2
suffix:semicolon
DECL|member|cmd
r_struct
id|scr_tblmove
id|cmd
suffix:semicolon
DECL|member|scmd
r_struct
id|scr_tblmove
id|scmd
suffix:semicolon
DECL|member|sense
r_struct
id|scr_tblmove
id|sense
suffix:semicolon
DECL|member|data
r_struct
id|scr_tblmove
id|data
(braket
id|MAX_SCATTER
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**      Declaration of structs:     Command control block.&n;**&n;**==========================================================&n;**&n;**&t;During execution of a ccb by the script processor,&n;**&t;the DSA (data structure address) register points&n;**&t;to this substructure of the ccb.&n;**&t;This substructure contains the header with&n;**&t;the script-processor-changable data and then&n;**&t;data blocks for the indirect move commands.&n;**&n;**----------------------------------------------------------&n;*/
DECL|struct|ccb
r_struct
id|ccb
(brace
multiline_comment|/*&n;&t;**&t;This field forces 32 bytes alignement for phys.header,&n;&t;**&t;in order to use cache line bursting when copying it &n;&t;**&t;to the ncb.&n;&t;*/
DECL|member|filler
r_struct
id|link
id|filler
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;during reselection the ncr jumps to this point.&n;&t;**&t;If a &quot;SIMPLE_TAG&quot; message was received,&n;&t;**&t;then SFBR is set to the tag.&n;&t;**&t;else SFBR is set to 0&n;&t;**&t;If looking for another tag, jump to the next ccb.&n;&t;**&n;&t;**&t;JUMP  IF (SFBR != #TAG#)&n;&t;**&t;@(next ccb of this lun)&n;&t;*/
DECL|member|jump_ccb
r_struct
id|link
id|jump_ccb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;After execution of this call, the return address&n;&t;**&t;(in  the TEMP register) points to the following&n;&t;**&t;data structure block.&n;&t;**&t;So copy it to the DSA register, and start&n;&t;**&t;processing of this data structure.&n;&t;**&n;&t;**&t;CALL&n;&t;**&t;&lt;RESEL_TMP&gt;&n;&t;*/
DECL|member|call_tmp
r_struct
id|link
id|call_tmp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;This is the data structure which is&n;&t;**&t;to be executed by the script processor.&n;&t;*/
DECL|member|phys
r_struct
id|dsb
id|phys
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If a data transfer phase is terminated too early&n;&t;**&t;(after reception of a message (i.e. DISCONNECT)),&n;&t;**&t;we have to prepare a mini script to transfer&n;&t;**&t;the rest of the data.&n;&t;*/
DECL|member|patch
id|ncrcmd
id|patch
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The general SCSI driver provides a&n;&t;**&t;pointer to a control block.&n;&t;*/
DECL|member|cmd
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
DECL|member|data_len
r_int
id|data_len
suffix:semicolon
multiline_comment|/*&n;&t;**&t;We prepare a message to be sent after selection,&n;&t;**&t;and a second one to be sent after getcc selection.&n;&t;**      Contents are IDENTIFY and SIMPLE_TAG.&n;&t;**&t;While negotiating sync or wide transfer,&n;&t;**&t;a SDTM or WDTM message is appended.&n;&t;*/
DECL|member|scsi_smsg
id|u_char
id|scsi_smsg
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|scsi_smsg2
id|u_char
id|scsi_smsg2
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Lock this ccb.&n;&t;**&t;Flag is used while looking for a free ccb.&n;&t;*/
DECL|member|magic
id|u_long
id|magic
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Physical address of this instance of ccb&n;&t;*/
DECL|member|p_ccb
id|u_long
id|p_ccb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Completion time out for this job.&n;&t;**&t;It&squot;s set to time of start + allowed number of seconds.&n;&t;*/
DECL|member|tlimit
id|u_long
id|tlimit
suffix:semicolon
multiline_comment|/*&n;&t;**&t;All ccbs of one hostadapter are chained.&n;&t;*/
DECL|member|link_ccb
id|ccb_p
id|link_ccb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;All ccbs of one target/lun are chained.&n;&t;*/
DECL|member|next_ccb
id|ccb_p
id|next_ccb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Sense command&n;&t;*/
DECL|member|sensecmd
id|u_char
id|sensecmd
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Tag for this transfer.&n;&t;**&t;It&squot;s patched into jump_ccb.&n;&t;**&t;If it&squot;s not zero, a SIMPLE_TAG&n;&t;**&t;message is included in smsg.&n;&t;*/
DECL|member|tag
id|u_char
id|tag
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Number of segments of the scatter list.&n;&t;**&t;Used for recalculation of savep/goalp/lastp on &n;&t;**&t;SIR_DATA_IO_IS_OUT interrupt.&n;&t;*/
DECL|member|segments
id|u_char
id|segments
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|CCB_PHYS
mdefine_line|#define CCB_PHYS(cp,lbl)&t;(cp-&gt;p_ccb + offsetof(struct ccb, lbl))
multiline_comment|/*==========================================================&n;**&n;**      Declaration of structs:     NCR device descriptor&n;**&n;**==========================================================&n;*/
DECL|struct|ncb
r_struct
id|ncb
(brace
multiline_comment|/*&n;&t;**&t;The global header.&n;&t;**&t;Accessible to both the host and the&n;&t;**&t;script-processor.&n;&t;**&t;Is 32 bytes aligned since ncb is, in order to &n;&t;**&t;allow cache line bursting when copying it from or &n;&t;**&t;to ccbs.&n;&t;*/
DECL|member|header
r_struct
id|head
id|header
suffix:semicolon
multiline_comment|/*-----------------------------------------------&n;&t;**&t;Specific Linux fields&n;&t;**-----------------------------------------------&n;&t;*/
DECL|member|unit
r_int
id|unit
suffix:semicolon
multiline_comment|/* Unit number                       */
DECL|member|chip_name
r_char
id|chip_name
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Chip name                         */
DECL|member|inst_name
r_char
id|inst_name
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Instance name                     */
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* Timer link header                 */
DECL|member|ncr_cache
r_int
id|ncr_cache
suffix:semicolon
multiline_comment|/* Cache test variable               */
DECL|member|waiting_list
id|Scsi_Cmnd
op_star
id|waiting_list
suffix:semicolon
multiline_comment|/* Waiting list header for commands  */
multiline_comment|/* that we can&squot;t put into the squeue */
DECL|member|settle_time
id|u_long
id|settle_time
suffix:semicolon
multiline_comment|/* Reset in progess&t;&t;     */
DECL|member|release_stage
id|u_char
id|release_stage
suffix:semicolon
multiline_comment|/* Synchronisation stage on release  */
DECL|member|verbose
id|u_char
id|verbose
suffix:semicolon
multiline_comment|/* Boot verbosity for this controller*/
macro_line|#ifdef&t;SCSI_NCR_DEBUG_ERROR_RECOVERY_SUPPORT
DECL|member|debug_error_recovery
id|u_char
id|debug_error_recovery
suffix:semicolon
DECL|member|stalling
id|u_char
id|stalling
suffix:semicolon
DECL|member|assert_atn
id|u_char
id|assert_atn
suffix:semicolon
macro_line|#endif
multiline_comment|/*-----------------------------------------------&n;&t;**&t;Added field to support differences&n;&t;**&t;between ncr chips.&n;&t;**&t;sv_xxx are some io register bit value at start-up and&n;&t;**&t;so assumed to have been set by the sdms bios.&n;&t;**&t;rv_xxx are the bit fields of io register that will keep &n;&t;**&t;the features used by the driver.&n;&t;**-----------------------------------------------&n;&t;*/
DECL|member|device_id
id|u_short
id|device_id
suffix:semicolon
DECL|member|revision_id
id|u_char
id|revision_id
suffix:semicolon
DECL|member|sv_scntl0
id|u_char
id|sv_scntl0
suffix:semicolon
DECL|member|sv_scntl3
id|u_char
id|sv_scntl3
suffix:semicolon
DECL|member|sv_dmode
id|u_char
id|sv_dmode
suffix:semicolon
DECL|member|sv_dcntl
id|u_char
id|sv_dcntl
suffix:semicolon
DECL|member|sv_ctest3
id|u_char
id|sv_ctest3
suffix:semicolon
DECL|member|sv_ctest4
id|u_char
id|sv_ctest4
suffix:semicolon
DECL|member|sv_ctest5
id|u_char
id|sv_ctest5
suffix:semicolon
DECL|member|sv_gpcntl
id|u_char
id|sv_gpcntl
suffix:semicolon
DECL|member|sv_stest2
id|u_char
id|sv_stest2
suffix:semicolon
DECL|member|sv_stest4
id|u_char
id|sv_stest4
suffix:semicolon
DECL|member|rv_scntl0
id|u_char
id|rv_scntl0
suffix:semicolon
DECL|member|rv_scntl3
id|u_char
id|rv_scntl3
suffix:semicolon
DECL|member|rv_dmode
id|u_char
id|rv_dmode
suffix:semicolon
DECL|member|rv_dcntl
id|u_char
id|rv_dcntl
suffix:semicolon
DECL|member|rv_ctest3
id|u_char
id|rv_ctest3
suffix:semicolon
DECL|member|rv_ctest4
id|u_char
id|rv_ctest4
suffix:semicolon
DECL|member|rv_ctest5
id|u_char
id|rv_ctest5
suffix:semicolon
DECL|member|rv_stest2
id|u_char
id|rv_stest2
suffix:semicolon
DECL|member|scsi_mode
id|u_char
id|scsi_mode
suffix:semicolon
multiline_comment|/*-----------------------------------------------&n;&t;**&t;Scripts ..&n;&t;**-----------------------------------------------&n;&t;**&n;&t;**&t;During reselection the ncr jumps to this point.&n;&t;**&t;The SFBR register is loaded with the encoded target id.&n;&t;**&n;&t;**&t;Jump to the first target.&n;&t;**&n;&t;**&t;JUMP&n;&t;**&t;@(next tcb)&n;&t;*/
DECL|member|jump_tcb
r_struct
id|link
id|jump_tcb
suffix:semicolon
multiline_comment|/*-----------------------------------------------&n;&t;**&t;Configuration ..&n;&t;**-----------------------------------------------&n;&t;**&n;&t;**&t;virtual and physical addresses&n;&t;**&t;of the 53c810 chip.&n;&t;*/
DECL|member|vaddr
id|vm_offset_t
id|vaddr
suffix:semicolon
DECL|member|paddr
id|vm_offset_t
id|paddr
suffix:semicolon
DECL|member|vaddr2
id|vm_offset_t
id|vaddr2
suffix:semicolon
DECL|member|paddr2
id|vm_offset_t
id|paddr2
suffix:semicolon
multiline_comment|/*&n;&t;**&t;pointer to the chip&squot;s registers.&n;&t;*/
r_volatile
DECL|member|reg
r_struct
id|ncr_reg
op_star
id|reg
suffix:semicolon
multiline_comment|/*&n;&t;**&t;A copy of the scripts, relocated for this ncb.&n;&t;*/
DECL|member|script0
r_struct
id|script
op_star
id|script0
suffix:semicolon
DECL|member|scripth0
r_struct
id|scripth
op_star
id|scripth0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Scripts instance virtual address.&n;&t;*/
DECL|member|script
r_struct
id|script
op_star
id|script
suffix:semicolon
DECL|member|scripth
r_struct
id|scripth
op_star
id|scripth
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Scripts instance physical address.&n;&t;*/
DECL|member|p_script
id|u_long
id|p_script
suffix:semicolon
DECL|member|p_scripth
id|u_long
id|p_scripth
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The SCSI address of the host adapter.&n;&t;*/
DECL|member|myaddr
id|u_char
id|myaddr
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Max dwords burst supported by the adapter.&n;&t;*/
DECL|member|maxburst
id|u_char
id|maxburst
suffix:semicolon
multiline_comment|/* log base 2 of dwords burst&t;*/
multiline_comment|/*&n;&t;**&t;timing parameters&n;&t;*/
DECL|member|minsync
id|u_char
id|minsync
suffix:semicolon
multiline_comment|/* Minimum sync period factor&t;*/
DECL|member|maxsync
id|u_char
id|maxsync
suffix:semicolon
multiline_comment|/* Maximum sync period factor&t;*/
DECL|member|maxoffs
id|u_char
id|maxoffs
suffix:semicolon
multiline_comment|/* Max scsi offset&t;&t;*/
DECL|member|multiplier
id|u_char
id|multiplier
suffix:semicolon
multiline_comment|/* Clock multiplier (1,2,4)&t;*/
DECL|member|clock_divn
id|u_char
id|clock_divn
suffix:semicolon
multiline_comment|/* Number of clock divisors&t;*/
DECL|member|clock_khz
id|u_long
id|clock_khz
suffix:semicolon
multiline_comment|/* SCSI clock frequency in KHz&t;*/
DECL|member|features
id|u_int
id|features
suffix:semicolon
multiline_comment|/* Chip features map&t;&t;*/
multiline_comment|/*-----------------------------------------------&n;&t;**&t;Link to the generic SCSI driver&n;&t;**-----------------------------------------------&n;&t;*/
multiline_comment|/* struct scsi_link&t;sc_link; */
multiline_comment|/*-----------------------------------------------&n;&t;**&t;Job control&n;&t;**-----------------------------------------------&n;&t;**&n;&t;**&t;Commands from user&n;&t;*/
DECL|member|user
r_struct
id|usrcmd
id|user
suffix:semicolon
DECL|member|order
id|u_char
id|order
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Target data&n;&t;*/
DECL|member|target
r_struct
id|tcb
id|target
(braket
id|MAX_TARGET
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Start queue.&n;&t;*/
DECL|member|squeue
id|u_int32
id|squeue
(braket
id|MAX_START
)braket
suffix:semicolon
DECL|member|squeueput
id|u_short
id|squeueput
suffix:semicolon
DECL|member|actccbs
id|u_short
id|actccbs
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Timeout handler&n;&t;*/
DECL|member|heartbeat
id|u_long
id|heartbeat
suffix:semicolon
DECL|member|ticks
id|u_short
id|ticks
suffix:semicolon
DECL|member|latetime
id|u_short
id|latetime
suffix:semicolon
DECL|member|lasttime
id|u_long
id|lasttime
suffix:semicolon
multiline_comment|/*-----------------------------------------------&n;&t;**&t;Debug and profiling&n;&t;**-----------------------------------------------&n;&t;**&n;&t;**&t;register dump&n;&t;*/
DECL|member|regdump
r_struct
id|ncr_reg
id|regdump
suffix:semicolon
DECL|member|regtime
id|u_long
id|regtime
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Profiling data&n;&t;*/
DECL|member|profile
r_struct
id|profile
id|profile
suffix:semicolon
DECL|member|disc_phys
id|u_long
id|disc_phys
suffix:semicolon
DECL|member|disc_ref
id|u_long
id|disc_ref
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The global control block.&n;&t;**&t;It&squot;s used only during the configuration phase.&n;&t;**&t;A target control block will be created&n;&t;**&t;after the first successful transfer.&n;&t;*/
DECL|member|ccb
r_struct
id|ccb
op_star
id|ccb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;message buffers.&n;&t;**&t;Should be longword aligned,&n;&t;**&t;because they&squot;re written with a&n;&t;**&t;COPY script command.&n;&t;*/
DECL|member|msgout
id|u_char
id|msgout
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|msgin
id|u_char
id|msgin
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|lastmsg
id|u_int32
id|lastmsg
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Buffer for STATUS_IN phase.&n;&t;*/
DECL|member|scratch
id|u_char
id|scratch
suffix:semicolon
multiline_comment|/*&n;&t;**&t;controller chip dependent maximal transfer width.&n;&t;*/
DECL|member|maxwide
id|u_char
id|maxwide
suffix:semicolon
multiline_comment|/*&n;&t;**&t;option for M_IDENTIFY message: enables disconnecting&n;&t;*/
DECL|member|disc
id|u_char
id|disc
suffix:semicolon
multiline_comment|/*&n;&t;**&t;address of the ncr control registers in io space&n;&t;*/
DECL|member|port
id|u_int
id|port
suffix:semicolon
multiline_comment|/*&n;&t;**&t;irq level&n;&t;*/
DECL|member|irq
id|u_short
id|irq
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|NCB_SCRIPT_PHYS
mdefine_line|#define NCB_SCRIPT_PHYS(np,lbl)&t; (np-&gt;p_script  + offsetof (struct script, lbl))
DECL|macro|NCB_SCRIPTH_PHYS
mdefine_line|#define NCB_SCRIPTH_PHYS(np,lbl) (np-&gt;p_scripth + offsetof (struct scripth, lbl))
multiline_comment|/*==========================================================&n;**&n;**&n;**      Script for NCR-Processor.&n;**&n;**&t;Use ncr_script_fill() to create the variable parts.&n;**&t;Use ncr_script_copy_and_bind() to make a copy and&n;**&t;bind to physical addresses.&n;**&n;**&n;**==========================================================&n;**&n;**&t;We have to know the offsets of all labels before&n;**&t;we reach them (for forward jumps).&n;**&t;Therefore we declare a struct here.&n;**&t;If you make changes inside the script,&n;**&t;DONT FORGET TO CHANGE THE LENGTHS HERE!&n;**&n;**----------------------------------------------------------&n;*/
multiline_comment|/*&n;**&t;Script fragments which are loaded into the on-board RAM &n;**&t;of 825A, 875 and 895 chips.&n;*/
DECL|struct|script
r_struct
id|script
(brace
DECL|member|start
id|ncrcmd
id|start
(braket
l_int|7
)braket
suffix:semicolon
DECL|member|start0
id|ncrcmd
id|start0
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|start1
id|ncrcmd
id|start1
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|startpos
id|ncrcmd
id|startpos
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|trysel
id|ncrcmd
id|trysel
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|skip
id|ncrcmd
id|skip
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|skip2
id|ncrcmd
id|skip2
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|idle
id|ncrcmd
id|idle
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|select
id|ncrcmd
id|select
(braket
l_int|22
)braket
suffix:semicolon
DECL|member|prepare
id|ncrcmd
id|prepare
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|loadpos
id|ncrcmd
id|loadpos
(braket
l_int|14
)braket
suffix:semicolon
DECL|member|prepare2
id|ncrcmd
id|prepare2
(braket
l_int|24
)braket
suffix:semicolon
DECL|member|setmsg
id|ncrcmd
id|setmsg
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|clrack
id|ncrcmd
id|clrack
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|dispatch
id|ncrcmd
id|dispatch
(braket
l_int|33
)braket
suffix:semicolon
DECL|member|no_data
id|ncrcmd
id|no_data
(braket
l_int|17
)braket
suffix:semicolon
DECL|member|checkatn
id|ncrcmd
id|checkatn
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|command
id|ncrcmd
id|command
(braket
l_int|15
)braket
suffix:semicolon
DECL|member|status
id|ncrcmd
id|status
(braket
l_int|27
)braket
suffix:semicolon
DECL|member|msg_in
id|ncrcmd
id|msg_in
(braket
l_int|26
)braket
suffix:semicolon
DECL|member|msg_bad
id|ncrcmd
id|msg_bad
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|complete
id|ncrcmd
id|complete
(braket
l_int|13
)braket
suffix:semicolon
DECL|member|cleanup
id|ncrcmd
id|cleanup
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|cleanup0
id|ncrcmd
id|cleanup0
(braket
l_int|11
)braket
suffix:semicolon
DECL|member|signal
id|ncrcmd
id|signal
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|save_dp
id|ncrcmd
id|save_dp
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|restore_dp
id|ncrcmd
id|restore_dp
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|disconnect
id|ncrcmd
id|disconnect
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|disconnect0
id|ncrcmd
id|disconnect0
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|disconnect1
id|ncrcmd
id|disconnect1
(braket
l_int|23
)braket
suffix:semicolon
DECL|member|msg_out
id|ncrcmd
id|msg_out
(braket
l_int|9
)braket
suffix:semicolon
DECL|member|msg_out_done
id|ncrcmd
id|msg_out_done
(braket
l_int|7
)braket
suffix:semicolon
DECL|member|badgetcc
id|ncrcmd
id|badgetcc
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|reselect
id|ncrcmd
id|reselect
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|reselect1
id|ncrcmd
id|reselect1
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|reselect2
id|ncrcmd
id|reselect2
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|resel_tmp
id|ncrcmd
id|resel_tmp
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|resel_lun
id|ncrcmd
id|resel_lun
(braket
l_int|18
)braket
suffix:semicolon
DECL|member|resel_tag
id|ncrcmd
id|resel_tag
(braket
l_int|24
)braket
suffix:semicolon
DECL|member|data_io
id|ncrcmd
id|data_io
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|data_in
id|ncrcmd
id|data_in
(braket
id|MAX_SCATTER
op_star
l_int|4
op_plus
l_int|4
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;Script fragments which stay in main memory for all chips.&n;*/
DECL|struct|scripth
r_struct
id|scripth
(brace
DECL|member|tryloop
id|ncrcmd
id|tryloop
(braket
id|MAX_START
op_star
l_int|5
op_plus
l_int|2
)braket
suffix:semicolon
DECL|member|msg_parity
id|ncrcmd
id|msg_parity
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|msg_reject
id|ncrcmd
id|msg_reject
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|msg_ign_residue
id|ncrcmd
id|msg_ign_residue
(braket
l_int|32
)braket
suffix:semicolon
DECL|member|msg_extended
id|ncrcmd
id|msg_extended
(braket
l_int|18
)braket
suffix:semicolon
DECL|member|msg_ext_2
id|ncrcmd
id|msg_ext_2
(braket
l_int|18
)braket
suffix:semicolon
DECL|member|msg_wdtr
id|ncrcmd
id|msg_wdtr
(braket
l_int|27
)braket
suffix:semicolon
DECL|member|msg_ext_3
id|ncrcmd
id|msg_ext_3
(braket
l_int|18
)braket
suffix:semicolon
DECL|member|msg_sdtr
id|ncrcmd
id|msg_sdtr
(braket
l_int|27
)braket
suffix:semicolon
DECL|member|msg_out_abort
id|ncrcmd
id|msg_out_abort
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|getcc
id|ncrcmd
id|getcc
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|getcc1
id|ncrcmd
id|getcc1
(braket
l_int|5
)braket
suffix:semicolon
macro_line|#ifdef NCR_GETCC_WITHMSG
DECL|member|getcc2
id|ncrcmd
id|getcc2
(braket
l_int|33
)braket
suffix:semicolon
macro_line|#else
DECL|member|getcc2
id|ncrcmd
id|getcc2
(braket
l_int|14
)braket
suffix:semicolon
macro_line|#endif
DECL|member|getcc3
id|ncrcmd
id|getcc3
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|data_out
id|ncrcmd
id|data_out
(braket
id|MAX_SCATTER
op_star
l_int|4
op_plus
l_int|4
)braket
suffix:semicolon
DECL|member|aborttag
id|ncrcmd
id|aborttag
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|abort
id|ncrcmd
m_abort
(braket
l_int|22
)braket
suffix:semicolon
DECL|member|snooptest
id|ncrcmd
id|snooptest
(braket
l_int|9
)braket
suffix:semicolon
DECL|member|snoopend
id|ncrcmd
id|snoopend
(braket
l_int|2
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&n;**      Function headers.&n;**&n;**&n;**==========================================================&n;*/
r_static
r_void
id|ncr_alloc_ccb
(paren
id|ncb_p
id|np
comma
id|u_long
id|t
comma
id|u_long
id|l
)paren
suffix:semicolon
r_static
r_void
id|ncr_complete
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
r_static
r_void
id|ncr_exception
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_free_ccb
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_long
id|t
comma
id|u_long
id|l
)paren
suffix:semicolon
r_static
r_void
id|ncr_getclock
(paren
id|ncb_p
id|np
comma
r_int
id|mult
)paren
suffix:semicolon
r_static
r_void
id|ncr_selectclock
(paren
id|ncb_p
id|np
comma
id|u_char
id|scntl3
)paren
suffix:semicolon
r_static
id|ccb_p
id|ncr_get_ccb
(paren
id|ncb_p
id|np
comma
id|u_long
id|t
comma
id|u_long
id|l
)paren
suffix:semicolon
r_static
r_void
id|ncr_init
(paren
id|ncb_p
id|np
comma
r_char
op_star
id|msg
comma
id|u_long
id|code
)paren
suffix:semicolon
r_static
r_int
id|ncr_int_sbmc
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_int
id|ncr_int_par
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_ma
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_sir
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_sto
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
id|u_long
id|ncr_lookup
(paren
r_char
op_star
id|id
)paren
suffix:semicolon
r_static
r_void
id|ncr_negotiate
(paren
r_struct
id|ncb
op_star
id|np
comma
r_struct
id|tcb
op_star
id|tp
)paren
suffix:semicolon
r_static
r_void
id|ncr_opennings
(paren
id|ncb_p
id|np
comma
id|lcb_p
id|lp
comma
id|Scsi_Cmnd
op_star
id|xp
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
r_static
r_void
id|ncb_profile
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|ncr_script_copy_and_bind
(paren
id|ncb_p
id|np
comma
id|ncrcmd
op_star
id|src
comma
id|ncrcmd
op_star
id|dst
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_void
id|ncr_script_fill
(paren
r_struct
id|script
op_star
id|scr
comma
r_struct
id|scripth
op_star
id|scripth
)paren
suffix:semicolon
r_static
r_int
id|ncr_scatter
(paren
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|ncr_setmaxtags
(paren
id|ncb_p
id|np
comma
id|tcb_p
id|tp
comma
id|u_long
id|numtags
)paren
suffix:semicolon
r_static
r_void
id|ncr_getsync
(paren
id|ncb_p
id|np
comma
id|u_char
id|sfac
comma
id|u_char
op_star
id|fakp
comma
id|u_char
op_star
id|scntl3p
)paren
suffix:semicolon
r_static
r_void
id|ncr_setsync
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|scntl3
comma
id|u_char
id|sxfer
)paren
suffix:semicolon
r_static
r_void
id|ncr_settags
(paren
id|tcb_p
id|tp
comma
id|lcb_p
id|lp
)paren
suffix:semicolon
r_static
r_void
id|ncr_setwide
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|wide
comma
id|u_char
id|ack
)paren
suffix:semicolon
r_static
r_int
id|ncr_show_msg
(paren
id|u_char
op_star
id|msg
)paren
suffix:semicolon
r_static
r_int
id|ncr_snooptest
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_timeout
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_wakeup
(paren
id|ncb_p
id|np
comma
id|u_long
id|code
)paren
suffix:semicolon
r_static
r_void
id|ncr_start_reset
(paren
id|ncb_p
id|np
comma
r_int
id|settle_delay
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_USER_COMMAND_SUPPORT
r_static
r_void
id|ncr_usercmd
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|ncr_attach
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|unit
comma
id|ncr_device
op_star
id|device
)paren
suffix:semicolon
r_static
r_void
id|insert_into_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
id|Scsi_Cmnd
op_star
id|retrieve_from_waiting_list
c_func
(paren
r_int
id|to_remove
comma
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|process_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|sts
)paren
suffix:semicolon
DECL|macro|remove_from_waiting_list
mdefine_line|#define remove_from_waiting_list(np, cmd) &bslash;&n;&t;&t;retrieve_from_waiting_list(1, (np), (cmd))
DECL|macro|requeue_waiting_list
mdefine_line|#define requeue_waiting_list(np) process_waiting_list((np), DID_OK)
DECL|macro|reset_waiting_list
mdefine_line|#define reset_waiting_list(np) process_waiting_list((np), DID_RESET)
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_static
r_int
id|ncr_get_Symbios_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|Symbios_nvram
op_star
id|nvram
)paren
suffix:semicolon
r_static
r_int
id|ncr_get_Tekram_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|Tekram_nvram
op_star
id|nvram
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&n;**      Global static data.&n;**&n;**&n;**==========================================================&n;*/
macro_line|#ifdef SCSI_NCR_DEBUG_INFO_SUPPORT
DECL|variable|ncr_debug
r_static
r_int
id|ncr_debug
op_assign
id|SCSI_NCR_DEBUG_FLAGS
suffix:semicolon
macro_line|#endif
DECL|function|ncr_name
r_static
r_inline
r_char
op_star
id|ncr_name
(paren
id|ncb_p
id|np
)paren
(brace
r_return
id|np-&gt;inst_name
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      Scripts for NCR-Processor.&n;**&n;**      Use ncr_script_bind for binding to physical addresses.&n;**&n;**&n;**==========================================================&n;**&n;**&t;NADDR generates a reference to a field of the controller data.&n;**&t;PADDR generates a reference to another part of the script.&n;**&t;RADDR generates a reference to a script processor register.&n;**&t;FADDR generates a reference to a script processor register&n;**&t;&t;with offset.&n;**&n;**----------------------------------------------------------&n;*/
DECL|macro|RELOC_SOFTC
mdefine_line|#define&t;RELOC_SOFTC&t;0x40000000
DECL|macro|RELOC_LABEL
mdefine_line|#define&t;RELOC_LABEL&t;0x50000000
DECL|macro|RELOC_REGISTER
mdefine_line|#define&t;RELOC_REGISTER&t;0x60000000
DECL|macro|RELOC_KVAR
mdefine_line|#define&t;RELOC_KVAR&t;0x70000000
DECL|macro|RELOC_LABELH
mdefine_line|#define&t;RELOC_LABELH&t;0x80000000
DECL|macro|RELOC_MASK
mdefine_line|#define&t;RELOC_MASK&t;0xf0000000
DECL|macro|NADDR
mdefine_line|#define&t;NADDR(label)&t;(RELOC_SOFTC | offsetof(struct ncb, label))
DECL|macro|PADDR
mdefine_line|#define PADDR(label)    (RELOC_LABEL | offsetof(struct script, label))
DECL|macro|PADDRH
mdefine_line|#define PADDRH(label)   (RELOC_LABELH | offsetof(struct scripth, label))
DECL|macro|RADDR
mdefine_line|#define&t;RADDR(label)&t;(RELOC_REGISTER | REG(label))
DECL|macro|FADDR
mdefine_line|#define&t;FADDR(label,ofs)(RELOC_REGISTER | ((REG(label))+(ofs)))
DECL|macro|KVAR
mdefine_line|#define&t;KVAR(which)&t;(RELOC_KVAR | (which))
DECL|macro|SCRIPT_KVAR_JIFFIES
mdefine_line|#define&t;SCRIPT_KVAR_JIFFIES&t;(0)
DECL|macro|SCRIPT_KVAR_FIRST
mdefine_line|#define&t;SCRIPT_KVAR_FIRST&t;&t;SCRIPT_KVAR_JIFFIES
DECL|macro|SCRIPT_KVAR_LAST
mdefine_line|#define&t;SCRIPT_KVAR_LAST&t;&t;SCRIPT_KVAR_JIFFIES
multiline_comment|/*&n; * Kernel variables referenced in the scripts.&n; * THESE MUST ALL BE ALIGNED TO A 4-BYTE BOUNDARY.&n; */
DECL|variable|__initdata
r_static
r_void
op_star
id|script_kvars
(braket
)braket
id|__initdata
op_assign
(brace
(paren
r_void
op_star
)paren
op_amp
id|jiffies
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_struct
id|script
id|script0
id|__initdata
op_assign
(brace
multiline_comment|/*--------------------------&lt; START &gt;-----------------------*/
(brace
multiline_comment|/*&n;&t;**&t;Claim to be still alive ...&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
(paren
(paren
r_struct
id|ncb
op_star
)paren
l_int|0
)paren
op_member_access_from_pointer
id|heartbeat
)paren
)paren
comma
id|KVAR
c_func
(paren
id|SCRIPT_KVAR_JIFFIES
)paren
comma
id|NADDR
(paren
id|heartbeat
)paren
comma
multiline_comment|/*&n;&t;**      Make data structure address invalid.&n;&t;**      clear SIGP.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|dsa
comma
l_int|0xff
)paren
comma
l_int|0
comma
id|SCR_FROM_REG
(paren
id|ctest2
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; START0 &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Hook for interrupted GetConditionCode.&n;&t;**&t;Will be patched to ... IFTRUE by&n;&t;**&t;the interrupt handler.&n;&t;*/
id|SCR_INT
op_xor
id|IFFALSE
(paren
l_int|0
)paren
comma
id|SIR_SENSE_RESTART
comma
)brace
multiline_comment|/*-------------------------&lt; START1 &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Hook for stalled start queue.&n;&t;**&t;Will be patched to IFTRUE by the interrupt handler.&n;&t;*/
id|SCR_INT
op_xor
id|IFFALSE
(paren
l_int|0
)paren
comma
id|SIR_STALL_RESTART
comma
multiline_comment|/*&n;&t;**&t;Then jump to a certain point in tryloop.&n;&t;**&t;Due to the lack of indirect addressing the code&n;&t;**&t;is self modifying here.&n;&t;*/
id|SCR_JUMP
comma
)brace
multiline_comment|/*-------------------------&lt; STARTPOS &gt;--------------------*/
comma
(brace
id|PADDRH
c_func
(paren
id|tryloop
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; TRYSEL &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Now:&n;&t;**&t;DSA: Address of a Data Structure&n;&t;**&t;or   Address of the IDLE-Label.&n;&t;**&n;&t;**&t;TEMP:&t;Address of a script, which tries to&n;&t;**&t;&t;start the NEXT entry.&n;&t;**&n;&t;**&t;Save the TEMP register into the SCRATCHA register.&n;&t;**&t;Then copy the DSA to TEMP and RETURN.&n;&t;**&t;This is kind of an indirect jump.&n;&t;**&t;(The script processor has NO stack, so the&n;&t;**&t;CALL is actually a jump and link, and the&n;&t;**&t;RETURN is an indirect jump.)&n;&t;**&n;&t;**&t;If the slot was empty, DSA contains the address&n;&t;**&t;of the IDLE part of this script. The processor&n;&t;**&t;jumps to IDLE and waits for a reselect.&n;&t;**&t;It will wake up and try the same slot again&n;&t;**&t;after the SIGP bit becomes set by the host.&n;&t;**&n;&t;**&t;If the slot was not empty, DSA contains&n;&t;**&t;the address of the phys-part of a ccb.&n;&t;**&t;The processor jumps to this address.&n;&t;**&t;phys starts with head,&n;&t;**&t;head starts with launch,&n;&t;**&t;so actually the processor jumps to&n;&t;**&t;the lauch part.&n;&t;**&t;If the entry is scheduled for execution,&n;&t;**&t;then launch contains a jump to SELECT.&n;&t;**&t;If it&squot;s not scheduled, it contains a jump to IDLE.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|dsa
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|SCR_RETURN
comma
l_int|0
)brace
multiline_comment|/*-------------------------&lt; SKIP &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;This entry has been canceled.&n;&t;**&t;Next time use the next slot.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|PADDR
(paren
id|startpos
)paren
comma
multiline_comment|/*&n;&t;**&t;patch the launch field.&n;&t;**&t;should look like an idle process.&n;&t;*/
id|SCR_COPY_F
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|dsa
)paren
comma
id|PADDR
(paren
id|skip2
)paren
comma
id|SCR_COPY
(paren
l_int|8
)paren
comma
id|PADDR
(paren
id|idle
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SKIP2 &gt;-----------------------*/
comma
(brace
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
c_func
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; IDLE &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Nothing to do?&n;&t;**&t;Wait for reselect.&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
c_func
(paren
id|reselect
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SELECT &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;DSA&t;contains the address of a scheduled&n;&t;**&t;&t;data structure.&n;&t;**&n;&t;**&t;SCRATCHA contains the address of the script,&n;&t;**&t;&t;which starts the next entry.&n;&t;**&n;&t;**&t;Set Initiator mode.&n;&t;**&n;&t;**&t;(Target mode is left as an exercise for the reader)&n;&t;*/
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
l_int|0xff
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**      And try to select this target.&n;&t;*/
id|SCR_SEL_TBL_ATN
op_xor
m_offsetof
(paren
r_struct
id|dsb
comma
id|select
)paren
comma
id|PADDR
(paren
id|reselect
)paren
comma
multiline_comment|/*&n;&t;**&t;Now there are 4 possibilities:&n;&t;**&n;&t;**&t;(1) The ncr looses arbitration.&n;&t;**&t;This is ok, because it will try again,&n;&t;**&t;when the bus becomes idle.&n;&t;**&t;(But beware of the timeout function!)&n;&t;**&n;&t;**&t;(2) The ncr is reselected.&n;&t;**&t;Then the script processor takes the jump&n;&t;**&t;to the RESELECT label.&n;&t;**&n;&t;**&t;(3) The ncr completes the selection.&n;&t;**&t;Then it will execute the next statement.&n;&t;**&n;&t;**&t;(4) There is a selection timeout.&n;&t;**&t;Then the ncr should interrupt the host and stop.&n;&t;**&t;Unfortunately, it seems to continue execution&n;&t;**&t;of the script. But it will fail with an&n;&t;**&t;IID-interrupt on the next WHEN.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Save target id to ctest0 register&n;&t;*/
id|SCR_FROM_REG
(paren
id|sdid
)paren
comma
l_int|0
comma
id|SCR_TO_REG
(paren
id|ctest0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Send the IDENTIFY and SIMPLE_TAG messages&n;&t;**&t;(and the M_X_SYNC_REQ message)&n;&t;*/
id|SCR_MOVE_TBL
op_xor
id|SCR_MSG_OUT
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|smsg
)paren
comma
macro_line|#ifdef undef /* XXX better fail than try to deal with this ... */
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
op_minus
l_int|16
comma
macro_line|#endif
id|SCR_CLR
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|sfbr
)paren
comma
id|NADDR
(paren
id|lastmsg
)paren
comma
multiline_comment|/*&n;&t;**&t;Selection complete.&n;&t;**&t;Next time use the next slot.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|PADDR
(paren
id|startpos
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PREPARE &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**      The ncr doesn&squot;t have an indirect load&n;&t;**&t;or store command. So we have to&n;&t;**&t;copy part of the control block to a&n;&t;**&t;fixed place, where we can access it.&n;&t;**&n;&t;**&t;We patch the address part of a&n;&t;**&t;COPY command with the DSA-register.&n;&t;*/
id|SCR_COPY_F
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|dsa
)paren
comma
id|PADDR
(paren
id|loadpos
)paren
comma
multiline_comment|/*&n;&t;**&t;then we do the actual copy.&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|head
)paren
)paren
comma
multiline_comment|/*&n;&t;**&t;continued after the next label ...&n;&t;*/
)brace
multiline_comment|/*-------------------------&lt; LOADPOS &gt;---------------------*/
comma
(brace
l_int|0
comma
id|NADDR
(paren
id|header
)paren
comma
multiline_comment|/*&n;&t;**      Mark this ccb as not scheduled.&n;&t;*/
id|SCR_COPY
(paren
l_int|8
)paren
comma
id|PADDR
(paren
id|idle
)paren
comma
id|NADDR
(paren
id|header.launch
)paren
comma
multiline_comment|/*&n;&t;**      Set a time stamp for this selection&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
id|u_long
)paren
)paren
comma
id|KVAR
c_func
(paren
id|SCRIPT_KVAR_JIFFIES
)paren
comma
id|NADDR
(paren
id|header.stamp.select
)paren
comma
multiline_comment|/*&n;&t;**      load the savep (saved pointer) into&n;&t;**      the TEMP register (actual pointer)&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|header.savep
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
multiline_comment|/*&n;&t;**      Initialize the status registers&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|header.status
)paren
comma
id|RADDR
(paren
id|scr0
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PREPARE2 &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t;**      Load the synchronous mode register&n;&t;*/
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|NADDR
(paren
id|sync_st
)paren
comma
id|RADDR
(paren
id|sxfer
)paren
comma
multiline_comment|/*&n;&t;**      Load the wide mode and timing register&n;&t;*/
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|NADDR
(paren
id|wide_st
)paren
comma
id|RADDR
(paren
id|scntl3
)paren
comma
multiline_comment|/*&n;&t;**&t;Initialize the msgout buffer with a NOOP message.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_NOOP
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|msgin
)paren
comma
multiline_comment|/*&n;&t;**&t;Message in phase ?&n;&t;*/
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;Extended or reject message ?&n;&t;*/
id|SCR_FROM_REG
(paren
id|sbdl
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_EXTENDED
)paren
)paren
comma
id|PADDR
(paren
id|msg_in
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_REJECT
)paren
)paren
comma
id|PADDRH
(paren
id|msg_reject
)paren
comma
multiline_comment|/*&n;&t;**&t;normal processing&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SETMSG &gt;----------------------*/
comma
(brace
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; CLRACK &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Terminate possible pending message phase.&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-----------------------&lt; DISPATCH &gt;----------------------*/
comma
(brace
id|SCR_FROM_REG
(paren
id|HS_REG
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|HS_NEGOTIATE
)paren
)paren
comma
id|SIR_NEGO_FAILED
comma
multiline_comment|/*&n;&t;**&t;remove bogus output signals&n;&t;*/
id|SCR_REG_REG
(paren
id|socl
comma
id|SCR_AND
comma
id|CACK
op_or
id|CATN
)paren
comma
l_int|0
comma
id|SCR_RETURN
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
l_int|0
comma
id|SCR_RETURN
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_DATA_IN
)paren
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR
(paren
id|msg_out
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|msg_in
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_COMMAND
)paren
)paren
comma
id|PADDR
(paren
id|command
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_STATUS
)paren
)paren
comma
id|PADDR
(paren
id|status
)paren
comma
multiline_comment|/*&n;&t;**      Discard one illegal phase byte, if required.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|XE_BAD_PHASE
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|xerr_st
)paren
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|IF
(paren
id|SCR_ILG_OUT
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_ILG_OUT
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|IF
(paren
id|SCR_ILG_IN
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_ILG_IN
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; NO_DATA &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;The target wants to tranfer too much data&n;&t;**&t;or in the wrong direction.&n;&t;**      Remember that in extended error.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|XE_EXTRA_DATA
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|xerr_st
)paren
comma
multiline_comment|/*&n;&t;**      Discard one data byte, if required.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_DATA_OUT
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|IF
(paren
id|SCR_DATA_IN
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_DATA_IN
comma
id|NADDR
(paren
id|scratch
)paren
comma
multiline_comment|/*&n;&t;**      .. and repeat as required.&n;&t;*/
id|SCR_CALL
comma
id|PADDR
(paren
id|dispatch
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|no_data
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; CHECKATN &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;If AAP (bit 1 of scntl0 register) is set&n;&t;**&t;and a parity error is detected,&n;&t;**&t;the script processor asserts ATN.&n;&t;**&n;&t;**&t;The target should switch to a MSG_OUT phase&n;&t;**&t;to get the message.&n;&t;*/
id|SCR_FROM_REG
(paren
id|socl
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|CATN
comma
id|CATN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;count it&n;&t;*/
id|SCR_REG_REG
(paren
id|PS_REG
comma
id|SCR_ADD
comma
l_int|1
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Prepare a M_ID_ERROR message&n;&t;**&t;(initiator detected error).&n;&t;**&t;The target should retry the transfer.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_ID_ERROR
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|setmsg
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; COMMAND &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;If this is not a GETCC transfer ...&n;&t;*/
id|SCR_FROM_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|S_CHECK_COND
)paren
)paren
comma
l_int|28
comma
multiline_comment|/*&n;&t;**&t;... set a timestamp ...&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
id|u_long
)paren
)paren
comma
id|KVAR
c_func
(paren
id|SCRIPT_KVAR_JIFFIES
)paren
comma
id|NADDR
(paren
id|header.stamp.command
)paren
comma
multiline_comment|/*&n;&t;**&t;... and send the command&n;&t;*/
id|SCR_MOVE_TBL
op_xor
id|SCR_COMMAND
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|cmd
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;Send the GETCC command&n;&t;*/
multiline_comment|/*&gt;&gt;&gt;*/
id|SCR_MOVE_TBL
op_xor
id|SCR_COMMAND
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|scmd
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; STATUS &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;set the timestamp.&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
id|u_long
)paren
)paren
comma
id|KVAR
c_func
(paren
id|SCRIPT_KVAR_JIFFIES
)paren
comma
id|NADDR
(paren
id|header.stamp.status
)paren
comma
multiline_comment|/*&n;&t;**&t;If this is a GETCC transfer,&n;&t;*/
id|SCR_FROM_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|S_CHECK_COND
)paren
)paren
comma
l_int|40
comma
multiline_comment|/*&n;&t;**&t;get the status&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_STATUS
comma
id|NADDR
(paren
id|scratch
)paren
comma
multiline_comment|/*&n;&t;**&t;Save status to scsi_status.&n;&t;**&t;Mark as complete.&n;&t;**&t;And wait for disconnect.&n;&t;*/
id|SCR_TO_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|SS_REG
comma
id|SCR_OR
comma
id|S_SENSE
)paren
comma
l_int|0
comma
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_COMPLETE
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|checkatn
)paren
comma
multiline_comment|/*&n;&t;**&t;If it was no GETCC transfer,&n;&t;**&t;save the status to scsi_status.&n;&t;*/
multiline_comment|/*&gt;&gt;&gt;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_STATUS
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_TO_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;if it was no check condition ...&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|S_CHECK_COND
)paren
)paren
comma
id|PADDR
(paren
id|checkatn
)paren
comma
multiline_comment|/*&n;&t;**&t;... mark as complete.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_COMPLETE
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|checkatn
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IN &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Get the first byte of the message&n;&t;**&t;and save it to SCRATCHA.&n;&t;**&n;&t;**&t;The script processor doesn&squot;t negate the&n;&t;**&t;ACK signal after this transfer.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|0
)braket
)paren
comma
multiline_comment|/*&n;&t;**&t;Check for message parity error.&n;&t;*/
id|SCR_TO_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_FROM_REG
(paren
id|socl
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|CATN
comma
id|CATN
)paren
)paren
comma
id|PADDRH
(paren
id|msg_parity
)paren
comma
id|SCR_FROM_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Parity was ok, handle this message.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_COMPLETE
)paren
)paren
comma
id|PADDR
(paren
id|complete
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_SAVE_DP
)paren
)paren
comma
id|PADDR
(paren
id|save_dp
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_RESTORE_DP
)paren
)paren
comma
id|PADDR
(paren
id|restore_dp
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_DISCONNECT
)paren
)paren
comma
id|PADDR
(paren
id|disconnect
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_EXTENDED
)paren
)paren
comma
id|PADDRH
(paren
id|msg_extended
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_NOOP
)paren
)paren
comma
id|PADDR
(paren
id|clrack
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_REJECT
)paren
)paren
comma
id|PADDRH
(paren
id|msg_reject
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_IGN_RESIDUE
)paren
)paren
comma
id|PADDRH
(paren
id|msg_ign_residue
)paren
comma
multiline_comment|/*&n;&t;**&t;Rest of the messages left as&n;&t;**&t;an exercise ...&n;&t;**&n;&t;**&t;Unimplemented messages:&n;&t;**&t;fall through to MSG_BAD.&n;&t;*/
)brace
multiline_comment|/*-------------------------&lt; MSG_BAD &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;unimplemented message - reject it.&n;&t;*/
id|SCR_INT
comma
id|SIR_REJECT_SENT
comma
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_REJECT
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|setmsg
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; COMPLETE &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Complete message.&n;&t;**&n;&t;**&t;If it&squot;s not the get condition code,&n;&t;**&t;copy TEMP register to LASTP in header.&n;&t;*/
id|SCR_FROM_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|S_SENSE
comma
id|S_SENSE
)paren
)paren
comma
l_int|12
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|NADDR
(paren
id|header.lastp
)paren
comma
multiline_comment|/*&gt;&gt;&gt;*/
multiline_comment|/*&n;&t;**&t;When we terminate the cycle by clearing ACK,&n;&t;**&t;the target may disconnect immediately.&n;&t;**&n;&t;**&t;We don&squot;t want to be told of an&n;&t;**&t;&quot;unexpected disconnect&quot;,&n;&t;**&t;so we disable this feature.&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Terminate cycle ...&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;... and wait for the disconnect.&n;&t;*/
id|SCR_WAIT_DISC
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; CLEANUP &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**      dsa:    Pointer to ccb&n;&t;**&t;      or xxxxxxFF (no ccb)&n;&t;**&n;&t;**      HS_REG:   Host-Status (&lt;&gt;0!)&n;&t;*/
id|SCR_FROM_REG
(paren
id|dsa
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
l_int|0xff
)paren
)paren
comma
id|PADDR
(paren
id|signal
)paren
comma
multiline_comment|/*&n;&t;**      dsa is valid.&n;&t;**&t;save the status registers&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|scr0
)paren
comma
id|NADDR
(paren
id|header.status
)paren
comma
multiline_comment|/*&n;&t;**&t;and copy back the header to the ccb.&n;&t;*/
id|SCR_COPY_F
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|dsa
)paren
comma
id|PADDR
(paren
id|cleanup0
)paren
comma
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|head
)paren
)paren
comma
id|NADDR
(paren
id|header
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; CLEANUP0 &gt;--------------------*/
comma
(brace
l_int|0
comma
multiline_comment|/*&n;&t;**&t;If command resulted in &quot;check condition&quot;&n;&t;**&t;status and is not yet completed,&n;&t;**&t;try to get the condition code.&n;&t;*/
id|SCR_FROM_REG
(paren
id|HS_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
l_int|0
comma
id|HS_DONEMASK
)paren
)paren
comma
l_int|16
comma
id|SCR_FROM_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|S_CHECK_COND
)paren
)paren
comma
id|PADDRH
c_func
(paren
id|getcc2
)paren
comma
multiline_comment|/*&n;&t;**&t;And make the DSA register invalid.&n;&t;*/
multiline_comment|/*&gt;&gt;&gt;*/
id|SCR_LOAD_REG
(paren
id|dsa
comma
l_int|0xff
)paren
comma
multiline_comment|/* invalid */
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; SIGNAL &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;if status = queue full,&n;&t;**&t;reinsert in startqueue and stall queue.&n;&t;*/
id|SCR_FROM_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|S_QUEUE_FULL
)paren
)paren
comma
id|SIR_STALL_QUEUE
comma
multiline_comment|/*&n;&t;**&t;if job completed ...&n;&t;*/
id|SCR_FROM_REG
(paren
id|HS_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;... signal completion to the host&n;&t;*/
id|SCR_INT_FLY
op_xor
id|IFFALSE
(paren
id|MASK
(paren
l_int|0
comma
id|HS_DONEMASK
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Auf zu neuen Schandtaten!&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
c_func
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SAVE_DP &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;SAVE_DP message:&n;&t;**&t;Copy TEMP register to SAVEP in header.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|NADDR
(paren
id|header.savep
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESTORE_DP &gt;---------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;RESTORE_DP message:&n;&t;**&t;Copy SAVEP in header to TEMP register.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|header.savep
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DISCONNECT &gt;---------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;If QUIRK_AUTOSAVE is set,&n;&t;**&t;do an &quot;save pointer&quot; operation.&n;&t;*/
id|SCR_FROM_REG
(paren
id|QU_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|QUIRK_AUTOSAVE
comma
id|QUIRK_AUTOSAVE
)paren
)paren
comma
l_int|12
comma
multiline_comment|/*&n;&t;**&t;like SAVE_DP message:&n;&t;**&t;Copy TEMP register to SAVEP in header.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|NADDR
(paren
id|header.savep
)paren
comma
multiline_comment|/*&gt;&gt;&gt;*/
multiline_comment|/*&n;&t;**&t;Check if temp==savep or temp==goalp:&n;&t;**&t;if not, log a missing save pointer message.&n;&t;**&t;In fact, it&squot;s a comparison mod 256.&n;&t;**&n;&t;**&t;Hmmm, I hadn&squot;t thought that I would be urged to&n;&t;**&t;write this kind of ugly self modifying code.&n;&t;**&n;&t;**&t;It&squot;s unbelievable, but the ncr53c8xx isn&squot;t able&n;&t;**&t;to subtract one register from another.&n;&t;*/
id|SCR_FROM_REG
(paren
id|temp
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;You are not expected to understand this ..&n;&t;**&n;&t;**&t;CAUTION: only little endian architectures supported! XXX&n;&t;*/
id|SCR_COPY_F
(paren
l_int|1
)paren
comma
id|NADDR
(paren
id|header.savep
)paren
comma
id|PADDR
(paren
id|disconnect0
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DISCONNECT0 &gt;--------------*/
comma
(brace
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|DATA
(paren
l_int|1
)paren
)paren
comma
l_int|20
comma
multiline_comment|/*&n;&t;**&t;neither this&n;&t;*/
id|SCR_COPY_F
(paren
l_int|1
)paren
comma
id|NADDR
(paren
id|header.goalp
)paren
comma
id|PADDR
(paren
id|disconnect1
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DISCONNECT1 &gt;--------------*/
comma
(brace
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|1
)paren
)paren
comma
id|SIR_MISSING_SAVE
comma
multiline_comment|/*&gt;&gt;&gt;*/
multiline_comment|/*&n;&t;**&t;DISCONNECTing  ...&n;&t;**&n;&t;**&t;disable the &quot;unexpected disconnect&quot; feature,&n;&t;**&t;and remove the ACK signal.&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Wait for the disconnect.&n;&t;*/
id|SCR_WAIT_DISC
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Profiling:&n;&t;**&t;Set a time stamp,&n;&t;**&t;and count the disconnects.&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
id|u_long
)paren
)paren
comma
id|KVAR
c_func
(paren
id|SCRIPT_KVAR_JIFFIES
)paren
comma
id|NADDR
(paren
id|header.stamp.disconnect
)paren
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|disc_phys
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|SCR_REG_REG
(paren
id|temp
comma
id|SCR_ADD
comma
l_int|0x01
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|NADDR
(paren
id|disc_phys
)paren
comma
multiline_comment|/*&n;&t;**&t;Status is: DISCONNECTED.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_DISCONNECT
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|cleanup
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_OUT &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;The target requests a message.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|sfbr
)paren
comma
id|NADDR
(paren
id|lastmsg
)paren
comma
multiline_comment|/*&n;&t;**&t;If it was no ABORT message ...&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_ABORT
)paren
)paren
comma
id|PADDRH
(paren
id|msg_out_abort
)paren
comma
multiline_comment|/*&n;&t;**&t;... wait for the next phase&n;&t;**&t;if it&squot;s a message out, send it again, ...&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR
(paren
id|msg_out
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_OUT_DONE &gt;--------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;... else clear the message ...&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_NOOP
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|msgout
)paren
comma
multiline_comment|/*&n;&t;**&t;... and process the next phase&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*------------------------&lt; BADGETCC &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;If SIGP was set, clear it and try again.&n;&t;*/
id|SCR_FROM_REG
(paren
id|ctest2
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|CSIGP
comma
id|CSIGP
)paren
)paren
comma
id|PADDRH
(paren
id|getcc2
)paren
comma
id|SCR_INT
comma
id|SIR_SENSE_FAILED
comma
)brace
multiline_comment|/*-------------------------&lt; RESELECT &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;This NOP will be patched with LED OFF&n;&t;**&t;SCR_REG_REG (gpreg, SCR_OR, 0x01)&n;&t;*/
id|SCR_NO_OP
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;make the DSA invalid.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|dsa
comma
l_int|0xff
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Sleep waiting for a reselection.&n;&t;**&t;If SIGP is set, special treatment.&n;&t;**&n;&t;**&t;Zu allem bereit ..&n;&t;*/
id|SCR_WAIT_RESEL
comma
id|PADDR
c_func
(paren
id|reselect2
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESELECT1 &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;This NOP will be patched with LED ON&n;&t;**&t;SCR_REG_REG (gpreg, SCR_AND, 0xfe)&n;&t;*/
id|SCR_NO_OP
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;... zu nichts zu gebrauchen ?&n;&t;**&n;&t;**      load the target id into the SFBR&n;&t;**&t;and jump to the control block.&n;&t;**&n;&t;**&t;Look at the declarations of&n;&t;**&t;- struct ncb&n;&t;**&t;- struct tcb&n;&t;**&t;- struct lcb&n;&t;**&t;- struct ccb&n;&t;**&t;to understand what&squot;s going on.&n;&t;*/
id|SCR_REG_SFBR
(paren
id|ssid
comma
id|SCR_AND
comma
l_int|0x8F
)paren
comma
l_int|0
comma
id|SCR_TO_REG
(paren
id|ctest0
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|NADDR
(paren
id|jump_tcb
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESELECT2 &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;This NOP will be patched with LED ON&n;&t;**&t;SCR_REG_REG (gpreg, SCR_AND, 0xfe)&n;&t;*/
id|SCR_NO_OP
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;If it&squot;s not connected :(&n;&t;**&t;-&gt; interrupted by SIGP bit.&n;&t;**&t;Jump to start.&n;&t;*/
id|SCR_FROM_REG
(paren
id|ctest2
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|CSIGP
comma
id|CSIGP
)paren
)paren
comma
id|PADDR
(paren
id|start
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|reselect
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_TMP &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;The return address in TEMP&n;&t;**&t;is in fact the data structure address,&n;&t;**&t;so copy it to the DSA register.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|RADDR
(paren
id|dsa
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|prepare
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_LUN &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;come back to this point&n;&t;**&t;to get an IDENTIFY message&n;&t;**&t;Wait for a msg_in phase.&n;&t;*/
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
l_int|48
comma
multiline_comment|/*&n;&t;**&t;message phase&n;&t;**&t;It&squot;s not a sony, it&squot;s a trick:&n;&t;**&t;read the data without acknowledging it.&n;&t;*/
id|SCR_FROM_REG
(paren
id|sbdl
)paren
comma
l_int|0
comma
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|M_IDENTIFY
comma
l_int|0x98
)paren
)paren
comma
l_int|32
comma
multiline_comment|/*&n;&t;**&t;It WAS an Identify message.&n;&t;**&t;get it and ack it!&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Mask out the lun.&n;&t;*/
id|SCR_REG_REG
(paren
id|sfbr
comma
id|SCR_AND
comma
l_int|0x07
)paren
comma
l_int|0
comma
id|SCR_RETURN
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;No message phase or no IDENTIFY message:&n;&t;**&t;return 0.&n;&t;*/
multiline_comment|/*&gt;&gt;&gt;*/
id|SCR_LOAD_SFBR
(paren
l_int|0
)paren
comma
l_int|0
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_TAG &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;come back to this point&n;&t;**&t;to get a SIMPLE_TAG message&n;&t;**&t;Wait for a MSG_IN phase.&n;&t;*/
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
l_int|64
comma
multiline_comment|/*&n;&t;**&t;message phase&n;&t;**&t;It&squot;s a trick - read the data&n;&t;**&t;without acknowledging it.&n;&t;*/
id|SCR_FROM_REG
(paren
id|sbdl
)paren
comma
l_int|0
comma
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|M_SIMPLE_TAG
)paren
)paren
comma
l_int|48
comma
multiline_comment|/*&n;&t;**&t;It WAS a SIMPLE_TAG message.&n;&t;**&t;get it and ack it!&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Wait for the second byte (the tag)&n;&t;*/
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
l_int|24
comma
multiline_comment|/*&n;&t;**&t;Get it and ack it!&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_CARRY
)paren
comma
l_int|0
comma
id|SCR_RETURN
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;No message phase or no SIMPLE_TAG message&n;&t;**&t;or no second byte: return 0.&n;&t;*/
multiline_comment|/*&gt;&gt;&gt;*/
id|SCR_LOAD_SFBR
(paren
l_int|0
)paren
comma
l_int|0
comma
id|SCR_SET
(paren
id|SCR_CARRY
)paren
comma
l_int|0
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IO &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;**&t;Because Linux does not provide xfer data direction &n;**&t;to low-level scsi drivers, we must trust the target &n;**&t;for actual data direction when we cannot guess it.&n;**&t;The programmed interrupt patches savep, lastp, goalp,&n;**&t;etc.., and restarts the scsi script at data_out/in.&n;*/
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
id|SIR_DATA_IO_IS_OUT
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
comma
id|SIR_DATA_IO_IS_IN
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|no_data
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IN &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;**&t;Because the size depends on the&n;**&t;#define MAX_SCATTER parameter,&n;**&t;it is filled in at runtime.&n;**&n;**  ##===========&lt; i=0; i&lt;MAX_SCATTER &gt;=========&n;**  ||&t;SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN)),&n;**  ||&t;&t;PADDR (checkatn),&n;**  ||&t;SCR_MOVE_TBL ^ SCR_DATA_IN,&n;**  ||&t;&t;offsetof (struct dsb, data[ i]),&n;**  ##==========================================&n;**&n;**&t;SCR_CALL,&n;**&t;&t;PADDR (checkatn),&n;**&t;SCR_JUMP,&n;**&t;&t;PADDR (no_data),&n;*/
l_int|0
)brace
multiline_comment|/*--------------------------------------------------------*/
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_struct
id|scripth
id|scripth0
id|__initdata
op_assign
(brace
multiline_comment|/*-------------------------&lt; TRYLOOP &gt;---------------------*/
(brace
multiline_comment|/*&n;**&t;Load an entry of the start queue into dsa&n;**&t;and try to start it by jumping to TRYSEL.&n;**&n;**&t;Because the size depends on the&n;**&t;#define MAX_START parameter, it is filled&n;**&t;in at runtime.&n;**&n;**-----------------------------------------------------------&n;**&n;**  ##===========&lt; I=0; i&lt;MAX_START &gt;===========&n;**  ||&t;SCR_COPY (4),&n;**  ||&t;&t;NADDR (squeue[i]),&n;**  ||&t;&t;RADDR (dsa),&n;**  ||&t;SCR_CALL,&n;**  ||&t;&t;PADDR (trysel),&n;**  ##==========================================&n;**&n;**&t;SCR_JUMP,&n;**&t;&t;PADDRH(tryloop),&n;**&n;**-----------------------------------------------------------&n;*/
l_int|0
)brace
comma
multiline_comment|/*-------------------------&lt; MSG_PARITY &gt;---------------*/
(brace
multiline_comment|/*&n;&t;**&t;count it&n;&t;*/
id|SCR_REG_REG
(paren
id|PS_REG
comma
id|SCR_ADD
comma
l_int|0x01
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;send a &quot;message parity error&quot; message.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_PARITY
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|setmsg
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_REJECT &gt;---------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;If a negotiation was in progress,&n;&t;**&t;negotiation failed.&n;&t;*/
id|SCR_FROM_REG
(paren
id|HS_REG
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|HS_NEGOTIATE
)paren
)paren
comma
id|SIR_NEGO_FAILED
comma
multiline_comment|/*&n;&t;**&t;else make host log this message&n;&t;*/
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|HS_NEGOTIATE
)paren
)paren
comma
id|SIR_REJECT_RECEIVED
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IGN_RESIDUE &gt;----------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Terminate cycle&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get residue size.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|1
)braket
)paren
comma
multiline_comment|/*&n;&t;**&t;Check for message parity error.&n;&t;*/
id|SCR_TO_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_FROM_REG
(paren
id|socl
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|CATN
comma
id|CATN
)paren
)paren
comma
id|PADDRH
(paren
id|msg_parity
)paren
comma
id|SCR_FROM_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Size is 0 .. ignore message.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
l_int|0
)paren
)paren
comma
id|PADDR
(paren
id|clrack
)paren
comma
multiline_comment|/*&n;&t;**&t;Size is not 1 .. have to interrupt.&n;&t;*/
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|1
)paren
)paren
comma
l_int|40
comma
multiline_comment|/*&n;&t;**&t;Check for residue byte in swide register&n;&t;*/
id|SCR_FROM_REG
(paren
id|scntl2
)paren
comma
l_int|0
comma
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|WSR
comma
id|WSR
)paren
)paren
comma
l_int|16
comma
multiline_comment|/*&n;&t;**&t;There IS data in the swide register.&n;&t;**&t;Discard it.&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_OR
comma
id|WSR
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
multiline_comment|/*&n;&t;**&t;Load again the size to the sfbr register.&n;&t;*/
multiline_comment|/*&gt;&gt;&gt;*/
id|SCR_FROM_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
multiline_comment|/*&gt;&gt;&gt;*/
id|SCR_INT
comma
id|SIR_IGN_RESIDUE
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_EXTENDED &gt;-------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Terminate cycle&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get length.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|1
)braket
)paren
comma
multiline_comment|/*&n;&t;**&t;Check for message parity error.&n;&t;*/
id|SCR_TO_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_FROM_REG
(paren
id|socl
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|CATN
comma
id|CATN
)paren
)paren
comma
id|PADDRH
(paren
id|msg_parity
)paren
comma
id|SCR_FROM_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
l_int|3
)paren
)paren
comma
id|PADDRH
(paren
id|msg_ext_3
)paren
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|2
)paren
)paren
comma
id|PADDR
(paren
id|msg_bad
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_EXT_2 &gt;----------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get extended message code.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|2
)braket
)paren
comma
multiline_comment|/*&n;&t;**&t;Check for message parity error.&n;&t;*/
id|SCR_TO_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_FROM_REG
(paren
id|socl
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|CATN
comma
id|CATN
)paren
)paren
comma
id|PADDRH
(paren
id|msg_parity
)paren
comma
id|SCR_FROM_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_X_WIDE_REQ
)paren
)paren
comma
id|PADDRH
(paren
id|msg_wdtr
)paren
comma
multiline_comment|/*&n;&t;**&t;unknown extended message&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|msg_bad
)paren
)brace
multiline_comment|/*-------------------------&lt; MSG_WDTR &gt;-----------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get data bus width&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|3
)braket
)paren
comma
id|SCR_FROM_REG
(paren
id|socl
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|CATN
comma
id|CATN
)paren
)paren
comma
id|PADDRH
(paren
id|msg_parity
)paren
comma
multiline_comment|/*&n;&t;**&t;let the host do the real work.&n;&t;*/
id|SCR_INT
comma
id|SIR_NEGO_WIDE
comma
multiline_comment|/*&n;&t;**&t;let the target fetch our answer.&n;&t;*/
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|SIR_NEGO_PROTO
comma
multiline_comment|/*&n;&t;**&t;Send the M_X_WIDE_REQ&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|4
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_CLR
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|sfbr
)paren
comma
id|NADDR
(paren
id|lastmsg
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|msg_out_done
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_EXT_3 &gt;----------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get extended message code.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|2
)braket
)paren
comma
multiline_comment|/*&n;&t;**&t;Check for message parity error.&n;&t;*/
id|SCR_TO_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_FROM_REG
(paren
id|socl
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|CATN
comma
id|CATN
)paren
)paren
comma
id|PADDRH
(paren
id|msg_parity
)paren
comma
id|SCR_FROM_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_X_SYNC_REQ
)paren
)paren
comma
id|PADDRH
(paren
id|msg_sdtr
)paren
comma
multiline_comment|/*&n;&t;**&t;unknown extended message&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|msg_bad
)paren
)brace
multiline_comment|/*-------------------------&lt; MSG_SDTR &gt;-----------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get period and offset&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|2
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|3
)braket
)paren
comma
id|SCR_FROM_REG
(paren
id|socl
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|CATN
comma
id|CATN
)paren
)paren
comma
id|PADDRH
(paren
id|msg_parity
)paren
comma
multiline_comment|/*&n;&t;**&t;let the host do the real work.&n;&t;*/
id|SCR_INT
comma
id|SIR_NEGO_SYNC
comma
multiline_comment|/*&n;&t;**&t;let the target fetch our answer.&n;&t;*/
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|SIR_NEGO_PROTO
comma
multiline_comment|/*&n;&t;**&t;Send the M_X_SYNC_REQ&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|5
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_CLR
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|sfbr
)paren
comma
id|NADDR
(paren
id|lastmsg
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|msg_out_done
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_OUT_ABORT &gt;-------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;After ABORT message,&n;&t;**&n;&t;**&t;expect an immediate disconnect, ...&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_WAIT_DISC
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;... and set the status to &quot;ABORTED&quot;&n;&t;*/
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_ABORTED
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|cleanup
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; GETCC &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;The ncr doesn&squot;t have an indirect load&n;&t;**&t;or store command. So we have to&n;&t;**&t;copy part of the control block to a&n;&t;**&t;fixed place, where we can modify it.&n;&t;**&n;&t;**&t;We patch the address part of a COPY command&n;&t;**&t;with the address of the dsa register ...&n;&t;*/
id|SCR_COPY_F
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|dsa
)paren
comma
id|PADDRH
(paren
id|getcc1
)paren
comma
multiline_comment|/*&n;&t;**&t;... then we do the actual copy.&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|head
)paren
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; GETCC1 &gt;----------------------*/
comma
(brace
l_int|0
comma
id|NADDR
(paren
id|header
)paren
comma
multiline_comment|/*&n;&t;**&t;Initialize the status registers&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
(paren
id|header.status
)paren
comma
id|RADDR
(paren
id|scr0
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; GETCC2 &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Get the condition code from a target.&n;&t;**&n;&t;**&t;DSA points to a data structure.&n;&t;**&t;Set TEMP to the script location&n;&t;**&t;that receives the condition code.&n;&t;**&n;&t;**&t;Because there is no script command&n;&t;**&t;to load a longword into a register,&n;&t;**&t;we use a CALL command.&n;&t;*/
multiline_comment|/*&lt;&lt;&lt;*/
id|SCR_CALLR
comma
l_int|24
comma
multiline_comment|/*&n;&t;**&t;Get the condition code.&n;&t;*/
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|sense
)paren
comma
multiline_comment|/*&n;&t;**&t;No data phase may follow!&n;&t;*/
id|SCR_CALL
comma
id|PADDR
(paren
id|checkatn
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|no_data
)paren
comma
multiline_comment|/*&gt;&gt;&gt;*/
multiline_comment|/*&n;&t;**&t;The CALL jumps to this point.&n;&t;**&t;Prepare for a RESTORE_POINTER message.&n;&t;**&t;Save the TEMP register into the saved pointer.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|NADDR
(paren
id|header.savep
)paren
comma
multiline_comment|/*&n;&t;**&t;Load scratcha, because in case of a selection timeout,&n;&t;**&t;the host will expect a new value for startpos in&n;&t;**&t;the scratcha register.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|PADDR
(paren
id|startpos
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
macro_line|#ifdef NCR_GETCC_WITHMSG
multiline_comment|/*&n;&t;**&t;If QUIRK_NOMSG is set, select without ATN.&n;&t;**&t;and don&squot;t send a message.&n;&t;*/
id|SCR_FROM_REG
(paren
id|QU_REG
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|QUIRK_NOMSG
comma
id|QUIRK_NOMSG
)paren
)paren
comma
id|PADDRH
c_func
(paren
id|getcc3
)paren
comma
multiline_comment|/*&n;&t;**&t;Then try to connect to the target.&n;&t;**&t;If we are reselected, special treatment&n;&t;**&t;of the current job is required before&n;&t;**&t;accepting the reselection.&n;&t;*/
id|SCR_SEL_TBL_ATN
op_xor
m_offsetof
(paren
r_struct
id|dsb
comma
id|select
)paren
comma
id|PADDR
c_func
(paren
id|badgetcc
)paren
comma
multiline_comment|/*&n;&t;**&t;save target id.&n;&t;*/
id|SCR_FROM_REG
(paren
id|sdid
)paren
comma
l_int|0
comma
id|SCR_TO_REG
(paren
id|ctest0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Send the IDENTIFY message.&n;&t;**&t;In case of short transfer, remove ATN.&n;&t;*/
id|SCR_MOVE_TBL
op_xor
id|SCR_MSG_OUT
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|smsg2
)paren
comma
id|SCR_CLR
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;save the first byte of the message.&n;&t;*/
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|sfbr
)paren
comma
id|NADDR
(paren
id|lastmsg
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|prepare2
)paren
comma
macro_line|#endif
)brace
multiline_comment|/*-------------------------&lt; GETCC3 &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Try to connect to the target.&n;&t;**&t;If we are reselected, special treatment&n;&t;**&t;of the current job is required before&n;&t;**&t;accepting the reselection.&n;&t;**&n;&t;**&t;Silly target won&squot;t accept a message.&n;&t;**&t;Select without ATN.&n;&t;*/
id|SCR_SEL_TBL
op_xor
m_offsetof
(paren
r_struct
id|dsb
comma
id|select
)paren
comma
id|PADDR
c_func
(paren
id|badgetcc
)paren
comma
multiline_comment|/*&n;&t;**&t;save target id.&n;&t;*/
id|SCR_FROM_REG
(paren
id|sdid
)paren
comma
l_int|0
comma
id|SCR_TO_REG
(paren
id|ctest0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Force error if selection timeout&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;don&squot;t negotiate.&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|prepare2
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_OUT &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;**&t;Because the size depends on the&n;**&t;#define MAX_SCATTER parameter,&n;**&t;it is filled in at runtime.&n;**&n;**  ##===========&lt; i=0; i&lt;MAX_SCATTER &gt;=========&n;**  ||&t;SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT)),&n;**  ||&t;&t;PADDR (dispatch),&n;**  ||&t;SCR_MOVE_TBL ^ SCR_DATA_OUT,&n;**  ||&t;&t;offsetof (struct dsb, data[ i]),&n;**  ##==========================================&n;**&n;**&t;SCR_CALL,&n;**&t;&t;PADDR (dispatch),&n;**&t;SCR_JUMP,&n;**&t;&t;PADDR (no_data),&n;**&n;**---------------------------------------------------------&n;*/
l_int|0
)brace
multiline_comment|/*-------------------------&lt; ABORTTAG &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**      Abort a bad reselection.&n;&t;**&t;Set the message to ABORT vs. ABORT_TAG&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_ABORT_TAG
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|CARRYSET
)paren
comma
l_int|8
comma
)brace
multiline_comment|/*-------------------------&lt; ABORT &gt;----------------------*/
comma
(brace
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|M_ABORT
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;and send it.&n;&t;**&t;we expect an immediate disconnect&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR
(paren
id|sfbr
)paren
comma
id|NADDR
(paren
id|lastmsg
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_WAIT_DISC
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SNOOPTEST &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Read the variable.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
c_func
(paren
id|ncr_cache
)paren
comma
id|RADDR
(paren
id|scratcha
)paren
comma
multiline_comment|/*&n;&t;**&t;Write the variable.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
id|NADDR
c_func
(paren
id|ncr_cache
)paren
comma
multiline_comment|/*&n;&t;**&t;Read back the variable.&n;&t;*/
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|NADDR
c_func
(paren
id|ncr_cache
)paren
comma
id|RADDR
(paren
id|temp
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SNOOPEND &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;And stop.&n;&t;*/
id|SCR_INT
comma
l_int|99
comma
)brace
multiline_comment|/*--------------------------------------------------------*/
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Fill in #define dependent parts of the script&n;**&n;**&n;**==========================================================&n;*/
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|ncr_script_fill
(paren
r_struct
id|script
op_star
id|scr
comma
r_struct
id|scripth
op_star
id|scrh
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
id|ncrcmd
op_star
id|p
suffix:semicolon
id|p
op_assign
id|scrh-&gt;tryloop
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_START
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
id|SCR_COPY
(paren
l_int|4
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|NADDR
(paren
id|squeue
(braket
id|i
)braket
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|RADDR
(paren
id|dsa
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_CALL
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|trysel
)paren
suffix:semicolon
)brace
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_JUMP
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDRH
c_func
(paren
id|tryloop
)paren
suffix:semicolon
m_assert
(paren
(paren
id|u_long
)paren
id|p
op_eq
(paren
id|u_long
)paren
op_amp
id|scrh-&gt;tryloop
op_plus
r_sizeof
(paren
id|scrh-&gt;tryloop
)paren
)paren
suffix:semicolon
id|p
op_assign
id|scr-&gt;data_in
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SCATTER
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
id|SCR_CALL
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|checkatn
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_IN
suffix:semicolon
op_star
id|p
op_increment
op_assign
m_offsetof
(paren
r_struct
id|dsb
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_CALL
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|checkatn
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_JUMP
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|no_data
)paren
suffix:semicolon
m_assert
(paren
(paren
id|u_long
)paren
id|p
op_eq
(paren
id|u_long
)paren
op_amp
id|scr-&gt;data_in
op_plus
r_sizeof
(paren
id|scr-&gt;data_in
)paren
)paren
suffix:semicolon
id|p
op_assign
id|scrh-&gt;data_out
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SCATTER
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
id|SCR_CALL
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|dispatch
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_OUT
suffix:semicolon
op_star
id|p
op_increment
op_assign
m_offsetof
(paren
r_struct
id|dsb
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_CALL
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|dispatch
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|SCR_JUMP
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|no_data
)paren
suffix:semicolon
m_assert
(paren
(paren
id|u_long
)paren
id|p
op_eq
(paren
id|u_long
)paren
op_amp
id|scrh-&gt;data_out
op_plus
r_sizeof
(paren
id|scrh-&gt;data_out
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Copy and rebind a script.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|ncr_script_copy_and_bind
(paren
id|ncb_p
id|np
comma
id|ncrcmd
op_star
id|src
comma
id|ncrcmd
op_star
id|dst
comma
r_int
id|len
)paren
)paren
(brace
id|ncrcmd
id|opcode
comma
r_new
comma
id|old
comma
id|tmp1
comma
id|tmp2
suffix:semicolon
id|ncrcmd
op_star
id|start
comma
op_star
id|end
suffix:semicolon
r_int
id|relocs
suffix:semicolon
r_int
id|opchanged
op_assign
l_int|0
suffix:semicolon
id|start
op_assign
id|src
suffix:semicolon
id|end
op_assign
id|src
op_plus
id|len
op_div
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|src
OL
id|end
)paren
(brace
op_star
id|dst
op_increment
op_assign
id|opcode
op_assign
op_star
id|src
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;If we forget to change the length&n;&t;&t;**&t;in struct script, a field will be&n;&t;&t;**&t;padded with 0. This is an illegal&n;&t;&t;**&t;command.&n;&t;&t;*/
r_if
c_cond
(paren
id|opcode
op_eq
l_int|0
)paren
(brace
id|printf
(paren
l_string|&quot;%s: ERROR0 IN SCRIPT at %d.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
r_int
)paren
(paren
id|src
op_minus
id|start
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|DELAY
(paren
l_int|1000000
)paren
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_SCRIPT
)paren
id|printf
(paren
l_string|&quot;%p:  &lt;%x&gt;&bslash;n&quot;
comma
(paren
id|src
op_minus
l_int|1
)paren
comma
(paren
r_int
)paren
id|opcode
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;We don&squot;t have to decode ALL commands&n;&t;&t;*/
r_switch
c_cond
(paren
id|opcode
op_rshift
l_int|28
)paren
(brace
r_case
l_int|0xc
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;COPY has TWO arguments.&n;&t;&t;&t;*/
id|relocs
op_assign
l_int|2
suffix:semicolon
id|tmp1
op_assign
id|src
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp1
op_amp
id|RELOC_MASK
)paren
op_eq
id|RELOC_KVAR
)paren
id|tmp1
op_assign
l_int|0
suffix:semicolon
id|tmp2
op_assign
id|src
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp2
op_amp
id|RELOC_MASK
)paren
op_eq
id|RELOC_KVAR
)paren
id|tmp2
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp1
op_xor
id|tmp2
)paren
op_amp
l_int|3
)paren
(brace
id|printf
(paren
l_string|&quot;%s: ERROR1 IN SCRIPT at %d.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
r_int
)paren
(paren
id|src
op_minus
id|start
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|DELAY
(paren
l_int|1000000
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;**&t;If PREFETCH feature not enabled, remove &n;&t;&t;&t;**&t;the NO FLUSH bit if present.&n;&t;&t;&t;*/
r_if
c_cond
(paren
(paren
id|opcode
op_amp
id|SCR_NO_FLUSH
)paren
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_PFEN
)paren
)paren
(brace
id|dst
(braket
op_minus
l_int|1
)braket
op_assign
(paren
id|opcode
op_amp
op_complement
id|SCR_NO_FLUSH
)paren
suffix:semicolon
op_increment
id|opchanged
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x0
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;MOVE (absolute address)&n;&t;&t;&t;*/
id|relocs
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x8
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;JUMP / CALL&n;&t;&t;&t;**&t;dont&squot;t relocate if relative :-)&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|opcode
op_amp
l_int|0x00800000
)paren
id|relocs
op_assign
l_int|0
suffix:semicolon
r_else
id|relocs
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x4
suffix:colon
r_case
l_int|0x5
suffix:colon
r_case
l_int|0x6
suffix:colon
r_case
l_int|0x7
suffix:colon
id|relocs
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|relocs
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|relocs
)paren
(brace
r_while
c_loop
(paren
id|relocs
op_decrement
)paren
(brace
id|old
op_assign
op_star
id|src
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|old
op_amp
id|RELOC_MASK
)paren
(brace
r_case
id|RELOC_REGISTER
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|np-&gt;paddr
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RELOC_LABEL
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|np-&gt;p_script
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RELOC_LABELH
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|np-&gt;p_scripth
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RELOC_SOFTC
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|vtophys
c_func
(paren
id|np
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RELOC_KVAR
suffix:colon
r_if
c_cond
(paren
(paren
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
OL
id|SCRIPT_KVAR_FIRST
)paren
op_logical_or
(paren
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
OG
id|SCRIPT_KVAR_LAST
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;ncr KVAR out of range&quot;
)paren
suffix:semicolon
r_new
op_assign
id|vtophys
c_func
(paren
id|script_kvars
(braket
id|old
op_amp
op_complement
id|RELOC_MASK
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* Don&squot;t relocate a 0 address. */
r_if
c_cond
(paren
id|old
op_eq
l_int|0
)paren
(brace
r_new
op_assign
id|old
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* fall through */
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;ncr_script_copy_and_bind: weird relocation %x&bslash;n&quot;
comma
id|old
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
id|dst
op_increment
op_assign
r_new
suffix:semicolon
)brace
)brace
r_else
op_star
id|dst
op_increment
op_assign
op_star
id|src
op_increment
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
op_logical_and
id|opchanged
)paren
id|printf
c_func
(paren
l_string|&quot;%s: NO FLUSH bit removed from %d script instructions&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|opchanged
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      Auto configuration:  attach and init a host adapter.&n;**&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**&t;Linux host data structure&n;**&n;**&t;The script area is allocated in the host data structure&n;**&t;because kmalloc() returns NULL during scsi initialisations&n;**&t;with Linux 1.2.X&n;*/
DECL|struct|host_data
r_struct
id|host_data
(brace
DECL|member|ncb
r_struct
id|ncb
op_star
id|ncb
suffix:semicolon
DECL|member|ncb_align
r_char
id|ncb_align
(braket
id|NCB_ALIGN_SIZE
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Filler for alignment */
DECL|member|_ncb_data
r_struct
id|ncb
id|_ncb_data
suffix:semicolon
DECL|member|ccb_align
r_char
id|ccb_align
(braket
id|CCB_ALIGN_SIZE
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Filler for alignment */
DECL|member|_ccb_data
r_struct
id|ccb
id|_ccb_data
suffix:semicolon
DECL|member|scr_align
r_char
id|scr_align
(braket
id|SCR_ALIGN_SIZE
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Filler for alignment */
DECL|member|script_data
r_struct
id|script
id|script_data
suffix:semicolon
DECL|member|scripth_data
r_struct
id|scripth
id|scripth_data
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;Print something which allow to retrieve the controler type, unit,&n;**&t;target, lun concerned by a kernel message.&n;*/
DECL|macro|PRINT_LUN
mdefine_line|#define PRINT_LUN(np, target, lun) &bslash;&n;printf(KERN_INFO &quot;%s-&lt;%d,%d&gt;: &quot;, ncr_name(np), (int) (target), (int) (lun))
DECL|function|PRINT_ADDR
r_static
r_void
id|PRINT_ADDR
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|host_data
op_star
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
id|ncb_p
id|np
op_assign
id|host_data-&gt;ncb
suffix:semicolon
r_if
c_cond
(paren
id|np
)paren
id|PRINT_LUN
c_func
(paren
id|np
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;NCR chip clock divisor table.&n;**&t;Divisors are multiplied by 10,000,000 in order to make &n;**&t;calculations more simple.&n;**&n;**==========================================================&n;*/
DECL|macro|_5M
mdefine_line|#define _5M 5000000
DECL|variable|div_10M
r_static
id|u_long
id|div_10M
(braket
)braket
op_assign
(brace
l_int|2
op_star
id|_5M
comma
l_int|3
op_star
id|_5M
comma
l_int|4
op_star
id|_5M
comma
l_int|6
op_star
id|_5M
comma
l_int|8
op_star
id|_5M
comma
l_int|12
op_star
id|_5M
comma
l_int|16
op_star
id|_5M
)brace
suffix:semicolon
multiline_comment|/*===============================================================&n;**&n;**&t;Prepare io register values used by ncr_init() according &n;**&t;to selected and supported features.&n;**&n;**&t;NCR chips allow burst lengths of 2, 4, 8, 16, 32, 64, 128 &n;**&t;transfers. 32,64,128 are only supported by 875 and 895 chips.&n;**&t;We use log base 2 (burst length) as internal code, with &n;**&t;value 0 meaning &quot;burst disabled&quot;.&n;**&n;**===============================================================&n;*/
multiline_comment|/*&n; *&t;Burst length from burst code.&n; */
DECL|macro|burst_length
mdefine_line|#define burst_length(bc) (!(bc))? 0 : 1 &lt;&lt; (bc)
multiline_comment|/*&n; *&t;Burst code from io register bits.&n; */
DECL|macro|burst_code
mdefine_line|#define burst_code(dmode, ctest4, ctest5) &bslash;&n;&t;(ctest4) &amp; 0x80? 0 : (((dmode) &amp; 0xc0) &gt;&gt; 6) + ((ctest5) &amp; 0x04) + 1
multiline_comment|/*&n; *&t;Set initial io register bits from burst code.&n; */
DECL|function|ncr_init_burst
r_static
r_inline
r_void
id|ncr_init_burst
c_func
(paren
id|ncb_p
id|np
comma
id|u_char
id|bc
)paren
(brace
id|np-&gt;rv_ctest4
op_and_assign
op_complement
l_int|0x80
suffix:semicolon
id|np-&gt;rv_dmode
op_and_assign
op_complement
(paren
l_int|0x3
op_lshift
l_int|6
)paren
suffix:semicolon
id|np-&gt;rv_ctest5
op_and_assign
op_complement
l_int|0x4
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc
)paren
(brace
id|np-&gt;rv_ctest4
op_or_assign
l_int|0x80
suffix:semicolon
)brace
r_else
(brace
op_decrement
id|bc
suffix:semicolon
id|np-&gt;rv_dmode
op_or_assign
(paren
(paren
id|bc
op_amp
l_int|0x3
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|np-&gt;rv_ctest5
op_or_assign
(paren
id|bc
op_amp
l_int|0x4
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
multiline_comment|/*&n;**&t;Get target set-up from Symbios format NVRAM.&n;*/
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|ncr_Symbios_setup_target
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|target
comma
id|Symbios_nvram
op_star
id|nvram
)paren
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|Symbios_target
op_star
id|tn
op_assign
op_amp
id|nvram-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|tp-&gt;usrsync
op_assign
id|tn-&gt;sync_period
ques
c_cond
(paren
id|tn-&gt;sync_period
op_plus
l_int|3
)paren
op_div
l_int|4
suffix:colon
l_int|255
suffix:semicolon
id|tp-&gt;usrwide
op_assign
id|tn-&gt;bus_width
op_eq
l_int|0x10
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|tp-&gt;usrtags
op_assign
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_QUEUE_TAGS_ENABLED
)paren
ques
c_cond
id|SCSI_NCR_MAX_TAGS
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_DISCONNECT_ENABLE
)paren
)paren
id|tp-&gt;usrflag
op_or_assign
id|UF_NODISC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_SCAN_AT_BOOT_TIME
)paren
)paren
id|tp-&gt;usrflag
op_or_assign
id|UF_NOSCAN
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Get target set-up from Tekram format NVRAM.&n;*/
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|ncr_Tekram_setup_target
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|target
comma
id|Tekram_nvram
op_star
id|nvram
)paren
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_struct
id|Tekram_target
op_star
id|tn
op_assign
op_amp
id|nvram-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_SYNC_NEGO
)paren
(brace
id|i
op_assign
id|tn-&gt;sync_index
op_amp
l_int|0xf
suffix:semicolon
id|tp-&gt;usrsync
op_assign
id|i
OL
l_int|12
ques
c_cond
id|Tekram_sync
(braket
id|i
)braket
suffix:colon
l_int|255
suffix:semicolon
)brace
id|tp-&gt;usrwide
op_assign
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_WIDE_NEGO
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_TAGGED_COMMANDS
)paren
(brace
id|tp-&gt;usrtags
op_assign
l_int|2
op_lshift
id|nvram-&gt;max_tags_index
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;usrtags
OG
id|SCSI_NCR_MAX_TAGS
)paren
id|tp-&gt;usrtags
op_assign
id|SCSI_NCR_MAX_TAGS
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_DISCONNECT_ENABLE
)paren
)paren
id|tp-&gt;usrflag
op_assign
id|UF_NODISC
suffix:semicolon
multiline_comment|/* If any device does not support parity, we will not use this option */
r_if
c_cond
(paren
op_logical_neg
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_PARITY_CHECK
)paren
)paren
id|np-&gt;rv_scntl0
op_and_assign
op_complement
l_int|0x0a
suffix:semicolon
multiline_comment|/* SCSI parity checking disabled */
)brace
macro_line|#endif /* SCSI_NCR_NVRAM_SUPPORT */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|ncr_prepare_setting
c_func
(paren
id|ncb_p
id|np
comma
id|ncr_nvram
op_star
id|nvram
)paren
)paren
(brace
id|u_char
id|burst_max
suffix:semicolon
id|u_long
id|period
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Save assumed BIOS setting&n;&t;*/
id|np-&gt;sv_scntl0
op_assign
id|INB
c_func
(paren
id|nc_scntl0
)paren
op_amp
l_int|0x0a
suffix:semicolon
id|np-&gt;sv_scntl3
op_assign
id|INB
c_func
(paren
id|nc_scntl3
)paren
op_amp
l_int|0x07
suffix:semicolon
id|np-&gt;sv_dmode
op_assign
id|INB
c_func
(paren
id|nc_dmode
)paren
op_amp
l_int|0xce
suffix:semicolon
id|np-&gt;sv_dcntl
op_assign
id|INB
c_func
(paren
id|nc_dcntl
)paren
op_amp
l_int|0xa8
suffix:semicolon
id|np-&gt;sv_ctest3
op_assign
id|INB
c_func
(paren
id|nc_ctest3
)paren
op_amp
l_int|0x01
suffix:semicolon
id|np-&gt;sv_ctest4
op_assign
id|INB
c_func
(paren
id|nc_ctest4
)paren
op_amp
l_int|0x80
suffix:semicolon
id|np-&gt;sv_ctest5
op_assign
id|INB
c_func
(paren
id|nc_ctest5
)paren
op_amp
l_int|0x24
suffix:semicolon
id|np-&gt;sv_gpcntl
op_assign
id|INB
c_func
(paren
id|nc_gpcntl
)paren
suffix:semicolon
id|np-&gt;sv_stest2
op_assign
id|INB
c_func
(paren
id|nc_stest2
)paren
op_amp
l_int|0x20
suffix:semicolon
id|np-&gt;sv_stest4
op_assign
id|INB
c_func
(paren
id|nc_stest4
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Wide ?&n;&t;*/
id|np-&gt;maxwide
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_WIDE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Get the frequency of the chip&squot;s clock.&n;&t;**&t;Find the right value for scntl3.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_QUAD
)paren
id|np-&gt;multiplier
op_assign
l_int|4
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_DBLR
)paren
id|np-&gt;multiplier
op_assign
l_int|2
suffix:semicolon
r_else
id|np-&gt;multiplier
op_assign
l_int|1
suffix:semicolon
id|np-&gt;clock_khz
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_CLK80
)paren
ques
c_cond
l_int|80000
suffix:colon
l_int|40000
suffix:semicolon
id|np-&gt;clock_khz
op_mul_assign
id|np-&gt;multiplier
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;clock_khz
op_ne
l_int|40000
)paren
id|ncr_getclock
c_func
(paren
id|np
comma
id|np-&gt;multiplier
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Divisor to be used for async (timer pre-scaler).&n;&t; */
id|i
op_assign
id|np-&gt;clock_divn
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|i
op_ge
l_int|0
)paren
(brace
op_decrement
id|i
suffix:semicolon
r_if
c_cond
(paren
l_int|10ul
op_star
id|SCSI_NCR_MIN_ASYNC
op_star
id|np-&gt;clock_khz
OG
id|div_10M
(braket
id|i
)braket
)paren
(brace
op_increment
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|np-&gt;rv_scntl3
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Minimum synchronous period factor supported by the chip.&n;&t; * Btw, &squot;period&squot; is in tenths of nanoseconds.&n;&t; */
id|period
op_assign
(paren
l_int|4
op_star
id|div_10M
(braket
l_int|0
)braket
op_plus
id|np-&gt;clock_khz
op_minus
l_int|1
)paren
op_div
id|np-&gt;clock_khz
suffix:semicolon
r_if
c_cond
(paren
id|period
op_le
l_int|250
)paren
id|np-&gt;minsync
op_assign
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
id|period
op_le
l_int|303
)paren
id|np-&gt;minsync
op_assign
l_int|11
suffix:semicolon
r_else
r_if
c_cond
(paren
id|period
op_le
l_int|500
)paren
id|np-&gt;minsync
op_assign
l_int|12
suffix:semicolon
r_else
id|np-&gt;minsync
op_assign
(paren
id|period
op_plus
l_int|40
op_minus
l_int|1
)paren
op_div
l_int|40
suffix:semicolon
multiline_comment|/*&n;&t; * Check against chip SCSI standard support (SCSI-2,ULTRA,ULTRA2).&n;&t; */
r_if
c_cond
(paren
id|np-&gt;minsync
OL
l_int|25
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
(paren
id|FE_ULTRA
op_or
id|FE_ULTRA2
)paren
)paren
)paren
id|np-&gt;minsync
op_assign
l_int|25
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;minsync
OL
l_int|12
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA2
)paren
)paren
id|np-&gt;minsync
op_assign
l_int|12
suffix:semicolon
multiline_comment|/*&n;&t; * Maximum synchronous period factor supported by the chip.&n;&t; */
id|period
op_assign
(paren
l_int|11
op_star
id|div_10M
(braket
id|np-&gt;clock_divn
op_minus
l_int|1
)braket
)paren
op_div
(paren
l_int|4
op_star
id|np-&gt;clock_khz
)paren
suffix:semicolon
id|np-&gt;maxsync
op_assign
id|period
OG
l_int|2540
ques
c_cond
l_int|254
suffix:colon
id|period
op_div
l_int|10
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Get on-board RAM bus address when supported&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_RAM
)paren
(brace
id|OUTONB
c_func
(paren
id|nc_ctest2
comma
l_int|0x8
)paren
suffix:semicolon
id|np-&gt;paddr2
op_assign
id|INL
c_func
(paren
id|nc_scr0
)paren
suffix:semicolon
id|OUTOFFB
c_func
(paren
id|nc_ctest2
comma
l_int|0x8
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Prepare initial value of other IO registers&n;&t;*/
macro_line|#if defined SCSI_NCR_TRUST_BIOS_SETTING
id|np-&gt;rv_scntl0
op_assign
id|np-&gt;sv_scntl0
suffix:semicolon
id|np-&gt;rv_dmode
op_assign
id|np-&gt;sv_dmode
suffix:semicolon
id|np-&gt;rv_dcntl
op_assign
id|np-&gt;sv_dcntl
suffix:semicolon
id|np-&gt;rv_ctest3
op_assign
id|np-&gt;sv_ctest3
suffix:semicolon
id|np-&gt;rv_ctest4
op_assign
id|np-&gt;sv_ctest4
suffix:semicolon
id|np-&gt;rv_ctest5
op_assign
id|np-&gt;sv_ctest5
suffix:semicolon
id|burst_max
op_assign
id|burst_code
c_func
(paren
id|np-&gt;sv_dmode
comma
id|np-&gt;sv_ctest4
comma
id|np-&gt;sv_ctest5
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/*&n;&t;**&t;Select burst length (dwords)&n;&t;*/
id|burst_max
op_assign
id|driver_setup.burst_max
suffix:semicolon
r_if
c_cond
(paren
id|burst_max
op_eq
l_int|255
)paren
id|burst_max
op_assign
id|burst_code
c_func
(paren
id|np-&gt;sv_dmode
comma
id|np-&gt;sv_ctest4
comma
id|np-&gt;sv_ctest5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|burst_max
OG
l_int|7
)paren
id|burst_max
op_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|burst_max
OG
id|np-&gt;maxburst
)paren
id|burst_max
op_assign
id|np-&gt;maxburst
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Select all supported special features&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_ERL
)paren
id|np-&gt;rv_dmode
op_or_assign
id|ERL
suffix:semicolon
multiline_comment|/* Enable Read Line */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_BOF
)paren
id|np-&gt;rv_dmode
op_or_assign
id|BOF
suffix:semicolon
multiline_comment|/* Burst Opcode Fetch */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_ERMP
)paren
id|np-&gt;rv_dmode
op_or_assign
id|ERMP
suffix:semicolon
multiline_comment|/* Enable Read Multiple */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_PFEN
)paren
id|np-&gt;rv_dcntl
op_or_assign
id|PFEN
suffix:semicolon
multiline_comment|/* Prefetch Enable */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_CLSE
)paren
id|np-&gt;rv_dcntl
op_or_assign
id|CLSE
suffix:semicolon
multiline_comment|/* Cache Line Size Enable */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_WRIE
)paren
id|np-&gt;rv_ctest3
op_or_assign
id|WRIE
suffix:semicolon
multiline_comment|/* Write and Invalidate */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_DFS
)paren
id|np-&gt;rv_ctest5
op_or_assign
id|DFS
suffix:semicolon
multiline_comment|/* Dma Fifo Size */
multiline_comment|/*&n;&t;**&t;Select some other&n;&t;*/
r_if
c_cond
(paren
id|driver_setup.master_parity
)paren
id|np-&gt;rv_ctest4
op_or_assign
id|MPEE
suffix:semicolon
multiline_comment|/* Master parity checking */
r_if
c_cond
(paren
id|driver_setup.scsi_parity
)paren
id|np-&gt;rv_scntl0
op_or_assign
l_int|0x0a
suffix:semicolon
multiline_comment|/*  full arb., ena parity, par-&gt;ATN  */
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
multiline_comment|/*&n;&t;**&t;Get parity checking, host ID and verbose mode from NVRAM&n;&t;**/
r_if
c_cond
(paren
id|nvram
)paren
(brace
r_switch
c_cond
(paren
id|nvram-&gt;type
)paren
(brace
r_case
id|SCSI_NCR_TEKRAM_NVRAM
suffix:colon
id|np-&gt;myaddr
op_assign
id|nvram-&gt;data.Tekram.host_id
op_amp
l_int|0x0f
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|nvram-&gt;data.Symbios.flags
op_amp
id|SYMBIOS_PARITY_ENABLE
)paren
)paren
id|np-&gt;rv_scntl0
op_and_assign
op_complement
l_int|0x0a
suffix:semicolon
id|np-&gt;myaddr
op_assign
id|nvram-&gt;data.Symbios.host_id
op_amp
l_int|0x0f
suffix:semicolon
r_if
c_cond
(paren
id|nvram-&gt;data.Symbios.flags
op_amp
id|SYMBIOS_VERBOSE_MSGS
)paren
id|np-&gt;verbose
op_add_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**  Get SCSI addr of host adapter (set by bios?).&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;myaddr
)paren
id|np-&gt;myaddr
op_assign
id|INB
c_func
(paren
id|nc_scid
)paren
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;myaddr
)paren
id|np-&gt;myaddr
op_assign
id|SCSI_NCR_MYADDR
suffix:semicolon
macro_line|#endif /* SCSI_NCR_TRUST_BIOS_SETTING */
multiline_comment|/*&n;&t; *&t;Prepare initial io register bits for burst length&n;&t; */
id|ncr_init_burst
c_func
(paren
id|np
comma
id|burst_max
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set differential mode and LED support.&n;&t;**&t;Ignore these features for boards known to use a &n;&t;**&t;specific GPIO wiring (Tekram only for now).&n;&t;**&t;Probe initial setting of GPREG and GPCNTL for &n;&t;**&t;other ones.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|nvram
op_logical_or
id|nvram-&gt;type
op_ne
id|SCSI_NCR_TEKRAM_NVRAM
)paren
(brace
r_switch
c_cond
(paren
id|driver_setup.diff_support
)paren
(brace
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_gpreg
)paren
op_amp
l_int|0x08
)paren
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|np-&gt;rv_stest2
op_or_assign
l_int|0x20
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|np-&gt;rv_stest2
op_or_assign
(paren
id|np-&gt;sv_stest2
op_amp
l_int|0x20
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|driver_setup.led_pin
op_logical_or
(paren
id|nvram
op_logical_and
id|nvram-&gt;type
op_eq
id|SCSI_NCR_SYMBIOS_NVRAM
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|np-&gt;sv_gpcntl
op_amp
l_int|0x01
)paren
)paren
id|np-&gt;features
op_or_assign
id|FE_LED0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set irq mode.&n;&t;*/
r_switch
c_cond
(paren
id|driver_setup.irqm
)paren
(brace
r_case
l_int|2
suffix:colon
id|np-&gt;rv_dcntl
op_or_assign
id|IRQM
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|np-&gt;rv_dcntl
op_or_assign
(paren
id|np-&gt;sv_dcntl
op_amp
id|IRQM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Configure targets according to driver setup.&n;&t;**&t;If NVRAM present get targets setup from NVRAM.&n;&t;**&t;Allow to override sync, wide and NOSCAN from &n;&t;**&t;boot command line.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|tp-&gt;usrsync
op_assign
l_int|255
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_if
c_cond
(paren
id|nvram
)paren
(brace
r_switch
c_cond
(paren
id|nvram-&gt;type
)paren
(brace
r_case
id|SCSI_NCR_TEKRAM_NVRAM
suffix:colon
id|ncr_Tekram_setup_target
c_func
(paren
id|np
comma
id|i
comma
op_amp
id|nvram-&gt;data.Tekram
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:colon
id|ncr_Symbios_setup_target
c_func
(paren
id|np
comma
id|i
comma
op_amp
id|nvram-&gt;data.Symbios
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x2
)paren
id|tp-&gt;usrsync
op_assign
id|driver_setup.default_sync
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x4
)paren
id|tp-&gt;usrwide
op_assign
id|driver_setup.max_wide
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x8
)paren
id|tp-&gt;usrflag
op_and_assign
op_complement
id|UF_NOSCAN
suffix:semicolon
)brace
r_else
(brace
macro_line|#else
r_if
c_cond
(paren
l_int|1
)paren
(brace
macro_line|#endif
id|tp-&gt;usrsync
op_assign
id|driver_setup.default_sync
suffix:semicolon
id|tp-&gt;usrwide
op_assign
id|driver_setup.max_wide
suffix:semicolon
id|tp-&gt;usrtags
op_assign
id|driver_setup.default_tags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver_setup.disconnection
)paren
id|np-&gt;target
(braket
id|i
)braket
dot
id|usrflag
op_assign
id|UF_NODISC
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;**&t;Announce all that stuff to user.&n;&t;*/
id|i
op_assign
id|nvram
ques
c_cond
id|nvram-&gt;type
suffix:colon
l_int|0
suffix:semicolon
id|printf
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %sID %d, Fast-%d%s%s&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|i
op_eq
id|SCSI_NCR_SYMBIOS_NVRAM
ques
c_cond
l_string|&quot;Symbios format NVRAM, &quot;
suffix:colon
(paren
id|i
op_eq
id|SCSI_NCR_TEKRAM_NVRAM
ques
c_cond
l_string|&quot;Tekram format NVRAM, &quot;
suffix:colon
l_string|&quot;&quot;
)paren
comma
id|np-&gt;myaddr
comma
id|np-&gt;minsync
OL
l_int|12
ques
c_cond
l_int|40
suffix:colon
(paren
id|np-&gt;minsync
OL
l_int|25
ques
c_cond
l_int|20
suffix:colon
l_int|10
)paren
comma
(paren
id|np-&gt;rv_scntl0
op_amp
l_int|0xa
)paren
ques
c_cond
l_string|&quot;, Parity Checking&quot;
suffix:colon
l_string|&quot;, NO Parity&quot;
comma
(paren
id|np-&gt;rv_stest2
op_amp
l_int|0x20
)paren
ques
c_cond
l_string|&quot;, Differential&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
)paren
(brace
id|printf
(paren
l_string|&quot;%s: initial SCNTL3/DMODE/DCNTL/CTEST3/4/5 = &quot;
l_string|&quot;(hex) %02x/%02x/%02x/%02x/%02x/%02x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;sv_scntl3
comma
id|np-&gt;sv_dmode
comma
id|np-&gt;sv_dcntl
comma
id|np-&gt;sv_ctest3
comma
id|np-&gt;sv_ctest4
comma
id|np-&gt;sv_ctest5
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;%s: final   SCNTL3/DMODE/DCNTL/CTEST3/4/5 = &quot;
l_string|&quot;(hex) %02x/%02x/%02x/%02x/%02x/%02x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;rv_scntl3
comma
id|np-&gt;rv_dmode
comma
id|np-&gt;rv_dcntl
comma
id|np-&gt;rv_ctest3
comma
id|np-&gt;rv_ctest4
comma
id|np-&gt;rv_ctest5
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bootverbose
op_logical_and
id|np-&gt;paddr2
)paren
id|printf
(paren
id|KERN_INFO
l_string|&quot;%s: on-board RAM at 0x%lx&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;paddr2
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_DEBUG_NVRAM
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|ncr_display_Symbios_nvram
c_func
(paren
id|ncb_p
id|np
comma
id|Symbios_nvram
op_star
id|nvram
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* display Symbios nvram host data */
id|printf
c_func
(paren
l_string|&quot;%s: HOST ID=%d%s%s%s%s&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|nvram-&gt;host_id
op_amp
l_int|0x0f
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_SCAM_ENABLE
)paren
ques
c_cond
l_string|&quot; SCAM&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_PARITY_ENABLE
)paren
ques
c_cond
l_string|&quot; PARITY&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_VERBOSE_MSGS
)paren
ques
c_cond
l_string|&quot; VERSBOSE&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags1
op_amp
id|SYMBIOS_SCAN_HI_LO
)paren
ques
c_cond
l_string|&quot; HI_LO&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
multiline_comment|/* display Symbios nvram drive data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|Symbios_target
op_star
id|tn
op_assign
op_amp
id|nvram-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s-%d:%s%s%s%s WIDTH=%d SYNC=%d TMO=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|i
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_DISCONNECT_ENABLE
)paren
ques
c_cond
l_string|&quot; DISC&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_SCAN_AT_BOOT_TIME
)paren
ques
c_cond
l_string|&quot; SCAN_BOOT&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_SCAN_LUNS
)paren
ques
c_cond
l_string|&quot; SCAN_LUNS&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_QUEUE_TAGS_ENABLED
)paren
ques
c_cond
l_string|&quot; TCQ&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|tn-&gt;bus_width
comma
id|tn-&gt;sync_period
op_div
l_int|4
comma
id|tn-&gt;timeout
)paren
suffix:semicolon
)brace
)brace
DECL|variable|__initdata
r_static
id|u_char
id|Tekram_boot_delay
(braket
l_int|7
)braket
id|__initdata
op_assign
(brace
l_int|3
comma
l_int|5
comma
l_int|10
comma
l_int|20
comma
l_int|30
comma
l_int|60
comma
l_int|120
)brace
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|ncr_display_Tekram_nvram
c_func
(paren
id|ncb_p
id|np
comma
id|Tekram_nvram
op_star
id|nvram
)paren
)paren
(brace
r_int
id|i
comma
id|tags
comma
id|boot_delay
suffix:semicolon
r_char
op_star
id|rem
suffix:semicolon
multiline_comment|/* display Tekram nvram host data */
id|tags
op_assign
l_int|2
op_lshift
id|nvram-&gt;max_tags_index
suffix:semicolon
id|boot_delay
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nvram-&gt;boot_delay_index
OL
l_int|6
)paren
id|boot_delay
op_assign
id|Tekram_boot_delay
(braket
id|nvram-&gt;boot_delay_index
)braket
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_REMOVABLE_FLAGS
)paren
op_rshift
l_int|6
)paren
(brace
r_default
suffix:colon
r_case
l_int|0
suffix:colon
id|rem
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|rem
op_assign
l_string|&quot; REMOVABLE=boot device&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|rem
op_assign
l_string|&quot; REMOVABLE=all&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;%s: HOST ID=%d%s%s%s%s%s%s%s%s%s BOOT DELAY=%d tags=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|nvram-&gt;host_id
op_amp
l_int|0x0f
comma
(paren
id|nvram-&gt;flags1
op_amp
id|SYMBIOS_SCAM_ENABLE
)paren
ques
c_cond
l_string|&quot; SCAM&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_MORE_THAN_2_DRIVES
)paren
ques
c_cond
l_string|&quot; &gt;2DRIVES&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_DRIVES_SUP_1GB
)paren
ques
c_cond
l_string|&quot; &gt;1GB&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_RESET_ON_POWER_ON
)paren
ques
c_cond
l_string|&quot; RESET&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_ACTIVE_NEGATION
)paren
ques
c_cond
l_string|&quot; ACT_NEG&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_IMMEDIATE_SEEK
)paren
ques
c_cond
l_string|&quot; IMM_SEEK&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_SCAN_LUNS
)paren
ques
c_cond
l_string|&quot; SCAN_LUNS&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags1
op_amp
id|TEKRAM_F2_F6_ENABLED
)paren
ques
c_cond
l_string|&quot; F2_F6&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|rem
comma
id|boot_delay
comma
id|tags
)paren
suffix:semicolon
multiline_comment|/* display Tekram nvram drive data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|sync
comma
id|j
suffix:semicolon
r_struct
id|Tekram_target
op_star
id|tn
op_assign
op_amp
id|nvram-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|j
op_assign
id|tn-&gt;sync_index
op_amp
l_int|0xf
suffix:semicolon
id|sync
op_assign
id|j
OL
l_int|12
ques
c_cond
id|Tekram_sync
(braket
id|j
)braket
suffix:colon
l_int|255
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s-%d:%s%s%s%s%s%s PERIOD=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|i
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_PARITY_CHECK
)paren
ques
c_cond
l_string|&quot; PARITY&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_SYNC_NEGO
)paren
ques
c_cond
l_string|&quot; SYNC&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_DISCONNECT_ENABLE
)paren
ques
c_cond
l_string|&quot; DISC&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_START_CMD
)paren
ques
c_cond
l_string|&quot; START&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_TAGGED_COMMANDS
)paren
ques
c_cond
l_string|&quot; TCQ&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_WIDE_NEGO
)paren
ques
c_cond
l_string|&quot; WIDE&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|sync
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* SCSI_NCR_DEBUG_NVRAM */
multiline_comment|/*&n;**&t;Host attach and initialisations.&n;**&n;**&t;Allocate host data and ncb structure.&n;**&t;Request IO region and remap MMIO region.&n;**&t;Do chip initialization.&n;**&t;If all is OK, install interrupt handling and&n;**&t;start the timer daemon.&n;*/
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|ncr_attach
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|unit
comma
id|ncr_device
op_star
id|device
)paren
)paren
(brace
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
id|ncb_p
id|np
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
op_assign
l_int|0
suffix:semicolon
id|u_long
id|flags
op_assign
l_int|0
suffix:semicolon
id|ncr_nvram
op_star
id|nvram
op_assign
id|device-&gt;nvram
suffix:semicolon
id|printf
c_func
(paren
id|KERN_INFO
l_string|&quot;ncr53c%s-%d: rev=0x%02x, base=0x%x, io_port=0x%x, irq=%d&bslash;n&quot;
comma
id|device-&gt;chip.name
comma
id|unit
comma
id|device-&gt;chip.revision_id
comma
id|device-&gt;slot.base
comma
id|device-&gt;slot.io_port
comma
id|device-&gt;slot.irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate host_data structure&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|instance
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
r_sizeof
(paren
op_star
id|host_data
)paren
)paren
)paren
)paren
r_goto
id|attach_error
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initialize structure.&n;&t;*/
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Align np and first ccb to 32 boundary for cache line &n;&t;**&t;bursting when copying the global header.&n;&t;*/
id|np
op_assign
(paren
id|ncb_p
)paren
(paren
(paren
(paren
id|u_long
)paren
op_amp
id|host_data-&gt;_ncb_data
)paren
op_amp
id|NCB_ALIGN_MASK
)paren
suffix:semicolon
id|host_data-&gt;ncb
op_assign
id|np
suffix:semicolon
id|bzero
(paren
id|np
comma
r_sizeof
(paren
op_star
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;ccb
op_assign
(paren
id|ccb_p
)paren
(paren
(paren
(paren
id|u_long
)paren
op_amp
id|host_data-&gt;_ccb_data
)paren
op_amp
id|CCB_ALIGN_MASK
)paren
suffix:semicolon
id|bzero
(paren
id|np-&gt;ccb
comma
r_sizeof
(paren
op_star
id|np-&gt;ccb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Store input informations in the host data structure.&n;&t;*/
id|strncpy
c_func
(paren
id|np-&gt;chip_name
comma
id|device-&gt;chip.name
comma
r_sizeof
(paren
id|np-&gt;chip_name
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|np-&gt;unit
op_assign
id|unit
suffix:semicolon
id|np-&gt;verbose
op_assign
id|driver_setup.verbose
suffix:semicolon
id|sprintf
c_func
(paren
id|np-&gt;inst_name
comma
l_string|&quot;ncr53c%s-%d&quot;
comma
id|np-&gt;chip_name
comma
id|np-&gt;unit
)paren
suffix:semicolon
id|np-&gt;device_id
op_assign
id|device-&gt;chip.device_id
suffix:semicolon
id|np-&gt;revision_id
op_assign
id|device-&gt;chip.revision_id
suffix:semicolon
id|np-&gt;features
op_assign
id|device-&gt;chip.features
suffix:semicolon
id|np-&gt;clock_divn
op_assign
id|device-&gt;chip.nr_divisor
suffix:semicolon
id|np-&gt;maxoffs
op_assign
id|device-&gt;chip.offset_max
suffix:semicolon
id|np-&gt;maxburst
op_assign
id|device-&gt;chip.burst_max
suffix:semicolon
id|np-&gt;script0
op_assign
(paren
r_struct
id|script
op_star
)paren
(paren
(paren
(paren
id|u_long
)paren
op_amp
id|host_data-&gt;script_data
)paren
op_amp
id|SCR_ALIGN_MASK
)paren
suffix:semicolon
id|np-&gt;scripth0
op_assign
op_amp
id|host_data-&gt;scripth_data
suffix:semicolon
multiline_comment|/*&n;&t;**    Initialize timer structure&n;        **&n;        */
id|init_timer
c_func
(paren
op_amp
id|np-&gt;timer
)paren
suffix:semicolon
id|np-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|np
suffix:semicolon
id|np-&gt;timer.function
op_assign
id|ncr53c8xx_timeout
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Try to map the controller chip to&n;&t;**&t;virtual and physical memory.&n;&t;*/
id|np-&gt;paddr
op_assign
id|device-&gt;slot.base
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
id|np-&gt;vaddr
op_assign
id|remap_pci_mem
c_func
(paren
(paren
id|u_long
)paren
id|np-&gt;paddr
comma
(paren
id|u_long
)paren
l_int|128
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;vaddr
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: can&squot;t map memory mapped IO region&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;%s: using memory mapped IO at virtual address 0x%lx&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|np-&gt;vaddr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Make the controller&squot;s registers available.&n;&t;**&t;Now the INB INW INL OUTB OUTW OUTL macros&n;&t;**&t;can be used safely.&n;&t;*/
id|np-&gt;reg
op_assign
(paren
r_struct
id|ncr_reg
op_star
)paren
id|np-&gt;vaddr
suffix:semicolon
macro_line|#endif /* !defined NCR_IOMAPPED */
multiline_comment|/*&n;&t;**&t;Try to map the controller chip into iospace.&n;&t;*/
id|request_region
c_func
(paren
id|device-&gt;slot.io_port
comma
l_int|128
comma
l_string|&quot;ncr53c8xx&quot;
)paren
suffix:semicolon
id|np-&gt;port
op_assign
id|device-&gt;slot.io_port
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_if
c_cond
(paren
id|nvram
)paren
(brace
r_switch
c_cond
(paren
id|nvram-&gt;type
)paren
(brace
r_case
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:colon
macro_line|#ifdef SCSI_NCR_DEBUG_NVRAM
id|ncr_display_Symbios_nvram
c_func
(paren
id|np
comma
op_amp
id|nvram-&gt;data.Symbios
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|SCSI_NCR_TEKRAM_NVRAM
suffix:colon
macro_line|#ifdef SCSI_NCR_DEBUG_NVRAM
id|ncr_display_Tekram_nvram
c_func
(paren
id|np
comma
op_amp
id|nvram-&gt;data.Tekram
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_default
suffix:colon
id|nvram
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SCSI_NCR_DEBUG_NVRAM
id|printf
c_func
(paren
l_string|&quot;%s: NVRAM: None or invalid data.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Do chip dependent initialization.&n;&t;*/
(paren
r_void
)paren
id|ncr_prepare_setting
c_func
(paren
id|np
comma
id|nvram
)paren
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
r_if
c_cond
(paren
id|np-&gt;paddr2
op_logical_and
r_sizeof
(paren
r_struct
id|script
)paren
op_le
l_int|4096
)paren
(brace
id|np-&gt;vaddr2
op_assign
id|remap_pci_mem
c_func
(paren
(paren
id|u_long
)paren
id|np-&gt;paddr2
comma
(paren
id|u_long
)paren
l_int|4096
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;vaddr2
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: can&squot;t map memory mapped IO region&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;%s: on-board ram mapped at virtual address 0x%lx&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|np-&gt;vaddr2
)paren
suffix:semicolon
)brace
macro_line|#endif /* !defined NCR_IOMAPPED */
multiline_comment|/*&n;&t;**&t;Fill Linux host instance structure&n;&t;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,0)
id|instance-&gt;max_channel
op_assign
l_int|0
suffix:semicolon
id|instance-&gt;max_id
op_assign
id|np-&gt;maxwide
ques
c_cond
l_int|16
suffix:colon
l_int|8
suffix:semicolon
id|instance-&gt;max_lun
op_assign
id|SCSI_NCR_MAX_LUN
suffix:semicolon
macro_line|#endif
macro_line|#ifndef NCR_IOMAPPED
id|instance-&gt;base
op_assign
(paren
r_char
op_star
)paren
id|np-&gt;reg
suffix:semicolon
macro_line|#endif
id|instance-&gt;irq
op_assign
id|device-&gt;slot.irq
suffix:semicolon
id|instance-&gt;io_port
op_assign
id|device-&gt;slot.io_port
suffix:semicolon
id|instance-&gt;n_io_port
op_assign
l_int|128
suffix:semicolon
id|instance-&gt;dma_channel
op_assign
l_int|0
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,0,0)
id|instance-&gt;select_queue_depths
op_assign
id|ncr53c8xx_select_queue_depths
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Patch script to physical addresses&n;&t;*/
id|ncr_script_fill
(paren
op_amp
id|script0
comma
op_amp
id|scripth0
)paren
suffix:semicolon
id|np-&gt;scripth
op_assign
id|np-&gt;scripth0
suffix:semicolon
id|np-&gt;p_scripth
op_assign
id|vtophys
c_func
(paren
id|np-&gt;scripth
)paren
suffix:semicolon
id|np-&gt;script
op_assign
(paren
id|np-&gt;vaddr2
)paren
ques
c_cond
(paren
r_struct
id|script
op_star
)paren
id|np-&gt;vaddr2
suffix:colon
id|np-&gt;script0
suffix:semicolon
id|np-&gt;p_script
op_assign
(paren
id|np-&gt;vaddr2
)paren
ques
c_cond
id|np-&gt;paddr2
suffix:colon
id|vtophys
c_func
(paren
id|np-&gt;script0
)paren
suffix:semicolon
id|ncr_script_copy_and_bind
(paren
id|np
comma
(paren
id|ncrcmd
op_star
)paren
op_amp
id|script0
comma
(paren
id|ncrcmd
op_star
)paren
id|np-&gt;script0
comma
r_sizeof
(paren
r_struct
id|script
)paren
)paren
suffix:semicolon
id|ncr_script_copy_and_bind
(paren
id|np
comma
(paren
id|ncrcmd
op_star
)paren
op_amp
id|scripth0
comma
(paren
id|ncrcmd
op_star
)paren
id|np-&gt;scripth0
comma
r_sizeof
(paren
r_struct
id|scripth
)paren
)paren
suffix:semicolon
id|np-&gt;ccb-&gt;p_ccb
op_assign
id|vtophys
(paren
id|np-&gt;ccb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**    Patch the script for LED support.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_LED0
)paren
(brace
id|np-&gt;script0-&gt;reselect
(braket
l_int|0
)braket
op_assign
id|SCR_REG_REG
c_func
(paren
id|gpreg
comma
id|SCR_OR
comma
l_int|0x01
)paren
suffix:semicolon
id|np-&gt;script0-&gt;reselect1
(braket
l_int|0
)braket
op_assign
id|SCR_REG_REG
c_func
(paren
id|gpreg
comma
id|SCR_AND
comma
l_int|0xfe
)paren
suffix:semicolon
id|np-&gt;script0-&gt;reselect2
(braket
l_int|0
)braket
op_assign
id|SCR_REG_REG
c_func
(paren
id|gpreg
comma
id|SCR_AND
comma
l_int|0xfe
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;init data structure&n;&t;*/
id|np-&gt;jump_tcb.l_cmd
op_assign
id|SCR_JUMP
suffix:semicolon
id|np-&gt;jump_tcb.l_paddr
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
m_abort
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Reset chip.&n;&t;*/
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|DELAY
(paren
l_int|1000
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Now check the cache handling of the pci chipset.&n;&t;*/
r_if
c_cond
(paren
id|ncr_snooptest
(paren
id|np
)paren
)paren
(brace
id|printf
(paren
l_string|&quot;CACHE INCORRECTLY CONFIGURED.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Install the interrupt handler.&n;&t;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,70)
macro_line|#ifdef SCSI_NCR_SHARE_IRQ
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;%s: requesting shared irq %d (dev_id=0x%lx)&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|device-&gt;slot.irq
comma
(paren
id|u_long
)paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|device-&gt;slot.irq
comma
id|ncr53c8xx_intr
comma
id|SA_INTERRUPT
op_or
id|SA_SHIRQ
comma
l_string|&quot;ncr53c8xx&quot;
comma
id|np
)paren
)paren
(brace
macro_line|#else
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|device-&gt;slot.irq
comma
id|ncr53c8xx_intr
comma
id|SA_INTERRUPT
comma
l_string|&quot;ncr53c8xx&quot;
comma
l_int|NULL
)paren
)paren
(brace
macro_line|#endif
macro_line|#else
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|device-&gt;slot.irq
comma
id|ncr53c8xx_intr
comma
id|SA_INTERRUPT
comma
l_string|&quot;ncr53c8xx&quot;
)paren
)paren
(brace
macro_line|#endif
id|printf
c_func
(paren
l_string|&quot;%s: request irq %d failure&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|device-&gt;slot.irq
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
id|np-&gt;irq
op_assign
id|device-&gt;slot.irq
suffix:semicolon
multiline_comment|/*&n;&t;**&t;After SCSI devices have been opened, we cannot&n;&t;**&t;reset the bus safely, so we do it here.&n;&t;**&t;Interrupt handler does the real work.&n;&t;**&t;Process the reset exception,&n;&t;**&t;if interrupts are not enabled yet.&n;&t;**&t;Then enable disconnects.&n;&t;*/
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ncr_start_reset
c_func
(paren
id|np
comma
id|driver_setup.settle_delay
)paren
suffix:semicolon
id|ncr_exception
(paren
id|np
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|np-&gt;disc
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The middle-level SCSI driver does not&n;&t;**&t;wait devices to settle.&n;&t;**&t;Wait synchronously if more than 2 seconds.&n;&t;*/
r_if
c_cond
(paren
id|driver_setup.settle_delay
OG
l_int|2
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: waiting %d seconds for scsi devices to settle...&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|driver_setup.settle_delay
)paren
suffix:semicolon
id|DELAY
c_func
(paren
l_int|1000000UL
op_star
id|driver_setup.settle_delay
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Now let the generic SCSI driver&n;&t;**&t;look for the SCSI devices on the bus ..&n;&t;*/
multiline_comment|/*&n;&t;**&t;start the timeout daemon&n;&t;*/
id|np-&gt;lasttime
op_assign
l_int|0
suffix:semicolon
id|ncr_timeout
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**  use SIMPLE TAG messages by default&n;&t;*/
macro_line|#ifdef SCSI_NCR_ALWAYS_SIMPLE_TAG
id|np-&gt;order
op_assign
id|M_SIMPLE_TAG
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**  Done.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|the_template
)paren
(brace
id|the_template
op_assign
id|instance-&gt;hostt
suffix:semicolon
id|first_host
op_assign
id|instance
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|attach_error
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|instance
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: detaching...&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
r_if
c_cond
(paren
id|np-&gt;vaddr
)paren
(brace
macro_line|#ifdef DEBUG_NCR53C8XX
id|printf
c_func
(paren
l_string|&quot;%s: releasing memory mapped IO region %lx[%d]&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|np-&gt;vaddr
comma
l_int|128
)paren
suffix:semicolon
macro_line|#endif
id|unmap_pci_mem
c_func
(paren
(paren
id|vm_offset_t
)paren
id|np-&gt;vaddr
comma
(paren
id|u_long
)paren
l_int|128
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|np-&gt;vaddr2
)paren
(brace
macro_line|#ifdef DEBUG_NCR53C8XX
id|printf
c_func
(paren
l_string|&quot;%s: releasing memory mapped IO region %lx[%d]&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|np-&gt;vaddr2
comma
l_int|4096
)paren
suffix:semicolon
macro_line|#endif
id|unmap_pci_mem
c_func
(paren
(paren
id|vm_offset_t
)paren
id|np-&gt;vaddr2
comma
(paren
id|u_long
)paren
l_int|4096
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|np-&gt;port
)paren
(brace
macro_line|#ifdef DEBUG_NCR53C8XX
id|printf
c_func
(paren
l_string|&quot;%s: releasing IO region %x[%d]&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;port
comma
l_int|128
)paren
suffix:semicolon
macro_line|#endif
id|release_region
c_func
(paren
id|np-&gt;port
comma
l_int|128
)paren
suffix:semicolon
)brace
id|scsi_unregister
c_func
(paren
id|instance
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Start execution of a SCSI command.&n;**&t;This is called from the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_queue_command
r_int
id|ncr_queue_command
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;host
suffix:semicolon
multiline_comment|/*&t;Scsi_Device        *device    = cmd-&gt;device; */
r_struct
id|host_data
op_star
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|ncb_p
id|np
op_assign
id|host_data-&gt;ncb
suffix:semicolon
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cmd-&gt;target
)braket
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
r_int
id|segments
suffix:semicolon
id|u_char
id|qidx
comma
id|nego
comma
id|idmsg
comma
op_star
id|msgptr
suffix:semicolon
id|u_int
id|msglen
comma
id|msglen2
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
r_int
id|xfer_direction
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*---------------------------------------------&n;&t;**&n;&t;**      Some shortcuts ...&n;&t;**&n;&t;**---------------------------------------------&n;&t;*/
r_if
c_cond
(paren
(paren
id|cmd-&gt;target
op_eq
id|np-&gt;myaddr
)paren
op_logical_or
(paren
id|cmd-&gt;target
op_ge
id|MAX_TARGET
)paren
op_logical_or
(paren
id|cmd-&gt;lun
op_ge
id|MAX_LUN
)paren
)paren
(brace
r_return
id|DID_BAD_TARGET
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------&n;&t;**&n;&t;**&t;Complete the 1st TEST UNIT READY command&n;&t;**&t;with error condition if the device is &n;&t;**&t;flagged NOSCAN, in order to speed up &n;&t;**&t;the boot.&n;&t;**&n;&t;**---------------------------------------------&n;&t;*/
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_and
(paren
id|tp-&gt;usrflag
op_amp
id|UF_NOSCAN
)paren
)paren
(brace
id|tp-&gt;usrflag
op_and_assign
op_complement
id|UF_NOSCAN
suffix:semicolon
r_return
id|DID_BAD_TARGET
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;CMD=%x &quot;
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;Assign a ccb / bind cmd&n;&t;**&t;If resetting or no free ccb,&n;&t;**&t;insert cmd into the waiting list.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;settle_time
op_logical_or
op_logical_neg
(paren
id|cp
op_assign
id|ncr_get_ccb
(paren
id|np
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
)paren
)paren
(brace
id|insert_into_waiting_list
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|DID_OK
suffix:semicolon
)brace
id|cp-&gt;cmd
op_assign
id|cmd
suffix:semicolon
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;Enable tagged queue if asked by scsi ioctl&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;usrtags
op_logical_and
id|cmd-&gt;device
op_logical_and
id|cmd-&gt;device-&gt;tagged_queue
)paren
(brace
id|tp-&gt;usrtags
op_assign
id|SCSI_NCR_MAX_TAGS
suffix:semicolon
id|ncr_setmaxtags
(paren
id|np
comma
id|tp
comma
id|SCSI_NCR_MAX_TAGS
)paren
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;timestamp&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
id|bzero
(paren
op_amp
id|cp-&gt;phys.header.stamp
comma
r_sizeof
(paren
r_struct
id|tstamp
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.header.stamp.start
op_assign
id|jiffies
suffix:semicolon
macro_line|#endif
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Get device quirks from a speciality table.&n;&t;**&n;&t;**&t;@GENSCSI@&n;&t;**&t;This should be a part of the device table&n;&t;**&t;in &quot;scsi_conf.c&quot;.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
r_if
c_cond
(paren
id|tp-&gt;quirks
op_amp
id|QUIRK_UPDATE
)paren
(brace
id|tp-&gt;quirks
op_assign
id|ncr_lookup
(paren
(paren
r_char
op_star
)paren
op_amp
id|tp-&gt;inqdata
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#ifndef NCR_GETCC_WITHMSG
r_if
c_cond
(paren
id|tp-&gt;quirks
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;quirks=%x.&bslash;n&quot;
comma
id|tp-&gt;quirks
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;negotiation required?&n;&t;**&n;&t;**&t;Only SCSI-II devices.&n;&t;**&t;To negotiate with SCSI-I devices is dangerous, since&n;&t;**&t;Synchronous Negotiation protocol is optional, and&n;&t;**&t;INQUIRY data do not contains capabilities in byte 7.&n;&t;**----------------------------------------------------&n;&t;*/
id|nego
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;lun
op_eq
l_int|0
op_logical_and
op_logical_neg
id|tp-&gt;nego_cp
op_logical_and
(paren
id|tp-&gt;inqdata
(braket
l_int|2
)braket
op_amp
l_int|0x7
)paren
op_ge
l_int|2
op_logical_and
id|tp-&gt;inqdata
(braket
l_int|7
)braket
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;negotiate wide transfers ?&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;widedone
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;inqdata
(braket
l_int|7
)braket
op_amp
id|INQ7_WIDE16
)paren
(brace
id|nego
op_assign
id|NS_WIDE
suffix:semicolon
)brace
r_else
id|tp-&gt;widedone
op_assign
l_int|1
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;negotiate synchronous transfers?&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|nego
op_logical_and
op_logical_neg
id|tp-&gt;period
)paren
(brace
r_if
c_cond
(paren
l_int|1
macro_line|#if defined (CDROM_ASYNC)
op_logical_and
(paren
(paren
id|tp-&gt;inqdata
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
op_ne
l_int|5
)paren
macro_line|#endif
op_logical_and
(paren
id|tp-&gt;inqdata
(braket
l_int|7
)braket
op_amp
id|INQ7_SYNC
)paren
)paren
(brace
id|nego
op_assign
id|NS_SYNC
suffix:semicolon
)brace
r_else
(brace
id|tp-&gt;period
op_assign
l_int|0xffff
suffix:semicolon
id|tp-&gt;sval
op_assign
l_int|0xe0
suffix:semicolon
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;asynchronous.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;remember nego is pending for the target.&n;&t;&t;**&t;Avoid to start a nego for all queued commands &n;&t;&t;**&t;when tagged command queuing is enabled.&n;&t;&t;*/
r_if
c_cond
(paren
id|nego
)paren
id|tp-&gt;nego_cp
op_assign
id|cp
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;choose a new tag ...&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
r_if
c_cond
(paren
(paren
id|lp
op_assign
id|tp-&gt;lp
(braket
id|cmd-&gt;lun
)braket
)paren
op_logical_and
(paren
id|lp-&gt;usetags
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;assign a tag to this ccb!&n;&t;&t;*/
r_while
c_loop
(paren
op_logical_neg
id|cp-&gt;tag
)paren
(brace
id|ccb_p
id|cp2
op_assign
id|lp-&gt;next_ccb
suffix:semicolon
id|lp-&gt;lasttag
op_assign
id|lp-&gt;lasttag
op_mod
l_int|255
op_plus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|cp2
op_logical_and
id|cp2-&gt;tag
op_ne
id|lp-&gt;lasttag
)paren
id|cp2
op_assign
id|cp2-&gt;next_ccb
suffix:semicolon
r_if
c_cond
(paren
id|cp2
)paren
r_continue
suffix:semicolon
id|cp-&gt;tag
op_assign
id|lp-&gt;lasttag
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TAGS
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;using tag #%d.&bslash;n&quot;
comma
id|cp-&gt;tag
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|cp-&gt;tag
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Build the identify / tag / sdtr message&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
id|idmsg
op_assign
id|M_IDENTIFY
op_or
id|cmd-&gt;lun
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_ne
id|np-&gt;ccb
op_logical_and
(paren
(paren
id|np-&gt;disc
op_logical_and
op_logical_neg
(paren
id|tp-&gt;usrflag
op_amp
id|UF_NODISC
)paren
)paren
op_logical_or
id|cp-&gt;tag
)paren
)paren
id|idmsg
op_or_assign
l_int|0x40
suffix:semicolon
id|msgptr
op_assign
id|cp-&gt;scsi_smsg
suffix:semicolon
id|msglen
op_assign
l_int|0
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|idmsg
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;tag
)paren
(brace
r_char
id|tag
suffix:semicolon
id|tag
op_assign
id|np-&gt;order
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;Ordered write ops, unordered read ops.&n;&t;&t;*/
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x08
suffix:colon
multiline_comment|/* READ_SMALL (6) */
r_case
l_int|0x28
suffix:colon
multiline_comment|/* READ_BIG  (10) */
r_case
l_int|0xa8
suffix:colon
multiline_comment|/* READ_HUGE (12) */
id|tag
op_assign
id|M_SIMPLE_TAG
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|tag
op_assign
id|M_ORDERED_TAG
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;    **&t;Have to force ordered tag to avoid timeouts&n;&t;    */
r_if
c_cond
(paren
(paren
id|lp
op_assign
id|tp-&gt;lp
(braket
id|cmd-&gt;lun
)braket
)paren
op_logical_and
(paren
id|lp-&gt;force_ordered_tag
)paren
)paren
(brace
id|tag
op_assign
id|M_ORDERED_TAG
suffix:semicolon
id|lp-&gt;force_ordered_tag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TAGS
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;Ordered Queue Tag forced&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tag
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|cp
op_member_access_from_pointer
id|tag
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|nego
)paren
(brace
r_case
id|NS_SYNC
suffix:colon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|3
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_SYNC_REQ
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;maxoffs
ques
c_cond
id|tp-&gt;minsync
suffix:colon
l_int|0
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;maxoffs
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;sync msgout: &quot;
)paren
suffix:semicolon
id|ncr_show_msg
(paren
op_amp
id|cp-&gt;scsi_smsg
(braket
id|msglen
op_minus
l_int|5
)braket
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_WIDE
suffix:colon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|2
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_WIDE_REQ
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;usrwide
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;wide msgout: &quot;
)paren
suffix:semicolon
id|ncr_show_msg
(paren
op_amp
id|cp-&gt;scsi_smsg
(braket
id|msglen
op_minus
l_int|4
)braket
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Build the identify message for getcc.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
id|cp
op_member_access_from_pointer
id|scsi_smsg2
(braket
l_int|0
)braket
op_assign
id|idmsg
suffix:semicolon
id|msglen2
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Build the data descriptors&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
id|segments
op_assign
id|ncr_scatter
(paren
id|cp
comma
id|cp-&gt;cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|segments
OL
l_int|0
)paren
(brace
id|ncr_free_ccb
c_func
(paren
id|np
comma
id|cp
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|DID_ERROR
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Guess xfer direction.&n;&t;**&t;Spare some CPU by testing here frequently opcode.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
r_switch
c_cond
(paren
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x08
suffix:colon
multiline_comment|/*&t;READ(6)&t;&t;&t;&t;08 */
r_case
l_int|0x28
suffix:colon
multiline_comment|/*&t;READ(10)&t;&t;&t;28 */
r_case
l_int|0xA8
suffix:colon
multiline_comment|/*&t;READ(12)&t;&t;&t;A8 */
id|xfer_direction
op_assign
id|XferIn
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0A
suffix:colon
multiline_comment|/*&t;WRITE(6)&t;&t;&t;0A */
r_case
l_int|0x2A
suffix:colon
multiline_comment|/*&t;WRITE(10)&t;&t;&t;2A */
r_case
l_int|0xAA
suffix:colon
multiline_comment|/*&t;WRITE(12)&t;&t;&t;AA */
id|xfer_direction
op_assign
id|XferOut
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|xfer_direction
op_assign
id|guess_xfer_direction
c_func
(paren
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Set the SAVED_POINTER.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
id|cp-&gt;segments
op_assign
id|segments
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;data_len
)paren
id|xfer_direction
op_assign
id|XferNone
suffix:semicolon
r_switch
c_cond
(paren
id|xfer_direction
)paren
(brace
id|u_long
id|endp
suffix:semicolon
r_default
suffix:colon
r_case
id|XferBoth
suffix:colon
id|cp-&gt;phys.header.savep
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|data_io
)paren
suffix:semicolon
id|cp-&gt;phys.header.goalp
op_assign
id|cp-&gt;phys.header.savep
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XferIn
suffix:colon
id|endp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|data_in
)paren
op_plus
id|MAX_SCATTER
op_star
l_int|16
suffix:semicolon
id|cp-&gt;phys.header.goalp
op_assign
id|endp
op_plus
l_int|8
suffix:semicolon
id|cp-&gt;phys.header.savep
op_assign
id|endp
op_minus
id|segments
op_star
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XferOut
suffix:colon
id|endp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|data_out
)paren
op_plus
id|MAX_SCATTER
op_star
l_int|16
suffix:semicolon
id|cp-&gt;phys.header.goalp
op_assign
id|endp
op_plus
l_int|8
suffix:semicolon
id|cp-&gt;phys.header.savep
op_assign
id|endp
op_minus
id|segments
op_star
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XferNone
suffix:colon
id|cp-&gt;phys.header.savep
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|no_data
)paren
suffix:semicolon
id|cp-&gt;phys.header.goalp
op_assign
id|cp-&gt;phys.header.savep
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cp-&gt;phys.header.lastp
op_assign
id|cp-&gt;phys.header.savep
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;fill in ccb&n;&t;**&n;&t;**----------------------------------------------------&n;&t;**&n;&t;**&n;&t;**&t;physical -&gt; virtual backlink&n;&t;**&t;Generic SCSI command&n;&t;*/
id|cp-&gt;phys.header.cp
op_assign
id|cp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Startqueue&n;&t;*/
id|cp-&gt;phys.header.launch.l_paddr
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|select
)paren
suffix:semicolon
id|cp-&gt;phys.header.launch.l_cmd
op_assign
id|SCR_JUMP
suffix:semicolon
multiline_comment|/*&n;&t;**&t;select&n;&t;*/
id|cp-&gt;phys.select.sel_id
op_assign
id|cmd-&gt;target
suffix:semicolon
id|cp-&gt;phys.select.sel_scntl3
op_assign
id|tp-&gt;wval
suffix:semicolon
id|cp-&gt;phys.select.sel_sxfer
op_assign
id|tp-&gt;sval
suffix:semicolon
multiline_comment|/*&n;&t;**&t;message&n;&t;*/
id|cp-&gt;phys.smsg.addr
op_assign
id|CCB_PHYS
(paren
id|cp
comma
id|scsi_smsg
)paren
suffix:semicolon
id|cp-&gt;phys.smsg.size
op_assign
id|msglen
suffix:semicolon
id|cp-&gt;phys.smsg2.addr
op_assign
id|CCB_PHYS
(paren
id|cp
comma
id|scsi_smsg2
)paren
suffix:semicolon
id|cp-&gt;phys.smsg2.size
op_assign
id|msglen2
suffix:semicolon
multiline_comment|/*&n;&t;**&t;command&n;&t;*/
id|cp-&gt;phys.cmd.addr
op_assign
id|vtophys
(paren
op_amp
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|cp-&gt;phys.cmd.size
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
multiline_comment|/*&n;&t;**&t;sense command&n;&t;*/
id|cp-&gt;phys.scmd.addr
op_assign
id|CCB_PHYS
(paren
id|cp
comma
id|sensecmd
)paren
suffix:semicolon
id|cp-&gt;phys.scmd.size
op_assign
l_int|6
suffix:semicolon
multiline_comment|/*&n;&t;**&t;patch requested size into sense command&n;&t;*/
id|cp-&gt;sensecmd
(braket
l_int|0
)braket
op_assign
l_int|0x03
suffix:semicolon
id|cp-&gt;sensecmd
(braket
l_int|1
)braket
op_assign
id|cmd-&gt;lun
op_lshift
l_int|5
suffix:semicolon
id|cp-&gt;sensecmd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;sense data&n;&t;*/
id|cp-&gt;phys.sense.addr
op_assign
id|vtophys
(paren
op_amp
id|cmd-&gt;sense_buffer
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|cp-&gt;phys.sense.size
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;status&n;&t;*/
id|cp-&gt;actualquirks
op_assign
id|tp-&gt;quirks
suffix:semicolon
id|cp-&gt;host_status
op_assign
id|nego
ques
c_cond
id|HS_NEGOTIATE
suffix:colon
id|HS_BUSY
suffix:semicolon
id|cp-&gt;scsi_status
op_assign
id|S_ILLEGAL
suffix:semicolon
id|cp-&gt;parity_status
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;xerr_status
op_assign
id|XE_OK
suffix:semicolon
id|cp-&gt;sync_status
op_assign
id|tp-&gt;sval
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|nego
suffix:semicolon
id|cp-&gt;wide_status
op_assign
id|tp-&gt;wval
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Critical region: start this job.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
multiline_comment|/*&n;&t;**&t;reselect pattern and activate this job.&n;&t;*/
id|cp-&gt;jump_ccb.l_cmd
op_assign
(paren
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|cp-&gt;tag
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Compute a time limit bigger than the middle-level driver one */
r_if
c_cond
(paren
id|cmd-&gt;timeout_per_command
OG
l_int|0
)paren
id|cp-&gt;tlimit
op_assign
id|jiffies
op_plus
id|cmd-&gt;timeout_per_command
op_plus
id|NCR_TIMEOUT_INCREASE
suffix:semicolon
r_else
id|cp-&gt;tlimit
op_assign
id|jiffies
op_plus
l_int|3600
op_star
id|HZ
suffix:semicolon
multiline_comment|/* No timeout=one hour */
id|cp-&gt;magic
op_assign
id|CCB_MAGIC
suffix:semicolon
multiline_comment|/*&n;&t;**&t;insert into start queue.&n;&t;*/
id|qidx
op_assign
id|np-&gt;squeueput
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|qidx
op_ge
id|MAX_START
)paren
id|qidx
op_assign
l_int|0
suffix:semicolon
id|np-&gt;squeue
(braket
id|qidx
)braket
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
suffix:semicolon
id|np-&gt;squeue
(braket
id|np-&gt;squeueput
)braket
op_assign
id|CCB_PHYS
(paren
id|cp
comma
id|phys
)paren
suffix:semicolon
id|np-&gt;squeueput
op_assign
id|qidx
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_QUEUE
)paren
(brace
id|printf
(paren
l_string|&quot;%s: queuepos=%d tryoffset=%d.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|np-&gt;squeueput
comma
(paren
r_int
)paren
(paren
id|np-&gt;script-&gt;startpos
(braket
l_int|0
)braket
op_minus
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|tryloop
)paren
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Script processor may be waiting for reselect.&n;&t;**&t;Wake it up.&n;&t;*/
macro_line|#ifdef&t;SCSI_NCR_DEBUG_ERROR_RECOVERY_SUPPORT
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;stalling
)paren
macro_line|#endif
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;and reenable interrupts&n;&t;*/
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Command is successfully queued.&n;&t;*/
r_return
id|DID_OK
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Start reset process.&n;**&t;If reset in progress do nothing.&n;**&t;The interrupt handler will reinitialize the chip.&n;**&t;The timeout handler will wait for settle_time before &n;**&t;clearing it and so resuming command processing.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_start_reset
r_static
r_void
id|ncr_start_reset
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|settle_delay
)paren
(brace
id|u_long
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;settle_time
)paren
(brace
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;%s: resetting, command processing suspended for %d seconds&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|settle_delay
)paren
suffix:semicolon
id|np-&gt;settle_time
op_assign
id|jiffies
op_plus
id|settle_delay
op_star
id|HZ
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|DELAY
(paren
l_int|1000
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
id|OUTW
(paren
id|nc_sien
comma
id|RST
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_scntl1
comma
id|CRST
)paren
suffix:semicolon
id|DELAY
(paren
l_int|100
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Reset the SCSI BUS.&n;**&t;This is called from the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_reset_bus
r_int
id|ncr_reset_bus
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|sync_reset
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;host
suffix:semicolon
multiline_comment|/*&t;Scsi_Device        *device    = cmd-&gt;device; */
r_struct
id|host_data
op_star
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|ncb_p
id|np
op_assign
id|host_data-&gt;ncb
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
r_int
id|found
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_DEBUG_ERROR_RECOVERY_SUPPORT
r_if
c_cond
(paren
id|np-&gt;stalling
)paren
id|np-&gt;stalling
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n; * Return immediately if reset is in progress.&n; */
r_if
c_cond
(paren
id|np-&gt;settle_time
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_RESET_PUNT
suffix:semicolon
)brace
multiline_comment|/*&n; * Start the reset process.&n; * The script processor is then assumed to be stopped.&n; * Commands will now be queued in the waiting list until a settle &n; * delay of 2 seconds will be completed.&n; */
id|ncr_start_reset
c_func
(paren
id|np
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n; * First, look in the wakeup list&n; */
r_for
c_loop
(paren
id|found
op_assign
l_int|0
comma
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;look for the ccb of this command.&n;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_IDLE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cmd
op_eq
id|cmd
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Then, look in the waiting list&n; */
r_if
c_cond
(paren
op_logical_neg
id|found
op_logical_and
id|retrieve_from_waiting_list
c_func
(paren
l_int|0
comma
id|np
comma
id|cmd
)paren
)paren
id|found
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Wake-up all awaiting commands with DID_RESET.&n; */
id|reset_waiting_list
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n; * Wake-up all pending commands with HS_RESET -&gt; DID_RESET.&n; */
id|ncr_wakeup
c_func
(paren
id|np
comma
id|HS_RESET
)paren
suffix:semicolon
multiline_comment|/*&n; * If the involved command was not in a driver queue, and the &n; * scsi driver told us reset is synchronous, and the command is not &n; * currently in the waiting list, complete it with DID_RESET status,&n; * in order to keep it alive.&n; */
r_if
c_cond
(paren
op_logical_neg
id|found
op_logical_and
id|sync_reset
op_logical_and
op_logical_neg
id|retrieve_from_waiting_list
c_func
(paren
l_int|0
comma
id|np
comma
id|cmd
)paren
)paren
(brace
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_RESET
comma
l_int|0
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_RESET_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Abort an SCSI command.&n;**&t;This is called from the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_abort_command
r_static
r_int
id|ncr_abort_command
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;host
suffix:semicolon
multiline_comment|/*&t;Scsi_Device        *device    = cmd-&gt;device; */
r_struct
id|host_data
op_star
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|ncb_p
id|np
op_assign
id|host_data-&gt;ncb
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
r_int
id|found
suffix:semicolon
r_int
id|retv
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_DEBUG_ERROR_RECOVERY_SUPPORT
r_if
c_cond
(paren
id|np-&gt;stalling
op_eq
l_int|2
)paren
id|np-&gt;stalling
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n; * First, look for the scsi command in the waiting list&n; */
r_if
c_cond
(paren
id|remove_from_waiting_list
c_func
(paren
id|np
comma
id|cmd
)paren
)paren
(brace
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_ABORT
comma
l_int|0
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Then, look in the wakeup list&n; */
r_for
c_loop
(paren
id|found
op_assign
l_int|0
comma
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;look for the ccb of this command.&n;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_IDLE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cmd
op_eq
id|cmd
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
r_if
c_cond
(paren
id|np-&gt;settle_time
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Disable reselect.&n;&t;**      Remove it from startqueue.&n;&t;**&t;Set cp-&gt;tlimit to 0. The ncr_timeout() handler will use &n;&t;**&t;this condition in order to complete the canceled command &n;&t;**&t;after the script skipped the ccb, if necessary.&n;&t;*/
id|cp-&gt;jump_ccb.l_cmd
op_assign
(paren
id|SCR_JUMP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;phys.header.launch.l_paddr
op_eq
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|select
)paren
)paren
(brace
id|printf
(paren
l_string|&quot;%s: abort ccb=%p (skip)&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|cp
)paren
suffix:semicolon
id|cp-&gt;phys.header.launch.l_paddr
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|skip
)paren
suffix:semicolon
)brace
id|cp-&gt;tlimit
op_assign
l_int|0
suffix:semicolon
id|retv
op_assign
id|SCSI_ABORT_PENDING
suffix:semicolon
multiline_comment|/*&n;&t;**      If there are no requests, the script&n;&t;**      processor will sleep on SEL_WAIT_RESEL.&n;&t;**      Let&squot;s wake it up, since it may have to work.&n;&t;*/
macro_line|#ifdef&t;SCSI_NCR_DEBUG_ERROR_RECOVERY_SUPPORT
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;stalling
)paren
macro_line|#endif
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Linux release module stuff.&n;**&n;**&t;Called before unloading the module&n;**&t;Detach the host.&n;**&t;We have to free resources and halt the NCR chip&n;**&n;**==========================================================&n;*/
macro_line|#ifdef MODULE
DECL|function|ncr_detach
r_static
r_int
id|ncr_detach
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|irq
)paren
(brace
id|ccb_p
id|cp
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
r_int
id|target
comma
id|lun
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: releasing host resources&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;**&t;Stop the ncr_timeout process&n;**&t;Set release_stage to 1 and wait that ncr_timeout() set it to 2.&n;*/
macro_line|#ifdef DEBUG_NCR53C8XX
id|printf
c_func
(paren
l_string|&quot;%s: stopping the timer&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
macro_line|#endif
id|np-&gt;release_stage
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|50
suffix:semicolon
id|i
op_logical_and
id|np-&gt;release_stage
op_ne
l_int|2
suffix:semicolon
id|i
op_decrement
)paren
id|DELAY
c_func
(paren
l_int|100000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;release_stage
op_ne
l_int|2
)paren
id|printf
c_func
(paren
l_string|&quot;%s: the timer seems to be already stopped&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_else
id|np-&gt;release_stage
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;**&t;Disable chip interrupts&n;*/
macro_line|#ifdef DEBUG_NCR53C8XX
id|printf
c_func
(paren
l_string|&quot;%s: disabling chip interrupts&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
macro_line|#endif
id|OUTW
(paren
id|nc_sien
comma
l_int|0
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_dien
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;**&t;Free irq&n;*/
macro_line|#ifdef DEBUG_NCR53C8XX
id|printf
c_func
(paren
l_string|&quot;%s: freeing irq %d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,70)
macro_line|#   ifdef SCSI_NCR_SHARE_IRQ
id|free_irq
c_func
(paren
id|irq
comma
id|np
)paren
suffix:semicolon
macro_line|#   else
id|free_irq
c_func
(paren
id|irq
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#   endif
macro_line|#else
id|free_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Reset NCR chip&n;&t;**&t;Restore bios setting for automatic clock detection.&n;&t;*/
id|printf
c_func
(paren
l_string|&quot;%s: resetting chip&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|DELAY
(paren
l_int|1000
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_dmode
comma
id|np-&gt;sv_dmode
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_dcntl
comma
id|np-&gt;sv_dcntl
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_ctest3
comma
id|np-&gt;sv_ctest3
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_ctest4
comma
id|np-&gt;sv_ctest4
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_ctest5
comma
id|np-&gt;sv_ctest5
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_gpcntl
comma
id|np-&gt;sv_gpcntl
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest2
comma
id|np-&gt;sv_stest2
)paren
suffix:semicolon
id|ncr_selectclock
c_func
(paren
id|np
comma
id|np-&gt;sv_scntl3
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Release Memory mapped IO region and IO mapped region&n;&t;*/
macro_line|#ifndef NCR_IOMAPPED
macro_line|#ifdef DEBUG_NCR53C8XX
id|printf
c_func
(paren
l_string|&quot;%s: releasing memory mapped IO region %lx[%d]&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|np-&gt;vaddr
comma
l_int|128
)paren
suffix:semicolon
macro_line|#endif
id|unmap_pci_mem
c_func
(paren
(paren
id|vm_offset_t
)paren
id|np-&gt;vaddr
comma
(paren
id|u_long
)paren
l_int|128
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_NCR53C8XX
id|printf
c_func
(paren
l_string|&quot;%s: releasing memory mapped IO region %lx[%d]&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|np-&gt;vaddr2
comma
l_int|4096
)paren
suffix:semicolon
macro_line|#endif
id|unmap_pci_mem
c_func
(paren
(paren
id|vm_offset_t
)paren
id|np-&gt;vaddr2
comma
(paren
id|u_long
)paren
l_int|4096
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_NCR53C8XX
id|printf
c_func
(paren
l_string|&quot;%s: releasing IO region %x[%d]&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;port
comma
l_int|128
)paren
suffix:semicolon
macro_line|#endif
id|release_region
c_func
(paren
id|np-&gt;port
comma
l_int|128
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Free allocated ccb(s)&n;&t;*/
r_while
c_loop
(paren
(paren
id|cp
op_assign
id|np-&gt;ccb-&gt;link_ccb
)paren
op_ne
l_int|NULL
)paren
(brace
id|np-&gt;ccb-&gt;link_ccb
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_status
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: shall free an active ccb (host_status=%d)&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|cp-&gt;host_status
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_NCR53C8XX
id|printf
c_func
(paren
l_string|&quot;%s: freeing ccb (%lx)&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|cp
)paren
suffix:semicolon
macro_line|#endif
id|m_free
c_func
(paren
id|cp
comma
r_sizeof
(paren
op_star
id|cp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Free allocated tp(s)&n;&t;*/
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
OL
id|MAX_TARGET
suffix:semicolon
id|target
op_increment
)paren
(brace
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
id|MAX_LUN
suffix:semicolon
id|lun
op_increment
)paren
(brace
id|lp
op_assign
id|tp-&gt;lp
(braket
id|lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lp
)paren
(brace
macro_line|#ifdef DEBUG_NCR53C8XX
id|printf
c_func
(paren
l_string|&quot;%s: freeing lp (%lx)&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|lp
)paren
suffix:semicolon
macro_line|#endif
id|m_free
c_func
(paren
id|lp
comma
r_sizeof
(paren
op_star
id|lp
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;%s: host resources successfully released&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Complete execution of a SCSI command.&n;**&t;Signal completion to the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_complete
r_void
id|ncr_complete
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Sanity check&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|cp
op_logical_or
(paren
id|cp-&gt;magic
op_ne
id|CCB_MAGIC
)paren
op_logical_or
op_logical_neg
id|cp-&gt;cmd
)paren
r_return
suffix:semicolon
id|cp-&gt;magic
op_assign
l_int|1
suffix:semicolon
id|cp-&gt;tlimit
op_assign
l_int|0
suffix:semicolon
id|cmd
op_assign
id|cp-&gt;cmd
suffix:semicolon
multiline_comment|/*&n;&t;**&t;No Reselect anymore.&n;&t;*/
id|cp-&gt;jump_ccb.l_cmd
op_assign
(paren
id|SCR_JUMP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;No starting.&n;&t;*/
id|cp-&gt;phys.header.launch.l_paddr
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;timestamp&n;&t;**&t;Optional, spare some CPU time&n;&t;*/
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
id|ncb_profile
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;CCB=%lx STAT=%x/%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cp
op_amp
l_int|0xfff
comma
id|cp-&gt;host_status
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
id|cmd
op_assign
id|cp-&gt;cmd
suffix:semicolon
id|cp-&gt;cmd
op_assign
l_int|NULL
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cmd-&gt;target
)braket
suffix:semicolon
id|lp
op_assign
id|tp-&gt;lp
(braket
id|cmd-&gt;lun
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;We donnot queue more than 1 ccb per target &n;&t;**&t;with negotiation at any time. If this ccb was &n;&t;**&t;used for negotiation, clear this info in the tcb.&n;&t;*/
r_if
c_cond
(paren
id|cp
op_eq
id|tp-&gt;nego_cp
)paren
id|tp-&gt;nego_cp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Check for parity errors.&n;&t;*/
r_if
c_cond
(paren
id|cp-&gt;parity_status
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;%d parity error(s), fallback.&bslash;n&quot;
comma
id|cp-&gt;parity_status
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;fallback to asynch transfer.&n;&t;&t;*/
id|tp-&gt;usrsync
op_assign
l_int|255
suffix:semicolon
id|tp-&gt;period
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Check for extended errors.&n;&t;*/
r_if
c_cond
(paren
id|cp-&gt;xerr_status
op_ne
id|XE_OK
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cp-&gt;xerr_status
)paren
(brace
r_case
id|XE_EXTRA_DATA
suffix:colon
id|printf
(paren
l_string|&quot;extraneous data discarded.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XE_BAD_PHASE
suffix:colon
id|printf
(paren
l_string|&quot;illegal scsi phase (4/5).&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
(paren
l_string|&quot;extended error %d.&bslash;n&quot;
comma
id|cp-&gt;xerr_status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
id|cp-&gt;host_status
op_assign
id|HS_FAIL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Check the status.&n;&t;*/
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
id|S_GOOD
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;All went well.&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_OK
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** if (cp-&gt;phys.header.lastp != cp-&gt;phys.header.goalp)...&n;&t;&t;**&n;&t;&t;**&t;@RESID@&n;&t;&t;**&t;Could dig out the correct value for resid,&n;&t;&t;**&t;but it would be quite complicated.&n;&t;&t;**&n;&t;&t;**&t;The ah1542.c driver sets it to 0 too ...&n;&t;&t;*/
multiline_comment|/*&n;&t;&t;**&t;Try to assign a ccb to this nexus&n;&t;&t;*/
id|ncr_alloc_ccb
(paren
id|np
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;On inquire cmd (0x12) save some data.&n;&t;&t;**&t;Clear questionnable capacities.&n;&t;&t;*/
r_if
c_cond
(paren
id|cmd-&gt;lun
op_eq
l_int|0
op_logical_and
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
l_int|0x12
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;unit
OL
id|SCSI_NCR_MAX_HOST
)paren
(brace
r_if
c_cond
(paren
id|driver_setup.force_sync_nego
)paren
(paren
(paren
r_char
op_star
)paren
id|cmd-&gt;request_buffer
)paren
(braket
l_int|7
)braket
op_or_assign
id|INQ7_SYNC
suffix:semicolon
r_else
(paren
(paren
r_char
op_star
)paren
id|cmd-&gt;request_buffer
)paren
(braket
l_int|7
)braket
op_and_assign
(paren
id|target_capabilities
(braket
id|np-&gt;unit
)braket
dot
id|and_map
(braket
id|cmd-&gt;target
)braket
)paren
suffix:semicolon
)brace
id|bcopy
(paren
id|cmd-&gt;request_buffer
comma
op_amp
id|tp-&gt;inqdata
comma
r_sizeof
(paren
id|tp-&gt;inqdata
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;**&t;set number of tags&n;&t;&t;&t;*/
id|ncr_setmaxtags
(paren
id|np
comma
id|tp
comma
id|driver_setup.default_tags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;**&t;prepare negotiation of synch and wide.&n;&t;&t;&t;*/
id|ncr_negotiate
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;**&t;force quirks update before next command start&n;&t;&t;&t;*/
id|tp-&gt;quirks
op_or_assign
id|QUIRK_UPDATE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Announce changes to the generic driver.&n;&t;&t;*/
r_if
c_cond
(paren
id|lp
)paren
(brace
id|ncr_settags
(paren
id|tp
comma
id|lp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;reqlink
op_ne
id|lp-&gt;actlink
)paren
id|ncr_opennings
(paren
id|np
comma
id|lp
comma
id|cmd
)paren
suffix:semicolon
)brace
suffix:semicolon
id|tp-&gt;bytes
op_add_assign
id|cp-&gt;data_len
suffix:semicolon
id|tp-&gt;transfers
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;If tags was reduced due to queue full,&n;&t;&t;**&t;increase tags if 100 good status received.&n;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;numtags
OL
id|tp-&gt;maxtags
)paren
(brace
op_increment
id|tp-&gt;num_good
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;num_good
op_ge
l_int|100
)paren
(brace
id|tp-&gt;num_good
op_assign
l_int|0
suffix:semicolon
op_increment
id|tp-&gt;numtags
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;numtags
op_eq
l_int|1
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;tagged command queueing resumed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
(paren
id|S_SENSE
op_or
id|S_GOOD
)paren
op_logical_or
id|cp-&gt;scsi_status
op_eq
(paren
id|S_SENSE
op_or
id|S_CHECK_COND
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**   Check condition code&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_OK
comma
id|S_CHECK_COND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
(paren
id|DEBUG_RESULT
op_or
id|DEBUG_TINY
)paren
)paren
(brace
id|u_char
op_star
id|p
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|cmd-&gt;sense_buffer
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printf
(paren
l_string|&quot;&bslash;n%s: sense data:&quot;
comma
id|ncr_name
(paren
id|np
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|14
suffix:semicolon
id|i
op_increment
)paren
id|printf
(paren
l_string|&quot; %x&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
id|S_BUSY
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**   Target is busy.&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_OK
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
id|S_QUEUE_FULL
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**   Target is stuffed.&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_OK
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**  Suspend tagged queuing and start good status counter.&n;&t;&t;**  Announce changes to the generic driver.&n;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;numtags
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;QUEUE FULL! suspending tagged command queueing&bslash;n&quot;
)paren
suffix:semicolon
id|tp-&gt;numtags
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;num_good
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lp
)paren
(brace
id|ncr_settags
(paren
id|tp
comma
id|lp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;reqlink
op_ne
id|lp-&gt;actlink
)paren
id|ncr_opennings
(paren
id|np
comma
id|lp
comma
id|cmd
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_SEL_TIMEOUT
)paren
op_logical_or
(paren
id|cp-&gt;host_status
op_eq
id|HS_TIMEOUT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**   No response&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_TIME_OUT
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_RESET
)paren
(brace
multiline_comment|/*&n;&t;&t;**   SCSI bus reset&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_RESET
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_ABORTED
)paren
(brace
multiline_comment|/*&n;&t;&t;**   Transfer aborted&n;&t;&t;*/
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_ABORT
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;**  Other protocol messes&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;COMMAND FAILED (%x %x) @%p.&bslash;n&quot;
comma
id|cp-&gt;host_status
comma
id|cp-&gt;scsi_status
comma
id|cp
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|DID_ERROR
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;trace output&n;&t;*/
r_if
c_cond
(paren
id|tp-&gt;usrflag
op_amp
id|UF_TRACE
)paren
(brace
id|u_char
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot; CMD:&quot;
)paren
suffix:semicolon
id|p
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cmd-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
id|printf
(paren
l_string|&quot; %x&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
(brace
r_switch
c_cond
(paren
id|cp-&gt;scsi_status
)paren
(brace
r_case
id|S_GOOD
suffix:colon
id|printf
(paren
l_string|&quot;  GOOD&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_CHECK_COND
suffix:colon
id|printf
(paren
l_string|&quot;  SENSE:&quot;
)paren
suffix:semicolon
id|p
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|cmd-&gt;sense_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|14
suffix:semicolon
id|i
op_increment
)paren
id|printf
(paren
l_string|&quot; %x&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
(paren
l_string|&quot;  STAT: %x&bslash;n&quot;
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
id|printf
(paren
l_string|&quot;  HOSTERROR: %x&quot;
comma
id|cp-&gt;host_status
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Free this ccb&n;&t;*/
id|ncr_free_ccb
(paren
id|np
comma
id|cp
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;requeue awaiting scsi commands&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;waiting_list
)paren
id|requeue_waiting_list
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;signal completion to generic driver.&n;&t;*/
id|cmd-&gt;scsi_done
(paren
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Signal all (or one) control block done.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_wakeup
r_void
id|ncr_wakeup
(paren
id|ncb_p
id|np
comma
id|u_long
id|code
)paren
(brace
multiline_comment|/*&n;&t;**&t;Starting at the default ccb and following&n;&t;**&t;the links, complete all jobs with a&n;&t;**&t;host_status greater than &quot;disconnect&quot;.&n;&t;**&n;&t;**&t;If the &quot;code&quot; parameter is not zero,&n;&t;**&t;complete all jobs that are not IDLE.&n;&t;*/
id|ccb_p
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
r_while
c_loop
(paren
id|cp
)paren
(brace
r_switch
c_cond
(paren
id|cp-&gt;host_status
)paren
(brace
r_case
id|HS_IDLE
suffix:colon
r_break
suffix:semicolon
r_case
id|HS_DISCONNECT
suffix:colon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
(brace
id|printf
(paren
l_string|&quot;D&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* fall through */
r_case
id|HS_BUSY
suffix:colon
r_case
id|HS_NEGOTIATE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|code
)paren
r_break
suffix:semicolon
id|cp-&gt;host_status
op_assign
id|code
suffix:semicolon
multiline_comment|/* fall through */
r_default
suffix:colon
id|ncr_complete
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|cp
op_assign
id|cp
op_member_access_from_pointer
id|link_ccb
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Start NCR chip.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_init
r_void
id|ncr_init
(paren
id|ncb_p
id|np
comma
r_char
op_star
id|msg
comma
id|u_long
id|code
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Reset chip.&n;&t;*/
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|DELAY
(paren
l_int|10000
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Message.&n;&t;*/
r_if
c_cond
(paren
id|msg
)paren
id|printf
(paren
id|KERN_INFO
l_string|&quot;%s: restart (%s).&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|msg
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Clear Start Queue&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_START
suffix:semicolon
id|i
op_increment
)paren
id|np
op_member_access_from_pointer
id|squeue
(braket
id|i
)braket
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Start at first entry.&n;&t;*/
id|np-&gt;squeueput
op_assign
l_int|0
suffix:semicolon
id|np-&gt;script0-&gt;startpos
(braket
l_int|0
)braket
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|tryloop
)paren
suffix:semicolon
id|np-&gt;script0-&gt;start0
(braket
l_int|0
)braket
op_assign
id|SCR_INT
op_xor
id|IFFALSE
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Wakeup all pending jobs.&n;&t;*/
id|ncr_wakeup
(paren
id|np
comma
id|code
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Init chip.&n;&t;*/
id|OUTB
(paren
id|nc_istat
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/*  Remove Reset, abort */
id|OUTB
(paren
id|nc_scntl0
comma
id|np-&gt;rv_scntl0
op_or
l_int|0xc0
)paren
suffix:semicolon
multiline_comment|/*  full arb., ena parity, par-&gt;ATN  */
id|OUTB
(paren
id|nc_scntl1
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/*  odd parity, and remove CRST!! */
id|ncr_selectclock
c_func
(paren
id|np
comma
id|np-&gt;rv_scntl3
)paren
suffix:semicolon
multiline_comment|/* Select SCSI clock */
id|OUTB
(paren
id|nc_scid
comma
id|RRE
op_or
id|np-&gt;myaddr
)paren
suffix:semicolon
multiline_comment|/* Adapter SCSI address */
id|OUTW
(paren
id|nc_respid
comma
l_int|1ul
op_lshift
id|np-&gt;myaddr
)paren
suffix:semicolon
multiline_comment|/* Id to respond to */
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
)paren
suffix:semicolon
multiline_comment|/*  Signal Process */
id|OUTB
(paren
id|nc_dmode
comma
id|np-&gt;rv_dmode
)paren
suffix:semicolon
multiline_comment|/* Burst length, dma mode */
id|OUTB
(paren
id|nc_ctest5
comma
id|np-&gt;rv_ctest5
)paren
suffix:semicolon
multiline_comment|/* Large fifo + large burst */
id|OUTB
(paren
id|nc_dcntl
comma
id|NOCOM
op_or
id|np-&gt;rv_dcntl
)paren
suffix:semicolon
multiline_comment|/* Protect SFBR */
id|OUTB
(paren
id|nc_ctest3
comma
id|np-&gt;rv_ctest3
)paren
suffix:semicolon
multiline_comment|/* Write and invalidate */
id|OUTB
(paren
id|nc_ctest4
comma
id|np-&gt;rv_ctest4
)paren
suffix:semicolon
multiline_comment|/* Master parity checking */
id|OUTB
(paren
id|nc_stest2
comma
id|EXT
op_or
id|np-&gt;rv_stest2
)paren
suffix:semicolon
multiline_comment|/* Extended Sreq/Sack filtering */
id|OUTB
(paren
id|nc_stest3
comma
id|TE
)paren
suffix:semicolon
multiline_comment|/* TolerANT enable */
id|OUTB
(paren
id|nc_stime0
comma
l_int|0x0d
)paren
suffix:semicolon
multiline_comment|/* HTH disabled  STO 0.4 sec. */
multiline_comment|/*&n;&t;**&t;Disable disconnects.&n;&t;*/
id|np-&gt;disc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**    Enable GPIO0 pin for writing if LED support.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_LED0
)paren
(brace
id|OUTOFFB
(paren
id|nc_gpcntl
comma
l_int|0x01
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    Upload the script into on-board RAM&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;vaddr2
)paren
(brace
r_if
c_cond
(paren
id|bootverbose
)paren
id|printf
(paren
l_string|&quot;%s: copying script fragments into the on-board RAM ...&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|bcopy
c_func
(paren
id|np-&gt;script0
comma
id|np-&gt;script
comma
r_sizeof
(paren
r_struct
id|script
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**      enable ints&n;&t;*/
id|OUTW
(paren
id|nc_sien
comma
id|STO
op_or
id|HTH
op_or
id|MA
op_or
id|SGE
op_or
id|UDC
op_or
id|RST
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_dien
comma
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|SSI
op_or
id|SIR
op_or
id|IID
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;For 895/6 enable SBMC interrupt and save current SCSI bus mode.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA2
)paren
(brace
id|OUTONW
(paren
id|nc_sien
comma
id|SBMC
)paren
suffix:semicolon
id|np-&gt;scsi_mode
op_assign
id|INB
(paren
id|nc_stest4
)paren
op_amp
id|SMODE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Fill in target structure.&n;&t;**&t;Reinitialize usrsync.&n;&t;**&t;Reinitialize usrwide.&n;&t;**&t;Prepare sync negotiation according to actual SCSI bus mode.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|tp-&gt;sval
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;wval
op_assign
id|np-&gt;rv_scntl3
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;usrsync
op_ne
l_int|255
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;usrsync
op_le
id|np-&gt;maxsync
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;usrsync
OL
id|np-&gt;minsync
)paren
(brace
id|tp-&gt;usrsync
op_assign
id|np-&gt;minsync
suffix:semicolon
)brace
)brace
r_else
id|tp-&gt;usrsync
op_assign
l_int|255
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;usrwide
OG
id|np-&gt;maxwide
)paren
id|tp-&gt;usrwide
op_assign
id|np-&gt;maxwide
suffix:semicolon
id|ncr_negotiate
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    Start script processor.&n;&t;*/
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|start
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Prepare the negotiation values for wide and&n;**&t;synchronous transfers.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_negotiate
r_static
r_void
id|ncr_negotiate
(paren
r_struct
id|ncb
op_star
id|np
comma
r_struct
id|tcb
op_star
id|tp
)paren
(brace
multiline_comment|/*&n;&t;**&t;minsync unit is 4ns !&n;&t;*/
id|u_long
id|minsync
op_assign
id|tp-&gt;usrsync
suffix:semicolon
multiline_comment|/*&n;&t;**&t;SCSI bus mode limit&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;scsi_mode
op_logical_and
id|np-&gt;scsi_mode
op_eq
id|SMODE_SE
)paren
(brace
r_if
c_cond
(paren
id|minsync
OL
l_int|12
)paren
id|minsync
op_assign
l_int|12
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;if not scsi 2&n;&t;**&t;don&squot;t believe FAST!&n;&t;*/
r_if
c_cond
(paren
(paren
id|minsync
OL
l_int|50
)paren
op_logical_and
(paren
id|tp-&gt;inqdata
(braket
l_int|2
)braket
op_amp
l_int|0x0f
)paren
OL
l_int|2
)paren
id|minsync
op_assign
l_int|50
suffix:semicolon
multiline_comment|/*&n;&t;**&t;our limit ..&n;&t;*/
r_if
c_cond
(paren
id|minsync
OL
id|np-&gt;minsync
)paren
id|minsync
op_assign
id|np-&gt;minsync
suffix:semicolon
multiline_comment|/*&n;&t;**&t;divider limit&n;&t;*/
r_if
c_cond
(paren
id|minsync
OG
id|np-&gt;maxsync
)paren
id|minsync
op_assign
l_int|255
suffix:semicolon
id|tp-&gt;minsync
op_assign
id|minsync
suffix:semicolon
id|tp-&gt;maxoffs
op_assign
(paren
id|minsync
OL
l_int|255
ques
c_cond
id|np-&gt;maxoffs
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;period=0: has to negotiate sync transfer&n;&t;*/
id|tp-&gt;period
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;widedone=0: has to negotiate wide transfer&n;&t;*/
id|tp-&gt;widedone
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Get clock factor and sync divisor for a given &n;**&t;synchronous factor period.&n;**&t;Returns the clock factor (in sxfer) and scntl3 &n;**&t;synchronous divisor field.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_getsync
r_static
r_void
id|ncr_getsync
c_func
(paren
id|ncb_p
id|np
comma
id|u_char
id|sfac
comma
id|u_char
op_star
id|fakp
comma
id|u_char
op_star
id|scntl3p
)paren
(brace
id|u_long
id|clk
op_assign
id|np-&gt;clock_khz
suffix:semicolon
multiline_comment|/* SCSI clock frequency in kHz&t;*/
r_int
id|div
op_assign
id|np-&gt;clock_divn
suffix:semicolon
multiline_comment|/* Number of divisors supported&t;*/
id|u_long
id|fak
suffix:semicolon
multiline_comment|/* Sync factor in sxfer&t;&t;*/
id|u_long
id|per
suffix:semicolon
multiline_comment|/* Period in tenths of ns&t;*/
id|u_long
id|kpc
suffix:semicolon
multiline_comment|/* (per * clk)&t;&t;&t;*/
multiline_comment|/*&n;&t;**&t;Compute the synchronous period in tenths of nano-seconds&n;&t;*/
r_if
c_cond
(paren
id|sfac
op_le
l_int|10
)paren
id|per
op_assign
l_int|250
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sfac
op_eq
l_int|11
)paren
id|per
op_assign
l_int|303
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sfac
op_eq
l_int|12
)paren
id|per
op_assign
l_int|500
suffix:semicolon
r_else
id|per
op_assign
l_int|40
op_star
id|sfac
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Look for the greatest clock divisor that allows an &n;&t;**&t;input speed faster than the period.&n;&t;*/
id|kpc
op_assign
id|per
op_star
id|clk
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|div
op_ge
l_int|0
)paren
r_if
c_cond
(paren
id|kpc
op_ge
(paren
id|div_10M
(braket
id|div
)braket
op_lshift
l_int|2
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Calculate the lowest clock factor that allows an output &n;&t;**&t;speed not faster than the period.&n;&t;*/
id|fak
op_assign
(paren
id|kpc
op_minus
l_int|1
)paren
op_div
id|div_10M
(braket
id|div
)braket
op_plus
l_int|1
suffix:semicolon
macro_line|#if 0&t;/* This optimization does not seem very usefull */
id|per
op_assign
(paren
id|fak
op_star
id|div_10M
(braket
id|div
)braket
)paren
op_div
id|clk
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Why not to try the immediate lower divisor and to choose &n;&t;**&t;the one that allows the fastest output speed ?&n;&t;**&t;We dont want input speed too much greater than output speed.&n;&t;*/
r_if
c_cond
(paren
id|div
op_ge
l_int|1
op_logical_and
id|fak
OL
l_int|8
)paren
(brace
id|u_long
id|fak2
comma
id|per2
suffix:semicolon
id|fak2
op_assign
(paren
id|kpc
op_minus
l_int|1
)paren
op_div
id|div_10M
(braket
id|div
op_minus
l_int|1
)braket
op_plus
l_int|1
suffix:semicolon
id|per2
op_assign
(paren
id|fak2
op_star
id|div_10M
(braket
id|div
op_minus
l_int|1
)braket
)paren
op_div
id|clk
suffix:semicolon
r_if
c_cond
(paren
id|per2
OL
id|per
op_logical_and
id|fak2
op_le
l_int|8
)paren
(brace
id|fak
op_assign
id|fak2
suffix:semicolon
id|per
op_assign
id|per2
suffix:semicolon
op_decrement
id|div
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|fak
OL
l_int|4
)paren
id|fak
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* Should never happen, too bad ... */
multiline_comment|/*&n;&t;**&t;Compute and return sync parameters for the ncr&n;&t;*/
op_star
id|fakp
op_assign
id|fak
op_minus
l_int|4
suffix:semicolon
op_star
id|scntl3p
op_assign
(paren
(paren
id|div
op_plus
l_int|1
)paren
op_lshift
l_int|4
)paren
op_plus
(paren
id|sfac
OL
l_int|25
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Set actual values, sync status and patch all ccbs of &n;**&t;a target according to new sync/wide agreement.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_set_sync_wide_status
r_static
r_void
id|ncr_set_sync_wide_status
(paren
id|ncb_p
id|np
comma
id|u_char
id|target
)paren
(brace
id|ccb_p
id|cp
suffix:semicolon
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;set actual value and sync_status&n;&t;*/
id|OUTB
(paren
id|nc_sxfer
comma
id|tp-&gt;sval
)paren
suffix:semicolon
id|np-&gt;sync_st
op_assign
id|tp-&gt;sval
suffix:semicolon
id|OUTB
(paren
id|nc_scntl3
comma
id|tp-&gt;wval
)paren
suffix:semicolon
id|np-&gt;wide_st
op_assign
id|tp-&gt;wval
suffix:semicolon
multiline_comment|/*&n;&t;**&t;patch ALL ccbs of this target.&n;&t;*/
r_for
c_loop
(paren
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;cmd
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cmd-&gt;target
op_ne
id|target
)paren
r_continue
suffix:semicolon
id|cp-&gt;sync_status
op_assign
id|tp-&gt;sval
suffix:semicolon
id|cp-&gt;wide_status
op_assign
id|tp-&gt;wval
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Switch sync mode for current job and it&squot;s target&n;**&n;**==========================================================&n;*/
DECL|function|ncr_setsync
r_static
r_void
id|ncr_setsync
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|scntl3
comma
id|u_char
id|sxfer
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|u_char
id|target
op_assign
id|INB
(paren
id|nc_ctest0
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|u_char
id|idiv
suffix:semicolon
m_assert
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
suffix:semicolon
id|cmd
op_assign
id|cp-&gt;cmd
suffix:semicolon
m_assert
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
r_return
suffix:semicolon
m_assert
(paren
id|target
op_eq
(paren
id|cmd-&gt;target
op_amp
l_int|0xf
)paren
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scntl3
op_logical_or
op_logical_neg
(paren
id|sxfer
op_amp
l_int|0x1f
)paren
)paren
id|scntl3
op_assign
id|np-&gt;rv_scntl3
suffix:semicolon
id|scntl3
op_assign
(paren
id|scntl3
op_amp
l_int|0xf0
)paren
op_or
(paren
id|tp-&gt;wval
op_amp
id|EWS
)paren
op_or
(paren
id|np-&gt;rv_scntl3
op_amp
l_int|0x07
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Deduce the value of controller sync period from scntl3.&n;&t;**&t;period is in tenths of nano-seconds.&n;&t;*/
id|idiv
op_assign
(paren
(paren
id|scntl3
op_rshift
l_int|4
)paren
op_amp
l_int|0x7
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sxfer
op_amp
l_int|0x1f
)paren
op_logical_and
id|idiv
)paren
id|tp-&gt;period
op_assign
(paren
(paren
(paren
id|sxfer
op_rshift
l_int|5
)paren
op_plus
l_int|4
)paren
op_star
id|div_10M
(braket
id|idiv
op_minus
l_int|1
)braket
)paren
op_div
id|np-&gt;clock_khz
suffix:semicolon
r_else
id|tp-&gt;period
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/*&n;&t;**&t; Stop there if sync parameters are unchanged&n;&t;*/
r_if
c_cond
(paren
id|tp-&gt;sval
op_eq
id|sxfer
op_logical_and
id|tp-&gt;wval
op_eq
id|scntl3
)paren
r_return
suffix:semicolon
id|tp-&gt;sval
op_assign
id|sxfer
suffix:semicolon
id|tp-&gt;wval
op_assign
id|scntl3
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Bells and whistles   ;-)&n;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sxfer
op_amp
l_int|0x01f
)paren
(brace
r_int
id|f10
op_assign
l_int|100000
op_lshift
(paren
id|tp-&gt;widedone
ques
c_cond
id|tp-&gt;widedone
op_minus
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_int
id|mb10
op_assign
(paren
id|f10
op_plus
id|tp-&gt;period
op_div
l_int|2
)paren
op_div
id|tp-&gt;period
suffix:semicolon
r_char
op_star
id|scsi
suffix:semicolon
multiline_comment|/*&n;&t;&t;**  Disable extended Sreq/Sack filtering&n;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;period
op_le
l_int|2000
)paren
id|OUTOFFB
(paren
id|nc_stest2
comma
id|EXT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Bells and whistles   ;-)&n;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;period
OL
l_int|500
)paren
id|scsi
op_assign
l_string|&quot;FAST-40&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;period
OL
l_int|1000
)paren
id|scsi
op_assign
l_string|&quot;FAST-20&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;period
OL
l_int|2000
)paren
id|scsi
op_assign
l_string|&quot;FAST-10&quot;
suffix:semicolon
r_else
id|scsi
op_assign
l_string|&quot;SLOW&quot;
suffix:semicolon
id|printf
(paren
l_string|&quot;%s %sSCSI %d.%d MB/s (%d ns, offset %d)&bslash;n&quot;
comma
id|scsi
comma
id|tp-&gt;widedone
OG
l_int|1
ques
c_cond
l_string|&quot;WIDE &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|mb10
op_div
l_int|10
comma
id|mb10
op_mod
l_int|10
comma
id|tp-&gt;period
op_div
l_int|10
comma
id|sxfer
op_amp
l_int|0x1f
)paren
suffix:semicolon
)brace
r_else
id|printf
(paren
l_string|&quot;%sasynchronous.&bslash;n&quot;
comma
id|tp-&gt;widedone
OG
l_int|1
ques
c_cond
l_string|&quot;wide &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;set actual value and sync_status&n;&t;**&t;patch ALL ccbs of this target.&n;&t;*/
id|ncr_set_sync_wide_status
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Switch wide mode for current job and it&squot;s target&n;**&t;SCSI specs say: a SCSI device that accepts a WDTR &n;**&t;message shall reset the synchronous agreement to &n;**&t;asynchronous mode.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_setwide
r_static
r_void
id|ncr_setwide
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|wide
comma
id|u_char
id|ack
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|u_short
id|target
op_assign
id|INB
(paren
id|nc_ctest0
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|u_char
id|scntl3
suffix:semicolon
id|u_char
id|sxfer
suffix:semicolon
m_assert
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
suffix:semicolon
id|cmd
op_assign
id|cp-&gt;cmd
suffix:semicolon
m_assert
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
r_return
suffix:semicolon
m_assert
(paren
id|target
op_eq
(paren
id|cmd-&gt;target
op_amp
l_int|0xf
)paren
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|tp-&gt;widedone
op_assign
id|wide
op_plus
l_int|1
suffix:semicolon
id|scntl3
op_assign
(paren
id|tp-&gt;wval
op_amp
(paren
op_complement
id|EWS
)paren
)paren
op_or
(paren
id|wide
ques
c_cond
id|EWS
suffix:colon
l_int|0
)paren
suffix:semicolon
id|sxfer
op_assign
id|ack
ques
c_cond
l_int|0
suffix:colon
id|tp-&gt;sval
suffix:semicolon
multiline_comment|/*&n;&t;**&t; Stop there if sync/wide parameters are unchanged&n;&t;*/
r_if
c_cond
(paren
id|tp-&gt;sval
op_eq
id|sxfer
op_logical_and
id|tp-&gt;wval
op_eq
id|scntl3
)paren
r_return
suffix:semicolon
id|tp-&gt;sval
op_assign
id|sxfer
suffix:semicolon
id|tp-&gt;wval
op_assign
id|scntl3
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Bells and whistles   ;-)&n;&t;*/
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scntl3
op_amp
id|EWS
)paren
id|printf
(paren
l_string|&quot;WIDE SCSI (16 bit) enabled.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printf
(paren
l_string|&quot;WIDE SCSI disabled.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;set actual value and sync_status&n;&t;**&t;patch ALL ccbs of this target.&n;&t;*/
id|ncr_set_sync_wide_status
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Switch tagged mode for a target.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_setmaxtags
r_static
r_void
id|ncr_setmaxtags
(paren
id|ncb_p
id|np
comma
id|tcb_p
id|tp
comma
id|u_long
id|numtags
)paren
(brace
r_int
id|l
suffix:semicolon
r_if
c_cond
(paren
id|numtags
OG
id|tp-&gt;usrtags
)paren
id|numtags
op_assign
id|tp-&gt;usrtags
suffix:semicolon
id|tp-&gt;numtags
op_assign
id|numtags
suffix:semicolon
id|tp-&gt;maxtags
op_assign
id|numtags
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|MAX_LUN
suffix:semicolon
id|l
op_increment
)paren
(brace
id|lcb_p
id|lp
suffix:semicolon
id|u_char
id|wastags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp
)paren
r_break
suffix:semicolon
id|lp
op_assign
id|tp-&gt;lp
(braket
id|l
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_continue
suffix:semicolon
id|wastags
op_assign
id|lp-&gt;usetags
suffix:semicolon
id|ncr_settags
(paren
id|tp
comma
id|lp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|numtags
OG
l_int|1
op_logical_and
id|lp-&gt;reqccbs
OG
l_int|1
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|tp
op_minus
id|np-&gt;target
comma
id|l
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;using tagged command queueing, up to %ld cmds/lun&bslash;n&quot;
comma
id|numtags
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|numtags
op_le
l_int|1
op_logical_and
id|wastags
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|tp
op_minus
id|np-&gt;target
comma
id|l
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;disabling tagged command queueing&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
suffix:semicolon
)brace
DECL|function|ncr_settags
r_static
r_void
id|ncr_settags
(paren
id|tcb_p
id|tp
comma
id|lcb_p
id|lp
)paren
(brace
id|u_char
id|reqtags
comma
id|tmp
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|tp
)paren
op_logical_or
(paren
op_logical_neg
id|lp
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;only devices conformant to ANSI Version &gt;= 2&n;&t;**&t;only devices capable of tagges commands&n;&t;**&t;only disk devices&n;&t;**&t;only if enabled by user ..&n;&t;*/
r_if
c_cond
(paren
(paren
id|tp-&gt;inqdata
(braket
l_int|2
)braket
op_amp
l_int|0x7
)paren
op_ge
l_int|2
op_logical_and
(paren
id|tp-&gt;inqdata
(braket
l_int|7
)braket
op_amp
id|INQ7_QUEUE
)paren
op_logical_and
(paren
(paren
id|tp-&gt;inqdata
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
op_eq
l_int|0x00
)paren
op_logical_and
id|tp-&gt;numtags
OG
l_int|1
)paren
(brace
id|reqtags
op_assign
id|tp-&gt;numtags
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;actlink
op_le
l_int|1
)paren
id|lp-&gt;usetags
op_assign
id|reqtags
suffix:semicolon
)brace
r_else
(brace
id|reqtags
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;actlink
op_le
l_int|1
)paren
id|lp-&gt;usetags
op_assign
l_int|0
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;don&squot;t announce more than available.&n;&t;*/
id|tmp
op_assign
id|lp-&gt;actccbs
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OG
id|reqtags
)paren
id|tmp
op_assign
id|reqtags
suffix:semicolon
id|lp-&gt;reqlink
op_assign
id|tmp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;don&squot;t discard if announced.&n;&t;*/
id|tmp
op_assign
id|lp-&gt;actlink
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
id|reqtags
)paren
id|tmp
op_assign
id|reqtags
suffix:semicolon
id|lp-&gt;reqccbs
op_assign
id|tmp
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------&n;**&n;**&t;handle user commands&n;**&n;**----------------------------------------------------&n;*/
macro_line|#ifdef SCSI_NCR_USER_COMMAND_SUPPORT
DECL|function|ncr_usercmd
r_static
r_void
id|ncr_usercmd
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|t
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
r_switch
c_cond
(paren
id|np-&gt;user.cmd
)paren
(brace
r_case
l_int|0
suffix:colon
r_return
suffix:semicolon
r_case
id|UC_SETSYNC
suffix:colon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|np-&gt;user.target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|t
)braket
suffix:semicolon
id|tp-&gt;usrsync
op_assign
id|np-&gt;user.data
suffix:semicolon
id|ncr_negotiate
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETTAGS
suffix:colon
r_if
c_cond
(paren
id|np-&gt;user.data
OG
id|SCSI_NCR_MAX_TAGS
)paren
id|np-&gt;user.data
op_assign
id|SCSI_NCR_MAX_TAGS
suffix:semicolon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|np-&gt;user.target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|np-&gt;target
(braket
id|t
)braket
dot
id|usrtags
op_assign
id|np-&gt;user.data
suffix:semicolon
id|ncr_setmaxtags
(paren
id|np
comma
op_amp
id|np-&gt;target
(braket
id|t
)braket
comma
id|np-&gt;user.data
)paren
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETDEBUG
suffix:colon
macro_line|#ifdef SCSI_NCR_DEBUG_INFO_SUPPORT
id|ncr_debug
op_assign
id|np-&gt;user.data
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|UC_SETORDER
suffix:colon
id|np-&gt;order
op_assign
id|np-&gt;user.data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETWIDE
suffix:colon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
id|u_long
id|size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|np-&gt;user.target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|t
)braket
suffix:semicolon
id|size
op_assign
id|np-&gt;user.data
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|np-&gt;maxwide
)paren
id|size
op_assign
id|np-&gt;maxwide
suffix:semicolon
id|tp-&gt;usrwide
op_assign
id|size
suffix:semicolon
id|ncr_negotiate
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETFLAG
suffix:colon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|np-&gt;user.target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|t
)braket
suffix:semicolon
id|tp-&gt;usrflag
op_assign
id|np-&gt;user.data
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_CLEARPROF
suffix:colon
id|bzero
c_func
(paren
op_amp
id|np-&gt;profile
comma
r_sizeof
(paren
id|np-&gt;profile
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef&t;UC_DEBUG_ERROR_RECOVERY
r_case
id|UC_DEBUG_ERROR_RECOVERY
suffix:colon
id|np-&gt;debug_error_recovery
op_assign
id|np-&gt;user.data
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
)brace
id|np-&gt;user.cmd
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*=====================================================================&n;**&n;**    Embedded error recovery debugging code.&n;**&n;**=====================================================================&n;**&n;**    This code is conditionned by SCSI_NCR_DEBUG_ERROR_RECOVERY_SUPPORT.&n;**    It only can be enabled after boot-up with a control command.&n;**&n;**    Every 30 seconds the timer handler of the driver decides to &n;**    change the behaviour of the driver in order to trigger errors.&n;**&n;**    If last command was &quot;debug_error_recovery sge&quot;, the driver &n;**    sets sync offset of all targets that use sync transfers to 2, &n;**    and so hopes a SCSI gross error at the next read operation.&n;**&n;**    If last command was &quot;debug_error_recovery abort&quot;, the driver &n;**    does not signal new scsi commands to the script processor, until &n;**    it is asked to abort or reset a command by the mid-level driver.&n;**&n;**    If last command was &quot;debug_error_recovery reset&quot;, the driver &n;**    does not signal new scsi commands to the script processor, until &n;**    it is asked to reset a command by the mid-level driver.&n;**&n;**    If last command was &quot;debug_error_recovery parity&quot;, the driver &n;**    will assert ATN on the next DATA IN phase mismatch, and so will &n;**    behave as if a parity error had been detected.&n;**&n;**    The command &quot;debug_error_recovery none&quot; makes the driver behave &n;**    normaly.&n;**&n;**=====================================================================&n;*/
macro_line|#ifdef&t;SCSI_NCR_DEBUG_ERROR_RECOVERY_SUPPORT
DECL|function|ncr_trigger_errors
r_static
r_void
id|ncr_trigger_errors
(paren
id|ncb_p
id|np
)paren
(brace
multiline_comment|/*&n;&t;** &t;If np-&gt;debug_error_recovery is not zero, we want to &n;&t;**&t;simulate common errors in order to test error recovery.&n;&t;*/
r_do
(brace
r_static
id|u_long
id|last
op_assign
l_int|0l
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;debug_error_recovery
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|last
)paren
id|last
op_assign
id|jiffies
suffix:semicolon
r_else
r_if
c_cond
(paren
id|jiffies
OL
id|last
op_plus
l_int|30
op_star
id|HZ
)paren
r_break
suffix:semicolon
id|last
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This one triggers SCSI gross errors.&n;&t;&t; */
r_if
c_cond
(paren
id|np-&gt;debug_error_recovery
op_eq
l_int|1
)paren
(brace
r_int
id|i
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: testing error recovery from SCSI gross error...&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;target
(braket
id|i
)braket
dot
id|sval
op_amp
l_int|0x1f
)paren
(brace
id|np-&gt;target
(braket
id|i
)braket
dot
id|sval
op_and_assign
op_complement
l_int|0x1f
suffix:semicolon
id|np-&gt;target
(braket
id|i
)braket
dot
id|sval
op_add_assign
l_int|2
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; * This one triggers abort from the mid-level driver.&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|np-&gt;debug_error_recovery
op_eq
l_int|2
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: testing error recovery from mid-level driver abort()...&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;stalling
op_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * This one triggers reset from the mid-level driver.&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|np-&gt;debug_error_recovery
op_eq
l_int|3
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: testing error recovery from mid-level driver reset()...&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;stalling
op_assign
l_int|3
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * This one set ATN on phase mismatch in DATA IN phase and so &n;&t;&t; * will behave as on scsi parity error detected.&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|np-&gt;debug_error_recovery
op_eq
l_int|4
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: testing data in parity error...&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;assert_atn
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;ncr timeout handler.&n;**&n;**&n;**==========================================================&n;**&n;**&t;Misused to keep the driver running when&n;**&t;interrupts are not configured correctly.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_timeout
r_static
r_void
id|ncr_timeout
(paren
id|ncb_p
id|np
)paren
(brace
id|u_long
id|thistime
op_assign
id|jiffies
suffix:semicolon
id|u_long
id|count
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|t
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If release process in progress, let&squot;s go&n;&t;**&t;Set the release stage from 1 to 2 to synchronize&n;&t;**&t;with the release process.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;release_stage
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;release_stage
op_eq
l_int|1
)paren
id|np-&gt;release_stage
op_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
id|np-&gt;timer.expires
op_assign
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,0)
id|jiffies
op_plus
macro_line|#endif
id|SCSI_NCR_TIMER_INTERVAL
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|np-&gt;timer
)paren
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_DEBUG_ERROR_RECOVERY_SUPPORT
id|ncr_trigger_errors
(paren
id|np
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;If we are resetting the ncr, wait for settle_time before &n;&t;**&t;clearing it. Then command processing will be resumed.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;settle_time
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;settle_time
op_le
id|thistime
)paren
(brace
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;%s: command processing resumed&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|np-&gt;settle_time
op_assign
l_int|0
suffix:semicolon
id|np-&gt;disc
op_assign
l_int|1
suffix:semicolon
id|requeue_waiting_list
c_func
(paren
id|np
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Since the generic scsi driver only allows us 0.5 second &n;&t;**&t;to perform abort of a command, we must look at ccbs about &n;&t;**&t;every 0.25 second.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;lasttime
op_plus
(paren
id|HZ
op_rshift
l_int|2
)paren
op_le
id|thistime
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;block ncr interrupts&n;&t;&t;*/
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|np-&gt;lasttime
op_assign
id|thistime
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Reset profile data to avoid ugly overflow&n;&t;&t;**&t;(Limited to 1024 GB for 32 bit architecture)&n;&t;&t;*/
r_if
c_cond
(paren
id|np-&gt;profile.num_kbytes
OG
(paren
op_complement
l_int|0UL
op_rshift
l_int|2
)paren
)paren
id|bzero
c_func
(paren
op_amp
id|np-&gt;profile
comma
r_sizeof
(paren
id|np-&gt;profile
)paren
)paren
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;handle ncr chip timeouts&n;&t;&t;**&n;&t;&t;**&t;Assumption:&n;&t;&t;**&t;We have a chance to arbitrate for the&n;&t;&t;**&t;SCSI bus at least every 10 seconds.&n;&t;&t;**&n;&t;&t;**----------------------------------------------------&n;&t;&t;*/
id|t
op_assign
(paren
id|thistime
op_minus
id|np-&gt;heartbeat
)paren
op_div
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|t
OL
l_int|2
)paren
id|np-&gt;latetime
op_assign
l_int|0
suffix:semicolon
r_else
id|np-&gt;latetime
op_increment
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;handle ccb timeouts&n;&t;&t;**&n;&t;&t;**----------------------------------------------------&n;&t;&t;*/
r_for
c_loop
(paren
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;**&t;look for timed out ccbs.&n;&t;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;host_status
)paren
r_continue
suffix:semicolon
id|count
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;**&t;Have to force ordered tag to avoid timeouts&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;cmd
op_logical_and
id|cp-&gt;tlimit
op_logical_and
id|cp-&gt;tlimit
op_le
id|thistime
op_plus
id|NCR_TIMEOUT_INCREASE
op_plus
id|SCSI_NCR_TIMEOUT_ALERT
)paren
(brace
id|lcb_p
id|lp
suffix:semicolon
id|lp
op_assign
id|np-&gt;target
(braket
id|cp-&gt;cmd-&gt;target
)braket
dot
id|lp
(braket
id|cp-&gt;cmd-&gt;lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lp
op_logical_and
op_logical_neg
id|lp-&gt;force_ordered_tag
)paren
(brace
id|lp-&gt;force_ordered_tag
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t;**&t;ncr_abort_command() cannot complete canceled &n;&t;&t;&t;**&t;commands immediately. It sets tlimit to zero &n;&t;&t;&t;**&t;and ask the script to skip the scsi process if &n;&t;&t;&t;**&t;necessary. We have to complete this work here.&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;tlimit
)paren
r_continue
suffix:semicolon
r_switch
c_cond
(paren
id|cp-&gt;host_status
)paren
(brace
r_case
id|HS_BUSY
suffix:colon
r_case
id|HS_NEGOTIATE
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;** still in start queue ?&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;phys.header.launch.l_paddr
op_eq
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|skip
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|HS_DISCONNECT
suffix:colon
id|cp-&gt;host_status
op_assign
id|HS_ABORTED
suffix:semicolon
)brace
suffix:semicolon
id|cp-&gt;tag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;**&t;wakeup this ccb.&n;&t;&t;&t;*/
id|ncr_complete
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_DEBUG_ERROR_RECOVERY_SUPPORT
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;stalling
)paren
macro_line|#endif
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_BROKEN_INTR
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_istat
)paren
op_amp
(paren
id|INTF
op_or
id|SIP
op_or
id|DIP
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;Process pending interrupts.&n;&t;&t;*/
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;{&quot;
)paren
suffix:semicolon
id|ncr_exception
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_BROKEN_INTR */
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;log message for real hard errors&n;**&n;**&t;&quot;ncr0 targ 0?: ERROR (ds:si) (so-si-sd) (sxfer/scntl3) @ name (dsp:dbc).&quot;&n;**&t;&quot;&t;      reg: r0 r1 r2 r3 r4 r5 r6 ..... rf.&quot;&n;**&n;**&t;exception register:&n;**&t;&t;ds:&t;dstat&n;**&t;&t;si:&t;sist&n;**&n;**&t;SCSI bus lines:&n;**&t;&t;so:&t;control lines as driver by NCR.&n;**&t;&t;si:&t;control lines as seen by NCR.&n;**&t;&t;sd:&t;scsi data lines as seen by NCR.&n;**&n;**&t;wide/fastmode:&n;**&t;&t;sxfer:&t;(see the manual)&n;**&t;&t;scntl3:&t;(see the manual)&n;**&n;**&t;current script command:&n;**&t;&t;dsp:&t;script adress (relative to start of script).&n;**&t;&t;dbc:&t;first word of script command.&n;**&n;**&t;First 16 register of the chip:&n;**&t;&t;r0..rf&n;**&n;**==========================================================&n;*/
DECL|function|ncr_log_hard_error
r_static
r_void
id|ncr_log_hard_error
c_func
(paren
id|ncb_p
id|np
comma
id|u_short
id|sist
comma
id|u_char
id|dstat
)paren
(brace
id|u_int32
id|dsp
suffix:semicolon
r_int
id|script_ofs
suffix:semicolon
r_int
id|script_size
suffix:semicolon
r_char
op_star
id|script_name
suffix:semicolon
id|u_char
op_star
id|script_base
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dsp
OG
id|np-&gt;p_script
op_logical_and
id|dsp
op_le
id|np-&gt;p_script
op_plus
r_sizeof
(paren
r_struct
id|script
)paren
)paren
(brace
id|script_ofs
op_assign
id|dsp
op_minus
id|np-&gt;p_script
suffix:semicolon
id|script_size
op_assign
r_sizeof
(paren
r_struct
id|script
)paren
suffix:semicolon
id|script_base
op_assign
(paren
id|u_char
op_star
)paren
id|np-&gt;script
suffix:semicolon
id|script_name
op_assign
l_string|&quot;script&quot;
suffix:semicolon
)brace
r_else
(brace
id|script_ofs
op_assign
id|dsp
op_minus
id|np-&gt;p_scripth
suffix:semicolon
id|script_size
op_assign
r_sizeof
(paren
r_struct
id|scripth
)paren
suffix:semicolon
id|script_base
op_assign
(paren
id|u_char
op_star
)paren
id|np-&gt;scripth
suffix:semicolon
id|script_name
op_assign
l_string|&quot;scripth&quot;
suffix:semicolon
)brace
id|printf
(paren
l_string|&quot;%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ %s (%x:%08x).&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_ctest0
)paren
op_amp
l_int|0x0f
comma
id|dstat
comma
id|sist
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_socl
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sbcl
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sbdl
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sxfer
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_scntl3
)paren
comma
id|script_name
comma
id|script_ofs
comma
(paren
r_int
)paren
id|INL
(paren
id|nc_dbc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|script_ofs
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
r_int
)paren
id|script_ofs
OL
id|script_size
)paren
(brace
id|printf
(paren
l_string|&quot;%s: script cmd = %08x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
r_int
)paren
op_star
(paren
id|ncrcmd
op_star
)paren
(paren
id|script_base
op_plus
id|script_ofs
)paren
)paren
suffix:semicolon
)brace
id|printf
(paren
l_string|&quot;%s: regdump:&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|printf
(paren
l_string|&quot; %02x&quot;
comma
(paren
r_int
)paren
id|INB_OFF
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*============================================================&n;**&n;**&t;ncr chip exception handler.&n;**&n;**============================================================&n;**&n;**&t;In normal cases, interrupt conditions occur one at a &n;**&t;time. The ncr is able to stack in some extra registers &n;**&t;other interrupts that will occurs after the first one.&n;**&t;But severall interrupts may occur at the same time.&n;**&n;**&t;We probably should only try to deal with the normal &n;**&t;case, but it seems that multiple interrupts occur in &n;**&t;some cases that are not abnormal at all.&n;**&n;**&t;The most frequent interrupt condition is Phase Mismatch.&n;**&t;We should want to service this interrupt quickly.&n;**&t;A SCSI parity error may be delivered at the same time.&n;**&t;The SIR interrupt is not very frequent in this driver, &n;**&t;since the INTFLY is likely used for command completion &n;**&t;signaling.&n;**&t;The Selection Timeout interrupt may be triggered with &n;**&t;IID and/or UDC.&n;**&t;The SBMC interrupt (SCSI Bus Mode Change) may probably &n;**&t;occur at any time.&n;**&n;**&t;This handler try to deal as cleverly as possible with all&n;**&t;the above.&n;**&n;**============================================================&n;*/
DECL|function|ncr_exception
r_void
id|ncr_exception
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|istat
comma
id|dstat
suffix:semicolon
id|u_short
id|sist
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;**&t;interrupt on the fly ?&n;&t;*/
r_while
c_loop
(paren
(paren
id|istat
op_assign
id|INB
(paren
id|nc_istat
)paren
)paren
op_amp
id|INTF
)paren
(brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;F &quot;
)paren
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_DEBUG_ERROR_RECOVERY_SUPPORT
r_if
c_cond
(paren
id|np-&gt;stalling
)paren
id|OUTB
(paren
id|nc_istat
comma
id|INTF
)paren
suffix:semicolon
r_else
macro_line|#endif
id|OUTB
(paren
id|nc_istat
comma
(paren
id|istat
op_amp
id|SIGP
)paren
op_or
id|INTF
)paren
suffix:semicolon
id|np-&gt;profile.num_fly
op_increment
suffix:semicolon
id|ncr_wakeup
(paren
id|np
comma
l_int|0
)paren
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|istat
op_amp
(paren
id|SIP
op_or
id|DIP
)paren
)paren
)paren
r_return
suffix:semicolon
id|np-&gt;profile.num_int
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|istat
op_amp
id|CABRT
)paren
id|OUTB
(paren
id|nc_istat
comma
id|CABRT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Steinbach&squot;s Guideline for Systems Programming:&n;&t;**&t;Never test for an error condition you don&squot;t know how to handle.&n;&t;*/
id|sist
op_assign
(paren
id|istat
op_amp
id|SIP
)paren
ques
c_cond
id|INW
(paren
id|nc_sist
)paren
suffix:colon
l_int|0
suffix:semicolon
id|dstat
op_assign
(paren
id|istat
op_amp
id|DIP
)paren
ques
c_cond
id|INB
(paren
id|nc_dstat
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;&lt;%d|%x:%x|%x:%x&gt;&quot;
comma
(paren
r_int
)paren
id|INB
c_func
(paren
id|nc_scr0
)paren
comma
id|dstat
comma
id|sist
comma
(paren
r_int
)paren
id|INL
c_func
(paren
id|nc_dsp
)paren
comma
(paren
r_int
)paren
id|INL
c_func
(paren
id|nc_dbc
)paren
)paren
suffix:semicolon
multiline_comment|/*========================================================&n;&t;**&t;First, interrupts we want to service cleanly.&n;&t;**&n;&t;**&t;Phase mismatch is the most frequent interrupt, and &n;&t;**&t;so we have to service it as quickly and as cleanly &n;&t;**&t;as possible.&n;&t;**&t;Programmed interrupts are rarely used in this driver,&n;&t;**&t;but we must handle them cleanly anyway.&n;&t;**&t;We try to deal with PAR and SBMC combined with &n;&t;**&t;some other interrupt(s).&n;&t;**=========================================================&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|sist
op_amp
(paren
id|STO
op_or
id|GEN
op_or
id|HTH
op_or
id|SGE
op_or
id|UDC
op_or
id|RST
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|IID
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|sist
op_amp
id|SBMC
)paren
op_logical_and
id|ncr_int_sbmc
(paren
id|np
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sist
op_amp
id|PAR
)paren
op_logical_and
id|ncr_int_par
(paren
id|np
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|sist
op_amp
id|MA
)paren
(brace
id|ncr_int_ma
(paren
id|np
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dstat
op_amp
id|SIR
)paren
(brace
id|ncr_int_sir
(paren
id|np
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|sist
op_amp
(paren
id|SBMC
op_or
id|PAR
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
id|SSI
)paren
)paren
id|printf
c_func
(paren
l_string|&quot;%s: unknown interrupt(s) ignored sist=%x dstat=%x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|sist
comma
id|dstat
)paren
suffix:semicolon
id|OUTONB
(paren
id|nc_dcntl
comma
(paren
id|STD
op_or
id|NOCOM
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*========================================================&n;&t;**&t;Now, interrupts that need some fixing up.&n;&t;**&t;Order and multiple interrupts is so less important.&n;&t;**&n;&t;**&t;If SRST has been asserted, we just reset the chip.&n;&t;**&n;&t;**&t;Selection is intirely handled by the chip. If the &n;&t;**&t;chip says STO, we trust it. Seems some other &n;&t;**&t;interrupts may occur at the same time (UDC, IID), so &n;&t;**&t;we ignore them. In any case we do enough fix-up &n;&t;**&t;in the service routine.&n;&t;**&t;We just exclude some fatal dma errors.&n;&t;**=========================================================&n;&t;*/
r_if
c_cond
(paren
id|sist
op_amp
id|RST
)paren
(brace
id|ncr_init
(paren
id|np
comma
id|bootverbose
ques
c_cond
l_string|&quot;scsi reset&quot;
suffix:colon
l_int|NULL
comma
id|HS_RESET
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sist
op_amp
id|STO
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
)paren
)paren
)paren
(brace
id|ncr_int_sto
(paren
id|np
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*=========================================================&n;&t;**&t;Now, interrupts we are not able to recover cleanly.&n;&t;**&t;(At least for the moment).&n;&t;**&n;&t;**&t;Do the register dump.&n;&t;**&t;Log message for real hard errors.&n;&t;**&t;Clear all fifos.&n;&t;**&t;For MDPE, BF, ABORT, IID, SGE and HTH we reset the &n;&t;**&t;BUS and the chip.&n;&t;**&t;We are more soft for UDC.&n;&t;**=========================================================&n;&t;*/
r_if
c_cond
(paren
id|jiffies
op_minus
id|np-&gt;regtime
OG
l_int|10
op_star
id|HZ
)paren
(brace
id|np-&gt;regtime
op_assign
id|jiffies
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|np-&gt;regdump
)paren
suffix:semicolon
id|i
op_increment
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|np-&gt;regdump
)paren
(braket
id|i
)braket
op_assign
id|INB_OFF
c_func
(paren
id|i
)paren
suffix:semicolon
id|np-&gt;regdump.nc_dstat
op_assign
id|dstat
suffix:semicolon
id|np-&gt;regdump.nc_sist
op_assign
id|sist
suffix:semicolon
)brace
suffix:semicolon
id|ncr_log_hard_error
c_func
(paren
id|np
comma
id|sist
comma
id|dstat
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;%s: have to clear fifos.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
id|OUTONB
(paren
id|nc_ctest3
comma
id|CLF
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sist
op_amp
(paren
id|SGE
)paren
)paren
op_logical_or
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABORT
op_or
id|IID
)paren
)paren
)paren
(brace
id|ncr_start_reset
c_func
(paren
id|np
comma
l_int|2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|sist
op_amp
id|HTH
)paren
(brace
id|printf
(paren
l_string|&quot;%s: handshake timeout&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|ncr_start_reset
c_func
(paren
id|np
comma
l_int|2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|sist
op_amp
id|UDC
)paren
(brace
id|printf
(paren
l_string|&quot;%s: unexpected disconnect&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INB
(paren
id|nc_scr1
)paren
op_ne
l_int|0xff
)paren
(brace
id|OUTB
(paren
id|nc_scr1
comma
id|HS_UNEXPECTED
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|cleanup
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
id|ncr_start_reset
c_func
(paren
id|np
comma
l_int|2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*=========================================================&n;&t;**&t;We just miss the cause of the interrupt. :(&n;&t;**&t;Print a message. The timeout will do the real work.&n;&t;**=========================================================&n;&t;*/
id|printf
(paren
l_string|&quot;%s: unknown interrupt&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip exception handler for selection timeout&n;**&n;**==========================================================&n;**&n;**&t;There seems to be a bug in the 53c810.&n;**&t;Although a STO-Interrupt is pending,&n;**&t;it continues executing script commands.&n;**&t;But it will fail and interrupt (IID) on&n;**&t;the next instruction where it&squot;s looking&n;**&t;for a valid phase.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_sto
r_void
id|ncr_int_sto
(paren
id|ncb_p
id|np
)paren
(brace
id|u_long
id|dsa
comma
id|scratcha
comma
id|diff
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;T&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;look for ccb and set the status.&n;&t;*/
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
r_while
c_loop
(paren
id|cp
op_logical_and
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|phys
)paren
op_ne
id|dsa
)paren
)paren
id|cp
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
r_if
c_cond
(paren
id|cp
)paren
(brace
id|cp
op_member_access_from_pointer
id|host_status
op_assign
id|HS_SEL_TIMEOUT
suffix:semicolon
id|ncr_complete
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;repair start queue&n;&t;*/
id|scratcha
op_assign
id|INL
(paren
id|nc_scratcha
)paren
suffix:semicolon
id|diff
op_assign
id|scratcha
op_minus
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|tryloop
)paren
suffix:semicolon
multiline_comment|/*&t;assert ((diff &lt;= MAX_START * 20) &amp;&amp; !(diff % 20));*/
r_if
c_cond
(paren
(paren
id|diff
op_le
id|MAX_START
op_star
l_int|20
)paren
op_logical_and
op_logical_neg
(paren
id|diff
op_mod
l_int|20
)paren
)paren
(brace
id|np-&gt;script-&gt;startpos
(braket
l_int|0
)braket
op_assign
id|scratcha
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|start
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
id|ncr_init
(paren
id|np
comma
l_string|&quot;selection timeout&quot;
comma
id|HS_FAIL
)paren
suffix:semicolon
id|np-&gt;disc
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip exception handler for SCSI bus mode change&n;**&n;**==========================================================&n;**&n;**&t;spi2-r12 11.2.3 says a transceiver mode change must &n;**&t;generate a reset event and a device that detects a reset &n;**&t;event shall initiate a hard reset. It says also that a&n;**&t;device that detects a mode change shall set data transfer &n;**&t;mode to eight bit asynchronous, etc...&n;**&t;So, just resetting should be enough.&n;**&t; &n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_sbmc
r_static
r_int
id|ncr_int_sbmc
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|scsi_mode
op_assign
id|INB
(paren
id|nc_stest4
)paren
op_amp
id|SMODE
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: SCSI bus mode change from %x to %x, resetting ...&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;scsi_mode
comma
id|scsi_mode
)paren
suffix:semicolon
id|np-&gt;scsi_mode
op_assign
id|scsi_mode
suffix:semicolon
id|ncr_start_reset
c_func
(paren
id|np
comma
l_int|2
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip exception handler for SCSI parity error.&n;**&n;**==========================================================&n;**&n;**&t;SCSI parity errors are handled by the SCSI script.&n;**&t;So, we just print some message.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_par
r_static
r_int
id|ncr_int_par
(paren
id|ncb_p
id|np
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: SCSI parity error detected&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;ncr chip exception handler for phase errors.&n;**&n;**&n;**==========================================================&n;**&n;**&t;We have to construct a new transfer descriptor,&n;**&t;to transfer the rest of the current block.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_ma
r_static
r_void
id|ncr_int_ma
(paren
id|ncb_p
id|np
)paren
(brace
id|u_int32
id|dbc
suffix:semicolon
id|u_int32
id|rest
suffix:semicolon
id|u_int32
id|dsp
suffix:semicolon
id|u_int32
id|dsa
suffix:semicolon
id|u_int32
id|nxtdsp
suffix:semicolon
id|u_int32
op_star
id|vdsp
suffix:semicolon
id|u_int32
id|oadr
comma
id|olen
suffix:semicolon
id|u_int32
op_star
id|tblp
suffix:semicolon
id|ncrcmd
op_star
id|newcmd
suffix:semicolon
id|u_char
id|cmd
comma
id|sbcl
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
id|dbc
op_assign
id|INL
(paren
id|nc_dbc
)paren
suffix:semicolon
id|sbcl
op_assign
id|INB
(paren
id|nc_sbcl
)paren
suffix:semicolon
id|cmd
op_assign
id|dbc
op_rshift
l_int|24
suffix:semicolon
id|rest
op_assign
id|dbc
op_amp
l_int|0xffffff
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Take into account dma fifo and various buffers and latches,&n;&t;**&t;only if the interrupted phase is an OUTPUT phase.&n;&t;*/
r_if
c_cond
(paren
(paren
id|cmd
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|u_char
id|ctest5
comma
id|ss0
comma
id|ss2
suffix:semicolon
id|u_short
id|delta
suffix:semicolon
id|ctest5
op_assign
(paren
id|np-&gt;rv_ctest5
op_amp
id|DFS
)paren
ques
c_cond
id|INB
(paren
id|nc_ctest5
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ctest5
op_amp
id|DFS
)paren
id|delta
op_assign
(paren
(paren
(paren
id|ctest5
op_lshift
l_int|8
)paren
op_or
(paren
id|INB
(paren
id|nc_dfifo
)paren
op_amp
l_int|0xff
)paren
)paren
op_minus
id|rest
)paren
op_amp
l_int|0x3ff
suffix:semicolon
r_else
id|delta
op_assign
(paren
id|INB
(paren
id|nc_dfifo
)paren
op_minus
id|rest
)paren
op_amp
l_int|0x7f
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;The data in the dma fifo has not been transfered to&n;&t;&t;**&t;the target -&gt; add the amount to the rest&n;&t;&t;**&t;and clear the data.&n;&t;&t;**&t;Check the sstat2 register in case of wide transfer.&n;&t;&t;*/
id|rest
op_add_assign
id|delta
suffix:semicolon
id|ss0
op_assign
id|INB
(paren
id|nc_sstat0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss0
op_amp
id|OLF
)paren
id|rest
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ss0
op_amp
id|ORF
)paren
id|rest
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_scntl3
)paren
op_amp
id|EWS
)paren
(brace
id|ss2
op_assign
id|INB
(paren
id|nc_sstat2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss2
op_amp
id|OLF1
)paren
id|rest
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ss2
op_amp
id|ORF1
)paren
id|rest
op_increment
suffix:semicolon
)brace
suffix:semicolon
id|OUTONB
(paren
id|nc_ctest3
comma
id|CLF
)paren
suffix:semicolon
multiline_comment|/* clear dma fifo  */
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
multiline_comment|/* clear scsi fifo */
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
(paren
id|DEBUG_TINY
op_or
id|DEBUG_PHASE
)paren
)paren
id|printf
(paren
l_string|&quot;P%x%x RL=%d D=%d SS0=%x &quot;
comma
id|cmd
op_amp
l_int|7
comma
id|sbcl
op_amp
l_int|7
comma
(paren
r_int
)paren
id|rest
comma
(paren
r_int
)paren
id|delta
comma
id|ss0
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
(paren
id|DEBUG_TINY
op_or
id|DEBUG_PHASE
)paren
)paren
id|printf
(paren
l_string|&quot;P%x%x RL=%d &quot;
comma
id|cmd
op_amp
l_int|7
comma
id|sbcl
op_amp
l_int|7
comma
id|rest
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_amp
l_int|7
)paren
op_ne
l_int|1
)paren
(brace
id|OUTONB
(paren
id|nc_ctest3
comma
id|CLF
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;**&t;locate matching cp&n;&t;*/
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
r_while
c_loop
(paren
id|cp
op_logical_and
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|phys
)paren
op_ne
id|dsa
)paren
)paren
id|cp
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
(brace
id|printf
(paren
l_string|&quot;%s: SCSI phase error fixup: CCB already dequeued (0x%08lx)&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|np-&gt;header.cp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cp
op_ne
id|np-&gt;header.cp
)paren
(brace
id|printf
(paren
l_string|&quot;%s: SCSI phase error fixup: CCB address mismatch (0x%08lx != 0x%08lx)&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|cp
comma
(paren
id|u_long
)paren
id|np-&gt;header.cp
)paren
suffix:semicolon
multiline_comment|/*&t;    return;*/
)brace
multiline_comment|/*&n;&t;**&t;find the interrupted script command,&n;&t;**&t;and the address at which to continue.&n;&t;*/
r_if
c_cond
(paren
id|dsp
op_eq
id|vtophys
(paren
op_amp
id|cp-&gt;patch
(braket
l_int|2
)braket
)paren
)paren
(brace
id|vdsp
op_assign
op_amp
id|cp-&gt;patch
(braket
l_int|0
)braket
suffix:semicolon
id|nxtdsp
op_assign
id|vdsp
(braket
l_int|3
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dsp
op_eq
id|vtophys
(paren
op_amp
id|cp-&gt;patch
(braket
l_int|6
)braket
)paren
)paren
(brace
id|vdsp
op_assign
op_amp
id|cp-&gt;patch
(braket
l_int|4
)braket
suffix:semicolon
id|nxtdsp
op_assign
id|vdsp
(braket
l_int|3
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dsp
OG
id|np-&gt;p_script
op_logical_and
id|dsp
op_le
id|np-&gt;p_script
op_plus
r_sizeof
(paren
r_struct
id|script
)paren
)paren
(brace
id|vdsp
op_assign
(paren
id|u_int32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|np-&gt;script
op_minus
id|np-&gt;p_script
op_plus
id|dsp
op_minus
l_int|8
)paren
suffix:semicolon
id|nxtdsp
op_assign
id|dsp
suffix:semicolon
)brace
r_else
(brace
id|vdsp
op_assign
(paren
id|u_int32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|np-&gt;scripth
op_minus
id|np-&gt;p_scripth
op_plus
id|dsp
op_minus
l_int|8
)paren
suffix:semicolon
id|nxtdsp
op_assign
id|dsp
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;log the information&n;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
(brace
id|printf
(paren
l_string|&quot;&bslash;nCP=%p CP2=%p DSP=%x NXT=%x VDSP=%p CMD=%x &quot;
comma
id|cp
comma
id|np-&gt;header.cp
comma
(paren
r_int
)paren
id|dsp
comma
(paren
r_int
)paren
id|nxtdsp
comma
id|vdsp
comma
id|cmd
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;get old startaddress and old length.&n;&t;*/
id|oadr
op_assign
id|vdsp
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_amp
l_int|0x10
)paren
(brace
multiline_comment|/* Table indirect */
id|tblp
op_assign
(paren
id|u_int32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|cp-&gt;phys
op_plus
id|oadr
)paren
suffix:semicolon
id|olen
op_assign
id|tblp
(braket
l_int|0
)braket
suffix:semicolon
id|oadr
op_assign
id|tblp
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_else
(brace
id|tblp
op_assign
(paren
id|u_int32
op_star
)paren
l_int|0
suffix:semicolon
id|olen
op_assign
id|vdsp
(braket
l_int|0
)braket
op_amp
l_int|0xffffff
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
(brace
id|printf
(paren
l_string|&quot;OCMD=%x&bslash;nTBLP=%p OLEN=%x OADR=%x&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|vdsp
(braket
l_int|0
)braket
op_rshift
l_int|24
)paren
comma
id|tblp
comma
(paren
r_int
)paren
id|olen
comma
(paren
r_int
)paren
id|oadr
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;check cmd against assumed interrupted script command.&n;&t;*/
r_if
c_cond
(paren
id|cmd
op_ne
(paren
id|vdsp
(braket
l_int|0
)braket
op_rshift
l_int|24
)paren
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;internal error: cmd=%02x != %02x=(vdsp[0] &gt;&gt; 24)&bslash;n&quot;
comma
(paren
r_int
)paren
id|cmd
comma
(paren
r_int
)paren
id|vdsp
(braket
l_int|0
)braket
op_rshift
l_int|24
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef&t;SCSI_NCR_DEBUG_ERROR_RECOVERY_SUPPORT
r_if
c_cond
(paren
(paren
id|cmd
op_amp
l_int|7
)paren
op_eq
l_int|1
op_logical_and
id|np-&gt;assert_atn
)paren
(brace
id|np-&gt;assert_atn
op_assign
l_int|0
suffix:semicolon
id|OUTONB
c_func
(paren
id|nc_socl
comma
id|CATN
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**&t;if old phase not dataphase, leave here.&n;&t;*/
r_if
c_cond
(paren
id|cmd
op_amp
l_int|0x06
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;phase change %x-%x %d@%08x resid=%d.&bslash;n&quot;
comma
id|cmd
op_amp
l_int|7
comma
id|sbcl
op_amp
l_int|7
comma
(paren
r_int
)paren
id|olen
comma
(paren
r_int
)paren
id|oadr
comma
(paren
r_int
)paren
id|rest
)paren
suffix:semicolon
id|OUTONB
(paren
id|nc_dcntl
comma
(paren
id|STD
op_or
id|NOCOM
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;choose the correct patch area.&n;&t;**&t;if savep points to one, choose the other.&n;&t;*/
id|newcmd
op_assign
id|cp-&gt;patch
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;phys.header.savep
op_eq
id|vtophys
(paren
id|newcmd
)paren
)paren
id|newcmd
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t;**&t;fillin the commands&n;&t;*/
id|newcmd
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|cmd
op_amp
l_int|0x0f
)paren
op_lshift
l_int|24
)paren
op_or
id|rest
suffix:semicolon
id|newcmd
(braket
l_int|1
)braket
op_assign
id|oadr
op_plus
id|olen
op_minus
id|rest
suffix:semicolon
id|newcmd
(braket
l_int|2
)braket
op_assign
id|SCR_JUMP
suffix:semicolon
id|newcmd
(braket
l_int|3
)braket
op_assign
id|nxtdsp
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;newcmd[%d] %x %x %x %x.&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|newcmd
op_minus
id|cp-&gt;patch
)paren
comma
(paren
r_int
)paren
id|newcmd
(braket
l_int|0
)braket
comma
(paren
r_int
)paren
id|newcmd
(braket
l_int|1
)braket
comma
(paren
r_int
)paren
id|newcmd
(braket
l_int|2
)braket
comma
(paren
r_int
)paren
id|newcmd
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;fake the return address (to the patch).&n;&t;**&t;and restart script processor at dispatcher.&n;&t;*/
id|np-&gt;profile.num_break
op_increment
suffix:semicolon
id|OUTL
(paren
id|nc_temp
comma
id|vtophys
(paren
id|newcmd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_amp
l_int|7
)paren
op_eq
l_int|0
)paren
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|dispatch
)paren
)paren
suffix:semicolon
r_else
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|checkatn
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      ncr chip exception handler for programmed interrupts.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_show_msg
r_static
r_int
id|ncr_show_msg
(paren
id|u_char
op_star
id|msg
)paren
(brace
id|u_char
id|i
suffix:semicolon
id|printf
(paren
l_string|&quot;%x&quot;
comma
op_star
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|msg
op_eq
id|M_EXTENDED
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_minus
l_int|1
OG
id|msg
(braket
l_int|1
)braket
)paren
r_break
suffix:semicolon
id|printf
(paren
l_string|&quot;-%x&quot;
comma
id|msg
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
id|i
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
op_star
id|msg
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
(brace
id|printf
(paren
l_string|&quot;-%x&quot;
comma
id|msg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
(paren
l_int|2
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|ncr_int_sir
r_void
id|ncr_int_sir
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|scntl3
suffix:semicolon
id|u_char
id|chg
comma
id|ofs
comma
id|per
comma
id|fak
comma
id|wide
suffix:semicolon
id|u_char
id|num
op_assign
id|INB
(paren
id|nc_dsps
)paren
suffix:semicolon
id|ccb_p
id|cp
op_assign
l_int|0
suffix:semicolon
id|u_long
id|dsa
suffix:semicolon
id|u_char
id|target
op_assign
id|INB
(paren
id|nc_ctest0
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;I#%d&quot;
comma
id|num
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|num
)paren
(brace
r_case
id|SIR_SENSE_RESTART
suffix:colon
r_case
id|SIR_STALL_RESTART
suffix:colon
r_break
suffix:semicolon
r_case
id|SIR_STALL_QUEUE
suffix:colon
multiline_comment|/* Ignore, just restart the script */
r_goto
id|out
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;lookup the ccb&n;&t;&t;*/
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
r_while
c_loop
(paren
id|cp
op_logical_and
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|phys
)paren
op_ne
id|dsa
)paren
)paren
id|cp
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
m_assert
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_goto
id|out
suffix:semicolon
m_assert
(paren
id|cp
op_eq
id|np-&gt;header.cp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_ne
id|np-&gt;header.cp
)paren
r_goto
id|out
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|num
)paren
(brace
id|u_long
id|endp
suffix:semicolon
r_case
id|SIR_DATA_IO_IS_OUT
suffix:colon
r_case
id|SIR_DATA_IO_IS_IN
suffix:colon
multiline_comment|/*&n;**&t;We did not guess the direction of transfer. We have to wait for &n;**&t;actual data direction driven by the target before setting &n;**&t;pointers. We must patch the global header too.&n;*/
r_if
c_cond
(paren
id|num
op_eq
id|SIR_DATA_IO_IS_OUT
)paren
(brace
id|endp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|data_out
)paren
op_plus
id|MAX_SCATTER
op_star
l_int|16
suffix:semicolon
id|cp-&gt;phys.header.goalp
op_assign
id|endp
op_plus
l_int|8
suffix:semicolon
id|cp-&gt;phys.header.savep
op_assign
id|endp
op_minus
id|cp-&gt;segments
op_star
l_int|16
suffix:semicolon
)brace
r_else
(brace
id|endp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|data_in
)paren
op_plus
id|MAX_SCATTER
op_star
l_int|16
suffix:semicolon
id|cp-&gt;phys.header.goalp
op_assign
id|endp
op_plus
l_int|8
suffix:semicolon
id|cp-&gt;phys.header.savep
op_assign
id|endp
op_minus
id|cp-&gt;segments
op_star
l_int|16
suffix:semicolon
)brace
id|cp-&gt;phys.header.lastp
op_assign
id|cp-&gt;phys.header.savep
suffix:semicolon
id|np-&gt;header.savep
op_assign
id|cp-&gt;phys.header.savep
suffix:semicolon
id|np-&gt;header.goalp
op_assign
id|cp-&gt;phys.header.goalp
suffix:semicolon
id|np-&gt;header.lastp
op_assign
id|cp-&gt;phys.header.lastp
suffix:semicolon
id|OUTL
(paren
id|nc_temp
comma
id|np-&gt;header.savep
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|np-&gt;header.savep
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* break; */
multiline_comment|/*--------------------------------------------------------------------&n;**&n;**&t;Processing of interrupted getcc selects&n;**&n;**--------------------------------------------------------------------&n;*/
r_case
id|SIR_SENSE_RESTART
suffix:colon
multiline_comment|/*------------------------------------------&n;&t;&t;**&t;Script processor is idle.&n;&t;&t;**&t;Look for interrupted &quot;check cond&quot;&n;&t;&t;**------------------------------------------&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_RESTART
)paren
id|printf
(paren
l_string|&quot;%s: int#%d&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|num
)paren
suffix:semicolon
id|cp
op_assign
(paren
id|ccb_p
)paren
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_RESTART
)paren
id|printf
(paren
l_string|&quot; t%d&quot;
comma
id|i
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_RESTART
)paren
id|printf
(paren
l_string|&quot;+&quot;
)paren
suffix:semicolon
id|cp
op_assign
id|tp-&gt;hold_cp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_RESTART
)paren
id|printf
(paren
l_string|&quot;+&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_BUSY
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
id|S_CHECK_COND
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_RESTART
)paren
id|printf
(paren
l_string|&quot;- (remove)&quot;
)paren
suffix:semicolon
id|tp-&gt;hold_cp
op_assign
id|cp
op_assign
(paren
id|ccb_p
)paren
l_int|0
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|cp
)paren
(brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_RESTART
)paren
id|printf
(paren
l_string|&quot;+ restart job ..&bslash;n&quot;
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsa
comma
id|CCB_PHYS
(paren
id|cp
comma
id|phys
)paren
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|getcc
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;no job, resume normal processing&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_RESTART
)paren
id|printf
(paren
l_string|&quot; -- remove trap&bslash;n&quot;
)paren
suffix:semicolon
id|np-&gt;script-&gt;start0
(braket
l_int|0
)braket
op_assign
id|SCR_INT
op_xor
id|IFFALSE
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIR_SENSE_FAILED
suffix:colon
multiline_comment|/*-------------------------------------------&n;&t;&t;**&t;While trying to select for&n;&t;&t;**&t;getting the condition code,&n;&t;&t;**&t;a target reselected us.&n;&t;&t;**-------------------------------------------&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_RESTART
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;in getcc reselect by t%d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|INB
c_func
(paren
id|nc_ssid
)paren
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Mark this job&n;&t;&t;*/
id|cp-&gt;host_status
op_assign
id|HS_BUSY
suffix:semicolon
id|cp-&gt;scsi_status
op_assign
id|S_CHECK_COND
suffix:semicolon
id|np-&gt;target
(braket
id|cp-&gt;cmd-&gt;target
)braket
dot
id|hold_cp
op_assign
id|cp
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;And patch code to restart it.&n;&t;&t;*/
id|np-&gt;script-&gt;start0
(braket
l_int|0
)braket
op_assign
id|SCR_INT
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*-----------------------------------------------------------------------------&n;**&n;**&t;Was Sie schon immer ueber transfermode negotiation wissen wollten ...&n;**&n;**&t;We try to negotiate sync and wide transfer only after&n;**&t;a successfull inquire command. We look at byte 7 of the&n;**&t;inquire data to determine the capabilities of the target.&n;**&n;**&t;When we try to negotiate, we append the negotiation message&n;**&t;to the identify and (maybe) simple tag message.&n;**&t;The host status field is set to HS_NEGOTIATE to mark this&n;**&t;situation.&n;**&n;**&t;If the target doesn&squot;t answer this message immidiately&n;**&t;(as required by the standard), the SIR_NEGO_FAIL interrupt&n;**&t;will be raised eventually.&n;**&t;The handler removes the HS_NEGOTIATE status, and sets the&n;**&t;negotiated value to the default (async / nowide).&n;**&n;**&t;If we receive a matching answer immediately, we check it&n;**&t;for validity, and set the values.&n;**&n;**&t;If we receive a Reject message immediately, we assume the&n;**&t;negotiation has failed, and fall back to standard values.&n;**&n;**&t;If we receive a negotiation message while not in HS_NEGOTIATE&n;**&t;state, it&squot;s a target initiated negotiation. We prepare a&n;**&t;(hopefully) valid answer, set our parameters, and send back &n;**&t;this answer to the target.&n;**&n;**&t;If the target doesn&squot;t fetch the answer (no message out phase),&n;**&t;we assume the negotiation has failed, and fall back to default&n;**&t;settings.&n;**&n;**&t;When we set the values, we adjust them in all ccbs belonging &n;**&t;to this target, in the controller&squot;s register, and in the &quot;phys&quot;&n;**&t;field of the controller&squot;s struct ncb.&n;**&n;**&t;Possible cases:&t;&t;   hs  sir   msg_in value  send   goto&n;**&t;We try try to negotiate:&n;**&t;-&gt; target doesnt&squot;t msgin   NEG FAIL  noop   defa.  -      dispatch&n;**&t;-&gt; target rejected our msg NEG FAIL  reject defa.  -      dispatch&n;**&t;-&gt; target answered  (ok)   NEG SYNC  sdtr   set    -      clrack&n;**&t;-&gt; target answered (!ok)   NEG SYNC  sdtr   defa.  REJ---&gt;msg_bad&n;**&t;-&gt; target answered  (ok)   NEG WIDE  wdtr   set    -      clrack&n;**&t;-&gt; target answered (!ok)   NEG WIDE  wdtr   defa.  REJ---&gt;msg_bad&n;**&t;-&gt; any other msgin&t;   NEG FAIL  noop   defa.  -      dispatch&n;**&n;**&t;Target tries to negotiate:&n;**&t;-&gt; incoming message&t;   --- SYNC  sdtr   set    SDTR   -&n;**&t;-&gt; incoming message&t;   --- WIDE  wdtr   set    WDTR   -&n;**      We sent our answer:&n;**&t;-&gt; target doesn&squot;t msgout   --- PROTO ?      defa.  -      dispatch&n;**&n;**-----------------------------------------------------------------------------&n;*/
r_case
id|SIR_NEGO_FAILED
suffix:colon
multiline_comment|/*-------------------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;Negotiation failed.&n;&t;&t;**&t;Target doesn&squot;t send an answer message,&n;&t;&t;**&t;or target rejected our message.&n;&t;&t;**&n;&t;&t;**      Remove negotiation request.&n;&t;&t;**&n;&t;&t;**-------------------------------------------------------&n;&t;&t;*/
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SIR_NEGO_PROTO
suffix:colon
multiline_comment|/*-------------------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;Negotiation failed.&n;&t;&t;**&t;Target doesn&squot;t fetch the answer message.&n;&t;&t;**&n;&t;&t;**-------------------------------------------------------&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;negotiation failed sir=%x status=%x.&bslash;n&quot;
comma
id|num
comma
id|cp-&gt;nego_status
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;any error in negotiation:&n;&t;&t;**&t;fall back to default mode.&n;&t;&t;*/
r_switch
c_cond
(paren
id|cp-&gt;nego_status
)paren
(brace
r_case
id|NS_SYNC
suffix:colon
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0xe0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_WIDE
suffix:colon
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|cp-&gt;nego_status
op_assign
l_int|0
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|dispatch
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIR_NEGO_SYNC
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;Synchronous request message received.&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;sync msgin: &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgin
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;get requested values.&n;&t;&t;*/
id|chg
op_assign
l_int|0
suffix:semicolon
id|per
op_assign
id|np-&gt;msgin
(braket
l_int|3
)braket
suffix:semicolon
id|ofs
op_assign
id|np-&gt;msgin
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_eq
l_int|0
)paren
id|per
op_assign
l_int|255
suffix:semicolon
multiline_comment|/*&n;&t;&t;**      if target sends SDTR message,&n;&t;&t;**&t;      it CAN transfer synch.&n;&t;&t;*/
r_if
c_cond
(paren
id|ofs
)paren
id|tp-&gt;inqdata
(braket
l_int|7
)braket
op_or_assign
id|INQ7_SYNC
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;check values against driver limits.&n;&t;&t;*/
r_if
c_cond
(paren
id|per
OL
id|np-&gt;minsync
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|per
op_assign
id|np-&gt;minsync
suffix:semicolon
)brace
r_if
c_cond
(paren
id|per
OL
id|tp-&gt;minsync
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|per
op_assign
id|tp-&gt;minsync
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ofs
OG
id|tp-&gt;maxoffs
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|ofs
op_assign
id|tp-&gt;maxoffs
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Check against controller limits.&n;&t;&t;*/
id|fak
op_assign
l_int|7
suffix:semicolon
id|scntl3
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_ne
l_int|0
)paren
(brace
id|ncr_getsync
c_func
(paren
id|np
comma
id|per
comma
op_amp
id|fak
comma
op_amp
id|scntl3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fak
OG
l_int|7
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|ofs
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ofs
op_eq
l_int|0
)paren
(brace
id|fak
op_assign
l_int|7
suffix:semicolon
id|per
op_assign
l_int|0
suffix:semicolon
id|scntl3
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;minsync
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;sync: per=%d scntl3=0x%x ofs=%d fak=%d chg=%d.&bslash;n&quot;
comma
id|per
comma
id|scntl3
comma
id|ofs
comma
id|fak
comma
id|chg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INB
(paren
id|HS_PRT
)paren
op_eq
id|HS_NEGOTIATE
)paren
(brace
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cp-&gt;nego_status
)paren
(brace
r_case
id|NS_SYNC
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;**      This was an answer message&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|chg
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;**&t;Answer wasn&squot;t acceptable.&n;&t;&t;&t;&t;&t;*/
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0xe0
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;**&t;Answer is ok.&n;&t;&t;&t;&t;&t;*/
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
id|scntl3
comma
(paren
id|fak
op_lshift
l_int|5
)paren
op_or
id|ofs
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
r_case
id|NS_WIDE
suffix:colon
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;It was a request.&n;&t;&t;**      Check against the table of target capabilities.&n;&t;&t;**      If target not capable force M_REJECT and asynchronous.&n;&t;&t;*/
r_if
c_cond
(paren
id|np-&gt;unit
OL
id|SCSI_NCR_MAX_HOST
)paren
(brace
id|tp-&gt;inqdata
(braket
l_int|7
)braket
op_and_assign
(paren
id|target_capabilities
(braket
id|np-&gt;unit
)braket
dot
id|and_map
(braket
id|target
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tp-&gt;inqdata
(braket
l_int|7
)braket
op_amp
id|INQ7_SYNC
)paren
)paren
(brace
id|ofs
op_assign
l_int|0
suffix:semicolon
id|fak
op_assign
l_int|7
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;**&t;It was a request. Set value and&n;&t;&t;**      prepare an answer message&n;&t;&t;*/
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
id|scntl3
comma
(paren
id|fak
op_lshift
l_int|5
)paren
op_or
id|ofs
)paren
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|1
)braket
op_assign
l_int|3
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|2
)braket
op_assign
id|M_X_SYNC_REQ
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|3
)braket
op_assign
id|per
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|4
)braket
op_assign
id|ofs
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|NS_SYNC
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;sync msgout: &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgout
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ofs
)paren
(brace
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIR_NEGO_WIDE
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;Wide request message received.&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;wide msgin: &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgin
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;get requested values.&n;&t;&t;*/
id|chg
op_assign
l_int|0
suffix:semicolon
id|wide
op_assign
id|np-&gt;msgin
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;**      if target sends WDTR message,&n;&t;&t;**&t;      it CAN transfer wide.&n;&t;&t;*/
r_if
c_cond
(paren
id|wide
)paren
id|tp-&gt;inqdata
(braket
l_int|7
)braket
op_or_assign
id|INQ7_WIDE16
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;check values against driver limits.&n;&t;&t;*/
r_if
c_cond
(paren
id|wide
OG
id|tp-&gt;usrwide
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|wide
op_assign
id|tp-&gt;usrwide
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;wide: wide=%d chg=%d.&bslash;n&quot;
comma
id|wide
comma
id|chg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INB
(paren
id|HS_PRT
)paren
op_eq
id|HS_NEGOTIATE
)paren
(brace
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cp-&gt;nego_status
)paren
(brace
r_case
id|NS_WIDE
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;**      This was an answer message&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|chg
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;**&t;Answer wasn&squot;t acceptable.&n;&t;&t;&t;&t;&t;*/
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;**&t;Answer is ok.&n;&t;&t;&t;&t;&t;*/
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
id|wide
comma
l_int|1
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
r_case
id|NS_SYNC
suffix:colon
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0xe0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;It was a request, set value and&n;&t;&t;**      prepare an answer message&n;&t;&t;*/
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
id|wide
comma
l_int|1
)paren
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|2
)braket
op_assign
id|M_X_WIDE_REQ
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|3
)braket
op_assign
id|wide
suffix:semicolon
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|NS_WIDE
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;wide msgout: &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgin
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/*--------------------------------------------------------------------&n;**&n;**&t;Processing of special messages&n;**&n;**--------------------------------------------------------------------&n;*/
r_case
id|SIR_REJECT_RECEIVED
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;We received a M_REJECT message.&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;M_REJECT received (%x:%x).&bslash;n&quot;
comma
(paren
r_int
)paren
id|np-&gt;lastmsg
comma
id|np-&gt;msgout
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIR_REJECT_SENT
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;We received an unknown message&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;M_REJECT sent for &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgin
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*--------------------------------------------------------------------&n;**&n;**&t;Processing of special messages&n;**&n;**--------------------------------------------------------------------&n;*/
r_case
id|SIR_IGN_RESIDUE
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;We received an IGNORE RESIDUE message,&n;&t;&t;**&t;which couldn&squot;t be handled by the script.&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;M_IGN_RESIDUE received, but not yet implemented.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIR_MISSING_SAVE
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;We received an DISCONNECT message,&n;&t;&t;**&t;but the datapointer wasn&squot;t saved before.&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;M_DISCONNECT received, but datapointer not saved: &quot;
l_string|&quot;data=%x save=%x goal=%x.&bslash;n&quot;
comma
(paren
r_int
)paren
id|INL
(paren
id|nc_temp
)paren
comma
(paren
r_int
)paren
id|np-&gt;header.savep
comma
(paren
r_int
)paren
id|np-&gt;header.goalp
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if 0   /* This stuff does not work */
multiline_comment|/*--------------------------------------------------------------------&n;**&n;**&t;Processing of a &quot;S_QUEUE_FULL&quot; status.&n;**&n;**&t;The current command has been rejected,&n;**&t;because there are too many in the command queue.&n;**&t;We have started too many commands for that target.&n;**&n;**&t;If possible, reinsert at head of queue.&n;**&t;Stall queue until there are no disconnected jobs&n;**&t;(ncr is REALLY idle). Then restart processing.&n;**&n;**&t;We should restart the current job after the controller&n;**&t;has become idle. But this is not yet implemented.&n;**&n;**--------------------------------------------------------------------&n;*/
r_case
id|SIR_STALL_QUEUE
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;Stall the start queue.&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;queue full.&bslash;n&quot;
)paren
suffix:semicolon
id|np-&gt;script-&gt;start1
(braket
l_int|0
)braket
op_assign
id|SCR_INT
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Try to disable tagged transfers.&n;&t;&t;*/
id|ncr_setmaxtags
(paren
id|np
comma
op_amp
id|np-&gt;target
(braket
id|target
)braket
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** @QUEUE@&n;&t;&t;**&n;&t;&t;**&t;Should update the launch field of the&n;&t;&t;**&t;current job to be able to restart it.&n;&t;&t;**&t;Then prepend it to the start queue.&n;&t;&t;*/
multiline_comment|/* fall through */
r_case
id|SIR_STALL_RESTART
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;Enable selecting again,&n;&t;&t;**&t;if NO disconnected jobs.&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
multiline_comment|/*&n;&t;&t;**&t;Look for a disconnected job.&n;&t;&t;*/
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
r_while
c_loop
(paren
id|cp
op_logical_and
id|cp-&gt;host_status
op_ne
id|HS_DISCONNECT
)paren
id|cp
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;if there is one, ...&n;&t;&t;*/
r_if
c_cond
(paren
id|cp
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;**&t;wait for reselection&n;&t;&t;&t;*/
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|reselect
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;else remove the interrupt.&n;&t;&t;*/
id|printf
(paren
l_string|&quot;%s: queue empty.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;script-&gt;start1
(braket
l_int|0
)braket
op_assign
id|SCR_INT
op_xor
id|IFFALSE
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif   /* This stuff does not work */
)brace
suffix:semicolon
id|out
suffix:colon
id|OUTONB
(paren
id|nc_dcntl
comma
(paren
id|STD
op_or
id|NOCOM
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Aquire a control block&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_get_ccb
r_static
id|ccb_p
id|ncr_get_ccb
(paren
id|ncb_p
id|np
comma
id|u_long
id|target
comma
id|u_long
id|lun
)paren
(brace
id|lcb_p
id|lp
suffix:semicolon
id|ccb_p
id|cp
op_assign
(paren
id|ccb_p
)paren
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Lun structure available ?&n;&t;*/
id|lp
op_assign
id|np-&gt;target
(braket
id|target
)braket
dot
id|lp
(braket
id|lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lp
op_logical_and
id|lp-&gt;opennings
op_logical_and
(paren
op_logical_neg
id|lp-&gt;active
op_logical_or
id|lp-&gt;active
OL
id|lp-&gt;reqlink
)paren
)paren
(brace
id|cp
op_assign
id|lp-&gt;next_ccb
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Look for free CCB&n;&t;&t;*/
r_while
c_loop
(paren
id|cp
op_logical_and
id|cp-&gt;magic
)paren
id|cp
op_assign
id|cp-&gt;next_ccb
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Increment active commands and decrement credit.&n;&t;&t;*/
r_if
c_cond
(paren
id|cp
)paren
(brace
op_increment
id|lp-&gt;active
suffix:semicolon
op_decrement
id|lp-&gt;opennings
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;**&t;if nothing available, take the default.&n;&t;**&t;DANGEROUS, because this ccb is not suitable for&n;&t;**&t;reselection.&n;&t;**&t;If lp-&gt;actccbs &gt; 0 wait for a suitable ccb to be free.&n;&t;*/
r_if
c_cond
(paren
(paren
op_logical_neg
id|cp
)paren
op_logical_and
id|lp
op_logical_and
id|lp-&gt;actccbs
OG
l_int|0
)paren
r_return
(paren
(paren
id|ccb_p
)paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
id|cp
op_assign
id|np-&gt;ccb
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Wait until available.&n;&t;*/
macro_line|#if 0
r_while
c_loop
(paren
id|cp-&gt;magic
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|SCSI_NOSLEEP
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|tsleep
(paren
(paren
id|caddr_t
)paren
id|cp
comma
id|PRIBIO
op_or
id|PCATCH
comma
l_string|&quot;ncr&quot;
comma
l_int|0
)paren
)paren
r_break
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cp-&gt;magic
)paren
r_return
(paren
(paren
id|ccb_p
)paren
l_int|0
)paren
suffix:semicolon
id|cp-&gt;magic
op_assign
l_int|1
suffix:semicolon
r_return
(paren
id|cp
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Release one control block&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_free_ccb
r_void
id|ncr_free_ccb
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_long
id|target
comma
id|u_long
id|lun
)paren
(brace
id|lcb_p
id|lp
suffix:semicolon
multiline_comment|/*&n;&t;**    sanity&n;&t;*/
m_assert
(paren
id|cp
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Decrement active commands and increment credit.&n;&t;*/
id|lp
op_assign
id|np-&gt;target
(braket
id|target
)braket
dot
id|lp
(braket
id|lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lp
)paren
(brace
op_decrement
id|lp-&gt;active
suffix:semicolon
op_increment
id|lp-&gt;opennings
suffix:semicolon
)brace
id|cp
op_member_access_from_pointer
id|host_status
op_assign
id|HS_IDLE
suffix:semicolon
id|cp
op_member_access_from_pointer
id|magic
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|cp
op_eq
id|np-&gt;ccb
)paren
id|wakeup
(paren
(paren
id|caddr_t
)paren
id|cp
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      Allocation of resources for Targets/Luns/Tags.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_alloc_ccb
r_static
r_void
id|ncr_alloc_ccb
(paren
id|ncb_p
id|np
comma
id|u_long
id|target
comma
id|u_long
id|lun
)paren
(brace
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
m_assert
(paren
id|np
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
op_ge
id|MAX_TARGET
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|lun
op_ge
id|MAX_LUN
)paren
r_return
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;jump_tcb.l_cmd
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;initialize it.&n;&t;&t;*/
id|tp-&gt;jump_tcb.l_cmd
op_assign
(paren
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|0x80
op_plus
id|target
)paren
)paren
)paren
suffix:semicolon
id|tp-&gt;jump_tcb.l_paddr
op_assign
id|np-&gt;jump_tcb.l_paddr
suffix:semicolon
id|tp-&gt;getscr
(braket
l_int|0
)braket
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_PFEN
)paren
ques
c_cond
id|SCR_COPY
c_func
(paren
l_int|1
)paren
suffix:colon
id|SCR_COPY_F
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|tp-&gt;getscr
(braket
l_int|1
)braket
op_assign
id|vtophys
(paren
op_amp
id|tp-&gt;sval
)paren
suffix:semicolon
id|tp-&gt;getscr
(braket
l_int|2
)braket
op_assign
id|np-&gt;paddr
op_plus
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_sxfer
)paren
suffix:semicolon
id|tp-&gt;getscr
(braket
l_int|3
)braket
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_PFEN
)paren
ques
c_cond
id|SCR_COPY
c_func
(paren
l_int|1
)paren
suffix:colon
id|SCR_COPY_F
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|tp-&gt;getscr
(braket
l_int|4
)braket
op_assign
id|vtophys
(paren
op_amp
id|tp-&gt;wval
)paren
suffix:semicolon
id|tp-&gt;getscr
(braket
l_int|5
)braket
op_assign
id|np-&gt;paddr
op_plus
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_scntl3
)paren
suffix:semicolon
m_assert
(paren
(paren
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_sxfer
)paren
op_xor
m_offsetof
(paren
r_struct
id|tcb
comma
id|sval
)paren
)paren
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
suffix:semicolon
m_assert
(paren
(paren
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_scntl3
)paren
op_xor
m_offsetof
(paren
r_struct
id|tcb
comma
id|wval
)paren
)paren
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|tp-&gt;call_lun.l_cmd
op_assign
(paren
id|SCR_CALL
)paren
suffix:semicolon
id|tp-&gt;call_lun.l_paddr
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|resel_lun
)paren
suffix:semicolon
id|tp-&gt;jump_lcb.l_cmd
op_assign
(paren
id|SCR_JUMP
)paren
suffix:semicolon
id|tp-&gt;jump_lcb.l_paddr
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
m_abort
)paren
suffix:semicolon
id|np-&gt;jump_tcb.l_paddr
op_assign
id|vtophys
(paren
op_amp
id|tp-&gt;jump_tcb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Logic unit control block&n;&t;*/
id|lp
op_assign
id|tp-&gt;lp
(braket
id|lun
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;Allocate a lcb&n;&t;&t;*/
id|lp
op_assign
(paren
id|lcb_p
)paren
id|m_alloc
(paren
r_sizeof
(paren
r_struct
id|lcb
)paren
comma
id|LCB_ALIGN_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_ALLOC
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;new lcb @%p.&bslash;n&quot;
comma
id|lp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Initialize it&n;&t;&t;*/
id|bzero
(paren
id|lp
comma
r_sizeof
(paren
op_star
id|lp
)paren
)paren
suffix:semicolon
id|lp-&gt;jump_lcb.l_cmd
op_assign
(paren
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|lun
)paren
)paren
)paren
suffix:semicolon
id|lp-&gt;jump_lcb.l_paddr
op_assign
id|tp-&gt;jump_lcb.l_paddr
suffix:semicolon
id|lp-&gt;call_tag.l_cmd
op_assign
(paren
id|SCR_CALL
)paren
suffix:semicolon
id|lp-&gt;call_tag.l_paddr
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|resel_tag
)paren
suffix:semicolon
id|lp-&gt;jump_ccb.l_cmd
op_assign
(paren
id|SCR_JUMP
)paren
suffix:semicolon
id|lp-&gt;jump_ccb.l_paddr
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|aborttag
)paren
suffix:semicolon
id|lp-&gt;actlink
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;active
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;**   Chain into LUN list&n;&t;&t;*/
id|tp-&gt;jump_lcb.l_paddr
op_assign
id|vtophys
(paren
op_amp
id|lp-&gt;jump_lcb
)paren
suffix:semicolon
id|tp-&gt;lp
(braket
id|lun
)braket
op_assign
id|lp
suffix:semicolon
id|ncr_setmaxtags
(paren
id|np
comma
id|tp
comma
id|driver_setup.default_tags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Allocate ccbs up to lp-&gt;reqccbs.&n;&t;*/
multiline_comment|/*&n;&t;**&t;Limit possible number of ccbs.&n;&t;**&n;&t;**&t;If tagged command queueing is enabled,&n;&t;**&t;can use more than one ccb.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;actccbs
op_ge
id|MAX_START
op_minus
l_int|2
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;actccbs
op_logical_and
(paren
id|lp-&gt;actccbs
op_ge
id|lp-&gt;reqccbs
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate a ccb&n;&t;*/
id|cp
op_assign
(paren
id|ccb_p
)paren
id|m_alloc
(paren
r_sizeof
(paren
r_struct
id|ccb
)paren
comma
id|CCB_ALIGN_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_ALLOC
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;new ccb @%p.&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Count it&n;&t;*/
id|lp-&gt;actccbs
op_increment
suffix:semicolon
id|np-&gt;actccbs
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initialize it&n;&t;*/
id|bzero
(paren
id|cp
comma
r_sizeof
(paren
op_star
id|cp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Fill in physical addresses&n;&t;*/
id|cp-&gt;p_ccb
op_assign
id|vtophys
(paren
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Chain into reselect list&n;&t;*/
id|cp-&gt;jump_ccb.l_cmd
op_assign
id|SCR_JUMP
suffix:semicolon
id|cp-&gt;jump_ccb.l_paddr
op_assign
id|lp-&gt;jump_ccb.l_paddr
suffix:semicolon
id|lp-&gt;jump_ccb.l_paddr
op_assign
id|CCB_PHYS
(paren
id|cp
comma
id|jump_ccb
)paren
suffix:semicolon
id|cp-&gt;call_tmp.l_cmd
op_assign
id|SCR_CALL
suffix:semicolon
id|cp-&gt;call_tmp.l_paddr
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|resel_tmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Chain into wakeup list&n;&t;*/
id|cp-&gt;link_ccb
op_assign
id|np-&gt;ccb-&gt;link_ccb
suffix:semicolon
id|np-&gt;ccb-&gt;link_ccb
op_assign
id|cp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Chain into CCB list&n;&t;*/
id|cp-&gt;next_ccb
op_assign
id|lp-&gt;next_ccb
suffix:semicolon
id|lp-&gt;next_ccb
op_assign
id|cp
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Announce the number of ccbs/tags to the scsi driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_opennings
r_static
r_void
id|ncr_opennings
(paren
id|ncb_p
id|np
comma
id|lcb_p
id|lp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/*&n;&t;**&t;want to reduce the number ...&n;&t;*/
r_if
c_cond
(paren
id|lp-&gt;actlink
OG
id|lp-&gt;reqlink
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;Try to  reduce the count.&n;&t;&t;**&t;We assume to run at splbio ..&n;&t;&t;*/
id|u_char
id|diff
op_assign
id|lp-&gt;actlink
op_minus
id|lp-&gt;reqlink
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|diff
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|diff
OG
id|lp-&gt;opennings
)paren
id|diff
op_assign
id|lp-&gt;opennings
suffix:semicolon
id|lp-&gt;opennings
op_sub_assign
id|diff
suffix:semicolon
id|lp-&gt;actlink
op_sub_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TAGS
)paren
id|printf
(paren
l_string|&quot;%s: actlink: diff=%d, new=%d, req=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|diff
comma
id|lp-&gt;actlink
comma
id|lp-&gt;reqlink
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;want to increase the number ?&n;&t;*/
r_if
c_cond
(paren
id|lp-&gt;reqlink
OG
id|lp-&gt;actlink
)paren
(brace
id|u_char
id|diff
op_assign
id|lp-&gt;reqlink
op_minus
id|lp-&gt;actlink
suffix:semicolon
id|lp-&gt;opennings
op_add_assign
id|diff
suffix:semicolon
id|lp-&gt;actlink
op_add_assign
id|diff
suffix:semicolon
macro_line|#if 0
id|wakeup
(paren
(paren
id|caddr_t
)paren
id|xp-&gt;sc_link
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TAGS
)paren
id|printf
(paren
l_string|&quot;%s: actlink: diff=%d, new=%d, req=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|diff
comma
id|lp-&gt;actlink
comma
id|lp-&gt;reqlink
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Build Scatter Gather Block&n;**&n;**&n;**==========================================================&n;**&n;**&t;The transfer area may be scattered among&n;**&t;several non adjacent physical pages.&n;**&n;**&t;We may use MAX_SCATTER blocks.&n;**&n;**----------------------------------------------------------&n;*/
multiline_comment|/*&n;**&t;We try to reduce the number of interrupts caused&n;**&t;by unexpected phase changes due to disconnects.&n;**&t;A typical harddisk may disconnect before ANY block.&n;**&t;If we wanted to avoid unexpected phase changes at all&n;**&t;we had to use a break point every 512 bytes.&n;**&t;Of course the number of scatter/gather blocks is&n;**&t;limited.&n;**&t;Under Linux, the scatter/gatter blocks are provided by &n;**&t;the generic driver. We just have to copy addresses and &n;**&t;sizes to the data segment array.&n;*/
DECL|function|ncr_scatter
r_static
r_int
id|ncr_scatter
c_func
(paren
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|scr_tblmove
op_star
id|data
suffix:semicolon
r_int
id|segment
op_assign
l_int|0
suffix:semicolon
r_int
id|use_sg
op_assign
(paren
r_int
)paren
id|cmd-&gt;use_sg
suffix:semicolon
macro_line|#if 0
id|bzero
(paren
id|cp-&gt;phys.data
comma
r_sizeof
(paren
id|cp-&gt;phys.data
)paren
)paren
suffix:semicolon
macro_line|#endif
id|data
op_assign
id|cp-&gt;phys.data
suffix:semicolon
id|cp-&gt;data_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_sg
)paren
(brace
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
)paren
(brace
id|data
op_assign
op_amp
id|data
(braket
id|MAX_SCATTER
op_minus
l_int|1
)braket
suffix:semicolon
id|data
(braket
l_int|0
)braket
dot
id|addr
op_assign
id|vtophys
c_func
(paren
id|cmd-&gt;request_buffer
)paren
suffix:semicolon
id|data
(braket
l_int|0
)braket
dot
id|size
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|cp-&gt;data_len
op_assign
id|data
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
id|segment
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|use_sg
op_le
id|MAX_SCATTER
)paren
(brace
r_struct
id|scatterlist
op_star
id|scatter
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
id|data
op_assign
op_amp
id|data
(braket
id|MAX_SCATTER
op_minus
id|use_sg
)braket
suffix:semicolon
r_while
c_loop
(paren
id|segment
OL
id|use_sg
)paren
(brace
id|data
(braket
id|segment
)braket
dot
id|addr
op_assign
id|vtophys
c_func
(paren
id|scatter
(braket
id|segment
)braket
dot
id|address
)paren
suffix:semicolon
id|data
(braket
id|segment
)braket
dot
id|size
op_assign
id|scatter
(braket
id|segment
)braket
dot
id|length
suffix:semicolon
id|cp-&gt;data_len
op_add_assign
id|data
(braket
id|segment
)braket
dot
id|size
suffix:semicolon
op_increment
id|segment
suffix:semicolon
)brace
)brace
r_else
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|segment
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Test the pci bus snoop logic :-(&n;**&n;**&t;Has to be called with interrupts disabled.&n;**&n;**&n;**==========================================================&n;*/
macro_line|#ifndef NCR_IOMAPPED
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|ncr_regtest
(paren
r_struct
id|ncb
op_star
id|np
)paren
)paren
(brace
r_register
r_volatile
id|u_long
id|data
suffix:semicolon
multiline_comment|/*&n;&t;**&t;ncr registers may NOT be cached.&n;&t;**&t;write 0xffffffff to a read only register area,&n;&t;**&t;and try to read it back.&n;&t;*/
id|data
op_assign
l_int|0xffffffff
suffix:semicolon
id|OUTL_OFF
c_func
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_dstat
)paren
comma
id|data
)paren
suffix:semicolon
id|data
op_assign
id|INL_OFF
c_func
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_dstat
)paren
)paren
suffix:semicolon
macro_line|#if 1
r_if
c_cond
(paren
id|data
op_eq
l_int|0xffffffff
)paren
(brace
macro_line|#else
r_if
c_cond
(paren
(paren
id|data
op_amp
l_int|0xe2f0fffd
)paren
op_ne
l_int|0x02000080
)paren
(brace
macro_line|#endif
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: reg dstat-sstat2 readback %x.&bslash;n&quot;
comma
(paren
r_int
)paren
id|data
)paren
suffix:semicolon
r_return
(paren
l_int|0x10
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|ncr_snooptest
(paren
r_struct
id|ncb
op_star
id|np
)paren
)paren
(brace
id|u_long
id|ncr_rd
comma
id|ncr_wr
comma
id|ncr_bk
comma
id|host_rd
comma
id|host_wr
comma
id|pc
comma
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
r_if
c_cond
(paren
id|np-&gt;reg
)paren
(brace
id|err
op_or_assign
id|ncr_regtest
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
(paren
id|err
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**&t;init&n;&t;*/
id|pc
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|snooptest
)paren
suffix:semicolon
id|host_wr
op_assign
l_int|1
suffix:semicolon
id|ncr_wr
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set memory and register.&n;&t;*/
id|np-&gt;ncr_cache
op_assign
id|host_wr
suffix:semicolon
id|OUTL
(paren
id|nc_temp
comma
id|ncr_wr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Start script (exchange values)&n;&t;*/
id|OUTL
(paren
id|nc_dsp
comma
id|pc
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Wait &squot;til done (with timeout)&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NCR_SNOOP_TIMEOUT
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_istat
)paren
op_amp
(paren
id|INTF
op_or
id|SIP
op_or
id|DIP
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Save termination position.&n;&t;*/
id|pc
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Read memory and register.&n;&t;*/
id|host_rd
op_assign
id|np-&gt;ncr_cache
suffix:semicolon
id|ncr_rd
op_assign
id|INL
(paren
id|nc_scratcha
)paren
suffix:semicolon
id|ncr_bk
op_assign
id|INL
(paren
id|nc_temp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Reset ncr chip&n;&t;*/
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|DELAY
(paren
l_int|1000
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;check for timeout&n;&t;*/
r_if
c_cond
(paren
id|i
op_ge
id|NCR_SNOOP_TIMEOUT
)paren
(brace
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: timeout.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0x20
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Check termination position.&n;&t;*/
r_if
c_cond
(paren
id|pc
op_ne
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|snoopend
)paren
op_plus
l_int|8
)paren
(brace
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: script execution failed.&bslash;n&quot;
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;start=%08lx, pc=%08lx, end=%08lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|snooptest
)paren
comma
id|pc
comma
(paren
id|u_long
)paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|snoopend
)paren
op_plus
l_int|8
)paren
suffix:semicolon
r_return
(paren
l_int|0x40
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Show results.&n;&t;*/
r_if
c_cond
(paren
id|host_wr
op_ne
id|ncr_rd
)paren
(brace
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: host wrote %d, ncr read %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|host_wr
comma
(paren
r_int
)paren
id|ncr_rd
)paren
suffix:semicolon
id|err
op_or_assign
l_int|1
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|host_rd
op_ne
id|ncr_wr
)paren
(brace
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: ncr wrote %d, host read %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|ncr_wr
comma
(paren
r_int
)paren
id|host_rd
)paren
suffix:semicolon
id|err
op_or_assign
l_int|2
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|ncr_bk
op_ne
id|ncr_wr
)paren
(brace
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: ncr wrote %d, read back %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|ncr_wr
comma
(paren
r_int
)paren
id|ncr_bk
)paren
suffix:semicolon
id|err
op_or_assign
l_int|4
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Profiling the drivers and targets performance.&n;**&n;**&n;**==========================================================&n;*/
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
multiline_comment|/*&n;**&t;Compute the difference in jiffies ticks.&n;*/
DECL|macro|ncr_delta
mdefine_line|#define ncr_delta(from, to) &bslash;&n;&t;( ((to) &amp;&amp; (from))? (to) - (from) : -1 )
DECL|macro|PROFILE
mdefine_line|#define PROFILE  cp-&gt;phys.header.stamp
DECL|function|ncb_profile
r_static
r_void
id|ncb_profile
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
r_int
id|co
comma
id|st
comma
id|en
comma
id|di
comma
id|se
comma
id|post
comma
id|work
comma
id|disc
suffix:semicolon
id|u_long
id|diff
suffix:semicolon
id|PROFILE.end
op_assign
id|jiffies
suffix:semicolon
id|st
op_assign
id|ncr_delta
(paren
id|PROFILE.start
comma
id|PROFILE.status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
OL
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* status  not reached  */
id|co
op_assign
id|ncr_delta
(paren
id|PROFILE.start
comma
id|PROFILE.command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|co
OL
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* command not executed */
id|en
op_assign
id|ncr_delta
(paren
id|PROFILE.start
comma
id|PROFILE.end
)paren
comma
id|di
op_assign
id|ncr_delta
(paren
id|PROFILE.start
comma
id|PROFILE.disconnect
)paren
comma
id|se
op_assign
id|ncr_delta
(paren
id|PROFILE.start
comma
id|PROFILE.select
)paren
suffix:semicolon
id|post
op_assign
id|en
op_minus
id|st
suffix:semicolon
multiline_comment|/*&n;&t;**&t;@PROFILE@  Disconnect time invalid if multiple disconnects&n;&t;*/
r_if
c_cond
(paren
id|di
op_ge
l_int|0
)paren
id|disc
op_assign
id|se
op_minus
id|di
suffix:semicolon
r_else
id|disc
op_assign
l_int|0
suffix:semicolon
id|work
op_assign
(paren
id|st
op_minus
id|co
)paren
op_minus
id|disc
suffix:semicolon
id|diff
op_assign
(paren
id|np-&gt;disc_phys
op_minus
id|np-&gt;disc_ref
)paren
op_amp
l_int|0xff
suffix:semicolon
id|np-&gt;disc_ref
op_add_assign
id|diff
suffix:semicolon
id|np-&gt;profile.num_trans
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cmd
)paren
(brace
id|np-&gt;profile.num_kbytes
op_add_assign
(paren
id|cp-&gt;cmd-&gt;request_bufflen
op_rshift
l_int|10
)paren
suffix:semicolon
id|np-&gt;profile.rest_bytes
op_add_assign
(paren
id|cp-&gt;cmd-&gt;request_bufflen
op_amp
(paren
l_int|0x400
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;profile.rest_bytes
op_ge
l_int|0x400
)paren
(brace
op_increment
id|np-&gt;profile.num_kbytes
suffix:semicolon
id|np-&gt;profile.rest_bytes
op_sub_assign
l_int|0x400
suffix:semicolon
)brace
)brace
id|np-&gt;profile.num_disc
op_add_assign
id|diff
suffix:semicolon
id|np-&gt;profile.ms_setup
op_add_assign
id|co
suffix:semicolon
id|np-&gt;profile.ms_data
op_add_assign
id|work
suffix:semicolon
id|np-&gt;profile.ms_disc
op_add_assign
id|disc
suffix:semicolon
id|np-&gt;profile.ms_post
op_add_assign
id|post
suffix:semicolon
)brace
DECL|macro|PROFILE
macro_line|#undef PROFILE
macro_line|#endif /* SCSI_NCR_PROFILE_SUPPORT */
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Device lookup.&n;**&n;**&t;@GENSCSI@ should be integrated to scsiconf.c&n;**&n;**&n;**==========================================================&n;*/
DECL|struct|table_entry
r_struct
id|table_entry
(brace
DECL|member|manufacturer
r_char
op_star
id|manufacturer
suffix:semicolon
DECL|member|model
r_char
op_star
id|model
suffix:semicolon
DECL|member|version
r_char
op_star
id|version
suffix:semicolon
DECL|member|info
id|u_long
id|info
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|device_tab
r_static
r_struct
id|table_entry
id|device_tab
(braket
)braket
op_assign
(brace
macro_line|#ifdef NCR_GETCC_WITHMSG
(brace
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
id|QUIRK_NOMSG
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;SDT-5000&quot;
comma
l_string|&quot;3.17&quot;
comma
id|QUIRK_NOMSG
)brace
comma
(brace
l_string|&quot;WangDAT&quot;
comma
l_string|&quot;Model 2600&quot;
comma
l_string|&quot;01.7&quot;
comma
id|QUIRK_NOMSG
)brace
comma
(brace
l_string|&quot;WangDAT&quot;
comma
l_string|&quot;Model 3200&quot;
comma
l_string|&quot;02.2&quot;
comma
id|QUIRK_NOMSG
)brace
comma
(brace
l_string|&quot;WangDAT&quot;
comma
l_string|&quot;Model 1300&quot;
comma
l_string|&quot;02.4&quot;
comma
id|QUIRK_NOMSG
)brace
comma
macro_line|#endif
(brace
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_int|0
)brace
multiline_comment|/* catch all: must be last entry. */
)brace
suffix:semicolon
DECL|function|ncr_lookup
r_static
id|u_long
id|ncr_lookup
c_func
(paren
r_char
op_star
id|id
)paren
(brace
r_struct
id|table_entry
op_star
id|p
op_assign
id|device_tab
suffix:semicolon
r_char
op_star
id|d
comma
op_star
id|r
comma
id|c
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|p
op_increment
)paren
(brace
id|d
op_assign
id|id
op_plus
l_int|8
suffix:semicolon
id|r
op_assign
id|p-&gt;manufacturer
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|r
op_increment
)paren
)paren
r_if
c_cond
(paren
id|c
op_ne
op_star
id|d
op_increment
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
r_continue
suffix:semicolon
id|d
op_assign
id|id
op_plus
l_int|16
suffix:semicolon
id|r
op_assign
id|p-&gt;model
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|r
op_increment
)paren
)paren
r_if
c_cond
(paren
id|c
op_ne
op_star
id|d
op_increment
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
r_continue
suffix:semicolon
id|d
op_assign
id|id
op_plus
l_int|32
suffix:semicolon
id|r
op_assign
id|p-&gt;version
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|r
op_increment
)paren
)paren
r_if
c_cond
(paren
id|c
op_ne
op_star
id|d
op_increment
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
r_continue
suffix:semicolon
r_return
(paren
id|p-&gt;info
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Determine the ncr&squot;s clock frequency.&n;**&t;This is essential for the negotiation&n;**&t;of the synchronous transfer rate.&n;**&n;**==========================================================&n;**&n;**&t;Note: we have to return the correct value.&n;**&t;THERE IS NO SAVE DEFAULT VALUE.&n;**&n;**&t;Most NCR/SYMBIOS boards are delivered with a 40 Mhz clock.&n;**&t;53C860 and 53C875 rev. 1 support fast20 transfers but &n;**&t;do not have a clock doubler and so are provided with a &n;**&t;80 MHz clock. All other fast20 boards incorporate a doubler &n;**&t;and so should be delivered with a 40 MHz clock.&n;**&t;The future fast40 chips (895/895) use a 40 Mhz base clock &n;**&t;and provide a clock quadrupler (160 Mhz). The code below &n;**&t;tries to deal as cleverly as possible with all this stuff.&n;**&n;**----------------------------------------------------------&n;*/
multiline_comment|/*&n; *&t;Select NCR SCSI clock frequency&n; */
DECL|function|ncr_selectclock
r_static
r_void
id|ncr_selectclock
c_func
(paren
id|ncb_p
id|np
comma
id|u_char
id|scntl3
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;multiplier
OL
l_int|2
)paren
(brace
id|OUTB
c_func
(paren
id|nc_scntl3
comma
id|scntl3
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
id|printf
(paren
l_string|&quot;%s: enabling clock multiplier&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest1
comma
id|DBLEN
)paren
suffix:semicolon
multiline_comment|/* Enable clock multiplier&t;&t;  */
r_if
c_cond
(paren
id|np-&gt;multiplier
OG
l_int|2
)paren
(brace
multiline_comment|/* Poll bit 5 of stest4 for quadrupler */
r_int
id|i
op_assign
l_int|20
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|INB
c_func
(paren
id|nc_stest4
)paren
op_amp
id|LCKFRQ
)paren
op_logical_and
op_decrement
id|i
OG
l_int|0
)paren
id|DELAY
c_func
(paren
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|printf
c_func
(paren
l_string|&quot;%s: the chip cannot lock the frequency&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Wait 20 micro-seconds for doubler&t;*/
id|DELAY
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest3
comma
id|HSC
)paren
suffix:semicolon
multiline_comment|/* Halt the scsi clock&t;&t;*/
id|OUTB
c_func
(paren
id|nc_scntl3
comma
id|scntl3
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest1
comma
(paren
id|DBLEN
op_or
id|DBLSEL
)paren
)paren
suffix:semicolon
multiline_comment|/* Select clock multiplier&t;*/
id|OUTB
c_func
(paren
id|nc_stest3
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* Restart scsi clock &t;&t;*/
)brace
multiline_comment|/*&n; *&t;calculate NCR SCSI clock frequency (in KHz)&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|ncrgetfreq
(paren
id|ncb_p
id|np
comma
r_int
id|gen
)paren
)paren
(brace
r_int
id|ms
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Measure GEN timer delay in order &n;&t; * to calculate SCSI clock frequency&n;&t; *&n;&t; * This code will never execute too&n;&t; * many loop iterations (if DELAY is &n;&t; * reasonably correct). It could get&n;&t; * too low a delay (too high a freq.)&n;&t; * if the CPU is slow executing the &n;&t; * loop for some reason (an NMI, for&n;&t; * example). For this reason we will&n;&t; * if multiple measurements are to be &n;&t; * performed trust the higher delay &n;&t; * (lower frequency returned).&n;&t; */
id|OUTB
(paren
id|nc_stest1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* make sure clock doubler is OFF */
id|OUTW
(paren
id|nc_sien
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* mask all scsi interrupts */
(paren
r_void
)paren
id|INW
(paren
id|nc_sist
)paren
suffix:semicolon
multiline_comment|/* clear pending scsi interrupt */
id|OUTB
(paren
id|nc_dien
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* mask all dma interrupts */
(paren
r_void
)paren
id|INW
(paren
id|nc_sist
)paren
suffix:semicolon
multiline_comment|/* another one, just to be sure :) */
id|OUTB
(paren
id|nc_scntl3
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* set pre-scaler to divide by 3 */
id|OUTB
(paren
id|nc_stime1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* disable general purpose timer */
id|OUTB
(paren
id|nc_stime1
comma
id|gen
)paren
suffix:semicolon
multiline_comment|/* set to nominal delay of 1&lt;&lt;gen * 125us */
r_while
c_loop
(paren
op_logical_neg
(paren
id|INW
c_func
(paren
id|nc_sist
)paren
op_amp
id|GEN
)paren
op_logical_and
id|ms
op_increment
OL
l_int|100000
)paren
id|DELAY
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* count ms */
id|OUTB
(paren
id|nc_stime1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* disable general purpose timer */
multiline_comment|/*&n; &t; * set prescaler to divide by whatever 0 means&n; &t; * 0 ought to choose divide by 2, but appears&n; &t; * to set divide by 3.5 mode in my 53c810 ...&n; &t; */
id|OUTB
(paren
id|nc_scntl3
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
id|printf
(paren
l_string|&quot;%s: Delay (GEN=%d): %u msec&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|gen
comma
id|ms
)paren
suffix:semicolon
multiline_comment|/*&n; &t; * adjust for prescaler, and convert into KHz &n;  &t; */
r_return
id|ms
ques
c_cond
(paren
(paren
l_int|1
op_lshift
id|gen
)paren
op_star
l_int|4340
)paren
op_div
id|ms
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get/probe NCR SCSI clock frequency&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|ncr_getclock
(paren
id|ncb_p
id|np
comma
r_int
id|mult
)paren
)paren
(brace
r_int
r_char
id|scntl3
op_assign
id|INB
c_func
(paren
id|nc_scntl3
)paren
suffix:semicolon
r_int
r_char
id|stest1
op_assign
id|INB
c_func
(paren
id|nc_stest1
)paren
suffix:semicolon
r_int
id|f1
suffix:semicolon
id|np-&gt;multiplier
op_assign
l_int|1
suffix:semicolon
id|f1
op_assign
l_int|40000
suffix:semicolon
multiline_comment|/*&n;&t;**&t;True with 875 or 895 with clock multiplier selected&n;&t;*/
r_if
c_cond
(paren
id|mult
OG
l_int|1
op_logical_and
(paren
id|stest1
op_amp
(paren
id|DBLEN
op_plus
id|DBLSEL
)paren
)paren
op_eq
id|DBLEN
op_plus
id|DBLSEL
)paren
(brace
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
id|printf
(paren
l_string|&quot;%s: clock multiplier found&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;multiplier
op_assign
id|mult
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;If multiplier not found or scntl3 not 7,5,3,&n;&t;**&t;reset chip and get frequency from general purpose timer.&n;&t;**&t;Otherwise trust scntl3 BIOS setting.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;multiplier
op_ne
id|mult
op_logical_or
(paren
id|scntl3
op_amp
l_int|7
)paren
OL
l_int|3
op_logical_or
op_logical_neg
(paren
id|scntl3
op_amp
l_int|1
)paren
)paren
(brace
r_int
id|f2
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|DELAY
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncrgetfreq
(paren
id|np
comma
l_int|11
)paren
suffix:semicolon
multiline_comment|/* throw away first result */
id|f1
op_assign
id|ncrgetfreq
(paren
id|np
comma
l_int|11
)paren
suffix:semicolon
id|f2
op_assign
id|ncrgetfreq
(paren
id|np
comma
l_int|11
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
id|printf
(paren
l_string|&quot;%s: NCR clock is %uKHz, %uKHz&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|f1
comma
id|f2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f1
OG
id|f2
)paren
id|f1
op_assign
id|f2
suffix:semicolon
multiline_comment|/* trust lower result&t;*/
r_if
c_cond
(paren
id|f1
OL
l_int|45000
)paren
id|f1
op_assign
l_int|40000
suffix:semicolon
r_else
r_if
c_cond
(paren
id|f1
OL
l_int|55000
)paren
id|f1
op_assign
l_int|50000
suffix:semicolon
r_else
id|f1
op_assign
l_int|80000
suffix:semicolon
r_if
c_cond
(paren
id|f1
template_param
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
id|printf
(paren
l_string|&quot;%s: clock multiplier assumed&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;multiplier
op_assign
id|mult
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|scntl3
op_amp
l_int|7
)paren
op_eq
l_int|3
)paren
id|f1
op_assign
l_int|40000
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|scntl3
op_amp
l_int|7
)paren
op_eq
l_int|5
)paren
id|f1
op_assign
l_int|80000
suffix:semicolon
r_else
id|f1
op_assign
l_int|160000
suffix:semicolon
id|f1
op_div_assign
id|np-&gt;multiplier
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Compute controller synchronous parameters.&n;&t;*/
id|f1
op_mul_assign
id|np-&gt;multiplier
suffix:semicolon
id|np-&gt;clock_khz
op_assign
id|f1
suffix:semicolon
)brace
multiline_comment|/*===================== LINUX ENTRY POINTS SECTION ==========================*/
macro_line|#ifndef uchar
DECL|macro|uchar
mdefine_line|#define uchar unsigned char
macro_line|#endif
macro_line|#ifndef ushort
DECL|macro|ushort
mdefine_line|#define ushort unsigned short
macro_line|#endif
macro_line|#ifndef ulong
DECL|macro|ulong
mdefine_line|#define ulong unsigned long
macro_line|#endif
multiline_comment|/* ---------------------------------------------------------------------&n;**&n;**&t;Driver setup from the boot command line&n;**&n;** ---------------------------------------------------------------------&n;*/
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|ncr53c8xx_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
)paren
(brace
macro_line|#ifdef SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT
r_char
op_star
id|cur
op_assign
id|str
suffix:semicolon
r_char
op_star
id|pc
comma
op_star
id|pv
suffix:semicolon
r_int
id|val
suffix:semicolon
r_int
id|base
suffix:semicolon
r_int
id|c
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_ne
l_int|NULL
op_logical_and
(paren
id|pc
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;:&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|val
op_assign
l_int|0
suffix:semicolon
id|pv
op_assign
id|pc
suffix:semicolon
id|c
op_assign
op_star
op_increment
id|pv
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;n&squot;
)paren
id|val
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;y&squot;
)paren
id|val
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|base
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;0&squot;
)paren
(brace
id|c
op_assign
op_star
id|pv
op_increment
suffix:semicolon
id|base
op_assign
l_int|8
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;x&squot;
)paren
(brace
op_increment
id|pv
suffix:semicolon
id|base
op_assign
l_int|16
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_ge
l_char|&squot;0&squot;
op_logical_and
id|c
op_le
l_char|&squot;9&squot;
)paren
id|base
op_assign
l_int|10
suffix:semicolon
r_else
r_break
suffix:semicolon
macro_line|#endif
id|val
op_assign
(paren
r_int
)paren
id|simple_strtoul
c_func
(paren
id|pv
comma
l_int|NULL
comma
id|base
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;mpar:&quot;
comma
l_int|5
)paren
)paren
id|driver_setup.master_parity
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;spar:&quot;
comma
l_int|5
)paren
)paren
id|driver_setup.scsi_parity
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;disc:&quot;
comma
l_int|5
)paren
)paren
id|driver_setup.disconnection
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;specf:&quot;
comma
l_int|6
)paren
)paren
id|driver_setup.special_features
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;ultra:&quot;
comma
l_int|6
)paren
)paren
id|driver_setup.ultra_scsi
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;fsn:&quot;
comma
l_int|4
)paren
)paren
id|driver_setup.force_sync_nego
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;revprob:&quot;
comma
l_int|8
)paren
)paren
id|driver_setup.reverse_probe
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;tags:&quot;
comma
l_int|5
)paren
)paren
(brace
r_if
c_cond
(paren
id|val
OG
id|SCSI_NCR_MAX_TAGS
)paren
id|val
op_assign
id|SCSI_NCR_MAX_TAGS
suffix:semicolon
id|driver_setup.default_tags
op_assign
id|val
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;sync:&quot;
comma
l_int|5
)paren
)paren
id|driver_setup.default_sync
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;verb:&quot;
comma
l_int|5
)paren
)paren
id|driver_setup.verbose
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;debug:&quot;
comma
l_int|6
)paren
)paren
id|driver_setup.debug
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;burst:&quot;
comma
l_int|6
)paren
)paren
id|driver_setup.burst_max
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;led:&quot;
comma
l_int|4
)paren
)paren
id|driver_setup.led_pin
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;wide:&quot;
comma
l_int|5
)paren
)paren
id|driver_setup.max_wide
op_assign
id|val
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;settle:&quot;
comma
l_int|7
)paren
)paren
id|driver_setup.settle_delay
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;diff:&quot;
comma
l_int|5
)paren
)paren
id|driver_setup.diff_support
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;irqm:&quot;
comma
l_int|5
)paren
)paren
id|driver_setup.irqm
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;pcifix:&quot;
comma
l_int|7
)paren
)paren
id|driver_setup.pci_fix_up
op_assign
id|val
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;nvram:&quot;
comma
l_int|6
)paren
)paren
id|driver_setup.use_nvram
op_assign
id|val
suffix:semicolon
macro_line|#endif
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;safe:&quot;
comma
l_int|5
)paren
op_logical_and
id|val
)paren
id|memcpy
c_func
(paren
op_amp
id|driver_setup
comma
op_amp
id|driver_safe_setup
comma
r_sizeof
(paren
id|driver_setup
)paren
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;ncr53c8xx_setup: unexpected boot option &squot;%.*s&squot; ignored&bslash;n&quot;
comma
id|pc
op_minus
id|cur
op_plus
l_int|1
comma
id|cur
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cur
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;,&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
op_increment
id|cur
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT */
)brace
r_static
r_int
id|ncr53c8xx_pci_init
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
id|uchar
id|bus
comma
id|uchar
id|device_fn
comma
id|ncr_device
op_star
id|device
)paren
suffix:semicolon
multiline_comment|/*&n;**   Linux entry point for NCR53C8XX devices detection routine.&n;**&n;**   Called by the middle-level scsi drivers at initialization time,&n;**   or at module installation.&n;**&n;**   Read the PCI configuration and try to attach each&n;**   detected NCR board.&n;**&n;**   If NVRAM is present, try to attach boards according to &n;**   the used defined boot order.&n;**&n;**   Returns the number of boards successfully attached.&n;*/
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|ncr_print_driver_setup
c_func
(paren
r_void
)paren
)paren
(brace
DECL|macro|YesNo
mdefine_line|#define YesNo(y)&t;y ? &squot;y&squot; : &squot;n&squot;
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx: setup=disc:%c,specf:%c,ultra:%c,tags:%d,sync:%d,burst:%d,wide:%c,diff:%d&bslash;n&quot;
comma
id|YesNo
c_func
(paren
id|driver_setup.disconnection
)paren
comma
id|YesNo
c_func
(paren
id|driver_setup.special_features
)paren
comma
id|YesNo
c_func
(paren
id|driver_setup.ultra_scsi
)paren
comma
id|driver_setup.default_tags
comma
id|driver_setup.default_sync
comma
id|driver_setup.burst_max
comma
id|YesNo
c_func
(paren
id|driver_setup.max_wide
)paren
comma
id|driver_setup.diff_support
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx: setup=mpar:%c,spar:%c,fsn=%c,verb:%d,debug:0x%x,led:%c,settle:%d,irqm:%d&bslash;n&quot;
comma
id|YesNo
c_func
(paren
id|driver_setup.master_parity
)paren
comma
id|YesNo
c_func
(paren
id|driver_setup.scsi_parity
)paren
comma
id|YesNo
c_func
(paren
id|driver_setup.force_sync_nego
)paren
comma
id|driver_setup.verbose
comma
id|driver_setup.debug
comma
id|YesNo
c_func
(paren
id|driver_setup.led_pin
)paren
comma
id|driver_setup.settle_delay
comma
id|driver_setup.irqm
)paren
suffix:semicolon
DECL|macro|YesNo
macro_line|#undef YesNo
)brace
multiline_comment|/*&n;**   NCR53C8XX devices description table and chip ids list.&n;*/
DECL|variable|__initdata
r_static
id|ncr_chip
id|ncr_chip_table
(braket
)braket
id|__initdata
op_assign
id|SCSI_NCR_CHIP_TABLE
suffix:semicolon
DECL|variable|__initdata
r_static
id|ushort
id|ncr_chip_ids
(braket
)braket
id|__initdata
op_assign
id|SCSI_NCR_CHIP_IDS
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|ncr_attach_using_nvram
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|nvram_index
comma
r_int
id|count
comma
id|ncr_device
id|device
(braket
)braket
)paren
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|attach_count
op_assign
l_int|0
suffix:semicolon
id|ncr_nvram
op_star
id|nvram
suffix:semicolon
id|ncr_device
op_star
id|devp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nvram_index
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* find first Symbios NVRAM if there is one as we need to check it for host boot order */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|nvram_index
op_assign
op_minus
l_int|1
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|devp
op_assign
op_amp
id|device
(braket
id|i
)braket
suffix:semicolon
id|nvram
op_assign
id|devp-&gt;nvram
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nvram
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|nvram-&gt;type
op_eq
id|SCSI_NCR_SYMBIOS_NVRAM
)paren
(brace
r_if
c_cond
(paren
id|nvram_index
op_eq
op_minus
l_int|1
)paren
id|nvram_index
op_assign
id|i
suffix:semicolon
macro_line|#ifdef SCSI_NCR_DEBUG_NVRAM
id|printf
c_func
(paren
l_string|&quot;ncr53c8xx: NVRAM: Symbios format Boot Block, 53c%s, PCI bus %d, device %d, function %d&bslash;n&quot;
comma
id|devp-&gt;chip.name
comma
id|devp-&gt;slot.bus
comma
(paren
r_int
)paren
(paren
id|devp-&gt;slot.device_fn
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
comma
(paren
r_int
)paren
id|devp-&gt;slot.device_fn
op_amp
l_int|7
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|4
suffix:semicolon
id|j
op_increment
)paren
(brace
id|Symbios_host
op_star
id|h
op_assign
op_amp
id|nvram-&gt;data.Symbios.host
(braket
id|j
)braket
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ncr53c8xx: BOOT[%d] device_id=%04x vendor_id=%04x device_fn=%02x io_port=%04x %s&bslash;n&quot;
comma
id|j
comma
id|h-&gt;device_id
comma
id|h-&gt;vendor_id
comma
id|h-&gt;device_fn
comma
id|h-&gt;io_port
comma
(paren
id|h-&gt;flags
op_amp
id|SYMBIOS_INIT_SCAN_AT_BOOT
)paren
ques
c_cond
l_string|&quot;SCAN AT BOOT&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|nvram-&gt;type
op_eq
id|SCSI_NCR_TEKRAM_NVRAM
)paren
(brace
multiline_comment|/* display Tekram nvram data */
id|printf
c_func
(paren
l_string|&quot;ncr53c8xx: NVRAM: Tekram format data, 53c%s, PCI bus %d, device %d, function %d&bslash;n&quot;
comma
id|devp-&gt;chip.name
comma
id|devp-&gt;slot.bus
comma
(paren
r_int
)paren
(paren
id|devp-&gt;slot.device_fn
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
comma
(paren
r_int
)paren
id|devp-&gt;slot.device_fn
op_amp
l_int|7
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_if
c_cond
(paren
id|nvram_index
op_ge
l_int|0
op_logical_and
id|nvram_index
OL
id|count
)paren
id|nvram
op_assign
id|device
(braket
id|nvram_index
)braket
dot
id|nvram
suffix:semicolon
r_else
id|nvram
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nvram
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* &n;&t;** check devices in the boot record against devices detected. &n;&t;** attach devices if we find a match. boot table records that &n;&t;** do not match any detected devices will be ignored. &n;&t;** devices that do not match any boot table will not be attached&n;&t;** here but will attempt to be attached during the device table &n;&t;** rescan.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Symbios_host
op_star
id|h
op_assign
op_amp
id|nvram-&gt;data.Symbios.host
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|count
suffix:semicolon
id|j
op_increment
)paren
(brace
id|devp
op_assign
op_amp
id|device
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|h-&gt;device_fn
op_eq
id|devp-&gt;slot.device_fn
op_logical_and
macro_line|#if 0&t;/* bus number location in nvram ? */
id|h-&gt;bus
op_eq
id|devp-&gt;slot.bus
op_logical_and
macro_line|#endif
id|h-&gt;device_id
op_eq
id|devp-&gt;chip.device_id
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
OL
id|count
op_logical_and
op_logical_neg
id|devp-&gt;attached
op_logical_and
op_logical_neg
id|ncr_attach
(paren
id|tpnt
comma
id|attach_count
comma
id|devp
)paren
)paren
(brace
id|attach_count
op_increment
suffix:semicolon
id|devp-&gt;attached
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
id|attach_count
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_NVRAM_SUPPORT */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
id|ncr53c8xx_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|chips
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|uchar
id|bus
comma
id|device_fn
suffix:semicolon
r_int
id|index
suffix:semicolon
r_int
id|attach_count
op_assign
l_int|0
suffix:semicolon
id|ncr_device
id|device
(braket
l_int|8
)braket
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
id|ncr_nvram
id|nvram
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|k
comma
id|nvrams
suffix:semicolon
macro_line|#endif
r_int
id|hosts
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_int
id|nvram_index
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|initverbose
op_ge
l_int|2
)paren
id|ncr_print_driver_setup
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_DEBUG_INFO_SUPPORT
id|ncr_debug
op_assign
id|driver_setup.debug
suffix:semicolon
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,0)
id|tpnt-&gt;proc_dir
op_assign
op_amp
id|proc_scsi_ncr53c8xx
suffix:semicolon
macro_line|# ifdef SCSI_NCR_PROC_INFO_SUPPORT
id|tpnt-&gt;proc_info
op_assign
id|ncr53c8xx_proc_info
suffix:semicolon
macro_line|# endif
macro_line|#endif
multiline_comment|/* &n;&t;** Detect all 53c8xx hosts and then attach them.&n;&t;**&n;&t;** If we are using NVRAM, once all hosts are detected, we need to check&n;&t;** any NVRAM for boot order in case detect and boot order differ and&n;&t;** attach them using the order in the NVRAM.&n;&t;**&n;&t;** If no NVRAM is found or data appears invalid attach boards in the &n;&t;** the order they are detected.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|pcibios_present
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|chips
op_assign
r_sizeof
(paren
id|ncr_chip_ids
)paren
op_div
r_sizeof
(paren
id|ncr_chip_ids
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|hosts
op_assign
r_sizeof
(paren
id|device
)paren
op_div
r_sizeof
(paren
id|device
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
id|k
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x1
)paren
id|nvrams
op_assign
r_sizeof
(paren
id|nvram
)paren
op_div
r_sizeof
(paren
id|nvram
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_else
id|nvrams
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|chips
suffix:semicolon
op_increment
id|j
)paren
(brace
id|i
op_assign
id|driver_setup.reverse_probe
ques
c_cond
id|chips
op_minus
l_int|1
op_minus
id|j
suffix:colon
id|j
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|index
op_increment
)paren
(brace
r_char
op_star
id|msg
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pcibios_find_device
c_func
(paren
id|PCI_VENDOR_ID_NCR
comma
id|ncr_chip_ids
(braket
id|i
)braket
comma
id|index
comma
op_amp
id|bus
comma
op_amp
id|device_fn
)paren
)paren
op_logical_or
(paren
id|count
op_eq
id|hosts
)paren
)paren
r_break
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
id|device
(braket
id|count
)braket
dot
id|nvram
op_assign
id|k
OL
id|nvrams
ques
c_cond
op_amp
id|nvram
(braket
id|k
)braket
suffix:colon
l_int|0
suffix:semicolon
macro_line|#else
id|device
(braket
id|count
)braket
dot
id|nvram
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ncr53c8xx_pci_init
c_func
(paren
id|tpnt
comma
id|bus
comma
id|device_fn
comma
op_amp
id|device
(braket
id|count
)braket
)paren
)paren
(brace
id|device
(braket
id|count
)braket
dot
id|nvram
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_if
c_cond
(paren
id|device
(braket
id|count
)braket
dot
id|nvram
)paren
(brace
op_increment
id|k
suffix:semicolon
id|nvram_index
op_or_assign
id|device
(braket
id|count
)braket
dot
id|nvram-&gt;type
suffix:semicolon
r_switch
c_cond
(paren
id|device
(braket
id|count
)braket
dot
id|nvram-&gt;type
)paren
(brace
r_case
id|SCSI_NCR_TEKRAM_NVRAM
suffix:colon
id|msg
op_assign
l_string|&quot;with Tekram NVRAM&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:colon
id|msg
op_assign
l_string|&quot;with Symbios NVRAM&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|msg
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|device
(braket
id|count
)braket
dot
id|nvram
op_assign
l_int|0
suffix:semicolon
op_decrement
id|k
suffix:semicolon
)brace
)brace
macro_line|#endif
id|printf
c_func
(paren
id|KERN_INFO
l_string|&quot;ncr53c8xx: 53c%s detected %s&bslash;n&quot;
comma
id|device
(braket
id|count
)braket
dot
id|chip.name
comma
id|msg
)paren
suffix:semicolon
id|device
(braket
id|count
)braket
dot
id|attached
op_assign
l_int|0
suffix:semicolon
op_increment
id|count
suffix:semicolon
)brace
)brace
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
id|attach_count
op_assign
id|ncr_attach_using_nvram
c_func
(paren
id|tpnt
comma
id|nvram_index
comma
id|count
comma
id|device
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t;** rescan device list to make sure all boards attached.&n;&t;** devices without boot records will not be attached yet&n;&t;** so try to attach them here.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|device
(braket
id|i
)braket
dot
id|attached
)paren
op_logical_and
(paren
op_logical_neg
id|ncr_attach
(paren
id|tpnt
comma
id|attach_count
comma
op_amp
id|device
(braket
id|i
)braket
)paren
)paren
)paren
(brace
id|attach_count
op_increment
suffix:semicolon
id|device
(braket
id|i
)braket
dot
id|attached
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|attach_count
suffix:semicolon
)brace
multiline_comment|/*&n;**   Read and check the PCI configuration for any detected NCR &n;**   boards and save data for attaching after all boards have &n;**   been detected.&n;*/
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|ncr53c8xx_pci_init
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
id|uchar
id|bus
comma
id|uchar
id|device_fn
comma
id|ncr_device
op_star
id|device
)paren
)paren
(brace
id|ushort
id|vendor_id
comma
id|device_id
comma
id|command
suffix:semicolon
id|uchar
id|cache_line_size
comma
id|latency_timer
suffix:semicolon
id|uchar
id|irq
comma
id|revision
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,0)
id|uint
id|base
comma
id|io_port
suffix:semicolon
macro_line|#else
id|ulong
id|base
comma
id|io_port
suffix:semicolon
macro_line|#endif
r_int
id|i
comma
id|error
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
id|ncr_nvram
op_star
id|nvram
op_assign
id|device-&gt;nvram
suffix:semicolon
macro_line|#endif
id|ncr_chip
op_star
id|chip
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ncr53c8xx: at PCI bus %d, device %d, function %d&bslash;n&quot;
comma
id|bus
comma
(paren
r_int
)paren
(paren
id|device_fn
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
comma
(paren
r_int
)paren
id|device_fn
op_amp
l_int|7
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read info from the PCI config space&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_VENDOR_ID
comma
op_amp
id|vendor_id
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_DEVICE_ID
comma
op_amp
id|device_id
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_COMMAND
comma
op_amp
id|command
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_BASE_ADDRESS_0
comma
op_amp
id|io_port
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_BASE_ADDRESS_1
comma
op_amp
id|base
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|revision
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_INTERRUPT_LINE
comma
op_amp
id|irq
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_CACHE_LINE_SIZE
comma
op_amp
id|cache_line_size
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_LATENCY_TIMER
comma
op_amp
id|latency_timer
)paren
)paren
)paren
r_goto
id|err_pcibios
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Check if the chip is supported&n;&t; */
id|chip
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|ncr_chip_table
)paren
op_div
r_sizeof
(paren
id|ncr_chip_table
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|device_id
op_ne
id|ncr_chip_table
(braket
id|i
)braket
dot
id|device_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|revision
OG
id|ncr_chip_table
(braket
id|i
)braket
dot
id|revision_id
)paren
r_continue
suffix:semicolon
id|chip
op_assign
op_amp
id|device-&gt;chip
suffix:semicolon
id|memcpy
c_func
(paren
id|chip
comma
op_amp
id|ncr_chip_table
(braket
id|i
)braket
comma
r_sizeof
(paren
op_star
id|chip
)paren
)paren
suffix:semicolon
id|chip-&gt;revision_id
op_assign
id|revision
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|chip
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx: not initializing, device not supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check availability of IO space, memory space and master capability.&n;&t; */
r_if
c_cond
(paren
id|command
op_amp
id|PCI_COMMAND_IO
)paren
(brace
r_if
c_cond
(paren
(paren
id|io_port
op_amp
l_int|3
)paren
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx: disabling I/O mapping since base address 0 (0x%x)&bslash;n&quot;
l_string|&quot;           bits 0..1 indicate a non-IO mapping&bslash;n&quot;
comma
(paren
r_int
)paren
id|io_port
)paren
suffix:semicolon
id|io_port
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|io_port
op_and_assign
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
)brace
r_else
id|io_port
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|command
op_amp
id|PCI_COMMAND_MEMORY
)paren
(brace
r_if
c_cond
(paren
(paren
id|base
op_amp
id|PCI_BASE_ADDRESS_SPACE
)paren
op_ne
id|PCI_BASE_ADDRESS_SPACE_MEMORY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx: disabling memory mapping since base address 1&bslash;n&quot;
l_string|&quot;            contains a non-memory mapping&bslash;n&quot;
)paren
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|base
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
)brace
r_else
id|base
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io_port
op_logical_and
op_logical_neg
id|base
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx: not initializing, both I/O and memory mappings disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|io_port
op_logical_and
id|check_region
(paren
id|io_port
comma
l_int|128
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx: IO region 0x%x to 0x%x is in use&bslash;n&quot;
comma
(paren
r_int
)paren
id|io_port
comma
(paren
r_int
)paren
(paren
id|io_port
op_plus
l_int|127
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|command
op_amp
id|PCI_COMMAND_MASTER
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx: not initializing, BUS MASTERING was disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fix some features according to driver setup.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|driver_setup.special_features
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_SPECIAL_SET
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.ultra_scsi
OL
l_int|2
op_logical_and
(paren
id|chip-&gt;features
op_amp
id|FE_ULTRA2
)paren
)paren
(brace
id|chip-&gt;features
op_or_assign
id|FE_ULTRA
suffix:semicolon
id|chip-&gt;features
op_and_assign
op_complement
id|FE_ULTRA2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver_setup.ultra_scsi
OL
l_int|1
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_ULTRA
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver_setup.max_wide
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_WIDE
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_PCI_FIX_UP_SUPPORT
multiline_comment|/*&n;&t; * Try to fix up PCI config according to wished features.&n;&t; */
macro_line|#if defined(__i386) &amp;&amp; !defined(MODULE)
r_if
c_cond
(paren
(paren
id|driver_setup.pci_fix_up
op_amp
l_int|1
)paren
op_logical_and
(paren
id|chip-&gt;features
op_amp
id|FE_CLSE
)paren
op_logical_and
id|cache_line_size
op_eq
l_int|0
)paren
(brace
r_extern
r_char
id|x86
suffix:semicolon
r_switch
c_cond
(paren
id|x86
)paren
(brace
r_case
l_int|4
suffix:colon
id|cache_line_size
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|cache_line_size
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cache_line_size
)paren
id|error
op_assign
id|pcibios_write_config_byte
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_CACHE_LINE_SIZE
comma
id|cache_line_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|err_pcibios
suffix:semicolon
r_if
c_cond
(paren
id|initverbose
)paren
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx: setting PCI_CACHE_LINE_SIZE to %d (fix-up).&bslash;n&quot;
comma
id|cache_line_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|driver_setup.pci_fix_up
op_amp
l_int|2
)paren
op_logical_and
id|cache_line_size
op_logical_and
(paren
id|chip-&gt;features
op_amp
id|FE_WRIE
)paren
op_logical_and
op_logical_neg
(paren
id|command
op_amp
id|PCI_COMMAND_INVALIDATE
)paren
)paren
(brace
id|command
op_or_assign
id|PCI_COMMAND_INVALIDATE
suffix:semicolon
id|error
op_assign
id|pcibios_write_config_word
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|err_pcibios
suffix:semicolon
r_if
c_cond
(paren
id|initverbose
)paren
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx: setting PCI_COMMAND_INVALIDATE bit (fix-up).&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Fix up for old chips that support READ LINE but not CACHE LINE SIZE.&n;&t; * - If CACHE LINE SIZE is unknown, set burst max to 32 bytes = 8 dwords&n;&t; *   and donnot enable READ LINE.&n;&t; * - Otherwise set it to the CACHE LINE SIZE (power of 2 assumed). &n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|chip-&gt;features
op_amp
id|FE_CLSE
)paren
)paren
(brace
r_int
id|burst_max
op_assign
id|chip-&gt;burst_max
suffix:semicolon
r_if
c_cond
(paren
id|cache_line_size
op_eq
l_int|0
)paren
(brace
id|chip-&gt;features
op_and_assign
op_complement
id|FE_ERL
suffix:semicolon
r_if
c_cond
(paren
id|burst_max
OG
l_int|3
)paren
id|burst_max
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
id|cache_line_size
OL
(paren
l_int|1
op_lshift
id|burst_max
)paren
)paren
op_decrement
id|burst_max
suffix:semicolon
)brace
id|chip-&gt;burst_max
op_assign
id|burst_max
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Tune PCI LATENCY TIMER according to burst max length transfer.&n;&t; * (latency timer &gt;= burst length + 6, we add 10 to be quite sure)&n;&t; * If current value is zero, the device has probably been configured &n;&t; * for no bursting due to some broken hardware.&n;&t; */
r_if
c_cond
(paren
id|latency_timer
op_eq
l_int|0
op_logical_and
id|chip-&gt;burst_max
)paren
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx: PCI_LATENCY_TIMER=0, bursting should&squot;nt be allowed.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|driver_setup.pci_fix_up
op_amp
l_int|4
)paren
op_logical_and
id|chip-&gt;burst_max
)paren
(brace
id|uchar
id|lt
op_assign
(paren
l_int|1
op_lshift
id|chip-&gt;burst_max
)paren
op_plus
l_int|6
op_plus
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|latency_timer
OL
id|lt
)paren
(brace
id|latency_timer
op_assign
id|lt
suffix:semicolon
r_if
c_cond
(paren
id|initverbose
)paren
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx: setting PCI_LATENCY_TIMER to %d bus clocks (fix-up).&bslash;n&quot;
comma
id|latency_timer
)paren
suffix:semicolon
id|error
op_assign
id|pcibios_write_config_byte
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_LATENCY_TIMER
comma
id|latency_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|err_pcibios
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Fix up for recent chips that support CACHE LINE SIZE.&n;&t; * If PCI config space is not OK, remove features that shall not be &n;&t; * used by the chip. No need to trigger possible chip bugs.&n;&t; */
r_if
c_cond
(paren
(paren
id|chip-&gt;features
op_amp
id|FE_CLSE
)paren
op_logical_and
id|cache_line_size
op_eq
l_int|0
)paren
(brace
id|chip-&gt;features
op_and_assign
op_complement
id|FE_CACHE_SET
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx: PCI_CACHE_LINE_SIZE not set, features based on CACHE LINE SIZE not used.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|chip-&gt;features
op_amp
id|FE_WRIE
)paren
op_logical_and
op_logical_neg
(paren
id|command
op_amp
id|PCI_COMMAND_INVALIDATE
)paren
)paren
(brace
id|chip-&gt;features
op_and_assign
op_complement
id|FE_WRIE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx: PCI_COMMAND_INVALIDATE not set, WRITE AND INVALIDATE not used&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* SCSI_NCR_PCI_FIX_UP_SUPPORT */
multiline_comment|/* initialise ncr_device structure with items required by ncr_attach */
id|device-&gt;slot.bus
op_assign
id|bus
suffix:semicolon
id|device-&gt;slot.device_fn
op_assign
id|device_fn
suffix:semicolon
id|device-&gt;slot.base
op_assign
id|base
suffix:semicolon
id|device-&gt;slot.io_port
op_assign
id|io_port
suffix:semicolon
id|device-&gt;slot.irq
op_assign
id|irq
suffix:semicolon
id|device-&gt;attached
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_if
c_cond
(paren
op_logical_neg
id|nvram
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;** Get access to chip IO registers&n;&t;*/
macro_line|#ifdef NCR_IOMAPPED
id|request_region
c_func
(paren
id|io_port
comma
l_int|128
comma
l_string|&quot;ncr53c8xx&quot;
)paren
suffix:semicolon
id|device-&gt;slot.port
op_assign
id|ioport
suffix:semicolon
macro_line|#else
id|device-&gt;slot.reg
op_assign
(paren
r_struct
id|ncr_reg
op_star
)paren
id|remap_pci_mem
c_func
(paren
(paren
id|ulong
)paren
id|base
comma
l_int|128
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;slot.reg
)paren
r_goto
id|out
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;** Try to read SYMBIOS nvram.&n;&t;** Data can be used to order booting of boards.&n;&t;**&n;&t;** Data is saved in ncr_device structure if NVRAM found. This&n;&t;** is then used to find drive boot order for ncr_attach().&n;&t;**&n;&t;** NVRAM data is passed to Scsi_Host_Template later during ncr_attach()&n;&t;** for any device set up.&n;&t;**&n;&t;** Try to read TEKRAM nvram if Symbios nvram not found.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|ncr_get_Symbios_nvram
c_func
(paren
op_amp
id|device-&gt;slot
comma
op_amp
id|nvram-&gt;data.Symbios
)paren
)paren
id|nvram-&gt;type
op_assign
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|ncr_get_Tekram_nvram
c_func
(paren
op_amp
id|device-&gt;slot
comma
op_amp
id|nvram-&gt;data.Tekram
)paren
)paren
id|nvram-&gt;type
op_assign
id|SCSI_NCR_TEKRAM_NVRAM
suffix:semicolon
r_else
id|nvram-&gt;type
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
multiline_comment|/*&n;&t;** Release access to chip IO registers&n;&t;*/
macro_line|#ifdef NCR_IOMAPPED
id|release_region
c_func
(paren
id|device-&gt;slot.port
comma
l_int|128
)paren
suffix:semicolon
macro_line|#else
id|unmap_pci_mem
c_func
(paren
(paren
id|vm_offset_t
)paren
id|device-&gt;slot.reg
comma
(paren
id|u_long
)paren
l_int|128
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif&t;/* SCSI_NCR_NVRAM_SUPPORT */
r_return
l_int|0
suffix:semicolon
id|err_pcibios
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx: error %s reading configuration space&bslash;n&quot;
comma
id|pcibios_strerror
c_func
(paren
id|error
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,0,0)
multiline_comment|/*&n;**   Linux select queue depths function&n;*/
DECL|function|ncr53c8xx_select_queue_depths
r_static
r_void
id|ncr53c8xx_select_queue_depths
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|scsi_device
op_star
id|devlist
)paren
(brace
r_struct
id|scsi_device
op_star
id|device
suffix:semicolon
r_for
c_loop
(paren
id|device
op_assign
id|devlist
suffix:semicolon
id|device
suffix:semicolon
id|device
op_assign
id|device-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;host
op_eq
id|host
)paren
(brace
macro_line|#if SCSI_NCR_MAX_TAGS &gt; 1
r_if
c_cond
(paren
id|device-&gt;tagged_supported
)paren
(brace
id|device-&gt;queue_depth
op_assign
id|SCSI_NCR_MAX_TAGS
suffix:semicolon
)brace
r_else
(brace
id|device-&gt;queue_depth
op_assign
l_int|2
suffix:semicolon
)brace
macro_line|#else
id|device-&gt;queue_depth
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx_select_queue_depth: id=%d, lun=%d, queue_depth=%d&bslash;n&quot;
comma
id|device-&gt;id
comma
id|device-&gt;lun
comma
id|device-&gt;queue_depth
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;**   Linux entry point of queuecommand() function&n;*/
DECL|function|ncr53c8xx_queue_command
r_int
id|ncr53c8xx_queue_command
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
id|sts
suffix:semicolon
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx_queue_command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|sts
op_assign
id|ncr_queue_command
c_func
(paren
id|cmd
comma
id|done
)paren
)paren
op_ne
id|DID_OK
)paren
(brace
id|cmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|sts
comma
l_int|0
)paren
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : command not queued - result=%d&bslash;n&quot;
comma
id|sts
)paren
suffix:semicolon
macro_line|#endif
r_return
id|sts
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : command successfully queued&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|sts
suffix:semicolon
)brace
multiline_comment|/*&n;**   Linux entry point of the interrupt handler&n;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,70)
DECL|function|ncr53c8xx_intr
r_static
r_void
id|ncr53c8xx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
macro_line|#else
r_static
r_void
id|ncr53c8xx_intr
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
macro_line|#endif
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
macro_line|#if 0
id|u_long
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : interrupt received&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|host
op_assign
id|first_host
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|host-&gt;hostt
op_eq
id|the_template
op_logical_and
id|host-&gt;irq
op_eq
id|irq
)paren
(brace
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(1,3,70)
macro_line|#   ifdef SCSI_NCR_SHARE_IRQ
r_if
c_cond
(paren
id|dev_id
op_eq
id|host_data-&gt;ncb
)paren
(brace
macro_line|#else
r_if
c_cond
(paren
l_int|1
)paren
(brace
macro_line|#   endif
macro_line|#endif
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;[&quot;
)paren
suffix:semicolon
id|ncr_exception
c_func
(paren
id|host_data-&gt;ncb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#if 0
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;**   Linux entry point of the timer handler&n;*/
DECL|function|ncr53c8xx_timeout
r_static
r_void
id|ncr53c8xx_timeout
c_func
(paren
r_int
r_int
id|np
)paren
(brace
id|ncr_timeout
c_func
(paren
(paren
id|ncb_p
)paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;**   Linux entry point of reset() function&n;*/
macro_line|#if defined SCSI_RESET_SYNCHRONOUS &amp;&amp; defined SCSI_RESET_ASYNCHRONOUS
DECL|function|ncr53c8xx_reset
r_int
id|ncr53c8xx_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_int
id|reset_flags
)paren
(brace
r_int
id|sts
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx_reset: pid=%lu reset_flags=%x serial_number=%ld serial_number_at_timeout=%ld&bslash;n&quot;
comma
id|cmd-&gt;pid
comma
id|reset_flags
comma
id|cmd-&gt;serial_number
comma
id|cmd-&gt;serial_number_at_timeout
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have to just ignore reset requests in some situations.&n;&t; */
macro_line|#if defined SCSI_RESET_NOT_RUNNING
r_if
c_cond
(paren
id|cmd-&gt;serial_number
op_ne
id|cmd-&gt;serial_number_at_timeout
)paren
(brace
id|sts
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * If the mid-level driver told us reset is synchronous, it seems &n;&t; * that we must call the done() callback for the involved command, &n;&t; * even if this command was not queued to the low-level driver, &n;&t; * before returning SCSI_RESET_SUCCESS.&n;&t; */
id|sts
op_assign
id|ncr_reset_bus
c_func
(paren
id|cmd
comma
(paren
id|reset_flags
op_amp
(paren
id|SCSI_RESET_SYNCHRONOUS
op_or
id|SCSI_RESET_ASYNCHRONOUS
)paren
)paren
op_eq
id|SCSI_RESET_SYNCHRONOUS
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since we always reset the controller, when we return success, &n;&t; * we add this information to the return code.&n;&t; */
macro_line|#if defined SCSI_RESET_HOST_RESET
r_if
c_cond
(paren
id|sts
op_eq
id|SCSI_RESET_SUCCESS
)paren
id|sts
op_or_assign
id|SCSI_RESET_HOST_RESET
suffix:semicolon
macro_line|#endif
id|out
suffix:colon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|sts
suffix:semicolon
)brace
macro_line|#else
DECL|function|ncr53c8xx_reset
r_int
id|ncr53c8xx_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx_reset: command pid %lu&bslash;n&quot;
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
r_return
id|ncr_reset_bus
c_func
(paren
id|cmd
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;**   Linux entry point of abort() function&n;*/
macro_line|#if defined SCSI_RESET_SYNCHRONOUS &amp;&amp; defined SCSI_RESET_ASYNCHRONOUS
DECL|function|ncr53c8xx_abort
r_int
id|ncr53c8xx_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|sts
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx_abort: pid=%lu serial_number=%ld serial_number_at_timeout=%ld&bslash;n&quot;
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;serial_number
comma
id|cmd-&gt;serial_number_at_timeout
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have to just ignore abort requests in some situations.&n;&t; */
r_if
c_cond
(paren
id|cmd-&gt;serial_number
op_ne
id|cmd-&gt;serial_number_at_timeout
)paren
(brace
id|sts
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|sts
op_assign
id|ncr_abort_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|out
suffix:colon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|sts
suffix:semicolon
)brace
macro_line|#else
DECL|function|ncr53c8xx_abort
r_int
id|ncr53c8xx_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx_abort: command pid %lu&bslash;n&quot;
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
r_return
id|ncr_abort_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef MODULE
DECL|function|ncr53c8xx_release
r_int
id|ncr53c8xx_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
macro_line|#ifdef DEBUG_NCR53C8XX
id|printk
c_func
(paren
l_string|&quot;ncr53c8xx : release&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|host
op_assign
id|first_host
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|host-&gt;hostt
op_eq
id|the_template
)paren
(brace
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|ncr_detach
c_func
(paren
id|host_data-&gt;ncb
comma
id|host-&gt;irq
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;**&t;Scsi command waiting list management.&n;**&n;**&t;It may happen that we cannot insert a scsi command into the start queue,&n;**&t;in the following circumstances.&n;** &t;&t;Too few preallocated ccb(s), &n;**&t;&t;maxtags &lt; cmd_per_lun of the Linux host control block,&n;**&t;&t;etc...&n;**&t;Such scsi commands are inserted into a waiting list.&n;**&t;When a scsi command complete, we try to requeue the commands of the&n;**&t;waiting list.&n;*/
DECL|macro|next_wcmd
mdefine_line|#define next_wcmd host_scribble
DECL|function|insert_into_waiting_list
r_static
r_void
id|insert_into_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|Scsi_Cmnd
op_star
id|wcmd
suffix:semicolon
macro_line|#ifdef DEBUG_WAITING_LIST
id|printf
c_func
(paren
l_string|&quot;%s: cmd %lx inserted into waiting list&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|cmd-&gt;next_wcmd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|wcmd
op_assign
id|np-&gt;waiting_list
)paren
)paren
id|np-&gt;waiting_list
op_assign
id|cmd
suffix:semicolon
r_else
(brace
r_while
c_loop
(paren
(paren
id|wcmd-&gt;next_wcmd
)paren
op_ne
l_int|0
)paren
id|wcmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|wcmd-&gt;next_wcmd
suffix:semicolon
id|wcmd-&gt;next_wcmd
op_assign
(paren
r_char
op_star
)paren
id|cmd
suffix:semicolon
)brace
)brace
DECL|function|retrieve_from_waiting_list
r_static
id|Scsi_Cmnd
op_star
id|retrieve_from_waiting_list
c_func
(paren
r_int
id|to_remove
comma
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|Scsi_Cmnd
op_star
id|wcmd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|wcmd
op_assign
id|np-&gt;waiting_list
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|wcmd-&gt;next_wcmd
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_eq
(paren
id|Scsi_Cmnd
op_star
)paren
id|wcmd-&gt;next_wcmd
)paren
(brace
r_if
c_cond
(paren
id|to_remove
)paren
(brace
id|wcmd-&gt;next_wcmd
op_assign
id|cmd-&gt;next_wcmd
suffix:semicolon
id|cmd-&gt;next_wcmd
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_WAITING_LIST
id|printf
c_func
(paren
l_string|&quot;%s: cmd %lx retrieved from waiting list&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|cmd
)paren
suffix:semicolon
macro_line|#endif
r_return
id|cmd
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|process_waiting_list
r_static
r_void
id|process_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|sts
)paren
(brace
id|Scsi_Cmnd
op_star
id|waiting_list
comma
op_star
id|wcmd
suffix:semicolon
id|waiting_list
op_assign
id|np-&gt;waiting_list
suffix:semicolon
id|np-&gt;waiting_list
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_WAITING_LIST
r_if
c_cond
(paren
id|waiting_list
)paren
id|printf
c_func
(paren
l_string|&quot;%s: waiting_list=%lx processing sts=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|waiting_list
comma
id|sts
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
(paren
id|wcmd
op_assign
id|waiting_list
)paren
op_ne
l_int|0
)paren
(brace
id|waiting_list
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|wcmd-&gt;next_wcmd
suffix:semicolon
id|wcmd-&gt;next_wcmd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sts
op_eq
id|DID_OK
)paren
(brace
macro_line|#ifdef DEBUG_WAITING_LIST
id|printf
c_func
(paren
l_string|&quot;%s: cmd %lx trying to requeue&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|wcmd
)paren
suffix:semicolon
macro_line|#endif
id|sts
op_assign
id|ncr_queue_command
c_func
(paren
id|wcmd
comma
id|wcmd-&gt;scsi_done
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sts
op_ne
id|DID_OK
)paren
(brace
macro_line|#ifdef DEBUG_WAITING_LIST
id|printf
c_func
(paren
l_string|&quot;%s: cmd %lx done forced sts=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|wcmd
comma
id|sts
)paren
suffix:semicolon
macro_line|#endif
id|wcmd-&gt;result
op_assign
id|ScsiResult
c_func
(paren
id|sts
comma
l_int|0
)paren
suffix:semicolon
id|wcmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|wcmd
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|macro|next_wcmd
macro_line|#undef next_wcmd
multiline_comment|/*&n;**&t;Returns data transfer direction for common op-codes.&n;*/
DECL|function|guess_xfer_direction
r_static
r_int
id|guess_xfer_direction
c_func
(paren
r_int
id|opcode
)paren
(brace
r_int
id|d
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
l_int|0x12
suffix:colon
multiline_comment|/*&t;INQUIRY&t;&t;&t;&t;12 */
r_case
l_int|0x4D
suffix:colon
multiline_comment|/*&t;LOG SENSE&t;&t;&t;4D */
r_case
l_int|0x5A
suffix:colon
multiline_comment|/*&t;MODE SENSE(10)&t;&t;&t;5A */
r_case
l_int|0x1A
suffix:colon
multiline_comment|/*&t;MODE SENSE(6)&t;&t;&t;1A */
r_case
l_int|0x3C
suffix:colon
multiline_comment|/*&t;READ BUFFER&t;&t;&t;3C */
r_case
l_int|0x1C
suffix:colon
multiline_comment|/*&t;RECEIVE DIAGNOSTIC RESULTS&t;1C */
r_case
l_int|0x03
suffix:colon
multiline_comment|/*&t;REQUEST SENSE&t;&t;&t;03 */
id|d
op_assign
id|XferIn
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x39
suffix:colon
multiline_comment|/*&t;COMPARE&t;&t;&t;&t;39 */
r_case
l_int|0x3A
suffix:colon
multiline_comment|/*&t;COPY AND VERIFY&t;&t;&t;3A */
r_case
l_int|0x18
suffix:colon
multiline_comment|/*&t;COPY&t;&t;&t;&t;18 */
r_case
l_int|0x4C
suffix:colon
multiline_comment|/*&t;LOG SELECT&t;&t;&t;4C */
r_case
l_int|0x55
suffix:colon
multiline_comment|/*&t;MODE SELECT(10)&t;&t;&t;55 */
r_case
l_int|0x3B
suffix:colon
multiline_comment|/*&t;WRITE BUFFER&t;&t;&t;3B */
r_case
l_int|0x1D
suffix:colon
multiline_comment|/*&t;SEND DIAGNOSTIC&t;&t;&t;1D */
r_case
l_int|0x40
suffix:colon
multiline_comment|/*&t;CHANGE DEFINITION&t;&t;40 */
r_case
l_int|0x15
suffix:colon
multiline_comment|/*&t;MODE SELECT(6)&t;&t;&t;15 */
id|d
op_assign
id|XferOut
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x00
suffix:colon
multiline_comment|/*&t;TEST UNIT READY&t;&t;&t;00 */
id|d
op_assign
id|XferNone
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|d
op_assign
id|XferBoth
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|d
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_PROC_INFO_SUPPORT
multiline_comment|/*=========================================================================&n;**&t;Proc file system stuff&n;**&n;**&t;A read operation returns profile information.&n;**&t;A write operation is a control command.&n;**&t;The string is parsed in the driver code and the command is passed &n;**&t;to the ncr_usercmd() function.&n;**=========================================================================&n;*/
macro_line|#ifdef SCSI_NCR_USER_COMMAND_SUPPORT
DECL|macro|is_digit
mdefine_line|#define is_digit(c)&t;((c) &gt;= &squot;0&squot; &amp;&amp; (c) &lt;= &squot;9&squot;)
DECL|macro|digit_to_bin
mdefine_line|#define digit_to_bin(c)&t;((c) - &squot;0&squot;)
DECL|macro|is_space
mdefine_line|#define is_space(c)&t;((c) == &squot; &squot; || (c) == &squot;&bslash;t&squot;)
DECL|function|skip_spaces
r_static
r_int
id|skip_spaces
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
)paren
(brace
r_int
id|cnt
comma
id|c
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
id|len
suffix:semicolon
id|cnt
OG
l_int|0
op_logical_and
(paren
id|c
op_assign
op_star
id|ptr
op_increment
)paren
op_logical_and
id|is_space
c_func
(paren
id|c
)paren
suffix:semicolon
id|cnt
op_decrement
)paren
suffix:semicolon
r_return
(paren
id|len
op_minus
id|cnt
)paren
suffix:semicolon
)brace
DECL|function|get_int_arg
r_static
r_int
id|get_int_arg
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
comma
id|u_long
op_star
id|pv
)paren
(brace
r_int
id|cnt
comma
id|c
suffix:semicolon
id|u_long
id|v
suffix:semicolon
r_for
c_loop
(paren
id|v
op_assign
l_int|0
comma
id|cnt
op_assign
id|len
suffix:semicolon
id|cnt
OG
l_int|0
op_logical_and
(paren
id|c
op_assign
op_star
id|ptr
op_increment
)paren
op_logical_and
id|is_digit
c_func
(paren
id|c
)paren
suffix:semicolon
id|cnt
op_decrement
)paren
(brace
id|v
op_assign
(paren
id|v
op_star
l_int|10
)paren
op_plus
id|digit_to_bin
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pv
)paren
op_star
id|pv
op_assign
id|v
suffix:semicolon
r_return
(paren
id|len
op_minus
id|cnt
)paren
suffix:semicolon
)brace
DECL|function|is_keyword
r_static
r_int
id|is_keyword
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
comma
r_char
op_star
id|verb
)paren
(brace
r_int
id|verb_len
op_assign
id|strlen
c_func
(paren
id|verb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|strlen
c_func
(paren
id|verb
)paren
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|verb
comma
id|ptr
comma
id|verb_len
)paren
)paren
r_return
id|verb_len
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SKIP_SPACES
mdefine_line|#define SKIP_SPACES(min_spaces)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if ((arg_len = skip_spaces(ptr, len)) &lt; (min_spaces))&t;&t;&bslash;&n;&t;&t;return -EINVAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ptr += arg_len; len -= arg_len;
DECL|macro|GET_INT_ARG
mdefine_line|#define GET_INT_ARG(v)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (!(arg_len = get_int_arg(ptr, len, &amp;(v))))&t;&t;&t;&bslash;&n;&t;&t;return -EINVAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ptr += arg_len; len -= arg_len;
multiline_comment|/*&n;**&t;Parse a control command&n;*/
DECL|function|ncr_user_command
r_static
r_int
id|ncr_user_command
c_func
(paren
id|ncb_p
id|np
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_char
op_star
id|ptr
op_assign
id|buffer
suffix:semicolon
r_int
id|len
op_assign
id|length
suffix:semicolon
r_struct
id|usrcmd
op_star
id|uc
op_assign
op_amp
id|np-&gt;user
suffix:semicolon
r_int
id|arg_len
suffix:semicolon
id|u_long
id|target
suffix:semicolon
id|bzero
c_func
(paren
id|uc
comma
r_sizeof
(paren
op_star
id|uc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
op_logical_and
id|ptr
(braket
id|len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
op_decrement
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setsync&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETSYNC
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;settags&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETTAGS
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setorder&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETORDER
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setwide&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETWIDE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setdebug&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETDEBUG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setflag&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETFLAG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;clearprof&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_CLEARPROF
suffix:semicolon
macro_line|#ifdef&t;UC_DEBUG_ERROR_RECOVERY
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;debug_error_recovery&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_DEBUG_ERROR_RECOVERY
suffix:semicolon
macro_line|#endif
r_else
id|arg_len
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printf
c_func
(paren
l_string|&quot;ncr_user_command: arg_len=%d, cmd=%ld&bslash;n&quot;
comma
id|arg_len
comma
id|uc-&gt;cmd
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|arg_len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETSYNC
suffix:colon
r_case
id|UC_SETTAGS
suffix:colon
r_case
id|UC_SETWIDE
suffix:colon
r_case
id|UC_SETFLAG
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;all&quot;
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
id|uc-&gt;target
op_assign
op_complement
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|GET_INT_ARG
c_func
(paren
id|target
)paren
suffix:semicolon
id|uc-&gt;target
op_assign
(paren
l_int|1
op_lshift
id|target
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printf
c_func
(paren
l_string|&quot;ncr_user_command: target=%ld&bslash;n&quot;
comma
id|target
)paren
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETSYNC
suffix:colon
r_case
id|UC_SETTAGS
suffix:colon
r_case
id|UC_SETWIDE
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|GET_INT_ARG
c_func
(paren
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printf
c_func
(paren
l_string|&quot;ncr_user_command: data=%ld&bslash;n&quot;
comma
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|UC_SETORDER
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;simple&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
id|M_SIMPLE_TAG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;ordered&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
id|M_ORDERED_TAG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;default&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
l_int|0
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETDEBUG
suffix:colon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;alloc&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_ALLOC
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;phase&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_PHASE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;poll&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_POLL
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;queue&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_QUEUE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;result&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_RESULT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;scatter&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_SCATTER
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;script&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_SCRIPT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;tiny&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TINY
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;timing&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TIMING
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;nego&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_NEGO
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;tags&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TAGS
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;freeze&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_FREEZE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;restart&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_RESTART
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_PROC_INFO
id|printf
c_func
(paren
l_string|&quot;ncr_user_command: data=%ld&bslash;n&quot;
comma
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|UC_SETFLAG
suffix:colon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;trace&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|UF_TRACE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;no_disc&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|UF_NODISC
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#ifdef&t;UC_DEBUG_ERROR_RECOVERY
r_case
id|UC_DEBUG_ERROR_RECOVERY
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;sge&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;abort&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
l_int|2
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;reset&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
l_int|3
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;parity&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
l_int|4
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;none&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
l_int|0
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
(brace
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ncr_usercmd
(paren
id|np
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_return
id|length
suffix:semicolon
)brace
macro_line|#endif&t;/* SCSI_NCR_USER_COMMAND_SUPPORT */
macro_line|#ifdef SCSI_NCR_USER_INFO_SUPPORT
DECL|struct|info_str
r_struct
id|info_str
(brace
DECL|member|buffer
r_char
op_star
id|buffer
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|pos
r_int
id|pos
suffix:semicolon
)brace
suffix:semicolon
DECL|function|copy_mem_info
r_static
r_void
id|copy_mem_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OG
id|info-&gt;length
)paren
id|len
op_assign
id|info-&gt;length
op_minus
id|info-&gt;pos
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OL
id|info-&gt;offset
)paren
(brace
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;pos
OL
id|info-&gt;offset
)paren
(brace
id|data
op_add_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|info-&gt;buffer
op_plus
id|info-&gt;pos
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
)brace
)brace
DECL|function|copy_info
r_static
r_int
id|copy_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_char
id|buf
(braket
l_int|81
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|len
op_assign
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
id|copy_mem_info
c_func
(paren
id|info
comma
id|buf
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Copy formatted profile information into the input buffer.&n;*/
DECL|macro|to_ms
mdefine_line|#define to_ms(t) ((t) * 1000 / HZ)
DECL|function|ncr_host_info
r_static
r_int
id|ncr_host_info
c_func
(paren
id|ncb_p
id|np
comma
r_char
op_star
id|ptr
comma
id|off_t
id|offset
comma
r_int
id|len
)paren
(brace
r_struct
id|info_str
id|info
suffix:semicolon
id|info.buffer
op_assign
id|ptr
suffix:semicolon
id|info.length
op_assign
id|len
suffix:semicolon
id|info.offset
op_assign
id|offset
suffix:semicolon
id|info.pos
op_assign
l_int|0
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;General information:&bslash;n&quot;
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  Chip NCR53C%s, &quot;
comma
id|np-&gt;chip_name
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;device id 0x%x, &quot;
comma
id|np-&gt;device_id
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;revision id 0x%x&bslash;n&quot;
comma
id|np-&gt;revision_id
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  IO port address 0x%lx, &quot;
comma
(paren
id|u_long
)paren
id|np-&gt;port
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;IRQ number %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|np-&gt;irq
)paren
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
r_if
c_cond
(paren
id|np-&gt;reg
)paren
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  Using memory mapped IO at virtual address 0x%lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
id|np-&gt;reg
)paren
suffix:semicolon
macro_line|#endif
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  Synchronous period factor %d, &quot;
comma
(paren
r_int
)paren
id|np-&gt;minsync
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;max commands per lun %d&bslash;n&quot;
comma
id|SCSI_NCR_MAX_TAGS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.debug
op_logical_or
id|driver_setup.verbose
OG
l_int|1
)paren
(brace
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  Debug flags 0x%x, &quot;
comma
id|driver_setup.debug
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;verbosity level %d&bslash;n&quot;
comma
id|driver_setup.verbose
)paren
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Profiling information:&bslash;n&quot;
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_trans&quot;
comma
id|np-&gt;profile.num_trans
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_kbytes&quot;
comma
id|np-&gt;profile.num_kbytes
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_disc&quot;
comma
id|np-&gt;profile.num_disc
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_break&quot;
comma
id|np-&gt;profile.num_break
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_int&quot;
comma
id|np-&gt;profile.num_int
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_fly&quot;
comma
id|np-&gt;profile.num_fly
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;ms_setup&quot;
comma
id|to_ms
c_func
(paren
id|np-&gt;profile.ms_setup
)paren
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;ms_data&quot;
comma
id|to_ms
c_func
(paren
id|np-&gt;profile.ms_data
)paren
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;ms_disc&quot;
comma
id|to_ms
c_func
(paren
id|np-&gt;profile.ms_disc
)paren
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;ms_post&quot;
comma
id|to_ms
c_func
(paren
id|np-&gt;profile.ms_post
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|info.pos
OG
id|info.offset
ques
c_cond
id|info.pos
op_minus
id|info.offset
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_USER_INFO_SUPPORT */
multiline_comment|/*&n;**&t;Entry point of the scsi proc fs of the driver.&n;**&t;- func = 0 means read  (returns profile data)&n;**&t;- func = 1 means write (parse user control command)&n;*/
DECL|function|ncr53c8xx_proc_info
r_int
id|ncr53c8xx_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|func
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
id|ncb_p
id|ncb
op_assign
l_int|0
suffix:semicolon
r_int
id|retv
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printf
c_func
(paren
l_string|&quot;ncr53c8xx_proc_info: hostno=%d, func=%d&bslash;n&quot;
comma
id|hostno
comma
id|func
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|host
op_assign
id|first_host
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|host-&gt;hostt
op_eq
id|the_template
op_logical_and
id|host-&gt;host_no
op_eq
id|hostno
)paren
(brace
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|ncb
op_assign
id|host_data-&gt;ncb
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ncb
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|func
)paren
(brace
macro_line|#ifdef&t;SCSI_NCR_USER_COMMAND_SUPPORT
id|retv
op_assign
id|ncr_user_command
c_func
(paren
id|ncb
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
macro_line|#else
id|retv
op_assign
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
id|start
)paren
op_star
id|start
op_assign
id|buffer
suffix:semicolon
macro_line|#ifdef SCSI_NCR_USER_INFO_SUPPORT
id|retv
op_assign
id|ncr_host_info
c_func
(paren
id|ncb
comma
id|buffer
comma
id|offset
comma
id|length
)paren
suffix:semicolon
macro_line|#else
id|retv
op_assign
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/*=========================================================================&n;**&t;End of proc file system stuff&n;**=========================================================================&n;*/
macro_line|#endif
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
multiline_comment|/* ---------------------------------------------------------------------&n;**&n;**&t;Try reading Symbios format nvram&n;**&n;** ---------------------------------------------------------------------&n;**&n;** GPOI0 - data in/data out&n;** GPIO1 - clock&n;**&n;**&t;return 0 if NVRAM data OK, 1 if NVRAM data not OK&n;** ---------------------------------------------------------------------&n;*/
DECL|macro|SET_BIT
mdefine_line|#define SET_BIT 0
DECL|macro|CLR_BIT
mdefine_line|#define CLR_BIT 1
DECL|macro|SET_CLK
mdefine_line|#define SET_CLK 2
DECL|macro|CLR_CLK
mdefine_line|#define CLR_CLK 3
r_static
id|u_short
id|nvram_read_data
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|data
comma
r_int
id|len
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
suffix:semicolon
r_static
r_void
id|nvram_start
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
r_static
r_void
id|nvram_write_byte
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|ack_data
comma
id|u_char
id|write_data
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
suffix:semicolon
r_static
r_void
id|nvram_read_byte
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_data
comma
id|u_char
id|ack_data
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
suffix:semicolon
r_static
r_void
id|nvram_readAck
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
suffix:semicolon
r_static
r_void
id|nvram_writeAck
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
suffix:semicolon
r_static
r_void
id|nvram_doBit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
r_static
r_void
id|nvram_stop
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
r_static
r_void
id|nvram_setBit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
comma
r_int
id|bit_mode
)paren
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|ncr_get_Symbios_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|Symbios_nvram
op_star
id|nvram
)paren
)paren
(brace
r_static
id|u_char
id|Symbios_trailer
(braket
l_int|6
)braket
op_assign
(brace
l_int|0xfe
comma
l_int|0xfe
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|u_char
id|gpcntl
comma
id|gpreg
suffix:semicolon
id|u_char
id|old_gpcntl
comma
id|old_gpreg
suffix:semicolon
id|u_short
id|csum
suffix:semicolon
id|u_char
id|ack_data
suffix:semicolon
r_int
id|retv
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* save current state of GPCNTL and GPREG */
id|old_gpreg
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
id|old_gpcntl
op_assign
id|INB
(paren
id|nc_gpcntl
)paren
suffix:semicolon
id|gpcntl
op_assign
id|old_gpcntl
op_amp
l_int|0xfc
suffix:semicolon
multiline_comment|/* set up GPREG &amp; GPCNTL to set GPIO0 and GPIO1 in to known state */
id|OUTB
(paren
id|nc_gpreg
comma
id|old_gpreg
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* this is to set NVRAM into a known state with GPIO0/1 both low */
id|gpreg
op_assign
id|old_gpreg
suffix:semicolon
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|0
comma
op_amp
id|gpreg
comma
id|CLR_CLK
)paren
suffix:semicolon
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|0
comma
op_amp
id|gpreg
comma
id|CLR_BIT
)paren
suffix:semicolon
multiline_comment|/* now set NVRAM inactive with GPIO0/1 both high */
id|nvram_stop
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* activate NVRAM */
id|nvram_start
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* write device code and random address MSB */
id|nvram_write_byte
c_func
(paren
id|np
comma
op_amp
id|ack_data
comma
l_int|0xa0
op_or
(paren
(paren
id|SYMBIOS_NVRAM_ADDRESS
op_rshift
l_int|7
)paren
op_amp
l_int|0x0e
)paren
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack_data
op_amp
l_int|0x01
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* write random address LSB */
id|nvram_write_byte
c_func
(paren
id|np
comma
op_amp
id|ack_data
comma
(paren
id|SYMBIOS_NVRAM_ADDRESS
op_amp
l_int|0x7f
)paren
op_lshift
l_int|1
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack_data
op_amp
l_int|0x01
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* regenerate START state to set up for reading */
id|nvram_start
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* rewrite device code and address MSB with read bit set (lsb = 0x01) */
id|nvram_write_byte
c_func
(paren
id|np
comma
op_amp
id|ack_data
comma
l_int|0xa1
op_or
(paren
(paren
id|SYMBIOS_NVRAM_ADDRESS
op_rshift
l_int|7
)paren
op_amp
l_int|0x0e
)paren
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack_data
op_amp
l_int|0x01
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* now set up GPIO0 for inputting data */
id|gpcntl
op_or_assign
l_int|0x01
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* input all active data - only part of total NVRAM */
id|csum
op_assign
id|nvram_read_data
c_func
(paren
id|np
comma
(paren
id|u_char
op_star
)paren
id|nvram
comma
r_sizeof
(paren
op_star
id|nvram
)paren
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* finally put NVRAM back in inactive mode */
id|gpcntl
op_and_assign
l_int|0xfe
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
id|nvram_stop
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_DEBUG_NVRAM
id|printf
c_func
(paren
l_string|&quot;ncr53c8xx: NvRAM marker=%x trailer=%x %x %x %x %x %x byte_count=%d/%d checksum=%x/%x&bslash;n&quot;
comma
id|nvram-&gt;start_marker
comma
id|nvram-&gt;trailer
(braket
l_int|0
)braket
comma
id|nvram-&gt;trailer
(braket
l_int|1
)braket
comma
id|nvram-&gt;trailer
(braket
l_int|2
)braket
comma
id|nvram-&gt;trailer
(braket
l_int|3
)braket
comma
id|nvram-&gt;trailer
(braket
l_int|4
)braket
comma
id|nvram-&gt;trailer
(braket
l_int|5
)braket
comma
id|nvram-&gt;byte_count
comma
r_sizeof
(paren
op_star
id|nvram
)paren
op_minus
l_int|12
comma
id|nvram-&gt;checksum
comma
id|csum
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* check valid NVRAM signature, verify byte count and checksum */
r_if
c_cond
(paren
id|nvram-&gt;start_marker
op_eq
l_int|0
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|nvram-&gt;trailer
comma
id|Symbios_trailer
comma
l_int|6
)paren
op_logical_and
id|nvram-&gt;byte_count
op_eq
r_sizeof
(paren
op_star
id|nvram
)paren
op_minus
l_int|12
op_logical_and
id|csum
op_eq
id|nvram-&gt;checksum
)paren
id|retv
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* return GPIO0/1 to original states after having accessed NVRAM */
id|OUTB
(paren
id|nc_gpcntl
comma
id|old_gpcntl
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
id|old_gpreg
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/*&n; * Read Symbios NvRAM data and compute checksum.&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
id|u_short
id|nvram_read_data
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|data
comma
r_int
id|len
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
)paren
(brace
r_int
id|x
suffix:semicolon
id|u_short
id|csum
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|len
suffix:semicolon
id|x
op_increment
)paren
id|nvram_read_byte
c_func
(paren
id|np
comma
op_amp
id|data
(braket
id|x
)braket
comma
(paren
id|x
op_eq
(paren
id|len
op_minus
l_int|1
)paren
)paren
comma
id|gpreg
comma
id|gpcntl
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|6
comma
id|csum
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|len
op_minus
l_int|6
suffix:semicolon
id|x
op_increment
)paren
id|csum
op_add_assign
id|data
(braket
id|x
)braket
suffix:semicolon
r_return
id|csum
suffix:semicolon
)brace
multiline_comment|/*&n; * Send START condition to NVRAM to wake it up.&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|nvram_start
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
)paren
(brace
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|1
comma
id|gpreg
comma
id|SET_BIT
)paren
suffix:semicolon
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|SET_CLK
)paren
suffix:semicolon
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_BIT
)paren
suffix:semicolon
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_CLK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * WRITE a byte to the NVRAM and then get an ACK to see it was accepted OK,&n; * GPIO0 must already be set as an output&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|nvram_write_byte
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|ack_data
comma
id|u_char
id|write_data
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
)paren
(brace
r_int
id|x
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|8
suffix:semicolon
id|x
op_increment
)paren
id|nvram_doBit
c_func
(paren
id|np
comma
l_int|0
comma
(paren
id|write_data
op_rshift
(paren
l_int|7
op_minus
id|x
)paren
)paren
op_amp
l_int|0x01
comma
id|gpreg
)paren
suffix:semicolon
id|nvram_readAck
c_func
(paren
id|np
comma
id|ack_data
comma
id|gpreg
comma
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * READ a byte from the NVRAM and then send an ACK to say we have got it,&n; * GPIO0 must already be set as an input&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|nvram_read_byte
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_data
comma
id|u_char
id|ack_data
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
)paren
(brace
r_int
id|x
suffix:semicolon
id|u_char
id|read_bit
suffix:semicolon
op_star
id|read_data
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|8
suffix:semicolon
id|x
op_increment
)paren
(brace
id|nvram_doBit
c_func
(paren
id|np
comma
op_amp
id|read_bit
comma
l_int|1
comma
id|gpreg
)paren
suffix:semicolon
op_star
id|read_data
op_or_assign
(paren
(paren
id|read_bit
op_amp
l_int|0x01
)paren
op_lshift
(paren
l_int|7
op_minus
id|x
)paren
)paren
suffix:semicolon
)brace
id|nvram_writeAck
c_func
(paren
id|np
comma
id|ack_data
comma
id|gpreg
comma
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Output an ACK to the NVRAM after reading,&n; * change GPIO0 to output and when done back to an input&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|nvram_writeAck
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
)paren
(brace
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
op_amp
l_int|0xfe
)paren
suffix:semicolon
id|nvram_doBit
c_func
(paren
id|np
comma
l_int|0
comma
id|write_bit
comma
id|gpreg
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Input an ACK from NVRAM after writing,&n; * change GPIO0 to input and when done back to an output&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|nvram_readAck
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
)paren
(brace
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
op_or
l_int|0x01
)paren
suffix:semicolon
id|nvram_doBit
c_func
(paren
id|np
comma
id|read_bit
comma
l_int|1
comma
id|gpreg
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read or write a bit to the NVRAM,&n; * read if GPIO0 input else write if GPIO0 output&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|nvram_doBit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
)paren
)paren
(brace
id|nvram_setBit
c_func
(paren
id|np
comma
id|write_bit
comma
id|gpreg
comma
id|SET_BIT
)paren
suffix:semicolon
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|SET_CLK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_bit
)paren
op_star
id|read_bit
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_CLK
)paren
suffix:semicolon
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_BIT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Send STOP condition to NVRAM - puts NVRAM to sleep... ZZzzzz!!&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|nvram_stop
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
)paren
(brace
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|SET_CLK
)paren
suffix:semicolon
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|1
comma
id|gpreg
comma
id|SET_BIT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set/clear data/clock bit in GPIO0&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|nvram_setBit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
comma
r_int
id|bit_mode
)paren
)paren
(brace
id|DELAY
c_func
(paren
l_int|5
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bit_mode
)paren
(brace
r_case
id|SET_BIT
suffix:colon
op_star
id|gpreg
op_or_assign
id|write_bit
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLR_BIT
suffix:colon
op_star
id|gpreg
op_and_assign
l_int|0xfe
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SET_CLK
suffix:colon
op_star
id|gpreg
op_or_assign
l_int|0x02
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLR_CLK
suffix:colon
op_star
id|gpreg
op_and_assign
l_int|0xfd
suffix:semicolon
r_break
suffix:semicolon
)brace
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
id|DELAY
c_func
(paren
l_int|5
)paren
suffix:semicolon
)brace
DECL|macro|SET_BIT
macro_line|#undef SET_BIT 0
DECL|macro|CLR_BIT
macro_line|#undef CLR_BIT 1
DECL|macro|SET_CLK
macro_line|#undef SET_CLK 2
DECL|macro|CLR_CLK
macro_line|#undef CLR_CLK 3
multiline_comment|/* ---------------------------------------------------------------------&n;**&n;**&t;Try reading Tekram format nvram&n;**&n;** ---------------------------------------------------------------------&n;**&n;** GPOI0 - data in&n;** GPIO1 - data out&n;** GPIO2 - clock&n;** GPIO4 - chip select&n;**&n;**&t;return 0 if NVRAM data OK, 1 if NVRAM data not OK&n;** ---------------------------------------------------------------------&n;*/
r_static
id|u_short
id|Tnvram_read_data
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
op_star
id|data
comma
r_int
id|len
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
r_static
r_void
id|Tnvram_Send_Command
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
id|write_data
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
r_static
r_void
id|Tnvram_Read_Word
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
op_star
id|nvram_data
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
r_static
r_void
id|Tnvram_Read_Bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
r_static
r_void
id|Tnvram_Write_Bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
r_static
r_void
id|Tnvram_Stop
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
r_static
r_void
id|Tnvram_Clk
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|ncr_get_Tekram_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|Tekram_nvram
op_star
id|nvram
)paren
)paren
(brace
id|u_char
id|gpcntl
comma
id|gpreg
suffix:semicolon
id|u_char
id|old_gpcntl
comma
id|old_gpreg
suffix:semicolon
id|u_short
id|csum
suffix:semicolon
multiline_comment|/* save current state of GPCNTL and GPREG */
id|old_gpreg
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
id|old_gpcntl
op_assign
id|INB
(paren
id|nc_gpcntl
)paren
suffix:semicolon
multiline_comment|/* set up GPREG &amp; GPCNTL to set GPIO0/1/2/4 in to known state, 0 in,&n;&t;   1/2/4 out */
id|gpreg
op_assign
id|old_gpreg
op_amp
l_int|0xe9
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
id|gpreg
)paren
suffix:semicolon
id|gpcntl
op_assign
(paren
id|old_gpcntl
op_amp
l_int|0xe9
)paren
op_or
l_int|0x09
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* input all of NVRAM, 64 words */
id|csum
op_assign
id|Tnvram_read_data
c_func
(paren
id|np
comma
(paren
id|u_short
op_star
)paren
id|nvram
comma
r_sizeof
(paren
op_star
id|nvram
)paren
op_div
r_sizeof
(paren
r_int
)paren
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* return GPIO0/1/2/4 to original states after having accessed NVRAM */
id|OUTB
(paren
id|nc_gpcntl
comma
id|old_gpcntl
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
id|old_gpreg
)paren
suffix:semicolon
multiline_comment|/* check data valid */
r_if
c_cond
(paren
id|csum
op_ne
l_int|0x1234
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read Tekram NvRAM data and compute checksum.&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
id|u_short
id|Tnvram_read_data
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
op_star
id|data
comma
r_int
id|len
comma
id|u_char
op_star
id|gpreg
)paren
)paren
(brace
id|u_char
id|read_bit
suffix:semicolon
id|u_short
id|csum
suffix:semicolon
r_int
id|x
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
comma
id|csum
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|len
suffix:semicolon
id|x
op_increment
)paren
(brace
multiline_comment|/* output read command and address */
id|Tnvram_Send_Command
c_func
(paren
id|np
comma
l_int|0x180
op_or
id|x
comma
op_amp
id|read_bit
comma
id|gpreg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_bit
op_amp
l_int|0x01
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Force bad checksum */
id|Tnvram_Read_Word
c_func
(paren
id|np
comma
op_amp
id|data
(braket
id|x
)braket
comma
id|gpreg
)paren
suffix:semicolon
id|csum
op_add_assign
id|data
(braket
id|x
)braket
suffix:semicolon
id|Tnvram_Stop
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
)brace
r_return
id|csum
suffix:semicolon
)brace
multiline_comment|/*&n; * Send read command and address to NVRAM&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|Tnvram_Send_Command
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
id|write_data
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
)paren
)paren
(brace
r_int
id|x
suffix:semicolon
multiline_comment|/* send 9 bits, start bit (1), command (2), address (6)  */
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|9
suffix:semicolon
id|x
op_increment
)paren
id|Tnvram_Write_Bit
c_func
(paren
id|np
comma
(paren
id|u_char
)paren
(paren
id|write_data
op_rshift
(paren
l_int|8
op_minus
id|x
)paren
)paren
comma
id|gpreg
)paren
suffix:semicolon
op_star
id|read_bit
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * READ a byte from the NVRAM&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|Tnvram_Read_Word
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
op_star
id|nvram_data
comma
id|u_char
op_star
id|gpreg
)paren
)paren
(brace
r_int
id|x
suffix:semicolon
id|u_char
id|read_bit
suffix:semicolon
op_star
id|nvram_data
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|16
suffix:semicolon
id|x
op_increment
)paren
(brace
id|Tnvram_Read_Bit
c_func
(paren
id|np
comma
op_amp
id|read_bit
comma
id|gpreg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_bit
op_amp
l_int|0x01
)paren
op_star
id|nvram_data
op_or_assign
(paren
l_int|0x01
op_lshift
(paren
l_int|15
op_minus
id|x
)paren
)paren
suffix:semicolon
r_else
op_star
id|nvram_data
op_and_assign
op_complement
(paren
l_int|0x01
op_lshift
(paren
l_int|15
op_minus
id|x
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Read bit from NVRAM&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|Tnvram_Read_Bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
)paren
)paren
(brace
id|DELAY
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|Tnvram_Clk
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
op_star
id|read_bit
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write bit to GPIO0&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|Tnvram_Write_Bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
)paren
)paren
(brace
r_if
c_cond
(paren
id|write_bit
op_amp
l_int|0x01
)paren
op_star
id|gpreg
op_or_assign
l_int|0x02
suffix:semicolon
r_else
op_star
id|gpreg
op_and_assign
l_int|0xfd
suffix:semicolon
op_star
id|gpreg
op_or_assign
l_int|0x10
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
id|DELAY
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|Tnvram_Clk
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Send STOP condition to NVRAM - puts NVRAM to sleep... ZZZzzz!!&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|Tnvram_Stop
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
)paren
(brace
op_star
id|gpreg
op_and_assign
l_int|0xef
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
id|DELAY
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|Tnvram_Clk
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Pulse clock bit in GPIO0&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|Tnvram_Clk
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
)paren
(brace
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
op_or
l_int|0x04
)paren
suffix:semicolon
id|DELAY
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* SCSI_NCR_NVRAM_SUPPORT */
multiline_comment|/*&n;**&t;Module stuff&n;*/
macro_line|#ifdef MODULE
DECL|variable|driver_template
id|Scsi_Host_Template
id|driver_template
op_assign
id|NCR53C8XX
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
macro_line|#endif
eof
