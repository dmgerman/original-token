multiline_comment|/* aha152x.c -- Adaptec AHA-152x driver&n; * Author: Juergen E. Fischer, fischer@server.et-inf.fho-emden.de&n; * Copyright 1993 Juergen E. Fischer&n; *&n; *&n; * This driver is based on&n; *   fdomain.c -- Future Domain TMC-16x0 driver&n; * which is&n; *   Copyright 1992, 1993 Rickard E. Faith (faith@cs.unc.edu)&n; *&n;&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n;&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; &n; *&n; * $Id: aha152x.c,v 0.97 1993/10/09 18:53:53 root Exp $&n; *&n;&n; * $Log: aha152x.c,v $&n; * Revision 0.97  1993/10/09  18:53:53  root&n; * - DATA IN fixed. Rarely left data in the fifo.&n; *&n; * Revision 0.96  1993/10/03  00:53:59  root&n; * - minor changes on DATA IN&n; *&n; * Revision 0.95  1993/09/24  10:36:01  root&n; * - change handling of MSGI after reselection&n; * - fixed sti/cli&n; * - minor changes&n; *&n; * Revision 0.94  1993/09/18  14:08:22  root&n; * - fixed bug in multiple outstanding command code&n; * - changed detection&n; * - support for kernel command line configuration&n; * - reset corrected&n; * - changed message handling&n; *&n; * Revision 0.93  1993/09/15  20:41:19  root&n; * - fixed bugs with multiple outstanding commands&n; *&n; * Revision 0.92  1993/09/13  02:46:33  root&n; * - multiple outstanding commands work (no problems with IBM drive)&n; *&n; * Revision 0.91  1993/09/12  20:51:46  root&n; * added multiple outstanding commands&n; * (some problem with this $%&amp;? IBM device remain)&n; *&n; * Revision 0.9  1993/09/12  11:11:22  root&n; * - corrected auto-configuration&n; * - changed the auto-configuration (added some &squot;#define&squot;s)&n; * - added support for dis-/reconnection&n; *&n; * Revision 0.8  1993/09/06  23:09:39  root&n; * - added support for the drive activity light&n; * - minor changes&n; *&n; * Revision 0.7  1993/09/05  14:30:15  root&n; * - improved phase detection&n; * - now using the new snarf_region code of 0.99pl13&n; *&n; * Revision 0.6  1993/09/02  11:01:38  root&n; * first public release; added some signatures and biosparam()&n; *&n; * Revision 0.5  1993/08/30  10:23:30  root&n; * fixed timing problems with my IBM drive&n; *&n; * Revision 0.4  1993/08/29  14:06:52  root&n; * fixed some problems with timeouts due incomplete commands&n; *&n; * Revision 0.3  1993/08/28  15:55:03  root&n; * writing data works too.  mounted and worked on a dos partition&n; *&n; * Revision 0.2  1993/08/27  22:42:07  root&n; * reading data works.  Mounted a msdos partition.&n; *&n; * Revision 0.1  1993/08/25  13:38:30  root&n; * first &quot;damn thing doesn&squot;t work&quot; version&n; *&n; * Revision 0.0  1993/08/14  19:54:25  root&n; * empty function bodies; detect() works.&n; *&n;&n; **************************************************************************&n;&n;&n; &n; DESCRIPTION:&n;&n; This is the Linux low-level SCSI driver for Adaptec AHA-1520/1522&n; SCSI host adapters.&n;&n;&n; PER-DEFINE CONFIGURABLE OPTIONS:&n;&n; AUTOCONF       : use configuration the controller reports (only 152x)&n; IRQ            : override interrupt channel (9,10,11 or 12) (default 11)&n; SCSI_ID        : override scsiid of AIC-6260 (0-7) (default 7)&n; RECONNECT      : override target dis-/reconnection/multiple outstanding commands&n; SKIP_BIOSTEST  : Don&squot;t test for BIOS signature (AHA-1510 or disabled BIOS)&n; PORTBASE       : Force port base. Don&squot;t try to probe&n;&n;&n; LILO COMMAND LINE OPTIONS:&n;&n; aha152x=&lt;PORTBASE&gt;,&lt;IRQ&gt;,&lt;SCSI-ID&gt;,&lt;RECONNECT&gt;&n;&n; The normal configuration can be overridden by specifying a command line.&n; When you do this, the BIOS test is skipped. Entered values have to be&n; valid (known). Don&squot;t use values that aren&squot;t support under normal operation.&n; If you think that you need other value: contact me.&n;&n;&n; REFERENCES USED:&n;&n; &quot;AIC-6260 SCSI Chip Specification&quot;, Adaptec Corporation.&n;&n; &quot;SCSI COMPUTER SYSTEM INTERFACE - 2 (SCSI-2)&quot;, X3T9.2/86-109 rev. 10h&n;&n; &quot;Writing a SCSI device driver for Linux&quot;, Rik Faith (faith@cs.unc.edu)&n;&n; &quot;Kernel Hacker&squot;s Guide&quot;, Michael K. Johnson (johnsonm@sunsite.unc.edu)&n;&n; &quot;Adaptec 1520/1522 User&squot;s Guide&quot;, Adaptec Corporation.&n; &n; Michael K. Johnson (johnsonm@sunsite.unc.edu)&n;&n; Drew Eckhardt (drew@cs.colorado.edu)&n;&n; Eric Youngdale (eric@tantalus.nrl.navy.mil) &n;&n; special thanks to Eric Youngdale for the free(!) supplying the&n; documentation on the chip.&n;&n; **************************************************************************/
macro_line|#include &quot;aha152x.h&quot;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;../block/blk.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
multiline_comment|/* DEFINES */
multiline_comment|/* If auto configuration is disabled, IRQ, SCSI_ID and RECONNECT have to&n;   be predefined */
macro_line|#if !defined(AUTOCONF)
macro_line|#if !defined(IRQ)
macro_line|#error undefined IRQ; define AUTOCONF or IRQ
macro_line|#endif
macro_line|#if !defined(SCSI_ID)
macro_line|#error undefined SCSI_ID; define AUTOCONF or SCSI_ID
macro_line|#endif
macro_line|#if !defined(RECONNECT)
macro_line|#error undefined RECONNECT; define AUTOCONF or RECONNECT
macro_line|#endif
macro_line|#endif
multiline_comment|/* I use this when I&squot;m looking for weird bugs */
DECL|macro|DEBUG_TIMING
mdefine_line|#define DEBUG_TIMING 
macro_line|#if defined(DEBUG)
DECL|macro|SKIP_PORTS
macro_line|#undef  SKIP_PORTS              /* don&squot;t display ports */
DECL|macro|DEBUG_QUEUE
macro_line|#undef  DEBUG_QUEUE             /* debug queue() */
DECL|macro|DEBUG_RESET
macro_line|#undef  DEBUG_RESET             /* debug reset() */
DECL|macro|DEBUG_INTR
macro_line|#undef  DEBUG_INTR              /* debug intr() */
DECL|macro|DEBUG_SELECTION
macro_line|#undef  DEBUG_SELECTION         /* debug selection part in intr() */
DECL|macro|DEBUG_MSGO
macro_line|#undef  DEBUG_MSGO              /* debug message out phase in intr() */
DECL|macro|DEBUG_MSGI
macro_line|#undef  DEBUG_MSGI              /* debug message in phase in intr() */
DECL|macro|DEBUG_STATUS
macro_line|#undef  DEBUG_STATUS            /* debug status phase in intr() */
DECL|macro|DEBUG_CMD
macro_line|#undef  DEBUG_CMD               /* debug command phase in intr() */
DECL|macro|DEBUG_DATAI
macro_line|#undef  DEBUG_DATAI             /* debug data in phase in intr() */
DECL|macro|DEBUG_DATAO
macro_line|#undef  DEBUG_DATAO             /* debug data out phase in intr() */
DECL|macro|DEBUG_ABORT
macro_line|#undef  DEBUG_ABORT             /* debug abort() */
DECL|macro|DEBUG_DONE
macro_line|#undef  DEBUG_DONE              /* debug done() */
DECL|macro|DEBUG_BIOSPARAM
macro_line|#undef  DEBUG_BIOSPARAM         /* debug biosparam() */
DECL|macro|DEBUG_RACE
macro_line|#undef  DEBUG_RACE              /* debug race conditions */
DECL|macro|DEBUG_PHASES
macro_line|#undef  DEBUG_PHASES            /* debug phases (useful to trace) */
DECL|macro|DEBUG_QUEUES
macro_line|#undef  DEBUG_QUEUES            /* debug reselection */
multiline_comment|/* recently used for debugging */
macro_line|#if 0
mdefine_line|#define DEBUG_PHASES
mdefine_line|#define DEBUG_DATAI
macro_line|#endif
macro_line|#endif
DECL|macro|DEBUG_BIOSPARAM
mdefine_line|#define DEBUG_BIOSPARAM         /* warn when biosparam is invoked */
DECL|macro|DEBUG_RESET
mdefine_line|#define DEBUG_RESET             /* resets should be rare */
DECL|macro|DEBUG_ABORT
mdefine_line|#define DEBUG_ABORT             /* aborts too */
multiline_comment|/* END OF DEFINES */
DECL|variable|aha152x_id
r_char
op_star
id|aha152x_id
op_assign
l_string|&quot;Adaptec 152x SCSI driver; $Revision: 0.97 $&bslash;n&quot;
suffix:semicolon
DECL|variable|port_base
r_static
r_int
id|port_base
op_assign
l_int|0
suffix:semicolon
DECL|variable|this_host
r_static
r_int
id|this_host
op_assign
l_int|0
suffix:semicolon
DECL|variable|can_disconnect
r_static
r_int
id|can_disconnect
op_assign
l_int|0
suffix:semicolon
DECL|variable|commands
r_static
r_int
id|commands
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set by aha152x_setup according to the command line */
DECL|variable|setup_called
r_static
r_int
id|setup_called
op_assign
l_int|0
suffix:semicolon
DECL|variable|setup_portbase
r_static
r_int
id|setup_portbase
op_assign
l_int|0
suffix:semicolon
DECL|variable|setup_irq
r_static
r_int
id|setup_irq
op_assign
l_int|0
suffix:semicolon
DECL|variable|setup_scsiid
r_static
r_int
id|setup_scsiid
op_assign
l_int|0
suffix:semicolon
DECL|variable|setup_reconnect
r_static
r_int
id|setup_reconnect
op_assign
l_int|0
suffix:semicolon
DECL|variable|setup_str
r_static
r_char
op_star
id|setup_str
op_assign
(paren
r_char
op_star
)paren
l_int|NULL
suffix:semicolon
r_enum
(brace
DECL|enumerator|not_issued
id|not_issued
op_assign
l_int|0x01
comma
DECL|enumerator|in_selection
id|in_selection
op_assign
l_int|0x02
comma
DECL|enumerator|disconnected
id|disconnected
op_assign
l_int|0x04
comma
DECL|enumerator|aborted
id|aborted
op_assign
l_int|0x08
comma
DECL|enumerator|sent_ident
id|sent_ident
op_assign
l_int|0x10
comma
DECL|enumerator|in_other
id|in_other
op_assign
l_int|0x20
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Command queues:&n; * issue_SC        : commands that are queued to be issued &n; * current_SC      : command that&squot;s currently using the bus&n; * disconnected_SC : commands that that have been disconnected &n; */
DECL|variable|issue_SC
r_static
id|Scsi_Cmnd
op_star
id|issue_SC
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|current_SC
r_static
id|Scsi_Cmnd
op_star
id|current_SC
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|disconnected_SC
r_static
id|Scsi_Cmnd
op_star
id|disconnected_SC
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|abortion_complete
r_static
r_struct
id|wait_queue
op_star
id|abortion_complete
suffix:semicolon
DECL|variable|abort_result
r_static
r_int
id|abort_result
suffix:semicolon
r_void
id|aha152x_intr
c_func
(paren
r_int
id|irqno
)paren
suffix:semicolon
r_void
id|aha152x_done
c_func
(paren
r_int
id|error
)paren
suffix:semicolon
r_void
id|aha152x_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
suffix:semicolon
r_static
r_void
id|aha152x_reset_ports
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|aha152x_panic
c_func
(paren
r_char
op_star
id|msg
)paren
suffix:semicolon
r_static
r_void
id|disp_ports
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|show_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_void
id|show_queues
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|disp_enintr
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_RACE)
r_static
r_void
id|enter_driver
c_func
(paren
r_const
r_char
op_star
)paren
suffix:semicolon
r_static
r_void
id|leave_driver
c_func
(paren
r_const
r_char
op_star
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* possible locations for the Adaptec BIOS */
DECL|variable|addresses
r_static
r_void
op_star
id|addresses
(braket
)braket
op_assign
(brace
(paren
r_void
op_star
)paren
l_int|0xdc000
comma
multiline_comment|/* default first */
(paren
r_void
op_star
)paren
l_int|0xc8000
comma
(paren
r_void
op_star
)paren
l_int|0xcc000
comma
(paren
r_void
op_star
)paren
l_int|0xd0000
comma
(paren
r_void
op_star
)paren
l_int|0xd4000
comma
(paren
r_void
op_star
)paren
l_int|0xd8000
comma
(paren
r_void
op_star
)paren
l_int|0xe0000
comma
(paren
r_void
op_star
)paren
l_int|0xf0000
comma
)brace
suffix:semicolon
DECL|macro|ADDRESS_COUNT
mdefine_line|#define ADDRESS_COUNT (sizeof( addresses ) / sizeof( unsigned ))
multiline_comment|/* possible i/o adresses for the AIC-6260 */
DECL|variable|ports
r_static
r_int
r_int
id|ports
(braket
)braket
op_assign
(brace
l_int|0x340
comma
multiline_comment|/* default first */
l_int|0x140
)brace
suffix:semicolon
DECL|macro|PORT_COUNT
mdefine_line|#define PORT_COUNT (sizeof( ports ) / sizeof( unsigned short ))
multiline_comment|/* possible interrupt channels */
DECL|variable|ints
r_static
r_int
r_int
id|ints
(braket
)braket
op_assign
(brace
l_int|9
comma
l_int|10
comma
l_int|11
comma
l_int|12
)brace
suffix:semicolon
multiline_comment|/* signatures for various AIC-6260 based controllers */
DECL|struct|signature
r_static
r_struct
id|signature
(brace
DECL|member|signature
r_char
op_star
id|signature
suffix:semicolon
DECL|member|sig_offset
r_int
id|sig_offset
suffix:semicolon
DECL|member|sig_length
r_int
id|sig_length
suffix:semicolon
DECL|variable|signatures
)brace
id|signatures
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;Adaptec AHA-1520 BIOS&bslash;r&bslash;n&bslash;0&bslash;&n;Version 1.4      &bslash;r&bslash;n&bslash;0&bslash;&n;Copyright 1990 Adaptec, Inc.&bslash;r&bslash;n&bslash;&n;All Rights Reserved&bslash;r&bslash;n &bslash;r&bslash;n &bslash;r&bslash;n&quot;
comma
l_int|0x102e
comma
l_int|101
)brace
comma
multiline_comment|/* Adaptec 152x */
(brace
l_string|&quot;Adaptec ASW-B626 BIOS&bslash;r&bslash;n&bslash;0&bslash;&n;Version 1.0      &bslash;r&bslash;n&bslash;0&bslash;&n;Copyright 1990 Adaptec, Inc.&bslash;r&bslash;n&bslash;&n;All Rights Reserved&bslash;r&bslash;n&bslash;0 &bslash;r&bslash;n &bslash;r&bslash;n&quot;
comma
l_int|0x1029
comma
l_int|102
)brace
comma
multiline_comment|/* on-board controller */
(brace
l_string|&quot;Adaptec BIOS: ASW-B626&quot;
comma
l_int|0x0F
comma
l_int|22
)brace
comma
multiline_comment|/* on-board controller */
(brace
l_string|&quot;Adaptec ASW-B626 S2 BIOS&quot;
comma
l_int|0x2e6c
comma
l_int|24
)brace
comma
multiline_comment|/* on-board controller */
)brace
suffix:semicolon
DECL|macro|SIGNATURE_COUNT
mdefine_line|#define SIGNATURE_COUNT (sizeof( signatures ) / sizeof( struct signature ))
multiline_comment|/* These defines are copied from kernel/blk_drv/hd.c */
DECL|macro|insw
mdefine_line|#define insw( buf, count, port ) &bslash;&n;  __asm__ volatile &bslash;&n;  (&quot;cld;rep;insw&quot;: :&quot;d&quot; (port),&quot;D&quot; (buf),&quot;c&quot; (count):&quot;cx&quot;,&quot;di&quot; )
DECL|macro|outsw
mdefine_line|#define outsw( buf, count, port ) &bslash;&n;  __asm__ volatile &bslash;&n;  (&quot;cld;rep;outsw&quot;: :&quot;d&quot; (port),&quot;S&quot; (buf),&quot;c&quot; (count):&quot;cx&quot;,&quot;si&quot;)
DECL|function|do_pause
r_static
r_void
id|do_pause
c_func
(paren
r_int
id|amount
)paren
multiline_comment|/* Pause for amount*10 milliseconds */
(brace
r_int
r_int
id|the_time
op_assign
id|jiffies
op_plus
id|amount
suffix:semicolon
multiline_comment|/* 0.01 seconds per jiffy */
r_while
c_loop
(paren
id|jiffies
OL
id|the_time
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  queue services:&n; */
DECL|function|append_SC
r_static
r_inline
r_void
id|append_SC
c_func
(paren
id|Scsi_Cmnd
op_star
op_star
id|SC
comma
id|Scsi_Cmnd
op_star
id|new_SC
)paren
(brace
id|Scsi_Cmnd
op_star
id|end
suffix:semicolon
id|new_SC-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|SC
)paren
(brace
op_star
id|SC
op_assign
id|new_SC
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|end
op_assign
op_star
id|SC
suffix:semicolon
id|end-&gt;host_scribble
suffix:semicolon
id|end
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|end-&gt;host_scribble
)paren
(brace
suffix:semicolon
)brace
id|end-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|new_SC
suffix:semicolon
)brace
)brace
DECL|function|remove_first_SC
r_static
r_inline
id|Scsi_Cmnd
op_star
id|remove_first_SC
c_func
(paren
id|Scsi_Cmnd
op_star
op_star
id|SC
)paren
(brace
id|Scsi_Cmnd
op_star
id|ptr
suffix:semicolon
id|ptr
op_assign
op_star
id|SC
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
(brace
op_star
id|SC
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
(paren
op_star
id|SC
)paren
op_member_access_from_pointer
id|host_scribble
suffix:semicolon
)brace
r_return
id|ptr
suffix:semicolon
)brace
DECL|function|remove_SC
r_static
r_inline
id|Scsi_Cmnd
op_star
id|remove_SC
c_func
(paren
id|Scsi_Cmnd
op_star
op_star
id|SC
comma
r_int
id|target
comma
r_int
id|lun
)paren
(brace
id|Scsi_Cmnd
op_star
id|ptr
comma
op_star
id|prev
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
op_star
id|SC
comma
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|ptr
op_logical_and
(paren
(paren
id|ptr-&gt;target
op_ne
id|target
)paren
op_logical_or
(paren
id|ptr-&gt;lun
op_ne
id|lun
)paren
)paren
suffix:semicolon
id|prev
op_assign
id|ptr
comma
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr
)paren
r_if
c_cond
(paren
id|prev
)paren
(brace
id|prev-&gt;host_scribble
op_assign
id|ptr-&gt;host_scribble
suffix:semicolon
)brace
r_else
op_star
id|SC
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
suffix:semicolon
r_return
id|ptr
suffix:semicolon
)brace
multiline_comment|/*&n; * read inbound byte and wait for ACK to get low&n; */
DECL|function|make_acklow
r_static
r_void
id|make_acklow
c_func
(paren
r_void
)paren
(brace
id|SETPORT
c_func
(paren
id|SXFRCTL0
comma
id|CH1
op_or
id|SPIOEN
)paren
suffix:semicolon
id|GETPORT
c_func
(paren
id|SCSIDAT
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SXFRCTL0
comma
id|CH1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|TESTHI
c_func
(paren
id|SCSISIG
comma
id|ACKI
)paren
)paren
(brace
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * detect current phase more reliable:&n; * phase is valid, when the target asserts REQ after we&squot;ve deasserted ACK.&n; *&n; * return value is a valid phase or an error code.&n; *&n; * errorcodes:&n; *   1 BUS FREE phase detected&n; *   2 RESET IN detected&n; *   3 parity error in DATA phase&n; */
DECL|function|getphase
r_static
r_int
id|getphase
c_func
(paren
r_void
)paren
(brace
r_int
id|phase
comma
id|sstat1
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_do
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|sstat1
op_assign
id|GETPORT
c_func
(paren
id|SSTAT1
)paren
)paren
op_amp
(paren
id|BUSFREE
op_or
id|SCSIRSTI
op_or
id|REQINIT
)paren
)paren
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sstat1
op_amp
id|BUSFREE
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sstat1
op_amp
id|SCSIRSTI
)paren
(brace
multiline_comment|/* IBM drive responds with RSTI to RSTO */
id|printk
c_func
(paren
l_string|&quot;aha152x: RESET IN&bslash;n&quot;
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SSTAT1
comma
id|SCSIRSTI
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|TESTHI
c_func
(paren
id|SCSISIG
comma
id|ACKI
)paren
op_logical_or
id|TESTLO
c_func
(paren
id|SSTAT1
comma
id|REQINIT
)paren
)paren
(brace
suffix:semicolon
)brace
id|SETPORT
c_func
(paren
id|SSTAT1
comma
id|CLRSCSIPERR
)paren
suffix:semicolon
id|phase
op_assign
id|GETPORT
c_func
(paren
id|SCSISIG
)paren
op_amp
id|P_MASK
suffix:semicolon
r_if
c_cond
(paren
id|TESTHI
c_func
(paren
id|SSTAT1
comma
id|SCSIPERR
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|phase
op_amp
(paren
id|CDO
op_or
id|MSGO
)paren
)paren
op_eq
l_int|0
)paren
multiline_comment|/* DATA phase */
(brace
r_return
l_int|3
suffix:semicolon
)brace
id|SETPORT
c_func
(paren
id|SCSISIG
comma
id|phase
)paren
suffix:semicolon
id|make_acklow
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|SETPORT
c_func
(paren
id|SCSISIG
comma
id|phase
)paren
suffix:semicolon
r_return
id|phase
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* called from init/main.c */
DECL|function|aha152x_setup
r_void
id|aha152x_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_if
c_cond
(paren
id|setup_called
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;aha152x: aha152x_setup called twice.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|setup_called
op_assign
id|ints
(braket
l_int|0
)braket
suffix:semicolon
id|setup_str
op_assign
id|str
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ne
l_int|4
)paren
(brace
r_return
suffix:semicolon
)brace
id|setup_portbase
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
id|setup_irq
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
id|setup_scsiid
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
id|setup_reconnect
op_assign
id|ints
(braket
l_int|4
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;   Test, if port_base is valid.&n; */
DECL|function|aha152x_porttest
r_static
r_int
id|aha152x_porttest
c_func
(paren
r_int
id|port_base
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|port_base
comma
id|TEST
op_minus
id|SCSISEQ
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|SETPORT
c_func
(paren
id|DMACNTRL1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset stack pointer */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|SETPORT
c_func
(paren
id|STACK
comma
id|i
)paren
suffix:semicolon
)brace
id|SETPORT
c_func
(paren
id|DMACNTRL1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset stack pointer */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
op_logical_and
id|GETPORT
c_func
(paren
id|STACK
)paren
op_eq
id|i
suffix:semicolon
id|i
op_increment
)paren
(brace
suffix:semicolon
)brace
r_return
id|i
op_eq
l_int|16
suffix:semicolon
)brace
DECL|function|aha152x_detect
r_int
id|aha152x_detect
c_func
(paren
r_int
id|hostno
)paren
(brace
r_int
id|i
comma
id|j
comma
id|ok
suffix:semicolon
id|aha152x_config
id|conf
suffix:semicolon
r_struct
id|sigaction
id|sa
suffix:semicolon
r_int
id|interrupt_level
suffix:semicolon
macro_line|#if defined(DEBUG_RACE)
id|enter_driver
c_func
(paren
l_string|&quot;detect&quot;
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;aha152x: Probing: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|setup_called
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;processing commandline: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|setup_called
op_ne
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;naha152x: %s&bslash;n&quot;
comma
id|setup_str
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aha152x: usage: aha152x=&lt;PORTBASE&gt;,&lt;IRQ&gt;,&lt;SCSI ID&gt;,&lt;RECONNECT&gt;&bslash;n&quot;
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;aha152x panics in line %d&quot;
comma
id|__LINE__
)paren
suffix:semicolon
)brace
id|port_base
op_assign
id|setup_portbase
suffix:semicolon
id|interrupt_level
op_assign
id|setup_irq
suffix:semicolon
id|this_host
op_assign
id|setup_scsiid
suffix:semicolon
id|can_disconnect
op_assign
id|setup_reconnect
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PORT_COUNT
op_logical_and
(paren
id|port_base
op_ne
id|ports
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|PORT_COUNT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;unknown portbase 0x%03x&bslash;n&quot;
comma
id|port_base
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;aha152x panics in line %d&quot;
comma
id|__LINE__
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|aha152x_porttest
c_func
(paren
id|port_base
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;portbase 0x%03x fails probe&bslash;n&quot;
comma
id|port_base
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;aha152x panics in line %d&quot;
comma
id|__LINE__
)paren
suffix:semicolon
)brace
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|ints
(braket
id|i
)braket
op_logical_and
(paren
id|interrupt_level
op_ne
id|ints
(braket
id|i
)braket
)paren
)paren
(brace
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ints
(braket
id|i
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;illegal IRQ %d&bslash;n&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;aha152x panics in line %d&quot;
comma
id|__LINE__
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|this_host
OL
l_int|0
)paren
op_logical_or
(paren
id|this_host
OG
l_int|7
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;illegal SCSI ID %d&bslash;n&quot;
comma
id|this_host
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;aha152x panics in line %d&quot;
comma
id|__LINE__
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|can_disconnect
OL
l_int|0
)paren
op_logical_or
(paren
id|can_disconnect
OG
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;reconnect %d should be 0 or 1&bslash;n&quot;
comma
id|can_disconnect
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;aha152x panics in line %d&quot;
comma
id|__LINE__
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;ok, &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if !defined(SKIP_BIOSTEST)
id|printk
c_func
(paren
l_string|&quot;BIOS test: &quot;
)paren
suffix:semicolon
id|ok
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ADDRESS_COUNT
op_logical_and
op_logical_neg
id|ok
suffix:semicolon
id|i
op_increment
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
(paren
id|j
OL
id|SIGNATURE_COUNT
)paren
op_logical_and
op_logical_neg
id|ok
suffix:semicolon
id|j
op_increment
)paren
(brace
id|ok
op_assign
op_logical_neg
id|memcmp
c_func
(paren
(paren
r_void
op_star
)paren
id|addresses
(braket
id|i
)braket
op_plus
id|signatures
(braket
id|j
)braket
dot
id|sig_offset
comma
(paren
r_void
op_star
)paren
id|signatures
(braket
id|j
)braket
dot
id|signature
comma
(paren
r_int
)paren
id|signatures
(braket
id|j
)braket
dot
id|sig_length
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ok
)paren
(brace
macro_line|#if defined(DEBUG_RACE)
id|leave_driver
c_func
(paren
l_string|&quot;(1) detect&quot;
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;ok, &quot;
)paren
suffix:semicolon
macro_line|#endif /* !SKIP_BIOSTEST */
macro_line|#if !defined(PORTBASE)
id|printk
c_func
(paren
l_string|&quot;porttest: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PORT_COUNT
op_logical_and
op_logical_neg
id|aha152x_porttest
c_func
(paren
id|ports
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|PORT_COUNT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_RACE)
id|leave_driver
c_func
(paren
l_string|&quot;(2) detect&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_else
id|port_base
op_assign
id|ports
(braket
id|i
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ok, &quot;
)paren
suffix:semicolon
macro_line|#else
id|port_base
op_assign
id|PORTBASE
suffix:semicolon
macro_line|#endif /* !PORTBASE */
macro_line|#if defined(AUTOCONF)
id|conf.cf_port
op_assign
(paren
id|GETPORT
c_func
(paren
id|PORTA
)paren
op_lshift
l_int|8
)paren
op_plus
id|GETPORT
c_func
(paren
id|PORTB
)paren
suffix:semicolon
id|interrupt_level
op_assign
id|ints
(braket
id|conf.cf_irq
)braket
suffix:semicolon
id|this_host
op_assign
id|conf.cf_id
suffix:semicolon
id|can_disconnect
op_assign
id|conf.cf_tardisc
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;auto configuration: ok, &quot;
)paren
suffix:semicolon
macro_line|#endif /* AUTOCONF */
macro_line|#if defined(IRQ)
id|interrupt_level
op_assign
id|IRQ
suffix:semicolon
macro_line|#endif
macro_line|#if defined(SCSI_ID)
id|this_host
op_assign
id|SCSI_ID
suffix:semicolon
macro_line|#endif
macro_line|#if defined(RECONNECT)
id|can_disconnect
op_assign
id|RECONNECT
suffix:semicolon
macro_line|#endif
)brace
id|printk
c_func
(paren
l_string|&quot;detection complete&bslash;n&quot;
)paren
suffix:semicolon
id|sa.sa_handler
op_assign
id|aha152x_intr
suffix:semicolon
id|sa.sa_flags
op_assign
id|SA_INTERRUPT
suffix:semicolon
id|sa.sa_mask
op_assign
l_int|0
suffix:semicolon
id|sa.sa_restorer
op_assign
l_int|NULL
suffix:semicolon
id|ok
op_assign
id|irqaction
c_func
(paren
id|interrupt_level
comma
op_amp
id|sa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ok
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ok
op_eq
op_minus
id|EINVAL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aha152x: bad IRQ %d.&bslash;n&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;         Contact author.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ok
op_eq
op_minus
id|EBUSY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aha152x: IRQ %d already in use. Configure another.&bslash;n&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;naha152x: Unexpected error code on requesting IRQ %d.&bslash;n&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;         Contact author.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|panic
c_func
(paren
l_string|&quot;aha152x: driver needs an IRQ.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|SETPORT
c_func
(paren
id|SCSIID
comma
id|this_host
op_lshift
l_int|4
)paren
suffix:semicolon
id|scsi_hosts
(braket
id|hostno
)braket
dot
id|this_id
op_assign
id|this_host
suffix:semicolon
r_if
c_cond
(paren
id|can_disconnect
)paren
(brace
id|scsi_hosts
(braket
id|hostno
)braket
dot
id|can_queue
op_assign
id|AHA152X_MAXQUEUE
suffix:semicolon
)brace
multiline_comment|/* RESET OUT */
id|SETBITS
c_func
(paren
id|SCSISEQ
comma
id|SCSIRSTO
)paren
suffix:semicolon
id|do_pause
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|CLRBITS
c_func
(paren
id|SCSISEQ
comma
id|SCSIRSTO
)paren
suffix:semicolon
id|aha152x_reset
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aha152x: vital data: PORTBASE=0x%03x, IRQ=%d, SCSI ID=%d, reconnect=%s, parity=enabled&bslash;n&quot;
comma
id|port_base
comma
id|interrupt_level
comma
id|this_host
comma
id|can_disconnect
ques
c_cond
l_string|&quot;enabled&quot;
suffix:colon
l_string|&quot;disabled&quot;
)paren
suffix:semicolon
id|snarf_region
c_func
(paren
id|port_base
comma
id|TEST
op_minus
id|SCSISEQ
)paren
suffix:semicolon
multiline_comment|/* Register */
multiline_comment|/* not expecting any interrupts */
id|SETPORT
c_func
(paren
id|SIMODE0
comma
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_RACE)
id|leave_driver
c_func
(paren
l_string|&quot;(3) detect&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SETBITS
c_func
(paren
id|DMACNTRL0
comma
id|INTEN
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *  return the name of the thing&n; */
DECL|function|aha152x_info
r_const
r_char
op_star
id|aha152x_info
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined(DEBUG_RACE)
id|enter_driver
c_func
(paren
l_string|&quot;info&quot;
)paren
suffix:semicolon
id|leave_driver
c_func
(paren
l_string|&quot;info&quot;
)paren
suffix:semicolon
macro_line|#else
macro_line|#if defined(DEBUG_INFO)
id|printk
c_func
(paren
l_string|&quot;&bslash;naha152x: info()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
r_return
id|aha152x_id
suffix:semicolon
)brace
multiline_comment|/* &n; *  Queue a command and setup interrupts for a free bus.&n; */
DECL|function|aha152x_queue
r_int
id|aha152x_queue
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
macro_line|#if defined(DEBUG_RACE)
id|enter_driver
c_func
(paren
l_string|&quot;queue&quot;
)paren
suffix:semicolon
macro_line|#else
macro_line|#if defined(DEBUG_QUEUE)
id|printk
c_func
(paren
l_string|&quot;aha152x: queue(), &quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
macro_line|#if defined(DEBUG_QUEUE)
id|printk
c_func
(paren
l_string|&quot;SCpnt (target = %d lun = %d cmnd = 0x%02x pieces = %d size = %u), &quot;
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
op_star
(paren
r_int
r_char
op_star
)paren
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;use_sg
comma
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
id|disp_ports
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Turn led on, when this is the first command. */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|commands
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|commands
op_eq
l_int|1
)paren
(brace
id|SETPORT
c_func
(paren
id|PORTA
comma
l_int|1
)paren
suffix:semicolon
)brace
id|SCpnt-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|SCpnt-&gt;SCp.phase
op_assign
id|not_issued
suffix:semicolon
macro_line|#if defined(DEBUG_QUEUES)
id|printk
c_func
(paren
l_string|&quot;i+ (%d), &quot;
comma
id|commands
)paren
suffix:semicolon
macro_line|#endif
id|append_SC
c_func
(paren
op_amp
id|issue_SC
comma
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/* Enable bus free interrupt, when we aren&squot;t currently on the bus */
r_if
c_cond
(paren
op_logical_neg
id|current_SC
)paren
(brace
id|SETPORT
c_func
(paren
id|SIMODE0
comma
id|disconnected_SC
ques
c_cond
id|ENSELDI
suffix:colon
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
id|issue_SC
ques
c_cond
id|ENBUSFREE
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  We only support command in interrupt-driven fashion&n; */
DECL|function|aha152x_command
r_int
id|aha152x_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aha152x: interrupt driven driver; use aha152x_queue()&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *  Abort a queued command&n; *  (commands that are on the bus can&squot;t be aborted easily)&n; */
DECL|function|aha152x_abort
r_int
id|aha152x_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|code
)paren
(brace
id|Scsi_Cmnd
op_star
id|ptr
comma
op_star
id|prev
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_ABORT)
id|printk
c_func
(paren
l_string|&quot;aha152x: abort(), SCpnt=0x%08x, &quot;
comma
(paren
r_int
r_int
)paren
id|SCpnt
)paren
suffix:semicolon
macro_line|#endif
id|show_queues
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* look for command in issue queue */
r_for
c_loop
(paren
id|ptr
op_assign
id|issue_SC
comma
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|ptr
op_logical_and
id|ptr
op_ne
id|SCpnt
suffix:semicolon
id|prev
op_assign
id|ptr
comma
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr
)paren
(brace
multiline_comment|/* dequeue */
r_if
c_cond
(paren
id|prev
)paren
(brace
id|prev-&gt;host_scribble
op_assign
id|ptr-&gt;host_scribble
suffix:semicolon
)brace
r_else
id|issue_SC
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|ptr-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|ptr-&gt;result
op_assign
(paren
id|code
ques
c_cond
id|code
suffix:colon
id|DID_ABORT
)paren
op_lshift
l_int|16
suffix:semicolon
id|ptr
op_member_access_from_pointer
id|done
c_func
(paren
id|ptr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Fail abortion, if we&squot;re on the bus */
r_if
c_cond
(paren
id|current_SC
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* look for command in disconnected queue */
r_for
c_loop
(paren
id|ptr
op_assign
id|disconnected_SC
comma
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|ptr
op_logical_and
id|ptr
op_ne
id|SCpnt
suffix:semicolon
id|prev
op_assign
id|ptr
comma
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr
op_logical_and
id|TESTLO
c_func
(paren
id|SSTAT1
comma
id|BUSFREE
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bus busy but no current command, &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr
op_logical_and
id|TESTHI
c_func
(paren
id|SSTAT1
comma
id|BUSFREE
)paren
)paren
(brace
multiline_comment|/* dequeue */
r_if
c_cond
(paren
id|prev
)paren
(brace
id|prev-&gt;host_scribble
op_assign
id|ptr-&gt;host_scribble
suffix:semicolon
)brace
r_else
id|issue_SC
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
suffix:semicolon
multiline_comment|/* set command current and initiate selection,&n;         let the interrupt routine take care of the abortion */
id|current_SC
op_assign
id|ptr
suffix:semicolon
id|ptr-&gt;SCp.phase
op_assign
id|in_selection
op_or
id|aborted
suffix:semicolon
id|SETPORT
c_func
(paren
id|SCSIID
comma
(paren
id|this_host
op_lshift
id|OID_
)paren
op_or
id|current_SC-&gt;target
)paren
suffix:semicolon
multiline_comment|/* enable interrupts for SELECTION OUT DONE and SELECTION TIME OUT */
id|SETPORT
c_func
(paren
id|SIMODE0
comma
id|ENSELDO
op_or
(paren
id|disconnected_SC
ques
c_cond
id|ENSELDI
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
id|ENSELTIMO
)paren
suffix:semicolon
multiline_comment|/* Enable SELECTION OUT sequence */
id|SETBITS
c_func
(paren
id|SCSISEQ
comma
id|ENSELO
op_or
id|ENAUTOATNO
)paren
suffix:semicolon
id|SETBITS
c_func
(paren
id|DMACNTRL0
comma
id|INTEN
)paren
suffix:semicolon
id|abort_result
op_assign
l_int|0
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* sleep until the abortion is complete */
id|sleep_on
c_func
(paren
op_amp
id|abortion_complete
)paren
suffix:semicolon
r_return
id|abort_result
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;aha152x: bus busy but no current command&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* command wasn&squot;t found */
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Restore default values to the AIC-6260 registers and reset the fifos&n; */
DECL|function|aha152x_reset_ports
r_static
r_void
id|aha152x_reset_ports
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* disable interrupts */
id|SETPORT
c_func
(paren
id|DMACNTRL0
comma
id|RSTFIFO
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SCSISEQ
comma
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SXFRCTL1
comma
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SCSISIG
comma
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SCSIRATE
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* clear all interrupt conditions */
id|SETPORT
c_func
(paren
id|SSTAT0
comma
l_int|0x7f
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SSTAT1
comma
l_int|0xef
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SSTAT4
comma
id|SYNCERR
op_or
id|FWERR
op_or
id|FRERR
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|DMACNTRL0
comma
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|DMACNTRL1
comma
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|BRSTCNTRL
comma
l_int|0xf1
)paren
suffix:semicolon
multiline_comment|/* clear channel 0 and transfer count */
id|SETPORT
c_func
(paren
id|SXFRCTL0
comma
id|CH1
op_or
id|CLRCH1
op_or
id|CLRSTCNT
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SXFRCTL0
comma
id|CH1
)paren
suffix:semicolon
multiline_comment|/* enable interrupts */
id|SETPORT
c_func
(paren
id|SIMODE0
comma
id|disconnected_SC
ques
c_cond
id|ENSELDI
suffix:colon
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
id|issue_SC
ques
c_cond
id|ENBUSFREE
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Reset registers, reset a hanging bus and&n; *  kill active and disconnected commands&n; */
DECL|function|aha152x_reset
r_int
id|aha152x_reset
c_func
(paren
r_void
)paren
(brace
id|Scsi_Cmnd
op_star
id|ptr
suffix:semicolon
id|aha152x_reset_ports
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Reset, if bus hangs */
r_if
c_cond
(paren
id|TESTLO
c_func
(paren
id|SSTAT1
comma
id|BUSFREE
)paren
)paren
(brace
id|CLRBITS
c_func
(paren
id|DMACNTRL0
comma
id|INTEN
)paren
suffix:semicolon
macro_line|#if defined( DEBUG_RESET )
id|printk
c_func
(paren
l_string|&quot;aha152x: reset(), bus not free: SCSI RESET OUT&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|show_queues
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_SC
)paren
(brace
id|current_SC-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|current_SC-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|current_SC
op_member_access_from_pointer
id|done
c_func
(paren
id|current_SC
)paren
suffix:semicolon
id|current_SC
op_assign
l_int|NULL
suffix:semicolon
)brace
r_while
c_loop
(paren
id|disconnected_SC
)paren
(brace
id|ptr
op_assign
id|disconnected_SC
suffix:semicolon
id|disconnected_SC
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
suffix:semicolon
id|ptr-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|ptr-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|ptr
op_member_access_from_pointer
id|done
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
multiline_comment|/* RESET OUT */
id|SETPORT
c_func
(paren
id|SCSISEQ
comma
id|SCSIRSTO
)paren
suffix:semicolon
id|do_pause
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SCSISEQ
comma
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE0
comma
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
id|issue_SC
ques
c_cond
id|ENBUSFREE
suffix:colon
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|DMACNTRL0
comma
id|INTEN
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the &quot;logical geometry&quot;&n; */
DECL|function|aha152x_biosparam
r_int
id|aha152x_biosparam
c_func
(paren
r_int
id|size
comma
r_int
id|dev
comma
r_int
op_star
id|info_array
)paren
(brace
macro_line|#if defined(DEBUG_RACE)
id|enter_driver
c_func
(paren
l_string|&quot;biosparam&quot;
)paren
suffix:semicolon
macro_line|#else
macro_line|#if defined(DEBUG_BIOSPARAM)
id|printk
c_func
(paren
l_string|&quot;&bslash;naha152x: biosparam(), &quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
macro_line|#if defined(DEBUG_BIOSPARAM)
id|printk
c_func
(paren
l_string|&quot;dev=%x, size=%d, &quot;
comma
id|dev
comma
id|size
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* I took this from other SCSI drivers, since it provides&n;   the correct data for my devices. */
id|info_array
(braket
l_int|0
)braket
op_assign
l_int|64
suffix:semicolon
id|info_array
(braket
l_int|1
)braket
op_assign
l_int|32
suffix:semicolon
id|info_array
(braket
l_int|2
)braket
op_assign
id|size
op_rshift
l_int|11
suffix:semicolon
macro_line|#if defined(DEBUG_BIOSPARAM)
id|printk
c_func
(paren
l_string|&quot;bios geometry: head=%d, sec=%d, cyl=%d&bslash;n&quot;
comma
id|info_array
(braket
l_int|0
)braket
comma
id|info_array
(braket
l_int|1
)braket
comma
id|info_array
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;WARNING: check, if the bios geometry is correct.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(DEBUG_RACE)
id|leave_driver
c_func
(paren
l_string|&quot;biosparam&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Internal done function&n; */
DECL|function|aha152x_done
r_void
id|aha152x_done
c_func
(paren
r_int
id|error
)paren
(brace
id|Scsi_Cmnd
op_star
id|done_SC
suffix:semicolon
macro_line|#if defined(DEBUG_DONE)
id|printk
c_func
(paren
l_string|&quot;&bslash;naha152x: done(), &quot;
)paren
suffix:semicolon
id|disp_ports
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|current_SC
)paren
(brace
macro_line|#if defined(DEBUG_DONE)
id|printk
c_func
(paren
l_string|&quot;done(%x), &quot;
comma
id|error
)paren
suffix:semicolon
macro_line|#endif
id|cli
c_func
(paren
)paren
suffix:semicolon
id|done_SC
op_assign
id|current_SC
suffix:semicolon
id|current_SC
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* turn led off, when no commands are in the driver */
id|commands
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commands
)paren
(brace
id|SETPORT
c_func
(paren
id|PORTA
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* turn led off */
macro_line|#if defined(DEBUG_QUEUES)
id|printk
c_func
(paren
l_string|&quot;ok (%d), &quot;
comma
id|commands
)paren
suffix:semicolon
macro_line|#endif
id|sti
c_func
(paren
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE0
comma
id|disconnected_SC
ques
c_cond
id|ENSELDI
suffix:colon
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
id|issue_SC
ques
c_cond
id|ENBUSFREE
suffix:colon
l_int|0
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_PHASES)
id|printk
c_func
(paren
l_string|&quot;BUS FREE loop, &quot;
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|TESTLO
c_func
(paren
id|SSTAT1
comma
id|BUSFREE
)paren
)paren
(brace
suffix:semicolon
)brace
macro_line|#if defined(DEBUG_PHASES)
id|printk
c_func
(paren
l_string|&quot;BUS FREE&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|done_SC-&gt;result
op_assign
id|error
suffix:semicolon
r_if
c_cond
(paren
id|done_SC-&gt;scsi_done
)paren
(brace
macro_line|#if defined(DEBUG_DONE)
id|printk
c_func
(paren
l_string|&quot;calling scsi_done, &quot;
)paren
suffix:semicolon
macro_line|#endif
id|done_SC
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|done_SC
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_DONE)
id|printk
c_func
(paren
l_string|&quot;done returned, &quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
id|panic
c_func
(paren
l_string|&quot;aha152x: current_SC-&gt;scsi_done() == NULL&quot;
)paren
suffix:semicolon
)brace
r_else
id|aha152x_panic
c_func
(paren
l_string|&quot;done() called outside of command&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Interrupts handler (main routine of the driver)&n; */
DECL|function|aha152x_intr
r_void
id|aha152x_intr
c_func
(paren
r_int
id|irqno
)paren
(brace
r_int
id|done
op_assign
l_int|0
comma
id|phase
suffix:semicolon
macro_line|#if defined(DEBUG_RACE)
id|enter_driver
c_func
(paren
l_string|&quot;intr&quot;
)paren
suffix:semicolon
macro_line|#else
macro_line|#if defined(DEBUG_INTR)
id|printk
c_func
(paren
l_string|&quot;&bslash;naha152x: intr(), &quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/* no more interrupts from the controller, while we busy.&n;     INTEN has to be restored, when we&squot;re ready to leave&n;     intr(). To avoid race conditions we have to return&n;     immediately afterwards. */
id|CLRBITS
c_func
(paren
id|DMACNTRL0
comma
id|INTEN
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* disconnected target is trying to reconnect.&n;     Only possible, if we have disconnected nexuses and&n;     nothing is occuping the bus.&n;  */
r_if
c_cond
(paren
id|TESTHI
c_func
(paren
id|SSTAT0
comma
id|SELDI
)paren
op_logical_and
id|disconnected_SC
op_logical_and
(paren
op_logical_neg
id|current_SC
op_logical_or
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|in_selection
)paren
)paren
)paren
(brace
r_int
id|identify_msg
comma
id|target
comma
id|i
suffix:semicolon
multiline_comment|/* Avoid conflicts when a target reconnects&n;         while we are trying to connect to another. */
r_if
c_cond
(paren
id|current_SC
)paren
(brace
macro_line|#if defined(DEBUG_QUEUES)
id|printk
c_func
(paren
l_string|&quot;i+, &quot;
)paren
suffix:semicolon
macro_line|#endif
id|cli
c_func
(paren
)paren
suffix:semicolon
id|append_SC
c_func
(paren
op_amp
id|issue_SC
comma
id|current_SC
)paren
suffix:semicolon
id|current_SC
op_assign
l_int|NULL
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* disable sequences */
id|SETPORT
c_func
(paren
id|SCSISEQ
comma
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SSTAT0
comma
id|CLRSELDI
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SSTAT1
comma
id|CLRBUSFREE
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_QUEUES) || defined(DEBUG_PHASES)
id|printk
c_func
(paren
l_string|&quot;reselected, &quot;
)paren
suffix:semicolon
macro_line|#endif
id|i
op_assign
id|GETPORT
c_func
(paren
id|SELID
)paren
op_amp
op_complement
(paren
l_int|1
op_lshift
id|this_host
)paren
suffix:semicolon
id|target
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_for
c_loop
(paren
suffix:semicolon
(paren
id|i
op_amp
l_int|1
)paren
op_eq
l_int|0
suffix:semicolon
id|target
op_increment
comma
id|i
op_rshift_assign
l_int|1
)paren
(brace
suffix:semicolon
)brace
r_else
id|aha152x_panic
c_func
(paren
l_string|&quot;reconnecting target unknown&quot;
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_QUEUES)
id|printk
c_func
(paren
l_string|&quot;SELID=%02x, target=%d, &quot;
comma
id|GETPORT
c_func
(paren
id|SELID
)paren
comma
id|target
)paren
suffix:semicolon
macro_line|#endif
id|SETPORT
c_func
(paren
id|SCSIID
comma
(paren
id|this_host
op_lshift
id|OID_
)paren
op_or
id|target
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SCSISEQ
comma
id|ENRESELI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TESTLO
c_func
(paren
id|SSTAT0
comma
id|SELDI
)paren
)paren
(brace
id|aha152x_panic
c_func
(paren
l_string|&quot;RESELI failed&quot;
)paren
suffix:semicolon
)brace
id|SETPORT
c_func
(paren
id|SCSISIG
comma
id|P_MSGI
)paren
suffix:semicolon
multiline_comment|/* Get identify message */
r_if
c_cond
(paren
(paren
id|i
op_assign
id|getphase
c_func
(paren
)paren
)paren
op_ne
id|P_MSGI
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;target doesn&squot;t enter MSGI to identify (phase=%02x)&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|aha152x_panic
c_func
(paren
l_string|&quot;unknown lun&quot;
)paren
suffix:semicolon
)brace
id|SETPORT
c_func
(paren
id|SCSISEQ
comma
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SXFRCTL0
comma
id|CH1
)paren
suffix:semicolon
id|identify_msg
op_assign
id|GETPORT
c_func
(paren
id|SCSIBUS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|identify_msg
op_amp
id|IDENTIFY_BASE
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;target=%d, inbound message (%02x) != IDENTIFY&bslash;n&quot;
comma
id|target
comma
id|identify_msg
)paren
suffix:semicolon
id|aha152x_panic
c_func
(paren
l_string|&quot;unknown lun&quot;
)paren
suffix:semicolon
)brace
id|make_acklow
c_func
(paren
)paren
suffix:semicolon
id|getphase
c_func
(paren
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SCSISIG
comma
id|P_MSGI
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_QUEUES)
id|printk
c_func
(paren
l_string|&quot;identify=%02x, lun=%d, &quot;
comma
id|identify_msg
comma
id|identify_msg
op_amp
l_int|0x3f
)paren
suffix:semicolon
macro_line|#endif
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_QUEUES)
id|printk
c_func
(paren
l_string|&quot;d-, &quot;
)paren
suffix:semicolon
macro_line|#endif
id|current_SC
op_assign
id|remove_SC
c_func
(paren
op_amp
id|disconnected_SC
comma
id|target
comma
id|identify_msg
op_amp
l_int|0x3f
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|current_SC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;lun=%d, &quot;
comma
id|identify_msg
op_amp
l_int|0x3f
)paren
suffix:semicolon
id|aha152x_panic
c_func
(paren
l_string|&quot;no disconnected command for that lun&quot;
)paren
suffix:semicolon
)brace
id|current_SC-&gt;SCp.phase
op_and_assign
op_complement
id|disconnected
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE0
comma
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
id|ENPHASEMIS
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_RACE)
id|leave_driver
c_func
(paren
l_string|&quot;(reselected) intr&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SETBITS
c_func
(paren
id|DMACNTRL0
comma
id|INTEN
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check, if we aren&squot;t busy with a command */
r_if
c_cond
(paren
op_logical_neg
id|current_SC
)paren
(brace
multiline_comment|/* bus is free to issue a queued command */
r_if
c_cond
(paren
id|TESTHI
c_func
(paren
id|SSTAT1
comma
id|BUSFREE
)paren
op_logical_and
id|issue_SC
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_QUEUES)
id|printk
c_func
(paren
l_string|&quot;i-, &quot;
)paren
suffix:semicolon
macro_line|#endif
id|current_SC
op_assign
id|remove_first_SC
c_func
(paren
op_amp
id|issue_SC
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_INTR) || defined(DEBUG_SELECTION) || defined(DEBUG_PHASES)
id|printk
c_func
(paren
l_string|&quot;issuing command, &quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* setup SCSI pointers&n;             SCp.ptr              : buffer pointer&n;             SCp.this_residual    : buffer length&n;             SCp.buffer           : next buffer&n;             SCp.buffers_residual : left buffers in list */
r_if
c_cond
(paren
id|current_SC-&gt;use_sg
)paren
(brace
id|current_SC-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|current_SC-&gt;request_buffer
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|current_SC-&gt;SCp.buffers_residual
op_assign
id|current_SC-&gt;use_sg
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|current_SC-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|current_SC-&gt;request_buffer
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;request_bufflen
suffix:semicolon
id|current_SC-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|current_SC-&gt;SCp.buffers_residual
op_assign
l_int|0
suffix:semicolon
)brace
id|current_SC-&gt;SCp.Status
op_assign
id|CHECK_CONDITION
suffix:semicolon
id|current_SC-&gt;SCp.Message
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.have_data_in
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.sent_command
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.phase
op_assign
id|in_selection
suffix:semicolon
macro_line|#if defined(DEBUG_INTR) || defined(DEBUG_SELECTION) || defined(DEBUG_PHASES)
id|printk
c_func
(paren
l_string|&quot;selecting %d, &quot;
comma
id|current_SC-&gt;target
)paren
suffix:semicolon
macro_line|#endif
id|SETPORT
c_func
(paren
id|SCSIID
comma
(paren
id|this_host
op_lshift
id|OID_
)paren
op_or
id|current_SC-&gt;target
)paren
suffix:semicolon
multiline_comment|/* Enable interrupts for SELECTION OUT DONE and SELECTION OUT INITIATED */
id|SETPORT
c_func
(paren
id|SXFRCTL1
comma
id|ENSPCHK
op_or
id|ENSTIMER
)paren
suffix:semicolon
multiline_comment|/* enable interrupts for SELECTION OUT DONE and SELECTION TIME OUT */
id|SETPORT
c_func
(paren
id|SIMODE0
comma
id|ENSELDO
op_or
(paren
id|disconnected_SC
ques
c_cond
id|ENSELDI
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
id|ENSELTIMO
)paren
suffix:semicolon
multiline_comment|/* Enable SELECTION OUT sequence */
id|SETBITS
c_func
(paren
id|SCSISEQ
comma
id|ENSELO
op_or
id|ENAUTOATNO
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_RACE)
id|leave_driver
c_func
(paren
l_string|&quot;(selecting) intr&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SETBITS
c_func
(paren
id|DMACNTRL0
comma
id|INTEN
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* No command we are busy with and no new to issue */
id|printk
c_func
(paren
l_string|&quot;aha152x: ignoring spurious interrupt, nothing to do&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* the bus is busy with something */
macro_line|#if defined(DEBUG_INTR)
id|disp_ports
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* we are waiting for the result of a selection attempt */
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|in_selection
)paren
(brace
r_if
c_cond
(paren
id|TESTLO
c_func
(paren
id|SSTAT1
comma
id|SELTO
)paren
)paren
multiline_comment|/* no timeout */
r_if
c_cond
(paren
id|TESTHI
c_func
(paren
id|SSTAT0
comma
id|SELDO
)paren
)paren
(brace
multiline_comment|/* clear BUS FREE interrupt */
id|SETPORT
c_func
(paren
id|SSTAT1
comma
id|CLRBUSFREE
)paren
suffix:semicolon
multiline_comment|/* Disable SELECTION OUT sequence */
id|CLRBITS
c_func
(paren
id|SCSISEQ
comma
id|ENSELO
op_or
id|ENAUTOATNO
)paren
suffix:semicolon
multiline_comment|/* Disable SELECTION OUT DONE interrupt */
id|CLRBITS
c_func
(paren
id|SIMODE0
comma
id|ENSELDO
)paren
suffix:semicolon
id|CLRBITS
c_func
(paren
id|SIMODE1
comma
id|ENSELTIMO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TESTLO
c_func
(paren
id|SSTAT0
comma
id|SELDO
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aha152x: passing bus free condition&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_RACE)
id|leave_driver
c_func
(paren
l_string|&quot;(passing bus free) intr&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SETBITS
c_func
(paren
id|DMACNTRL0
comma
id|INTEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|aborted
)paren
(brace
id|abort_result
op_assign
l_int|1
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|abortion_complete
)paren
suffix:semicolon
)brace
id|aha152x_done
c_func
(paren
id|DID_NO_CONNECT
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if defined(DEBUG_SELECTION) || defined(DEBUG_PHASES)
id|printk
c_func
(paren
l_string|&quot;SELDO (SELID=%x), &quot;
comma
id|GETPORT
c_func
(paren
id|SELID
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* selection was done */
id|SETPORT
c_func
(paren
id|SSTAT0
comma
id|CLRSELDO
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_ABORT)
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|aborted
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(ABORT) target selected, &quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|current_SC-&gt;SCp.phase
op_and_assign
op_complement
id|in_selection
suffix:semicolon
id|current_SC-&gt;SCp.phase
op_or_assign
id|in_other
suffix:semicolon
macro_line|#if defined(DEBUG_RACE)
id|leave_driver
c_func
(paren
l_string|&quot;(SELDO) intr&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SETPORT
c_func
(paren
id|SCSISIG
comma
id|P_MSGO
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE0
comma
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
id|ENREQINIT
)paren
suffix:semicolon
id|SETBITS
c_func
(paren
id|DMACNTRL0
comma
id|INTEN
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
id|aha152x_panic
c_func
(paren
l_string|&quot;neither timeout nor selection&bslash;007&quot;
)paren
suffix:semicolon
r_else
(brace
macro_line|#if defined(DEBUG_SELECTION) || defined(DEBUG_PHASES)
id|printk
c_func
(paren
l_string|&quot;SELTO, &quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* timeout */
id|SETPORT
c_func
(paren
id|SSTAT1
comma
id|CLRSELTIMO
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE0
comma
id|disconnected_SC
ques
c_cond
id|ENSELDI
suffix:colon
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
id|issue_SC
ques
c_cond
id|ENBUSFREE
suffix:colon
l_int|0
)paren
suffix:semicolon
id|SETBITS
c_func
(paren
id|DMACNTRL0
comma
id|INTEN
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_RACE)
id|leave_driver
c_func
(paren
l_string|&quot;(SELTO) intr&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|aborted
)paren
(brace
macro_line|#if defined(DEBUG_ABORT)
id|printk
c_func
(paren
l_string|&quot;(ABORT) selection timeout, &quot;
)paren
suffix:semicolon
macro_line|#endif
id|abort_result
op_assign
l_int|1
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|abortion_complete
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TESTLO
c_func
(paren
id|SSTAT0
comma
id|SELINGO
)paren
)paren
(brace
multiline_comment|/* ARBITRATION not won */
id|aha152x_done
c_func
(paren
id|DID_BUS_BUSY
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* ARBITRATION won, but SELECTION failed */
id|aha152x_done
c_func
(paren
id|DID_NO_CONNECT
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* enable interrupt, when target leaves current phase */
id|phase
op_assign
id|getphase
c_func
(paren
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SSTAT1
comma
id|CLRPHASECHG
)paren
suffix:semicolon
id|current_SC-&gt;SCp.phase
op_assign
(paren
id|current_SC-&gt;SCp.phase
op_amp
op_complement
(paren
(paren
id|P_MASK
op_or
l_int|1
)paren
op_lshift
l_int|16
)paren
)paren
op_or
(paren
id|phase
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* information transfer phase */
r_switch
c_cond
(paren
id|phase
)paren
(brace
r_case
id|P_MSGO
suffix:colon
multiline_comment|/* MESSAGE OUT */
(brace
r_int
r_char
id|message
suffix:semicolon
macro_line|#if defined(DEBUG_INTR) || defined(DEBUG_MSGO) || defined(DEBUG_PHASES)
id|printk
c_func
(paren
l_string|&quot;MESSAGE OUT, &quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|aborted
)paren
(brace
macro_line|#if defined(DEBUG_MSGO) || defined(DEBUG_ABORT)
id|printk
c_func
(paren
l_string|&quot;ABORT, &quot;
)paren
suffix:semicolon
macro_line|#endif
id|message
op_assign
id|ABORT
suffix:semicolon
)brace
r_else
multiline_comment|/* If we didn&squot;t identify yet, do it. Otherwise there&squot;s nothing to do,&n;             but reject (perhaps one could do as NOP as well) */
r_if
c_cond
(paren
op_logical_neg
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|sent_ident
)paren
)paren
(brace
id|message
op_assign
id|IDENTIFY
c_func
(paren
id|can_disconnect
comma
id|current_SC-&gt;lun
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_MSGO)
id|printk
c_func
(paren
l_string|&quot;IDENTIFY (reconnect=%s;lun=%d), &quot;
comma
id|can_disconnect
ques
c_cond
l_string|&quot;enabled&quot;
suffix:colon
l_string|&quot;disabled&quot;
comma
id|current_SC-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|message
op_assign
id|MESSAGE_REJECT
suffix:semicolon
macro_line|#if defined(DEBUG_MSGO)
id|printk
c_func
(paren
l_string|&quot;REJECT, &quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
id|CLRSETBITS
c_func
(paren
id|SXFRCTL0
comma
id|ENDMA
comma
id|SPIOEN
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE0
comma
id|ENSPIORDY
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
id|ENPHASEMIS
)paren
suffix:semicolon
multiline_comment|/* wait for data latch to become ready or a phase change */
r_while
c_loop
(paren
id|TESTLO
c_func
(paren
id|DMASTAT
comma
id|INTSTAT
)paren
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TESTLO
c_func
(paren
id|SSTAT0
comma
id|SPIORDY
)paren
)paren
(brace
id|aha152x_panic
c_func
(paren
l_string|&quot;couldn&squot;t send message&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Leave MESSAGE OUT after transfer */
id|SETPORT
c_func
(paren
id|SSTAT1
comma
id|CLRATNO
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SCSIDAT
comma
id|message
)paren
suffix:semicolon
id|CLRBITS
c_func
(paren
id|SXFRCTL0
comma
id|SPIOEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|message
op_eq
id|IDENTIFY
c_func
(paren
id|can_disconnect
comma
id|current_SC-&gt;lun
)paren
)paren
(brace
id|current_SC-&gt;SCp.phase
op_or_assign
id|sent_ident
suffix:semicolon
)brace
r_if
c_cond
(paren
id|message
op_eq
id|ABORT
)paren
(brace
multiline_comment|/* revive abort(); abort() enables interrupts */
id|abort_result
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|abortion_complete
)paren
suffix:semicolon
id|current_SC-&gt;SCp.phase
op_assign
(paren
id|current_SC-&gt;SCp.phase
op_amp
op_complement
(paren
id|P_MASK
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
multiline_comment|/* exit */
id|SETBITS
c_func
(paren
id|DMACNTRL0
comma
id|INTEN
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_RACE)
id|leave_driver
c_func
(paren
l_string|&quot;(ABORT) intr&quot;
)paren
suffix:semicolon
macro_line|#endif
id|aha152x_done
c_func
(paren
id|DID_ABORT
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|P_CMD
suffix:colon
multiline_comment|/* COMMAND phase */
macro_line|#if defined(DEBUG_INTR) || defined(DEBUG_CMD) || defined(DEBUG_PHASES)
id|printk
c_func
(paren
l_string|&quot;COMMAND, &quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|current_SC-&gt;SCp.sent_command
)paren
)paren
(brace
r_if
c_cond
(paren
id|GETPORT
c_func
(paren
id|FIFOSTAT
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aha152x: %d bytes left in FIFO, resetting&bslash;n&quot;
comma
id|GETPORT
c_func
(paren
id|FIFOSTAT
)paren
)paren
suffix:semicolon
id|disp_ports
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;contents ( &quot;
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SXFRCTL0
comma
id|CH1
op_or
id|SPIOEN
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|GETPORT
c_func
(paren
id|FIFOSTAT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|GETPORT
c_func
(paren
id|SCSIDAT
)paren
)paren
suffix:semicolon
)brace
id|SETPORT
c_func
(paren
id|SXFRCTL0
comma
id|CH1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;)&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|SETPORT
c_func
(paren
id|DMACNTRL0
comma
id|WRITE_READ
op_or
id|RSTFIFO
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|DMACNTRL0
comma
id|ENDMA
op_or
id|WRITE_READ
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SXFRCTL0
comma
id|CH1
op_or
id|CLRSTCNT
op_or
id|CLRCH1
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SXFRCTL0
comma
id|SCSIEN
op_or
id|DMAEN
op_or
id|CH1
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE0
comma
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
id|ENPHASEMIS
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_CMD)
id|printk
c_func
(paren
l_string|&quot;waiting, &quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* wait for FIFO to get empty */
r_while
c_loop
(paren
id|TESTLO
(paren
id|DMASTAT
comma
id|DFIFOEMP
op_or
id|INTSTAT
)paren
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TESTHI
c_func
(paren
id|SSTAT1
comma
id|PHASEMIS
)paren
)paren
(brace
id|aha152x_panic
c_func
(paren
l_string|&quot;target left COMMAND phase&quot;
)paren
suffix:semicolon
)brace
macro_line|#if defined(DEBUG_CMD)
id|printk
c_func
(paren
l_string|&quot;DFIFOEMP, outsw (%d words), &quot;
comma
id|COMMAND_SIZE
c_func
(paren
id|current_SC-&gt;cmnd
(braket
l_int|0
)braket
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
id|disp_ports
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|outsw
c_func
(paren
op_amp
id|current_SC-&gt;cmnd
comma
id|COMMAND_SIZE
c_func
(paren
id|current_SC-&gt;cmnd
(braket
l_int|0
)braket
)paren
op_rshift
l_int|1
comma
id|DATAPORT
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_CMD)
id|printk
c_func
(paren
l_string|&quot;FCNT=%d, STCNT=%d, &quot;
comma
id|GETPORT
c_func
(paren
id|FIFOSTAT
)paren
comma
id|GETSTCNT
c_func
(paren
)paren
)paren
suffix:semicolon
id|disp_ports
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* wait for SCSI FIFO to get empty.&n;             very important to send complete commands. */
r_while
c_loop
(paren
id|TESTLO
(paren
id|SSTAT2
comma
id|SEMPTY
)paren
)paren
(brace
suffix:semicolon
)brace
id|CLRBITS
c_func
(paren
id|SXFRCTL0
comma
id|SCSIEN
op_or
id|DMAEN
)paren
suffix:semicolon
multiline_comment|/* transfer can be considered ended, when SCSIEN reads back zero */
r_while
c_loop
(paren
id|TESTHI
c_func
(paren
id|SXFRCTL0
comma
id|SCSIEN
)paren
)paren
(brace
suffix:semicolon
)brace
id|CLRBITS
c_func
(paren
id|DMACNTRL0
comma
id|ENDMA
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_CMD) || defined(DEBUG_INTR)
id|printk
c_func
(paren
l_string|&quot;sent %d/%d command bytes, &quot;
comma
id|GETSTCNT
c_func
(paren
)paren
comma
id|COMMAND_SIZE
c_func
(paren
id|current_SC-&gt;cmnd
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
id|aha152x_panic
c_func
(paren
l_string|&quot;Nothing to sent while in COMMAND OUT&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_MSGI
suffix:colon
multiline_comment|/* MESSAGE IN phase */
macro_line|#if defined(DEBUG_INTR) || defined(DEBUG_MSGI) || defined(DEBUG_PHASES)
id|printk
c_func
(paren
l_string|&quot;MESSAGE IN, &quot;
)paren
suffix:semicolon
macro_line|#endif
id|SETPORT
c_func
(paren
id|SXFRCTL0
comma
id|CH1
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE0
comma
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
id|ENBUSFREE
)paren
suffix:semicolon
r_while
c_loop
(paren
id|phase
op_eq
id|P_MSGI
)paren
(brace
id|current_SC-&gt;SCp.Message
op_assign
id|GETPORT
c_func
(paren
id|SCSIBUS
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|current_SC-&gt;SCp.Message
)paren
(brace
r_case
id|DISCONNECT
suffix:colon
macro_line|#if defined(DEBUG_MSGI) || defined(DEBUG_PHASES)
id|printk
c_func
(paren
l_string|&quot;target disconnected, &quot;
)paren
suffix:semicolon
macro_line|#endif
id|current_SC-&gt;SCp.Message
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.phase
op_or_assign
id|disconnected
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|can_disconnect
)paren
(brace
id|aha152x_panic
c_func
(paren
l_string|&quot;target was not allowed to disconnect&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|COMMAND_COMPLETE
suffix:colon
macro_line|#if defined(DEBUG_MSGI) || defined(DEBUG_PHASES)
id|printk
c_func
(paren
l_string|&quot;inbound message ( COMMAND COMPLETE ), &quot;
)paren
suffix:semicolon
macro_line|#endif
id|done
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MESSAGE_REJECT
suffix:colon
macro_line|#if defined(DEBUG_MSGI)
id|printk
c_func
(paren
l_string|&quot;inbound message ( MESSAGE REJECT ), &quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|SAVE_POINTERS
suffix:colon
macro_line|#if defined(DEBUG_MSGI)
id|printk
c_func
(paren
l_string|&quot;inbound message ( SAVE DATA POINTERS ), &quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
multiline_comment|/* my IBM drive responds to the first command with an extended message.&n;   I just ignore it... */
r_case
id|EXTENDED_MESSAGE
suffix:colon
(brace
r_int
id|i
comma
id|code
suffix:semicolon
macro_line|#if defined(DEBUG_MSGI)
id|printk
c_func
(paren
l_string|&quot;inbound message ( EXTENDED MESSAGE ), &quot;
)paren
suffix:semicolon
macro_line|#endif
id|make_acklow
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|getphase
c_func
(paren
)paren
op_ne
id|P_MSGI
)paren
(brace
r_break
suffix:semicolon
)brace
id|i
op_assign
id|GETPORT
c_func
(paren
id|SCSIDAT
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_MSGI)
id|printk
c_func
(paren
l_string|&quot;length (%d), &quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#endif
id|make_acklow
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|getphase
c_func
(paren
)paren
op_ne
id|P_MSGI
)paren
(brace
r_break
suffix:semicolon
)brace
macro_line|#if defined(DEBUG_MSGI)
id|printk
c_func
(paren
l_string|&quot;code ( &quot;
)paren
suffix:semicolon
macro_line|#endif
id|code
op_assign
id|GETPORT
c_func
(paren
id|SCSIDAT
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_MSGI)
r_switch
c_cond
(paren
id|code
)paren
(brace
r_case
l_int|0x00
suffix:colon
id|printk
c_func
(paren
l_string|&quot;MODIFY DATA POINTER &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SYNCHRONOUS DATA TRANSFER REQUEST &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x02
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXTENDED IDENTIFY &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x03
suffix:colon
id|printk
c_func
(paren
l_string|&quot;WIDE DATA TRANSFER REQUEST &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|code
op_amp
l_int|0x80
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;reserved (%d) &quot;
comma
id|code
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;vendor specific (%d) &quot;
comma
id|code
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; ), data ( &quot;
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
op_decrement
id|i
op_logical_and
(paren
id|make_acklow
c_func
(paren
)paren
comma
id|getphase
c_func
(paren
)paren
op_eq
id|P_MSGI
)paren
)paren
(brace
macro_line|#if defined(DEBUG_MSGI)
id|printk
c_func
(paren
l_string|&quot;%x &quot;
comma
id|GETPORT
c_func
(paren
id|SCSIDAT
)paren
)paren
suffix:semicolon
macro_line|#else
id|GETPORT
c_func
(paren
id|SCSIDAT
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if defined(DEBUG_MSGI)
id|printk
c_func
(paren
l_string|&quot; ), &quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;unsupported inbound message %x, &quot;
comma
id|current_SC-&gt;SCp.Message
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|make_acklow
c_func
(paren
)paren
suffix:semicolon
id|phase
op_assign
id|getphase
c_func
(paren
)paren
suffix:semicolon
)brace
id|SETPORT
c_func
(paren
id|SCSISIG
comma
id|P_MSGI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|disconnected
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_QUEUES)
id|printk
c_func
(paren
l_string|&quot;d+, &quot;
)paren
suffix:semicolon
macro_line|#endif
id|append_SC
c_func
(paren
op_amp
id|disconnected_SC
comma
id|current_SC
)paren
suffix:semicolon
id|current_SC
op_assign
l_int|NULL
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|SETBITS
c_func
(paren
id|SCSISEQ
comma
id|ENRESELI
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE0
comma
id|disconnected_SC
ques
c_cond
id|ENSELDI
suffix:colon
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
id|issue_SC
ques
c_cond
id|ENBUSFREE
suffix:colon
l_int|0
)paren
suffix:semicolon
id|SETBITS
c_func
(paren
id|DMACNTRL0
comma
id|INTEN
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|P_STATUS
suffix:colon
multiline_comment|/* STATUS IN phase */
macro_line|#if defined(DEBUG_STATUS) || defined(DEBUG_INTR) || defined(DEBUG_PHASES)
id|printk
c_func
(paren
l_string|&quot;STATUS, &quot;
)paren
suffix:semicolon
macro_line|#endif
id|SETPORT
c_func
(paren
id|SXFRCTL0
comma
id|CH1
op_or
id|SPIOEN
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE0
comma
id|ENSPIORDY
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
id|ENPHASEMIS
)paren
suffix:semicolon
id|SETBITS
c_func
(paren
id|SXFRCTL0
comma
id|SCSIEN
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_STATUS)
id|printk
c_func
(paren
l_string|&quot;waiting for status, &quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(DEBUG_STATUS)
id|disp_ports
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|TESTLO
c_func
(paren
id|DMASTAT
comma
id|INTSTAT
)paren
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TESTLO
c_func
(paren
id|SSTAT0
comma
id|SPIORDY
)paren
)paren
(brace
id|aha152x_panic
c_func
(paren
l_string|&quot;passing STATUS phase&quot;
)paren
suffix:semicolon
)brace
id|current_SC-&gt;SCp.Status
op_assign
id|GETPORT
c_func
(paren
id|SCSIDAT
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_STATUS)
id|printk
c_func
(paren
l_string|&quot;inbound status &quot;
)paren
suffix:semicolon
id|print_status
c_func
(paren
id|current_SC-&gt;SCp.Status
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, &quot;
)paren
suffix:semicolon
macro_line|#endif
id|CLRBITS
c_func
(paren
id|SXFRCTL0
comma
id|SCSIEN
)paren
suffix:semicolon
r_while
c_loop
(paren
id|TESTHI
c_func
(paren
id|SXFRCTL0
comma
id|SCSIEN
)paren
)paren
(brace
suffix:semicolon
)brace
id|CLRBITS
c_func
(paren
id|SXFRCTL0
comma
id|SPIOEN
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_DATAI
suffix:colon
multiline_comment|/* DATA IN phase */
(brace
r_int
id|fifodata
comma
id|data_count
comma
id|done
suffix:semicolon
macro_line|#if defined(DEBUG_DATAI) || defined(DEBUG_INTR) || defined(DEBUG_PHASES)
id|printk
c_func
(paren
l_string|&quot;DATA IN, &quot;
)paren
suffix:semicolon
macro_line|#endif
id|SETPORT
c_func
(paren
id|SIMODE0
comma
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
id|ENPHASEMIS
op_or
id|ENBUSFREE
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SXFRCTL0
comma
id|CH1
op_or
id|CLRSTCNT
op_or
id|CLRCH1
)paren
suffix:semicolon
id|CLRSETBITS
c_func
(paren
id|SXFRCTL0
comma
id|CLRSTCNT
comma
id|SCSIEN
op_or
id|DMAEN
op_or
id|CH1
)paren
suffix:semicolon
id|SETBITS
c_func
(paren
id|DMACNTRL0
comma
id|RSTFIFO
)paren
suffix:semicolon
id|CLRSETBITS
c_func
(paren
id|DMACNTRL0
comma
id|WRITE_READ
comma
id|ENDMA
)paren
suffix:semicolon
multiline_comment|/* done is set when the FIFO is empty after the target left DATA IN */
id|done
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* while the target stays in DATA to transfer data */
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
(brace
macro_line|#if defined(DEBUG_DATAI)
id|printk
c_func
(paren
l_string|&quot;expecting data, &quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* wait for PHASEMIS or full FIFO */
r_while
c_loop
(paren
id|TESTLO
(paren
id|DMASTAT
comma
id|DFIFOFULL
op_or
id|INTSTAT
)paren
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TESTHI
c_func
(paren
id|DMASTAT
comma
id|DFIFOFULL
)paren
)paren
(brace
id|fifodata
op_assign
l_int|132
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* wait for SCSI fifo to get empty */
r_while
c_loop
(paren
id|TESTLO
c_func
(paren
id|SSTAT2
comma
id|SEMPTY
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* rest of data in FIFO */
id|fifodata
op_assign
id|GETPORT
c_func
(paren
id|FIFOSTAT
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_DATAI)
id|printk
c_func
(paren
l_string|&quot;last transfer, &quot;
)paren
suffix:semicolon
macro_line|#endif
id|done
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#if defined(DEBUG_DATAI)
id|printk
c_func
(paren
l_string|&quot;fifodata=%d, &quot;
comma
id|fifodata
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* I don&squot;t know yet why, but rarely I get empty&n;               buffers here, so I&squot;ve to advance to the next buffer&n;               before I enter the loop */
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.this_residual
op_logical_and
id|current_SC-&gt;SCp.buffers_residual
)paren
(brace
multiline_comment|/* advance to next buffer */
id|current_SC-&gt;SCp.buffers_residual
op_decrement
suffix:semicolon
id|current_SC-&gt;SCp.buffer
op_increment
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
r_while
c_loop
(paren
id|fifodata
op_logical_and
id|current_SC-&gt;SCp.this_residual
)paren
(brace
id|data_count
op_assign
id|fifodata
suffix:semicolon
multiline_comment|/* limit data transfer to size of first sg buffer */
r_if
c_cond
(paren
id|data_count
OG
id|current_SC-&gt;SCp.this_residual
)paren
id|data_count
op_assign
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
id|fifodata
op_sub_assign
id|data_count
suffix:semicolon
macro_line|#if defined(DEBUG_DATAI)
id|printk
c_func
(paren
l_string|&quot;data_count=%d, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
multiline_comment|/* get a single byte in byte mode */
id|SETBITS
c_func
(paren
id|DMACNTRL0
comma
id|_8BIT
)paren
suffix:semicolon
op_star
id|current_SC-&gt;SCp.ptr
op_increment
op_assign
id|GETPORT
c_func
(paren
id|DATAPORT
)paren
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|CLRBITS
c_func
(paren
id|DMACNTRL0
comma
id|_8BIT
)paren
suffix:semicolon
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Number of words */
id|insw
c_func
(paren
id|current_SC-&gt;SCp.ptr
comma
id|data_count
comma
id|DATAPORT
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_DATAI)
multiline_comment|/* show what comes with the last transfer */
r_if
c_cond
(paren
id|done
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;data on last transfer (%d bytes: &quot;
comma
l_int|2
op_star
id|data_count
)paren
suffix:semicolon
id|data
op_assign
(paren
r_int
r_char
op_star
)paren
id|current_SC-&gt;SCp.ptr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
op_star
id|data_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2x &quot;
comma
op_star
id|data
op_increment
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;), &quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|current_SC-&gt;SCp.ptr
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_sub_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
multiline_comment|/* if this buffer is full and there are more buffers left */
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.this_residual
op_logical_and
id|current_SC-&gt;SCp.buffers_residual
)paren
(brace
multiline_comment|/* advance to next buffer */
id|current_SC-&gt;SCp.buffers_residual
op_decrement
suffix:semicolon
id|current_SC-&gt;SCp.buffer
op_increment
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
)brace
multiline_comment|/* rare (but possible) status bytes (probably also DISCONNECT &n;               messages) get transfered in the data phase, so I assume 1&n;               additional byte is ok */
r_if
c_cond
(paren
id|fifodata
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aha152x: more data than expected (%d bytes)&bslash;n&quot;
comma
id|GETPORT
c_func
(paren
id|FIFOSTAT
)paren
)paren
suffix:semicolon
)brace
macro_line|#if defined(DEBUG_DATAI)
r_if
c_cond
(paren
op_logical_neg
id|fifodata
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fifo empty, &quot;
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;something left in fifo, &quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if defined(DEBUG_DATAI)
r_if
c_cond
(paren
id|current_SC-&gt;SCp.buffers_residual
op_logical_or
id|current_SC-&gt;SCp.this_residual
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;left buffers (buffers=%d, bytes=%d), &quot;
comma
id|current_SC-&gt;SCp.buffers_residual
comma
id|current_SC-&gt;SCp.this_residual
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* transfer can be considered ended, when SCSIEN reads back zero */
id|CLRBITS
c_func
(paren
id|SXFRCTL0
comma
id|SCSIEN
op_or
id|DMAEN
)paren
suffix:semicolon
r_while
c_loop
(paren
id|TESTHI
c_func
(paren
id|SXFRCTL0
comma
id|SCSIEN
)paren
)paren
(brace
suffix:semicolon
)brace
id|CLRBITS
c_func
(paren
id|DMACNTRL0
comma
id|ENDMA
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_DATAI) || defined(DEBUG_INTR)
id|printk
c_func
(paren
l_string|&quot;got %d bytes, &quot;
comma
id|GETSTCNT
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
id|current_SC-&gt;SCp.have_data_in
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|P_DATAO
suffix:colon
multiline_comment|/* DATA OUT phase */
(brace
r_int
id|data_count
suffix:semicolon
macro_line|#if defined(DEBUG_DATAO) || defined(DEBUG_INTR) || defined(DEBUG_PHASES)
id|printk
c_func
(paren
l_string|&quot;DATA OUT, &quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(DEBUG_DATAO)
id|printk
c_func
(paren
l_string|&quot;got data to send (bytes=%d, buffers=%d), &quot;
comma
id|current_SC-&gt;SCp.this_residual
comma
id|current_SC-&gt;SCp.buffers_residual
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|GETPORT
c_func
(paren
id|FIFOSTAT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%d left in FIFO, &quot;
comma
id|GETPORT
c_func
(paren
id|FIFOSTAT
)paren
)paren
suffix:semicolon
id|aha152x_panic
c_func
(paren
l_string|&quot;FIFO should be empty&quot;
)paren
suffix:semicolon
)brace
id|SETPORT
c_func
(paren
id|DMACNTRL0
comma
id|WRITE_READ
op_or
id|RSTFIFO
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|DMACNTRL0
comma
id|ENDMA
op_or
id|WRITE_READ
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SXFRCTL0
comma
id|CH1
op_or
id|CLRSTCNT
op_or
id|CLRCH1
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SXFRCTL0
comma
id|SCSIEN
op_or
id|DMAEN
op_or
id|CH1
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE0
comma
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
id|ENPHASEMIS
)paren
suffix:semicolon
multiline_comment|/* while current buffer is not empty or&n;           there are more buffers to transfer */
r_while
c_loop
(paren
id|TESTLO
c_func
(paren
id|SSTAT1
comma
id|PHASEMIS
)paren
op_logical_and
(paren
id|current_SC-&gt;SCp.this_residual
op_logical_or
id|current_SC-&gt;SCp.buffers_residual
)paren
)paren
(brace
macro_line|#if defined(DEBUG_DATAO)
id|printk
c_func
(paren
l_string|&quot;sending data (left: bytes=%d, buffers=%d), waiting, &quot;
comma
id|current_SC-&gt;SCp.this_residual
comma
id|current_SC-&gt;SCp.buffers_residual
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* transfer rest of buffer, but max. 128 byte */
id|data_count
op_assign
id|current_SC-&gt;SCp.this_residual
OG
l_int|128
ques
c_cond
l_int|128
suffix:colon
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
macro_line|#if defined(DEBUG_DATAO)
id|printk
c_func
(paren
l_string|&quot;data_count=%d, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
multiline_comment|/* put a single byte in byte mode */
id|SETBITS
c_func
(paren
id|DMACNTRL0
comma
id|_8BIT
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|DATAPORT
comma
op_star
id|current_SC-&gt;SCp.ptr
op_increment
)paren
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|CLRBITS
c_func
(paren
id|DMACNTRL0
comma
id|_8BIT
)paren
suffix:semicolon
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Number of words */
id|outsw
c_func
(paren
id|current_SC-&gt;SCp.ptr
comma
id|data_count
comma
id|DATAPORT
)paren
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_sub_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
multiline_comment|/* wait for FIFO to get empty */
r_while
c_loop
(paren
id|TESTLO
(paren
id|DMASTAT
comma
id|DFIFOEMP
op_or
id|INTSTAT
)paren
)paren
(brace
suffix:semicolon
)brace
macro_line|#if defined(DEBUG_DATAO)
id|printk
c_func
(paren
l_string|&quot;fifo (%d bytes), transfered (%d bytes), &quot;
comma
id|GETPORT
c_func
(paren
id|FIFOSTAT
)paren
comma
id|GETSTCNT
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* if this buffer is empty and there are more buffers left */
r_if
c_cond
(paren
id|TESTLO
c_func
(paren
id|SSTAT1
comma
id|PHASEMIS
)paren
op_logical_and
op_logical_neg
id|current_SC-&gt;SCp.this_residual
op_logical_and
id|current_SC-&gt;SCp.buffers_residual
)paren
(brace
multiline_comment|/* advance to next buffer */
id|current_SC-&gt;SCp.buffers_residual
op_decrement
suffix:semicolon
id|current_SC-&gt;SCp.buffer
op_increment
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|current_SC-&gt;SCp.this_residual
op_logical_or
id|current_SC-&gt;SCp.buffers_residual
)paren
(brace
multiline_comment|/* target leaves DATA OUT for an other phase&n;               (perhaps disconnect) */
multiline_comment|/* data in fifos has to be resend */
id|data_count
op_assign
id|GETPORT
c_func
(paren
id|SSTAT2
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data_count
op_amp
id|SFCNT
)paren
op_eq
l_int|0
)paren
(brace
id|data_count
op_assign
(paren
id|data_count
op_amp
id|SEMPTY
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|8
suffix:semicolon
)brace
r_else
id|data_count
op_and_assign
id|SFCNT
suffix:semicolon
macro_line|#if defined(DEBUG_DATAO)
id|printk
c_func
(paren
l_string|&quot;&bslash;ntarget left DATA OUT, fifo=%d, scsififo=%d, &quot;
comma
id|GETPORT
c_func
(paren
id|FIFOSTAT
)paren
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
id|data_count
op_add_assign
id|GETPORT
c_func
(paren
id|FIFOSTAT
)paren
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_sub_assign
id|data_count
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_add_assign
id|data_count
suffix:semicolon
macro_line|#if defined(DEBUG_DATAO)
id|printk
c_func
(paren
l_string|&quot;left data (bytes=%d, buffers=%d), fifos (bytes=%d), transfer incomplete, resetting fifo, &quot;
comma
id|current_SC-&gt;SCp.this_residual
comma
id|current_SC-&gt;SCp.buffers_residual
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
id|SETPORT
c_func
(paren
id|DMACNTRL0
comma
id|WRITE_READ
op_or
id|RSTFIFO
)paren
suffix:semicolon
id|CLRBITS
c_func
(paren
id|SXFRCTL0
comma
id|SCSIEN
op_or
id|DMAEN
)paren
suffix:semicolon
id|CLRBITS
c_func
(paren
id|DMACNTRL0
comma
id|ENDMA
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if defined(DEBUG_DATAO)
id|printk
c_func
(paren
l_string|&quot;waiting for SCSI fifo to get empty, &quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* wait for SCSI fifo to get empty */
r_while
c_loop
(paren
id|TESTLO
c_func
(paren
id|SSTAT2
comma
id|SEMPTY
)paren
)paren
(brace
suffix:semicolon
)brace
macro_line|#if defined(DEBUG_DATAO)
id|printk
c_func
(paren
l_string|&quot;ok, &quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(DEBUG_DATAO)
id|printk
c_func
(paren
l_string|&quot;left data (bytes=%d, buffers=%d) &quot;
comma
id|current_SC-&gt;SCp.this_residual
comma
id|current_SC-&gt;SCp.buffers_residual
)paren
suffix:semicolon
macro_line|#endif
id|CLRBITS
c_func
(paren
id|SXFRCTL0
comma
id|SCSIEN
op_or
id|DMAEN
)paren
suffix:semicolon
multiline_comment|/* transfer can be considered ended, when SCSIEN reads back zero */
r_while
c_loop
(paren
id|TESTHI
c_func
(paren
id|SXFRCTL0
comma
id|SCSIEN
)paren
)paren
(brace
suffix:semicolon
)brace
id|CLRBITS
c_func
(paren
id|DMACNTRL0
comma
id|ENDMA
)paren
suffix:semicolon
)brace
macro_line|#if defined(DEBUG_DATAO) || defined(DEBUG_INTR)
id|printk
c_func
(paren
l_string|&quot;sent %d data bytes, &quot;
comma
id|GETSTCNT
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* BUSFREE */
macro_line|#if defined(DEBUG_RACE)
id|leave_driver
c_func
(paren
l_string|&quot;(BUSFREE) intr&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(DEBUG_PHASES)
id|printk
c_func
(paren
l_string|&quot;unexpected BUS FREE, &quot;
)paren
suffix:semicolon
macro_line|#endif
id|current_SC-&gt;SCp.phase
op_assign
(paren
id|current_SC-&gt;SCp.phase
op_amp
op_complement
(paren
id|P_MASK
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
id|aha152x_done
c_func
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t know any better */
r_return
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* parity error in DATA phase */
macro_line|#if defined(DEBUG_RACE)
id|leave_driver
c_func
(paren
l_string|&quot;(DID_PARITY) intr&quot;
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;PARITY error in DATA phase, &quot;
)paren
suffix:semicolon
id|current_SC-&gt;SCp.phase
op_assign
(paren
id|current_SC-&gt;SCp.phase
op_amp
op_complement
(paren
id|P_MASK
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
id|SETBITS
c_func
(paren
id|DMACNTRL0
comma
id|INTEN
)paren
suffix:semicolon
id|aha152x_done
c_func
(paren
id|DID_PARITY
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
macro_line|#if defined(DEBUG_INTR)
id|printk
c_func
(paren
l_string|&quot;unexpected phase, &quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|done
)paren
(brace
macro_line|#if defined(DEBUG_INTR)
id|printk
c_func
(paren
l_string|&quot;command done.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(DEBUG_RACE)
id|leave_driver
c_func
(paren
l_string|&quot;(done) intr&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SETPORT
c_func
(paren
id|SIMODE0
comma
id|disconnected_SC
ques
c_cond
id|ENSELDI
suffix:colon
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
id|issue_SC
ques
c_cond
id|ENBUSFREE
suffix:colon
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SCSISEQ
comma
id|disconnected_SC
ques
c_cond
id|ENRESELI
suffix:colon
l_int|0
)paren
suffix:semicolon
id|SETBITS
c_func
(paren
id|DMACNTRL0
comma
id|INTEN
)paren
suffix:semicolon
id|aha152x_done
c_func
(paren
(paren
id|current_SC-&gt;SCp.Status
op_amp
l_int|0xff
)paren
op_or
(paren
(paren
id|current_SC-&gt;SCp.Message
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|DID_OK
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_RACE)
id|printk
c_func
(paren
l_string|&quot;done returned (DID_OK: Status=%x; Message=%x).&bslash;n&quot;
comma
id|current_SC-&gt;SCp.Status
comma
id|current_SC-&gt;SCp.Message
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current_SC
)paren
(brace
id|current_SC-&gt;SCp.phase
op_or_assign
l_int|1
op_lshift
l_int|16
suffix:semicolon
)brace
id|SETPORT
c_func
(paren
id|SIMODE0
comma
l_int|0
)paren
suffix:semicolon
id|SETPORT
c_func
(paren
id|SIMODE1
comma
id|ENPHASEMIS
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_INTR)
id|disp_enintr
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(DEBUG_RACE)
id|leave_driver
c_func
(paren
l_string|&quot;(PHASEEND) intr&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SETBITS
c_func
(paren
id|DMACNTRL0
comma
id|INTEN
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* &n; * Dump the current driver status and panic...&n; */
DECL|function|aha152x_panic
r_static
r_void
id|aha152x_panic
c_func
(paren
r_char
op_star
id|msg
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;naha152x_panic: %s&bslash;n&quot;
comma
id|msg
)paren
suffix:semicolon
id|show_queues
c_func
(paren
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;aha152x panic&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Display registers of AIC-6260&n; */
DECL|function|disp_ports
r_static
r_void
id|disp_ports
c_func
(paren
r_void
)paren
(brace
macro_line|#if !defined(SKIP_PORTS)
r_int
id|s
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n%s: &quot;
comma
id|current_SC
ques
c_cond
l_string|&quot;on bus&quot;
suffix:colon
l_string|&quot;waiting&quot;
)paren
suffix:semicolon
id|s
op_assign
id|GETPORT
c_func
(paren
id|SCSISEQ
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SCSISEQ ( &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_amp
id|TEMODEO
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TARGET MODE &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ENSELO
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SELO &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ENSELI
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SELI &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ENRESELI
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RESELI &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ENAUTOATNO
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;AUTOATNO &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ENAUTOATNI
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;AUTOATNI &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ENAUTOATNP
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;AUTOATNP &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SCSIRSTO
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSIRSTO &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;);&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; SCSISIG ( &quot;
)paren
suffix:semicolon
id|s
op_assign
id|GETPORT
c_func
(paren
id|SCSISIG
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|s
op_amp
id|P_MASK
)paren
(brace
r_case
id|P_DATAO
suffix:colon
id|printk
c_func
(paren
l_string|&quot;DATA OUT&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_DATAI
suffix:colon
id|printk
c_func
(paren
l_string|&quot;DATA IN&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_CMD
suffix:colon
id|printk
c_func
(paren
l_string|&quot;COMMAND&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_STATUS
suffix:colon
id|printk
c_func
(paren
l_string|&quot;STATUS&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_MSGO
suffix:colon
id|printk
c_func
(paren
l_string|&quot;MESSAGE OUT&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_MSGI
suffix:colon
id|printk
c_func
(paren
l_string|&quot;MESSAGE IN&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;*illegal*&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; ); &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;INTSTAT ( %s ); &quot;
comma
id|TESTHI
c_func
(paren
id|DMASTAT
comma
id|INTSTAT
)paren
ques
c_cond
l_string|&quot;hi&quot;
suffix:colon
l_string|&quot;lo&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SSTAT ( &quot;
)paren
suffix:semicolon
id|s
op_assign
id|GETPORT
c_func
(paren
id|SSTAT0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_amp
id|TARGET
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TARGET &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SELDO
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SELDO &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SELDI
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SELDI &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SELINGO
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SELINGO &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SWRAP
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SWRAP &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SDONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SDONE &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SPIORDY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SPIORDY &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|DMADONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DMADONE &quot;
)paren
suffix:semicolon
)brace
id|s
op_assign
id|GETPORT
c_func
(paren
id|SSTAT1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_amp
id|SELTO
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SELTO &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ATNTARG
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ATNTARG &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SCSIRSTI
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSIRSTI &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|PHASEMIS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PHASEMIS &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|BUSFREE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BUSFREE &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SCSIPERR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSIPERR &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|PHASECHG
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PHASECHG &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|REQINIT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;REQINIT &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;); &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SSTAT ( &quot;
)paren
suffix:semicolon
id|s
op_assign
id|GETPORT
c_func
(paren
id|SSTAT0
)paren
op_amp
id|GETPORT
c_func
(paren
id|SIMODE0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_amp
id|TARGET
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TARGET &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SELDO
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SELDO &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SELDI
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SELDI &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SELINGO
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SELINGO &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SWRAP
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SWRAP &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SDONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SDONE &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SPIORDY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SPIORDY &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|DMADONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DMADONE &quot;
)paren
suffix:semicolon
)brace
id|s
op_assign
id|GETPORT
c_func
(paren
id|SSTAT1
)paren
op_amp
id|GETPORT
c_func
(paren
id|SIMODE1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_amp
id|SELTO
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SELTO &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ATNTARG
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ATNTARG &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SCSIRSTI
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSIRSTI &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|PHASEMIS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PHASEMIS &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|BUSFREE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BUSFREE &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SCSIPERR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSIPERR &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|PHASECHG
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PHASECHG &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|REQINIT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;REQINIT &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;); &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SXFRCTL0 ( &quot;
)paren
suffix:semicolon
id|s
op_assign
id|GETPORT
c_func
(paren
id|SXFRCTL0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_amp
id|SCSIEN
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSIEN &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|DMAEN
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DMAEN &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|CH1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CH1 &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|CLRSTCNT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CLRSTCNT &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SPIOEN
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SPIOEN &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|CLRCH1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CLRCH1 &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;); &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SIGNAL ( &quot;
)paren
suffix:semicolon
id|s
op_assign
id|GETPORT
c_func
(paren
id|SCSISIG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_amp
id|ATNI
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ATNI &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SELI
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SELI &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|BSYI
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BSYI &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|REQI
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;REQI &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ACKI
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ACKI &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;); &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SELID ( %02x ), &quot;
comma
id|GETPORT
c_func
(paren
id|SELID
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SSTAT2 ( &quot;
)paren
suffix:semicolon
id|s
op_assign
id|GETPORT
c_func
(paren
id|SSTAT2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_amp
id|SOFFSET
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SOFFSET &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SEMPTY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SEMPTY &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SFULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SFULL &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;); &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_amp
id|SFCNT
)paren
(brace
id|s
op_and_assign
id|SFCNT
suffix:semicolon
)brace
r_else
id|s
op_assign
(paren
id|s
op_amp
id|SEMPTY
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|8
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SFCNT ( %d ); &quot;
comma
id|s
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;SSTAT4 ( &quot;
)paren
suffix:semicolon
id|s
op_assign
id|GETPORT
c_func
(paren
id|SSTAT4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_amp
id|SYNCERR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SYNCERR &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|FWERR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FWERR &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|FRERR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FRERR &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;); &quot;
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;FCNT ( %d ); &quot;
comma
id|GETPORT
c_func
(paren
id|FIFOSTAT
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;DMACNTRL0 ( &quot;
)paren
suffix:semicolon
id|s
op_assign
id|GETPORT
c_func
(paren
id|DMACNTRL0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s &quot;
comma
id|s
op_amp
id|_8BIT
ques
c_cond
l_string|&quot;8BIT&quot;
suffix:colon
l_string|&quot;16BIT&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s &quot;
comma
id|s
op_amp
id|DMA
ques
c_cond
l_string|&quot;DMA&quot;
suffix:colon
l_string|&quot;PIO&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s &quot;
comma
id|s
op_amp
id|WRITE_READ
ques
c_cond
l_string|&quot;WRITE&quot;
suffix:colon
l_string|&quot;READ&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_amp
id|ENDMA
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ENDMA &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|INTEN
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;INTEN &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|RSTFIFO
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RSTFIFO &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|SWINT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SWINT &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;); &quot;
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;DMACNTRL1 ( &quot;
)paren
suffix:semicolon
id|s
op_assign
id|GETPORT
c_func
(paren
id|DMACNTRL1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_amp
id|PWRDWN
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PWRDN &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;); &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;STK ( %d ); &quot;
comma
id|s
op_amp
l_int|0xf
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;DMASTAT (&quot;
)paren
suffix:semicolon
id|s
op_assign
id|GETPORT
c_func
(paren
id|DMASTAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_amp
id|ATDONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ATDONE &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|WORDRDY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;WORDRDY &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|DFIFOFULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DFIFOFULL &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|DFIFOEMP
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DFIFOEMP &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;)&quot;
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * display enabled interrupts&n; */
DECL|function|disp_enintr
r_static
r_void
id|disp_enintr
c_func
(paren
r_void
)paren
(brace
r_int
id|s
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;enabled interrupts ( &quot;
)paren
suffix:semicolon
id|s
op_assign
id|GETPORT
c_func
(paren
id|SIMODE0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_amp
id|ENSELDO
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ENSELDO &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ENSELDI
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ENSELDI &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ENSELINGO
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ENSELINGO &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ENSWRAP
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ENSWRAP &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ENSDONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ENSDONE &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ENSPIORDY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ENSPIORDY &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ENDMADONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ENDMADONE &quot;
)paren
suffix:semicolon
)brace
id|s
op_assign
id|GETPORT
c_func
(paren
id|SIMODE1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_amp
id|ENSELTIMO
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ENSELTIMO &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ENATNTARG
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ENATNTARG &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ENPHASEMIS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ENPHASEMIS &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ENBUSFREE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ENBUSFREE &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ENSCSIPERR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ENSCSIPERR &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ENPHASECHG
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ENPHASECHG &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_amp
id|ENREQINIT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ENREQINIT &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;)&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#if defined(DEBUG_RACE)
DECL|variable|should_leave
r_static
r_const
r_char
op_star
id|should_leave
suffix:semicolon
DECL|variable|in_driver
r_static
r_int
id|in_driver
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Only one routine can be in the driver at once.&n; */
DECL|function|enter_driver
r_static
r_void
id|enter_driver
c_func
(paren
r_const
r_char
op_star
id|func
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aha152x: entering %s() (%x)&bslash;n&quot;
comma
id|func
comma
id|jiffies
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_driver
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s should leave first.&bslash;n&quot;
comma
id|should_leave
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;aha152x: already in driver&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|in_driver
op_increment
suffix:semicolon
id|should_leave
op_assign
id|func
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|leave_driver
r_static
r_void
id|leave_driver
c_func
(paren
r_const
r_char
op_star
id|func
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;naha152x: leaving %s() (%x)&bslash;n&quot;
comma
id|func
comma
id|jiffies
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_driver
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aha152x: %s already left.&bslash;n&quot;
comma
id|should_leave
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;aha152x: %s already left driver.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|in_driver
op_decrement
suffix:semicolon
id|should_leave
op_assign
id|func
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Show the command data of a command&n; */
DECL|function|show_command
r_static
r_void
id|show_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|ptr
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;0x%08x: target=%d; lun=%d; cmnd=( &quot;
comma
(paren
r_int
r_int
)paren
id|ptr
comma
id|ptr-&gt;target
comma
id|ptr-&gt;lun
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|COMMAND_SIZE
c_func
(paren
id|ptr-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|ptr-&gt;cmnd
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;); residual=%d; buffers=%d; phase |&quot;
comma
id|ptr-&gt;SCp.this_residual
comma
id|ptr-&gt;SCp.buffers_residual
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr-&gt;SCp.phase
op_amp
id|not_issued
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;not issued|&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr-&gt;SCp.phase
op_amp
id|in_selection
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;in selection|&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr-&gt;SCp.phase
op_amp
id|disconnected
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;disconnected|&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr-&gt;SCp.phase
op_amp
id|aborted
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aborted|&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr-&gt;SCp.phase
op_amp
id|sent_ident
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;send_ident|&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr-&gt;SCp.phase
op_amp
id|in_other
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;; in other(&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|ptr-&gt;SCp.phase
op_rshift
l_int|16
)paren
op_amp
id|P_MASK
)paren
(brace
r_case
id|P_DATAO
suffix:colon
id|printk
c_func
(paren
l_string|&quot;DATA OUT&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_DATAI
suffix:colon
id|printk
c_func
(paren
l_string|&quot;DATA IN&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_CMD
suffix:colon
id|printk
c_func
(paren
l_string|&quot;COMMAND&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_STATUS
suffix:colon
id|printk
c_func
(paren
l_string|&quot;STATUS&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_MSGO
suffix:colon
id|printk
c_func
(paren
l_string|&quot;MESSAGE OUT&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_MSGI
suffix:colon
id|printk
c_func
(paren
l_string|&quot;MESSAGE IN&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;*illegal*&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;)&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr-&gt;SCp.phase
op_amp
(paren
l_int|1
op_lshift
l_int|16
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;; phaseend&quot;
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;; next=0x%08x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ptr-&gt;host_scribble
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Dump the queued data&n; */
DECL|function|show_queues
r_static
r_void
id|show_queues
c_func
(paren
r_void
)paren
(brace
id|Scsi_Cmnd
op_star
id|ptr
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;QUEUE STATUS:&bslash;nissue_SC:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
id|issue_SC
suffix:semicolon
id|ptr
suffix:semicolon
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
)paren
(brace
id|show_command
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;current_SC:&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_SC
)paren
(brace
id|show_command
c_func
(paren
id|current_SC
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;none&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;disconnected_SC:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
id|disconnected_SC
suffix:semicolon
id|ptr
suffix:semicolon
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
)paren
(brace
id|show_command
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
id|disp_ports
c_func
(paren
)paren
suffix:semicolon
id|disp_enintr
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
eof
