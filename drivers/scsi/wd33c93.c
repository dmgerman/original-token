multiline_comment|/*&n; *    wd33c93.c - Linux-68k device driver for the Commodore&n; *                Amiga A2091/590 SCSI controller card&n; *&n; * Copyright (c) 1996 John Shifflett, GeoLog Consulting&n; *    john@geolog.com&n; *    jshiffle@netcom.com&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; *&n; * Drew Eckhardt&squot;s excellent &squot;Generic NCR5380&squot; sources from Linux-PC&n; * provided much of the inspiration and some of the code for this&n; * driver. Everything I know about Amiga DMA was gleaned from careful&n; * reading of Hamish Mcdonald&squot;s original wd33c93 driver; in fact, I&n; * borrowed shamelessly from all over that source. Thanks Hamish!&n; *&n; * _This_ driver is (I feel) an improvement over the old one in&n; * several respects:&n; *&n; *    -  Target Disconnection/Reconnection  is now supported. Any&n; *          system with more than one device active on the SCSI bus&n; *          will benefit from this.&n; *&n; *    -  Synchronous data transfers are now supported. The driver&n; *          automatically uses this faster protocol with any device&n; *          able to handle it.&n; *&n; *    -  Runtime operating parameters can now be specified through&n; *       either the &squot;amiboot&squot; or the LILO command line. Something&n; *       like:&n; *          &quot;wd33c93=0x0000&quot;&n; *       The value 0x0000 results in the defaults being used; bits&n; *       are defined in wd33c93.h.&n; *&n; *    -  The old driver relied exclusively on what the Western Digital&n; *          docs call &quot;Combination Level 2 Commands&quot;, which are a great&n; *          idea in that the CPU is relieved of a lot of interrupt&n; *          overhead. However, by accepting a certain (user-settable)&n; *          amount of additional interrupts, this driver achieves&n; *          better control over the SCSI bus, and data transfers are&n; *          almost as fast while being much easier to define, track,&n; *          and debug.&n; *&n; *&n; * TODO:&n; *       more speed. tagged queuing.&n; *&n; *&n; * People with bug reports, wish-lists, complaints, comments,&n; * or improvements are asked to pah-leeez email me (John Shifflett)&n; * at john@geolog.com or jshiffle@netcom.com! I&squot;m anxious to get&n; * this thing into as good a shape as possible, and I&squot;m positive&n; * there are lots of lurking bugs and &quot;Stupid Places&quot;.&n; *&n; */
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;wd33c93.h&quot;
DECL|macro|SYNC_DEBUG
mdefine_line|#define SYNC_DEBUG
DECL|macro|DEBUGGING_ON
mdefine_line|#define DEBUGGING_ON
DECL|macro|WD33C93_VERSION
mdefine_line|#define WD33C93_VERSION    &quot;1.17&quot;
DECL|macro|WD33C93_DATE
mdefine_line|#define WD33C93_DATE       &quot;06/Feb/1996&quot;
macro_line|#ifdef DEBUGGING_ON
DECL|macro|DB
mdefine_line|#define DB(f,a) if (hostdata-&gt;args &amp; (f)) a;
macro_line|#else
DECL|macro|DB
mdefine_line|#define DB(f,a)
macro_line|#endif
DECL|macro|IS_DIR_OUT
mdefine_line|#define IS_DIR_OUT(cmd) ((cmd)-&gt;cmnd[0] == WRITE_6  || &bslash;&n;                         (cmd)-&gt;cmnd[0] == WRITE_10 || &bslash;&n;                         (cmd)-&gt;cmnd[0] == WRITE_12)
multiline_comment|/*&n; * setup_default is a bunch of bits that define some of the operating&n; * parameters and settings for this driver. It is used unless a LILO&n; * or insmod command line has been specified, in which case setup_default&n; * is _completely_ ignored. Take a look at the &quot;defines for hostdata-&gt;args&quot;&n; * section in wd33c93.h - that stuff is what you&squot;d use here if you want&n; * to change the defaults.&n; */
DECL|variable|setup_default
r_static
r_int
r_int
id|setup_default
op_assign
l_int|0
suffix:semicolon
DECL|function|read_wd33c93
r_inline
id|uchar
id|read_wd33c93
c_func
(paren
id|wd33c93_regs
op_star
id|regp
comma
id|uchar
id|reg_num
)paren
(brace
id|regp-&gt;SASR
op_assign
id|reg_num
suffix:semicolon
r_return
id|regp-&gt;SCMD
suffix:semicolon
)brace
DECL|macro|READ_AUX_STAT
mdefine_line|#define READ_AUX_STAT() (regp-&gt;SASR)
DECL|function|write_wd33c93
r_inline
r_void
id|write_wd33c93
c_func
(paren
id|wd33c93_regs
op_star
id|regp
comma
id|uchar
id|reg_num
comma
id|uchar
id|value
)paren
(brace
id|regp-&gt;SASR
op_assign
id|reg_num
suffix:semicolon
id|regp-&gt;SCMD
op_assign
id|value
suffix:semicolon
)brace
DECL|function|write_wd33c93_cmd
r_inline
r_void
id|write_wd33c93_cmd
c_func
(paren
id|wd33c93_regs
op_star
id|regp
comma
id|uchar
id|cmd
)paren
(brace
id|regp-&gt;SASR
op_assign
id|WD_COMMAND
suffix:semicolon
id|regp-&gt;SCMD
op_assign
id|cmd
suffix:semicolon
)brace
DECL|function|read_1_byte
r_inline
id|uchar
id|read_1_byte
c_func
(paren
id|wd33c93_regs
op_star
id|regp
)paren
(brace
id|uchar
id|asr
suffix:semicolon
id|uchar
id|x
op_assign
l_int|0
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_POLLED
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_TRANS_INFO
op_or
l_int|0x80
)paren
suffix:semicolon
r_do
(brace
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asr
op_amp
id|ASR_DBR
)paren
id|x
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_DATA
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|asr
op_amp
id|ASR_INT
)paren
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
DECL|function|write_wd33c93_count
r_void
id|write_wd33c93_count
c_func
(paren
id|wd33c93_regs
op_star
id|regp
comma
r_int
r_int
id|value
)paren
(brace
id|regp-&gt;SASR
op_assign
id|WD_TRANSFER_COUNT_MSB
suffix:semicolon
id|regp-&gt;SCMD
op_assign
id|value
op_rshift
l_int|16
suffix:semicolon
id|regp-&gt;SCMD
op_assign
id|value
op_rshift
l_int|8
suffix:semicolon
id|regp-&gt;SCMD
op_assign
id|value
suffix:semicolon
)brace
DECL|function|read_wd33c93_count
r_int
r_int
id|read_wd33c93_count
c_func
(paren
id|wd33c93_regs
op_star
id|regp
)paren
(brace
r_int
r_int
id|value
suffix:semicolon
id|regp-&gt;SASR
op_assign
id|WD_TRANSFER_COUNT_MSB
suffix:semicolon
id|value
op_assign
id|regp-&gt;SCMD
op_lshift
l_int|16
suffix:semicolon
id|value
op_or_assign
id|regp-&gt;SCMD
op_lshift
l_int|8
suffix:semicolon
id|value
op_or_assign
id|regp-&gt;SCMD
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
DECL|variable|sx_table
r_static
r_struct
id|sx_period
id|sx_table
(braket
)braket
op_assign
(brace
(brace
l_int|1
comma
l_int|0x20
)brace
comma
(brace
l_int|252
comma
l_int|0x20
)brace
comma
(brace
l_int|376
comma
l_int|0x30
)brace
comma
(brace
l_int|500
comma
l_int|0x40
)brace
comma
(brace
l_int|624
comma
l_int|0x50
)brace
comma
(brace
l_int|752
comma
l_int|0x60
)brace
comma
(brace
l_int|876
comma
l_int|0x70
)brace
comma
(brace
l_int|1000
comma
l_int|0x00
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|function|calc_sync_xfer
id|uchar
id|calc_sync_xfer
c_func
(paren
r_int
r_int
id|period
comma
r_int
r_int
id|offset
)paren
(brace
id|uchar
id|result
suffix:semicolon
r_int
id|x
suffix:semicolon
id|period
op_mul_assign
l_int|4
suffix:semicolon
multiline_comment|/* convert SDTR code to ns */
id|result
op_assign
l_int|0x00
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|1
suffix:semicolon
id|sx_table
(braket
id|x
)braket
dot
id|period_ns
suffix:semicolon
id|x
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|period
op_le
id|sx_table
(braket
id|x
op_minus
l_int|0
)braket
dot
id|period_ns
)paren
op_logical_and
(paren
id|period
OG
id|sx_table
(braket
id|x
op_minus
l_int|1
)braket
dot
id|period_ns
)paren
)paren
(brace
id|result
op_assign
id|sx_table
(braket
id|x
)braket
dot
id|reg_value
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|result
op_or_assign
(paren
id|offset
OL
id|OPTIMUM_SX_OFF
)paren
ques
c_cond
id|offset
suffix:colon
id|OPTIMUM_SX_OFF
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_static
r_void
id|wd33c93_execute
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
suffix:semicolon
DECL|function|wd33c93_queuecommand
r_int
id|wd33c93_queuecommand
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|WD33C93_hostdata
op_star
id|hostdata
suffix:semicolon
id|Scsi_Cmnd
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|WD33C93_hostdata
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
id|DB
c_func
(paren
id|DB_QUEUE_COMMAND
comma
id|printk
c_func
(paren
l_string|&quot;Q-%d-%02x-%ld( &quot;
comma
id|cmd-&gt;target
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
id|cmd-&gt;pid
)paren
)paren
multiline_comment|/*&n; * Set up a few fields in the Scsi_Cmnd structure for our own use:&n; *  - host_scribble is the pointer to the next cmd in the input queue&n; *  - scsi_done points to the routine we call when a cmd is finished&n; *  - result is what you&squot;d expect&n; */
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We use the Scsi_Pointer structure that&squot;s included with each command&n; * as a scratchpad (as it&squot;s intended to be used!). The handy thing about&n; * the SCp.xxx fields is that they&squot;re always associated with a given&n; * cmd, and are preserved across disconnect-reselect. This means we&n; * can pretty much ignore SAVE_POINTERS and RESTORE_POINTERS messages&n; * if we keep all the critical pointers and counters in SCp:&n; *  - SCp.ptr is the pointer into the RAM buffer&n; *  - SCp.this_residual is the size of that buffer&n; *  - SCp.buffer points to the current scatter-gather buffer&n; *  - SCp.buffers_residual tells us how many S.G. buffers there are&n; */
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
id|cmd-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
id|cmd-&gt;SCp.buffers_residual
op_assign
id|cmd-&gt;use_sg
op_minus
l_int|1
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|cmd-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
r_else
(brace
id|cmd-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.buffers_residual
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
)brace
multiline_comment|/* Preset the command status to GOOD, since that&squot;s the normal case */
id|cmd-&gt;SCp.Status
op_assign
id|GOOD
suffix:semicolon
multiline_comment|/*&n;    * Add the cmd to the end of &squot;input_Q&squot;. Note that REQUEST SENSE&n;    * commands are added to the head of the queue so that the desired&n;    * sense data is not lost before REQUEST_SENSE executes.&n;    */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;input_Q
)paren
op_logical_or
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
)paren
(brace
id|cmd-&gt;host_scribble
op_assign
(paren
id|uchar
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|hostdata-&gt;input_Q
op_assign
id|cmd
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|tmp-&gt;host_scribble
suffix:semicolon
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
suffix:semicolon
id|tmp-&gt;host_scribble
op_assign
(paren
id|uchar
op_star
)paren
id|cmd
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* We know that there&squot;s at least one command in &squot;input_Q&squot; now.&n; * Go see if any of them are runnable!&n; */
id|wd33c93_execute
c_func
(paren
id|cmd-&gt;host
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_QUEUE_COMMAND
comma
id|printk
c_func
(paren
l_string|&quot;)Q-%d-%02x-%ld &quot;
comma
id|cmd-&gt;target
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
id|cmd-&gt;pid
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine attempts to start a scsi command. If the host_card is&n; * already connected, we give up immediately. Otherwise, look through&n; * the input_Q, using the first command we find that&squot;s intended&n; * for a currently non-busy target/lun.&n; */
DECL|function|wd33c93_execute
r_static
r_void
id|wd33c93_execute
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
r_struct
id|WD33C93_hostdata
op_star
id|hostdata
suffix:semicolon
id|wd33c93_regs
op_star
id|regp
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
comma
op_star
id|prev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|WD33C93_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|regp
op_assign
id|hostdata-&gt;regp
suffix:semicolon
id|DB
c_func
(paren
id|DB_EXECUTE
comma
id|printk
c_func
(paren
l_string|&quot;EX( &quot;
)paren
)paren
r_if
c_cond
(paren
id|hostdata-&gt;selecting
op_logical_or
id|hostdata-&gt;connected
)paren
(brace
id|DB
c_func
(paren
id|DB_EXECUTE
comma
id|printk
c_func
(paren
l_string|&quot;)EX-0 &quot;
)paren
)paren
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;     * Search through the input_Q for a command destined&n;     * for an idle target/lun.&n;     */
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|prev
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cmd
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_amp
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
)paren
)paren
r_break
suffix:semicolon
id|prev
op_assign
id|cmd
suffix:semicolon
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
)brace
multiline_comment|/* quit if queue empty or all possible targets are busy */
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
(brace
id|DB
c_func
(paren
id|DB_EXECUTE
comma
id|printk
c_func
(paren
l_string|&quot;)EX-1 &quot;
)paren
)paren
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*  remove command from queue, put it in selecting */
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;host_scribble
op_assign
id|cmd-&gt;host_scribble
suffix:semicolon
r_else
id|hostdata-&gt;input_Q
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
id|hostdata-&gt;selecting
op_assign
id|cmd
suffix:semicolon
multiline_comment|/*&n;    * Start the selection process&n;    */
r_if
c_cond
(paren
id|IS_DIR_OUT
c_func
(paren
id|cmd
)paren
)paren
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_DESTINATION_ID
comma
id|cmd-&gt;target
)paren
suffix:semicolon
r_else
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_DESTINATION_ID
comma
id|cmd-&gt;target
op_or
id|DSTID_DPD
)paren
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_TARGET_LUN
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_POLLED
)paren
suffix:semicolon
id|write_wd33c93_count
c_func
(paren
id|regp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* this guarantees a DATA_PHASE interrupt */
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_or_assign
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hostdata-&gt;level2
op_eq
id|L2_NONE
)paren
op_logical_or
(paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_eq
id|SS_UNSET
)paren
)paren
(brace
multiline_comment|/*&n;          * Now do a &squot;Select-With-ATN&squot; command. This will end with&n;          * one of the following interrupts:&n;          *    CSR_RESEL_AM:  failure - can try again later.&n;          *    CSR_TIMEOUT:   failure - give up.&n;          *    CSR_SELECT:    success - proceed.&n;          */
multiline_comment|/* Every target has its own synchronous transfer setting, kept in the&n; * sync_xfer array, and a corresponding status byte in sync_stat[].&n; * Each target&squot;s sync_stat[] entry is initialized to SX_UNSET, and its&n; * sync_xfer[] entry is initialized to the default/safe value. SS_UNSET&n; * means that the parameters are undetermined as yet, and that we&n; * need to send an SDTR message to this device after selection is&n; * complete. We set SS_FIRST to tell the interrupt routine to do so,&n; * unless we&squot;ve been asked not to try synchronous transfers on this&n; * target (and _all_ luns within it): In this case we set SS_SET to&n; * make the defaults final.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_eq
id|SS_UNSET
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;args
op_amp
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
)paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_assign
id|SS_SET
suffix:semicolon
r_else
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_assign
id|SS_FIRST
suffix:semicolon
)brace
id|hostdata-&gt;state
op_assign
id|S_SELECTING
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_SEL_ATN
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;          * Now do a &squot;Select-With-ATN-Xfer&squot; command. This will end with&n;          * one of the following interrupts:&n;          *    CSR_RESEL_AM:  failure - can try again later.&n;          *    CSR_TIMEOUT:   failure - give up.&n;          *    anything else: success - proceed.&n;          */
id|hostdata-&gt;connected
op_assign
id|cmd
suffix:semicolon
id|hostdata-&gt;selecting
op_assign
l_int|NULL
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_COMMAND_PHASE
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* copy command_descriptor_block into WD chip */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cmd-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_CDB_1
op_plus
id|i
comma
id|cmd-&gt;cmnd
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* The wd33c93 only knows about Group 0, 1, and 5 commands when&n;    * it&squot;s doing a &squot;select-and-transfer&squot;. To be safe, we write the&n;    * size of the CDB into the OWN_ID register for every case. This&n;    * way there won&squot;t be problems with vendor-unique, audio, etc.&n;    */
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_OWN_ID
comma
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    * Since the SCSI bus can handle only 1 connection at a time,&n;    * we get out of here now. If the selection fails, or when&n;    * the command disconnects, we&squot;ll come back to this routine&n;    * to search the input_Q again...&n;    */
id|DB
c_func
(paren
id|DB_EXECUTE
comma
id|printk
c_func
(paren
l_string|&quot;)EX-2 &quot;
)paren
)paren
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|transfer_pio
r_void
id|transfer_pio
c_func
(paren
id|wd33c93_regs
op_star
id|regp
comma
id|uchar
op_star
op_star
id|buf
comma
r_int
op_star
id|cnt
comma
r_int
id|data_in_dir
comma
r_struct
id|WD33C93_hostdata
op_star
id|hostdata
)paren
(brace
id|uchar
op_star
id|b
comma
id|asr
suffix:semicolon
r_int
id|c
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_POLLED
)paren
suffix:semicolon
id|b
op_assign
op_star
id|buf
suffix:semicolon
id|c
op_assign
op_star
id|cnt
suffix:semicolon
id|DB
c_func
(paren
id|DB_TRANSFER_DATA
comma
id|printk
c_func
(paren
l_string|&quot;[[%p/%d]]&quot;
comma
id|b
comma
id|c
)paren
)paren
id|write_wd33c93_count
c_func
(paren
id|regp
comma
id|c
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_TRANS_INFO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_in_dir
)paren
(brace
r_do
(brace
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asr
op_amp
id|ASR_DBR
)paren
op_star
id|b
op_increment
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_DATA
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|asr
op_amp
id|ASR_INT
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_do
(brace
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asr
op_amp
id|ASR_DBR
)paren
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_DATA
comma
op_star
id|b
op_increment
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|asr
op_amp
id|ASR_INT
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* update original buffer pointer and original count */
op_star
id|cnt
op_assign
id|read_wd33c93_count
c_func
(paren
id|regp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_in_dir
)paren
op_star
id|buf
op_assign
id|b
suffix:semicolon
r_else
op_star
id|buf
op_add_assign
(paren
id|c
op_minus
op_star
id|cnt
)paren
suffix:semicolon
multiline_comment|/* Note: we are returning with the interrupt UN-cleared.&n;   * Since (presumably) an entire I/O operation has&n;   * completed, the bus phase is probably different, and&n;   * the interrupt routine will discover this when it&n;   * responds to the uncleared int.&n;   */
)brace
DECL|function|transfer_bytes
r_void
id|transfer_bytes
c_func
(paren
id|wd33c93_regs
op_star
id|regp
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|data_in_dir
)paren
(brace
r_struct
id|WD33C93_hostdata
op_star
id|hostdata
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|WD33C93_hostdata
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
multiline_comment|/* Normally, you&squot;d expect &squot;this_residual&squot; to be non-zero here.&n; * In a series of scatter-gather transfers, however, this&n; * routine will usually be called with &squot;this_residual&squot; equal&n; * to 0 and &squot;buffers_residual&squot; non-zero. This means that a&n; * previous transfer completed, clearing &squot;this_residual&squot;, and&n; * now we need to setup the next scatter-gather buffer as the&n; * source or destination for THIS transfer.&n; */
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;SCp.this_residual
op_logical_and
id|cmd-&gt;SCp.buffers_residual
)paren
(brace
op_increment
id|cmd-&gt;SCp.buffer
suffix:semicolon
op_decrement
id|cmd-&gt;SCp.buffers_residual
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
id|cmd-&gt;SCp.buffer-&gt;address
suffix:semicolon
)brace
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_SYNCHRONOUS_TRANSFER
comma
id|hostdata-&gt;sync_xfer
(braket
id|cmd-&gt;target
)braket
)paren
suffix:semicolon
multiline_comment|/* &squot;dma_setup()&squot; will return TRUE if we can&squot;t do DMA. */
r_if
c_cond
(paren
id|hostdata
op_member_access_from_pointer
id|dma_setup
c_func
(paren
id|cmd
comma
id|data_in_dir
)paren
)paren
(brace
id|transfer_pio
c_func
(paren
id|regp
comma
(paren
id|uchar
op_star
op_star
)paren
op_amp
id|cmd-&gt;SCp.ptr
comma
op_amp
id|cmd-&gt;SCp.this_residual
comma
id|data_in_dir
comma
id|hostdata
)paren
suffix:semicolon
)brace
multiline_comment|/* We are able to do DMA (in fact, the Amiga hardware is&n; * already going!), so start up the wd33c93 in DMA mode.&n; * We set &squot;hostdata-&gt;dma&squot; = D_DMA_RUNNING so that when the&n; * transfer completes and causes an interrupt, we&squot;re&n; * reminded to tell the Amiga to shut down its end. We&squot;ll&n; * postpone the updating of &squot;this_residual&squot; and &squot;ptr&squot;&n; * until then.&n; */
r_else
(brace
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_DMA
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_TRANSFER_DATA
comma
id|printk
c_func
(paren
l_string|&quot;[%p/%d]&quot;
comma
id|cmd-&gt;SCp.ptr
comma
id|cmd-&gt;SCp.this_residual
)paren
)paren
id|write_wd33c93_count
c_func
(paren
id|regp
comma
id|cmd-&gt;SCp.this_residual
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;level2
op_ge
id|L2_DATA
)paren
(brace
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_COMMAND_PHASE
comma
l_int|0x41
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
)brace
r_else
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_TRANS_INFO
)paren
suffix:semicolon
id|hostdata-&gt;dma
op_assign
id|D_DMA_RUNNING
suffix:semicolon
)brace
)brace
DECL|function|wd33c93_intr
r_void
id|wd33c93_intr
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
r_struct
id|WD33C93_hostdata
op_star
id|hostdata
suffix:semicolon
id|Scsi_Cmnd
op_star
id|patch
comma
op_star
id|cmd
suffix:semicolon
id|wd33c93_regs
op_star
id|regp
suffix:semicolon
id|uchar
id|asr
comma
id|sr
comma
id|phs
comma
id|id
comma
id|lun
comma
op_star
id|ucp
comma
id|msg
suffix:semicolon
r_int
r_int
id|length
suffix:semicolon
r_int
id|i
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|WD33C93_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|regp
op_assign
id|hostdata-&gt;regp
suffix:semicolon
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|asr
op_amp
id|ASR_INT
)paren
op_logical_or
(paren
id|asr
op_amp
id|ASR_BSY
)paren
)paren
r_return
suffix:semicolon
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;connected
suffix:semicolon
multiline_comment|/* assume we&squot;re connected */
id|sr
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
multiline_comment|/* clear the interrupt */
id|phs
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_COMMAND_PHASE
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;{%02x:%02x-&quot;
comma
id|asr
comma
id|sr
)paren
)paren
multiline_comment|/* After starting a DMA transfer, the next interrupt&n; * is guaranteed to be in response to completion of&n; * the transfer. Since the Amiga DMA hardware runs in&n; * in an open-ended fashion, it needs to be told when&n; * to stop; do that here if D_DMA_RUNNING is true.&n; * Also, we have to update &squot;this_residual&squot; and &squot;ptr&squot;&n; * based on the contents of the TRANSFER_COUNT register,&n; * in case the device decided to do an intermediate&n; * disconnect (a device may do this if it has to do a&n; * seek, or just to be nice and let other devices have&n; * some bus time during long transfers). After doing&n; * whatever is needed, we go on and service the WD3393&n; * interrupt normally.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;dma
op_eq
id|D_DMA_RUNNING
)paren
(brace
id|DB
c_func
(paren
id|DB_TRANSFER_DATA
comma
id|printk
c_func
(paren
l_string|&quot;[%p/%d:&quot;
comma
id|cmd-&gt;SCp.ptr
comma
id|cmd-&gt;SCp.this_residual
)paren
)paren
id|hostdata
op_member_access_from_pointer
id|dma_stop
c_func
(paren
id|cmd-&gt;host
comma
id|cmd
comma
l_int|1
)paren
suffix:semicolon
id|hostdata-&gt;dma
op_assign
id|D_DMA_OFF
suffix:semicolon
id|length
op_assign
id|cmd-&gt;SCp.this_residual
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|read_wd33c93_count
c_func
(paren
id|regp
)paren
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_add_assign
(paren
id|length
op_minus
id|cmd-&gt;SCp.this_residual
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_TRANSFER_DATA
comma
id|printk
c_func
(paren
l_string|&quot;%p/%d]&quot;
comma
id|cmd-&gt;SCp.ptr
comma
id|cmd-&gt;SCp.this_residual
)paren
)paren
)brace
multiline_comment|/* Respond to the specific WD3393 interrupt - there are quite a few! */
r_switch
c_cond
(paren
id|sr
)paren
(brace
r_case
id|CSR_TIMEOUT
suffix:colon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;TIMEOUT&quot;
)paren
)paren
r_if
c_cond
(paren
id|hostdata-&gt;state
op_eq
id|S_RUNNING_LEVEL2
)paren
(brace
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
)brace
r_else
(brace
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;selecting
suffix:semicolon
multiline_comment|/* get a valid cmd */
id|hostdata-&gt;selecting
op_assign
l_int|NULL
suffix:semicolon
)brace
id|cmd-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|hostdata-&gt;selecting
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/* I think scsi_done() enables ints */
multiline_comment|/* We are not connected to a target - check to see if there&n; * are commands waiting to be executed.&n; */
id|wd33c93_execute
c_func
(paren
id|instance
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Note: this interrupt should not occur in a LEVEL2 command */
r_case
id|CSR_SELECT
suffix:colon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;SELECT&quot;
)paren
)paren
id|hostdata-&gt;connected
op_assign
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;selecting
suffix:semicolon
id|hostdata-&gt;selecting
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* construct an IDENTIFY message with correct disconnect bit */
r_if
c_cond
(paren
id|hostdata-&gt;args
op_amp
id|A_NO_DISCONNECT
)paren
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_assign
(paren
l_int|0x80
op_or
id|cmd-&gt;lun
)paren
suffix:semicolon
r_else
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_assign
(paren
l_int|0x80
op_or
l_int|0x40
op_or
id|cmd-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_eq
id|SS_FIRST
)paren
(brace
macro_line|#ifdef SYNC_DEBUG
id|printk
c_func
(paren
l_string|&quot; sending SDTR &quot;
)paren
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_assign
id|SS_WAITING
suffix:semicolon
multiline_comment|/* tack on a 2nd message to ask about synchronous transfers */
id|hostdata-&gt;outgoing_msg
(braket
l_int|1
)braket
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|2
)braket
op_assign
l_int|3
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|3
)braket
op_assign
id|EXTENDED_SDTR
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|4
)braket
op_assign
id|OPTIMUM_SX_PER
op_div
l_int|4
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|5
)braket
op_assign
id|OPTIMUM_SX_OFF
suffix:semicolon
id|hostdata-&gt;outgoing_len
op_assign
l_int|6
suffix:semicolon
)brace
r_else
id|hostdata-&gt;outgoing_len
op_assign
l_int|1
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_XFER_DONE
op_or
id|PHS_DATA_IN
suffix:colon
r_case
id|CSR_UNEXP
op_or
id|PHS_DATA_IN
suffix:colon
r_case
id|CSR_SRV_REQ
op_or
id|PHS_DATA_IN
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;IN-%d.%d&quot;
comma
id|cmd-&gt;SCp.this_residual
comma
id|cmd-&gt;SCp.buffers_residual
)paren
)paren
id|transfer_bytes
c_func
(paren
id|regp
comma
id|cmd
comma
id|DATA_IN_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;state
op_ne
id|S_RUNNING_LEVEL2
)paren
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_XFER_DONE
op_or
id|PHS_DATA_OUT
suffix:colon
r_case
id|CSR_UNEXP
op_or
id|PHS_DATA_OUT
suffix:colon
r_case
id|CSR_SRV_REQ
op_or
id|PHS_DATA_OUT
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;OUT-%d.%d&quot;
comma
id|cmd-&gt;SCp.this_residual
comma
id|cmd-&gt;SCp.buffers_residual
)paren
)paren
id|transfer_bytes
c_func
(paren
id|regp
comma
id|cmd
comma
id|DATA_OUT_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;state
op_ne
id|S_RUNNING_LEVEL2
)paren
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Note: this interrupt should not occur in a LEVEL2 command */
r_case
id|CSR_XFER_DONE
op_or
id|PHS_COMMAND
suffix:colon
r_case
id|CSR_SRV_REQ
op_or
id|PHS_COMMAND
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;CMND-%02x,%ld&quot;
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
id|cmd-&gt;pid
)paren
)paren
id|ucp
op_assign
id|cmd-&gt;cmnd
suffix:semicolon
id|i
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|transfer_pio
c_func
(paren
id|regp
comma
op_amp
id|ucp
comma
op_amp
id|i
comma
id|DATA_OUT_DIR
comma
id|hostdata
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_XFER_DONE
op_or
id|PHS_STATUS
suffix:colon
r_case
id|CSR_UNEXP
op_or
id|PHS_STATUS
suffix:colon
r_case
id|CSR_SRV_REQ
op_or
id|PHS_STATUS
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;STATUS&quot;
)paren
)paren
id|cmd-&gt;SCp.Status
op_assign
id|read_1_byte
c_func
(paren
id|regp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;level2
op_ge
id|L2_BASIC
)paren
(brace
id|sr
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
multiline_comment|/* clear interrupt */
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_COMMAND_PHASE
comma
l_int|0x50
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
)brace
r_else
(brace
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;=%02x&quot;
comma
id|cmd-&gt;SCp.Status
)paren
)paren
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CSR_XFER_DONE
op_or
id|PHS_MESS_IN
suffix:colon
r_case
id|CSR_UNEXP
op_or
id|PHS_MESS_IN
suffix:colon
r_case
id|CSR_SRV_REQ
op_or
id|PHS_MESS_IN
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;MSG_IN=&quot;
)paren
)paren
id|msg
op_assign
id|read_1_byte
c_func
(paren
id|regp
)paren
suffix:semicolon
id|sr
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
multiline_comment|/* clear interrupt */
id|hostdata-&gt;incoming_msg
(braket
id|hostdata-&gt;incoming_ptr
)braket
op_assign
id|msg
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;incoming_msg
(braket
l_int|0
)braket
op_eq
id|EXTENDED_MESSAGE
)paren
id|msg
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
r_else
id|hostdata-&gt;incoming_ptr
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.Message
op_assign
id|msg
suffix:semicolon
r_switch
c_cond
(paren
id|msg
)paren
(brace
r_case
id|COMMAND_COMPLETE
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;CCMP-%ld&quot;
comma
id|cmd-&gt;pid
)paren
)paren
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_PRE_CMP_DISC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SAVE_POINTERS
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;SDP&quot;
)paren
)paren
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESTORE_POINTERS
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;RDP&quot;
)paren
)paren
r_if
c_cond
(paren
id|hostdata-&gt;level2
op_ge
id|L2_BASIC
)paren
(brace
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_COMMAND_PHASE
comma
l_int|0x45
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
)brace
r_else
(brace
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DISCONNECT
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;DIS&quot;
)paren
)paren
id|cmd-&gt;device-&gt;disconnect
op_assign
l_int|1
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_PRE_TMP_DISC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MESSAGE_REJECT
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;REJ&quot;
)paren
)paren
macro_line|#ifdef SYNC_DEBUG
id|printk
c_func
(paren
l_string|&quot;-REJ-&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_eq
id|SS_WAITING
)paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_assign
id|SS_SET
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EXTENDED_MESSAGE
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;EXT&quot;
)paren
)paren
id|ucp
op_assign
id|hostdata-&gt;incoming_msg
suffix:semicolon
macro_line|#ifdef SYNC_DEBUG
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
id|ucp
(braket
id|hostdata-&gt;incoming_ptr
)braket
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Is this the last byte of the extended message? */
r_if
c_cond
(paren
(paren
id|hostdata-&gt;incoming_ptr
op_ge
l_int|2
)paren
op_logical_and
(paren
id|hostdata-&gt;incoming_ptr
op_eq
(paren
id|ucp
(braket
l_int|1
)braket
op_plus
l_int|1
)paren
)paren
)paren
(brace
r_switch
c_cond
(paren
id|ucp
(braket
l_int|2
)braket
)paren
(brace
multiline_comment|/* what&squot;s the EXTENDED code? */
r_case
id|EXTENDED_SDTR
suffix:colon
id|id
op_assign
id|calc_sync_xfer
c_func
(paren
id|ucp
(braket
l_int|3
)braket
comma
id|ucp
(braket
l_int|4
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_ne
id|SS_WAITING
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Rejecting target&squot;s SDTR message &quot;
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_ASSERT_ATN
)paren
suffix:semicolon
multiline_comment|/* want MESS_OUT */
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_assign
id|MESSAGE_REJECT
suffix:semicolon
id|hostdata-&gt;outgoing_len
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|hostdata-&gt;sync_xfer
(braket
id|cmd-&gt;target
)braket
op_assign
id|id
suffix:semicolon
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_assign
id|SS_SET
suffix:semicolon
)brace
macro_line|#ifdef SYNC_DEBUG
id|printk
c_func
(paren
l_string|&quot;sync_xfer=%02x&quot;
comma
id|id
)paren
suffix:semicolon
macro_line|#endif
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Rejecting Unknown Extended Message(%02x). &quot;
comma
id|ucp
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_ASSERT_ATN
)paren
suffix:semicolon
multiline_comment|/* want MESS_OUT */
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_assign
id|MESSAGE_REJECT
suffix:semicolon
id|hostdata-&gt;outgoing_len
op_assign
l_int|1
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hostdata-&gt;incoming_ptr
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We need to read more MESS_IN bytes for the extended message */
r_else
(brace
id|hostdata-&gt;incoming_ptr
op_increment
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Rejecting Unknown Message(%02x) &quot;
comma
id|ucp
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_ASSERT_ATN
)paren
suffix:semicolon
multiline_comment|/* want MESS_OUT */
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_assign
id|MESSAGE_REJECT
suffix:semicolon
id|hostdata-&gt;outgoing_len
op_assign
l_int|1
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* Note: this interrupt will occur only after a LEVEL2 command */
r_case
id|CSR_SEL_XFER_DONE
suffix:colon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|phs
op_eq
l_int|0x60
)paren
(brace
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;SX-DONE-%ld&quot;
comma
id|cmd-&gt;pid
)paren
)paren
id|cmd-&gt;SCp.Message
op_assign
id|COMMAND_COMPLETE
suffix:semicolon
id|lun
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_TARGET_LUN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;SCp.Status
op_eq
id|GOOD
)paren
id|cmd-&gt;SCp.Status
op_assign
id|lun
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|REQUEST_SENSE
)paren
id|cmd-&gt;result
op_assign
id|cmd-&gt;SCp.Status
op_or
(paren
id|cmd-&gt;SCp.Message
op_lshift
l_int|8
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd-&gt;SCp.Status
op_ne
id|GOOD
)paren
id|cmd-&gt;result
op_assign
(paren
id|cmd-&gt;result
op_amp
l_int|0x00ffff
)paren
op_or
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/* I think scsi_done() enables ints */
multiline_comment|/* We are no longer  connected to a target - check to see if&n; * there are commands waiting to be executed.&n; */
id|wd33c93_execute
c_func
(paren
id|instance
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%02x:%02x:%02x-%ld: Unknown SEL_XFER_DONE phase!!---&quot;
comma
id|asr
comma
id|sr
comma
id|phs
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* Note: this interrupt will occur only after a LEVEL2 command */
r_case
id|CSR_SDP
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;SDP&quot;
)paren
)paren
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_COMMAND_PHASE
comma
l_int|0x41
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_XFER_DONE
op_or
id|PHS_MESS_OUT
suffix:colon
r_case
id|CSR_UNEXP
op_or
id|PHS_MESS_OUT
suffix:colon
r_case
id|CSR_SRV_REQ
op_or
id|PHS_MESS_OUT
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;MSG_OUT=&quot;
)paren
)paren
multiline_comment|/* To get here, we&squot;ve probably requested MESSAGE_OUT and have&n; * already put the correct bytes in outgoing_msg[] and filled&n; * in outgoing_len. We simply send them out to the SCSI bus.&n; * Sometimes we get MESSAGE_OUT phase when we&squot;re not expecting&n; * it - like when our SDTR message is rejected by a target. Some&n; * targets send the REJECT before receiving all of the extended&n; * message, and then seem to go back to MESSAGE_OUT for a byte&n; * or two. Not sure why, ot if I&squot;m doing something wrong to&n; * casue this to happen. Regardless, it seems that sending&n; * NOP messages in these situations results in no harm and&n; * makes everyone happy.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;outgoing_len
op_eq
l_int|0
)paren
(brace
id|hostdata-&gt;outgoing_len
op_assign
l_int|1
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_assign
id|NOP
suffix:semicolon
)brace
id|ucp
op_assign
id|hostdata-&gt;outgoing_msg
suffix:semicolon
id|i
op_assign
id|hostdata-&gt;outgoing_len
suffix:semicolon
id|transfer_pio
c_func
(paren
id|regp
comma
op_amp
id|ucp
comma
op_amp
id|i
comma
id|DATA_OUT_DIR
comma
id|hostdata
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
)paren
)paren
id|hostdata-&gt;outgoing_len
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_DISC
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;DISC&quot;
)paren
)paren
r_if
c_cond
(paren
id|cmd
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; - Already disconnected! &quot;
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
r_return
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|hostdata-&gt;state
)paren
(brace
r_case
id|S_PRE_CMP_DISC
suffix:colon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|REQUEST_SENSE
)paren
id|cmd-&gt;result
op_assign
id|cmd-&gt;SCp.Status
op_or
(paren
id|cmd-&gt;SCp.Message
op_lshift
l_int|8
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd-&gt;SCp.Status
op_ne
id|GOOD
)paren
id|cmd-&gt;result
op_assign
(paren
id|cmd-&gt;result
op_amp
l_int|0x00ffff
)paren
op_or
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/* I think scsi_done() enables ints */
r_break
suffix:semicolon
r_case
id|S_PRE_TMP_DISC
suffix:colon
r_case
id|S_RUNNING_LEVEL2
suffix:colon
id|cmd-&gt;host_scribble
op_assign
(paren
id|uchar
op_star
)paren
id|hostdata-&gt;disconnected_Q
suffix:semicolon
id|hostdata-&gt;disconnected_Q
op_assign
id|cmd
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;*** Unexpected DISCONNECT interrupt! ***&quot;
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
)brace
multiline_comment|/* We are no longer connected to a target - check to see if&n; * there are commands waiting to be executed.&n; */
id|wd33c93_execute
c_func
(paren
id|instance
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_RESEL_AM
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;RESEL&quot;
)paren
)paren
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* First we have to make sure this reselection didn&squot;t */
multiline_comment|/* happen during Arbitration/Selection of some other device. */
multiline_comment|/* If yes, put losing command back on top of input_Q. */
r_if
c_cond
(paren
id|hostdata-&gt;level2
op_eq
id|L2_NONE
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;selecting
)paren
(brace
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;selecting
suffix:semicolon
id|hostdata-&gt;selecting
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
(paren
id|uchar
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|hostdata-&gt;input_Q
op_assign
id|cmd
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|phs
op_eq
l_int|0x00
)paren
(brace
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
(paren
id|uchar
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|hostdata-&gt;input_Q
op_assign
id|cmd
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;---%02x:%02x:%02x-TROUBLE: Intrusive ReSelect!---&quot;
comma
id|asr
comma
id|sr
comma
id|phs
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;r&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* OK - find out which device reslected us. */
id|id
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_SOURCE_ID
)paren
suffix:semicolon
id|id
op_and_assign
id|SRCID_MASK
suffix:semicolon
multiline_comment|/* and extract the lun from the ID message. (Note that we don&squot;t&n;    * bother to check for a valid message here - I guess this is&n;    * not the right way to go, but...)&n;    */
id|lun
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;level2
OL
id|L2_RESELECT
)paren
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|lun
op_and_assign
l_int|7
suffix:semicolon
multiline_comment|/* Now we look for the command that&squot;s reconnecting. */
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_Q
suffix:semicolon
id|patch
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|id
op_eq
id|cmd-&gt;target
op_logical_and
id|lun
op_eq
id|cmd-&gt;lun
)paren
r_break
suffix:semicolon
id|patch
op_assign
id|cmd
suffix:semicolon
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
)brace
multiline_comment|/* Hmm. Couldn&squot;t find a valid command.... What to do? */
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;---TROUBLE: target %d.%d not in disconnect queue---&quot;
comma
id|id
comma
id|lun
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Ok, found the command - now start it up again. */
r_if
c_cond
(paren
id|patch
)paren
id|patch-&gt;host_scribble
op_assign
id|cmd-&gt;host_scribble
suffix:semicolon
r_else
id|hostdata-&gt;disconnected_Q
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
id|hostdata-&gt;connected
op_assign
id|cmd
suffix:semicolon
multiline_comment|/* We don&squot;t need to worry about &squot;initialize_SCp()&squot; or &squot;hostdata-&gt;busy[]&squot;&n;    * because these things are preserved over a disconnect.&n;    * But we DO need to fix the DPD bit so it&squot;s correct for this command.&n;    */
r_if
c_cond
(paren
id|IS_DIR_OUT
c_func
(paren
id|cmd
)paren
)paren
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_DESTINATION_ID
comma
id|cmd-&gt;target
)paren
suffix:semicolon
r_else
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_DESTINATION_ID
comma
id|cmd-&gt;target
op_or
id|DSTID_DPD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;level2
op_ge
id|L2_RESELECT
)paren
(brace
id|write_wd33c93_count
c_func
(paren
id|regp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* we want a DATA_PHASE interrupt */
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_COMMAND_PHASE
comma
l_int|0x45
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
)brace
r_else
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;-%ld&quot;
comma
id|cmd-&gt;pid
)paren
)paren
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;&bslash;n---UNKNOWN INTERRUPT:%02x:%02x:%02x!!---&quot;
comma
id|asr
comma
id|sr
comma
id|phs
)paren
suffix:semicolon
)brace
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;} &quot;
)paren
)paren
)brace
DECL|function|reset_wd33c93
r_void
id|reset_wd33c93
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
r_struct
id|WD33C93_hostdata
op_star
id|hostdata
suffix:semicolon
id|wd33c93_regs
op_star
id|regp
suffix:semicolon
id|uchar
id|sr
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|WD33C93_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|regp
op_assign
id|hostdata-&gt;regp
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_OWN_ID
comma
id|OWNID_EAF
op_or
id|OWNID_RAF
op_or
id|instance-&gt;this_id
op_or
id|hostdata-&gt;clock_freq
)paren
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_POLLED
)paren
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_SYNCHRONOUS_TRANSFER
comma
id|calc_sync_xfer
c_func
(paren
id|DEFAULT_SX_PER
op_div
l_int|4
comma
id|DEFAULT_SX_OFF
)paren
)paren
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_COMMAND
comma
id|WD_CMD_RESET
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|READ_AUX_STAT
c_func
(paren
)paren
op_amp
id|ASR_INT
)paren
)paren
suffix:semicolon
id|sr
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
id|hostdata-&gt;microcode
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_CDB_1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sr
op_eq
l_int|0x00
)paren
id|hostdata-&gt;chip
op_assign
id|C_WD33C93
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sr
op_eq
l_int|0x01
)paren
(brace
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_QUEUE_TAG
comma
l_int|0xa5
)paren
suffix:semicolon
multiline_comment|/* any random number */
id|sr
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_QUEUE_TAG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sr
op_eq
l_int|0xa5
)paren
(brace
id|hostdata-&gt;chip
op_assign
id|C_WD33C93B
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_QUEUE_TAG
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|hostdata-&gt;chip
op_assign
id|C_WD33C93A
suffix:semicolon
)brace
r_else
id|hostdata-&gt;chip
op_assign
id|C_UNKNOWN_CHIP
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_TIMEOUT_PERIOD
comma
id|TIMEOUT_PERIOD_VALUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;args
op_amp
id|A_NO_DISCONNECT
)paren
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_SOURCE_ID
comma
l_int|0
)paren
suffix:semicolon
r_else
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_SOURCE_ID
comma
id|SRCID_ER
)paren
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_POLLED
)paren
suffix:semicolon
)brace
DECL|function|wd33c93_reset
r_int
id|wd33c93_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
id|instance
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d: reset. &quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
(paren
(paren
r_struct
id|WD33C93_hostdata
op_star
)paren
id|instance-&gt;hostdata
)paren
op_member_access_from_pointer
id|dma_stop
c_func
(paren
id|instance
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|reset_wd33c93
c_func
(paren
id|instance
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|wd33c93_abort
r_int
id|wd33c93_abort
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_struct
id|WD33C93_hostdata
op_star
id|hostdata
suffix:semicolon
id|wd33c93_regs
op_star
id|regp
suffix:semicolon
id|Scsi_Cmnd
op_star
id|tmp
comma
op_star
op_star
id|prev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|instance
op_assign
id|cmd-&gt;host
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|WD33C93_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|regp
op_assign
id|hostdata-&gt;regp
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d: abort. &quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n; * Case 1 : If the command hasn&squot;t been issued yet, we simply remove it&n; *     from the issue queue.&n; */
r_for
c_loop
(paren
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
id|hostdata-&gt;input_Q
)paren
comma
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|tmp
suffix:semicolon
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
id|tmp-&gt;host_scribble
)paren
comma
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
r_if
c_cond
(paren
id|cmd
op_eq
id|tmp
)paren
(brace
(paren
op_star
id|prev
)paren
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
suffix:semicolon
id|tmp-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : abort removed command from issue queue. &quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|tmp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Case 2 : If any commands are connected, we&squot;re going to fail the abort&n; *     and let the high level SCSI driver retry at a later time or&n; *     issue a reset.&n; *&n; *     Timeouts, and therefore aborted commands, will be highly unlikely&n; *     and handling them cleanly in this situation would make the common&n; *     case of noresets less efficient, and would pollute our code.  So,&n; *     we fail.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;connected
op_eq
id|cmd
)paren
(brace
id|uchar
id|sr
comma
id|asr
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : aborting connected command. &quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;dma
op_eq
id|D_DMA_RUNNING
)paren
(brace
id|hostdata
op_member_access_from_pointer
id|dma_stop
c_func
(paren
id|instance
comma
id|cmd
comma
l_int|0
)paren
suffix:semicolon
id|hostdata-&gt;dma
op_assign
id|D_DMA_OFF
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : wd33c93 asr is %x. &quot;
comma
id|instance-&gt;host_no
comma
id|READ_AUX_STAT
c_func
(paren
)paren
)paren
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_POLLED
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_ABORT
)paren
suffix:semicolon
multiline_comment|/* Now we have to attempt to flush out the FIFO... */
id|timeout
op_assign
l_int|1000000
suffix:semicolon
r_do
(brace
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asr
op_amp
id|ASR_DBR
)paren
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_DATA
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|asr
op_amp
id|ASR_INT
)paren
op_logical_and
id|timeout
op_decrement
OG
l_int|0
)paren
suffix:semicolon
id|sr
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : wd33c93 sr is %x. &quot;
comma
id|instance-&gt;host_no
comma
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_SCSI_STATUS
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sr
op_ge
(paren
id|CSR_ABORT
op_or
id|PHS_DATA_OUT
)paren
op_logical_and
id|sr
op_le
(paren
id|CSR_ABORT
op_or
id|PHS_MESS_IN
)paren
)paren
(brace
multiline_comment|/*&n;    * Abort command processed.&n;    * Still connected.&n;    * We must disconnect.&n;    */
id|printk
c_func
(paren
l_string|&quot;scsi%d : count was %ld. &quot;
comma
id|instance-&gt;host_no
comma
id|read_wd33c93_count
c_func
(paren
id|regp
)paren
)paren
suffix:semicolon
id|timeout
op_assign
l_int|1000000
suffix:semicolon
r_while
c_loop
(paren
(paren
id|asr
op_amp
id|ASR_CIP
)paren
op_logical_and
id|timeout
op_decrement
OG
l_int|0
)paren
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_DISCONNECT
)paren
suffix:semicolon
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asr
op_amp
id|ASR_LCI
)paren
id|printk
(paren
l_string|&quot;scsi%d: disconnect command ignored. &quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|timeout
op_assign
l_int|1000000
suffix:semicolon
r_while
c_loop
(paren
(paren
id|asr
op_amp
id|ASR_CIP
)paren
op_logical_and
id|timeout
op_decrement
OG
l_int|0
)paren
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
)brace
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
id|sr
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : asr is %x, sr is %x. &quot;
comma
id|instance-&gt;host_no
comma
id|asr
comma
id|sr
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_DISCONNECT
)paren
suffix:semicolon
id|timeout
op_assign
l_int|1000000
suffix:semicolon
r_while
c_loop
(paren
(paren
id|asr
op_amp
id|ASR_CIP
)paren
op_logical_and
id|timeout
op_decrement
OG
l_int|0
)paren
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
id|sr
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : asr is %x, sr is %x. &quot;
comma
id|instance-&gt;host_no
comma
id|asr
comma
id|sr
)paren
suffix:semicolon
id|reset_wd33c93
c_func
(paren
id|instance
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
id|wd33c93_execute
(paren
id|instance
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Case 3: If the command is currently disconnected from the bus,&n; * we&squot;re not going to expend much effort here: Let&squot;s just return&n; * an ABORT_SNOOZE and hope for the best...&n; */
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_Q
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
r_if
c_cond
(paren
id|cmd
op_eq
id|tmp
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
multiline_comment|/*&n; * Case 4 : If we reached this point, the command was not found in any of&n; *     the queues.&n; *&n; * We probably reached this point because of an unlikely race condition&n; * between the command completing successfully and the abortion code,&n; * so we won&squot;t panic, but we will notify the user in case somethign really&n; * broke.&n; */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : warning : SCSI command probably completed successfully&bslash;n&quot;
l_string|&quot;         before abortion. &quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
DECL|macro|MAX_WD33C93_HOSTS
mdefine_line|#define MAX_WD33C93_HOSTS 8
DECL|variable|setup_args_array
r_static
r_int
r_int
id|setup_args_array
(braket
id|MAX_WD33C93_HOSTS
)braket
suffix:semicolon
DECL|variable|setup_args_array_x
r_static
r_int
id|setup_args_array_x
op_assign
l_int|0
suffix:semicolon
DECL|function|wd33c93_setup
r_void
id|wd33c93_setup
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ints
(braket
l_int|0
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
id|setup_args_array
(braket
id|i
)braket
op_assign
id|ints
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
)brace
DECL|function|wd33c93_init
r_void
id|wd33c93_init
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
id|wd33c93_regs
op_star
id|regs
comma
id|dma_setup_t
id|setup
comma
id|dma_stop_t
id|stop
comma
r_int
id|clock_freq
)paren
(brace
r_struct
id|WD33C93_hostdata
op_star
id|hostdata
suffix:semicolon
r_int
id|i
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|WD33C93_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|hostdata-&gt;regp
op_assign
id|regs
suffix:semicolon
id|hostdata-&gt;clock_freq
op_assign
id|clock_freq
suffix:semicolon
id|hostdata-&gt;dma_setup
op_assign
id|setup
suffix:semicolon
id|hostdata-&gt;dma_stop
op_assign
id|stop
suffix:semicolon
id|hostdata-&gt;dma_bounce_buffer
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;dma_bounce_len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hostdata-&gt;busy
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;sync_xfer
(braket
id|i
)braket
op_assign
id|calc_sync_xfer
c_func
(paren
id|DEFAULT_SX_PER
op_div
l_int|4
comma
id|DEFAULT_SX_OFF
)paren
suffix:semicolon
id|hostdata-&gt;sync_stat
(braket
id|i
)braket
op_assign
id|SS_UNSET
suffix:semicolon
multiline_comment|/* using default sync values */
)brace
id|hostdata-&gt;input_Q
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;selecting
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;disconnected_Q
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
id|hostdata-&gt;dma
op_assign
id|D_DMA_OFF
suffix:semicolon
id|hostdata-&gt;incoming_ptr
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;outgoing_len
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;args
op_assign
id|setup_default
suffix:semicolon
r_if
c_cond
(paren
(paren
id|setup_args_array_x
OL
id|MAX_WD33C93_HOSTS
)paren
op_logical_and
(paren
id|setup_args_array
(braket
id|setup_args_array_x
)braket
)paren
)paren
id|hostdata-&gt;args
op_assign
id|setup_args_array
(braket
id|setup_args_array_x
)braket
suffix:semicolon
id|setup_args_array_x
op_increment
suffix:semicolon
id|i
op_assign
id|hostdata-&gt;args
op_amp
(paren
id|A_LEVEL2_0
op_or
id|A_LEVEL2_1
op_or
id|A_LEVEL2_2
)paren
suffix:semicolon
id|i
op_rshift_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
id|i
op_assign
id|L2_DEFAULT
suffix:semicolon
id|hostdata-&gt;level2
op_assign
id|i
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|reset_wd33c93
c_func
(paren
id|instance
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;wd33c93-%d: &quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hostdata-&gt;chip
)paren
(brace
r_case
id|C_WD33C93
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Found WD33c93 chip! This driver probably needs at least the &squot;A&squot; version!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|C_WD33C93A
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Found WD33c93A chip: microcode=%02x&bslash;n&quot;
comma
id|hostdata-&gt;microcode
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|C_WD33C93B
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Found WD33c93B chip: microcode=%02x&bslash;n&quot;
comma
id|hostdata-&gt;microcode
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unknown 3393 chip!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;wd33c93-%d: LEVEL2 commands %s (%d)&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
(paren
id|hostdata-&gt;level2
op_eq
id|L2_NONE
)paren
ques
c_cond
l_string|&quot;disabled&quot;
suffix:colon
l_string|&quot;enabled&quot;
comma
id|hostdata-&gt;level2
)paren
suffix:semicolon
macro_line|#ifdef DEBUGGING_ON
id|printk
c_func
(paren
l_string|&quot;wd33c93-%d: debug_flags = %04x&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|hostdata-&gt;args
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;wd33c93-%d: driver version %s - %s&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|WD33C93_VERSION
comma
id|WD33C93_DATE
)paren
suffix:semicolon
)brace
eof
