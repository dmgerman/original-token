multiline_comment|/*&n; *    wd33c93.c - Linux-68k device driver for the Commodore&n; *                Amiga A2091/590 SCSI controller card&n; *&n; * Copyright (c) 1996 John Shifflett, GeoLog Consulting&n; *    john@geolog.com&n; *    jshiffle@netcom.com&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; *&n; * Drew Eckhardt&squot;s excellent &squot;Generic NCR5380&squot; sources from Linux-PC&n; * provided much of the inspiration and some of the code for this&n; * driver. Everything I know about Amiga DMA was gleaned from careful&n; * reading of Hamish Mcdonald&squot;s original wd33c93 driver; in fact, I&n; * borrowed shamelessly from all over that source. Thanks Hamish!&n; *&n; * _This_ driver is (I feel) an improvement over the old one in&n; * several respects:&n; *&n; *    -  Target Disconnection/Reconnection  is now supported. Any&n; *          system with more than one device active on the SCSI bus&n; *          will benefit from this. The driver defaults to what I&n; *          call &squot;adaptive disconnect&squot; - meaning that each command&n; *          is evaluated individually as to whether or not it should&n; *          be run with the option to disconnect/reselect (if the&n; *          device chooses), or as a &quot;SCSI-bus-hog&quot;.&n; *&n; *    -  Synchronous data transfers are now supported. Because of&n; *          a few devices that choke after telling the driver that&n; *          they can do sync transfers, we don&squot;t automatically use&n; *          this faster protocol - it can be enabled via the command-&n; *          line on a device-by-device basis.&n; *&n; *    -  Runtime operating parameters can now be specified through&n; *       the &squot;amiboot&squot; or the &squot;insmod&squot; command line. For amiboot do:&n; *          &quot;amiboot [usual stuff] wd33c93=blah,blah,blah&quot;&n; *       The defaults should be good for most people. See the comment&n; *       for &squot;setup_strings&squot; below for more details.&n; *&n; *    -  The old driver relied exclusively on what the Western Digital&n; *          docs call &quot;Combination Level 2 Commands&quot;, which are a great&n; *          idea in that the CPU is relieved of a lot of interrupt&n; *          overhead. However, by accepting a certain (user-settable)&n; *          amount of additional interrupts, this driver achieves&n; *          better control over the SCSI bus, and data transfers are&n; *          almost as fast while being much easier to define, track,&n; *          and debug.&n; *&n; *&n; * TODO:&n; *       more speed. linked commands.&n; *&n; *&n; * People with bug reports, wish-lists, complaints, comments,&n; * or improvements are asked to pah-leeez email me (John Shifflett)&n; * at john@geolog.com or jshiffle@netcom.com! I&squot;m anxious to get&n; * this thing into as good a shape as possible, and I&squot;m positive&n; * there are lots of lurking bugs and &quot;Stupid Places&quot;.&n; *&n; * Updates:&n; *&n; * Added support for pre -A chips, which don&squot;t have advanced features&n; * and will generate CSR_RESEL rather than CSR_RESEL_AM.&n; *&t;Richard Hirst &lt;richard@sleepie.demon.co.uk&gt;  August 2000&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
DECL|macro|WD33C93_VERSION
mdefine_line|#define WD33C93_VERSION    &quot;1.25&quot;
DECL|macro|WD33C93_DATE
mdefine_line|#define WD33C93_DATE       &quot;09/Jul/1997&quot;
multiline_comment|/* NOTE: 1.25 for m68k is related to in2000-1.31 for x86 */
multiline_comment|/*&n; * Note - the following defines have been moved to &squot;wd33c93.h&squot;:&n; *&n; *    PROC_INTERFACE&n; *    PROC_STATISTICS&n; *    SYNC_DEBUG&n; *    DEBUGGING_ON&n; *    DEBUG_DEFAULTS&n; *&n; */
macro_line|#include &quot;wd33c93.h&quot;
multiline_comment|/*&n; * &squot;setup_strings&squot; is a single string used to pass operating parameters and&n; * settings from the kernel/module command-line to the driver. &squot;setup_args[]&squot;&n; * is an array of strings that define the compile-time default values for&n; * these settings. If Linux boots with an amiboot or insmod command-line,&n; * those settings are combined with &squot;setup_args[]&squot;. Note that amiboot&n; * command-lines are prefixed with &quot;wd33c93=&quot; while insmod uses a&n; * &quot;setup_strings=&quot; prefix. The driver recognizes the following keywords&n; * (lower case required) and arguments:&n; *&n; * -  nosync:bitmask -bitmask is a byte where the 1st 7 bits correspond with&n; *                    the 7 possible SCSI devices. Set a bit to negotiate for&n; *                    asynchronous transfers on that device. To maintain&n; *                    backwards compatibility, a command-line such as&n; *                    &quot;wd33c93=255&quot; will be automatically translated to&n; *                    &quot;wd33c93=nosync:0xff&quot;.&n; * -  nodma:x        -x = 1 to disable DMA, x = 0 to enable it. Argument is&n; *                    optional - if not present, same as &quot;nodma:1&quot;.&n; * -  period:ns      -ns is the minimum # of nanoseconds in a SCSI data transfer&n; *                    period. Default is 500; acceptable values are 250 - 1000.&n; * -  disconnect:x   -x = 0 to never allow disconnects, 2 to always allow them.&n; *                    x = 1 does &squot;adaptive&squot; disconnects, which is the default&n; *                    and generally the best choice.&n; * -  debug:x        -If &squot;DEBUGGING_ON&squot; is defined, x is a bit mask that causes&n; *                    various types of debug output to printed - see the DB_xxx&n; *                    defines in wd33c93.h&n; * -  clock:x        -x = clock input in MHz for WD33c93 chip. Normal values&n; *                    would be from 8 through 20. Default is 8.&n; * -  next           -No argument. Used to separate blocks of keywords when&n; *                    there&squot;s more than one host adapter in the system.&n; *&n; * Syntax Notes:&n; * -  Numeric arguments can be decimal or the &squot;0x&squot; form of hex notation. There&n; *    _must_ be a colon between a keyword and its numeric argument, with no&n; *    spaces.&n; * -  Keywords are separated by commas, no spaces, in the standard kernel&n; *    command-line manner.&n; * -  A keyword in the &squot;nth&squot; comma-separated command-line member will overwrite&n; *    the &squot;nth&squot; element of setup_args[]. A blank command-line member (in&n; *    other words, a comma with no preceding keyword) will _not_ overwrite&n; *    the corresponding setup_args[] element.&n; * -  If a keyword is used more than once, the first one applies to the first&n; *    SCSI host found, the second to the second card, etc, unless the &squot;next&squot;&n; *    keyword is used to change the order.&n; *&n; * Some amiboot examples (for insmod, use &squot;setup_strings&squot; instead of &squot;wd33c93&squot;):&n; * -  wd33c93=nosync:255&n; * -  wd33c93=nodma&n; * -  wd33c93=nodma:1&n; * -  wd33c93=disconnect:2,nosync:0x08,period:250&n; * -  wd33c93=debug:0x1c&n; */
multiline_comment|/* Normally, no defaults are specified */
DECL|variable|setup_args
r_static
r_char
op_star
id|setup_args
(braket
)braket
op_assign
(brace
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
)brace
suffix:semicolon
multiline_comment|/* filled in by &squot;insmod&squot; */
DECL|variable|setup_strings
r_static
r_char
op_star
id|setup_strings
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef MODULE_PARM
id|MODULE_PARM
c_func
(paren
id|setup_strings
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
macro_line|#endif
DECL|function|read_wd33c93
r_static
r_inline
id|uchar
id|read_wd33c93
c_func
(paren
id|wd33c93_regs
op_star
id|regp
comma
id|uchar
id|reg_num
)paren
(brace
id|regp-&gt;SASR
op_assign
id|reg_num
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_return
id|regp-&gt;SCMD
suffix:semicolon
)brace
DECL|macro|READ_AUX_STAT
mdefine_line|#define READ_AUX_STAT() (regp-&gt;SASR)
DECL|function|write_wd33c93
r_static
r_inline
r_void
id|write_wd33c93
c_func
(paren
id|wd33c93_regs
op_star
id|regp
comma
id|uchar
id|reg_num
comma
id|uchar
id|value
)paren
(brace
id|regp-&gt;SASR
op_assign
id|reg_num
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|regp-&gt;SCMD
op_assign
id|value
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|write_wd33c93_cmd
r_static
r_inline
r_void
id|write_wd33c93_cmd
c_func
(paren
id|wd33c93_regs
op_star
id|regp
comma
id|uchar
id|cmd
)paren
(brace
id|regp-&gt;SASR
op_assign
id|WD_COMMAND
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|regp-&gt;SCMD
op_assign
id|cmd
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|read_1_byte
r_static
r_inline
id|uchar
id|read_1_byte
c_func
(paren
id|wd33c93_regs
op_star
id|regp
)paren
(brace
id|uchar
id|asr
suffix:semicolon
id|uchar
id|x
op_assign
l_int|0
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_POLLED
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_TRANS_INFO
op_or
l_int|0x80
)paren
suffix:semicolon
r_do
(brace
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asr
op_amp
id|ASR_DBR
)paren
id|x
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_DATA
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|asr
op_amp
id|ASR_INT
)paren
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
DECL|function|write_wd33c93_count
r_static
r_void
id|write_wd33c93_count
c_func
(paren
id|wd33c93_regs
op_star
id|regp
comma
r_int
r_int
id|value
)paren
(brace
id|regp-&gt;SASR
op_assign
id|WD_TRANSFER_COUNT_MSB
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|regp-&gt;SCMD
op_assign
id|value
op_rshift
l_int|16
suffix:semicolon
id|regp-&gt;SCMD
op_assign
id|value
op_rshift
l_int|8
suffix:semicolon
id|regp-&gt;SCMD
op_assign
id|value
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|read_wd33c93_count
r_static
r_int
r_int
id|read_wd33c93_count
c_func
(paren
id|wd33c93_regs
op_star
id|regp
)paren
(brace
r_int
r_int
id|value
suffix:semicolon
id|regp-&gt;SASR
op_assign
id|WD_TRANSFER_COUNT_MSB
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|value
op_assign
id|regp-&gt;SCMD
op_lshift
l_int|16
suffix:semicolon
id|value
op_or_assign
id|regp-&gt;SCMD
op_lshift
l_int|8
suffix:semicolon
id|value
op_or_assign
id|regp-&gt;SCMD
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
multiline_comment|/* The 33c93 needs to be told which direction a command transfers its&n; * data; we use this function to figure it out. Returns true if there&n; * will be a DATA_OUT phase with this command, false otherwise.&n; * (Thanks to Joerg Dorchain for the research and suggestion.)&n; */
DECL|function|is_dir_out
r_static
r_int
id|is_dir_out
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
r_case
id|WRITE_12
suffix:colon
r_case
id|WRITE_LONG
suffix:colon
r_case
id|WRITE_SAME
suffix:colon
r_case
id|WRITE_BUFFER
suffix:colon
r_case
id|WRITE_VERIFY
suffix:colon
r_case
id|WRITE_VERIFY_12
suffix:colon
r_case
id|COMPARE
suffix:colon
r_case
id|COPY
suffix:colon
r_case
id|COPY_VERIFY
suffix:colon
r_case
id|SEARCH_EQUAL
suffix:colon
r_case
id|SEARCH_HIGH
suffix:colon
r_case
id|SEARCH_LOW
suffix:colon
r_case
id|SEARCH_EQUAL_12
suffix:colon
r_case
id|SEARCH_HIGH_12
suffix:colon
r_case
id|SEARCH_LOW_12
suffix:colon
r_case
id|FORMAT_UNIT
suffix:colon
r_case
id|REASSIGN_BLOCKS
suffix:colon
r_case
id|RESERVE
suffix:colon
r_case
id|MODE_SELECT
suffix:colon
r_case
id|MODE_SELECT_10
suffix:colon
r_case
id|LOG_SELECT
suffix:colon
r_case
id|SEND_DIAGNOSTIC
suffix:colon
r_case
id|CHANGE_DEFINITION
suffix:colon
r_case
id|UPDATE_BLOCK
suffix:colon
r_case
id|SET_WINDOW
suffix:colon
r_case
id|MEDIUM_SCAN
suffix:colon
r_case
id|SEND_VOLUME_TAG
suffix:colon
r_case
l_int|0xea
suffix:colon
r_return
l_int|1
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|variable|sx_table
r_static
r_struct
id|sx_period
id|sx_table
(braket
)braket
op_assign
(brace
(brace
l_int|1
comma
l_int|0x20
)brace
comma
(brace
l_int|252
comma
l_int|0x20
)brace
comma
(brace
l_int|376
comma
l_int|0x30
)brace
comma
(brace
l_int|500
comma
l_int|0x40
)brace
comma
(brace
l_int|624
comma
l_int|0x50
)brace
comma
(brace
l_int|752
comma
l_int|0x60
)brace
comma
(brace
l_int|876
comma
l_int|0x70
)brace
comma
(brace
l_int|1000
comma
l_int|0x00
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|function|round_period
r_static
r_int
id|round_period
c_func
(paren
r_int
r_int
id|period
)paren
(brace
r_int
id|x
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|1
suffix:semicolon
id|sx_table
(braket
id|x
)braket
dot
id|period_ns
suffix:semicolon
id|x
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|period
op_le
id|sx_table
(braket
id|x
op_minus
l_int|0
)braket
dot
id|period_ns
)paren
op_logical_and
(paren
id|period
OG
id|sx_table
(braket
id|x
op_minus
l_int|1
)braket
dot
id|period_ns
)paren
)paren
(brace
r_return
id|x
suffix:semicolon
)brace
)brace
r_return
l_int|7
suffix:semicolon
)brace
DECL|function|calc_sync_xfer
r_static
id|uchar
id|calc_sync_xfer
c_func
(paren
r_int
r_int
id|period
comma
r_int
r_int
id|offset
)paren
(brace
id|uchar
id|result
suffix:semicolon
id|period
op_mul_assign
l_int|4
suffix:semicolon
multiline_comment|/* convert SDTR code to ns */
id|result
op_assign
id|sx_table
(braket
id|round_period
c_func
(paren
id|period
)paren
)braket
dot
id|reg_value
suffix:semicolon
id|result
op_or_assign
(paren
id|offset
OL
id|OPTIMUM_SX_OFF
)paren
ques
c_cond
id|offset
suffix:colon
id|OPTIMUM_SX_OFF
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_static
r_void
id|wd33c93_execute
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
suffix:semicolon
DECL|function|wd33c93_queuecommand
r_int
id|wd33c93_queuecommand
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|WD33C93_hostdata
op_star
id|hostdata
suffix:semicolon
id|Scsi_Cmnd
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|WD33C93_hostdata
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
id|DB
c_func
(paren
id|DB_QUEUE_COMMAND
comma
id|printk
c_func
(paren
l_string|&quot;Q-%d-%02x-%ld( &quot;
comma
id|cmd-&gt;target
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
id|cmd-&gt;pid
)paren
)paren
multiline_comment|/* Set up a few fields in the Scsi_Cmnd structure for our own use:&n; *  - host_scribble is the pointer to the next cmd in the input queue&n; *  - scsi_done points to the routine we call when a cmd is finished&n; *  - result is what you&squot;d expect&n; */
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We use the Scsi_Pointer structure that&squot;s included with each command&n; * as a scratchpad (as it&squot;s intended to be used!). The handy thing about&n; * the SCp.xxx fields is that they&squot;re always associated with a given&n; * cmd, and are preserved across disconnect-reselect. This means we&n; * can pretty much ignore SAVE_POINTERS and RESTORE_POINTERS messages&n; * if we keep all the critical pointers and counters in SCp:&n; *  - SCp.ptr is the pointer into the RAM buffer&n; *  - SCp.this_residual is the size of that buffer&n; *  - SCp.buffer points to the current scatter-gather buffer&n; *  - SCp.buffers_residual tells us how many S.G. buffers there are&n; *  - SCp.have_data_in is not used&n; *  - SCp.sent_command is not used&n; *  - SCp.phase records this command&squot;s SRCID_ER bit setting&n; */
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
id|cmd-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
id|cmd-&gt;SCp.buffers_residual
op_assign
id|cmd-&gt;use_sg
op_minus
l_int|1
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|cmd-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
r_else
(brace
id|cmd-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.buffers_residual
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
)brace
multiline_comment|/* WD docs state that at the conclusion of a &quot;LEVEL2&quot; command, the&n; * status byte can be retrieved from the LUN register. Apparently,&n; * this is the case only for *uninterrupted* LEVEL2 commands! If&n; * there are any unexpected phases entered, even if they are 100%&n; * legal (different devices may choose to do things differently),&n; * the LEVEL2 command sequence is exited. This often occurs prior&n; * to receiving the status byte, in which case the driver does a&n; * status phase interrupt and gets the status byte on its own.&n; * While such a command can then be &quot;resumed&quot; (ie restarted to&n; * finish up as a LEVEL2 command), the LUN register will NOT be&n; * a valid status byte at the command&squot;s conclusion, and we must&n; * use the byte obtained during the earlier interrupt. Here, we&n; * preset SCp.Status to an illegal value (0xff) so that when&n; * this command finally completes, we can tell where the actual&n; * status byte is stored.&n; */
id|cmd-&gt;SCp.Status
op_assign
id|ILLEGAL_STATUS_BYTE
suffix:semicolon
multiline_comment|/*&n;    * Add the cmd to the end of &squot;input_Q&squot;. Note that REQUEST SENSE&n;    * commands are added to the head of the queue so that the desired&n;    * sense data is not lost before REQUEST_SENSE executes.&n;    */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;input_Q
)paren
op_logical_or
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
)paren
(brace
id|cmd-&gt;host_scribble
op_assign
(paren
id|uchar
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|hostdata-&gt;input_Q
op_assign
id|cmd
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* find the end of the queue */
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|tmp-&gt;host_scribble
suffix:semicolon
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
suffix:semicolon
id|tmp-&gt;host_scribble
op_assign
(paren
id|uchar
op_star
)paren
id|cmd
suffix:semicolon
)brace
multiline_comment|/* We know that there&squot;s at least one command in &squot;input_Q&squot; now.&n; * Go see if any of them are runnable!&n; */
id|wd33c93_execute
c_func
(paren
id|cmd-&gt;host
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_QUEUE_COMMAND
comma
id|printk
c_func
(paren
l_string|&quot;)Q-%ld &quot;
comma
id|cmd-&gt;pid
)paren
)paren
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine attempts to start a scsi command. If the host_card is&n; * already connected, we give up immediately. Otherwise, look through&n; * the input_Q, using the first command we find that&squot;s intended&n; * for a currently non-busy target/lun.&n; *&n; * wd33c93_execute() is always called with interrupts disabled or from&n; * the wd33c93_intr itself, which means that a wd33c93 interrupt&n; * cannot occur while we are in here.&n; */
DECL|function|wd33c93_execute
r_static
r_void
id|wd33c93_execute
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
r_struct
id|WD33C93_hostdata
op_star
id|hostdata
suffix:semicolon
id|wd33c93_regs
op_star
id|regp
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
comma
op_star
id|prev
suffix:semicolon
r_int
id|i
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|WD33C93_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|regp
op_assign
id|hostdata-&gt;regp
suffix:semicolon
id|DB
c_func
(paren
id|DB_EXECUTE
comma
id|printk
c_func
(paren
l_string|&quot;EX(&quot;
)paren
)paren
r_if
c_cond
(paren
id|hostdata-&gt;selecting
op_logical_or
id|hostdata-&gt;connected
)paren
(brace
id|DB
c_func
(paren
id|DB_EXECUTE
comma
id|printk
c_func
(paren
l_string|&quot;)EX-0 &quot;
)paren
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;     * Search through the input_Q for a command destined&n;     * for an idle target/lun.&n;     */
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|prev
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cmd
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_amp
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
)paren
)paren
r_break
suffix:semicolon
id|prev
op_assign
id|cmd
suffix:semicolon
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
)brace
multiline_comment|/* quit if queue empty or all possible targets are busy */
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
(brace
id|DB
c_func
(paren
id|DB_EXECUTE
comma
id|printk
c_func
(paren
l_string|&quot;)EX-1 &quot;
)paren
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/*  remove command from queue */
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;host_scribble
op_assign
id|cmd-&gt;host_scribble
suffix:semicolon
r_else
id|hostdata-&gt;input_Q
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
macro_line|#ifdef PROC_STATISTICS
id|hostdata-&gt;cmd_cnt
(braket
id|cmd-&gt;target
)braket
op_increment
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;    * Start the selection process&n;    */
r_if
c_cond
(paren
id|is_dir_out
c_func
(paren
id|cmd
)paren
)paren
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_DESTINATION_ID
comma
id|cmd-&gt;target
)paren
suffix:semicolon
r_else
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_DESTINATION_ID
comma
id|cmd-&gt;target
op_or
id|DSTID_DPD
)paren
suffix:semicolon
multiline_comment|/* Now we need to figure out whether or not this command is a good&n; * candidate for disconnect/reselect. We guess to the best of our&n; * ability, based on a set of hierarchical rules. When several&n; * devices are operating simultaneously, disconnects are usually&n; * an advantage. In a single device system, or if only 1 device&n; * is being accessed, transfers usually go faster if disconnects&n; * are not allowed:&n; *&n; * + Commands should NEVER disconnect if hostdata-&gt;disconnect =&n; *   DIS_NEVER (this holds for tape drives also), and ALWAYS&n; *   disconnect if hostdata-&gt;disconnect = DIS_ALWAYS.&n; * + Tape drive commands should always be allowed to disconnect.&n; * + Disconnect should be allowed if disconnected_Q isn&squot;t empty.&n; * + Commands should NOT disconnect if input_Q is empty.&n; * + Disconnect should be allowed if there are commands in input_Q&n; *   for a different target/lun. In this case, the other commands&n; *   should be made disconnect-able, if not already.&n; *&n; * I know, I know - this code would flunk me out of any&n; * &quot;C Programming 101&quot; class ever offered. But it&squot;s easy&n; * to change around and experiment with for now.&n; */
id|cmd-&gt;SCp.phase
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* assume no disconnect */
r_if
c_cond
(paren
id|hostdata-&gt;disconnect
op_eq
id|DIS_NEVER
)paren
r_goto
id|no
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;disconnect
op_eq
id|DIS_ALWAYS
)paren
r_goto
id|yes
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;type
op_eq
l_int|1
)paren
multiline_comment|/* tape drive? */
r_goto
id|yes
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;disconnected_Q
)paren
multiline_comment|/* other commands disconnected? */
r_goto
id|yes
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;input_Q
)paren
)paren
multiline_comment|/* input_Q empty? */
r_goto
id|no
suffix:semicolon
r_for
c_loop
(paren
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|prev
suffix:semicolon
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|prev-&gt;host_scribble
)paren
(brace
r_if
c_cond
(paren
(paren
id|prev-&gt;target
op_ne
id|cmd-&gt;target
)paren
op_logical_or
(paren
id|prev-&gt;lun
op_ne
id|cmd-&gt;lun
)paren
)paren
(brace
r_for
c_loop
(paren
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|prev
suffix:semicolon
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|prev-&gt;host_scribble
)paren
id|prev-&gt;SCp.phase
op_assign
l_int|1
suffix:semicolon
r_goto
id|yes
suffix:semicolon
)brace
)brace
r_goto
id|no
suffix:semicolon
id|yes
suffix:colon
id|cmd-&gt;SCp.phase
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef PROC_STATISTICS
id|hostdata-&gt;disc_allowed_cnt
(braket
id|cmd-&gt;target
)braket
op_increment
suffix:semicolon
macro_line|#endif
id|no
suffix:colon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_SOURCE_ID
comma
(paren
(paren
id|cmd-&gt;SCp.phase
)paren
ques
c_cond
id|SRCID_ER
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_TARGET_LUN
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_SYNCHRONOUS_TRANSFER
comma
id|hostdata-&gt;sync_xfer
(braket
id|cmd-&gt;target
)braket
)paren
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_or_assign
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hostdata-&gt;level2
op_eq
id|L2_NONE
)paren
op_logical_or
(paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_eq
id|SS_UNSET
)paren
)paren
(brace
multiline_comment|/*&n;          * Do a &squot;Select-With-ATN&squot; command. This will end with&n;          * one of the following interrupts:&n;          *    CSR_RESEL_AM:  failure - can try again later.&n;          *    CSR_TIMEOUT:   failure - give up.&n;          *    CSR_SELECT:    success - proceed.&n;          */
id|hostdata-&gt;selecting
op_assign
id|cmd
suffix:semicolon
multiline_comment|/* Every target has its own synchronous transfer setting, kept in the&n; * sync_xfer array, and a corresponding status byte in sync_stat[].&n; * Each target&squot;s sync_stat[] entry is initialized to SX_UNSET, and its&n; * sync_xfer[] entry is initialized to the default/safe value. SS_UNSET&n; * means that the parameters are undetermined as yet, and that we&n; * need to send an SDTR message to this device after selection is&n; * complete: We set SS_FIRST to tell the interrupt routine to do so.&n; * If we&squot;ve been asked not to try synchronous transfers on this&n; * target (and _all_ luns within it), we&squot;ll still send the SDTR message&n; * later, but at that time we&squot;ll negotiate for async by specifying a&n; * sync fifo depth of 0.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_eq
id|SS_UNSET
)paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_assign
id|SS_FIRST
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_SELECTING
suffix:semicolon
id|write_wd33c93_count
c_func
(paren
id|regp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* guarantee a DATA_PHASE interrupt */
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_SEL_ATN
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;          * Do a &squot;Select-With-ATN-Xfer&squot; command. This will end with&n;          * one of the following interrupts:&n;          *    CSR_RESEL_AM:  failure - can try again later.&n;          *    CSR_TIMEOUT:   failure - give up.&n;          *    anything else: success - proceed.&n;          */
id|hostdata-&gt;connected
op_assign
id|cmd
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_COMMAND_PHASE
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* copy command_descriptor_block into WD chip&n;    * (take advantage of auto-incrementing)&n;    */
id|regp-&gt;SASR
op_assign
id|WD_CDB_1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cmd-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
id|regp-&gt;SCMD
op_assign
id|cmd-&gt;cmnd
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* The wd33c93 only knows about Group 0, 1, and 5 commands when&n;    * it&squot;s doing a &squot;select-and-transfer&squot;. To be safe, we write the&n;    * size of the CDB into the OWN_ID register for every case. This&n;    * way there won&squot;t be problems with vendor-unique, audio, etc.&n;    */
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_OWN_ID
comma
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
multiline_comment|/* When doing a non-disconnect command with DMA, we can save&n;    * ourselves a DATA phase interrupt later by setting everything&n;    * up ahead of time.&n;    */
r_if
c_cond
(paren
(paren
id|cmd-&gt;SCp.phase
op_eq
l_int|0
)paren
op_logical_and
(paren
id|hostdata-&gt;no_dma
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|hostdata
op_member_access_from_pointer
id|dma_setup
c_func
(paren
id|cmd
comma
(paren
id|is_dir_out
c_func
(paren
id|cmd
)paren
)paren
ques
c_cond
id|DATA_OUT_DIR
suffix:colon
id|DATA_IN_DIR
)paren
)paren
id|write_wd33c93_count
c_func
(paren
id|regp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* guarantee a DATA_PHASE interrupt */
r_else
(brace
id|write_wd33c93_count
c_func
(paren
id|regp
comma
id|cmd-&gt;SCp.this_residual
)paren
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_DMA
)paren
suffix:semicolon
id|hostdata-&gt;dma
op_assign
id|D_DMA_RUNNING
suffix:semicolon
)brace
)brace
r_else
id|write_wd33c93_count
c_func
(paren
id|regp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* guarantee a DATA_PHASE interrupt */
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    * Since the SCSI bus can handle only 1 connection at a time,&n;    * we get out of here now. If the selection fails, or when&n;    * the command disconnects, we&squot;ll come back to this routine&n;    * to search the input_Q again...&n;    */
id|DB
c_func
(paren
id|DB_EXECUTE
comma
id|printk
c_func
(paren
l_string|&quot;%s%ld)EX-2 &quot;
comma
(paren
id|cmd-&gt;SCp.phase
)paren
ques
c_cond
l_string|&quot;d:&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|cmd-&gt;pid
)paren
)paren
)brace
DECL|function|transfer_pio
r_static
r_void
id|transfer_pio
c_func
(paren
id|wd33c93_regs
op_star
id|regp
comma
id|uchar
op_star
id|buf
comma
r_int
id|cnt
comma
r_int
id|data_in_dir
comma
r_struct
id|WD33C93_hostdata
op_star
id|hostdata
)paren
(brace
id|uchar
id|asr
suffix:semicolon
id|DB
c_func
(paren
id|DB_TRANSFER
comma
id|printk
c_func
(paren
l_string|&quot;(%p,%d,%s:&quot;
comma
id|buf
comma
id|cnt
comma
id|data_in_dir
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
)paren
)paren
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_POLLED
)paren
suffix:semicolon
id|write_wd33c93_count
c_func
(paren
id|regp
comma
id|cnt
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_TRANS_INFO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_in_dir
)paren
(brace
r_do
(brace
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asr
op_amp
id|ASR_DBR
)paren
op_star
id|buf
op_increment
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_DATA
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|asr
op_amp
id|ASR_INT
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_do
(brace
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asr
op_amp
id|ASR_DBR
)paren
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_DATA
comma
op_star
id|buf
op_increment
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|asr
op_amp
id|ASR_INT
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Note: we are returning with the interrupt UN-cleared.&n;   * Since (presumably) an entire I/O operation has&n;   * completed, the bus phase is probably different, and&n;   * the interrupt routine will discover this when it&n;   * responds to the uncleared int.&n;   */
)brace
DECL|function|transfer_bytes
r_static
r_void
id|transfer_bytes
c_func
(paren
id|wd33c93_regs
op_star
id|regp
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|data_in_dir
)paren
(brace
r_struct
id|WD33C93_hostdata
op_star
id|hostdata
suffix:semicolon
r_int
r_int
id|length
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|WD33C93_hostdata
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
multiline_comment|/* Normally, you&squot;d expect &squot;this_residual&squot; to be non-zero here.&n; * In a series of scatter-gather transfers, however, this&n; * routine will usually be called with &squot;this_residual&squot; equal&n; * to 0 and &squot;buffers_residual&squot; non-zero. This means that a&n; * previous transfer completed, clearing &squot;this_residual&squot;, and&n; * now we need to setup the next scatter-gather buffer as the&n; * source or destination for THIS transfer.&n; */
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;SCp.this_residual
op_logical_and
id|cmd-&gt;SCp.buffers_residual
)paren
(brace
op_increment
id|cmd-&gt;SCp.buffer
suffix:semicolon
op_decrement
id|cmd-&gt;SCp.buffers_residual
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
id|cmd-&gt;SCp.buffer-&gt;address
suffix:semicolon
)brace
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_SYNCHRONOUS_TRANSFER
comma
id|hostdata-&gt;sync_xfer
(braket
id|cmd-&gt;target
)braket
)paren
suffix:semicolon
multiline_comment|/* &squot;hostdata-&gt;no_dma&squot; is TRUE if we don&squot;t even want to try DMA.&n; * Update &squot;this_residual&squot; and &squot;ptr&squot; after &squot;transfer_pio()&squot; returns.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;no_dma
)paren
r_goto
id|use_transfer_pio
suffix:semicolon
multiline_comment|/* &squot;dma_setup()&squot; will return TRUE if we can&squot;t do DMA.&n; * Update &squot;this_residual&squot; and &squot;ptr&squot; after &squot;transfer_pio()&squot; returns.&n; */
r_else
r_if
c_cond
(paren
id|hostdata
op_member_access_from_pointer
id|dma_setup
c_func
(paren
id|cmd
comma
id|data_in_dir
)paren
)paren
(brace
id|use_transfer_pio
suffix:colon
macro_line|#ifdef PROC_STATISTICS
id|hostdata-&gt;pio_cnt
op_increment
suffix:semicolon
macro_line|#endif
id|transfer_pio
c_func
(paren
id|regp
comma
(paren
id|uchar
op_star
)paren
id|cmd-&gt;SCp.ptr
comma
id|cmd-&gt;SCp.this_residual
comma
id|data_in_dir
comma
id|hostdata
)paren
suffix:semicolon
id|length
op_assign
id|cmd-&gt;SCp.this_residual
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|read_wd33c93_count
c_func
(paren
id|regp
)paren
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_add_assign
(paren
id|length
op_minus
id|cmd-&gt;SCp.this_residual
)paren
suffix:semicolon
)brace
multiline_comment|/* We are able to do DMA (in fact, the Amiga hardware is&n; * already going!), so start up the wd33c93 in DMA mode.&n; * We set &squot;hostdata-&gt;dma&squot; = D_DMA_RUNNING so that when the&n; * transfer completes and causes an interrupt, we&squot;re&n; * reminded to tell the Amiga to shut down its end. We&squot;ll&n; * postpone the updating of &squot;this_residual&squot; and &squot;ptr&squot;&n; * until then.&n; */
r_else
(brace
macro_line|#ifdef PROC_STATISTICS
id|hostdata-&gt;dma_cnt
op_increment
suffix:semicolon
macro_line|#endif
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_DMA
)paren
suffix:semicolon
id|write_wd33c93_count
c_func
(paren
id|regp
comma
id|cmd-&gt;SCp.this_residual
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hostdata-&gt;level2
op_ge
id|L2_DATA
)paren
op_logical_or
(paren
id|hostdata-&gt;level2
op_eq
id|L2_BASIC
op_logical_and
id|cmd-&gt;SCp.phase
op_eq
l_int|0
)paren
)paren
(brace
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_COMMAND_PHASE
comma
l_int|0x45
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
)brace
r_else
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_TRANS_INFO
)paren
suffix:semicolon
id|hostdata-&gt;dma
op_assign
id|D_DMA_RUNNING
suffix:semicolon
)brace
)brace
DECL|function|wd33c93_intr
r_void
id|wd33c93_intr
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
r_struct
id|WD33C93_hostdata
op_star
id|hostdata
suffix:semicolon
id|Scsi_Cmnd
op_star
id|patch
comma
op_star
id|cmd
suffix:semicolon
id|wd33c93_regs
op_star
id|regp
suffix:semicolon
id|uchar
id|asr
comma
id|sr
comma
id|phs
comma
id|id
comma
id|lun
comma
op_star
id|ucp
comma
id|msg
suffix:semicolon
r_int
r_int
id|length
comma
id|flags
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|WD33C93_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|regp
op_assign
id|hostdata-&gt;regp
suffix:semicolon
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|asr
op_amp
id|ASR_INT
)paren
op_logical_or
(paren
id|asr
op_amp
id|ASR_BSY
)paren
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef PROC_STATISTICS
id|hostdata-&gt;int_cnt
op_increment
suffix:semicolon
macro_line|#endif
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;connected
suffix:semicolon
multiline_comment|/* assume we&squot;re connected */
id|sr
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
multiline_comment|/* clear the interrupt */
id|phs
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_COMMAND_PHASE
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;{%02x:%02x-&quot;
comma
id|asr
comma
id|sr
)paren
)paren
multiline_comment|/* After starting a DMA transfer, the next interrupt&n; * is guaranteed to be in response to completion of&n; * the transfer. Since the Amiga DMA hardware runs in&n; * in an open-ended fashion, it needs to be told when&n; * to stop; do that here if D_DMA_RUNNING is true.&n; * Also, we have to update &squot;this_residual&squot; and &squot;ptr&squot;&n; * based on the contents of the TRANSFER_COUNT register,&n; * in case the device decided to do an intermediate&n; * disconnect (a device may do this if it has to do a&n; * seek, or just to be nice and let other devices have&n; * some bus time during long transfers). After doing&n; * whatever is needed, we go on and service the WD3393&n; * interrupt normally.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;dma
op_eq
id|D_DMA_RUNNING
)paren
(brace
id|DB
c_func
(paren
id|DB_TRANSFER
comma
id|printk
c_func
(paren
l_string|&quot;[%p/%d:&quot;
comma
id|cmd-&gt;SCp.ptr
comma
id|cmd-&gt;SCp.this_residual
)paren
)paren
id|hostdata
op_member_access_from_pointer
id|dma_stop
c_func
(paren
id|cmd-&gt;host
comma
id|cmd
comma
l_int|1
)paren
suffix:semicolon
id|hostdata-&gt;dma
op_assign
id|D_DMA_OFF
suffix:semicolon
id|length
op_assign
id|cmd-&gt;SCp.this_residual
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|read_wd33c93_count
c_func
(paren
id|regp
)paren
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_add_assign
(paren
id|length
op_minus
id|cmd-&gt;SCp.this_residual
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_TRANSFER
comma
id|printk
c_func
(paren
l_string|&quot;%p/%d]&quot;
comma
id|cmd-&gt;SCp.ptr
comma
id|cmd-&gt;SCp.this_residual
)paren
)paren
)brace
multiline_comment|/* Respond to the specific WD3393 interrupt - there are quite a few! */
r_switch
c_cond
(paren
id|sr
)paren
(brace
r_case
id|CSR_TIMEOUT
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;TIMEOUT&quot;
)paren
)paren
r_if
c_cond
(paren
id|hostdata-&gt;state
op_eq
id|S_RUNNING_LEVEL2
)paren
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;selecting
suffix:semicolon
multiline_comment|/* get a valid cmd */
id|hostdata-&gt;selecting
op_assign
l_int|NULL
suffix:semicolon
)brace
id|cmd-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/* From esp.c:&n;     * There is a window of time within the scsi_done() path&n;     * of execution where interrupts are turned back on full&n;     * blast and left that way.  During that time we could&n;     * reconnect to a disconnected command, then we&squot;d bomb&n;     * out below.  We could also end up executing two commands&n;     * at _once_.  ...just so you know why the restore_flags()&n;     * is here...&n;     */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* We are not connected to a target - check to see if there&n; * are commands waiting to be executed.&n; */
id|wd33c93_execute
c_func
(paren
id|instance
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Note: this interrupt should not occur in a LEVEL2 command */
r_case
id|CSR_SELECT
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;SELECT&quot;
)paren
)paren
id|hostdata-&gt;connected
op_assign
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;selecting
suffix:semicolon
id|hostdata-&gt;selecting
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* construct an IDENTIFY message with correct disconnect bit */
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_assign
(paren
l_int|0x80
op_or
l_int|0x00
op_or
id|cmd-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;SCp.phase
)paren
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_or_assign
l_int|0x40
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_eq
id|SS_FIRST
)paren
(brace
macro_line|#ifdef SYNC_DEBUG
id|printk
c_func
(paren
l_string|&quot; sending SDTR &quot;
)paren
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_assign
id|SS_WAITING
suffix:semicolon
multiline_comment|/* Tack on a 2nd message to ask about synchronous transfers. If we&squot;ve&n; * been asked to do only asynchronous transfers on this device, we&n; * request a fifo depth of 0, which is equivalent to async - should&n; * solve the problems some people have had with GVP&squot;s Guru ROM.&n; */
id|hostdata-&gt;outgoing_msg
(braket
l_int|1
)braket
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|2
)braket
op_assign
l_int|3
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|3
)braket
op_assign
id|EXTENDED_SDTR
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;no_sync
op_amp
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
)paren
(brace
id|hostdata-&gt;outgoing_msg
(braket
l_int|4
)braket
op_assign
id|hostdata-&gt;default_sx_per
op_div
l_int|4
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|hostdata-&gt;outgoing_msg
(braket
l_int|4
)braket
op_assign
id|OPTIMUM_SX_PER
op_div
l_int|4
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|5
)braket
op_assign
id|OPTIMUM_SX_OFF
suffix:semicolon
)brace
id|hostdata-&gt;outgoing_len
op_assign
l_int|6
suffix:semicolon
)brace
r_else
id|hostdata-&gt;outgoing_len
op_assign
l_int|1
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_XFER_DONE
op_or
id|PHS_DATA_IN
suffix:colon
r_case
id|CSR_UNEXP
op_or
id|PHS_DATA_IN
suffix:colon
r_case
id|CSR_SRV_REQ
op_or
id|PHS_DATA_IN
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;IN-%d.%d&quot;
comma
id|cmd-&gt;SCp.this_residual
comma
id|cmd-&gt;SCp.buffers_residual
)paren
)paren
id|transfer_bytes
c_func
(paren
id|regp
comma
id|cmd
comma
id|DATA_IN_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;state
op_ne
id|S_RUNNING_LEVEL2
)paren
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_XFER_DONE
op_or
id|PHS_DATA_OUT
suffix:colon
r_case
id|CSR_UNEXP
op_or
id|PHS_DATA_OUT
suffix:colon
r_case
id|CSR_SRV_REQ
op_or
id|PHS_DATA_OUT
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;OUT-%d.%d&quot;
comma
id|cmd-&gt;SCp.this_residual
comma
id|cmd-&gt;SCp.buffers_residual
)paren
)paren
id|transfer_bytes
c_func
(paren
id|regp
comma
id|cmd
comma
id|DATA_OUT_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;state
op_ne
id|S_RUNNING_LEVEL2
)paren
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Note: this interrupt should not occur in a LEVEL2 command */
r_case
id|CSR_XFER_DONE
op_or
id|PHS_COMMAND
suffix:colon
r_case
id|CSR_UNEXP
op_or
id|PHS_COMMAND
suffix:colon
r_case
id|CSR_SRV_REQ
op_or
id|PHS_COMMAND
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;CMND-%02x,%ld&quot;
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
id|cmd-&gt;pid
)paren
)paren
id|transfer_pio
c_func
(paren
id|regp
comma
id|cmd-&gt;cmnd
comma
id|cmd-&gt;cmd_len
comma
id|DATA_OUT_DIR
comma
id|hostdata
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_XFER_DONE
op_or
id|PHS_STATUS
suffix:colon
r_case
id|CSR_UNEXP
op_or
id|PHS_STATUS
suffix:colon
r_case
id|CSR_SRV_REQ
op_or
id|PHS_STATUS
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;STATUS=&quot;
)paren
)paren
id|cmd-&gt;SCp.Status
op_assign
id|read_1_byte
c_func
(paren
id|regp
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
id|cmd-&gt;SCp.Status
)paren
)paren
r_if
c_cond
(paren
id|hostdata-&gt;level2
op_ge
id|L2_BASIC
)paren
(brace
id|sr
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
multiline_comment|/* clear interrupt */
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_COMMAND_PHASE
comma
l_int|0x50
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
)brace
r_else
(brace
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CSR_XFER_DONE
op_or
id|PHS_MESS_IN
suffix:colon
r_case
id|CSR_UNEXP
op_or
id|PHS_MESS_IN
suffix:colon
r_case
id|CSR_SRV_REQ
op_or
id|PHS_MESS_IN
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;MSG_IN=&quot;
)paren
)paren
id|msg
op_assign
id|read_1_byte
c_func
(paren
id|regp
)paren
suffix:semicolon
id|sr
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
multiline_comment|/* clear interrupt */
id|hostdata-&gt;incoming_msg
(braket
id|hostdata-&gt;incoming_ptr
)braket
op_assign
id|msg
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;incoming_msg
(braket
l_int|0
)braket
op_eq
id|EXTENDED_MESSAGE
)paren
id|msg
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
r_else
id|hostdata-&gt;incoming_ptr
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.Message
op_assign
id|msg
suffix:semicolon
r_switch
c_cond
(paren
id|msg
)paren
(brace
r_case
id|COMMAND_COMPLETE
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;CCMP-%ld&quot;
comma
id|cmd-&gt;pid
)paren
)paren
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_PRE_CMP_DISC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SAVE_POINTERS
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;SDP&quot;
)paren
)paren
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESTORE_POINTERS
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;RDP&quot;
)paren
)paren
r_if
c_cond
(paren
id|hostdata-&gt;level2
op_ge
id|L2_BASIC
)paren
(brace
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_COMMAND_PHASE
comma
l_int|0x45
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
)brace
r_else
(brace
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DISCONNECT
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;DIS&quot;
)paren
)paren
id|cmd-&gt;device-&gt;disconnect
op_assign
l_int|1
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_PRE_TMP_DISC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MESSAGE_REJECT
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;REJ&quot;
)paren
)paren
macro_line|#ifdef SYNC_DEBUG
id|printk
c_func
(paren
l_string|&quot;-REJ-&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_eq
id|SS_WAITING
)paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_assign
id|SS_SET
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EXTENDED_MESSAGE
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;EXT&quot;
)paren
)paren
id|ucp
op_assign
id|hostdata-&gt;incoming_msg
suffix:semicolon
macro_line|#ifdef SYNC_DEBUG
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
id|ucp
(braket
id|hostdata-&gt;incoming_ptr
)braket
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Is this the last byte of the extended message? */
r_if
c_cond
(paren
(paren
id|hostdata-&gt;incoming_ptr
op_ge
l_int|2
)paren
op_logical_and
(paren
id|hostdata-&gt;incoming_ptr
op_eq
(paren
id|ucp
(braket
l_int|1
)braket
op_plus
l_int|1
)paren
)paren
)paren
(brace
r_switch
c_cond
(paren
id|ucp
(braket
l_int|2
)braket
)paren
(brace
multiline_comment|/* what&squot;s the EXTENDED code? */
r_case
id|EXTENDED_SDTR
suffix:colon
id|id
op_assign
id|calc_sync_xfer
c_func
(paren
id|ucp
(braket
l_int|3
)braket
comma
id|ucp
(braket
l_int|4
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_ne
id|SS_WAITING
)paren
(brace
multiline_comment|/* A device has sent an unsolicited SDTR message; rather than go&n; * through the effort of decoding it and then figuring out what&n; * our reply should be, we&squot;re just gonna say that we have a&n; * synchronous fifo depth of 0. This will result in asynchronous&n; * transfers - not ideal but so much easier.&n; * Actually, this is OK because it assures us that if we don&squot;t&n; * specifically ask for sync transfers, we won&squot;t do any.&n; */
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_ASSERT_ATN
)paren
suffix:semicolon
multiline_comment|/* want MESS_OUT */
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|1
)braket
op_assign
l_int|3
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|2
)braket
op_assign
id|EXTENDED_SDTR
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|3
)braket
op_assign
id|hostdata-&gt;default_sx_per
op_div
l_int|4
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;outgoing_len
op_assign
l_int|5
suffix:semicolon
id|hostdata-&gt;sync_xfer
(braket
id|cmd-&gt;target
)braket
op_assign
id|calc_sync_xfer
c_func
(paren
id|hostdata-&gt;default_sx_per
op_div
l_int|4
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|hostdata-&gt;sync_xfer
(braket
id|cmd-&gt;target
)braket
op_assign
id|id
suffix:semicolon
)brace
macro_line|#ifdef SYNC_DEBUG
id|printk
c_func
(paren
l_string|&quot;sync_xfer=%02x&quot;
comma
id|hostdata-&gt;sync_xfer
(braket
id|cmd-&gt;target
)braket
)paren
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_assign
id|SS_SET
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EXTENDED_WDTR
suffix:colon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_ASSERT_ATN
)paren
suffix:semicolon
multiline_comment|/* want MESS_OUT */
id|printk
c_func
(paren
l_string|&quot;sending WDTR &quot;
)paren
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|2
)braket
op_assign
id|EXTENDED_WDTR
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 8 bit transfer width */
id|hostdata-&gt;outgoing_len
op_assign
l_int|4
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_ASSERT_ATN
)paren
suffix:semicolon
multiline_comment|/* want MESS_OUT */
id|printk
c_func
(paren
l_string|&quot;Rejecting Unknown Extended Message(%02x). &quot;
comma
id|ucp
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_assign
id|MESSAGE_REJECT
suffix:semicolon
id|hostdata-&gt;outgoing_len
op_assign
l_int|1
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hostdata-&gt;incoming_ptr
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We need to read more MESS_IN bytes for the extended message */
r_else
(brace
id|hostdata-&gt;incoming_ptr
op_increment
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Rejecting Unknown Message(%02x) &quot;
comma
id|msg
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_ASSERT_ATN
)paren
suffix:semicolon
multiline_comment|/* want MESS_OUT */
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_assign
id|MESSAGE_REJECT
suffix:semicolon
id|hostdata-&gt;outgoing_len
op_assign
l_int|1
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Note: this interrupt will occur only after a LEVEL2 command */
r_case
id|CSR_SEL_XFER_DONE
suffix:colon
multiline_comment|/* Make sure that reselection is enabled at this point - it may&n; * have been turned off for the command that just completed.&n; */
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_SOURCE_ID
comma
id|SRCID_ER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|phs
op_eq
l_int|0x60
)paren
(brace
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;SX-DONE-%ld&quot;
comma
id|cmd-&gt;pid
)paren
)paren
id|cmd-&gt;SCp.Message
op_assign
id|COMMAND_COMPLETE
suffix:semicolon
id|lun
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_TARGET_LUN
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;:%d.%d&quot;
comma
id|cmd-&gt;SCp.Status
comma
id|lun
)paren
)paren
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;SCp.Status
op_eq
id|ILLEGAL_STATUS_BYTE
)paren
id|cmd-&gt;SCp.Status
op_assign
id|lun
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
id|cmd-&gt;SCp.Status
op_ne
id|GOOD
)paren
id|cmd-&gt;result
op_assign
(paren
id|cmd-&gt;result
op_amp
l_int|0x00ffff
)paren
op_or
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
r_else
id|cmd-&gt;result
op_assign
id|cmd-&gt;SCp.Status
op_or
(paren
id|cmd-&gt;SCp.Message
op_lshift
l_int|8
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/* We are no longer  connected to a target - check to see if&n; * there are commands waiting to be executed.&n; */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|wd33c93_execute
c_func
(paren
id|instance
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%02x:%02x:%02x-%ld: Unknown SEL_XFER_DONE phase!!---&quot;
comma
id|asr
comma
id|sr
comma
id|phs
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* Note: this interrupt will occur only after a LEVEL2 command */
r_case
id|CSR_SDP
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;SDP&quot;
)paren
)paren
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_COMMAND_PHASE
comma
l_int|0x41
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_XFER_DONE
op_or
id|PHS_MESS_OUT
suffix:colon
r_case
id|CSR_UNEXP
op_or
id|PHS_MESS_OUT
suffix:colon
r_case
id|CSR_SRV_REQ
op_or
id|PHS_MESS_OUT
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;MSG_OUT=&quot;
)paren
)paren
multiline_comment|/* To get here, we&squot;ve probably requested MESSAGE_OUT and have&n; * already put the correct bytes in outgoing_msg[] and filled&n; * in outgoing_len. We simply send them out to the SCSI bus.&n; * Sometimes we get MESSAGE_OUT phase when we&squot;re not expecting&n; * it - like when our SDTR message is rejected by a target. Some&n; * targets send the REJECT before receiving all of the extended&n; * message, and then seem to go back to MESSAGE_OUT for a byte&n; * or two. Not sure why, or if I&squot;m doing something wrong to&n; * cause this to happen. Regardless, it seems that sending&n; * NOP messages in these situations results in no harm and&n; * makes everyone happy.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;outgoing_len
op_eq
l_int|0
)paren
(brace
id|hostdata-&gt;outgoing_len
op_assign
l_int|1
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_assign
id|NOP
suffix:semicolon
)brace
id|transfer_pio
c_func
(paren
id|regp
comma
id|hostdata-&gt;outgoing_msg
comma
id|hostdata-&gt;outgoing_len
comma
id|DATA_OUT_DIR
comma
id|hostdata
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
)paren
)paren
id|hostdata-&gt;outgoing_len
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_UNEXP_DISC
suffix:colon
multiline_comment|/* I think I&squot;ve seen this after a request-sense that was in response&n; * to an error condition, but not sure. We certainly need to do&n; * something when we get this interrupt - the question is &squot;what?&squot;.&n; * Let&squot;s think positively, and assume some command has finished&n; * in a legal manner (like a command that provokes a request-sense),&n; * so we treat it as a normal command-complete-disconnect.&n; */
multiline_comment|/* Make sure that reselection is enabled at this point - it may&n; * have been turned off for the command that just completed.&n; */
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_SOURCE_ID
comma
id|SRCID_ER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; - Already disconnected! &quot;
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;UNEXP_DISC-%ld&quot;
comma
id|cmd-&gt;pid
)paren
)paren
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
id|cmd-&gt;SCp.Status
op_ne
id|GOOD
)paren
id|cmd-&gt;result
op_assign
(paren
id|cmd-&gt;result
op_amp
l_int|0x00ffff
)paren
op_or
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
r_else
id|cmd-&gt;result
op_assign
id|cmd-&gt;SCp.Status
op_or
(paren
id|cmd-&gt;SCp.Message
op_lshift
l_int|8
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/* We are no longer connected to a target - check to see if&n; * there are commands waiting to be executed.&n; */
multiline_comment|/* look above for comments on scsi_done() */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|wd33c93_execute
c_func
(paren
id|instance
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_DISC
suffix:colon
multiline_comment|/* Make sure that reselection is enabled at this point - it may&n; * have been turned off for the command that just completed.&n; */
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_SOURCE_ID
comma
id|SRCID_ER
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;DISC-%ld&quot;
comma
id|cmd-&gt;pid
)paren
)paren
r_if
c_cond
(paren
id|cmd
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; - Already disconnected! &quot;
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|hostdata-&gt;state
)paren
(brace
r_case
id|S_PRE_CMP_DISC
suffix:colon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;:%d&quot;
comma
id|cmd-&gt;SCp.Status
)paren
)paren
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
id|cmd-&gt;SCp.Status
op_ne
id|GOOD
)paren
id|cmd-&gt;result
op_assign
(paren
id|cmd-&gt;result
op_amp
l_int|0x00ffff
)paren
op_or
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
r_else
id|cmd-&gt;result
op_assign
id|cmd-&gt;SCp.Status
op_or
(paren
id|cmd-&gt;SCp.Message
op_lshift
l_int|8
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_PRE_TMP_DISC
suffix:colon
r_case
id|S_RUNNING_LEVEL2
suffix:colon
id|cmd-&gt;host_scribble
op_assign
(paren
id|uchar
op_star
)paren
id|hostdata-&gt;disconnected_Q
suffix:semicolon
id|hostdata-&gt;disconnected_Q
op_assign
id|cmd
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
macro_line|#ifdef PROC_STATISTICS
id|hostdata-&gt;disc_done_cnt
(braket
id|cmd-&gt;target
)braket
op_increment
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;*** Unexpected DISCONNECT interrupt! ***&quot;
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
)brace
multiline_comment|/* We are no longer connected to a target - check to see if&n; * there are commands waiting to be executed.&n; */
id|wd33c93_execute
c_func
(paren
id|instance
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_RESEL_AM
suffix:colon
r_case
id|CSR_RESEL
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;RESEL%s&quot;
comma
id|sr
op_eq
id|CSR_RESEL_AM
ques
c_cond
l_string|&quot;_AM&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
multiline_comment|/* Old chips (pre -A ???) don&squot;t have advanced features and will&n;    * generate CSR_RESEL.  In that case we have to extract the LUN the&n;    * hard way (see below).&n;    * First we have to make sure this reselection didn&squot;t&n;    * happen during Arbitration/Selection of some other device.&n;    * If yes, put losing command back on top of input_Q.&n;    */
r_if
c_cond
(paren
id|hostdata-&gt;level2
op_le
id|L2_NONE
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;selecting
)paren
(brace
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;selecting
suffix:semicolon
id|hostdata-&gt;selecting
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
(paren
id|uchar
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|hostdata-&gt;input_Q
op_assign
id|cmd
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|phs
op_eq
l_int|0x00
)paren
(brace
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
(paren
id|uchar
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|hostdata-&gt;input_Q
op_assign
id|cmd
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;---%02x:%02x:%02x-TROUBLE: Intrusive ReSelect!---&quot;
comma
id|asr
comma
id|sr
comma
id|phs
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;r&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* OK - find out which device reselected us. */
id|id
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_SOURCE_ID
)paren
suffix:semicolon
id|id
op_and_assign
id|SRCID_MASK
suffix:semicolon
multiline_comment|/* and extract the lun from the ID message. (Note that we don&squot;t&n;    * bother to check for a valid message here - I guess this is&n;    * not the right way to go, but...)&n;    */
r_if
c_cond
(paren
id|sr
op_eq
id|CSR_RESEL_AM
)paren
(brace
id|lun
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;level2
OL
id|L2_RESELECT
)paren
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|lun
op_and_assign
l_int|7
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Old chip; wait for msgin phase to pick up the LUN. */
r_for
c_loop
(paren
id|lun
op_assign
l_int|255
suffix:semicolon
id|lun
suffix:semicolon
id|lun
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
)paren
op_amp
id|ASR_INT
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|asr
op_amp
id|ASR_INT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;wd33c93: Reselected without IDENTIFY&bslash;n&quot;
)paren
suffix:semicolon
id|lun
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Verify this is a change to MSG_IN and read the message */
id|sr
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sr
op_eq
(paren
id|CSR_ABORT
op_or
id|PHS_MESS_IN
)paren
op_logical_or
id|sr
op_eq
(paren
id|CSR_UNEXP
op_or
id|PHS_MESS_IN
)paren
op_logical_or
id|sr
op_eq
(paren
id|CSR_SRV_REQ
op_or
id|PHS_MESS_IN
)paren
)paren
(brace
multiline_comment|/* Got MSG_IN, grab target LUN */
id|lun
op_assign
id|read_1_byte
c_func
(paren
id|regp
)paren
suffix:semicolon
multiline_comment|/* Now we expect a &squot;paused with ACK asserted&squot; int.. */
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|asr
op_amp
id|ASR_INT
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|asr
op_amp
id|ASR_INT
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;wd33c93: No int after LUN on RESEL (%02x)&bslash;n&quot;
comma
id|asr
)paren
suffix:semicolon
)brace
id|sr
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sr
op_ne
id|CSR_MSGIN
)paren
id|printk
c_func
(paren
l_string|&quot;wd33c93: Not paused with ACK on RESEL (%02x)&bslash;n&quot;
comma
id|sr
)paren
suffix:semicolon
id|lun
op_and_assign
l_int|7
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;wd33c93: Not MSG_IN on reselect (%02x)&bslash;n&quot;
comma
id|sr
)paren
suffix:semicolon
id|lun
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Now we look for the command that&squot;s reconnecting. */
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_Q
suffix:semicolon
id|patch
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|id
op_eq
id|cmd-&gt;target
op_logical_and
id|lun
op_eq
id|cmd-&gt;lun
)paren
r_break
suffix:semicolon
id|patch
op_assign
id|cmd
suffix:semicolon
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
)brace
multiline_comment|/* Hmm. Couldn&squot;t find a valid command.... What to do? */
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;---TROUBLE: target %d.%d not in disconnect queue---&quot;
comma
id|id
comma
id|lun
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Ok, found the command - now start it up again. */
r_if
c_cond
(paren
id|patch
)paren
id|patch-&gt;host_scribble
op_assign
id|cmd-&gt;host_scribble
suffix:semicolon
r_else
id|hostdata-&gt;disconnected_Q
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
id|hostdata-&gt;connected
op_assign
id|cmd
suffix:semicolon
multiline_comment|/* We don&squot;t need to worry about &squot;initialize_SCp()&squot; or &squot;hostdata-&gt;busy[]&squot;&n;    * because these things are preserved over a disconnect.&n;    * But we DO need to fix the DPD bit so it&squot;s correct for this command.&n;    */
r_if
c_cond
(paren
id|is_dir_out
c_func
(paren
id|cmd
)paren
)paren
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_DESTINATION_ID
comma
id|cmd-&gt;target
)paren
suffix:semicolon
r_else
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_DESTINATION_ID
comma
id|cmd-&gt;target
op_or
id|DSTID_DPD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;level2
op_ge
id|L2_RESELECT
)paren
(brace
id|write_wd33c93_count
c_func
(paren
id|regp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* we want a DATA_PHASE interrupt */
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_COMMAND_PHASE
comma
l_int|0x45
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
)brace
r_else
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;-%ld&quot;
comma
id|cmd-&gt;pid
)paren
)paren
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;--UNKNOWN INTERRUPT:%02x:%02x:%02x--&quot;
comma
id|asr
comma
id|sr
comma
id|phs
)paren
suffix:semicolon
)brace
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;} &quot;
)paren
)paren
)brace
DECL|function|reset_wd33c93
r_static
r_void
id|reset_wd33c93
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
r_struct
id|WD33C93_hostdata
op_star
id|hostdata
suffix:semicolon
id|wd33c93_regs
op_star
id|regp
suffix:semicolon
id|uchar
id|sr
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|WD33C93_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|regp
op_assign
id|hostdata-&gt;regp
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_OWN_ID
comma
id|OWNID_EAF
op_or
id|OWNID_RAF
op_or
id|instance-&gt;this_id
op_or
id|hostdata-&gt;clock_freq
)paren
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_POLLED
)paren
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_SYNCHRONOUS_TRANSFER
comma
id|calc_sync_xfer
c_func
(paren
id|hostdata-&gt;default_sx_per
op_div
l_int|4
comma
id|DEFAULT_SX_OFF
)paren
)paren
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_COMMAND
comma
id|WD_CMD_RESET
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MVME147_SCSI
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
multiline_comment|/* The old wd33c93 on MVME147 needs this, at least */
macro_line|#endif
r_while
c_loop
(paren
op_logical_neg
(paren
id|READ_AUX_STAT
c_func
(paren
)paren
op_amp
id|ASR_INT
)paren
)paren
suffix:semicolon
id|sr
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
id|hostdata-&gt;microcode
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_CDB_1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sr
op_eq
l_int|0x00
)paren
id|hostdata-&gt;chip
op_assign
id|C_WD33C93
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sr
op_eq
l_int|0x01
)paren
(brace
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_QUEUE_TAG
comma
l_int|0xa5
)paren
suffix:semicolon
multiline_comment|/* any random number */
id|sr
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_QUEUE_TAG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sr
op_eq
l_int|0xa5
)paren
(brace
id|hostdata-&gt;chip
op_assign
id|C_WD33C93B
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_QUEUE_TAG
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|hostdata-&gt;chip
op_assign
id|C_WD33C93A
suffix:semicolon
)brace
r_else
id|hostdata-&gt;chip
op_assign
id|C_UNKNOWN_CHIP
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_TIMEOUT_PERIOD
comma
id|TIMEOUT_PERIOD_VALUE
)paren
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_POLLED
)paren
suffix:semicolon
)brace
DECL|function|wd33c93_reset
r_int
id|wd33c93_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
r_int
id|reset_flags
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_struct
id|WD33C93_hostdata
op_star
id|hostdata
suffix:semicolon
r_int
id|i
suffix:semicolon
id|instance
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|WD33C93_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d: reset. &quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|disable_irq
c_func
(paren
id|instance-&gt;irq
)paren
suffix:semicolon
(paren
(paren
r_struct
id|WD33C93_hostdata
op_star
)paren
id|instance-&gt;hostdata
)paren
op_member_access_from_pointer
id|dma_stop
c_func
(paren
id|instance
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hostdata-&gt;busy
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;sync_xfer
(braket
id|i
)braket
op_assign
id|calc_sync_xfer
c_func
(paren
id|DEFAULT_SX_PER
op_div
l_int|4
comma
id|DEFAULT_SX_OFF
)paren
suffix:semicolon
id|hostdata-&gt;sync_stat
(braket
id|i
)braket
op_assign
id|SS_UNSET
suffix:semicolon
multiline_comment|/* using default sync values */
)brace
id|hostdata-&gt;input_Q
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;selecting
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;disconnected_Q
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
id|hostdata-&gt;dma
op_assign
id|D_DMA_OFF
suffix:semicolon
id|hostdata-&gt;incoming_ptr
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;outgoing_len
op_assign
l_int|0
suffix:semicolon
id|reset_wd33c93
c_func
(paren
id|instance
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|enable_irq
c_func
(paren
id|instance-&gt;irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|wd33c93_abort
r_int
id|wd33c93_abort
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_struct
id|WD33C93_hostdata
op_star
id|hostdata
suffix:semicolon
id|wd33c93_regs
op_star
id|regp
suffix:semicolon
id|Scsi_Cmnd
op_star
id|tmp
comma
op_star
id|prev
suffix:semicolon
id|disable_irq
c_func
(paren
id|cmd-&gt;host-&gt;irq
)paren
suffix:semicolon
id|instance
op_assign
id|cmd-&gt;host
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|WD33C93_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|regp
op_assign
id|hostdata-&gt;regp
suffix:semicolon
multiline_comment|/*&n; * Case 1 : If the command hasn&squot;t been issued yet, we simply remove it&n; *     from the input_Q.&n; */
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|prev
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|tmp
op_eq
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;host_scribble
op_assign
id|cmd-&gt;host_scribble
suffix:semicolon
r_else
id|hostdata-&gt;input_Q
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d: Abort - removing command %ld from input_Q. &quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|cmd-&gt;host-&gt;irq
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
id|prev
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
suffix:semicolon
)brace
multiline_comment|/*&n; * Case 2 : If the command is connected, we&squot;re going to fail the abort&n; *     and let the high level SCSI driver retry at a later time or&n; *     issue a reset.&n; *&n; *     Timeouts, and therefore aborted commands, will be highly unlikely&n; *     and handling them cleanly in this situation would make the common&n; *     case of noresets less efficient, and would pollute our code.  So,&n; *     we fail.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;connected
op_eq
id|cmd
)paren
(brace
id|uchar
id|sr
comma
id|asr
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d: Aborting connected command %ld - &quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;stopping DMA - &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;dma
op_eq
id|D_DMA_RUNNING
)paren
(brace
id|hostdata
op_member_access_from_pointer
id|dma_stop
c_func
(paren
id|instance
comma
id|cmd
comma
l_int|0
)paren
suffix:semicolon
id|hostdata-&gt;dma
op_assign
id|D_DMA_OFF
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;sending wd33c93 ABORT command - &quot;
)paren
suffix:semicolon
id|write_wd33c93
c_func
(paren
id|regp
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_POLLED
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_ABORT
)paren
suffix:semicolon
multiline_comment|/* Now we have to attempt to flush out the FIFO... */
id|printk
c_func
(paren
l_string|&quot;flushing fifo - &quot;
)paren
suffix:semicolon
id|timeout
op_assign
l_int|1000000
suffix:semicolon
r_do
(brace
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asr
op_amp
id|ASR_DBR
)paren
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_DATA
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|asr
op_amp
id|ASR_INT
)paren
op_logical_and
id|timeout
op_decrement
OG
l_int|0
)paren
suffix:semicolon
id|sr
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;asr=%02x, sr=%02x, %ld bytes un-transferred (timeout=%ld) - &quot;
comma
id|asr
comma
id|sr
comma
id|read_wd33c93_count
c_func
(paren
id|regp
)paren
comma
id|timeout
)paren
suffix:semicolon
multiline_comment|/*&n;    * Abort command processed.&n;    * Still connected.&n;    * We must disconnect.&n;    */
id|printk
c_func
(paren
l_string|&quot;sending wd33c93 DISCONNECT command - &quot;
)paren
suffix:semicolon
id|write_wd33c93_cmd
c_func
(paren
id|regp
comma
id|WD_CMD_DISCONNECT
)paren
suffix:semicolon
id|timeout
op_assign
l_int|1000000
suffix:semicolon
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|asr
op_amp
id|ASR_CIP
)paren
op_logical_and
id|timeout
op_decrement
OG
l_int|0
)paren
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
id|sr
op_assign
id|read_wd33c93
c_func
(paren
id|regp
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;asr=%02x, sr=%02x.&quot;
comma
id|asr
comma
id|sr
)paren
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/*      sti();*/
id|wd33c93_execute
(paren
id|instance
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|cmd-&gt;host-&gt;irq
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Case 3: If the command is currently disconnected from the bus,&n; * we&squot;re not going to expend much effort here: Let&squot;s just return&n; * an ABORT_SNOOZE and hope for the best...&n; */
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_Q
suffix:semicolon
r_while
c_loop
(paren
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|tmp
op_eq
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Abort - command %ld found on disconnected_Q - &quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;returning ABORT_SNOOZE. &quot;
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|cmd-&gt;host-&gt;irq
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
suffix:semicolon
)brace
multiline_comment|/*&n; * Case 4 : If we reached this point, the command was not found in any of&n; *     the queues.&n; *&n; * We probably reached this point because of an unlikely race condition&n; * between the command completing successfully and the abortion code,&n; * so we won&squot;t panic, but we will notify the user in case something really&n; * broke.&n; */
multiline_comment|/*   sti();*/
id|wd33c93_execute
(paren
id|instance
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|cmd-&gt;host-&gt;irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d: warning : SCSI command probably completed successfully&quot;
l_string|&quot;         before abortion. &quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
DECL|macro|MAX_WD33C93_HOSTS
mdefine_line|#define MAX_WD33C93_HOSTS 4
DECL|macro|MAX_SETUP_ARGS
mdefine_line|#define MAX_SETUP_ARGS ((int)(sizeof(setup_args) / sizeof(char *)))
DECL|macro|SETUP_BUFFER_SIZE
mdefine_line|#define SETUP_BUFFER_SIZE 200
DECL|variable|setup_buffer
r_static
r_char
id|setup_buffer
(braket
id|SETUP_BUFFER_SIZE
)braket
suffix:semicolon
DECL|variable|setup_used
r_static
r_char
id|setup_used
(braket
id|MAX_SETUP_ARGS
)braket
suffix:semicolon
DECL|variable|done_setup
r_static
r_int
id|done_setup
op_assign
l_int|0
suffix:semicolon
DECL|function|wd33c93_setup
r_int
id|wd33c93_setup
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|p1
comma
op_star
id|p2
suffix:semicolon
multiline_comment|/* The kernel does some processing of the command-line before calling&n;    * this function: If it begins with any decimal or hex number arguments,&n;    * ints[0] = how many numbers found and ints[1] through [n] are the values&n;    * themselves. str points to where the non-numeric arguments (if any)&n;    * start: We do our own parsing of those. We construct synthetic &squot;nosync&squot;&n;    * keywords out of numeric args (to maintain compatibility with older&n;    * versions) and then add the rest of the arguments.&n;    */
id|p1
op_assign
id|setup_buffer
suffix:semicolon
op_star
id|p1
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n; * Old style command line arguments are now dead&n; */
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ints
(braket
l_int|0
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
id|x
op_assign
id|vsprintf
c_func
(paren
id|p1
comma
l_string|&quot;nosync:0x%02x,&quot;
comma
op_amp
(paren
id|ints
(braket
id|i
op_plus
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|p1
op_add_assign
id|x
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|str
)paren
id|strncpy
c_func
(paren
id|p1
comma
id|str
comma
id|SETUP_BUFFER_SIZE
op_minus
id|strlen
c_func
(paren
id|setup_buffer
)paren
)paren
suffix:semicolon
id|setup_buffer
(braket
id|SETUP_BUFFER_SIZE
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|p1
op_assign
id|setup_buffer
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p1
op_logical_and
(paren
id|i
OL
id|MAX_SETUP_ARGS
)paren
)paren
(brace
id|p2
op_assign
id|strchr
c_func
(paren
id|p1
comma
l_char|&squot;,&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p2
)paren
(brace
op_star
id|p2
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|p1
op_ne
id|p2
)paren
id|setup_args
(braket
id|i
)braket
op_assign
id|p1
suffix:semicolon
id|p1
op_assign
id|p2
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_else
(brace
id|setup_args
(braket
id|i
)braket
op_assign
id|p1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SETUP_ARGS
suffix:semicolon
id|i
op_increment
)paren
id|setup_used
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|done_setup
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;wd33c93&quot;
comma
id|wd33c93_setup
)paren
suffix:semicolon
multiline_comment|/* check_setup_args() returns index if key found, 0 if not&n; */
DECL|function|check_setup_args
r_static
r_int
id|check_setup_args
c_func
(paren
r_char
op_star
id|key
comma
r_int
op_star
id|flags
comma
r_int
op_star
id|val
comma
r_char
op_star
id|buf
)paren
(brace
r_int
id|x
suffix:semicolon
r_char
op_star
id|cp
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|MAX_SETUP_ARGS
suffix:semicolon
id|x
op_increment
)paren
(brace
r_if
c_cond
(paren
id|setup_used
(braket
id|x
)braket
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|setup_args
(braket
id|x
)braket
comma
id|key
comma
id|strlen
c_func
(paren
id|key
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|setup_args
(braket
id|x
)braket
comma
l_string|&quot;next&quot;
comma
id|strlen
c_func
(paren
l_string|&quot;next&quot;
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_eq
id|MAX_SETUP_ARGS
)paren
r_return
l_int|0
suffix:semicolon
id|setup_used
(braket
id|x
)braket
op_assign
l_int|1
suffix:semicolon
id|cp
op_assign
id|setup_args
(braket
id|x
)braket
op_plus
id|strlen
c_func
(paren
id|key
)paren
suffix:semicolon
op_star
id|val
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|cp
op_ne
l_char|&squot;:&squot;
)paren
r_return
op_increment
id|x
suffix:semicolon
id|cp
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|cp
op_ge
l_char|&squot;0&squot;
)paren
op_logical_and
(paren
op_star
id|cp
op_le
l_char|&squot;9&squot;
)paren
)paren
(brace
op_star
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|cp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
op_increment
id|x
suffix:semicolon
)brace
DECL|function|wd33c93_init
r_void
id|wd33c93_init
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
id|wd33c93_regs
op_star
id|regs
comma
id|dma_setup_t
id|setup
comma
id|dma_stop_t
id|stop
comma
r_int
id|clock_freq
)paren
(brace
r_struct
id|WD33C93_hostdata
op_star
id|hostdata
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_int
id|val
suffix:semicolon
r_char
id|buf
(braket
l_int|32
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|done_setup
op_logical_and
id|setup_strings
)paren
id|wd33c93_setup
c_func
(paren
id|setup_strings
)paren
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|WD33C93_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|hostdata-&gt;regp
op_assign
id|regs
suffix:semicolon
id|hostdata-&gt;clock_freq
op_assign
id|clock_freq
suffix:semicolon
id|hostdata-&gt;dma_setup
op_assign
id|setup
suffix:semicolon
id|hostdata-&gt;dma_stop
op_assign
id|stop
suffix:semicolon
id|hostdata-&gt;dma_bounce_buffer
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;dma_bounce_len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hostdata-&gt;busy
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;sync_xfer
(braket
id|i
)braket
op_assign
id|calc_sync_xfer
c_func
(paren
id|DEFAULT_SX_PER
op_div
l_int|4
comma
id|DEFAULT_SX_OFF
)paren
suffix:semicolon
id|hostdata-&gt;sync_stat
(braket
id|i
)braket
op_assign
id|SS_UNSET
suffix:semicolon
multiline_comment|/* using default sync values */
macro_line|#ifdef PROC_STATISTICS
id|hostdata-&gt;cmd_cnt
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;disc_allowed_cnt
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;disc_done_cnt
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
id|hostdata-&gt;input_Q
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;selecting
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;disconnected_Q
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
id|hostdata-&gt;dma
op_assign
id|D_DMA_OFF
suffix:semicolon
id|hostdata-&gt;level2
op_assign
id|L2_BASIC
suffix:semicolon
id|hostdata-&gt;disconnect
op_assign
id|DIS_ADAPTIVE
suffix:semicolon
id|hostdata-&gt;args
op_assign
id|DEBUG_DEFAULTS
suffix:semicolon
id|hostdata-&gt;incoming_ptr
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;outgoing_len
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;default_sx_per
op_assign
id|DEFAULT_SX_PER
suffix:semicolon
id|hostdata-&gt;no_sync
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* sync defaults to off */
id|hostdata-&gt;no_dma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default is DMA enabled */
macro_line|#ifdef PROC_INTERFACE
id|hostdata-&gt;proc
op_assign
id|PR_VERSION
op_or
id|PR_INFO
op_or
id|PR_STATISTICS
op_or
id|PR_CONNECTED
op_or
id|PR_INPUTQ
op_or
id|PR_DISCQ
op_or
id|PR_STOP
suffix:semicolon
macro_line|#ifdef PROC_STATISTICS
id|hostdata-&gt;dma_cnt
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;pio_cnt
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;int_cnt
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#endif
r_if
c_cond
(paren
id|check_setup_args
c_func
(paren
l_string|&quot;nosync&quot;
comma
op_amp
id|flags
comma
op_amp
id|val
comma
id|buf
)paren
)paren
id|hostdata-&gt;no_sync
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|check_setup_args
c_func
(paren
l_string|&quot;nodma&quot;
comma
op_amp
id|flags
comma
op_amp
id|val
comma
id|buf
)paren
)paren
id|hostdata-&gt;no_dma
op_assign
(paren
id|val
op_eq
op_minus
l_int|1
)paren
ques
c_cond
l_int|1
suffix:colon
id|val
suffix:semicolon
r_if
c_cond
(paren
id|check_setup_args
c_func
(paren
l_string|&quot;period&quot;
comma
op_amp
id|flags
comma
op_amp
id|val
comma
id|buf
)paren
)paren
id|hostdata-&gt;default_sx_per
op_assign
id|sx_table
(braket
id|round_period
c_func
(paren
(paren
r_int
r_int
)paren
id|val
)paren
)braket
dot
id|period_ns
suffix:semicolon
r_if
c_cond
(paren
id|check_setup_args
c_func
(paren
l_string|&quot;disconnect&quot;
comma
op_amp
id|flags
comma
op_amp
id|val
comma
id|buf
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|val
op_ge
id|DIS_NEVER
)paren
op_logical_and
(paren
id|val
op_le
id|DIS_ALWAYS
)paren
)paren
id|hostdata-&gt;disconnect
op_assign
id|val
suffix:semicolon
r_else
id|hostdata-&gt;disconnect
op_assign
id|DIS_ADAPTIVE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_setup_args
c_func
(paren
l_string|&quot;level2&quot;
comma
op_amp
id|flags
comma
op_amp
id|val
comma
id|buf
)paren
)paren
id|hostdata-&gt;level2
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|check_setup_args
c_func
(paren
l_string|&quot;debug&quot;
comma
op_amp
id|flags
comma
op_amp
id|val
comma
id|buf
)paren
)paren
id|hostdata-&gt;args
op_assign
id|val
op_amp
id|DB_MASK
suffix:semicolon
r_if
c_cond
(paren
id|check_setup_args
c_func
(paren
l_string|&quot;clock&quot;
comma
op_amp
id|flags
comma
op_amp
id|val
comma
id|buf
)paren
)paren
(brace
r_if
c_cond
(paren
id|val
OG
l_int|7
op_logical_and
id|val
OL
l_int|11
)paren
id|val
op_assign
id|WD33C93_FS_8_10
suffix:semicolon
r_else
r_if
c_cond
(paren
id|val
OG
l_int|11
op_logical_and
id|val
OL
l_int|16
)paren
id|val
op_assign
id|WD33C93_FS_12_15
suffix:semicolon
r_else
r_if
c_cond
(paren
id|val
OG
l_int|15
op_logical_and
id|val
OL
l_int|21
)paren
id|val
op_assign
id|WD33C93_FS_16_20
suffix:semicolon
r_else
id|val
op_assign
id|WD33C93_FS_8_10
suffix:semicolon
id|hostdata-&gt;clock_freq
op_assign
id|val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|i
op_assign
id|check_setup_args
c_func
(paren
l_string|&quot;next&quot;
comma
op_amp
id|flags
comma
op_amp
id|val
comma
id|buf
)paren
)paren
)paren
(brace
r_while
c_loop
(paren
id|i
)paren
id|setup_used
(braket
op_decrement
id|i
)braket
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef PROC_INTERFACE
r_if
c_cond
(paren
id|check_setup_args
c_func
(paren
l_string|&quot;proc&quot;
comma
op_amp
id|flags
comma
op_amp
id|val
comma
id|buf
)paren
)paren
id|hostdata-&gt;proc
op_assign
id|val
suffix:semicolon
macro_line|#endif
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|reset_wd33c93
c_func
(paren
id|instance
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;wd33c93-%d: chip=%s/%d no_sync=0x%x no_dma=%d&quot;
comma
id|instance-&gt;host_no
comma
(paren
id|hostdata-&gt;chip
op_eq
id|C_WD33C93
)paren
ques
c_cond
l_string|&quot;WD33c93&quot;
suffix:colon
(paren
id|hostdata-&gt;chip
op_eq
id|C_WD33C93A
)paren
ques
c_cond
l_string|&quot;WD33c93A&quot;
suffix:colon
(paren
id|hostdata-&gt;chip
op_eq
id|C_WD33C93B
)paren
ques
c_cond
l_string|&quot;WD33c93B&quot;
suffix:colon
l_string|&quot;unknown&quot;
comma
id|hostdata-&gt;microcode
comma
id|hostdata-&gt;no_sync
comma
id|hostdata-&gt;no_dma
)paren
suffix:semicolon
macro_line|#ifdef DEBUGGING_ON
id|printk
c_func
(paren
l_string|&quot; debug_flags=0x%02x&bslash;n&quot;
comma
id|hostdata-&gt;args
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot; debugging=OFF&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;           setup_args=&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SETUP_ARGS
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%s,&quot;
comma
id|setup_args
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;           Version %s - %s, Compiled %s at %s&bslash;n&quot;
comma
id|WD33C93_VERSION
comma
id|WD33C93_DATE
comma
id|__DATE__
comma
id|__TIME__
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
)brace
DECL|function|wd33c93_proc_info
r_int
id|wd33c93_proc_info
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|len
comma
r_int
id|hn
comma
r_int
id|in
)paren
(brace
macro_line|#ifdef PROC_INTERFACE
r_char
op_star
id|bp
suffix:semicolon
r_char
id|tbuf
(braket
l_int|128
)braket
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_struct
id|WD33C93_hostdata
op_star
id|hd
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_int
id|x
comma
id|i
suffix:semicolon
r_static
r_int
id|stop
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|instance
op_assign
id|scsi_hostlist
suffix:semicolon
id|instance
suffix:semicolon
id|instance
op_assign
id|instance-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|instance-&gt;host_no
op_eq
id|hn
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|instance
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;*** Hmm... Can&squot;t find host #%d!&bslash;n&quot;
comma
id|hn
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ESRCH
)paren
suffix:semicolon
)brace
id|hd
op_assign
(paren
r_struct
id|WD33C93_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
multiline_comment|/* If &squot;in&squot; is TRUE we need to _read_ the proc file. We accept the following&n; * keywords (same format as command-line, but only ONE per read):&n; *    debug&n; *    disconnect&n; *    period&n; *    resync&n; *    proc&n; *    nodma&n; */
r_if
c_cond
(paren
id|in
)paren
(brace
id|buf
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|bp
op_assign
id|buf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|bp
comma
l_string|&quot;debug:&quot;
comma
l_int|6
)paren
)paren
(brace
id|bp
op_add_assign
l_int|6
suffix:semicolon
id|hd-&gt;args
op_assign
id|simple_strtoul
c_func
(paren
id|bp
comma
l_int|NULL
comma
l_int|0
)paren
op_amp
id|DB_MASK
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|bp
comma
l_string|&quot;disconnect:&quot;
comma
l_int|11
)paren
)paren
(brace
id|bp
op_add_assign
l_int|11
suffix:semicolon
id|x
op_assign
id|simple_strtoul
c_func
(paren
id|bp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
template_param
id|DIS_ALWAYS
)paren
id|x
op_assign
id|DIS_ADAPTIVE
suffix:semicolon
id|hd-&gt;disconnect
op_assign
id|x
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|bp
comma
l_string|&quot;period:&quot;
comma
l_int|7
)paren
)paren
(brace
id|bp
op_add_assign
l_int|7
suffix:semicolon
id|x
op_assign
id|simple_strtoul
c_func
(paren
id|bp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|hd-&gt;default_sx_per
op_assign
id|sx_table
(braket
id|round_period
c_func
(paren
(paren
r_int
r_int
)paren
id|x
)paren
)braket
dot
id|period_ns
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|bp
comma
l_string|&quot;resync:&quot;
comma
l_int|7
)paren
)paren
(brace
id|bp
op_add_assign
l_int|7
suffix:semicolon
id|x
op_assign
id|simple_strtoul
c_func
(paren
id|bp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|x
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|hd-&gt;sync_stat
(braket
id|i
)braket
op_assign
id|SS_UNSET
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|bp
comma
l_string|&quot;proc:&quot;
comma
l_int|5
)paren
)paren
(brace
id|bp
op_add_assign
l_int|5
suffix:semicolon
id|hd-&gt;proc
op_assign
id|simple_strtoul
c_func
(paren
id|bp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|bp
comma
l_string|&quot;nodma:&quot;
comma
l_int|6
)paren
)paren
(brace
id|bp
op_add_assign
l_int|6
suffix:semicolon
id|hd-&gt;no_dma
op_assign
id|simple_strtoul
c_func
(paren
id|bp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|bp
comma
l_string|&quot;level2:&quot;
comma
l_int|7
)paren
)paren
(brace
id|bp
op_add_assign
l_int|7
suffix:semicolon
id|hd-&gt;level2
op_assign
id|simple_strtoul
c_func
(paren
id|bp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|bp
op_assign
id|buf
suffix:semicolon
op_star
id|bp
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;proc
op_amp
id|PR_VERSION
)paren
(brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot;&bslash;nVersion %s - %s. Compiled %s %s&quot;
comma
id|WD33C93_VERSION
comma
id|WD33C93_DATE
comma
id|__DATE__
comma
id|__TIME__
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hd-&gt;proc
op_amp
id|PR_INFO
)paren
(brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot;&bslash;nclock_freq=%02x no_sync=%02x no_dma=%d&quot;
comma
id|hd-&gt;clock_freq
comma
id|hd-&gt;no_sync
comma
id|hd-&gt;no_dma
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;nsync_xfer[] =       &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|7
suffix:semicolon
id|x
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot;&bslash;t%02x&quot;
comma
id|hd-&gt;sync_xfer
(braket
id|x
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
)brace
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;nsync_stat[] =       &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|7
suffix:semicolon
id|x
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot;&bslash;t%02x&quot;
comma
id|hd-&gt;sync_stat
(braket
id|x
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef PROC_STATISTICS
r_if
c_cond
(paren
id|hd-&gt;proc
op_amp
id|PR_STATISTICS
)paren
(brace
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;ncommands issued:    &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|7
suffix:semicolon
id|x
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot;&bslash;t%ld&quot;
comma
id|hd-&gt;cmd_cnt
(braket
id|x
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
)brace
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;ndisconnects allowed:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|7
suffix:semicolon
id|x
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot;&bslash;t%ld&quot;
comma
id|hd-&gt;disc_allowed_cnt
(braket
id|x
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
)brace
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;ndisconnects done:   &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|7
suffix:semicolon
id|x
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot;&bslash;t%ld&quot;
comma
id|hd-&gt;disc_done_cnt
(braket
id|x
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot;&bslash;ninterrupts: %ld, DATA_PHASE ints: %ld DMA, %ld PIO&quot;
comma
id|hd-&gt;int_cnt
comma
id|hd-&gt;dma_cnt
comma
id|hd-&gt;pio_cnt
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|hd-&gt;proc
op_amp
id|PR_CONNECTED
)paren
(brace
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;nconnected:     &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;connected
)paren
(brace
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hd-&gt;connected
suffix:semicolon
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot; %ld-%d:%d(%02x)&quot;
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|hd-&gt;proc
op_amp
id|PR_INPUTQ
)paren
(brace
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;ninput_Q:       &quot;
)paren
suffix:semicolon
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hd-&gt;input_Q
suffix:semicolon
r_while
c_loop
(paren
id|cmd
)paren
(brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot; %ld-%d:%d(%02x)&quot;
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|hd-&gt;proc
op_amp
id|PR_DISCQ
)paren
(brace
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;ndisconnected_Q:&quot;
)paren
suffix:semicolon
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hd-&gt;disconnected_Q
suffix:semicolon
r_while
c_loop
(paren
id|cmd
)paren
(brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot; %ld-%d:%d(%02x)&quot;
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
)brace
)brace
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|stop
)paren
(brace
id|stop
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|off
OG
l_int|0x40000
)paren
multiline_comment|/* ALWAYS stop after 256k bytes have been read */
id|stop
op_assign
l_int|1
suffix:semicolon
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;proc
op_amp
id|PR_STOP
)paren
multiline_comment|/* stop every other time */
id|stop
op_assign
l_int|1
suffix:semicolon
r_return
id|strlen
c_func
(paren
id|bp
)paren
suffix:semicolon
macro_line|#else    /* PROC_INTERFACE */
r_return
l_int|0
suffix:semicolon
macro_line|#endif   /* PROC_INTERFACE */
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
)brace
DECL|function|wd33c93_release
r_void
id|wd33c93_release
c_func
(paren
r_void
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
macro_line|#endif
eof
