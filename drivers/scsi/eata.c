multiline_comment|/*&n; *      eata.c - Low-level driver for EATA/DMA SCSI host adapters.&n; *&n; *      11 Feb 1995 rev. 1.17 for linux 1.1.91&n; *          Now DEBUG_RESET is disabled by default.&n; *          Register a board even if it does not assert DMA protocol support&n; *          (DPT SK2011B does not report correctly the dmasup bit).&n; *&n; *       9 Feb 1995 rev. 1.16 for linux 1.1.90&n; *          Use host-&gt;wish_block instead of host-&gt;block.&n; *          New list of Data Out SCSI commands.&n; *&n; *       8 Feb 1995 rev. 1.15 for linux 1.1.89&n; *          Cleared target_time_out counter while performing a reset.&n; *          All external symbols renamed to avoid possible name conflicts.&n; *&n; *      28 Jan 1995 rev. 1.14 for linux 1.1.86&n; *          Added module support.&n; *          Log and do a retry when a disk drive returns a target status &n; *          different from zero on a recovered error.&n; *&n; *      24 Jan 1995 rev. 1.13 for linux 1.1.85&n; *          Use optimized board configuration, with a measured performance&n; *          increase in the range 10%-20% on i/o throughput.&n; *&n; *      16 Jan 1995 rev. 1.12 for linux 1.1.81&n; *          Fix mscp structure comments (no functional change).&n; *          Display a message if check_region detects a port address&n; *          already in use.&n; *&n; *      17 Dec 1994 rev. 1.11 for linux 1.1.74&n; *          Use the scsicam_bios_param routine. This allows an easy&n; *          migration path from disk partition tables created using &n; *          different SCSI drivers and non optimal disk geometry.&n; *&n; *      15 Dec 1994 rev. 1.10 for linux 1.1.74&n; *          Added support for ISA EATA boards (DPT PM2011, DPT PM2021).&n; *          The host-&gt;block flag is set for all the detected ISA boards.&n; *          The detect routine no longer enforces LEVEL triggering&n; *          for EISA boards, it just prints a warning message.&n; *&n; *      30 Nov 1994 rev. 1.09 for linux 1.1.68&n; *          Redo i/o on target status CHECK_CONDITION for TYPE_DISK only.&n; *          Added optional support for using a single board at a time.&n; *&n; *      18 Nov 1994 rev. 1.08 for linux 1.1.64&n; *          Forces sg_tablesize = 64 and can_queue = 64 if these&n; *          values are not correctly detected (DPT PM2012).&n; *&n; *      14 Nov 1994 rev. 1.07 for linux 1.1.63  Final BETA release.&n; *      04 Aug 1994 rev. 1.00 for linux 1.1.39  First BETA release.&n; *&n; *&n; *          This driver is based on the CAM (Common Access Method Committee)&n; *          EATA (Enhanced AT Bus Attachment) rev. 2.0A, using DMA protocol.&n; *&n; *      Copyright (C) 1994, 1995 Dario Ballabio (dario@milano.europe.dg.com)&n; *&n; */
multiline_comment|/*&n; *&n; *  Here is a brief description of the DPT SCSI host adapters.&n; *  All these boards provide an EATA/DMA compatible programming interface&n; *  and are fully supported by this driver:&n; *&n; *  PM2011B/9X -  Entry Level ISA&n; *  PM2021A/9X -  High Performance ISA&n; *  PM2012A       Old EISA&n; *  PM2012B       Old EISA&n; *  PM2022A/9X -  Entry Level EISA&n; *  PM2122A/9X -  High Performance EISA&n; *  PM2322A/9X -  Extra High Performance EISA&n; *&n; *  The DPT PM2001 provides only the EATA/PIO interface and hence is not&n; *  supported by this driver.&n; *&n; *  This code has been tested with up to 3 Distributed Processing Technology &n; *  PM2122A/9X (DPT SCSI BIOS v002.D1, firmware v05E.0) eisa controllers,&n; *  no on board cache and no RAID option. &n; *  BIOS must be enabled on the first board and must be disabled for all other &n; *  boards. &n; *  Support is provided for any number of DPT PM2122 eisa boards.&n; *  All boards should be configured at the same IRQ level.&n; *  Multiple IRQ configurations are supported too.&n; *  Boards can be located in any eisa slot (1-15) and are named EATA0, &n; *  EATA1,... in increasing eisa slot number. ISA boards are detected&n; *  after the eisa slot probes.&n; *&n; *  The IRQ for EISA boards should be _level_ triggered (not _edge_ triggered).&n; *  This is a requirement in order to support multiple boards on the same IRQ.&n; *&n; *  Other eisa configuration parameters are:&n; *&n; *  COMMAND QUEUING   : ENABLED&n; *  COMMAND TIMEOUT   : ENABLED&n; *  CACHE             : DISABLED&n; *&n; *  In order to support multiple ISA boards in a reliable way,&n; *  the driver sets host-&gt;wish_block = TRUE for all ISA boards.&n; */
macro_line|#if defined(MODULE)
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &quot;../block/blk.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &quot;linux/in.h&quot;
macro_line|#include &quot;eata.h&quot;
multiline_comment|/* Subversion values */
DECL|macro|ISA
mdefine_line|#define ISA  0
DECL|macro|ESA
mdefine_line|#define ESA 1
DECL|macro|FORCE_CONFIG
macro_line|#undef FORCE_CONFIG
DECL|macro|DEBUG_DETECT
macro_line|#undef  DEBUG_DETECT
DECL|macro|DEBUG_INTERRUPT
macro_line|#undef  DEBUG_INTERRUPT
DECL|macro|DEBUG_STATISTICS
macro_line|#undef  DEBUG_STATISTICS
DECL|macro|DEBUG_RESET
macro_line|#undef  DEBUG_RESET
DECL|macro|MAX_TARGET
mdefine_line|#define MAX_TARGET 8
DECL|macro|MAX_IRQ
mdefine_line|#define MAX_IRQ 16
DECL|macro|MAX_BOARDS
mdefine_line|#define MAX_BOARDS 18
DECL|macro|MAX_MAILBOXES
mdefine_line|#define MAX_MAILBOXES 64
DECL|macro|MAX_SGLIST
mdefine_line|#define MAX_SGLIST 64
DECL|macro|MAX_CMD_PER_LUN
mdefine_line|#define MAX_CMD_PER_LUN 2
DECL|macro|FALSE
mdefine_line|#define FALSE 0
DECL|macro|TRUE
mdefine_line|#define TRUE 1
DECL|macro|FREE
mdefine_line|#define FREE 0
DECL|macro|IN_USE
mdefine_line|#define IN_USE   1
DECL|macro|LOCKED
mdefine_line|#define LOCKED   2
DECL|macro|IN_RESET
mdefine_line|#define IN_RESET 3
DECL|macro|IGNORE
mdefine_line|#define IGNORE   4
DECL|macro|NO_IRQ
mdefine_line|#define NO_IRQ  0xff
DECL|macro|NO_DMA
mdefine_line|#define NO_DMA  0xff
DECL|macro|MAXLOOP
mdefine_line|#define MAXLOOP 200000
DECL|macro|REG_CMD
mdefine_line|#define REG_CMD         7
DECL|macro|REG_STATUS
mdefine_line|#define REG_STATUS      7
DECL|macro|REG_AUX_STATUS
mdefine_line|#define REG_AUX_STATUS  8
DECL|macro|REG_DATA
mdefine_line|#define REG_DATA        0
DECL|macro|REG_DATA2
mdefine_line|#define REG_DATA2       1
DECL|macro|REG_SEE
mdefine_line|#define REG_SEE         6
DECL|macro|REG_LOW
mdefine_line|#define REG_LOW         2
DECL|macro|REG_LM
mdefine_line|#define REG_LM          3
DECL|macro|REG_MID
mdefine_line|#define REG_MID         4
DECL|macro|REG_MSB
mdefine_line|#define REG_MSB         5
DECL|macro|REGION_SIZE
mdefine_line|#define REGION_SIZE     9
DECL|macro|EISA_RANGE
mdefine_line|#define EISA_RANGE      0xf000
DECL|macro|BSY_ASSERTED
mdefine_line|#define BSY_ASSERTED      0x80
DECL|macro|DRQ_ASSERTED
mdefine_line|#define DRQ_ASSERTED      0x08
DECL|macro|ABSY_ASSERTED
mdefine_line|#define ABSY_ASSERTED     0x01
DECL|macro|IRQ_ASSERTED
mdefine_line|#define IRQ_ASSERTED      0x02
DECL|macro|READ_CONFIG_PIO
mdefine_line|#define READ_CONFIG_PIO   0xf0
DECL|macro|SET_CONFIG_PIO
mdefine_line|#define SET_CONFIG_PIO    0xf1
DECL|macro|SEND_CP_PIO
mdefine_line|#define SEND_CP_PIO       0xf2
DECL|macro|RECEIVE_SP_PIO
mdefine_line|#define RECEIVE_SP_PIO    0xf3
DECL|macro|TRUNCATE_XFR_PIO
mdefine_line|#define TRUNCATE_XFR_PIO  0xf4
DECL|macro|RESET_PIO
mdefine_line|#define RESET_PIO         0xf9
DECL|macro|READ_CONFIG_DMA
mdefine_line|#define READ_CONFIG_DMA   0xfd
DECL|macro|SET_CONFIG_DMA
mdefine_line|#define SET_CONFIG_DMA    0xfe
DECL|macro|SEND_CP_DMA
mdefine_line|#define SEND_CP_DMA       0xff
DECL|macro|ASOK
mdefine_line|#define ASOK              0x00
DECL|macro|ASST
mdefine_line|#define ASST              0x01
DECL|macro|ARRAY_SIZE
mdefine_line|#define ARRAY_SIZE(arr) (sizeof (arr) / sizeof (arr)[0])
multiline_comment|/* &quot;EATA&quot;, in Big Endian format */
DECL|macro|EATA_SIGNATURE
mdefine_line|#define EATA_SIGNATURE 0x41544145
multiline_comment|/* Number of valid bytes in the board config structure for EATA 2.0x */
DECL|macro|EATA_2_0A_SIZE
mdefine_line|#define EATA_2_0A_SIZE 28
DECL|macro|EATA_2_0B_SIZE
mdefine_line|#define EATA_2_0B_SIZE 30
multiline_comment|/* Board info structure */
DECL|struct|eata_info
r_struct
id|eata_info
(brace
DECL|member|data_len
id|ulong
id|data_len
suffix:semicolon
multiline_comment|/* Number of valid bytes after this field */
DECL|member|sign
id|ulong
id|sign
suffix:semicolon
multiline_comment|/* ASCII &quot;EATA&quot; signature */
DECL|member|unchar
id|unchar
suffix:colon
l_int|4
comma
multiline_comment|/* unused low nibble */
DECL|member|version
id|version
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* EATA version, should be 0x1 */
DECL|member|ocsena
id|unchar
id|ocsena
suffix:colon
l_int|1
comma
multiline_comment|/* Overlap Command Support Enabled */
DECL|member|tarsup
id|tarsup
suffix:colon
l_int|1
comma
multiline_comment|/* Target Mode Supported */
suffix:colon
l_int|2
comma
DECL|member|dmasup
id|dmasup
suffix:colon
l_int|1
comma
multiline_comment|/* DMA Supported */
DECL|member|drqvld
id|drqvld
suffix:colon
l_int|1
comma
multiline_comment|/* DRQ Index (DRQX) is valid */
DECL|member|ata
id|ata
suffix:colon
l_int|1
comma
multiline_comment|/* This is an ATA device */
DECL|member|haaval
id|haaval
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Host Adapter Address Valid */
DECL|member|cp_pad_len
id|ushort
id|cp_pad_len
suffix:semicolon
multiline_comment|/* Number of pad bytes after cp_len */
DECL|member|host_addr
id|unchar
id|host_addr
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Host Adapter SCSI ID for channels 2, 1, 0 */
DECL|member|reserved
id|unchar
id|reserved
suffix:semicolon
DECL|member|cp_len
id|ulong
id|cp_len
suffix:semicolon
multiline_comment|/* Number of valid bytes in cp */
DECL|member|sp_len
id|ulong
id|sp_len
suffix:semicolon
multiline_comment|/* Number of valid bytes in sp */
DECL|member|queue_size
id|ushort
id|queue_size
suffix:semicolon
multiline_comment|/* Max number of cp that can be queued */
DECL|member|unused
id|ushort
id|unused
suffix:semicolon
DECL|member|scatt_size
id|ushort
id|scatt_size
suffix:semicolon
multiline_comment|/* Max number of entries in scatter/gather table */
DECL|member|irq
id|unchar
id|irq
suffix:colon
l_int|4
comma
multiline_comment|/* Interrupt Request assigned to this controller */
DECL|member|irq_tr
id|irq_tr
suffix:colon
l_int|1
comma
multiline_comment|/* 0 for edge triggered, 1 for level triggered */
DECL|member|second
id|second
suffix:colon
l_int|1
comma
multiline_comment|/* 1 if this is a secondary (not primary) controller */
DECL|member|drqx
id|drqx
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* DRQ Index (0=DMA0, 1=DMA7, 2=DMA6, 3=DMA5) */
DECL|member|sync
id|unchar
id|sync
suffix:semicolon
multiline_comment|/* 1 if scsi target id 7...0 is running sync scsi */
multiline_comment|/* Structure extension defined in EATA 2.0B */
DECL|member|isaena
id|unchar
id|isaena
suffix:colon
l_int|1
comma
multiline_comment|/* ISA i/o addressing is disabled/enabled */
DECL|member|forcaddr
id|forcaddr
suffix:colon
l_int|1
comma
multiline_comment|/* Port address has been forced */
suffix:colon
l_int|6
suffix:semicolon
DECL|member|max_id
id|unchar
id|max_id
suffix:colon
l_int|5
comma
multiline_comment|/* Max number of SCSI target IDs */
DECL|member|max_chan
id|max_chan
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* Max SCSI channel number on this board */
DECL|member|ipad
id|ushort
id|ipad
(braket
l_int|249
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Board config structure */
DECL|struct|eata_config
r_struct
id|eata_config
(brace
DECL|member|len
id|ushort
id|len
suffix:semicolon
multiline_comment|/* Number of bytes following this field */
DECL|member|edis
id|unchar
id|edis
suffix:colon
l_int|1
comma
multiline_comment|/* Disable EATA interface after config command */
DECL|member|ocena
id|ocena
suffix:colon
l_int|1
comma
multiline_comment|/* Overlapped Commands Enabled */
DECL|member|mdpena
id|mdpena
suffix:colon
l_int|1
comma
multiline_comment|/* Transfer all Modified Data Pointer Messages */
DECL|member|tarena
id|tarena
suffix:colon
l_int|1
comma
multiline_comment|/* Target Mode Enabled for this controller */
suffix:colon
l_int|4
suffix:semicolon
DECL|member|cpad
id|unchar
id|cpad
(braket
l_int|511
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Returned status packet structure */
DECL|struct|mssp
r_struct
id|mssp
(brace
DECL|member|adapter_status
id|unchar
id|adapter_status
suffix:colon
l_int|7
comma
multiline_comment|/* State related to current command */
DECL|member|eoc
id|eoc
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* End Of Command (1 = command completed) */
DECL|member|target_status
id|unchar
id|target_status
suffix:semicolon
multiline_comment|/* SCSI status received after data transfer */
DECL|member|unused
id|unchar
id|unused
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|inv_res_len
id|ulong
id|inv_res_len
suffix:semicolon
multiline_comment|/* Number of bytes not transferred */
DECL|member|SCpnt
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
multiline_comment|/* Address set in cp */
DECL|member|mess
r_char
id|mess
(braket
l_int|12
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* MailBox SCSI Command Packet */
DECL|struct|mscp
r_struct
id|mscp
(brace
DECL|member|sreset
id|unchar
id|sreset
suffix:colon
l_int|1
comma
multiline_comment|/* SCSI Bus Reset Signal should be asserted */
DECL|member|init
id|init
suffix:colon
l_int|1
comma
multiline_comment|/* Re-initialize controller and self test */
DECL|member|reqsen
id|reqsen
suffix:colon
l_int|1
comma
multiline_comment|/* Transfer Request Sense Data to addr using DMA */
DECL|member|sg
id|sg
suffix:colon
l_int|1
comma
multiline_comment|/* Use Scatter/Gather */
suffix:colon
l_int|1
comma
DECL|member|interp
id|interp
suffix:colon
l_int|1
comma
multiline_comment|/* The controller interprets cp, not the target */
DECL|member|dout
id|dout
suffix:colon
l_int|1
comma
multiline_comment|/* Direction of Transfer is Out (Host to Target) */
DECL|member|din
id|din
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Direction of Transfer is In (Target to Host) */
DECL|member|sense_len
id|unchar
id|sense_len
suffix:semicolon
multiline_comment|/* Request Sense Length */
DECL|member|unused
id|unchar
id|unused
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|phsunit
id|unchar
id|phsunit
suffix:colon
l_int|1
comma
multiline_comment|/* Send to Target Physical Unit (bypass RAID) */
DECL|member|notused
id|notused
suffix:colon
l_int|7
suffix:semicolon
DECL|member|target
id|unchar
id|target
suffix:semicolon
multiline_comment|/* SCSI Target ID */
DECL|member|lun
id|unchar
id|lun
suffix:colon
l_int|3
comma
multiline_comment|/* LUN */
suffix:colon
l_int|2
comma
DECL|member|luntar
id|luntar
suffix:colon
l_int|1
comma
multiline_comment|/* This cp is for Target (not LUN) */
DECL|member|dispri
id|dispri
suffix:colon
l_int|1
comma
multiline_comment|/* Disconnect Privilege granted */
DECL|member|one
id|one
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 1 */
DECL|member|mess
id|unchar
id|mess
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Massage to/from Target */
DECL|member|cdb
id|unchar
id|cdb
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/* Command Descriptor Block */
DECL|member|data_len
id|ulong
id|data_len
suffix:semicolon
multiline_comment|/* If sg=0 Data Length, if sg=1 sglist length */
DECL|member|SCpnt
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
multiline_comment|/* Address to be returned is sp */
DECL|member|data_address
id|ulong
id|data_address
suffix:semicolon
multiline_comment|/* If sg=0 Data Address, if sg=1 sglist address */
DECL|member|sp_addr
id|ulong
id|sp_addr
suffix:semicolon
multiline_comment|/* Address where sp is DMA&squot;ed when cp completes */
DECL|member|sense_addr
id|ulong
id|sense_addr
suffix:semicolon
multiline_comment|/* Address where Sense Data is DMA&squot;ed on error */
DECL|struct|sg_list
r_struct
id|sg_list
(brace
DECL|member|address
r_int
r_int
id|address
suffix:semicolon
multiline_comment|/* Segment Address */
DECL|member|num_bytes
r_int
r_int
id|num_bytes
suffix:semicolon
multiline_comment|/* Segment Length */
DECL|member|sglist
)brace
id|sglist
(braket
id|MAX_SGLIST
)braket
suffix:semicolon
DECL|member|index
r_int
r_int
id|index
suffix:semicolon
multiline_comment|/* cp index */
)brace
suffix:semicolon
DECL|struct|hostdata
r_struct
id|hostdata
(brace
DECL|member|cp
r_struct
id|mscp
id|cp
(braket
id|MAX_MAILBOXES
)braket
suffix:semicolon
multiline_comment|/* Mailboxes for this board */
DECL|member|cp_stat
r_int
r_int
id|cp_stat
(braket
id|MAX_MAILBOXES
)braket
suffix:semicolon
multiline_comment|/* FREE, IN_USE, LOCKED, IN_RESET */
DECL|member|last_cp_used
r_int
r_int
id|last_cp_used
suffix:semicolon
multiline_comment|/* Index of last mailbox used */
DECL|member|iocount
r_int
r_int
id|iocount
suffix:semicolon
multiline_comment|/* Total i/o done for this board */
DECL|member|multicount
r_int
r_int
id|multicount
suffix:semicolon
multiline_comment|/* Total ... in second ihdlr loop */
DECL|member|board_number
r_int
id|board_number
suffix:semicolon
multiline_comment|/* Number of this board */
DECL|member|board_name
r_char
id|board_name
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Name of this board */
DECL|member|board_id
r_char
id|board_id
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/* data from INQUIRY on this board */
DECL|member|in_reset
r_int
id|in_reset
suffix:semicolon
multiline_comment|/* True if board is doing a reset */
DECL|member|target_time_out
r_int
id|target_time_out
(braket
id|MAX_TARGET
)braket
suffix:semicolon
multiline_comment|/* N. of timeout errors on target */
DECL|member|target_reset
r_int
id|target_reset
(braket
id|MAX_TARGET
)braket
suffix:semicolon
multiline_comment|/* If TRUE redo operation on target */
DECL|member|subversion
r_int
r_char
id|subversion
suffix:semicolon
multiline_comment|/* Bus type, either ISA or ESA */
DECL|member|protocol_rev
r_int
r_char
id|protocol_rev
suffix:semicolon
multiline_comment|/* EATA 2.0 rev., &squot;A&squot; or &squot;B&squot; or &squot;C&squot; */
DECL|member|sp
r_struct
id|mssp
id|sp
(braket
id|MAX_MAILBOXES
)braket
suffix:semicolon
multiline_comment|/* Returned status for this board */
)brace
suffix:semicolon
DECL|variable|sh
r_static
r_struct
id|Scsi_Host
op_star
id|sh
(braket
id|MAX_BOARDS
op_plus
l_int|1
)braket
suffix:semicolon
DECL|variable|driver_name
r_static
r_char
op_star
id|driver_name
op_assign
l_string|&quot;EATA&quot;
suffix:semicolon
DECL|variable|irqlist
DECL|variable|calls
r_static
r_int
r_int
id|irqlist
(braket
id|MAX_IRQ
)braket
comma
id|calls
(braket
id|MAX_IRQ
)braket
suffix:semicolon
DECL|macro|HD
mdefine_line|#define HD(board) ((struct hostdata *) &amp;sh[board]-&gt;hostdata)
DECL|macro|BN
mdefine_line|#define BN(board) (HD(board)-&gt;board_name)
r_static
r_void
id|eata2x_interrupt_handler
c_func
(paren
r_int
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
DECL|variable|do_trace
r_static
r_int
id|do_trace
op_assign
id|FALSE
suffix:semicolon
DECL|function|wait_on_busy
r_static
r_inline
id|unchar
id|wait_on_busy
c_func
(paren
id|ushort
id|iobase
)paren
(brace
r_int
r_int
id|loop
op_assign
id|MAXLOOP
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|iobase
op_plus
id|REG_AUX_STATUS
)paren
op_amp
id|ABSY_ASSERTED
)paren
r_if
c_cond
(paren
op_decrement
id|loop
op_eq
l_int|0
)paren
r_return
id|TRUE
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
DECL|function|do_dma
r_static
r_inline
id|unchar
id|do_dma
(paren
id|ushort
id|iobase
comma
r_int
r_int
id|addr
comma
id|unchar
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|wait_on_busy
c_func
(paren
id|iobase
)paren
)paren
r_return
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|addr
)paren
(brace
id|outb
c_func
(paren
(paren
r_char
)paren
id|addr
comma
id|iobase
op_plus
id|REG_LOW
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
r_char
)paren
(paren
id|addr
op_rshift
l_int|8
)paren
comma
id|iobase
op_plus
id|REG_LM
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
r_char
)paren
(paren
id|addr
op_rshift
l_int|16
)paren
comma
id|iobase
op_plus
id|REG_MID
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
r_char
)paren
(paren
id|addr
op_rshift
l_int|24
)paren
comma
id|iobase
op_plus
id|REG_MSB
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|cmd
comma
id|iobase
op_plus
id|REG_CMD
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
DECL|function|read_pio
r_static
r_inline
id|unchar
id|read_pio
(paren
id|ushort
id|iobase
comma
id|ushort
op_star
id|start
comma
id|ushort
op_star
id|end
)paren
(brace
r_int
r_int
id|loop
op_assign
id|MAXLOOP
suffix:semicolon
id|ushort
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|start
suffix:semicolon
id|p
op_le
id|end
suffix:semicolon
id|p
op_increment
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|iobase
op_plus
id|REG_STATUS
)paren
op_amp
id|DRQ_ASSERTED
)paren
)paren
r_if
c_cond
(paren
op_decrement
id|loop
op_eq
l_int|0
)paren
r_return
id|TRUE
suffix:semicolon
id|loop
op_assign
id|MAXLOOP
suffix:semicolon
op_star
id|p
op_assign
id|inw
c_func
(paren
id|iobase
)paren
suffix:semicolon
)brace
r_return
id|FALSE
suffix:semicolon
)brace
DECL|function|port_detect
r_static
r_inline
r_int
id|port_detect
c_func
(paren
id|ushort
op_star
id|port_base
comma
r_int
r_int
id|j
comma
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
r_char
id|irq
comma
id|dma_channel
comma
id|subversion
suffix:semicolon
r_int
r_char
id|protocol_rev
suffix:semicolon
r_struct
id|eata_info
id|info
suffix:semicolon
r_char
op_star
id|board_status
suffix:semicolon
multiline_comment|/* Allowed DMA channels for ISA (0 indicates reserved) */
r_int
r_char
id|dma_channel_table
(braket
l_int|4
)braket
op_assign
(brace
l_int|5
comma
l_int|6
comma
l_int|7
comma
l_int|0
)brace
suffix:semicolon
r_char
id|name
(braket
l_int|16
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%s%d&quot;
comma
id|driver_name
comma
id|j
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
op_star
id|port_base
comma
id|REGION_SIZE
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: address 0x%03x in use, skipping probe.&bslash;n&quot;
comma
id|name
comma
op_star
id|port_base
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_dma
c_func
(paren
op_star
id|port_base
comma
l_int|0
comma
id|READ_CONFIG_PIO
)paren
)paren
r_return
id|FALSE
suffix:semicolon
multiline_comment|/* Read the info structure */
r_if
c_cond
(paren
id|read_pio
c_func
(paren
op_star
id|port_base
comma
(paren
id|ushort
op_star
)paren
op_amp
id|info
comma
(paren
id|ushort
op_star
)paren
op_amp
id|info.ipad
(braket
l_int|0
)braket
)paren
)paren
r_return
id|FALSE
suffix:semicolon
multiline_comment|/* Check the controller &quot;EATA&quot; signature */
r_if
c_cond
(paren
id|info.sign
op_ne
id|EATA_SIGNATURE
)paren
r_return
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|info.data_len
)paren
OL
id|EATA_2_0A_SIZE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: config structure size (%ld bytes) too short, detaching.&bslash;n&quot;
comma
id|name
comma
id|ntohl
c_func
(paren
id|info.data_len
)paren
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|info.data_len
)paren
op_eq
id|EATA_2_0A_SIZE
)paren
id|protocol_rev
op_assign
l_char|&squot;A&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|info.data_len
)paren
op_eq
id|EATA_2_0B_SIZE
)paren
id|protocol_rev
op_assign
l_char|&squot;B&squot;
suffix:semicolon
r_else
id|protocol_rev
op_assign
l_char|&squot;C&squot;
suffix:semicolon
r_if
c_cond
(paren
id|protocol_rev
op_ne
l_char|&squot;A&squot;
op_logical_and
id|info.max_chan
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: warning, only scsi channel 0 is supported.&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|irq
op_assign
id|info.irq
suffix:semicolon
r_if
c_cond
(paren
op_star
id|port_base
op_amp
id|EISA_RANGE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|info.haaval
op_logical_or
id|info.ata
op_logical_or
id|info.drqvld
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unusable EISA board found (%d%d%d), detaching.&bslash;n&quot;
comma
id|name
comma
id|info.haaval
comma
id|info.ata
comma
id|info.drqvld
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|subversion
op_assign
id|ESA
suffix:semicolon
id|dma_channel
op_assign
id|NO_DMA
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|info.haaval
op_logical_or
id|info.ata
op_logical_or
op_logical_neg
id|info.drqvld
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unusable ISA board found (%d%d%d), detaching.&bslash;n&quot;
comma
id|name
comma
id|info.haaval
comma
id|info.ata
comma
id|info.drqvld
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|subversion
op_assign
id|ISA
suffix:semicolon
id|dma_channel
op_assign
id|dma_channel_table
(braket
l_int|3
op_minus
id|info.drqx
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|info.dmasup
)paren
id|printk
c_func
(paren
l_string|&quot;%s: warning, DMA protocol support not asserted.&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subversion
op_eq
id|ESA
op_logical_and
op_logical_neg
id|info.irq_tr
)paren
id|printk
c_func
(paren
l_string|&quot;%s: warning, LEVEL triggering is suggested for IRQ %u.&bslash;n&quot;
comma
id|name
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info.second
)paren
id|board_status
op_assign
l_string|&quot;Sec.&quot;
suffix:semicolon
r_else
id|board_status
op_assign
l_string|&quot;Prim.&quot;
suffix:semicolon
multiline_comment|/* Board detected, allocate its IRQ if not already done */
r_if
c_cond
(paren
(paren
id|irq
op_ge
id|MAX_IRQ
)paren
op_logical_or
(paren
(paren
id|irqlist
(braket
id|irq
)braket
op_eq
id|NO_IRQ
)paren
op_logical_and
id|request_irq
(paren
id|irq
comma
id|eata2x_interrupt_handler
comma
id|SA_INTERRUPT
comma
id|driver_name
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to allocate IRQ %u, detaching.&bslash;n&quot;
comma
id|name
comma
id|irq
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|subversion
op_eq
id|ISA
op_logical_and
id|request_dma
c_func
(paren
id|dma_channel
comma
id|driver_name
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to allocate DMA channel %u, detaching.&bslash;n&quot;
comma
id|name
comma
id|dma_channel
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
macro_line|#if defined (FORCE_CONFIG)
(brace
r_struct
id|eata_config
id|config
suffix:semicolon
multiline_comment|/* Set board configuration */
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|config
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|eata_config
)paren
)paren
suffix:semicolon
id|config.len
op_assign
(paren
id|ushort
)paren
id|htons
c_func
(paren
(paren
id|ushort
)paren
l_int|510
)paren
suffix:semicolon
id|config.ocena
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|do_dma
c_func
(paren
op_star
id|port_base
comma
(paren
r_int
r_int
)paren
op_amp
id|config
comma
id|SET_CONFIG_DMA
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: busy timeout sending configuration, detaching.&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
)brace
macro_line|#endif
id|sh
(braket
id|j
)braket
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
r_sizeof
(paren
r_struct
id|hostdata
)paren
)paren
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_assign
op_star
id|port_base
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|n_io_port
op_assign
id|REGION_SIZE
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|dma_channel
op_assign
id|dma_channel
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|irq
op_assign
id|irq
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
op_assign
(paren
id|ushort
)paren
id|ntohs
c_func
(paren
id|info.scatt_size
)paren
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|this_id
op_assign
(paren
id|ushort
)paren
id|info.host_addr
(braket
l_int|3
)braket
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
op_assign
(paren
id|ushort
)paren
id|ntohs
c_func
(paren
id|info.queue_size
)paren
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|cmd_per_lun
op_assign
id|MAX_CMD_PER_LUN
suffix:semicolon
multiline_comment|/* Register the I/O space that we use */
id|request_region
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
id|REGION_SIZE
comma
id|driver_name
)paren
suffix:semicolon
id|memset
c_func
(paren
id|HD
c_func
(paren
id|j
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|hostdata
)paren
)paren
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|subversion
op_assign
id|subversion
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|protocol_rev
op_assign
id|protocol_rev
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|board_number
op_assign
id|j
suffix:semicolon
id|irqlist
(braket
id|irq
)braket
op_assign
id|j
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|subversion
op_eq
id|ESA
)paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|unchecked_isa_dma
op_assign
id|FALSE
suffix:semicolon
r_else
(brace
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|wish_block
op_assign
id|TRUE
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|unchecked_isa_dma
op_assign
id|TRUE
suffix:semicolon
id|disable_dma
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|dma_channel
comma
id|DMA_MODE_CASCADE
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|BN
c_func
(paren
id|j
)paren
comma
id|name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: 2.0%c, %s, ID %d, PORT 0x%03x, IRQ %u, DMA %u, SG %d, &quot;
"&bslash;"
l_string|&quot;Mbox %d, CmdLun %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|protocol_rev
comma
id|board_status
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|this_id
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|irq
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|dma_channel
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|cmd_per_lun
)paren
suffix:semicolon
multiline_comment|/* DPT PM2012 does not allow to detect sg_tablesize correctly */
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
OG
id|MAX_SGLIST
op_logical_or
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: detect, forcing to use %d SG lists.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|MAX_SGLIST
)paren
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
op_assign
id|MAX_SGLIST
suffix:semicolon
)brace
multiline_comment|/* DPT PM2012 does not allow to detect can_queue correctly */
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
OG
id|MAX_MAILBOXES
op_logical_or
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: detect, forcing to use %d Mbox.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|MAX_MAILBOXES
)paren
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
op_assign
id|MAX_MAILBOXES
suffix:semicolon
)brace
macro_line|#if defined (DEBUG_DETECT)
r_if
c_cond
(paren
id|protocol_rev
op_ne
l_char|&squot;A&squot;
)paren
id|printk
c_func
(paren
l_string|&quot;%s: EATA 2.0%c, isaena %u, forcaddr %u, max_id %u,&quot;
"&bslash;"
l_string|&quot; max_chan %u.&bslash;n&quot;
comma
id|name
comma
id|protocol_rev
comma
id|info.isaena
comma
id|info.forcaddr
comma
id|info.max_id
comma
id|info.max_chan
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Version 0x%x, SYNC 0x%x, infol %ld, cpl %ld spl %ld.&bslash;n&quot;
comma
id|name
comma
id|info.version
comma
id|info.sync
comma
id|ntohl
c_func
(paren
id|info.data_len
)paren
comma
id|ntohl
c_func
(paren
id|info.cp_len
)paren
comma
id|ntohl
c_func
(paren
id|info.sp_len
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|TRUE
suffix:semicolon
)brace
DECL|function|eata2x_detect
r_int
id|eata2x_detect
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
r_int
id|j
op_assign
l_int|0
comma
id|k
comma
id|flags
suffix:semicolon
id|ushort
id|io_port
(braket
)braket
op_assign
(brace
l_int|0x1c88
comma
l_int|0x2c88
comma
l_int|0x3c88
comma
l_int|0x4c88
comma
l_int|0x5c88
comma
l_int|0x6c88
comma
l_int|0x7c88
comma
l_int|0x8c88
comma
l_int|0x9c88
comma
l_int|0xac88
comma
l_int|0xbc88
comma
l_int|0xcc88
comma
l_int|0xdc88
comma
l_int|0xec88
comma
l_int|0xfc88
comma
l_int|0x1f0
comma
l_int|0x170
comma
l_int|0x330
comma
l_int|0x230
comma
l_int|0x0
)brace
suffix:semicolon
id|ushort
op_star
id|port_base
op_assign
id|io_port
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|MAX_IRQ
suffix:semicolon
id|k
op_increment
)paren
(brace
id|irqlist
(braket
id|k
)braket
op_assign
id|NO_IRQ
suffix:semicolon
id|calls
(braket
id|k
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|MAX_BOARDS
op_plus
l_int|1
suffix:semicolon
id|k
op_increment
)paren
id|sh
(braket
id|k
)braket
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
op_star
id|port_base
)paren
(brace
r_if
c_cond
(paren
id|j
OL
id|MAX_BOARDS
op_logical_and
id|port_detect
c_func
(paren
id|port_base
comma
id|j
comma
id|tpnt
)paren
)paren
id|j
op_increment
suffix:semicolon
id|port_base
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;EATA/DMA 2.0x: Copyright (C) 1994, 1995 Dario Ballabio.&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|j
suffix:semicolon
)brace
DECL|function|build_sg_list
r_static
r_inline
r_void
id|build_sg_list
c_func
(paren
r_struct
id|mscp
op_star
id|cpp
comma
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|k
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sgpnt
suffix:semicolon
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;request_buffer
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|k
op_increment
)paren
(brace
id|cpp-&gt;sglist
(braket
id|k
)braket
dot
id|address
op_assign
id|htonl
c_func
(paren
(paren
r_int
r_int
)paren
id|sgpnt
(braket
id|k
)braket
dot
id|address
)paren
suffix:semicolon
id|cpp-&gt;sglist
(braket
id|k
)braket
dot
id|num_bytes
op_assign
id|htonl
c_func
(paren
(paren
r_int
r_int
)paren
id|sgpnt
(braket
id|k
)braket
dot
id|length
)paren
suffix:semicolon
)brace
id|cpp-&gt;data_address
op_assign
id|htonl
c_func
(paren
(paren
r_int
r_int
)paren
id|cpp-&gt;sglist
)paren
suffix:semicolon
id|cpp-&gt;data_len
op_assign
id|htonl
c_func
(paren
(paren
id|SCpnt-&gt;use_sg
op_star
r_sizeof
(paren
r_struct
id|sg_list
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|eata2x_queuecommand
r_int
id|eata2x_queuecommand
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
r_int
id|i
comma
id|j
comma
id|k
comma
id|flags
suffix:semicolon
r_struct
id|mscp
op_star
id|cpp
suffix:semicolon
r_struct
id|mssp
op_star
id|spp
suffix:semicolon
r_static
r_const
r_int
r_char
id|data_out_cmds
(braket
)braket
op_assign
(brace
l_int|0x0a
comma
l_int|0x2a
comma
l_int|0x15
comma
l_int|0x55
comma
l_int|0x04
comma
l_int|0x07
comma
l_int|0x0b
comma
l_int|0x10
comma
l_int|0x16
comma
l_int|0x18
comma
l_int|0x1d
comma
l_int|0x24
comma
l_int|0x2b
comma
l_int|0x2e
comma
l_int|0x30
comma
l_int|0x31
comma
l_int|0x32
comma
l_int|0x38
comma
l_int|0x39
comma
l_int|0x3a
comma
l_int|0x3b
comma
l_int|0x3d
comma
l_int|0x3f
comma
l_int|0x40
comma
l_int|0x41
comma
l_int|0x4c
comma
l_int|0xaa
comma
l_int|0xae
comma
l_int|0xb0
comma
l_int|0xb1
comma
l_int|0xb2
comma
l_int|0xb6
comma
l_int|0xea
)brace
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* j is the board number */
id|j
op_assign
(paren
(paren
r_struct
id|hostdata
op_star
)paren
id|SCpnt-&gt;host-&gt;hostdata
)paren
op_member_access_from_pointer
id|board_number
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
id|panic
c_func
(paren
l_string|&quot;%s: qcomm, pid %ld, null done.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
multiline_comment|/* i is the mailbox number, look for the first free mailbox &n;      starting from last_cp_used */
id|i
op_assign
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|last_cp_used
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
suffix:semicolon
id|k
op_increment
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_ge
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
)paren
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|FREE
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|last_cp_used
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|k
op_eq
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: qcomm, no free mailbox, resetting.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|in_reset
)paren
id|printk
c_func
(paren
l_string|&quot;%s: qcomm, already in reset.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|eata2x_reset
c_func
(paren
id|SCpnt
)paren
op_eq
id|SCSI_RESET_SUCCESS
)paren
id|panic
c_func
(paren
l_string|&quot;%s: qcomm, SCSI_RESET_SUCCESS.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: qcomm, pid %ld, DID_BUS_BUSY, done.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Set pointer to control packet structure */
id|cpp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
suffix:semicolon
id|memset
c_func
(paren
id|cpp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mscp
)paren
)paren
suffix:semicolon
multiline_comment|/* Set pointer to status packet structure */
id|spp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|sp
(braket
id|i
)braket
suffix:semicolon
id|memset
c_func
(paren
id|spp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mssp
)paren
)paren
suffix:semicolon
multiline_comment|/* The EATA protocol uses Big Endian format, while Intel is Little Endian */
id|cpp-&gt;sp_addr
op_assign
id|htonl
c_func
(paren
(paren
r_int
r_int
)paren
id|spp
)paren
suffix:semicolon
id|SCpnt-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cpp-&gt;index
op_assign
id|i
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|cpp-&gt;index
suffix:semicolon
r_if
c_cond
(paren
id|do_trace
)paren
id|printk
c_func
(paren
l_string|&quot;%s: qcomm, mbox %d, target %d, pid %ld.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|ARRAY_SIZE
c_func
(paren
id|data_out_cmds
)paren
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|data_out_cmds
(braket
id|k
)braket
)paren
(brace
id|cpp-&gt;dout
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cpp-&gt;din
op_assign
op_logical_neg
id|cpp-&gt;dout
suffix:semicolon
id|cpp-&gt;reqsen
op_assign
id|TRUE
suffix:semicolon
id|cpp-&gt;dispri
op_assign
id|TRUE
suffix:semicolon
id|cpp-&gt;one
op_assign
id|TRUE
suffix:semicolon
id|cpp-&gt;target
op_assign
id|SCpnt-&gt;target
suffix:semicolon
id|cpp-&gt;lun
op_assign
id|SCpnt-&gt;lun
suffix:semicolon
id|cpp-&gt;SCpnt
op_assign
id|SCpnt
suffix:semicolon
id|cpp-&gt;sense_addr
op_assign
id|htonl
c_func
(paren
(paren
r_int
r_int
)paren
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|cpp-&gt;sense_len
op_assign
r_sizeof
id|SCpnt-&gt;sense_buffer
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
id|cpp-&gt;sg
op_assign
id|TRUE
suffix:semicolon
id|build_sg_list
c_func
(paren
id|cpp
comma
id|SCpnt
)paren
suffix:semicolon
)brace
r_else
(brace
id|cpp-&gt;data_address
op_assign
id|htonl
c_func
(paren
(paren
r_int
r_int
)paren
id|SCpnt-&gt;request_buffer
)paren
suffix:semicolon
id|cpp-&gt;data_len
op_assign
id|htonl
c_func
(paren
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|cpp-&gt;cdb
comma
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;cmd_len
)paren
suffix:semicolon
multiline_comment|/* Send control packet to the board */
r_if
c_cond
(paren
id|do_dma
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
(paren
r_int
r_int
)paren
id|cpp
comma
id|SEND_CP_DMA
)paren
)paren
(brace
id|SCpnt-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: qcomm, target %d, pid %ld, adapter busy, DID_ERROR, done.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|IN_USE
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|eata2x_abort
r_int
id|eata2x_abort
(paren
id|Scsi_Cmnd
op_star
id|SCarg
)paren
(brace
r_int
r_int
id|i
comma
id|j
comma
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|j
op_assign
(paren
(paren
r_struct
id|hostdata
op_star
)paren
id|SCarg-&gt;host-&gt;hostdata
)paren
op_member_access_from_pointer
id|board_number
suffix:semicolon
r_if
c_cond
(paren
id|SCarg-&gt;host_scribble
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: abort, target %d, pid %ld inactive.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCarg-&gt;target
comma
id|SCarg-&gt;pid
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
id|i
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|SCarg-&gt;host_scribble
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: abort, mbox %d, target %d, pid %ld.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCarg-&gt;target
comma
id|SCarg-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
)paren
id|panic
c_func
(paren
l_string|&quot;%s: abort, invalid SCarg-&gt;host_scribble.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_on_busy
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: abort, timeout error.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|FREE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: abort, mbox %d is free.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|IN_USE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: abort, mbox %d is in use.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCarg
op_ne
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
dot
id|SCpnt
)paren
id|panic
c_func
(paren
l_string|&quot;%s: abort, mbox %d, SCarg %p, cp SCpnt %p.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCarg
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
dot
id|SCpnt
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|IN_RESET
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: abort, mbox %d is in reset.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|LOCKED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: abort, mbox %d is locked.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
r_else
id|panic
c_func
(paren
l_string|&quot;%s: abort, mbox %d, invalid cp_stat.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
)brace
DECL|function|eata2x_reset
r_int
id|eata2x_reset
(paren
id|Scsi_Cmnd
op_star
id|SCarg
)paren
(brace
r_int
r_int
id|i
comma
id|j
comma
id|flags
comma
id|time
comma
id|k
comma
id|limit
op_assign
l_int|0
suffix:semicolon
r_int
id|arg_done
op_assign
id|FALSE
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|j
op_assign
(paren
(paren
r_struct
id|hostdata
op_star
)paren
id|SCarg-&gt;host-&gt;hostdata
)paren
op_member_access_from_pointer
id|board_number
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: reset, enter, target %d, pid %ld.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCarg-&gt;target
comma
id|SCarg-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCarg-&gt;host_scribble
op_eq
l_int|NULL
)paren
id|printk
c_func
(paren
l_string|&quot;%s: reset, pid %ld inactive.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCarg-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|in_reset
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: reset, exit, already in reset.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_RESET_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wait_on_busy
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: reset, exit, timeout error.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_RESET_ERROR
suffix:semicolon
)brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|MAX_TARGET
suffix:semicolon
id|k
op_increment
)paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_reset
(braket
id|k
)braket
op_assign
id|TRUE
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|MAX_TARGET
suffix:semicolon
id|k
op_increment
)paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_time_out
(braket
id|k
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|FREE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|LOCKED
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|FREE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: reset, locked mbox %d forced free.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|SCpnt
op_assign
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
dot
id|SCpnt
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|IN_RESET
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: reset, mbox %d in reset, pid %ld.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;%s: reset, mbox %d, SCpnt == NULL.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host_scribble
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;%s: reset, mbox %d, garbled SCpnt.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|SCpnt-&gt;host_scribble
op_ne
id|i
)paren
id|panic
c_func
(paren
l_string|&quot;%s: reset, mbox %d, index mismatch.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;scsi_done
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;%s: reset, mbox %d, SCpnt-&gt;scsi_done == NULL.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_eq
id|SCarg
)paren
id|arg_done
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_dma
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
l_int|0
comma
id|RESET_PIO
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: reset, cannot reset, timeout error.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_RESET_ERROR
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: reset, board reset done, enabling interrupts.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
macro_line|#if defined (DEBUG_RESET)
id|do_trace
op_assign
id|TRUE
suffix:semicolon
macro_line|#endif
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|in_reset
op_assign
id|TRUE
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|time
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
(paren
id|time
op_plus
l_int|100
)paren
op_logical_and
id|limit
op_increment
OL
l_int|100000000
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: reset, interrupts disabled, loops %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|limit
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Skip mailboxes already set free by interrupt */
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_ne
id|IN_RESET
)paren
r_continue
suffix:semicolon
id|SCpnt
op_assign
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
dot
id|SCpnt
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* This mailbox is still waiting for its interrupt */
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|LOCKED
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s, reset, mbox %d locked, DID_RESET, pid %ld done.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|SCpnt
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|in_reset
op_assign
id|FALSE
suffix:semicolon
id|do_trace
op_assign
id|FALSE
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg_done
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: reset, exit, success.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_return
id|SCSI_RESET_SUCCESS
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: reset, exit, wakeup.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_return
id|SCSI_RESET_PUNT
suffix:semicolon
)brace
)brace
DECL|function|eata2x_interrupt_handler
r_static
r_void
id|eata2x_interrupt_handler
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_int
r_int
id|i
comma
id|j
comma
id|k
comma
id|flags
comma
id|status
comma
id|tstatus
comma
id|loops
comma
id|total_loops
op_assign
l_int|0
suffix:semicolon
r_struct
id|mssp
op_star
id|spp
suffix:semicolon
r_struct
id|mscp
op_star
id|cpp
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqlist
(braket
id|irq
)braket
op_eq
id|NO_IRQ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s, ihdlr, irq %d, unexpected interrupt.&bslash;n&quot;
comma
id|driver_name
comma
id|irq
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_trace
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, enter, irq %d, calls %d.&bslash;n&quot;
comma
id|driver_name
comma
id|irq
comma
id|calls
(braket
id|irq
)braket
)paren
suffix:semicolon
multiline_comment|/* Service all the boards configured on this irq */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|sh
(braket
id|j
)braket
op_ne
l_int|NULL
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|irq
op_ne
id|irq
)paren
r_continue
suffix:semicolon
id|loops
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Loop until all interrupts for a board are serviced */
r_while
c_loop
(paren
id|inb
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_AUX_STATUS
)paren
op_amp
id|IRQ_ASSERTED
)paren
(brace
id|total_loops
op_increment
suffix:semicolon
id|loops
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|do_trace
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, start service, count %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
)paren
suffix:semicolon
multiline_comment|/* Read the status register to clear the interrupt indication */
id|inb
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_STATUS
)paren
suffix:semicolon
multiline_comment|/* Service all mailboxes of this board */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
suffix:semicolon
id|i
op_increment
)paren
(brace
id|spp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|sp
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Check if this mailbox has completed the operation */
r_if
c_cond
(paren
id|spp-&gt;eoc
op_eq
id|FALSE
)paren
r_continue
suffix:semicolon
id|spp-&gt;eoc
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|IGNORE
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|FREE
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|LOCKED
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|FREE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d unlocked, count %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|FREE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d is free, count %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|IN_RESET
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d is in reset.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_ne
id|IN_USE
)paren
id|panic
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d, invalid cp_stat.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|FREE
suffix:semicolon
id|cpp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
suffix:semicolon
id|SCpnt
op_assign
id|spp-&gt;SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d, SCpnt == NULL.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_ne
id|cpp-&gt;SCpnt
)paren
id|panic
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d, sp SCpnt %p, cp SCpnt %p.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt
comma
id|cpp-&gt;SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host_scribble
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d, pid %ld, SCpnt %p garbled.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;pid
comma
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|SCpnt-&gt;host_scribble
op_ne
id|i
)paren
id|panic
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d, pid %ld, index mismatch %d,&quot;
"&bslash;"
l_string|&quot; irq %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;pid
comma
op_star
(paren
r_int
r_int
op_star
)paren
id|SCpnt-&gt;host_scribble
comma
id|irq
)paren
suffix:semicolon
id|tstatus
op_assign
id|status_byte
c_func
(paren
id|spp-&gt;target_status
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|spp-&gt;adapter_status
)paren
(brace
r_case
id|ASOK
suffix:colon
multiline_comment|/* status OK */
multiline_comment|/* Forces a reset if a disk drive keeps returning BUSY */
r_if
c_cond
(paren
id|tstatus
op_eq
id|BUSY
op_logical_and
id|SCpnt-&gt;device-&gt;type
op_ne
id|TYPE_TAPE
)paren
id|status
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* If there was a bus reset, redo operation on each target */
r_else
r_if
c_cond
(paren
id|tstatus
op_ne
id|GOOD
op_logical_and
id|SCpnt-&gt;device-&gt;type
op_eq
id|TYPE_DISK
op_logical_and
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_reset
(braket
id|SCpnt-&gt;target
)braket
)paren
id|status
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* Works around a flaw in scsi.c */
r_else
r_if
c_cond
(paren
id|tstatus
op_eq
id|CHECK_CONDITION
op_logical_and
id|SCpnt-&gt;device-&gt;type
op_eq
id|TYPE_DISK
op_logical_and
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
id|RECOVERED_ERROR
)paren
id|status
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tstatus
op_eq
id|CHECK_CONDITION
op_logical_and
id|SCpnt-&gt;device-&gt;type
op_eq
id|TYPE_DISK
op_logical_and
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
id|UNIT_ATTENTION
)paren
id|status
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_else
id|status
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|tstatus
op_eq
id|GOOD
)paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_reset
(braket
id|SCpnt-&gt;target
)braket
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|spp-&gt;target_status
op_logical_and
id|SCpnt-&gt;device-&gt;type
op_eq
id|TYPE_DISK
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, target %d:%d, pid %ld, target_status &quot;
"&bslash;"
l_string|&quot;0x%x, sense key 0x%x.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;pid
comma
id|spp-&gt;target_status
comma
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_time_out
(braket
id|SCpnt-&gt;target
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ASST
suffix:colon
multiline_comment|/* Selection Time Out */
r_case
l_int|0x02
suffix:colon
multiline_comment|/* Command Time Out   */
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_time_out
(braket
id|SCpnt-&gt;target
)braket
OG
l_int|1
)paren
id|status
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_else
(brace
id|status
op_assign
id|DID_TIME_OUT
op_lshift
l_int|16
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_time_out
(braket
id|SCpnt-&gt;target
)braket
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x03
suffix:colon
multiline_comment|/* SCSI Bus Reset Received */
r_case
l_int|0x04
suffix:colon
multiline_comment|/* Initial Controller Power-up */
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;type
op_ne
id|TYPE_TAPE
)paren
id|status
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
r_else
id|status
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|MAX_TARGET
suffix:semicolon
id|k
op_increment
)paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_reset
(braket
id|k
)braket
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x07
suffix:colon
multiline_comment|/* Bus Parity Error */
r_case
l_int|0x0c
suffix:colon
multiline_comment|/* Controller Ram Parity */
r_case
l_int|0x05
suffix:colon
multiline_comment|/* Unexpected Bus Phase */
r_case
l_int|0x06
suffix:colon
multiline_comment|/* Unexpected Bus Free */
r_case
l_int|0x08
suffix:colon
multiline_comment|/* SCSI Hung */
r_case
l_int|0x09
suffix:colon
multiline_comment|/* Unexpected Message Reject */
r_case
l_int|0x0a
suffix:colon
multiline_comment|/* SCSI Bus Reset Stuck */
r_case
l_int|0x0b
suffix:colon
multiline_comment|/* Auto Request-Sense Failed */
r_default
suffix:colon
id|status
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
)brace
id|SCpnt-&gt;result
op_assign
id|status
op_or
id|spp-&gt;target_status
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|loops
OG
l_int|1
)paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|multicount
op_increment
suffix:semicolon
macro_line|#if defined (DEBUG_INTERRUPT)
r_if
c_cond
(paren
id|SCpnt-&gt;result
op_logical_or
id|do_trace
)paren
macro_line|#else
r_if
c_cond
(paren
(paren
id|spp-&gt;adapter_status
op_ne
id|ASOK
op_logical_and
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
OG
l_int|1000
)paren
op_logical_or
(paren
id|spp-&gt;adapter_status
op_ne
id|ASOK
op_logical_and
id|spp-&gt;adapter_status
op_ne
id|ASST
op_logical_and
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
op_le
l_int|1000
)paren
op_logical_or
id|do_trace
)paren
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d, err 0x%x:%x,&quot;
"&bslash;"
l_string|&quot; target %d:%d, pid %ld, count %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|spp-&gt;adapter_status
comma
id|spp-&gt;target_status
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;pid
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
)paren
suffix:semicolon
multiline_comment|/* Set the command state to inactive */
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|SCpnt
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Mailbox loop */
)brace
multiline_comment|/* Multiple command loop */
)brace
multiline_comment|/* Boards loop */
id|calls
(braket
id|irq
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|total_loops
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, irq %d, no command completed, calls %d.&bslash;n&quot;
comma
id|driver_name
comma
id|irq
comma
id|calls
(braket
id|irq
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_trace
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, exit, irq %d, calls %d.&bslash;n&quot;
comma
id|driver_name
comma
id|irq
comma
id|calls
(braket
id|irq
)braket
)paren
suffix:semicolon
macro_line|#if defined (DEBUG_STATISTICS)
r_if
c_cond
(paren
(paren
id|calls
(braket
id|irq
)braket
op_mod
l_int|100000
)paren
op_eq
l_int|10000
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|sh
(braket
id|j
)braket
op_ne
l_int|NULL
suffix:semicolon
id|j
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, calls %d, count %d, multi %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|calls
(braket
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|irq
)paren
)braket
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|multicount
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if defined(MODULE)
DECL|variable|driver_template
id|Scsi_Host_Template
id|driver_template
op_assign
id|EATA
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
macro_line|#endif
eof
