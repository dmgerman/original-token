multiline_comment|/*&n; *      eata.c - Low-level driver for EATA/DMA SCSI host adapters.&n; *&n; *      22 Nov 2000 Rev. 6.02 for linux 2.4.0-test11&n; *        + Return code checked when calling pci_enable_device.&n; *        + Removed old scsi error handling support.&n; *        + The obsolete boot option flag eh:n is silently ignored.&n; *        + Removed error messages while a disk drive is powered up at&n; *          boot time.&n; *        + Improved boot messages: all tagged capable device are&n; *          indicated as &quot;tagged&quot; or &quot;soft-tagged&quot; :&n; *          - &quot;soft-tagged&quot;  means that the driver is trying to do its &n; *            own tagging (i.e. the tc:y option is in effect);&n; *          - &quot;tagged&quot; means that the device supports tagged commands,&n; *            but the driver lets the HBA be responsible for tagging&n; *            support.&n; *&n; *      16 Sep 1999 Rev. 5.11 for linux 2.2.12 and 2.3.18&n; *        + Updated to the new __setup interface for boot command line options.&n; *        + When loaded as a module, accepts the new parameter boot_options&n; *          which value is a string with the same format of the kernel boot&n; *          command line options. A valid example is:&n; *          modprobe eata boot_options=&bslash;&quot;0x7410,0x230,lc:y,tc:n,mq:4&bslash;&quot;&n; *&n; *       9 Sep 1999 Rev. 5.10 for linux 2.2.12 and 2.3.17&n; *        + 64bit cleanup for Linux/Alpha platform support&n; *          (contribution from H.J. Lu).&n; *&n; *      22 Jul 1999 Rev. 5.00 for linux 2.2.10 and 2.3.11&n; *        + Removed pre-2.2 source code compatibility.&n; *        + Added call to pci_set_master.&n; *&n; *      26 Jul 1998 Rev. 4.33 for linux 2.0.35 and 2.1.111&n; *        + Added command line option (rs:[y|n]) to reverse the scan order&n; *          of PCI boards. The default is rs:y, which reverses the BIOS order&n; *          while registering PCI boards. The default value rs:y generates&n; *          the same order of all previous revisions of this driver.&n; *          Pls. note that &quot;BIOS order&quot; might have been reversed itself&n; *          after the 2.1.9x PCI modifications in the linux kernel.&n; *          The rs value is ignored when the explicit list of addresses&n; *          is used by the &quot;eata=port0,port1,...&quot; command line option.&n; *        + Added command line option (et:[y|n]) to force use of extended&n; *          translation (255 heads, 63 sectors) as disk geometry.&n; *          The default is et:n, which uses the disk geometry returned&n; *          by scsicam_bios_param. The default value et:n is compatible with&n; *          all previous revisions of this driver.&n; *&n; *      28 May 1998 Rev. 4.32 for linux 2.0.33 and 2.1.104&n; *          Increased busy timeout from 10 msec. to 200 msec. while&n; *          processing interrupts.&n; *&n; *      16 May 1998 Rev. 4.31 for linux 2.0.33 and 2.1.102&n; *          Improved abort handling during the eh recovery process.&n; *&n; *      13 May 1998 Rev. 4.30 for linux 2.0.33 and 2.1.101&n; *          The driver is now fully SMP safe, including the&n; *          abort and reset routines.&n; *          Added command line options (eh:[y|n]) to choose between&n; *          new_eh_code and the old scsi code.&n; *          If linux version &gt;= 2.1.101 the default is eh:y, while the eh&n; *          option is ignored for previous releases and the old scsi code&n; *          is used.&n; *&n; *      18 Apr 1998 Rev. 4.20 for linux 2.0.33 and 2.1.97&n; *          Reworked interrupt handler.&n; *&n; *      11 Apr 1998 rev. 4.05 for linux 2.0.33 and 2.1.95&n; *          Major reliability improvement: when a batch with overlapping&n; *          requests is detected, requests are queued one at a time&n; *          eliminating any possible board or drive reordering.&n; *&n; *      10 Apr 1998 rev. 4.04 for linux 2.0.33 and 2.1.95&n; *          Improved SMP support (if linux version &gt;= 2.1.95).&n; *&n; *       9 Apr 1998 rev. 4.03 for linux 2.0.33 and 2.1.94&n; *          Added support for new PCI code and IO-APIC remapping of irqs.&n; *          Performance improvement: when sequential i/o is detected,&n; *          always use direct sort instead of reverse sort.&n; *&n; *       4 Apr 1998 rev. 4.02 for linux 2.0.33 and 2.1.92&n; *          io_port is now unsigned long.&n; *&n; *      17 Mar 1998 rev. 4.01 for linux 2.0.33 and 2.1.88&n; *          Use new scsi error handling code (if linux version &gt;= 2.1.88).&n; *          Use new interrupt code.&n; *&n; *      12 Sep 1997 rev. 3.11 for linux 2.0.30 and 2.1.55&n; *          Use of udelay inside the wait loops to avoid timeout&n; *          problems with fast cpus.&n; *          Removed check about useless calls to the interrupt service&n; *          routine (reported on SMP systems only).&n; *          At initialization time &quot;sorted/unsorted&quot; is displayed instead&n; *          of &quot;linked/unlinked&quot; to reinforce the fact that &quot;linking&quot; is&n; *          nothing but &quot;elevator sorting&quot; in the actual implementation.&n; *&n; *      17 May 1997 rev. 3.10 for linux 2.0.30 and 2.1.38&n; *          Use of serial_number_at_timeout in abort and reset processing.&n; *          Use of the __initfunc and __initdata macro in setup code.&n; *          Minor cleanups in the list_statistics code.&n; *          Increased controller busy timeout in order to better support&n; *          slow SCSI devices.&n; *&n; *      24 Feb 1997 rev. 3.00 for linux 2.0.29 and 2.1.26&n; *          When loading as a module, parameter passing is now supported&n; *          both in 2.0 and in 2.1 style.&n; *          Fixed data transfer direction for some SCSI opcodes.&n; *          Immediate acknowledge to request sense commands.&n; *          Linked commands to each disk device are now reordered by elevator&n; *          sorting. Rare cases in which reordering of write requests could&n; *          cause wrong results are managed.&n; *          Fixed spurious timeouts caused by long simple queue tag sequences.&n; *          New command line option (tm:[0-3]) to choose the type of tags:&n; *          0 -&gt; mixed (default); 1 -&gt; simple; 2 -&gt; head; 3 -&gt; ordered.&n; *&n; *      18 Jan 1997 rev. 2.60 for linux 2.1.21 and 2.0.28&n; *          Added command line options to enable/disable linked commands&n; *          (lc:[y|n]), tagged commands (tc:[y|n]) and to set the max queue&n; *          depth (mq:xx). Default is &quot;eata=lc:n,tc:n,mq:16&quot;.&n; *          Improved command linking.&n; *          Documented how to setup RAID-0 with DPT SmartRAID boards.&n; *&n; *       8 Jan 1997 rev. 2.50 for linux 2.1.20 and 2.0.27&n; *          Added linked command support.&n; *          Improved detection of PCI boards using ISA base addresses.&n; *&n; *       3 Dec 1996 rev. 2.40 for linux 2.1.14 and 2.0.27&n; *          Added support for tagged commands and queue depth adjustment.&n; *&n; *      22 Nov 1996 rev. 2.30 for linux 2.1.12 and 2.0.26&n; *          When CONFIG_PCI is defined, BIOS32 is used to include in the&n; *          list of i/o ports to be probed all the PCI SCSI controllers.&n; *          The list of i/o ports to be probed can be overwritten by the&n; *          &quot;eata=port0,port1,....&quot; boot command line option.&n; *          Scatter/gather lists are now allocated by a number of kmalloc&n; *          calls, in order to avoid the previous size limit of 64Kb.&n; *&n; *      16 Nov 1996 rev. 2.20 for linux 2.1.10 and 2.0.25&n; *          Added support for EATA 2.0C, PCI, multichannel and wide SCSI.&n; *&n; *      27 Sep 1996 rev. 2.12 for linux 2.1.0&n; *          Portability cleanups (virtual/bus addressing, little/big endian&n; *          support).&n; *&n; *      09 Jul 1996 rev. 2.11 for linux 2.0.4&n; *          Number of internal retries is now limited.&n; *&n; *      16 Apr 1996 rev. 2.10 for linux 1.3.90&n; *          New argument &quot;reset_flags&quot; to the reset routine.&n; *&n; *       6 Jul 1995 rev. 2.01 for linux 1.3.7&n; *          Update required by the new /proc/scsi support.&n; *&n; *      11 Mar 1995 rev. 2.00 for linux 1.2.0&n; *          Fixed a bug which prevented media change detection for removable&n; *          disk drives.&n; *&n; *      23 Feb 1995 rev. 1.18 for linux 1.1.94&n; *          Added a check for scsi_register returning NULL.&n; *&n; *      11 Feb 1995 rev. 1.17 for linux 1.1.91&n; *          Now DEBUG_RESET is disabled by default.&n; *          Register a board even if it does not assert DMA protocol support&n; *          (DPT SK2011B does not report correctly the dmasup bit).&n; *&n; *       9 Feb 1995 rev. 1.16 for linux 1.1.90&n; *          Use host-&gt;wish_block instead of host-&gt;block.&n; *          New list of Data Out SCSI commands.&n; *&n; *       8 Feb 1995 rev. 1.15 for linux 1.1.89&n; *          Cleared target_time_out counter while performing a reset.&n; *          All external symbols renamed to avoid possible name conflicts.&n; *&n; *      28 Jan 1995 rev. 1.14 for linux 1.1.86&n; *          Added module support.&n; *          Log and do a retry when a disk drive returns a target status&n; *          different from zero on a recovered error.&n; *&n; *      24 Jan 1995 rev. 1.13 for linux 1.1.85&n; *          Use optimized board configuration, with a measured performance&n; *          increase in the range 10%-20% on i/o throughput.&n; *&n; *      16 Jan 1995 rev. 1.12 for linux 1.1.81&n; *          Fix mscp structure comments (no functional change).&n; *          Display a message if check_region detects a port address&n; *          already in use.&n; *&n; *      17 Dec 1994 rev. 1.11 for linux 1.1.74&n; *          Use the scsicam_bios_param routine. This allows an easy&n; *          migration path from disk partition tables created using&n; *          different SCSI drivers and non optimal disk geometry.&n; *&n; *      15 Dec 1994 rev. 1.10 for linux 1.1.74&n; *          Added support for ISA EATA boards (DPT PM2011, DPT PM2021).&n; *          The host-&gt;block flag is set for all the detected ISA boards.&n; *          The detect routine no longer enforces LEVEL triggering&n; *          for EISA boards, it just prints a warning message.&n; *&n; *      30 Nov 1994 rev. 1.09 for linux 1.1.68&n; *          Redo i/o on target status CHECK_CONDITION for TYPE_DISK only.&n; *          Added optional support for using a single board at a time.&n; *&n; *      18 Nov 1994 rev. 1.08 for linux 1.1.64&n; *          Forces sg_tablesize = 64 and can_queue = 64 if these&n; *          values are not correctly detected (DPT PM2012).&n; *&n; *      14 Nov 1994 rev. 1.07 for linux 1.1.63  Final BETA release.&n; *      04 Aug 1994 rev. 1.00 for linux 1.1.39  First BETA release.&n; *&n; *&n; *          This driver is based on the CAM (Common Access Method Committee)&n; *          EATA (Enhanced AT Bus Attachment) rev. 2.0A, using DMA protocol.&n; *&n; *  Copyright (C) 1994-2000 Dario Ballabio (ballabio_dario@emc.com)&n; *&n; *  Alternate email: dario.ballabio@inwind.it, dario.ballabio@tiscalinet.it&n; *&n; *  Redistribution and use in source and binary forms, with or without&n; *  modification, are permitted provided that redistributions of source&n; *  code retain the above copyright notice and this comment without&n; *  modification.&n; *&n; */
multiline_comment|/*&n; *&n; *  Here is a brief description of the DPT SCSI host adapters.&n; *  All these boards provide an EATA/DMA compatible programming interface&n; *  and are fully supported by this driver in any configuration, including&n; *  multiple SCSI channels:&n; *&n; *  PM2011B/9X -  Entry Level ISA&n; *  PM2021A/9X -  High Performance ISA&n; *  PM2012A       Old EISA&n; *  PM2012B       Old EISA&n; *  PM2022A/9X -  Entry Level EISA&n; *  PM2122A/9X -  High Performance EISA&n; *  PM2322A/9X -  Extra High Performance EISA&n; *  PM3021     -  SmartRAID Adapter for ISA&n; *  PM3222     -  SmartRAID Adapter for EISA (PM3222W is 16-bit wide SCSI)&n; *  PM3224     -  SmartRAID Adapter for PCI  (PM3224W is 16-bit wide SCSI)&n; *  PM33340UW  -  SmartRAID Adapter for PCI  ultra wide multichannel&n; *&n; *  The above list is just an indication: as a matter of fact all DPT&n; *  boards using the EATA/DMA protocol are supported by this driver,&n; *  since they use exactely the same programming interface.&n; *&n; *  The DPT PM2001 provides only the EATA/PIO interface and hence is not&n; *  supported by this driver.&n; *&n; *  This code has been tested with up to 3 Distributed Processing Technology&n; *  PM2122A/9X (DPT SCSI BIOS v002.D1, firmware v05E.0) EISA controllers,&n; *  in any combination of private and shared IRQ.&n; *  PCI support has been tested using up to 2 DPT PM3224W (DPT SCSI BIOS&n; *  v003.D0, firmware v07G.0).&n; *&n; *  DPT SmartRAID boards support &quot;Hardware Array&quot; - a group of disk drives&n; *  which are all members of the same RAID-0, RAID-1 or RAID-5 array implemented&n; *  in host adapter hardware. Hardware Arrays are fully compatible with this&n; *  driver, since they look to it as a single disk drive.&n; *&n; *  WARNING: to create a RAID-0 &quot;Hardware Array&quot; you must select &quot;Other Unix&quot;&n; *  as the current OS in the DPTMGR &quot;Initial System Installation&quot; menu.&n; *  Otherwise RAID-0 is generated as an &quot;Array Group&quot; (i.e. software RAID-0),&n; *  which is not supported by the actual SCSI subsystem.&n; *  To get the &quot;Array Group&quot; functionality, the Linux MD driver must be used&n; *  instead of the DPT &quot;Array Group&quot; feature.&n; *&n; *  Multiple ISA, EISA and PCI boards can be configured in the same system.&n; *  It is suggested to put all the EISA boards on the same IRQ level, all&n; *  the PCI  boards on another IRQ level, while ISA boards cannot share&n; *  interrupts.&n; *&n; *  If you configure multiple boards on the same IRQ, the interrupt must&n; *  be _level_ triggered (not _edge_ triggered).&n; *&n; *  This driver detects EATA boards by probes at fixed port addresses,&n; *  so no BIOS32 or PCI BIOS support is required.&n; *  The suggested way to detect a generic EATA PCI board is to force on it&n; *  any unused EISA address, even if there are other controllers on the EISA&n; *  bus, or even if you system has no EISA bus at all.&n; *  Do not force any ISA address on EATA PCI boards.&n; *&n; *  If PCI bios support is configured into the kernel, BIOS32 is used to&n; *  include in the list of i/o ports to be probed all the PCI SCSI controllers.&n; *&n; *  Due to a DPT BIOS &quot;feature&quot;, it might not be possible to force an EISA&n; *  address on more then a single DPT PCI board, so in this case you have to&n; *  let the PCI BIOS assign the addresses.&n; *&n; *  The sequence of detection probes is:&n; *&n; *  - ISA 0x1F0;&n; *  - PCI SCSI controllers (only if BIOS32 is available);&n; *  - EISA/PCI 0x1C88 through 0xFC88 (corresponding to EISA slots 1 to 15);&n; *  - ISA  0x170, 0x230, 0x330.&n; *&n; *  The above list of detection probes can be totally replaced by the&n; *  boot command line option: &quot;eata=port0,port1,port2,...&quot;, where the&n; *  port0, port1... arguments are ISA/EISA/PCI addresses to be probed.&n; *  For example using &quot;eata=0x7410,0x7450,0x230&quot;, the driver probes&n; *  only the two PCI addresses 0x7410 and 0x7450 and the ISA address 0x230,&n; *  in this order; &quot;eata=0&quot; totally disables this driver.&n; *&n; *  After the optional list of detection probes, other possible command line&n; *  options are:&n; *&n; *  et:y  force use of extended translation (255 heads, 63 sectors);&n; *  et:n  use disk geometry detected by scsicam_bios_param;&n; *  rs:y  reverse scan order while detecting PCI boards;&n; *  rs:n  use BIOS order while detecting PCI boards;&n; *  lc:y  enables linked commands;&n; *  lc:n  disables linked commands;&n; *  tc:y  enables tagged commands;&n; *  tc:n  disables tagged commands;&n; *  tm:0  use head/simple/ordered queue tag sequences;&n; *  tm:1  use only simple queue tags;&n; *  tm:2  use only head of queue tags;&n; *  tm:3  use only ordered queue tags;&n; *  mq:xx set the max queue depth to the value xx (2 &lt;= xx &lt;= 32).&n; *&n; *  The default value is: &quot;eata=lc:n,tc:n,mq:16,tm:0,et:n,rs:n&quot;.&n; *  An example using the list of detection probes could be:&n; *  &quot;eata=0x7410,0x230,lc:y,tc:n,mq:4,et:n&quot;.&n; *&n; *  When loading as a module, parameters can be specified as well.&n; *  The above example would be (use 1 in place of y and 0 in place of n):&n; *&n; *  modprobe eata io_port=0x7410,0x230 linked_comm=1 tagged_comm=0 &bslash;&n; *                max_queue_depth=4 tag_mode=0 &bslash;&n; *                ext_tran=0 rev_scan=1&n; *&n; *  ----------------------------------------------------------------------------&n; *  In this implementation, linked commands are designed to work with any DISK&n; *  or CD-ROM, since this linking has only the intent of clustering (time-wise)&n; *  and reordering by elevator sorting commands directed to each device,&n; *  without any relation with the actual SCSI protocol between the controller&n; *  and the device.&n; *  If Q is the queue depth reported at boot time for each device (also named&n; *  cmds/lun) and Q &gt; 2, whenever there is already an active command to the&n; *  device all other commands to the same device  (up to Q-1) are kept waiting&n; *  in the elevator sorting queue. When the active command completes, the&n; *  commands in this queue are sorted by sector address. The sort is chosen&n; *  between increasing or decreasing by minimizing the seek distance between&n; *  the sector of the commands just completed and the sector of the first&n; *  command in the list to be sorted.&n; *  Trivial math assures that the unsorted average seek distance when doing&n; *  random seeks over S sectors is S/3.&n; *  When (Q-1) requests are uniformly distributed over S sectors, the average&n; *  distance between two adjacent requests is S/((Q-1) + 1), so the sorted&n; *  average seek distance for (Q-1) random requests over S sectors is S/Q.&n; *  The elevator sorting hence divides the seek distance by a factor Q/3.&n; *  The above pure geometric remarks are valid in all cases and the&n; *  driver effectively reduces the seek distance by the predicted factor&n; *  when there are Q concurrent read i/o operations on the device, but this&n; *  does not necessarily results in a noticeable performance improvement:&n; *  your mileage may vary....&n; *&n; *  Note: command reordering inside a batch of queued commands could cause&n; *        wrong results only if there is at least one write request and the&n; *        intersection (sector-wise) of all requests is not empty.&n; *        When the driver detects a batch including overlapping requests&n; *        (a really rare event) strict serial (pid) order is enforced.&n; *  ----------------------------------------------------------------------------&n; *  The extended translation option (et:y) is useful when using large physical&n; *  disks/arrays. It could also be useful when switching between Adaptec boards&n; *  and DPT boards without reformatting the disk.&n; *  When a boot disk is partitioned with extended translation, in order to&n; *  be able to boot it with a DPT board is could be necessary to add to&n; *  lilo.conf additional commands as in the following example:&n; *&n; *  fix-table&n; *  disk=/dev/sda bios=0x80 sectors=63 heads=128 cylindres=546&n; *&n; *  where the above geometry should be replaced with the one reported at&n; *  power up by the DPT controller.&n; *  ----------------------------------------------------------------------------&n; *&n; *  The boards are named EATA0, EATA1,... according to the detection order.&n; *&n; *  In order to support multiple ISA boards in a reliable way,&n; *  the driver sets host-&gt;wish_block = TRUE for all ISA boards.&n; */
macro_line|#include &lt;linux/version.h&gt;
macro_line|#ifndef LinuxVersionCode
DECL|macro|LinuxVersionCode
mdefine_line|#define LinuxVersionCode(v, p, s) (((v)&lt;&lt;16)+((p)&lt;&lt;8)+(s))
macro_line|#endif
DECL|macro|MAX_INT_PARAM
mdefine_line|#define MAX_INT_PARAM 10
macro_line|#if defined(MODULE)
macro_line|#include &lt;linux/module.h&gt;
id|MODULE_PARM
c_func
(paren
id|boot_options
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io_port
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_INT_PARAM
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|linked_comm
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|tagged_comm
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|link_statistics
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_queue_depth
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|tag_mode
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ext_tran
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|rev_scan
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Dario Ballabio&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &quot;eata.h&quot;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
DECL|macro|SPIN_FLAGS
mdefine_line|#define SPIN_FLAGS unsigned long spin_flags;
DECL|macro|SPIN_LOCK
mdefine_line|#define SPIN_LOCK spin_lock_irq(&amp;io_request_lock);
DECL|macro|SPIN_LOCK_SAVE
mdefine_line|#define SPIN_LOCK_SAVE spin_lock_irqsave(&amp;io_request_lock, spin_flags);
DECL|macro|SPIN_UNLOCK
mdefine_line|#define SPIN_UNLOCK spin_unlock_irq(&amp;io_request_lock);
DECL|macro|SPIN_UNLOCK_RESTORE
mdefine_line|#define SPIN_UNLOCK_RESTORE &bslash;&n;                  spin_unlock_irqrestore(&amp;io_request_lock, spin_flags);
multiline_comment|/* Subversion values */
DECL|macro|ISA
mdefine_line|#define ISA  0
DECL|macro|ESA
mdefine_line|#define ESA 1
DECL|macro|FORCE_CONFIG
macro_line|#undef FORCE_CONFIG
DECL|macro|DEBUG_LINKED_COMMANDS
macro_line|#undef  DEBUG_LINKED_COMMANDS
DECL|macro|DEBUG_DETECT
macro_line|#undef  DEBUG_DETECT
DECL|macro|DEBUG_PCI_DETECT
macro_line|#undef  DEBUG_PCI_DETECT
DECL|macro|DEBUG_INTERRUPT
macro_line|#undef  DEBUG_INTERRUPT
DECL|macro|DEBUG_RESET
macro_line|#undef  DEBUG_RESET
DECL|macro|DEBUG_GENERATE_ERRORS
macro_line|#undef  DEBUG_GENERATE_ERRORS
DECL|macro|DEBUG_GENERATE_ABORTS
macro_line|#undef  DEBUG_GENERATE_ABORTS
DECL|macro|DEBUG_GEOMETRY
macro_line|#undef  DEBUG_GEOMETRY
DECL|macro|MAX_ISA
mdefine_line|#define MAX_ISA 4
DECL|macro|MAX_VESA
mdefine_line|#define MAX_VESA 0
DECL|macro|MAX_EISA
mdefine_line|#define MAX_EISA 15
DECL|macro|MAX_PCI
mdefine_line|#define MAX_PCI 16
DECL|macro|MAX_BOARDS
mdefine_line|#define MAX_BOARDS (MAX_ISA + MAX_VESA + MAX_EISA + MAX_PCI)
DECL|macro|MAX_CHANNEL
mdefine_line|#define MAX_CHANNEL 4
DECL|macro|MAX_LUN
mdefine_line|#define MAX_LUN 32
DECL|macro|MAX_TARGET
mdefine_line|#define MAX_TARGET 32
DECL|macro|MAX_MAILBOXES
mdefine_line|#define MAX_MAILBOXES 64
DECL|macro|MAX_SGLIST
mdefine_line|#define MAX_SGLIST 64
DECL|macro|MAX_LARGE_SGLIST
mdefine_line|#define MAX_LARGE_SGLIST 122
DECL|macro|MAX_INTERNAL_RETRIES
mdefine_line|#define MAX_INTERNAL_RETRIES 64
DECL|macro|MAX_CMD_PER_LUN
mdefine_line|#define MAX_CMD_PER_LUN 2
DECL|macro|MAX_TAGGED_CMD_PER_LUN
mdefine_line|#define MAX_TAGGED_CMD_PER_LUN (MAX_MAILBOXES - MAX_CMD_PER_LUN)
DECL|macro|SKIP
mdefine_line|#define SKIP ULONG_MAX
DECL|macro|FALSE
mdefine_line|#define FALSE 0
DECL|macro|TRUE
mdefine_line|#define TRUE 1
DECL|macro|FREE
mdefine_line|#define FREE 0
DECL|macro|IN_USE
mdefine_line|#define IN_USE   1
DECL|macro|LOCKED
mdefine_line|#define LOCKED   2
DECL|macro|IN_RESET
mdefine_line|#define IN_RESET 3
DECL|macro|IGNORE
mdefine_line|#define IGNORE   4
DECL|macro|READY
mdefine_line|#define READY    5
DECL|macro|ABORTING
mdefine_line|#define ABORTING 6
DECL|macro|NO_DMA
mdefine_line|#define NO_DMA  0xff
DECL|macro|MAXLOOP
mdefine_line|#define MAXLOOP  10000
DECL|macro|TAG_MIXED
mdefine_line|#define TAG_MIXED    0
DECL|macro|TAG_SIMPLE
mdefine_line|#define TAG_SIMPLE   1
DECL|macro|TAG_HEAD
mdefine_line|#define TAG_HEAD     2
DECL|macro|TAG_ORDERED
mdefine_line|#define TAG_ORDERED  3
DECL|macro|REG_CMD
mdefine_line|#define REG_CMD         7
DECL|macro|REG_STATUS
mdefine_line|#define REG_STATUS      7
DECL|macro|REG_AUX_STATUS
mdefine_line|#define REG_AUX_STATUS  8
DECL|macro|REG_DATA
mdefine_line|#define REG_DATA        0
DECL|macro|REG_DATA2
mdefine_line|#define REG_DATA2       1
DECL|macro|REG_SEE
mdefine_line|#define REG_SEE         6
DECL|macro|REG_LOW
mdefine_line|#define REG_LOW         2
DECL|macro|REG_LM
mdefine_line|#define REG_LM          3
DECL|macro|REG_MID
mdefine_line|#define REG_MID         4
DECL|macro|REG_MSB
mdefine_line|#define REG_MSB         5
DECL|macro|REGION_SIZE
mdefine_line|#define REGION_SIZE     9
DECL|macro|MAX_ISA_ADDR
mdefine_line|#define MAX_ISA_ADDR    0x03ff
DECL|macro|MIN_EISA_ADDR
mdefine_line|#define MIN_EISA_ADDR   0x1c88
DECL|macro|MAX_EISA_ADDR
mdefine_line|#define MAX_EISA_ADDR   0xfc88
DECL|macro|BSY_ASSERTED
mdefine_line|#define BSY_ASSERTED      0x80
DECL|macro|DRQ_ASSERTED
mdefine_line|#define DRQ_ASSERTED      0x08
DECL|macro|ABSY_ASSERTED
mdefine_line|#define ABSY_ASSERTED     0x01
DECL|macro|IRQ_ASSERTED
mdefine_line|#define IRQ_ASSERTED      0x02
DECL|macro|READ_CONFIG_PIO
mdefine_line|#define READ_CONFIG_PIO   0xf0
DECL|macro|SET_CONFIG_PIO
mdefine_line|#define SET_CONFIG_PIO    0xf1
DECL|macro|SEND_CP_PIO
mdefine_line|#define SEND_CP_PIO       0xf2
DECL|macro|RECEIVE_SP_PIO
mdefine_line|#define RECEIVE_SP_PIO    0xf3
DECL|macro|TRUNCATE_XFR_PIO
mdefine_line|#define TRUNCATE_XFR_PIO  0xf4
DECL|macro|RESET_PIO
mdefine_line|#define RESET_PIO         0xf9
DECL|macro|READ_CONFIG_DMA
mdefine_line|#define READ_CONFIG_DMA   0xfd
DECL|macro|SET_CONFIG_DMA
mdefine_line|#define SET_CONFIG_DMA    0xfe
DECL|macro|SEND_CP_DMA
mdefine_line|#define SEND_CP_DMA       0xff
DECL|macro|ASOK
mdefine_line|#define ASOK              0x00
DECL|macro|ASST
mdefine_line|#define ASST              0x01
DECL|macro|YESNO
mdefine_line|#define YESNO(a) ((a) ? &squot;y&squot; : &squot;n&squot;)
DECL|macro|TLDEV
mdefine_line|#define TLDEV(type) ((type) == TYPE_DISK || (type) == TYPE_ROM)
multiline_comment|/* &quot;EATA&quot;, in Big Endian format */
DECL|macro|EATA_SIGNATURE
mdefine_line|#define EATA_SIGNATURE 0x41544145
multiline_comment|/* Number of valid bytes in the board config structure for EATA 2.0x */
DECL|macro|EATA_2_0A_SIZE
mdefine_line|#define EATA_2_0A_SIZE 28
DECL|macro|EATA_2_0B_SIZE
mdefine_line|#define EATA_2_0B_SIZE 30
DECL|macro|EATA_2_0C_SIZE
mdefine_line|#define EATA_2_0C_SIZE 34
multiline_comment|/* Board info structure */
DECL|struct|eata_info
r_struct
id|eata_info
(brace
DECL|member|data_len
id|u_int32_t
id|data_len
suffix:semicolon
multiline_comment|/* Number of valid bytes after this field */
DECL|member|sign
id|u_int32_t
id|sign
suffix:semicolon
multiline_comment|/* ASCII &quot;EATA&quot; signature */
DECL|member|unchar
id|unchar
suffix:colon
l_int|4
comma
multiline_comment|/* unused low nibble */
DECL|member|version
id|version
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* EATA version, should be 0x1 */
DECL|member|ocsena
id|unchar
id|ocsena
suffix:colon
l_int|1
comma
multiline_comment|/* Overlap Command Support Enabled */
DECL|member|tarsup
id|tarsup
suffix:colon
l_int|1
comma
multiline_comment|/* Target Mode Supported */
DECL|member|trnxfr
id|trnxfr
suffix:colon
l_int|1
comma
multiline_comment|/* Truncate Transfer Cmd NOT Necessary */
DECL|member|morsup
id|morsup
suffix:colon
l_int|1
comma
multiline_comment|/* More Supported */
DECL|member|dmasup
id|dmasup
suffix:colon
l_int|1
comma
multiline_comment|/* DMA Supported */
DECL|member|drqvld
id|drqvld
suffix:colon
l_int|1
comma
multiline_comment|/* DRQ Index (DRQX) is valid */
DECL|member|ata
id|ata
suffix:colon
l_int|1
comma
multiline_comment|/* This is an ATA device */
DECL|member|haaval
id|haaval
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Host Adapter Address Valid */
DECL|member|cp_pad_len
id|ushort
id|cp_pad_len
suffix:semicolon
multiline_comment|/* Number of pad bytes after cp_len */
DECL|member|host_addr
id|unchar
id|host_addr
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Host Adapter SCSI ID for channels 3, 2, 1, 0 */
DECL|member|cp_len
id|u_int32_t
id|cp_len
suffix:semicolon
multiline_comment|/* Number of valid bytes in cp */
DECL|member|sp_len
id|u_int32_t
id|sp_len
suffix:semicolon
multiline_comment|/* Number of valid bytes in sp */
DECL|member|queue_size
id|ushort
id|queue_size
suffix:semicolon
multiline_comment|/* Max number of cp that can be queued */
DECL|member|unused
id|ushort
id|unused
suffix:semicolon
DECL|member|scatt_size
id|ushort
id|scatt_size
suffix:semicolon
multiline_comment|/* Max number of entries in scatter/gather table */
DECL|member|irq
id|unchar
id|irq
suffix:colon
l_int|4
comma
multiline_comment|/* Interrupt Request assigned to this controller */
DECL|member|irq_tr
id|irq_tr
suffix:colon
l_int|1
comma
multiline_comment|/* 0 for edge triggered, 1 for level triggered */
DECL|member|second
id|second
suffix:colon
l_int|1
comma
multiline_comment|/* 1 if this is a secondary (not primary) controller */
DECL|member|drqx
id|drqx
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* DRQ Index (0=DMA0, 1=DMA7, 2=DMA6, 3=DMA5) */
DECL|member|sync
id|unchar
id|sync
suffix:semicolon
multiline_comment|/* 1 if scsi target id 7...0 is running sync scsi */
multiline_comment|/* Structure extension defined in EATA 2.0B */
DECL|member|isaena
id|unchar
id|isaena
suffix:colon
l_int|1
comma
multiline_comment|/* ISA i/o addressing is disabled/enabled */
DECL|member|forcaddr
id|forcaddr
suffix:colon
l_int|1
comma
multiline_comment|/* Port address has been forced */
DECL|member|large_sg
id|large_sg
suffix:colon
l_int|1
comma
multiline_comment|/* 1 if large SG lists are supported */
DECL|member|res1
id|res1
suffix:colon
l_int|1
comma
suffix:colon
l_int|4
suffix:semicolon
DECL|member|max_id
id|unchar
id|max_id
suffix:colon
l_int|5
comma
multiline_comment|/* Max SCSI target ID number */
DECL|member|max_chan
id|max_chan
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* Max SCSI channel number on this board */
multiline_comment|/* Structure extension defined in EATA 2.0C */
DECL|member|max_lun
id|unchar
id|max_lun
suffix:semicolon
multiline_comment|/* Max SCSI LUN number */
DECL|member|unchar
id|unchar
suffix:colon
l_int|4
comma
DECL|member|m1
id|m1
suffix:colon
l_int|1
comma
multiline_comment|/* This is a PCI with an M1 chip installed */
DECL|member|idquest
id|idquest
suffix:colon
l_int|1
comma
multiline_comment|/* RAIDNUM returned is questionable */
DECL|member|pci
id|pci
suffix:colon
l_int|1
comma
multiline_comment|/* This board is PCI */
DECL|member|eisa
id|eisa
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* This board is EISA */
DECL|member|raidnum
id|unchar
id|raidnum
suffix:semicolon
multiline_comment|/* Uniquely identifies this HBA in a system */
DECL|member|notused
id|unchar
id|notused
suffix:semicolon
DECL|member|ipad
id|ushort
id|ipad
(braket
l_int|247
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Board config structure */
DECL|struct|eata_config
r_struct
id|eata_config
(brace
DECL|member|len
id|ushort
id|len
suffix:semicolon
multiline_comment|/* Number of bytes following this field */
DECL|member|edis
id|unchar
id|edis
suffix:colon
l_int|1
comma
multiline_comment|/* Disable EATA interface after config command */
DECL|member|ocena
id|ocena
suffix:colon
l_int|1
comma
multiline_comment|/* Overlapped Commands Enabled */
DECL|member|mdpena
id|mdpena
suffix:colon
l_int|1
comma
multiline_comment|/* Transfer all Modified Data Pointer Messages */
DECL|member|tarena
id|tarena
suffix:colon
l_int|1
comma
multiline_comment|/* Target Mode Enabled for this controller */
suffix:colon
l_int|4
suffix:semicolon
DECL|member|cpad
id|unchar
id|cpad
(braket
l_int|511
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Returned status packet structure */
DECL|struct|mssp
r_struct
id|mssp
(brace
DECL|member|adapter_status
id|unchar
id|adapter_status
suffix:colon
l_int|7
comma
multiline_comment|/* State related to current command */
DECL|member|eoc
id|eoc
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* End Of Command (1 = command completed) */
DECL|member|target_status
id|unchar
id|target_status
suffix:semicolon
multiline_comment|/* SCSI status received after data transfer */
DECL|member|unused
id|unchar
id|unused
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|inv_res_len
id|u_int32_t
id|inv_res_len
suffix:semicolon
multiline_comment|/* Number of bytes not transferred */
DECL|member|cpp_index
id|u_int32_t
id|cpp_index
suffix:semicolon
multiline_comment|/* Index of address set in cp */
DECL|member|mess
r_char
id|mess
(braket
l_int|12
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|sg_list
r_struct
id|sg_list
(brace
DECL|member|address
r_int
r_int
id|address
suffix:semicolon
multiline_comment|/* Segment Address */
DECL|member|num_bytes
r_int
r_int
id|num_bytes
suffix:semicolon
multiline_comment|/* Segment Length */
)brace
suffix:semicolon
multiline_comment|/* MailBox SCSI Command Packet */
DECL|struct|mscp
r_struct
id|mscp
(brace
DECL|member|sreset
id|unchar
id|sreset
suffix:colon
l_int|1
comma
multiline_comment|/* SCSI Bus Reset Signal should be asserted */
DECL|member|init
id|init
suffix:colon
l_int|1
comma
multiline_comment|/* Re-initialize controller and self test */
DECL|member|reqsen
id|reqsen
suffix:colon
l_int|1
comma
multiline_comment|/* Transfer Request Sense Data to addr using DMA */
DECL|member|sg
id|sg
suffix:colon
l_int|1
comma
multiline_comment|/* Use Scatter/Gather */
suffix:colon
l_int|1
comma
DECL|member|interp
id|interp
suffix:colon
l_int|1
comma
multiline_comment|/* The controller interprets cp, not the target */
DECL|member|dout
id|dout
suffix:colon
l_int|1
comma
multiline_comment|/* Direction of Transfer is Out (Host to Target) */
DECL|member|din
id|din
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Direction of Transfer is In (Target to Host) */
DECL|member|sense_len
id|unchar
id|sense_len
suffix:semicolon
multiline_comment|/* Request Sense Length */
DECL|member|unused
id|unchar
id|unused
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|fwnest
id|unchar
id|fwnest
suffix:colon
l_int|1
comma
multiline_comment|/* Send command to a component of an Array Group */
suffix:colon
l_int|7
suffix:semicolon
DECL|member|phsunit
id|unchar
id|phsunit
suffix:colon
l_int|1
comma
multiline_comment|/* Send to Target Physical Unit (bypass RAID) */
DECL|member|iat
id|iat
suffix:colon
l_int|1
comma
multiline_comment|/* Inhibit Address Translation */
DECL|member|hbaci
id|hbaci
suffix:colon
l_int|1
comma
multiline_comment|/* Inhibit HBA Caching for this command */
suffix:colon
l_int|5
suffix:semicolon
DECL|member|target
id|unchar
id|target
suffix:colon
l_int|5
comma
multiline_comment|/* SCSI target ID */
DECL|member|channel
id|channel
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* SCSI channel number */
DECL|member|lun
id|unchar
id|lun
suffix:colon
l_int|5
comma
multiline_comment|/* SCSI logical unit number */
DECL|member|luntar
id|luntar
suffix:colon
l_int|1
comma
multiline_comment|/* This cp is for Target (not LUN) */
DECL|member|dispri
id|dispri
suffix:colon
l_int|1
comma
multiline_comment|/* Disconnect Privilege granted */
DECL|member|one
id|one
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 1 */
DECL|member|mess
id|unchar
id|mess
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Massage to/from Target */
DECL|member|cdb
id|unchar
id|cdb
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/* Command Descriptor Block */
DECL|member|data_len
id|u_int32_t
id|data_len
suffix:semicolon
multiline_comment|/* If sg=0 Data Length, if sg=1 sglist length */
DECL|member|cpp_index
id|u_int32_t
id|cpp_index
suffix:semicolon
multiline_comment|/* Index of address to be returned in sp */
DECL|member|data_address
id|u_int32_t
id|data_address
suffix:semicolon
multiline_comment|/* If sg=0 Data Address, if sg=1 sglist address */
DECL|member|sp_addr
id|u_int32_t
id|sp_addr
suffix:semicolon
multiline_comment|/* Address where sp is DMA&squot;ed when cp completes */
DECL|member|sense_addr
id|u_int32_t
id|sense_addr
suffix:semicolon
multiline_comment|/* Address where Sense Data is DMA&squot;ed on error */
multiline_comment|/* Additional fields begin here. */
DECL|member|SCpnt
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
DECL|member|sglist
r_struct
id|sg_list
op_star
id|sglist
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|hostdata
r_struct
id|hostdata
(brace
DECL|member|cp
r_struct
id|mscp
id|cp
(braket
id|MAX_MAILBOXES
)braket
suffix:semicolon
multiline_comment|/* Mailboxes for this board */
DECL|member|cp_stat
r_int
r_int
id|cp_stat
(braket
id|MAX_MAILBOXES
)braket
suffix:semicolon
multiline_comment|/* FREE, IN_USE, LOCKED, IN_RESET */
DECL|member|last_cp_used
r_int
r_int
id|last_cp_used
suffix:semicolon
multiline_comment|/* Index of last mailbox used */
DECL|member|iocount
r_int
r_int
id|iocount
suffix:semicolon
multiline_comment|/* Total i/o done for this board */
DECL|member|board_number
r_int
id|board_number
suffix:semicolon
multiline_comment|/* Number of this board */
DECL|member|board_name
r_char
id|board_name
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Name of this board */
DECL|member|board_id
r_char
id|board_id
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/* data from INQUIRY on this board */
DECL|member|in_reset
r_int
id|in_reset
suffix:semicolon
multiline_comment|/* True if board is doing a reset */
DECL|member|target_to
r_int
id|target_to
(braket
id|MAX_TARGET
)braket
(braket
id|MAX_CHANNEL
)braket
suffix:semicolon
multiline_comment|/* N. of timeout errors on target */
DECL|member|target_redo
r_int
id|target_redo
(braket
id|MAX_TARGET
)braket
(braket
id|MAX_CHANNEL
)braket
suffix:semicolon
multiline_comment|/* If TRUE redo i/o on target */
DECL|member|retries
r_int
r_int
id|retries
suffix:semicolon
multiline_comment|/* Number of internal retries */
DECL|member|last_retried_pid
r_int
r_int
id|last_retried_pid
suffix:semicolon
multiline_comment|/* Pid of last retried command */
DECL|member|subversion
r_int
r_char
id|subversion
suffix:semicolon
multiline_comment|/* Bus type, either ISA or EISA/PCI */
DECL|member|protocol_rev
r_int
r_char
id|protocol_rev
suffix:semicolon
multiline_comment|/* EATA 2.0 rev., &squot;A&squot; or &squot;B&squot; or &squot;C&squot; */
DECL|member|sp
r_struct
id|mssp
id|sp
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Returned status for this board */
)brace
suffix:semicolon
DECL|variable|sh
r_static
r_struct
id|Scsi_Host
op_star
id|sh
(braket
id|MAX_BOARDS
op_plus
l_int|1
)braket
suffix:semicolon
DECL|variable|driver_name
r_static
r_const
r_char
op_star
id|driver_name
op_assign
l_string|&quot;EATA&quot;
suffix:semicolon
DECL|variable|sha
r_static
r_char
id|sha
(braket
id|MAX_BOARDS
)braket
suffix:semicolon
multiline_comment|/* Initialize num_boards so that ihdlr can work while detect is in progress */
DECL|variable|num_boards
r_static
r_int
r_int
id|num_boards
op_assign
id|MAX_BOARDS
suffix:semicolon
DECL|variable|io_port
r_static
r_int
r_int
id|io_port
(braket
)braket
op_assign
(brace
multiline_comment|/* Space for MAX_INT_PARAM ports usable while loading as a module */
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
multiline_comment|/* First ISA */
l_int|0x1f0
comma
multiline_comment|/* Space for MAX_PCI ports possibly reported by PCI_BIOS */
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
multiline_comment|/* MAX_EISA ports */
l_int|0x1c88
comma
l_int|0x2c88
comma
l_int|0x3c88
comma
l_int|0x4c88
comma
l_int|0x5c88
comma
l_int|0x6c88
comma
l_int|0x7c88
comma
l_int|0x8c88
comma
l_int|0x9c88
comma
l_int|0xac88
comma
l_int|0xbc88
comma
l_int|0xcc88
comma
l_int|0xdc88
comma
l_int|0xec88
comma
l_int|0xfc88
comma
multiline_comment|/* Other (MAX_ISA - 1) ports */
l_int|0x170
comma
l_int|0x230
comma
l_int|0x330
comma
multiline_comment|/* End of list */
l_int|0x0
)brace
suffix:semicolon
DECL|macro|HD
mdefine_line|#define HD(board) ((struct hostdata *) &amp;sh[board]-&gt;hostdata)
DECL|macro|BN
mdefine_line|#define BN(board) (HD(board)-&gt;board_name)
DECL|macro|H2DEV
mdefine_line|#define H2DEV(x) htonl(x)
DECL|macro|DEV2H
mdefine_line|#define DEV2H(x) H2DEV(x)
DECL|macro|V2DEV
mdefine_line|#define V2DEV(addr) ((addr) ? H2DEV(virt_to_bus((void *)addr)) : 0)
DECL|macro|DEV2V
mdefine_line|#define DEV2V(addr) ((addr) ? DEV2H(bus_to_virt((unsigned long)addr)) : 0)
r_static
r_void
id|do_interrupt_handler
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|flush_dev
c_func
(paren
id|Scsi_Device
op_star
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
DECL|variable|do_trace
r_static
r_int
id|do_trace
op_assign
id|FALSE
suffix:semicolon
DECL|variable|setup_done
r_static
r_int
id|setup_done
op_assign
id|FALSE
suffix:semicolon
DECL|variable|link_statistics
r_static
r_int
id|link_statistics
suffix:semicolon
DECL|variable|tag_mode
r_static
r_int
id|tag_mode
op_assign
id|TAG_MIXED
suffix:semicolon
DECL|variable|ext_tran
r_static
r_int
id|ext_tran
op_assign
id|FALSE
suffix:semicolon
DECL|variable|rev_scan
r_static
r_int
id|rev_scan
op_assign
id|TRUE
suffix:semicolon
DECL|variable|boot_options
r_static
r_char
op_star
id|boot_options
suffix:semicolon
macro_line|#if defined(CONFIG_SCSI_EATA_TAGGED_QUEUE)
DECL|variable|tagged_comm
r_static
r_int
id|tagged_comm
op_assign
id|TRUE
suffix:semicolon
macro_line|#else
DECL|variable|tagged_comm
r_static
r_int
id|tagged_comm
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_SCSI_EATA_LINKED_COMMANDS)
DECL|variable|linked_comm
r_static
r_int
id|linked_comm
op_assign
id|TRUE
suffix:semicolon
macro_line|#else
DECL|variable|linked_comm
r_static
r_int
id|linked_comm
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_SCSI_EATA_MAX_TAGS)
DECL|variable|max_queue_depth
r_static
r_int
id|max_queue_depth
op_assign
id|CONFIG_SCSI_EATA_MAX_TAGS
suffix:semicolon
macro_line|#else
DECL|variable|max_queue_depth
r_static
r_int
id|max_queue_depth
op_assign
id|MAX_CMD_PER_LUN
suffix:semicolon
macro_line|#endif
DECL|function|select_queue_depths
r_static
r_void
id|select_queue_depths
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
id|Scsi_Device
op_star
id|devlist
)paren
(brace
id|Scsi_Device
op_star
id|dev
suffix:semicolon
r_int
id|j
comma
id|ntag
op_assign
l_int|0
comma
id|nuntag
op_assign
l_int|0
comma
id|tqd
comma
id|utqd
suffix:semicolon
id|j
op_assign
(paren
(paren
r_struct
id|hostdata
op_star
)paren
id|host-&gt;hostdata
)paren
op_member_access_from_pointer
id|board_number
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|devlist
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;host
op_ne
id|host
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|TLDEV
c_func
(paren
id|dev-&gt;type
)paren
op_logical_and
(paren
id|dev-&gt;tagged_supported
op_logical_or
id|linked_comm
)paren
)paren
id|ntag
op_increment
suffix:semicolon
r_else
id|nuntag
op_increment
suffix:semicolon
)brace
id|utqd
op_assign
id|MAX_CMD_PER_LUN
suffix:semicolon
id|tqd
op_assign
(paren
id|host-&gt;can_queue
op_minus
id|utqd
op_star
id|nuntag
)paren
op_div
(paren
id|ntag
ques
c_cond
id|ntag
suffix:colon
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tqd
OG
id|max_queue_depth
)paren
id|tqd
op_assign
id|max_queue_depth
suffix:semicolon
r_if
c_cond
(paren
id|tqd
OL
id|MAX_CMD_PER_LUN
)paren
id|tqd
op_assign
id|MAX_CMD_PER_LUN
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|devlist
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_char
op_star
id|tag_suffix
op_assign
l_string|&quot;&quot;
comma
op_star
id|link_suffix
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;host
op_ne
id|host
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|TLDEV
c_func
(paren
id|dev-&gt;type
)paren
op_logical_and
(paren
id|dev-&gt;tagged_supported
op_logical_or
id|linked_comm
)paren
)paren
id|dev-&gt;queue_depth
op_assign
id|tqd
suffix:semicolon
r_else
id|dev-&gt;queue_depth
op_assign
id|utqd
suffix:semicolon
r_if
c_cond
(paren
id|TLDEV
c_func
(paren
id|dev-&gt;type
)paren
)paren
(brace
r_if
c_cond
(paren
id|linked_comm
op_logical_and
id|dev-&gt;queue_depth
OG
l_int|2
)paren
id|link_suffix
op_assign
l_string|&quot;, sorted&quot;
suffix:semicolon
r_else
id|link_suffix
op_assign
l_string|&quot;, unsorted&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tagged_comm
op_logical_and
id|dev-&gt;tagged_supported
op_logical_and
id|TLDEV
c_func
(paren
id|dev-&gt;type
)paren
)paren
(brace
id|dev-&gt;tagged_queue
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;current_tag
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;tagged_supported
op_logical_and
id|TLDEV
c_func
(paren
id|dev-&gt;type
)paren
op_logical_and
id|dev-&gt;tagged_queue
)paren
id|tag_suffix
op_assign
l_string|&quot;, soft-tagged&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dev-&gt;tagged_supported
op_logical_and
id|TLDEV
c_func
(paren
id|dev-&gt;type
)paren
)paren
id|tag_suffix
op_assign
l_string|&quot;, tagged&quot;
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: scsi%d, channel %d, id %d, lun %d, cmds/lun %d%s%s.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|host-&gt;host_no
comma
id|dev-&gt;channel
comma
id|dev-&gt;id
comma
id|dev-&gt;lun
comma
id|dev-&gt;queue_depth
comma
id|link_suffix
comma
id|tag_suffix
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|wait_on_busy
r_static
r_inline
r_int
id|wait_on_busy
c_func
(paren
r_int
r_int
id|iobase
comma
r_int
r_int
id|loop
)paren
(brace
r_while
c_loop
(paren
id|inb
c_func
(paren
id|iobase
op_plus
id|REG_AUX_STATUS
)paren
op_amp
id|ABSY_ASSERTED
)paren
(brace
id|udelay
c_func
(paren
l_int|1L
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|loop
op_eq
l_int|0
)paren
r_return
id|TRUE
suffix:semicolon
)brace
r_return
id|FALSE
suffix:semicolon
)brace
DECL|function|do_dma
r_static
r_inline
r_int
id|do_dma
c_func
(paren
r_int
r_int
id|iobase
comma
r_int
r_int
id|addr
comma
id|unchar
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|wait_on_busy
c_func
(paren
id|iobase
comma
(paren
id|addr
ques
c_cond
id|MAXLOOP
op_star
l_int|100
suffix:colon
id|MAXLOOP
)paren
)paren
)paren
r_return
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_assign
id|V2DEV
c_func
(paren
id|addr
)paren
)paren
)paren
(brace
id|outb
c_func
(paren
(paren
r_char
)paren
(paren
id|addr
op_rshift
l_int|24
)paren
comma
id|iobase
op_plus
id|REG_LOW
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
r_char
)paren
(paren
id|addr
op_rshift
l_int|16
)paren
comma
id|iobase
op_plus
id|REG_LM
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
r_char
)paren
(paren
id|addr
op_rshift
l_int|8
)paren
comma
id|iobase
op_plus
id|REG_MID
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
r_char
)paren
id|addr
comma
id|iobase
op_plus
id|REG_MSB
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|cmd
comma
id|iobase
op_plus
id|REG_CMD
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
DECL|function|read_pio
r_static
r_inline
r_int
id|read_pio
c_func
(paren
r_int
r_int
id|iobase
comma
id|ushort
op_star
id|start
comma
id|ushort
op_star
id|end
)paren
(brace
r_int
r_int
id|loop
op_assign
id|MAXLOOP
suffix:semicolon
id|ushort
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|start
suffix:semicolon
id|p
op_le
id|end
suffix:semicolon
id|p
op_increment
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|iobase
op_plus
id|REG_STATUS
)paren
op_amp
id|DRQ_ASSERTED
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|1L
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|loop
op_eq
l_int|0
)paren
r_return
id|TRUE
suffix:semicolon
)brace
id|loop
op_assign
id|MAXLOOP
suffix:semicolon
op_star
id|p
op_assign
id|inw
c_func
(paren
id|iobase
)paren
suffix:semicolon
)brace
r_return
id|FALSE
suffix:semicolon
)brace
DECL|function|tune_pci_port
r_static
r_inline
r_void
id|tune_pci_port
c_func
(paren
r_int
r_int
id|port_base
)paren
(brace
macro_line|#if defined(CONFIG_PCI)
r_int
r_int
id|addr
comma
id|k
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|MAX_PCI
suffix:semicolon
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev
op_assign
id|pci_find_class
c_func
(paren
id|PCI_CLASS_STORAGE_SCSI
op_lshift
l_int|8
comma
id|dev
)paren
)paren
)paren
r_break
suffix:semicolon
id|addr
op_assign
id|pci_resource_start
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
(paren
id|dev
)paren
)paren
r_continue
suffix:semicolon
macro_line|#if defined(DEBUG_PCI_DETECT)
id|printk
c_func
(paren
l_string|&quot;%s: tune_pci_port, bus %d, devfn 0x%x, addr 0x%x.&bslash;n&quot;
comma
id|driver_name
comma
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|addr
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|addr
op_amp
id|PCI_BASE_ADDRESS_IO_MASK
)paren
op_plus
id|PCI_BASE_ADDRESS_0
op_eq
id|port_base
)paren
(brace
id|pci_set_master
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif /* end CONFIG_PCI */
r_return
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|get_pci_irq
id|get_pci_irq
c_func
(paren
r_int
r_int
id|port_base
comma
r_int
r_char
op_star
id|apic_irq
)paren
(brace
macro_line|#if defined(CONFIG_PCI)
r_int
r_int
id|addr
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
r_return
id|FALSE
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dev
op_assign
id|pci_find_class
c_func
(paren
id|PCI_CLASS_STORAGE_SCSI
op_lshift
l_int|8
comma
id|dev
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PCI_BASE_ADDRESS_0
comma
op_amp
id|addr
)paren
)paren
r_continue
suffix:semicolon
macro_line|#if defined(DEBUG_PCI_DETECT)
id|printk
c_func
(paren
l_string|&quot;%s: get_pci_irq, bus %d, devfn 0x%x, addr 0x%x, apic_irq %u.&bslash;n&quot;
comma
id|driver_name
comma
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|addr
comma
id|dev-&gt;irq
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|addr
op_amp
id|PCI_BASE_ADDRESS_IO_MASK
)paren
op_plus
id|PCI_BASE_ADDRESS_0
op_eq
id|port_base
)paren
(brace
op_star
id|apic_irq
op_assign
id|dev-&gt;irq
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
)brace
macro_line|#endif /* end CONFIG_PCI */
r_return
id|FALSE
suffix:semicolon
)brace
DECL|function|port_detect
r_static
r_inline
r_int
id|port_detect
"&bslash;"
(paren
r_int
r_int
id|port_base
comma
r_int
r_int
id|j
comma
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
r_char
id|irq
comma
id|dma_channel
comma
id|subversion
comma
id|i
suffix:semicolon
r_int
r_char
id|protocol_rev
comma
id|apic_irq
suffix:semicolon
r_struct
id|eata_info
id|info
suffix:semicolon
r_char
op_star
id|bus_type
comma
id|dma_name
(braket
l_int|16
)braket
comma
id|tag_type
suffix:semicolon
multiline_comment|/* Allowed DMA channels for ISA (0 indicates reserved) */
r_int
r_char
id|dma_channel_table
(braket
l_int|4
)braket
op_assign
(brace
l_int|5
comma
l_int|6
comma
l_int|7
comma
l_int|0
)brace
suffix:semicolon
r_char
id|name
(braket
l_int|16
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%s%d&quot;
comma
id|driver_name
comma
id|j
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|port_base
comma
id|REGION_SIZE
)paren
)paren
(brace
macro_line|#if defined(DEBUG_DETECT)
id|printk
c_func
(paren
l_string|&quot;%s: address 0x%03lx in use, skipping probe.&bslash;n&quot;
comma
id|name
comma
id|port_base
)paren
suffix:semicolon
macro_line|#endif
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_dma
c_func
(paren
id|port_base
comma
l_int|0
comma
id|READ_CONFIG_PIO
)paren
)paren
r_return
id|FALSE
suffix:semicolon
multiline_comment|/* Read the info structure */
r_if
c_cond
(paren
id|read_pio
c_func
(paren
id|port_base
comma
(paren
id|ushort
op_star
)paren
op_amp
id|info
comma
(paren
id|ushort
op_star
)paren
op_amp
id|info.ipad
(braket
l_int|0
)braket
)paren
)paren
r_return
id|FALSE
suffix:semicolon
multiline_comment|/* Check the controller &quot;EATA&quot; signature */
r_if
c_cond
(paren
id|info.sign
op_ne
id|EATA_SIGNATURE
)paren
r_return
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|DEV2H
c_func
(paren
id|info.data_len
)paren
OL
id|EATA_2_0A_SIZE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: config structure size (%d bytes) too short, detaching.&bslash;n&quot;
comma
id|name
comma
id|DEV2H
c_func
(paren
id|info.data_len
)paren
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|DEV2H
c_func
(paren
id|info.data_len
)paren
op_eq
id|EATA_2_0A_SIZE
)paren
id|protocol_rev
op_assign
l_char|&squot;A&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|DEV2H
c_func
(paren
id|info.data_len
)paren
op_eq
id|EATA_2_0B_SIZE
)paren
id|protocol_rev
op_assign
l_char|&squot;B&squot;
suffix:semicolon
r_else
id|protocol_rev
op_assign
l_char|&squot;C&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|setup_done
op_logical_and
id|j
OG
l_int|0
op_logical_and
id|j
op_le
id|MAX_PCI
)paren
(brace
id|bus_type
op_assign
l_string|&quot;PCI&quot;
suffix:semicolon
id|subversion
op_assign
id|ESA
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|port_base
OG
id|MAX_EISA_ADDR
op_logical_or
(paren
id|protocol_rev
op_eq
l_char|&squot;C&squot;
op_logical_and
id|info.pci
)paren
)paren
(brace
id|bus_type
op_assign
l_string|&quot;PCI&quot;
suffix:semicolon
id|subversion
op_assign
id|ESA
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|port_base
op_ge
id|MIN_EISA_ADDR
op_logical_or
(paren
id|protocol_rev
op_eq
l_char|&squot;C&squot;
op_logical_and
id|info.eisa
)paren
)paren
(brace
id|bus_type
op_assign
l_string|&quot;EISA&quot;
suffix:semicolon
id|subversion
op_assign
id|ESA
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|protocol_rev
op_eq
l_char|&squot;C&squot;
op_logical_and
op_logical_neg
id|info.eisa
op_logical_and
op_logical_neg
id|info.pci
)paren
(brace
id|bus_type
op_assign
l_string|&quot;ISA&quot;
suffix:semicolon
id|subversion
op_assign
id|ISA
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|port_base
OG
id|MAX_ISA_ADDR
)paren
(brace
id|bus_type
op_assign
l_string|&quot;PCI&quot;
suffix:semicolon
id|subversion
op_assign
id|ESA
suffix:semicolon
)brace
r_else
(brace
id|bus_type
op_assign
l_string|&quot;ISA&quot;
suffix:semicolon
id|subversion
op_assign
id|ISA
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|info.haaval
op_logical_or
id|info.ata
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: address 0x%03lx, unusable %s board (%d%d), detaching.&bslash;n&quot;
comma
id|name
comma
id|port_base
comma
id|bus_type
comma
id|info.haaval
comma
id|info.ata
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info.drqvld
)paren
(brace
r_if
c_cond
(paren
id|subversion
op_eq
id|ESA
)paren
id|printk
c_func
(paren
l_string|&quot;%s: warning, weird %s board using DMA.&bslash;n&quot;
comma
id|name
comma
id|bus_type
)paren
suffix:semicolon
id|subversion
op_assign
id|ISA
suffix:semicolon
id|dma_channel
op_assign
id|dma_channel_table
(braket
l_int|3
op_minus
id|info.drqx
)braket
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|subversion
op_eq
id|ISA
)paren
id|printk
c_func
(paren
l_string|&quot;%s: warning, weird %s board not using DMA.&bslash;n&quot;
comma
id|name
comma
id|bus_type
)paren
suffix:semicolon
id|subversion
op_assign
id|ESA
suffix:semicolon
id|dma_channel
op_assign
id|NO_DMA
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|info.dmasup
)paren
id|printk
c_func
(paren
l_string|&quot;%s: warning, DMA protocol support not asserted.&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|irq
op_assign
id|info.irq
suffix:semicolon
r_if
c_cond
(paren
id|subversion
op_eq
id|ESA
op_logical_and
op_logical_neg
id|info.irq_tr
)paren
id|printk
c_func
(paren
l_string|&quot;%s: warning, LEVEL triggering is suggested for IRQ %u.&bslash;n&quot;
comma
id|name
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_pci_irq
c_func
(paren
id|port_base
comma
op_amp
id|apic_irq
)paren
op_logical_and
(paren
id|irq
op_ne
id|apic_irq
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: IRQ %u mapped to IO-APIC IRQ %u.&bslash;n&quot;
comma
id|name
comma
id|irq
comma
id|apic_irq
)paren
suffix:semicolon
id|irq
op_assign
id|apic_irq
suffix:semicolon
)brace
multiline_comment|/* Board detected, allocate its IRQ */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|irq
comma
id|do_interrupt_handler
comma
id|SA_INTERRUPT
op_or
(paren
(paren
id|subversion
op_eq
id|ESA
)paren
ques
c_cond
id|SA_SHIRQ
suffix:colon
l_int|0
)paren
comma
id|driver_name
comma
(paren
r_void
op_star
)paren
op_amp
id|sha
(braket
id|j
)braket
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to allocate IRQ %u, detaching.&bslash;n&quot;
comma
id|name
comma
id|irq
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|subversion
op_eq
id|ISA
op_logical_and
id|request_dma
c_func
(paren
id|dma_channel
comma
id|driver_name
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to allocate DMA channel %u, detaching.&bslash;n&quot;
comma
id|name
comma
id|dma_channel
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|irq
comma
op_amp
id|sha
(braket
id|j
)braket
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
macro_line|#if defined(FORCE_CONFIG)
(brace
r_struct
id|eata_config
id|config
suffix:semicolon
multiline_comment|/* Set board configuration */
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|config
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|eata_config
)paren
)paren
suffix:semicolon
id|config.len
op_assign
(paren
id|ushort
)paren
id|htons
c_func
(paren
(paren
id|ushort
)paren
l_int|510
)paren
suffix:semicolon
id|config.ocena
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|do_dma
c_func
(paren
id|port_base
comma
(paren
r_int
r_int
)paren
op_amp
id|config
comma
id|SET_CONFIG_DMA
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: busy timeout sending configuration, detaching.&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
)brace
macro_line|#endif
id|sh
(braket
id|j
)braket
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
r_sizeof
(paren
r_struct
id|hostdata
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to register host, detaching.&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|irq
comma
op_amp
id|sha
(braket
id|j
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subversion
op_eq
id|ISA
)paren
id|free_dma
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_assign
id|port_base
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|unique_id
op_assign
id|port_base
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|n_io_port
op_assign
id|REGION_SIZE
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|dma_channel
op_assign
id|dma_channel
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|irq
op_assign
id|irq
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
op_assign
(paren
id|ushort
)paren
id|ntohs
c_func
(paren
id|info.scatt_size
)paren
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|this_id
op_assign
(paren
id|ushort
)paren
id|info.host_addr
(braket
l_int|3
)braket
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
op_assign
(paren
id|ushort
)paren
id|ntohs
c_func
(paren
id|info.queue_size
)paren
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|cmd_per_lun
op_assign
id|MAX_CMD_PER_LUN
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|select_queue_depths
op_assign
id|select_queue_depths
suffix:semicolon
multiline_comment|/* Register the I/O space that we use */
id|request_region
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|n_io_port
comma
id|driver_name
)paren
suffix:semicolon
id|memset
c_func
(paren
id|HD
c_func
(paren
id|j
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|hostdata
)paren
)paren
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|subversion
op_assign
id|subversion
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|protocol_rev
op_assign
id|protocol_rev
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|board_number
op_assign
id|j
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|subversion
op_eq
id|ESA
)paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|unchecked_isa_dma
op_assign
id|FALSE
suffix:semicolon
r_else
(brace
r_int
r_int
id|flags
suffix:semicolon
id|scsi_register_blocked_host
c_func
(paren
id|sh
(braket
id|j
)braket
)paren
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|unchecked_isa_dma
op_assign
id|TRUE
suffix:semicolon
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|dma_channel
comma
id|DMA_MODE_CASCADE
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|BN
c_func
(paren
id|j
)paren
comma
id|name
)paren
suffix:semicolon
multiline_comment|/* DPT PM2012 does not allow to detect sg_tablesize correctly */
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
OG
id|MAX_SGLIST
op_logical_or
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: detect, wrong n. of SG lists %d, fixed.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
)paren
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
op_assign
id|MAX_SGLIST
suffix:semicolon
)brace
multiline_comment|/* DPT PM2012 does not allow to detect can_queue correctly */
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
OG
id|MAX_MAILBOXES
op_logical_or
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: detect, wrong n. of mbox %d, fixed.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
)paren
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
op_assign
id|MAX_MAILBOXES
suffix:semicolon
)brace
r_if
c_cond
(paren
id|protocol_rev
op_ne
l_char|&squot;A&squot;
)paren
(brace
r_if
c_cond
(paren
id|info.max_chan
OG
l_int|0
op_logical_and
id|info.max_chan
OL
id|MAX_CHANNEL
)paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_channel
op_assign
id|info.max_chan
suffix:semicolon
r_if
c_cond
(paren
id|info.max_id
OG
l_int|7
op_logical_and
id|info.max_id
OL
id|MAX_TARGET
)paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_id
op_assign
id|info.max_id
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|info.large_sg
op_logical_and
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
op_eq
id|MAX_SGLIST
)paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
op_assign
id|MAX_LARGE_SGLIST
suffix:semicolon
)brace
r_if
c_cond
(paren
id|protocol_rev
op_eq
l_char|&squot;C&squot;
)paren
(brace
r_if
c_cond
(paren
id|info.max_lun
OG
l_int|7
op_logical_and
id|info.max_lun
OL
id|MAX_LUN
)paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_lun
op_assign
id|info.max_lun
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dma_channel
op_eq
id|NO_DMA
)paren
id|sprintf
c_func
(paren
id|dma_name
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;BMST&quot;
)paren
suffix:semicolon
r_else
id|sprintf
c_func
(paren
id|dma_name
comma
l_string|&quot;DMA %u&quot;
comma
id|dma_channel
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
)paren
op_member_access_from_pointer
id|sglist
op_assign
id|kmalloc
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
op_star
r_sizeof
(paren
r_struct
id|sg_list
)paren
comma
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|unchecked_isa_dma
ques
c_cond
id|GFP_DMA
suffix:colon
l_int|0
)paren
op_or
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: kmalloc SGlist failed, mbox %d, detaching.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
id|eata2x_release
c_func
(paren
id|sh
(braket
id|j
)braket
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|max_queue_depth
OG
id|MAX_TAGGED_CMD_PER_LUN
)paren
id|max_queue_depth
op_assign
id|MAX_TAGGED_CMD_PER_LUN
suffix:semicolon
r_if
c_cond
(paren
id|max_queue_depth
OL
id|MAX_CMD_PER_LUN
)paren
id|max_queue_depth
op_assign
id|MAX_CMD_PER_LUN
suffix:semicolon
r_if
c_cond
(paren
id|tagged_comm
)paren
(brace
r_if
c_cond
(paren
id|tag_mode
op_eq
id|TAG_SIMPLE
)paren
id|tag_type
op_assign
l_char|&squot;1&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tag_mode
op_eq
id|TAG_HEAD
)paren
id|tag_type
op_assign
l_char|&squot;2&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tag_mode
op_eq
id|TAG_ORDERED
)paren
id|tag_type
op_assign
l_char|&squot;3&squot;
suffix:semicolon
r_else
id|tag_type
op_assign
l_char|&squot;y&squot;
suffix:semicolon
)brace
r_else
id|tag_type
op_assign
l_char|&squot;n&squot;
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;EATA/DMA 2.0x: Copyright (C) 1994-2000 Dario Ballabio.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s config options -&gt; tc:%c, lc:%c, mq:%d, rs:%c, et:%c.&bslash;n&quot;
comma
id|driver_name
comma
id|tag_type
comma
id|YESNO
c_func
(paren
id|linked_comm
)paren
comma
id|max_queue_depth
comma
id|YESNO
c_func
(paren
id|rev_scan
)paren
comma
id|YESNO
c_func
(paren
id|ext_tran
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: 2.0%c, %s 0x%03lx, IRQ %u, %s, SG %d, MB %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|protocol_rev
comma
id|bus_type
comma
(paren
r_int
r_int
)paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|irq
comma
id|dma_name
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_id
OG
l_int|8
op_logical_or
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_lun
OG
l_int|8
)paren
id|printk
c_func
(paren
l_string|&quot;%s: wide SCSI support enabled, max_id %u, max_lun %u.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_id
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_lun
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_channel
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%s: SCSI channel %u enabled, host target ID %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|info.host_addr
(braket
l_int|3
op_minus
id|i
)braket
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_DETECT)
id|printk
c_func
(paren
l_string|&quot;%s: Vers. 0x%x, ocs %u, tar %u, trnxfr %u, more %u, SYNC 0x%x, &quot;
"&bslash;"
l_string|&quot;sec. %u, infol %ld, cpl %ld spl %ld.&bslash;n&quot;
comma
id|name
comma
id|info.version
comma
id|info.ocsena
comma
id|info.tarsup
comma
id|info.trnxfr
comma
id|info.morsup
comma
id|info.sync
comma
id|info.second
comma
id|DEV2H
c_func
(paren
id|info.data_len
)paren
comma
id|DEV2H
c_func
(paren
id|info.cp_len
)paren
comma
id|DEV2H
c_func
(paren
id|info.sp_len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|protocol_rev
op_eq
l_char|&squot;B&squot;
op_logical_or
id|protocol_rev
op_eq
l_char|&squot;C&squot;
)paren
id|printk
c_func
(paren
l_string|&quot;%s: isaena %u, forcaddr %u, max_id %u, max_chan %u, &quot;
"&bslash;"
l_string|&quot;large_sg %u, res1 %u.&bslash;n&quot;
comma
id|name
comma
id|info.isaena
comma
id|info.forcaddr
comma
id|info.max_id
comma
id|info.max_chan
comma
id|info.large_sg
comma
id|info.res1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|protocol_rev
op_eq
l_char|&squot;C&squot;
)paren
id|printk
c_func
(paren
l_string|&quot;%s: max_lun %u, m1 %u, idquest %u, pci %u, eisa %u, &quot;
"&bslash;"
l_string|&quot;raidnum %u.&bslash;n&quot;
comma
id|name
comma
id|info.max_lun
comma
id|info.m1
comma
id|info.idquest
comma
id|info.pci
comma
id|info.eisa
comma
id|info.raidnum
)paren
suffix:semicolon
macro_line|#endif
id|tune_pci_port
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
DECL|function|internal_setup
r_static
r_void
id|internal_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_int
id|i
comma
id|argc
op_assign
id|ints
(braket
l_int|0
)braket
suffix:semicolon
r_char
op_star
id|cur
op_assign
id|str
comma
op_star
id|pc
suffix:semicolon
r_if
c_cond
(paren
id|argc
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|argc
OG
id|MAX_INT_PARAM
)paren
id|argc
op_assign
id|MAX_INT_PARAM
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
id|io_port
(braket
id|i
)braket
op_assign
id|ints
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
id|io_port
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|setup_done
op_assign
id|TRUE
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cur
op_logical_and
(paren
id|pc
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;:&squot;
)paren
)paren
)paren
(brace
r_int
id|val
op_assign
l_int|0
comma
id|c
op_assign
op_star
op_increment
id|pc
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;n&squot;
op_logical_or
id|c
op_eq
l_char|&squot;N&squot;
)paren
id|val
op_assign
id|FALSE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;y&squot;
op_logical_or
id|c
op_eq
l_char|&squot;Y&squot;
)paren
id|val
op_assign
id|TRUE
suffix:semicolon
r_else
id|val
op_assign
(paren
r_int
)paren
id|simple_strtoul
c_func
(paren
id|pc
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;lc:&quot;
comma
l_int|3
)paren
)paren
id|linked_comm
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;tc:&quot;
comma
l_int|3
)paren
)paren
id|tagged_comm
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;tm:&quot;
comma
l_int|3
)paren
)paren
id|tag_mode
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;mq:&quot;
comma
l_int|3
)paren
)paren
id|max_queue_depth
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;ls:&quot;
comma
l_int|3
)paren
)paren
id|link_statistics
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;et:&quot;
comma
l_int|3
)paren
)paren
id|ext_tran
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;rs:&quot;
comma
l_int|3
)paren
)paren
id|rev_scan
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cur
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;,&squot;
)paren
)paren
)paren
op_increment
id|cur
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|option_setup
r_static
r_int
id|option_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|ints
(braket
id|MAX_INT_PARAM
)braket
suffix:semicolon
r_char
op_star
id|cur
op_assign
id|str
suffix:semicolon
r_int
id|i
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_logical_and
id|isdigit
c_func
(paren
op_star
id|cur
)paren
op_logical_and
id|i
op_le
id|MAX_INT_PARAM
)paren
(brace
id|ints
(braket
id|i
op_increment
)braket
op_assign
id|simple_strtoul
c_func
(paren
id|cur
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cur
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;,&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
id|cur
op_increment
suffix:semicolon
)brace
id|ints
(braket
l_int|0
)braket
op_assign
id|i
op_minus
l_int|1
suffix:semicolon
id|internal_setup
c_func
(paren
id|cur
comma
id|ints
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|add_pci_ports
r_static
r_void
id|add_pci_ports
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined(CONFIG_PCI)
r_int
r_int
id|addr
comma
id|k
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|MAX_PCI
suffix:semicolon
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev
op_assign
id|pci_find_class
c_func
(paren
id|PCI_CLASS_STORAGE_SCSI
op_lshift
l_int|8
comma
id|dev
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PCI_BASE_ADDRESS_0
comma
op_amp
id|addr
)paren
)paren
r_continue
suffix:semicolon
macro_line|#if defined(DEBUG_PCI_DETECT)
id|printk
c_func
(paren
l_string|&quot;%s: detect, seq. %d, bus %d, devfn 0x%x, addr 0x%x.&bslash;n&quot;
comma
id|driver_name
comma
id|k
comma
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|addr
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|addr
op_amp
id|PCI_BASE_ADDRESS_SPACE
)paren
op_ne
id|PCI_BASE_ADDRESS_SPACE_IO
)paren
r_continue
suffix:semicolon
multiline_comment|/* Order addresses according to rev_scan value */
id|io_port
(braket
id|MAX_INT_PARAM
op_plus
(paren
id|rev_scan
ques
c_cond
(paren
id|MAX_PCI
op_minus
id|k
)paren
suffix:colon
(paren
l_int|1
op_plus
id|k
)paren
)paren
)braket
op_assign
(paren
id|addr
op_amp
id|PCI_BASE_ADDRESS_IO_MASK
)paren
op_plus
id|PCI_BASE_ADDRESS_0
suffix:semicolon
)brace
macro_line|#endif /* end CONFIG_PCI */
r_return
suffix:semicolon
)brace
DECL|function|eata2x_detect
r_int
id|eata2x_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
r_int
id|j
op_assign
l_int|0
comma
id|k
suffix:semicolon
id|tpnt-&gt;proc_name
op_assign
l_string|&quot;eata2x&quot;
suffix:semicolon
r_if
c_cond
(paren
id|boot_options
)paren
(brace
id|option_setup
c_func
(paren
id|boot_options
)paren
suffix:semicolon
)brace
macro_line|#if defined(MODULE)
multiline_comment|/* io_port could have been modified when loading as a module */
r_if
c_cond
(paren
id|io_port
(braket
l_int|0
)braket
op_ne
id|SKIP
)paren
(brace
id|setup_done
op_assign
id|TRUE
suffix:semicolon
id|io_port
(braket
id|MAX_INT_PARAM
)braket
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|MAX_BOARDS
op_plus
l_int|1
suffix:semicolon
id|k
op_increment
)paren
id|sh
(braket
id|k
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|setup_done
)paren
id|add_pci_ports
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|io_port
(braket
id|k
)braket
suffix:semicolon
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
id|io_port
(braket
id|k
)braket
op_eq
id|SKIP
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|j
OL
id|MAX_BOARDS
op_logical_and
id|port_detect
c_func
(paren
id|io_port
(braket
id|k
)braket
comma
id|j
comma
id|tpnt
)paren
)paren
id|j
op_increment
suffix:semicolon
)brace
id|num_boards
op_assign
id|j
suffix:semicolon
r_return
id|j
suffix:semicolon
)brace
DECL|function|build_sg_list
r_static
r_inline
r_void
id|build_sg_list
c_func
(paren
r_struct
id|mscp
op_star
id|cpp
comma
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|k
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sgpnt
suffix:semicolon
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;request_buffer
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|k
op_increment
)paren
(brace
id|cpp-&gt;sglist
(braket
id|k
)braket
dot
id|address
op_assign
id|V2DEV
c_func
(paren
id|sgpnt
(braket
id|k
)braket
dot
id|address
)paren
suffix:semicolon
id|cpp-&gt;sglist
(braket
id|k
)braket
dot
id|num_bytes
op_assign
id|H2DEV
c_func
(paren
id|sgpnt
(braket
id|k
)braket
dot
id|length
)paren
suffix:semicolon
)brace
id|cpp-&gt;data_address
op_assign
id|V2DEV
c_func
(paren
id|cpp-&gt;sglist
)paren
suffix:semicolon
id|cpp-&gt;data_len
op_assign
id|H2DEV
c_func
(paren
(paren
id|SCpnt-&gt;use_sg
op_star
r_sizeof
(paren
r_struct
id|sg_list
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|do_qcomm
r_static
r_inline
r_int
id|do_qcomm
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_struct
id|mscp
op_star
id|cpp
suffix:semicolon
r_struct
id|mssp
op_star
id|spp
suffix:semicolon
r_static
r_const
r_int
r_char
id|data_out_cmds
(braket
)braket
op_assign
(brace
l_int|0x0a
comma
l_int|0x2a
comma
l_int|0x15
comma
l_int|0x55
comma
l_int|0x04
comma
l_int|0x07
comma
l_int|0x18
comma
l_int|0x1d
comma
l_int|0x24
comma
l_int|0x2e
comma
l_int|0x30
comma
l_int|0x31
comma
l_int|0x32
comma
l_int|0x38
comma
l_int|0x39
comma
l_int|0x3a
comma
l_int|0x3b
comma
l_int|0x3d
comma
l_int|0x3f
comma
l_int|0x40
comma
l_int|0x41
comma
l_int|0x4c
comma
l_int|0xaa
comma
l_int|0xae
comma
l_int|0xb0
comma
l_int|0xb1
comma
l_int|0xb2
comma
l_int|0xb6
comma
l_int|0xea
comma
l_int|0x1b
)brace
suffix:semicolon
r_static
r_const
r_int
r_char
id|data_none_cmds
(braket
)braket
op_assign
(brace
l_int|0x01
comma
l_int|0x0b
comma
l_int|0x10
comma
l_int|0x11
comma
l_int|0x13
comma
l_int|0x16
comma
l_int|0x17
comma
l_int|0x19
comma
l_int|0x2b
comma
l_int|0x1e
comma
l_int|0x2c
comma
l_int|0xac
comma
l_int|0x2f
comma
l_int|0xaf
comma
l_int|0x33
comma
l_int|0xb3
comma
l_int|0x35
comma
l_int|0x36
comma
l_int|0x45
comma
l_int|0x47
comma
l_int|0x48
comma
l_int|0x49
comma
l_int|0xa9
comma
l_int|0x4b
comma
l_int|0xa5
comma
l_int|0xa6
comma
l_int|0xb5
)brace
suffix:semicolon
multiline_comment|/* j is the board number */
id|j
op_assign
(paren
(paren
r_struct
id|hostdata
op_star
)paren
id|SCpnt-&gt;host-&gt;hostdata
)paren
op_member_access_from_pointer
id|board_number
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host_scribble
)paren
id|panic
c_func
(paren
l_string|&quot;%s: qcomm, pid %ld, SCpnt %p already active.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCpnt-&gt;pid
comma
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/* i is the mailbox number, look for the first free mailbox&n;      starting from last_cp_used */
id|i
op_assign
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|last_cp_used
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
suffix:semicolon
id|k
op_increment
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_ge
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
)paren
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|FREE
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|last_cp_used
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|k
op_eq
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: qcomm, no free mailbox.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Set pointer to control packet structure */
id|cpp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
suffix:semicolon
id|memset
c_func
(paren
id|cpp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mscp
)paren
op_minus
r_sizeof
(paren
r_struct
id|sg_list
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/* Set pointer to status packet structure */
id|spp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|sp
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* The EATA protocol uses Big Endian format */
id|cpp-&gt;sp_addr
op_assign
id|V2DEV
c_func
(paren
id|spp
)paren
suffix:semicolon
id|SCpnt-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cpp-&gt;cpp_index
op_assign
id|i
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|cpp-&gt;cpp_index
suffix:semicolon
r_if
c_cond
(paren
id|do_trace
)paren
id|printk
c_func
(paren
l_string|&quot;%s: qcomm, mbox %d, target %d.%d:%d, pid %ld.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|ARRAY_SIZE
c_func
(paren
id|data_out_cmds
)paren
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|data_out_cmds
(braket
id|k
)braket
)paren
(brace
id|cpp-&gt;dout
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cpp-&gt;din
op_assign
op_logical_neg
id|cpp-&gt;dout
)paren
)paren
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|ARRAY_SIZE
c_func
(paren
id|data_none_cmds
)paren
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|data_none_cmds
(braket
id|k
)braket
)paren
(brace
id|cpp-&gt;din
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cpp-&gt;reqsen
op_assign
id|TRUE
suffix:semicolon
id|cpp-&gt;dispri
op_assign
id|TRUE
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;type
op_eq
id|TYPE_TAPE
)paren
id|cpp-&gt;hbaci
op_assign
id|TRUE
suffix:semicolon
macro_line|#endif
id|cpp-&gt;one
op_assign
id|TRUE
suffix:semicolon
id|cpp-&gt;channel
op_assign
id|SCpnt-&gt;channel
suffix:semicolon
id|cpp-&gt;target
op_assign
id|SCpnt-&gt;target
suffix:semicolon
id|cpp-&gt;lun
op_assign
id|SCpnt-&gt;lun
suffix:semicolon
id|cpp-&gt;SCpnt
op_assign
id|SCpnt
suffix:semicolon
id|cpp-&gt;sense_addr
op_assign
id|V2DEV
c_func
(paren
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|cpp-&gt;sense_len
op_assign
r_sizeof
id|SCpnt-&gt;sense_buffer
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;tagged_queue
)paren
(brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_redo
(braket
id|SCpnt-&gt;target
)braket
(braket
id|SCpnt-&gt;channel
)braket
op_logical_or
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_to
(braket
id|SCpnt-&gt;target
)braket
(braket
id|SCpnt-&gt;channel
)braket
)paren
id|cpp-&gt;mess
(braket
l_int|0
)braket
op_assign
id|ORDERED_QUEUE_TAG
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tag_mode
op_eq
id|TAG_SIMPLE
)paren
id|cpp-&gt;mess
(braket
l_int|0
)braket
op_assign
id|SIMPLE_QUEUE_TAG
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tag_mode
op_eq
id|TAG_HEAD
)paren
id|cpp-&gt;mess
(braket
l_int|0
)braket
op_assign
id|HEAD_OF_QUEUE_TAG
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tag_mode
op_eq
id|TAG_ORDERED
)paren
id|cpp-&gt;mess
(braket
l_int|0
)braket
op_assign
id|ORDERED_QUEUE_TAG
suffix:semicolon
r_else
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;current_tag
op_eq
l_int|0
)paren
id|cpp-&gt;mess
(braket
l_int|0
)braket
op_assign
id|ORDERED_QUEUE_TAG
suffix:semicolon
r_else
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;current_tag
op_eq
l_int|1
)paren
id|cpp-&gt;mess
(braket
l_int|0
)braket
op_assign
id|HEAD_OF_QUEUE_TAG
suffix:semicolon
r_else
id|cpp-&gt;mess
(braket
l_int|0
)braket
op_assign
id|SIMPLE_QUEUE_TAG
suffix:semicolon
id|cpp-&gt;mess
(braket
l_int|1
)braket
op_assign
id|SCpnt-&gt;device-&gt;current_tag
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
id|cpp-&gt;sg
op_assign
id|TRUE
suffix:semicolon
id|build_sg_list
c_func
(paren
id|cpp
comma
id|SCpnt
)paren
suffix:semicolon
)brace
r_else
(brace
id|cpp-&gt;data_address
op_assign
id|V2DEV
c_func
(paren
id|SCpnt-&gt;request_buffer
)paren
suffix:semicolon
id|cpp-&gt;data_len
op_assign
id|H2DEV
c_func
(paren
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|cpp-&gt;cdb
comma
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;cmd_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|linked_comm
op_logical_and
id|SCpnt-&gt;device-&gt;queue_depth
OG
l_int|2
op_logical_and
id|TLDEV
c_func
(paren
id|SCpnt-&gt;device-&gt;type
)paren
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|READY
suffix:semicolon
id|flush_dev
c_func
(paren
id|SCpnt-&gt;device
comma
id|SCpnt-&gt;request.sector
comma
id|j
comma
id|FALSE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Send control packet to the board */
r_if
c_cond
(paren
id|do_dma
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
(paren
r_int
r_int
)paren
id|cpp
comma
id|SEND_CP_DMA
)paren
)paren
(brace
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: qcomm, target %d.%d:%d, pid %ld, adapter busy.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|IN_USE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|eata2x_queuecommand
r_int
id|eata2x_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
id|rtn
suffix:semicolon
id|rtn
op_assign
id|do_qcomm
c_func
(paren
id|SCpnt
comma
id|done
)paren
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
DECL|function|do_abort
r_static
r_inline
r_int
id|do_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCarg
)paren
(brace
r_int
r_int
id|i
comma
id|j
suffix:semicolon
id|j
op_assign
(paren
(paren
r_struct
id|hostdata
op_star
)paren
id|SCarg-&gt;host-&gt;hostdata
)paren
op_member_access_from_pointer
id|board_number
suffix:semicolon
r_if
c_cond
(paren
id|SCarg-&gt;host_scribble
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: abort, target %d.%d:%d, pid %ld inactive.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCarg-&gt;channel
comma
id|SCarg-&gt;target
comma
id|SCarg-&gt;lun
comma
id|SCarg-&gt;pid
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
id|i
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|SCarg-&gt;host_scribble
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: abort, mbox %d, target %d.%d:%d, pid %ld.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCarg-&gt;channel
comma
id|SCarg-&gt;target
comma
id|SCarg-&gt;lun
comma
id|SCarg-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
)paren
id|panic
c_func
(paren
l_string|&quot;%s: abort, invalid SCarg-&gt;host_scribble.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_on_busy
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
id|MAXLOOP
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: abort, timeout error.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|FREE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: abort, mbox %d is free.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|IN_USE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: abort, mbox %d is in use.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCarg
op_ne
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
dot
id|SCpnt
)paren
id|panic
c_func
(paren
l_string|&quot;%s: abort, mbox %d, SCarg %p, cp SCpnt %p.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCarg
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
dot
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_AUX_STATUS
)paren
op_amp
id|IRQ_ASSERTED
)paren
id|printk
c_func
(paren
l_string|&quot;%s: abort, mbox %d, interrupt pending.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCarg-&gt;eh_state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
id|SCarg-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|FREE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s, abort, mbox %d, eh_state timeout, pid %ld.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCarg-&gt;pid
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
r_return
id|FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|IN_RESET
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: abort, mbox %d is in reset.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|LOCKED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: abort, mbox %d is locked.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|READY
op_logical_or
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|ABORTING
)paren
(brace
id|SCarg-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|SCarg-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|FREE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s, abort, mbox %d ready, DID_ABORT, pid %ld done.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCarg-&gt;pid
)paren
suffix:semicolon
id|SCarg
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|SCarg
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
id|panic
c_func
(paren
l_string|&quot;%s: abort, mbox %d, invalid cp_stat.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
)brace
DECL|function|eata2x_abort
r_int
id|eata2x_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCarg
)paren
(brace
r_return
id|do_abort
c_func
(paren
id|SCarg
)paren
suffix:semicolon
)brace
DECL|function|do_reset
r_static
r_inline
r_int
id|do_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCarg
)paren
(brace
r_int
r_int
id|i
comma
id|j
comma
id|time
comma
id|k
comma
id|c
comma
id|limit
op_assign
l_int|0
suffix:semicolon
r_int
id|arg_done
op_assign
id|FALSE
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|j
op_assign
(paren
(paren
r_struct
id|hostdata
op_star
)paren
id|SCarg-&gt;host-&gt;hostdata
)paren
op_member_access_from_pointer
id|board_number
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: reset, enter, target %d.%d:%d, pid %ld.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCarg-&gt;channel
comma
id|SCarg-&gt;target
comma
id|SCarg-&gt;lun
comma
id|SCarg-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCarg-&gt;host_scribble
op_eq
l_int|NULL
)paren
id|printk
c_func
(paren
l_string|&quot;%s: reset, pid %ld inactive.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCarg-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|in_reset
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: reset, exit, already in reset.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wait_on_busy
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
id|MAXLOOP
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: reset, exit, timeout error.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|retries
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
l_int|0
suffix:semicolon
id|c
op_le
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_channel
suffix:semicolon
id|c
op_increment
)paren
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_id
suffix:semicolon
id|k
op_increment
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_redo
(braket
id|k
)braket
(braket
id|c
)braket
op_assign
id|TRUE
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_to
(braket
id|k
)braket
(braket
id|c
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|FREE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|LOCKED
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|FREE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: reset, locked mbox %d forced free.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|SCpnt
op_assign
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
dot
id|SCpnt
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;%s: reset, mbox %d, SCpnt == NULL.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|READY
op_logical_or
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|ABORTING
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|ABORTING
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: reset, mbox %d aborting, pid %ld.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
)brace
r_else
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|IN_RESET
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: reset, mbox %d in reset, pid %ld.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;host_scribble
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;%s: reset, mbox %d, garbled SCpnt.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|SCpnt-&gt;host_scribble
op_ne
id|i
)paren
id|panic
c_func
(paren
l_string|&quot;%s: reset, mbox %d, index mismatch.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;scsi_done
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;%s: reset, mbox %d, SCpnt-&gt;scsi_done == NULL.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_eq
id|SCarg
)paren
id|arg_done
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_dma
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
l_int|0
comma
id|RESET_PIO
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: reset, cannot reset, timeout error.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: reset, board reset done, enabling interrupts.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_RESET)
id|do_trace
op_assign
id|TRUE
suffix:semicolon
macro_line|#endif
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|in_reset
op_assign
id|TRUE
suffix:semicolon
id|SPIN_UNLOCK
id|time
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
(paren
id|jiffies
op_minus
id|time
)paren
OL
(paren
l_int|10
op_star
id|HZ
)paren
op_logical_and
id|limit
op_increment
OL
l_int|200000
)paren
id|udelay
c_func
(paren
l_int|100L
)paren
suffix:semicolon
id|SPIN_LOCK
id|printk
c_func
(paren
l_string|&quot;%s: reset, interrupts disabled, loops %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|limit
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|IN_RESET
)paren
(brace
id|SCpnt
op_assign
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
dot
id|SCpnt
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* This mailbox is still waiting for its interrupt */
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|LOCKED
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s, reset, mbox %d locked, DID_RESET, pid %ld done.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|ABORTING
)paren
(brace
id|SCpnt
op_assign
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
dot
id|SCpnt
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* This mailbox was never queued to the adapter */
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|FREE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s, reset, mbox %d aborting, DID_RESET, pid %ld done.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Any other mailbox has already been set free by interrupt */
r_continue
suffix:semicolon
id|SCpnt
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|in_reset
op_assign
id|FALSE
suffix:semicolon
id|do_trace
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|arg_done
)paren
id|printk
c_func
(paren
l_string|&quot;%s: reset, exit, pid %ld done.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCarg-&gt;pid
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%s: reset, exit.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
DECL|function|eata2x_reset
r_int
id|eata2x_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCarg
)paren
(brace
r_return
id|do_reset
c_func
(paren
id|SCarg
)paren
suffix:semicolon
)brace
DECL|function|eata2x_biosparam
r_int
id|eata2x_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
op_star
id|dkinfo
)paren
(brace
r_int
id|size
op_assign
id|disk-&gt;capacity
suffix:semicolon
r_if
c_cond
(paren
id|ext_tran
op_logical_or
(paren
id|scsicam_bios_param
c_func
(paren
id|disk
comma
id|dev
comma
id|dkinfo
)paren
OL
l_int|0
)paren
)paren
(brace
id|dkinfo
(braket
l_int|0
)braket
op_assign
l_int|255
suffix:semicolon
id|dkinfo
(braket
l_int|1
)braket
op_assign
l_int|63
suffix:semicolon
id|dkinfo
(braket
l_int|2
)braket
op_assign
id|size
op_div
(paren
id|dkinfo
(braket
l_int|0
)braket
op_star
id|dkinfo
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
macro_line|#if defined (DEBUG_GEOMETRY)
id|printk
(paren
l_string|&quot;%s: biosparam, head=%d, sec=%d, cyl=%d.&bslash;n&quot;
comma
id|driver_name
comma
id|dkinfo
(braket
l_int|0
)braket
comma
id|dkinfo
(braket
l_int|1
)braket
comma
id|dkinfo
(braket
l_int|2
)braket
)paren
suffix:semicolon
macro_line|#endif
r_return
id|FALSE
suffix:semicolon
)brace
DECL|function|sort
r_static
r_void
id|sort
c_func
(paren
r_int
r_int
id|sk
(braket
)braket
comma
r_int
r_int
id|da
(braket
)braket
comma
r_int
r_int
id|n
comma
r_int
r_int
id|rev
)paren
(brace
r_int
r_int
id|i
comma
id|j
comma
id|k
comma
id|y
suffix:semicolon
r_int
r_int
id|x
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|k
op_assign
id|i
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|k
op_plus
l_int|1
suffix:semicolon
id|j
OL
id|n
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|rev
)paren
(brace
r_if
c_cond
(paren
id|sk
(braket
id|j
)braket
OG
id|sk
(braket
id|k
)braket
)paren
id|k
op_assign
id|j
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk
(braket
id|j
)braket
OL
id|sk
(braket
id|k
)braket
)paren
id|k
op_assign
id|j
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
op_ne
id|i
)paren
(brace
id|x
op_assign
id|sk
(braket
id|k
)braket
suffix:semicolon
id|sk
(braket
id|k
)braket
op_assign
id|sk
(braket
id|i
)braket
suffix:semicolon
id|sk
(braket
id|i
)braket
op_assign
id|x
suffix:semicolon
id|y
op_assign
id|da
(braket
id|k
)braket
suffix:semicolon
id|da
(braket
id|k
)braket
op_assign
id|da
(braket
id|i
)braket
suffix:semicolon
id|da
(braket
id|i
)braket
op_assign
id|y
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
DECL|function|reorder
r_static
r_inline
r_int
id|reorder
c_func
(paren
r_int
r_int
id|j
comma
r_int
r_int
id|cursec
comma
r_int
r_int
id|ihdlr
comma
r_int
r_int
id|il
(braket
)braket
comma
r_int
r_int
id|n_ready
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_struct
id|mscp
op_star
id|cpp
suffix:semicolon
r_int
r_int
id|k
comma
id|n
suffix:semicolon
r_int
r_int
id|rev
op_assign
id|FALSE
comma
id|s
op_assign
id|TRUE
comma
id|r
op_assign
id|TRUE
suffix:semicolon
r_int
r_int
id|input_only
op_assign
id|TRUE
comma
id|overlap
op_assign
id|FALSE
suffix:semicolon
r_int
r_int
id|sl
(braket
id|n_ready
)braket
comma
id|pl
(braket
id|n_ready
)braket
comma
id|ll
(braket
id|n_ready
)braket
suffix:semicolon
r_int
r_int
id|maxsec
op_assign
l_int|0
comma
id|minsec
op_assign
id|ULONG_MAX
comma
id|seek
op_assign
l_int|0
comma
id|iseek
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|ioseek
op_assign
l_int|0
suffix:semicolon
r_static
r_int
r_int
id|flushcount
op_assign
l_int|0
comma
id|batchcount
op_assign
l_int|0
comma
id|sortcount
op_assign
l_int|0
suffix:semicolon
r_static
r_int
r_int
id|readycount
op_assign
l_int|0
comma
id|ovlcount
op_assign
l_int|0
comma
id|inputcount
op_assign
l_int|0
suffix:semicolon
r_static
r_int
r_int
id|readysorted
op_assign
l_int|0
comma
id|revcount
op_assign
l_int|0
suffix:semicolon
r_static
r_int
r_int
id|seeksorted
op_assign
l_int|0
comma
id|seeknosort
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|link_statistics
op_logical_and
op_logical_neg
(paren
op_increment
id|flushcount
op_mod
id|link_statistics
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;fc %d bc %d ic %d oc %d rc %d rs %d sc %d re %d&quot;
"&bslash;"
l_string|&quot; av %ldK as %ldK.&bslash;n&quot;
comma
id|flushcount
comma
id|batchcount
comma
id|inputcount
comma
id|ovlcount
comma
id|readycount
comma
id|readysorted
comma
id|sortcount
comma
id|revcount
comma
id|seeknosort
op_div
(paren
id|readycount
op_plus
l_int|1
)paren
comma
id|seeksorted
op_div
(paren
id|readycount
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_ready
op_le
l_int|1
)paren
r_return
id|FALSE
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|n_ready
suffix:semicolon
id|n
op_increment
)paren
(brace
id|k
op_assign
id|il
(braket
id|n
)braket
suffix:semicolon
id|cpp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|k
)braket
suffix:semicolon
id|SCpnt
op_assign
id|cpp-&gt;SCpnt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpp-&gt;din
)paren
id|input_only
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request.sector
OL
id|minsec
)paren
id|minsec
op_assign
id|SCpnt-&gt;request.sector
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request.sector
OG
id|maxsec
)paren
id|maxsec
op_assign
id|SCpnt-&gt;request.sector
suffix:semicolon
id|sl
(braket
id|n
)braket
op_assign
id|SCpnt-&gt;request.sector
suffix:semicolon
id|ioseek
op_add_assign
id|SCpnt-&gt;request.nr_sectors
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|sl
(braket
id|n
)braket
OL
id|sl
(braket
id|n
op_minus
l_int|1
)braket
)paren
id|s
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|sl
(braket
id|n
)braket
OG
id|sl
(braket
id|n
op_minus
l_int|1
)braket
)paren
id|r
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|link_statistics
)paren
(brace
r_if
c_cond
(paren
id|sl
(braket
id|n
)braket
OG
id|sl
(braket
id|n
op_minus
l_int|1
)braket
)paren
id|seek
op_add_assign
id|sl
(braket
id|n
)braket
op_minus
id|sl
(braket
id|n
op_minus
l_int|1
)braket
suffix:semicolon
r_else
id|seek
op_add_assign
id|sl
(braket
id|n
op_minus
l_int|1
)braket
op_minus
id|sl
(braket
id|n
)braket
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|link_statistics
)paren
(brace
r_if
c_cond
(paren
id|cursec
OG
id|sl
(braket
l_int|0
)braket
)paren
id|seek
op_add_assign
id|cursec
op_minus
id|sl
(braket
l_int|0
)braket
suffix:semicolon
r_else
id|seek
op_add_assign
id|sl
(braket
l_int|0
)braket
op_minus
id|cursec
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cursec
OG
(paren
(paren
id|maxsec
op_plus
id|minsec
)paren
op_div
l_int|2
)paren
)paren
id|rev
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|ioseek
OG
(paren
(paren
id|maxsec
op_minus
id|minsec
)paren
op_div
l_int|2
)paren
)paren
id|rev
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|rev
op_logical_and
id|r
)paren
op_logical_or
(paren
op_logical_neg
id|rev
op_logical_and
id|s
)paren
)paren
)paren
id|sort
c_func
(paren
id|sl
comma
id|il
comma
id|n_ready
comma
id|rev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|input_only
)paren
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|n_ready
suffix:semicolon
id|n
op_increment
)paren
(brace
id|k
op_assign
id|il
(braket
id|n
)braket
suffix:semicolon
id|cpp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|k
)braket
suffix:semicolon
id|SCpnt
op_assign
id|cpp-&gt;SCpnt
suffix:semicolon
id|ll
(braket
id|n
)braket
op_assign
id|SCpnt-&gt;request.nr_sectors
suffix:semicolon
id|pl
(braket
id|n
)braket
op_assign
id|SCpnt-&gt;pid
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sl
(braket
id|n
)braket
op_eq
id|sl
(braket
id|n
op_minus
l_int|1
)braket
)paren
op_logical_or
(paren
op_logical_neg
id|rev
op_logical_and
(paren
(paren
id|sl
(braket
id|n
op_minus
l_int|1
)braket
op_plus
id|ll
(braket
id|n
op_minus
l_int|1
)braket
)paren
OG
id|sl
(braket
id|n
)braket
)paren
)paren
op_logical_or
(paren
id|rev
op_logical_and
(paren
(paren
id|sl
(braket
id|n
)braket
op_plus
id|ll
(braket
id|n
)braket
)paren
OG
id|sl
(braket
id|n
op_minus
l_int|1
)braket
)paren
)paren
)paren
id|overlap
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|overlap
)paren
id|sort
c_func
(paren
id|pl
comma
id|il
comma
id|n_ready
comma
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link_statistics
)paren
(brace
r_if
c_cond
(paren
id|cursec
OG
id|sl
(braket
l_int|0
)braket
)paren
id|iseek
op_assign
id|cursec
op_minus
id|sl
(braket
l_int|0
)braket
suffix:semicolon
r_else
id|iseek
op_assign
id|sl
(braket
l_int|0
)braket
op_minus
id|cursec
suffix:semicolon
id|batchcount
op_increment
suffix:semicolon
id|readycount
op_add_assign
id|n_ready
suffix:semicolon
id|seeknosort
op_add_assign
id|seek
op_div
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
id|input_only
)paren
id|inputcount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|overlap
)paren
(brace
id|ovlcount
op_increment
suffix:semicolon
id|seeksorted
op_add_assign
id|iseek
op_div
l_int|1024
suffix:semicolon
)brace
r_else
id|seeksorted
op_add_assign
(paren
id|iseek
op_plus
id|maxsec
op_minus
id|minsec
)paren
op_div
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
id|rev
op_logical_and
op_logical_neg
id|r
)paren
(brace
id|revcount
op_increment
suffix:semicolon
id|readysorted
op_add_assign
id|n_ready
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rev
op_logical_and
op_logical_neg
id|s
)paren
(brace
id|sortcount
op_increment
suffix:semicolon
id|readysorted
op_add_assign
id|n_ready
suffix:semicolon
)brace
)brace
macro_line|#if defined(DEBUG_LINKED_COMMANDS)
r_if
c_cond
(paren
id|link_statistics
op_logical_and
(paren
id|overlap
op_logical_or
op_logical_neg
(paren
id|flushcount
op_mod
id|link_statistics
)paren
)paren
)paren
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|n_ready
suffix:semicolon
id|n
op_increment
)paren
(brace
id|k
op_assign
id|il
(braket
id|n
)braket
suffix:semicolon
id|cpp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|k
)braket
suffix:semicolon
id|SCpnt
op_assign
id|cpp-&gt;SCpnt
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s %d.%d:%d pid %ld mb %d fc %d nr %d sec %ld ns %ld&quot;
"&bslash;"
l_string|&quot; cur %ld s:%c r:%c rev:%c in:%c ov:%c xd %d.&bslash;n&quot;
comma
(paren
id|ihdlr
ques
c_cond
l_string|&quot;ihdlr&quot;
suffix:colon
l_string|&quot;qcomm&quot;
)paren
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;pid
comma
id|k
comma
id|flushcount
comma
id|n_ready
comma
id|SCpnt-&gt;request.sector
comma
id|SCpnt-&gt;request.nr_sectors
comma
id|cursec
comma
id|YESNO
c_func
(paren
id|s
)paren
comma
id|YESNO
c_func
(paren
id|r
)paren
comma
id|YESNO
c_func
(paren
id|rev
)paren
comma
id|YESNO
c_func
(paren
id|input_only
)paren
comma
id|YESNO
c_func
(paren
id|overlap
)paren
comma
id|cpp-&gt;din
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|overlap
suffix:semicolon
)brace
DECL|function|flush_dev
r_static
r_void
id|flush_dev
c_func
(paren
id|Scsi_Device
op_star
id|dev
comma
r_int
r_int
id|cursec
comma
r_int
r_int
id|j
comma
r_int
r_int
id|ihdlr
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_struct
id|mscp
op_star
id|cpp
suffix:semicolon
r_int
r_int
id|k
comma
id|n
comma
id|n_ready
op_assign
l_int|0
comma
id|il
(braket
id|MAX_MAILBOXES
)braket
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
suffix:semicolon
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|k
)braket
op_ne
id|READY
op_logical_and
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|k
)braket
op_ne
id|IN_USE
)paren
r_continue
suffix:semicolon
id|cpp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|k
)braket
suffix:semicolon
id|SCpnt
op_assign
id|cpp-&gt;SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;device
op_ne
id|dev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|k
)braket
op_eq
id|IN_USE
)paren
r_return
suffix:semicolon
id|il
(braket
id|n_ready
op_increment
)braket
op_assign
id|k
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reorder
c_func
(paren
id|j
comma
id|cursec
comma
id|ihdlr
comma
id|il
comma
id|n_ready
)paren
)paren
id|n_ready
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|n_ready
suffix:semicolon
id|n
op_increment
)paren
(brace
id|k
op_assign
id|il
(braket
id|n
)braket
suffix:semicolon
id|cpp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|k
)braket
suffix:semicolon
id|SCpnt
op_assign
id|cpp-&gt;SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|do_dma
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
(paren
r_int
r_int
)paren
id|cpp
comma
id|SEND_CP_DMA
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s, target %d.%d:%d, pid %ld, mbox %d, adapter&quot;
"&bslash;"
l_string|&quot; busy, will abort.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
(paren
id|ihdlr
ques
c_cond
l_string|&quot;ihdlr&quot;
suffix:colon
l_string|&quot;qcomm&quot;
)paren
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;pid
comma
id|k
)paren
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|k
)braket
op_assign
id|ABORTING
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|k
)braket
op_assign
id|IN_USE
suffix:semicolon
)brace
)brace
DECL|function|ihdlr
r_static
r_inline
r_void
id|ihdlr
c_func
(paren
r_int
id|irq
comma
r_int
r_int
id|j
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_int
r_int
id|i
comma
id|k
comma
id|c
comma
id|status
comma
id|tstatus
comma
id|reg
suffix:semicolon
r_struct
id|mssp
op_star
id|dspp
comma
op_star
id|spp
suffix:semicolon
r_struct
id|mscp
op_star
id|cpp
suffix:semicolon
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|irq
op_ne
id|irq
)paren
id|panic
c_func
(paren
l_string|&quot;%s: ihdlr, irq %d, sh[j]-&gt;irq %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|irq
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|irq
)paren
suffix:semicolon
multiline_comment|/* Check if this board need to be serviced */
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_AUX_STATUS
)paren
op_amp
id|IRQ_ASSERTED
)paren
)paren
r_return
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|do_trace
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, enter, irq %d, count %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|irq
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
)paren
suffix:semicolon
multiline_comment|/* Check if this board is still busy */
r_if
c_cond
(paren
id|wait_on_busy
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
l_int|20
op_star
id|MAXLOOP
)paren
)paren
(brace
id|reg
op_assign
id|inb
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_STATUS
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, busy timeout error,  irq %d, reg 0x%x, count %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|irq
comma
id|reg
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dspp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|sp
(braket
l_int|0
)braket
suffix:semicolon
id|spp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|sp
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Make a local copy just before clearing the interrupt indication */
id|memcpy
c_func
(paren
id|spp
comma
id|dspp
comma
r_sizeof
(paren
r_struct
id|mssp
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear the completion flag and cp pointer on the dynamic copy of sp */
id|memset
c_func
(paren
id|dspp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mssp
)paren
)paren
suffix:semicolon
multiline_comment|/* Read the status register to clear the interrupt indication */
id|reg
op_assign
id|inb
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_STATUS
)paren
suffix:semicolon
multiline_comment|/* Reject any sp with supspect data */
r_if
c_cond
(paren
id|spp-&gt;eoc
op_eq
id|FALSE
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, spp-&gt;eoc == FALSE, irq %d, reg 0x%x, count %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|irq
comma
id|reg
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|spp-&gt;cpp_index
OL
l_int|0
op_logical_or
id|spp-&gt;cpp_index
op_ge
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, bad spp-&gt;cpp_index %d, irq %d, reg 0x%x, count %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|spp-&gt;cpp_index
comma
id|irq
comma
id|reg
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|spp-&gt;eoc
op_eq
id|FALSE
op_logical_or
id|spp-&gt;cpp_index
OL
l_int|0
op_logical_or
id|spp-&gt;cpp_index
op_ge
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
)paren
r_return
suffix:semicolon
multiline_comment|/* Find the mailbox to be serviced on this board */
id|i
op_assign
id|spp-&gt;cpp_index
suffix:semicolon
id|cpp
op_assign
op_amp
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_GENERATE_ABORTS)
r_if
c_cond
(paren
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
OG
l_int|500
)paren
op_logical_and
(paren
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
op_mod
l_int|500
)paren
OL
l_int|3
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|IGNORE
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|FREE
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|LOCKED
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|FREE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d unlocked, count %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|FREE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d is free, count %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|IN_RESET
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d is in reset.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_ne
id|IN_USE
)paren
id|panic
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d, invalid cp_stat: %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
)paren
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|FREE
suffix:semicolon
id|SCpnt
op_assign
id|cpp-&gt;SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d, SCpnt == NULL.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host_scribble
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d, pid %ld, SCpnt %p garbled.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;pid
comma
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|SCpnt-&gt;host_scribble
op_ne
id|i
)paren
id|panic
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d, pid %ld, index mismatch %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;pid
comma
op_star
(paren
r_int
r_int
op_star
)paren
id|SCpnt-&gt;host_scribble
)paren
suffix:semicolon
r_if
c_cond
(paren
id|linked_comm
op_logical_and
id|SCpnt-&gt;device-&gt;queue_depth
OG
l_int|2
op_logical_and
id|TLDEV
c_func
(paren
id|SCpnt-&gt;device-&gt;type
)paren
)paren
id|flush_dev
c_func
(paren
id|SCpnt-&gt;device
comma
id|SCpnt-&gt;request.sector
comma
id|j
comma
id|TRUE
)paren
suffix:semicolon
id|tstatus
op_assign
id|status_byte
c_func
(paren
id|spp-&gt;target_status
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_GENERATE_ERRORS)
r_if
c_cond
(paren
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
OG
l_int|500
)paren
op_logical_and
(paren
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
op_mod
l_int|200
)paren
OL
l_int|2
)paren
)paren
id|spp-&gt;adapter_status
op_assign
l_int|0x01
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|spp-&gt;adapter_status
)paren
(brace
r_case
id|ASOK
suffix:colon
multiline_comment|/* status OK */
multiline_comment|/* Forces a reset if a disk drive keeps returning BUSY */
r_if
c_cond
(paren
id|tstatus
op_eq
id|BUSY
op_logical_and
id|SCpnt-&gt;device-&gt;type
op_ne
id|TYPE_TAPE
)paren
id|status
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* If there was a bus reset, redo operation on each target */
r_else
r_if
c_cond
(paren
id|tstatus
op_ne
id|GOOD
op_logical_and
id|SCpnt-&gt;device-&gt;type
op_eq
id|TYPE_DISK
op_logical_and
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_redo
(braket
id|SCpnt-&gt;target
)braket
(braket
id|SCpnt-&gt;channel
)braket
)paren
id|status
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* Works around a flaw in scsi.c */
r_else
r_if
c_cond
(paren
id|tstatus
op_eq
id|CHECK_CONDITION
op_logical_and
id|SCpnt-&gt;device-&gt;type
op_eq
id|TYPE_DISK
op_logical_and
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
id|RECOVERED_ERROR
)paren
id|status
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
r_else
id|status
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|tstatus
op_eq
id|GOOD
)paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_redo
(braket
id|SCpnt-&gt;target
)braket
(braket
id|SCpnt-&gt;channel
)braket
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|spp-&gt;target_status
op_logical_and
id|SCpnt-&gt;device-&gt;type
op_eq
id|TYPE_DISK
op_logical_and
(paren
op_logical_neg
(paren
id|tstatus
op_eq
id|CHECK_CONDITION
op_logical_and
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
op_le
l_int|1000
op_logical_and
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
id|NOT_READY
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, target %d.%d:%d, pid %ld, &quot;
"&bslash;"
l_string|&quot;target_status 0x%x, sense key 0x%x.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;pid
comma
id|spp-&gt;target_status
comma
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_to
(braket
id|SCpnt-&gt;target
)braket
(braket
id|SCpnt-&gt;channel
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|last_retried_pid
op_eq
id|SCpnt-&gt;pid
)paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|retries
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ASST
suffix:colon
multiline_comment|/* Selection Time Out */
r_case
l_int|0x02
suffix:colon
multiline_comment|/* Command Time Out   */
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_to
(braket
id|SCpnt-&gt;target
)braket
(braket
id|SCpnt-&gt;channel
)braket
OG
l_int|1
)paren
id|status
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_else
(brace
id|status
op_assign
id|DID_TIME_OUT
op_lshift
l_int|16
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_to
(braket
id|SCpnt-&gt;target
)braket
(braket
id|SCpnt-&gt;channel
)braket
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* Perform a limited number of internal retries */
r_case
l_int|0x03
suffix:colon
multiline_comment|/* SCSI Bus Reset Received */
r_case
l_int|0x04
suffix:colon
multiline_comment|/* Initial Controller Power-up */
r_for
c_loop
(paren
id|c
op_assign
l_int|0
suffix:semicolon
id|c
op_le
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_channel
suffix:semicolon
id|c
op_increment
)paren
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_id
suffix:semicolon
id|k
op_increment
)paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_redo
(braket
id|k
)braket
(braket
id|c
)braket
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;type
op_ne
id|TYPE_TAPE
op_logical_and
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|retries
OL
id|MAX_INTERNAL_RETRIES
)paren
(brace
macro_line|#if defined(DID_SOFT_ERROR)
id|status
op_assign
id|DID_SOFT_ERROR
op_lshift
l_int|16
suffix:semicolon
macro_line|#else
id|status
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
macro_line|#endif
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|retries
op_increment
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|last_retried_pid
op_assign
id|SCpnt-&gt;pid
suffix:semicolon
)brace
r_else
id|status
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x05
suffix:colon
multiline_comment|/* Unexpected Bus Phase */
r_case
l_int|0x06
suffix:colon
multiline_comment|/* Unexpected Bus Free */
r_case
l_int|0x07
suffix:colon
multiline_comment|/* Bus Parity Error */
r_case
l_int|0x08
suffix:colon
multiline_comment|/* SCSI Hung */
r_case
l_int|0x09
suffix:colon
multiline_comment|/* Unexpected Message Reject */
r_case
l_int|0x0a
suffix:colon
multiline_comment|/* SCSI Bus Reset Stuck */
r_case
l_int|0x0b
suffix:colon
multiline_comment|/* Auto Request-Sense Failed */
r_case
l_int|0x0c
suffix:colon
multiline_comment|/* Controller Ram Parity Error */
r_default
suffix:colon
id|status
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
)brace
id|SCpnt-&gt;result
op_assign
id|status
op_or
id|spp-&gt;target_status
suffix:semicolon
macro_line|#if defined(DEBUG_INTERRUPT)
r_if
c_cond
(paren
id|SCpnt-&gt;result
op_logical_or
id|do_trace
)paren
macro_line|#else
r_if
c_cond
(paren
(paren
id|spp-&gt;adapter_status
op_ne
id|ASOK
op_logical_and
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
OG
l_int|1000
)paren
op_logical_or
(paren
id|spp-&gt;adapter_status
op_ne
id|ASOK
op_logical_and
id|spp-&gt;adapter_status
op_ne
id|ASST
op_logical_and
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
op_le
l_int|1000
)paren
op_logical_or
id|do_trace
op_logical_or
id|msg_byte
c_func
(paren
id|spp-&gt;target_status
)paren
)paren
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %2d, err 0x%x:%x,&quot;
"&bslash;"
l_string|&quot; target %d.%d:%d, pid %ld, reg 0x%x, count %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|spp-&gt;adapter_status
comma
id|spp-&gt;target_status
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;pid
comma
id|reg
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
)paren
suffix:semicolon
multiline_comment|/* Set the command state to inactive */
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_trace
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, exit, irq %d, count %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|irq
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|do_interrupt_handler
r_static
r_void
id|do_interrupt_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|shap
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|j
suffix:semicolon
id|SPIN_FLAGS
multiline_comment|/* Check if the interrupt must be processed by this handler */
r_if
c_cond
(paren
(paren
id|j
op_assign
(paren
r_int
r_int
)paren
(paren
(paren
r_char
op_star
)paren
id|shap
op_minus
id|sha
)paren
)paren
op_ge
id|num_boards
)paren
r_return
suffix:semicolon
id|SPIN_LOCK_SAVE
id|ihdlr
c_func
(paren
id|irq
comma
id|j
)paren
suffix:semicolon
id|SPIN_UNLOCK_RESTORE
)brace
DECL|function|eata2x_release
r_int
id|eata2x_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_int
r_int
id|i
comma
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|sh
(braket
id|j
)braket
op_ne
l_int|NULL
op_logical_and
id|sh
(braket
id|j
)braket
op_ne
id|shpnt
suffix:semicolon
id|j
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;%s: release, invalid Scsi_Host pointer.&bslash;n&quot;
comma
id|driver_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|unchecked_isa_dma
)paren
(brace
id|scsi_deregister_blocked_host
c_func
(paren
id|sh
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
)paren
op_member_access_from_pointer
id|sglist
)paren
id|kfree
c_func
(paren
(paren
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
)paren
op_member_access_from_pointer
id|sglist
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|irq
comma
op_amp
id|sha
(braket
id|j
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|dma_channel
op_ne
id|NO_DMA
)paren
id|free_dma
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|dma_channel
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|n_io_port
)paren
suffix:semicolon
id|scsi_unregister
c_func
(paren
id|sh
(braket
id|j
)braket
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|EATA
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
macro_line|#ifndef MODULE
id|__setup
c_func
(paren
l_string|&quot;eata=&quot;
comma
id|option_setup
)paren
suffix:semicolon
macro_line|#endif /* end MODULE */
eof
