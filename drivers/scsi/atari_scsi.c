multiline_comment|/*&n; * atari_scsi.c -- Device dependent functions for the Atari generic SCSI port&n; *&n; * Copyright 1994 Roman Hodek &lt;Roman.Hodek@informatik.uni-erlangen.de&gt;&n; *&n; *   Loosely based on the work of Robert De Vries&squot; team and added:&n; *    - working real DMA&n; *    - Falcon support (untested yet!)   ++bjoern fixed and now it works&n; *    - lots of extensions and bug fixes.&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file COPYING in the main directory of this archive&n; * for more details.&n; *&n; */
multiline_comment|/**************************************************************************/
multiline_comment|/*                                                                        */
multiline_comment|/* Notes for Falcon SCSI:                                                 */
multiline_comment|/* ----------------------                                                 */
multiline_comment|/*                                                                        */
multiline_comment|/* Since the Falcon SCSI uses the ST-DMA chip, that is shared among       */
multiline_comment|/* several device drivers, locking and unlocking the access to this       */
multiline_comment|/* chip is required. But locking is not possible from an interrupt,       */
multiline_comment|/* since it puts the process to sleep if the lock is not available.       */
multiline_comment|/* This prevents &quot;late&quot; locking of the DMA chip, i.e. locking it just     */
multiline_comment|/* before using it, since in case of disconnection-reconnection           */
multiline_comment|/* commands, the DMA is started from the reselection interrupt.           */
multiline_comment|/*                                                                        */
multiline_comment|/* Two possible schemes for ST-DMA-locking would be:                      */
multiline_comment|/*  1) The lock is taken for each command separately and disconnecting    */
multiline_comment|/*     is forbidden (i.e. can_queue = 1).                                 */
multiline_comment|/*  2) The DMA chip is locked when the first command comes in and         */
multiline_comment|/*     released when the last command is finished and all queues are      */
multiline_comment|/*     empty.                                                             */
multiline_comment|/* The first alternative would result in bad performance, since the       */
multiline_comment|/* interleaving of commands would not be used. The second is unfair to    */
multiline_comment|/* other drivers using the ST-DMA, because the queues will seldom be      */
multiline_comment|/* totally empty if there is a lot of disk traffic.                       */
multiline_comment|/*                                                                        */
multiline_comment|/* For this reasons I decided to employ a more elaborate scheme:          */
multiline_comment|/*  - First, we give up the lock every time we can (for fairness), this    */
multiline_comment|/*    means every time a command finishes and there are no other commands */
multiline_comment|/*    on the disconnected queue.                                          */
multiline_comment|/*  - If there are others waiting to lock the DMA chip, we stop           */
multiline_comment|/*    issuing commands, i.e. moving them onto the issue queue.           */
multiline_comment|/*    Because of that, the disconnected queue will run empty in a         */
multiline_comment|/*    while. Instead we go to sleep on a &squot;fairness_queue&squot;.                */
multiline_comment|/*  - If the lock is released, all processes waiting on the fairness      */
multiline_comment|/*    queue will be woken. The first of them tries to re-lock the DMA,     */
multiline_comment|/*    the others wait for the first to finish this task. After that,      */
multiline_comment|/*    they can all run on and do their commands...                        */
multiline_comment|/* This sounds complicated (and it is it :-(), but it seems to be a       */
multiline_comment|/* good compromise between fairness and performance: As long as no one     */
multiline_comment|/* else wants to work with the ST-DMA chip, SCSI can go along as          */
multiline_comment|/* usual. If now someone else comes, this behaviour is changed to a       */
multiline_comment|/* &quot;fairness mode&quot;: just already initiated commands are finished and      */
multiline_comment|/* then the lock is released. The other one waiting will probably win     */
multiline_comment|/* the race for locking the DMA, since it was waiting for longer. And     */
multiline_comment|/* after it has finished, SCSI can go ahead again. Finally: I hope I      */
multiline_comment|/* have not produced any deadlock possibilities!                          */
multiline_comment|/*                                                                        */
multiline_comment|/**************************************************************************/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
DECL|macro|NDEBUG
mdefine_line|#define NDEBUG (0)
DECL|macro|NDEBUG_ABORT
mdefine_line|#define NDEBUG_ABORT&t;0x800000
DECL|macro|NDEBUG_TAGS
mdefine_line|#define NDEBUG_TAGS&t;0x1000000
DECL|macro|NDEBUG_MERGING
mdefine_line|#define NDEBUG_MERGING&t;0x2000000
DECL|macro|AUTOSENSE
mdefine_line|#define AUTOSENSE
multiline_comment|/* For the Atari version, use only polled IO or REAL_DMA */
DECL|macro|REAL_DMA
mdefine_line|#define&t;REAL_DMA
multiline_comment|/* Support tagged queuing? (on devices that are able to... :-) */
DECL|macro|SUPPORT_TAGS
mdefine_line|#define&t;SUPPORT_TAGS
DECL|macro|MAX_TAGS
mdefine_line|#define&t;MAX_TAGS 32
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/nvram.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/atarihw.h&gt;
macro_line|#include &lt;asm/atariints.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/traps.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;atari_scsi.h&quot;
macro_line|#include &quot;NCR5380.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#include &lt;asm/atari_stdma.h&gt;
macro_line|#include &lt;asm/atari_stram.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
DECL|macro|IS_A_TT
mdefine_line|#define&t;IS_A_TT()&t;ATARIHW_PRESENT(TT_SCSI)
DECL|macro|SCSI_DMA_WRITE_P
mdefine_line|#define&t;SCSI_DMA_WRITE_P(elt,val)&t;&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;unsigned long v = val;&t;&t;&t;&t;&bslash;&n;&t;&t;tt_scsi_dma.elt##_lo = v &amp; 0xff;&t;&t;&bslash;&n;&t;&t;v &gt;&gt;= 8;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;tt_scsi_dma.elt##_lmd = v &amp; 0xff;&t;&t;&bslash;&n;&t;&t;v &gt;&gt;= 8;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;tt_scsi_dma.elt##_hmd = v &amp; 0xff;&t;&t;&bslash;&n;&t;&t;v &gt;&gt;= 8;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;tt_scsi_dma.elt##_hi = v &amp; 0xff;&t;&t;&bslash;&n;&t;} while(0)
DECL|macro|SCSI_DMA_READ_P
mdefine_line|#define&t;SCSI_DMA_READ_P(elt)&t;&t;&t;&t;&t;&bslash;&n;&t;(((((((unsigned long)tt_scsi_dma.elt##_hi &lt;&lt; 8) |&t;&bslash;&n;&t;     (unsigned long)tt_scsi_dma.elt##_hmd) &lt;&lt; 8) |&t;&bslash;&n;&t;   (unsigned long)tt_scsi_dma.elt##_lmd) &lt;&lt; 8) |&t;&bslash;&n;&t; (unsigned long)tt_scsi_dma.elt##_lo)
DECL|function|SCSI_DMA_SETADR
r_static
r_inline
r_void
id|SCSI_DMA_SETADR
c_func
(paren
r_int
r_int
id|adr
)paren
(brace
id|st_dma.dma_lo
op_assign
(paren
r_int
r_char
)paren
id|adr
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|adr
op_rshift_assign
l_int|8
suffix:semicolon
id|st_dma.dma_md
op_assign
(paren
r_int
r_char
)paren
id|adr
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|adr
op_rshift_assign
l_int|8
suffix:semicolon
id|st_dma.dma_hi
op_assign
(paren
r_int
r_char
)paren
id|adr
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|SCSI_DMA_GETADR
r_static
r_inline
r_int
r_int
id|SCSI_DMA_GETADR
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|adr
suffix:semicolon
id|adr
op_assign
id|st_dma.dma_lo
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|adr
op_or_assign
(paren
id|st_dma.dma_md
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|adr
op_or_assign
(paren
id|st_dma.dma_hi
op_amp
l_int|0xff
)paren
op_lshift
l_int|16
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
r_return
id|adr
suffix:semicolon
)brace
DECL|function|ENABLE_IRQ
r_static
r_inline
r_void
id|ENABLE_IRQ
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|IS_A_TT
c_func
(paren
)paren
)paren
id|atari_enable_irq
c_func
(paren
id|IRQ_TT_MFP_SCSI
)paren
suffix:semicolon
r_else
id|atari_enable_irq
c_func
(paren
id|IRQ_MFP_FSCSI
)paren
suffix:semicolon
)brace
DECL|function|DISABLE_IRQ
r_static
r_inline
r_void
id|DISABLE_IRQ
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|IS_A_TT
c_func
(paren
)paren
)paren
id|atari_disable_irq
c_func
(paren
id|IRQ_TT_MFP_SCSI
)paren
suffix:semicolon
r_else
id|atari_disable_irq
c_func
(paren
id|IRQ_MFP_FSCSI
)paren
suffix:semicolon
)brace
DECL|macro|HOSTDATA_DMALEN
mdefine_line|#define HOSTDATA_DMALEN&t;&t;(((struct NCR5380_hostdata *) &bslash;&n;&t;&t;&t;&t;(atari_scsi_host-&gt;hostdata))-&gt;dma_len)
multiline_comment|/* Time (in jiffies) to wait after a reset; the SCSI standard calls for 250ms,&n; * we usually do 0.5s to be on the safe side. But Toshiba CD-ROMs once more&n; * need ten times the standard value... */
macro_line|#ifndef CONFIG_ATARI_SCSI_TOSHIBA_DELAY
DECL|macro|AFTER_RESET_DELAY
mdefine_line|#define&t;AFTER_RESET_DELAY&t;(HZ/2)
macro_line|#else
DECL|macro|AFTER_RESET_DELAY
mdefine_line|#define&t;AFTER_RESET_DELAY&t;(5*HZ/2)
macro_line|#endif
multiline_comment|/***************************** Prototypes *****************************/
macro_line|#ifdef REAL_DMA
r_static
r_int
id|scsi_dma_is_ignored_buserr
c_func
(paren
r_int
r_char
id|dma_stat
)paren
suffix:semicolon
r_static
r_void
id|atari_scsi_fetch_restbytes
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|atari_scsi_dma_residual
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
suffix:semicolon
r_static
r_int
id|falcon_classify_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_int
r_int
id|atari_dma_xfer_len
c_func
(paren
r_int
r_int
id|wanted_len
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|write_flag
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|scsi_tt_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dummy
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
suffix:semicolon
r_static
r_void
id|scsi_falcon_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dummy
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
suffix:semicolon
r_static
r_void
id|falcon_release_lock_if_possible
c_func
(paren
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
)paren
suffix:semicolon
r_static
r_void
id|falcon_get_lock
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ATARI_SCSI_RESET_BOOT
r_static
r_void
id|atari_scsi_reset_boot
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
r_char
id|atari_scsi_tt_reg_read
c_func
(paren
r_int
r_char
id|reg
)paren
suffix:semicolon
r_static
r_void
id|atari_scsi_tt_reg_write
c_func
(paren
r_int
r_char
id|reg
comma
r_int
r_char
id|value
)paren
suffix:semicolon
r_static
r_int
r_char
id|atari_scsi_falcon_reg_read
c_func
(paren
r_int
r_char
id|reg
)paren
suffix:semicolon
r_static
r_void
id|atari_scsi_falcon_reg_write
c_func
(paren
r_int
r_char
id|reg
comma
r_int
r_char
id|value
)paren
suffix:semicolon
multiline_comment|/************************* End of Prototypes **************************/
DECL|variable|atari_scsi_host
r_static
r_struct
id|Scsi_Host
op_star
id|atari_scsi_host
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|atari_scsi_reg_read
r_static
r_int
r_char
(paren
op_star
id|atari_scsi_reg_read
)paren
(paren
r_int
r_char
id|reg
)paren
suffix:semicolon
DECL|variable|atari_scsi_reg_write
r_static
r_void
(paren
op_star
id|atari_scsi_reg_write
)paren
(paren
r_int
r_char
id|reg
comma
r_int
r_char
id|value
)paren
suffix:semicolon
macro_line|#ifdef REAL_DMA
DECL|variable|atari_dma_residual
DECL|variable|atari_dma_startaddr
r_static
r_int
r_int
id|atari_dma_residual
comma
id|atari_dma_startaddr
suffix:semicolon
DECL|variable|atari_dma_active
r_static
r_int
id|atari_dma_active
suffix:semicolon
multiline_comment|/* pointer to the dribble buffer */
DECL|variable|atari_dma_buffer
r_static
r_char
op_star
id|atari_dma_buffer
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* precalculated physical address of the dribble buffer */
DECL|variable|atari_dma_phys_buffer
r_static
r_int
r_int
id|atari_dma_phys_buffer
suffix:semicolon
multiline_comment|/* != 0 tells the Falcon int handler to copy data from the dribble buffer */
DECL|variable|atari_dma_orig_addr
r_static
r_char
op_star
id|atari_dma_orig_addr
suffix:semicolon
multiline_comment|/* size of the dribble buffer; 4k seems enough, since the Falcon cannot use&n; * scatter-gather anyway, so most transfers are 1024 byte only. In the rare&n; * cases where requests to physical contiguous buffers have been merged, this&n; * request is &lt;= 4k (one page). So I don&squot;t think we have to split transfers&n; * just due to this buffer size...&n; */
DECL|macro|STRAM_BUFFER_SIZE
mdefine_line|#define&t;STRAM_BUFFER_SIZE&t;(4096)
multiline_comment|/* mask for address bits that can&squot;t be used with the ST-DMA */
DECL|variable|atari_dma_stram_mask
r_static
r_int
r_int
id|atari_dma_stram_mask
suffix:semicolon
DECL|macro|STRAM_ADDR
mdefine_line|#define STRAM_ADDR(a)&t;(((a) &amp; atari_dma_stram_mask) == 0)
multiline_comment|/* number of bytes to cut from a transfer to handle NCR overruns */
DECL|variable|atari_read_overruns
r_static
r_int
id|atari_read_overruns
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|variable|setup_can_queue
r_static
r_int
id|setup_can_queue
op_assign
op_minus
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|setup_can_queue
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|variable|setup_cmd_per_lun
r_static
r_int
id|setup_cmd_per_lun
op_assign
op_minus
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|setup_cmd_per_lun
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|variable|setup_sg_tablesize
r_static
r_int
id|setup_sg_tablesize
op_assign
op_minus
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|setup_sg_tablesize
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#ifdef SUPPORT_TAGS
DECL|variable|setup_use_tagged_queuing
r_static
r_int
id|setup_use_tagged_queuing
op_assign
op_minus
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|setup_use_tagged_queuing
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|setup_hostid
r_static
r_int
id|setup_hostid
op_assign
op_minus
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|setup_hostid
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_TT_DMA_EMUL)
macro_line|#include &quot;atari_dma_emul.c&quot;
macro_line|#endif
macro_line|#if defined(REAL_DMA)
DECL|function|scsi_dma_is_ignored_buserr
r_static
r_int
id|scsi_dma_is_ignored_buserr
c_func
(paren
r_int
r_char
id|dma_stat
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|addr
op_assign
id|SCSI_DMA_READ_P
c_func
(paren
id|dma_addr
)paren
comma
id|end_addr
suffix:semicolon
r_if
c_cond
(paren
id|dma_stat
op_amp
l_int|0x01
)paren
(brace
multiline_comment|/* A bus error happens when DMA-ing from the last page of a&n;&t;&t; * physical memory chunk (DMA prefetch!), but that doesn&squot;t hurt.&n;&t;&t; * Check for this case:&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|m68k_num_memory
suffix:semicolon
op_increment
id|i
)paren
(brace
id|end_addr
op_assign
id|m68k_memory
(braket
id|i
)braket
dot
id|addr
op_plus
id|m68k_memory
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end_addr
op_le
id|addr
op_logical_and
id|addr
op_le
id|end_addr
op_plus
l_int|4
)paren
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* Dead code... wasn&squot;t called anyway :-) and causes some trouble, because at&n; * end-of-DMA, both SCSI ints are triggered simultaneously, so the NCR int has&n; * to clear the DMA int pending bit before it allows other level 6 interrupts.&n; */
r_static
r_void
id|scsi_dma_buserr
(paren
r_int
id|irq
comma
r_void
op_star
id|dummy
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_int
r_char
id|dma_stat
op_assign
id|tt_scsi_dma.dma_ctrl
suffix:semicolon
multiline_comment|/* Don&squot;t do anything if a NCR interrupt is pending. Probably it&squot;s just&n;&t; * masked... */
r_if
c_cond
(paren
id|atari_irq_pending
c_func
(paren
id|IRQ_TT_MFP_SCSI
)paren
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Bad SCSI DMA interrupt! dma_addr=0x%08lx dma_stat=%02x dma_cnt=%08lx&bslash;n&quot;
comma
id|SCSI_DMA_READ_P
c_func
(paren
id|dma_addr
)paren
comma
id|dma_stat
comma
id|SCSI_DMA_READ_P
c_func
(paren
id|dma_cnt
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_stat
op_amp
l_int|0x80
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|scsi_dma_is_ignored_buserr
c_func
(paren
id|dma_stat
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;SCSI DMA bus error -- bad DMA programming!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Under normal circumstances we never should get to this point,&n;&t;&t; * since both interrupts are triggered simultaneously and the 5380&n;&t;&t; * int has higher priority. When this irq is handled, that DMA&n;&t;&t; * interrupt is cleared. So a warning message is printed here.&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;SCSI DMA intr ?? -- this shouldn&squot;t happen!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#endif
DECL|function|scsi_tt_intr
r_static
r_void
id|scsi_tt_intr
(paren
r_int
id|irq
comma
r_void
op_star
id|dummy
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
macro_line|#ifdef REAL_DMA
r_int
id|dma_stat
suffix:semicolon
id|dma_stat
op_assign
id|tt_scsi_dma.dma_ctrl
suffix:semicolon
id|INT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: NCR5380 interrupt, DMA status = %02x&bslash;n&quot;
comma
id|atari_scsi_host-&gt;host_no
comma
id|dma_stat
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* Look if it was the DMA that has interrupted: First possibility&n;&t; * is that a bus error occurred...&n;&t; */
r_if
c_cond
(paren
id|dma_stat
op_amp
l_int|0x80
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|scsi_dma_is_ignored_buserr
c_func
(paren
id|dma_stat
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SCSI DMA caused bus error near 0x%08lx&bslash;n&quot;
comma
id|SCSI_DMA_READ_P
c_func
(paren
id|dma_addr
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;SCSI DMA bus error -- bad DMA programming!&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* If the DMA is active but not finished, we have the case&n;&t; * that some other 5380 interrupt occurred within the DMA transfer.&n;&t; * This means we have residual bytes, if the desired end address&n;&t; * is not yet reached. Maybe we have to fetch some bytes from the&n;&t; * rest data register, too. The residual must be calculated from&n;&t; * the address pointer, not the counter register, because only the&n;&t; * addr reg counts bytes not yet written and pending in the rest&n;&t; * data reg!&n;&t; */
r_if
c_cond
(paren
(paren
id|dma_stat
op_amp
l_int|0x02
)paren
op_logical_and
op_logical_neg
(paren
id|dma_stat
op_amp
l_int|0x40
)paren
)paren
(brace
id|atari_dma_residual
op_assign
id|HOSTDATA_DMALEN
op_minus
(paren
id|SCSI_DMA_READ_P
c_func
(paren
id|dma_addr
)paren
op_minus
id|atari_dma_startaddr
)paren
suffix:semicolon
id|DMA_PRINTK
c_func
(paren
l_string|&quot;SCSI DMA: There are %ld residual bytes.&bslash;n&quot;
comma
id|atari_dma_residual
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|atari_dma_residual
OL
l_int|0
)paren
id|atari_dma_residual
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dma_stat
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* After read operations, we maybe have to&n;&t;&t;&t;   transport some rest bytes */
id|atari_scsi_fetch_restbytes
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* There seems to be a nasty bug in some SCSI-DMA/NCR&n;&t;&t;&t;   combinations: If a target disconnects while a write&n;&t;&t;&t;   operation is going on, the address register of the&n;&t;&t;&t;   DMA may be a few bytes farer than it actually read.&n;&t;&t;&t;   This is probably due to DMA prefetching and a delay&n;&t;&t;&t;   between DMA and NCR.  Experiments showed that the&n;&t;&t;&t;   dma_addr is 9 bytes to high, but this could vary.&n;&t;&t;&t;   The problem is, that the residual is thus calculated&n;&t;&t;&t;   wrong and the next transfer will start behind where&n;&t;&t;&t;   it should.  So we round up the residual to the next&n;&t;&t;&t;   multiple of a sector size, if it isn&squot;t already a&n;&t;&t;&t;   multiple and the originally expected transfer size&n;&t;&t;&t;   was.  The latter condition is there to ensure that&n;&t;&t;&t;   the correction is taken only for &quot;real&quot; data&n;&t;&t;&t;   transfers and not for, e.g., the parameters of some&n;&t;&t;&t;   other command.  These shouldn&squot;t disconnect anyway.&n;&t;&t;&t;   */
r_if
c_cond
(paren
id|atari_dma_residual
op_amp
l_int|0x1ff
)paren
(brace
id|DMA_PRINTK
c_func
(paren
l_string|&quot;SCSI DMA: DMA bug corrected, &quot;
l_string|&quot;difference %ld bytes&bslash;n&quot;
comma
l_int|512
op_minus
(paren
id|atari_dma_residual
op_amp
l_int|0x1ff
)paren
)paren
suffix:semicolon
id|atari_dma_residual
op_assign
(paren
id|atari_dma_residual
op_plus
l_int|511
)paren
op_amp
op_complement
l_int|0x1ff
suffix:semicolon
)brace
)brace
id|tt_scsi_dma.dma_ctrl
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If the DMA is finished, fetch the rest bytes and turn it off */
r_if
c_cond
(paren
id|dma_stat
op_amp
l_int|0x40
)paren
(brace
id|atari_dma_residual
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dma_stat
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
id|atari_scsi_fetch_restbytes
c_func
(paren
)paren
suffix:semicolon
id|tt_scsi_dma.dma_ctrl
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* REAL_DMA */
id|NCR5380_intr
(paren
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* To be sure the int is not masked */
id|atari_enable_irq
c_func
(paren
id|IRQ_TT_MFP_SCSI
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|scsi_falcon_intr
r_static
r_void
id|scsi_falcon_intr
(paren
r_int
id|irq
comma
r_void
op_star
id|dummy
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
macro_line|#ifdef REAL_DMA
r_int
id|dma_stat
suffix:semicolon
multiline_comment|/* Turn off DMA and select sector counter register before&n;&t; * accessing the status register (Atari recommendation!)&n;&t; */
id|st_dma.dma_mode_status
op_assign
l_int|0x90
suffix:semicolon
id|dma_stat
op_assign
id|st_dma.dma_mode_status
suffix:semicolon
multiline_comment|/* Bit 0 indicates some error in the DMA process... don&squot;t know&n;&t; * what happened exactly (no further docu).&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dma_stat
op_amp
l_int|0x01
)paren
)paren
(brace
multiline_comment|/* DMA error */
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;SCSI DMA error near 0x%08lx!&bslash;n&quot;
comma
id|SCSI_DMA_GETADR
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* If the DMA was active, but now bit 1 is not clear, it is some&n;&t; * other 5380 interrupt that finishes the DMA transfer. We have to&n;&t; * calculate the number of residual bytes and give a warning if&n;&t; * bytes are stuck in the ST-DMA fifo (there&squot;s no way to reach them!)&n;&t; */
r_if
c_cond
(paren
id|atari_dma_active
op_logical_and
(paren
id|dma_stat
op_amp
l_int|0x02
)paren
)paren
(brace
r_int
r_int
id|transferred
suffix:semicolon
id|transferred
op_assign
id|SCSI_DMA_GETADR
c_func
(paren
)paren
op_minus
id|atari_dma_startaddr
suffix:semicolon
multiline_comment|/* The ST-DMA address is incremented in 2-byte steps, but the&n;&t;&t; * data are written only in 16-byte chunks. If the number of&n;&t;&t; * transferred bytes is not divisible by 16, the remainder is&n;&t;&t; * lost somewhere in outer space.&n;&t;&t; */
r_if
c_cond
(paren
id|transferred
op_amp
l_int|15
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SCSI DMA error: %ld bytes lost in &quot;
l_string|&quot;ST-DMA fifo&bslash;n&quot;
comma
id|transferred
op_amp
l_int|15
)paren
suffix:semicolon
id|atari_dma_residual
op_assign
id|HOSTDATA_DMALEN
op_minus
id|transferred
suffix:semicolon
id|DMA_PRINTK
c_func
(paren
l_string|&quot;SCSI DMA: There are %ld residual bytes.&bslash;n&quot;
comma
id|atari_dma_residual
)paren
suffix:semicolon
)brace
r_else
id|atari_dma_residual
op_assign
l_int|0
suffix:semicolon
id|atari_dma_active
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|atari_dma_orig_addr
)paren
(brace
multiline_comment|/* If the dribble buffer was used on a read operation, copy the DMA-ed&n;&t;&t; * data to the original destination address.&n;&t;&t; */
id|memcpy
c_func
(paren
id|atari_dma_orig_addr
comma
id|phys_to_virt
c_func
(paren
id|atari_dma_startaddr
)paren
comma
id|HOSTDATA_DMALEN
op_minus
id|atari_dma_residual
)paren
suffix:semicolon
id|atari_dma_orig_addr
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif /* REAL_DMA */
id|NCR5380_intr
(paren
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef REAL_DMA
DECL|function|atari_scsi_fetch_restbytes
r_static
r_void
id|atari_scsi_fetch_restbytes
c_func
(paren
r_void
)paren
(brace
r_int
id|nr
suffix:semicolon
r_char
op_star
id|src
comma
op_star
id|dst
suffix:semicolon
r_int
r_int
id|phys_dst
suffix:semicolon
multiline_comment|/* fetch rest bytes in the DMA register */
id|phys_dst
op_assign
id|SCSI_DMA_READ_P
c_func
(paren
id|dma_addr
)paren
suffix:semicolon
id|nr
op_assign
id|phys_dst
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|nr
)paren
(brace
multiline_comment|/* there are &squot;nr&squot; bytes left for the last long address&n;&t;&t;   before the DMA pointer */
id|phys_dst
op_xor_assign
id|nr
suffix:semicolon
id|DMA_PRINTK
c_func
(paren
l_string|&quot;SCSI DMA: there are %d rest bytes for phys addr 0x%08lx&quot;
comma
id|nr
comma
id|phys_dst
)paren
suffix:semicolon
multiline_comment|/* The content of the DMA pointer is a physical address!  */
id|dst
op_assign
id|phys_to_virt
c_func
(paren
id|phys_dst
)paren
suffix:semicolon
id|DMA_PRINTK
c_func
(paren
l_string|&quot; = virt addr %p&bslash;n&quot;
comma
id|dst
)paren
suffix:semicolon
r_for
c_loop
(paren
id|src
op_assign
(paren
r_char
op_star
)paren
op_amp
id|tt_scsi_dma.dma_restdata
suffix:semicolon
id|nr
op_ne
l_int|0
suffix:semicolon
op_decrement
id|nr
)paren
op_star
id|dst
op_increment
op_assign
op_star
id|src
op_increment
suffix:semicolon
)brace
)brace
macro_line|#endif /* REAL_DMA */
DECL|variable|falcon_got_lock
r_static
r_int
id|falcon_got_lock
op_assign
l_int|0
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|falcon_fairness_wait
)paren
suffix:semicolon
DECL|variable|falcon_trying_lock
r_static
r_int
id|falcon_trying_lock
op_assign
l_int|0
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|falcon_try_wait
)paren
suffix:semicolon
DECL|variable|falcon_dont_release
r_static
r_int
id|falcon_dont_release
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This function releases the lock on the DMA chip if there is no&n; * connected command and the disconnected queue is empty. On&n; * releasing, instances of falcon_get_lock are awoken, that put&n; * themselves to sleep for fairness. They can now try to get the lock&n; * again (but others waiting longer more probably will win).&n; */
r_static
r_void
DECL|function|falcon_release_lock_if_possible
id|falcon_release_lock_if_possible
c_func
(paren
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
)paren
(brace
r_int
r_int
id|oldflags
suffix:semicolon
r_if
c_cond
(paren
id|IS_A_TT
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|falcon_got_lock
op_logical_and
op_logical_neg
id|hostdata-&gt;disconnected_queue
op_logical_and
op_logical_neg
id|hostdata-&gt;issue_queue
op_logical_and
op_logical_neg
id|hostdata-&gt;connected
)paren
(brace
r_if
c_cond
(paren
id|falcon_dont_release
)paren
(brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;WARNING: Lock release not allowed. Ignored&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|falcon_got_lock
op_assign
l_int|0
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|falcon_fairness_wait
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
)brace
multiline_comment|/* This function manages the locking of the ST-DMA.&n; * If the DMA isn&squot;t locked already for SCSI, it tries to lock it by&n; * calling stdma_lock(). But if the DMA is locked by the SCSI code and&n; * there are other drivers waiting for the chip, we do not issue the&n; * command immediately but wait on &squot;falcon_fairness_queue&squot;. We will be&n; * waked up when the DMA is unlocked by some SCSI interrupt. After that&n; * we try to get the lock again.&n; * But we must be prepared that more than one instance of&n; * falcon_get_lock() is waiting on the fairness queue. They should not&n; * try all at once to call stdma_lock(), one is enough! For that, the&n; * first one sets &squot;falcon_trying_lock&squot;, others that see that variable&n; * set wait on the queue &squot;falcon_try_wait&squot;.&n; * Complicated, complicated.... Sigh...&n; */
DECL|function|falcon_get_lock
r_static
r_void
id|falcon_get_lock
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|oldflags
suffix:semicolon
r_if
c_cond
(paren
id|IS_A_TT
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|in_interrupt
c_func
(paren
)paren
op_logical_and
id|falcon_got_lock
op_logical_and
id|stdma_others_waiting
c_func
(paren
)paren
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|falcon_fairness_wait
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|falcon_got_lock
)paren
(brace
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Falcon SCSI hasn&squot;t ST-DMA lock in interrupt&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|falcon_trying_lock
)paren
(brace
id|falcon_trying_lock
op_assign
l_int|1
suffix:semicolon
id|stdma_lock
c_func
(paren
id|scsi_falcon_intr
comma
l_int|NULL
)paren
suffix:semicolon
id|falcon_got_lock
op_assign
l_int|1
suffix:semicolon
id|falcon_trying_lock
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|falcon_try_wait
)paren
suffix:semicolon
)brace
r_else
(brace
id|sleep_on
c_func
(paren
op_amp
id|falcon_try_wait
)paren
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|oldflags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|falcon_got_lock
)paren
id|panic
c_func
(paren
l_string|&quot;Falcon SCSI: someone stole the lock :-(&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* This is the wrapper function for NCR5380_queue_command(). It just&n; * tries to get the lock on the ST-DMA (see above) and then calls the&n; * original function.&n; */
macro_line|#if 0
r_int
id|atari_queue_command
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
multiline_comment|/* falcon_get_lock();&n;&t; * ++guenther: moved to NCR5380_queue_command() to prevent&n;&t; * race condition, see there for an explanation.&n;&t; */
r_return
id|NCR5380_queue_command
c_func
(paren
id|cmd
comma
id|done
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|atari_scsi_detect
r_int
id|atari_scsi_detect
(paren
id|Scsi_Host_Template
op_star
id|host
)paren
(brace
r_static
r_int
id|called
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MACH_IS_ATARI
op_logical_or
(paren
op_logical_neg
id|ATARIHW_PRESENT
c_func
(paren
id|ST_SCSI
)paren
op_logical_and
op_logical_neg
id|ATARIHW_PRESENT
c_func
(paren
id|TT_SCSI
)paren
)paren
op_logical_or
id|called
)paren
r_return
l_int|0
suffix:semicolon
id|host-&gt;proc_name
op_assign
l_string|&quot;Atari&quot;
suffix:semicolon
id|atari_scsi_reg_read
op_assign
id|IS_A_TT
c_func
(paren
)paren
ques
c_cond
id|atari_scsi_tt_reg_read
suffix:colon
id|atari_scsi_falcon_reg_read
suffix:semicolon
id|atari_scsi_reg_write
op_assign
id|IS_A_TT
c_func
(paren
)paren
ques
c_cond
id|atari_scsi_tt_reg_write
suffix:colon
id|atari_scsi_falcon_reg_write
suffix:semicolon
multiline_comment|/* setup variables */
id|host-&gt;can_queue
op_assign
(paren
id|setup_can_queue
OG
l_int|0
)paren
ques
c_cond
id|setup_can_queue
suffix:colon
id|IS_A_TT
c_func
(paren
)paren
ques
c_cond
id|ATARI_TT_CAN_QUEUE
suffix:colon
id|ATARI_FALCON_CAN_QUEUE
suffix:semicolon
id|host-&gt;cmd_per_lun
op_assign
(paren
id|setup_cmd_per_lun
OG
l_int|0
)paren
ques
c_cond
id|setup_cmd_per_lun
suffix:colon
id|IS_A_TT
c_func
(paren
)paren
ques
c_cond
id|ATARI_TT_CMD_PER_LUN
suffix:colon
id|ATARI_FALCON_CMD_PER_LUN
suffix:semicolon
multiline_comment|/* Force sg_tablesize to 0 on a Falcon! */
id|host-&gt;sg_tablesize
op_assign
op_logical_neg
id|IS_A_TT
c_func
(paren
)paren
ques
c_cond
id|ATARI_FALCON_SG_TABLESIZE
suffix:colon
(paren
id|setup_sg_tablesize
op_ge
l_int|0
)paren
ques
c_cond
id|setup_sg_tablesize
suffix:colon
id|ATARI_TT_SG_TABLESIZE
suffix:semicolon
r_if
c_cond
(paren
id|setup_hostid
op_ge
l_int|0
)paren
id|host-&gt;this_id
op_assign
id|setup_hostid
suffix:semicolon
r_else
(brace
multiline_comment|/* use 7 as default */
id|host-&gt;this_id
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* Test if a host id is set in the NVRam */
r_if
c_cond
(paren
id|ATARIHW_PRESENT
c_func
(paren
id|TT_CLK
)paren
op_logical_and
id|nvram_check_checksum
c_func
(paren
)paren
)paren
(brace
r_int
r_char
id|b
op_assign
id|nvram_read_byte
c_func
(paren
l_int|14
)paren
suffix:semicolon
multiline_comment|/* Arbitration enabled? (for TOS) If yes, use configured host ID */
r_if
c_cond
(paren
id|b
op_amp
l_int|0x80
)paren
id|host-&gt;this_id
op_assign
id|b
op_amp
l_int|7
suffix:semicolon
)brace
)brace
macro_line|#ifdef SUPPORT_TAGS
r_if
c_cond
(paren
id|setup_use_tagged_queuing
OL
l_int|0
)paren
id|setup_use_tagged_queuing
op_assign
id|DEFAULT_USE_TAGGED_QUEUING
suffix:semicolon
macro_line|#endif
macro_line|#ifdef REAL_DMA
multiline_comment|/* If running on a Falcon and if there&squot;s TT-Ram (i.e., more than one&n;&t; * memory block, since there&squot;s always ST-Ram in a Falcon), then allocate a&n;&t; * STRAM_BUFFER_SIZE byte dribble buffer for transfers from/to alternative&n;&t; * Ram.&n;&t; */
r_if
c_cond
(paren
id|MACH_IS_ATARI
op_logical_and
id|ATARIHW_PRESENT
c_func
(paren
id|ST_SCSI
)paren
op_logical_and
op_logical_neg
id|ATARIHW_PRESENT
c_func
(paren
id|EXTD_DMA
)paren
op_logical_and
id|m68k_num_memory
OG
l_int|1
)paren
(brace
id|atari_dma_buffer
op_assign
id|atari_stram_alloc
c_func
(paren
id|STRAM_BUFFER_SIZE
comma
l_string|&quot;SCSI&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atari_dma_buffer
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;atari_scsi_detect: can&squot;t allocate ST-RAM &quot;
l_string|&quot;double buffer&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|atari_dma_phys_buffer
op_assign
id|virt_to_phys
c_func
(paren
id|atari_dma_buffer
)paren
suffix:semicolon
id|atari_dma_orig_addr
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
id|instance
op_assign
id|scsi_register
(paren
id|host
comma
r_sizeof
(paren
r_struct
id|NCR5380_hostdata
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|instance
op_eq
l_int|NULL
)paren
(brace
id|atari_stram_free
c_func
(paren
id|atari_dma_buffer
)paren
suffix:semicolon
id|atari_dma_buffer
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|atari_scsi_host
op_assign
id|instance
suffix:semicolon
multiline_comment|/* Set irq to 0, to avoid that the mid-level code disables our interrupt&n;        * during queue_command calls. This is completely unnecessary, and even&n;        * worse causes bad problems on the Falcon, where the int is shared with&n;        * IDE and floppy! */
id|instance-&gt;irq
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_ATARI_SCSI_RESET_BOOT
id|atari_scsi_reset_boot
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_init
(paren
id|instance
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_A_TT
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* This int is actually &quot;pseudo-slow&quot;, i.e. it acts like a slow&n;&t;&t; * interrupt after having cleared the pending flag for the DMA&n;&t;&t; * interrupt. */
id|request_irq
c_func
(paren
id|IRQ_TT_MFP_SCSI
comma
id|scsi_tt_intr
comma
id|IRQ_TYPE_SLOW
comma
l_string|&quot;SCSI NCR5380&quot;
comma
id|scsi_tt_intr
)paren
suffix:semicolon
id|tt_mfp.active_edge
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* SCSI int on L-&gt;H */
macro_line|#ifdef REAL_DMA
id|tt_scsi_dma.dma_ctrl
op_assign
l_int|0
suffix:semicolon
id|atari_dma_residual
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* REAL_DMA */
macro_line|#ifdef REAL_DMA
macro_line|#ifdef CONFIG_TT_DMA_EMUL
r_if
c_cond
(paren
id|MACH_IS_HADES
)paren
(brace
id|request_irq
c_func
(paren
id|IRQ_AUTO_2
comma
id|hades_dma_emulator
comma
id|IRQ_TYPE_PRIO
comma
l_string|&quot;Hades DMA emulator&quot;
comma
id|hades_dma_emulator
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|MACH_IS_MEDUSA
op_logical_or
id|MACH_IS_HADES
)paren
(brace
multiline_comment|/* While the read overruns (described by Drew Eckhardt in&n;&t;&t;&t; * NCR5380.c) never happened on TTs, they do in fact on the Medusa&n;&t;&t;&t; * (This was the cause why SCSI didn&squot;t work right for so long&n;&t;&t;&t; * there.) Since handling the overruns slows down a bit, I turned&n;&t;&t;&t; * the #ifdef&squot;s into a runtime condition.&n;&t;&t;&t; *&n;&t;&t;&t; * In principle it should be sufficient to do max. 1 byte with&n;&t;&t;&t; * PIO, but there is another problem on the Medusa with the DMA&n;&t;&t;&t; * rest data register. So &squot;atari_read_overruns&squot; is currently set&n;&t;&t;&t; * to 4 to avoid having transfers that aren&squot;t a multiple of 4. If&n;&t;&t;&t; * the rest data bug is fixed, this can be lowered to 1.&n;&t;&t;&t; */
id|atari_read_overruns
op_assign
l_int|4
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* ! IS_A_TT */
multiline_comment|/* Nothing to do for the interrupt: the ST-DMA is initialized&n;&t;&t; * already by atari_init_INTS()&n;&t;&t; */
macro_line|#ifdef REAL_DMA
id|atari_dma_residual
op_assign
l_int|0
suffix:semicolon
id|atari_dma_active
op_assign
l_int|0
suffix:semicolon
id|atari_dma_stram_mask
op_assign
(paren
id|ATARIHW_PRESENT
c_func
(paren
id|EXTD_DMA
)paren
ques
c_cond
l_int|0x00000000
suffix:colon
l_int|0xff000000
)paren
suffix:semicolon
macro_line|#endif
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi%d: options CAN_QUEUE=%d CMD_PER_LUN=%d SCAT-GAT=%d &quot;
macro_line|#ifdef SUPPORT_TAGS
l_string|&quot;TAGGED-QUEUING=%s &quot;
macro_line|#endif
l_string|&quot;HOSTID=%d&quot;
comma
id|instance-&gt;host_no
comma
id|instance-&gt;hostt-&gt;can_queue
comma
id|instance-&gt;hostt-&gt;cmd_per_lun
comma
id|instance-&gt;hostt-&gt;sg_tablesize
comma
macro_line|#ifdef SUPPORT_TAGS
id|setup_use_tagged_queuing
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
macro_line|#endif
id|instance-&gt;hostt-&gt;this_id
)paren
suffix:semicolon
id|NCR5380_print_options
(paren
id|instance
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|called
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|atari_scsi_release
r_int
id|atari_scsi_release
(paren
r_struct
id|Scsi_Host
op_star
id|sh
)paren
(brace
r_if
c_cond
(paren
id|IS_A_TT
c_func
(paren
)paren
)paren
id|free_irq
c_func
(paren
id|IRQ_TT_MFP_SCSI
comma
id|scsi_tt_intr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atari_dma_buffer
)paren
id|atari_stram_free
(paren
id|atari_dma_buffer
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
DECL|function|atari_scsi_setup
r_void
id|__init
id|atari_scsi_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
multiline_comment|/* Format of atascsi parameter is:&n;&t; *   atascsi=&lt;can_queue&gt;,&lt;cmd_per_lun&gt;,&lt;sg_tablesize&gt;,&lt;hostid&gt;,&lt;use_tags&gt;&n;&t; * Defaults depend on TT or Falcon, hostid determined at run time.&n;&t; * Negative values mean don&squot;t change.&n;&t; */
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OL
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;atari_scsi_setup: no arguments!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|1
)braket
OG
l_int|0
)paren
multiline_comment|/* no limits on this, just &gt; 0 */
id|setup_can_queue
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|2
)braket
OG
l_int|0
)paren
id|setup_cmd_per_lun
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|3
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|3
)braket
op_ge
l_int|0
)paren
(brace
id|setup_sg_tablesize
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Must be &lt;= SG_ALL (255) */
r_if
c_cond
(paren
id|setup_sg_tablesize
OG
id|SG_ALL
)paren
id|setup_sg_tablesize
op_assign
id|SG_ALL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|4
)paren
(brace
multiline_comment|/* Must be between 0 and 7 */
r_if
c_cond
(paren
id|ints
(braket
l_int|4
)braket
op_ge
l_int|0
op_logical_and
id|ints
(braket
l_int|4
)braket
op_le
l_int|7
)paren
id|setup_hostid
op_assign
id|ints
(braket
l_int|4
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ints
(braket
l_int|4
)braket
OG
l_int|7
)paren
id|printk
c_func
(paren
l_string|&quot;atari_scsi_setup: invalid host ID %d !&bslash;n&quot;
comma
id|ints
(braket
l_int|4
)braket
)paren
suffix:semicolon
)brace
macro_line|#ifdef SUPPORT_TAGS
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|5
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|5
)braket
op_ge
l_int|0
)paren
id|setup_use_tagged_queuing
op_assign
op_logical_neg
op_logical_neg
id|ints
(braket
l_int|5
)braket
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|function|atari_scsi_reset
r_int
id|atari_scsi_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_int
id|reset_flags
)paren
(brace
r_int
id|rv
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
multiline_comment|/* For doing the reset, SCSI interrupts must be disabled first,&n;&t; * since the 5380 raises its IRQ line while _RST is active and we&n;&t; * can&squot;t disable interrupts completely, since we need the timer.&n;&t; */
multiline_comment|/* And abort a maybe active DMA transfer */
r_if
c_cond
(paren
id|IS_A_TT
c_func
(paren
)paren
)paren
(brace
id|atari_turnoff_irq
c_func
(paren
id|IRQ_TT_MFP_SCSI
)paren
suffix:semicolon
macro_line|#ifdef REAL_DMA
id|tt_scsi_dma.dma_ctrl
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* REAL_DMA */
)brace
r_else
(brace
id|atari_turnoff_irq
c_func
(paren
id|IRQ_MFP_FSCSI
)paren
suffix:semicolon
macro_line|#ifdef REAL_DMA
id|st_dma.dma_mode_status
op_assign
l_int|0x90
suffix:semicolon
id|atari_dma_active
op_assign
l_int|0
suffix:semicolon
id|atari_dma_orig_addr
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif /* REAL_DMA */
)brace
id|rv
op_assign
id|NCR5380_reset
c_func
(paren
id|cmd
comma
id|reset_flags
)paren
suffix:semicolon
multiline_comment|/* Re-enable ints */
r_if
c_cond
(paren
id|IS_A_TT
c_func
(paren
)paren
)paren
(brace
id|atari_turnon_irq
c_func
(paren
id|IRQ_TT_MFP_SCSI
)paren
suffix:semicolon
)brace
r_else
(brace
id|atari_turnon_irq
c_func
(paren
id|IRQ_MFP_FSCSI
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rv
op_amp
id|SCSI_RESET_ACTION
)paren
op_eq
id|SCSI_RESET_SUCCESS
)paren
id|falcon_release_lock_if_possible
c_func
(paren
id|hostdata
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_ATARI_SCSI_RESET_BOOT
DECL|function|atari_scsi_reset_boot
r_static
r_void
id|__init
id|atari_scsi_reset_boot
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|end
suffix:semicolon
multiline_comment|/*&n;&t; * Do a SCSI reset to clean up the bus during initialization. No messing&n;&t; * with the queues, interrupts, or locks necessary here.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;Atari SCSI: resetting the SCSI bus...&quot;
)paren
suffix:semicolon
multiline_comment|/* get in phase */
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
id|PHASE_SR_TO_TCR
c_func
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* assert RST */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_RST
)paren
suffix:semicolon
multiline_comment|/* The min. reset hold time is 25us, so 40us should be enough */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/* reset RST and interrupt */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
id|end
op_assign
id|jiffies
op_plus
id|AFTER_RESET_DELAY
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|end
)paren
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; done&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|atari_scsi_info
r_const
r_char
op_star
id|atari_scsi_info
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
multiline_comment|/* atari_scsi_detect() is verbose enough... */
r_static
r_const
r_char
id|string
(braket
)braket
op_assign
l_string|&quot;Atari native SCSI&quot;
suffix:semicolon
r_return
id|string
suffix:semicolon
)brace
macro_line|#if defined(REAL_DMA)
DECL|function|atari_scsi_dma_setup
r_int
r_int
id|atari_scsi_dma_setup
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_void
op_star
id|data
comma
r_int
r_int
id|count
comma
r_int
id|dir
)paren
(brace
r_int
r_int
id|addr
op_assign
id|virt_to_phys
c_func
(paren
id|data
)paren
suffix:semicolon
id|DMA_PRINTK
c_func
(paren
l_string|&quot;scsi%d: setting up dma, data = %p, phys = %lx, count = %ld, &quot;
l_string|&quot;dir = %d&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|data
comma
id|addr
comma
id|count
comma
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_A_TT
c_func
(paren
)paren
op_logical_and
op_logical_neg
id|STRAM_ADDR
c_func
(paren
id|addr
)paren
)paren
(brace
multiline_comment|/* If we have a non-DMAable address on a Falcon, use the dribble&n;&t;&t; * buffer; &squot;orig_addr&squot; != 0 in the read case tells the interrupt&n;&t;&t; * handler to copy data from the dribble buffer to the originally&n;&t;&t; * wanted address.&n;&t;&t; */
r_if
c_cond
(paren
id|dir
)paren
id|memcpy
c_func
(paren
id|atari_dma_buffer
comma
id|data
comma
id|count
)paren
suffix:semicolon
r_else
id|atari_dma_orig_addr
op_assign
id|data
suffix:semicolon
id|addr
op_assign
id|atari_dma_phys_buffer
suffix:semicolon
)brace
id|atari_dma_startaddr
op_assign
id|addr
suffix:semicolon
multiline_comment|/* Needed for calculating residual later. */
multiline_comment|/* Cache cleanup stuff: On writes, push any dirty cache out before sending&n;&t; * it to the peripheral. (Must be done before DMA setup, since at least&n;&t; * the ST-DMA begins to fill internal buffers right after setup. For&n;&t; * reads, invalidate any cache, may be altered after DMA without CPU&n;&t; * knowledge.&n;&t; * &n;&t; * ++roman: For the Medusa, there&squot;s no need at all for that cache stuff,&n;&t; * because the hardware does bus snooping (fine!).&n;&t; */
id|dma_cache_maintenance
c_func
(paren
id|addr
comma
id|count
comma
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;SCSI warning: DMA programmed for 0 bytes !&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_A_TT
c_func
(paren
)paren
)paren
(brace
id|tt_scsi_dma.dma_ctrl
op_assign
id|dir
suffix:semicolon
id|SCSI_DMA_WRITE_P
c_func
(paren
id|dma_addr
comma
id|addr
)paren
suffix:semicolon
id|SCSI_DMA_WRITE_P
c_func
(paren
id|dma_cnt
comma
id|count
)paren
suffix:semicolon
id|tt_scsi_dma.dma_ctrl
op_assign
id|dir
op_or
l_int|2
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ! IS_A_TT */
multiline_comment|/* set address */
id|SCSI_DMA_SETADR
c_func
(paren
id|addr
)paren
suffix:semicolon
multiline_comment|/* toggle direction bit to clear FIFO and set DMA direction */
id|dir
op_lshift_assign
l_int|8
suffix:semicolon
id|st_dma.dma_mode_status
op_assign
l_int|0x90
op_or
id|dir
suffix:semicolon
id|st_dma.dma_mode_status
op_assign
l_int|0x90
op_or
(paren
id|dir
op_xor
l_int|0x100
)paren
suffix:semicolon
id|st_dma.dma_mode_status
op_assign
l_int|0x90
op_or
id|dir
suffix:semicolon
id|udelay
c_func
(paren
l_int|40
)paren
suffix:semicolon
multiline_comment|/* On writes, round up the transfer length to the next multiple of 512&n;&t;&t; * (see also comment at atari_dma_xfer_len()). */
id|st_dma.fdc_acces_seccount
op_assign
(paren
id|count
op_plus
(paren
id|dir
ques
c_cond
l_int|511
suffix:colon
l_int|0
)paren
)paren
op_rshift
l_int|9
suffix:semicolon
id|udelay
c_func
(paren
l_int|40
)paren
suffix:semicolon
id|st_dma.dma_mode_status
op_assign
l_int|0x10
op_or
id|dir
suffix:semicolon
id|udelay
c_func
(paren
l_int|40
)paren
suffix:semicolon
multiline_comment|/* need not restore value of dir, only boolean value is tested */
id|atari_dma_active
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|atari_scsi_dma_residual
r_static
r_int
id|atari_scsi_dma_residual
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
r_return
id|atari_dma_residual
suffix:semicolon
)brace
DECL|macro|CMD_SURELY_BLOCK_MODE
mdefine_line|#define&t;CMD_SURELY_BLOCK_MODE&t;0
DECL|macro|CMD_SURELY_BYTE_MODE
mdefine_line|#define&t;CMD_SURELY_BYTE_MODE&t;1
DECL|macro|CMD_MODE_UNKNOWN
mdefine_line|#define&t;CMD_MODE_UNKNOWN&t;&t;2
DECL|function|falcon_classify_cmd
r_static
r_int
id|falcon_classify_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
r_char
id|opcode
op_assign
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|opcode
op_eq
id|READ_DEFECT_DATA
op_logical_or
id|opcode
op_eq
id|READ_LONG
op_logical_or
id|opcode
op_eq
id|READ_BUFFER
)paren
r_return
id|CMD_SURELY_BYTE_MODE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|opcode
op_eq
id|READ_6
op_logical_or
id|opcode
op_eq
id|READ_10
op_logical_or
id|opcode
op_eq
l_int|0xa8
multiline_comment|/* READ_12 */
op_logical_or
id|opcode
op_eq
id|READ_REVERSE
op_logical_or
id|opcode
op_eq
id|RECOVER_BUFFERED_DATA
)paren
(brace
multiline_comment|/* In case of a sequential-access target (tape), special care is&n;&t;&t; * needed here: The transfer is block-mode only if the &squot;fixed&squot; bit is&n;&t;&t; * set! */
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;type
op_eq
id|TYPE_TAPE
op_logical_and
op_logical_neg
(paren
id|cmd-&gt;cmnd
(braket
l_int|1
)braket
op_amp
l_int|1
)paren
)paren
r_return
id|CMD_SURELY_BYTE_MODE
suffix:semicolon
r_else
r_return
id|CMD_SURELY_BLOCK_MODE
suffix:semicolon
)brace
r_else
r_return
id|CMD_MODE_UNKNOWN
suffix:semicolon
)brace
multiline_comment|/* This function calculates the number of bytes that can be transferred via&n; * DMA. On the TT, this is arbitrary, but on the Falcon we have to use the&n; * ST-DMA chip. There are only multiples of 512 bytes possible and max.&n; * 255*512 bytes :-( This means also, that defining READ_OVERRUNS is not&n; * possible on the Falcon, since that would require to program the DMA for&n; * n*512 - atari_read_overrun bytes. But it seems that the Falcon doesn&squot;t have&n; * the overrun problem, so this question is academic :-)&n; */
DECL|function|atari_dma_xfer_len
r_static
r_int
r_int
id|atari_dma_xfer_len
c_func
(paren
r_int
r_int
id|wanted_len
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|write_flag
)paren
(brace
r_int
r_int
id|possible_len
comma
id|limit
suffix:semicolon
macro_line|#ifndef CONFIG_TT_DMA_EMUL
r_if
c_cond
(paren
id|MACH_IS_HADES
)paren
multiline_comment|/* Hades has no SCSI DMA at all :-( Always force use of PIO */
r_return
l_int|0
suffix:semicolon
macro_line|#endif&t;
r_if
c_cond
(paren
id|IS_A_TT
c_func
(paren
)paren
)paren
multiline_comment|/* TT SCSI DMA can transfer arbitrary #bytes */
r_return
id|wanted_len
suffix:semicolon
multiline_comment|/* ST DMA chip is stupid -- only multiples of 512 bytes! (and max.&n;&t; * 255*512 bytes, but this should be enough)&n;&t; *&n;&t; * ++roman: Aaargl! Another Falcon-SCSI problem... There are some commands&n;&t; * that return a number of bytes which cannot be known beforehand. In this&n;&t; * case, the given transfer length is an &quot;allocation length&quot;. Now it&n;&t; * can happen that this allocation length is a multiple of 512 bytes and&n;&t; * the DMA is used. But if not n*512 bytes really arrive, some input data&n;&t; * will be lost in the ST-DMA&squot;s FIFO :-( Thus, we have to distinguish&n;&t; * between commands that do block transfers and those that do byte&n;&t; * transfers. But this isn&squot;t easy... there are lots of vendor specific&n;&t; * commands, and the user can issue any command via the&n;&t; * SCSI_IOCTL_SEND_COMMAND.&n;&t; *&n;&t; * The solution: We classify SCSI commands in 1) surely block-mode cmd.s,&n;&t; * 2) surely byte-mode cmd.s and 3) cmd.s with unknown mode. In case 1)&n;&t; * and 3), the thing to do is obvious: allow any number of blocks via DMA&n;&t; * or none. In case 2), we apply some heuristic: Byte mode is assumed if&n;&t; * the transfer (allocation) length is &lt; 1024, hoping that no cmd. not&n;&t; * explicitly known as byte mode have such big allocation lengths...&n;&t; * BTW, all the discussion above applies only to reads. DMA writes are&n;&t; * unproblematic anyways, since the targets aborts the transfer after&n;&t; * receiving a sufficient number of bytes.&n;&t; *&n;&t; * Another point: If the transfer is from/to an non-ST-RAM address, we&n;&t; * use the dribble buffer and thus can do only STRAM_BUFFER_SIZE bytes.&n;&t; */
r_if
c_cond
(paren
id|write_flag
)paren
(brace
multiline_comment|/* Write operation can always use the DMA, but the transfer size must&n;&t;&t; * be rounded up to the next multiple of 512 (atari_dma_setup() does&n;&t;&t; * this).&n;&t;&t; */
id|possible_len
op_assign
id|wanted_len
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Read operations: if the wanted transfer length is not a multiple of&n;&t;&t; * 512, we cannot use DMA, since the ST-DMA cannot split transfers&n;&t;&t; * (no interrupt on DMA finished!)&n;&t;&t; */
r_if
c_cond
(paren
id|wanted_len
op_amp
l_int|0x1ff
)paren
id|possible_len
op_assign
l_int|0
suffix:semicolon
r_else
(brace
multiline_comment|/* Now classify the command (see above) and decide whether it is&n;&t;&t;&t; * allowed to do DMA at all */
r_switch
c_cond
(paren
id|falcon_classify_cmd
c_func
(paren
id|cmd
)paren
)paren
(brace
r_case
id|CMD_SURELY_BLOCK_MODE
suffix:colon
id|possible_len
op_assign
id|wanted_len
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_SURELY_BYTE_MODE
suffix:colon
id|possible_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* DMA prohibited */
r_break
suffix:semicolon
r_case
id|CMD_MODE_UNKNOWN
suffix:colon
r_default
suffix:colon
multiline_comment|/* For unknown commands assume block transfers if the transfer&n;&t;&t;&t;&t; * size/allocation length is &gt;= 1024 */
id|possible_len
op_assign
(paren
id|wanted_len
OL
l_int|1024
)paren
ques
c_cond
l_int|0
suffix:colon
id|wanted_len
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Last step: apply the hard limit on DMA transfers */
id|limit
op_assign
(paren
id|atari_dma_buffer
op_logical_and
op_logical_neg
id|STRAM_ADDR
c_func
(paren
id|virt_to_phys
c_func
(paren
id|cmd-&gt;SCp.ptr
)paren
)paren
)paren
ques
c_cond
id|STRAM_BUFFER_SIZE
suffix:colon
l_int|255
op_star
l_int|512
suffix:semicolon
r_if
c_cond
(paren
id|possible_len
OG
id|limit
)paren
id|possible_len
op_assign
id|limit
suffix:semicolon
r_if
c_cond
(paren
id|possible_len
op_ne
id|wanted_len
)paren
id|DMA_PRINTK
c_func
(paren
l_string|&quot;Sorry, must cut DMA transfer size to %ld bytes &quot;
l_string|&quot;instead of %ld&bslash;n&quot;
comma
id|possible_len
comma
id|wanted_len
)paren
suffix:semicolon
r_return
id|possible_len
suffix:semicolon
)brace
macro_line|#endif&t;/* REAL_DMA */
multiline_comment|/* NCR5380 register access functions&n; *&n; * There are separate functions for TT and Falcon, because the access&n; * methods are quite different. The calling macros NCR5380_read and&n; * NCR5380_write call these functions via function pointers.&n; */
DECL|function|atari_scsi_tt_reg_read
r_static
r_int
r_char
id|atari_scsi_tt_reg_read
c_func
(paren
r_int
r_char
id|reg
)paren
(brace
r_return
id|tt_scsi_regp
(braket
id|reg
op_star
l_int|2
)braket
suffix:semicolon
)brace
DECL|function|atari_scsi_tt_reg_write
r_static
r_void
id|atari_scsi_tt_reg_write
c_func
(paren
r_int
r_char
id|reg
comma
r_int
r_char
id|value
)paren
(brace
id|tt_scsi_regp
(braket
id|reg
op_star
l_int|2
)braket
op_assign
id|value
suffix:semicolon
)brace
DECL|function|atari_scsi_falcon_reg_read
r_static
r_int
r_char
id|atari_scsi_falcon_reg_read
c_func
(paren
r_int
r_char
id|reg
)paren
(brace
id|dma_wd.dma_mode_status
op_assign
(paren
id|u_short
)paren
(paren
l_int|0x88
op_plus
id|reg
)paren
suffix:semicolon
r_return
(paren
id|u_char
)paren
id|dma_wd.fdc_acces_seccount
suffix:semicolon
)brace
DECL|function|atari_scsi_falcon_reg_write
r_static
r_void
id|atari_scsi_falcon_reg_write
c_func
(paren
r_int
r_char
id|reg
comma
r_int
r_char
id|value
)paren
(brace
id|dma_wd.dma_mode_status
op_assign
(paren
id|u_short
)paren
(paren
l_int|0x88
op_plus
id|reg
)paren
suffix:semicolon
id|dma_wd.fdc_acces_seccount
op_assign
(paren
id|u_short
)paren
id|value
suffix:semicolon
)brace
macro_line|#include &quot;atari_NCR5380.c&quot;
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|ATARI_SCSI
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
eof
